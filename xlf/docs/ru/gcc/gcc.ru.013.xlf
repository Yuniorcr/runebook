<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="ea3c4fdc7ae483f6eeee71767d6d7c25afd3b747" translate="yes" xml:space="preserve">
          <source>ULLK</source>
          <target state="translated">ULLK</target>
        </trans-unit>
        <trans-unit id="bd9c57578a5fa70fa2923dfa1948bb1047652950" translate="yes" xml:space="preserve">
          <source>ULLR</source>
          <target state="translated">ULLR</target>
        </trans-unit>
        <trans-unit id="181f09b6cf6ff48fe2bced4f8717c409974c7ccb" translate="yes" xml:space="preserve">
          <source>ULR</source>
          <target state="translated">ULR</target>
        </trans-unit>
        <trans-unit id="fdf943dd853f60e8f066b9ff1db365525dfa7714" translate="yes" xml:space="preserve">
          <source>UR</source>
          <target state="translated">UR</target>
        </trans-unit>
        <trans-unit id="b92dcc34c6f88a2b085f0fcf11324b5c2cf08f22" translate="yes" xml:space="preserve">
          <source>Unary absolute value.</source>
          <target state="translated">Унарное абсолютное значение.</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">Унарное отрицание.</target>
        </trans-unit>
        <trans-unit id="5b74b98336e7267fb4f37f0b361c833e21dc0aa0" translate="yes" xml:space="preserve">
          <source>Unary square root operation.</source>
          <target state="translated">Унарный квадратный корень.</target>
        </trans-unit>
        <trans-unit id="00399f106390204b9e8a47f8e8e78be426150d13" translate="yes" xml:space="preserve">
          <source>Unbounded uses, on the other hand, are uses of &lt;code&gt;alloca&lt;/code&gt; with no controlling predicate constraining its integer argument. For example:</source>
          <target state="translated">С другой стороны, неограниченное использование - это использование &lt;code&gt;alloca&lt;/code&gt; без управляющего предиката, ограничивающего его целочисленный аргумент. Например:</target>
        </trans-unit>
        <trans-unit id="d6ba59d2b5ffc5c4e08397a280a30fb560e8436a" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; when</source>
          <target state="translated">Неопределение &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; , когда</target>
        </trans-unit>
        <trans-unit id="f070a98f1b801c2b6e78c0be33c88683a70671cf" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code&gt;__STDC__&lt;/code&gt; in C++.</source>
          <target state="translated">Неопределение &lt;code&gt;__STDC__&lt;/code&gt; в C ++.</target>
        </trans-unit>
        <trans-unit id="ca3f9bb4feba0ac0f3a9b154b20506b4c489b2f4" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your &lt;code&gt;asm&lt;/code&gt; code defines symbols or labels. Using &amp;lsquo;</source>
          <target state="translated">При определенных обстоятельствах GCC может дублировать (или удалять дубликаты) ваш ассемблерный код при оптимизации. Это может привести к неожиданным ошибкам дублирования символов во время компиляции, если ваш код &lt;code&gt;asm&lt;/code&gt; определяет символы или метки. С помощью '</target>
        </trans-unit>
        <trans-unit id="199aae5416e814ba38647e12711c671c6b6db5a1" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your assembly code defines symbols or labels.</source>
          <target state="translated">При определенных обстоятельствах GCC может дублировать (или удалять дубликаты)вашего ассемблерного кода при оптимизации.Это может привести к неожиданным ошибкам при дублировании символов во время компиляции,если ваш ассемблерный код определяет символы или метки.</target>
        </trans-unit>
        <trans-unit id="72b29a25fd6f124cae730e139b0e10b10a80e560" translate="yes" xml:space="preserve">
          <source>Unfortunately, historically GCC used to have a number of bugs in its encoding code. The NeXT runtime expects GCC to emit type encodings in this historical format (compatible with GCC-3.3), so when using the NeXT runtime, GCC will introduce on purpose a number of incorrect encodings:</source>
          <target state="translated">К сожалению,исторически GCC имел ряд ошибок в своем кодировочном коде.Во время выполнения NeXT GCC ожидает,что в этом историческом формате (совместимом с GCC-3.3)будут излучаться кодировки типа,поэтому при использовании времени выполнения NeXT GCC будет специально вводить ряд неправильных кодировок:</target>
        </trans-unit>
        <trans-unit id="aeee418a8137652ee6d9ab3008a38b4d74bc2a2f" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are some characters allowed in identifiers by ISO C and ISO C++ that, when turned into NFC, are not allowed in identifiers. That is, there&amp;rsquo;s no way to use these symbols in portable ISO C or C++ and have all your identifiers in NFC.</source>
          <target state="translated">К сожалению, в идентификаторах ISO C и ISO C ++ разрешены некоторые символы, которые при преобразовании в NFC не допускаются в идентификаторах. То есть нет возможности использовать эти символы в переносимых ISO C или C ++ и иметь все ваши идентификаторы в NFC.</target>
        </trans-unit>
        <trans-unit id="5ddc1e63d4f989177759a83df41bd4b7dad20371" translate="yes" xml:space="preserve">
          <source>Unix C compilers have traditionally allocated storage for uninitialized global variables in a common block. This allows the linker to resolve all tentative definitions of the same variable in different compilation units to the same object, or to a non-tentative definition. This is the behavior specified by</source>
          <target state="translated">Компиляторы Unix C традиционно выделяют хранилище для неинициализированных глобальных переменных в общем блоке.Это позволяет компоновщику разрешать все условные определения одной и той же переменной в разных единицах компиляции в один и тот же объект или в не условное определение.Это поведение определяется</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="d6a3e0eb54ec1efd8ae1e1735e817354b9b6421f" translate="yes" xml:space="preserve">
          <source>Unless &lt;var&gt;*ptr&lt;/var&gt; and &lt;var&gt;vobj&lt;/var&gt; can be aliased, it is not guaranteed that the write to &lt;var&gt;*ptr&lt;/var&gt; occurs by the time the update of &lt;var&gt;vobj&lt;/var&gt; happens. If you need this guarantee, you must use a stronger memory barrier such as:</source>
          <target state="translated">Если только &lt;var&gt;*ptr&lt;/var&gt; и &lt;var&gt;vobj&lt;/var&gt; не могут иметь псевдонимы, не гарантируется, что запись в &lt;var&gt;*ptr&lt;/var&gt; произойдет к моменту обновления &lt;var&gt;vobj&lt;/var&gt; . Если вам нужна эта гарантия, вы должны использовать более сильный барьер памяти, например:</target>
        </trans-unit>
        <trans-unit id="c9e3382936f0af0d7125a8bf9b98d564d02b82c4" translate="yes" xml:space="preserve">
          <source>Unless specified explicitly (with</source>
          <target state="translated">Если не указано прямо (с</target>
        </trans-unit>
        <trans-unit id="5eaa8563a22dc64db7ac666eb5d3e5ba11cc1996" translate="yes" xml:space="preserve">
          <source>Unlike Java, Objective-C does not allow for entire methods to be marked &lt;code&gt;@synchronized&lt;/code&gt;. Note that throwing exceptions out of &lt;code&gt;@synchronized&lt;/code&gt; blocks is allowed, and will cause the guarding object to be unlocked properly.</source>
          <target state="translated">В отличие от Java, Objective-C не позволяет помечать целые методы как &lt;code&gt;@synchronized&lt;/code&gt; . Обратите внимание, что выброс исключений из блоков &lt;code&gt;@synchronized&lt;/code&gt; разрешен и приведет к правильной разблокировке объекта защиты.</target>
        </trans-unit>
        <trans-unit id="0cd317bbd72a217068977127c104995a9862be9b" translate="yes" xml:space="preserve">
          <source>Unlike for floating-point numbers in the decimal notation the exponent is always required in the hexadecimal notation. Otherwise the compiler would not be able to resolve the ambiguity of, e.g., &lt;code&gt;0x1.f&lt;/code&gt;. This could mean &lt;code&gt;1.0f&lt;/code&gt; or &lt;code&gt;1.9375&lt;/code&gt; since &amp;lsquo;</source>
          <target state="translated">В отличие от чисел с плавающей запятой в десятичной системе счисления показатель степени всегда требуется в шестнадцатеричной системе счисления. В противном случае компилятор не сможет разрешить неоднозначность, например, &lt;code&gt;0x1.f&lt;/code&gt; . Это может означать &lt;code&gt;1.0f&lt;/code&gt; или &lt;code&gt;1.9375&lt;/code&gt; , поскольку '</target>
        </trans-unit>
        <trans-unit id="c540371c5127336fc94b6b29fa3c46f81c44897b" translate="yes" xml:space="preserve">
          <source>Unlike in C, in C++, flowing off the end of a non-&lt;code&gt;void&lt;/code&gt; function other than &lt;code&gt;main&lt;/code&gt; results in undefined behavior even when the value of the function is not used.</source>
          <target state="translated">В отличие от C, в C ++ переход за конец &lt;code&gt;void&lt;/code&gt; функции, отличной от &lt;code&gt;main&lt;/code&gt; , приводит к неопределенному поведению, даже если значение функции не используется.</target>
        </trans-unit>
        <trans-unit id="2a830c95434f7db0cbf0fd8fd9277c1d051a3f31" translate="yes" xml:space="preserve">
          <source>Unnamed struct/union fields within structs/unions.</source>
          <target state="translated">Неназванные структурные/союзные поля внутри структур/союзов.</target>
        </trans-unit>
        <trans-unit id="205edf29824c8a0cb244fc56417458952c504c66" translate="yes" xml:space="preserve">
          <source>Unrecognized input files, not requiring compilation or assembly, are ignored.</source>
          <target state="translated">Нераспознанные входные файлы,не требующие компиляции или сборки,игнорируются.</target>
        </trans-unit>
        <trans-unit id="a51fd22f926dc0631cc272a22033e9d7fec59c36" translate="yes" xml:space="preserve">
          <source>Unroll all loops, even if their number of iterations is uncertain when the loop is entered. This usually makes programs run more slowly.</source>
          <target state="translated">Разворачивать все циклы,даже если количество их итераций при входе в цикл неизвестно.Обычно это заставляет программы работать медленнее.</target>
        </trans-unit>
        <trans-unit id="fc450b83181b0c2161a73acfdbf2dc658513bec3" translate="yes" xml:space="preserve">
          <source>Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop.</source>
          <target state="translated">Развертывание циклов,количество итераций которых можно определить во время компиляции или при входе в цикл.</target>
        </trans-unit>
        <trans-unit id="ad4d059f80e723b4d81766ec66adc71e8b2e5c48" translate="yes" xml:space="preserve">
          <source>Unsigned 12-bit constant (0&amp;ndash;4095)</source>
          <target state="translated">12-битная константа без знака (0&amp;ndash;4095)</target>
        </trans-unit>
        <trans-unit id="aec081f8e4cecc49f843970cd77df1a02a1c1643" translate="yes" xml:space="preserve">
          <source>Unsigned 16 bit integer (in the range 0 to 65535)</source>
          <target state="translated">Беззнаковое 16-битное целое число (в диапазоне от 0 до 65535)</target>
        </trans-unit>
        <trans-unit id="01dcb67eb6663625a6596ec55251e6ebe419078e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant</source>
          <target state="translated">Беззнаковая 16-битная константа</target>
        </trans-unit>
        <trans-unit id="005d69054eb4a9d53e3d7fc838909272fcdf1d1e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant shifted left 16 bits (use &amp;lsquo;</source>
          <target state="translated">16-битная константа без знака, сдвинутая влево на 16 бит (используйте '</target>
        </trans-unit>
        <trans-unit id="803ea2cff434611bd7a889a5f8f4e2a80e2f6534" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit integer constant.</source>
          <target state="translated">Беззнаковая 16-битная целочисленная константа.</target>
        </trans-unit>
        <trans-unit id="baffe105924a920d4f7c404a4974ebe483612051" translate="yes" xml:space="preserve">
          <source>Unsigned 3 bit integer (in the range 0 to 7)</source>
          <target state="translated">Беззнаковое 3-х битное целое число (в диапазоне от 0 до 7)</target>
        </trans-unit>
        <trans-unit id="5d0b43b79f775a23c99274c057849b2132918314" translate="yes" xml:space="preserve">
          <source>Unsigned 5 bit integer (in the range 0 to 31)</source>
          <target state="translated">Беззнаковое 5-битное целое число (в диапазоне от 0 до 31)</target>
        </trans-unit>
        <trans-unit id="ee9e535a39880e194545226484f376dc9293656d" translate="yes" xml:space="preserve">
          <source>Unsigned 7 bit integer (in the range 0 to 127)</source>
          <target state="translated">Беззнаковое 7-битное целое число (в диапазоне от 0 до 127)</target>
        </trans-unit>
        <trans-unit id="64587bc80a139da54c64da1869304a4854d6ae7d" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit constant (0&amp;ndash;255)</source>
          <target state="translated">8-битная константа без знака (0&amp;ndash;255)</target>
        </trans-unit>
        <trans-unit id="389b98b2eb7e556938b37c1b397214bf77e480bb" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer constant (for &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; instructions).</source>
          <target state="translated">Знака 8-битовое целое число константа (для &lt;code&gt;in&lt;/code&gt; и &lt;code&gt;out&lt;/code&gt; инструкции).</target>
        </trans-unit>
        <trans-unit id="8f0359d8e4b83d3d17663b1351a70fc1f8166d35" translate="yes" xml:space="preserve">
          <source>Unsigned constant that fits in 4 bits</source>
          <target state="translated">Беззнаковая константа,которая помещается в 4 бита.</target>
        </trans-unit>
        <trans-unit id="2b90c224883efa79af0519ac0faa9b9d93afd6a8" translate="yes" xml:space="preserve">
          <source>Unsigned constant valid for BccUI instructions</source>
          <target state="translated">Беззнаковая константа,действительная для инструкций BccUI</target>
        </trans-unit>
        <trans-unit id="6f39b25ebfb39b4238321ae23982857dd100a843" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 15-bit value.</source>
          <target state="translated">Непосредственное 15-битное значение без подписи.</target>
        </trans-unit>
        <trans-unit id="643476a0dd6f53437ba7e1cc7fb664b7f588a51c" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 3-bit value.</source>
          <target state="translated">Непосредственное 3-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="45a42311f5f53acd8a7d22cb085352156026813a" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 4-bit value.</source>
          <target state="translated">Непосредственное 4-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="39b8bb86545b9e829db3c4d0a8f246e834af0861" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value for movpi45 instruction with range 16&amp;ndash;47.</source>
          <target state="translated">Непосредственное 5-битное значение без знака для инструкции movpi45 в диапазоне 16&amp;ndash;47.</target>
        </trans-unit>
        <trans-unit id="899fe6e57441b37398096e6133a6ef0bf027d95b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value.</source>
          <target state="translated">Непосредственное 5-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="deb14acda231f891d200f45725f5e7e68bae6ef4" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 6-bit value constraint for addri36.sp instruction.</source>
          <target state="translated">Непосредственное неподписанное 6-битное ограничение по значению для инструкции addri36.sp.</target>
        </trans-unit>
        <trans-unit id="4d84bf34896cf4e54d3ca29c18d4eaac197e6b98" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 8-bit value.</source>
          <target state="translated">Непосредственное 8-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="0063ff83a123db3db2d8d12d6f824ef8fd590f5b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 9-bit value.</source>
          <target state="translated">Непосредственное 9-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="39e06dafd3f0aedfc6583e0a42cd32ba3116cfa2" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;Executing code before main&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Вверх: &lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;Выполнение кода перед основным&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;Содержание&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Индекс&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="a632eb28fbdc638221eda735f91ebefbd97cd0d5" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;MIPS SIMD Architecture (MSA) Support&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Вверх: &lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;Поддержка архитектуры MIPS SIMD (MSA)&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;Содержание&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Индекс&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="62c310f2ecc602f87c21d2fd813dc1c5d88ab539" translate="yes" xml:space="preserve">
          <source>Upon entering the &lt;code&gt;@synchronized&lt;/code&gt; block, a thread of execution shall first check whether a lock has been placed on the corresponding &lt;code&gt;guard&lt;/code&gt; object by another thread. If it has, the current thread shall wait until the other thread relinquishes its lock. Once &lt;code&gt;guard&lt;/code&gt; becomes available, the current thread will place its own lock on it, execute the code contained in the &lt;code&gt;@synchronized&lt;/code&gt; block, and finally relinquish the lock (thereby making &lt;code&gt;guard&lt;/code&gt; available to other threads).</source>
          <target state="translated">При входе в блок &lt;code&gt;@synchronized&lt;/code&gt; поток выполнения должен сначала проверить, была ли установлена ​​блокировка на соответствующий объект &lt;code&gt;guard&lt;/code&gt; другим потоком. Если да, текущий поток должен ждать, пока другой поток не освободит свою блокировку. Когда &lt;code&gt;guard&lt;/code&gt; становится доступной, текущий поток устанавливает на нее свою собственную блокировку, выполняет код, содержащийся в блоке &lt;code&gt;@synchronized&lt;/code&gt; , и, наконец, снимает блокировку (тем самым делая &lt;code&gt;guard&lt;/code&gt; доступной для других потоков).</target>
        </trans-unit>
        <trans-unit id="b8aaa5b821490b029c1a6fe5ed310256ca59552f" translate="yes" xml:space="preserve">
          <source>Upper floating point register (32-bit), floating point register (64-bit)</source>
          <target state="translated">Верхний регистр с плавающей точкой (32 бита),регистр с плавающей точкой (64 бита)</target>
        </trans-unit>
        <trans-unit id="06ee1205db8b9a4061f4febc2c51ef1b19f3d539" translate="yes" xml:space="preserve">
          <source>Usage of ISO string concatenation is detected.</source>
          <target state="translated">Обнаружено использование конкатенирования ISO-строк.</target>
        </trans-unit>
        <trans-unit id="89c2b631459be5cbc1277d90f51cb2dcbd76dfd6" translate="yes" xml:space="preserve">
          <source>Use (do not use) &amp;lsquo;</source>
          <target state="translated">Использовать (не использовать) '</target>
        </trans-unit>
        <trans-unit id="6c996ac92914ff016f27df663925672950a9f247" translate="yes" xml:space="preserve">
          <source>Use (do not use) GP-relative accesses for symbols that are known to be in a small data section; see</source>
          <target state="translated">Используйте (не используйте)GP-относительные доступы для символов,которые,как известно,находятся в небольшом разделе данных;смотрите</target>
        </trans-unit>
        <trans-unit id="841162f62263bc7378cda3013dbe47b1df4ab93e" translate="yes" xml:space="preserve">
          <source>Use (do not use) MIPS Digital Media Extension instructions. This option can only be used when generating 64-bit code and requires hardware floating-point support to be enabled.</source>
          <target state="translated">Использовать (не использовать)инструкции по расширению MIPS цифровых носителей.Данная опция может быть использована только при генерации 64-битного кода и требует аппаратной поддержки с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="b20024dc2d601c71b4e717f07d0f9b2a6822d063" translate="yes" xml:space="preserve">
          <source>Use (do not use) MT Multithreading instructions.</source>
          <target state="translated">Использовать (не использовать)инструкции по многопоточности MT.</target>
        </trans-unit>
        <trans-unit id="4c4c87eb21af6765217c1c52b2b2d0c31fe5b0c7" translate="yes" xml:space="preserve">
          <source>Use (do not use) assembler relocation operators when dealing with symbolic addresses. The alternative, selected by</source>
          <target state="translated">Используйте (не используйте)операторы перемещения ассемблера при работе с символьными адресами.Альтернатива,выбранная</target>
        </trans-unit>
        <trans-unit id="e2fb9fc1fd117af3b437fc4e8c7a5214e20addd7" translate="yes" xml:space="preserve">
          <source>Use (do not use) paired-single floating-point instructions. See &lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;MIPS Paired-Single Support&lt;/a&gt;. This option requires hardware floating-point support to be enabled.</source>
          <target state="translated">Используйте (не используйте) пары одинарных инструкций с плавающей запятой. См. Раздел &amp;laquo; &lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;Поддержка одиночной пары MIPS&amp;raquo;&lt;/a&gt; . Эта опция требует, чтобы была включена аппаратная поддержка с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="f6259aa651c4c62a1528ed119090031f79dd3a9c" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 1 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macro &lt;code&gt;__mips_dsp&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 1.</source>
          <target state="translated">Используйте (не используйте) версию 1 MIPS DSP ASE. См. &amp;laquo; &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;Встроенные функции MIPS DSP&amp;raquo;&lt;/a&gt; . Эта опция определяет макрос препроцессора &lt;code&gt;__mips_dsp&lt;/code&gt; . Он также определяет &lt;code&gt;__mips_dsp_rev&lt;/code&gt; равным 1.</target>
        </trans-unit>
        <trans-unit id="84f11c6cd6e5cf30011af44cf15833421d85ad29" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 2 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macros &lt;code&gt;__mips_dsp&lt;/code&gt; and &lt;code&gt;__mips_dspr2&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 2.</source>
          <target state="translated">Используйте (не используйте) версию 2 MIPS DSP ASE. См. &amp;laquo; &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;Встроенные функции MIPS DSP&amp;raquo;&lt;/a&gt; . Этот параметр определяет макросы препроцессора &lt;code&gt;__mips_dsp&lt;/code&gt; и &lt;code&gt;__mips_dspr2&lt;/code&gt; . Он также определяет &lt;code&gt;__mips_dsp_rev&lt;/code&gt; равным 2.</target>
        </trans-unit>
        <trans-unit id="f05f23d689cc06c1b3087b4a4cee4ab4e3b531c1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="translated">Используйте (не используйте)инструкции по MIPS-цикловой проверке избыточности (CRC).</target>
        </trans-unit>
        <trans-unit id="41957dbedef9adbd80884a4e90cb75e57229baa1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Enhanced Virtual Addressing instructions.</source>
          <target state="translated">Используйте (не используйте)инструкции по виртуальной адресации MIPS Enhanced Virtual Addressing.</target>
        </trans-unit>
        <trans-unit id="d449a2af21b4cd68389988954d474d0704ce78ae" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Global INValidate (GINV) instructions.</source>
          <target state="translated">Использовать (не использовать)инструкцию MIPS Global INValidate (GINV).</target>
        </trans-unit>
        <trans-unit id="321d2808ff8ddfa8d27e08fae5ef2b18bb82a26d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions (EXT) instructions.</source>
          <target state="translated">Используйте (не используйте)инструкцию MIPS Loongson EXTensions (EXT).</target>
        </trans-unit>
        <trans-unit id="7e1498ad7af62c3d7182f6f503ffa752981eda71" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions r2 (EXT2) instructions.</source>
          <target state="translated">Используйте (не используйте)инструкцию MIPS Loongson EXTensions r2 (EXT2).</target>
        </trans-unit>
        <trans-unit id="2dd360e823e7db9203619f4657c5c205b972d79d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson MultiMedia extensions Instructions (MMI).</source>
          <target state="translated">Используйте (не используйте)Инструкцию по расширению MIPS Loongson MultiMedia (MMI).</target>
        </trans-unit>
        <trans-unit id="5f61baef9b142c63c1358980a670d3440a0eab96" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS MCU ASE instructions.</source>
          <target state="translated">Использовать (не использовать)инструкцию MIPS MCU ASE.</target>
        </trans-unit>
        <trans-unit id="8ec8692f1855f7387d01c2d894055d7cd55aa28a" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS SmartMIPS ASE.</source>
          <target state="translated">Используйте (не используйте)MIPS SmartMIPS ASE.</target>
        </trans-unit>
        <trans-unit id="5ea0be9e9db2179c015e95d8d46f2c8b505a9fe4" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Virtualization (VZ) instructions.</source>
          <target state="translated">Использовать (не использовать)инструкции по MIPS-виртуализации (VZ).</target>
        </trans-unit>
        <trans-unit id="a2cdb6f5e1b2e85269c8ddd06af937bfeb499e18" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS eXtended Physical Address (XPA) instructions.</source>
          <target state="translated">Используйте (не используйте)инструкции MIPS eXtended Physical Address (XPA).</target>
        </trans-unit>
        <trans-unit id="36354659118438f767b17fe9c67973e669f59454" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS-3D ASE. See &lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;MIPS-3D Built-in Functions&lt;/a&gt;. The option</source>
          <target state="translated">Используйте (не используйте) MIPS-3D ASE. См. Раздел &amp;laquo; &lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;Встроенные функции MIPS-3D&amp;raquo;&lt;/a&gt; . Опция</target>
        </trans-unit>
        <trans-unit id="9ef75b208cd56b64585639240694bc21bc152e3d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware decimal-floating-point instructions for decimal-floating-point operations. When</source>
          <target state="translated">Для операций с десятичными запятыми используйте (не используйте)аппаратные инструкции по операциям с десятичными запятыми.При</target>
        </trans-unit>
        <trans-unit id="bf41f711c39d909ef84416fdb9864104894d7725" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions and registers for floating-point operations. When</source>
          <target state="translated">Для операций с плавающей запятой используйте (не используйте)аппаратные инструкции и регистры.При</target>
        </trans-unit>
        <trans-unit id="de7cd0fb38e7a6dbf8bf51e3e0d617effe989eb9" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions for floating-point operations. When</source>
          <target state="translated">Для операций с плавающей запятой используйте (не используйте)инструкции по эксплуатации аппаратных средств с плавающей запятой.При</target>
        </trans-unit>
        <trans-unit id="bd5d0dcb1bead4c9931bcc516462cf8c519e7f83" translate="yes" xml:space="preserve">
          <source>Use (do not use) the packed stack layout. When</source>
          <target state="translated">Используйте (не используйте)компоновку упакованного стека.Когда</target>
        </trans-unit>
        <trans-unit id="cbc7bc66fe33b21f66fff87d1b33e82b9091e241" translate="yes" xml:space="preserve">
          <source>Use (do not use) the probable-branch instructions, when static branch prediction indicates a probable branch.</source>
          <target state="translated">Используйте (не используйте)инструкции по вероятной ветке,когда статическое предсказание ветки указывает на вероятную ветку.</target>
        </trans-unit>
        <trans-unit id="f319b3952ec422e138086d2e7e1d3e6616dd87b3" translate="yes" xml:space="preserve">
          <source>Use 16-bit &lt;code&gt;int&lt;/code&gt;. This is the default.</source>
          <target state="translated">Используйте 16-битное &lt;code&gt;int&lt;/code&gt; . Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="89aa31a04c6ac47e58631515dc9a5eacae0d2be9" translate="yes" xml:space="preserve">
          <source>Use 32-bit &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Используйте 32-битное &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41a727b715072a7a83f64450d014d46413f9d7b5" translate="yes" xml:space="preserve">
          <source>Use 32-bit offsets in &lt;code&gt;switch&lt;/code&gt; tables. The default is to use 16-bit offsets.</source>
          <target state="translated">Используйте 32-битные смещения в таблицах &lt;code&gt;switch&lt;/code&gt; . По умолчанию используется 16-битное смещение.</target>
        </trans-unit>
        <trans-unit id="88f9f3c158d922b7a42c33cd301395b97a6091ab" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;brk_interrupt&lt;/code&gt; instead of &lt;code&gt;interrupt&lt;/code&gt; for handlers intended to be used with the &lt;code&gt;BRK&lt;/code&gt; opcode (i.e. those that must end with &lt;code&gt;RETB&lt;/code&gt; instead of &lt;code&gt;RETI&lt;/code&gt;).</source>
          <target state="translated">Используйте &lt;code&gt;brk_interrupt&lt;/code&gt; вместо &lt;code&gt;interrupt&lt;/code&gt; для обработчиков, предназначенных для использования с &lt;code&gt;BRK&lt;/code&gt; операции BRK (то есть тех, которые должны заканчиваться &lt;code&gt;RETB&lt;/code&gt; вместо &lt;code&gt;RETI&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a90fcb500090afb38bb3e24622641ed3199bfbe3" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;class-name&lt;/var&gt; as the name of the class to instantiate for each literal string specified with the syntax &lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt;. The default class name is &lt;code&gt;NXConstantString&lt;/code&gt; if the GNU runtime is being used, and &lt;code&gt;NSConstantString&lt;/code&gt; if the NeXT runtime is being used (see below). The</source>
          <target state="translated">Используйте &lt;var&gt;class-name&lt;/var&gt; в качестве имени класса, который нужно создать для каждой буквальной строки, указанной с помощью синтаксиса &lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt; . Имя класса по умолчанию - &lt;code&gt;NXConstantString&lt;/code&gt; , если используется среда выполнения GNU, и &lt;code&gt;NSConstantString&lt;/code&gt; , если используется среда выполнения NeXT (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="eb4639975214bd02baed9aee7811250d9713b6c2" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as a subdirectory of the directory containing target-specific C++ headers.</source>
          <target state="translated">Используйте &lt;var&gt;dir&lt;/var&gt; как подкаталог каталога, содержащего заголовки C ++ для конкретных целей.</target>
        </trans-unit>
        <trans-unit id="6e0e3e325ab15f9c4ea6c1c5a12adf0dc5651ccc" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as the logical root directory for headers and libraries. For example, if the compiler normally searches for headers in</source>
          <target state="translated">Используйте &lt;var&gt;dir&lt;/var&gt; как логический корневой каталог для заголовков и библиотек. Например, если компилятор обычно ищет заголовки в</target>
        </trans-unit>
        <trans-unit id="6f28e148765dfa527c350e4d6f8a2d064b3f5447" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;script&lt;/var&gt; as the linker script. This option is supported by most systems using the GNU linker. On some targets, such as bare-board targets without an operating system, the</source>
          <target state="translated">Используйте &lt;var&gt;script&lt;/var&gt; как сценарий компоновщика. Эта опция поддерживается большинством систем, использующих компоновщик GNU. На некоторых задачах, таких как цели без операционной системы,</target>
        </trans-unit>
        <trans-unit id="603c63161e45119aff170517df5f944adaf08316" translate="yes" xml:space="preserve">
          <source>Use Bionic C library. This is the default on &amp;lsquo;</source>
          <target state="translated">Используйте библиотеку Bionic C. Это значение по умолчанию включено '</target>
        </trans-unit>
        <trans-unit id="e1b7e66656ee6fc5c3b9eff78bd1af4ab51c4a01" translate="yes" xml:space="preserve">
          <source>Use DEC assembler syntax.</source>
          <target state="translated">Используйте синтаксис ассемблера DEC.</target>
        </trans-unit>
        <trans-unit id="cf5c1a8e637cc6c211fb5b791033642a96c7344a" translate="yes" xml:space="preserve">
          <source>Use GNU assembler syntax. This is the default.</source>
          <target state="translated">Используйте синтаксис ассемблера GNU.Это настройка по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4ca68a7754f649f50b2ce419251af4261f6f0855" translate="yes" xml:space="preserve">
          <source>Use GP-relative &lt;code&gt;.sdata&lt;/code&gt;/&lt;code&gt;.sbss&lt;/code&gt; sections.</source>
          <target state="translated">Используйте разделы &lt;code&gt;.sdata&lt;/code&gt; / &lt;code&gt;.sbss&lt;/code&gt; ,относящиеся к GP .</target>
        </trans-unit>
        <trans-unit id="5a4f813886fea8ad38a8f2df1482e30df599c3e3" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in loops for decisions to move loop invariants. This option usually results in generation of faster and smaller code on machines with large register files (&amp;gt;= 32 registers), but it can slow the compiler down.</source>
          <target state="translated">Используйте IRA для оценки давления в контурах для принятия решений о перемещении инвариантов контура. Этот параметр обычно приводит к созданию более быстрого и меньшего кода на машинах с большими файлами регистров (&amp;gt; = 32 регистров), но он может замедлить работу компилятора.</target>
        </trans-unit>
        <trans-unit id="9fa83817840cfc83225757a8f388ff5927c560a5" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in the code hoisting pass for decisions to hoist expressions. This option usually results in smaller code, but it can slow the compiler down.</source>
          <target state="translated">Используйте IRA для оценки давления регистра в коде подъемного прохода для принятия решений о подъеме выражений.Этот вариант обычно приводит к уменьшению кода,но может замедлить работу компилятора.</target>
        </trans-unit>
        <trans-unit id="cf05afd7829c886cb42acb12e1e8f5c401d38cca" translate="yes" xml:space="preserve">
          <source>Use PC-relative switch case tables to enable case table shortening. This is the default for</source>
          <target state="translated">Используйте PC-относительные коммутационные таблицы корпусов,чтобы обеспечить сокращение таблиц корпусов.По умолчанию для</target>
        </trans-unit>
        <trans-unit id="00b72e087f73e29c719a0c570f2c43c4886f6d49" translate="yes" xml:space="preserve">
          <source>Use PUSH operations to store outgoing parameters. This method is shorter and usually equally fast as method using SUB/MOV operations and is enabled by default. In some cases disabling it may improve performance because of improved scheduling and reduced dependencies.</source>
          <target state="translated">Используйте операции PUSH для сохранения исходящих параметров.Этот метод короче и обычно не менее быстр,чем метод,использующий операции SUB/MOV,и включен по умолчанию.В некоторых случаях его отключение может повысить производительность за счет улучшения планирования и уменьшения зависимостей.</target>
        </trans-unit>
        <trans-unit id="3d45d39c4ac78022d817a61ee97d331c721c6435" translate="yes" xml:space="preserve">
          <source>Use SSE register passing conventions for float and double arguments and return values. You can control this behavior for a specific function by using the function attribute &lt;code&gt;sseregparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">Используйте соглашения о передаче регистров SSE для аргументов типа float и double и возвращаемых значений. Вы можете управлять этим поведением конкретной функции с помощью атрибута функции &lt;code&gt;sseregparm&lt;/code&gt; . См. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b404c19baa5a518d1cdcd1a18e31cedc71ed3a2b" translate="yes" xml:space="preserve">
          <source>Use TLS descriptors as the thread-local storage mechanism for dynamic accesses of TLS variables. This is the default.</source>
          <target state="translated">Используйте дескрипторы TLS как потоколокальный механизм хранения для динамического доступа к переменным TLS.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="e3576757916332969b16cf2fe6a0dad2cf57cc25" translate="yes" xml:space="preserve">
          <source>Use Unix assembler syntax.</source>
          <target state="translated">Используйте синтаксис ассемблера Unix.</target>
        </trans-unit>
        <trans-unit id="203b2b8006e8188de9ec3c4dca584f80e20ca5d1" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">Используйте другое соглашение о вызове функций, в котором функции, которые принимают фиксированное количество аргументов, возвращаются с помощью инструкции &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; , которая выталкивает свои аргументы при возврате. Это сохраняет одну инструкцию в вызывающей программе, поскольку нет необходимости вставлять туда аргументы.</target>
        </trans-unit>
        <trans-unit id="da4193d8552139570f953ba462e87b5070659dde" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;rtd&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">Используйте другое соглашение о вызове функций, в котором функции, которые принимают фиксированное количество аргументов, возвращаются с &lt;code&gt;rtd&lt;/code&gt; инструкции rtd , которая выдвигает свои аргументы при возврате. Это сохраняет одну инструкцию в вызывающей программе, поскольку нет необходимости вставлять туда аргументы.</target>
        </trans-unit>
        <trans-unit id="331cc29755f1e26195a1d5ecc670eb6f5d017ee2" translate="yes" xml:space="preserve">
          <source>Use a simple check for control speculation. This option is on by default.</source>
          <target state="translated">Используйте простую проверку для контрольной спекуляции.Эта опция включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d6f85727b6057ae83760d6f97594f9ace81b0f7f" translate="yes" xml:space="preserve">
          <source>Use a simple data speculation check. This option is on by default.</source>
          <target state="translated">Используйте простую проверку спекуляции данными.Эта опция включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ca6587349df9a9ae271539d7763d513420cd65bb" translate="yes" xml:space="preserve">
          <source>Use a suffix in a fixed-point literal constant:</source>
          <target state="translated">Используйте суффикс в буквенной константе с фиксированной точкой:</target>
        </trans-unit>
        <trans-unit id="0eca7aa56a0b3e6cf63ecaa0b25877af246ac580" translate="yes" xml:space="preserve">
          <source>Use address register &lt;code&gt;X&lt;/code&gt; in a way proposed by the hardware. This means that &lt;code&gt;X&lt;/code&gt; is only used in indirect, post-increment or pre-decrement addressing.</source>
          <target state="translated">Используйте регистр адреса &lt;code&gt;X&lt;/code&gt; способом, предлагаемым оборудованием. Это означает, что &lt;code&gt;X&lt;/code&gt; используется только для косвенной адресации, адресации с постинкрементом или до декремента.</target>
        </trans-unit>
        <trans-unit id="3b89385a22047536803090fc547fb07c50377d4f" translate="yes" xml:space="preserve">
          <source>Use all 64 floating-point registers.</source>
          <target state="translated">Используйте все 64 регистра с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="feaeb911667dc1becc91e63f2c1dd1a8d7da1545" translate="yes" xml:space="preserve">
          <source>Use all 64 general-purpose registers.</source>
          <target state="translated">Используйте все 64 регистра общего назначения.</target>
        </trans-unit>
        <trans-unit id="b82e484b31c31a6751f032044a77e4b8d923804b" translate="yes" xml:space="preserve">
          <source>Use all eight media accumulator registers.</source>
          <target state="translated">Используйте все восемь регистров аккумуляторов носителей.</target>
        </trans-unit>
        <trans-unit id="2f6df81f72a01bee304049bedcc53aa9e70e7e34" translate="yes" xml:space="preserve">
          <source>Use all functions as a single region. This typically results in the smallest code size, and is enabled by default for</source>
          <target state="translated">Используйте все функции как единый регион.Как правило,это приводит к наименьшим размерам кода,и по умолчанию включена функция для</target>
        </trans-unit>
        <trans-unit id="ba424a2a390669d654a999945050b535cb620662" translate="yes" xml:space="preserve">
          <source>Use all loops as register allocation regions. This can give the best results for machines with a small and/or irregular register set.</source>
          <target state="translated">Используйте все петли как регионы распределения регистров.Это может дать наилучшие результаты для машин с небольшим и/или нерегулярным набором регистров.</target>
        </trans-unit>
        <trans-unit id="a043a5ff8ff9ce3ddafabde6a2ea3b417ae65cc6" translate="yes" xml:space="preserve">
          <source>Use all loops except for loops with small register pressure as the regions. This value usually gives the best results in most cases and for most architectures, and is enabled by default when compiling with optimization for speed (</source>
          <target state="translated">Используйте в качестве регионов все петли,за исключением петель с малым давлением регистра.Это значение обычно дает наилучшие результаты в большинстве случаев и для большинства архитектур,и включено по умолчанию при компиляции с оптимизацией на скорость (</target>
        </trans-unit>
        <trans-unit id="812a6d3805650c2a1098b0f9c55012ae713394e0" translate="yes" xml:space="preserve">
          <source>Use caller save registers for allocation if those registers are not used by any called function. In that case it is not necessary to save and restore them around calls. This is only possible if called functions are part of same compilation unit as current function and they are compiled before it.</source>
          <target state="translated">Используйте сохраненные регистры вызывающего абонента для распределения,если эти регистры не используются ни одной вызываемой функцией.В этом случае нет необходимости сохранять и восстанавливать их вокруг вызовов.Это возможно только в том случае,если вызываемые функции являются частью той же компиляционной единицы,что и текущая функция,и они компилируются перед ней.</target>
        </trans-unit>
        <trans-unit id="4382016563c1274a421ee87c295b12ebd4559c24" translate="yes" xml:space="preserve">
          <source>Use color in diagnostics. &lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">Используйте цвет в диагностике. &lt;var&gt;WHEN&lt;/var&gt; это &quot;</target>
        </trans-unit>
        <trans-unit id="40d7328de5846368928e724db703acd82494276b" translate="yes" xml:space="preserve">
          <source>Use colors for lines of code that have zero coverage. We use red color for non-exceptional lines and cyan for exceptional. Same colors are used for basic blocks with</source>
          <target state="translated">Используйте цвета для строк кода,которые имеют нулевое покрытие.Для неисключительных линий мы используем красный цвет,а для исключительных-голубой.Те же цвета используются для основных блоков с</target>
        </trans-unit>
        <trans-unit id="b78480b3c04e31f02a22c6b9fc0432c39f656a99" translate="yes" xml:space="preserve">
          <source>Use conditional execution (where available) to transform conditional jumps into branch-less equivalents.</source>
          <target state="translated">Использовать условное исполнение (при наличии)для преобразования условных переходов в эквиваленты без ветвей.</target>
        </trans-unit>
        <trans-unit id="cfd175a21aedd34017c2ac1e6f5bcb8597ba832d" translate="yes" xml:space="preserve">
          <source>Use features of, and schedule code for, the given CPU. Supported values are in the format &amp;lsquo;</source>
          <target state="translated">Используйте функции и код расписания для данного ЦП. Поддерживаемые значения имеют формат '</target>
        </trans-unit>
        <trans-unit id="3784fc1428664a00120c0092c2a68e1d52938803" translate="yes" xml:space="preserve">
          <source>Use floating-point coprocessor instructions.</source>
          <target state="translated">Используйте инструкции сопроцессора с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="b74dc5c253b5d41873111acddddd0a6e12b4df73" translate="yes" xml:space="preserve">
          <source>Use floating-point double instructions.</source>
          <target state="translated">Используйте двойную инструкцию с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="92af032aeee5f8e42b7b1aaa0f92eee3c63e96e3" translate="yes" xml:space="preserve">
          <source>Use full-set registers for register allocation.</source>
          <target state="translated">Используйте полные регистры для распределения регистров.</target>
        </trans-unit>
        <trans-unit id="16451ea3ea1710752acecdfbc9b28aca9f971795" translate="yes" xml:space="preserve">
          <source>Use hardware FPP floating point. This is the default. (FIS floating point on the PDP-11/40 is not supported.) Implies -m45.</source>
          <target state="translated">Используйте аппаратные FPP с плавающей запятой.Это значение установлено по умолчанию.(FIS с плавающей запятой на PDP-11/40 не поддерживается.)Подразумевает -m45.</target>
        </trans-unit>
        <trans-unit id="1d53b0a05bad4ee0582a36e272217d96ad44c641" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point conversion instructions.</source>
          <target state="translated">Используйте инструкции по аппаратурному пересчету с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="7c8d9f72c2a09e8bf637992aee381f0538cc91ce" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point instructions.</source>
          <target state="translated">Используйте инструкции по аппаратным средствам с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="0a53c63d0196fe12e50c8354a0f08f23a9436376" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point square root instruction.</source>
          <target state="translated">Используйте аппаратную инструкцию квадратного корня с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="9299be4448e9c807bf8ea8d91a628cfcd14cfa8d" translate="yes" xml:space="preserve">
          <source>Use hardware instructions for floating-point operations.</source>
          <target state="translated">Для работы с плавающей запятой используйте инструкции по эксплуатации оборудования.</target>
        </trans-unit>
        <trans-unit id="d1208904e1c443035a1b8ffe0c523b26cf7b7a8b" translate="yes" xml:space="preserve">
          <source>Use indirect addressing to call functions outside the current compilation unit. This allows the functions to be placed anywhere within the 32-bit address space.</source>
          <target state="translated">Для вызова функций вне текущего компилятора используйте косвенную адресацию.Это позволяет разместить функции в любом месте 32-битного адресного пространства.</target>
        </trans-unit>
        <trans-unit id="78fc9788b47e65039b1b1b871970de2bb141152a" translate="yes" xml:space="preserve">
          <source>Use large-model addressing (20-bit pointers, 32-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">Используйте адресацию большой модели (20-битные указатели, 32-битный &lt;code&gt;size_t&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="da84f773a2b422eeb1cc59880ada32d1f5127685" translate="yes" xml:space="preserve">
          <source>Use library routines for floating-point operations.</source>
          <target state="translated">Используйте библиотечные подпрограммы для операций с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="089ac39a7bb68a3ed32ee7b6986eee393acae4e9" translate="yes" xml:space="preserve">
          <source>Use media instructions.</source>
          <target state="translated">Используйте инструкции для СМИ.</target>
        </trans-unit>
        <trans-unit id="0eb15f40fe2c97b8f815cbb7844e284b610d0dac" translate="yes" xml:space="preserve">
          <source>Use multiply and add/subtract instructions.</source>
          <target state="translated">Используйте инструкции по умножению и добавлению/вычитанию.</target>
        </trans-unit>
        <trans-unit id="3113eba3d237f18c9452620ae8a871803037c9fe" translate="yes" xml:space="preserve">
          <source>Use multiply high instructions for high part of 32x32 multiply.</source>
          <target state="translated">Используйте инструкции по умножению для умножения высокой части 32x32.</target>
        </trans-unit>
        <trans-unit id="274542aa04ed64b151c2d6a22c787feacea52bb1" translate="yes" xml:space="preserve">
          <source>Use of ISO C style function definitions. This warning intentionally is &lt;em&gt;not&lt;/em&gt; issued for prototype declarations or variadic functions because these ISO C features appear in your code when using libiberty&amp;rsquo;s traditional C compatibility macros, &lt;code&gt;PARAMS&lt;/code&gt; and &lt;code&gt;VPARAMS&lt;/code&gt;. This warning is also bypassed for nested functions because that feature is already a GCC extension and thus not relevant to traditional C compatibility.</source>
          <target state="translated">Использование определений функций в стиле ISO C. Это предупреждение намеренно &lt;em&gt;не&lt;/em&gt; выдается для объявлений прототипов или вариативных функций, потому что эти возможности ISO C появляются в вашем коде при использовании традиционных макросов совместимости C &lt;code&gt;VPARAMS&lt;/code&gt; , &lt;code&gt;PARAMS&lt;/code&gt; и VPARAMS . Это предупреждение также игнорируется для вложенных функций, поскольку эта функция уже является расширением GCC и, следовательно, не имеет отношения к традиционной совместимости с C.</target>
        </trans-unit>
        <trans-unit id="158fc2002245113de73abd265a7ea7ceaec3a883" translate="yes" xml:space="preserve">
          <source>Use of these options requires the</source>
          <target state="translated">Использование этих опций требует</target>
        </trans-unit>
        <trans-unit id="c4cc269c9473450b3919e9b442477125758842d4" translate="yes" xml:space="preserve">
          <source>Use only (or not only) &lt;code&gt;JSR&lt;/code&gt; instructions to access functions. This option can be used when code size exceeds the range of &lt;code&gt;BSR&lt;/code&gt; instructions. Note that</source>
          <target state="translated">Используйте только (или не только) инструкции &lt;code&gt;JSR&lt;/code&gt; для доступа к функциям. Эта опция может использоваться, когда размер кода превышает диапазон инструкций &lt;code&gt;BSR&lt;/code&gt; . Обратите внимание, что</target>
        </trans-unit>
        <trans-unit id="3d7a23d4b8552ff506438fdaad793f73e9ba8b5c" translate="yes" xml:space="preserve">
          <source>Use only the first 32 floating-point registers.</source>
          <target state="translated">Используйте только первые 32 регистра с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="514349ebdaf390b152f0baa20866afbb16f28603" translate="yes" xml:space="preserve">
          <source>Use only the first four media accumulator registers.</source>
          <target state="translated">Используйте только первые четыре регистра аккумулятора носителей.</target>
        </trans-unit>
        <trans-unit id="dbcdb22850ebf5d2eaa31bb7774cbe3b9ea3b9b1" translate="yes" xml:space="preserve">
          <source>Use options specific to GNU &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">Используйте параметры, специфичные для GNU &lt;code&gt;ld&lt;/code&gt; . Это проходит</target>
        </trans-unit>
        <trans-unit id="d0990e1967b634e363212e972c2e0f4cff8a380b" translate="yes" xml:space="preserve">
          <source>Use options specific to HP &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">Используйте параметры, специфичные для HP &lt;code&gt;ld&lt;/code&gt; . Это проходит</target>
        </trans-unit>
        <trans-unit id="b612fc229c98c8b45507f89276f4127d6c212de2" translate="yes" xml:space="preserve">
          <source>Use or do not use assembler relocation operators when dealing with symbolic addresses. The alternative is to use assembler macros instead, which may limit optimization.</source>
          <target state="translated">Используйте или не используйте операторы перемещения ассемблера при работе с символьными адресами.Альтернативой является использование вместо них ассемблерных макросов,что может ограничить оптимизацию.</target>
        </trans-unit>
        <trans-unit id="0d238a2890f95ffe47564d56929f04ca231d7f2f" translate="yes" xml:space="preserve">
          <source>Use ordinarily cached memory accesses for volatile references. This is the default.</source>
          <target state="translated">Использовать обычный доступ к кэшированной памяти для нестабильных ссылок.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="561289d64c63454cbaa3cc42d60da8f4f3023750" translate="yes" xml:space="preserve">
          <source>Use pattern compare instructions.</source>
          <target state="translated">Используйте инструкции по сопоставлению шаблонов.</target>
        </trans-unit>
        <trans-unit id="040518cc797faf0101d0aa9c313c620444e4ee87" translate="yes" xml:space="preserve">
          <source>Use pipes rather than temporary files for communication between the various stages of compilation. This fails to work on some systems where the assembler is unable to read from a pipe; but the GNU assembler has no trouble.</source>
          <target state="translated">Для связи между различными этапами компиляции используйте трубы,а не временные файлы.Это не работает на некоторых системах,где ассемблер не может читать из трубы;но у ассемблера GNU нет проблем.</target>
        </trans-unit>
        <trans-unit id="f48e58d8b4ccb76ce170698e169b17f602f7b800" translate="yes" xml:space="preserve">
          <source>Use reduced-set registers for register allocation.</source>
          <target state="translated">Используйте регистры с сокращенными настройками для распределения регистров.</target>
        </trans-unit>
        <trans-unit id="2593d8520ea117d76ab84232fac04161f6934239" translate="yes" xml:space="preserve">
          <source>Use reorder instructions (swap and byte reversed load/store).</source>
          <target state="translated">Используйте инструкции по перезаказу (замена и байтовая перезагрузка/хранение).</target>
        </trans-unit>
        <trans-unit id="e07ac16585fa1254cfa0cb9da67063979e26bb7c" translate="yes" xml:space="preserve">
          <source>Use scalar floating-point instructions present in the SSE instruction set. This instruction set is supported by Pentium III and newer chips, and in the AMD line by Athlon-4, Athlon XP and Athlon MP chips. The earlier version of the SSE instruction set supports only single-precision arithmetic, thus the double and extended-precision arithmetic are still done using 387. A later version, present only in Pentium 4 and AMD x86-64 chips, supports double-precision arithmetic too.</source>
          <target state="translated">Используйте скалярные инструкции с плавающей запятой,содержащиеся в наборе инструкций SSE.Данный набор инструкций поддерживается микросхемами Pentium III и более новыми микросхемами,а в линии AMD-микросхемами Athlon-4,Athlon XP и Athlon MP.Более ранняя версия набора инструкций SSE поддерживает только арифметику с одинарной точностью,таким образом,двойная и расширенная арифметика точности все еще выполняется с использованием 387.Более поздняя версия,представленная только в микросхемах Pentium 4 и AMD x86-64,также поддерживает арифметику двойной точности.</target>
        </trans-unit>
        <trans-unit id="d6e4ef6e570b37c45555a81f6cdc377b4bae049b" translate="yes" xml:space="preserve">
          <source>Use small-model addressing (16-bit pointers, 16-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">Используйте адресацию малой модели (16-битные указатели, 16-битный &lt;code&gt;size_t&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="427046297d0e2e2fa23aa9bbce2f51b1069e5680" translate="yes" xml:space="preserve">
          <source>Use software emulation for divides (default).</source>
          <target state="translated">Используйте программную эмуляцию разделителей (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="28d4c98240044920040873705d9156aeeb423961" translate="yes" xml:space="preserve">
          <source>Use software emulation for floating point (default).</source>
          <target state="translated">Используйте программную эмуляцию с плавающей точкой (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="1da6f7e54a7af9cc7e53be95e1caa19cec640f21" translate="yes" xml:space="preserve">
          <source>Use software multiply emulation (default).</source>
          <target state="translated">Использовать программную эмуляцию умножения (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="51ebd4110af8f919b9d1120fda4a348de24109ee" translate="yes" xml:space="preserve">
          <source>Use specified regions for the integrated register allocator. The &lt;var&gt;region&lt;/var&gt; argument should be one of the following:</source>
          <target state="translated">Используйте указанные регионы для интегрированного распределителя регистров. &lt;var&gt;region&lt;/var&gt; аргумент должен быть один из следующих:</target>
        </trans-unit>
        <trans-unit id="8bf48e2b51779d631071d9653fad6d3f53bf023b" translate="yes" xml:space="preserve">
          <source>Use table lookup optimization for small signed integer divisions.</source>
          <target state="translated">Используйте оптимизацию поиска таблиц для малых знаковых целочисленных делений.</target>
        </trans-unit>
        <trans-unit id="22aeb5074275903d6cc2bc285a95ec6de6392b7d" translate="yes" xml:space="preserve">
          <source>Use the &amp;lsquo;</source>
          <target state="translated">Использовать '</target>
        </trans-unit>
        <trans-unit id="4c08ac9947cb5cb5ba71955417b6bbe576595e7e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bfd&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">Используйте компоновщик &lt;code&gt;bfd&lt;/code&gt; вместо компоновщика по умолчанию.</target>
        </trans-unit>
        <trans-unit id="49f654b96f5c6203d75686fb510717eb4b09cb8c" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;dcpl&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache.</source>
          <target state="translated">Используйте команду &lt;code&gt;dcpl&lt;/code&gt; , чтобы загрузить содержимое адреса &lt;var&gt;x&lt;/var&gt; в кэш данных.</target>
        </trans-unit>
        <trans-unit id="bf6f4ab92454be3b8a7530a2bda919c27587ed37" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;gold&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">Используйте &lt;code&gt;gold&lt;/code&gt; компоновщик вместо компоновщика по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6ce5962b43b6bd52ef348d693006572a8183c27a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;nldub&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache. The instruction is issued in slot I1.</source>
          <target state="translated">Используйте инструкцию &lt;code&gt;nldub&lt;/code&gt; , чтобы загрузить содержимое адреса &lt;var&gt;x&lt;/var&gt; в кэш данных. Инструкция выдается в слоте I1.</target>
        </trans-unit>
        <trans-unit id="867d5a75d613034d3b5e7a22efb5a5d5d0038d5f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;section&lt;/code&gt; attribute with &lt;em&gt;global&lt;/em&gt; variables and not &lt;em&gt;local&lt;/em&gt; variables, as shown in the example.</source>
          <target state="translated">Используйте атрибут &lt;code&gt;section&lt;/code&gt; с &lt;em&gt;глобальными&lt;/em&gt; переменными, а не с &lt;em&gt;локальными&lt;/em&gt; переменными, как показано в примере.</target>
        </trans-unit>
        <trans-unit id="9a7c0df6001ba89f4adccf5164b3cb2c7ebaeebd" translate="yes" xml:space="preserve">
          <source>Use the GNU C library. This is the default except on &amp;lsquo;</source>
          <target state="translated">Используйте библиотеку GNU C. Это значение по умолчанию, за исключением '</target>
        </trans-unit>
        <trans-unit id="750d7f5d1705c279b333b6c74a4ba7e65ef492b9" translate="yes" xml:space="preserve">
          <source>Use the Graphite data dependence analysis to identify loops that can be parallelized. Parallelize all the loops that can be analyzed to not contain loop carried dependences without checking that it is profitable to parallelize the loops.</source>
          <target state="translated">Используйте анализ зависимости данных от графита для выявления циклов,которые можно распараллелить.Распараллелить все циклы,которые могут быть проанализированы,чтобы не содержать переносимых циклов зависимостей,не проверяя,выгодно ли распараллеливать циклы.</target>
        </trans-unit>
        <trans-unit id="7a211de8053eb75fc4551a2253a98b04c844e3fd" translate="yes" xml:space="preserve">
          <source>Use the LLVM &lt;code&gt;lld&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">Используйте компоновщик LLVM &lt;code&gt;lld&lt;/code&gt; вместо компоновщика по умолчанию.</target>
        </trans-unit>
        <trans-unit id="04b872414955ba2ec914569c9ca7e852388533f1" translate="yes" xml:space="preserve">
          <source>Use the divide instruction. (Enabled by default).</source>
          <target state="translated">Используйте инструкцию разделения.(Включено по умолчанию).</target>
        </trans-unit>
        <trans-unit id="558e68bc0e42df73038edd83e1eeba8d09d26633" translate="yes" xml:space="preserve">
          <source>Use the hardware barrel shifter.</source>
          <target state="translated">Используйте аппаратный переключатель ствола.</target>
        </trans-unit>
        <trans-unit id="3ddc7c28193ef0a55228689dee7a52062a4edc76" translate="yes" xml:space="preserve">
          <source>Use the musl C library. This is the default on &amp;lsquo;</source>
          <target state="translated">Используйте библиотеку musl C. Это значение по умолчанию включено '</target>
        </trans-unit>
        <trans-unit id="1f0e93cc02e9fe65de10db69a6186e0dc79df964" translate="yes" xml:space="preserve">
          <source>Use the new LRA register allocator. By default, the old &amp;ldquo;reload&amp;rdquo; allocator is used.</source>
          <target state="translated">Используйте новый распределитель регистров LRA. По умолчанию используется старый распределитель &amp;laquo;перезагрузки&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b8160c2417cc8a5cdcd5adcb2b4ace153689638e" translate="yes" xml:space="preserve">
          <source>Use the pc-relative addressing mode of the 68000 directly, instead of using a global offset table. At present, this option implies</source>
          <target state="translated">Используйте режим pc-реляционной адресации 68000 напрямую,вместо использования глобальной таблицы смещения.В настоящее время этот вариант подразумевает</target>
        </trans-unit>
        <trans-unit id="f07a2b31cfd22ad424266d7caad833e89dee9597" translate="yes" xml:space="preserve">
          <source>Use the portable calling conventions proposed by HP for ELF systems.</source>
          <target state="translated">Используйте портативные соглашения по вызову,предложенные HP для систем ELF.</target>
        </trans-unit>
        <trans-unit id="0b4db49c13b2cd9f44e64e88aadae4892b55bc28" translate="yes" xml:space="preserve">
          <source>Use the simulator runtime. The default is to use the libgloss board-specific runtime.</source>
          <target state="translated">Используйте время работы симулятора.По умолчанию используется специфическое для libgloss время выполнения.</target>
        </trans-unit>
        <trans-unit id="41338fd388f1668b19ad991f249f38977077076b" translate="yes" xml:space="preserve">
          <source>Use the small address space model. This can produce smaller code, but it does assume that all symbolic values and addresses fit into a 20-bit range.</source>
          <target state="translated">Используйте модель небольшого адресного пространства.Это может привести к меньшему коду,но предполагает,что все символьные значения и адреса помещаются в 20-битный диапазон.</target>
        </trans-unit>
        <trans-unit id="13568366d19d7f746b8b97efedd41fb9de7088bc" translate="yes" xml:space="preserve">
          <source>Use the specified algorithm for basic block reordering. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">Используйте указанный алгоритм для переупорядочения базового блока. &lt;var&gt;algorithm&lt;/var&gt; аргумент может быть &quot;</target>
        </trans-unit>
        <trans-unit id="ab53cd8c99a5cd67bf095646da8562b04af28820" translate="yes" xml:space="preserve">
          <source>Use the specified coloring algorithm for the integrated register allocator. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">Используйте указанный алгоритм окраски для встроенного распределителя регистров. &lt;var&gt;algorithm&lt;/var&gt; аргумент может быть &quot;</target>
        </trans-unit>
        <trans-unit id="c25bc5036e9135cfbfa139415172d379794c44f1" translate="yes" xml:space="preserve">
          <source>Use the standard 387 floating-point coprocessor present on the majority of chips and emulated otherwise. Code compiled with this option runs almost everywhere. The temporary results are computed in 80-bit precision instead of the precision specified by the type, resulting in slightly different results compared to most of other chips. See</source>
          <target state="translated">Используйте стандартный сопроцессор с плавающей запятой 387,присутствующий на большинстве микросхем,и эмулируйте его по-другому.Код,скомпилированный с этой опцией,запускается практически везде.Временные результаты вычисляются с точностью до 80 бит вместо точности,заданной типом,в результате чего результаты немного отличаются от результатов большинства других микросхем.См..</target>
        </trans-unit>
        <trans-unit id="5c3eebf40b38ef456cf7b33dffd08d0bed4ad5c6" translate="yes" xml:space="preserve">
          <source>Use the string argument if you want a single implementation file to include code from multiple header files. (You must also use &amp;lsquo;</source>
          <target state="translated">Используйте строковый аргумент, если вы хотите, чтобы один файл реализации включал код из нескольких файлов заголовков. (Вы также должны использовать '</target>
        </trans-unit>
        <trans-unit id="8b250eb8bd58bde677af68374494bb2406d4bfb9" translate="yes" xml:space="preserve">
          <source>Use the timing characteristics of the indicated CPU type when scheduling instructions. This does not change the targeted processor type. The CPU type must be one of &amp;lsquo;</source>
          <target state="translated">При планировании инструкций используйте временные характеристики указанного типа ЦП. Это не меняет целевой тип процессора. Тип процессора должен быть одним из '</target>
        </trans-unit>
        <trans-unit id="e509cf065cb591da77c6d1b119a1c9955ae2884c" translate="yes" xml:space="preserve">
          <source>Use these attributes on the Blackfin to place the variable into L1 Data SRAM. Variables with &lt;code&gt;l1_data&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data&lt;/code&gt;. Those with &lt;code&gt;l1_data_A&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.A&lt;/code&gt;. Those with &lt;code&gt;l1_data_B&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.B&lt;/code&gt;.</source>
          <target state="translated">Используйте эти атрибуты на Blackfin, чтобы поместить переменную в L1 Data SRAM. Переменные с атрибутом &lt;code&gt;l1_data&lt;/code&gt; помещаются в специальный раздел с именем &lt;code&gt;.l1.data&lt;/code&gt; . Те, у &lt;code&gt;l1_data_A&lt;/code&gt; атрибут l1_data_A , помещаются в специальный раздел с именем &lt;code&gt;.l1.data.A&lt;/code&gt; . Те, у &lt;code&gt;l1_data_B&lt;/code&gt; атрибут l1_data_B , помещаются в специальный раздел с именем &lt;code&gt;.l1.data.B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="160cca57d4e5e0f9858135c86f73f6c1abb97d0c" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either attribute is present.</source>
          <target state="translated">Используйте эти атрибуты,чтобы показать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии любого из атрибутов.</target>
        </trans-unit>
        <trans-unit id="bf93b175e1b39a6bc44235ab705a17a9dd4f6b45" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either of these attributes are present.</source>
          <target state="translated">Используйте эти атрибуты,чтобы показать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания,когда присутствует один из этих атрибутов.</target>
        </trans-unit>
        <trans-unit id="713ae23784c01f8e2dec060c72284704315954a7" translate="yes" xml:space="preserve">
          <source>Use these options on systems where the linker can perform optimizations to improve locality of reference in the instruction space. Most systems using the ELF object format have linkers with such optimizations. On AIX, the linker rearranges sections (CSECTs) based on the call graph. The performance impact varies.</source>
          <target state="translated">Используйте эти опции на системах,где компоновщик может выполнять оптимизацию для улучшения расположения ссылок в пространстве инструкций.В большинстве систем,использующих формат ELF-объектов,есть компоновщики с такими оптимизациями.В AIX компоновщик переставляет секции (CSECTs)на основе графика вызовов.Влияние производительности варьируется.</target>
        </trans-unit>
        <trans-unit id="78e3ee99ed9959a22e988df0584ccd7d00c7b9a6" translate="yes" xml:space="preserve">
          <source>Use this attribute on ARM to write Interrupt Service Routines. This is an alias to the &lt;code&gt;interrupt&lt;/code&gt; attribute above.</source>
          <target state="translated">Используйте этот атрибут в ARM для записи подпрограмм обслуживания прерываний. Это псевдоним атрибута &lt;code&gt;interrupt&lt;/code&gt; указанного выше.</target>
        </trans-unit>
        <trans-unit id="6c570cb3577b10adeb554e34c1e75804adbd4ff0" translate="yes" xml:space="preserve">
          <source>Use this attribute on SH targets to indicate that an &lt;code&gt;interrupt_handler&lt;/code&gt; function should not save and restore registers R0..R7. This can be used on SH3* and SH4* targets that have a second R0..R7 register bank for non-reentrant interrupt handlers.</source>
          <target state="translated">Используйте этот атрибут для целей SH, чтобы указать, что функция &lt;code&gt;interrupt_handler&lt;/code&gt; не должна сохранять и восстанавливать регистры R0..R7. Это можно использовать для целей SH3 * и SH4 *, которые имеют второй банк регистров R0..R7 для обработчиков прерываний без повторного входа.</target>
        </trans-unit>
        <trans-unit id="f5c77347991d0824e6e1b28414143e53ed7d053c" translate="yes" xml:space="preserve">
          <source>Use this attribute on fido, a subarchitecture of the m68k, to indicate that the specified function is an interrupt handler that is designed to run as a thread. The compiler omits generate prologue/epilogue sequences and replaces the return instruction with a &lt;code&gt;sleep&lt;/code&gt; instruction. This attribute is available only on fido.</source>
          <target state="translated">Используйте этот атрибут в fido, субархитектуре m68k, чтобы указать, что указанная функция является обработчиком прерывания, предназначенным для работы в виде потока. Компилятор пропускает создание последовательностей пролога / эпилога и заменяет инструкцию возврата инструкцией &lt;code&gt;sleep&lt;/code&gt; . Этот атрибут доступен только на fido.</target>
        </trans-unit>
        <trans-unit id="d1f324113425943e40b53dec4caee6bc8c992d2f" translate="yes" xml:space="preserve">
          <source>Use this attribute on the AVR to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут на AVR,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии данного атрибута.</target>
        </trans-unit>
        <trans-unit id="a5bf0a65e4d4990ce1711a80366a15b5a93d0b22" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an NMI handler. The compiler generates function entry and exit sequences suitable for use in an NMI handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут на Blackfin,чтобы указать,что указанная функция является обработчиком NMI.Компилятор генерирует входные и выходные последовательности функций,подходящие для использования в обработчике NMI,когда данный атрибут присутствует.</target>
        </trans-unit>
        <trans-unit id="dfb0dab0829881fae4719db2bc2a5d4b0371e0d9" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an exception handler. The compiler generates function entry and exit sequences suitable for use in an exception handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут на Blackfin,чтобы указать,что указанная функция является обработчиком исключения.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике исключения,когда данный атрибут присутствует.</target>
        </trans-unit>
        <trans-unit id="8869ad65102c3d5175ee58c9a5d4d12dd9377ae3" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to place the variable into L2 SRAM. Variables with &lt;code&gt;l2&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l2.data&lt;/code&gt;.</source>
          <target state="translated">Используйте этот атрибут на Blackfin, чтобы поместить переменную в L2 SRAM. Переменные с атрибутом &lt;code&gt;l2&lt;/code&gt; помещаются в специальный раздел с именем &lt;code&gt;.l2.data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77ba6ef03647597caec122d43f2ce8b19030a7ba" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">Используйте этот атрибут на H8/300,H8/300H,и H8S,чтобы указать,что все регистры,кроме указателя стека,должны быть сохранены в прологе независимо от того,используются они или нет.</target>
        </trans-unit>
        <trans-unit id="df02a088eeed2ddabe9512b735b51f56751782bf" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут на H8/300,H8/300H и H8S,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания,когда данный атрибут присутствует.</target>
        </trans-unit>
        <trans-unit id="fd7a5bf8f68787afcff36ce2f74606dfa6e83fb2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function should be called through the function vector. Calling a function through the function vector reduces code size; however, the function vector has a limited size (maximum 128 entries on the H8/300 and 64 entries on the H8/300H and H8S) and shares space with the interrupt vector.</source>
          <target state="translated">Используйте этот атрибут на H8/300,H8/300H и H8S,чтобы указать,что указанная функция должна быть вызвана через вектор функции.Вызов функции через вектор функции уменьшает размер кода,однако вектор функции имеет ограниченный размер (максимум 128 записей на H8/300 и 64 записи на H8/300H и H8S)и разделяет пространство с вектором прерывания.</target>
        </trans-unit>
        <trans-unit id="599c44ccc726a6980df5cc0406dd5d4d98bf81c0" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified variable should be placed into the eight-bit data section. The compiler generates more efficient code for certain operations on data in the eight-bit data area. Note the eight-bit data area is limited to 256 bytes of data.</source>
          <target state="translated">Используйте этот атрибут на H8/300,H8/300H и H8S,чтобы указать,что указанная переменная должна быть помещена в восьмибитную секцию данных.Компилятор генерирует более эффективный код для определенных операций с данными в восьмиразрядной области данных.Обратите внимание,что восьмибитная область данных ограничена 256 байтами данных.</target>
        </trans-unit>
        <trans-unit id="a601987d8058a933f8472ba9226cb9a2f96a02f6" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300H and H8S to indicate that the specified variable should be placed into the tiny data section. The compiler generates more efficient code for loads and stores on data in the tiny data section. Note the tiny data area is limited to slightly under 32KB of data.</source>
          <target state="translated">Используйте этот атрибут на H8/300H и H8S для того чтобы указать что указанная переменная должна быть помещена в крошечную секцию данных.Компилятор генерирует более эффективный код для загрузки и хранения данных в крошечной секции данных.Обратите внимание,что крошечная область данных ограничена чуть менее 32KB данных.</target>
        </trans-unit>
        <trans-unit id="85d60dec57fe15c501fdf7e341a3a258fde629e1" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32C port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">Используйте этот атрибут на порту M32C, чтобы указать, что указанная функция является быстрым обработчиком прерывания. Это так же , как &lt;code&gt;interrupt&lt;/code&gt; атрибута, за исключением того, что &lt;code&gt;freit&lt;/code&gt; используется для возврата вместо &lt;code&gt;reit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="297c80fc49a65c78b7920bfb2bee0762b9925dea" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32R/D to set the addressability of an object. The identifier &lt;var&gt;model-name&lt;/var&gt; is one of &lt;code&gt;small&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;large&lt;/code&gt;, representing each of the code models.</source>
          <target state="translated">Используйте этот атрибут на M32R / D для установки адресуемости объекта. Идентификатор &lt;var&gt;model-name&lt;/var&gt; может быть &lt;code&gt;small&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; или &lt;code&gt;large&lt;/code&gt; , представляя каждую из моделей кода.</target>
        </trans-unit>
        <trans-unit id="96da4205ef51f9f643ebc02b337015bd75a20bc4" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is a reset handler. The compiler will generate corresponding sections for use in a reset handler. You can use the following attributes to provide extra exception handling:</source>
          <target state="translated">Используйте этот атрибут на цели NDS32,чтобы указать,что указанная функция является обработчиком сброса.Компилятор сгенерирует соответствующие секции для использования в обработчике сброса.Для дополнительной обработки исключений можно использовать следующие атрибуты:</target>
        </trans-unit>
        <trans-unit id="baa8e68af06ff2588951a9683b9bf9ad21db1c70" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is an exception handler. The compiler will generate corresponding sections for use in an exception handler.</source>
          <target state="translated">Используйте этот атрибут на цели NDS32,чтобы указать,что указанная функция является обработчиком исключений.Компилятор сгенерирует соответствующие секции для использования в обработчике исключения.</target>
        </trans-unit>
        <trans-unit id="420b4fa6a036410c655f106a939e0146c5f824c7" translate="yes" xml:space="preserve">
          <source>Use this attribute on the RX port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">Используйте этот атрибут на порту RX, чтобы указать, что указанная функция является быстрым обработчиком прерывания. Это так же , как &lt;code&gt;interrupt&lt;/code&gt; атрибута, за исключением того, что &lt;code&gt;freit&lt;/code&gt; используется для возврата вместо &lt;code&gt;reit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8551dfbdf943cb7774be60c5de8ba39aba7167f2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH for an &lt;code&gt;interrupt_handler&lt;/code&gt; to return using &lt;code&gt;trapa&lt;/code&gt; instead of &lt;code&gt;rte&lt;/code&gt;. This attribute expects an integer argument specifying the trap number to be used.</source>
          <target state="translated">Используйте этот атрибут в SH, чтобы &lt;code&gt;trapa&lt;/code&gt; &lt;code&gt;interrupt_handler&lt;/code&gt; возвращался с использованием trapa вместо &lt;code&gt;rte&lt;/code&gt; . Этот атрибут ожидает целочисленный аргумент, указывающий номер прерывания, который будет использоваться.</target>
        </trans-unit>
        <trans-unit id="96f131ead8b3e83868bdd55e3669cea512c61c77" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH to indicate an &lt;code&gt;interrupt_handler&lt;/code&gt; function should switch to an alternate stack. It expects a string argument that names a global variable holding the address of the alternate stack.</source>
          <target state="translated">Используйте этот атрибут в SH, чтобы указать, что функция &lt;code&gt;interrupt_handler&lt;/code&gt; должна переключиться на альтернативный стек. Он ожидает строковый аргумент, который называет глобальную переменную, содержащую адрес альтернативного стека.</target>
        </trans-unit>
        <trans-unit id="7835a2a9ca1e1170ad95a6f19a530b6da32924fa" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the first 32 kilobytes of memory.</source>
          <target state="translated">Используйте этот атрибут для явного помещения переменной в первые 32 килобайта памяти.</target>
        </trans-unit>
        <trans-unit id="6f81bc7b08ff6f3b4d15b67ecb7306d1b4cac77a" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the small data area, which can hold up to 64 kilobytes.</source>
          <target state="translated">Используйте этот атрибут для явного размещения переменной в небольшой области данных,которая может вмещать до 64 килобайт.</target>
        </trans-unit>
        <trans-unit id="25a478a508b894220fe0716716b37246794c924f" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the tiny data area, which can hold up to 256 bytes in total.</source>
          <target state="translated">Используйте этот атрибут,чтобы явно поместить переменную в крошечную область данных,которая может вместить до 256 байт в целом.</target>
        </trans-unit>
        <trans-unit id="236f15e780f5078ecf100afe1366fac4aadd1410" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что все регистры,кроме указателя стека,должны быть сохранены в прологе независимо от того,используются они или нет.</target>
        </trans-unit>
        <trans-unit id="764c3380316fc59c0e08f071dd7a44fb3d9e29ae" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the function is an interrupt handler. All volatile registers (in addition to non-volatile registers) are saved in the function prologue. If the function is a leaf function, only volatiles used by the function are saved. A normal function return is generated instead of a return from interrupt.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что функция является обработчиком прерываний.Все энергонезависимые регистры (в дополнение к энергонезависимым)сохраняются в прологе функции.Если функция является функцией листа,то сохраняются только летучие регистры,используемые функцией.Вместо возврата по прерыванию генерируется обычный возврат функции.</target>
        </trans-unit>
        <trans-unit id="e7371ecf2ac4e4a5beb340500a4170b79e5aeb2e" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function has no caller-saved registers. That is, all registers are callee-saved. For example, this attribute can be used for a function called from an interrupt handler. The compiler generates proper function entry and exit sequences to save and restore any modified registers, except for the EFLAGS register. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">Используйте этот атрибут, чтобы указать, что указанная функция не имеет регистров, сохраненных вызывающей стороной. То есть все регистры сохраняются вызываемым пользователем. Например, этот атрибут можно использовать для функции, вызываемой из обработчика прерывания. Компилятор генерирует правильные последовательности входа и выхода функции для сохранения и восстановления любых измененных регистров, кроме регистра EFLAGS. Поскольку GCC не сохраняет состояния SSE, MMX или x87, параметр GCC</target>
        </trans-unit>
        <trans-unit id="7d075359795fbb683e03390ae2ab96a3eb2f08a2" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is a break handler. The compiler generates function entry and exit sequences suitable for use in an break handler when this attribute is present. The return from &lt;code&gt;break_handler&lt;/code&gt; is done through the &lt;code&gt;rtbd&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">Используйте этот атрибут, чтобы указать, что указанная функция является обработчиком прерывания. Компилятор генерирует последовательности входа и выхода функции, подходящие для использования в обработчике прерывания, когда этот атрибут присутствует. Возврат от &lt;code&gt;break_handler&lt;/code&gt; осуществляется через &lt;code&gt;rtbd&lt;/code&gt; вместо &lt;code&gt;rtsd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2edc9f687349668f0ff9d21a9fd536ad89ad9e2f" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler or an exception handler (depending on parameters passed to the function, explained further). The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. The &lt;code&gt;IRET&lt;/code&gt; instruction, instead of the &lt;code&gt;RET&lt;/code&gt; instruction, is used to return from interrupt handlers. All registers, except for the EFLAGS register which is restored by the &lt;code&gt;IRET&lt;/code&gt; instruction, are preserved by the compiler. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">Используйте этот атрибут, чтобы указать, что указанная функция является обработчиком прерывания или обработчиком исключений (в зависимости от параметров, переданных в функцию, как описано ниже). Компилятор генерирует последовательности входа и выхода функции, подходящие для использования в обработчике прерывания, когда этот атрибут присутствует. &lt;code&gt;IRET&lt;/code&gt; инструкцию, вместо &lt;code&gt;RET&lt;/code&gt; инструкции, используются для возврата из обработчиков прерываний. Все регистры, кроме регистра EFLAGS, который восстанавливается инструкцией &lt;code&gt;IRET&lt;/code&gt; , сохраняются компилятором. Поскольку GCC не сохраняет состояния SSE, MMX или x87, параметр GCC</target>
        </trans-unit>
        <trans-unit id="0c30254e85a0958ba0ac7ce6feb29ae31661d530" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии данного атрибута.</target>
        </trans-unit>
        <trans-unit id="d47a65245a7242658fd94eba35172dfdbe8eccc4" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. An optional argument is supported for the interrupt attribute which allows the interrupt mode to be described. By default GCC assumes the external interrupt controller (EIC) mode is in use, this can be explicitly set using &lt;code&gt;eic&lt;/code&gt;. When interrupts are non-masked then the requested Interrupt Priority Level (IPL) is copied to the current IPL which has the effect of only enabling higher priority interrupts. To use vectored interrupt mode use the argument &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt;, this will change the behavior of the non-masked interrupt support and GCC will arrange to mask all interrupts from sw0 up to and including the specified interrupt vector.</source>
          <target state="translated">Используйте этот атрибут, чтобы указать, что указанная функция является обработчиком прерывания. Компилятор генерирует последовательности входа и выхода функции, подходящие для использования в обработчике прерывания, когда этот атрибут присутствует. Для атрибута прерывания поддерживается необязательный аргумент, который позволяет описать режим прерывания. По умолчанию GCC предполагает, что используется режим внешнего контроллера прерываний (EIC), это можно явно установить с помощью &lt;code&gt;eic&lt;/code&gt; . Если прерывания немаскированы, запрошенный уровень приоритета прерывания (IPL) копируется в текущую IPL, в результате чего разрешаются только прерывания с более высоким приоритетом. Чтобы использовать режим векторного прерывания, используйте &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt; аргументов = [sw0 | sw1 | hw0 | hw1 | hw2 | hw3 | hw4 | hw5], это изменит поведение поддержки немаскированных прерываний, и GCC будет маскировать все прерывания от sw0 до указанного вектора прерывания включительно.</target>
        </trans-unit>
        <trans-unit id="0ace02ca61dedf94a751682f5d4174fdf42f160d" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. Either name may be used.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии данного атрибута.Может быть использовано любое из имен.</target>
        </trans-unit>
        <trans-unit id="bb60152fa1da7627a1b21880311cc9395167dfd1" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. It may also generate a special section with code to initialize the interrupt vector table.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии данного атрибута.Он также может генерировать специальную секцию с кодом для инициализации таблицы векторов прерываний.</target>
        </trans-unit>
        <trans-unit id="ea92b79a9f3c03589b9a2bec6c52bb535643eb63" translate="yes" xml:space="preserve">
          <source>Use this attribute to place a variable in the &lt;code&gt;.shared&lt;/code&gt; memory space. This memory space is private to each cooperative thread array; only threads within one thread block refer to the same instance of the variable. The runtime does not initialize variables in this memory space.</source>
          <target state="translated">Используйте этот атрибут, чтобы поместить переменную в область &lt;code&gt;.shared&lt;/code&gt; памяти. Это пространство памяти принадлежит каждому массиву взаимодействующих потоков; только потоки в одном блоке потока ссылаются на один и тот же экземпляр переменной. Среда выполнения не инициализирует переменные в этом пространстве памяти.</target>
        </trans-unit>
        <trans-unit id="b1ecdb3757207ea0940932cf33695720d7e7f73c" translate="yes" xml:space="preserve">
          <source>Use this attribute together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt; to indicate that the function entry code should enable nested interrupts or exceptions.</source>
          <target state="translated">Используйте этот атрибут вместе с &lt;code&gt;interrupt_handler&lt;/code&gt; , &lt;code&gt;exception_handler&lt;/code&gt; или &lt;code&gt;nmi_handler&lt;/code&gt; , чтобы указать, что код входа функции должен разрешать вложенные прерывания или исключения.</target>
        </trans-unit>
        <trans-unit id="01448e4d9272cc29bf3907d177e8611ce1e38ee0" translate="yes" xml:space="preserve">
          <source>Use this directive in &lt;em&gt;header files&lt;/em&gt; that define object classes, to save space in most of the object files that use those classes. Normally, local copies of certain information (backup copies of inline member functions, debugging information, and the internal tables that implement virtual functions) must be kept in each object file that includes class definitions. You can use this pragma to avoid such duplication. When a header file containing &amp;lsquo;</source>
          <target state="translated">Используйте эту директиву в &lt;em&gt;файлах заголовков,&lt;/em&gt; которые определяют классы объектов, чтобы сэкономить место в большинстве объектных файлов, которые используют эти классы. Обычно локальные копии определенной информации (резервные копии встроенных функций-членов, отладочная информация и внутренние таблицы, реализующие виртуальные функции) должны храниться в каждом объектном файле, который включает определения классов. Вы можете использовать эту прагму, чтобы избежать такого дублирования. Когда файл заголовка, содержащий '</target>
        </trans-unit>
        <trans-unit id="d280eeca70b31bee4ab8a083eaebf1bfa7fbe798" translate="yes" xml:space="preserve">
          <source>Use this option for microcontroller with a 5200 core, including the MCF5202, MCF5203, MCF5204 and MCF5206.</source>
          <target state="translated">Используйте эту опцию для микроконтроллера с ядром 5200,включая MCF5202,MCF5203,MCF5204 и MCF5206.</target>
        </trans-unit>
        <trans-unit id="a112527843e5614605b4e3f46e7e6138969c47d8" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a 68000 or EC000 core, including the 68008, 68302, 68306, 68307, 68322, 68328 and 68356.</source>
          <target state="translated">Используйте эту опцию для микроконтроллеров с ядром 68000 или EC000,включая 68008,68302,68306,68307,68322,68328 и 68356.</target>
        </trans-unit>
        <trans-unit id="63187c5307bd577a4586510b3b1f06b54dea5f9f" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a CPU32 or CPU32+ core, including the 68330, 68331, 68332, 68333, 68334, 68336, 68340, 68341, 68349 and 68360.</source>
          <target state="translated">Используйте эту опцию для микроконтроллеров с ядром CPU32 или CPU32+,включая 68330,68331,68332,68333,68334,68336,68340,68341,68349 и 68360.</target>
        </trans-unit>
        <trans-unit id="41f23198542e0d6a3a5d2900310d1b7abe9d3260" translate="yes" xml:space="preserve">
          <source>Use this option to require GCC to construct &lt;em&gt;all&lt;/em&gt; integer constants using code, even if it takes more instructions (the maximum is six).</source>
          <target state="translated">Используйте этот параметр, чтобы GCC создавал &lt;em&gt;все&lt;/em&gt; целочисленные константы с использованием кода, даже если для этого требуется больше инструкций (максимум шесть).</target>
        </trans-unit>
        <trans-unit id="6aa829df1806f0740110776091d0764dbe5ca6cc" translate="yes" xml:space="preserve">
          <source>Use this pragma in a &lt;em&gt;main input file&lt;/em&gt;, when you want full output from included header files to be generated (and made globally visible). The included header file, in turn, should use &amp;lsquo;</source>
          <target state="translated">Используйте эту прагму в &lt;em&gt;основном входном файле&lt;/em&gt; , если вы хотите, чтобы был сгенерирован полный вывод из включенных файлов заголовков (и был сделан глобально видимым). Включенный файл заголовка, в свою очередь, должен использовать '</target>
        </trans-unit>
        <trans-unit id="cf5e8f8ca29a0892846d7e7fbb28cf80ccb1a6dd" translate="yes" xml:space="preserve">
          <source>Use traditional TLS as the thread-local storage mechanism for dynamic accesses of TLS variables.</source>
          <target state="translated">Используйте традиционный TLS в качестве потоколокального механизма хранения для динамического доступа к переменным TLS.</target>
        </trans-unit>
        <trans-unit id="d8a60407e03b2ced230c36ef1b80cb979fd89c1c" translate="yes" xml:space="preserve">
          <source>Use uClibc C library. This is the default on &amp;lsquo;</source>
          <target state="translated">Используйте библиотеку uClibc C. Это значение по умолчанию включено '</target>
        </trans-unit>
        <trans-unit id="5a7b4e094ebc57080c3754943807a6fa36611b6e" translate="yes" xml:space="preserve">
          <source>Use uids starting at this parameter for nondebug insns. The range below the parameter is reserved exclusively for debug insns created by</source>
          <target state="translated">Для отладочных вставок используйте uids,начинающиеся с этого параметра.Диапазон,приведенный ниже параметра,зарезервирован исключительно для отладочных вставок,созданных с помощью</target>
        </trans-unit>
        <trans-unit id="5c902a2c872ceeb654d592edec56cf917fe25417" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the C++ ABI. The default is version 0.</source>
          <target state="translated">Используйте версию &lt;var&gt;n&lt;/var&gt; C ++ ABI. По умолчанию - версия 0.</target>
        </trans-unit>
        <trans-unit id="80654292da05f375c19f860e1835e2717583ea50" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the Objective-C ABI for the selected runtime. This option is currently supported only for the NeXT runtime. In that case, Version 0 is the traditional (32-bit) ABI without support for properties and other Objective-C 2.0 additions. Version 1 is the traditional (32-bit) ABI with support for properties and other Objective-C 2.0 additions. Version 2 is the modern (64-bit) ABI. If nothing is specified, the default is Version 0 on 32-bit target machines, and Version 2 on 64-bit target machines.</source>
          <target state="translated">Используйте версию &lt;var&gt;n&lt;/var&gt; Objective-C ABI для выбранной среды выполнения. Эта опция в настоящее время поддерживается только для среды выполнения NeXT. В этом случае Версия 0 является традиционным (32-битным) ABI без поддержки свойств и других дополнений Objective-C 2.0. Версия 1 - это традиционный (32-битный) ABI с поддержкой свойств и других дополнений Objective-C 2.0. Версия 2 - это современный (64-битный) ABI. Если ничего не указано, по умолчанию используется Версия 0 на 32-разрядных целевых машинах и Версия 2 на 64-разрядных целевых машинах.</target>
        </trans-unit>
        <trans-unit id="60277ce820e41f7e776a5ef4d10492797080b9c8" translate="yes" xml:space="preserve">
          <source>User defined libraries may want to implement their own constant string class. To be able to support them, the GNU Objective-C compiler provides a new command line options</source>
          <target state="translated">Определенные пользователем библиотеки могут захотеть реализовать свой собственный класс константной строки.Чтобы иметь возможность их поддерживать,компилятор GNU Objective-C предоставляет новые опции командной строки</target>
        </trans-unit>
        <trans-unit id="6d924128c5dfe7331fc4ebe7adabf4aa651b95c3" translate="yes" xml:space="preserve">
          <source>Users often think it is a bug when GCC reports an error for code like this:</source>
          <target state="translated">Пользователи часто думают,что это ошибка,когда GCC сообщает об ошибке для такого кода:</target>
        </trans-unit>
        <trans-unit id="af3138cc282360a8600ef75867abc1b680f535c7" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;</source>
          <target state="translated">С помощью '</target>
        </trans-unit>
        <trans-unit id="c673f0c8f99a2c8acaf1de1f7743b24ea2d61bf5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;__auto_type&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt; has two advantages:</source>
          <target state="translated">Использование &lt;code&gt;__auto_type&lt;/code&gt; вместо &lt;code&gt;typeof&lt;/code&gt; имеет два преимущества:</target>
        </trans-unit>
        <trans-unit id="ae16306fd8fc8ae70da39e8eba7d569ba5d4c5f6" translate="yes" xml:space="preserve">
          <source>Using extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) typically produces smaller, safer, and more efficient code, and in most cases it is a better solution than basic &lt;code&gt;asm&lt;/code&gt;. However, there are two situations where only basic &lt;code&gt;asm&lt;/code&gt; can be used:</source>
          <target state="translated">Использование расширенного &lt;code&gt;asm&lt;/code&gt; (см. &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt; ) обычно дает меньший, более безопасный и более эффективный код, и в большинстве случаев это лучшее решение, чем базовое &lt;code&gt;asm&lt;/code&gt; . Однако есть две ситуации, когда можно использовать только базовый &lt;code&gt;asm&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fdb3b64210e267abb96c2653531b3f456e595b0e" translate="yes" xml:space="preserve">
          <source>Using floating point parameters for indirect calls to static functions will not work when using the HP assembler. There simply is no way for GCC to specify what registers hold arguments for static functions when using the HP assembler. GAS for the PA does not have this problem.</source>
          <target state="translated">Использование параметров с плавающей точкой для косвенного вызова статических функций не будет работать при использовании ассемблера HP.Просто GCC не может указать,в каких регистрах хранятся аргументы для статических функций при использовании ассемблера HP.GAS для ПА не имеет этой проблемы.</target>
        </trans-unit>
        <trans-unit id="7f26807350569d85ac77ce79b84cf07a635bf81a" translate="yes" xml:space="preserve">
          <source>Using gcov with GCC optimization.</source>
          <target state="translated">Использование gcov с GCC оптимизацией.</target>
        </trans-unit>
        <trans-unit id="057195ec8f49950ab0bbd7ddf35c8adeaad3604e" translate="yes" xml:space="preserve">
          <source>Using that same compiler, this code:</source>
          <target state="translated">Используя тот же компилятор,этот код:</target>
        </trans-unit>
        <trans-unit id="2e7015f3209d38900be9cab70f20fe385b6b0e2e" translate="yes" xml:space="preserve">
          <source>Using the GNU Compiler Collection (GCC)</source>
          <target state="translated">Использование коллекции компиляторов GNU (GCC)</target>
        </trans-unit>
        <trans-unit id="e084cdbad1b5de611e7b01b9c20a68e2bf4e6eb3" translate="yes" xml:space="preserve">
          <source>Using the argument forms of the &lt;code&gt;constructor&lt;/code&gt; and &lt;code&gt;destructor&lt;/code&gt; attributes on targets where the feature is not supported is rejected with an error.</source>
          <target state="translated">Использование форм аргументов атрибутов &lt;code&gt;constructor&lt;/code&gt; и &lt;code&gt;destructor&lt;/code&gt; для целей, где функция не поддерживается, отклоняется с ошибкой.</target>
        </trans-unit>
        <trans-unit id="b7a3e4a21bb4f065c09ef23587c979ac36262bbb" translate="yes" xml:space="preserve">
          <source>Using the built-in functions described below, you can record the arguments a function received, and call another function with the same arguments, without knowing the number or types of the arguments.</source>
          <target state="translated">Используя встроенные функции,описанные ниже,вы можете записать аргументы,полученные функцией,и вызвать другую функцию с теми же аргументами,не зная количество или типы аргументов.</target>
        </trans-unit>
        <trans-unit id="4a1d87094917525e3f4fb29e2aa35aa01c301737" translate="yes" xml:space="preserve">
          <source>Using the cast as the right-hand side of an assignment to a variable of union type is equivalent to storing in a member of the union with the same type</source>
          <target state="translated">Использование кастинга в качестве правой стороны присваивания переменной типа союза эквивалентно хранению в члене союза с таким же типом</target>
        </trans-unit>
        <trans-unit id="db9a503a051e32ac0fce6e9c55331f5affaaa22c" translate="yes" xml:space="preserve">
          <source>Using the variable</source>
          <target state="translated">Использование переменной</target>
        </trans-unit>
        <trans-unit id="b34c5d037644130f54f15d5f39b3ad23e6aef200" translate="yes" xml:space="preserve">
          <source>Using these common set of HTM inline functions, we can create a more portable version of the HTM example in the previous section that will work on either PowerPC or S/390:</source>
          <target state="translated">Используя этот общий набор встроенных функций HTM,в предыдущем разделе мы можем создать более портативную версию примера HTM,которая будет работать либо на PowerPC,либо на S/390:</target>
        </trans-unit>
        <trans-unit id="e5427ab978358d5a7992aa85bab4f2f802b870d2" translate="yes" xml:space="preserve">
          <source>Using this attribute can improve optimization. Compiler predicts that a function with the attribute returns non-null in most cases. Functions like &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;calloc&lt;/code&gt; have this property because they return a pointer to uninitialized or zeroed-out storage. However, functions like &lt;code&gt;realloc&lt;/code&gt; do not have this property, as they can return a pointer to storage containing pointers.</source>
          <target state="translated">Использование этого атрибута может улучшить оптимизацию. Компилятор предсказывает, что функция с атрибутом в большинстве случаев возвращает ненулевое значение. Такие функции, как &lt;code&gt;malloc&lt;/code&gt; и &lt;code&gt;calloc&lt;/code&gt; , имеют это свойство, потому что они возвращают указатель на неинициализированное или обнуленное хранилище. Однако такие функции, как &lt;code&gt;realloc&lt;/code&gt; , не имеют этого свойства, поскольку они могут возвращать указатель на хранилище, содержащее указатели.</target>
        </trans-unit>
        <trans-unit id="1b49b124c3d34a77d39d66c92e391e732c60826d" translate="yes" xml:space="preserve">
          <source>Using vector instructions through built-in functions.</source>
          <target state="translated">Использование векторных инструкций через встроенные функции.</target>
        </trans-unit>
        <trans-unit id="2dfe46da755d749792dfc6596d3900b7c7d1225d" translate="yes" xml:space="preserve">
          <source>Usually, the more IPA optimizations enabled, the larger the number of impacted functions for each function. In order to control the number of impacted functions and more easily compute the list of impacted function, IPA optimizations can be partially enabled at two different levels.</source>
          <target state="translated">Обычно,чем больше включено оптимизаций IPA,тем больше количество затрагиваемых функций для каждой функции.Для того,чтобы контролировать количество затрагиваемых функций и легче вычислять список затрагиваемых функций,оптимизация IPA может быть частично включена на двух различных уровнях.</target>
        </trans-unit>
        <trans-unit id="75ec5cdb7f54185163f339da83a6bb1078cb8cdf" translate="yes" xml:space="preserve">
          <source>Usually, the specified type of a compound literal is a structure. Assume that &lt;code&gt;struct foo&lt;/code&gt; and &lt;code&gt;structure&lt;/code&gt; are declared as shown:</source>
          <target state="translated">Обычно указанный тип составного литерала - это структура. Предположим, что &lt;code&gt;struct foo&lt;/code&gt; и &lt;code&gt;structure&lt;/code&gt; объявлены, как показано:</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="574d16a752ab33d0cef891f9de30707743042305" translate="yes" xml:space="preserve">
          <source>V850E2V3</source>
          <target state="translated">V850E2V3</target>
        </trans-unit>
        <trans-unit id="18daea8d25a1ff1128b31b35345423541b18cfb9" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d31&lt;/code&gt; and the appropriate subset &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d15&lt;/code&gt; based on command line options. Used for 64 bit values only. Not valid for Thumb1.</source>
          <target state="translated">Регистры с плавающей запятой VFP &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d31&lt;/code&gt; и соответствующее подмножество &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d15&lt;/code&gt; на основе параметров командной строки. Используется только для 64-битных значений. Недействительно для Thumb1.</target>
        </trans-unit>
        <trans-unit id="9cbb2d892b07e55db914e77fcb2ce30c1ce00bae" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;s0&lt;/code&gt;-&lt;code&gt;s31&lt;/code&gt;. Used for 32 bit values.</source>
          <target state="translated">Регистры с плавающей запятой VFP &lt;code&gt;s0&lt;/code&gt; - &lt;code&gt;s31&lt;/code&gt; . Используется для 32-битных значений.</target>
        </trans-unit>
        <trans-unit id="3d910167fb4f24dfbb3904aef13e596ce47de5f7" translate="yes" xml:space="preserve">
          <source>VGPR register</source>
          <target state="translated">регистр VGPR</target>
        </trans-unit>
        <trans-unit id="d5387553aab64197b27321b5224709eacf46c07a" translate="yes" xml:space="preserve">
          <source>VIA C3 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA C3 с поддержкой MMX и 3DNow! набора инструкций.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="488b543fd950a74701b966446818fb5fe7d6e4bc" translate="yes" xml:space="preserve">
          <source>VIA C3-2 (Nehemiah/C5XL) CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">ЦП VIA C3-2 (Nehemiah/C5XL)с поддержкой MMX и набора команд SSE.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="ea585482eb4a4acc3a6360d2898743a7c9373beb" translate="yes" xml:space="preserve">
          <source>VIA C7 (Esther) CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">ЦП VIA C7 (Esther)с поддержкой наборов команд MMX,SSE,SSE2 и SSE3.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="f935a35014da34c94c36f4bd8a1a050285f9d495" translate="yes" xml:space="preserve">
          <source>VIA Eden Esther CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Esther процессор с поддержкой наборов команд MMX,SSE,SSE2 и SSE3.(Планирование для этого чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="c111443ef87aeb29107b8a68909620c76e8f94c1" translate="yes" xml:space="preserve">
          <source>VIA Eden Nehemiah CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Nehemiah CPU с поддержкой набора команд MMX и SSE.(Планирование для этого чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="8cce1c624bb9c2543acc6d544b6d1ed27c2158a4" translate="yes" xml:space="preserve">
          <source>VIA Eden Samuel 2 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Samuel 2 CPU с поддержкой MMX и 3DNow! набора инструкций.(Планирование для этого чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="2151cc7927e87e8f1c1dda8e6327ac4e0a64b7a2" translate="yes" xml:space="preserve">
          <source>VIA Eden X2 CPU with x86-64, MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Eden X2 с поддержкой наборов команд x86-64,MMX,SSE,SSE2 и SSE3.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="1d98ef012706e83dddd4d35e5d791491017f3e46" translate="yes" xml:space="preserve">
          <source>VIA Eden X4 CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX and AVX2 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Eden X4 с поддержкой наборов команд x86-64,MMX,SSE,SSE2,SSE3,SSSE3,SSE4.1,SSE4.2,AVX и AVX2.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="b8b4d4a862d49f8ff0f8c10fa3fdc814a539ab87" translate="yes" xml:space="preserve">
          <source>VIA Nano 1xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Nano 1xxx с поддержкой набора команд x86-64,MMX,SSE,SSE2,SSE3 и SSSE3.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="dd719c7a93195bbf6d07de4c172b28d8c80267d3" translate="yes" xml:space="preserve">
          <source>VIA Nano 2xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Nano 2xxx с поддержкой набора команд x86-64,MMX,SSE,SSE2,SSE3 и SSSE3.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="01f9fedc3d4f11e857e6f0d9dcaa2b13176b8f56" translate="yes" xml:space="preserve">
          <source>VIA Nano 3xxx CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Nano 3xxx с поддержкой набора команд x86-64,MMX,SSE,SSE2,SSE3,SSSE3 и SSE4.1.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="06b544d4bdd7d18ca4149d3c750f4127e9f983b2" translate="yes" xml:space="preserve">
          <source>VIA Nano Dual Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Двухъядерный процессор VIA Nano с поддержкой наборов команд x86-64,MMX,SSE,SSE2,SSE3,SSSE3 и SSE4.1.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="a67ea4083339300c1d547f346d07c9d5764525af" translate="yes" xml:space="preserve">
          <source>VIA Nano Quad Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Nano Quad Core CPU с поддержкой набора команд x86-64,MMX,SSE,SSE2,SSE3,SSSE3 и SSE4.1.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="04026107ef9bdc35c4d06c69d4d8d9bd034df2b9" translate="yes" xml:space="preserve">
          <source>VPCLMULQDQ instructions.</source>
          <target state="translated">VPCLMULQDQ инструкции.</target>
        </trans-unit>
        <trans-unit id="47b598fadc542503a4dfb3ab0e7c08963d810a39" translate="yes" xml:space="preserve">
          <source>VRSAVE</source>
          <target state="translated">VRSAVE</target>
        </trans-unit>
        <trans-unit id="55aa2f856c0f4ab3cdcac26a348778a588a6f8d7" translate="yes" xml:space="preserve">
          <source>VSIB address operand.</source>
          <target state="translated">Адресный операнд ВСИБ.</target>
        </trans-unit>
        <trans-unit id="1e028c813fc89395b126781b62fe740e1e2e5612" translate="yes" xml:space="preserve">
          <source>VSX register if direct move instructions are enabled, or NO_REGS.</source>
          <target state="translated">VSX-регистр,если включены прямые указания по перемещению,или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="b1bf4ce917ea0e342c5ba87416d3c1425045396d" translate="yes" xml:space="preserve">
          <source>VSX register if the</source>
          <target state="translated">Регистрация VSX,если</target>
        </trans-unit>
        <trans-unit id="fa37e771ee1559b7e1a74968d2d6f9d21bbad3f8" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point TFmode, or NO_REGS.</source>
          <target state="translated">Регистр VSX,используемый для IEEE 128-битного TFmode с плавающей точкой,или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="dceb09e56dc6976e2ceb44b306b90d48c16cdbfa" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point, or NO_REGS.</source>
          <target state="translated">Регистр VSX,используемый для IEEE 128-битной вычисленной точки с плавающей запятой,или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="5f2931cf969db5dec892ea6c97702a431f737f4f" translate="yes" xml:space="preserve">
          <source>VSX register to use for ISA 3.0 vector instructions, or NO_REGS.</source>
          <target state="translated">Регистр VSX для использования векторных инструкций ISA 3.0,или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="e1e2b74202b4df2a34423d711c880f4bed5b3b14" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold 128 bit integer or NO_REGS.</source>
          <target state="translated">VSX векторный регистр для хранения 128-битного целого числа или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="f3dc5e0d7bbebef3893829b42a25b08c256dd4d8" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold scalar double values or NO_REGS.</source>
          <target state="translated">VSX векторный регистр для хранения скалярных двойных значений или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="dc350e1093c1db7d408d43c001ed04b73c029f23" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector double data or NO_REGS.</source>
          <target state="translated">VSX векторный регистр для хранения векторных двойных данных или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="167ef2a892b4ddc57b82f58074b39f524e5008e6" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector float data or NO_REGS.</source>
          <target state="translated">VSX векторный регистр для хранения векторных данных с плавающей запятой или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="81969f619b07a96e38c916b9993cc433143a784f" translate="yes" xml:space="preserve">
          <source>VTables</source>
          <target state="translated">VTables</target>
        </trans-unit>
        <trans-unit id="f5f8e1247b6f26b263b34207afe669cb4ac9de15" translate="yes" xml:space="preserve">
          <source>Valid ISO C and ISO C++ programs should compile properly with or without this option (though a rare few require</source>
          <target state="translated">Действительные программы на ISO C и ISO C++должны компилироваться правильно с этой опцией или без нее (хотя некоторые редкие программы требуют</target>
        </trans-unit>
        <trans-unit id="6c1f687862693a87865ad97fba05738669eac5ce" translate="yes" xml:space="preserve">
          <source>Valid alignment values other than those returned by an _Alignof expression for fundamental types, if any (C11 6.2.8).</source>
          <target state="translated">Действительные значения выравнивания,отличные от значений,возвращаемых выражением _Alignof для фундаментальных типов,если таковые имеются (С11 6.2.8).</target>
        </trans-unit>
        <trans-unit id="b8f1ffda93c672ca444e36a4f56d16e63e5832c4" translate="yes" xml:space="preserve">
          <source>Valid alignments are powers of 2 up to and including &lt;em&gt;2^{28}&lt;/em&gt;.</source>
          <target state="translated">Допустимые варианты выравнивания: степени от 2 до &lt;em&gt;2 ^ {28}&lt;/em&gt; включительно .</target>
        </trans-unit>
        <trans-unit id="e0567df87b1ea75cda27929ada4a4306a0c755cd" translate="yes" xml:space="preserve">
          <source>Valid options for &lt;var&gt;time&lt;/var&gt; are</source>
          <target state="translated">Допустимые варианты &lt;var&gt;time&lt;/var&gt; являются</target>
        </trans-unit>
        <trans-unit id="bd15e3ace5dbddf7a0573a3f99038d776bddea91" translate="yes" xml:space="preserve">
          <source>Value appropriate as displacement.</source>
          <target state="translated">Значение соответствует смещению.</target>
        </trans-unit>
        <trans-unit id="bb6561e8ab01989a094611590f0602e85a6c5513" translate="yes" xml:space="preserve">
          <source>Values &amp;lsquo;</source>
          <target state="translated">Ценности '</target>
        </trans-unit>
        <trans-unit id="d206078a63cff7bace258bb1f4bb9507b5cf8d12" translate="yes" xml:space="preserve">
          <source>Variable, function, and type attributes for C++ only.</source>
          <target state="translated">Атрибуты переменной,функции и типа только для C++.</target>
        </trans-unit>
        <trans-unit id="02b16fb34038c0c62719510ede0c2e29dc2b90fc" translate="yes" xml:space="preserve">
          <source>Variable-length automatic arrays are allowed in ISO C99, and as an extension GCC accepts them in C90 mode and in C++. These arrays are declared like any other automatic arrays, but with a length that is not a constant expression. The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits. For example:</source>
          <target state="translated">Автоматические массивы переменной длины разрешены в ISO C99,а в качестве расширения GCC принимает их в режиме C90 и в C++.Эти массивы объявляются,как и любые другие автоматические массивы,но с длиной,не являющейся константным выражением.Хранилище выделяется в момент объявления и деблокируется при выходе из области видимости блока,содержащего объявление.Например:</target>
        </trans-unit>
        <trans-unit id="c1cafb0eff03f52681f175e65218139665f9ce2c" translate="yes" xml:space="preserve">
          <source>Variables declared at global scope.</source>
          <target state="translated">Переменные,объявленные в глобальном масштабе.</target>
        </trans-unit>
        <trans-unit id="5c01cb4a8cb1760f9b45c63f7213bd015da5c74c" translate="yes" xml:space="preserve">
          <source>Variables declared within a function.</source>
          <target state="translated">Переменные,объявленные в рамках функции.</target>
        </trans-unit>
        <trans-unit id="b8da0198222d30500868466badddd4041e14cce0" translate="yes" xml:space="preserve">
          <source>Variables of size &lt;var&gt;n&lt;/var&gt; bytes or smaller are placed in the &lt;code&gt;.based&lt;/code&gt; section by default. Based variables use the &lt;code&gt;$tp&lt;/code&gt; register as a base register, and there is a 128-byte limit to the &lt;code&gt;.based&lt;/code&gt; section.</source>
          <target state="translated">Переменные размером &lt;var&gt;n&lt;/var&gt; байт или меньше по умолчанию помещаются в раздел &lt;code&gt;.based&lt;/code&gt; . Базовые переменные используют регистр &lt;code&gt;$tp&lt;/code&gt; как базовый регистр, а для секции &lt;code&gt;.based&lt;/code&gt; существует ограничение в 128 байт .</target>
        </trans-unit>
        <trans-unit id="10abea2eed8c32edbb792ccf39c883573091a3b2" translate="yes" xml:space="preserve">
          <source>Variables that are &lt;var&gt;n&lt;/var&gt; bytes or smaller are allocated to the &lt;code&gt;.tiny&lt;/code&gt; section. These variables use the &lt;code&gt;$gp&lt;/code&gt; base register. The default for this option is 4, but note that there&amp;rsquo;s a 65536-byte limit to the &lt;code&gt;.tiny&lt;/code&gt; section.</source>
          <target state="translated">Переменные размером &lt;var&gt;n&lt;/var&gt; байтов или меньше выделяются в раздел &lt;code&gt;.tiny&lt;/code&gt; . Эти переменные используют базовый регистр &lt;code&gt;$gp&lt;/code&gt; . По умолчанию для этого параметра установлено значение 4, но обратите внимание, что для раздела &lt;code&gt;.tiny&lt;/code&gt; существует ограничение в 65536 байт .</target>
        </trans-unit>
        <trans-unit id="fd3f9d35c079daab2745eafe9db9775e6794913e" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;cb&lt;/code&gt; attribute are used to access the control bus, using special instructions. &lt;code&gt;addr&lt;/code&gt; indicates the control bus address. Example:</source>
          <target state="translated">Переменные с атрибутом &lt;code&gt;cb&lt;/code&gt; используются для доступа к шине управления с помощью специальных инструкций. &lt;code&gt;addr&lt;/code&gt; указывает адрес шины управления. Пример:</target>
        </trans-unit>
        <trans-unit id="de934aeb77c58838cc9846aadb82fbd1b8f30e96" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;far&lt;/code&gt; attribute are addressed using a full 32-bit address. Since this covers the entire memory space, this allows modules to make no assumptions about where variables might be stored.</source>
          <target state="translated">Переменные с атрибутом &lt;code&gt;far&lt;/code&gt; адресуются с использованием полного 32-битного адреса. Поскольку это охватывает все пространство памяти, это позволяет модулям не делать предположений о том, где могут храниться переменные.</target>
        </trans-unit>
        <trans-unit id="36905cf24c84385c4961b4619b30de52faf8e512" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;io&lt;/code&gt; attribute are used to address memory-mapped peripherals. If an address is specified, the variable is assigned that address, else it is not assigned an address (it is assumed some other module assigns an address). Example:</source>
          <target state="translated">Переменные с атрибутом &lt;code&gt;io&lt;/code&gt; используются для адресации периферийных устройств с отображением памяти. Если адрес указан, переменной назначается этот адрес, в противном случае ему не назначается адрес (предполагается, что какой-то другой модуль назначает адрес). Пример:</target>
        </trans-unit>
        <trans-unit id="8908399e90d6597694e9414404cf146058083fc2" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;near&lt;/code&gt; attribute are assumed to have addresses that fit in a 24-bit addressing mode. This is the default for large variables (&lt;code&gt;-mtiny=4&lt;/code&gt; is the default) but this attribute can override &lt;code&gt;-mtiny=&lt;/code&gt; for small variables, or override &lt;code&gt;-ml&lt;/code&gt;.</source>
          <target state="translated">Предполагается, что переменные с атрибутом &lt;code&gt;near&lt;/code&gt; имеют адреса, соответствующие 24-битному режиму адресации. Это значение по умолчанию для больших переменных ( &lt;code&gt;-mtiny=4&lt;/code&gt; по умолчанию), но этот атрибут может переопределить &lt;code&gt;-mtiny=&lt;/code&gt; для малых переменных или &lt;code&gt;-ml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f34701193da16d128be7840c2b5e27cdc6209c0" translate="yes" xml:space="preserve">
          <source>Variadic functions always use the &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; calling convention and the compiler rejects attempts to specify an alternative.</source>
          <target state="translated">Функции Variadic всегда используют &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; и компилятор отклоняет попытки указать альтернативу.</target>
        </trans-unit>
        <trans-unit id="c34add3442e320001d71a4acf459f90b84551e3c" translate="yes" xml:space="preserve">
          <source>Variations on C++.</source>
          <target state="translated">Вариации на С++.</target>
        </trans-unit>
        <trans-unit id="0125a3430008ecbd7c8a33ef91916cf2ea436c9e" translate="yes" xml:space="preserve">
          <source>Variations on Objective-C and Objective-C++.</source>
          <target state="translated">Вариации на тему &quot;Цель-С&quot; и &quot;Цель-С++&quot;.</target>
        </trans-unit>
        <trans-unit id="eb5d846c7919ee0bdc2338a4cc38cee42f3c00b6" translate="yes" xml:space="preserve">
          <source>Vector comparison is supported with standard comparison operators: &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt;. Comparison operands can be vector expressions of integer-type or real-type. Comparison between integer-type vectors and real-type vectors are not supported. The result of the comparison is a vector of the same width and number of elements as the comparison operands with a signed integral element type.</source>
          <target state="translated">Сравнение векторов поддерживается стандартными операторами сравнения: &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; . Операнды сравнения могут быть векторными выражениями целочисленного или вещественного типа. Сравнение между векторами целочисленного типа и векторами действительного типа не поддерживается. Результатом сравнения является вектор той же ширины и количества элементов, что и операнды сравнения со знаком целочисленного типа элемента.</target>
        </trans-unit>
        <trans-unit id="5abc95e73e06fb4a5dc5582edf5afa312b0850ca" translate="yes" xml:space="preserve">
          <source>Vector condition register: VCC, VCC_LO, VCC_HI</source>
          <target state="translated">Векторный регистр состояния:VCC,VCC_LO,VCC_HI</target>
        </trans-unit>
        <trans-unit id="53804d00035aa75837541b3ccf479dca992da7d5" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with XXSPLTIB &amp;amp; sign extension.</source>
          <target state="translated">Векторная константа, которую можно загрузить с помощью расширения XXSPLTIB и знака.</target>
        </trans-unit>
        <trans-unit id="82f741b1697518a50ba54947e1a23cae2eaec1c0" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with the XXSPLTIB instruction.</source>
          <target state="translated">Векторная константа,которая может быть загружена с инструкцией XXSPLTIB.</target>
        </trans-unit>
        <trans-unit id="46e517c61990308718dcf40277ed1d92f620280a" translate="yes" xml:space="preserve">
          <source>Vector constant that does not require memory</source>
          <target state="translated">Векторная константа,не требующая памяти</target>
        </trans-unit>
        <trans-unit id="b42c5127757a32ed5d06d2b5cf09ce9893f82ec9" translate="yes" xml:space="preserve">
          <source>Vector constant that is all zeros.</source>
          <target state="translated">Векторная константа,то есть все нули.</target>
        </trans-unit>
        <trans-unit id="9c36bdfc3b8d0b06a49e5ef972497ba956ef9bbc" translate="yes" xml:space="preserve">
          <source>Vector conversion is available using the &lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; function. &lt;var&gt;vec&lt;/var&gt; must be an expression with integral or floating vector type and &lt;var&gt;vectype&lt;/var&gt; an integral or floating vector type with the same number of elements. The result has &lt;var&gt;vectype&lt;/var&gt; type and value of a C cast of every element of &lt;var&gt;vec&lt;/var&gt; to the element type of &lt;var&gt;vectype&lt;/var&gt;.</source>
          <target state="translated">Векторное преобразование доступно с помощью функции &lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; . &lt;var&gt;vec&lt;/var&gt; должно быть выражением с целочисленным или плавающим векторным типом, а &lt;var&gt;vectype&lt;/var&gt; - с целым или плавающим векторным типом с тем же числом элементов. Результат имеет тип &lt;var&gt;vectype&lt;/var&gt; и значение преобразования C каждого элемента &lt;var&gt;vec&lt;/var&gt; в тип элемента &lt;var&gt;vectype&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bad6bdbaf23ec0df51bc6d85940b036ecbab94" translate="yes" xml:space="preserve">
          <source>Vector registers.</source>
          <target state="translated">Векторные регистры.</target>
        </trans-unit>
        <trans-unit id="8e0df7cd51c0d162c1fce7156e6eae770327c8c2" translate="yes" xml:space="preserve">
          <source>Vector shuffling is available using functions &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; and &lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt;. Both functions construct a permutation of elements from one or two vectors and return a vector of the same type as the input vector(s). The &lt;var&gt;mask&lt;/var&gt; is an integral vector with the same width (&lt;var&gt;W&lt;/var&gt;) and element count (&lt;var&gt;N&lt;/var&gt;) as the output vector.</source>
          <target state="translated">&lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt; доступно с использованием функций &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; и __builtin_shuffle (vec0, vec1, mask) . Обе функции создают перестановку элементов из одного или двух векторов и возвращают вектор того же типа, что и входной вектор (ы). &lt;var&gt;mask&lt;/var&gt; является составным вектором с такой же шириной ( &lt;var&gt;W&lt;/var&gt; ) и числом элементов ( &lt;var&gt;N&lt;/var&gt; ) в качестве выходного вектора.</target>
        </trans-unit>
        <trans-unit id="58128c4d1de4d0a51bf04fac4cddbc549bd01efb" translate="yes" xml:space="preserve">
          <source>Vector zero</source>
          <target state="translated">вектор нуля</target>
        </trans-unit>
        <trans-unit id="73c5f8f62b1af06d2d8df3f66347a1a059d5cf24" translate="yes" xml:space="preserve">
          <source>Vectors are compared element-wise producing 0 when comparison is false and -1 (constant of the appropriate type where all bits are set) otherwise. Consider the following example.</source>
          <target state="translated">Векторы сравниваются по элементам,производя 0,если сравнение ложное,и -1 (константа соответствующего типа,где все биты установлены)в противном случае.Рассмотрим следующий пример.</target>
        </trans-unit>
        <trans-unit id="fcd23bd0a88ba1a503b10ed5edf55ece81978ffc" translate="yes" xml:space="preserve">
          <source>Vectors can be subscripted as if the vector were an array with the same number of elements and base type. Out of bound accesses invoke undefined behavior at run time. Warnings for out of bound accesses for vector subscription can be enabled with</source>
          <target state="translated">Векторы можно подписывать так,как если бы вектор был массивом с таким же количеством элементов и базовым типом.Внеграничные обращения вызывают неопределенное поведение во время выполнения.Предупреждения о выходе из-под привязки для векторной подписки можно включить с помощью параметра</target>
        </trans-unit>
        <trans-unit id="e368f0bdb096cdc80b942de26edde7361d633b14" translate="yes" xml:space="preserve">
          <source>Version 0 refers to the version conforming most closely to the C++ ABI specification. Therefore, the ABI obtained using version 0 will change in different versions of G++ as ABI bugs are fixed.</source>
          <target state="translated">Версия 0 относится к версии,наиболее близкой к спецификации C++ABI.Поэтому ABI,полученный с использованием версии 0,будет изменяться в разных версиях G++,так как ошибки ABI исправлены.</target>
        </trans-unit>
        <trans-unit id="4d24a59e560f384b23499b32746ec055716a43ab" translate="yes" xml:space="preserve">
          <source>Version 1 is the version of the C++ ABI that first appeared in G++ 3.2.</source>
          <target state="translated">Версия 1-это версия C++ABI,которая впервые появилась в G++3.2.</target>
        </trans-unit>
        <trans-unit id="3c0b003b505c0ed05512e30de5602e0fe9cf92cd" translate="yes" xml:space="preserve">
          <source>Version 10, which first appeared in G++ 6.1, adds mangling of attributes that affect type identity, such as ia32 calling convention attributes (e.g. &amp;lsquo;</source>
          <target state="translated">Версия 10, впервые появившаяся в G ++ 6.1, добавляет изменение атрибутов, влияющих на идентичность типа, например атрибутов соглашения о вызовах ia32 (например, '</target>
        </trans-unit>
        <trans-unit id="663092bb020840a15939c0d6a393bb5154dcf611" translate="yes" xml:space="preserve">
          <source>Version 11, which first appeared in G++ 7, corrects the mangling of sizeof... expressions and operator names. For multiple entities with the same name within a function, that are declared in different scopes, the mangling now changes starting with the twelfth occurrence. It also implies</source>
          <target state="translated">Версия 11,впервые появившаяся в G++7,исправляет искажение размеров...выражений и имен операторов.Для множества сущностей с одним и тем же именем внутри функции,которые объявлены в разных диапазонах,искажение теперь меняется,начиная с двенадцатого вхождения.Это также подразумевает</target>
        </trans-unit>
        <trans-unit id="0ca6a1ee7b0905689803a926babe92130837b997" translate="yes" xml:space="preserve">
          <source>Version 12, which first appeared in G++ 8, corrects the calling conventions for empty classes on the x86_64 target and for classes with only deleted copy/move constructors. It accidentally changes the calling convention for classes with a deleted copy constructor and a trivial move constructor.</source>
          <target state="translated">Версия 12,впервые появившаяся в G++8,исправляет соглашения о вызове для пустых классов на x86_64 цели и для классов с только удаленными конструкторами копирования/перемещения.Случайно изменяется соглашение о вызове для классов с конструктором удаленного копирования и тривиальным конструктором перемещения.</target>
        </trans-unit>
        <trans-unit id="50a009d60ade6b341d095db62ce8f2e0c4f1391a" translate="yes" xml:space="preserve">
          <source>Version 13, which first appeared in G++ 8.2, fixes the accidental change in version 12.</source>
          <target state="translated">Версия 13,впервые появившаяся в G++8.2,исправляет случайное изменение в версии 12.</target>
        </trans-unit>
        <trans-unit id="3b38c5970d57d0e95ac144e09f14ebe98042886d" translate="yes" xml:space="preserve">
          <source>Version 2 is the version of the C++ ABI that first appeared in G++ 3.4, and was the default through G++ 4.9.</source>
          <target state="translated">Версия 2-это версия C++ABI,которая впервые появилась в G++3.4,и была по умолчанию через G++4.9.</target>
        </trans-unit>
        <trans-unit id="b724fbb5aa7b15b70d72eb03063512067a94eeca" translate="yes" xml:space="preserve">
          <source>Version 3 corrects an error in mangling a constant address as a template argument.</source>
          <target state="translated">Версия 3 исправляет ошибку при использовании постоянного адреса в качестве аргумента шаблона.</target>
        </trans-unit>
        <trans-unit id="01a6ae459293959ae77cf0ff9e1fc859781779ed" translate="yes" xml:space="preserve">
          <source>Version 4 may require GDB 7.0 and</source>
          <target state="translated">Для версии 4 может потребоваться GDB 7.0 и</target>
        </trans-unit>
        <trans-unit id="dd83630f9225432d363943045fc9c9e3da8fa1fd" translate="yes" xml:space="preserve">
          <source>Version 4, which first appeared in G++ 4.5, implements a standard mangling for vector types.</source>
          <target state="translated">Версия 4,впервые появившаяся в G++4.5,реализует стандартное управление векторными типами.</target>
        </trans-unit>
        <trans-unit id="bcd8e454766585098e98a3f378e25d4a3a094eb0" translate="yes" xml:space="preserve">
          <source>Version 5, which first appeared in G++ 4.6, corrects the mangling of attribute const/volatile on function pointer types, decltype of a plain decl, and use of a function parameter in the declaration of another parameter.</source>
          <target state="translated">Версия 5,впервые появившаяся в G++4.6,исправляет искажение атрибута const/volatile на типы указателей функций,тип склонения простого объявления,а также использование параметра функции в объявлении другого параметра.</target>
        </trans-unit>
        <trans-unit id="b60149f703c30d6cd13e3a5cac7ff5559e1b4439" translate="yes" xml:space="preserve">
          <source>Version 6, which first appeared in G++ 4.7, corrects the promotion behavior of C++11 scoped enums and the mangling of template argument packs, const/static_cast, prefix ++ and &amp;ndash;, and a class scope function used as a template argument.</source>
          <target state="translated">Версия 6, которая впервые появилась в G ++ 4.7, исправляет продвижение перечислений с областью видимости C ++ 11 и искажение пакетов аргументов шаблона, const / static_cast, prefix ++ и -, а также функцию области действия класса, используемую в качестве аргумента шаблона.</target>
        </trans-unit>
        <trans-unit id="4782295af04ef7af5fe54b3ee6d18f5a34a794e5" translate="yes" xml:space="preserve">
          <source>Version 7, which first appeared in G++ 4.8, that treats nullptr_t as a builtin type and corrects the mangling of lambdas in default argument scope.</source>
          <target state="translated">Версия 7,впервые появившаяся в G++4.8,рассматривает nullptr_t как тип builtin и исправляет искажение lambdas в области аргументов по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d1c84e5d1ca1394d2ffa2a327b111624fb731bc7" translate="yes" xml:space="preserve">
          <source>Version 8, which first appeared in G++ 4.9, corrects the substitution behavior of function types with function-cv-qualifiers.</source>
          <target state="translated">Версия 8,впервые появившаяся в G++4.9,корректирует поведение подстановки типов функций с помощью функций-cv-квалификаторов.</target>
        </trans-unit>
        <trans-unit id="4ac00f95e84165203755f6a82a57d89ac3c1bab9" translate="yes" xml:space="preserve">
          <source>Version 9, which first appeared in G++ 5.2, corrects the alignment of &lt;code&gt;nullptr_t&lt;/code&gt;.</source>
          <target state="translated">Версия 9, которая впервые появилась в G ++ 5.2, исправляет выравнивание &lt;code&gt;nullptr_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cbaf9a36f9cc94b3082b235b02920043f217806" translate="yes" xml:space="preserve">
          <source>Visium&amp;mdash;</source>
          <target state="translated">Visium&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="ea87a96f76fbda4a0ceea67f5b82b7da4f4e2ed4" translate="yes" xml:space="preserve">
          <source>Volatile memory access bypass the cache using the I/O variants of the load and store instructions. The default is not to bypass the cache.</source>
          <target state="translated">Энергонезависимый доступ к памяти обходит кэш,используя варианты загрузки и хранения инструкций ввода/вывода.По умолчанию обхода кэша не производится.</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="1b1d16cb93f0aa2689c3eb4f6494e062863aa127" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011, e.g., identifiers in ISO C++ 1998 that are keywords in ISO C++ 2011. This warning turns on</source>
          <target state="translated">Предупреждаем о конструкциях С++,значение которых отличается между ISO C++1998 и ISO C++2011,например,идентификаторы в ISO C++1998,которые являются ключевыми словами в ISO C++2011.Это предупреждение включает</target>
        </trans-unit>
        <trans-unit id="a16be8e81dda2e7fc6c8f9439ff0fc768831de14" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014. This warning is enabled by</source>
          <target state="translated">Предупреждаем о конструкциях C++,значение которых отличается от ISO C++2011 и ISO C++2014.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="7632b789c4deefeb017ad2d53cdd4160afd5fe89" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2014 and ISO C++ 2017. This warning is enabled by</source>
          <target state="translated">Предупреждаем о конструкциях С++,значение которых отличается между ISO C++2014 и ISO C++2017.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="53b51f298dc17e10801636bad5bebb8011117716" translate="yes" xml:space="preserve">
          <source>Warn about ISO C constructs that are outside of the common subset of ISO C and ISO C++, e.g. request for implicit conversion from &lt;code&gt;void *&lt;/code&gt; to a pointer to non-&lt;code&gt;void&lt;/code&gt; type.</source>
          <target state="translated">Предупреждать о конструкциях ISO C, которые выходят за рамки общего подмножества ISO C и ISO C ++, например, о запросе неявного преобразования из &lt;code&gt;void *&lt;/code&gt; в указатель на &lt;code&gt;void&lt;/code&gt; тип.</target>
        </trans-unit>
        <trans-unit id="4f7de69bb81f9d506bfb6d47f928c946ab6b330c" translate="yes" xml:space="preserve">
          <source>Warn about One Definition Rule violations during link-time optimization. Requires</source>
          <target state="translated">Предупреждать о нарушении правила One Definition Rule при оптимизации времени соединения.Требуется</target>
        </trans-unit>
        <trans-unit id="f7cf98ad983fadf59ea9d8e55fff149a4d55f39b" translate="yes" xml:space="preserve">
          <source>Warn about a comparison between values of different enumerated types. In C++ enumerated type mismatches in conditional expressions are also diagnosed and the warning is enabled by default. In C this warning is enabled by</source>
          <target state="translated">Предупреждать о сравнении значений различных перечисленных типов.В Си++также диагностируется несовпадение перечисляемых типов в условных выражениях и по умолчанию включено предупреждение.В Си это предупреждение включается по</target>
        </trans-unit>
        <trans-unit id="5887fb5f81adf7425e8f523309718b847865d42f" translate="yes" xml:space="preserve">
          <source>Warn about a definition of an unsized deallocation function</source>
          <target state="translated">Предупредить об определении негабаритной функции распределения сделок.</target>
        </trans-unit>
        <trans-unit id="a4b22fdd430cf26b4eb0550ba2a6437e719969f1" translate="yes" xml:space="preserve">
          <source>Warn about a new-expression of a type that requires greater alignment than the &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; but uses an allocation function without an explicit alignment parameter. This option is enabled by</source>
          <target state="translated">Предупреждать о новом выражении типа, который требует большего выравнивания, чем &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; но использует функцию распределения без явного параметра выравнивания. Эта опция включена</target>
        </trans-unit>
        <trans-unit id="57392da628b0c1cb78f8e90a0ce56848a537dcc1" translate="yes" xml:space="preserve">
          <source>Warn about anything that depends on the &amp;ldquo;size of&amp;rdquo; a function type or of &lt;code&gt;void&lt;/code&gt;. GNU C assigns these types a size of 1, for convenience in calculations with &lt;code&gt;void *&lt;/code&gt; pointers and pointers to functions. In C++, warn also when an arithmetic operation involves &lt;code&gt;NULL&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">Предупреждать обо всем, что зависит от &amp;laquo;размера&amp;raquo; типа функции или &lt;code&gt;void&lt;/code&gt; . GNU C присваивает этим типам размер 1 для удобства вычислений с указателями &lt;code&gt;void *&lt;/code&gt; и указателями на функции. В C ++ предупреждать также, когда в арифметической операции используется &lt;code&gt;NULL&lt;/code&gt; . Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="a808a76d216f717246383427b89eff52c9b874ec" translate="yes" xml:space="preserve">
          <source>Warn about boolean expression compared with an integer value different from &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;. For instance, the following comparison is always false:</source>
          <target state="translated">Предупредить о сравнении логического выражения с целочисленным значением, отличным от &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; . Например, следующее сравнение всегда неверно:</target>
        </trans-unit>
        <trans-unit id="a9d532ae5e4af7c1749f0187b9a6c681cd5f881a" translate="yes" xml:space="preserve">
          <source>Warn about calls to allocation functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that specify zero bytes, including those to the built-in forms of the functions &lt;code&gt;aligned_alloc&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, and &lt;code&gt;realloc&lt;/code&gt;. Because the behavior of these functions when called with a zero size differs among implementations (and in the case of &lt;code&gt;realloc&lt;/code&gt; has been deprecated) relying on it may result in subtle portability bugs and should be avoided.</source>
          <target state="translated">Предупреждать о вызовах функций распределения, украшенных атрибутом &lt;code&gt;alloc_size&lt;/code&gt; , которые указывают нулевые байты, в том числе для встроенных форм функций &lt;code&gt;aligned_alloc&lt;/code&gt; , &lt;code&gt;alloca&lt;/code&gt; , &lt;code&gt;calloc&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; и &lt;code&gt;realloc&lt;/code&gt; . Поскольку поведение этих функций при вызове с нулевым размером различается в разных реализациях (а в случае &lt;code&gt;realloc&lt;/code&gt; не рекомендуется), использование этого метода может привести к незначительным ошибкам переносимости, и его следует избегать.</target>
        </trans-unit>
        <trans-unit id="3cff65779e3725cfbc2854d42263f2ace49a0bba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;snprintf&lt;/code&gt; and &lt;code&gt;vsnprintf&lt;/code&gt; that might result in output truncation. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives. Except as noted otherwise, the option uses the same logic</source>
          <target state="translated">Предупреждать о вызовах форматированных функций ввода / вывода, таких как &lt;code&gt;snprintf&lt;/code&gt; и &lt;code&gt;vsnprintf&lt;/code&gt; , которые могут привести к усечению вывода. Когда точное количество байтов, записанных директивой формата, не может быть определено во время компиляции, оно оценивается на основе эвристики, которая зависит от аргумента &lt;var&gt;level&lt;/var&gt; и от оптимизации. Хотя включение оптимизации в большинстве случаев повысит точность предупреждения, оно также может привести к ложным срабатываниям. Если не указано иное, опция использует ту же логику</target>
        </trans-unit>
        <trans-unit id="66472dc4cd87cc63c73cb46419c0fd90cf1906ba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;sprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; that might overflow the destination buffer. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives.</source>
          <target state="translated">Предупреждать о вызовах форматированных функций ввода / вывода, таких как &lt;code&gt;sprintf&lt;/code&gt; и &lt;code&gt;vsprintf&lt;/code&gt; , которые могут переполнить целевой буфер. Когда точное количество байтов, записанных директивой формата, не может быть определено во время компиляции, оно оценивается на основе эвристики, которая зависит от аргумента &lt;var&gt;level&lt;/var&gt; и от оптимизации. Хотя включение оптимизации в большинстве случаев повысит точность предупреждения, оно также может привести к ложным срабатываниям.</target>
        </trans-unit>
        <trans-unit id="8986e7105a9ec8665e2dbbf6296adf8b057bee04" translate="yes" xml:space="preserve">
          <source>Warn about calls to functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that attempt to allocate objects larger than the specified number of bytes, or where the result of the size computation in an integer type with infinite precision would exceed the value of &amp;lsquo;</source>
          <target state="translated">Предупреждать о вызовах функций, украшенных атрибутом &lt;code&gt;alloc_size&lt;/code&gt; , которые пытаются выделить объекты, размер которых превышает указанное количество байтов, или когда результат вычисления размера в целочисленном типе с бесконечной точностью превысит значение '</target>
        </trans-unit>
        <trans-unit id="88c937d55912c756c7716e6f943b38520ff30020" translate="yes" xml:space="preserve">
          <source>Warn about cases that are both questionable and easy to avoid. For example the compiler simplifies &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;. This level of</source>
          <target state="translated">Предупреждайте о случаях, которые одновременно сомнительны и которых легко избежать. Например, компилятор упрощает &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; до &lt;code&gt;1&lt;/code&gt; . Этот уровень</target>
        </trans-unit>
        <trans-unit id="179fecfde091b7cc90c5093c0b77e7c3ec453920" translate="yes" xml:space="preserve">
          <source>Warn about catch handlers that do not catch via reference. With</source>
          <target state="translated">Предупреждайте об обработчиках уловов,которые не ловят по ссылке.С помощью .</target>
        </trans-unit>
        <trans-unit id="5d56df9ae38e57af735866e84e0cdb01862c2396" translate="yes" xml:space="preserve">
          <source>Warn about certain constructs that behave differently in traditional and ISO C. Also warn about ISO C constructs that have no traditional C equivalent, and/or problematic constructs that should be avoided.</source>
          <target state="translated">Предупреждать об определенных конструкциях,которые ведут себя по-разному в традиционных и ИСО С.Также предупреждать о конструкциях ИСО С,которые не имеют традиционного С-эквивалента,и/или проблемных конструкциях,которых следует избегать.</target>
        </trans-unit>
        <trans-unit id="208feed4ba7b2db7b751737e5df71463aa2d59a9" translate="yes" xml:space="preserve">
          <source>Warn about code that may have undefined semantics because of violations of sequence point rules in the C and C++ standards.</source>
          <target state="translated">Предупреждать о коде,который может иметь неопределенную семантику из-за нарушения правил точек следования в стандартах Си и Си++.</target>
        </trans-unit>
        <trans-unit id="120296c8df6378a5551d4a8157d2634bb8869dc7" translate="yes" xml:space="preserve">
          <source>Warn about constructions where there may be confusion to which &lt;code&gt;if&lt;/code&gt; statement an &lt;code&gt;else&lt;/code&gt; branch belongs. Here is an example of such a case:</source>
          <target state="translated">Предупреждать о конструкциях, в которых может возникнуть путаница, к которой принадлежит оператор &lt;code&gt;if&lt;/code&gt; и ветвь &lt;code&gt;else&lt;/code&gt; . Вот пример такого случая:</target>
        </trans-unit>
        <trans-unit id="5a68fb773b2ee57c56ecf208d21e354737b77e2a" translate="yes" xml:space="preserve">
          <source>Warn about conversions between address spaces in the case where the resulting address space is not contained in the incoming address space.</source>
          <target state="translated">Предупреждает о преобразовании между адресными пространствами в том случае,если результирующее адресное пространство не содержится во входящем адресном пространстве.</target>
        </trans-unit>
        <trans-unit id="0761a82a1e056ee411ecf4ae535a9dfad8b30dfc" translate="yes" xml:space="preserve">
          <source>Warn about declarations using the &lt;code&gt;alias&lt;/code&gt; and similar attributes whose target is incompatible with the type of the alias. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;.</source>
          <target state="translated">Предупреждать об объявлениях с использованием &lt;code&gt;alias&lt;/code&gt; и подобных атрибутов, цель которых несовместима с типом псевдонима. См. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Объявление атрибутов функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f643480f69fb1c621533ba0cdd904776e7e1ef4b" translate="yes" xml:space="preserve">
          <source>Warn about duplicated conditions in an if-else-if chain. For instance, warn for the following code:</source>
          <target state="translated">Предупреждаю о дублировании условий в цепочке if-else-if.Например,предупредите о следующем коде:</target>
        </trans-unit>
        <trans-unit id="f7359f7ae633c3c242379554307ef603621fed1e" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C90, but present in ISO C99. For instance, warn about use of variable length arrays, &lt;code&gt;long long&lt;/code&gt; type, &lt;code&gt;bool&lt;/code&gt; type, compound literals, designated initializers, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">Предупредить о функциях, отсутствующих в ISO C90, но присутствующих в ISO C99. Например, предупреждать об использовании массивов переменной длины, типа &lt;code&gt;long long&lt;/code&gt; , типа &lt;code&gt;bool&lt;/code&gt; , составных литералов, назначенных инициализаторов и т. Д. Эта опция не зависит от стандартного режима. Предупреждения отключены в выражении, которое следует за &lt;code&gt;__extension__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="626c854c9715d516c67e89068f1bb76234cf669a" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C99, but present in ISO C11. For instance, warn about use of anonymous structures and unions, &lt;code&gt;_Atomic&lt;/code&gt; type qualifier, &lt;code&gt;_Thread_local&lt;/code&gt; storage-class specifier, &lt;code&gt;_Alignas&lt;/code&gt; specifier, &lt;code&gt;Alignof&lt;/code&gt; operator, &lt;code&gt;_Generic&lt;/code&gt; keyword, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">Предупредить о функциях, отсутствующих в ISO C99, но присутствующих в ISO C11. Например, предупреждать об использовании анонимных структур и объединений, квалификатора типа &lt;code&gt;_Atomic&lt;/code&gt; , &lt;code&gt;_Thread_local&lt;/code&gt; класса хранения &lt;code&gt;_Alignas&lt;/code&gt; спецификатора &lt;code&gt;Alignof&lt;/code&gt; оператора &lt;code&gt;_Generic&lt;/code&gt; ключевого слова _Generic и т. Д. Эта опция не зависит от стандартного режима. Предупреждения отключены в выражении, которое следует за &lt;code&gt;__extension__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="643ea2b6cbf0ea1bcfec495e08e3195164382b91" translate="yes" xml:space="preserve">
          <source>Warn about function pointers that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Note these are only possible candidates, not absolute ones. GCC guesses that function pointers with &lt;code&gt;format&lt;/code&gt; attributes that are used in assignment, initialization, parameter passing or return statements should have a corresponding &lt;code&gt;format&lt;/code&gt; attribute in the resulting type. I.e. the left-hand side of the assignment or initialization, the type of the parameter variable, or the return type of the containing function respectively should also have a &lt;code&gt;format&lt;/code&gt; attribute to avoid the warning.</source>
          <target state="translated">Предупреждать об указателях функций, которые могут быть кандидатами на атрибуты &lt;code&gt;format&lt;/code&gt; . Обратите внимание, что это только возможные кандидаты, а не абсолютные. GCC предполагает, что указатели функций с атрибутами &lt;code&gt;format&lt;/code&gt; , которые используются в операторах присваивания, инициализации, передачи параметров или возврата, должны иметь соответствующий атрибут &lt;code&gt;format&lt;/code&gt; в результирующем типе. Т.е. левая часть присвоения или инициализации, тип переменной параметра или тип возвращаемого значения содержащейся функции, соответственно, также должны иметь атрибут &lt;code&gt;format&lt;/code&gt; чтобы избежать предупреждения.</target>
        </trans-unit>
        <trans-unit id="ff3534585cbc01893459375a2f73a721f1390a46" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for &lt;code&gt;cold&lt;/code&gt; attribute. This is based on static detection and generally will only warn about functions which always leads to a call to another &lt;code&gt;cold&lt;/code&gt; function such as wrappers of C++ &lt;code&gt;throw&lt;/code&gt; or fatal error reporting functions leading to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">Предупреждать о функциях, которые могут быть кандидатами на атрибут &lt;code&gt;cold&lt;/code&gt; . Это основано на статическом обнаружении и обычно предупреждает только о функциях, которые всегда приводят к вызову другой &lt;code&gt;cold&lt;/code&gt; функции, такой как обертки C ++ &lt;code&gt;throw&lt;/code&gt; или функции сообщения о фатальных ошибках, приводящие к &lt;code&gt;abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5773c66378dee79865728b1022e5f1ddb94781" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for attributes &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;noreturn&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt;. The compiler only warns for functions visible in other compilation units or (in the case of &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;) if it cannot prove that the function returns normally. A function returns normally if it doesn&amp;rsquo;t contain an infinite loop or return abnormally by throwing, calling &lt;code&gt;abort&lt;/code&gt; or trapping. This analysis requires option</source>
          <target state="translated">Предупреждать о функциях , которые могут быть кандидатами для атрибутов &lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;noreturn&lt;/code&gt; или &lt;code&gt;malloc&lt;/code&gt; . Компилятор предупреждает только о функциях, видимых в других единицах компиляции или (в случае &lt;code&gt;pure&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; ), если он не может доказать, что функция возвращается нормально. Функция возвращается нормально, если она не содержит бесконечного цикла или ненормально возвращается, бросая, вызывая &lt;code&gt;abort&lt;/code&gt; или захват. Этот анализ требует опции</target>
        </trans-unit>
        <trans-unit id="97272a64aa6772a9d1f50422c6dbb8adfe294518" translate="yes" xml:space="preserve">
          <source>Warn about left shift overflows. This warning is enabled by default in C99 and C++11 modes (and newer).</source>
          <target state="translated">Предупреждаю о переполнении левой смены.Данное предупреждение включено по умолчанию в режимах C99 и C++11 (и более новых).</target>
        </trans-unit>
        <trans-unit id="cab17a3fd72f34df7821e30e584c4c51a37bba48" translate="yes" xml:space="preserve">
          <source>Warn about logical not used on the left hand side operand of a comparison. This option does not warn if the right operand is considered to be a boolean expression. Its purpose is to detect suspicious code like the following:</source>
          <target state="translated">Предупредить о логическом не используется на левой стороне операнд сравнения.Эта опция не предупреждает,если правый операнд считается булевым выражением.Ее целью является обнаружение подозрительного кода,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="48b82c0283a2915829a3ee6a3436cc1017b5ea05" translate="yes" xml:space="preserve">
          <source>Warn about macros defined in the main file that are unused. A macro is &lt;em&gt;used&lt;/em&gt; if it is expanded or tested for existence at least once. The preprocessor also warns if the macro has not been used at the time it is redefined or undefined.</source>
          <target state="translated">Предупреждать о неиспользуемых макросах, определенных в основном файле. Макрос &lt;em&gt;используется,&lt;/em&gt; если он раскрывается или проверяется на наличие хотя бы один раз. Препроцессор также предупреждает, если макрос не использовался во время переопределения или не определен.</target>
        </trans-unit>
        <trans-unit id="b4b8fd61bdb1f1846bd01a97a7bd276155ea4f4c" translate="yes" xml:space="preserve">
          <source>Warn about overriding virtual functions that are not marked with the override keyword.</source>
          <target state="translated">Предупреждать о переопределении виртуальных функций,которые не отмечены ключевым словом переопределения.</target>
        </trans-unit>
        <trans-unit id="b83b9745dc97dfb351a27bd912c00da1a8c7a2f9" translate="yes" xml:space="preserve">
          <source>Warn about passing a null pointer for arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">Предупредить о передаче нулевого указателя для аргументов, отмеченных как требующие &lt;code&gt;nonnull&lt;/code&gt; атрибутом функции, отличным от NULL .</target>
        </trans-unit>
        <trans-unit id="6aa9959edf6bc4922ebb912c9a250384b3090f7c" translate="yes" xml:space="preserve">
          <source>Warn about placement new expressions with undefined behavior, such as constructing an object in a buffer that is smaller than the type of the object. For example, the placement new expression below is diagnosed because it attempts to construct an array of 64 integers in a buffer only 64 bytes large.</source>
          <target state="translated">Предупреждать о размещении новых выражений с неопределенным поведением,например,построение объекта в буфере,который меньше типа объекта.Например,приведенное ниже размещение нового выражения диагностируется,так как оно пытается построить массив из 64 целых чисел в буфере размером всего 64 байта.</target>
        </trans-unit>
        <trans-unit id="185c654029973156a2e707b7e9ffcc02226e09a9" translate="yes" xml:space="preserve">
          <source>Warn about redundant semicolon after in-class function definition.</source>
          <target state="translated">Предупреждайте о избыточной точке с запятой после определения функции в классе.</target>
        </trans-unit>
        <trans-unit id="083bdeb1c857ab3b93f3cbf9b4f7687d0f51ffb4" translate="yes" xml:space="preserve">
          <source>Warn about string constants that are longer than the &amp;ldquo;minimum maximum&amp;rdquo; length specified in the C standard. Modern compilers generally allow string constants that are much longer than the standard&amp;rsquo;s minimum limit, but very portable programs should avoid using longer strings.</source>
          <target state="translated">Предупреждать о строковых константах, длина которых превышает &amp;laquo;минимальную максимальную&amp;raquo; длину, указанную в стандарте C. Современные компиляторы обычно допускают строковые константы, которые намного длиннее минимального предела стандарта, но очень переносимые программы должны избегать использования более длинных строк.</target>
        </trans-unit>
        <trans-unit id="e453618f3508cc5c8f222f7ad7869db1fe428a6f" translate="yes" xml:space="preserve">
          <source>Warn about suspicious operations on expressions of a boolean type. For instance, bitwise negation of a boolean is very likely a bug in the program. For C, this warning also warns about incrementing or decrementing a boolean, which rarely makes sense. (In C++, decrementing a boolean is always invalid. Incrementing a boolean is invalid in C++17, and deprecated otherwise.)</source>
          <target state="translated">Предупреждать о подозрительных операциях на выражениях булевого типа.Например,битовое отрицание булева типа очень вероятно является ошибкой в программе.Для C это предупреждение также предупреждает об инкременте или декременте булева,что редко имеет смысл.(В Си++декремент булева всегда недействителен.В Си++17 инкремент булева недействителен,а в противном случае он недействителен).</target>
        </trans-unit>
        <trans-unit id="2336eb6d6105fde77f9d067a2cdcc81228032540" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of logical operators in expressions. This includes using logical operators in contexts where a bit-wise operator is likely to be expected. Also warns when the operands of a logical operator are the same:</source>
          <target state="translated">Предупреждать о подозрительном использовании логических операторов в выражениях.Это включает в себя использование логических операторов в контекстах,где,скорее всего,ожидается битовый оператор.Также предупреждает,когда операндов логического оператора одно и то же:</target>
        </trans-unit>
        <trans-unit id="47cf408f4ecd083d50c4f6fada7dd8bdd9b93bb0" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of memory addresses. These include using the address of a function in a conditional expression, such as &lt;code&gt;void func(void); if (func)&lt;/code&gt;, and comparisons against the memory address of a string literal, such as &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt;. Such uses typically indicate a programmer error: the address of a function always evaluates to true, so their use in a conditional usually indicate that the programmer forgot the parentheses in a function call; and comparisons against string literals result in unspecified behavior and are not portable in C, so they usually indicate that the programmer intended to use &lt;code&gt;strcmp&lt;/code&gt;. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительном использовании адресов памяти. К ним относятся использование адреса функции в условном выражении, например &lt;code&gt;void func(void); if (func)&lt;/code&gt; и сравнения с адресом памяти строкового литерала, например &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt; . Такое использование обычно указывает на ошибку программиста: адрес функции всегда принимает значение true, поэтому их использование в условном выражении обычно указывает на то, что программист забыл круглые скобки в вызове функции; а сравнения со строковыми литералами приводят к неопределенному поведению и не переносятся в C, поэтому обычно указывают, что программист намеревался использовать &lt;code&gt;strcmp&lt;/code&gt; . Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="693b5ffe72b40cbff2e2c2d99e95d2c139392a00" translate="yes" xml:space="preserve">
          <source>Warn about the use of an uncasted &lt;code&gt;NULL&lt;/code&gt; as sentinel. When compiling only with GCC this is a valid sentinel, as &lt;code&gt;NULL&lt;/code&gt; is defined to &lt;code&gt;__null&lt;/code&gt;. Although it is a null pointer constant rather than a null pointer, it is guaranteed to be of the same size as a pointer. But this use is not portable across different compilers.</source>
          <target state="translated">Предупредить об использовании в качестве контрольного значения &lt;code&gt;NULL&lt;/code&gt; без преобразования . При компиляции только с GCC это действительный дозорный, поскольку &lt;code&gt;NULL&lt;/code&gt; определен как &lt;code&gt;__null&lt;/code&gt; . Хотя это константа нулевого указателя, а не нулевой указатель, гарантированно будет такого же размера, что и указатель. Но это использование не переносимо между разными компиляторами.</target>
        </trans-unit>
        <trans-unit id="047e09655cbc00205404926996b3c4d4165e9649" translate="yes" xml:space="preserve">
          <source>Warn about trampolines generated for pointers to nested functions. A trampoline is a small piece of data or code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. For some targets, it is made up of data only and thus requires no special treatment. But, for most targets, it is made up of code and thus requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">Предупреждайте о батутах,генерируемых для указателей на вложенные функции.Батут-это небольшой кусок данных или кода,который создаётся во время выполнения на стеке,когда берется адрес вложенной функции,и используется для косвенного вызова вложенной функции.Для некоторых целей он состоит только из данных и не требует специальной обработки.Но для большинства целей он состоит из кода и,таким образом,требует,чтобы стек был исполняемым,чтобы программа корректно работала.</target>
        </trans-unit>
        <trans-unit id="038f9bc926635b6b8fb6c2afe2d9bffe1c8b0f31" translate="yes" xml:space="preserve">
          <source>Warn about types with virtual methods where code quality would be improved if the type were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, declared in an anonymous namespace. This allows GCC to more aggressively devirtualize the polymorphic calls. This warning is more effective with link time optimization, where the information about the class hierarchy graph is more complete.</source>
          <target state="translated">Предупреждать о типах с виртуальными методами, в которых качество кода могло бы быть улучшено, если бы тип был объявлен с помощью спецификатора C ++ 11 &lt;code&gt;final&lt;/code&gt; или, если возможно, объявлен в анонимном пространстве имен. Это позволяет GCC более агрессивно девиртуализировать полиморфные вызовы. Это предупреждение более эффективно при оптимизации времени компоновки, когда информация о графе иерархии классов более полная.</target>
        </trans-unit>
        <trans-unit id="ebb96b1bde565bfb0748c8483dc57189a3190e4d" translate="yes" xml:space="preserve">
          <source>Warn about uninitialized variables that are initialized with themselves. Note this option can only be used with the</source>
          <target state="translated">Предупреждать об неинициализированных переменных,которые инициализируются сами собой.Обратите внимание,что эта опция может быть использована только с</target>
        </trans-unit>
        <trans-unit id="3e4a4254c8cb8b052f1898488cd3d24c1bac24c2" translate="yes" xml:space="preserve">
          <source>Warn about unsafe multiple statement macros that appear to be guarded by a clause such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, or &lt;code&gt;while&lt;/code&gt;, in which only the first statement is actually guarded after the macro is expanded.</source>
          <target state="translated">Предупреждать о небезопасных макросах с несколькими операторами, которые кажутся защищенными таким предложением, как &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; или &lt;code&gt;while&lt;/code&gt; , в котором только первый оператор фактически защищен после раскрытия макроса.</target>
        </trans-unit>
        <trans-unit id="c815119ab8450282a6819d07553d786431d0bc98" translate="yes" xml:space="preserve">
          <source>Warn about violations of the following style guidelines from Scott Meyers&amp;rsquo; Effective C++ series of books:</source>
          <target state="translated">Предупреждайте о нарушениях следующих рекомендаций по стилю из серии книг Скотта Мейерса по эффективному C ++:</target>
        </trans-unit>
        <trans-unit id="44cda8e3e380e8f31dd971fc6b0f31b237513dcc" translate="yes" xml:space="preserve">
          <source>Warn about virtual methods where code quality would be improved if the method were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, its type were declared in an anonymous namespace or with the &lt;code&gt;final&lt;/code&gt; specifier. This warning is more effective with link-time optimization, where the information about the class hierarchy graph is more complete. It is recommended to first consider suggestions of</source>
          <target state="translated">Предупреждать о виртуальных методах, где качество кода могло бы быть улучшено, если бы метод был объявлен с помощью спецификатора &lt;code&gt;final&lt;/code&gt; C ++ 11 или, если возможно, его тип был объявлен в анонимном пространстве имен или с помощью спецификатора &lt;code&gt;final&lt;/code&gt; . Это предупреждение более эффективно при оптимизации времени компоновки, когда информация о графе иерархии классов более полная. Рекомендуется в первую очередь рассмотреть предложения</target>
        </trans-unit>
        <trans-unit id="be3e052e75298edad5e44ae2d0677574dff86d7c" translate="yes" xml:space="preserve">
          <source>Warn for calls to bounded string manipulation functions such as &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, and &lt;code&gt;stpncpy&lt;/code&gt; that may either truncate the copied string or leave the destination unchanged.</source>
          <target state="translated">Предупреждать о вызовах функций обработки ограниченной строки, таких как &lt;code&gt;strncat&lt;/code&gt; , &lt;code&gt;strncpy&lt;/code&gt; и &lt;code&gt;stpncpy&lt;/code&gt; , которые могут либо усечь скопированную строку, либо оставить место назначения без изменений.</target>
        </trans-unit>
        <trans-unit id="97f52c63875e1d71f753bc97c51fe3992eac28f3" translate="yes" xml:space="preserve">
          <source>Warn for calls to standard functions that compute the absolute value of an argument when a more appropriate standard function is available. For example, calling &lt;code&gt;abs(3.14)&lt;/code&gt; triggers the warning because the appropriate function to call to compute the absolute value of a double argument is &lt;code&gt;fabs&lt;/code&gt;. The option also triggers warnings when the argument in a call to such a function has an unsigned type. This warning can be suppressed with an explicit type cast and it is also enabled by</source>
          <target state="translated">Предупреждать о вызовах стандартных функций, которые вычисляют абсолютное значение аргумента, когда доступна более подходящая стандартная функция. Например, вызов &lt;code&gt;abs(3.14)&lt;/code&gt; вызывает предупреждение, потому что соответствующая функция, вызываемая для вычисления абсолютного значения двойного аргумента, - это &lt;code&gt;fabs&lt;/code&gt; . Эта опция также вызывает предупреждения, когда аргумент в вызове такой функции имеет беззнаковый тип. Это предупреждение можно подавить с помощью явного приведения типа, и оно также включается</target>
        </trans-unit>
        <trans-unit id="c5733f483a0e2d12a12ef399d58192ff21069495" translate="yes" xml:space="preserve">
          <source>Warn for calls to string manipulation functions such as &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;strcpy&lt;/code&gt; that are determined to overflow the destination buffer. The optional argument is one greater than the type of Object Size Checking to perform to determine the size of the destination. See &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Object Size Checking&lt;/a&gt;. The argument is meaningful only for functions that operate on character arrays but not for raw memory functions like &lt;code&gt;memcpy&lt;/code&gt; which always make use of Object Size type-0. The option also warns for calls that specify a size in excess of the largest possible object or at most &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; bytes. The option produces the best results with optimization enabled but can detect a small subset of simple buffer overflows even without optimization in calls to the GCC built-in functions like &lt;code&gt;__builtin_memcpy&lt;/code&gt; that correspond to the standard functions. In any case, the option warns about just a subset of buffer overflows detected by the corresponding overflow checking built-ins. For example, the option will issue a warning for the &lt;code&gt;strcpy&lt;/code&gt; call below because it copies at least 5 characters (the string &lt;code&gt;&quot;blue&quot;&lt;/code&gt; including the terminating NUL) into the buffer of size 4.</source>
          <target state="translated">Предупреждать о вызовах функций обработки строк, таких как &lt;code&gt;memcpy&lt;/code&gt; и &lt;code&gt;strcpy&lt;/code&gt; , которые определены как переполнение целевого буфера. Необязательный аргумент на единицу больше, чем тип проверки размера объекта, выполняемой для определения размера места назначения. См. &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Проверка размера объекта&lt;/a&gt; . Аргумент имеет смысл только для функций, которые работают с массивами символов, но не для функций необработанной памяти, таких как &lt;code&gt;memcpy&lt;/code&gt; , которые всегда используют тип 0 размера объекта. Эта опция также предупреждает о вызовах, в которых указан размер, превышающий максимально возможный объект или не более &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; байт. Этот параметр дает наилучшие результаты при включенной оптимизации, но может обнаруживать небольшое подмножество простых переполнений буфера даже без оптимизации при вызовах встроенных функций GCC, таких как &lt;code&gt;__builtin_memcpy&lt;/code&gt; , которые соответствуют стандартным функциям. В любом случае эта опция предупреждает только о подмножестве переполнений буфера, обнаруженных соответствующими встроенными модулями проверки переполнения. Например, опция выдаст предупреждение для приведенного ниже вызова &lt;code&gt;strcpy&lt;/code&gt; , потому что он копирует не менее 5 символов (строка &lt;code&gt;&quot;blue&quot;&lt;/code&gt; включая завершающий NUL) в буфер размером 4.</target>
        </trans-unit>
        <trans-unit id="ea89d9fe51cb214a220766e4af0abed7f830d316" translate="yes" xml:space="preserve">
          <source>Warn for cases where adding an attribute may be beneficial. The attributes currently supported are listed below.</source>
          <target state="translated">Предупреждение для случаев,когда добавление атрибута может быть полезным.Поддерживаемые в настоящее время атрибуты перечислены ниже.</target>
        </trans-unit>
        <trans-unit id="8436e41e82368d15262acc8884e5704ddb1ce7dc" translate="yes" xml:space="preserve">
          <source>Warn for conditionally-supported (C++11 [intro.defs]) constructs.</source>
          <target state="translated">Предупреждение для условно поддерживаемых (C++11 [intro.defs])конструкций.</target>
        </trans-unit>
        <trans-unit id="ddd0db7c59c0ac572b0cd3ff62ca85c741d9e547" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may alter a value. This includes conversions between real and integer, like &lt;code&gt;abs (x)&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;; conversions between signed and unsigned, like &lt;code&gt;unsigned ui = -1&lt;/code&gt;; and conversions to smaller types, like &lt;code&gt;sqrtf (M_PI)&lt;/code&gt;. Do not warn for explicit casts like &lt;code&gt;abs
((int) x)&lt;/code&gt; and &lt;code&gt;ui = (unsigned) -1&lt;/code&gt;, or if the value is not changed by the conversion like in &lt;code&gt;abs (2.0)&lt;/code&gt;. Warnings about conversions between signed and unsigned integers can be disabled by using</source>
          <target state="translated">Предупреждать о неявных преобразованиях, которые могут изменить значение. Это включает преобразование между действительным и целым числом, например, &lt;code&gt;abs (x)&lt;/code&gt; , когда &lt;code&gt;x&lt;/code&gt; равно &lt;code&gt;double&lt;/code&gt; ; преобразования между знаком и без знака, например, &lt;code&gt;unsigned ui = -1&lt;/code&gt; ; и преобразование в более мелкие типы, например &lt;code&gt;sqrtf (M_PI)&lt;/code&gt; . Не предупреждать о явных приведениях, таких как &lt;code&gt;abs ((int) x)&lt;/code&gt; и &lt;code&gt;ui = (unsigned) -1&lt;/code&gt; , или если значение не изменяется в результате преобразования, как в &lt;code&gt;abs (2.0)&lt;/code&gt; . Предупреждения о преобразованиях между целыми числами со знаком и без знака можно отключить с помощью</target>
        </trans-unit>
        <trans-unit id="ec1638cbd7bdbbe5cf0d16d8253b596c446311e3" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may change the sign of an integer value, like assigning a signed integer expression to an unsigned integer variable. An explicit cast silences the warning. In C, this option is enabled also by</source>
          <target state="translated">Предупреждать о неявных превращениях,которые могут изменить знак целочисленного значения,например,присваивание знакового целого выражения беззнаковой целочисленной переменной.Явное приведение замалчивает предупреждение.В языке C эта опция также включается с помощью</target>
        </trans-unit>
        <trans-unit id="97be0057bd1773b0bcfe31a7fd58f64b07846102" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that reduce the precision of a real value. This includes conversions from real to integer, and from higher precision real to lower precision real values. This option is also enabled by</source>
          <target state="translated">Предупреждайте за неявные преобразования,которые снижают точность реального значения.Это включает в себя преобразования из вещественного в целое,а также из вещественного с большей точностью в вещественное с меньшей точностью.Эта опция также включается при помощи</target>
        </trans-unit>
        <trans-unit id="fba779234a6e85d8e28133f5b96c546a4b460be1" translate="yes" xml:space="preserve">
          <source>Warn for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</source>
          <target state="translated">Предупреждать о &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;вызовах __atomic Builtins&lt;/a&gt; , &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt; и атомарных универсальных функций C11 с аргументом согласованности памяти, который либо недопустим для операции, либо выходит за пределы диапазона значений перечисления &lt;code&gt;memory_order&lt;/code&gt; . Например, поскольку встроенные модули &lt;code&gt;__atomic_store&lt;/code&gt; и &lt;code&gt;__atomic_store_n&lt;/code&gt; определены только для ослабленных, освобожденных и последовательно согласованных порядков памяти, диагностируется следующий код:</target>
        </trans-unit>
        <trans-unit id="588f265a9e502d85c1dc2042e355d13326591d0f" translate="yes" xml:space="preserve">
          <source>Warn for obsolescent usages, according to the C Standard, in a declaration. For example, warn if storage-class specifiers like &lt;code&gt;static&lt;/code&gt; are not the first things in a declaration. This warning is also enabled by</source>
          <target state="translated">Предупреждать об устаревшем использовании в соответствии со стандартом C. Например, предупредите, если спецификаторы класса хранения, такие как &lt;code&gt;static&lt;/code&gt; , не являются первыми в объявлении. Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="e259b4649f2c39d620aa79263dfa4900b1e91328" translate="yes" xml:space="preserve">
          <source>Warn for pointer argument passing or assignment with different signedness. This option is only supported for C and Objective-C. It is implied by</source>
          <target state="translated">Предупреждение о передаче аргумента указателя или присваивании с различной подписью.Эта опция поддерживается только для C и Objective-C.Это подразумевается</target>
        </trans-unit>
        <trans-unit id="9ff91ea12bc4958bf94b9d94062e90a35c47ff2b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function where the second argument is not zero and the third argument is zero. For example, the call &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; is diagnosed because &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; was meant instead. The diagnostic is only emitted if the third argument is a literal zero. Otherwise, if it is an expression that is folded to zero, or a cast of zero to some type, it is far less likely that the arguments have been mistakenly transposed and no warning is emitted. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительных вызовах встроенной функции &lt;code&gt;memset&lt;/code&gt; , когда второй аргумент не равен нулю, а третий аргумент равен нулю. Например, вызов &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; диагностируется, потому что вместо него имелось в виду &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; . Диагностическое сообщение выдается только в том случае, если третий аргумент равен нулю. В противном случае, если это выражение, свернутое до нуля, или приведение нуля к какому-либо типу, гораздо менее вероятно, что аргументы были ошибочно транспонированы и предупреждение не выдается. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="bc6dbae9a566682d74e9a96f0ac749b8042dc5bb" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function, if the first argument references an array, and the third argument is a number equal to the number of elements, but not equal to the size of the array in memory. This indicates that the user has omitted a multiplication by the element size. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительных вызовах встроенной функции &lt;code&gt;memset&lt;/code&gt; , если первый аргумент ссылается на массив, а третий аргумент является числом, равным количеству элементов, но не равным размеру массива в памяти. Это означает, что пользователь пропустил умножение на размер элемента. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="d71f136265b6596c9fcf21bacafb65164bba32b6" translate="yes" xml:space="preserve">
          <source>Warn for suspicious divisions of two sizeof expressions that divide the pointer size by the element size, which is the usual way to compute the array size but won&amp;rsquo;t work out correctly with pointers. This warning warns e.g. about &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительных делениях двух выражений sizeof, которые делят размер указателя на размер элемента, что является обычным способом вычисления размера массива, но не работает правильно с указателями. Это предупреждение предупреждает, например, о &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; если &lt;code&gt;ptr&lt;/code&gt; не массив, а указатель. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="eb46193b49397250439f9bab61fa46107f1cb89b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious length parameters to certain string and memory built-in functions if the argument uses &lt;code&gt;sizeof&lt;/code&gt;. This warning triggers for example for &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer, and suggests a possible fix, or about &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt;.</source>
          <target state="translated">Предупреждать о параметрах подозрительной длины для определенных строковых и встроенных функций памяти, если аргумент использует &lt;code&gt;sizeof&lt;/code&gt; . Это предупреждение срабатывает, например, для &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; если &lt;code&gt;ptr&lt;/code&gt; - не массив, а указатель и предлагает возможное исправление, или о &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="474691b4f69f5e3fa5e5d8572e94d30c04b806ca" translate="yes" xml:space="preserve">
          <source>Warn for suspicious use of integer values where boolean values are expected, such as conditional expressions (?:) using non-boolean integer constants in boolean context, like &lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt;. Or left shifting of signed integers in boolean context, like &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt;. Likewise for all kinds of multiplications regardless of the data type. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительном использовании целочисленных значений, где ожидаются логические значения, например условных выражений (? :) с использованием небулевых целочисленных констант в логическом контексте, например &lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt; . Или сдвиг влево целых чисел со знаком в логическом контексте, например &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt; , То же самое для всех видов умножения независимо от типа данных. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="ef3f0d67d9be730bb5bb60eec12cdf29a3590cd3" translate="yes" xml:space="preserve">
          <source>Warn for variables that might be changed by &lt;code&gt;longjmp&lt;/code&gt; or &lt;code&gt;vfork&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">Предупреждать о переменных, которые могут быть изменены &lt;code&gt;longjmp&lt;/code&gt; или &lt;code&gt;vfork&lt;/code&gt; . Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="dd2e7578a65337ecde9cfa288e81a35cf44426a6" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;long long&lt;/code&gt; type is used. This is enabled by either</source>
          <target state="translated">Предупреждать, если используется &lt;code&gt;long long&lt;/code&gt; шрифт. Это обеспечивается либо</target>
        </trans-unit>
        <trans-unit id="e19f1630667f871b7fea15d47a722bf79ecb0d1d" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, either explicitly in an &lt;code&gt;@interface&lt;/code&gt; or &lt;code&gt;@protocol&lt;/code&gt; declaration, or implicitly in an &lt;code&gt;@implementation&lt;/code&gt; section. This option always performs its checks as soon as a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression is found, while</source>
          <target state="translated">Предупреждать, если &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; выражение @selector (&amp;hellip;), относящееся к необъявленному селектору. Селектор считаются необъявленным , если ни один метод с таким именем не был объявлен до &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; выражения, либо в явном виде в &lt;code&gt;@interface&lt;/code&gt; или &lt;code&gt;@protocol&lt;/code&gt; декларации, или неявно в &lt;code&gt;@implementation&lt;/code&gt; разделе. Эта опция всегда выполняет свои проверки, как только будет найдено выражение &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; , а</target>
        </trans-unit>
        <trans-unit id="004d33c975e481dfebbcb509835b3167b8da9eba" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;goto&lt;/code&gt; statement or a &lt;code&gt;switch&lt;/code&gt; statement jumps forward across the initialization of a variable, or jumps backward to a label after the variable has been initialized. This only warns about variables that are initialized when they are declared. This warning is only supported for C and Objective-C; in C++ this sort of branch is an error in any case.</source>
          <target state="translated">Предупреждать, если &lt;code&gt;goto&lt;/code&gt; или оператор &lt;code&gt;switch&lt;/code&gt; перескакивает вперед через инициализацию переменной или перескакивает назад к метке после инициализации переменной. Это только предупреждает о переменных, которые инициализируются при объявлении. Это предупреждение поддерживается только для C и Objective-C; в C ++ такая ветвь в любом случае является ошибкой.</target>
        </trans-unit>
        <trans-unit id="70a205e11ff52468e2abea9748f0e8471729efe0" translate="yes" xml:space="preserve">
          <source>Warn if a built-in function is declared with an incompatible signature or as a non-function, or when a built-in function declared with a type that does not include a prototype is called with arguments whose promoted types do not match those expected by the function. When</source>
          <target state="translated">Предупреждать,если встроенная функция объявлена с несовместимой сигнатурой или как нефункция,или если встроенная функция,объявленная с типом,не включающим прототип,вызывается с аргументами,чьи продвигаемые типы не соответствуют ожидаемым функцией.Когда .</target>
        </trans-unit>
        <trans-unit id="7e0b0c17d1b6ef946e72a0839cb1ce3047e47301" translate="yes" xml:space="preserve">
          <source>Warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage. If a type A depends on a type B with no or internal linkage, defining it in multiple translation units would be an ODR violation because the meaning of B is different in each translation unit. If A only appears in a single translation unit, the best way to silence the warning is to give it internal linkage by putting it in an anonymous namespace as well. The compiler doesn&amp;rsquo;t give this warning for types defined in the main .C file, as those are unlikely to have multiple definitions.</source>
          <target state="translated">Предупреждать, если тип класса имеет базу или поле, тип которого использует анонимное пространство имен или зависит от типа без связи. Если тип A зависит от типа B, не имеющего внутренней связи или не имеющего внутренней связи, определение его в нескольких единицах трансляции будет нарушением ODR, поскольку значение B отличается в каждой единице трансляции. Если A появляется только в одной единице перевода, лучший способ заглушить предупреждение - это дать ему внутреннюю ссылку, поместив его также в анонимное пространство имен. Компилятор не выдает это предупреждение для типов, определенных в основном файле .C, поскольку они вряд ли будут иметь несколько определений.</target>
        </trans-unit>
        <trans-unit id="f50d7f18228e548a744dc4a11054b6259740a50d" translate="yes" xml:space="preserve">
          <source>Warn if a comparison is always true or always false due to the limited range of the data type, but do not warn for constant expressions. For example, warn if an unsigned variable is compared against zero with &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">Предупреждать, если сравнение всегда верно или всегда ложно из-за ограниченного диапазона типа данных, но не предупреждать о постоянных выражениях. Например, предупредить, если беззнаковая переменная сравнивается с нулем с помощью &lt;code&gt;&amp;lt;&lt;/code&gt; или &lt;code&gt;&amp;gt;=&lt;/code&gt; . Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="2a11d0f858be1c6e9bc24aa3b844f38a2b441160" translate="yes" xml:space="preserve">
          <source>Warn if a declaration has duplicate &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restrict&lt;/code&gt; or &lt;code&gt;_Atomic&lt;/code&gt; specifier. This warning is enabled by</source>
          <target state="translated">Предупреждать, если в объявлении есть повторяющиеся спецификаторы &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; , &lt;code&gt;restrict&lt;/code&gt; или &lt;code&gt;_Atomic&lt;/code&gt; . Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="435844d61c42ac3708481fd4e2d3779e1e2c4fcb" translate="yes" xml:space="preserve">
          <source>Warn if a function is declared or defined without specifying the argument types. (An old-style function definition is permitted without a warning if preceded by a declaration that specifies the argument types.)</source>
          <target state="translated">Предупреждать,если функция объявлена или определена без указания типов аргументов.(Определение функции по старому стилю допускается без предупреждения,если ему предшествует объявление,в котором указываются типы аргументов).</target>
        </trans-unit>
        <trans-unit id="a760172e23a18bb5477be698491bcdf520546606" translate="yes" xml:space="preserve">
          <source>Warn if a function that is declared as inline cannot be inlined. Even with this option, the compiler does not warn about failures to inline functions declared in system headers.</source>
          <target state="translated">Предупреждать,если функция,объявленная как inline,не может быть включена.Даже при такой опции компилятор не предупреждает о сбоях встроенных функций,объявленных в системных заголовках.</target>
        </trans-unit>
        <trans-unit id="8022445f9b194569635957ab8997ae493df541b3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous declaration. Do so even if the definition itself provides a prototype. Use this option to detect global functions that are not declared in header files. In C, no warnings are issued for functions with previous non-prototype declarations; use</source>
          <target state="translated">Предупреждать,если глобальная функция определена без предыдущего объявления.Делайте это,даже если само определение предоставляет прототип.Использовать эту опцию для обнаружения глобальных функций,которые не объявлены в заголовочных файлах.В C предупреждение не выдается для функций с предыдущим непрототипным объявлением;использовать</target>
        </trans-unit>
        <trans-unit id="8accbb9b2caefa3a198b26af7aaf7ecef01e8cb3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous prototype declaration. This warning is issued even if the definition itself provides a prototype. Use this option to detect global functions that do not have a matching prototype declaration in a header file. This option is not valid for C++ because all function declarations provide prototypes and a non-matching declaration declares an overload rather than conflict with an earlier declaration. Use</source>
          <target state="translated">Предупреждать,если глобальная функция определена без предыдущего объявления прототипа.Это предупреждение выдается,даже если само определение предоставляет прототип.Используйте эту опцию для обнаружения глобальных функций,которые не имеют соответствующего объявления прототипа в заголовочном файле.Эта опция не действительна для C++,так как все объявления функций предоставляют прототипы,а несовпадающее объявление декларирует перегрузку,а не конфликт с более ранним объявлением.Использовать .</target>
        </trans-unit>
        <trans-unit id="158841ec1502166264ebd7700487b8265d3a7024" translate="yes" xml:space="preserve">
          <source>Warn if a pointer is compared with a zero character constant. This usually means that the pointer was meant to be dereferenced. For example:</source>
          <target state="translated">Предупредить,если указатель сравнивается с нулевой символьной константой.Обычно это означает,что указатель должен быть разыменован.Например:</target>
        </trans-unit>
        <trans-unit id="cc6737ba51245ef04a02acb681eeef00c75f1a8a" translate="yes" xml:space="preserve">
          <source>Warn if a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) is found in the search path but cannot be used.</source>
          <target state="translated">Предупреждать, если предварительно скомпилированный заголовок (см. &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Предварительно скомпилированные заголовки&lt;/a&gt; ) найден в пути поиска, но не может быть использован.</target>
        </trans-unit>
        <trans-unit id="0939e5ffcf8a00c23be50c55ee10373ce78e992e" translate="yes" xml:space="preserve">
          <source>Warn if a prototype causes a type conversion that is different from what would happen to the same argument in the absence of a prototype. This includes conversions of fixed point to floating and vice versa, and conversions changing the width or signedness of a fixed-point argument except when the same as the default promotion.</source>
          <target state="translated">Предупредить,если прототип вызывает приведение типа,отличное от того,что случилось бы с тем же аргументом при отсутствии прототипа.Это включает в себя приведение фиксированной точки к плавающей и наоборот,а также приведение,изменяющее ширину или подпись аргумента с фиксированной точкой,за исключением случаев,когда оно совпадает с прототипом по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f0026b1975a3aa571d75e5560f23067faee1ed8d" translate="yes" xml:space="preserve">
          <source>Warn if a register variable is declared volatile. The volatile modifier does not inhibit all optimizations that may eliminate reads and/or writes to register variables. This warning is enabled by</source>
          <target state="translated">Предупреждать,если переменная регистра объявлена волатильной.Модификатор volatile не запрещает все оптимизации,которые могут устранить чтение и/или запись в регистровые переменные.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="3798bc740d5ed1fe194f654e04bcdb3d1c47efb1" translate="yes" xml:space="preserve">
          <source>Warn if a requested optimization pass is disabled. This warning does not generally indicate that there is anything wrong with your code; it merely indicates that GCC&amp;rsquo;s optimizers are unable to handle the code effectively. Often, the problem is that your code is too big or too complex; GCC refuses to optimize programs when the optimization itself is likely to take inordinate amounts of time.</source>
          <target state="translated">Предупреждать, если запрошенный проход оптимизации отключен. Это предупреждение обычно не означает, что с вашим кодом что-то не так; это просто указывает на то, что оптимизаторы GCC не могут эффективно обрабатывать код. Часто проблема в том, что ваш код слишком большой или слишком сложный; GCC отказывается оптимизировать программы, когда сама оптимизация может занять чрезмерно много времени.</target>
        </trans-unit>
        <trans-unit id="13c5db18900b8a64496f744ccfd5e2648bd6cc79" translate="yes" xml:space="preserve">
          <source>Warn if a self-comparison always evaluates to true or false. This warning detects various mistakes such as:</source>
          <target state="translated">Предупреждайте,если самосравнение всегда оценивается как истинное или ложное.Это предупреждение обнаруживает различные ошибки,например:</target>
        </trans-unit>
        <trans-unit id="3ddcbce9d2796dc0f4331ea0e609fc2579e95907" translate="yes" xml:space="preserve">
          <source>Warn if a structure field with explicitly specified alignment in a packed struct or union is misaligned. For example, a warning will be issued on &lt;code&gt;struct S&lt;/code&gt;, like, &lt;code&gt;warning: alignment 1 of
'struct S' is less than 8&lt;/code&gt;, in this code:</source>
          <target state="translated">Предупреждать, если поле структуры с явно указанным выравниванием в упакованной структуре или объединении не выровнено. Например, для &lt;code&gt;struct S&lt;/code&gt; будет выдано предупреждение , например, &lt;code&gt;warning: alignment 1 of 'struct S' is less than 8&lt;/code&gt; в этом коде:</target>
        </trans-unit>
        <trans-unit id="4090da0abd58db5d6b3c1df786fa78fbd44ccb0c" translate="yes" xml:space="preserve">
          <source>Warn if a structure is given the packed attribute, but the packed attribute has no effect on the layout or size of the structure. Such structures may be mis-aligned for little benefit. For instance, in this code, the variable &lt;code&gt;f.x&lt;/code&gt; in &lt;code&gt;struct bar&lt;/code&gt; is misaligned even though &lt;code&gt;struct bar&lt;/code&gt; does not itself have the packed attribute:</source>
          <target state="translated">Предупреждать, если структуре задан упакованный атрибут, но упакованный атрибут не влияет на макет или размер структуры. Такие структуры могут быть неправильно выровнены с небольшой выгодой. Например, в этом коде переменная &lt;code&gt;f.x&lt;/code&gt; в &lt;code&gt;struct bar&lt;/code&gt; смещена, хотя сама &lt;code&gt;struct bar&lt;/code&gt; не имеет упакованного атрибута:</target>
        </trans-unit>
        <trans-unit id="25445489d5b31008c73b432793637e0936c19aa4" translate="yes" xml:space="preserve">
          <source>Warn if a structure&amp;rsquo;s initializer has some fields missing. For example, the following code causes such a warning, because &lt;code&gt;x.h&lt;/code&gt; is implicitly zero:</source>
          <target state="translated">Предупреждать, если в инициализаторе структуры отсутствуют некоторые поля. Например, следующий код вызывает такое предупреждение, потому что &lt;code&gt;x.h&lt;/code&gt; неявно равен нулю:</target>
        </trans-unit>
        <trans-unit id="ff8391aca57a7124434de4ac423b8ea2b9835ac5" translate="yes" xml:space="preserve">
          <source>Warn if a user-supplied include directory does not exist.</source>
          <target state="translated">Предупреждайте,если пользовательский каталог include не существует.</target>
        </trans-unit>
        <trans-unit id="3fc14a4903f34179ede0f1ca4ae1ec5c8d1b70b1" translate="yes" xml:space="preserve">
          <source>Warn if a variable-length array is used in the code.</source>
          <target state="translated">Предупредить,если в коде используется массив переменной длины.</target>
        </trans-unit>
        <trans-unit id="36f8e0d2c860d788d014b0fd6079fd78b6555ede" translate="yes" xml:space="preserve">
          <source>Warn if an &lt;code&gt;extern&lt;/code&gt; declaration is encountered within a function.</source>
          <target state="translated">Предупреждать, если в функции встречается объявление &lt;code&gt;extern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a938c70ebc261d86f7b298216ca1b2a1c719c46" translate="yes" xml:space="preserve">
          <source>Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for &lt;code&gt;a&lt;/code&gt; is not fully bracketed, but that for &lt;code&gt;b&lt;/code&gt; is fully bracketed. This warning is enabled by</source>
          <target state="translated">Предупреждать, если инициализатор агрегата или объединения не полностью заключен в квадратные скобки. В следующем примере инициализатор для &lt;code&gt;a&lt;/code&gt; не полностью заключен в квадратные скобки, но для &lt;code&gt;b&lt;/code&gt; полностью заключен в квадратные скобки. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="13b8026e8132cdf11c73019d5520d0d0def0ca31" translate="yes" xml:space="preserve">
          <source>Warn if an array subscript has type &lt;code&gt;char&lt;/code&gt;. This is a common cause of error, as programmers often forget that this type is signed on some machines. This warning is enabled by</source>
          <target state="translated">Предупреждать, если индекс массива имеет тип &lt;code&gt;char&lt;/code&gt; . Это частая причина ошибок, поскольку программисты часто забывают, что этот тип подписан на некоторых машинах. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="4eadd49680011e5fcccbd2afb576905c49ae4f6b" translate="yes" xml:space="preserve">
          <source>Warn if an automatic variable is used without first being initialized or if a variable may be clobbered by a &lt;code&gt;setjmp&lt;/code&gt; call. In C++, warn if a non-static reference or non-static &lt;code&gt;const&lt;/code&gt; member appears in a class without constructors.</source>
          <target state="translated">Предупреждать, если автоматическая переменная используется без предварительной инициализации или если переменная может быть заблокирована вызовом &lt;code&gt;setjmp&lt;/code&gt; . В C ++ предупреждать, если нестатическая ссылка или нестатический &lt;code&gt;const&lt;/code&gt; член появляется в классе без конструкторов.</target>
        </trans-unit>
        <trans-unit id="dc1ee512cf2decbbe83cea7bedf87603b46e0326" translate="yes" xml:space="preserve">
          <source>Warn if an empty body occurs in an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; or &lt;code&gt;do
while&lt;/code&gt; statement. This warning is also enabled by</source>
          <target state="translated">Предупреждать, если в операторе &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; или &lt;code&gt;do while&lt;/code&gt; встречается пустое тело . Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="383fdc3973b7b5cc3531ea392827d8edfbd6eb85" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field with side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;). This warning is enabled by default.</source>
          <target state="translated">Предупреждать, если инициализированное поле с побочными эффектами отменяется при использовании назначенных инициализаторов (см. &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Назначенные инициализаторы&lt;/a&gt; ). Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fdf68e08c13104db975e1e1b5bfffcc9f671b2dc" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field without side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;).</source>
          <target state="translated">Предупреждать, если инициализированное поле без побочных эффектов отменяется при использовании назначенных инициализаторов (см. &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Назначенные инициализаторы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d80a9ebeceb31bde1433b7b0306e206a1d5169eb" translate="yes" xml:space="preserve">
          <source>Warn if an old-style (C-style) cast to a non-void type is used within a C++ program. The new-style casts (&lt;code&gt;dynamic_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, &lt;code&gt;reinterpret_cast&lt;/code&gt;, and &lt;code&gt;const_cast&lt;/code&gt;) are less vulnerable to unintended effects and much easier to search for.</source>
          <target state="translated">Предупреждать, если в программе на C ++ используется приведение старого стиля (стиля C) к непустому типу. Приведения нового стиля ( &lt;code&gt;dynamic_cast&lt;/code&gt; , &lt;code&gt;static_cast&lt;/code&gt; , &lt;code&gt;reinterpret_cast&lt;/code&gt; и &lt;code&gt;const_cast&lt;/code&gt; ) менее уязвимы для непреднамеренных эффектов и их намного проще искать.</target>
        </trans-unit>
        <trans-unit id="c7f9169958964ae3bf708d5e9fc733f1b6f3d079" translate="yes" xml:space="preserve">
          <source>Warn if an old-style function definition is used. A warning is given even if there is a previous prototype.</source>
          <target state="translated">Предупредить,если используется старое определение функции.Предупреждение выдается,даже если есть предыдущий прототип.</target>
        </trans-unit>
        <trans-unit id="da6e0c7f139a454bc8182dc0ec55a473f639305f" translate="yes" xml:space="preserve">
          <source>Warn if an undefined identifier is evaluated in an &lt;code&gt;#if&lt;/code&gt; directive. Such identifiers are replaced with zero.</source>
          <target state="translated">Предупреждать, если неопределенный идентификатор оценивается в директиве &lt;code&gt;#if&lt;/code&gt; . Такие идентификаторы заменяются нулем.</target>
        </trans-unit>
        <trans-unit id="ac1c57ed34616373c808e98ba1a7016be9451740" translate="yes" xml:space="preserve">
          <source>Warn if any functions that return structures or unions are defined or called. (In languages where you can return an array, this also elicits a warning.)</source>
          <target state="translated">Предупреждать о том,что любые функции,возвращающие структуры или союзы,определены или вызваны.(В языках,где можно вернуть массив,это также вызывает предупреждение).</target>
        </trans-unit>
        <trans-unit id="51dd1d087c6f2f3e06e53605399888ad9deb557f" translate="yes" xml:space="preserve">
          <source>Warn if any trigraphs are encountered that might change the meaning of the program. Trigraphs within comments are not warned about, except those that would form escaped newlines.</source>
          <target state="translated">Предупреждайте,если встречаются триграфы,которые могут изменить смысл программы.Триграфы в комментариях не предупреждаются,за исключением тех,которые могли бы образовывать ускользающие строки.</target>
        </trans-unit>
        <trans-unit id="4ffcebae22b64bc0188075323e253a892fb2c53e" translate="yes" xml:space="preserve">
          <source>Warn if anything is declared more than once in the same scope, even in cases where multiple declaration is valid and changes nothing.</source>
          <target state="translated">Предупреждать,если что-либо декларируется несколько раз в одной и той же области,даже в тех случаях,когда многократное декларирование является действительным и ничего не меняет.</target>
        </trans-unit>
        <trans-unit id="e116ff785f520c78cab89ec80c259fd9b971e9a1" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles are missing when using the</source>
          <target state="translated">Предупреждать,если профили обратной связи отсутствуют при использовании параметра</target>
        </trans-unit>
        <trans-unit id="159621fc69892b60a8932abc53e5e7077fd3432a" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles do not match when using the</source>
          <target state="translated">Предупреждать,если профили обратной связи не совпадают при использовании параметра</target>
        </trans-unit>
        <trans-unit id="4484a988d285daa67ba50d8d0068eac8b9c3b671" translate="yes" xml:space="preserve">
          <source>Warn if floating-point values are used in equality comparisons.</source>
          <target state="translated">Предупредить,если при сравнении равенства используются значения с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="5905365a7243693b281255e7cd734a616d419731" translate="yes" xml:space="preserve">
          <source>Warn if in a loop with constant number of iterations the compiler detects undefined behavior in some statement during one or more of the iterations.</source>
          <target state="translated">Предупреждать,если в цикле с постоянным количеством итераций компилятор обнаруживает неопределенное поведение в том или ином операторе во время одной или нескольких итераций.</target>
        </trans-unit>
        <trans-unit id="30ffd0486ea9b42613bc7458b80c284dea250c07" translate="yes" xml:space="preserve">
          <source>Warn if left shifting a negative value. This warning is enabled by</source>
          <target state="translated">Предупреждайте,если левое смещение отрицательного значения.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="59ffb10f60449caf44bc018fb1547abe48a875a4" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods of different types for the same selector are found during compilation. The check is performed on the list of methods in the final stage of compilation. Additionally, a check is performed for each selector appearing in a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, and a corresponding method for that selector has been found during compilation. Because these checks scan the method table only at the end of compilation, these warnings are not produced if the final stage of compilation is not reached, for example because an error is found during compilation, or because the</source>
          <target state="translated">Предупреждать, если во время компиляции обнаружено несколько методов разных типов для одного и того же селектора. Проверка выполняется по списку методов на завершающей стадии компиляции. Кроме того, выполняется проверка каждого селектора, появляющегося в &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; , и во время компиляции был найден соответствующий метод для этого селектора. Поскольку эти проверки сканируют таблицу методов только в конце компиляции, эти предупреждения не выдаются, если не достигнут последний этап компиляции, например, из-за того, что во время компиляции обнаружена ошибка или</target>
        </trans-unit>
        <trans-unit id="cd90c2f7bb5d921c657a205bebfbd186d1fe38a6" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;Class&lt;/code&gt;. When this flag is off (which is the default behavior), the compiler omits such warnings if any differences found are confined to types that share the same size and alignment.</source>
          <target state="translated">Предупреждать, если для данного селектора найдено несколько методов с разными аргументами и / или возвращаемыми типами при попытке отправить сообщение с использованием этого селектора получателю типа &lt;code&gt;id&lt;/code&gt; или &lt;code&gt;Class&lt;/code&gt; . Когда этот флаг выключен (что является поведением по умолчанию), компилятор пропускает такие предупреждения, если любые обнаруженные различия ограничиваются типами, которые имеют одинаковый размер и выравнивание.</target>
        </trans-unit>
        <trans-unit id="b4a4ef5836fcd4eb9eae356fd7d365383ac64fa2" translate="yes" xml:space="preserve">
          <source>Warn if padding is included in a structure, either to align an element of the structure or to align the whole structure. Sometimes when this happens it is possible to rearrange the fields of the structure to reduce the padding and so make the structure smaller.</source>
          <target state="translated">Предупреждение,если накладка включена в конструкцию,либо для выравнивания элемента конструкции,либо для выравнивания всей конструкции.Иногда,когда это происходит,можно переставить поля конструкции,чтобы уменьшить набивку и таким образом уменьшить конструкцию.</target>
        </trans-unit>
        <trans-unit id="cd9ef45fbb8d72f1831fd326b4e220df7e2faf4b" translate="yes" xml:space="preserve">
          <source>Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence people often get confused about.</source>
          <target state="translated">Предупреждайте,если скобки опущены в определенных контекстах,например,когда есть задание в контексте,где ожидается значение истины,или когда вложены операторы,приоритет которых часто путают в людях.</target>
        </trans-unit>
        <trans-unit id="3dceb1e23a828c2f0ba0a906a334b86bd9449ace" translate="yes" xml:space="preserve">
          <source>Warn if shift count &amp;gt;= width of type. This warning is enabled by default.</source>
          <target state="translated">Предупреждать, если количество сдвигов&amp;gt; = ширина типа. Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="782b64d027fe58cf65d8d3d5a2401f820f146ca7" translate="yes" xml:space="preserve">
          <source>Warn if shift count is negative. This warning is enabled by default.</source>
          <target state="translated">Предупреждаю,если счетчик смен отрицательный.Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9c75b9200e1a12aae1dc4d040bec33d9a26d867e" translate="yes" xml:space="preserve">
          <source>Warn if the C++17 feature making &lt;code&gt;noexcept&lt;/code&gt; part of a function type changes the mangled name of a symbol relative to C++14. Enabled by</source>
          <target state="translated">Предупреждать , если С ++ 17 функция делает &lt;code&gt;noexcept&lt;/code&gt; часть типа функции изменяет искаженное имя символа по отношению к C ++ 14. Включено</target>
        </trans-unit>
        <trans-unit id="46702f45847b2104b177e9b694f3c3f7e2226105" translate="yes" xml:space="preserve">
          <source>Warn if the ISR is misspelled, i.e. without __vector prefix. Enabled by default.</source>
          <target state="translated">Предупредить,если ISR написан неправильно,т.е.без префикса __vector.По умолчанию включено.</target>
        </trans-unit>
        <trans-unit id="33d88165f92bdb2b45ff7a297ce9db7215dfa02b" translate="yes" xml:space="preserve">
          <source>Warn if the compiler detects paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. This option is only active when</source>
          <target state="translated">Предупреждать,если компилятор обнаруживает пути,которые приводят к ошибочному или неопределенному поведению из-за разыменования нулевого указателя.Эта опция активна только в том случае,если</target>
        </trans-unit>
        <trans-unit id="201bd84a1d08c6c2787e78691ed2f3f92ff20d03" translate="yes" xml:space="preserve">
          <source>Warn if the loop cannot be optimized because the compiler cannot assume anything on the bounds of the loop indices. With</source>
          <target state="translated">Предупреждать,если цикл не может быть оптимизирован,так как компилятор не может ничего предположить на границах индексов цикла.С</target>
        </trans-unit>
        <trans-unit id="6ce9dcfeb56e93b36f3824efcafb3fac2f89db30" translate="yes" xml:space="preserve">
          <source>Warn if the return type of a function has a type qualifier such as &lt;code&gt;const&lt;/code&gt;. For ISO C such a type qualifier has no effect, since the value returned by a function is not an lvalue. For C++, the warning is only emitted for scalar types or &lt;code&gt;void&lt;/code&gt;. ISO C prohibits qualified &lt;code&gt;void&lt;/code&gt; return types on function definitions, so such return types always receive a warning even without this option.</source>
          <target state="translated">Предупреждать, если тип возвращаемого значения функции имеет квалификатор типа, например &lt;code&gt;const&lt;/code&gt; . Для ISO C такой квалификатор типа не действует, поскольку значение, возвращаемое функцией, не является lvalue. Для C ++ предупреждение выдается только для скалярных типов или &lt;code&gt;void&lt;/code&gt; . ISO C запрещает квалифицированные возвращаемые типы &lt;code&gt;void&lt;/code&gt; в определениях функций, поэтому такие возвращаемые типы всегда получают предупреждение даже без этой опции.</target>
        </trans-unit>
        <trans-unit id="84e834ec069e09da87cddcf3972bf0a3064670e4" translate="yes" xml:space="preserve">
          <source>Warn if the size of a function frame exceeds &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack frame size is approximate and not conservative. The actual requirements may be somewhat greater than &lt;var&gt;byte-size&lt;/var&gt; even if you do not get a warning. In addition, any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is not included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">Предупредить, если размер фрейма функции превышает &lt;var&gt;byte-size&lt;/var&gt; . Вычисления, выполняемые для определения размера кадра стека, являются приблизительными и неконсервативными. Фактические требования могут быть несколько больше &lt;var&gt;byte-size&lt;/var&gt; даже если вы не получите предупреждения. Кроме того, любое пространство, выделенное с помощью &lt;code&gt;alloca&lt;/code&gt; , массивов переменной длины или связанных конструкций, не включается компилятором при определении того, выдавать ли предупреждение.</target>
        </trans-unit>
        <trans-unit id="5b03e969a133a7f61dfd42668c90fbd199dc871d" translate="yes" xml:space="preserve">
          <source>Warn if the stack usage of a function might exceed &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack usage is conservative. Any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">Предупреждать, если использование стека функцией может превышать &lt;var&gt;byte-size&lt;/var&gt; . Расчет, сделанный для определения использования стека, является консервативным. Любое пространство, выделенное с помощью &lt;code&gt;alloca&lt;/code&gt; , массивов переменной длины или связанных конструкций, включается компилятором при определении, выдавать ли предупреждение.</target>
        </trans-unit>
        <trans-unit id="949e7c4b1e5fd9dd73b3df3e4dd44a3a50fb46cc" translate="yes" xml:space="preserve">
          <source>Warn if the type of &lt;code&gt;main&lt;/code&gt; is suspicious. &lt;code&gt;main&lt;/code&gt; should be a function with external linkage, returning int, taking either zero arguments, two, or three arguments of appropriate types. This warning is enabled by default in C++ and is enabled by either</source>
          <target state="translated">Предупредить, если тип &lt;code&gt;main&lt;/code&gt; подозрительного. &lt;code&gt;main&lt;/code&gt; должна быть функцией с внешней связью, возвращающей int, принимающей либо ноль аргументов, либо два, либо три аргумента соответствующих типов. Это предупреждение включено по умолчанию в C ++ и включается либо</target>
        </trans-unit>
        <trans-unit id="6da28b5dec8555c7e8c577e4ad18fb400e3b7e57" translate="yes" xml:space="preserve">
          <source>Warn if the vectorizer cost model overrides the OpenMP simd directive set by user. The</source>
          <target state="translated">Предупреждать,если модель стоимости векторизатора переопределяет установленную пользователем директиву OpenMP simd.</target>
        </trans-unit>
        <trans-unit id="cd147a815b47d8a61a481259e6bec92f6328c4b1" translate="yes" xml:space="preserve">
          <source>Warn if variadic macros are used in ISO C90 mode, or if the GNU alternate syntax is used in ISO C99 mode. This is enabled by either</source>
          <target state="translated">Предупреждать,если в режиме ISO C90 используются вариадические макросы,или если в режиме ISO C99 используется альтернативный синтаксис GNU.Это включается либо</target>
        </trans-unit>
        <trans-unit id="55d977b102dea3867bcd6836e9a2eac79a9f6018" translate="yes" xml:space="preserve">
          <source>Warn if vector operation is not implemented via SIMD capabilities of the architecture. Mainly useful for the performance tuning. Vector operation can be implemented &lt;code&gt;piecewise&lt;/code&gt;, which means that the scalar operation is performed on every vector element; &lt;code&gt;in parallel&lt;/code&gt;, which means that the vector operation is implemented using scalars of wider type, which normally is more performance efficient; and &lt;code&gt;as a single scalar&lt;/code&gt;, which means that vector fits into a scalar type.</source>
          <target state="translated">Предупреждать, если векторные операции не реализованы через SIMD-возможности архитектуры. В основном полезно для настройки производительности. Операция с вектором может быть реализована &lt;code&gt;piecewise&lt;/code&gt; , что означает, что скалярная операция выполняется для каждого элемента вектора; &lt;code&gt;in parallel&lt;/code&gt; , что означает, что векторная операция реализуется с использованием скаляров более широкого типа, что обычно более эффективно по производительности; и &lt;code&gt;as a single scalar&lt;/code&gt; , что означает, что вектор соответствует скалярному типу.</target>
        </trans-unit>
        <trans-unit id="d552f4c46cc5d3bd7e299e5496e695efcda3d372" translate="yes" xml:space="preserve">
          <source>Warn on uses of the &lt;code&gt;register&lt;/code&gt; storage class specifier, except when it is part of the GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; extension. The use of the &lt;code&gt;register&lt;/code&gt; keyword as storage class specifier has been deprecated in C++11 and removed in C++17. Enabled by default with</source>
          <target state="translated">Предупреждать об использовании спецификатора класса хранения &lt;code&gt;register&lt;/code&gt; , кроме случаев, когда он является частью расширения GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; . Использование ключевого слова &lt;code&gt;register&lt;/code&gt; в качестве спецификатора класса хранения объявлено устаревшим в C ++ 11 и удалено в C ++ 17. Включено по умолчанию с</target>
        </trans-unit>
        <trans-unit id="77c0caa2b84a54b5bcf764add54f563ae56b7071" translate="yes" xml:space="preserve">
          <source>Warn that the implicit declaration of a copy constructor or copy assignment operator is deprecated if the class has a user-provided copy constructor or copy assignment operator, in C++11 and up. This warning is enabled by</source>
          <target state="translated">Предупредить,что неявное объявление конструктора копирования или оператора присваивания копий устарело,если класс имеет предоставленный пользователем конструктор копирования или оператор присваивания копий,в языке C++11 и выше.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="4d2e76892f19022181f5882885c8f72e1722da44" translate="yes" xml:space="preserve">
          <source>Warn upon questionable usage of the macros used to handle variable arguments like &lt;code&gt;va_start&lt;/code&gt;. This is default. To inhibit the warning messages, use</source>
          <target state="translated">Предупреждать о сомнительном использовании макросов, используемых для обработки переменных аргументов, таких как &lt;code&gt;va_start&lt;/code&gt; . Это по умолчанию. Чтобы подавить предупреждающие сообщения, используйте</target>
        </trans-unit>
        <trans-unit id="3abec5289cdc959e5a13fe23b53843308a01da72" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; and &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; built-in functions are used. These functions changed semantics in GCC 4.4.</source>
          <target state="translated">Предупреждать, когда &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; встроенные функции __sync_fetch_and_nand и &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; . Эти функции изменили семантику в GCC 4.4.</target>
        </trans-unit>
        <trans-unit id="2aa9b92f65cbea3024eccc7e04605b70f951ef46" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;delete&lt;/code&gt; is used to destroy an instance of a class that has virtual functions and non-virtual destructor. It is unsafe to delete an instance of a derived class through a pointer to a base class if the base class does not have a virtual destructor. This warning is enabled by</source>
          <target state="translated">Предупреждать, когда &lt;code&gt;delete&lt;/code&gt; используется для уничтожения экземпляра класса, который имеет виртуальные функции и не виртуальный деструктор. Небезопасно удалять экземпляр производного класса через указатель на базовый класс, если базовый класс не имеет виртуального деструктора. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="f21bdb487f01146075a954516a5aced86463b3d2" translate="yes" xml:space="preserve">
          <source>Warn when G++ it generates code that is probably not compatible with the vendor-neutral C++ ABI. Since G++ now defaults to updating the ABI with each major release, normally</source>
          <target state="translated">Предупреждайте,когда G++генерирует код,который,вероятно,не совместим с нейтрализующим производителя C++ABI.Так как G++теперь по умолчанию обновляет ABI с каждым основным выпуском,то обычно</target>
        </trans-unit>
        <trans-unit id="35e0de5085f6b803ca5c49ba47e5ebe4c1616823" translate="yes" xml:space="preserve">
          <source>Warn when a &lt;code&gt;#pragma&lt;/code&gt; directive is encountered that is not understood by GCC. If this command-line option is used, warnings are even issued for unknown pragmas in system header files. This is not the case if the warnings are only enabled by the</source>
          <target state="translated">Предупреждать при обнаружении директивы &lt;code&gt;#pragma&lt;/code&gt; , не понимаемой GCC. Если используется этот параметр командной строки, предупреждения выдаются даже для неизвестных прагм в файлах системных заголовков. Это не тот случай, если предупреждения включены только</target>
        </trans-unit>
        <trans-unit id="62d4dab62f762a61b2f522842ea9ed134dd06936" translate="yes" xml:space="preserve">
          <source>Warn when a class has virtual functions and an accessible non-virtual destructor itself or in an accessible polymorphic base class, in which case it is possible but unsafe to delete an instance of a derived class through a pointer to the class itself or base class. This warning is automatically enabled if</source>
          <target state="translated">Предупреждение при наличии в классе виртуальных функций и доступного невиртуального деструктора как такового,так и в доступном полиморфном базовом классе,в этом случае возможно,но небезопасно удалить экземпляр производного класса по указателю на сам класс или базовый класс.Данное предупреждение автоматически включается,если</target>
        </trans-unit>
        <trans-unit id="2cb7e95f48120a523e19a1fdc36b0b8e1ca72f8b" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with a virtual direct base class. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use virtual inheritance.</source>
          <target state="translated">Предупреждать,когда класс определен с помощью виртуального прямого базового класса.Некоторые правила кодирования запрещают множественное наследование,и это может быть использовано для принудительного применения данного правила.Предупреждение неактивно внутри системного заголовочного файла,такого как STL,поэтому можно использовать STL.Можно также определить классы,которые косвенно используют виртуальное наследование.</target>
        </trans-unit>
        <trans-unit id="856d4cae226810333db6e35bc2ec148c4f408659" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with multiple direct base classes. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use multiple inheritance.</source>
          <target state="translated">Предупреждение,когда класс определен с несколькими прямыми базовыми классами.Некоторые правила кодирования запрещают множественное наследование,и это может быть использовано для принудительного применения данного правила.Предупреждение неактивно внутри системного заголовочного файла,такого как STL,поэтому можно использовать STL.Можно также определить классы,которые косвенно используют множественное наследование.</target>
        </trans-unit>
        <trans-unit id="62d55cbfe764766f5f6f7218d2c7a740a50c90ce" translate="yes" xml:space="preserve">
          <source>Warn when a class seems unusable because all the constructors or destructors in that class are private, and it has neither friends nor public static member functions. Also warn if there are no non-private methods, and there&amp;rsquo;s at least one private member function that isn&amp;rsquo;t a constructor or destructor.</source>
          <target state="translated">Предупреждать, когда класс кажется непригодным для использования, потому что все конструкторы или деструкторы в этом классе являются частными и у него нет ни друзей, ни общедоступных статических функций-членов. Также предупредите, если нет неприватных методов и есть хотя бы одна закрытая функция-член, которая не является конструктором или деструктором.</target>
        </trans-unit>
        <trans-unit id="3da6bed540b8c798c01ac10e6f991d33a93d7840" translate="yes" xml:space="preserve">
          <source>Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned. In C++, this warning is also enabled by</source>
          <target state="translated">Предупреждать,когда сравнение подписанного и неподписанного значений может привести к неверному результату,когда подписанное значение конвертируется в неподписанное.В языке Си++это предупреждение также включается по команде</target>
        </trans-unit>
        <trans-unit id="d0d230a7b94f00a257ce101a92be2d7094f8073f" translate="yes" xml:space="preserve">
          <source>Warn when a declaration does not specify a type. This warning is enabled by</source>
          <target state="translated">Предупреждать,если в декларации не указан тип.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="65d83d710bdf5c622a92b858d79d70755ab8010e" translate="yes" xml:space="preserve">
          <source>Warn when a declaration is found after a statement in a block. This construct, known from C++, was introduced with ISO C99 and is by default allowed in GCC. It is not supported by ISO C90. See &lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;Mixed Declarations&lt;/a&gt;.</source>
          <target state="translated">Предупреждать, если объявление находится после оператора в блоке. Эта конструкция, известная из C ++, была введена в ISO C99 и по умолчанию разрешена в GCC. Он не поддерживается ISO C90. См. &lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;Смешанные декларации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a51fcbd164dc3089b47299b1d3b6f2732c7c6fcc" translate="yes" xml:space="preserve">
          <source>Warn when a declaration of a function is missing one or more attributes that a related function is declared with and whose absence may adversely affect the correctness or efficiency of generated code. For example, the warning is issued for declarations of aliases that use attributes to specify less restrictive requirements than those of their targets. This typically represents a potential optimization opportunity. By contrast, the</source>
          <target state="translated">Предупреждать,когда в объявлении функции отсутствует один или несколько атрибутов,с которыми объявлена связанная функция,и отсутствие которых может отрицательно сказаться на корректности или эффективности генерируемого кода.Например,предупреждение выдается для объявлений псевдонимов,в которых атрибуты используются для указания менее ограничительных требований,чем для их целей.Как правило,это представляет собой потенциальную возможность оптимизации.В отличие от этого</target>
        </trans-unit>
        <trans-unit id="4f18983de88b8950abf6205674919e5d25d36a1f" translate="yes" xml:space="preserve">
          <source>Warn when a function call is cast to a non-matching type. For example, warn if a call to a function returning an integer type is cast to a pointer type.</source>
          <target state="translated">Предупреждать,когда вызов функции приводится к несоответствующему типу.Например,предупреждать,если вызов функции,возвращающей целочисленный тип,приведен к типу указателя.</target>
        </trans-unit>
        <trans-unit id="1fee5efa47b570695ab661666c6e4fee9e9b04a8" translate="yes" xml:space="preserve">
          <source>Warn when a function declaration hides virtual functions from a base class. For example, in:</source>
          <target state="translated">Предупреждать,когда объявление функции скрывает виртуальные функции от базового класса.Например,in:</target>
        </trans-unit>
        <trans-unit id="e0dab17ca245164b1ca8348967e2bf698b2a4654" translate="yes" xml:space="preserve">
          <source>Warn when a function pointer is cast to an incompatible function pointer. In a cast involving function types with a variable argument list only the types of initial arguments that are provided are considered. Any parameter of pointer-type matches any other pointer-type. Any benign differences in integral types are ignored, like &lt;code&gt;int&lt;/code&gt; vs. &lt;code&gt;long&lt;/code&gt; on ILP32 targets. Likewise type qualifiers are ignored. The function type &lt;code&gt;void (*) (void)&lt;/code&gt; is special and matches everything, which can be used to suppress this warning. In a cast involving pointer to member types this warning warns whenever the type cast is changing the pointer to member type. This warning is enabled by</source>
          <target state="translated">Предупреждать, когда указатель функции приводится к несовместимому указателю функции. В приведении типов функций со списком переменных аргументов учитываются только те типы исходных аргументов, которые предоставлены. Любой параметр типа указателя соответствует любому другому типу указателя. Любые незначительные различия в целочисленных типах игнорируются, например, &lt;code&gt;int&lt;/code&gt; и &lt;code&gt;long&lt;/code&gt; в целях ILP32. Точно так же игнорируются квалификаторы типа. Тип функции &lt;code&gt;void (*) (void)&lt;/code&gt; является особенным и соответствует всему, что можно использовать для подавления этого предупреждения. В приведении типов, включающих указатель на типы членов, это предупреждение предупреждает всякий раз, когда приведение типа изменяет указатель на тип члена. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="1c95c86068b8b8d1d8a72bc94ef016e54d5ce483" translate="yes" xml:space="preserve">
          <source>Warn when a literal &amp;lsquo;</source>
          <target state="translated">Предупреждать, когда буквальный</target>
        </trans-unit>
        <trans-unit id="fc5d5783ac1277dfc41a8a050b298452017de063" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter whose type is compatible with that of the shadowing variable. In C++, type compatibility here means the type of the shadowing variable can be converted to that of the shadowed variable. The creation of this flag (in addition to</source>
          <target state="translated">Предупреждать,когда локальная переменная отбрасывает тень на другую локальную переменную или параметр,тип которого совместим с типом переменной отбрасывания.В языке C++совместимость типов здесь означает,что тип переменной shadowing может быть приведен к типу переменной shadowed.Создание этого флага (в дополнение к</target>
        </trans-unit>
        <trans-unit id="15ad15a27db9c39d53d6f814ef18cd0f426f15bd" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter. This warning is enabled by</source>
          <target state="translated">Предупреждать,когда локальная переменная отбрасывает тень на другую локальную переменную или параметр.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="7332bfdf0522cbf64f5e187ed28df9e9bbf190d7" translate="yes" xml:space="preserve">
          <source>Warn when a namespace definition is opened. Some coding rules disallow namespaces, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also use using directives and qualified names.</source>
          <target state="translated">Предупреждать при открытии определения пространства имен.Некоторые правила кодирования запрещают пространства имен,и это может быть использовано для обеспечения соблюдения этого правила.Предупреждение неактивно внутри системного заголовочного файла,такого как STL,поэтому можно использовать STL.Можно также использовать директивы и квалифицированные имена.</target>
        </trans-unit>
        <trans-unit id="0c68af853608801bfccea4375c872dd95f8c2c74" translate="yes" xml:space="preserve">
          <source>Warn when a noexcept-expression evaluates to false because of a call to a function that does not have a non-throwing exception specification (i.e. &lt;code&gt;throw()&lt;/code&gt; or &lt;code&gt;noexcept&lt;/code&gt;) but is known by the compiler to never throw an exception.</source>
          <target state="translated">Предупреждать, когда выражение noexcept принимает значение false из-за вызова функции, не имеющей спецификации исключения, не вызывающей исключения (например, &lt;code&gt;throw()&lt;/code&gt; или &lt;code&gt;noexcept&lt;/code&gt; ), но известно компилятору, что она никогда не генерирует исключение.</target>
        </trans-unit>
        <trans-unit id="64beb2070ebf4a8be0aefd1a955c78bef9d98677" translate="yes" xml:space="preserve">
          <source>Warn when a primary template declaration is encountered. Some coding rules disallow templates, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also instantiate or specialize templates.</source>
          <target state="translated">Предупреждать,когда встречается первичное шаблонное объявление.Некоторые правила кодирования запрещают шаблоны,и это может быть использовано для обеспечения соблюдения этого правила.Предупреждение неактивно внутри системного заголовочного файла,такого как STL,поэтому можно использовать STL.Можно также инстанцировать или специализировать шаблоны.</target>
        </trans-unit>
        <trans-unit id="ecfd63f7bf76274a278010015f443553fb311275" translate="yes" xml:space="preserve">
          <source>Warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore. As a conforming extension, GCC treats such suffixes as separate preprocessing tokens in order to maintain backwards compatibility with code that uses formatting macros from &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">Предупреждать, когда за строковым или символьным литералом следует суффикс ud, который не начинается с символа подчеркивания. В качестве соответствующего расширения GCC обрабатывает такие суффиксы как отдельные токены предварительной обработки, чтобы поддерживать обратную совместимость с кодом, который использует макросы форматирования из &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="af55e43f2240ead9470434a0686aeb1f0a48afd9" translate="yes" xml:space="preserve">
          <source>Warn when a switch case falls through. For example:</source>
          <target state="translated">Предупреждать,когда корпус переключателя выпадает из строя.Например:</target>
        </trans-unit>
        <trans-unit id="fae5e5411e11c5c48526329b8f085ab67410eafc" translate="yes" xml:space="preserve">
          <source>Warn when a type with an ABI tag is used in a context that does not have that ABI tag. See &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C++ Attributes&lt;/a&gt; for more information about ABI tags.</source>
          <target state="translated">Предупреждать, когда тип с тегом ABI используется в контексте, не имеющем этого тега ABI. См. &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;Атрибуты C ++&lt;/a&gt; для получения дополнительной информации о тегах ABI.</target>
        </trans-unit>
        <trans-unit id="b81088e3c7de4ba5e43b90938614126c8743c79a" translate="yes" xml:space="preserve">
          <source>Warn when a typedef locally defined in a function is not used. This warning is enabled by</source>
          <target state="translated">Предупреждать,если в функции не используется локально заданный шрифт.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="7f92b37eeb1fc74d56bfb3de4e40a33e9756c1f8" translate="yes" xml:space="preserve">
          <source>Warn when an attribute is ignored. This is different from the</source>
          <target state="translated">Предупреждать,когда атрибут игнорируется.Это отличается от</target>
        </trans-unit>
        <trans-unit id="69d8172c43b83e36a9fc251e2742504cc5f07f18" translate="yes" xml:space="preserve">
          <source>Warn when an expression is casted to its own type.</source>
          <target state="translated">Предупреждать,когда выражение кастится к своему типу.</target>
        </trans-unit>
        <trans-unit id="68276b3f14c999ac5fd8362dd7f4c1eb0d25507e" translate="yes" xml:space="preserve">
          <source>Warn when an if-else has identical branches. This warning detects cases like</source>
          <target state="translated">Предупреждайте,если у &quot;иф-альса&quot; одинаковые ветви.Это предупреждение обнаруживает такие случаи,как</target>
        </trans-unit>
        <trans-unit id="4eaddac0ef918127a66832ad98be3ebdfc801bcd" translate="yes" xml:space="preserve">
          <source>Warn when an object referenced by a &lt;code&gt;restrict&lt;/code&gt;-qualified parameter (or, in C++, a &lt;code&gt;__restrict&lt;/code&gt;-qualified parameter) is aliased by another argument, or when copies between such objects overlap. For example, the call to the &lt;code&gt;strcpy&lt;/code&gt; function below attempts to truncate the string by replacing its initial characters with the last four. However, because the call writes the terminating NUL into &lt;code&gt;a[4]&lt;/code&gt;, the copies overlap and the call is diagnosed.</source>
          <target state="translated">Предупреждать, когда объект, на который ссылается параметр &lt;code&gt;restrict&lt;/code&gt; -qualified (или, в C ++, параметр &lt;code&gt;__restrict&lt;/code&gt; -qualified), имеет псевдоним другого аргумента или когда копии между такими объектами перекрываются. Например, приведенный ниже вызов функции &lt;code&gt;strcpy&lt;/code&gt; пытается усечь строку, заменив ее начальные символы последними четырьмя. Однако, поскольку вызов записывает завершающий NUL в &lt;code&gt;a[4]&lt;/code&gt; , копии перекрываются, и вызов диагностируется.</target>
        </trans-unit>
        <trans-unit id="48e014515a7db6fc79ef0eeec4d6a1ef40fdd1b6" translate="yes" xml:space="preserve">
          <source>Warn when comparing an argument marked with the &lt;code&gt;nonnull&lt;/code&gt; function attribute against null inside the function.</source>
          <target state="translated">Предупреждать при сравнении аргумента, помеченного атрибутом функции, &lt;code&gt;nonnull&lt;/code&gt; от NULL, с нулевым значением внутри функции.</target>
        </trans-unit>
        <trans-unit id="448f3542d0488bfdc3c401daf34114424d62966e" translate="yes" xml:space="preserve">
          <source>Warn when deleting a pointer to incomplete type, which may cause undefined behavior at runtime. This warning is enabled by default.</source>
          <target state="translated">Предупреждение при удалении указателя на неполный тип,что может привести к неопределенному поведению во время выполнения.Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4aead77201e88b8231585b494878f47ece446b42" translate="yes" xml:space="preserve">
          <source>Warn when macros &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt; or &lt;code&gt;__TIMESTAMP__&lt;/code&gt; are encountered as they might prevent bit-wise-identical reproducible compilations.</source>
          <target state="translated">Предупреждать при &lt;code&gt;__TIME__&lt;/code&gt; макросов __TIME__ , &lt;code&gt;__DATE__&lt;/code&gt; или &lt;code&gt;__TIMESTAMP__&lt;/code&gt; , поскольку они могут помешать побитно-идентичным воспроизводимым компиляциям.</target>
        </trans-unit>
        <trans-unit id="f416313a5d687fda4c349efcccdbcd43185983e0" translate="yes" xml:space="preserve">
          <source>Warn when overload resolution chooses a promotion from unsigned or enumerated type to a signed type, over a conversion to an unsigned type of the same size. Previous versions of G++ tried to preserve unsignedness, but the standard mandates the current behavior.</source>
          <target state="translated">Предупреждать,когда разрешение перегрузки выбирает продвижение из неподписанного или перечисленного типа в подписанный,по преобразованию в неподписанный тип того же размера.Предыдущие версии G++пытались сохранить беззнаковое поведение,но стандарт предписывал текущее поведение.</target>
        </trans-unit>
        <trans-unit id="6b26cc3f03f85ab2638c4cf2001a077d93732070" translate="yes" xml:space="preserve">
          <source>Warn when the &amp;lsquo;</source>
          <target state="translated">Предупреждать, когда '</target>
        </trans-unit>
        <trans-unit id="8090e980ff3867e87fe893e55e71d464e21173ec" translate="yes" xml:space="preserve">
          <source>Warn when the &lt;code&gt;sizeof&lt;/code&gt; operator is applied to a parameter that is declared as an array in a function definition. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">Предупреждать, когда оператор &lt;code&gt;sizeof&lt;/code&gt; применяется к параметру, который объявлен как массив в определении функции. Это предупреждение включено по умолчанию для программ C и C ++.</target>
        </trans-unit>
        <trans-unit id="9e36c088ae2b71459782ca704065537e9a26901f" translate="yes" xml:space="preserve">
          <source>Warn when the address of packed member of struct or union is taken, which usually results in an unaligned pointer value. This is enabled by default.</source>
          <target state="translated">Предупреждают,когда берется адрес упакованного члена структуры или союза,что обычно приводит к выравниванию значения указателя.По умолчанию это включено.</target>
        </trans-unit>
        <trans-unit id="99f87649fa1908434c721b9cad02a2282152635b" translate="yes" xml:space="preserve">
          <source>Warn when the destination of a call to a raw memory function such as &lt;code&gt;memset&lt;/code&gt; or &lt;code&gt;memcpy&lt;/code&gt; is an object of class type, and when writing into such an object might bypass the class non-trivial or deleted constructor or copy assignment, violate const-correctness or encapsulation, or corrupt virtual table pointers. Modifying the representation of such objects may violate invariants maintained by member functions of the class. For example, the call to &lt;code&gt;memset&lt;/code&gt; below is undefined because it modifies a non-trivial class object and is, therefore, diagnosed. The safe way to either initialize or clear the storage of objects of such types is by using the appropriate constructor or assignment operator, if one is available.</source>
          <target state="translated">Предупреждать, когда адресатом вызова необработанной функции памяти, такой как &lt;code&gt;memset&lt;/code&gt; или &lt;code&gt;memcpy&lt;/code&gt; , является объект типа класса, и при записи в такой объект может обойти нетривиальный или удаленный конструктор класса или присвоение копии, нарушить константную корректность или инкапсуляция или повреждение указателей виртуальных таблиц. Изменение представления таких объектов может нарушить инварианты, поддерживаемые функциями-членами класса. Например, вызов &lt;code&gt;memset&lt;/code&gt; ниже не определен, поскольку он изменяет нетривиальный объект класса и, следовательно, диагностируется. Безопасный способ инициализировать или очистить хранилище объектов таких типов - использовать соответствующий конструктор или оператор присваивания, если он доступен.</target>
        </trans-unit>
        <trans-unit id="40608df8d0fb171d8c9fd495ba5d5a7b32bd842d" translate="yes" xml:space="preserve">
          <source>Warn when the indentation of the code does not reflect the block structure. Specifically, a warning is issued for &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt; clauses with a guarded statement that does not use braces, followed by an unguarded statement with the same indentation.</source>
          <target state="translated">Предупреждаем, когда отступ в коде не отражает структуру блока. В частности, предупреждение выдается для предложений &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; и &lt;code&gt;for&lt;/code&gt; предложений с защищенным оператором, не использующим фигурные скобки, за которым следует неохраняемый оператор с тем же отступом.</target>
        </trans-unit>
        <trans-unit id="ccf62a55eeac02e2a52c16724b5155a1eb1a630e" translate="yes" xml:space="preserve">
          <source>Warn when the order of member initializers given in the code does not match the order in which they must be executed. For instance:</source>
          <target state="translated">Предупреждать,если порядок инициализаторов членов,указанный в коде,не совпадает с порядком,в котором они должны быть выполнены.Например:</target>
        </trans-unit>
        <trans-unit id="761311d3e33c39156d8e3725fcf020a8f1821794" translate="yes" xml:space="preserve">
          <source>Warn when the stack frame of a function exceeds &lt;var&gt;n&lt;/var&gt; bytes.</source>
          <target state="translated">Предупреждать, когда размер стека функции превышает &lt;var&gt;n&lt;/var&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="837d376bd42b01ca86e7606408854284b9f96c39" translate="yes" xml:space="preserve">
          <source>Warn whenever &amp;lsquo;</source>
          <target state="translated">Предупреждать всякий раз</target>
        </trans-unit>
        <trans-unit id="0c2135b897d3d5641cf8e18388c032eb11d6e43a" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement contains statements between the controlling expression and the first case label, which will never be executed. For example:</source>
          <target state="translated">Предупреждать всякий раз, когда оператор &lt;code&gt;switch&lt;/code&gt; содержит операторы между управляющим выражением и первой меткой case, которые никогда не будут выполнены. Например:</target>
        </trans-unit>
        <trans-unit id="3eb686177c30ed2e6e5f5f2664f95e4bb53041fa" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement does not have a &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="translated">Предупреждать всякий раз, когда в инструкции &lt;code&gt;switch&lt;/code&gt; нет регистра по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee15f4deaad963ee59e6e25cbd36a97c1a0b6f8" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of boolean type and the case values are outside the range of a boolean type. It is possible to suppress this warning by casting the controlling expression to a type other than &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">Предупреждать всякий раз, когда оператор &lt;code&gt;switch&lt;/code&gt; имеет индекс логического типа, а значения case выходят за пределы диапазона логического типа. Это предупреждение можно подавить, приведя управляющее выражение к типу, отличному от &lt;code&gt;bool&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="d226ed0209ee1c2fb6432b4c47bf17b27b050c76" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. (The presence of a &lt;code&gt;default&lt;/code&gt; label prevents this warning.) &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used (even if there is a &lt;code&gt;default&lt;/code&gt; label). This warning is enabled by</source>
          <target state="translated">Предупреждать всякий раз, когда оператор &lt;code&gt;switch&lt;/code&gt; имеет индекс перечислимого типа и не имеет &lt;code&gt;case&lt;/code&gt; для одного или нескольких именованных кодов этого перечисления. (Наличие метки по &lt;code&gt;default&lt;/code&gt; предотвращает появление этого предупреждения.) Метки &lt;code&gt;case&lt;/code&gt; за пределами диапазона перечисления также вызывают предупреждения при использовании этой опции (даже если есть метка по &lt;code&gt;default&lt;/code&gt; ). Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="de11d7b668ccdb23ca7bd8a246e58548a37f3260" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used. The only difference between</source>
          <target state="translated">Предупреждать всякий раз, когда оператор &lt;code&gt;switch&lt;/code&gt; имеет индекс перечислимого типа и не имеет &lt;code&gt;case&lt;/code&gt; для одного или нескольких именованных кодов этого перечисления. метки &lt;code&gt;case&lt;/code&gt; вне диапазона перечисления также вызывают предупреждения при использовании этой опции. Единственная разница между</target>
        </trans-unit>
        <trans-unit id="2d59fb66fde78bda0a4dd35cce84a5db357b0d28" translate="yes" xml:space="preserve">
          <source>Warn whenever a comment-start sequence &amp;lsquo;</source>
          <target state="translated">Предупреждать всякий раз, когда последовательность начала комментария '</target>
        </trans-unit>
        <trans-unit id="017d9dfe987bf5077b04f6ad0db50c54e128c51c" translate="yes" xml:space="preserve">
          <source>Warn whenever a constant static variable is unused aside from its declaration.</source>
          <target state="translated">Предупреждать всякий раз,когда не используется постоянная статическая переменная,кроме ее объявления.</target>
        </trans-unit>
        <trans-unit id="44c2f3d6fa32cff8b5706f1e4a38180d5b65ee57" translate="yes" xml:space="preserve">
          <source>Warn whenever a function is defined with a return type that defaults to &lt;code&gt;int&lt;/code&gt;. Also warn about any &lt;code&gt;return&lt;/code&gt; statement with no return value in a function whose return type is not &lt;code&gt;void&lt;/code&gt; (falling off the end of the function body is considered returning without a value).</source>
          <target state="translated">Предупреждать всякий раз, когда функция определяется с возвращаемым типом, который по умолчанию имеет значение &lt;code&gt;int&lt;/code&gt; . Также предупреждайте о любом операторе &lt;code&gt;return&lt;/code&gt; без возвращаемого значения в функции, тип возвращаемого значения которой не является &lt;code&gt;void&lt;/code&gt; (падение с конца тела функции считается возвратом без значения).</target>
        </trans-unit>
        <trans-unit id="89fb51e22730b538a06b8e80540c16d1c3734cc8" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is assigned to, but otherwise unused (aside from its declaration).</source>
          <target state="translated">Предупреждать всякий раз,когда назначается параметр функции,но в противном случае не используется (кроме его объявления).</target>
        </trans-unit>
        <trans-unit id="7522f02e51d59309d9911182c3c068a365219bc7" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is unused aside from its declaration.</source>
          <target state="translated">Предупреждать всякий раз,когда параметр функции не используется помимо его объявления.</target>
        </trans-unit>
        <trans-unit id="c0a7eb9ab9f17ff83adfaf6aff2a67a4af1e6664" translate="yes" xml:space="preserve">
          <source>Warn whenever a label is declared but not used. This warning is enabled by</source>
          <target state="translated">Предупреждать всякий раз,когда этикетка объявлена,но не используется.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="2d58d8f5ceb022d5ba0d30591a67aed1db06f84d" translate="yes" xml:space="preserve">
          <source>Warn whenever a local or static variable is unused aside from its declaration. This option implies</source>
          <target state="translated">Предупреждать всякий раз,когда локальная или статическая переменная не используется помимо ее объявления.Эта опция подразумевает</target>
        </trans-unit>
        <trans-unit id="6e4150091f2d91d35b21758f7af8935b067c74b6" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable is assigned to, but otherwise unused (aside from its declaration). This warning is enabled by</source>
          <target state="translated">Предупреждать всякий раз,когда локальная переменная присваивается,но в противном случае не используется (кроме ее объявления).Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="79ce592a35665d53c155cc3462735224db9a9571" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable or type declaration shadows another variable, parameter, type, class member (in C++), or instance variable (in Objective-C) or whenever a built-in function is shadowed. Note that in C++, the compiler warns if a local variable shadows an explicit typedef, but not if it shadows a struct/class/enum. Same as</source>
          <target state="translated">Предупреждать всякий раз,когда локальная переменная или объявление типа затеняет другую переменную,параметр,тип,член класса (в C++)или переменную экземпляра (в Objective-C),или когда затеняется встроенная функция.Обратите внимание,что в языке Си++компилятор предупреждает,если локальная переменная оттеняет явный тип,но не оттеняет структуру/класс/значение.То же самое,что и</target>
        </trans-unit>
        <trans-unit id="05ffb9a97b76e12ea54aaaeb8badea77adb678ae" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast so as to remove a type qualifier from the target type. For example, warn if a &lt;code&gt;const char *&lt;/code&gt; is cast to an ordinary &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">Предупреждать всякий раз при приведении указателя, чтобы удалить квалификатор типа из целевого типа. Например, предупредить, если &lt;code&gt;const char *&lt;/code&gt; приведен к обычному &lt;code&gt;char *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c63ef9e66f9b18bee95bf1723987dfd5d11a58f" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; on machines where integers can only be accessed at two- or four-byte boundaries.</source>
          <target state="translated">Предупреждать всякий раз, когда указатель приводится так, что требуемое выравнивание цели увеличивается. Например, предупреждать, если &lt;code&gt;char *&lt;/code&gt; приведен к &lt;code&gt;int *&lt;/code&gt; на машинах, где целые числа доступны только на двух- или четырехбайтовых границах.</target>
        </trans-unit>
        <trans-unit id="ef7fc95a5c54b16b21f690678e6321f329b8c724" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; regardless of the target machine.</source>
          <target state="translated">Предупреждать всякий раз, когда указатель приводится так, что требуемое выравнивание цели увеличивается. Например, предупреждать, если &lt;code&gt;char *&lt;/code&gt; приводится к &lt;code&gt;int *&lt;/code&gt; независимо от целевой машины.</target>
        </trans-unit>
        <trans-unit id="f17199fabf0d6edb5e8d9320d9584ee47f24d757" translate="yes" xml:space="preserve">
          <source>Warn whenever a statement computes a result that is explicitly not used. To suppress this warning cast the unused expression to &lt;code&gt;void&lt;/code&gt;. This includes an expression-statement or the left-hand side of a comma expression that contains no side effects. For example, an expression such as &lt;code&gt;x[i,j]&lt;/code&gt; causes a warning, while &lt;code&gt;x[(void)i,j]&lt;/code&gt; does not.</source>
          <target state="translated">Предупреждать всякий раз, когда инструкция вычисляет результат, который явно не используется. Чтобы подавить это предупреждение, &lt;code&gt;void&lt;/code&gt; неиспользуемое выражение . Это включает выражение-выражение или левую часть выражения запятой, которое не содержит побочных эффектов. Например, выражение, такое как &lt;code&gt;x[i,j]&lt;/code&gt; вызывает предупреждение, а &lt;code&gt;x[(void)i,j]&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="e9ed26895683fb69327818c06ae2df9969d8a9f1" translate="yes" xml:space="preserve">
          <source>Warn whenever a static function is declared but not defined or a non-inline static function is unused. This warning is enabled by</source>
          <target state="translated">Предупреждать всякий раз,когда статическая функция объявлена,но не определена,или когда нестрочная статическая функция не используется.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="682ef1b46b2728b71e94a89b2010ca06ceb12456" translate="yes" xml:space="preserve">
          <source>Warn whenever an Objective-C assignment is being intercepted by the garbage collector.</source>
          <target state="translated">Предупреждать всякий раз,когда задание Объекта-С перехватывается сборщиком мусора.</target>
        </trans-unit>
        <trans-unit id="5f84fae543b9699e7c995142a54b65f353ecae8d" translate="yes" xml:space="preserve">
          <source>Warn whenever an object is defined whose size exceeds &lt;var&gt;byte-size&lt;/var&gt;.</source>
          <target state="translated">Предупреждать всякий раз, когда определяется объект, размер которого превышает размер &lt;var&gt;byte-size&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ea0ef30fd9bda293d78af05a20b81fc75c62d811" translate="yes" xml:space="preserve">
          <source>Warning Options</source>
          <target state="translated">Предупреждающие опции</target>
        </trans-unit>
        <trans-unit id="986ddebcadb3fa23d23a5b826b014fe8f130debb" translate="yes" xml:space="preserve">
          <source>Warning about assigning a signed value to an unsigned variable.</source>
          <target state="translated">Предупреждение о присвоении беззнакового значения беззнаковой переменной.</target>
        </trans-unit>
        <trans-unit id="e9e66e7d69e59ab3855b10526f1e61fff27e7187" translate="yes" xml:space="preserve">
          <source>Warning about using an expression whose type is signed as a shift count.</source>
          <target state="translated">Предупреждение об использовании выражения,тип которого обозначен как счетчик сдвигов.</target>
        </trans-unit>
        <trans-unit id="418dee8a9f5c36e0b14dc254214604e6561b0bc6" translate="yes" xml:space="preserve">
          <source>Warning when a non-void function value is ignored.</source>
          <target state="translated">Предупреждение,когда игнорируется значение неотвратимой функции.</target>
        </trans-unit>
        <trans-unit id="6016747760c907aec70fe12b355cb7c681c5c0db" translate="yes" xml:space="preserve">
          <source>Warnings are diagnostic messages that report constructions that are not inherently erroneous but that are risky or suggest there may have been an error.</source>
          <target state="translated">Предупреждения-это диагностические сообщения,которые сообщают о конструкциях,которые по своей природе не являются ошибочными,но рискованными или предполагают,что могла быть ошибка.</target>
        </trans-unit>
        <trans-unit id="0dd982bec66fde4c74400108fddfd5cb384244af" translate="yes" xml:space="preserve">
          <source>Warnings may indicate danger points where you should check to make sure that your program really does what you intend; or the use of obsolete features; or the use of nonstandard features of GNU C or C++. Many warnings are issued only if you ask for them, with one of the</source>
          <target state="translated">Предупреждения могут указывать на опасные моменты,в которых вам следует проверить,действительно ли ваша программа делает то,что вы задумали;или на применение устаревших возможностей;или на применение нестандартных возможностей GNU C или C++.Многие предупреждения выдаются только в том случае,если вы их запрашиваете,с одним из следующих пунктов</target>
        </trans-unit>
        <trans-unit id="774110e2ee23eade4be0249d185f9d3f531f461a" translate="yes" xml:space="preserve">
          <source>Weak pointers are supported through a new type character specifier represented by the &amp;lsquo;</source>
          <target state="translated">Слабые указатели поддерживаются с помощью спецификатора символа нового типа, представленного символом '</target>
        </trans-unit>
        <trans-unit id="833f5330898dc442fd023004015464621900910e" translate="yes" xml:space="preserve">
          <source>What constitutes an access to a volatile object.</source>
          <target state="translated">Что представляет собой доступ к взрывоопасному объекту.</target>
        </trans-unit>
        <trans-unit id="29d1640b5550a77154368675da8078c8ec35026f" translate="yes" xml:space="preserve">
          <source>What constitutes an access to an object that has volatile-qualified type (C90 6.5.3, C99 and C11 6.7.3).</source>
          <target state="translated">Что представляет собой доступ к объекту,который имеет взрывоопасный тип (С90 6.5.3,С99 и С11 6.7.3).</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="73ab9ffb5b7365deaf1034842a4b9d0c5073a1f3" translate="yes" xml:space="preserve">
          <source>When G++ and another C++ compiler conform to the same C++ ABI, but the implementations of the Standard C++ Library that they normally use do not follow the same ABI for the Standard C++ Library, object files built with those compilers can be used in the same program only if they use the same C++ library. This requires specifying the location of the C++ library header files when invoking the compiler whose usual library is not being used. The location of GCC&amp;rsquo;s C++ header files depends on how the GCC build was configured, but can be seen by using the G++</source>
          <target state="translated">Когда G ++ и другой компилятор C ++ соответствуют одному и тому же ABI C ++, но реализации стандартной библиотеки C ++, которые они обычно используют, не соответствуют одному и тому же ABI для стандартной библиотеки C ++, объектные файлы, созданные с помощью этих компиляторов, могут использоваться в одной программе. только если они используют одну и ту же библиотеку C ++. Для этого необходимо указать расположение файлов заголовков библиотеки C ++ при вызове компилятора, обычная библиотека которого не используется. Расположение файлов заголовков C ++ GCC зависит от того, как была настроена сборка GCC, но это можно увидеть с помощью G ++</target>
        </trans-unit>
        <trans-unit id="25b318e1653c6b6dda339c34d9872ce5b96093ce" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the index of an array access known, it adds a bonus of</source>
          <target state="translated">Когда IPA-CP определяет,что кандидат на клонирование сделает известным индекс доступа к массиву,он добавляет бонус в размере</target>
        </trans-unit>
        <trans-unit id="3fbfba2a71ffaa54417e4d873e33ec3bbc19a7e4" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the number of iterations of a loop known, it adds a bonus of</source>
          <target state="translated">Когда IPA-CP определяет,что кандидат на клонирование сделает известным количество итераций петли,он добавляет бонус в размере</target>
        </trans-unit>
        <trans-unit id="0b074b049fd7c7f48c6da34e1272635cac52856d" translate="yes" xml:space="preserve">
          <source>When a base class is virtual, only one subobject of the base class belongs to each full object. Also, the constructors and destructors are invoked only once, and called from the most-derived class. However, such objects behave unspecified when being assigned. For example:</source>
          <target state="translated">Когда базовый класс является виртуальным,каждому полному объекту принадлежит только один подобъект базового класса.Кроме того,конструкторы и деструкторы вызываются только один раз и вызываются из самого полученного класса.Однако при назначении такие объекты ведут себя неуточненно.Например:</target>
        </trans-unit>
        <trans-unit id="67be4830f6cdd00004022ad6db1aaae5471c2589" translate="yes" xml:space="preserve">
          <source>When a class has static data members, it is not enough to &lt;em&gt;declare&lt;/em&gt; the static member; you must also &lt;em&gt;define&lt;/em&gt; it. For example:</source>
          <target state="translated">Когда класс имеет статические члены данных, недостаточно &lt;em&gt;объявить&lt;/em&gt; статический член; вы также должны &lt;em&gt;определить&lt;/em&gt; это. Например:</target>
        </trans-unit>
        <trans-unit id="d927dabaa85a2fec9fca96ddc5e395f531b27e67" translate="yes" xml:space="preserve">
          <source>When a division strategy has not been specified the default strategy is selected based on the current target. For SH2A the default strategy is to use the &lt;code&gt;divs&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions instead of library function calls.</source>
          <target state="translated">Если стратегия разделения не указана, стратегия по умолчанию выбирается на основе текущей цели. Для SH2A стратегия по умолчанию использовать &lt;code&gt;divs&lt;/code&gt; и &lt;code&gt;divu&lt;/code&gt; инструкции вместо вызовов функций библиотеки.</target>
        </trans-unit>
        <trans-unit id="0a75adb840378c14dc9a655e4aba002e527f73a2" translate="yes" xml:space="preserve">
          <source>When a file is compiled with</source>
          <target state="translated">Когда файл компилируется с</target>
        </trans-unit>
        <trans-unit id="0cd90cdfd69b208961a20a866e993339b4b5f840" translate="yes" xml:space="preserve">
          <source>When a function is both inline and &lt;code&gt;static&lt;/code&gt;, if all calls to the function are integrated into the caller, and the function&amp;rsquo;s address is never used, then the function&amp;rsquo;s own assembler code is never referenced. In this case, GCC does not actually output assembler code for the function, unless you specify the option</source>
          <target state="translated">Когда функция является как встроенной, так и &lt;code&gt;static&lt;/code&gt; , если все вызовы функции интегрированы в вызывающий объект, а адрес функции никогда не используется, то на собственный ассемблерный код функции никогда не ссылаются. В этом случае GCC фактически не выводит ассемблерный код для функции, если вы не укажете параметр</target>
        </trans-unit>
        <trans-unit id="678a6d73dd419ef65f8fe5fe05b5c39fad57f23c" translate="yes" xml:space="preserve">
          <source>When a list constructor stores the &lt;code&gt;begin&lt;/code&gt; pointer from the &lt;code&gt;initializer_list&lt;/code&gt; argument, this doesn&amp;rsquo;t extend the lifetime of the array, so if a class variable is constructed from a temporary &lt;code&gt;initializer_list&lt;/code&gt;, the pointer is left dangling by the end of the variable declaration statement.</source>
          <target state="translated">Когда конструктор списка сохраняет указатель &lt;code&gt;begin&lt;/code&gt; из аргумента &lt;code&gt;initializer_list&lt;/code&gt; , это не продлевает время существования массива, поэтому, если переменная класса создается из временного &lt;code&gt;initializer_list&lt;/code&gt; , указатель остается висящим к концу оператора объявления переменной.</target>
        </trans-unit>
        <trans-unit id="00f542136163060bf7630e6166417f9110c29edb" translate="yes" xml:space="preserve">
          <source>When a lock acquire fails, it is required for good performance to abort the transaction quickly. This can be done with a &lt;code&gt;_mm_pause&lt;/code&gt;.</source>
          <target state="translated">При сбое запроса блокировки для хорошей производительности требуется быстрое прерывание транзакции. Это можно сделать с помощью &lt;code&gt;_mm_pause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f7415b6c4bfc3b8582a73345fc35229f98c2491" translate="yes" xml:space="preserve">
          <source>When a type involving an ABI tag is used as the type of a variable or return type of a function where that tag is not already present in the signature of the function, the tag is automatically applied to the variable or function.</source>
          <target state="translated">Когда тип,включающий ABI-тег,используется в качестве типа переменной или возвращаемого типа функции,где этот тег еще не присутствует в сигнатуре функции,тег автоматически применяется к переменной или функции.</target>
        </trans-unit>
        <trans-unit id="6dad89b8cb0d35ea0fd46b863a5983c0e559d839" translate="yes" xml:space="preserve">
          <source>When added to an interrupt handler with the M32C port, causes the prologue and epilogue to use bank switching to preserve the registers rather than saving them on the stack.</source>
          <target state="translated">При добавлении в обработчик прерываний с портом M32C,заставляет пролог и эпилог использовать банковское переключение для сохранения регистров,а не для их сохранения в стеке.</target>
        </trans-unit>
        <trans-unit id="f8717fcf897c9e046dd756abc024e5f7d502ccd8" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;initializer_list&lt;/code&gt; variable is assigned from a brace-enclosed initializer list, the temporary array created for the right side of the assignment only lives until the end of the full-expression, so at the next statement the &lt;code&gt;initializer_list&lt;/code&gt; variable has a dangling pointer.</source>
          <target state="translated">Когда переменная &lt;code&gt;initializer_list&lt;/code&gt; назначается из заключенного в фигурные скобки списка инициализаторов, временный массив, созданный для правой стороны присваивания, живет только до конца полного выражения, поэтому в следующем операторе переменная &lt;code&gt;initializer_list&lt;/code&gt; имеет висящий указатель.</target>
        </trans-unit>
        <trans-unit id="f82873b6d13dce7be3f4357951354ec118469799" translate="yes" xml:space="preserve">
          <source>When an error message refers to a specialization of a function template, the compiler normally prints the signature of the template followed by the template arguments and any typedefs or typenames in the signature (e.g. &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; rather than &lt;code&gt;void f(int)&lt;/code&gt;) so that it&amp;rsquo;s clear which template is involved. When an error message refers to a specialization of a class template, the compiler omits any template arguments that match the default template arguments for that template. If either of these behaviors make it harder to understand the error message rather than easier, you can use</source>
          <target state="translated">Когда сообщение об ошибке относится к специализации шаблона функции, компилятор обычно печатает подпись шаблона, за которой следуют аргументы шаблона и любые определения типов или имена типов в подписи (например, &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; а не &lt;code&gt;void f(int)&lt;/code&gt; ), чтобы было понятно, какой шаблон задействован. Когда сообщение об ошибке относится к специализации шаблона класса, компилятор пропускает любые аргументы шаблона, которые соответствуют аргументам шаблона по умолчанию для этого шаблона. Если какое-либо из этих действий затрудняет понимание сообщения об ошибке, а не упрощает, вы можете использовать</target>
        </trans-unit>
        <trans-unit id="4a0782c5484322bfadd7fe79666979332dd01a38" translate="yes" xml:space="preserve">
          <source>When an executable is run in a massive parallel environment, it is recommended to save profile to different folders. That can be done with variables in &lt;var&gt;path&lt;/var&gt; that are exported during run-time:</source>
          <target state="translated">Когда исполняемый файл запускается в массивной параллельной среде, рекомендуется сохранять профиль в разные папки. Это можно сделать с помощью переменных в &lt;var&gt;path&lt;/var&gt; , которые экспортируются во время выполнения:</target>
        </trans-unit>
        <trans-unit id="d2c4f8c7d6b26eab60b9d9e100920ff031a8aaf4" translate="yes" xml:space="preserve">
          <source>When an inline function is not &lt;code&gt;static&lt;/code&gt;, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-&lt;code&gt;static&lt;/code&gt; inline function is always compiled on its own in the usual fashion.</source>
          <target state="translated">Когда встроенная функция не является &lt;code&gt;static&lt;/code&gt; , компилятор должен предположить, что могут быть вызовы из других исходных файлов; поскольку глобальный символ может быть определен только один раз в любой программе, функция не должна быть определена в других исходных файлах, поэтому вызовы в них не могут быть интегрированы. Поэтому &lt;code&gt;static&lt;/code&gt; встроенная функция всегда компилируется сама по себе обычным способом.</target>
        </trans-unit>
        <trans-unit id="b338539fbe33495121e46c5661e5bc16f008a3e0" translate="yes" xml:space="preserve">
          <source>When an insn has two alternative constraint-patterns.</source>
          <target state="translated">Когда у Insn есть два альтернативных способа ограничения.</target>
        </trans-unit>
        <trans-unit id="4cbff59218859bab09c21980b2597e3d4c6294f2" translate="yes" xml:space="preserve">
          <source>When an unrecognized warning option is requested (e.g.,</source>
          <target state="translated">Когда запрашивается нераспознанная опция предупреждения (например</target>
        </trans-unit>
        <trans-unit id="537d39cd77a447e897b80dd75224237bdc4e0719" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of 4-operand &lt;code&gt;madd.s&lt;/code&gt;, &lt;code&gt;madd.d&lt;/code&gt; and related instructions. Enabled by default.</source>
          <target state="translated">Если возможно, включите (отключите) генерацию 4-операндов &lt;code&gt;madd.s&lt;/code&gt; , &lt;code&gt;madd.d&lt;/code&gt; и связанных инструкций. Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4c26cdde33cc06bf31aab1a7bf63c69c29f00704" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of &lt;code&gt;lwxc1&lt;/code&gt;, &lt;code&gt;swxc1&lt;/code&gt;, &lt;code&gt;ldxc1&lt;/code&gt;, &lt;code&gt;sdxc1&lt;/code&gt; instructions. Enabled by default.</source>
          <target state="translated">Если применимо, включите (отключите) создание &lt;code&gt;lwxc1&lt;/code&gt; , &lt;code&gt;swxc1&lt;/code&gt; , &lt;code&gt;ldxc1&lt;/code&gt; , &lt;code&gt;sdxc1&lt;/code&gt; . Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7184e15e5684528f54729686834cdf00887683be" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks defined non-inlined member functions and static data members as exports. Static consts initialized in-class are not marked unless they are also defined out-of-class.</source>
          <target state="translated">При применении к классам C++,метки атрибутов определяли в качестве экспортируемых необлицованные функции-члены и статические члены данных.Статические консоли,инициализированные в классе,не отмечаются,если только они также не определены вне класса.</target>
        </trans-unit>
        <trans-unit id="7d9feaafaf97b8f7fe46d8b6b598964809d89431" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks non-inlined member functions and static data members as imports. However, the attribute is ignored for virtual methods to allow creation of vtables using thunks.</source>
          <target state="translated">При применении к классам C++атрибут отмечает в качестве импорта необлицованные функции-члены и статические члены данных.Однако,атрибут игнорируется для виртуальных методов,чтобы позволить создание таблиц с использованием thunks.</target>
        </trans-unit>
        <trans-unit id="bbf180b63c03eb34a3aba311a968f02d5135ed3e" translate="yes" xml:space="preserve">
          <source>When applied to a member function of a C++ class template, the attribute also means that the function is instantiated if the class itself is instantiated.</source>
          <target state="translated">При применении к функции-члену шаблона класса C++атрибут также означает,что функция инстанцируется,если инстанцируется сам класс.</target>
        </trans-unit>
        <trans-unit id="cabddb6e825602d843a117fb734ca3aff3112d1a" translate="yes" xml:space="preserve">
          <source>When applied to a static data member of a C++ class template, the attribute also means that the member is instantiated if the class itself is instantiated.</source>
          <target state="translated">При применении к статическому члену данных шаблона класса C++атрибут также означает,что этот член инстанцируется,если сам класс инстанцируется.</target>
        </trans-unit>
        <trans-unit id="59f0e6f1d8d71dac3701cee27ca42c33aae99e5f" translate="yes" xml:space="preserve">
          <source>When attached to a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, this attribute sets the storage order, aka endianness, of the scalar fields of the type, as well as the array fields whose component is scalar. The supported endiannesses are &lt;code&gt;big-endian&lt;/code&gt; and &lt;code&gt;little-endian&lt;/code&gt;. The attribute has no effects on fields which are themselves a &lt;code&gt;union&lt;/code&gt;, a &lt;code&gt;struct&lt;/code&gt; or an array whose component is a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, and it is possible for these fields to have a different scalar storage order than the enclosing type.</source>
          <target state="translated">При присоединении к &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; этот атрибут устанавливает порядок хранения, также называемый порядком следования байтов, скалярных полей типа, а также полей массива, компонент которых является скалярным. Поддерживаемые endiannesses являются &lt;code&gt;big-endian&lt;/code&gt; и &lt;code&gt;little-endian&lt;/code&gt; . Атрибут не влияет на поля, которые сами являются &lt;code&gt;union&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; или массивом, компонентом которого является &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; , и эти поля могут иметь другой скалярный порядок хранения, чем включающий тип.</target>
        </trans-unit>
        <trans-unit id="5370f9b64efe5c0ffe3fe15dfade832ac9be14df" translate="yes" xml:space="preserve">
          <source>When attached to a type (including a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;), this attribute means that variables of that type are meant to appear possibly unused. GCC does not produce a warning for any variables of that type, even if the variable appears to do nothing. This is often the case with lock or thread classes, which are usually defined and then not referenced, but contain constructors and destructors that have nontrivial bookkeeping functions.</source>
          <target state="translated">При присоединении к типу (включая &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; ) этот атрибут означает, что переменные этого типа могут казаться неиспользуемыми. GCC не выдает предупреждения ни для каких переменных этого типа, даже если переменная ничего не делает. Это часто случается с классами блокировки или потоков, которые обычно определяются, а затем не упоминаются, но содержат конструкторы и деструкторы, которые имеют нетривиальные бухгалтерские функции.</target>
        </trans-unit>
        <trans-unit id="607b6b9a753f4dcb8aa6e646687045411231d9db" translate="yes" xml:space="preserve">
          <source>When attached to an &lt;code&gt;enum&lt;/code&gt; definition, the &lt;code&gt;packed&lt;/code&gt; attribute indicates that the smallest integral type should be used. Specifying the</source>
          <target state="translated">Когда он прикреплен к определению &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;packed&lt;/code&gt; атрибут указывает, что следует использовать наименьший интегральный тип. Указание</target>
        </trans-unit>
        <trans-unit id="3212c36750452527c536dd1eddfa9228aa24bc41" translate="yes" xml:space="preserve">
          <source>When branch is predicted to be taken with probability lower than this threshold (in percent), then it is considered well predictable.</source>
          <target state="translated">Когда предсказывается,что ветка будет взята с вероятностью ниже этого порога (в процентах),то это считается хорошо предсказуемым.</target>
        </trans-unit>
        <trans-unit id="f92818ac1f6c1cf9820bd7ad2460f0b770895e75" translate="yes" xml:space="preserve">
          <source>When branch probabilities are given, include those of unconditional branches. Unconditional branches are normally not interesting.</source>
          <target state="translated">Когда приводятся вероятности ветвей,включайте вероятности безусловных ветвей.Безусловные ветви обычно не интересны.</target>
        </trans-unit>
        <trans-unit id="0ae42b215512052c2cadc23355c16f5c5dd443cf" translate="yes" xml:space="preserve">
          <source>When calling routines that are not aware of the reservation, be cautious if those routines call back into code which uses them. As an example, if you call the system library version of &lt;code&gt;qsort&lt;/code&gt;, it may clobber your registers during execution, but (if you have selected appropriate registers) it will restore them before returning. However it will &lt;em&gt;not&lt;/em&gt; restore them before calling &lt;code&gt;qsort&lt;/code&gt;&amp;rsquo;s comparison function. As a result, global values will not reliably be available to the comparison function unless the &lt;code&gt;qsort&lt;/code&gt; function itself is rebuilt.</source>
          <target state="translated">При вызове подпрограмм, которые не знают о резервировании, будьте осторожны, если эти подпрограммы обращаются к коду, который их использует. Например, если вы вызываете версию &lt;code&gt;qsort&lt;/code&gt; из системной библиотеки , она может сбивать ваши регистры во время выполнения, но (если вы выбрали соответствующие регистры) восстановит их перед возвратом. Однако он &lt;em&gt;не&lt;/em&gt; восстановит их до вызова &lt;code&gt;qsort&lt;/code&gt; сравнения qsort . В результате глобальные значения не будут надежно доступны для функции сравнения, если сама функция &lt;code&gt;qsort&lt;/code&gt; не будет перестроена.</target>
        </trans-unit>
        <trans-unit id="6ce64a23abaaddcfa5831e43098fffe47be4e539" translate="yes" xml:space="preserve">
          <source>When casting from pointer to integer and back again, the resulting pointer must reference the same object as the original pointer, otherwise the behavior is undefined. That is, one may not use integer arithmetic to avoid the undefined behavior of pointer arithmetic as proscribed in C99 and C11 6.5.6/8.</source>
          <target state="translated">При приведении от указателя к целому и обратно результирующий указатель должен ссылаться на тот же объект,что и исходный указатель,иначе поведение будет неопределенным.То есть нельзя использовать целочисленную арифметику,чтобы избежать неопределённого поведения арифметики с указателями,как это запрещено в C99 и C11 6.5.6/8.</target>
        </trans-unit>
        <trans-unit id="4a6770a95cb182eb94130a66a137214e2a89e539" translate="yes" xml:space="preserve">
          <source>When code compiled with</source>
          <target state="translated">При компиляции кода с</target>
        </trans-unit>
        <trans-unit id="2694a5fd19642dc29f67abfd4afa306ec8d78457" translate="yes" xml:space="preserve">
          <source>When compiling C++, warn about the deprecated conversion from string literals to &lt;code&gt;char *&lt;/code&gt;. This warning is enabled by default for C++ programs.</source>
          <target state="translated">При компиляции C ++ предупредите об устаревшем преобразовании строковых литералов в &lt;code&gt;char *&lt;/code&gt; . Это предупреждение включено по умолчанию для программ на C ++.</target>
        </trans-unit>
        <trans-unit id="b58e8f8f470141f0b7d65fa2b304a55713649c15" translate="yes" xml:space="preserve">
          <source>When compiling C, give string constants the type &lt;code&gt;const
char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; so that copying the address of one into a non-&lt;code&gt;const&lt;/code&gt;&lt;code&gt;char *&lt;/code&gt; pointer produces a warning. These warnings help you find at compile time code that can try to write into a string constant, but only if you have been very careful about using &lt;code&gt;const&lt;/code&gt; in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not make</source>
          <target state="translated">При компиляции C присвойте строковым константам тип &lt;code&gt;const char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; чтобы при копировании адреса одной в указатель, не являющийся &lt;code&gt;const&lt;/code&gt; &lt;code&gt;char *&lt;/code&gt; , вызывалось предупреждение. Эти предупреждения помогут вам найти время компиляции кода , который может попытаться записать в строковую константу, но только если вы были очень осторожны при использовании &lt;code&gt;const&lt;/code&gt; в объявлениях и прототипах. В остальном это просто неприятность. Вот почему мы не сделали</target>
        </trans-unit>
        <trans-unit id="cd87062968fd1ca6c15b5a9b85fba86d8a5ccfc2" translate="yes" xml:space="preserve">
          <source>When compiling code for single processor systems, it is generally safe to use &lt;code&gt;synci&lt;/code&gt;. However, on many multi-core (SMP) systems, it does not invalidate the instruction caches on all cores and may lead to undefined behavior.</source>
          <target state="translated">При компиляции кода для однопроцессорных систем обычно безопасно использовать &lt;code&gt;synci&lt;/code&gt; . Однако во многих многоядерных (SMP) системах это не делает недействительными кеши инструкций на всех ядрах и может привести к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="7c10c0020a810534faa4083bee532dbff326c982" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed MIPS16 and non-MIPS16 code, the preprocessor symbol &lt;code&gt;__mips16&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed MIPS16 and non-MIPS16 code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">При компиляции файлов, содержащих смешанный код MIPS16 и не-MIPS16, символ препроцессора &lt;code&gt;__mips16&lt;/code&gt; отражает настройку в командной строке, а не в отдельных функциях. Смешанный код MIPS16 и не-MIPS16 может плохо взаимодействовать с некоторыми расширениями GCC, такими как &lt;code&gt;__builtin_apply&lt;/code&gt; (см. &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Создание вызовов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="60deff215e04b72131ce496d836442fb3376a9ed" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed microMIPS and non-microMIPS code, the preprocessor symbol &lt;code&gt;__mips_micromips&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed microMIPS and non-microMIPS code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">При компиляции файлов, содержащих смешанный код microMIPS и не microMIPS, символ препроцессора &lt;code&gt;__mips_micromips&lt;/code&gt; отражает настройку в командной строке, а не в отдельных функциях. Смешанный код microMIPS и не-microMIPS может плохо взаимодействовать с некоторыми расширениями GCC, такими как &lt;code&gt;__builtin_apply&lt;/code&gt; (см. &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Создание вызовов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b21353af5c286cba09d175d058607a98bab9646" translate="yes" xml:space="preserve">
          <source>When compiling files residing in directory</source>
          <target state="translated">При компиляции файлов,находящихся в каталоге</target>
        </trans-unit>
        <trans-unit id="fb1c662fe80e2a5daa84889e9b20929141a1f39e" translate="yes" xml:space="preserve">
          <source>When compiling for Nios II, the following options are allowed:</source>
          <target state="translated">При компиляции для Nios II допускаются следующие варианты:</target>
        </trans-unit>
        <trans-unit id="47a745ce02eda6e5b8af0283813b8d27ac893e5a" translate="yes" xml:space="preserve">
          <source>When compiling for the NeXT runtime, the compiler ordinarily replaces calls to &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; (when the name of the class is known at compile time) with static class references that get initialized at load time, which improves run-time performance. Specifying the</source>
          <target state="translated">При компиляции для среды выполнения NeXT компилятор обычно заменяет вызовы &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; (когда имя класса известно во время компиляции) статическими ссылками на классы, которые инициализируются во время загрузки, что улучшает производительность во время выполнения. Указание</target>
        </trans-unit>
        <trans-unit id="7acd9f9e9a72745fc09c352c58646de2d43a5f5e" translate="yes" xml:space="preserve">
          <source>When compiling functions that return &lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt;, PCC converts it to a double. GCC actually returns a &lt;code&gt;float&lt;/code&gt;. If you are concerned with PCC compatibility, you should declare your functions to return &lt;code&gt;double&lt;/code&gt;; you might as well say what you mean.</source>
          <target state="translated">При компиляции функций, возвращающих &lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt; , PCC преобразует его в double. GCC фактически возвращает число с &lt;code&gt;float&lt;/code&gt; . Если вас беспокоит совместимость с PCC, вы должны объявить, что ваши функции возвращают &lt;code&gt;double&lt;/code&gt; ; с таким же успехом вы можете сказать то, что имеете в виду.</target>
        </trans-unit>
        <trans-unit id="d5db0043541449725fbfb6c49474d3dea04ea8f6" translate="yes" xml:space="preserve">
          <source>When compiling functions that return structures or unions, GCC output code normally uses a method different from that used on most versions of Unix. As a result, code compiled with GCC cannot call a structure-returning function compiled with PCC, and vice versa.</source>
          <target state="translated">При компиляции функций,возвращающих структуры или объединения,выходной код GCC обычно использует метод,отличный от используемого в большинстве версий Unix.В результате,код,скомпилированный с помощью GCC,не может вызвать функцию возврата структуры,скомпилированную с помощью PCC,и наоборот.</target>
        </trans-unit>
        <trans-unit id="42802196182be1a26f30e794627d93f753ad7250" translate="yes" xml:space="preserve">
          <source>When compiling using the AAPCS ABI (or a variant of it) then valid values for the argument are &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; and &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;. In order to use a variant other than &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; then the compiler must be permitted to use the appropriate co-processor registers (i.e., the VFP registers must be available in order to use &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;). For example,</source>
          <target state="translated">При компиляции с использованием AAPCS ABI (или его варианта) допустимые значения для аргумента - &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; и &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; . Чтобы использовать вариант, отличный от &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; компилятору должно быть разрешено использовать соответствующие регистры сопроцессора (т. &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; VFP должны быть доступны для использования &amp;laquo;aapcs-vfp&amp;raquo; ). Например,</target>
        </trans-unit>
        <trans-unit id="6f269c2c80bc0b6cd00bdccd1a4ad395d3f1e317" translate="yes" xml:space="preserve">
          <source>When compiling, this option enables</source>
          <target state="translated">При компиляции,эта опция включает</target>
        </trans-unit>
        <trans-unit id="315f128e4ce30c782f28bfb565507bc8d99b6552" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps (see</source>
          <target state="translated">При отладке дампа (см.</target>
        </trans-unit>
        <trans-unit id="dce8f6e7dddb2ada38853381a56083f98e91e173" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different compiler binaries and/or different text / bss / data / heap / stack / dso start locations.</source>
          <target state="translated">При отладке дампа подавляйте вывод адресов.Это делает более целесообразным использование diff при отладке дампов для вызовов компилятора с различными двоичными файлами компилятора и/или различными текстовыми/bss/data/heap/stack/dso стартовыми точками.</target>
        </trans-unit>
        <trans-unit id="5cb94325a71b749cb8e5d8b4041d1d7a131d0f11" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress instruction numbers and address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different options, in particular with and without</source>
          <target state="translated">При отладке дампа подавляйте номера команд и вывод адресов.Это делает более целесообразным использование diff при отладке дампов для вызовов компилятора с различными опциями,в частности,с и без</target>
        </trans-unit>
        <trans-unit id="6a3f0b550d9291ec66729667f3f7ca83fd2f4d8b" translate="yes" xml:space="preserve">
          <source>When dumping RTL, print the RTL in slim (condensed) form instead of the default LISP-like representation.</source>
          <target state="translated">При демпинге RTL,распечатайте RTL в тонком (конденсированном)виде вместо LISP-подобного представления по умолчанию.</target>
        </trans-unit>
        <trans-unit id="74301d6d6862291588f10bf29b45b4967ce13d2f" translate="yes" xml:space="preserve">
          <source>When dumping front-end intermediate representations, inhibit dumping of members of a scope or body of a function merely because that scope has been reached. Only dump such items when they are directly reachable by some other path.</source>
          <target state="translated">При сбросе фронтальных промежуточных представлений препятствуйте сбросу членов области видимости или тела функции только потому,что эта область видимости была достигнута.Выдавать такие элементы только тогда,когда они непосредственно доступны по какому-либо другому пути.</target>
        </trans-unit>
        <trans-unit id="f945883699fc9792ba3afeb26f744a7773586ecc" translate="yes" xml:space="preserve">
          <source>When dumping pretty-printed trees, this option inhibits dumping the bodies of control structures.</source>
          <target state="translated">При сбросе красиво напечатанных деревьев эта опция препятствует сбросу тел структур управления.</target>
        </trans-unit>
        <trans-unit id="6fc1555729570caee324aa057f7026754c896f3e" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural bitwise constant propagation. This flag is enabled by default at</source>
          <target state="translated">Если включено,выполняйте межпроцедурное битовое распространение константы.Этот флаг включен по умолчанию при</target>
        </trans-unit>
        <trans-unit id="bf82f180e269afc159377aa835c2b162d457aecd" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural propagation of value ranges. This flag is enabled by default at</source>
          <target state="translated">Если включено,выполните межпроцедурное распространение диапазонов значений.Этот флаг включен по умолчанию при</target>
        </trans-unit>
        <trans-unit id="5a6db9d98413978e8951a290a39c293b6dbce38a" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain CSYNC or SSYNC instructions too soon after conditional branches. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; is defined.</source>
          <target state="translated">Если этот параметр включен, компилятор гарантирует, что сгенерированный код не содержит инструкций CSYNC или SSYNC слишком быстро после условных переходов. Если используется эта опция, определяется &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cabeafae5f5d65fb548beb5767960c04d9a35b8" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain speculative loads after jump instructions. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; is defined.</source>
          <target state="translated">Если этот параметр включен, компилятор гарантирует, что сгенерированный код не содержит спекулятивных нагрузок после инструкций перехода. Если используется эта опция, определяется &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="177174ed256fb1fc5ac1ff6e0a69365e95922527" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler is free to take advantage of the knowledge that the entire program fits into the low 64k of memory.</source>
          <target state="translated">При включении компилятор может свободно воспользоваться знанием того,что вся программа помещается в низкий уровень 64k памяти.</target>
        </trans-unit>
        <trans-unit id="f1158beec156e6a8ecff5cd217a56a66d53e95d9" translate="yes" xml:space="preserve">
          <source>When enabled, this option states that a range reduction step is not needed when performing complex division. Also, there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case. The default is</source>
          <target state="translated">Если этот параметр включен, то при выполнении сложного деления шаг уменьшения диапазона не требуется. Кроме того, не проверяется, равен ли результат сложного умножения или деления &lt;code&gt;NaN + I*NaN&lt;/code&gt; , с попыткой спасти ситуацию в этом случае. По умолчанию</target>
        </trans-unit>
        <trans-unit id="5c41cf550423b99323059ab9102f75c243821bb0" translate="yes" xml:space="preserve">
          <source>When estimated performance improvement of caller + callee runtime exceeds this threshold (in percent), the function can be inlined regardless of the limit on</source>
          <target state="translated">Когда предполагаемое улучшение производительности вызывающего+вызываемого абонента превышает этот порог (в процентах),функция может быть включена независимо от лимита на</target>
        </trans-unit>
        <trans-unit id="0546498041d4ec0ccfc5ce36934cf27647842a41" translate="yes" xml:space="preserve">
          <source>When generating PIC code, do or don&amp;rsquo;t allow the use of PLTs. Ignored for non-PIC. The default is</source>
          <target state="translated">При генерации кода PIC разрешать или запрещать использование PLT. Игнорируется для не-PIC. По умолчанию</target>
        </trans-unit>
        <trans-unit id="511bcbbf68adbe04ec79792863471cde6b014863" translate="yes" xml:space="preserve">
          <source>When generating a function that returns a pointer, return the pointer in both &lt;code&gt;a0&lt;/code&gt; and &lt;code&gt;d0&lt;/code&gt;. Otherwise, the pointer is returned only in &lt;code&gt;a0&lt;/code&gt;, and attempts to call such functions without a prototype result in errors. Note that this option is on by default; use</source>
          <target state="translated">При создании функции, возвращающей указатель, возвращайте указатель как в &lt;code&gt;a0&lt;/code&gt; ,так и в &lt;code&gt;d0&lt;/code&gt; . В противном случае указатель возвращается только в &lt;code&gt;a0&lt;/code&gt; , и попытки вызвать такие функции без прототипа приводят к ошибкам. Обратите внимание, что этот параметр включен по умолчанию; использование</target>
        </trans-unit>
        <trans-unit id="dd2029500976920c4504065ca16226229e4f7c22" translate="yes" xml:space="preserve">
          <source>When generating assembler output use a syntax that is compatible with Renesas&amp;rsquo;s AS100 assembler. This syntax can also be handled by the GAS assembler, but it has some restrictions so it is not generated by default.</source>
          <target state="translated">При создании вывода на ассемблере используйте синтаксис, совместимый с ассемблером Renesas AS100. Этот синтаксис также может обрабатываться ассемблером GAS, но у него есть некоторые ограничения, поэтому он не генерируется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="34010eecdc80bda1996b3453a5842eca5948c6ad" translate="yes" xml:space="preserve">
          <source>When generating code for shared libraries,</source>
          <target state="translated">При генерации кода для разделяемых библиотек,</target>
        </trans-unit>
        <trans-unit id="ee57ba558572772d8e7d0fd148c855146cc649ba" translate="yes" xml:space="preserve">
          <source>When generating code for the x86-64 architecture with SSE extensions disabled,</source>
          <target state="translated">При генерации кода для архитектуры x86-64 с отключенными SSE расширениями,</target>
        </trans-unit>
        <trans-unit id="8c85713507dce4f24637fdca8c9dd42ecd242b3b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code for ColdFire, generate code that works if the GOT has more than 8192 entries. This code is larger and slower than code generated without this option. On M680x0 processors, this option is not needed;</source>
          <target state="translated">При генерации позиционно-независимого кода для ColdFire,генерируйте код,который работает,если GOT имеет более 8192 записей.Этот код больше и медленнее,чем код,генерируемый без этой опции.На процессорах M680x0 эта опция не требуется;</target>
        </trans-unit>
        <trans-unit id="ddb821edf6cd4d8eabb391980c4305801a4dd35b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code, emit function calls using the Global Offset Table instead of the Procedure Linkage Table.</source>
          <target state="translated">При генерации позиционно-независимого кода,излучайте вызовы функций с использованием Глобальной таблицы смещений вместо Таблицы связи процедур.</target>
        </trans-unit>
        <trans-unit id="58318867846389e3f00483e730d9cdc45f04b844" translate="yes" xml:space="preserve">
          <source>When implementing patterns for these built-in functions, the memory order parameter can be ignored as long as the pattern implements the most restrictive &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; memory order. Any of the other memory orders execute correctly with this memory order but they may not execute as efficiently as they could with a more appropriate implementation of the relaxed requirements.</source>
          <target state="translated">При реализации шаблонов для этих встроенных функций параметр порядка памяти можно игнорировать, пока шаблон реализует наиболее строгий &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; памяти __ATOMIC_SEQ_CST . Любой из других порядков памяти выполняется правильно с этим порядком памяти, но они могут выполняться не так эффективно, как могли бы при более подходящей реализации ослабленных требований.</target>
        </trans-unit>
        <trans-unit id="e9af953ed4f40761c964f415712e4b881671dfb2" translate="yes" xml:space="preserve">
          <source>When linking a big-endian image select between BE8 and BE32 formats. The option has no effect for little-endian images and is ignored. The default is dependent on the selected target architecture. For ARMv6 and later architectures the default is BE8, for older architectures the default is BE32. BE32 format has been deprecated by ARM.</source>
          <target state="translated">При привязке изображения с большой диагональю выберите между форматами BE8 и BE32.Опция не имеет эффекта для биг-ендианских растров и игнорируется.Значение по умолчанию зависит от выбранной целевой архитектуры.Для архитектур ARMv6 и более поздних версий по умолчанию используется BE8,для более старых архитектур-BE32.Формат BE32 был устарел от ARM.</target>
        </trans-unit>
        <trans-unit id="920068058745daad77bac4500e9d9b0ac2200c05" translate="yes" xml:space="preserve">
          <source>When making copies of thread-local variables in a transaction, this parameter specifies the size in bytes after which variables are saved with the logging functions as opposed to save/restore code sequence pairs. This option only applies when using</source>
          <target state="translated">При копировании потоколокальных переменных в транзакции данный параметр задает размер в байтах,после чего переменные сохраняются функциями протоколирования,а не парами сохранения/восстановления последовательности кода.Данный параметр применяется только при использовании</target>
        </trans-unit>
        <trans-unit id="20fd5eb54a80ab92bcf13e1600542aa28ff5d13b" translate="yes" xml:space="preserve">
          <source>When mangling a function type with function-cv-qualifiers, the un-qualified function type was incorrectly treated as a substitution candidate.</source>
          <target state="translated">При использовании функционального типа с функциями-cv-квалификаторами,неквалифицированный тип функции ошибочно рассматривался как кандидат на замену.</target>
        </trans-unit>
        <trans-unit id="6e16f38a870c014c4bf05a4ba66aff0d8f015c53" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are three output operands, use &amp;lsquo;</source>
          <target state="translated">Если &lt;var&gt;asmSymbolicName&lt;/var&gt; не используется, используйте позицию (отсчитывающуюся от нуля) операнда в списке операндов в шаблоне ассемблера. Например, если есть три выходных операнда, используйте '</target>
        </trans-unit>
        <trans-unit id="f7f108470bcf6e6b304f3263a3362bac9bf0990f" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are two output operands and three inputs, use &amp;lsquo;</source>
          <target state="translated">Если &lt;var&gt;asmSymbolicName&lt;/var&gt; не используется, используйте позицию (отсчитывающуюся от нуля) операнда в списке операндов в шаблоне ассемблера. Например, если есть два выходных операнда и три входа, используйте '</target>
        </trans-unit>
        <trans-unit id="9ab94547949a5e4c3215ae42df94303adb7916f4" translate="yes" xml:space="preserve">
          <source>When optimizing for size (using</source>
          <target state="translated">При оптимизации размера (используя</target>
        </trans-unit>
        <trans-unit id="97bc78492cc0f58dc12735620055de6a1daa4843" translate="yes" xml:space="preserve">
          <source>When passed this option, GCC produces a dynamic library instead of an executable when linking, using the Darwin</source>
          <target state="translated">При передаче этой опции GCC создает динамическую библиотеку вместо исполняемого файла при линковке,используя Darwin</target>
        </trans-unit>
        <trans-unit id="f2411855bc2157c02295a4d406d5bb74f6ed2885" translate="yes" xml:space="preserve">
          <source>When performing a stack backtrace, code can inspect the value of &lt;code&gt;pc&lt;/code&gt; stored at &lt;code&gt;fp + 0&lt;/code&gt;. If the trace function then looks at location &lt;code&gt;pc - 12&lt;/code&gt; and the top 8 bits are set, then we know that there is a function name embedded immediately preceding this location and has length &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt;.</source>
          <target state="translated">При выполнении трассировки стека код может проверять значение &lt;code&gt;pc&lt;/code&gt; , хранящееся в &lt;code&gt;fp + 0&lt;/code&gt; . Если функция трассировки затем смотрит на местоположение &lt;code&gt;pc - 12&lt;/code&gt; и установлены верхние 8 бит, то мы знаем, что имя функции встроено непосредственно перед этим местоположением и имеет длину &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f597a9e8b63ff1121b0842bcdb388264d1b3c5ff" translate="yes" xml:space="preserve">
          <source>When performing branch target register load optimization, don&amp;rsquo;t reuse branch target registers within any basic block.</source>
          <target state="translated">При выполнении оптимизации загрузки целевого регистра перехода не используйте повторно целевые регистры перехода в любом базовом блоке.</target>
        </trans-unit>
        <trans-unit id="9c01537a52102dd8946fc5982208fe491740f320" translate="yes" xml:space="preserve">
          <source>When pipelining loops during selective scheduling, also pipeline outer loops. This option has no effect unless</source>
          <target state="translated">При селективной прокладке трубопроводных контуров во время селективного планирования,необходимо также прокладывать внешние контуры трубопровода.Этот вариант не имеет эффекта,если только</target>
        </trans-unit>
        <trans-unit id="1280e31b08d3497c525b6d236dd8d4d87c36c837" translate="yes" xml:space="preserve">
          <source>When preprocessing files residing in directory</source>
          <target state="translated">При препроцессировании файлов,находящихся в каталоге</target>
        </trans-unit>
        <trans-unit id="18019b7cb63563a2a1382c41adbfffdfc589112f" translate="yes" xml:space="preserve">
          <source>When preprocessing, do not shorten system header paths with canonicalization.</source>
          <target state="translated">При препроцессировании не укорачивайте системные пути заголовков с каноническим исполнением.</target>
        </trans-unit>
        <trans-unit id="2727468a8d8ea18794592843d12955ca0144b622" translate="yes" xml:space="preserve">
          <source>When preprocessing, handle directives, but do not expand macros.</source>
          <target state="translated">При препроцессировании обрабатывайте директивы,но не расширяйте макросы.</target>
        </trans-unit>
        <trans-unit id="bb09a7ade548f20e19021a30661ff4362be9b030" translate="yes" xml:space="preserve">
          <source>When printing percentages, 0% and 100% are only printed when the values are &lt;em&gt;exactly&lt;/em&gt; 0% and 100% respectively. Other values which would conventionally be rounded to 0% or 100% are instead printed as the nearest non-boundary value.</source>
          <target state="translated">При печати в процентах, 0% и 100% печатаются только тогда , когда значения &lt;em&gt;ровно&lt;/em&gt; 0% и 100% соответственно. Другие значения, которые обычно округляются до 0% или 100%, вместо этого печатаются как ближайшее не граничное значение.</target>
        </trans-unit>
        <trans-unit id="814abd66e9c273530f2d56ad0a0cd6cc246294fd" translate="yes" xml:space="preserve">
          <source>When producing the final binary, GCC only applies link-time optimizations to those files that contain bytecode. Therefore, you can mix and match object files and libraries with GIMPLE bytecodes and final object code. GCC automatically selects which files to optimize in LTO mode and which files to link without further processing.</source>
          <target state="translated">При создании финального двоичного файла GCC применяет оптимизацию во времени компоновки только к тем файлам,которые содержат байткод.Таким образом,вы можете смешивать и сопоставлять объектные файлы и библиотеки с байткодами GIMPLE и конечным объектным кодом.GCC автоматически выбирает,какие файлы оптимизировать в режиме LTO,а какие компоновать без дальнейшей обработки.</target>
        </trans-unit>
        <trans-unit id="b96765bcbef2cdc563af58e2e7b14e500edcf025" translate="yes" xml:space="preserve">
          <source>When profile feedback is available (see</source>
          <target state="translated">Когда доступен отзыв профиля (см.</target>
        </trans-unit>
        <trans-unit id="21ec7c5b40c9ae6af5acdf4a048ad5c0d3bce4e5" translate="yes" xml:space="preserve">
          <source>When profile feedback is available, via</source>
          <target state="translated">Когда отзыв профиля доступен,через</target>
        </trans-unit>
        <trans-unit id="2f272057236473f0d19fb086d6183a38dfbd5bad" translate="yes" xml:space="preserve">
          <source>When reading data from memory in sizes shorter than 64 bits, use (do not use) zero-extending load instructions by default, rather than sign-extending ones.</source>
          <target state="translated">При чтении данных из памяти размером меньше 64 бит используйте (не используйте)по умолчанию не знаково-расширяющие инструкции загрузки,а нулевые.</target>
        </trans-unit>
        <trans-unit id="f96511339203319c533d1e5bb317204cec489683" translate="yes" xml:space="preserve">
          <source>When scheduling after register allocation, use superblock scheduling. This allows motion across basic block boundaries, resulting in faster schedules. This option is experimental, as not all machine descriptions used by GCC model the CPU closely enough to avoid unreliable results from the algorithm.</source>
          <target state="translated">При составлении расписания после распределения регистров используйте планирование суперблоков.Это позволяет перемещаться через границы основных блоков,что приводит к более быстрому составлению расписаний.Эта опция является экспериментальной,так как не все описания машин,используемые GCC моделью CPU достаточно близко,чтобы избежать ненадежных результатов от алгоритма.</target>
        </trans-unit>
        <trans-unit id="711283accf977e698dde3a25dc400a61116947e3" translate="yes" xml:space="preserve">
          <source>When selecting a register, choose one that is normally saved and restored by function calls on your machine. This ensures that code which is unaware of this reservation (such as library routines) will restore it before returning.</source>
          <target state="translated">При выборе регистра выберите тот,который обычно сохраняется и восстанавливается по вызовам функций на вашем аппарате.Это гарантирует,что код,который не знает об этом резервировании (например,библиотечные процедуры),восстановит его перед возвращением.</target>
        </trans-unit>
        <trans-unit id="935d1b181ddc0bd3e6f68299a5752f8a09580e76" translate="yes" xml:space="preserve">
          <source>When selecting this option, be aware that the standard library headers do not obey all of these guidelines; use &amp;lsquo;</source>
          <target state="translated">Выбирая эту опцию, помните, что заголовки стандартной библиотеки не подчиняются всем этим рекомендациям; использовать '</target>
        </trans-unit>
        <trans-unit id="30da98647c378a61b9ead522311838c64d97cf26" translate="yes" xml:space="preserve">
          <source>When supplied with a 128-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a quad-precision ieee floating point value. The sign bit of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 15 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 112 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="translated">При наличии 128-битного первого аргумента встроенная функция &lt;code&gt;scalar_insert_exp&lt;/code&gt; возвращает значение с плавающей запятой ieee с четырехкратной точностью. Знаковый бит результата копируется из старшего разряда &lt;code&gt;significand&lt;/code&gt; аргумента. Мантиссы и экспоненты компоненты результата состоят из наименее значимых 15 битых &lt;code&gt;exponent&lt;/code&gt; аргумента и наименее значимых бит 112 в &lt;code&gt;significand&lt;/code&gt; аргумента соответственно.</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">Когда</target>
        </trans-unit>
        <trans-unit id="82085de4f0e784cd78a6493470847db57c3b16cf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;g++&lt;/code&gt; program is used to link a C++ program, it normally automatically links against</source>
          <target state="translated">Когда программа &lt;code&gt;g++&lt;/code&gt; используется для связывания программы на C ++, она обычно автоматически связывается с</target>
        </trans-unit>
        <trans-unit id="9d1f5e646a4aa7fceb07c0207db652e826f24dbb" translate="yes" xml:space="preserve">
          <source>When the address-of operator is applied to a thread-local variable, it is evaluated at run time and returns the address of the current thread&amp;rsquo;s instance of that variable. An address so obtained may be used by any thread. When a thread terminates, any pointers to thread-local variables in that thread become invalid.</source>
          <target state="translated">Когда оператор адресации применяется к локальной переменной потока, она оценивается во время выполнения и возвращает адрес экземпляра этой переменной текущего потока. Полученный таким образом адрес может использоваться любым потоком. Когда поток завершается, любые указатели на локальные переменные потока в этом потоке становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="0b679da0a8fd732962aaaa73513d25a32daf4775" translate="yes" xml:space="preserve">
          <source>When the compiled program exits it saves this data to a file called</source>
          <target state="translated">Когда скомпилированная программа выходит из программы,она сохраняет эти данные в файл с именем</target>
        </trans-unit>
        <trans-unit id="ba14367decd6810d3de98e37ab796a274e5fcb83" translate="yes" xml:space="preserve">
          <source>When the compiler creates the statically allocated constant string object, the &lt;code&gt;c_string&lt;/code&gt; field will be filled by the compiler with the string; the &lt;code&gt;length&lt;/code&gt; field will be filled by the compiler with the string length; the &lt;code&gt;isa&lt;/code&gt; pointer will be filled with &lt;code&gt;NULL&lt;/code&gt; by the compiler, and it will later be fixed up automatically at runtime by the GNU Objective-C runtime library to point to the class which was set by the</source>
          <target state="translated">Когда компилятор создает статически выделенный строковый объект- &lt;code&gt;c_string&lt;/code&gt; поле c_string будет заполнено компилятором строкой; &lt;code&gt;length&lt;/code&gt; поле будет заполнено компилятором с длиной строки; &lt;code&gt;isa&lt;/code&gt; указатель будет заполнен &lt;code&gt;NULL&lt;/code&gt; компилятором, и он будет позже фиксируется автоматически во время выполнения в Objective-C библиотеки времени выполнения GNU в точке к классу , который был задан</target>
        </trans-unit>
        <trans-unit id="75d541d9bedf275908dc64ccacf78982bc497338" translate="yes" xml:space="preserve">
          <source>When the compiler fixes up the operands to satisfy the constraints, it needs to know which operands are read by the instruction and which are written by it. &amp;lsquo;</source>
          <target state="translated">Когда компилятор исправляет операнды для удовлетворения ограничений, ему необходимо знать, какие операнды считываются инструкцией, а какие записываются ею. '</target>
        </trans-unit>
        <trans-unit id="fe9038c60a954d7fa872648aae2a7292450a7e26" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the input operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">Когда компилятор выбирает регистры для использования для представления входных операндов, он не использует ни один из затираемых регистров (см. &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers и Scratch Registers&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc0664d7c952e60ae422d980b70454766a66b5fe" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the output operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">Когда компилятор выбирает регистры для использования для представления выходных операндов, он не использует ни один из затираемых регистров (см. &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers и Scratch Registers&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9af3756142eed3c562da1e3a657ce9b62976062a" translate="yes" xml:space="preserve">
          <source>When the compiler selects which registers to use to represent input and output operands, it does not use any of the clobbered registers. As a result, clobbered registers are available for any use in the assembler code.</source>
          <target state="translated">Когда компилятор выбирает,какие регистры использовать для представления операндов ввода и вывода,он не использует ни один из забитых регистров.В результате,забитые регистры доступны для любого использования в ассемблерном коде.</target>
        </trans-unit>
        <trans-unit id="c3d75a61bee977e603b0ea8873c523597d8f39fa" translate="yes" xml:space="preserve">
          <source>When the garbage collector is used, the objects are allocated using the so-called typed memory allocation mechanism available in the Boehm-Demers-Weiser collector. This mode requires precise information on where pointers are located inside objects. This information is computed once per class, immediately after the class has been initialized.</source>
          <target state="translated">При использовании сборщика мусора объекты выделяются с помощью так называемого механизма типизированного выделения памяти,доступного в коллекторе Boehm-Demers-Weiser.Этот режим требует точной информации о том,где находятся указатели внутри объектов.Эта информация вычисляется один раз для каждого класса,сразу после инициализации класса.</target>
        </trans-unit>
        <trans-unit id="ce04df43b58d0607f55d930a3e25d2b0c0d86fd3" translate="yes" xml:space="preserve">
          <source>When the instructions are enabled GCC defines the C preprocessor symbol &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt;, otherwise it defines the symbol &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt;.</source>
          <target state="translated">Когда инструкции включены, GCC определяет символ препроцессора C &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt; , в противном случае он определяет символ &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="237034d602a7895e4b871df52b8d8208437c1b5e" translate="yes" xml:space="preserve">
          <source>When the option</source>
          <target state="translated">Когда вариант</target>
        </trans-unit>
        <trans-unit id="f59a2028d7f7059c14cfbb4f7cac2e937416cda2" translate="yes" xml:space="preserve">
          <source>When the value of a decimal floating type cannot be represented in the integer type to which it is being converted, the result is undefined rather than the result value specified by the draft technical report.</source>
          <target state="translated">Когда значение десятичного плавающего типа не может быть представлено в целочисленном типе,к которому оно приводится,результат является неопределенным,а не результатом,указанным в проекте технического отчета.</target>
        </trans-unit>
        <trans-unit id="43dfcc6f2fffee0a3a2515bfa1a37e71e51242de" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 1.</source>
          <target state="translated">Когда этот флаг установлен, макросам &lt;code&gt;__pic__&lt;/code&gt; и &lt;code&gt;__PIC__&lt;/code&gt; присваивается значение 1.</target>
        </trans-unit>
        <trans-unit id="44c57deb401735025dc176c7c63debf58618c2fc" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 2.</source>
          <target state="translated">Когда этот флаг установлен, макросам &lt;code&gt;__pic__&lt;/code&gt; и &lt;code&gt;__PIC__&lt;/code&gt; присвоено значение 2.</target>
        </trans-unit>
        <trans-unit id="4a1317c4b8d2af979d94b62164c9d7ecd9184a36" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC inserts &lt;code&gt;MEMW&lt;/code&gt; instructions before &lt;code&gt;volatile&lt;/code&gt; memory references to guarantee sequential consistency. The default is</source>
          <target state="translated">Когда этот параметр включен, GCC вставляет инструкции &lt;code&gt;MEMW&lt;/code&gt; перед ссылками на &lt;code&gt;volatile&lt;/code&gt; память, чтобы гарантировать последовательную согласованность. По умолчанию</target>
        </trans-unit>
        <trans-unit id="4f8fad713a34ff4dd67014e2a8d65e863876b686" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to automatically align instructions to reduce branch penalties at the expense of some code density. The assembler attempts to widen density instructions to align branch targets and the instructions following call instructions. If there are not enough preceding safe density instructions to align a target, no widening is performed. The default is</source>
          <target state="translated">Когда эта опция включена,GCC инструктирует ассемблера автоматически выравнивать инструкции для уменьшения штрафов за ветки за счет некоторой плотности кода.Ассемблер пытается расширить инструкции по выравниванию плотности ветвей,а также инструкции,следующие за инструкциями по вызову.Если предшествующих инструкций по безопасному выравниванию плотности недостаточно для выравнивания цели,то расширение не выполняется.По умолчанию</target>
        </trans-unit>
        <trans-unit id="6aace4cd615149f89dea8fcd082fb55d9878fa43" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to translate direct calls to indirect calls unless it can determine that the target of a direct call is in the range allowed by the call instruction. This translation typically occurs for calls to functions in other source files. Specifically, the assembler translates a direct &lt;code&gt;CALL&lt;/code&gt; instruction into an &lt;code&gt;L32R&lt;/code&gt; followed by a &lt;code&gt;CALLX&lt;/code&gt; instruction. The default is</source>
          <target state="translated">Когда эта опция включена, GCC инструктирует ассемблер переводить прямые вызовы в косвенные вызовы, если он не может определить, что цель прямого вызова находится в диапазоне, разрешенном инструкцией вызова. Этот перевод обычно происходит для вызовов функций в других исходных файлах. В частности, ассемблер переводит прямую инструкцию &lt;code&gt;CALL&lt;/code&gt; в &lt;code&gt;L32R&lt;/code&gt; , за которой &lt;code&gt;CALLX&lt;/code&gt; инструкция CALLX . По умолчанию</target>
        </trans-unit>
        <trans-unit id="932f419fffb4962ea09a2d68b7d48f6dd70fbe9a" translate="yes" xml:space="preserve">
          <source>When this option is not used, GCC optimizes for the processor specified by</source>
          <target state="translated">Когда эта опция не используется,GCC оптимизирует для процессора,указанного в параметре</target>
        </trans-unit>
        <trans-unit id="d8e1351858aa322f0a55264f24813443d8991eb4" translate="yes" xml:space="preserve">
          <source>When this option is passed to the compiler driver, it causes the &lt;em&gt;first&lt;/em&gt; compilation to be skipped, which makes it useful for little other than debugging the compiler proper.</source>
          <target state="translated">Когда этот параметр передается драйверу компилятора, он приводит к пропуску &lt;em&gt;первой&lt;/em&gt; компиляции, что делает ее полезной практически для всех, кроме собственно отладки компилятора.</target>
        </trans-unit>
        <trans-unit id="9e23f54eaa8f9101922e305be1e7015dd6fc78fe" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">Когда эта версия ABI включена, определяется символ препроцессора C &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a3a63e7e68adaacd52d22d0fef6ef4e247546c7" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">Когда эта версия ABI включена, определяется символ препроцессора C &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffcbc5063df93d534e3fd1a9be3948f3d608cc53" translate="yes" xml:space="preserve">
          <source>When trying to fill delay slots, the maximum number of instructions to consider when searching for a block with valid live register information. Increasing this arbitrarily chosen value means more aggressive optimization, increasing the compilation time. This parameter should be removed when the delay slot code is rewritten to maintain the control-flow graph.</source>
          <target state="translated">При попытке заполнить слоты задержки,максимальное количество инструкций,которые необходимо учитывать при поиске блока с достоверной информацией о живом регистре.Увеличение этого произвольно выбранного значения означает более агрессивную оптимизацию,увеличение времени компиляции.Этот параметр следует удалять,когда код слота задержки переписывается для поддержания графа управляющего потока.</target>
        </trans-unit>
        <trans-unit id="ca1100086e04f30d15e50b0b6ef7fef7de69d02a" translate="yes" xml:space="preserve">
          <source>When used as part of the register variable extension, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">При использовании как части расширения регистровой переменной см. &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Явные регистровые переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="106a6c1a466d5af73cd467f48ab954141e8dae1a" translate="yes" xml:space="preserve">
          <source>When used as the pattern of a pack expansion within a template definition, expands to a template argument pack containing integers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt;. This is provided for efficient implementation of &lt;code&gt;std::make_integer_sequence&lt;/code&gt;.</source>
          <target state="translated">При использовании в качестве шаблона расширения пакета в определении шаблона расширяется до пакета аргументов шаблона, содержащего целые числа от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;length-1&lt;/code&gt; . Это предусмотрено для эффективной реализации &lt;code&gt;std::make_integer_sequence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="780fee7b38bbbc14d6460730fc730c12ac99a32c" translate="yes" xml:space="preserve">
          <source>When used from GCC without</source>
          <target state="translated">При использовании из GCC без</target>
        </trans-unit>
        <trans-unit id="0e9e8833e240e4ed56f0fb1a36eb014753411cc2" translate="yes" xml:space="preserve">
          <source>When used in combination with</source>
          <target state="translated">При использовании в сочетании с</target>
        </trans-unit>
        <trans-unit id="4ec2dc1132b93e0ccc417d346f716fa8317dce1d" translate="yes" xml:space="preserve">
          <source>When used in combination with the</source>
          <target state="translated">При использовании в сочетании с</target>
        </trans-unit>
        <trans-unit id="7e7b12188944613e3ecc2fd00ed8b819fb8ad2ca" translate="yes" xml:space="preserve">
          <source>When used in conjunction with</source>
          <target state="translated">При использовании в сочетании с</target>
        </trans-unit>
        <trans-unit id="49cb60ae0da0fc7302708101bdf54d1b69871514" translate="yes" xml:space="preserve">
          <source>When used on a struct, or struct member, the &lt;code&gt;aligned&lt;/code&gt; attribute can only increase the alignment; in order to decrease it, the &lt;code&gt;packed&lt;/code&gt; attribute must be specified as well. When used as part of a typedef, the &lt;code&gt;aligned&lt;/code&gt; attribute can both increase and decrease alignment, and specifying the &lt;code&gt;packed&lt;/code&gt; attribute generates a warning.</source>
          <target state="translated">При использовании в структуре или члене структуры, &lt;code&gt;aligned&lt;/code&gt; атрибут может только увеличить выравнивание; для его уменьшения необходимо указать также и &lt;code&gt;packed&lt;/code&gt; атрибут. При использовании как часть typedef атрибут &lt;code&gt;aligned&lt;/code&gt; может как увеличивать, так и уменьшать выравнивание, а указание атрибута &lt;code&gt;packed&lt;/code&gt; генерирует предупреждение.</target>
        </trans-unit>
        <trans-unit id="9e5e1c3d3ae3ca589eb9e745a2edd3f0de6b0b04" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt;, code is generated to load the stack pointer from the USP register in the function prologue.</source>
          <target state="translated">При использовании вместе с &lt;code&gt;interrupt_handler&lt;/code&gt; , &lt;code&gt;exception_handler&lt;/code&gt; или &lt;code&gt;nmi_handler&lt;/code&gt; создается код для загрузки указателя стека из регистра USP в прологе функции.</target>
        </trans-unit>
        <trans-unit id="0fa555d9978b74bbd46ce823e883fc5dc96ece10" translate="yes" xml:space="preserve">
          <source>When used together,</source>
          <target state="translated">При совместном использовании,</target>
        </trans-unit>
        <trans-unit id="dd9e3fff8e9f3de600aeb120c0ac434ae6e8fd7f" translate="yes" xml:space="preserve">
          <source>When used with</source>
          <target state="translated">При использовании с</target>
        </trans-unit>
        <trans-unit id="92cecb0d71e3d06f0f2ee726aec0670791ccea60" translate="yes" xml:space="preserve">
          <source>When used with GNU ld version 2.8 or later on an ELF system such as GNU/Linux or Solaris 2, or on Microsoft Windows, duplicate copies of these constructs will be discarded at link time. This is known as COMDAT support.</source>
          <target state="translated">При использовании с GNU ld версии 2.8 или более поздней в системе ELF,такой как GNU/Linux или Solaris 2,или в Microsoft Windows дубликаты этих конструкций будут отбрасываться во время компоновки.Это известно как поддержка COMDAT.</target>
        </trans-unit>
        <trans-unit id="3e4af787046ae7ade38ea86db68f50943f9b708f" translate="yes" xml:space="preserve">
          <source>When used with the driver options</source>
          <target state="translated">При использовании с опциями драйвера</target>
        </trans-unit>
        <trans-unit id="c37b9bb49622ff1b2c39fa2ca14e91b87c1c3e6e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;__vector&lt;/code&gt; instead of &lt;code&gt;vector&lt;/code&gt;; for example,</source>
          <target state="translated">При использовании &lt;code&gt;__vector&lt;/code&gt; вместо &lt;code&gt;vector&lt;/code&gt; ; например,</target>
        </trans-unit>
        <trans-unit id="6b2bcfc1c3c9cde870c3782ea70e6faf69a223bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;gcov&lt;/code&gt;, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">При использовании &lt;code&gt;gcov&lt;/code&gt; вы должны сначала скомпилировать свою программу со специальной опцией GCC '</target>
        </trans-unit>
        <trans-unit id="813ae21e068ea720242cb9123e52a1c2bfc86b90" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vector&lt;/code&gt; in keyword-and-predefine mode; for example,</source>
          <target state="translated">При использовании &lt;code&gt;vector&lt;/code&gt; в режиме ключевых слов и предопределения; например,</target>
        </trans-unit>
        <trans-unit id="5643f8856029d91e0b316af45e590b017e03b023" translate="yes" xml:space="preserve">
          <source>When using &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt;, gcov uses the full pathname of the source files to create an output filename. This can lead to long filenames that can overflow filesystem limits. This option creates names of the form</source>
          <target state="translated">При использовании &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt; gcov использует полный путь к исходным файлам для создания имени файла вывода. Это может привести к длинным именам файлов, которые могут выйти за рамки ограничений файловой системы. Эта опция создает имена формы</target>
        </trans-unit>
        <trans-unit id="86e384abcdbbd0ac6dda953fb252a5fa852b9cab" translate="yes" xml:space="preserve">
          <source>When using DWARF Version 4 or higher, type DIEs can be put into their own &lt;code&gt;.debug_types&lt;/code&gt; section instead of making them part of the &lt;code&gt;.debug_info&lt;/code&gt; section. It is more efficient to put them in a separate comdat section since the linker can then remove duplicates. But not all DWARF consumers support &lt;code&gt;.debug_types&lt;/code&gt; sections yet and on some objects &lt;code&gt;.debug_types&lt;/code&gt; produces larger instead of smaller debugging information.</source>
          <target state="translated">При использовании DWARF версии 4 или выше, типы DIE можно поместить в &lt;code&gt;.debug_types&lt;/code&gt; раздел .debug_types вместо того, чтобы делать их частью раздела &lt;code&gt;.debug_info&lt;/code&gt; . Более эффективно поместить их в отдельный раздел comdat, так как компоновщик может удалить дубликаты. Но не все потребители &lt;code&gt;.debug_types&lt;/code&gt; пока поддерживают разделы .debug_types, а для некоторых объектов &lt;code&gt;.debug_types&lt;/code&gt; дает больше, а не меньшую отладочную информацию.</target>
        </trans-unit>
        <trans-unit id="7fb27cfc2abe0d594f6b16d8710a96a8aeba9d2c" translate="yes" xml:space="preserve">
          <source>When using a reference to volatile, G++ does not treat equivalent expressions as accesses to volatiles, but instead issues a warning that no volatile is accessed. The rationale for this is that otherwise it becomes difficult to determine where volatile access occur, and not possible to ignore the return value from functions returning volatile references. Again, if you wish to force a read, cast the reference to an rvalue.</source>
          <target state="translated">При использовании ссылки на volatile,G++не рассматривает эквивалентные выражения как доступ к волатилям,а выдает предупреждение об отсутствии доступа к волатилям.Это объясняется тем,что в противном случае становится сложно определить,где происходит обращение к волатильности,и невозможно игнорировать возвращаемое значение из функций,возвращающих волатильные ссылки.Опять же,если вы хотите принудительно прочитать,бросьте ссылку на значение rvalue.</target>
        </trans-unit>
        <trans-unit id="ffb95a64a466d2bd4851566c5320aa64fa40418e" translate="yes" xml:space="preserve">
          <source>When using a type that occupies multiple registers, such as &lt;code&gt;long
long&lt;/code&gt; on a 32-bit system, split the registers apart and allocate them independently. This normally generates better code for those types, but may make debugging more difficult.</source>
          <target state="translated">При использовании типа, который занимает несколько регистров, например &lt;code&gt;long long&lt;/code&gt; в 32-разрядной системе, разделите регистры на части и распределите их независимо. Обычно это создает лучший код для этих типов, но может затруднить отладку.</target>
        </trans-unit>
        <trans-unit id="f38f792e072335436a4ef70d8d149701336de24f" translate="yes" xml:space="preserve">
          <source>When using any of the register constraints (&lt;code&gt;wa&lt;/code&gt;, &lt;code&gt;wd&lt;/code&gt;, &lt;code&gt;wf&lt;/code&gt;, &lt;code&gt;wg&lt;/code&gt;, &lt;code&gt;wh&lt;/code&gt;, &lt;code&gt;wi&lt;/code&gt;, &lt;code&gt;wj&lt;/code&gt;, &lt;code&gt;wk&lt;/code&gt;, &lt;code&gt;wl&lt;/code&gt;, &lt;code&gt;wm&lt;/code&gt;, &lt;code&gt;wo&lt;/code&gt;, &lt;code&gt;wp&lt;/code&gt;, &lt;code&gt;wq&lt;/code&gt;, &lt;code&gt;ws&lt;/code&gt;, &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;wu&lt;/code&gt;, &lt;code&gt;wv&lt;/code&gt;, &lt;code&gt;ww&lt;/code&gt;, or &lt;code&gt;wy&lt;/code&gt;) that take VSX registers, you must use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; in the template so that the correct register is used. Otherwise the register number output in the assembly file will be incorrect if an Altivec register is an operand of a VSX instruction that expects VSX register numbering.</source>
          <target state="translated">При использовании любых ограничений регистров ( &lt;code&gt;wa&lt;/code&gt; , &lt;code&gt;wd&lt;/code&gt; , &lt;code&gt;wf&lt;/code&gt; , &lt;code&gt;wg&lt;/code&gt; , &lt;code&gt;wh&lt;/code&gt; , &lt;code&gt;wi&lt;/code&gt; , &lt;code&gt;wj&lt;/code&gt; , &lt;code&gt;wk&lt;/code&gt; , &lt;code&gt;wl&lt;/code&gt; , &lt;code&gt;wm&lt;/code&gt; , &lt;code&gt;wo&lt;/code&gt; , &lt;code&gt;wp&lt;/code&gt; , &lt;code&gt;wq&lt;/code&gt; , &lt;code&gt;ws&lt;/code&gt; , &lt;code&gt;wt&lt;/code&gt; , &lt;code&gt;wu&lt;/code&gt; , &lt;code&gt;wv&lt;/code&gt; , &lt;code&gt;ww&lt;/code&gt; или &lt;code&gt;wy&lt;/code&gt; ), которые принимают VSX регистры, вы должны использовать &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; в шаблоне, чтобы использовался правильный регистр. В противном случае вывод номера регистра в файле сборки будет неправильным, если регистр Altivec является операндом инструкции VSX, которая ожидает нумерацию регистров VSX.</target>
        </trans-unit>
        <trans-unit id="c184ccdd41991ac034a44b8741c7f1fabbb85a41" translate="yes" xml:space="preserve">
          <source>When using precompiled headers (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;), this flag causes the dependency-output flags to also list the files from the precompiled header&amp;rsquo;s dependencies. If not specified, only the precompiled header are listed and not the files that were used to create it, because those files are not consulted when a precompiled header is used.</source>
          <target state="translated">При использовании предварительно скомпилированных заголовков (см. &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Предварительно скомпилированные заголовки&lt;/a&gt; ) этот флаг заставляет флаги вывода зависимостей также перечислять файлы из зависимостей предварительно скомпилированного заголовка. Если не указано иное, отображается только предварительно скомпилированный заголовок, а не файлы, которые использовались для его создания, потому что при использовании предварительно скомпилированного заголовка к этим файлам не обращаются.</target>
        </trans-unit>
        <trans-unit id="4d73200be5ca0030ca174cac8ec7eb66631895c5" translate="yes" xml:space="preserve">
          <source>When using the GNU linker, it is usually more convenient to pass arguments to linker options using the</source>
          <target state="translated">При использовании компоновщика GNU обычно удобнее передавать аргументы в опции компоновщика,используя команду</target>
        </trans-unit>
        <trans-unit id="07d62f57e8744ee5ede23dc9a1e4cfca2395afa4" translate="yes" xml:space="preserve">
          <source>When you are using the &lt;code&gt;goto&lt;/code&gt; form of &lt;code&gt;asm&lt;/code&gt;, this section contains the list of all C labels to which the code in the &lt;var&gt;AssemblerTemplate&lt;/var&gt; may jump. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">Когда вы используете форму &lt;code&gt;goto&lt;/code&gt; для &lt;code&gt;asm&lt;/code&gt; , этот раздел содержит список всех меток C, на которые может перейти код в &lt;var&gt;AssemblerTemplate&lt;/var&gt; . См. &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1da9d83d815287fc18f851fe43c98fefdf50af5" translate="yes" xml:space="preserve">
          <source>When you compile C++ programs, you may specify many of the same command-line options that you use for compiling programs in any language; or command-line options meaningful for C and related languages; or options that are meaningful only for C++ programs. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;, for explanations of options for languages related to C. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;, for explanations of options that are meaningful only for C++ programs.</source>
          <target state="translated">При компиляции программ на C ++ вы можете указать многие из тех же параметров командной строки, которые вы используете для компиляции программ на любом языке; или параметры командной строки, значимые для C и родственных языков; или параметры, имеющие значение только для программ на C ++. См. В разделе &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Параметры, управляющие диалектом C&lt;/a&gt; , объяснения параметров для языков, связанных с C. См. &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Параметры, управляющие диалектом C ++&lt;/a&gt; , для объяснения параметров, имеющих значение только для программ на C ++.</target>
        </trans-unit>
        <trans-unit id="628daae8697f91bc17f481bc0199bf74cc7f3f93" translate="yes" xml:space="preserve">
          <source>When you invoke GCC, it normally does preprocessing, compilation, assembly and linking. The &amp;ldquo;overall options&amp;rdquo; allow you to stop this process at an intermediate stage. For example, the</source>
          <target state="translated">Когда вы вызываете GCC, он обычно выполняет предварительную обработку, компиляцию, сборку и компоновку. &amp;laquo;Общие параметры&amp;raquo; позволяют остановить этот процесс на промежуточном этапе. Например,</target>
        </trans-unit>
        <trans-unit id="dc4bcf9de739295968f25374fa0b9b82393e8d47" translate="yes" xml:space="preserve">
          <source>When you use</source>
          <target state="translated">При использовании</target>
        </trans-unit>
        <trans-unit id="8bb9a5cb938f4f893dfe56300e7991ff5d9ac371" translate="yes" xml:space="preserve">
          <source>When you use &lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;, the only automatic variables guaranteed to remain valid are those declared &lt;code&gt;volatile&lt;/code&gt;. This is a consequence of automatic register allocation. Consider this function:</source>
          <target state="translated">Когда вы используете &lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; и &lt;code&gt;longjmp&lt;/code&gt; , единственные автоматические переменные, которые гарантированно остаются действительными, - это те, которые объявлены &lt;code&gt;volatile&lt;/code&gt; . Это следствие автоматического распределения регистров. Рассмотрим эту функцию:</target>
        </trans-unit>
        <trans-unit id="4f5a87979f362a282d672c1cd391334d27dc161a" translate="yes" xml:space="preserve">
          <source>When you use the</source>
          <target state="translated">Когда вы используете</target>
        </trans-unit>
        <trans-unit id="cef8b3831d50a66f25ff90c61c375348a6eba6bf" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should use the general-purpose constraint letters in &lt;code&gt;asm&lt;/code&gt; arguments, since they will convey meaning more readily to people reading your code. Failing that, use the constraint letters that usually have very similar meanings across architectures. The most commonly used constraints are &amp;lsquo;</source>
          <target state="translated">По возможности следует использовать в аргументах &lt;code&gt;asm&lt;/code&gt; ограничительные буквы общего назначения , так как они легче передают смысл людям, читающим ваш код. В противном случае используйте буквы ограничений, которые обычно имеют очень похожее значение для разных архитектур. Наиболее часто используемые ограничения:</target>
        </trans-unit>
        <trans-unit id="3a4007ba3fafc819a7924ea3b2d8632c8709039c" translate="yes" xml:space="preserve">
          <source>Whenever you leave out the alignment factor in an &lt;code&gt;aligned&lt;/code&gt; attribute specification, the compiler automatically sets the alignment for the type to the largest alignment that is ever used for any data type on the target machine you are compiling for. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables that have types that you have aligned this way.</source>
          <target state="translated">Каждый раз, когда вы пропускаете коэффициент &lt;code&gt;aligned&lt;/code&gt; спецификации выровненного атрибута, компилятор автоматически устанавливает выравнивание для типа на самое большое выравнивание, которое когда-либо использовалось для любого типа данных на целевой машине, для которой вы компилируете. Выполнение этого часто может сделать операции копирования более эффективными, потому что компилятор может использовать любые инструкции, копирующие самые большие фрагменты памяти, при выполнении копий в или из переменных, типы которых вы выровнены таким образом.</target>
        </trans-unit>
        <trans-unit id="08306a1126e7ec7f2d356c52bfc279fbbf71d360" translate="yes" xml:space="preserve">
          <source>Where &lt;var&gt;op&lt;/var&gt; is the name of the instruction. Refer to the ISA manual for the complete list of instructions.</source>
          <target state="translated">Где &lt;var&gt;op&lt;/var&gt; - название инструкции. См. Полный список инструкций в руководстве ISA.</target>
        </trans-unit>
        <trans-unit id="a66402f17809117f1d29c4b80df406d4e2f11bba" translate="yes" xml:space="preserve">
          <source>Where G++ puts inlines, vtables and such.</source>
          <target state="translated">Где G++ставит в строки,конюшни и тому подобное.</target>
        </trans-unit>
        <trans-unit id="f97bcbccf23129ffc3f54b71abd0f18cfe88a7d0" translate="yes" xml:space="preserve">
          <source>Where none of</source>
          <target state="translated">Где никто из</target>
        </trans-unit>
        <trans-unit id="18ba47ae48773e2f3f0699ad79e05aa7bd3185d2" translate="yes" xml:space="preserve">
          <source>Where the standard specified with</source>
          <target state="translated">Если стандарт указан с</target>
        </trans-unit>
        <trans-unit id="7c95dc097ed9e81e390e81810c6f3d829c025cc5" translate="yes" xml:space="preserve">
          <source>Where the unused arguments lie between used arguments that are specified with &amp;lsquo;</source>
          <target state="translated">Если неиспользуемые аргументы находятся между использованными аргументами, которые указаны с помощью '</target>
        </trans-unit>
        <trans-unit id="b3e4d8bab3e588a9e2b728940ccf589c5438a70e" translate="yes" xml:space="preserve">
          <source>Where the value in &lt;var&gt;dest&lt;/var&gt; will be the result returned from the built-in.</source>
          <target state="translated">Где значение в &lt;var&gt;dest&lt;/var&gt; будет результатом, возвращаемым встроенным.</target>
        </trans-unit>
        <trans-unit id="e57ba6952af402ae437a5e3309d0cfb54d03b1f3" translate="yes" xml:space="preserve">
          <source>Where to find header files and libraries. Where to find the compiler executable files.</source>
          <target state="translated">Где найти заголовочные файлы и библиотеки.Где найти исполняемые файлы компилятора.</target>
        </trans-unit>
        <trans-unit id="3c00f7db25c9cf9b37e3952008b0e2f58aade5fa" translate="yes" xml:space="preserve">
          <source>Whether a &amp;ldquo;plain&amp;rdquo; &lt;code&gt;int&lt;/code&gt; bit-field is treated as a &lt;code&gt;signed int&lt;/code&gt; bit-field or as an &lt;code&gt;unsigned int&lt;/code&gt; bit-field (C90 6.5.2, C90 6.5.2.1, C99 and C11 6.7.2, C99 and C11 6.7.2.1).</source>
          <target state="translated">Является ли &amp;laquo;простой&amp;raquo; &lt;code&gt;int&lt;/code&gt; битовое поле рассматривается как &lt;code&gt;signed int&lt;/code&gt; битовое поле или как &lt;code&gt;unsigned int&lt;/code&gt; битового поля (C90 6.5.2, C90 6.5.2.1, C99 и C11 6.7.2, C99 и C11 6.7.2.1 ).</target>
        </trans-unit>
        <trans-unit id="7531059d0a25c98e7ca278e75f82acc76daa9a55" translate="yes" xml:space="preserve">
          <source>Whether a bit-field can straddle a storage-unit boundary (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">Может ли битовое поле пересекать границу раздела хранилища (C90 6.5.2.1,C99 и C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="fe2aebfc599d584921175261d958d43ef0f0aec0" translate="yes" xml:space="preserve">
          <source>Whether a function in a binary built by one set of tools can call a function in a binary built by a different set of tools is a subset of interoperability.</source>
          <target state="translated">Может ли функция в двоичном файле,собранная одним набором инструментов,вызывать функцию в двоичном файле,собранном другим набором инструментов,является подмножеством функциональной совместимости.</target>
        </trans-unit>
        <trans-unit id="c06b8898733d76cc9dce4e56a21efa3845ac1918" translate="yes" xml:space="preserve">
          <source>Whether an argument of class type with a non-trivial copy constructor or destructor can be passed to ... (C++0x 5.2.2).</source>
          <target state="translated">Может ли аргумент типа класса с нетривиальным конструктором копирования или деструктором быть передан в ...(C++0x 5.2.2).</target>
        </trans-unit>
        <trans-unit id="f086235b38a936fb8979e808d23b4c24d86f5d9b" translate="yes" xml:space="preserve">
          <source>Whether and how floating expressions are contracted when not disallowed by the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 6.5).</source>
          <target state="translated">&lt;code&gt;FP_CONTRACT&lt;/code&gt; ли и как плавающие выражения, если они не запрещены прагмой FP_CONTRACT (C99 и C11 6.5).</target>
        </trans-unit>
        <trans-unit id="f8840ea94992b3ba6df4412ec15b47848948aba5" translate="yes" xml:space="preserve">
          <source>Whether any extended alignments are supported and the contexts in which they are supported (C11 6.2.8).</source>
          <target state="translated">Поддерживаются ли расширенные выравнивания и контексты,в которых они поддерживаются (C11 6.2.8).</target>
        </trans-unit>
        <trans-unit id="5e7ac927cf9e33f4c488cef419402e9a193f27f2" translate="yes" xml:space="preserve">
          <source>Whether atomic types are permitted for bit-fields (C11 6.7.2.1).</source>
          <target state="translated">Разрешены ли атомные типы для битовых полей (С11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="1b73e138d1b7cf4eb52da0986b7749369200c235" translate="yes" xml:space="preserve">
          <source>Whether case distinctions are significant in an identifier with external linkage (C90 6.1.2).</source>
          <target state="translated">Значимы ли различия в регистре в идентификаторе с внешней связью (C90 6.1.2).</target>
        </trans-unit>
        <trans-unit id="f11ebb9d3de47abc2e0ca0f87e800f9634ac636f" translate="yes" xml:space="preserve">
          <source>Whether codegen errors should be ICEs when</source>
          <target state="translated">Должны ли кодовые ошибки быть ICE,когда</target>
        </trans-unit>
        <trans-unit id="354a46344b75f29340cafb16fbb91450a8587db2" translate="yes" xml:space="preserve">
          <source>Whether differently-prefixed wide string literal tokens can be concatenated and, if so, the treatment of the resulting multibyte character sequence (C11 6.4.5).</source>
          <target state="translated">Могут ли быть сконцентрированы по-разному исправленные маркеры широкострочных литералов,и если да,то обработка получившейся многобайтовой последовательности символов (C11 6.4.5).</target>
        </trans-unit>
        <trans-unit id="3b5528cb4a8a2228a3304685d15fcf34a763a7fb" translate="yes" xml:space="preserve">
          <source>Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character in translation phase 3 (C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">Сохраняется ли каждая непустая последовательность пробельных символов,кроме новой строки,или заменяется одним пробелом на третьем этапе перевода (C90,C99 и C11 5.1.1.2).</target>
        </trans-unit>
        <trans-unit id="599547a438479475d1d2cda798d15d3f35866c27" translate="yes" xml:space="preserve">
          <source>Whether signed integer types are represented using sign and magnitude, two&amp;rsquo;s complement, or one&amp;rsquo;s complement, and whether the extraordinary value is a trap representation or an ordinary value (C99 and C11 6.2.6.2).</source>
          <target state="translated">Представляются ли целочисленные типы со знаком с использованием знака и величины, дополнения до двух или дополнения до одного, и является ли исключительное значение представлением прерывания или обычным значением (C99 и C11 6.2.6.2).</target>
        </trans-unit>
        <trans-unit id="40b6d1461dda1b8f55b388b60612f0a1c5dc15ae" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;inexact&amp;rdquo; floating-point exception can be raised when the rounded result actually does equal the mathematical result in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">Может ли быть вызвано &amp;laquo;неточное&amp;raquo; исключение с плавающей запятой, когда округленный результат действительно равен математическому результату в реализации, соответствующей IEC 60559 (C99 F.9).</target>
        </trans-unit>
        <trans-unit id="c1f63f009e459571f2431bd617b7dca64a11adca" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;underflow&amp;rdquo; (and &amp;ldquo;inexact&amp;rdquo;) floating-point exception can be raised when a result is tiny but not inexact in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">Может ли быть вызвано исключение с плавающей запятой &amp;laquo;недополнение&amp;raquo; (и &amp;laquo;неточность&amp;raquo;), если результат мал, но не неточен в реализации, соответствующей IEC 60559 (C99 F.9).</target>
        </trans-unit>
        <trans-unit id="945b6d4fa9a5ecbaf6bafbdb8d0d89ae5b700edc" translate="yes" xml:space="preserve">
          <source>Whether the &amp;lsquo;</source>
          <target state="translated">Будь то</target>
        </trans-unit>
        <trans-unit id="bba97b060da98c792876d4d0754d818ca89f0204" translate="yes" xml:space="preserve">
          <source>Whether the compiler should use the &amp;ldquo;canonical&amp;rdquo; type system. Should always be 1, which uses a more efficient internal mechanism for comparing types in C++ and Objective-C++. However, if bugs in the canonical type system are causing compilation failures, set this value to 0 to disable canonical types.</source>
          <target state="translated">Следует ли компилятору использовать &amp;laquo;каноническую&amp;raquo; систему типов. Всегда должно быть 1, что позволяет использовать более эффективный внутренний механизм сравнения типов в C ++ и Objective-C ++. Однако, если ошибки в системе канонических типов вызывают сбои компиляции, установите для этого значения 0, чтобы отключить канонические типы.</target>
        </trans-unit>
        <trans-unit id="9bf07719435931f48daf3148b7f591b08eee6622" translate="yes" xml:space="preserve">
          <source>Whether the loop array prefetch pass should issue software prefetch hints for strides that are non-constant. In some cases this may be beneficial, though the fact the stride is non-constant may make it hard to predict when there is clear benefit to issuing these hints.</source>
          <target state="translated">Должна ли передача предварительной выборки массива в цикле выдавать программные подсказки предварительной выборки для неконстантных шагов.В некоторых случаях это может быть полезно,хотя тот факт,что шаг не постоянен,может затруднить предсказание,когда есть явная выгода от выдачи этих подсказок.</target>
        </trans-unit>
        <trans-unit id="3783705a05be7fc566fd28d14a20893e46a49fb1" translate="yes" xml:space="preserve">
          <source>Whether the value of a character constant in a constant expression that controls conditional inclusion matches the value of the same character constant in the execution character set (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">Совпадает ли значение символьной константы в константном выражении,которое управляет условным включением,со значением той же символьной константы в наборе символов исполнения (C90 6.8.1,C99 и C11 6.10.1).</target>
        </trans-unit>
        <trans-unit id="c36d4d5da07291b1b8267749102489e31d3d638e" translate="yes" xml:space="preserve">
          <source>Whether the value of a single-character character constant in a constant expression that controls conditional inclusion may have a negative value (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">Может ли значение односимвольной символьной константы в константном выражении,которое контролирует условное включение,иметь отрицательное значение (С90 6.8.1,С99 и С11 6.10.1).</target>
        </trans-unit>
        <trans-unit id="9cb3bdf69d2ad24cba5875ebe4f0cafed80a2719" translate="yes" xml:space="preserve">
          <source>Which additional multibyte characters may appear in identifiers and their correspondence to universal character names (C99 and C11 6.4.2).</source>
          <target state="translated">Какие дополнительные многобайтовые символы могут появляться в идентификаторах и их соответствие универсальным символьным именам (С99 и С11 6.4.2).</target>
        </trans-unit>
        <trans-unit id="d42124c28b1baab39d06e79c2e6fbc80bcb8c3b0" translate="yes" xml:space="preserve">
          <source>Which of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; has the same range, representation, and behavior as &amp;ldquo;plain&amp;rdquo; &lt;code&gt;char&lt;/code&gt; (C90 6.1.2.5, C90 6.2.1.1, C99 and C11 6.2.5, C99 and C11 6.3.1.1).</source>
          <target state="translated">Какой из &lt;code&gt;signed char&lt;/code&gt; или &lt;code&gt;unsigned char&lt;/code&gt; имеет тот же диапазон, представление и поведение, что и &amp;laquo;простой&amp;raquo; &lt;code&gt;char&lt;/code&gt; (C90 6.1.2.5, C90 6.2.1.1, C99 и C11 6.2.5, C99 и C11 6.3.1.1).</target>
        </trans-unit>
        <trans-unit id="a3f8e01950ee5a5eeec136d809212bfccead4676" translate="yes" xml:space="preserve">
          <source>Which problems in your code get warnings, and which get errors.</source>
          <target state="translated">Какие проблемы в вашем коде получают предупреждения,а какие-ошибки.</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="78cfea135064bce5a81b5bd15458f3f64f56702d" translate="yes" xml:space="preserve">
          <source>While it is possible to leave the function undefined and thus invoke a link failure (to define the function with a message in &lt;code&gt;.gnu.warning*&lt;/code&gt; section), when using these attributes the problem is diagnosed earlier and with exact location of the call even in presence of inline functions or when not emitting debugging information.</source>
          <target state="translated">Хотя можно оставить функцию неопределенной и, таким образом, вызвать сбой связи (чтобы определить функцию с сообщением в разделе &lt;code&gt;.gnu.warning*&lt;/code&gt; ), при использовании этих атрибутов проблема диагностируется раньше и с точным местоположением вызова даже в наличие встроенных функций или отсутствие отладочной информации.</target>
        </trans-unit>
        <trans-unit id="652d59cea2004903b4f313a4a1b258897728e71e" translate="yes" xml:space="preserve">
          <source>While the compiler is aware of changes to entries listed in the output operands, the inline &lt;code&gt;asm&lt;/code&gt; code may modify more than just the outputs. For example, calculations may require additional registers, or the processor may overwrite a register as a side effect of a particular assembler instruction. In order to inform the compiler of these changes, list them in the clobber list. Clobber list items are either register names or the special clobbers (listed below). Each clobber list item is a string constant enclosed in double quotes and separated by commas.</source>
          <target state="translated">Хотя компилятор знает об изменениях записей, перечисленных в выходных операндах, встроенный &lt;code&gt;asm&lt;/code&gt; - код может изменять не только выходные данные. Например, для вычислений могут потребоваться дополнительные регистры, или процессор может перезаписать регистр как побочный эффект конкретной инструкции ассемблера. Чтобы сообщить компилятору об этих изменениях, внесите их в список clobber. Пункты списка Clobber - это либо имена регистров, либо специальные clobbers (перечисленные ниже). Каждый элемент списка clobber представляет собой строковую константу, заключенную в двойные кавычки и разделенные запятыми.</target>
        </trans-unit>
        <trans-unit id="e21fa2c7a90a60eea68201dc97480d9a5390c69c" translate="yes" xml:space="preserve">
          <source>While the uses of &lt;code&gt;asm&lt;/code&gt; are many and varied, it may help to think of an &lt;code&gt;asm&lt;/code&gt; statement as a series of low-level instructions that convert input parameters to output parameters. So a simple (if not particularly useful) example for i386 using &lt;code&gt;asm&lt;/code&gt; might look like this:</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;asm&lt;/code&gt; используется много и разнообразно, можно подумать об операторе &lt;code&gt;asm&lt;/code&gt; как о серии низкоуровневых инструкций, которые преобразуют входные параметры в выходные параметры. Итак, простой (если не особо полезный) пример для i386 с использованием &lt;code&gt;asm&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="39d000e8aa5910f6d9ef12595235838dbefbbb8c" translate="yes" xml:space="preserve">
          <source>While transforming the program out of the SSA representation, attempt to reduce copying by coalescing versions of different user-defined variables, instead of just compiler temporaries. This may severely limit the ability to debug an optimized program compiled with</source>
          <target state="translated">При преобразовании программы из представления SSA попытайтесь сократить копирование путем объединения версий различных пользовательских переменных,а не только временных файлов компилятора.Это может серьезно ограничить возможность отладки оптимизированной программы,скомпилированной с помощью</target>
        </trans-unit>
        <trans-unit id="91e29563eb1f68f27cd54dba1d78ec9cc5f02f0e" translate="yes" xml:space="preserve">
          <source>Whitespace characters are ignored and can be inserted at any position except the first. This enables each alternative for different operands to be visually aligned in the machine description even if they have different number of constraints and modifiers.</source>
          <target state="translated">Пробельные символы игнорируются и могут быть вставлены в любую позицию,кроме первой.Это позволяет визуально выровнять каждую альтернативу для различных операндов в описании машины,даже если они имеют разное количество ограничений и модификаторов.</target>
        </trans-unit>
        <trans-unit id="45faa4599697b06106508c630a671752d1b455fb" translate="yes" xml:space="preserve">
          <source>Wint-to-pointer-cast</source>
          <target state="translated">Wint-to-pointer-cast</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="db41302cf4b363b4a1378448e9a36c920e1a7fca" translate="yes" xml:space="preserve">
          <source>With both</source>
          <target state="translated">С обоими</target>
        </trans-unit>
        <trans-unit id="a29e68e9d153083133283a2db9d7b73482a032a4" translate="yes" xml:space="preserve">
          <source>With extended &lt;code&gt;asm&lt;/code&gt; you can read and write C variables from assembler and perform jumps from assembler code to C labels. Extended &lt;code&gt;asm&lt;/code&gt; syntax uses colons (&amp;lsquo;</source>
          <target state="translated">С расширенным &lt;code&gt;asm&lt;/code&gt; вы можете читать и записывать переменные C из ассемблера и выполнять переходы от кода ассемблера к меткам C. Расширенный синтаксис &lt;code&gt;asm&lt;/code&gt; использует двоеточия ('</target>
        </trans-unit>
        <trans-unit id="b2027ec70d531c569c806c46a0ed0d35bbfbe374" translate="yes" xml:space="preserve">
          <source>With no modifiers, this is what the output from the operands would be for the &amp;lsquo;</source>
          <target state="translated">Без модификаторов это то, что будет вывод операндов для '</target>
        </trans-unit>
        <trans-unit id="d8a4b9d08d97e45adb4da87468c9bc15fb87e195" translate="yes" xml:space="preserve">
          <source>With the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd37ca8139ba8f0077df8728d69e1509b46cb93" translate="yes" xml:space="preserve">
          <source>With the GNU C++ front end, for x86 targets, you may specify multiple versions of a function, where each function is specialized for a specific target feature. At runtime, the appropriate version of the function is automatically executed depending on the characteristics of the execution platform. Here is an example.</source>
          <target state="translated">В GNU C++front end,для x86 targets,вы можете указать несколько версий функции,где каждая функция специализируется на конкретной целевой функции.Во время выполнения автоматически выполняется соответствующая версия функции в зависимости от характеристик платформы выполнения.Приведем пример.</target>
        </trans-unit>
        <trans-unit id="872450a8fc748ddfde2cdc81d3d1bdedfaa16509" translate="yes" xml:space="preserve">
          <source>With the GNU runtime, exceptions are always implemented as &amp;ldquo;native&amp;rdquo; exceptions and it is recommended that the</source>
          <target state="translated">В среде исполнения GNU исключения всегда реализуются как &amp;laquo;собственные&amp;raquo; исключения, и рекомендуется, чтобы</target>
        </trans-unit>
        <trans-unit id="ede352de48f14dbfe64db09513e522c73f079435" translate="yes" xml:space="preserve">
          <source>With the NeXT runtime, although currently designed to be binary compatible with &lt;code&gt;NS_HANDLER&lt;/code&gt;-style idioms provided by the &lt;code&gt;NSException&lt;/code&gt; class, the new exceptions can only be used on Mac OS X 10.3 (Panther) and later systems, due to additional functionality needed in the NeXT Objective-C runtime.</source>
          <target state="translated">Со средой выполнения NeXT, хотя в настоящее время она предназначена для двоичной совместимости с &lt;code&gt;NS_HANDLER&lt;/code&gt; стиля NS_HANDLER, предоставляемыми классом &lt;code&gt;NSException&lt;/code&gt; , новые исключения могут использоваться только в Mac OS X 10.3 (Panther) и более поздних системах из-за дополнительных функций, необходимых в NeXT. Среда выполнения Objective-C.</target>
        </trans-unit>
        <trans-unit id="dab61d2e9aaa3623f28b2c32d76967b2c680ed03" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one &lt;var&gt;storage-class-specifier&lt;/var&gt; shall appear in a given &lt;var&gt;decl-specifier-seq&lt;/var&gt;. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers. [&amp;hellip;]</source>
          <target state="translated">За исключением &lt;code&gt;__thread&lt;/code&gt; , не более одного &lt;var&gt;storage-class-specifier&lt;/var&gt; должен появиться в данном &lt;var&gt;decl-specifier-seq&lt;/var&gt; . Спецификатор &lt;code&gt;__thread&lt;/code&gt; может использоваться отдельно или сразу после спецификаторов &lt;code&gt;extern&lt;/code&gt; или &lt;code&gt;static&lt;/code&gt; . [...]</target>
        </trans-unit>
        <trans-unit id="292a47839ebc29dbb70ec7b25cc162b60e68673e" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one storage-class specifier may be given [&amp;hellip;]. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">За исключением &lt;code&gt;__thread&lt;/code&gt; , может быть задано не более одного спецификатора класса хранения [&amp;hellip;]. Спецификатор &lt;code&gt;__thread&lt;/code&gt; может использоваться отдельно или сразу после &lt;code&gt;extern&lt;/code&gt; или &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a3f5b76de67732f25dfbe9b7ab3c5b977a603b2" translate="yes" xml:space="preserve">
          <source>With the exception of built-ins that have library equivalents such as the standard C library functions discussed below, or that expand to library calls, GCC built-in functions are always expanded inline and thus do not have corresponding entry points and their address cannot be obtained. Attempting to use them in an expression other than a function call results in a compile-time error.</source>
          <target state="translated">За исключением встраиваемых функций,которые имеют библиотечные эквиваленты,такие как стандартные библиотечные функции C,рассмотренные ниже,или которые расширяются до вызовов библиотек,встроенные функции GCC всегда расширяются встроенными функциями,и поэтому не имеют соответствующих точек входа,и их адрес не может быть получен.Попытка использовать их в выражении,отличном от вызова функции,приводит к ошибке во время компиляции.</target>
        </trans-unit>
        <trans-unit id="e736ee71288d11d1b230f0b89bdd35b5282b45ac" translate="yes" xml:space="preserve">
          <source>With the latter choice the options</source>
          <target state="translated">С последним выбором вариантов</target>
        </trans-unit>
        <trans-unit id="a6637ce41dda1dbfc19245d823fa7fce4d91f90f" translate="yes" xml:space="preserve">
          <source>With the linker plugin enabled, the linker extracts the needed GIMPLE files from</source>
          <target state="translated">При включенном плагине компоновщика,компоновщик извлекает нужные файлы GIMPLE из</target>
        </trans-unit>
        <trans-unit id="8b0e7753b83f2f64fc1212f98878b05c847daa5e" translate="yes" xml:space="preserve">
          <source>With the specification of an output file, the output is appended to the named file, and it looks like this:</source>
          <target state="translated">При спецификации выходного файла выходной файл добавляется к именованному файлу,и он выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="51ee435d4a40a1b09c0e1be2e1a80aec4607b86e" translate="yes" xml:space="preserve">
          <source>With this interface, &lt;code&gt;wait&lt;/code&gt;&amp;rsquo;s implementation might look like this:</source>
          <target state="translated">В этом интерфейсе реализация &lt;code&gt;wait&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="901e3b5288c53d25410e3fbe70a050954297b494" translate="yes" xml:space="preserve">
          <source>With this option, the compiler creates multiple copies of some local variables when unrolling a loop, which can result in superior code.</source>
          <target state="translated">С помощью этой опции компилятор при разворачивании цикла создает несколько копий некоторых локальных переменных,что может привести к улучшению кода.</target>
        </trans-unit>
        <trans-unit id="ce8a418995461de4210630163f948f5da9423e89" translate="yes" xml:space="preserve">
          <source>With this option, the compiler turns the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call into a diagnostics message call instead. When reaching the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call, the behavior is undefined.</source>
          <target state="translated">С помощью этой опции компилятор вместо этого превращает вызов &lt;code&gt;__builtin_unreachable&lt;/code&gt; в вызов диагностического сообщения. При достижении вызова &lt;code&gt;__builtin_unreachable&lt;/code&gt; поведение не определено.</target>
        </trans-unit>
        <trans-unit id="756db1c4a886455bb3e77429e2aacb2477c5e4e1" translate="yes" xml:space="preserve">
          <source>With this pragma, the programmer asserts that there are no loop-carried dependencies which would prevent consecutive iterations of the following loop from executing concurrently with SIMD (single instruction multiple data) instructions.</source>
          <target state="translated">С помощью этой прагмы программист утверждает,что не существует зацикленных зависимостей,которые препятствовали бы одновременному выполнению последовательных итераций следующего цикла с инструкциями SIMD (одна инструкция-несколько данных).</target>
        </trans-unit>
        <trans-unit id="a8d9a31f26b7d1b3f16e1e66c83efb3ffbd755c5" translate="yes" xml:space="preserve">
          <source>Within either execution environment, a &lt;em&gt;thread&lt;/em&gt; is a flow of control within a program. It is implementation defined whether or not there may be more than one thread associated with a program. It is implementation defined how threads beyond the first are created, the name and type of the function called at thread startup, and how threads may be terminated. However, objects with thread storage duration shall be initialized before thread startup.</source>
          <target state="translated">В любой среде выполнения &lt;em&gt;поток&lt;/em&gt; - это поток управления в программе. Реализация определяется, может ли с программой быть связано более одного потока. Реализация определяет, как создаются потоки, помимо первого, имя и тип функции, вызываемой при запуске потока, и как потоки могут быть завершены. Однако объекты с длительностью хранения потока должны быть инициализированы перед запуском потока.</target>
        </trans-unit>
        <trans-unit id="0e894809a49c1ed8c2eb1cfd50b560eb03dca15f" translate="yes" xml:space="preserve">
          <source>Within the body of &lt;code&gt;T::fn&lt;/code&gt;, &lt;var&gt;this&lt;/var&gt; has the effective definition &lt;code&gt;T *__restrict__ const this&lt;/code&gt;. Notice that the interpretation of a &lt;code&gt;__restrict__&lt;/code&gt; member function qualifier is different to that of &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt; qualifier, in that it is applied to the pointer rather than the object. This is consistent with other compilers that implement restricted pointers.</source>
          <target state="translated">В теле &lt;code&gt;T::fn&lt;/code&gt; , &lt;var&gt;this&lt;/var&gt; имеет эффективное определение &lt;code&gt;T *__restrict__ const this&lt;/code&gt; . Обратите внимание, что интерпретация квалификатора функции-члена &lt;code&gt;__restrict__&lt;/code&gt; отличается от интерпретации квалификатора &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;volatile&lt;/code&gt; тем , что он применяется к указателю, а не к объекту. Это согласуется с другими компиляторами, реализующими ограниченные указатели.</target>
        </trans-unit>
        <trans-unit id="06d91320f48b09da02ef917261dcfd59521156ff" translate="yes" xml:space="preserve">
          <source>Without a value specified, pack all structure members together without holes. When a value is specified (which must be a small power of two), pack structure members according to this value, representing the maximum alignment (that is, objects with default alignment requirements larger than this are output potentially unaligned at the next fitting location.</source>
          <target state="translated">Без указания значения упакуйте все элементы конструкции вместе без отверстий.Когда указано значение (которое должно быть небольшим из двух),члены структуры упаковываются в соответствии с этим значением,представляющим собой максимальное выравнивание (т.е.объекты с требованиями по умолчанию по выравниванию,превышающими это значение,выводятся потенциально не выровненными в следующем подходящем месте.</target>
        </trans-unit>
        <trans-unit id="4610e8cd3674760f9e34246c3335f6375dea470e" translate="yes" xml:space="preserve">
          <source>Without any optimization option, the compiler&amp;rsquo;s goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you expect from the source code.</source>
          <target state="translated">Без какой-либо опции оптимизации цель компилятора - снизить стоимость компиляции и добиться от отладки ожидаемых результатов. Операторы независимы: если вы останавливаете программу с точкой останова между операторами, вы можете затем присвоить новое значение любой переменной или изменить счетчик программы на любой другой оператор в функции и получить именно те результаты, которые вы ожидаете от исходного кода.</target>
        </trans-unit>
        <trans-unit id="d8d4a33aae2a07ecc8c812bfec17c5e5d451e08a" translate="yes" xml:space="preserve">
          <source>Without the specification of an output file, the output looks like this:</source>
          <target state="translated">Без спецификации выходного файла вывод выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5f36069c670576f1745c3bcd64036649a26fba3f" translate="yes" xml:space="preserve">
          <source>Without this option, &amp;lsquo;</source>
          <target state="translated">Без этой опции '</target>
        </trans-unit>
        <trans-unit id="810b49b99b225fdb366e04ce850176fc78b9dace" translate="yes" xml:space="preserve">
          <source>Without this option, the &lt;code&gt;X&lt;/code&gt; register may be used in the same way as &lt;code&gt;Y&lt;/code&gt; or &lt;code&gt;Z&lt;/code&gt; which then is emulated by additional instructions. For example, loading a value with &lt;code&gt;X+const&lt;/code&gt; addressing with a small non-negative &lt;code&gt;const &amp;lt; 64&lt;/code&gt; to a register &lt;var&gt;Rn&lt;/var&gt; is performed as</source>
          <target state="translated">Без этой опции регистр &lt;code&gt;X&lt;/code&gt; может использоваться так же, как &lt;code&gt;Y&lt;/code&gt; или &lt;code&gt;Z&lt;/code&gt; , который затем эмулируется дополнительными инструкциями. Например, загрузка значения с адресацией &lt;code&gt;X+const&lt;/code&gt; с небольшим неотрицательным &lt;code&gt;const &amp;lt; 64&lt;/code&gt; в регистр &lt;var&gt;Rn&lt;/var&gt; выполняется как</target>
        </trans-unit>
        <trans-unit id="4c7069fd8666957ba9eac9efad054fa1d2f74644" translate="yes" xml:space="preserve">
          <source>Work around a bug in the &lt;code&gt;muls&lt;/code&gt; and &lt;code&gt;mulu&lt;/code&gt; instructions for CPU models where it applies. This option is active by default.</source>
          <target state="translated">Работа вокруг ошибки в &lt;code&gt;muls&lt;/code&gt; и &lt;code&gt;mulu&lt;/code&gt; инструкции для моделей процессоров , где она применяется. Эта опция активна по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9517982144bf04b0b47a4d85a09581d177ba1cbb" translate="yes" xml:space="preserve">
          <source>Work around a hardware bug that causes the SPU to stall indefinitely. By default, GCC inserts the &lt;code&gt;hbrp&lt;/code&gt; instruction to make sure this stall won&amp;rsquo;t happen.</source>
          <target state="translated">Обходите аппаратную ошибку, из-за которой SPU зависает на неопределенное время. По умолчанию GCC вставляет инструкцию &lt;code&gt;hbrp&lt;/code&gt; , чтобы этого не произошло.</target>
        </trans-unit>
        <trans-unit id="8c4b8e3f13ae11240c809eb84fd3edb5d1bba62a" translate="yes" xml:space="preserve">
          <source>Work around certain R10000 errata:</source>
          <target state="translated">Поработайте с определенными ошибками R10000:</target>
        </trans-unit>
        <trans-unit id="9074be04c7616416ed213f212eeb7c6c7c183d4c" translate="yes" xml:space="preserve">
          <source>Work around certain R4000 CPU errata:</source>
          <target state="translated">Работайте с определенными ошибками процессора R4000:</target>
        </trans-unit>
        <trans-unit id="fd709a4ced203846b02db64672dd131b123d5504" translate="yes" xml:space="preserve">
          <source>Work around certain R4400 CPU errata:</source>
          <target state="translated">Работайте с определенными ошибками процессора R4400:</target>
        </trans-unit>
        <trans-unit id="9c76802dfaf86b35388bb6eac2a9a428f20a7a39" translate="yes" xml:space="preserve">
          <source>Work around certain SB-1 CPU core errata. (This flag currently works around the SB-1 revision 2 &amp;ldquo;F1&amp;rdquo; and &amp;ldquo;F2&amp;rdquo; floating-point errata.)</source>
          <target state="translated">Устраните определенные ошибки ядра ЦП SB-1. (Этот флаг в настоящее время работает с ошибками с плавающей запятой SB-1 версии 2 &amp;laquo;F1&amp;raquo; и &amp;laquo;F2&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="f1322c2c26c7f8a2ae0c4abcf920ab6e36d8883e" translate="yes" xml:space="preserve">
          <source>Work around certain VR4120 errata:</source>
          <target state="translated">Поработайте с определенными ошибками VR4120:</target>
        </trans-unit>
        <trans-unit id="70f65ee28d3f60e1570e5c0565d3bacdc0372408" translate="yes" xml:space="preserve">
          <source>Work around the 24K E48 (lost data on stores during refill) errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">Работайте с ошибками 24K E48 (потеря данных в хранилищах при пополнении).Обходные пути реализуются ассемблером,а не GCC.</target>
        </trans-unit>
        <trans-unit id="eecdf3e0ad9c1e4373885008c446ef1d15e0de5a" translate="yes" xml:space="preserve">
          <source>Work around the RM7000 &lt;code&gt;dmult&lt;/code&gt;/&lt;code&gt;dmultu&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">Исправьте &lt;code&gt;dmult&lt;/code&gt; RM7000 dmult / &lt;code&gt;dmultu&lt;/code&gt; . Обходные пути реализуются ассемблером, а не GCC.</target>
        </trans-unit>
        <trans-unit id="f514e8f6d3c8232406871016402b0b519b9f1bff" translate="yes" xml:space="preserve">
          <source>Work around the VR4130 &lt;code&gt;mflo&lt;/code&gt;/&lt;code&gt;mfhi&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC, although GCC avoids using &lt;code&gt;mflo&lt;/code&gt; and &lt;code&gt;mfhi&lt;/code&gt; if the VR4130 &lt;code&gt;macc&lt;/code&gt;, &lt;code&gt;macchi&lt;/code&gt;, &lt;code&gt;dmacc&lt;/code&gt; and &lt;code&gt;dmacchi&lt;/code&gt; instructions are available instead.</source>
          <target state="translated">Исправьте &lt;code&gt;mflo&lt;/code&gt; VR4130 mflo / &lt;code&gt;mfhi&lt;/code&gt; . Обходные пути реализуются ассемблером, а не GCC, хотя GCC избегает использования &lt;code&gt;mflo&lt;/code&gt; и &lt;code&gt;mfhi&lt;/code&gt; , если вместо них доступны инструкции VR4130 &lt;code&gt;macc&lt;/code&gt; , &lt;code&gt;macchi&lt;/code&gt; , &lt;code&gt;dmacc&lt;/code&gt; и &lt;code&gt;dmacchi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a937c64e2a5b7eba62b666d7ca837eb48731984" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into Y.</source>
          <target state="translated">Запишите &lt;var&gt;src1&lt;/var&gt; в Y.</target>
        </trans-unit>
        <trans-unit id="b99c5ddd130a32b9357572f70d99408237dc24f1" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into the least significant half of X and &lt;var&gt;src2&lt;/var&gt; into the most significant half of X.</source>
          <target state="translated">Запишите &lt;var&gt;src1&lt;/var&gt; в младшую половину X и &lt;var&gt;src2&lt;/var&gt; в старшую половину X.</target>
        </trans-unit>
        <trans-unit id="282a09ed773c8ef9852a2c6377ed12597d3a9c69" translate="yes" xml:space="preserve">
          <source>Write a SRCFILE.opt-record.json.gz file detailing what optimizations were performed, for those optimizations that support</source>
          <target state="translated">Напишите файл SRCFILE.opt-record.json.gz,в котором подробно описано,какие оптимизации были выполнены,для тех оптимизаций,которые поддерживаются</target>
        </trans-unit>
        <trans-unit id="40d1ca8852e0dec6c7d4fad7e6bc0514fe5d1c54" translate="yes" xml:space="preserve">
          <source>Write branch frequencies as the number of branches taken, rather than the percentage of branches taken.</source>
          <target state="translated">Частоты ветвей записывайте как количество взятых ветвей,а не как процент взятых ветвей.</target>
        </trans-unit>
        <trans-unit id="1423ee2af8243360b137ebe26d7ad382ca0b3b1e" translate="yes" xml:space="preserve">
          <source>Write branch frequencies to the output file, and write branch summary info to the standard output. This option allows you to see how often each branch in your program was taken. Unconditional branches will not be shown, unless the</source>
          <target state="translated">Запишите частоты ветвей в выходной файл и запишите сводную информацию о ветвях в стандартный выходной файл.Эта опция позволяет вам увидеть,как часто каждая ветвь в вашей программе была взята.Необусловленные ветви не будут показаны,если только</target>
        </trans-unit>
        <trans-unit id="1fecc6871d15f561a1a398ebd76fa3a7a1663e9e" translate="yes" xml:space="preserve">
          <source>Write counts in human readable format (like 24.6k).</source>
          <target state="translated">Пишите в формате,удобном для чтения человеком (например,24.6k).</target>
        </trans-unit>
        <trans-unit id="e00e26a5662df1b01236462f99618d8089824cf9" translate="yes" xml:space="preserve">
          <source>Write individual execution counts for every basic block. Normally gcov outputs execution counts only for the main blocks of a line. With this option you can determine if blocks within a single line are not being executed.</source>
          <target state="translated">Запишите индивидуальные подсчеты выполнения для каждого базового блока.Обычно gcov выводит счетчик выполнения только для основных блоков строки.С помощью этой опции можно определить,не выполняются ли блоки внутри одной строки.</target>
        </trans-unit>
        <trans-unit id="27b79e5dd909fed4a63697002ecabe6d4fcefd2b" translate="yes" xml:space="preserve">
          <source>Write the name of each function into the text section, directly preceding the function prologue. The generated code is similar to this:</source>
          <target state="translated">Запишите название каждой функции в текстовую секцию,непосредственно предшествующую прологу функции.Сгенерированный код аналогичен этому:</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="2c144edd2dd673b9ae13db81c4f7c41356844426" translate="yes" xml:space="preserve">
          <source>XER[CA]</source>
          <target state="translated">XER[CA]</target>
        </trans-unit>
        <trans-unit id="edd05eca97855bc49145e43cb3ab5438e61cd98b" translate="yes" xml:space="preserve">
          <source>XOP instructions.</source>
          <target state="translated">XOP инструкции.</target>
        </trans-unit>
        <trans-unit id="e69dd5b634eb9535ab5de7682e5d1e10df284ccf" translate="yes" xml:space="preserve">
          <source>Xstormy16&amp;mdash;</source>
          <target state="translated">Xstormy16&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8341de0a85a327eb2d7c97b77086eb0bff937ecb" translate="yes" xml:space="preserve">
          <source>Xtensa&amp;mdash;</source>
          <target state="translated">Xtensa&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="cbfadbe232364f5b4cd1f9250a9cda7fadbb0042" translate="yes" xml:space="preserve">
          <source>You can additionally specify a string parameter: &amp;lsquo;</source>
          <target state="translated">Вы можете дополнительно указать строковый параметр: '</target>
        </trans-unit>
        <trans-unit id="37f047474bb2991bbc870836a4b1dc7ea6a7e179" translate="yes" xml:space="preserve">
          <source>You can also construct an array, though this is dangerous in C++, as explained below. If all the elements of the compound literal are (made up of) simple constant expressions suitable for use in initializers of objects of static storage duration, then the compound literal can be coerced to a pointer to its first element and used in such an initializer, as shown here:</source>
          <target state="translated">Вы также можете построить массив,хотя это опасно в C++,как поясняется ниже.Если все элементы составного литерала представляют собой (состоящие из)простых константных выражений,пригодных для использования в инициализаторах объектов статической длительности хранения,то составной литерал может быть принудительно приведен к указателю на его первый элемент и использован в таком инициализаторе,как показано здесь:</target>
        </trans-unit>
        <trans-unit id="7e3923b44bbc7d66662628b3637d89fe21e428bc" translate="yes" xml:space="preserve">
          <source>You can also include type attributes in a &lt;code&gt;typedef&lt;/code&gt; declaration. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes.</source>
          <target state="translated">Вы также можете включить атрибуты типа в объявление &lt;code&gt;typedef&lt;/code&gt; . См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; подробную информацию о точном синтаксисе использования атрибутов.</target>
        </trans-unit>
        <trans-unit id="c36aaae0a5a83266e8e76c432773d2ebb3588799" translate="yes" xml:space="preserve">
          <source>You can also override the ARM and Thumb mode for each function by using the &lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; and &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">Вы также можете переопределить режимы ARM и Thumb для каждой функции, используя атрибуты функции &lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; и &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; (см. &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;Атрибуты функций ARM&lt;/a&gt; ) или прагмы (см. &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Прагмы опций, специфичных для функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="70f9f23d58cf9ce6f889493d1bc7a0c90625f3a7" translate="yes" xml:space="preserve">
          <source>You can also record the return value of that function call, and later return that value, without knowing what data type the function tried to return (as long as your caller expects that data type).</source>
          <target state="translated">Вы также можете записать возвращаемое значение этого вызова функции,а затем вернуть это значение,не зная,какой тип данных пыталась вернуть функция (до тех пор,пока ваш вызывающий абонент ожидает этот тип данных).</target>
        </trans-unit>
        <trans-unit id="1165641e4d4b9af84b909635ee9d9e9c442957c3" translate="yes" xml:space="preserve">
          <source>You can also set the fpu name at function level by using the &lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">Вы также можете установить имя fpu на уровне функции с помощью &lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; атрибутов функции (см. &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;Атрибуты функций ARM&lt;/a&gt; ) или прагм (см. &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Прагмы опций, специфичных для функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7268dd0eaeb17935e5094a8029ba22d93c31a1ac" translate="yes" xml:space="preserve">
          <source>You can also specify</source>
          <target state="translated">Вы также можете указать</target>
        </trans-unit>
        <trans-unit id="08bf03c9c6ff7624c857011e74954c5c6f9f4300" translate="yes" xml:space="preserve">
          <source>You can also specify the alignment of structure fields. For example, to create a double-word aligned &lt;code&gt;int&lt;/code&gt; pair, you could write:</source>
          <target state="translated">Вы также можете указать выравнивание полей структуры. Например, чтобы создать пару &lt;code&gt;int&lt;/code&gt; , выровненную по двойному слову , вы можете написать:</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">Вы также можете использовать</target>
        </trans-unit>
        <trans-unit id="282b6d022cb9c27fb3bb9103220d6eb51129f71a" translate="yes" xml:space="preserve">
          <source>You can also use attributes to control memory placement, code generation options or call/return conventions within the function being annotated. Many of these attributes are target-specific. For example, many targets support attributes for defining interrupt handler functions, which typically must follow special register usage and return conventions. Such attributes are described in the subsection for each target. However, a considerable number of attributes are supported by most, if not all targets. Those are described in the &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt; section.</source>
          <target state="translated">Вы также можете использовать атрибуты для управления размещением в памяти, параметрами генерации кода или соглашениями о вызове / возврате в аннотируемой функции. Многие из этих атрибутов являются целевыми. Например, многие цели поддерживают атрибуты для определения функций обработчика прерываний, которые обычно должны следовать специальным соглашениям об использовании регистров и возврате. Такие атрибуты описаны в подразделе для каждой цели. Однако значительное количество атрибутов поддерживается большинством, если не всеми целями. Они описаны в разделе &amp;laquo; &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функций&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="972bfbc14b560aee91d8b7d5cfbc635d959441aa" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;asm&lt;/code&gt; keyword to override the assembler name for a C symbol, or to place a C variable in a specific register.</source>
          <target state="translated">Вы также можете использовать ключевое слово &lt;code&gt;asm&lt;/code&gt; , чтобы переопределить имя ассемблера для символа C или поместить переменную C в определенный регистр.</target>
        </trans-unit>
        <trans-unit id="354710c3fd8ed8d70c6d2f210156da0243dc4ade" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;nocf_check&lt;/code&gt; attribute to identify which functions and calls should be skipped from instrumentation (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">Вы также можете использовать атрибут &lt;code&gt;nocf_check&lt;/code&gt; , чтобы определить, какие функции и вызовы следует пропускать из инструментария (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1c6ca2bbbe80bcabecefea25be4aa8fafd6e4d0" translate="yes" xml:space="preserve">
          <source>You can also use the union cast as a function argument:</source>
          <target state="translated">Вы также можете использовать кастинг союза в качестве аргумента функции:</target>
        </trans-unit>
        <trans-unit id="66b750e5491b307807c28732748047266dbd8e2a" translate="yes" xml:space="preserve">
          <source>You can also use variable-length arrays as arguments to functions:</source>
          <target state="translated">Вы также можете использовать массивы переменной длины в качестве аргументов к функциям:</target>
        </trans-unit>
        <trans-unit id="3ed04a1e1ec2d18dcef36c3f37e8523ec33398b1" translate="yes" xml:space="preserve">
          <source>You can also write a series of &amp;lsquo;</source>
          <target state="translated">Вы также можете написать серию &quot;</target>
        </trans-unit>
        <trans-unit id="9a5d42d9b4feab1feb11ac3d7558132f70441d15" translate="yes" xml:space="preserve">
          <source>You can combine this technique of naming elements with ordinary C initialization of successive elements. Each initializer element that does not have a designator applies to the next consecutive element of the array or structure. For example,</source>
          <target state="translated">Вы можете комбинировать эту технику именования элементов с обычной инициализацией последовательных элементов на языке C.Каждый элемент инициализатора,не имеющий обозначения,относится к следующему последующему элементу массива или структуры.Например,</target>
        </trans-unit>
        <trans-unit id="dafe9f6d4d43d75c6afd7b0ee12396460454db2d" translate="yes" xml:space="preserve">
          <source>You can compile C or C++ programs.</source>
          <target state="translated">Вы можете скомпилировать программы на C или C++.</target>
        </trans-unit>
        <trans-unit id="54a148541552bb61abf1cc1bf716d6d5d34812ff" translate="yes" xml:space="preserve">
          <source>You can declare variables and use them in function calls and returns, as well as in assignments and some casts. You can specify a vector type as a return type for a function. Vector types can also be used as function arguments. It is possible to cast from one vector type to another, provided they are of the same size (in fact, you can also cast vectors to and from other datatypes of the same size).</source>
          <target state="translated">Вы можете объявлять переменные и использовать их в вызовах и возвратах функций,а также в присваиваниях и некоторых кастах.В качестве типа возврата для функции можно указать тип вектора.Векторные типы также могут быть использованы в качестве аргументов функции.Возможно приведение от одного векторного типа к другому при условии,что они имеют одинаковый размер (фактически,можно также приводить векторы к и от других типов данных того же размера).</target>
        </trans-unit>
        <trans-unit id="1ab5d021681ed2c7cdd4c44a866c9249ac2dea29" translate="yes" xml:space="preserve">
          <source>You can define a global register variable and associate it with a specified register like this:</source>
          <target state="translated">Вы можете определить глобальную регистровую переменную и связать ее с указанным регистром вот так:</target>
        </trans-unit>
        <trans-unit id="77ca46933320ecebc543d5687d368957991075a9" translate="yes" xml:space="preserve">
          <source>You can define a local register variable and associate it with a specified register like this:</source>
          <target state="translated">Вы можете определить локальную регистровую переменную и связать ее с указанным регистром вот так:</target>
        </trans-unit>
        <trans-unit id="ca45e2aac1a5f53872ccff8b57eb4700a2d304e0" translate="yes" xml:space="preserve">
          <source>You can define an &lt;code&gt;enum&lt;/code&gt; tag without specifying its possible values. This results in an incomplete type, much like what you get if you write &lt;code&gt;struct foo&lt;/code&gt; without describing the elements. A later declaration that does specify the possible values completes the type.</source>
          <target state="translated">Вы можете определить тег &lt;code&gt;enum&lt;/code&gt; без указания его возможных значений. Это приводит к неполному типу, очень похожему на то, что вы получите, если напишете &lt;code&gt;struct foo&lt;/code&gt; без описания элементов. Более позднее объявление, в котором указаны возможные значения, завершает тип.</target>
        </trans-unit>
        <trans-unit id="fb2a1d08a5c520db79d7874dd1dd146adad124cb" translate="yes" xml:space="preserve">
          <source>You can easily find more examples by running the &amp;ldquo;strings&amp;rdquo; program on an Objective-C object file compiled by GCC. You&amp;rsquo;ll see a lot of strings that look very much like &lt;code&gt;i8@0:4&lt;/code&gt;. They are signatures of Objective-C methods.</source>
          <target state="translated">Вы можете легко найти больше примеров, запустив программу &amp;laquo;строк&amp;raquo; ​​в объектном файле Objective-C, скомпилированном GCC. Вы увидите множество строк, очень похожих на &lt;code&gt;i8@0:4&lt;/code&gt; . Они являются сигнатурами методов Objective-C.</target>
        </trans-unit>
        <trans-unit id="c91ff1d5bc0072fabb3f73c5cf99e1426b54e8b7" translate="yes" xml:space="preserve">
          <source>You can extract a function pointer to the method denoted by a &amp;lsquo;</source>
          <target state="translated">Вы можете извлечь указатель функции на метод, обозначенный символом '</target>
        </trans-unit>
        <trans-unit id="8a467dff38136e5694516c0b9fa42d9b5384c2d1" translate="yes" xml:space="preserve">
          <source>You can get the address of a label defined in the current function (or a containing function) with the unary operator &amp;lsquo;</source>
          <target state="translated">Вы можете получить адрес метки, определенной в текущей функции (или содержащей функцию), с помощью унарного оператора '</target>
        </trans-unit>
        <trans-unit id="66a39a597ab8644152ae7afe5488f241a221884a" translate="yes" xml:space="preserve">
          <source>You can locally override stack limit checking by using the &lt;code&gt;no_stack_limit&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">Вы можете локально переопределить проверку предела стека, используя &lt;code&gt;no_stack_limit&lt;/code&gt; функции no_stack_limit (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="017844d9ef74d08a2197a10acca046c6aa9a28bc" translate="yes" xml:space="preserve">
          <source>You can make</source>
          <target state="translated">Вы можете сделать</target>
        </trans-unit>
        <trans-unit id="f287c383d16164fdc862549b5e329c619384b24c" translate="yes" xml:space="preserve">
          <source>You can mix options and other arguments. For the most part, the order you use doesn&amp;rsquo;t matter. Order does matter when you use several options of the same kind; for example, if you specify</source>
          <target state="translated">Вы можете смешивать варианты и другие аргументы. По большей части порядок, который вы используете, не имеет значения. Порядок имеет значение, когда вы используете несколько вариантов одного и того же типа; например, если вы укажете</target>
        </trans-unit>
        <trans-unit id="a60d360fa80936234f5b0e4eae813689b9ce29d9" translate="yes" xml:space="preserve">
          <source>You can partially avoid this problem by using the</source>
          <target state="translated">Вы можете частично избежать этой проблемы,используя</target>
        </trans-unit>
        <trans-unit id="dd9e0967154278910b1a4d13c152f96dcaf35354" translate="yes" xml:space="preserve">
          <source>You can pass options to the assembler.</source>
          <target state="translated">Вы можете передать опции сборщику.</target>
        </trans-unit>
        <trans-unit id="394017d54ef624457656b3872471fba70d98d59b" translate="yes" xml:space="preserve">
          <source>You can provide an argument to the interrupt attribute which specifies a name or number. If the argument is a number it indicates the slot in the interrupt vector table (0 - 31) to which this handler should be assigned. If the argument is a name it is treated as a symbolic name for the vector slot. These names should match up with appropriate entries in the linker script. By default the names &lt;code&gt;watchdog&lt;/code&gt; for vector 26, &lt;code&gt;nmi&lt;/code&gt; for vector 30 and &lt;code&gt;reset&lt;/code&gt; for vector 31 are recognized.</source>
          <target state="translated">Вы можете предоставить аргумент для атрибута прерывания, который указывает имя или номер. Если аргумент является числом, он указывает слот в таблице векторов прерываний (0&amp;ndash;31), которому должен быть назначен этот обработчик. Если аргументом является имя, оно рассматривается как символическое имя для векторного слота. Эти имена должны совпадать с соответствующими записями в сценарии компоновщика. По умолчанию распознаются &lt;code&gt;watchdog&lt;/code&gt; имен для вектора 26, &lt;code&gt;nmi&lt;/code&gt; для вектора 30 и &lt;code&gt;reset&lt;/code&gt; для вектора 31.</target>
        </trans-unit>
        <trans-unit id="21a34f7c6e1539af9716888a85e0e6ebdfedbecf" translate="yes" xml:space="preserve">
          <source>You can request many specific warnings with options beginning with &amp;lsquo;</source>
          <target state="translated">Вы можете запросить множество конкретных предупреждений с параметрами, начинающимися с '</target>
        </trans-unit>
        <trans-unit id="7fbbe3966a5814f26c4830b1276b72ab5f2dc01c" translate="yes" xml:space="preserve">
          <source>You can specify a range of consecutive values in a single &lt;code&gt;case&lt;/code&gt; label, like this:</source>
          <target state="translated">Вы можете указать диапазон последовательных значений в метке с одним &lt;code&gt;case&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="97b79ea591cef9266e325e711531c14dffd1c998" translate="yes" xml:space="preserve">
          <source>You can specify any number or combination of these options on the command line to search for header files in several directories. The lookup order is as follows:</source>
          <target state="translated">Вы можете указать любое количество или комбинацию этих опций в командной строке для поиска заголовочных файлов в нескольких каталогах.Порядок поиска следующий:</target>
        </trans-unit>
        <trans-unit id="0856d34db6c364c78838eb5dc1f8a6703a890626" translate="yes" xml:space="preserve">
          <source>You can specify that an individual function is called with this calling sequence with the function attribute &lt;code&gt;stdcall&lt;/code&gt;. You can also override the</source>
          <target state="translated">Вы можете указать, что отдельная функция вызывается с этой последовательностью вызовов, с помощью атрибута функции &lt;code&gt;stdcall&lt;/code&gt; . Вы также можете переопределить</target>
        </trans-unit>
        <trans-unit id="e32757ea6fc6362ed46b9b724d574c0143bee986" translate="yes" xml:space="preserve">
          <source>You can specify the input language explicitly with the</source>
          <target state="translated">Вы можете явно указать язык ввода с помощью команды</target>
        </trans-unit>
        <trans-unit id="5a6c68a45d3cab174002900881189fc68df355b1" translate="yes" xml:space="preserve">
          <source>You can specify the kind of interrupt to be handled by adding an optional parameter to the interrupt attribute like this:</source>
          <target state="translated">Вы можете указать тип обрабатываемого прерывания,добавив дополнительный параметр к атрибуту прерывания,например,такой:</target>
        </trans-unit>
        <trans-unit id="eee1f7bf9410ab86d8dd30e2bec2be1b2b043010" translate="yes" xml:space="preserve">
          <source>You can specify the name to be used in the assembler code for a C function or variable by writing the &lt;code&gt;asm&lt;/code&gt; (or &lt;code&gt;__asm__&lt;/code&gt;) keyword after the declarator. It is up to you to make sure that the assembler names you choose do not conflict with any other assembler symbols, or reference registers.</source>
          <target state="translated">Вы можете указать имя, которое будет использоваться в коде ассемблера для функции или переменной C, написав ключевое слово &lt;code&gt;asm&lt;/code&gt; (или &lt;code&gt;__asm__&lt;/code&gt; ) после декларатора. Вы должны убедиться, что выбранные вами имена ассемблера не конфликтуют с другими символами ассемблера или ссылочными регистрами.</target>
        </trans-unit>
        <trans-unit id="30703f7905f24c8604a78167a64a5e3a31da9d67" translate="yes" xml:space="preserve">
          <source>You can switch the warning off for all characters by writing</source>
          <target state="translated">Вы можете отключить предупреждение для всех символов,написав</target>
        </trans-unit>
        <trans-unit id="95dff15ddf46fdf8429aae6e46c8c16ce4977196" translate="yes" xml:space="preserve">
          <source>You can tell GCC to use a compatible convention for all structure and union returning with the option</source>
          <target state="translated">Вы можете сказать GCC использовать совместимое соглашение для всех структур и союзов возвращения с вариантом</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">Вы можете использовать</target>
        </trans-unit>
        <trans-unit id="4f81d4b126c2797fc5e8e7dc1694c11a9c296047" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllexport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;__declspec(dllexport)&lt;/code&gt; как синоним для &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; для совместимости с другими компиляторами.</target>
        </trans-unit>
        <trans-unit id="50005d4562495b37fc24571844dc1743ca746f4c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllimport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;__declspec(dllimport)&lt;/code&gt; в качестве синонима &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; для совместимости с другими компиляторами.</target>
        </trans-unit>
        <trans-unit id="86cd667b81efa67cbffa6feec930a1fbdb8eae9f" translate="yes" xml:space="preserve">
          <source>You can use a single C++ header file for both declarations and definitions.</source>
          <target state="translated">Вы можете использовать один C++заголовочный файл как для деклараций,так и для определений.</target>
        </trans-unit>
        <trans-unit id="9d208552bb3a27bb1eed945c45c53009e9054861" translate="yes" xml:space="preserve">
          <source>You can use any combination of these attributes, as shown below:</source>
          <target state="translated">Вы можете использовать любую комбинацию этих атрибутов,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="db76755964be4e6b6be71f9e85d1a8d93663640f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;copy&lt;/code&gt; attribute to apply the same set of attributes to a declaration as that on another declaration without explicitly enumerating the attributes. This attribute can be applied to declarations of functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;), or types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="translated">Вы можете использовать атрибут &lt;code&gt;copy&lt;/code&gt; чтобы применить тот же набор атрибутов к объявлению, что и к другому объявлению, без явного перечисления атрибутов. Этот атрибут может применяться к объявлениям функций (см. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функций&lt;/a&gt; ), переменных (см. &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Общие атрибуты переменных&lt;/a&gt; ) или типов (см. &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Общие атрибуты типов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="89b5b15d997a3489b69c6b152372fee0f86bbdac" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_choose_expr&lt;/code&gt; to evaluate code depending on the value of a constant expression. This built-in function returns &lt;var&gt;exp1&lt;/var&gt; if &lt;var&gt;const_exp&lt;/var&gt;, which is an integer constant expression, is nonzero. Otherwise it returns &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">Вы можете использовать встроенную функцию &lt;code&gt;__builtin_choose_expr&lt;/code&gt; для оценки кода в зависимости от значения константного выражения. Эта встроенная функция возвращает &lt;var&gt;exp1&lt;/var&gt; , если &lt;var&gt;const_exp&lt;/var&gt; , которое является целочисленным константным выражением, не равно нулю. В противном случае возвращается &lt;var&gt;exp2&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd9fec295629e67098066cf6cb3c9ec92e5bb68" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_constant_p&lt;/code&gt; to determine if a value is known to be constant at compile time and hence that GCC can perform constant-folding on expressions involving that value. The argument of the function is the value to test. The function returns the integer 1 if the argument is known to be a compile-time constant and 0 if it is not known to be a compile-time constant. A return of 0 does not indicate that the value is &lt;em&gt;not&lt;/em&gt; a constant, but merely that GCC cannot prove it is a constant with the specified value of the</source>
          <target state="translated">Вы можете использовать встроенную функцию &lt;code&gt;__builtin_constant_p&lt;/code&gt; , чтобы определить, является ли значение постоянным во время компиляции и, следовательно, GCC может выполнять свертывание констант для выражений, включающих это значение. Аргумент функции - это проверяемое значение. Функция возвращает целое число 1, если известно, что аргумент является константой времени компиляции, и 0, если известно, что он не является константой времени компиляции. Возврат 0 не означает, что значение &lt;em&gt;не&lt;/em&gt; является константой, а просто то, что GCC не может доказать, что это константа с указанным значением</target>
        </trans-unit>
        <trans-unit id="9782a2381707d838ed59767d72501592b95036b5" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; to determine whether two types are the same.</source>
          <target state="translated">Вы можете использовать встроенную функцию &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; , чтобы определить, являются ли два типа одинаковыми.</target>
        </trans-unit>
        <trans-unit id="43fa60b9360490e7ba0b03452edb689c2650070f" translate="yes" xml:space="preserve">
          <source>You can use the following attributes to modify the behavior of an interrupt handler:</source>
          <target state="translated">Вы можете использовать следующие атрибуты для изменения поведения обработчика прерываний:</target>
        </trans-unit>
        <trans-unit id="02c72ec7b7bacac9ecd4a1fee983fedeb76ad118" translate="yes" xml:space="preserve">
          <source>You can use the function &lt;code&gt;alloca&lt;/code&gt; to get an effect much like variable-length arrays. The function &lt;code&gt;alloca&lt;/code&gt; is available in many other C implementations (but not in all). On the other hand, variable-length arrays are more elegant.</source>
          <target state="translated">Вы можете использовать функцию &lt;code&gt;alloca&lt;/code&gt; , чтобы получить эффект, похожий на массивы переменной длины. Функция &lt;code&gt;alloca&lt;/code&gt; доступна во многих других реализациях C (но не во всех). С другой стороны, массивы переменной длины более элегантны.</target>
        </trans-unit>
        <trans-unit id="50e67953531648188b117541d8b8b4fa30e96296" translate="yes" xml:space="preserve">
          <source>You can use the function attribute &lt;code&gt;no_instrument_function&lt;/code&gt; to suppress profiling of individual functions when compiling with these options. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">Вы можете использовать атрибут функции &lt;code&gt;no_instrument_function&lt;/code&gt; , чтобы подавить профилирование отдельных функций при компиляции с этими параметрами. См. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0525436fc5cc0248b7f78e573bd26eb006c5427" translate="yes" xml:space="preserve">
          <source>You can use the sequence &amp;lsquo;</source>
          <target state="translated">Вы можете использовать последовательность '</target>
        </trans-unit>
        <trans-unit id="25c48302e37cab0b76739d2efc98f5300353b6c4" translate="yes" xml:space="preserve">
          <source>You can use these attributes on Microsoft Windows targets. &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; for additional Windows compatibility attributes available on all x86 targets.</source>
          <target state="translated">Вы можете использовать эти атрибуты в целях Microsoft Windows. &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;Атрибуты переменных x86&lt;/a&gt; для дополнительных атрибутов совместимости Windows, доступных для всех целей x86.</target>
        </trans-unit>
        <trans-unit id="349076840f0960c3892315d6f39c00e2e8d77252" translate="yes" xml:space="preserve">
          <source>You can use these types in arithmetic like any other integer types. Addition, subtraction, and bitwise boolean operations on these types are open-coded on all types of machines. Multiplication is open-coded if the machine supports a fullword-to-doubleword widening multiply instruction. Division and shifts are open-coded only on machines that provide special support. The operations that are not open-coded use special library routines that come with GCC.</source>
          <target state="translated">Вы можете использовать эти типы в арифметике,как и любые другие целочисленные типы.Добавление,вычитание и битовые логические операции над этими типами открыты для всех типов машин.Умножение является открытым кодом,если машина поддерживает инструкцию умножения с расширением от одного до двух слов.Деление и сдвиги открыты только на машинах,которые обеспечивают специальную поддержку.Операции,которые не имеют открытого кода,используют специальные библиотечные подпрограммы,которые поставляются с GCC.</target>
        </trans-unit>
        <trans-unit id="5aa1044e05ab82d1a453a9feb88c6b31c8d70c35" translate="yes" xml:space="preserve">
          <source>You can use this pragma to control how many times a loop should be unrolled. It must be placed immediately before a &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt; loop or a &lt;code&gt;#pragma GCC ivdep&lt;/code&gt;, and applies only to the loop that follows. &lt;var&gt;n&lt;/var&gt; is an integer constant expression specifying the unrolling factor. The values of &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;1&lt;/em&gt; block any unrolling of the loop.</source>
          <target state="translated">Вы можете использовать эту прагму, чтобы контролировать, сколько раз цикл должен быть развернут. Он должен быть размещен непосредственно перед циклом &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; или &lt;code&gt;do&lt;/code&gt; или &lt;code&gt;#pragma GCC ivdep&lt;/code&gt; и применяется только к следующему циклу. &lt;var&gt;n&lt;/var&gt; - целочисленное постоянное выражение, определяющее коэффициент развертки. Значения &lt;em&gt;0&lt;/em&gt; и &lt;em&gt;1&lt;/em&gt; блокируют любое развертывание цикла.</target>
        </trans-unit>
        <trans-unit id="d29715d375c9f43b63580c5f152e79229b459a6b" translate="yes" xml:space="preserve">
          <source>You can write any number of such parameter forward declarations in the parameter list. They can be separated by commas or semicolons, but the last one must end with a semicolon, which is followed by the &amp;ldquo;real&amp;rdquo; parameter declarations. Each forward declaration must match a &amp;ldquo;real&amp;rdquo; declaration in parameter name and data type. ISO C99 does not support parameter forward declarations.</source>
          <target state="translated">Вы можете записать любое количество таких предварительных объявлений параметров в список параметров. Их можно разделять запятыми или точками с запятой, но последняя должна заканчиваться точкой с запятой, за которой следуют &amp;laquo;настоящие&amp;raquo; объявления параметров. Каждое предварительное объявление должно соответствовать &amp;laquo;реальному&amp;raquo; объявлению в имени параметра и типе данных. ISO C99 не поддерживает предварительное объявление параметров.</target>
        </trans-unit>
        <trans-unit id="4d285fcb57d29c445f5c75a81399654db437434b" translate="yes" xml:space="preserve">
          <source>You cannot allocate variables or storage using the type while it is incomplete. However, you can work with pointers to that type.</source>
          <target state="translated">Нельзя выделять переменные или хранилище по типу,пока он неполный.Однако,вы можете работать с указателями на этот тип.</target>
        </trans-unit>
        <trans-unit id="53335da409471fbe7935a617fd9f6ebf473abc26" translate="yes" xml:space="preserve">
          <source>You cannot operate between vectors of different lengths or different signedness without a cast.</source>
          <target state="translated">Нельзя работать между векторами разной длины или разной подписью без гипса.</target>
        </trans-unit>
        <trans-unit id="13abf1800307e25590d2602f0489f433955f9bc6" translate="yes" xml:space="preserve">
          <source>You have freedom to copy and modify this GNU Manual, like GNU software. Copies published by the Free Software Foundation raise funds for GNU development.</source>
          <target state="translated">У вас есть свобода копировать и изменять это Руководство GNU,как программы GNU.Копии,опубликованные Фондом свободного программного обеспечения,собирают средства на разработку GNU.</target>
        </trans-unit>
        <trans-unit id="35918096a4cd3290ec21ef1581f71b03f35bc6de" translate="yes" xml:space="preserve">
          <source>You have the following options for dealing with template instantiations:</source>
          <target state="translated">У вас есть следующие опции для работы с инстанциями шаблонов:</target>
        </trans-unit>
        <trans-unit id="83ae29ebda55f943f2de3641f83fdea66157c750" translate="yes" xml:space="preserve">
          <source>You have to expect a certain amount of disagreement between the executable and your source code, when you use optimization.</source>
          <target state="translated">При использовании оптимизации следует ожидать некоторого расхождения между исполняемым файлом и вашим исходным кодом.</target>
        </trans-unit>
        <trans-unit id="c18143538d54c0195224945ef42bc5ea23853737" translate="yes" xml:space="preserve">
          <source>You may also specify whether a member function&amp;rsquo;s &lt;var&gt;this&lt;/var&gt; pointer is unaliased by using &lt;code&gt;__restrict__&lt;/code&gt; as a member function qualifier.</source>
          <target state="translated">Вы можете также указать , является ли функция - член в &lt;var&gt;this&lt;/var&gt; является unaliased с помощью указателя &lt;code&gt;__restrict__&lt;/code&gt; в качестве функции члена классификатором.</target>
        </trans-unit>
        <trans-unit id="3c9c1785a9b73c6c0c84000e89963aae3de9c571" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;__builtin_constant_p&lt;/code&gt; in initializers for static data. For instance, you can write</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;__builtin_constant_p&lt;/code&gt; в инициализаторах для статических данных. Например, вы можете написать</target>
        </trans-unit>
        <trans-unit id="77816405062bcfbd54b0c2d088c0cfe9f5a2c604" translate="yes" xml:space="preserve">
          <source>You may mark a method as having a visibility explicitly to negate the effect of the switch for that method. For example, if you do want to compare pointers to a particular inline method, you might mark it as having default visibility. Marking the enclosing class with explicit visibility has no effect.</source>
          <target state="translated">Вы можете пометить метод как метод,имеющий видимость явно для того,чтобы отрицать эффект коммутатора для этого метода.Например,если вы хотите сравнить указатели с определенным методом,вы можете пометить его как метод,имеющий видимость по умолчанию.Пометка класса-вкладыша с явной видимостью не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="e445da5feb655d87cca8dbc770cb3f7e24dc970f" translate="yes" xml:space="preserve">
          <source>You may need to experiment to determine the best settings for your application.</source>
          <target state="translated">Возможно,вам понадобится поэкспериментировать,чтобы определить наилучшие настройки для вашего приложения.</target>
        </trans-unit>
        <trans-unit id="bad95174418ab8218d171a6375d9166859a034cf" translate="yes" xml:space="preserve">
          <source>You may need to specify</source>
          <target state="translated">Возможно,вам понадобится указать</target>
        </trans-unit>
        <trans-unit id="48a08602699410d27da97f57d05daf9841a17a43" translate="yes" xml:space="preserve">
          <source>You may not use this mechanism to jump to code in a different function. If you do that, totally unpredictable things happen. The best way to avoid this is to store the label address only in automatic variables and never pass it as an argument.</source>
          <target state="translated">Этот механизм нельзя использовать для перехода к коду в другой функции.Если вы это сделаете,то произойдут совершенно непредсказуемые вещи.Лучший способ избежать этого-хранить адрес метки только в автоматических переменных и никогда не передавать его в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="bff5113fa76e9e5005f3a00a7843919b5149c765" translate="yes" xml:space="preserve">
          <source>You may only specify the &lt;code&gt;packed&lt;/code&gt; attribute on the definition of an &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;class&lt;/code&gt;, not on a &lt;code&gt;typedef&lt;/code&gt; that does not also define the enumerated type, structure, union, or class.</source>
          <target state="translated">Вы можете указать только &lt;code&gt;packed&lt;/code&gt; атрибут в определении &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;class&lt;/code&gt; , но не в &lt;code&gt;typedef&lt;/code&gt; , который также не определяет перечислимый тип, структуру, объединение или класс.</target>
        </trans-unit>
        <trans-unit id="54442d3018c5bf124a5cec286579f5b0f4a37809" translate="yes" xml:space="preserve">
          <source>You may only use the &lt;code&gt;shared&lt;/code&gt; attribute along with &lt;code&gt;section&lt;/code&gt; attribute with a fully-initialized global definition because of the way linkers work. See &lt;code&gt;section&lt;/code&gt; attribute for more information.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;shared&lt;/code&gt; атрибут только вместе с атрибутом &lt;code&gt;section&lt;/code&gt; с полностью инициализированным глобальным определением из-за того, как работают компоновщики. См. Дополнительную информацию в &lt;code&gt;section&lt;/code&gt; атрибут.</target>
        </trans-unit>
        <trans-unit id="9c7b80e390300159d4993b9cd813e610830fb794" translate="yes" xml:space="preserve">
          <source>You may optionally specify attribute names with &amp;lsquo;</source>
          <target state="translated">Вы можете дополнительно указать имена атрибутов с помощью '</target>
        </trans-unit>
        <trans-unit id="b744bc45d5f9c7b517250c91d7d9ce559fd58615" translate="yes" xml:space="preserve">
          <source>You may place multiple assembler instructions together in a single &lt;code&gt;asm&lt;/code&gt; string, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character (written as &amp;lsquo;</source>
          <target state="translated">Вы можете поместить несколько инструкций ассемблера вместе в одну строку &lt;code&gt;asm&lt;/code&gt; , разделенную символами, обычно используемыми в коде сборки для системы. Комбинация, которая работает в большинстве случаев, - это новая строка для разрыва строки плюс символ табуляции (записанный как '</target>
        </trans-unit>
        <trans-unit id="c17cdd78fed8e2f19f13ed7c6a72d4082d16e577" translate="yes" xml:space="preserve">
          <source>You may place multiple assembler instructions together in a single &lt;code&gt;asm&lt;/code&gt; string, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character to move to the instruction field (written as &amp;lsquo;</source>
          <target state="translated">Вы можете поместить несколько инструкций ассемблера вместе в одну строку &lt;code&gt;asm&lt;/code&gt; , разделенную символами, обычно используемыми в коде сборки для системы. Комбинация, которая работает в большинстве случаев, - это новая строка для разрыва строки плюс символ табуляции для перехода в поле инструкции (записанный как '</target>
        </trans-unit>
        <trans-unit id="f0570114f2ecbb2dbeed78e2cafecfaebd377566" translate="yes" xml:space="preserve">
          <source>You may specify type attributes in an enum, struct or union type declaration or definition by placing them immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword. You can also place them just past the closing curly brace of the definition, but this is less preferred because logically the type should be fully defined at the closing brace.</source>
          <target state="translated">Вы можете указать атрибуты типа в объявлении или определении типа перечисления, структуры или объединения, поместив их сразу после ключевого слова &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;enum&lt;/code&gt; . Вы также можете разместить их сразу за закрывающей фигурной скобкой определения, но это менее предпочтительно, потому что логически тип должен быть полностью определен в закрывающей фигурной скобке.</target>
        </trans-unit>
        <trans-unit id="1fcc73998e38d45743d93a8c5804d34b2fb5bae5" translate="yes" xml:space="preserve">
          <source>You may use &lt;code&gt;__builtin_expect&lt;/code&gt; to provide the compiler with branch prediction information. In general, you should prefer to use actual profile feedback for this (</source>
          <target state="translated">Вы можете использовать &lt;code&gt;__builtin_expect&lt;/code&gt; , чтобы предоставить компилятору информацию о предсказании ветвления. В общем, вы должны предпочесть использовать для этого фактические отзывы профиля (</target>
        </trans-unit>
        <trans-unit id="dd9213edd154d9e31cb91aff441ba460289ac018" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;section&lt;/code&gt; attribute with initialized or uninitialized global variables but the linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the &lt;code&gt;common&lt;/code&gt; (or &lt;code&gt;bss&lt;/code&gt;) section and can be multiply &amp;ldquo;defined&amp;rdquo;. Using the &lt;code&gt;section&lt;/code&gt; attribute changes what section the variable goes into and may cause the linker to issue an error if an uninitialized variable has multiple definitions. You can force a variable to be initialized with the</source>
          <target state="translated">Вы можете использовать атрибут &lt;code&gt;section&lt;/code&gt; с инициализированными или неинициализированными глобальными переменными, но компоновщик требует, чтобы каждый объект был определен один раз, за ​​исключением того, что неинициализированные переменные предварительно &lt;code&gt;bss&lt;/code&gt; в &lt;code&gt;common&lt;/code&gt; (или bss ) раздел и могут быть &amp;laquo;определены&amp;raquo; многократно. Использование атрибута &lt;code&gt;section&lt;/code&gt; изменяет раздел, в который входит переменная, и может привести к тому, что компоновщик выдаст ошибку, если неинициализированная переменная имеет несколько определений. Вы можете принудительно инициализировать переменную с помощью</target>
        </trans-unit>
        <trans-unit id="0897ffec25d2d3e9ff5e4c9a12cc715a05821b36" translate="yes" xml:space="preserve">
          <source>You may use this built-in function in either a macro or an inline function. However, if you use it in an inlined function and pass an argument of the function as the argument to the built-in, GCC never returns 1 when you call the inline function with a string constant or compound literal (see &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt;) and does not return 1 when you pass a constant numeric value to the inline function unless you specify the</source>
          <target state="translated">Вы можете использовать эту встроенную функцию как в макросе, так и во встроенной функции. Однако, если вы используете его во встроенной функции и передаете аргумент функции в качестве аргумента встроенной функции, GCC никогда не возвращает 1, когда вы вызываете встроенную функцию со строковой константой или составным литералом (см. &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Составные литералы&lt;/a&gt; ) и не возвращать 1, когда вы передаете постоянное числовое значение встроенной функции, если вы не укажете</target>
        </trans-unit>
        <trans-unit id="179c17b93d49191ff63b1b0b1b00b166383a79b3" translate="yes" xml:space="preserve">
          <source>You must move the data files to the expected directory tree in order to use them for profile directed optimizations (</source>
          <target state="translated">Вы должны переместить файлы данных в ожидаемое дерево каталогов,чтобы использовать их для профильно-направленных оптимизаций (</target>
        </trans-unit>
        <trans-unit id="65535d14a26d4547fe9b855313a51330599397c9" translate="yes" xml:space="preserve">
          <source>You must never create such structures that cause ambiguous field definitions. For example, in this structure:</source>
          <target state="translated">Вы никогда не должны создавать такие структуры,которые вызывают неоднозначные определения полей.Например,в этой структуре:</target>
        </trans-unit>
        <trans-unit id="364d53586a93cb7dd4166336e04c54defad73c15" translate="yes" xml:space="preserve">
          <source>You must specify</source>
          <target state="translated">Вы должны указать</target>
        </trans-unit>
        <trans-unit id="a0fd70e362d1f4b760a9cd038d96c07ea7f21b49" translate="yes" xml:space="preserve">
          <source>You must use GAS and GLD from GNU binutils version 2.7 or later for this attribute to work correctly.</source>
          <target state="translated">Для корректной работы этого атрибута необходимо использовать GAS и GLD из бинутилей GNU версии 2.7 или более поздней.</target>
        </trans-unit>
        <trans-unit id="6993ebfa9e3b6b6d6560ac8997eeb7ede6d0e9b1" translate="yes" xml:space="preserve">
          <source>You need this special case of the</source>
          <target state="translated">Вам нужен этот особый случай</target>
        </trans-unit>
        <trans-unit id="5a83a0c884ced5b1afbf8e0b73de9c85e4e8c7bb" translate="yes" xml:space="preserve">
          <source>You should be prepared for side effects when using</source>
          <target state="translated">Вы должны быть готовы к побочным эффектам при использовании</target>
        </trans-unit>
        <trans-unit id="fc2603d33fd81fe37c5c600db9786f0599bb7f89" translate="yes" xml:space="preserve">
          <source>You should compile your code without optimization if you plan to use &lt;code&gt;gcov&lt;/code&gt; because the optimization, by combining some lines of code into one function, may not give you as much information as you need to look for &amp;lsquo;hot spots&amp;rsquo; where the code is using a great deal of computer time. Likewise, because &lt;code&gt;gcov&lt;/code&gt; accumulates statistics by line (at the lowest resolution), it works best with a programming style that places only one statement on each line. If you use complicated macros that expand to loops or to other control structures, the statistics are less helpful&amp;mdash;they only report on the line where the macro call appears. If your complex macros behave like functions, you can replace them with inline functions to solve this problem.</source>
          <target state="translated">Если вы планируете использовать &lt;code&gt;gcov&lt;/code&gt; , вам следует скомпилировать свой код без оптимизации, потому что оптимизация путем объединения нескольких строк кода в одну функцию может не дать вам столько информации, сколько вам нужно для поиска &amp;laquo;горячих точек&amp;raquo;, где код использует много компьютерного времени. Точно так же, поскольку &lt;code&gt;gcov&lt;/code&gt; накапливает статистику по строкам (с самым низким разрешением), он лучше всего работает со стилем программирования, который помещает только один оператор в каждую строку. Если вы используете сложные макросы, которые расширяются до циклов или других управляющих структур, статистика будет менее полезной - они сообщают только о строке, где появляется вызов макроса. Если ваши сложные макросы ведут себя как функции, вы можете заменить их встроенными функциями, чтобы решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="fe80fe3d98f647e191798f4bf1cd85c0708a7905" translate="yes" xml:space="preserve">
          <source>You should declare the jump buffer argument &lt;var&gt;buf&lt;/var&gt; to the built-in functions as:</source>
          <target state="translated">Вы должны объявить аргумент буфера перехода &lt;var&gt;buf&lt;/var&gt; для встроенных функций как:</target>
        </trans-unit>
        <trans-unit id="7d1fbba229a2654e9c51633205d301f0603b772d" translate="yes" xml:space="preserve">
          <source>You should make no assumptions about receiving &lt;code&gt;+load&lt;/code&gt; in sibling classes when you write &lt;code&gt;+load&lt;/code&gt; of a class. The order in which sibling classes receive &lt;code&gt;+load&lt;/code&gt; is not guaranteed.</source>
          <target state="translated">Вы не должны делать никаких предположений о получении &lt;code&gt;+load&lt;/code&gt; в родственных классах, когда вы пишете &lt;code&gt;+load&lt;/code&gt; для класса. Порядок, в котором родственные классы получают &lt;code&gt;+load&lt;/code&gt; , не гарантируется.</target>
        </trans-unit>
        <trans-unit id="3a466242a3e9760eaada5a308649a4f792fde67b" translate="yes" xml:space="preserve">
          <source>You should not write this &lt;code&gt;#pragma&lt;/code&gt; in your own code, but it is safe to edit the filename if the PCH file is available in a different location. The filename may be absolute or it may be relative to GCC&amp;rsquo;s current directory.</source>
          <target state="translated">Вы не должны писать эту &lt;code&gt;#pragma&lt;/code&gt; в своем собственном коде, но можно безопасно редактировать имя файла, если файл PCH доступен в другом месте. Имя файла может быть абсолютным или относительным относительно текущего каталога GCC.</target>
        </trans-unit>
        <trans-unit id="b5b58bacb34de248a5caa9e1d70684a5e3e9e81a" translate="yes" xml:space="preserve">
          <source>You should rewrite your code to avoid these warnings if you are concerned about the fact that code generated by G++ may not be binary compatible with code generated by other compilers.</source>
          <target state="translated">Следует переписать код,чтобы избежать этих предупреждений,если вас беспокоит тот факт,что код,генерируемый G++,может быть не бинарно совместим с кодом,генерируемым другими компиляторами.</target>
        </trans-unit>
        <trans-unit id="3200321f5c777dbbacc4f9ef21ac598c37fa6c47" translate="yes" xml:space="preserve">
          <source>You typically use this function in an embedded application where memory is a critical resource. If you have some complex calculation, you may want it to be folded if it involves constants, but need to call a function if it does not. For example:</source>
          <target state="translated">Обычно эту функцию используют во встроенных приложениях,где память является критическим ресурсом.Если у вас есть какое-то сложное вычисление,вы можете захотеть,чтобы оно было сложено,если оно включает в себя константы,но нужно вызвать функцию,если этого не происходит.Например:</target>
        </trans-unit>
        <trans-unit id="b1963db30d39d58a295ec397d230925d0854ee73" translate="yes" xml:space="preserve">
          <source>You typically use this function in code whose execution varies depending on the arguments&amp;rsquo; types. For example:</source>
          <target state="translated">Обычно вы используете эту функцию в коде, выполнение которого зависит от типов аргументов. Например:</target>
        </trans-unit>
        <trans-unit id="a382ebf878d522cc46ae079d7811d40f2d546d5e" translate="yes" xml:space="preserve">
          <source>You typically use this option to build a shared library dynamic loader. Itself a shared library, it must relocate itself in memory before it can find the variables and constants in its own data segment.</source>
          <target state="translated">Обычно вы используете эту опцию для построения динамического загрузчика общей библиотеки.Сама по себе разделяемая библиотека,она должна переместиться в память до того,как сможет найти переменные и константы в своем сегменте данных.</target>
        </trans-unit>
        <trans-unit id="ff2858040c7368b4f7687d2e4605dbe04fb48ce1" translate="yes" xml:space="preserve">
          <source>You use these options to specify which instructions are available on the processor you are using. The default value of these options is determined when configuring GCC. Specifying the</source>
          <target state="translated">Вы используете эти опции,чтобы указать,какие инструкции доступны на используемом вами процессоре.Значение по умолчанию этих опций определяется при настройке GCC.Указание</target>
        </trans-unit>
        <trans-unit id="afc6c45769ec18ef9f8f79510ff88d4f56540059" translate="yes" xml:space="preserve">
          <source>Zero</source>
          <target state="translated">Zero</target>
        </trans-unit>
        <trans-unit id="553f12b0c01c796a9c01fbfbed6d38920ed5b259" translate="yes" xml:space="preserve">
          <source>Zero-length arrays.</source>
          <target state="translated">Массивы нулевой длины.</target>
        </trans-unit>
        <trans-unit id="258478ec83495aa79136f18ffc9233ee1f0db5ed" translate="yes" xml:space="preserve">
          <source>Zero-length bit-fields following non-bit-field members are ignored:</source>
          <target state="translated">Нулевые битовые поля,следующие за небитными членами поля,игнорируются:</target>
        </trans-unit>
        <trans-unit id="0c2ceddaf3c2e5b315ce6df93a6d703e090097e2" translate="yes" xml:space="preserve">
          <source>[.A-Za-z]*</source>
          <target state="translated">[.A-Za-z]*</target>
        </trans-unit>
        <trans-unit id="abf3f56fd4893df51cec0f301e1d141ec4cf5a54" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;first&lt;/var&gt; ... &lt;var&gt;last&lt;/var&gt;] = &lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">[ &lt;var&gt;first&lt;/var&gt; ... &lt;var&gt;last&lt;/var&gt; ] = &lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="893b2523426b47e65f5145303772e8166d192d46" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;index&lt;/var&gt;]</source>
          <target state="translated">[&lt;var&gt;index&lt;/var&gt;]</target>
        </trans-unit>
        <trans-unit id="96a90e0b102b000a44c98efbcdab9b6dee99bbd8" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;index&lt;/var&gt;] =</source>
          <target state="translated">[ &lt;var&gt;index&lt;/var&gt; ] =</target>
        </trans-unit>
        <trans-unit id="aaf8c573d70607ca295cc0cde78f8a6154aa6363" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;suffix&lt;/var&gt;] spec</source>
          <target state="translated">[ &lt;var&gt;suffix&lt;/var&gt; ] спецификация</target>
        </trans-unit>
        <trans-unit id="323d9668ca564c93e740198e5fd45fcacecbe669" translate="yes" xml:space="preserve">
          <source>[dir/]include</source>
          <target state="translated">[dir/]include</target>
        </trans-unit>
        <trans-unit id="14aee59b80f3ae18852c214fd35ef6a55a3b42a6" translate="yes" xml:space="preserve">
          <source>[dir/]stage&lt;var&gt;N&lt;/var&gt;/</source>
          <target state="translated">[dir/]stage&lt;var&gt;N&lt;/var&gt;/</target>
        </trans-unit>
        <trans-unit id="08534f33c201a45017b502e90a800f1b708ebcb3" translate="yes" xml:space="preserve">
          <source>\</source>
          <target state="translated">\</target>
        </trans-unit>
        <trans-unit id="ec24514fcd2c759e6e733c1219e798f6a27080dd" translate="yes" xml:space="preserve">
          <source>\,</source>
          <target state="translated">\,</target>
        </trans-unit>
        <trans-unit id="80bcc8b02cd875c9c7b9dc9e6159a6cd886a4b36" translate="yes" xml:space="preserve">
          <source>\e</source>
          <target state="translated">\e</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="5260fdfe19fbab22b26fb10a5b1cdaa4e4d5fa1f" translate="yes" xml:space="preserve">
          <source>\n\t</source>
          <target state="translated">\n\t</target>
        </trans-unit>
        <trans-unit id="dd56ac3bfe32e89d0b9eada9071564fe17a96c3a" translate="yes" xml:space="preserve">
          <source>_&lt;var&gt;L&lt;/var&gt;</source>
          <target state="translated">_&lt;var&gt;L&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="f2b8017c21a3fa06728ebdd896c9f0840460e437" translate="yes" xml:space="preserve">
          <source>_&lt;var&gt;n&lt;/var&gt;</source>
          <target state="translated">_&lt;var&gt;n&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="bef0f1b1eda1a69cc6d7593689c6ad7764f8486b" translate="yes" xml:space="preserve">
          <source>_Complex double x;</source>
          <target state="translated">_Сложный двойной x;</target>
        </trans-unit>
        <trans-unit id="be1a596019bc728455ca6e661ae186a03fbaf2a6" translate="yes" xml:space="preserve">
          <source>_Complex short int y;</source>
          <target state="translated">_Complex short int y;</target>
        </trans-unit>
        <trans-unit id="4efeab93d874226b7c2975a5130348c4a300a2cf" translate="yes" xml:space="preserve">
          <source>_MAX</source>
          <target state="translated">_MAX</target>
        </trans-unit>
        <trans-unit id="dde95929ec72357d1a78e9ef9086ad031a0699b2" translate="yes" xml:space="preserve">
          <source>_MIN</source>
          <target state="translated">_MIN</target>
        </trans-unit>
        <trans-unit id="9624af4051d439e5359b9152ec698ceaa0261659" translate="yes" xml:space="preserve">
          <source>__atomic</source>
          <target state="translated">__atomic</target>
        </trans-unit>
        <trans-unit id="011657d58155e0e3541069c651cbe40aace6f116" translate="yes" xml:space="preserve">
          <source>__atomic_thread_fence</source>
          <target state="translated">__atomic_thread_fence</target>
        </trans-unit>
        <trans-unit id="b5190ca2a20962ff5fe42fd3d915ec20ed74f142" translate="yes" xml:space="preserve">
          <source>__attribute__ ((aligned (16), packed))</source>
          <target state="translated">__attribute__ ((выровнено (16), упаковано))</target>
        </trans-unit>
        <trans-unit id="9763de6eac5cd7741fca26ac575ae576079de73c" translate="yes" xml:space="preserve">
          <source>__builtin_</source>
          <target state="translated">__builtin_</target>
        </trans-unit>
        <trans-unit id="9ffdd3b639dbcc260c36604d951401b356ebdfa9" translate="yes" xml:space="preserve">
          <source>__builtin_frame_address</source>
          <target state="translated">__builtin_frame_address</target>
        </trans-unit>
        <trans-unit id="77d71c429ddc63ee19bd5fc63e5f0770c3745449" translate="yes" xml:space="preserve">
          <source>__builtin_return_address</source>
          <target state="translated">__builtin_return_address</target>
        </trans-unit>
        <trans-unit id="090f89da9d6d5b98fdd005c2ae6006ce69c1facf" translate="yes" xml:space="preserve">
          <source>__f</source>
          <target state="translated">__f</target>
        </trans-unit>
        <trans-unit id="3535355516b8a7449fdf619b53778778636b0eea" translate="yes" xml:space="preserve">
          <source>__int128</source>
          <target state="translated">__int128</target>
        </trans-unit>
        <trans-unit id="39a41d9f01352f9be126d019a0f55223b6f117ec" translate="yes" xml:space="preserve">
          <source>__sync</source>
          <target state="translated">__sync</target>
        </trans-unit>
        <trans-unit id="36fb58f934823421b6f9498810790aeee97de129" translate="yes" xml:space="preserve">
          <source>__v850*__</source>
          <target state="translated">__v850*__</target>
        </trans-unit>
        <trans-unit id="e748065bbc4c0e6c0efc4285894458b89aaf5dff" translate="yes" xml:space="preserve">
          <source>_flush_cache</source>
          <target state="translated">_flush_cache</target>
        </trans-unit>
        <trans-unit id="43bf149a9ed61bc94557723db25e4af7f39d8d75" translate="yes" xml:space="preserve">
          <source>_foo</source>
          <target state="translated">_foo</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="20276f54b2fb0d6340042fdc1e284afc48a41106" translate="yes" xml:space="preserve">
          <source>a hard limit, disallowing more than that number in an instruction group. Otherwise, the limit is &amp;ldquo;soft&amp;rdquo;, meaning that non-memory operations are preferred when the limit is reached, but memory operations may still be scheduled.</source>
          <target state="translated">жесткий предел, запрещающий больше, чем это число в группе инструкций. В противном случае ограничение будет &amp;laquo;мягким&amp;raquo;, что означает, что операции, не связанные с памятью, предпочтительнее, когда предел достигнут, но операции с памятью все еще могут быть запланированы.</target>
        </trans-unit>
        <trans-unit id="4d45fbf9e18e03187144f653f6c867ab6a4cb2ce" translate="yes" xml:space="preserve">
          <source>a signed doubleword</source>
          <target state="translated">подписанное двойное слово</target>
        </trans-unit>
        <trans-unit id="9efaa9ee2486d205847ff7f6eb2734e13064b3d6" translate="yes" xml:space="preserve">
          <source>a signed word</source>
          <target state="translated">подписанное слово</target>
        </trans-unit>
        <trans-unit id="2e5e828ebf29441ab1d17abe9b59440764703bd5" translate="yes" xml:space="preserve">
          <source>a.c</source>
          <target state="translated">a.c</target>
        </trans-unit>
        <trans-unit id="2ef04052181a3bcb9eb40398327d275b7122b76b" translate="yes" xml:space="preserve">
          <source>a.c##x.h.gcov</source>
          <target state="translated">a.c##x.h.gcov</target>
        </trans-unit>
        <trans-unit id="937373b898e354572539c11778b8369b6021d02b" translate="yes" xml:space="preserve">
          <source>a.out</source>
          <target state="translated">a.out</target>
        </trans-unit>
        <trans-unit id="b9f85daa6f83cf02ce5c31913d1f64d3f5c8fade" translate="yes" xml:space="preserve">
          <source>a2</source>
          <target state="translated">a2</target>
        </trans-unit>
        <trans-unit id="62352d3d034a492b743d85067daad3ede5b2104b" translate="yes" xml:space="preserve">
          <source>aapcs</source>
          <target state="translated">aapcs</target>
        </trans-unit>
        <trans-unit id="cb76f70bd27803c92785136c45fbc376f9dd2652" translate="yes" xml:space="preserve">
          <source>aapcs-linux</source>
          <target state="translated">aapcs-linux</target>
        </trans-unit>
        <trans-unit id="973eb567623a16af6cc4b072efcf2388a12b9404" translate="yes" xml:space="preserve">
          <source>aarch64-*-*</source>
          <target state="translated">aarch64-*-*</target>
        </trans-unit>
        <trans-unit id="c10ebf10559ad9cfd389b344d22aa0551d5fd166" translate="yes" xml:space="preserve">
          <source>aarch64_be-*-*</source>
          <target state="translated">aarch64_be-*-*</target>
        </trans-unit>
        <trans-unit id="715a5d4d840064196cfa2f6763ef29067adb4d87" translate="yes" xml:space="preserve">
          <source>abi</source>
          <target state="translated">abi</target>
        </trans-unit>
        <trans-unit id="dcd67d1087e07b87a59bb90a9324a369479ccb75" translate="yes" xml:space="preserve">
          <source>abm</source>
          <target state="translated">abm</target>
        </trans-unit>
        <trans-unit id="f3bf4a18bc12d3fd665f34273aa77398ca033388" translate="yes" xml:space="preserve">
          <source>about invoking</source>
          <target state="translated">насчёт вызова</target>
        </trans-unit>
        <trans-unit id="de671ae4cf4c6f58efe6bf4db141ff43ea23375f" translate="yes" xml:space="preserve">
          <source>above). Currently, the following sets are defined:</source>
          <target state="translated">выше).В настоящее время определены следующие наборы:</target>
        </trans-unit>
        <trans-unit id="614cd09c5357289d30936d7b18d4378a9149026f" translate="yes" xml:space="preserve">
          <source>above, generate Ada specs as child units of parent &lt;var&gt;unit&lt;/var&gt;.</source>
          <target state="translated">выше, сгенерируйте спецификации Ada как дочерние блоки родительского &lt;var&gt;unit&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="76726f07acaef7a675fe282314fc6d7f44669323" translate="yes" xml:space="preserve">
          <source>accidentally contains floating-point operations, it is likely to suffer a link-time or run-time failure.</source>
          <target state="translated">случайно содержит операции с плавающей точкой,вероятно,пострадает во время соединения или сбоя во время выполнения.</target>
        </trans-unit>
        <trans-unit id="466afffe5fc6585663064937defed67d00d3e3b4" translate="yes" xml:space="preserve">
          <source>acml</source>
          <target state="translated">acml</target>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="translated">address</target>
        </trans-unit>
        <trans-unit id="798db27fb8836547e7eae5cbf51a015317e5a479" translate="yes" xml:space="preserve">
          <source>adds keywords &lt;code&gt;__vector&lt;/code&gt;, &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;__pixel&lt;/code&gt;, &lt;code&gt;pixel&lt;/code&gt;, &lt;code&gt;__bool&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;. When compiling ISO C, the context-sensitive substitution of the keywords &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;pixel&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; is disabled. To use them, you must include &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">добавляет ключевые слова &lt;code&gt;__vector&lt;/code&gt; , &lt;code&gt;vector&lt;/code&gt; , &lt;code&gt;__pixel&lt;/code&gt; , &lt;code&gt;pixel&lt;/code&gt; , &lt;code&gt;__bool&lt;/code&gt; и &lt;code&gt;bool&lt;/code&gt; . При компиляции ISO C контекстно-зависимая подстановка ключевых слов &lt;code&gt;vector&lt;/code&gt; , &lt;code&gt;pixel&lt;/code&gt; и &lt;code&gt;bool&lt;/code&gt; отключена. Чтобы использовать их, вы должны вместо этого включить &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a4611cf85989cfb032315de1816f14ac9f3517b" translate="yes" xml:space="preserve">
          <source>adiw</source>
          <target state="translated">adiw</target>
        </trans-unit>
        <trans-unit id="70115ea66975f8392735da74af10a532c95caaf7" translate="yes" xml:space="preserve">
          <source>adx</source>
          <target state="translated">adx</target>
        </trans-unit>
        <trans-unit id="9b214a0fbc91794f9b2f7c03b2ffdadc705bb106" translate="yes" xml:space="preserve">
          <source>aes</source>
          <target state="translated">aes</target>
        </trans-unit>
        <trans-unit id="1ba7d6d2d5d6b99ecac4784439f26289cba856d4" translate="yes" xml:space="preserve">
          <source>align-stringops</source>
          <target state="translated">align-stringops</target>
        </trans-unit>
        <trans-unit id="3bea4606b8381d936b8f862d721bc4422652b565" translate="yes" xml:space="preserve">
          <source>aligned</source>
          <target state="translated">aligned</target>
        </trans-unit>
        <trans-unit id="a8d2e4967b2627fcbbcd7bab5490853d70874e12" translate="yes" xml:space="preserve">
          <source>aligns &lt;code&gt;long double&lt;/code&gt; to a 16-byte boundary by padding the &lt;code&gt;long double&lt;/code&gt; with an additional 32-bit zero.</source>
          <target state="translated">выравнивает &lt;code&gt;long double&lt;/code&gt; по 16-байтовой границе, дополняя &lt;code&gt;long double&lt;/code&gt; дополнительным 32-битным нулем.</target>
        </trans-unit>
        <trans-unit id="3efdc33c698275c6bba0bfe0a5cc4bb1ae2af995" translate="yes" xml:space="preserve">
          <source>aligns functions to the next 32-byte boundary,</source>
          <target state="translated">выравнивает функции к следующей 32-байтовой границе,</target>
        </trans-unit>
        <trans-unit id="244280ce7bd1f8e5d39e22b8ef0ce1ca3d784e6f" translate="yes" xml:space="preserve">
          <source>aligns to the next 32-byte boundary only if this can be done by skipping 23 bytes or less,</source>
          <target state="translated">выравнивается до следующей 32-байтовой границы только в том случае,если это можно сделать,пропустив 23 байта или меньше,</target>
        </trans-unit>
        <trans-unit id="cfa7e3dfee8e7262fa433d58f986a5d3347143cb" translate="yes" xml:space="preserve">
          <source>aligns to the next 32-byte boundary only if this can be done by skipping 6 bytes or less.</source>
          <target state="translated">выравнивается до следующей 32-байтовой границы только в том случае,если это можно сделать,пропустив 6 байт или меньше.</target>
        </trans-unit>
        <trans-unit id="79635748432e8322454f167c344ee1a5dee023d5" translate="yes" xml:space="preserve">
          <source>aligns to the next 64-byte boundary if this can be done by skipping 6 bytes or less, otherwise aligns to the next 32-byte boundary if this can be done by skipping 2 bytes or less. If &lt;var&gt;m2&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n2&lt;/var&gt;.</source>
          <target state="translated">выравнивается по следующей 64-байтовой границе, если это можно сделать, пропустив 6 байтов или меньше, в противном случае выравнивается по следующей 32-байтовой границе, если это можно сделать, пропустив 2 байта или меньше. Если &lt;var&gt;m2&lt;/var&gt; не указан, по умолчанию используется &lt;var&gt;n2&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="a8901683ad5f4f61f902c68d29d69c8b1ad5d90d" translate="yes" xml:space="preserve">
          <source>all external symbols are resolved at load time.</source>
          <target state="translated">все внешние символы разрешаются во время загрузки.</target>
        </trans-unit>
        <trans-unit id="bbe28b8276e31a373247e1c8a94a3beb37c5b6fa" translate="yes" xml:space="preserve">
          <source>all.h</source>
          <target state="translated">all.h</target>
        </trans-unit>
        <trans-unit id="3b0a792c2b1703577a069f12d469a0473536a471" translate="yes" xml:space="preserve">
          <source>all.h.gch</source>
          <target state="translated">all.h.gch</target>
        </trans-unit>
        <trans-unit id="b9bf38b9b4d225abc840bc0ee7480fcc2434e2b3" translate="yes" xml:space="preserve">
          <source>allclass.cc</source>
          <target state="translated">allclass.cc</target>
        </trans-unit>
        <trans-unit id="ca4599448f2501f9fa384de7b7038a3e242e0dfb" translate="yes" xml:space="preserve">
          <source>allocation of or sending messages to arbitrary objects;</source>
          <target state="translated">распределение или отправка сообщений произвольным объектам;</target>
        </trans-unit>
        <trans-unit id="32b74672543fdbbdcfc868ba07acb1ff2110d200" translate="yes" xml:space="preserve">
          <source>allocation of or sending messages to objects whose classes have a category implemented in the same file;</source>
          <target state="translated">выделение или отправка сообщений объектам,классы которых имеют категорию,реализованную в том же файле;</target>
        </trans-unit>
        <trans-unit id="453b7342a6d3f523c8d652e090720e4f47db0bd8" translate="yes" xml:space="preserve">
          <source>allow you to switch between producing output that works with the GNU Objective-C runtime library and output that works with the Apple/NeXT Objective-C runtime library.</source>
          <target state="translated">позволяют вам переключаться между производством вывода,который работает с библиотекой времени исполнения GNU Objective-C,и выводом,который работает с библиотекой времени исполнения Apple/NeXT Objective-C.</target>
        </trans-unit>
        <trans-unit id="dd4aebec0f6653650ee91987b02de80dc8963201" translate="yes" xml:space="preserve">
          <source>allowing the user to call &lt;code&gt;memcpy&lt;/code&gt; as a regular function, unaware of the actual implementation. Finally, the indirect function needs to be defined in the same translation unit as the resolver function:</source>
          <target state="translated">позволяя пользователю вызывать &lt;code&gt;memcpy&lt;/code&gt; как обычную функцию, не зная о фактической реализации. Наконец, косвенная функция должна быть определена в той же единице перевода, что и функция преобразователя:</target>
        </trans-unit>
        <trans-unit id="66438aaa4bea9ecc573f56890befc19245624f30" translate="yes" xml:space="preserve">
          <source>allows GCC to generate code that may not run at all on processors other than the one indicated. Specifying</source>
          <target state="translated">позволяет GCC генерировать код,который может вообще не выполняться на процессорах,отличных от указанных.Указание</target>
        </trans-unit>
        <trans-unit id="cf49e111caf7da05b98404623112872b82a367f9" translate="yes" xml:space="preserve">
          <source>allows GCC to use the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root. Specifying</source>
          <target state="translated">позволяет GCC использовать дополнительные инструкции по архитектуре PowerPC в группе общего назначения,включая квадратный корень с плавающей точкой.Указание .</target>
        </trans-unit>
        <trans-unit id="f5666aaba4ff4d9843997efb2fce32365976d352" translate="yes" xml:space="preserve">
          <source>allows GCC to use the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">позволяет GCC использовать дополнительные инструкции по архитектуре PowerPC в группе Графики,включая выбор с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="2abc9f7d66d3a1198b14bbaa01458338cdf813bd" translate="yes" xml:space="preserve">
          <source>allows some nonconforming code to compile.</source>
          <target state="translated">позволяет скомпилировать некоторую часть несоответствующего кода.</target>
        </trans-unit>
        <trans-unit id="bedf43ad0a95e8d3ef4a98d57277220a9905abdc" translate="yes" xml:space="preserve">
          <source>along with</source>
          <target state="translated">наравне с</target>
        </trans-unit>
        <trans-unit id="eec221c0b71d49bdac9cb852917ed960c85ad0a8" translate="yes" xml:space="preserve">
          <source>also being enabled.</source>
          <target state="translated">также включается.</target>
        </trans-unit>
        <trans-unit id="5fad31864ed398f45dae03d45460e898d7d29f7e" translate="yes" xml:space="preserve">
          <source>also being specified, the code is tuned to perform well across a range of target processors implementing the target architecture.</source>
          <target state="translated">Кроме того,при указании,код настраивается так,чтобы он хорошо работал на ряде целевых процессоров,реализующих целевую архитектуру.</target>
        </trans-unit>
        <trans-unit id="8d6a07b9735308ca8e95431227809c536d7831ad" translate="yes" xml:space="preserve">
          <source>also by</source>
          <target state="translated">также за</target>
        </trans-unit>
        <trans-unit id="187a158ae4568f3cc3e2b692351e6276268ce95b" translate="yes" xml:space="preserve">
          <source>also checks for null format arguments for several functions,</source>
          <target state="translated">также проверяет нулевой формат аргументов для нескольких функций,</target>
        </trans-unit>
        <trans-unit id="f587f4ff38f8c2cccf85ae4104732656fd8bb96d" translate="yes" xml:space="preserve">
          <source>also diagnoses cases where the attributes of the alias declaration are more restrictive than the attributes applied to its target. These mismatches can potentially result in incorrect code generation. In other cases they may be benign and could be resolved simply by adding the missing attribute to the target. For comparison, see the</source>
          <target state="translated">также диагностирует случаи,когда атрибуты объявления псевдонима являются более ограничительными,чем атрибуты,применяемые к его цели.Такое несоответствие потенциально может привести к некорректной генерации кода.В других случаях они могут быть доброкачественными и могут быть устранены простым добавлением недостающего атрибута в цель.Для сравнения см.</target>
        </trans-unit>
        <trans-unit id="cb860f8821c8635791611ff058e7157ab855da31" translate="yes" xml:space="preserve">
          <source>also implies</source>
          <target state="translated">также подразумевает</target>
        </trans-unit>
        <trans-unit id="6f42e4ce494f5b76f2544a0f03b983119cfbce78" translate="yes" xml:space="preserve">
          <source>also includes dependence info.</source>
          <target state="translated">также включает в себя информацию о зависимости.</target>
        </trans-unit>
        <trans-unit id="be3f59c6748c3a9b4a7ae21f5715d657a72eeb15" translate="yes" xml:space="preserve">
          <source>also prints warning messages for the following cases:</source>
          <target state="translated">также печатает предупреждающие сообщения для следующих случаев:</target>
        </trans-unit>
        <trans-unit id="2e5682119037273f933c083ad00d7701aba2cf5c" translate="yes" xml:space="preserve">
          <source>also provides equivalent macros called &lt;code&gt;_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; that can be used for programming ease and improved readability. The following macros for DMA control are also provided:</source>
          <target state="translated">также предоставляет эквивалентные макросы, называемые &lt;code&gt;_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; , которые можно использовать для упрощения программирования и улучшения читаемости. Также предусмотрены следующие макросы для управления DMA:</target>
        </trans-unit>
        <trans-unit id="f34eaf4f6ae89eb9588e134559245afad4e138e4" translate="yes" xml:space="preserve">
          <source>also sets</source>
          <target state="translated">также комплекты</target>
        </trans-unit>
        <trans-unit id="e117a2e5dfc7efe817347989346d6cd665ab904c" translate="yes" xml:space="preserve">
          <source>also suppresses preprocessed output, as a missing header file renders this useless.</source>
          <target state="translated">также подавляет препроцессированный вывод,так как отсутствующий заголовочный файл делает это бесполезным.</target>
        </trans-unit>
        <trans-unit id="63a0640542d5918d3932396f482586803338d771" translate="yes" xml:space="preserve">
          <source>also takes into account control flow statements, such as ifs, and only warns when appropriate. E.g.</source>
          <target state="translated">также принимает во внимание отчёты о контрольном потоке,например,ifs,и предупреждает только в случае необходимости.Например</target>
        </trans-unit>
        <trans-unit id="30f35ed6e318ea969ed59edf47b9b26381d2be26" translate="yes" xml:space="preserve">
          <source>also warns about calls to bounded string copy functions like &lt;code&gt;strncat&lt;/code&gt; or &lt;code&gt;strncpy&lt;/code&gt; that specify as the bound a &lt;code&gt;sizeof&lt;/code&gt; expression of the source array. For example, in the following function the call to &lt;code&gt;strncat&lt;/code&gt; specifies the size of the source string as the bound. That is almost certainly a mistake and so the call is diagnosed.</source>
          <target state="translated">также предупреждает о вызовах функций копирования ограниченной строки, таких как &lt;code&gt;strncat&lt;/code&gt; или &lt;code&gt;strncpy&lt;/code&gt; , которые указывают в качестве привязки выражение &lt;code&gt;sizeof&lt;/code&gt; исходного массива. Например, в следующей функции вызов &lt;code&gt;strncat&lt;/code&gt; указывает размер исходной строки в качестве границы. Это почти наверняка ошибка, поэтому звонок диагностируется.</target>
        </trans-unit>
        <trans-unit id="4f244ab7b0dd86244a85d676a4e7e6a378a2f85e" translate="yes" xml:space="preserve">
          <source>also warns about class member allocation functions.</source>
          <target state="translated">также предупреждает о функциях распределения членов класса.</target>
        </trans-unit>
        <trans-unit id="b62db011fc5c4e0ddffda8c03fb7a1020abe09e6" translate="yes" xml:space="preserve">
          <source>also warns about this situation; this warning can be avoided by explicitly tagging the variable or function or moving it into a tagged inline namespace.</source>
          <target state="translated">также предупреждает об этой ситуации;этого предупреждения можно избежать,явно помечая переменную или функцию или перемещая ее в помеченное в строке пространство имён.</target>
        </trans-unit>
        <trans-unit id="816d63e63c53fbbcdc73b605731fb850111597ab" translate="yes" xml:space="preserve">
          <source>alternative</source>
          <target state="translated">alternative</target>
        </trans-unit>
        <trans-unit id="cbcd5fa05a97da31161499a40e885c28da334f58" translate="yes" xml:space="preserve">
          <source>altivec</source>
          <target state="translated">altivec</target>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="a17ce9b6918e1f1ff5f858aa6106831fa7297c8c" translate="yes" xml:space="preserve">
          <source>always has a large stack. Support for this is implemented in the gold linker in GNU binutils release 2.21 and later.</source>
          <target state="translated">всегда имеет большую стопку.Поддержка этого реализована в золотом компоновщике в бинутилях GNU версии 2.21 и более поздней.</target>
        </trans-unit>
        <trans-unit id="80e7ce3e370a6dda4a9fb0810b8685ac34fc5708" translate="yes" xml:space="preserve">
          <source>always_inline</source>
          <target state="translated">always_inline</target>
        </trans-unit>
        <trans-unit id="8dbe12ece6858c4818dac43b3d526c9a1f59fee3" translate="yes" xml:space="preserve">
          <source>am33</source>
          <target state="translated">am33</target>
        </trans-unit>
        <trans-unit id="11b883c428dac39d27e1d63b6df041f0638d659b" translate="yes" xml:space="preserve">
          <source>am33-2</source>
          <target state="translated">am33-2</target>
        </trans-unit>
        <trans-unit id="534aa547f58efe57e7088bffcb38a66eaac8a75f" translate="yes" xml:space="preserve">
          <source>am34</source>
          <target state="translated">am34</target>
        </trans-unit>
        <trans-unit id="1ea0b794e1acd33fc0e733b79c72bf9252569c11" translate="yes" xml:space="preserve">
          <source>amd</source>
          <target state="translated">amd</target>
        </trans-unit>
        <trans-unit id="2395059e740ec74ddaadf44ba1fd6be5abeb4f3f" translate="yes" xml:space="preserve">
          <source>amd64</source>
          <target state="translated">amd64</target>
        </trans-unit>
        <trans-unit id="b35a515e5c6e1bbc58411f2be892a9ab16847ea8" translate="yes" xml:space="preserve">
          <source>amdfam10</source>
          <target state="translated">amdfam10</target>
        </trans-unit>
        <trans-unit id="3a6d03b94ef74592e176a5d5190e78a646119762" translate="yes" xml:space="preserve">
          <source>amdfam10h</source>
          <target state="translated">amdfam10h</target>
        </trans-unit>
        <trans-unit id="261cb5d6b8474d348d7cc4b9daa4299477e3581e" translate="yes" xml:space="preserve">
          <source>amdfam15h</source>
          <target state="translated">amdfam15h</target>
        </trans-unit>
        <trans-unit id="77c479bd3bd5a6e9817c756457f45b3383bfda8b" translate="yes" xml:space="preserve">
          <source>amdfam17h</source>
          <target state="translated">amdfam17h</target>
        </trans-unit>
        <trans-unit id="fd4a625a31a18d16fe04662ffe5a54c9d06947f3" translate="yes" xml:space="preserve">
          <source>an &lt;code&gt;enum&lt;/code&gt; is encoded exactly as the integer type that the compiler uses for it, which depends on the enumeration values. Often the compiler users &lt;code&gt;unsigned int&lt;/code&gt;, which is then encoded as &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; кодируются точно так , как целый тип , что компилятор использует для него, который зависит от значений перечисления. Часто пользователи компилятора &lt;code&gt;unsigned int&lt;/code&gt; , который затем кодируется как &lt;code&gt;I&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a2ad1f0fd30a224aa1740e4739fe7eb9ee94f86" translate="yes" xml:space="preserve">
          <source>an ACC register number</source>
          <target state="translated">регистрационный номер ACC</target>
        </trans-unit>
        <trans-unit id="45bc278ac53a1060e69cab091ecac756552d2721" translate="yes" xml:space="preserve">
          <source>an IACC register number</source>
          <target state="translated">регистрационный номер IACC</target>
        </trans-unit>
        <trans-unit id="0666bd4cf85f6a8a3d638122033f89aff472392a" translate="yes" xml:space="preserve">
          <source>an integer constant</source>
          <target state="translated">целочисленная константа</target>
        </trans-unit>
        <trans-unit id="6d3c084323cc6197a38855b1039213d1fa5e3a22" translate="yes" xml:space="preserve">
          <source>an unsigned doubleword</source>
          <target state="translated">неподписанное двойное слово</target>
        </trans-unit>
        <trans-unit id="3657f24217b612273b00133ebb412d287de01a77" translate="yes" xml:space="preserve">
          <source>an unsigned halfword</source>
          <target state="translated">неподписанное полусловие</target>
        </trans-unit>
        <trans-unit id="1773204396a38972d97d6f1c14d98973abbaa970" translate="yes" xml:space="preserve">
          <source>an unsigned word</source>
          <target state="translated">неподписанное слово</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="70913d37024f402445c0df52a7fadf651367bc49" translate="yes" xml:space="preserve">
          <source>and &amp;ldquo;on&amp;rdquo; for</source>
          <target state="translated">и &quot;on&quot; для</target>
        </trans-unit>
        <trans-unit id="16ef79c113045b4dd6e920ca55a6a62dad230d8e" translate="yes" xml:space="preserve">
          <source>and 2 for</source>
          <target state="translated">и 2 для</target>
        </trans-unit>
        <trans-unit id="6e8bd910160e77b35630d8e9ecd21b71ad3f3f1e" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;__attribute__ ((visibility(&quot;default&quot;)))&lt;/code&gt; instead of &lt;code&gt;__declspec(dllexport)&lt;/code&gt; you get almost identical semantics with identical syntax. This is a great boon to those working with cross-platform projects.</source>
          <target state="translated">и &lt;code&gt;__attribute__ ((visibility(&quot;default&quot;)))&lt;/code&gt; вместо &lt;code&gt;__declspec(dllexport)&lt;/code&gt; вы получаете почти идентичную семантику с идентичным синтаксисом. Это большое благо для тех, кто работает с кроссплатформенными проектами.</target>
        </trans-unit>
        <trans-unit id="ecd7bafc40d24575da004f86f8a90c2aaf8b6d10" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;gold&lt;/code&gt; is used as the linker plugin, &lt;code&gt;externally_visible&lt;/code&gt; attributes are automatically added to functions (not variable yet due to a current &lt;code&gt;gold&lt;/code&gt; issue) that are accessed outside of LTO objects according to resolution file produced by &lt;code&gt;gold&lt;/code&gt;. For other linkers that cannot generate resolution file, explicit &lt;code&gt;externally_visible&lt;/code&gt; attributes are still necessary.</source>
          <target state="translated">а &lt;code&gt;gold&lt;/code&gt; используется в качестве подключаемого модуля компоновщика, атрибуты &lt;code&gt;externally_visible&lt;/code&gt; автоматически добавляются к функциям (пока не изменяются из-за текущей проблемы с &lt;code&gt;gold&lt;/code&gt; ), доступ к которым осуществляется за пределами объектов LTO в соответствии с файлом разрешения, созданным &lt;code&gt;gold&lt;/code&gt; . Для других компоновщиков, которые не могут генерировать файл разрешения, все же необходимы явные атрибуты &lt;code&gt;externally_visible&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc057aa007baa6ea326398d0908a19dee419f14d" translate="yes" xml:space="preserve">
          <source>and CSE is often sufficient to obtain the same effect. However, that is not reliable in cases where the loop body is more complicated than a single basic block. It also does not work at all on some architectures due to restrictions in the CSE pass.</source>
          <target state="translated">и CSE часто бывает достаточно,чтобы получить тот же эффект.Однако это ненадежно в тех случаях,когда тело петли сложнее,чем один основной блок.На некоторых архитектурах он также вообще не работает из-за ограничений в передаче CSE.</target>
        </trans-unit>
        <trans-unit id="2d730a90936bf795bf3e3ee8f9ba908c353e4fdf" translate="yes" xml:space="preserve">
          <source>and PowerPC64 ELFv1 (big-endian) do not support inline PLT calls.</source>
          <target state="translated">и PowerPC64 ELFv1 (big-endian)не поддерживают встроенные вызовы PLT.</target>
        </trans-unit>
        <trans-unit id="b187d89af0f244b0d50df4ccd6e399a3d2177284" translate="yes" xml:space="preserve">
          <source>and above).</source>
          <target state="translated">и выше).</target>
        </trans-unit>
        <trans-unit id="540943c2bc2692326429df85dfa3348df4f1b753" translate="yes" xml:space="preserve">
          <source>and above). It warns about subscripts to arrays that are always out of bounds. This warning is enabled by</source>
          <target state="translated">и выше).Предупреждает о подписках на массивы,которые всегда выходят за рамки.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="3763092639f876f5583517a9d0eb30243e45a887" translate="yes" xml:space="preserve">
          <source>and above.</source>
          <target state="translated">и выше.</target>
        </trans-unit>
        <trans-unit id="e116e2dfbcfa1008e272a76654ceabd0ae9dcd52" translate="yes" xml:space="preserve">
          <source>and above. For some sorts of source code the enhanced partial redundancy elimination optimization can run away, consuming all of the memory available on the host machine. This parameter sets a limit on the length of the sets that are computed, which prevents the runaway behavior. Setting a value of 0 for this parameter allows an unlimited set length.</source>
          <target state="translated">и выше.Для некоторых видов исходных текстов оптимизация по устранению частичного дублирования может закончиться,потребляя всю доступную на хост-машине память.Этот параметр устанавливает ограничение на длину вычисляемых наборов,что предотвращает поведение при побеге.Установка значения 0 для этого параметра позволяет устанавливать неограниченную длину наборов.</target>
        </trans-unit>
        <trans-unit id="d4c36d2256d758a63a43d0d687d1ad18856d0f48" translate="yes" xml:space="preserve">
          <source>and above. It is included in</source>
          <target state="translated">и выше.Он включен в</target>
        </trans-unit>
        <trans-unit id="8ca6f8b65a307f3565d2bdeac5195f1e6675246e" translate="yes" xml:space="preserve">
          <source>and above. It works in tandem with the</source>
          <target state="translated">и выше.Он работает в тандеме с</target>
        </trans-unit>
        <trans-unit id="196478f2d301e69e64852ded07da61f6a1994c32" translate="yes" xml:space="preserve">
          <source>and above. The flag</source>
          <target state="translated">и выше.Флаг</target>
        </trans-unit>
        <trans-unit id="16cca3a59f077ac790f119f67104a42b8a0ffc3d" translate="yes" xml:space="preserve">
          <source>and accordingly for the postamble of the epilogue &amp;mdash; no matter whether the mentioned registers are actually used in the ISR or not. Situations where you might want to use this attribute include:</source>
          <target state="translated">и соответственно для послесловия эпилога - независимо от того, действительно ли упомянутые регистры используются в ISR или нет. Ситуации, в которых вы можете захотеть использовать этот атрибут, включают:</target>
        </trans-unit>
        <trans-unit id="0cba2aa225bdda89770493d09134f7ac4e9d6a51" translate="yes" xml:space="preserve">
          <source>and all C files starting with &amp;rsquo;module&amp;rsquo;.</source>
          <target state="translated">и все файлы C, начинающиеся с 'module'.</target>
        </trans-unit>
        <trans-unit id="bab3e293e424c711fb965241b4ac9719742de334" translate="yes" xml:space="preserve">
          <source>and all the</source>
          <target state="translated">и весь</target>
        </trans-unit>
        <trans-unit id="c05c88d23f63de9b36f3b812e4c3b3636aa4477a" translate="yes" xml:space="preserve">
          <source>and also turns on the following optimization flags:</source>
          <target state="translated">а также включает следующие флаги оптимизации:</target>
        </trans-unit>
        <trans-unit id="2ebde484284695bea6e3641a94d76fb9524875f9" translate="yes" xml:space="preserve">
          <source>and another with</source>
          <target state="translated">и ещё с</target>
        </trans-unit>
        <trans-unit id="a66594753907e18391761122d0c6251f7905b621" translate="yes" xml:space="preserve">
          <source>and another with the default options. GCC must be configured to use GLIBC 2.23 or newer in order to use the &lt;code&gt;target_clones&lt;/code&gt; attribute.</source>
          <target state="translated">и еще один с параметрами по умолчанию. GCC должен быть настроен для использования GLIBC 2.23 или новее, чтобы использовать атрибут &lt;code&gt;target_clones&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be06f33f42d5fdd847c8ef1a054178ef64e8d724" translate="yes" xml:space="preserve">
          <source>and by</source>
          <target state="translated">и за</target>
        </trans-unit>
        <trans-unit id="bd91aa685e568528bf96de5c3a56f0d28ba7fac2" translate="yes" xml:space="preserve">
          <source>and by default a cost model defined with</source>
          <target state="translated">и по умолчанию модель затрат,определяемая с помощью</target>
        </trans-unit>
        <trans-unit id="b58b6b69e9a6e2dffafda6e336f4d4562a450054" translate="yes" xml:space="preserve">
          <source>and code compiled with</source>
          <target state="translated">и код,скомпилированный с</target>
        </trans-unit>
        <trans-unit id="5f781abb49c37ac3e1988d7f276013bdf87a40b0" translate="yes" xml:space="preserve">
          <source>and either</source>
          <target state="translated">да и вообще</target>
        </trans-unit>
        <trans-unit id="db999ebc24b4a98f48dfa65e6948013de37b01d1" translate="yes" xml:space="preserve">
          <source>and emitting the result direct to stdout via</source>
          <target state="translated">и излучение результата непосредственно в stdout через</target>
        </trans-unit>
        <trans-unit id="1769c9699ef4ab291d81bfc70d0f12e25b85fd42" translate="yes" xml:space="preserve">
          <source>and export those classes that are intended to be externally visible. Unfortunately it is possible for code to rely, perhaps accidentally, on the Visual Studio behavior.</source>
          <target state="translated">и экспортировать те классы,которые предназначены для внешней видимости.К сожалению,код может рассчитывать,возможно,случайно,на поведение Visual Studio.</target>
        </trans-unit>
        <trans-unit id="36b302c13ab3c153e6cac498496443414d3fce07" translate="yes" xml:space="preserve">
          <source>and finally</source>
          <target state="translated">и,наконец</target>
        </trans-unit>
        <trans-unit id="8b3b299fce213f2a1e237365ea4fcb9e5607c1e3" translate="yes" xml:space="preserve">
          <source>and higher and depends on</source>
          <target state="translated">и выше и зависит от</target>
        </trans-unit>
        <trans-unit id="d3ee9cb1836394c3283e4bf670015859583e15fc" translate="yes" xml:space="preserve">
          <source>and higher as well as</source>
          <target state="translated">заодно и выше</target>
        </trans-unit>
        <trans-unit id="5a9bec14cd65cb6407309dcf8b220e22883b3c85" translate="yes" xml:space="preserve">
          <source>and higher if</source>
          <target state="translated">и выше,если</target>
        </trans-unit>
        <trans-unit id="bcbf9cf724baaa2c05cb8d8ef447ba9db9b1d32e" translate="yes" xml:space="preserve">
          <source>and higher on architectures that support this.</source>
          <target state="translated">и выше на архитектурах,которые это поддерживают.</target>
        </trans-unit>
        <trans-unit id="5652f51541248dfcd407bf27224a828b6323954d" translate="yes" xml:space="preserve">
          <source>and higher,</source>
          <target state="translated">и выше,</target>
        </trans-unit>
        <trans-unit id="20df9f0858c9d558bdf3ec73ab7b30c8be3693c7" translate="yes" xml:space="preserve">
          <source>and higher, and also at</source>
          <target state="translated">и выше,а также</target>
        </trans-unit>
        <trans-unit id="d997e6f0b5d9397ce43f624b10d7171a88e8eab8" translate="yes" xml:space="preserve">
          <source>and higher, except for</source>
          <target state="translated">и выше,за исключением</target>
        </trans-unit>
        <trans-unit id="de9609e65fe8304aa2b84c02990d0ddd0b347ca8" translate="yes" xml:space="preserve">
          <source>and higher.</source>
          <target state="translated">и выше.</target>
        </trans-unit>
        <trans-unit id="4822df6fd07924d846e61249bdf13788d9ead31a" translate="yes" xml:space="preserve">
          <source>and higher. Higher optimization levels improve the accuracy of the analysis.</source>
          <target state="translated">и выше.Более высокие уровни оптимизации повышают точность анализа.</target>
        </trans-unit>
        <trans-unit id="afc0a14fb13d8311f68301c0ecd98042f1e9800d" translate="yes" xml:space="preserve">
          <source>and higher. It is not enabled for</source>
          <target state="translated">и выше.Не включено для</target>
        </trans-unit>
        <trans-unit id="a76fab721d9a45aaff56d37fa7059d4d07c6bf05" translate="yes" xml:space="preserve">
          <source>and higher. Null pointer check elimination is only done if</source>
          <target state="translated">и выше.Ликвидация проверки нулевого указателя производится только в том случае,если</target>
        </trans-unit>
        <trans-unit id="17f12a1567309243f3153a113c5c9b0dc8b04f9a" translate="yes" xml:space="preserve">
          <source>and higher. The compilation time in this pass can be limited using</source>
          <target state="translated">и выше.Время компиляции в этом проходе может быть ограничено использованием</target>
        </trans-unit>
        <trans-unit id="1352c6defb413a9629f8a883262aafbdf1d73c3e" translate="yes" xml:space="preserve">
          <source>and if the variable arguments are omitted or empty, the &amp;lsquo;</source>
          <target state="translated">и если переменные аргументы опущены или пусты, '</target>
        </trans-unit>
        <trans-unit id="97253136342a86d551cb8f938043a04fa09b8e17" translate="yes" xml:space="preserve">
          <source>and in the</source>
          <target state="translated">и в</target>
        </trans-unit>
        <trans-unit id="71e7f852efd77608e67d67f4769c27771f643624" translate="yes" xml:space="preserve">
          <source>and in the cases of</source>
          <target state="translated">и в случаях,когда</target>
        </trans-unit>
        <trans-unit id="8e1a25c4625f2b80697437af8a97194c0476ac2c" translate="yes" xml:space="preserve">
          <source>and introduces new signatures for user-defined literals:</source>
          <target state="translated">и вводит новые подписи для определяемых пользователем литералов:</target>
        </trans-unit>
        <trans-unit id="4a1b1d4b275aa98ab0a4a65283ca64d508b23283" translate="yes" xml:space="preserve">
          <source>and is defined for compatibility with Diab.</source>
          <target state="translated">и определена для совместимости с Diab.</target>
        </trans-unit>
        <trans-unit id="b6b1e55ec15f2cb25e78716d325961ca33806bb5" translate="yes" xml:space="preserve">
          <source>and is deprecated.</source>
          <target state="translated">и он испорчен.</target>
        </trans-unit>
        <trans-unit id="9c32e4dd09aae4d64ecbad3933f8c85c732ca5ff" translate="yes" xml:space="preserve">
          <source>and is enabled by</source>
          <target state="translated">и включается по</target>
        </trans-unit>
        <trans-unit id="60f868f3a7c169f71793f02a83a16555d3150a50" translate="yes" xml:space="preserve">
          <source>and is enabled by default in C99 and C++11 modes (and newer). This warning level does not warn about left-shifting 1 into the sign bit. (However, in C, such an overflow is still rejected in contexts where an integer constant expression is required.) No warning is emitted in C++2A mode (and newer), as signed left shifts always wrap.</source>
          <target state="translated">и включена по умолчанию в режимах C99 и C++11 (и более новых).Данный уровень предупреждений не предупреждает о сдвиге влево 1 в знаковый бит.(Однако в Си такое переполнение все равно отвергается в контекстах,где требуется целочисленное константное выражение).В режиме Си++2А (и более новых)предупреждение не выдается,так как знаковые левые сдвиги всегда обертываются.</target>
        </trans-unit>
        <trans-unit id="18a6194526a99bc8a75aa2625ef50b249a3cc54a" translate="yes" xml:space="preserve">
          <source>and is ignored at link time.</source>
          <target state="translated">и игнорируется во время соединения.</target>
        </trans-unit>
        <trans-unit id="8cdd0a931822d69709608b564b7f6b552ac906b1" translate="yes" xml:space="preserve">
          <source>and its related options. Both absolute and relative paths can be used. By default, GCC uses the current directory as &lt;var&gt;path&lt;/var&gt;, thus the profile data file appears in the same directory as the object file. In order to prevent the file name clashing, if the object file name is not an absolute path, we mangle the absolute path of the</source>
          <target state="translated">и связанные с ним параметры. Могут использоваться как абсолютные, так и относительные пути. По умолчанию GCC использует текущий каталог в качестве &lt;var&gt;path&lt;/var&gt; , поэтому файл данных профиля появляется в том же каталоге, что и объектный файл. Чтобы предотвратить конфликт имен файлов, если имя объектного файла не является абсолютным путем, мы изменяем абсолютный путь к</target>
        </trans-unit>
        <trans-unit id="8aaeb495a9e5b482acebee2f5a8a0a37a7e8745c" translate="yes" xml:space="preserve">
          <source>and joined by spaces. This list is intended to be passed to the LTO linker plugin.</source>
          <target state="translated">и соединены пространствами.Этот список предназначен для передачи плагину компоновщика LTO.</target>
        </trans-unit>
        <trans-unit id="c7acf5a5b05ac0929c1671052424680580734fbc" translate="yes" xml:space="preserve">
          <source>and let the driver handle the options instead.</source>
          <target state="translated">и пусть вместо этого водитель займется опциями.</target>
        </trans-unit>
        <trans-unit id="bfccb2c5c250efe79e7d9930697e9b24c391e2ac" translate="yes" xml:space="preserve">
          <source>and libraries in</source>
          <target state="translated">и библиотеки в</target>
        </trans-unit>
        <trans-unit id="f0e01a5c55ee31dbcc71234d1f7dd13b04392356" translate="yes" xml:space="preserve">
          <source>and must be explicitly requested since in C++ this isn&amp;rsquo;t an error and in C it might be harder to clean up all headers included.</source>
          <target state="translated">и должен быть явно запрошен, поскольку в C ++ это не ошибка, а в C может быть сложнее очистить все включенные заголовки.</target>
        </trans-unit>
        <trans-unit id="c8b774402ab6984eabd550c359a10ea00ca9ffbe" translate="yes" xml:space="preserve">
          <source>and optimization options should be specified at compile time and during the final link. It is recommended that you compile all the files participating in the same link with the same options and also specify those options at link time. For example:</source>
          <target state="translated">и опции оптимизации должны быть указаны при компиляции и во время финальной ссылки.Рекомендуется компилировать все файлы,участвующие в одной и той же ссылке с одними и теми же опциями,а также указывать эти опции во время компиляции.Например:</target>
        </trans-unit>
        <trans-unit id="c7904d214a56c9420eebba683732a4bd59f75475" translate="yes" xml:space="preserve">
          <source>and other options cause warnings for many GNU C extensions. You can prevent such warnings within one expression by writing &lt;code&gt;__extension__&lt;/code&gt; before the expression. &lt;code&gt;__extension__&lt;/code&gt; has no effect aside from this.</source>
          <target state="translated">и другие параметры вызывают предупреждения для многих расширений GNU C. Вы можете предотвратить появление таких предупреждений в одном выражении, написав &lt;code&gt;__extension__&lt;/code&gt; перед выражением. &lt;code&gt;__extension__&lt;/code&gt; кроме этого не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="737b71e6d8426b3fda4249cd8c1165da4988f20d" translate="yes" xml:space="preserve">
          <source>and outputs the command-line option</source>
          <target state="translated">и выводит опцию командной строки</target>
        </trans-unit>
        <trans-unit id="4a51075a2d63bdd9c031332e64282ebb86738b8f" translate="yes" xml:space="preserve">
          <source>and passes them on to the running GCC to make them part of the aggregated GIMPLE image to be optimized.</source>
          <target state="translated">и передает их в работающий GCC,чтобы сделать их частью агрегированного изображения GIMPLE,которое будет оптимизировано.</target>
        </trans-unit>
        <trans-unit id="b7483c73e6a38e6274495270d12341498eeacbbb" translate="yes" xml:space="preserve">
          <source>and prevents linking with the shared libraries. On other systems, this option has no effect.</source>
          <target state="translated">и предотвращает соединение с общими библиотеками.На других системах эта опция не действует.</target>
        </trans-unit>
        <trans-unit id="123217ee99d19efe020f3f3466fda26930ff804c" translate="yes" xml:space="preserve">
          <source>and remove the</source>
          <target state="translated">и убрать</target>
        </trans-unit>
        <trans-unit id="d0ba1984262756dc3e97eba7054a343cd95b906e" translate="yes" xml:space="preserve">
          <source>and sets the start address of the program to 0x800.</source>
          <target state="translated">и устанавливает стартовый адрес программы на 0x800.</target>
        </trans-unit>
        <trans-unit id="ca533d5e239b86c5bce8e5223c75d9799ce24658" translate="yes" xml:space="preserve">
          <source>and so on. Most of these have both positive and negative forms; the negative form of</source>
          <target state="translated">и так далее.Большинство из них имеют как положительные,так и отрицательные формы;отрицательная форма</target>
        </trans-unit>
        <trans-unit id="8448c2525daee3e2e6799cb7b66fc64c9ee09e88" translate="yes" xml:space="preserve">
          <source>and that the standard C libraries are</source>
          <target state="translated">и что стандартные библиотеки Си</target>
        </trans-unit>
        <trans-unit id="673968187c298fea9b969fc56a05d8e49cf79c7d" translate="yes" xml:space="preserve">
          <source>and the Fortran-specific</source>
          <target state="translated">и специфический для Фортрана</target>
        </trans-unit>
        <trans-unit id="584bb0d053da62487d41fcb63d90a5569011ef09" translate="yes" xml:space="preserve">
          <source>and the application be linked with</source>
          <target state="translated">и приложение должно быть связано с</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
