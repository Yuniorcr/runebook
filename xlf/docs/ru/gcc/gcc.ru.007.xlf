<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="adca7822f575134857a5ee57f78ae4fe66d4c44f" translate="yes" xml:space="preserve">
          <source>As an optimization, G++ sometimes gives array compound literals longer lifetimes: when the array either appears outside a function or has a &lt;code&gt;const&lt;/code&gt;-qualified type. If &lt;code&gt;foo&lt;/code&gt; and its initializer had elements of type &lt;code&gt;char *const&lt;/code&gt; rather than &lt;code&gt;char *&lt;/code&gt;, or if &lt;code&gt;foo&lt;/code&gt; were a global variable, the array would have static storage duration. But it is probably safest just to avoid the use of array compound literals in C++ code.</source>
          <target state="translated">В качестве оптимизации, G ++ иногда дает массив соединение литералов большее время жизни: когда массив либо выходит за пределы функции или имеет &lt;code&gt;const&lt;/code&gt; -qualified типа. Если бы &lt;code&gt;foo&lt;/code&gt; и его инициализатор имели элементы типа &lt;code&gt;char *const&lt;/code&gt; а не &lt;code&gt;char *&lt;/code&gt; , или если бы &lt;code&gt;foo&lt;/code&gt; была глобальной переменной, массив имел бы статическую продолжительность хранения. Но, вероятно, безопаснее всего просто избегать использования составных литералов массива в коде C ++.</target>
        </trans-unit>
        <trans-unit id="4440512ea926e0e3e9623211be65c0fe001b769e" translate="yes" xml:space="preserve">
          <source>As another example,</source>
          <target state="translated">В качестве другого примера,</target>
        </trans-unit>
        <trans-unit id="c2d7d2d398b725a8ff7f6339f33b58fb71e37c73" translate="yes" xml:space="preserve">
          <source>As another example, the following call to &lt;code&gt;strncpy&lt;/code&gt; results in copying to &lt;code&gt;d&lt;/code&gt; just the characters preceding the terminating NUL, without appending the NUL to the end. Assuming the result of &lt;code&gt;strncpy&lt;/code&gt; is necessarily a NUL-terminated string is a common mistake, and so the call is diagnosed. To avoid the warning when the result is not expected to be NUL-terminated, call &lt;code&gt;memcpy&lt;/code&gt; instead.</source>
          <target state="translated">В качестве другого примера, следующий вызов &lt;code&gt;strncpy&lt;/code&gt; приводит к копированию в &lt;code&gt;d&lt;/code&gt; только символов, предшествующих завершающему NUL, без добавления NUL в конец. Предположение, что результатом &lt;code&gt;strncpy&lt;/code&gt; обязательно является строка с завершающим NUL, является распространенной ошибкой, поэтому вызов диагностируется. Чтобы избежать предупреждения, когда не ожидается, что результат будет завершаться NUL, вместо этого вызовите &lt;code&gt;memcpy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f22e08722bb8e7ce646a0894d86b714e1a18ddc2" translate="yes" xml:space="preserve">
          <source>As bit-fields are not individually addressable, volatile bit-fields may be implicitly read when written to, or when adjacent bit-fields are accessed. Bit-field operations may be optimized such that adjacent bit-fields are only partially accessed, if they straddle a storage unit boundary. For these reasons it is unwise to use volatile bit-fields to access hardware.</source>
          <target state="translated">Поскольку битовые поля не являются индивидуально адресуемыми,нестабильные битовые поля могут быть неявно прочитаны при записи в них или при обращении к соседним битовым полям.Операции с битовыми полями могут быть оптимизированы таким образом,что доступ к соседним битовым полям будет только частичным,если они будут пересекать границу хранилища.По этим причинам использование нестабильных битовых полей для доступа к оборудованию неразумно.</target>
        </trans-unit>
        <trans-unit id="54cb09a605966e1ec9e0e0780e8355b83cacd9f7" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, this attribute allows specification of target-specific compilation options.</source>
          <target state="translated">Как обсуждалось в &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;разделе &amp;laquo;Общие атрибуты функций&amp;raquo;&lt;/a&gt; , этот атрибут позволяет специфицировать параметры компиляции для конкретных целей.</target>
        </trans-unit>
        <trans-unit id="c47f4f2d2c816a9b7574ec5c08de30912daa2a80" translate="yes" xml:space="preserve">
          <source>As for &amp;lsquo;</source>
          <target state="translated">Что касается '</target>
        </trans-unit>
        <trans-unit id="71478357402c28a54c8c6fca58d451aad7e53ab5" translate="yes" xml:space="preserve">
          <source>As in standard C++ and ISO C99, the elements of an aggregate initializer for an automatic variable are not required to be constant expressions in GNU C. Here is an example of an initializer with run-time varying elements:</source>
          <target state="translated">Как и в стандартах C++и ISO C99,элементы совокупного инициализатора для автоматической переменной не обязательно должны быть константными выражениями в GNU C.Приведем пример инициализатора с элементами,изменяющими время выполнения:</target>
        </trans-unit>
        <trans-unit id="e19fab7ccaf71008439ad46e66a6dd8a8249abc0" translate="yes" xml:space="preserve">
          <source>As in the preceding example, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; type. Alternatively, you can leave out the alignment factor and just ask the compiler to align a type to the maximum useful alignment for the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">Как и в предыдущем примере, вы можете явно указать выравнивание (в байтах), которое вы хотите, чтобы компилятор использовал для данной &lt;code&gt;struct&lt;/code&gt; или типа &lt;code&gt;union&lt;/code&gt; . В качестве альтернативы вы можете не указывать коэффициент выравнивания и просто попросить компилятор выровнять тип по максимально полезному выравниванию для целевой машины, для которой вы компилируете. Например, вы можете написать:</target>
        </trans-unit>
        <trans-unit id="b67040c22389d40183c4661602eeb071108d65a1" translate="yes" xml:space="preserve">
          <source>As in the preceding examples, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given variable or structure field. Alternatively, you can leave out the alignment factor and just ask the compiler to align a variable or field to the default alignment for the target architecture you are compiling for. The default alignment is sufficient for all scalar types, but may not be enough for all vector types on a target that supports vector operations. The default alignment is fixed for a particular target ABI.</source>
          <target state="translated">Как и в предыдущих примерах,вы можете явно указать выравнивание (в байтах),которое компилятор должен использовать для заданной переменной или поля структуры.Или же вы можете не указывать коэффициент выравнивания и просто попросить компилятор выровнять переменную или поле по умолчанию для целевой архитектуры,для которой вы выполняете компиляцию.Выравнивание по умолчанию достаточно для всех скалярных типов,но может быть недостаточно для всех векторных типов на целевой,поддерживающей векторные операции.Выравнивание по умолчанию фиксировано для конкретного целевого ABI.</target>
        </trans-unit>
        <trans-unit id="4953117cca7e33df31955c24738168de010b1a14" translate="yes" xml:space="preserve">
          <source>As long as the stack frame backchain is not used, code generated with</source>
          <target state="translated">До тех пор,пока не используется бэк-фрейм стека,код,сгенерированный с помощью</target>
        </trans-unit>
        <trans-unit id="55612a0f57841c9314e7eae808cb715df500b680" translate="yes" xml:space="preserve">
          <source>As mentioned above, the new exceptions do not support handling types other than Objective-C objects. Furthermore, when used from Objective-C++, the Objective-C exception model does not interoperate with C++ exceptions at this time. This means you cannot &lt;code&gt;@throw&lt;/code&gt; an exception from Objective-C and &lt;code&gt;catch&lt;/code&gt; it in C++, or vice versa (i.e., &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt;).</source>
          <target state="translated">Как упоминалось выше, новые исключения не поддерживают типы обработки, отличные от объектов Objective-C. Более того, при использовании из Objective-C ++ модель исключений Objective-C в настоящее время не взаимодействует с исключениями C ++. Это означает , что вы не можете &lt;code&gt;@throw&lt;/code&gt; исключения из Objective-C и &lt;code&gt;catch&lt;/code&gt; его в C ++, или наоборот (то есть, &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="294a250033394e9398ee357e8a3028f8f81f0fc0" translate="yes" xml:space="preserve">
          <source>As new Intel processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the most current Intel processors at the time that version of GCC is released.</source>
          <target state="translated">По мере развертывания на рынке новых процессоров Intel,поведение этой опции изменится.Поэтому,если вы перейдете на более новую версию GCC,генерация кода,управляемая этой опцией,изменится,чтобы отразить самые современные процессоры Intel на момент выпуска этой версии GCC.</target>
        </trans-unit>
        <trans-unit id="071c1df1bb91e5145c672769a3ad43fada5e0f32" translate="yes" xml:space="preserve">
          <source>As new processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the processors that are most common at the time that version of GCC is released.</source>
          <target state="translated">По мере развертывания новых процессоров на рынке,поведение этой опции будет меняться.Поэтому,если вы перейдете на более новую версию GCC,генерация кода,контролируемая этой опцией,изменится,чтобы отразить процессоры,которые наиболее распространены на момент выпуска этой версии GCC.</target>
        </trans-unit>
        <trans-unit id="3744f46b0905194e3e22c08ee725283caaeed6c9" translate="yes" xml:space="preserve">
          <source>As of the GCC 4.7.1 release, GCC supports the Go 1 language standard, described at &lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1&lt;/a&gt;.</source>
          <target state="translated">Начиная с выпуска GCC 4.7.1, GCC поддерживает стандарт языка Go 1, описанный на &lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e64c1bee27f99a750cc73752558d5aa035a91d3b" translate="yes" xml:space="preserve">
          <source>As of this writing, only the NeXT runtime on Mac OS X 10.4 and later has support for invoking the &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods.</source>
          <target state="translated">На момент написания этой статьи только среда выполнения NeXT в Mac OS X 10.4 и более поздних версиях поддерживает &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; методов &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; и - (void) .cxx_destruct .</target>
        </trans-unit>
        <trans-unit id="190838497fcc16bfeb19ed9bf8cb7b33b5859658" translate="yes" xml:space="preserve">
          <source>As of this writing, there are no SPARC implementations that have hardware support for the quad-word floating-point instructions. They all invoke a trap handler for one of these instructions, and then the trap handler emulates the effect of the instruction. Because of the trap handler overhead, this is much slower than calling the ABI library routines. Thus the</source>
          <target state="translated">На момент написания этой статьи не существует реализаций SPARC,которые имеют аппаратную поддержку инструкций с плавающей запятой в четырех словах.Все они вызывают обработчик ловушки для одной из этих инструкций,а затем обработчик ловушки эмулирует действие инструкции.Из-за накладных расходов на обработчик ловушек,это намного медленнее,чем вызов библиотечных процедур ABI.Таким образом</target>
        </trans-unit>
        <trans-unit id="ea115f65d5a89a6a0ce102bba12e75c8b98c940e" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements the intrinsics below. FPTR is used here to mean any function pointer type.</source>
          <target state="translated">В рамках расширений безопасности GCC реализует нижеприведенные неотъемлемые элементы.FPTR используется здесь для обозначения любого типа указателя на функцию.</target>
        </trans-unit>
        <trans-unit id="44e4fff7ccbcdce5ca766f79d5a621ec9dbe0d23" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements two new function attributes: &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; and &lt;code&gt;cmse_nonsecure_call&lt;/code&gt;.</source>
          <target state="translated">Как часть Security Extensions GCC реализует два новых атрибута функции: &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; и &lt;code&gt;cmse_nonsecure_call&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7eaf9c2848babad871d614fdc58e037312c5b34b" translate="yes" xml:space="preserve">
          <source>As per</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bdd745d898a259ccaad1e7c0edf927d13bbb62" translate="yes" xml:space="preserve">
          <source>As per the previous level, but also show events for the entry to each function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c247ef3385f14a80d57ef00798ecd37f7339e8" translate="yes" xml:space="preserve">
          <source>As per the previous level, but also show events relating to control flow that are significant to triggering the issue (e.g. &amp;ldquo;true path taken&amp;rdquo; at a conditional).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2efe9a9ef3b6fb5fc179ca740391f6374be999fe" translate="yes" xml:space="preserve">
          <source>As per the previous level, but show all control flow events, not just significant ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6f3f1d276c90c5e06c8b6bf28158a5a889bccd" translate="yes" xml:space="preserve">
          <source>As permitted by ISO C11 and for compatibility with other compilers, GCC allows you to define a structure or union that contains, as fields, structures and unions without names. For example:</source>
          <target state="translated">В соответствии с разрешением ISO C11 и для совместимости с другими компиляторами,GCC позволяет определить структуру или союз,который содержит,как поля,структуры и союзы без названий.Например:</target>
        </trans-unit>
        <trans-unit id="cd38e2252e3cfbc1562a66af3fc83a7b3476b926" translate="yes" xml:space="preserve">
          <source>As required by ISO C++, GCC considers member functions defined within the body of a class to be marked inline even if they are not explicitly declared with the &lt;code&gt;inline&lt;/code&gt; keyword. You can override this with</source>
          <target state="translated">В соответствии с требованиями ISO C ++, GCC считает функции-члены, определенные в теле класса, помеченными как встроенные, даже если они явно не объявлены с помощью ключевого слова &lt;code&gt;inline&lt;/code&gt; . Вы можете изменить это с помощью</target>
        </trans-unit>
        <trans-unit id="ee86d176185420b2cd516cd28e0d2c038499f36a" translate="yes" xml:space="preserve">
          <source>As with all outermost parameter qualifiers, &lt;code&gt;__restrict__&lt;/code&gt; is ignored in function definition matching. This means you only need to specify &lt;code&gt;__restrict__&lt;/code&gt; in a function definition, rather than in a function prototype as well.</source>
          <target state="translated">Как и все квалификаторы внешних параметров, &lt;code&gt;__restrict__&lt;/code&gt; игнорируется при сопоставлении определения функции. Это означает, что вам нужно указать &lt;code&gt;__restrict__&lt;/code&gt; только в определении функции, а не в прототипе функции.</target>
        </trans-unit>
        <trans-unit id="ba3fbd93824241c0022727ea0aaa70098dbf8058" translate="yes" xml:space="preserve">
          <source>As with global register variables, it is recommended that you choose a register that is normally saved and restored by function calls on your machine, so that calls to library routines will not clobber it.</source>
          <target state="translated">Как и в случае с глобальными переменными реестра,рекомендуется выбрать регистр,который обычно сохраняется и восстанавливается вызовами функций на вашей машине,чтобы вызовы библиотечных процедур не засоряли его.</target>
        </trans-unit>
        <trans-unit id="9d9e595b377650b7d530b408f01a2295e9aa3eb5" translate="yes" xml:space="preserve">
          <source>As with the C front end, G++ understands the C99 feature of restricted pointers, specified with the &lt;code&gt;__restrict__&lt;/code&gt;, or &lt;code&gt;__restrict&lt;/code&gt; type qualifier. Because you cannot compile C++ by specifying the</source>
          <target state="translated">Как и интерфейс C, G ++ понимает функцию C99 ограниченных указателей, указанных с помощью квалификатора типа &lt;code&gt;__restrict__&lt;/code&gt; или &lt;code&gt;__restrict&lt;/code&gt; . Поскольку вы не можете скомпилировать C ++, указав</target>
        </trans-unit>
        <trans-unit id="21e7da79fc603087dc1baeac067752aa75dc3fe9" translate="yes" xml:space="preserve">
          <source>Assembler Options</source>
          <target state="translated">Опции ассемблера</target>
        </trans-unit>
        <trans-unit id="bcf5f12f4332ce70ca2c9b5133dda1d57f7cdf19" translate="yes" xml:space="preserve">
          <source>Assembler code that must be preprocessed.</source>
          <target state="translated">Ассемблерный код,который должен быть препроцессирован.</target>
        </trans-unit>
        <trans-unit id="f9cab59729ce9a72e9592405aff1f8fcf01f46db" translate="yes" xml:space="preserve">
          <source>Assembler code.</source>
          <target state="translated">Соберите код.</target>
        </trans-unit>
        <trans-unit id="32b8b4178e9d441788dbf96199839a839961313d" translate="yes" xml:space="preserve">
          <source>Assembler names for data:</source>
          <target state="translated">Имена ассемблеров для данных:</target>
        </trans-unit>
        <trans-unit id="a60468da111a0ab238610d89ab550d7cb3db7634" translate="yes" xml:space="preserve">
          <source>Assembler names for functions:</source>
          <target state="translated">Имена ассемблеров для функций:</target>
        </trans-unit>
        <trans-unit id="c09492c8b5916e81a92681e73286dd4d053d0d64" translate="yes" xml:space="preserve">
          <source>Assembly output</source>
          <target state="translated">сборочный выход</target>
        </trans-unit>
        <trans-unit id="c20d25392b6fcd428956d9fadf904cf6f25c34c2" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a freestanding environment. This implies</source>
          <target state="translated">Утвердить,что компиляция нацелена на отдельную среду.Это подразумевает</target>
        </trans-unit>
        <trans-unit id="d5b5344f90d89057b5b4c1d64f39bf480cc87ed4" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a hosted environment. This implies</source>
          <target state="translated">Утвердить,что компиляция нацелена на хостируемую среду.Это подразумевает</target>
        </trans-unit>
        <trans-unit id="3d6a91afbb703874ed1adcc1fc07fbc355255566" translate="yes" xml:space="preserve">
          <source>Assignments are also expressions and have an rvalue. However when assigning to a scalar volatile, the volatile object is not reread, regardless of whether the assignment expression&amp;rsquo;s rvalue is used or not. If the assignment&amp;rsquo;s rvalue is used, the value is that assigned to the volatile object. For instance, there is no read of &lt;var&gt;vobj&lt;/var&gt; in all the following cases:</source>
          <target state="translated">Присвоения также являются выражениями и имеют значение r. Однако при назначении скалярному изменчивому объекту изменчивый объект не перечитывается независимо от того, используется ли r-значение выражения присваивания или нет. Если используется rvalue присваивания, это значение, присвоенное изменчивому объекту. Например, &lt;var&gt;vobj&lt;/var&gt; не читается во всех следующих случаях:</target>
        </trans-unit>
        <trans-unit id="0c40f851ca2e4b0159b069f87df3cdf0c325569f" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that all symbols have 32-bit values, regardless of the selected ABI. This option is useful in combination with</source>
          <target state="translated">Предположим (не предполагаем),что все символы имеют 32-битные значения,независимо от выбранного ABI.Эта опция полезна в сочетании с</target>
        </trans-unit>
        <trans-unit id="29f90ada4a3fec867ca24dbc5026596c24d16fc4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that externally-defined data is in a small data section if the size of that data is within the</source>
          <target state="translated">Предположим (не предполагаем),что данные,определяемые извне,находятся в маленькой секции данных,если размер этих данных находится в пределах поля</target>
        </trans-unit>
        <trans-unit id="2cfe16d43985ee39e482829ca4a8dfdcb2d636f4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI.</source>
          <target state="translated">Предположим (не предполагаем),что инструкции по взаимным оценкам обеспечивают более высокую точность оценок,чем предусмотрено PowerPC ABI.</target>
        </trans-unit>
        <trans-unit id="ec6f2df5d90d0e07067a08f77629a109a7baeb7c" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI. Selecting</source>
          <target state="translated">Предположим (не предполагаем),что инструкции по взаимным оценкам обеспечивают более высокую точность оценок,чем предусмотрено PowerPC ABI.Выбор .</target>
        </trans-unit>
        <trans-unit id="813b5f0f913426f167f43f6e9f2605b43322e0d6" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the static and dynamic linkers support PLTs and copy relocations. This option only affects</source>
          <target state="translated">Предположим (не предполагаем),что статические и динамические компоновщики поддерживают PLT и копируют перемещения.Этот вариант влияет только на</target>
        </trans-unit>
        <trans-unit id="6218242555601cfde6dcb1f0fb4410c65b0c0afe" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that zero displacement conditional branch instructions &lt;code&gt;bt&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt; are fast. If</source>
          <target state="translated">Предположим (не предполагаем), что команды условного перехода с нулевым смещением &lt;code&gt;bt&lt;/code&gt; и &lt;code&gt;bf&lt;/code&gt; являются быстрыми. Если</target>
        </trans-unit>
        <trans-unit id="4d87b438e6a49fee40ee2b8e75d048b2cb33a8d4" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;int&lt;/code&gt; to be 8-bit integer. This affects the sizes of all types: a &lt;code&gt;char&lt;/code&gt; is 1 byte, an &lt;code&gt;int&lt;/code&gt; is 1 byte, a &lt;code&gt;long&lt;/code&gt; is 2 bytes, and &lt;code&gt;long long&lt;/code&gt; is 4 bytes. Please note that this option does not conform to the C standards, but it results in smaller code size.</source>
          <target state="translated">Предположим, что &lt;code&gt;int&lt;/code&gt; - это 8-битное целое число. Это влияет на размеры всех типов: &lt;code&gt;char&lt;/code&gt; - 1 байт, &lt;code&gt;int&lt;/code&gt; - 1 байт, &lt;code&gt;long&lt;/code&gt; - 2 байта, &lt;code&gt;long long&lt;/code&gt; - 4 байта. Обратите внимание, что эта опция не соответствует стандартам C, но приводит к меньшему размеру кода.</target>
        </trans-unit>
        <trans-unit id="5c2bc85ec675432aace4d6922b50129cffa86b60" translate="yes" xml:space="preserve">
          <source>Assume &lt;var&gt;num&lt;/var&gt; to be the cost for a branch instruction. Higher numbers make the compiler try to generate more branch-free code if possible. If not specified the value is selected depending on the processor type that is being compiled for.</source>
          <target state="translated">Предположим, что &lt;var&gt;num&lt;/var&gt; - это стоимость инструкции перехода. Более высокие числа заставляют компилятор пытаться сгенерировать больше кода без ветвлений, если это возможно. Если не указано, значение выбирается в зависимости от типа процессора, для которого выполняется компиляция.</target>
        </trans-unit>
        <trans-unit id="a18b03a98d3895d8de33097ebfdc73e386381f27" translate="yes" xml:space="preserve">
          <source>Assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">При генерации потокового локального кода предполагайте большой сегмент TLS.</target>
        </trans-unit>
        <trans-unit id="dcc9240dada623776592057c6e5b8a92da4c9b4e" translate="yes" xml:space="preserve">
          <source>Assume addresses can be loaded as 16-bit unsigned values. This does not apply to function addresses for which</source>
          <target state="translated">Предполагаемые адреса могут быть загружены в виде 16-битных беззнаковых значений.Это не относится к адресам функций,для которых</target>
        </trans-unit>
        <trans-unit id="fb31614e67999bd6734c6361178e2cdabb52e555" translate="yes" xml:space="preserve">
          <source>Assume all objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction. This is the default.</source>
          <target state="translated">Предположим, что все объекты находятся в нижних 16 МБ памяти (чтобы их адреса можно было загрузить с &lt;code&gt;ld24&lt;/code&gt; инструкции ld24 ), и предположим, что все подпрограммы достижимы с помощью инструкции &lt;code&gt;bl&lt;/code&gt; . Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c507ae5c9607f036356273bef8470c3d07a51113" translate="yes" xml:space="preserve">
          <source>Assume inline assembler is using unified asm syntax. The default is currently off which implies divided syntax. This option has no impact on Thumb2. However, this may change in future releases of GCC. Divided syntax should be considered deprecated.</source>
          <target state="translated">Предполагается,что встроенный ассемблер использует унифицированный синтаксис asm.По умолчанию синтаксис по умолчанию выключен,что подразумевает разделенный синтаксис.Эта опция не влияет на Thumb2.Однако,это может измениться в будущих выпусках GCC.Разделенный синтаксис следует считать устаревшим.</target>
        </trans-unit>
        <trans-unit id="db05f7ded93295035bf91b215647f3c25bb15bd8" translate="yes" xml:space="preserve">
          <source>Assume loading data from flash is slower than fetching instruction. Therefore literal load is minimized for better performance. This option is only supported when compiling for ARMv7 M-profile and off by default. It conflicts with</source>
          <target state="translated">Предполагается,что загрузка данных с флэш-памяти происходит медленнее,чем получение инструкций.Поэтому буквальная загрузка сведена к минимуму для лучшей производительности.Эта опция поддерживается только при компиляции для ARMv7 M-профиля и по умолчанию выключена.Она конфликтует с</target>
        </trans-unit>
        <trans-unit id="d4a16bcb883f109ce15025d3902db389e542f4a1" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction.</source>
          <target state="translated">Предположим, что объекты могут находиться где угодно в 32-битном адресном пространстве (компилятор генерирует инструкции &lt;code&gt;seth/add3&lt;/code&gt; для загрузки их адресов), и предположим, что все подпрограммы достижимы с помощью инструкции &lt;code&gt;bl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d339dd7aa4708a54eb51d13312b9c328ad3f5e5" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume subroutines may not be reachable with the &lt;code&gt;bl&lt;/code&gt; instruction (the compiler generates the much slower &lt;code&gt;seth/add3/jl&lt;/code&gt; instruction sequence).</source>
          <target state="translated">Предположим, что объекты могут находиться где угодно в 32-битном адресном пространстве (компилятор генерирует инструкции &lt;code&gt;seth/add3&lt;/code&gt; для загрузки их адресов), и предположим, что подпрограммы могут быть недоступны с помощью инструкции &lt;code&gt;bl&lt;/code&gt; (компилятор генерирует гораздо более &lt;code&gt;seth/add3/jl&lt;/code&gt; инструкцию seth / add3 / jl. последовательность).</target>
        </trans-unit>
        <trans-unit id="c85e043c6d4b72a1f02e91090d703114e74e4f8f" translate="yes" xml:space="preserve">
          <source>Assume that &lt;code&gt;RJMP&lt;/code&gt; and &lt;code&gt;RCALL&lt;/code&gt; can target the whole program memory.</source>
          <target state="translated">Предположим, что &lt;code&gt;RJMP&lt;/code&gt; и &lt;code&gt;RCALL&lt;/code&gt; могут нацеливаться на всю программную память.</target>
        </trans-unit>
        <trans-unit id="33caf9125270759b9ef9dbfd91c8e100e633839c" translate="yes" xml:space="preserve">
          <source>Assume that ICPLBs are enabled at run time. This has an effect on certain anomaly workarounds. For Linux targets, the default is to assume ICPLBs are enabled; for standalone applications the default is off.</source>
          <target state="translated">Предположим,что ICPLB включены во время выполнения.Это влияет на определенные обходные пути аномалий.Для целей Linux по умолчанию предполагается,что ICPLB включена;для автономных приложений по умолчанию выключена.</target>
        </trans-unit>
        <trans-unit id="b5ac123daea99f10bd295c162e2bdc33dbbb4983" translate="yes" xml:space="preserve">
          <source>Assume that a loop with an exit will eventually take the exit and not loop indefinitely. This allows the compiler to remove loops that otherwise have no side-effects, not considering eventual endless looping as such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed72c79186a186d46e787e25dd72b1da5c105ed8" translate="yes" xml:space="preserve">
          <source>Assume that all Objective-C message dispatches (&lt;code&gt;[receiver
message:arg]&lt;/code&gt;) in this translation unit ensure that the receiver is not &lt;code&gt;nil&lt;/code&gt;. This allows for more efficient entry points in the runtime to be used. This option is only available in conjunction with the NeXT runtime and ABI version 0 or 1.</source>
          <target state="translated">Предположим, что все отправления сообщений Objective-C ( &lt;code&gt;[receiver message:arg]&lt;/code&gt; ) в этой единице трансляции гарантируют, что получатель не равен &lt;code&gt;nil&lt;/code&gt; . Это позволяет использовать более эффективные точки входа во время выполнения. Эта опция доступна только в сочетании со средой выполнения NeXT и ABI версии 0 или 1.</target>
        </trans-unit>
        <trans-unit id="866258482a2aa9fcb54dee6ab333e2e33fa56a9f" translate="yes" xml:space="preserve">
          <source>Assume that all data in static storage can be accessed by LDS / STS instructions. This option has only an effect on reduced Tiny devices like ATtiny40. See also the &lt;code&gt;absdata&lt;/code&gt;&lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;variable attribute&lt;/a&gt;.</source>
          <target state="translated">Предположим, что ко всем данным в статическом хранилище можно получить доступ с помощью инструкций LDS / STS. Этот параметр действует только на устройства Tiny с ограниченным доступом, такие как ATtiny40. См. Также &lt;code&gt;absdata&lt;/code&gt; &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;переменной &lt;/a&gt;absdata .</target>
        </trans-unit>
        <trans-unit id="9ef3d0ef83e6f997acb69f32efa34ce5f18bfd5d" translate="yes" xml:space="preserve">
          <source>Assume that doubles have 8-byte alignment. This is the default.</source>
          <target state="translated">Предположим,что у двойников 8-байтовое выравнивание.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="856f36f37f5770dafc37ec4f5ce9ae4ba43b9ab0" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 32 bits wide.</source>
          <target state="translated">Предположим,что регистры с плавающей точкой имеют ширину 32 бита.</target>
        </trans-unit>
        <trans-unit id="89754b304532c00897fca86b5c5a4a2fdb8ea856" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 64 bits wide.</source>
          <target state="translated">Предположим,что регистры с плавающей точкой имеют ширину 64 бита.</target>
        </trans-unit>
        <trans-unit id="6c5971ed7912aa4bcfc190d25dcfc54913916046" translate="yes" xml:space="preserve">
          <source>Assume that floating-point stores and loads are not likely to cause a conflict when placed into the same instruction group. This option is disabled by default.</source>
          <target state="translated">Предположим,что запасы и нагрузки с плавающей точкой вряд ли приведут к конфликту,если их поместить в одну и ту же группу инструкций.Эта опция отключена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="79ddd95e70fe2bc8d68e335f2358d8d016cca43e" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 32 bits wide.</source>
          <target state="translated">Предположим,что регистры общего назначения имеют ширину 32 бита.</target>
        </trans-unit>
        <trans-unit id="67b1eea988cecf507f4140115cf0f3a04a0b6bc0" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 64 bits wide.</source>
          <target state="translated">Предположим,что регистры общего назначения имеют ширину 64 бита.</target>
        </trans-unit>
        <trans-unit id="d05b8de7cb58ad911a3c660af041154da0f70378" translate="yes" xml:space="preserve">
          <source>Assume that programs cannot safely dereference null pointers, and that no code or data element resides at address zero. This option enables simple constant folding optimizations at all optimization levels. In addition, other optimization passes in GCC use this flag to control global dataflow analyses that eliminate useless checks for null pointers; these assume that a memory access to address zero always results in a trap, so that if a pointer is checked after it has already been dereferenced, it cannot be null.</source>
          <target state="translated">Предположим,что программы не могут безопасно разыменовывать нулевые указатели,и что ни код,ни элемент данных не находится в нулевом адресе.Эта опция обеспечивает простую оптимизацию с постоянным сгибанием на всех уровнях оптимизации.Кроме того,другие проходы оптимизации в GCC используют этот флаг для контроля глобального анализа потока данных,который устраняет бесполезные проверки нулевых указателей;они предполагают,что доступ к памяти с нулевым адресом всегда приводит к ловушке,так что если указатель проверяется после того,как он уже был разыменован,то он не может быть нулевым.</target>
        </trans-unit>
        <trans-unit id="076633874f4c1995b07023b5b94aab209c515c86" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so omit the simulator library (</source>
          <target state="translated">Предположим,что поддержка исполнения была обеспечена,и поэтому опустим библиотеку симулятора (</target>
        </trans-unit>
        <trans-unit id="42823e20bce5001093b19d4ebc090a1f52fb87fe" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so there is no need to include the simulator library (</source>
          <target state="translated">Предположим,что поддержка исполнения была обеспечена и поэтому нет необходимости включать библиотеку симулятора (</target>
        </trans-unit>
        <trans-unit id="0d530f525409fd98b58f0bb247b2945e9f43679e" translate="yes" xml:space="preserve">
          <source>Assume that the current compilation unit represents the whole program being compiled. All public functions and variables with the exception of &lt;code&gt;main&lt;/code&gt; and those merged by attribute &lt;code&gt;externally_visible&lt;/code&gt; become static functions and in effect are optimized more aggressively by interprocedural optimizers.</source>
          <target state="translated">Предположим, что текущая единица компиляции представляет всю компилируемую программу. Все общедоступные функции и переменные, за исключением &lt;code&gt;main&lt;/code&gt; и тех, которые объединены атрибутом &lt;code&gt;externally_visible&lt;/code&gt; становятся статическими функциями и, по сути, более агрессивно оптимизируются межпроцедурными оптимизаторами.</target>
        </trans-unit>
        <trans-unit id="d4cfc093a537b06194880f65fa701bc5be05c19f" translate="yes" xml:space="preserve">
          <source>Assume that the device supports the Read-Modify-Write instructions &lt;code&gt;XCH&lt;/code&gt;, &lt;code&gt;LAC&lt;/code&gt;, &lt;code&gt;LAS&lt;/code&gt; and &lt;code&gt;LAT&lt;/code&gt;.</source>
          <target state="translated">Предположим, что устройство поддерживает инструкции чтения-изменения-записи &lt;code&gt;XCH&lt;/code&gt; , &lt;code&gt;LAC&lt;/code&gt; , &lt;code&gt;LAS&lt;/code&gt; и &lt;code&gt;LAT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="766547e453a1be99c1e3faccd183445d895ac153" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This allows data to be referenced by offset from start of text address instead of GOT since PC-relative addressing is not supported.</source>
          <target state="translated">Предположим,что смещение между текстовым сегментом и сегментом данных фиксировано во время статической связи.Это позволяет ссылаться на данные со смещением от начала текстового адреса вместо GOT,так как PC-относительная адресация не поддерживается.</target>
        </trans-unit>
        <trans-unit id="ebfb14654d3ce6ee7fc14d89650e1df706d43a0e" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This permits using PC-relative addressing operations to access data known to be in the data segment. For non-VxWorks RTP targets, this option is enabled by default. When disabled on such targets, it will enable</source>
          <target state="translated">Предположим,что смещение между текстовым сегментом и сегментом данных фиксировано во время статической связи.Это позволяет использовать операции корреляционной адресации на ПК для доступа к данным,известным в сегменте данных.Для RTP-целей,не относящихся к VxWorks,данная опция включена по умолчанию.При отключении данной опции для таких целей будет включено</target>
        </trans-unit>
        <trans-unit id="38bffa713c2a7cd96b200f3894b2b7a3ab419ebb" translate="yes" xml:space="preserve">
          <source>Assume that the flash memory has a size of &lt;var&gt;num&lt;/var&gt; times 64 KiB.</source>
          <target state="translated">Предположим , что флэш - память имеет размер &lt;var&gt;num&lt;/var&gt; раз 64 КБ.</target>
        </trans-unit>
        <trans-unit id="0381000794bbd2c3b341dcaa9dd877537e5d82e9" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor only supports single-precision operations.</source>
          <target state="translated">Предположим,что сопроцессор с плавающей точкой поддерживает только операции с одинарной точностью.</target>
        </trans-unit>
        <trans-unit id="da28820fdda9574eb1ba106e15f86ccdafa0352f" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor supports double-precision operations. This is the default.</source>
          <target state="translated">Предположим,что сопроцессор с плавающей точкой поддерживает операции двойной точности.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="fdfa0bfee5480efa2b5e12152c0e653e6cc25473" translate="yes" xml:space="preserve">
          <source>Assume that the handler uses a shadow register set, instead of the main general-purpose registers. An optional argument &lt;code&gt;intstack&lt;/code&gt; is supported to indicate that the shadow register set contains a valid stack pointer.</source>
          <target state="translated">Предположим, что обработчик использует набор теневых регистров вместо основных регистров общего назначения. &lt;code&gt;intstack&lt;/code&gt; необязательный аргумент intstack , указывающий, что набор теневых регистров содержит допустимый указатель стека.</target>
        </trans-unit>
        <trans-unit id="cb05f1c18ebd5a07940293ac38328ed8480807dc" translate="yes" xml:space="preserve">
          <source>Assume that the program is arbitrarily large. This is the default.</source>
          <target state="translated">Предположим,что программа произвольно большая.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="bea8e60014028d1c1e2350ea91c13bef18cfe395" translate="yes" xml:space="preserve">
          <source>Assume the incoming stack is aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">Предположим, что входящий стек выровнен по границе 2, возведенной в &lt;var&gt;num&lt;/var&gt; байтов. Если</target>
        </trans-unit>
        <trans-unit id="2b0c018c4bbeac1a835b6bc4f97980f45c5201f9" translate="yes" xml:space="preserve">
          <source>At level &lt;var&gt;2&lt;/var&gt;, the call in the example above is again diagnosed, but this time because with &lt;var&gt;a&lt;/var&gt; equal to a 32-bit &lt;code&gt;INT_MIN&lt;/code&gt; the first &lt;code&gt;%i&lt;/code&gt; directive will write some of its digits beyond the end of the destination buffer. To make the call safe regardless of the values of the two variables, the size of the destination buffer must be increased to at least 34 bytes. GCC includes the minimum size of the buffer in an informational note following the warning.</source>
          <target state="translated">На уровне &lt;var&gt;2&lt;/var&gt; , вызов в приведенном выше примере снова диагностировал, но на этот раз , потому что с равным 32-битным &lt;code&gt;INT_MIN&lt;/code&gt; первой &lt;code&gt;%i&lt;/code&gt; директива будет писать некоторые из его цифр после окончания буфера назначения. Чтобы сделать вызов безопасным независимо от значений двух переменных, размер целевого буфера должен быть увеличен как минимум до 34 байтов. GCC включает минимальный размер буфера в информационную заметку после предупреждения. &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="3ddf0f631ce882bb84e3fb93f118fee7f5a7f5f9" translate="yes" xml:space="preserve">
          <source>At present, GCC only provides support for operations on 32-bit vectors. The vector type associated with 8-bit integer data is usually called &lt;code&gt;v4i8&lt;/code&gt;, the vector type associated with Q7 is usually called &lt;code&gt;v4q7&lt;/code&gt;, the vector type associated with 16-bit integer data is usually called &lt;code&gt;v2i16&lt;/code&gt;, and the vector type associated with Q15 is usually called &lt;code&gt;v2q15&lt;/code&gt;. They can be defined in C as follows:</source>
          <target state="translated">В настоящее время GCC поддерживает операции только с 32-битными векторами. Векторный тип, связанный с 8-битными целочисленными данными, обычно называется &lt;code&gt;v4i8&lt;/code&gt; , векторный тип, связанный с Q7, обычно называется &lt;code&gt;v4q7&lt;/code&gt; , векторный тип, связанный с 16-битными целочисленными данными, обычно называется &lt;code&gt;v2i16&lt;/code&gt; , а векторный тип, связанный с Q15, обычно называется &lt;code&gt;v2q15&lt;/code&gt; . Их можно определить в C следующим образом:</target>
        </trans-unit>
        <trans-unit id="7562b8145986b9d15bbe747f7453ec31fbcb23e3" translate="yes" xml:space="preserve">
          <source>At present, a declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached can only be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">В настоящее время объявление, к которому прикреплен &lt;code&gt;weakref&lt;/code&gt; , может быть только &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4135487f1e326a7c07cb63519ab457040bcc6fd" translate="yes" xml:space="preserve">
          <source>At present, the first parameter in a function prototype must have some type specifier that is not an attribute specifier; this resolves an ambiguity in the interpretation of &lt;code&gt;void f(int
(__attribute__((foo)) x))&lt;/code&gt;, but is subject to change. At present, if the parentheses of a function declarator contain only attributes then those attributes are ignored, rather than yielding an error or warning or implying a single parameter of type int, but this is subject to change.</source>
          <target state="translated">В настоящее время первый параметр в прототипе функции должен иметь некоторый спецификатор типа, который не является спецификатором атрибута; это устраняет двусмысленность в интерпретации &lt;code&gt;void f(int (__attribute__((foo)) x))&lt;/code&gt; , но может быть изменено. В настоящее время, если круглые скобки декларатора функции содержат только атрибуты, тогда эти атрибуты игнорируются, а не выдают ошибку или предупреждение или подразумевают единственный параметр типа int, но это может быть изменено.</target>
        </trans-unit>
        <trans-unit id="aba1eab05ac64c3b09192d2f6e850b4049723108" translate="yes" xml:space="preserve">
          <source>At the user level, the extension is visible with a new storage class keyword: &lt;code&gt;__thread&lt;/code&gt;. For example:</source>
          <target state="translated">На уровне пользователя расширение отображается с новым ключевым словом класса хранения: &lt;code&gt;__thread&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="822a22d01653371bac14c53e07474f5d45325389" translate="yes" xml:space="preserve">
          <source>At this level</source>
          <target state="translated">На этом уровне</target>
        </trans-unit>
        <trans-unit id="87ea658ed4a4a90d1fc99e8e69012153c56f031c" translate="yes" xml:space="preserve">
          <source>At this level, in addition to diagnosing all the same constructs as at level 1, a diagnostic is also issued for placement new expressions that construct an object in the last member of structure whose type is an array of a single element and whose size is less than the size of the object being constructed. While the previous example would be diagnosed, the following construct makes use of the flexible member array extension to avoid the warning at level 2.</source>
          <target state="translated">На этом уровне,помимо диагностики всех тех же конструкций,что и на уровне 1,выдается диагностика на размещение новых выражений,которые строят объект в последнем члене структуры,типом которого является массив одного элемента и размер которого меньше размера строящегося объекта.При диагностике предыдущего примера следующая конструкция использует расширение гибкого массива-членов,чтобы избежать предупреждения на уровне 2.</target>
        </trans-unit>
        <trans-unit id="899a58ab48a1eeb8b5da7677f79db54f17f5ac4a" translate="yes" xml:space="preserve">
          <source>At this level, interprocedural call and return events are displayed, along with the most pertinent state-change events relating to a diagnostic. For example, for a double-&lt;code&gt;free&lt;/code&gt; diagnostic, both calls to &lt;code&gt;free&lt;/code&gt; will be shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d0144240e3a9879fbee890a976db3a3119bfe0" translate="yes" xml:space="preserve">
          <source>At this time GCC tries to detect also a few terminals that are known to not implement the URL feature, and have bugs or at least had bugs in some versions that are still in use, where the URL escapes are likely to misbehave, i.e. print garbage on the screen. That list is currently xfce4-terminal, certain known to be buggy gnome-terminal versions, the linux console, and mingw. This check can be skipped with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bef66661f5c0b03146d1698ca3afb51d9a26fb" translate="yes" xml:space="preserve">
          <source>Atomic built-in functions with memory model.</source>
          <target state="translated">Атомные встроенные функции с моделью памяти.</target>
        </trans-unit>
        <trans-unit id="4ce1364206864236a22c5c48cd625fe86883adb2" translate="yes" xml:space="preserve">
          <source>Atomic types are not permitted for bit-fields.</source>
          <target state="translated">Атомные типы не допускаются для битовых полей.</target>
        </trans-unit>
        <trans-unit id="b41c8daf0a5d584177e036c6b54eb5d698ff31ca" translate="yes" xml:space="preserve">
          <source>Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization most benefits processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">Попытайтесь избежать ложных зависимостей в запланированном коде, используя регистры, оставшиеся после выделения регистров. Эта оптимизация больше всего подходит для процессоров с большим количеством регистров. Однако в зависимости от формата отладочной информации, принятого целью, это может сделать отладку невозможной, поскольку переменные больше не остаются в &amp;laquo;домашнем регистре&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c6f5acede0fbb18382444dea8c6c4247f6477d4a" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to direct calls. This is done both within a procedure and interprocedurally as part of indirect inlining (</source>
          <target state="translated">Попытка преобразования вызовов в виртуальные функции в прямые вызовы.Это делается как в рамках процедуры,так и в межпроцедурном порядке в рамках косвенного встраивания (</target>
        </trans-unit>
        <trans-unit id="23ecd786dc35f08a1baffd99e6e7d5e25ec53b58" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to speculative direct calls. Based on the analysis of the type inheritance graph, determine for a given call the set of likely targets. If the set is small, preferably of size 1, change the call into a conditional deciding between direct and indirect calls. The speculative calls enable more optimizations, such as inlining. When they seem useless after further optimization, they are converted back into original form.</source>
          <target state="translated">Попытка преобразования вызовов виртуальных функций в спекулятивные прямые вызовы.На основе анализа графика наследования типов определите для данного вызова набор вероятных целей.Если набор маленький,желательно 1-го размера,превратить вызов в условное решение между прямыми и непрямыми вызовами.Спекулятивные вызовы позволяют производить больше оптимизаций,например,встраивание.Когда они кажутся бесполезными после дальнейшей оптимизации,они преобразуются обратно в исходную форму.</target>
        </trans-unit>
        <trans-unit id="015c279bf199fbda7e73b9795378a6fd0b0af2c9" translate="yes" xml:space="preserve">
          <source>Attempt to decrease register pressure through register live range shrinkage. This is helpful for fast processors with small or moderate size register sets.</source>
          <target state="translated">Попытайтесь снизить регистровое давление за счет усадки диапазона живой силы регистра.Это полезно для быстрых процессоров с небольшими или умеренными наборами регистров.</target>
        </trans-unit>
        <trans-unit id="687510f6384de354811653c1b3a65669791e13da" translate="yes" xml:space="preserve">
          <source>Attempt to determine location views that can be omitted from location view lists. This requires the compiler to have very accurate insn length estimates, which isn&amp;rsquo;t always the case, and it may cause incorrect view lists to be generated silently when using an assembler that does not support location view lists. The GNU assembler will flag any such error as a &lt;code&gt;view number mismatch&lt;/code&gt;. This is only enabled on ports that define a reliable estimation function.</source>
          <target state="translated">Попытка определить представления местоположения, которые можно исключить из списков представлений местоположения. Это требует, чтобы компилятор имел очень точные оценки длины insn, что не всегда так, и это может привести к тому, что неверные списки представлений будут генерироваться без уведомления при использовании ассемблера, который не поддерживает списки представлений расположения. Ассемблер GNU пометит любую такую ​​ошибку как &lt;code&gt;view number mismatch&lt;/code&gt; . Это доступно только для портов, которые определяют надежную функцию оценки.</target>
        </trans-unit>
        <trans-unit id="aac236b78fdffe9d37dcfcf412e47b1651113242" translate="yes" xml:space="preserve">
          <source>Attempt to keep the stack boundary aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">Попытка держать границу стеки выровненную к 2 , возведенным в &lt;var&gt;num&lt;/var&gt; границы байта. Если</target>
        </trans-unit>
        <trans-unit id="c862c84dcea1c34fb363ef2530e074c7fb9ff011" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants (string constants and floating-point constants) across compilation units.</source>
          <target state="translated">Попытка объединить идентичные константы (строковые и с плавающей точкой)между единицами компиляции.</target>
        </trans-unit>
        <trans-unit id="50e4bd95dd66a112841cf4cd0b134789556e574d" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants and identical variables.</source>
          <target state="translated">Попытайтесь объединить одинаковые константы и одинаковые переменные.</target>
        </trans-unit>
        <trans-unit id="0f797d45d3d320c615fd705a20d8464b1c6f92f0" translate="yes" xml:space="preserve">
          <source>Attempt to minimize stack usage. The compiler attempts to use less stack space, even if that makes the program slower. This option implies setting the</source>
          <target state="translated">Попытайтесь свести к минимуму использование стека.Компилятор пытается использовать меньше пространства стека,даже если это делает программу медленнее.Эта опция подразумевает установку</target>
        </trans-unit>
        <trans-unit id="1d6331b92854e1a7daaaa3b254ef23d3e2705563" translate="yes" xml:space="preserve">
          <source>Attempt to remove redundant extension instructions. This is especially helpful for the x86-64 architecture, which implicitly zero-extends in 64-bit registers after writing to their lower 32-bit half.</source>
          <target state="translated">Попытайтесь удалить избыточные инструкции по расширению.Это особенно полезно для архитектуры x86-64,которая неявно нулирует расширения в 64-битных регистрах после записи в их нижнюю 32-битную половину.</target>
        </trans-unit>
        <trans-unit id="af8cd75ee0ed545b02a70bb0db32f4bb7b0a164a" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled.</source>
          <target state="translated">Попытка преобразовать условные прыжки во внутренних циклах в безветвистые эквиваленты.Цель состоит в удалении управляющего потока из самых внутренних контуров,чтобы улучшить возможность прохождения векторизации для обработки этих контуров.Это включено по умолчанию,если включена векторизация.</target>
        </trans-unit>
        <trans-unit id="a82b9d3f6e114711b5045a6cdf1e499c5d11c4fa" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps into branch-less equivalents. This includes use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics. The use of conditional execution on chips where it is available is controlled by</source>
          <target state="translated">Попытка трансформировать условные прыжки в эквиваленты без ветвей.Это включает в себя использование условных ходов,мин,макс,установку флагов и инструкций абс,а также некоторые трюки,выполняемые стандартной арифметикой.Использование условного исполнения на микросхемах,где оно доступно,контролируется следующими способами</target>
        </trans-unit>
        <trans-unit id="1ffd089c28cbc3f051c86ecbaa3c75b1a01df17f" translate="yes" xml:space="preserve">
          <source>Attempt to utilize both instruction sets at once. This effectively doubles the amount of available registers, and on chips with separate execution units for 387 and SSE the execution resources too. Use this option with care, as it is still experimental, because the GCC register allocator does not model separate functional units well, resulting in unstable performance.</source>
          <target state="translated">Попытайтесь использовать оба набора инструкций одновременно.Это фактически удваивает количество доступных регистров,а на микросхемах с отдельными модулями исполнения для 387 и SSE ресурсы исполнения тоже.Используйте эту опцию с осторожностью,так как она все еще экспериментальная,так как аллокатор регистров GCC плохо моделирует отдельные функциональные узлы,что приводит к нестабильной производительности.</target>
        </trans-unit>
        <trans-unit id="768394a0c657893c518e749955ef528cb8973c45" translate="yes" xml:space="preserve">
          <source>Attribute specifiers may be mixed with type qualifiers appearing inside the &lt;code&gt;[]&lt;/code&gt; of a parameter array declarator, in the C99 construct by which such qualifiers are applied to the pointer to which the array is implicitly converted. Such attribute specifiers apply to the pointer, not to the array, but at present this is not implemented and they are ignored.</source>
          <target state="translated">Спецификаторы атрибутов могут быть смешаны с квалификаторами типа, появляющимися внутри &lt;code&gt;[]&lt;/code&gt; декларатора массива параметров в конструкции C99, с помощью которой такие квалификаторы применяются к указателю, в который неявно преобразуется массив. Такие спецификаторы атрибутов применяются к указателю, а не к массиву, но в настоящее время это не реализовано, и они игнорируются.</target>
        </trans-unit>
        <trans-unit id="f15f9fabc9141a4fd02709ab1f144944da1df77d" translate="yes" xml:space="preserve">
          <source>Attributes considered include &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;cold&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;hot&lt;/code&gt;, &lt;code&gt;leaf&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;nonnull&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;returns_nonnull&lt;/code&gt;, and &lt;code&gt;returns_twice&lt;/code&gt;.</source>
          <target state="translated">Атрибуты рассмотрены , включают &lt;code&gt;alloc_align&lt;/code&gt; , &lt;code&gt;alloc_size&lt;/code&gt; , &lt;code&gt;cold&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;hot&lt;/code&gt; , &lt;code&gt;leaf&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; , &lt;code&gt;nonnull&lt;/code&gt; , &lt;code&gt;noreturn&lt;/code&gt; , &lt;code&gt;nothrow&lt;/code&gt; , &lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;returns_nonnull&lt;/code&gt; и &lt;code&gt;returns_twice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e72cecf4ee93be8444bf26683f3314180b4f20f" translate="yes" xml:space="preserve">
          <source>Augment variable location lists with progressive view numbers implied from the line number table. This enables debug information consumers to inspect state at certain points of the program, even if no instructions associated with the corresponding source locations are present at that point. If the assembler lacks support for view numbers in line number tables, this will cause the compiler to emit the line number table, which generally makes them somewhat less compact. The augmented line number tables and location lists are fully backward-compatible, so they can be consumed by debug information consumers that are not aware of these augmentations, but they won&amp;rsquo;t derive any benefit from them either.</source>
          <target state="translated">Дополните списки расположения переменных прогрессивными номерами просмотров, указанными в таблице номеров строк. Это позволяет потребителям отладочной информации проверять состояние в определенных точках программы, даже если в этой точке нет инструкций, связанных с соответствующими исходными местоположениями. Если ассемблер не поддерживает номера представлений в таблицах номеров строк, это приведет к тому, что компилятор выдаст таблицу номеров строк, что обычно делает их несколько менее компактными. Таблицы расширенных номеров строк и списки местоположений полностью обратно совместимы, поэтому они могут использоваться потребителями отладочной информации, которые не знают об этих расширениях, но они также не получат от них никакой пользы.</target>
        </trans-unit>
        <trans-unit id="e028ddf293b9280450ea608fcf02b6afb803a5cf" translate="yes" xml:space="preserve">
          <source>Automatically convert relative source file names to absolute path names in the</source>
          <target state="translated">Автоматически преобразовывает относительные имена файлов-источников в абсолютные имена путей в</target>
        </trans-unit>
        <trans-unit id="5484fc94aa2d1ceccb816e9c671bdaec50d90ef7" translate="yes" xml:space="preserve">
          <source>Average number of iterations of a loop.</source>
          <target state="translated">Среднее количество итераций цикла.</target>
        </trans-unit>
        <trans-unit id="04f04d96d845a90ad835e69c3cba86443a61a89a" translate="yes" xml:space="preserve">
          <source>Avoid or allow generating memory accesses that may not be aligned on a natural object boundary as described in the architecture specification.</source>
          <target state="translated">Избегайте или разрешайте генерировать доступы к памяти,которые могут быть не выровнены по границе естественного объекта,как описано в спецификации архитектуры.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="25ec48c867ed8bb8e6f96a8b43aad4372bc4578a" translate="yes" xml:space="preserve">
          <source>B register</source>
          <target state="translated">регистр B</target>
        </trans-unit>
        <trans-unit id="cde782be8b675144b1c3a413d952e5058ca53d38" translate="yes" xml:space="preserve">
          <source>BL</source>
          <target state="translated">BL</target>
        </trans-unit>
        <trans-unit id="7a64a2253d2959f0bf9362ab5d3438b38d98d231" translate="yes" xml:space="preserve">
          <source>BMI instructions.</source>
          <target state="translated">Инструкции по BMI.</target>
        </trans-unit>
        <trans-unit id="a694b7ba8977f0d1b0d7c872c114539da755bd3b" translate="yes" xml:space="preserve">
          <source>BMI2 instructions.</source>
          <target state="translated">Инструкции BMI2.</target>
        </trans-unit>
        <trans-unit id="bfdb06081cf1ce665b573d70cc38b7b454902ff9" translate="yes" xml:space="preserve">
          <source>BRIG files (binary representation of HSAIL).</source>
          <target state="translated">BRIG-файлы (двоичное представление HSAIL).</target>
        </trans-unit>
        <trans-unit id="089ea9746c8cbdc04b34721f820ba603e6881ff2" translate="yes" xml:space="preserve">
          <source>Base pointer register (r28&amp;ndash;r31)</source>
          <target state="translated">Регистр базового указателя (r28 &amp;ndash; r31)</target>
        </trans-unit>
        <trans-unit id="92f76287d800c12dfd6b51ad7e80eed03e92c213" translate="yes" xml:space="preserve">
          <source>Base::Base</source>
          <target state="translated">Base::Base</target>
        </trans-unit>
        <trans-unit id="9039faeb6333b5e373bf646f9ff036f287abc6be" translate="yes" xml:space="preserve">
          <source>Base::operator=</source>
          <target state="translated">Base::operator=</target>
        </trans-unit>
        <trans-unit id="7b3a608459615b9bc19c9d4a294c3d2c0cd4a8a0" translate="yes" xml:space="preserve">
          <source>Basic use of constraints.</source>
          <target state="translated">Основное использование ограничений.</target>
        </trans-unit>
        <trans-unit id="d5770040433fcf2fed9fca7319c3ac627f6efe91" translate="yes" xml:space="preserve">
          <source>Be aware of this when performing timing tests, for instance the following loop can be completely removed, provided &lt;code&gt;some_expression&lt;/code&gt; can provably not change any global state.</source>
          <target state="translated">Помните об этом при выполнении тестов времени, например, следующий цикл может быть полностью удален, при условии, что &lt;code&gt;some_expression&lt;/code&gt; , очевидно, не может изменить какое-либо глобальное состояние.</target>
        </trans-unit>
        <trans-unit id="6d4c386efa741fabb074be3b34ff11b267e4e0d7" translate="yes" xml:space="preserve">
          <source>Be aware that headers from outside your project, in particular system headers and headers from any other library you use, may not be expecting to be compiled with visibility other than the default. You may need to explicitly say &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; before including any such headers.</source>
          <target state="translated">Имейте в виду, что заголовки извне вашего проекта, в частности системные заголовки и заголовки из любой другой библиотеки, которую вы используете, могут не рассчитывать на компиляцию с видимостью, отличной от установленной по умолчанию. Возможно, вам потребуется явно &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; прежде чем включать такие заголовки.</target>
        </trans-unit>
        <trans-unit id="b31e54ef88fe124b0da9af9ee2524cfb6800e5f0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__builtin_longjmp&lt;/code&gt; depends on the function return mechanism to restore the stack context, it cannot be called from the same function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt; to initialize &lt;var&gt;buf&lt;/var&gt;. It can only be called from a function called (directly or indirectly) from the function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;__builtin_longjmp&lt;/code&gt; зависит от механизма возврата функции для восстановления контекста стека, его нельзя вызвать из той же функции, которая вызывает &lt;code&gt;__builtin_setjmp&lt;/code&gt; для инициализации &lt;var&gt;buf&lt;/var&gt; . Его можно вызвать только из функции, вызываемой (прямо или косвенно) из функции, вызывающей &lt;code&gt;__builtin_setjmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d94ff60e2bbcd755c2d21600b1c5beacc8d88e0e" translate="yes" xml:space="preserve">
          <source>Because of the interactions between synchronization and exception handling, you can only use &lt;code&gt;@synchronized&lt;/code&gt; when compiling with exceptions enabled, that is with the command line option</source>
          <target state="translated">Из-за взаимодействия между синхронизацией и обработкой исключений вы можете использовать &lt;code&gt;@synchronized&lt;/code&gt; только при компиляции с включенными исключениями, то есть с параметром командной строки</target>
        </trans-unit>
        <trans-unit id="bc31609fad1f0a543a7bf312e8fc7b4e085e75b6" translate="yes" xml:space="preserve">
          <source>Because of the special nature of the flag output operands, the constraint may not include alternatives.</source>
          <target state="translated">В связи с особой природой операндов вывода флага,ограничение может не включать в себя альтернативы.</target>
        </trans-unit>
        <trans-unit id="74b7dab219d7dd89ab8e51f25903de3035d7b00a" translate="yes" xml:space="preserve">
          <source>Because of the way GCC instruments calls, a call count can be shown after a line with no individual blocks. As you can see, line 33 contains a basic block that was not executed.</source>
          <target state="translated">Из-за способа вызова инструментов GCC счетчик вызовов может отображаться после линии без отдельных блоков.Как видно,линия 33 содержит основной блок,который не был выполнен.</target>
        </trans-unit>
        <trans-unit id="ba975e496f98093e5f2ea388a49453725d139a4b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;asm&lt;/code&gt; statement unconditionally transfers control out of the function, control never reaches the end of the function body. The &lt;code&gt;__builtin_unreachable&lt;/code&gt; is in fact unreachable and communicates this fact to the compiler.</source>
          <target state="translated">Поскольку оператор &lt;code&gt;asm&lt;/code&gt; безоговорочно передает управление из функции, управление никогда не достигает конца тела функции. &lt;code&gt;__builtin_unreachable&lt;/code&gt; фактически недостижимый и сообщает об этом факте компилятора.</target>
        </trans-unit>
        <trans-unit id="a314cc1449bd666eda6884b69e668c28f95c1087" translate="yes" xml:space="preserve">
          <source>Before you can use this option, you must first generate profiling information. See &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Instrumentation Options&lt;/a&gt;, for information about the</source>
          <target state="translated">Прежде чем вы сможете использовать эту опцию, вы должны сначала создать информацию профилирования. См. Раздел &amp;laquo; &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Параметры инструментария&amp;raquo;&lt;/a&gt; для получения информации о</target>
        </trans-unit>
        <trans-unit id="5ba07a31df23960760847e555518779312499558" translate="yes" xml:space="preserve">
          <source>Below</source>
          <target state="translated">Below</target>
        </trans-unit>
        <trans-unit id="5788148d39b8d5244dcdc29f7a93a22a6334768d" translate="yes" xml:space="preserve">
          <source>Besides declarations, the file indicates, in comments, the origin of each declaration (source file and line), whether the declaration was implicit, prototyped or unprototyped (&amp;lsquo;</source>
          <target state="translated">Помимо объявлений, файл указывает в комментариях происхождение каждого объявления (исходный файл и строку), было ли объявление неявным, прототипированным или незапрототипированным ('</target>
        </trans-unit>
        <trans-unit id="51eccbcd60621399284c614907bba67ce4fca17c" translate="yes" xml:space="preserve">
          <source>Beware that on some ELF systems this attribute is unsuitable for global functions in shared libraries with lazy binding (which is the default). Lazy binding sends the first call via resolving code in the loader, which might assume EAX, EDX and ECX can be clobbered, as per the standard calling conventions. Solaris 8 is affected by this. Systems with the GNU C Library version 2.1 or higher and FreeBSD are believed to be safe since the loaders there save EAX, EDX and ECX. (Lazy binding can be disabled with the linker or the loader if desired, to avoid the problem.)</source>
          <target state="translated">Остерегайтесь,что на некоторых ELF системах этот атрибут непригоден для глобальных функций в разделяемых библиотеках с ленивым связыванием (что является значением по умолчанию).Ленивая привязка посылает первый вызов через разрешающий код в загрузчике,который может предполагать,что EAX,EDX и ECX могут быть забиты,в соответствии со стандартными соглашениями о вызовах.Это влияет на Solaris 8.Считается,что системы с библиотекой GNU C Library версии 2.1 или выше и FreeBSD безопасны,так как там загрузчики сохраняют EAX,EDX и ECX.(Ленивая привязка может быть отключена при желании компоновщиком или загрузчиком,чтобы избежать проблемы).</target>
        </trans-unit>
        <trans-unit id="2c5d61cd9cd2849c270a6af03ebe1306ad2048ca" translate="yes" xml:space="preserve">
          <source>Binary Compatibility</source>
          <target state="translated">Двоичная совместимость</target>
        </trans-unit>
        <trans-unit id="8668d27514898ff49d03fb634b072fd0aba7e0f7" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operations.</source>
          <target state="translated">Двоичные арифметические операции.</target>
        </trans-unit>
        <trans-unit id="18e9b92cdcd75a69e0946923d3da4f8d0a7fd71d" translate="yes" xml:space="preserve">
          <source>Binary compatibility encompasses several related concepts:</source>
          <target state="translated">Двоичная совместимость включает в себя несколько взаимосвязанных концепций:</target>
        </trans-unit>
        <trans-unit id="f8ed98dae9970ec4cee447405cb8c658f46ef706" translate="yes" xml:space="preserve">
          <source>Binary constants using the &amp;lsquo;</source>
          <target state="translated">Бинарные константы с использованием символа '</target>
        </trans-unit>
        <trans-unit id="666bffac0affe44914b807024f7928a6d6ca6941" translate="yes" xml:space="preserve">
          <source>Bind references to global symbols when building a shared object. Warn about any unresolved references (unless overridden by the link editor option</source>
          <target state="translated">Привязывайте ссылки на глобальные символы при построении общего объекта.Предупреждать о любых неразрешенных ссылках (если только они не переопределены опцией редактора ссылок</target>
        </trans-unit>
        <trans-unit id="628682c1112ff8669d8fed436fe1daac74760ad6" translate="yes" xml:space="preserve">
          <source>Bit reversal. Return the result of reversing the bits in &lt;var&gt;value&lt;/var&gt;. Bit 15 is swapped with bit 0, bit 14 is swapped with bit 1, and so on.</source>
          <target state="translated">Смена битов. Возвращает результат перестановки битов в &lt;var&gt;value&lt;/var&gt; . Бит 15 заменяется битом 0, бит 14 заменяется битом 1 и так далее.</target>
        </trans-unit>
        <trans-unit id="2eb3706f981c5da19b9c626f35ee7ccc246608e1" translate="yes" xml:space="preserve">
          <source>Bitwise operators act on the representation of the value including both the sign and value bits, where the sign bit is considered immediately above the highest-value value bit. Signed &amp;lsquo;</source>
          <target state="translated">Поразрядные операторы воздействуют на представление значения, включая биты знака и значения, где бит знака считается непосредственно над битом значения самого высокого значения. Подпись '</target>
        </trans-unit>
        <trans-unit id="8b063c3045af1663a8359f63f1ffd9a1d853789c" translate="yes" xml:space="preserve">
          <source>Blackfin family&amp;mdash;</source>
          <target state="translated">Семья Блэкфин&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="0daa776b5dad37eac562c1bddec1cfa040024e9a" translate="yes" xml:space="preserve">
          <source>Borland C++ solved the template instantiation problem by adding the code equivalent of common blocks to their linker; the compiler emits template instances in each translation unit that uses them, and the linker collapses them together. The advantage of this model is that the linker only has to consider the object files themselves; there is no external complexity to worry about. The disadvantage is that compilation time is increased because the template code is being compiled repeatedly. Code written for this model tends to include definitions of all templates in the header file, since they must be seen to be instantiated.</source>
          <target state="translated">Borland C++решил проблему инстанцирования шаблонов,добавив в компоновщик код,эквивалентный обычным блокам;компилятор испускает экземпляры шаблонов в каждом модуле трансляции,который их использует,а компоновщик свертывает их вместе.Преимущество данной модели в том,что компоновщик должен учитывать только сами объектные файлы;нет никакой внешней сложности,о которой стоит беспокоиться.Недостаток заключается в том,что увеличивается время компиляции,так как код шаблона компилируется многократно.Код,написанный для данной модели,имеет тенденцию включать определения всех шаблонов в заголовочный файл,так как их нужно видеть инстанцированными.</target>
        </trans-unit>
        <trans-unit id="200e3a355b82a42f3341fd59904fc5750775b807" translate="yes" xml:space="preserve">
          <source>Borland model</source>
          <target state="translated">модель Borland</target>
        </trans-unit>
        <trans-unit id="06b22f59b253dcf9c37ea4fe24c6526c4dd1e47c" translate="yes" xml:space="preserve">
          <source>Both global and local variables can be associated with a register. The consequences of performing this association are very different between the two, as explained in the sections below.</source>
          <target state="translated">С регистром могут быть связаны как глобальные,так и локальные переменные.Последствия выполнения этой ассоциации весьма различны,как это объясняется в разделах ниже.</target>
        </trans-unit>
        <trans-unit id="fc4416d6a83edb82efd0f4cdffd08c5cd70ca428" translate="yes" xml:space="preserve">
          <source>Bound on number of candidates for induction variables, below which all candidates are considered for each use in induction variable optimizations. If there are more candidates than this, only the most relevant ones are considered to avoid quadratic time complexity.</source>
          <target state="translated">Привязанный к числу кандидатов на вводные переменные,ниже которого рассматриваются все кандидаты для каждого использования при оптимизации вводных переменных.При наличии большего числа кандидатов,чем это,во избежание квадратичной временной сложности рассматриваются только наиболее актуальные из них.</target>
        </trans-unit>
        <trans-unit id="430f77e04bd4e8702495c79a5ebb639d2a4812c8" translate="yes" xml:space="preserve">
          <source>Bound on size of expressions used in the scalar evolutions analyzer. Large expressions slow the analyzer.</source>
          <target state="translated">Связанный с размером выражений,используемых в анализаторе скалярных эволюций.Большие выражения замедляют работу анализатора.</target>
        </trans-unit>
        <trans-unit id="f0e549afa5762802ff68ea72f123883ebb295578" translate="yes" xml:space="preserve">
          <source>Bound on the complexity of the expressions in the scalar evolutions analyzer. Complex expressions slow the analyzer.</source>
          <target state="translated">Связано со сложностью выражений в анализаторе скалярных эволюций.Сложные выражения замедляют работу анализатора.</target>
        </trans-unit>
        <trans-unit id="c2a6a8fa6e2e8a317cd5dd66c604413295e3eb45" translate="yes" xml:space="preserve">
          <source>Bound on the cost of an expression to compute the number of iterations.</source>
          <target state="translated">Связанная со стоимостью выражения для вычисления количества итераций.</target>
        </trans-unit>
        <trans-unit id="26981c43732b427e5b2eae3c3cb43a791d6ce820" translate="yes" xml:space="preserve">
          <source>Brain half-precision floating-point instructions. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb1b62c34f820227fd0537f593962386bf2cc61" translate="yes" xml:space="preserve">
          <source>Branch register</source>
          <target state="translated">Реестр филиалов</target>
        </trans-unit>
        <trans-unit id="a833b9b5c7959a93636f56f73df394e8d3c434e8" translate="yes" xml:space="preserve">
          <source>Branches are present only with &lt;var&gt;-b&lt;/var&gt; option. Fields of the &lt;var&gt;line&lt;/var&gt; element have following semantics:</source>
          <target state="translated">Ветви присутствуют только с опцией &lt;var&gt;-b&lt;/var&gt; . Поля &lt;var&gt;line&lt;/var&gt; элемента имеют следующую семантику:</target>
        </trans-unit>
        <trans-unit id="a6495e1aabddcd6526141ce6efe62824f5a7eae3" translate="yes" xml:space="preserve">
          <source>Brief list of all options, without explanations.</source>
          <target state="translated">Краткий список всех вариантов,без объяснений.</target>
        </trans-unit>
        <trans-unit id="654ffe48f6054af226250c2aa3867b5fc4c80bcc" translate="yes" xml:space="preserve">
          <source>Bugs we will fix later.</source>
          <target state="translated">Ошибки мы исправим позже.</target>
        </trans-unit>
        <trans-unit id="de5bfe3fd9b6538bfa34acbeb7a505866d87ffce" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core A of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core A, and the macro &lt;code&gt;__BFIN_COREA&lt;/code&gt; is defined. This option can only be used in conjunction with</source>
          <target state="translated">Создайте автономное приложение для ядра A BF561 при использовании модели программирования &amp;laquo;одно приложение на ядро&amp;raquo;. Для поддержки Core A используются правильные стартовые файлы и скрипты ссылок, и определен макрос &lt;code&gt;__BFIN_COREA&lt;/code&gt; . Этот параметр можно использовать только вместе с</target>
        </trans-unit>
        <trans-unit id="6320906d93f259f860a69b97e3abeb20581c59d7" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core B of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core B, and the macro &lt;code&gt;__BFIN_COREB&lt;/code&gt; is defined. When this option is used, &lt;code&gt;coreb_main&lt;/code&gt; should be used instead of &lt;code&gt;main&lt;/code&gt;. This option can only be used in conjunction with</source>
          <target state="translated">Создайте автономное приложение для ядра B BF561 при использовании модели программирования &amp;laquo;одно приложение на ядро&amp;raquo;. Для поддержки Core B используются правильные стартовые файлы и скрипты ссылок, и определен макрос &lt;code&gt;__BFIN_COREB&lt;/code&gt; . При использовании этой опции, &lt;code&gt;coreb_main&lt;/code&gt; следует использовать вместо &lt;code&gt;main&lt;/code&gt; . Этот параметр можно использовать только вместе с</target>
        </trans-unit>
        <trans-unit id="e010c48c400b5b030ac052e6ece9a00978fee8f4" translate="yes" xml:space="preserve">
          <source>Build a standalone application for SDRAM. Proper start files and link scripts are used to put the application into SDRAM, and the macro &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; is defined. The loader should initialize SDRAM before loading the application.</source>
          <target state="translated">Создайте отдельное приложение для SDRAM. Для помещения приложения в SDRAM используются правильные файлы запуска и сценарии связывания, а также определяется макрос &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; . Загрузчик должен инициализировать SDRAM перед загрузкой приложения.</target>
        </trans-unit>
        <trans-unit id="93828509d9639cf155e61322b59daf0187eb136a" translate="yes" xml:space="preserve">
          <source>Build a standalone application for multicore Blackfin processors. This option causes proper start files and link scripts supporting multicore to be used, and defines the macro &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt;. It can only be used with</source>
          <target state="translated">Создайте автономное приложение для многоядерных процессоров Blackfin. Этот параметр вызывает использование правильных файлов запуска и сценариев связи, поддерживающих многоядерность, и определяет макрос &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt; . Его можно использовать только с</target>
        </trans-unit>
        <trans-unit id="f3ef0f891e9c255998243907e244b5b488c698cb" translate="yes" xml:space="preserve">
          <source>Build-in macro that resolves to a decimal number that identifies the architecture and depends on the</source>
          <target state="translated">Встроенный макрос,который преобразуется в десятичное число,идентифицирующее архитектуру и зависящее от</target>
        </trans-unit>
        <trans-unit id="2d34970179e2bcbb0ecc79b090b87f98043678d3" translate="yes" xml:space="preserve">
          <source>Building data dependencies is expensive for very large loops. This parameter limits the number of data references in loops that are considered for data dependence analysis. These large loops are no handled by the optimizations using loop data dependencies.</source>
          <target state="translated">Зависимости строительных данных дорогостоящи для очень больших петель.Этот параметр ограничивает количество ссылок на данные в циклах,которые рассматриваются для анализа зависимости данных.Такие большие циклы не обрабатываются оптимизациями,использующими циклические зависимости данных.</target>
        </trans-unit>
        <trans-unit id="2d296efa2545fd43e5ab712c86bbcd120531a39c" translate="yes" xml:space="preserve">
          <source>Built-in Function:  &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt; ()</source>
          <target state="translated">Встроенная функция: &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="77cea55a1a3d5467f8414836cb770a0b2fa5b655" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_add_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_add_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="65f1c3be3667c2fa06bb169c518b6d4d03675142" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_and_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_and_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="a03055a0cd281ae02bbb4f07ca3c585700a7af0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_exchange_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="6eb648ab26ef838877bc3cc4ee57b8ff3c3ec10d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_add&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_add&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="caf737dd7d0b652a623f88bdd6fd64fcd63596e4" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_and&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_and&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="f9b1604908ceaddf5e7b79ba9db81f0f1c23485e" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="45f4365ebf0124211f5cb2705e77bd2bfd90775d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_or&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_or&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="cf646256d882577bfba56a5678e5b9426274e60b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="5041b1cf8f3a6577d287aff4388265cba990c15b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="75268ab0697eb9af1dc5c6b541d4d1ba8ac4dbf6" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_load_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_load_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, int memorder)</target>
        </trans-unit>
        <trans-unit id="cd00e4ef24b741036ea643da78829d2849f8f8d7" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="a4657eb44924236cf67282c47ad4d932f5594137" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_or_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_or_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="57b4ecf7d291340ab5ae6cc114b7f02d58e8a705" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="a52f64419e32735eabc4e3c18aa68dedfb2e4625" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="1167cb7b44d7d9f620598ea0aefcbfdf9dc55a1f" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt; (&lt;var&gt;call_exp&lt;/var&gt;, &lt;var&gt;pointer_exp&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt; ( &lt;var&gt;call_exp&lt;/var&gt; , &lt;var&gt;pointer_exp&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="34f799a7c8358da11b0de0991867b1ca62dd416b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_choose_expr&lt;/strong&gt; (&lt;var&gt;const_exp&lt;/var&gt;, &lt;var&gt;exp1&lt;/var&gt;, &lt;var&gt;exp2&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_choose_expr&lt;/strong&gt; ( &lt;var&gt;const_exp&lt;/var&gt; , &lt;var&gt;exp1&lt;/var&gt; , &lt;var&gt;exp2&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="11e363a3b892d8f6c1c1fdfdd845f80862a3606b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_complex&lt;/strong&gt; (&lt;var&gt;real&lt;/var&gt;, &lt;var&gt;imag&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_complex&lt;/strong&gt; ( &lt;var&gt;real&lt;/var&gt; , &lt;var&gt;imag&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="9eec0865162048e6dccab85fb3d740aa5f07fc05" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; val, &lt;var&gt;type&lt;/var&gt; failval)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; val, &lt;var&gt;type&lt;/var&gt; failval)</target>
        </trans-unit>
        <trans-unit id="7c5c7616bd765dd4fc8d843ce99908ad16336f51" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_tgmath&lt;/strong&gt; (&lt;var&gt;functions&lt;/var&gt;, &lt;var&gt;arguments&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_tgmath&lt;/strong&gt; ( &lt;var&gt;functions&lt;/var&gt; , &lt;var&gt;arguments&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="e3600affbf40f82a1f599528ce0f72402f629874" translate="yes" xml:space="preserve">
          <source>Built-in Function: Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt; (void * x)</source>
          <target state="translated">Встроенная функция: Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt; (void * x)</target>
        </trans-unit>
        <trans-unit id="b7ca6e3021fea0b720388d29d28e89de6177efaa" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bf8fbba0296cd046f79b2f8fac454e9f96b680c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="ad3f5c8f497e0e257636ccbaf6459ad1ad8e6479" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="2d12b2517571e9887a8920d94ebf233b53b0d3e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="c4f59dbda6a0f6f12e013b7d8146bb95b52fddbf" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="dcf12c95c5e2671a78a61f716ad8c91e6ab3dca2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="e065d1bdd11d40eb46afaa76c7e3c275e0e7c656" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bc1ad27f368302d827ffdedc2f161e1a34576916" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4f4a5dc00bc657abe7ad80938a7d60c8e79b5015" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: _Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="28b60d24ae373b1240786dec7b198434f539e010" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: _Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bf9f5f175d78dc2baeeae0348c4b4da7826acad2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="d8897a35cb1a3842c5a7b59ff4525f61eb36974a" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="1bd15fd91da1a9d9a87216c52e010f17bc3d22e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="615e03fdb9ea794729a2a1d7c358b1e301921c3b" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="f520d1247e2979f87ba6e5662e70795dbd438963" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt; (size_t size, void * ptr)</target>
        </trans-unit>
        <trans-unit id="24b1fe88fa6197e2c0740249ab472fde949dc447" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; *desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * ожидаемый, &lt;var&gt;type&lt;/var&gt; * желаемый, bool weak, int success_memorder, int failure_memorder)</target>
        </trans-unit>
        <trans-unit id="e0cae369ba572d6fc730f1208ec5ebfd8c31b5c9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * ожидаемый, &lt;var&gt;type&lt;/var&gt; желаемый, bool weak, int success_memorder, int failure_memorder)</target>
        </trans-unit>
        <trans-unit id="e6ff9b335ec817f16bd5f09bc44d64b4868726b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt; (size_t size, void * ptr)</target>
        </trans-unit>
        <trans-unit id="24aee6114b477fd331dab8c2aef844fb97f49851" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt; (void *ptr, int memorder)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt; (void * ptr, int memorder)</target>
        </trans-unit>
        <trans-unit id="64b8a4ae04512641547c12a9c73d39675cb460a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; * res)</target>
        </trans-unit>
        <trans-unit id="af59554b89a8bf55a3dc48af48346f20f06e852a" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</target>
        </trans-unit>
        <trans-unit id="be98828c48e0d16aa6b6e2421edf84970dc86a6f" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt; (&lt;var&gt;type-or-expression&lt;/var&gt;, &lt;var&gt;attribute&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt; ( &lt;var&gt;type-or-expression&lt;/var&gt; , &lt;var&gt;attribute&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="b7e50b8a64da2b188793a4579bb5cae5cac82268" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="ee9d3aabacf2156e5d393cd93749ff7c8037d66e" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; * res)</target>
        </trans-unit>
        <trans-unit id="8fd735437fc9239fd342fe45001594bf9731cdde" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</target>
        </trans-unit>
        <trans-unit id="25ee4265411f06ce5b584d4448bc72ef70be2921" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt; (int a, int b, int * res)</target>
        </trans-unit>
        <trans-unit id="69472084a70d9c551110645ab2de32722f859a56" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt; (long int a, long int b, long int * res)</target>
        </trans-unit>
        <trans-unit id="d167da624174d67a584837afb39ffafce3529192" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int * res)</target>
        </trans-unit>
        <trans-unit id="0751d990e1a6176428723a69b8b9d35eb80fd837" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt; (int a, int b, int * res)</target>
        </trans-unit>
        <trans-unit id="956b1e662b4c40d70010047e2d0274713e3963f3" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt; (long int a, long int b, long int * res)</target>
        </trans-unit>
        <trans-unit id="90b14c01667b17099ca43e693ecf1b190d3e0c9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int * res)</target>
        </trans-unit>
        <trans-unit id="77b2f488874750806435b3aaff4f191420925191" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt; (int a, int b, int * res)</target>
        </trans-unit>
        <trans-unit id="49724eb9cf1b5f433d9a763058afdd03539a15c8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt; (long int a, long int b, long int * res)</target>
        </trans-unit>
        <trans-unit id="8bb17f1956b296109f50ac2e4c7c8a50ec613924" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int * res)</target>
        </trans-unit>
        <trans-unit id="3ca0d6297a605dc41e2b859a3577a44be6641a95" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; * res)</target>
        </trans-unit>
        <trans-unit id="cc3ccbf74e07a994d7fa1a99c72273b8a5afff58" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</target>
        </trans-unit>
        <trans-unit id="5b02b9649ef1800e43226f7e7109d8bbef8357dc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int * res)</target>
        </trans-unit>
        <trans-unit id="567411aa095944ed062923c573393ad7b9494fcc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int * res)</target>
        </trans-unit>
        <trans-unit id="a7d580478c24cd4b2a59ce2c1f75d3bbd1e01675" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int * res)</target>
        </trans-unit>
        <trans-unit id="4df720b89a79aa504ee2325733fecf62f5d154df" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int * res)</target>
        </trans-unit>
        <trans-unit id="127b7aa724932fc0c15543b161cf5ca336f40c65" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int * res)</target>
        </trans-unit>
        <trans-unit id="6e0e5de085f1421cd056a7b7c2d1ac4593a791e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int * res)</target>
        </trans-unit>
        <trans-unit id="43f0099aa9a654a142bfe318e5e28643d8ddc6f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int * res)</target>
        </trans-unit>
        <trans-unit id="1c5542c5653c759c2ffcd0eb56e8e4fce2653611" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int * res)</target>
        </trans-unit>
        <trans-unit id="8967205f7b6c405e734e918e4030fc20dcc7a6e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">Встроенная функция: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int * res)</target>
        </trans-unit>
        <trans-unit id="3d3ebe01d55449070f5b00bc45933b6ab0472f70" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt; ()</source>
          <target state="translated">Встроенная функция: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="0721ec3a797458f28da3b2711e9fc2d2af1823e2" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt; ()</source>
          <target state="translated">Встроенная функция: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="2a1712d1ad359c0cac12cd7a3537116bd9e795fc" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="ffafe4d74af74fb9ca60ea9821704b751632b93c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="2864a0d09a57cc7f91ca4ff8697942e0585349f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="51bc6d3e017f472618e17d8b483f22c00009407c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="b40603712a54f648b2195d490214834e3f8465f8" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt; (double, int)</source>
          <target state="translated">Встроенная функция: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt; (double, int)</target>
        </trans-unit>
        <trans-unit id="37264a6694867df8b96fcd2a07266108a13c8c2e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="605b7b7bd5e72cf972739ddb673591e051dadcd8" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="a84c6b7adfcd7dc51b670ecde42ed816377e7198" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="ae6f3577a561b5595beef7b2c40d9183bbecdc53" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="a17547d96b5dcfda1585e7b927ed2efd4413b34e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt; (float, int)</source>
          <target state="translated">Встроенная функция: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt; (float, int)</target>
        </trans-unit>
        <trans-unit id="5af70608a64ebe69db59d9a08864316c44173d0e" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt; ()</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="48642fe0ecb713fe1c2c62aceb4756a077c1f773" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt; (void *&lt;var&gt;val&lt;/var&gt;, int &lt;var&gt;alignval&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt; (void * &lt;var&gt;val&lt;/var&gt; , int &lt;var&gt;alignval&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="d03ad02fdd87a3d6c105f1b3776333e8f10a10d5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt; , int &lt;var&gt;b&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="9c45a4bbd1df9874258bef23963c99d6fdf07ecc" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="343cfc12f31c0a60920faf8b433b92fcf3f860cf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="4d84191dd5a2bd1c0e1ed8ebf20f4a6e76b3cbe6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt; (int x)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="26c48a9f003c2411e7dd88432db5f58cb7b19302" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt; (long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt; (long)</target>
        </trans-unit>
        <trans-unit id="def7076c73776e0b25f88bdee6855cecbffd2e2a" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt; (long long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt; (long long)</target>
        </trans-unit>
        <trans-unit id="68a0ab60ba16fc861473b90def46ecb8b60b639d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt; (unsigned int x)</target>
        </trans-unit>
        <trans-unit id="af52cee1c123c25328e32f99b41a08f4a5682992" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt; (беззнаковое длинное)</target>
        </trans-unit>
        <trans-unit id="f3a7c4157a06fcdbaf2b34c2852b5f5191d70ac6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt; (unsigned long long)</target>
        </trans-unit>
        <trans-unit id="e47a14a24701e5c3353b9003a2bdd96c5e473a94" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt; (&lt;var&gt;exp&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt; ( &lt;var&gt;exp&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="ef14ea6a7a4d27be1b6d59915aed4bf7b4b1a9b6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char * &lt;var&gt;cpuname&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="b3f1d6da484baf586ba4417cd2ac456d3490d574" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char * &lt;var&gt;cpuname&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="8f5e90517840f43dd21b0d12105cc6839b7ba276" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; ( &lt;var&gt;feature&lt;/var&gt; const char * )</target>
        </trans-unit>
        <trans-unit id="be485791899d037b9a8263a3418dab2b9ad4f3b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; ( &lt;var&gt;feature&lt;/var&gt; const char * )</target>
        </trans-unit>
        <trans-unit id="7f22b95a5cdd587669aed9814a5480962c20cb7d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt; (unsigned int x)</target>
        </trans-unit>
        <trans-unit id="8e1e06b0d6fb4ae3123c409271d97e77380c487c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt; (беззнаковое длинное)</target>
        </trans-unit>
        <trans-unit id="20a1238733f66fff846c6029aaa32b6b42066621" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt; (unsigned long long)</target>
        </trans-unit>
        <trans-unit id="0937729bdd117da89bde58b2fd5056203d7a7e12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt; (int x)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="c820dda274694fd7c04aa653b01ff9cf75ba5bae" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt; (long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt; (long)</target>
        </trans-unit>
        <trans-unit id="0419174c77d9db8a178954419d9e7c6e3dc80183" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt; (long long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt; (long long)</target>
        </trans-unit>
        <trans-unit id="d32b1e79ff752f0a0ce225c7feb84f484de727e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt; (int, int, int, int, int, ...)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt; (int, int, int, int, int, ...)</target>
        </trans-unit>
        <trans-unit id="e67b5cb4d37226ea2da9240fb2bf4c5fbfb5a8e1" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt; (int x)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="6e97eb7d6696130c1b12f3a195f09c5fe85037ac" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt; (int x)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="6d1c7c86aea003afe938bab829e378b0663f340f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt; (...)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt; (...)</target>
        </trans-unit>
        <trans-unit id="b6364cb6c54b3f23f200e94c257634d572b72a2b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt; (int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt; (int &lt;var&gt;sr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="75355c68c6a70985d49c27c009882adbab77b765" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt; (int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt; (int &lt;var&gt;usr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="4ea0be9b20abc1e8c8611e711574fc9d068aecdf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt; (unsigned int x)</target>
        </trans-unit>
        <trans-unit id="d2674768572b8928e01401026a8478558c974780" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt; (unsigned long)</target>
        </trans-unit>
        <trans-unit id="ee9664e69ce71d737f813b0b4d98ebf2574871d2" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt; (unsigned long long)</target>
        </trans-unit>
        <trans-unit id="f4ff1595ae9b712ea80b334ac2a6cdea20f82b68" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt; (unsigned int x)</target>
        </trans-unit>
        <trans-unit id="06a51eea95b9b1a09db27133b891662e30ce0448" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt; (беззнаковое длинное)</target>
        </trans-unit>
        <trans-unit id="cdd076b3e2da0133a80ede36a8b399d240589b8d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt; (unsigned long long)</target>
        </trans-unit>
        <trans-unit id="81ba97f2fd93c345aa1ebd2ae07061c6b3b1e18d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bc349ef1269f6645b577d9e0423a3da86a3c0c64" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="3c6283c7dae9e9bf7ecb0b6d081f4b083bb18c46" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="061b61de0614f91eda3a2e79ebd09fdb750a9e0f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="90ac1419f6405c9d67980323a8c6db2b17519fa4" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="ba08ce759241ad5b54043023fc31cb69ea10ef12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt; (intptr_t * &lt;var&gt;buf&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="3b5f4e2e49e883c140bdde81a146113e7826c6e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt; (void*)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt; (void *)</target>
        </trans-unit>
        <trans-unit id="00769436b2cde422b3b7011657e79f1018006b03" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt; (void*)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt; (void *)</target>
        </trans-unit>
        <trans-unit id="b626c4c35bdf8b837ccbdac21dccf04d3259501c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt; (void*, int)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt; (void *, int)</target>
        </trans-unit>
        <trans-unit id="7b0e1df41de31ed2e428c07e756094f54001f4e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt; (void*, int)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt; (void *, int)</target>
        </trans-unit>
        <trans-unit id="5a37cc4aa4480ad9e51ba1642145972ee824d1c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="b156bfa334cc82648dee3d2f253e789fdf0de655" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="7d1b9cf1258d4a3f36ac2384619d6f6feef8480b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt;, &lt;var&gt;type2&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; , &lt;var&gt;type2&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="ab0fd3c8fa261ef1e9881453b5ce3996db8b353f" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt; (long &lt;var&gt;exp&lt;/var&gt;, long &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt; (long &lt;var&gt;exp&lt;/var&gt; , long &lt;var&gt;c&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f748429dddf7f60efd21f75bc9d96a2f04db2076" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</source>
          <target state="translated">Встроенная функция: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971be5dbeae5d7765bfe0bd927cc0410ae39a447" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="f890816fdc58a1aea60b82df935d886c00b2bf15" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4324db719b621df0af588063a194c3f4173810b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="05afbb2ee64f8e1c3ac88b778a44096576c7f966" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">Встроенная функция: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="2b868b2b6ef31f0d2806eabe890d6c604ddddf56" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt; (long double, int)</source>
          <target state="translated">Встроенная функция: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt; (long double, int)</target>
        </trans-unit>
        <trans-unit id="d356427c6ff17cd4bc34021c1341be077bc0c8a1" translate="yes" xml:space="preserve">
          <source>Built-in Function: short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt; (short int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt; (short int &lt;var&gt;src&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f029118b8798750fa6c678264c3c7762285f4d28" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt; , int &lt;var&gt;type&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="e7554947332f78bb70c0521290e9a6608845a4d1" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt; , int &lt;var&gt;type&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="989a30653b65ffed34f5682558a8970a9aa0e644" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt; ()</source>
          <target state="translated">Встроенная функция: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="22d331467c48fe2922c4d1d28e785562b4d984a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt; (uint16_t x)</source>
          <target state="translated">Встроенная функция: uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt; (uint16_t x)</target>
        </trans-unit>
        <trans-unit id="c1726e6c424d7f99d5018566837c4927b7db5948" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt; (uint32_t x)</source>
          <target state="translated">Встроенная функция: uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt; (uint32_t x)</target>
        </trans-unit>
        <trans-unit id="3c5352b73e73ceeb994fa2584683f756d8f9d112" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt; (uint64_t x)</source>
          <target state="translated">Встроенная функция: uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt; (uint64_t x)</target>
        </trans-unit>
        <trans-unit id="abc61c858b13f41c2e5ca8e8946562bef29c71f9" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned &lt;strong id=&quot;index-long&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_byte (unsigned long long &lt;var&gt;offset&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa41c7be715e464532b85eaa4dc6a456f1c00215" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned &lt;strong id=&quot;index-long-1&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_half (unsigned long long &lt;var&gt;offset&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b96451756f237a6911f0f759acff406d9ac6251" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned &lt;strong id=&quot;index-long-2&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_word (unsigned long long &lt;var&gt;offset&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509ae15fd2e87932ac8b26cb6b1d223cd12aa699" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="930e355c3b80a5a9fc58fc1acd0a189dee429782" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="fe43f813f2eb2f9db208678d8efd3062ab0ae06f" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="7bd053e0e0e0c481f2fd8761cce8fb20e0497500" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt; (void (*&lt;var&gt;function&lt;/var&gt;)(), void *&lt;var&gt;arguments&lt;/var&gt;, size_t &lt;var&gt;size&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt; (void (* &lt;var&gt;function&lt;/var&gt; ) (), void * &lt;var&gt;arguments&lt;/var&gt; , size_t &lt;var&gt;size&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="34fa5cc333ec1b465b8bc1469ac13a9805646394" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt; ()</source>
          <target state="translated">Встроенная функция: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="ae3f4e7eb7b92dd81ca2567a194a5a901d0bfe5f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt; (const void *&lt;var&gt;exp&lt;/var&gt;, size_t &lt;var&gt;align&lt;/var&gt;, ...)</source>
          <target state="translated">Встроенная функция: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt; (const void * &lt;var&gt;exp&lt;/var&gt; , size_t &lt;var&gt;align&lt;/var&gt; , ...)</target>
        </trans-unit>
        <trans-unit id="89fd532a50930c3b77686313f0365b067e8b2061" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt; (void * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="af5db4b2531bc00d2c26aa89ffd98b83b1ec2ffd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt; (беззнаковый &lt;var&gt;level&lt;/var&gt; int )</target>
        </trans-unit>
        <trans-unit id="d65d4d6005c36effe3b2d9cb5dc89b8f157bffcd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddr&quot;&gt;__builtin_frob_return_addr&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae549b690a18db077d51fc88ddfe8895c32f392" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt; (void * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="570bc19f96ffb431d4ed4e07d4a76a73d90b1bab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt; (беззнаковый &lt;var&gt;level&lt;/var&gt; int )</target>
        </trans-unit>
        <trans-unit id="2a17d8a48dd1cfb01e5eca9e0fefb74ccd1f3e19" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="f386f8fa1a3ce61aaddb01d8f87e99be90ce722e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;*__builtin_alloca&lt;/strong&gt; (size_t size)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;* __ builtin_alloca&lt;/strong&gt; (size_t size)</target>
        </trans-unit>
        <trans-unit id="c063cc66ca8c65c97e5563c39a35ab67426b4796" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;*__builtin_alloca_with_align&lt;/strong&gt; (size_t size, size_t alignment)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;* __ builtin_alloca_with_align&lt;/strong&gt; (размер size_t, выравнивание size_t)</target>
        </trans-unit>
        <trans-unit id="9c9a2cc82b83f94f4d0c65d76c51d114da95b31b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;*__builtin_alloca_with_align_and_max&lt;/strong&gt; (size_t size, size_t alignment, size_t max_size)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;* __ builtin_alloca_with_align_and_max&lt;/strong&gt; (размер size_t, выравнивание size_t, size_t max_size)</target>
        </trans-unit>
        <trans-unit id="9362d0fd68d2bba012773ea9bf47a7cf19548a71" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt; (bool *ptr, int memorder)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt; (bool * ptr, int memorder)</target>
        </trans-unit>
        <trans-unit id="af38ddba7b2c30fcdbcb19cb7f7f28b84121aca6" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * val, &lt;var&gt;type&lt;/var&gt; * ret, int memorder)</target>
        </trans-unit>
        <trans-unit id="81cf5ada4648091ed72e1aa65aae72b350e8c4d3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * ret, int memorder)</target>
        </trans-unit>
        <trans-unit id="a339c94ea5a60096d289e4b1ba778af9caadce5c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt; (int memorder)</target>
        </trans-unit>
        <trans-unit id="a1bcb5179154226f5bada80a127d69eae1eb5cec" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, int memorder)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * val, int memorder)</target>
        </trans-unit>
        <trans-unit id="0a97d93631348e25f6183eb76cee2e101979f75e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="2d340009d0a0b7de28ca2e66c34cf11a1340bae0" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt; (int memorder)</target>
        </trans-unit>
        <trans-unit id="de406e12d51eaad788fc9e9d5903dcbf3bcb9513" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt; (void *&lt;var&gt;begin&lt;/var&gt;, void *&lt;var&gt;end&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt; (void * &lt;var&gt;begin&lt;/var&gt; , void * &lt;var&gt;end&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="fbdc79fbdaaac306ca33e716a38d2039cdbc731c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="41dfbf690d1f1831d27b0be428eb428d5c08e800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt; , unsigned int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="938747d2d81b773df4eb146dc47c371852f38281" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="dacbc2eeaf144c8f5f67ca6a60249f78488adc0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt; , int &lt;var&gt;b&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="5df39d3186b8d524cef79461c8ccbf9360ab5670" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;, unsigned int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt; , unsigned int &lt;var&gt;b&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f6b3b375828d6b123d4a73fe0837a99b6630234e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="3e99485526d0fd614866e77c7a635130751c7b1d" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="5cc0e84fe67d81076fbea0352fb8f5781564ffca" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="39ed65244aa708bd181a626a0afcf9435d2147f5" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt; , unsigned int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f420eb345d10d7bfd574d6a3346de63183adc893" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="b42e0753d14b76f3a20b1e491681f5295a8dc135" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="78cc7129f46ffcafd69b91e8eda56456c2ecced9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt; (unsigned int &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt; (unsigned int &lt;var&gt;c&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="627e1715f16535c4e6e435528706da2168cf77df" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="b29e71f1f17adad688b68068d1063df98d3d4aee" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="ae429fc5f0112c7890dcdff589f10f47deea16dd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="d3cd845b205509711bbf6256051511ce8b3607ab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;, int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt; (intptr_t * &lt;var&gt;buf&lt;/var&gt; , int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="fff14e5c46a00a91c0c0603fe5f170bde38d705e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="fe5501c6b5d93e7b033487f6a848dd334597db03" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt; (int *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt; (int * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="841f0b2bab051a37cafce912e8b554544bed4ffb" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt; , int &lt;var&gt;sr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="df8bab86f6689c778da28b14954604543548fb9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt; , int &lt;var&gt;usr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="cc7672c01bcce0ae5cb385b443579f1f0e814383" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="01c2cb53755ea177e9b7bcabfb291e59bf8c8d8b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_en&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_en&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="2f23c91db2e471b60a85c1d974b337410d93c4ae" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt; (uint64_t *, uint64_t)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt; (uint64_t *, uint64_t)</target>
        </trans-unit>
        <trans-unit id="2321505821d1604108a7105b3b6858f231f0c9ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt; (const void *&lt;var&gt;addr&lt;/var&gt;, ...)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt; (const void * &lt;var&gt;addr&lt;/var&gt; , ...)</target>
        </trans-unit>
        <trans-unit id="fe3fc0ac7968932105d1c1d3ab50d7b85cfe594b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt; (void *&lt;var&gt;result&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt; (void * &lt;var&gt;result&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="a1a8dfdf0491f60d9f3285d8de87cb556335dd7c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="baafeee4f82f6b2b3615bbf58d2dd0b69de47091" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="40ac58e52ec8cfeb1ed0ce17f884d6ca28de4bb2" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="60f5dc479a3c9ca583cab1eca4c28279f3d7220a" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt; (int, int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="8e28f28fffe61c4b4679e59b89330fa5d0042874" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt; (int, int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="46c536195bce3a86157c9c49ee77c45d3577dcc4" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt; (int, int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="5621acbcbc1163f811efb159aa50ed209c490ad9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt; (int, int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="227762640b3aca70bd083850fd27548557a69595" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="4eefd425b2ddf508a48e8a2189b6454058653fea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="662dad4c2fd795f4f1dddab9d3e0737c1c8a5708" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt; (int reg, int val)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt; (int reg, int val)</target>
        </trans-unit>
        <trans-unit id="276391cb278528b1f872b1280affb29edbd7927c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="700036ac6c5189b95316dbc5c4ae3b0309325df1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="c48b2b82b14ae8b91fdb2fe28e06b8ea0b1cb522" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4595d30c690a3b8c89c7807c08a9959f30d56800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt; (float)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt; (float)</target>
        </trans-unit>
        <trans-unit id="c5948033a96e4003655c71953e27a3f9741045b3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="f89dbf6d50890784687748f168df8d729aebf79c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="95b218b72a2c6b938556ce1a8c8a3cca255a13b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt; (void *&lt;var&gt;ptr&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt; (void * &lt;var&gt;ptr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="2db4725d0eae1acd204db5ae18744d85101db3ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt; (unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt; (unsigned int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f9baaf9b0798ed586e63831552a408b61b1a992c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="d228c7f65857695f955c2630b92714965d36378f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="94689ecdbd4d60ff7b0fd602ce7245bc7b6beb10" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4a1c671de0baf7c15aaf53f248312afd293d5b33" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt; (int)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="5904be3f2c9a60beac8be0103847c267a6f80e80" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt; (void)</source>
          <target state="translated">Встроенная функция: void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="836cf5a0e71cae3a60324503179866ad686508a7" translate="yes" xml:space="preserve">
          <source>Built-in functions for limited buffer overflow checking.</source>
          <target state="translated">Встроенные функции для ограниченной проверки переполнения буфера.</target>
        </trans-unit>
        <trans-unit id="d4b5ba0eb7000fc998fff5b209a2516ba2e54a3f" translate="yes" xml:space="preserve">
          <source>Built-in functions specific to particular targets.</source>
          <target state="translated">Встроенные функции,специфичные для конкретных целей.</target>
        </trans-unit>
        <trans-unit id="253258e2e82600175022e888019e1f8e9ab9c3a1" translate="yes" xml:space="preserve">
          <source>Built-in functions to perform arithmetics and arithmetic overflow checking.</source>
          <target state="translated">Встроенные функции для выполнения арифметики и проверки арифметического переполнения.</target>
        </trans-unit>
        <trans-unit id="4708bb7371d5b0f788e5028a015745453830a6ee" translate="yes" xml:space="preserve">
          <source>Built-in macros, macros defined on the command line, and macros defined in include files are not warned about.</source>
          <target state="translated">Встроенные макросы,макросы,определенные в командной строке,и макросы,определенные во включаемых файлах,не предупреждаются.</target>
        </trans-unit>
        <trans-unit id="606b68375f39bb1e243e870d45cdf01eab0caad3" translate="yes" xml:space="preserve">
          <source>But if you need to debug a problem with method signatures and need to know how they are implemented (i.e., the &amp;ldquo;ABI&amp;rdquo;), read on.</source>
          <target state="translated">Но если вам нужно отладить проблему с сигнатурами методов и нужно знать, как они реализованы (например, &amp;laquo;ABI&amp;raquo;), читайте дальше.</target>
        </trans-unit>
        <trans-unit id="18ba03b4395ba58ba0713d75a0907aa6ed34a2f6" translate="yes" xml:space="preserve">
          <source>But in the definition of &lt;code&gt;foo&lt;/code&gt;, the file-scope type is used because that is available to be inherited. Thus, the definition and the prototype do not match, and you get an error.</source>
          <target state="translated">Но в определении &lt;code&gt;foo&lt;/code&gt; используется тип файловой области, потому что он доступен для наследования. Таким образом, определение и прототип не совпадают, и вы получаете ошибку.</target>
        </trans-unit>
        <trans-unit id="54f71fd5d9e178736a8b25951cca5312e798d273" translate="yes" xml:space="preserve">
          <source>But in this example, the &lt;code&gt;std::move&lt;/code&gt; call prevents copy elision.</source>
          <target state="translated">Но в этом примере вызов &lt;code&gt;std::move&lt;/code&gt; предотвращает удаление копии.</target>
        </trans-unit>
        <trans-unit id="cf56c043a9173e054f17c75c7e06c6a5d352b771" translate="yes" xml:space="preserve">
          <source>But this definition computes either &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; or &lt;var&gt;b&lt;/var&gt; twice, with bad results if the operand has side effects. In GNU C, if you know the type of the operands (here taken as &lt;code&gt;int&lt;/code&gt;), you can avoid this problem by defining the macro as follows:</source>
          <target state="translated">Но это определение вычисляет либо &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; , либо &lt;var&gt;b&lt;/var&gt; дважды, с плохими результатами, если операнд имеет побочные эффекты. В GNU C, если вы знаете тип операндов (здесь используется как &lt;code&gt;int&lt;/code&gt; ), вы можете избежать этой проблемы, определив макрос следующим образом:</target>
        </trans-unit>
        <trans-unit id="089c24745336688f5099a4bd50557aedc8fc6fff" translate="yes" xml:space="preserve">
          <source>By contrast, PCC on most target machines returns structures and unions of any size by copying the data into an area of static storage, and then returning the address of that storage as if it were a pointer value. The caller must copy the data from that memory area to the place where the value is wanted. GCC does not use this method because it is slower and nonreentrant.</source>
          <target state="translated">Напротив,PCC на большинстве целевых машин возвращает структуры и объединения любого размера путем копирования данных в область статического хранилища,а затем возвращает адрес этого хранилища,как если бы это было значение указателя.Звонящий должен скопировать данные из этой области памяти в то место,где нужно значение.GCC не использует этот метод,так как он медленнее и не реентерабельный.</target>
        </trans-unit>
        <trans-unit id="8e8864b0dc6da1e44443610d33567bb75bb81d17" translate="yes" xml:space="preserve">
          <source>By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function&amp;rsquo;s code into the code for its callers. This makes execution faster by eliminating the function-call overhead; in addition, if any of the actual argument values are constant, their known values may permit simplifications at compile time so that not all of the inline function&amp;rsquo;s code needs to be included. The effect on code size is less predictable; object code may be larger or smaller with function inlining, depending on the particular case. You can also direct GCC to try to integrate all &amp;ldquo;simple enough&amp;rdquo; functions into their callers with the option</source>
          <target state="translated">Объявив функцию встроенной, вы можете направить GCC на выполнение вызовов этой функции быстрее. Один из способов, которым GCC может достичь этого, - интегрировать код этой функции в код для ее вызывающих. Это ускоряет выполнение за счет устранения накладных расходов на вызов функций; кроме того, если какое-либо из фактических значений аргументов является постоянным, их известные значения могут допускать упрощения во время компиляции, так что не нужно включать весь код встроенной функции. Влияние на размер кода менее предсказуемо; объектный код может быть больше или меньше при встраивании функций, в зависимости от конкретного случая. Вы также можете указать GCC попытаться интегрировать все &amp;laquo;достаточно простые&amp;raquo; функции в их вызывающих с опцией</target>
        </trans-unit>
        <trans-unit id="571c61d917cc3bc4c5e2835a5dd40c5c41bd768f" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the GR5 variant of the Visium architecture.</source>
          <target state="translated">По умолчанию (если не настроено иначе),GCC генерирует код для варианта GR5 архитектуры Visium.</target>
        </trans-unit>
        <trans-unit id="8ff1bd96a4bdcc76b002de9ee97861c9f804a0dc" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the V7 variant of the SPARC architecture. With</source>
          <target state="translated">По умолчанию (если не настроено иначе),GCC генерирует код для варианта V7 архитектуры SPARC.С</target>
        </trans-unit>
        <trans-unit id="44c806b35c6f92efecb7ce7748b95c7a4f87c40c" translate="yes" xml:space="preserve">
          <source>By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary. This enables more inlining and increases code size, but may improve performance of code that depends on fast &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memset&lt;/code&gt; for short lengths. The option enables inline expansion of &lt;code&gt;strlen&lt;/code&gt; for all pointer alignments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5c102e65c6f170a209b204a4dbc9b094f06846" translate="yes" xml:space="preserve">
          <source>By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary. This enables more inlining and increases code size, but may improve performance of code that depends on fast &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, and &lt;code&gt;memset&lt;/code&gt; for short lengths.</source>
          <target state="translated">По умолчанию GCC встраивает строковые операции только в том случае, если известно, что место назначения выровнено как минимум по 4-байтовой границе. Это позволяет больше встраивать и увеличивает размер кода, но может улучшить производительность кода, который зависит от быстрых &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;strlen&lt;/code&gt; и &lt;code&gt;memset&lt;/code&gt; для небольших длин.</target>
        </trans-unit>
        <trans-unit id="828f5d805ef0fc5866d738b0ffbff970c7d7f41f" translate="yes" xml:space="preserve">
          <source>By default assume that all calls are far away so that a longer and more expensive calling sequence is required. This is required for calls farther than 32 megabytes (33,554,432 bytes) from the current location. A short call is generated if the compiler knows the call cannot be that far away. This setting can be overridden by the &lt;code&gt;shortcall&lt;/code&gt; function attribute, or by &lt;code&gt;#pragma
longcall(0)&lt;/code&gt;.</source>
          <target state="translated">По умолчанию предполагается, что все вызовы находятся далеко, поэтому требуется более длительная и дорогостоящая последовательность вызовов. Это требуется для вызовов на расстоянии более 32 мегабайт (33 554 432 байта) от текущего местоположения. Если компилятор знает, что вызов не может быть так далеко, генерируется короткий вызов. Этот параметр можно переопределить &lt;code&gt;shortcall&lt;/code&gt; функции shortcall или &lt;code&gt;#pragma longcall(0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7d64d02eb42b84df503cac7606206757e75fdfc" translate="yes" xml:space="preserve">
          <source>By default instance variables in Objective-C can be accessed as if they were local variables from within the methods of the class they&amp;rsquo;re declared in. This can lead to shadowing between instance variables and other variables declared either locally inside a class method or globally with the same name. Specifying the</source>
          <target state="translated">По умолчанию переменные экземпляра в Objective-C доступны, как если бы они были локальными переменными, из методов класса, в котором они объявлены. Это может привести к затенению между переменными экземпляра и другими переменными, объявленными локально внутри метода класса или глобально. с таким же названием. Указание</target>
        </trans-unit>
        <trans-unit id="812f601802f8d41b61d44c3f0bd220d17f966e00" translate="yes" xml:space="preserve">
          <source>By default it is treated as &lt;code&gt;signed int&lt;/code&gt; but this may be changed by the</source>
          <target state="translated">По умолчанию он рассматривается как &lt;code&gt;signed int&lt;/code&gt; но это может быть изменено</target>
        </trans-unit>
        <trans-unit id="42ef9328c623bad5538b4f26249da5459c5c08d3" translate="yes" xml:space="preserve">
          <source>By default or when</source>
          <target state="translated">По умолчанию или когда</target>
        </trans-unit>
        <trans-unit id="3fa72f6f9c5a94c5d09caf64d4a1e9c339e8bb7c" translate="yes" xml:space="preserve">
          <source>By default the analyzer attempts to simplify analysis by merging sufficiently similar states at each program point as it builds its &amp;ldquo;exploded graph&amp;rdquo;. With</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238d21ed5942f525fb456a138be81dac5934eca2" translate="yes" xml:space="preserve">
          <source>By default the analyzer attempts to simplify analysis by purging aspects of state at a program point that appear to no longer be relevant e.g. the values of locals that aren&amp;rsquo;t accessed later in the function and which aren&amp;rsquo;t relevant to leak analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b76575429db7ab5c66debc083d774f7e949e1c" translate="yes" xml:space="preserve">
          <source>By default this feature is not enabled. The default can be restored via the</source>
          <target state="translated">По умолчанию эта функция не включена.По умолчанию эта функция может быть восстановлена через</target>
        </trans-unit>
        <trans-unit id="be7bad4b8f0ace00e1f8f2cdea4bdacee4c90882" translate="yes" xml:space="preserve">
          <source>By default when the C++ frontend prints diagnostics showing mismatching template types, common parts of the types are printed as &amp;ldquo;[...]&amp;rdquo; to simplify the error message. For example:</source>
          <target state="translated">По умолчанию, когда интерфейс C ++ выводит диагностику, показывающую несоответствующие типы шаблонов, общие части типов печатаются как &amp;laquo;[...]&amp;raquo;, чтобы упростить сообщение об ошибке. Например:</target>
        </trans-unit>
        <trans-unit id="e5c0fdbe4acada00b33542c8af5765b2142c6787" translate="yes" xml:space="preserve">
          <source>By default, GCC also provides some additional extensions to the C++ language that on rare occasions conflict with the C++ standard. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;. Use of the</source>
          <target state="translated">По умолчанию GCC также предоставляет некоторые дополнительные расширения для языка C ++, которые в редких случаях конфликтуют со стандартом C ++. См. Раздел &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Параметры, управляющие диалектом C ++&lt;/a&gt; . Использование</target>
        </trans-unit>
        <trans-unit id="1b721c8be1fed47cd95a2b324cc0ec1f3f3fd2db" translate="yes" xml:space="preserve">
          <source>By default, GCC emits an error message if the feedback profiles do not match the source code. This error can be turned into a warning by using</source>
          <target state="translated">По умолчанию GCC выдает сообщение об ошибке,если профили обратной связи не соответствуют исходному коду.Эту ошибку можно превратить в предупреждение с помощью функции</target>
        </trans-unit>
        <trans-unit id="68205120aabfb538f7bc7f4202c9b447a1cf9091" translate="yes" xml:space="preserve">
          <source>By default, GCC generates a branch hint instruction to avoid pipeline stalls for always-taken or probably-taken branches. A hint is not generated closer than 8 instructions away from its branch. There is little reason to disable them, except for debugging purposes, or to make an object a little bit smaller.</source>
          <target state="translated">По умолчанию,GCC генерирует инструкцию по подсказке ответвления,чтобы избежать простоя трубопроводов для постоянно или возможно поврежденных ответвлений.Подсказка генерируется не ближе,чем 8 инструкций от его ответвления.Нет причин их отключать,кроме как в целях отладки,или делать объект немного меньше.</target>
        </trans-unit>
        <trans-unit id="0f0fae0fc27ffb4e00a4f068905f564a20595bd8" translate="yes" xml:space="preserve">
          <source>By default, GCC generates code assuming that addresses are never larger than 18 bits. With</source>
          <target state="translated">По умолчанию GCC генерирует код,предполагая,что адреса никогда не бывают больше 18 бит.С</target>
        </trans-unit>
        <trans-unit id="bfc14d5fdff5ebfd96cb93f60f01d2cd55db824a" translate="yes" xml:space="preserve">
          <source>By default, GCC ignores trigraphs, but in standard-conforming modes it converts them. See the</source>
          <target state="translated">По умолчанию GCC игнорирует триграфы,но в стандартных режимах конвертирует их.См.раздел</target>
        </trans-unit>
        <trans-unit id="7b2b09a4a457e7ae05463c18b24ed251756826ce" translate="yes" xml:space="preserve">
          <source>By default, GCC inserts NOPs to increase dual issue when it expects it to increase performance. &lt;var&gt;n&lt;/var&gt; can be a value from 0 to 10. A smaller &lt;var&gt;n&lt;/var&gt; inserts fewer NOPs. 10 is the default, 0 is the same as</source>
          <target state="translated">По умолчанию GCC вставляет NOP, чтобы увеличить двойную проблему, когда он ожидает повышения производительности. &lt;var&gt;n&lt;/var&gt; может иметь значение от 0 до 10. Чем меньше &lt;var&gt;n&lt;/var&gt; ,тем меньше NOP. 10 по умолчанию, 0 то же, что и</target>
        </trans-unit>
        <trans-unit id="fb6ff38e6ed640debf4ee9a5067811f24a626ac7" translate="yes" xml:space="preserve">
          <source>By default, GCC limits the size of functions that can be inlined. This flag allows coarse control of this limit. &lt;var&gt;n&lt;/var&gt; is the size of functions that can be inlined in number of pseudo instructions.</source>
          <target state="translated">По умолчанию GCC ограничивает размер функций, которые могут быть встроены. Этот флаг позволяет грубо регулировать этот предел. &lt;var&gt;n&lt;/var&gt; - размер функций, которые могут быть встроены в число псевдоинструкций.</target>
        </trans-unit>
        <trans-unit id="9bf107b2c0510e1f5a934dedd69183ab9f3da713" translate="yes" xml:space="preserve">
          <source>By default, GCC links against startup code that assumes the SPU-style main function interface (which has an unconventional parameter list). With</source>
          <target state="translated">По умолчанию GCC связывается с кодом запуска,который принимает интерфейс главной функции в стиле SPU (который имеет нетрадиционный список параметров).С .</target>
        </trans-unit>
        <trans-unit id="7b2fda2cbe2c03ae974fe1e7172dd8c82c7ece3a" translate="yes" xml:space="preserve">
          <source>By default, GCC provides some extensions to the C language that, on rare occasions conflict with the C standard. See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Extensions to the C Language Family&lt;/a&gt;. Some features that are part of the C99 standard are accepted as extensions in C90 mode, and some features that are part of the C11 standard are accepted as extensions in C90 and C99 modes. Use of the</source>
          <target state="translated">По умолчанию GCC предоставляет некоторые расширения для языка C, которые в редких случаях конфликтуют со стандартом C. См &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Расширение языка C семье&lt;/a&gt; . Некоторые функции, которые являются частью стандарта C99, принимаются как расширения в режиме C90, а некоторые функции, которые являются частью стандарта C11, принимаются как расширения в режимах C90 и C99. Использование</target>
        </trans-unit>
        <trans-unit id="9893f2e72481c2382557fc2f081ec3a8e97bc79b" translate="yes" xml:space="preserve">
          <source>By default, an edge in this graph can contain the effects of a run of multiple statements within a basic block. With</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7c9e5570dcde91269bdc30909a64efa434ef4f" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes text indicating the command-line option that directly controls the diagnostic (if such an option is known to the diagnostic machinery). Specifying the</source>
          <target state="translated">По умолчанию каждая выданная диагностика включает в себя текст с указанием опции командной строки,которая непосредственно управляет диагностикой (если такая опция известна диагностической машине).Указание</target>
        </trans-unit>
        <trans-unit id="6a4309cf8cee66811505f90edea42d61f9045107" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes the original source line and a caret &amp;lsquo;</source>
          <target state="translated">По умолчанию каждая отправляемая диагностика включает в себя исходную строку исходного кода и курсор '</target>
        </trans-unit>
        <trans-unit id="bac331913dd18e98186423b1f11ca77a9b8683cf" translate="yes" xml:space="preserve">
          <source>By default, no debug information is produced for symbols that are not actually used. Use this option if you want debug information for all symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7763701cba03a5661d0405bf0959714c47202a4e" translate="yes" xml:space="preserve">
          <source>By default, only &amp;ldquo;high-level&amp;rdquo; messages are emitted. This option enables additional, more detailed, messages, which are likely to only be of interest to GCC developers.</source>
          <target state="translated">По умолчанию отправляются только сообщения &amp;laquo;высокого уровня&amp;raquo;. Эта опция включает дополнительные, более подробные сообщения, которые могут быть интересны только разработчикам GCC.</target>
        </trans-unit>
        <trans-unit id="98a82faa0eba738f33fea70355cca2f77f4d752d" translate="yes" xml:space="preserve">
          <source>By default, the analysis silently stops if the code is too complicated for the analyzer to fully explore and it reaches an internal limit. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d31796fedde16b57588ddd5284b3abd8463c996" translate="yes" xml:space="preserve">
          <source>By default, the assembler file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">По умолчанию имя файла ассемблера для исходного файла создается путем замены суффикса '</target>
        </trans-unit>
        <trans-unit id="10caadf2568f37c4e4608d0c62719e2855118ce6" translate="yes" xml:space="preserve">
          <source>By default, the dump will contain messages about successful optimizations (equivalent to</source>
          <target state="translated">По умолчанию,дамп будет содержать сообщения об успешных оптимизациях (эквивалентно</target>
        </trans-unit>
        <trans-unit id="ae9a2b16ff551e2f7ff627c2fd6228056bed25a8" translate="yes" xml:space="preserve">
          <source>By default, the keyword &lt;code&gt;__vector&lt;/code&gt; is added. The macro &lt;code&gt;vector&lt;/code&gt; is defined in &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; and can be undefined.</source>
          <target state="translated">По умолчанию добавляется ключевое слово &lt;code&gt;__vector&lt;/code&gt; . Макро- &lt;code&gt;vector&lt;/code&gt; определен в &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; и может быть неопределенным.</target>
        </trans-unit>
        <trans-unit id="b102924aa2fe89599576741a2bd8c5becb0889f6" translate="yes" xml:space="preserve">
          <source>By default, the object file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">По умолчанию имя объектного файла для исходного файла создается путем замены суффикса '</target>
        </trans-unit>
        <trans-unit id="4e689c10c02894b0d8e0dcec9a7f6bd5f47a0486" translate="yes" xml:space="preserve">
          <source>By default, when printing source code (via</source>
          <target state="translated">По умолчанию,при печати исходного кода (через</target>
        </trans-unit>
        <trans-unit id="f618b8855eb83706e0dd5ba4b20f8784c6acdce1" translate="yes" xml:space="preserve">
          <source>Byte swap. Return the result of swapping the upper and lower bytes of &lt;var&gt;value&lt;/var&gt;.</source>
          <target state="translated">Обмен байтами. Вернуть результат замены верхнего и нижнего байтов &lt;var&gt;value&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="8c7f20acc9bb2d58739f2e1f94cb9494f549d093" translate="yes" xml:space="preserve">
          <source>C Language Options</source>
          <target state="translated">C Варианты языка</target>
        </trans-unit>
        <trans-unit id="4f2345e5746cc2edc7fabec343cb3f91233c3786" translate="yes" xml:space="preserve">
          <source>C and Objective-C-only Warning Options</source>
          <target state="translated">C и опции предупреждения только об объекте C</target>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="translated">C-код</target>
        </trans-unit>
        <trans-unit id="43bd1aa29c2f227114eb9168f3aeb20a853ce287" translate="yes" xml:space="preserve">
          <source>C contains many standard functions that return a value that most programs choose to ignore. One obvious example is &lt;code&gt;printf&lt;/code&gt;. Warning about this practice only leads the defensive programmer to clutter programs with dozens of casts to &lt;code&gt;void&lt;/code&gt;. Such casts are required so frequently that they become visual noise. Writing those casts becomes so automatic that they no longer convey useful information about the intentions of the programmer. For functions where the return value should never be ignored, use the &lt;code&gt;warn_unused_result&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">C содержит множество стандартных функций, возвращающих значение, которое большинство программ предпочитают игнорировать. Один из очевидных примеров - &lt;code&gt;printf&lt;/code&gt; . Предупреждение об этой практике только заставляет защитного программиста загромождать программы десятками приведений к &lt;code&gt;void&lt;/code&gt; . Такие слепки требуются настолько часто, что становятся визуальным шумом. Написание этих приведений становится настолько автоматическим, что они больше не передают полезную информацию о намерениях программиста. Для функций, в которых возвращаемое значение никогда не следует игнорировать, используйте &lt;code&gt;warn_unused_result&lt;/code&gt; функции warn_unused_result (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b3d334ba58e80b66d4161266b799ef1fa9dce232" translate="yes" xml:space="preserve">
          <source>C flag clear or unsigned less than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa17b2be06e6856744ee3e4f2479342954c18298" translate="yes" xml:space="preserve">
          <source>C flag set or unsigned greater than equal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc85e5ef0494952e2e594d8f572f0cb62561829" translate="yes" xml:space="preserve">
          <source>C has the concept of volatile objects. These are normally accessed by pointers and used for accessing hardware or inter-thread communication. The standard encourages compilers to refrain from optimizations concerning accesses to volatile objects, but leaves it implementation defined as to what constitutes a volatile access. The minimum requirement is that at a sequence point all previous accesses to volatile objects have stabilized and no subsequent accesses have occurred. Thus an implementation is free to reorder and combine volatile accesses that occur between sequence points, but cannot do so for accesses across a sequence point. The use of volatile does not allow you to violate the restriction on updating objects multiple times between two sequence points.</source>
          <target state="translated">C имеет понятие &quot;летучие объекты&quot;.Обычно к ним обращаются указатели и они используются для доступа к оборудованию или для межпоточной связи.Стандарт призывает компиляторы воздержаться от оптимизаций,касающихся доступа к нестабильным объектам,но оставляет реализацию,определяющую,что представляет собой нестабильный доступ.Минимальным требованием является то,что в точке следования все предыдущие обращения к нестабильным объектам стабилизировались и никаких последующих обращений не происходило.Таким образом,реализация свободна в переупорядочивании и объединении нестабильных обращений,которые происходят между точками следования,но не может этого сделать для обращений через точку следования.Использование volatile не позволяет нарушить ограничение на многократное обновление объектов между двумя точками следования.</target>
        </trans-unit>
        <trans-unit id="c49f69bf7866959fd041d254d44ecd95bab5ba98" translate="yes" xml:space="preserve">
          <source>C register.</source>
          <target state="translated">Реестр С.</target>
        </trans-unit>
        <trans-unit id="2327d3d6eb8a5f7ce91755caf9e65d7a2e7dc1de" translate="yes" xml:space="preserve">
          <source>C source code that must be preprocessed.</source>
          <target state="translated">Исходный код на Си,который должен быть препроцессирован.</target>
        </trans-unit>
        <trans-unit id="61f8a2e0d02a243e776c6bb9750832b606cb81e5" translate="yes" xml:space="preserve">
          <source>C source code that should not be preprocessed.</source>
          <target state="translated">Исходный код на Си,который не должен быть препроцессирован.</target>
        </trans-unit>
        <trans-unit id="11548c240585bf5af759bc0a6b301b88b353e27e" translate="yes" xml:space="preserve">
          <source>C++ Language Options</source>
          <target state="translated">Язык C++Параметры языка</target>
        </trans-unit>
        <trans-unit id="57f68a93b1bb79e369d8676d696444f1cbbc7bb2" translate="yes" xml:space="preserve">
          <source>C++ comments are recognized.</source>
          <target state="translated">Комментарии C++распознаются.</target>
        </trans-unit>
        <trans-unit id="7f61cc8037210ca9970d93d649a42c41aee100de" translate="yes" xml:space="preserve">
          <source>C++ concepts provide much-improved support for generic programming. In particular, they allow the specification of constraints on template arguments. The constraints are used to extend the usual overloading and partial specialization capabilities of the language, allowing generic data structures and algorithms to be &amp;ldquo;refined&amp;rdquo; based on their properties rather than their type names.</source>
          <target state="translated">Концепции C ++ обеспечивают значительно улучшенную поддержку общего программирования. В частности, они позволяют специфицировать ограничения для аргументов шаблона. Ограничения используются для расширения обычных возможностей перегрузки и частичной специализации языка, позволяя &amp;laquo;уточнять&amp;raquo; общие структуры данных и алгоритмы на основе их свойств, а не имен типов.</target>
        </trans-unit>
        <trans-unit id="98cd14ec337b46f3c719029c11a0be19021fb2b8" translate="yes" xml:space="preserve">
          <source>C++ header file to be turned into a precompiled header or Ada spec.</source>
          <target state="translated">C++заголовочный файл,который должен быть превращен в прекомпилированный заголовок или спецификацию Ada.</target>
        </trans-unit>
        <trans-unit id="f7bc99762b7f83b6b621c845d769390544ce75a0" translate="yes" xml:space="preserve">
          <source>C++ is a complex language and an evolving one, and its standard definition (the ISO C++ standard) was only recently completed. As a result, your C++ compiler may occasionally surprise you, even when its behavior is correct. This section discusses some areas that frequently give rise to questions of this sort.</source>
          <target state="translated">С++-сложный и развивающийся язык,и его стандартное определение (стандарт ISO C++)было дано совсем недавно.В результате,ваш C++компилятор иногда может удивлять вас,даже если его поведение корректно.В этом разделе рассматриваются некоторые области,которые часто вызывают вопросы подобного рода.</target>
        </trans-unit>
        <trans-unit id="e84a747565fa51df782491a580d39e6a3f403239" translate="yes" xml:space="preserve">
          <source>C++ requires information about types to be written out in order to implement &amp;lsquo;</source>
          <target state="translated">C ++ требует, чтобы информация о типах была записана для реализации '</target>
        </trans-unit>
        <trans-unit id="fda8008d202b2d7ff2b02b361c7ea913221a6d44" translate="yes" xml:space="preserve">
          <source>C++ source code that must be preprocessed. Note that in &amp;lsquo;</source>
          <target state="translated">Исходный код C ++, который необходимо предварительно обработать. Обратите внимание, что в '</target>
        </trans-unit>
        <trans-unit id="99fa7c5a2c337828c11bc2c4ade3aae26a30fe89" translate="yes" xml:space="preserve">
          <source>C++ source code that should not be preprocessed.</source>
          <target state="translated">Исходный код на Си++,который не должен препроцессироваться.</target>
        </trans-unit>
        <trans-unit id="cc9e861072d065eff5c8caf3bd72ac42f37e3e61" translate="yes" xml:space="preserve">
          <source>C++ source files conventionally use one of the suffixes &amp;lsquo;</source>
          <target state="translated">Исходные файлы C ++ обычно используют один из суффиксов '</target>
        </trans-unit>
        <trans-unit id="e4d70d761fb7676ae22ebe197ff2d2dd053c553d" translate="yes" xml:space="preserve">
          <source>C++ templates were the first language feature to require more intelligence from the environment than was traditionally found on a UNIX system. Somehow the compiler and linker have to make sure that each template instance occurs exactly once in the executable if it is needed, and not at all otherwise. There are two basic approaches to this problem, which are referred to as the Borland model and the Cfront model.</source>
          <target state="translated">Шаблоны на C++были первой языковой возможностью,требующей от среды больше интеллекта,чем традиционно находилось в UNIX системе.Каким-то образом компилятор и компоновщик должны быть уверены,что каждый экземпляр шаблона встречается в исполняемом файле ровно один раз,если это необходимо,и вовсе не в противном случае.Существует два основных подхода к этой проблеме,которые называются моделью Borland и моделью Cfront.</target>
        </trans-unit>
        <trans-unit id="16bd188cbd64c4bf1a17218266102bf9d269e075" translate="yes" xml:space="preserve">
          <source>C++ virtual functions are implemented in most compilers using a lookup table, known as a vtable. The vtable contains pointers to the virtual functions provided by a class, and each object of the class contains a pointer to its vtable (or vtables, in some multiple-inheritance situations). If the class declares any non-inline, non-pure virtual functions, the first one is chosen as the &amp;ldquo;key method&amp;rdquo; for the class, and the vtable is only emitted in the translation unit where the key method is defined.</source>
          <target state="translated">Виртуальные функции C ++ реализованы в большинстве компиляторов с помощью таблицы поиска, известной как vtable. Таблица vtable содержит указатели на виртуальные функции, предоставляемые классом, и каждый объект класса содержит указатель на свою таблицу vtable (или vtables в некоторых ситуациях с множественным наследованием). Если класс объявляет какие-либо не встроенные, нечистые виртуальные функции, первая выбирается в качестве &amp;laquo;ключевого метода&amp;raquo; для класса, а vtable генерируется только в той единице трансляции, в которой определен ключевой метод.</target>
        </trans-unit>
        <trans-unit id="17265012fdaf7b797d7862b29ff392331cd3a4a0" translate="yes" xml:space="preserve">
          <source>C++17 provides a standard way to suppress the</source>
          <target state="translated">C++17 обеспечивает стандартный способ подавления</target>
        </trans-unit>
        <trans-unit id="f78d571177e03968d05d81e87283c743f9bd11eb" translate="yes" xml:space="preserve">
          <source>C, C++, Objective-C or Objective-C++ header file to be turned into a precompiled header (default), or C, C++ header file to be turned into an Ada spec (via the</source>
          <target state="translated">C,C++,Objective-C или Objective-C++заголовочный файл,который должен быть превращен в прекомпилированный заголовочный файл (по умолчанию),или C,C++заголовочный файл,который должен быть превращен в спецификацию Ada (с помощью команды</target>
        </trans-unit>
        <trans-unit id="6297518e9deb3ffb36cfb4da17e5731d4f43ddd3" translate="yes" xml:space="preserve">
          <source>C-EUCJP</source>
          <target state="translated">C-EUCJP</target>
        </trans-unit>
        <trans-unit id="fea2102020df627a3fcd18f01c6b90d1d1ebc0a5" translate="yes" xml:space="preserve">
          <source>C-JIS</source>
          <target state="translated">C-JIS</target>
        </trans-unit>
        <trans-unit id="8aed662488c94d21a572d72dd344a0c46e870bc0" translate="yes" xml:space="preserve">
          <source>C-SJIS</source>
          <target state="translated">C-SJIS</target>
        </trans-unit>
        <trans-unit id="e1c33b8c4686460cd515031a9d28c68a3cfcef87" translate="yes" xml:space="preserve">
          <source>C-SKY&amp;mdash;</source>
          <target state="translated">C-SKY&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e66b4865aad9938d99c99c6f4ab23939ca58e09e" translate="yes" xml:space="preserve">
          <source>C99 Annex F is followed.</source>
          <target state="translated">С99 Приложение F.</target>
        </trans-unit>
        <trans-unit id="0817809900308ce7f22b686082215869550cf931" translate="yes" xml:space="preserve">
          <source>C99 restricted pointers and references.</source>
          <target state="translated">C99 ограничительные указатели и ссылки.</target>
        </trans-unit>
        <trans-unit id="792d9ffa119c05fda74148cc441c8be905361027" translate="yes" xml:space="preserve">
          <source>CALL_INSN</source>
          <target state="translated">CALL_INSN</target>
        </trans-unit>
        <trans-unit id="a4c1d0441ce79e81e5b485ea5fcda7d1c56b743e" translate="yes" xml:space="preserve">
          <source>CB</source>
          <target state="translated">CB</target>
        </trans-unit>
        <trans-unit id="7c9c078a9c0f1169f25be27f38940093778bb37c" translate="yes" xml:space="preserve">
          <source>CET Function: ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt; (void)</source>
          <target state="translated">Функция CET: ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="01ab10eefead0e21345d5d4e4f22d758ced4568b" translate="yes" xml:space="preserve">
          <source>CET Function: void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt; (unsigned int)</source>
          <target state="translated">Функция CET: void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt; ( &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;целое&lt;/strong&gt; без знака)</target>
        </trans-unit>
        <trans-unit id="feca3790fce7c96d6df26540c7b4128215a81089" translate="yes" xml:space="preserve">
          <source>CMOV instruction.</source>
          <target state="translated">Инструкция CMOV.</target>
        </trans-unit>
        <trans-unit id="c2711a4d5237b1b481ba6a122e49ae7f80826ead" translate="yes" xml:space="preserve">
          <source>CPU does not have a timebase (eg, 601 and 403gx).</source>
          <target state="translated">Процессор не имеет тайм-базы (например,601 и 403gx).</target>
        </trans-unit>
        <trans-unit id="ca704ae8911deda5afe0231823961924eb739a85" translate="yes" xml:space="preserve">
          <source>CPU has a CELL broadband engine.</source>
          <target state="translated">Процессор оснащен широкополосным двигателем CELL.</target>
        </trans-unit>
        <trans-unit id="4f3f4709b09760afc34be4c56dc4c6225a92c342" translate="yes" xml:space="preserve">
          <source>CPU has a SIMD/Vector Unit.</source>
          <target state="translated">ЦПУ имеет SIMD/Векторный блок.</target>
        </trans-unit>
        <trans-unit id="7513f4d098c1065cad2f73416dc6c7b6d28bb7ca" translate="yes" xml:space="preserve">
          <source>CPU has a SPE double precision floating point unit.</source>
          <target state="translated">ЦПУ оснащен блоком плавающей запятой двойной точности SPE.</target>
        </trans-unit>
        <trans-unit id="249044ceb00915a3621d91cc9c9342822f5d3a2e" translate="yes" xml:space="preserve">
          <source>CPU has a SPE single precision floating point unit.</source>
          <target state="translated">ЦПУ оснащен блоком точной плавающей запятой SPE.</target>
        </trans-unit>
        <trans-unit id="afc457a7d1f6c70e1a12a91ad1a70b454e13c88b" translate="yes" xml:space="preserve">
          <source>CPU has a decimal floating point unit.</source>
          <target state="translated">ЦПУ имеет десятичный блок с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="daecf052e0ef6eddacd32a707988a46a48b10a26" translate="yes" xml:space="preserve">
          <source>CPU has a floating point unit.</source>
          <target state="translated">ЦПУ имеет блок с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="e350ba25d5b50e7eecaa8cd017e06461b70e0e96" translate="yes" xml:space="preserve">
          <source>CPU has a memory management unit.</source>
          <target state="translated">ЦПУ имеет блок управления памятью.</target>
        </trans-unit>
        <trans-unit id="d25b3ec38c741ef05546cfa00487c01e86a288da" translate="yes" xml:space="preserve">
          <source>CPU has a signal processing extension unit.</source>
          <target state="translated">ЦПУ оснащен блоком расширения обработки сигналов.</target>
        </trans-unit>
        <trans-unit id="a6cdbd18b45d3ceafe188679188c10b0e63fc06b" translate="yes" xml:space="preserve">
          <source>CPU has hardware transaction memory instructions.</source>
          <target state="translated">ЦПУ имеет инструкции по аппаратным операциям с памятью транзакций.</target>
        </trans-unit>
        <trans-unit id="817e69cd99aa2fae8e8cb1ea4ccb1e7cade39e36" translate="yes" xml:space="preserve">
          <source>CPU has unified I/D cache.</source>
          <target state="translated">ЦПУ имеет унифицированный I/D кэш.</target>
        </trans-unit>
        <trans-unit id="a85030d258895560b198880492e35a8dc7104678" translate="yes" xml:space="preserve">
          <source>CPU support simultaneous multi-threading.</source>
          <target state="translated">Поддержка процессора с одновременным многопоточностью.</target>
        </trans-unit>
        <trans-unit id="1fa8be29b90ade4bb4d6c9abca15ef4efb5cea12" translate="yes" xml:space="preserve">
          <source>CPU supports 128-bit IEEE binary floating point instructions.</source>
          <target state="translated">ЦПУ поддерживает 128-битные двоичные инструкции IEEE с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="d0ec10bc634bb744e9ff5bc9b6ccebe2f8a4c1fd" translate="yes" xml:space="preserve">
          <source>CPU supports 32-bit mode execution.</source>
          <target state="translated">ЦПУ поддерживает 32-битное исполнение.</target>
        </trans-unit>
        <trans-unit id="c550c34cceac587d8bfa3d110ce84630536005e1" translate="yes" xml:space="preserve">
          <source>CPU supports 64-bit mode execution.</source>
          <target state="translated">Процессор поддерживает 64-битное исполнение.</target>
        </trans-unit>
        <trans-unit id="969f1a1bfc594794e1d088866f33884cafe4c0a3" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.00 (eg, POWER4)</source>
          <target state="translated">ЦПУ поддерживает ISA 2.00 (например,POWER4).</target>
        </trans-unit>
        <trans-unit id="f021a7b007d311f22fec3723c62516e8f3a0319b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.02 (eg, POWER5)</source>
          <target state="translated">ЦПУ поддерживает ISA 2.02 (например,POWER5).</target>
        </trans-unit>
        <trans-unit id="ee64c969eb8481f0eae6c612175233cd07361227" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.03 (eg, POWER5+)</source>
          <target state="translated">ЦПУ поддерживает ISA 2.03 (например,POWER5+).</target>
        </trans-unit>
        <trans-unit id="13964fdc29b60cfc0a706e4cb0569a01c55f1208" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6)</source>
          <target state="translated">ЦПУ поддерживает ISA 2.05 (например,POWER6).</target>
        </trans-unit>
        <trans-unit id="4ba1460155478447375ae1fb486a30ad51582aec" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr.</source>
          <target state="translated">ЦПУ поддерживает ISA 2.05 (например,POWER6)расширенные опкоды mffgpr и mftgpr.</target>
        </trans-unit>
        <trans-unit id="990b205fa1433a7d0dc63ad9070ee91af0800dd1" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.06 (eg, POWER7)</source>
          <target state="translated">ЦПУ поддерживает ISA 2.06 (например,POWER7).</target>
        </trans-unit>
        <trans-unit id="6a9081f5b37e7737655ad795c102d5fe7087b65d" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.07 (eg, POWER8)</source>
          <target state="translated">ЦПУ поддерживает ISA 2.07 (например,POWER8).</target>
        </trans-unit>
        <trans-unit id="dcf25ddc902c83eba265e85451df12c824bf2a7b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 3.0 (eg, POWER9)</source>
          <target state="translated">ЦПУ поддерживает ISA 3.0 (например,POWER9).</target>
        </trans-unit>
        <trans-unit id="6092133b8e23ee5373746ec5bc5db76ea54238a4" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 3.1 (eg, POWER10)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055a8304e60c6c298c280b0809896894a417c35e" translate="yes" xml:space="preserve">
          <source>CPU supports a little-endian mode that uses address swizzling.</source>
          <target state="translated">Процессор поддерживает режим little-endian,использующий завихрение адреса.</target>
        </trans-unit>
        <trans-unit id="255ddfc220c178db8c2fdf2c3d887268be52afce" translate="yes" xml:space="preserve">
          <source>CPU supports event base branching.</source>
          <target state="translated">Процессор поддерживает ветвление событийной базы.</target>
        </trans-unit>
        <trans-unit id="7a546c031cbdf8f942b2e95c5d11fb1b52e9cc57" translate="yes" xml:space="preserve">
          <source>CPU supports hardware transaction memory but does not support the &lt;code&gt;tsuspend.&lt;/code&gt; instruction.</source>
          <target state="translated">ЦП поддерживает аппаратную память транзакций, но не поддерживает &lt;code&gt;tsuspend.&lt;/code&gt; инструкция.</target>
        </trans-unit>
        <trans-unit id="98cc31dee3a3972d6c8549b9b9d63935ff74bd07" translate="yes" xml:space="preserve">
          <source>CPU supports icache snooping capabilities.</source>
          <target state="translated">Процессор поддерживает возможность слежения за ледяным покровом.</target>
        </trans-unit>
        <trans-unit id="86a7a3dc0108d58ef63d3f6ab2c6e0a72b7c8029" translate="yes" xml:space="preserve">
          <source>CPU supports the &lt;code&gt;darn&lt;/code&gt; (deliver a random number) instruction.</source>
          <target state="translated">CPU поддерживает инструкцию &lt;code&gt;darn&lt;/code&gt; (доставить случайное число).</target>
        </trans-unit>
        <trans-unit id="77d7a3e63ab0326c7992c2322e10e155757df7b2" translate="yes" xml:space="preserve">
          <source>CPU supports the Embedded ISA category.</source>
          <target state="translated">ЦПУ поддерживает категорию Embedded ISA.</target>
        </trans-unit>
        <trans-unit id="c159e0e90690ac6c2f371b7dff8ce2db12767971" translate="yes" xml:space="preserve">
          <source>CPU supports the PA Semi 6T CORE ISA.</source>
          <target state="translated">Процессор поддерживает PA Semi 6T CORE ISA.</target>
        </trans-unit>
        <trans-unit id="2267dd90003bf8b5f66bba6f8158082ed6e95240" translate="yes" xml:space="preserve">
          <source>CPU supports the data stream control register.</source>
          <target state="translated">ЦПУ поддерживает регистр управления потоком данных.</target>
        </trans-unit>
        <trans-unit id="45a297e9cc9f2eb5df0912ac8e91302da6382422" translate="yes" xml:space="preserve">
          <source>CPU supports the integer select instruction.</source>
          <target state="translated">ЦПУ поддерживает целочисленную инструкцию выбора.</target>
        </trans-unit>
        <trans-unit id="2e306759e72b16093678ea3f4c4c712cd49b17a9" translate="yes" xml:space="preserve">
          <source>CPU supports the matrix-multiply assist instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a95efc8023d10b71a08bff59a8789aa22a0fb6" translate="yes" xml:space="preserve">
          <source>CPU supports the old POWER ISA (eg, 601)</source>
          <target state="translated">ЦПУ поддерживает старую версию POWER ISA (например,601).</target>
        </trans-unit>
        <trans-unit id="309f8ee6774ef217dd65020d0047499e145915f8" translate="yes" xml:space="preserve">
          <source>CPU supports the set of compatible performance monitoring events.</source>
          <target state="translated">ЦПУ поддерживает набор совместимых событий мониторинга производительности.</target>
        </trans-unit>
        <trans-unit id="654d56ee4aa1191ad640c84c9cda741472551b11" translate="yes" xml:space="preserve">
          <source>CPU supports the target address register.</source>
          <target state="translated">ЦПУ поддерживает регистр целевых адресов.</target>
        </trans-unit>
        <trans-unit id="2b74cd2604db8f416c0c904f549425dc7576345f" translate="yes" xml:space="preserve">
          <source>CPU supports the vector cryptography instructions.</source>
          <target state="translated">ЦПУ поддерживает инструкции по векторной криптографии.</target>
        </trans-unit>
        <trans-unit id="2910c789b3b4293207054dd9a2e43cc18d433b78" translate="yes" xml:space="preserve">
          <source>CPU supports the vector-scalar extension.</source>
          <target state="translated">Процессор поддерживает векторно-скалярное расширение.</target>
        </trans-unit>
        <trans-unit id="41c99496e20c6a12697b36d694855c474afbe5bb" translate="yes" xml:space="preserve">
          <source>CPU supports true little-endian mode.</source>
          <target state="translated">Процессор поддерживает истинный режим Little-endian.</target>
        </trans-unit>
        <trans-unit id="2ec7e4eb5fc127660ed425c7dcd89cd8eddc4bc5" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 10h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSE4A, 3DNow!, enhanced 3DNow!, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">ЦП на базе 10-ти часовых ядер AMD Family с поддержкой набора команд x86-64.(Это превосходит MMX,SSE,SSE2,SSE3,SSE4A,3DNow,расширенные 3DNow,ABM и 64-битные расширения набора команд).</target>
        </trans-unit>
        <trans-unit id="b84062366ba14fb3f3b6ff6b47d03c475a3828a9" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 14h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">ЦП на базе 14-часовых ядер AMD Family с поддержкой набора команд x86-64.(Это превосходит MMX,SSE,SSE2,SSE3,SSSE3,SSE4A,CX16,ABM и 64-битные расширения набора инструкций).</target>
        </trans-unit>
        <trans-unit id="7cd17945f4d7f7d90dbb7eb4390b3e09de24051b" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 15h cores with x86-64 instruction set support. (This supersets FMA4, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113524bb3893cb5857442da17502358001cf141b" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 15h cores with x86-64 instruction set support. (This supersets FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">ЦП на базе 15-часовых ядер AMD Family с поддержкой набора команд x86-64.(Это дополняет FMA4,AVX,XOP,LWP,AES,PCL_MUL,CX16,MMX,SSE,SSE2,SSE3,SSE4A,SSSE3,SSE4.1,SSE4.2,ABM и 64-битные расширения набора инструкций).</target>
        </trans-unit>
        <trans-unit id="de84db6df1b92636fc4cae8a7a0a74534cf2484c" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCLMUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a0219528807f6268d19e1c7ca96f3e9c601c1e" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.</source>
          <target state="translated">ЦП на базе 16-часовых ядер AMD Family с поддержкой набора команд x86-64.Сюда входят MOVBE,F16C,BMI,AVX,PCL_MUL,AES,SSE4.2,SSE4.1,CX16,ABM,SSE4A,SSSE3,SSE3,SSE2,SSE,MMX и расширения 64-битных наборов команд.</target>
        </trans-unit>
        <trans-unit id="762cf7076b068d306d32ea79b0d0e2277121f2b5" translate="yes" xml:space="preserve">
          <source>CR</source>
          <target state="translated">CR</target>
        </trans-unit>
        <trans-unit id="5e1fb0077df92097ce069aa21ed47aa03c3d5c5d" translate="yes" xml:space="preserve">
          <source>CR16 Architecture&amp;mdash;</source>
          <target state="translated">CR16 Архитектура&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="f9c744e8c0ecb712753e6342db41d199b59d9bf6" translate="yes" xml:space="preserve">
          <source>CTR</source>
          <target state="translated">CTR</target>
        </trans-unit>
        <trans-unit id="58ad68590efc1385d2b4fd64a16b4b9f8cfaaa44" translate="yes" xml:space="preserve">
          <source>Call operand, const_int, for absolute calls.</source>
          <target state="translated">Вызовите операнд,const_int,для абсолютных вызовов.</target>
        </trans-unit>
        <trans-unit id="3373e7e79f4085d8f7291896ef1d3760c15083be" translate="yes" xml:space="preserve">
          <source>Call operand, reg, for indirect calls</source>
          <target state="translated">Звоните в операнд,рег,для непрямых звонков</target>
        </trans-unit>
        <trans-unit id="3c51d11770c5ea3546c0d152d73faf160c859f37" translate="yes" xml:space="preserve">
          <source>Call operand, symbol, for relative calls.</source>
          <target state="translated">Вызовите операнд,символ,для относительных вызовов.</target>
        </trans-unit>
        <trans-unit id="f0c515fe9bf062328bec62182c3bb93d352208ec" translate="yes" xml:space="preserve">
          <source>Call the named function &lt;var&gt;function&lt;/var&gt;, passing it &lt;var&gt;args&lt;/var&gt;. &lt;var&gt;args&lt;/var&gt; is first processed as a nested spec string, then split into an argument vector in the usual fashion. The function returns a string which is processed as if it had appeared literally as part of the current spec.</source>
          <target state="translated">Вызовите названную функцию- &lt;var&gt;function&lt;/var&gt; , передав ей &lt;var&gt;args&lt;/var&gt; . &lt;var&gt;args&lt;/var&gt; сначала обрабатывается как вложенная строка спецификации, а затем обычным образом разбивается на вектор аргументов. Функция возвращает строку, которая обрабатывается так, как если бы она появилась буквально как часть текущей спецификации.</target>
        </trans-unit>
        <trans-unit id="4b1ccc6ccff0a4b4d69b01f9c83e0859c8e4f058" translate="yes" xml:space="preserve">
          <source>Calling conventions are a subset of an ABI that specify of how arguments are passed and function results are returned.</source>
          <target state="translated">Соглашения о вызовах-это подмножество ABI,которое определяет,как передаются аргументы и возвращаются результаты работы функции.</target>
        </trans-unit>
        <trans-unit id="8e13d2ff4cf44ed7d75b8cee9472ba906dfafd20" translate="yes" xml:space="preserve">
          <source>Calling this function with a nonzero argument can have unpredictable effects, including crashing the calling program. As a result, calls that are considered unsafe are diagnosed when the</source>
          <target state="translated">Вызов этой функции с ненулевым аргументом может привести к непредсказуемым последствиям,в том числе к аварийному завершению работы вызывающей программы.В результате,вызовы,считающиеся небезопасными,диагностируются при помощи функции</target>
        </trans-unit>
        <trans-unit id="fc12921ff6d4899e4dc68b34cc1cd37e3157e57e" translate="yes" xml:space="preserve">
          <source>Calls a library function that performs the operation in double precision floating point. Division by zero causes a floating-point exception. This is the default for SHcompact with FPU. Specifying this for targets that do not have a double precision FPU defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">Вызывает библиотечную функцию, выполняющую операцию с плавающей запятой двойной точности. Деление на ноль вызывает исключение с плавающей запятой. Это значение по умолчанию для SHcompact с FPU. Указание этого для целей, которые не имеют FPU двойной точности, по умолчанию &lt;code&gt;call-div1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e8cd2fa85f5515142e26b60a518bb56cd4bcb6" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses a lookup table for small divisors and the &lt;code&gt;div1&lt;/code&gt; instruction with case distinction for larger divisors. Division by zero calculates an unspecified result and does not trap. This is the default for SH4. Specifying this for targets that do not have dynamic shift instructions defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">Вызывает библиотечную функцию, которая использует таблицу поиска для малых делителей и инструкцию &lt;code&gt;div1&lt;/code&gt; с разделением регистра для больших делителей. При делении на ноль вычисляется неопределенный результат и не выполняется перехват. Это значение по умолчанию для SH4. Указание этого для целей, которые не имеют инструкций динамического сдвига, по умолчанию &lt;code&gt;call-div1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b66ee13b0a48eb1333567adb5302965969bbf50a" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses the single-step division instruction &lt;code&gt;div1&lt;/code&gt; to perform the operation. Division by zero calculates an unspecified result and does not trap. This is the default except for SH4, SH2A and SHcompact.</source>
          <target state="translated">Вызывает библиотечную функцию, которая использует инструкцию &lt;code&gt;div1&lt;/code&gt; деления div1 для выполнения операции. При делении на ноль вычисляется неопределенный результат и не выполняется перехват. Это значение по умолчанию, за исключением SH4, SH2A и SHcompact.</target>
        </trans-unit>
        <trans-unit id="b45cc51de5de6fd998285ffd2412d7b2646d5ad0" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;foo&lt;/code&gt; are mapped to calls to &lt;code&gt;foo{20040821}&lt;/code&gt;.</source>
          <target state="translated">Вызовы к &lt;code&gt;foo&lt;/code&gt; отображаются на вызовы к &lt;code&gt;foo{20040821}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="293878ce1781e2ea1bacb79578feb3fbe4be3315" translate="yes" xml:space="preserve">
          <source>Calls to external functions with this attribute must return to the current compilation unit only by return or by exception handling. In particular, a leaf function is not allowed to invoke callback functions passed to it from the current compilation unit, directly call functions exported by the unit, or &lt;code&gt;longjmp&lt;/code&gt; into the unit. Leaf functions might still call functions from other compilation units and thus they are not necessarily leaf in the sense that they contain no function calls at all.</source>
          <target state="translated">Вызов внешних функций с этим атрибутом должен возвращаться в текущую единицу компиляции только путем возврата или обработки исключений. В частности, листовой функции не разрешается вызывать функции обратного вызова, переданные ей из текущего модуля компиляции, напрямую вызывать функции, экспортированные модулем, или &lt;code&gt;longjmp&lt;/code&gt; в модуль. Конечные функции могут по-прежнему вызывать функции из других единиц компиляции, и поэтому они не обязательно являются листовыми в том смысле, что они вообще не содержат вызовов функций.</target>
        </trans-unit>
        <trans-unit id="4271715ba8546178ce2b0fafe7396f6340205ed7" translate="yes" xml:space="preserve">
          <source>Calls to functions that have no observable effects on the state of the program other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;pure&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">Вызов функций, которые не оказывают никакого наблюдаемого влияния на состояние программы, кроме как вернуть значение, могут подойти для оптимизации, такой как устранение общего подвыражения. Объявление таких функций с помощью атрибута &lt;code&gt;pure&lt;/code&gt; позволяет GCC избегать генерации некоторых вызовов при повторных вызовах функции с теми же значениями аргументов.</target>
        </trans-unit>
        <trans-unit id="3b52d0ab938b444cac1b9e9d1c160806cd6da345" translate="yes" xml:space="preserve">
          <source>Calls to functions whose return value is not affected by changes to the observable state of the program and that have no observable effects on such state other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;const&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">Вызов функций, на возвращаемое значение которых не влияют изменения наблюдаемого состояния программы и которые не оказывают наблюдаемого воздействия на такое состояние, кроме возврата значения, могут подойти для таких оптимизаций, как устранение общего подвыражения. Объявление таких функций с помощью атрибута &lt;code&gt;const&lt;/code&gt; позволяет GCC избегать генерации некоторых вызовов при повторных вызовах функции с теми же значениями аргументов.</target>
        </trans-unit>
        <trans-unit id="f8eba46ecad008a4e218a210a71672db04d7e157" translate="yes" xml:space="preserve">
          <source>Cancel an assertion with the predicate &lt;var&gt;predicate&lt;/var&gt; and answer &lt;var&gt;answer&lt;/var&gt;.</source>
          <target state="translated">Отмените утверждение с помощью предиката &lt;var&gt;predicate&lt;/var&gt; и ответного &lt;var&gt;answer&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="59d15eea66865b0282cb17c0e3120ed653071f95" translate="yes" xml:space="preserve">
          <source>Cancel any previous definition of &lt;var&gt;name&lt;/var&gt;, either built in or provided with a</source>
          <target state="translated">Отменить любое предыдущее определение &lt;var&gt;name&lt;/var&gt; , встроенное или снабженное</target>
        </trans-unit>
        <trans-unit id="192387cfc73b539ff900c725ddee4d021db73db5" translate="yes" xml:space="preserve">
          <source>Casting to union type from any member of the union.</source>
          <target state="translated">Кастинг по типу профсоюза от любого члена профсоюза.</target>
        </trans-unit>
        <trans-unit id="b08eca4544a17d0207cde77668a933d9951e246a" translate="yes" xml:space="preserve">
          <source>Cause gas to print out tomcat statistics.</source>
          <target state="translated">Потому что газ распечатывает статистику по Томкату.</target>
        </trans-unit>
        <trans-unit id="5a1bd09378f19d49cb410444dadaeb9f88738a8a" translate="yes" xml:space="preserve">
          <source>Cause the errors having to do with files that have the wrong architecture to be fatal.</source>
          <target state="translated">Причина,по которой ошибки связаны с файлами,которые имеют неправильную архитектуру,является фатальной.</target>
        </trans-unit>
        <trans-unit id="5019333f8c270c0e57b171951e0397047e39d35e" translate="yes" xml:space="preserve">
          <source>Causes GCC to remember the state of the diagnostics as of each &lt;code&gt;push&lt;/code&gt;, and restore to that point at each &lt;code&gt;pop&lt;/code&gt;. If a &lt;code&gt;pop&lt;/code&gt; has no matching &lt;code&gt;push&lt;/code&gt;, the command-line options are restored.</source>
          <target state="translated">Причины GCC вспомнить состояние диагностики, каждый &lt;code&gt;push&lt;/code&gt; и восстановление в эту точку в каждой &lt;code&gt;pop&lt;/code&gt; . Если для &lt;code&gt;pop&lt;/code&gt; нет подходящего &lt;code&gt;push&lt;/code&gt; , восстанавливаются параметры командной строки.</target>
        </trans-unit>
        <trans-unit id="667cccec716e1283ccef9e29985511e0bdf9e0a0" translate="yes" xml:space="preserve">
          <source>Causes all functions to default to the &lt;code&gt;.far&lt;/code&gt; section. Without this option, functions default to the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">По умолчанию для всех функций используется раздел &lt;code&gt;.far&lt;/code&gt; . Без этого параметра функции по умолчанию &lt;code&gt;.near&lt;/code&gt; разделе .near .</target>
        </trans-unit>
        <trans-unit id="e30905206e2b1ac1064f6ac3bbe5bd6c803a6b79" translate="yes" xml:space="preserve">
          <source>Causes all variables to default to the &lt;code&gt;.tiny&lt;/code&gt; section. Note that there is a 65536-byte limit to this section. Accesses to these variables use the &lt;code&gt;%gp&lt;/code&gt; base register.</source>
          <target state="translated">Заставляет все переменные по умолчанию &lt;code&gt;.tiny&lt;/code&gt; разделу .tiny . Обратите внимание, что этот раздел ограничен 65536 байтами. Для доступа к этим переменным используется базовый регистр &lt;code&gt;%gp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98be0c7de301463de1c80070885a43330018a0b2" translate="yes" xml:space="preserve">
          <source>Causes constant variables to be placed in the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">Помещает постоянные переменные в секцию &lt;code&gt;.near&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="655599ac8eaa0291e221b62364ffdf96a51309de" translate="yes" xml:space="preserve">
          <source>Causes the output file to be marked such that the dynamic linker will bind all undefined references when the file is loaded or launched.</source>
          <target state="translated">Заставляет выходной файл быть помеченным таким образом,что динамический компоновщик будет связывать все неопределённые ссылки при загрузке или запуске файла.</target>
        </trans-unit>
        <trans-unit id="c48452dfc4582d4eee857576d8fb13bb7694884b" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.far&lt;/code&gt; section by default.</source>
          <target state="translated">По умолчанию &lt;code&gt;.far&lt;/code&gt; присваивать переменные разделу .far .</target>
        </trans-unit>
        <trans-unit id="13cb136a09a7c1b01f2dc417dcf7c22b8038c03d" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.near&lt;/code&gt; section by default.</source>
          <target state="translated">Заставляет по умолчанию присваивать &lt;code&gt;.near&lt;/code&gt; секции .near .</target>
        </trans-unit>
        <trans-unit id="efdb8f56a4df91a529ce6b66e59857019a48ac1f" translate="yes" xml:space="preserve">
          <source>Certain ABI-changing flags are required to match in all compilation units, and trying to override this at link time with a conflicting value is ignored. This includes options such as</source>
          <target state="translated">Определенные флаги,изменяющие ABI,должны совпадать во всех модулях компиляции,и попытка переопределить это во время соединения с конфликтующим значением игнорируется.Это включает в себя такие опции,как</target>
        </trans-unit>
        <trans-unit id="a8db3b10d95cbc07c88dbe64efa680baa0d22c3b" translate="yes" xml:space="preserve">
          <source>Certain local variables aren&amp;rsquo;t recognized by debuggers when you compile with optimization.</source>
          <target state="translated">Некоторые локальные переменные не распознаются отладчиками при компиляции с оптимизацией.</target>
        </trans-unit>
        <trans-unit id="be7c527dd55f67d739c97b4f416bd42f396b0844" translate="yes" xml:space="preserve">
          <source>Cfront model</source>
          <target state="translated">передняя модель</target>
        </trans-unit>
        <trans-unit id="1aba59b0fc2fb3ed3ce5d3423cf83addc1f152f7" translate="yes" xml:space="preserve">
          <source>Change ABI to use double word insns.</source>
          <target state="translated">Измените ABI,чтобы использовать двойные вставки.</target>
        </trans-unit>
        <trans-unit id="9f8ed70cb1d356e0b695cceb7ab02d866b216534" translate="yes" xml:space="preserve">
          <source>Change paragraph 1</source>
          <target state="translated">Изменить пункт 1</target>
        </trans-unit>
        <trans-unit id="3cb692fbb429d564d86c14c1772ab21a4cec5d73" translate="yes" xml:space="preserve">
          <source>Change paragraph 2</source>
          <target state="translated">Изменить пункт 2</target>
        </trans-unit>
        <trans-unit id="9b9fbfc9cacb726e629a9636bbe98d28a8d83b9b" translate="yes" xml:space="preserve">
          <source>Change paragraph 2 to</source>
          <target state="translated">Изменить пункт 2 на</target>
        </trans-unit>
        <trans-unit id="cb241f39f5fa8625fba68e7d9da30611af7534b7" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IBM extended-precision long double. This is not likely to work if your system defaults to using IEEE extended-precision long double. If you change the long double type from IEEE extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">Измените текущий ABI,чтобы использовать IBM расширенной точности длинной двойной.Вряд ли это сработает,если ваша система по умолчанию использует IEEE extended-precision long double.Если вы измените тип long double с расширенной точности IEEE,компилятор выдаст предупреждение,если только вы не используете параметр</target>
        </trans-unit>
        <trans-unit id="8b05bb4515e125b765f13f146e5cba54744fff37" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IEEE extended-precision long double. This is not likely to work if your system defaults to using IBM extended-precision long double. If you change the long double type from IBM extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">Измените текущий ABI,чтобы использовать IEEE расширенной точности длинной двойной.Вряд ли это сработает,если ваша система по умолчанию будет использовать IBM с расширенной точностью long double.Если вы измените тип long double с расширенной точности IBM,компилятор выдаст предупреждение,если только вы не используете параметр</target>
        </trans-unit>
        <trans-unit id="24cf332293e237ad325e62a5ee2905fadea5402b" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv1 ABI. This is the default ABI for big-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">Измените текущий ABI,чтобы использовать ELFv1 ABI.Это ABI по умолчанию для big-endian PowerPC 64-bit Linux.Переопределение ABI по умолчанию требует специальной поддержки системы и,скорее всего,даст сбои эффектным способом.</target>
        </trans-unit>
        <trans-unit id="8ed54cd4038a43f7d20137c040c4f60546641dbf" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv2 ABI. This is the default ABI for little-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">Измените текущий ABI,чтобы использовать ELFv2 ABI.Это ABI по умолчанию для little-endian PowerPC 64-bit Linux.Переопределение ABI по умолчанию требует специальной поддержки системы и,скорее всего,даст сбои эффектным способом.</target>
        </trans-unit>
        <trans-unit id="85a1bd4814c92b33b933c24808e3438fdd28e471" translate="yes" xml:space="preserve">
          <source>Change the preferred SIMD mode to SImode. The default is</source>
          <target state="translated">Измените предпочтительный режим SIMD на SImode.По умолчанию</target>
        </trans-unit>
        <trans-unit id="1693787c0c1da76f7df927835bc9d253ab1baa96" translate="yes" xml:space="preserve">
          <source>Change the target of the rule emitted by dependency generation. By default CPP takes the name of the main input file, deletes any directory components and any file suffix such as &amp;lsquo;</source>
          <target state="translated">Измените цель правила, созданного генерацией зависимости. По умолчанию CPP принимает имя основного входного файла, удаляет все компоненты каталога и любой суффикс файла, например '</target>
        </trans-unit>
        <trans-unit id="aca39a5b032e87a9c462bafacf2e62ade09bc55e" translate="yes" xml:space="preserve">
          <source>Check calls to &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;, etc., to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense. This includes standard functions, and others specified by format attributes (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), in the &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; and &lt;code&gt;strfmon&lt;/code&gt; (an X/Open extension, not in the C standard) families (or other target-specific families). Which functions are checked without format attributes having been specified depends on the standard version selected, and such checks of functions without the attribute specified are disabled by</source>
          <target state="translated">Проверьте вызовы &lt;code&gt;printf&lt;/code&gt; и &lt;code&gt;scanf&lt;/code&gt; и т. Д., Чтобы убедиться, что предоставленные аргументы имеют типы, соответствующие указанной строке формата, и что преобразования, указанные в строке формата, имеют смысл. Сюда входят стандартные функции и другие, определенные атрибутами формата (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), в семействах &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; , &lt;code&gt;strftime&lt;/code&gt; и &lt;code&gt;strfmon&lt;/code&gt; (расширение X / Open, не в стандарте C) (или других целевых семействах). Какие функции проверяются без указания атрибутов формата, зависит от выбранной стандартной версии, и такие проверки функций без указанного атрибута отключаются</target>
        </trans-unit>
        <trans-unit id="c6a3f453fdd63ac92077276df83570873739aa07" translate="yes" xml:space="preserve">
          <source>Check for 64 bits wide constants for add/sub instructions</source>
          <target state="translated">Проверьте наличие констант шириной 64 бита для получения инструкций по добавлению/выводу.</target>
        </trans-unit>
        <trans-unit id="fac4c7c683a989d8b06bb9ece7f678cee49ed294" translate="yes" xml:space="preserve">
          <source>Check that the pointer returned by &lt;code&gt;operator new&lt;/code&gt; is non-null before attempting to modify the storage allocated. This check is normally unnecessary because the C++ standard specifies that &lt;code&gt;operator new&lt;/code&gt; only returns &lt;code&gt;0&lt;/code&gt; if it is declared &lt;code&gt;throw()&lt;/code&gt;, in which case the compiler always checks the return value even without this option. In all other cases, when &lt;code&gt;operator new&lt;/code&gt; has a non-empty exception specification, memory exhaustion is signalled by throwing &lt;code&gt;std::bad_alloc&lt;/code&gt;. See also &amp;lsquo;</source>
          <target state="translated">Перед попыткой изменить выделенное хранилище убедитесь, что указатель, возвращаемый &lt;code&gt;operator new&lt;/code&gt; равен нулю. В этой проверке обычно нет необходимости, поскольку стандарт C ++ указывает, что &lt;code&gt;operator new&lt;/code&gt; возвращает &lt;code&gt;0&lt;/code&gt; только в том случае, если он объявлен &lt;code&gt;throw()&lt;/code&gt; , и в этом случае компилятор всегда проверяет возвращаемое значение даже без этой опции. Во всех остальных случаях, когда &lt;code&gt;operator new&lt;/code&gt; имеет непустую спецификацию исключения, об исчерпании памяти сигнализирует &lt;code&gt;std::bad_alloc&lt;/code&gt; . Смотрите также '</target>
        </trans-unit>
        <trans-unit id="81e890de105f29124c3560894740b09b086a655a" translate="yes" xml:space="preserve">
          <source>Check the code for syntax errors, but don&amp;rsquo;t do anything beyond that.</source>
          <target state="translated">Проверьте код на наличие синтаксических ошибок, но не делайте ничего, кроме этого.</target>
        </trans-unit>
        <trans-unit id="5b609f7a36a96f87c3d3229801dbbe278531362e" translate="yes" xml:space="preserve">
          <source>Checking the number and type of arguments to a function which has an old-fashioned definition and no prototype.</source>
          <target state="translated">Проверка числа и типа аргументов функции,которая имеет старомодное определение и не имеет прототипа.</target>
        </trans-unit>
        <trans-unit id="fd9acb009d6a873fdb579dcb1f012d6d507dcf76" translate="yes" xml:space="preserve">
          <source>Choose a data model. The choices for &lt;var&gt;model&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">Выберите модель данных. Выбор &lt;var&gt;model&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="8d3369d8e5fea9b901b46c632d20401df2fdb02c" translate="yes" xml:space="preserve">
          <source>Choose between the two available implementations of</source>
          <target state="translated">Выбирайте между двумя доступными реализациями</target>
        </trans-unit>
        <trans-unit id="41e3a1c87aff0500a839e105b5b619da6d89b8a6" translate="yes" xml:space="preserve">
          <source>Choose integer type as 32-bit wide.</source>
          <target state="translated">Выберите целочисленный тип шириной 32 бита.</target>
        </trans-unit>
        <trans-unit id="fd477ac5e4063d79ef6de9d30fdf3c13757351dd" translate="yes" xml:space="preserve">
          <source>Choose startup files and linker script suitable for the simulator.</source>
          <target state="translated">Выберите стартовые файлы и компоновочный скрипт,подходящий для симулятора.</target>
        </trans-unit>
        <trans-unit id="a7c124dc3d6f2fff1283f2960f19679f618eb758" translate="yes" xml:space="preserve">
          <source>Chopped rounding mode. Floating-point numbers are rounded towards zero.</source>
          <target state="translated">Режим рубленого округления.Числа с плавающей точкой округляются до нуля.</target>
        </trans-unit>
        <trans-unit id="baeeaf6c90ab7667596e853c19ec9377ba1a6bed" translate="yes" xml:space="preserve">
          <source>Chunk size of omp schedule for loops parallelized by parloops.</source>
          <target state="translated">Размер кусочка расписания ОМП для циклов,распараллеленных парлупами.</target>
        </trans-unit>
        <trans-unit id="39f6c5316b94c42ede9e8f3c0902f04af5a47ac9" translate="yes" xml:space="preserve">
          <source>Clobber descriptions may not in any way overlap with an input or output operand. For example, you may not have an operand describing a register class with one member when listing that register in the clobber list. Variables declared to live in specific registers (see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;) and used as &lt;code&gt;asm&lt;/code&gt; input or output operands must have no part mentioned in the clobber description. In particular, there is no way to specify that input operands get modified without also specifying them as output operands.</source>
          <target state="translated">Описания Clobber ни в коем случае не могут совпадать с входным или выходным операндом. Например, у вас может не быть операнда, описывающего класс регистров с одним членом, при перечислении этого регистра в списке clobber. Переменные, объявленные как живущие в определенных регистрах (см. &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Явные переменные регистров&lt;/a&gt; ) и используемые как входные или выходные операнды &lt;code&gt;asm&lt;/code&gt; , не должны иметь части, упомянутой в описании clobber. В частности, невозможно указать, что входные операнды изменяются, не указав их также как выходные операнды.</target>
        </trans-unit>
        <trans-unit id="e7d5e82c3d8cf6aecb50f1c3dec1dfd81862c300" translate="yes" xml:space="preserve">
          <source>Code Generation Options</source>
          <target state="translated">Опции генерации кода</target>
        </trans-unit>
        <trans-unit id="de73aa04e00c631b2bba60472a9b4cb42f90647b" translate="yes" xml:space="preserve">
          <source>Code generation tweaks that disable, respectively, splitting of 32-bit loads, generation of post-increment addresses, and generation of post-modify addresses. The defaults are</source>
          <target state="translated">Твики генерации кода,отключающие,соответственно,разделение 32-битных загрузок,генерацию пост-инкрементных адресов и генерацию пост-модифицированных адресов.По умолчанию</target>
        </trans-unit>
        <trans-unit id="0acb8ba8662201458fc8762cdc2bfb973da3d9b7" translate="yes" xml:space="preserve">
          <source>Code like this may run successfully under some other compilers, particularly obsolete cfront-based compilers that delete temporaries along with normal local variables. However, the GNU C++ behavior is standard-conforming, so if your program depends on late destruction of temporaries it is not portable.</source>
          <target state="translated">Подобный код может успешно работать под управлением некоторых других компиляторов,в частности,устаревших компиляторов на основе cfront,которые удаляют временные файлы вместе с обычными локальными переменными.Однако поведение GNU C++соответствует стандартам,так что если ваша программа зависит от позднего уничтожения временных переменных,она не переносится.</target>
        </trans-unit>
        <trans-unit id="d477ef0f890f99da791a35a9c4922d4a6b4caa9b" translate="yes" xml:space="preserve">
          <source>Code that (effectively) clobbers bits of &lt;code&gt;SREG&lt;/code&gt; other than the &lt;code&gt;I&lt;/code&gt;-flag by writing to the memory location of &lt;code&gt;SREG&lt;/code&gt;.</source>
          <target state="translated">Код, который (эффективно) уничтожает биты &lt;code&gt;SREG&lt;/code&gt; , отличные от &lt;code&gt;I&lt;/code&gt; -flag, путем записи в ячейку памяти &lt;code&gt;SREG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22aee03764143c3347036737d5c49aa3c48b93fe" translate="yes" xml:space="preserve">
          <source>Code that uses inline assembler to jump to a different function which expects (parts of) the prologue code as outlined above to be present.</source>
          <target state="translated">Код,который использует встроенный ассемблер для перехода к другой функции,которая ожидает (часть)пролог-кода,как описано выше.</target>
        </trans-unit>
        <trans-unit id="a04d4be0af028c55d37a5eda8e2e9e52e00d9883" translate="yes" xml:space="preserve">
          <source>Collect and dump debug information into a temporary file if an internal compiler error (ICE) occurs.</source>
          <target state="translated">Сбор и выгрузка отладочной информации во временный файл при возникновении ошибки внутреннего компилятора (ICE).</target>
        </trans-unit>
        <trans-unit id="3de9bf73c20469d02f33a82c6c1b964c35ca72c5" translate="yes" xml:space="preserve">
          <source>Collect the profiles for different set of inputs, and use this tool to merge them. One can specify the weight to factor in the relative importance of each input.</source>
          <target state="translated">Соберите профили для различных наборов входов и используйте этот инструмент для их объединения.Можно задать вес к фактору в относительной важности каждого входа.</target>
        </trans-unit>
        <trans-unit id="674fdd25c0f94978ce5404bf7783af22ebecb1fb" translate="yes" xml:space="preserve">
          <source>Combine increments or decrements of addresses with memory accesses. This pass is always skipped on architectures that do not have instructions to support this. Enabled by default at</source>
          <target state="translated">Комбинируйте инкременты или декременты адресов с доступом к памяти.Этот проход всегда пропускается на архитектурах,которые не имеют инструкций для поддержки этого.Включено по умолчанию на</target>
        </trans-unit>
        <trans-unit id="5c675961000becf8ff6422c0eeb1b9242b5fdf0f" translate="yes" xml:space="preserve">
          <source>Combines the effects of both &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">Сочетает в себе эффекты &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; и &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4393d8b520a9b50ddef09d9f77984a620fcf38de" translate="yes" xml:space="preserve">
          <source>Combining several classes is possible, although this usually restricts the output so much that there is nothing to display. One case where it does work, however, is when one of the classes is &lt;var&gt;target&lt;/var&gt;. For example, to display all the target-specific optimization options, use:</source>
          <target state="translated">Возможно объединение нескольких классов, хотя обычно это настолько ограничивает вывод, что отображать нечего. Однако один из случаев, когда это действительно работает, - это когда один из классов является &lt;var&gt;target&lt;/var&gt; . Например, чтобы отобразить все параметры оптимизации для конкретной цели, используйте:</target>
        </trans-unit>
        <trans-unit id="72a257637f31b3509bd8ac95d015b26d1c5d9ce9" translate="yes" xml:space="preserve">
          <source>Command options supported by &amp;lsquo;</source>
          <target state="translated">Параметры команды, поддерживаемые '</target>
        </trans-unit>
        <trans-unit id="8e5bbd00924927db3116b7ce896a99d0d6c09a71" translate="yes" xml:space="preserve">
          <source>Commit the current transaction. When no transaction is active this faults. All memory side effects of the transaction become visible to other threads in an atomic manner.</source>
          <target state="translated">Совершить текущую сделку.Когда ни одна транзакция не активна,этот дефект.Все побочные эффекты памяти транзакции становятся видимы другим потокам атомарным образом.</target>
        </trans-unit>
        <trans-unit id="953dbfff4f1c2d7c9623cfa81345a412c8c95e6f" translate="yes" xml:space="preserve">
          <source>Common misunderstandings with GNU C++.</source>
          <target state="translated">Распространенные недоразумения с GNU C++.</target>
        </trans-unit>
        <trans-unit id="99484341af697bedb30f82944a2b8048a7bd9d3b" translate="yes" xml:space="preserve">
          <source>Compare at most &lt;var&gt;num&lt;/var&gt; string bytes with inline code. If the difference or end of string is not found at the end of the inline compare a call to &lt;code&gt;strcmp&lt;/code&gt; or &lt;code&gt;strncmp&lt;/code&gt; will take care of the rest of the comparison. The default is 64 bytes.</source>
          <target state="translated">Сравните не более &lt;var&gt;num&lt;/var&gt; байтов строки со встроенным кодом. Если разница или конец строки не найдены в конце встроенного сравнения, вызов &lt;code&gt;strcmp&lt;/code&gt; или &lt;code&gt;strncmp&lt;/code&gt; позаботится об остальном сравнении. По умолчанию 64 байта.</target>
        </trans-unit>
        <trans-unit id="7e11797436f7910f8bb83ca2860c72513034685a" translate="yes" xml:space="preserve">
          <source>Comparison of four paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any4t&lt;/code&gt;/&lt;code&gt;bc1any4f&lt;/code&gt;).</source>
          <target state="translated">Сравнение четырех парных отдельных значений ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1any4t&lt;/code&gt; / &lt;code&gt;bc1any4f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8cb7f422f46057d6869362d0511c9090d3a1fd7" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">Сравнение двух парных отдельных значений ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11a9160f31b23e32c54ba7fe5458de10730189d9" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any2t&lt;/code&gt;/&lt;code&gt;bc1any2f&lt;/code&gt;).</source>
          <target state="translated">Сравнение двух парных отдельных значений ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1any2t&lt;/code&gt; / &lt;code&gt;bc1any2f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="651d13a7683a8781ee0feea932b0d34d198ddce8" translate="yes" xml:space="preserve">
          <source>Comparison operations.</source>
          <target state="translated">Сравнительные операции.</target>
        </trans-unit>
        <trans-unit id="1adbeb956bb205e79fa3fa9ca1c2daca593fb1fa" translate="yes" xml:space="preserve">
          <source>Compatibilities with earlier definitions of C++.</source>
          <target state="translated">Сопоставимость с более ранними определениями С++.</target>
        </trans-unit>
        <trans-unit id="51c2b0659cd05018587a8d43545227600a32a376" translate="yes" xml:space="preserve">
          <source>Compilation can involve up to four stages: preprocessing, compilation proper, assembly and linking, always in that order. GCC is capable of preprocessing and compiling several files either into several assembler input files, or into one assembler input file; then each assembler input file produces an object file, and linking combines all the object files (those newly compiled, and those specified as input) into an executable file.</source>
          <target state="translated">Компиляция может включать до четырех этапов:препроцессирование,собственно компиляция,сборка и связывание,всегда в таком порядке.GCC способен препроцессировать и скомпилировать несколько файлов либо в несколько входных файлов ассемблера,либо в один входной файл ассемблера;затем каждый входной файл ассемблера создает объектный файл,а компоновка объединяет все объектные файлы (те,которые только что скомпилированы,и те,которые указаны как входные)в исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="1f490d968ba17b1a6b9c49acd428a6392e787830" translate="yes" xml:space="preserve">
          <source>Compile ARCv2 code with a multiplier design option. You can specify the option using either a string or numeric value for &lt;var&gt;multo&lt;/var&gt;. &amp;lsquo;</source>
          <target state="translated">Скомпилируйте код ARCv2 с возможностью разработки множителя. Вы можете указать параметр, используя строковое или числовое значение для &lt;var&gt;multo&lt;/var&gt; . '</target>
        </trans-unit>
        <trans-unit id="4a90dd66273f8436ce33369f342227123629a080" translate="yes" xml:space="preserve">
          <source>Compile code assuming that IEEE signaling NaNs may generate user-visible traps during floating-point operations. Setting this option disables optimizations that may change the number of exceptions visible with signaling NaNs. This option implies</source>
          <target state="translated">Скомпилируйте код,предполагая,что IEEE-сигнализация NaNs может генерировать видимые пользователю ловушки во время операций с плавающей точкой.Установка данной опции отключает оптимизацию,которая может изменить количество исключений,видимых при сигнализации NaNs.Данная опция подразумевает</target>
        </trans-unit>
        <trans-unit id="9970fa5395affc7dc93ea1ed06f8fdd6c082c5bc" translate="yes" xml:space="preserve">
          <source>Compile code assuming that floating-point operations cannot generate user-visible traps. These traps include division by zero, overflow, underflow, inexact result and invalid operation. This option requires that</source>
          <target state="translated">Скомпилируйте код,предполагая,что операции с плавающей точкой не могут генерировать видимые пользователю ловушки.Эти ловушки включают деление на ноль,переполнение,недолив,неточный результат и недействительную операцию.Эта опция требует,чтобы</target>
        </trans-unit>
        <trans-unit id="7167229840a9f09cf85e4d3c02813e6e3f7c2954" translate="yes" xml:space="preserve">
          <source>Compile code assuming that pointers to the PPU address space accessed via the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier are either 32 or 64 bits wide. The default is 32 bits. As this is an ABI-changing option, all object code in an executable must be compiled with the same setting.</source>
          <target state="translated">Компиляция кода предполагает, что указатели на адресное пространство PPU, доступ к которому осуществляется через &lt;code&gt;__ea&lt;/code&gt; именованного адресного пространства __ea, имеют ширину 32 или 64 бита. По умолчанию 32 бита. Поскольку это параметр, изменяющий ABI, весь объектный код в исполняемом файле должен быть скомпилирован с одинаковыми настройками.</target>
        </trans-unit>
        <trans-unit id="31103695d6eecad4fc985951c0af142d11cd5c1a" translate="yes" xml:space="preserve">
          <source>Compile code compatible with Android platform. This is the default on &amp;lsquo;</source>
          <target state="translated">Скомпилируйте код, совместимый с платформой Android. Это значение по умолчанию включено '</target>
        </trans-unit>
        <trans-unit id="894efb97728307a39eeed2699c1c4e4bd26dd9dc" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian mode. This is the default.</source>
          <target state="translated">Скомпилируйте код для режима big-endian.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="d1832ee4b35f2abfa3f4e141edadd28f18085110" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian targets. Use of these options is now deprecated. Big-endian code is supported by configuring GCC to build &lt;code&gt;arceb-elf32&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets, for which big endian is the default.</source>
          <target state="translated">Скомпилируйте код для целей с прямым порядком байтов. Использование этих параметров теперь не рекомендуется. Код с &lt;code&gt;arceb-elf32&lt;/code&gt; байтов поддерживается путем настройки GCC для построения целей arceb-elf32 и &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; , для которых по умолчанию используется прямой порядок байтов.</target>
        </trans-unit>
        <trans-unit id="be8c22e36ad1f39109ec2efd6cc1a81d955acd13" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian mode.</source>
          <target state="translated">Скомпилируйте код для режима little-endian.</target>
        </trans-unit>
        <trans-unit id="9b8ec4f965ec58185bb6754ac805aafeb89d3ae4" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian targets. Use of these options is now deprecated. Little-endian code is supported by configuring GCC to build &lt;code&gt;arc-elf32&lt;/code&gt; and &lt;code&gt;arc-linux-uclibc&lt;/code&gt; targets, for which little endian is the default.</source>
          <target state="translated">Скомпилируйте код для целей с прямым порядком байтов. Использование этих параметров теперь не рекомендуется. Код с &lt;code&gt;arc-elf32&lt;/code&gt; байтов поддерживается путем настройки GCC для построения целей arc-elf32 и &lt;code&gt;arc-linux-uclibc&lt;/code&gt; , для которых по умолчанию используется прямой порядок байтов.</target>
        </trans-unit>
        <trans-unit id="b9cb11574bb395057387b096cea7b6d6f515f971" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in big-endian mode.</source>
          <target state="translated">Скомпилируйте код для процессора в режиме big-endian.</target>
        </trans-unit>
        <trans-unit id="9f489feb9b6caedf9bb6320c99f84e7364f3077b" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in little-endian mode.</source>
          <target state="translated">Скомпилируйте код для процессора в режиме little-endian.</target>
        </trans-unit>
        <trans-unit id="39bc5e8e166e8b03d8be316efdd326cda59c0f57" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">Компиляция для ЦП ARC 600 с включенными инструкциями &lt;code&gt;norm&lt;/code&gt; и 32x16-битного умножения.</target>
        </trans-unit>
        <trans-unit id="17be7dfb615c6d886c0d693b9048e7e155b99fb6" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">Компиляция для процессора ARC 600 с &lt;code&gt;mul64&lt;/code&gt; командами &lt;code&gt;norm&lt;/code&gt; и mul64 -family.</target>
        </trans-unit>
        <trans-unit id="d7f2d72dcd31900923f3da8d539cfc9292aa3f8e" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">Скомпилировать для ЦП ARC 600 с включенными инструкциями &lt;code&gt;norm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16696f4c8426aaf6854eeea45ee7e1bd467edd27" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">Компиляция для ЦП ARC 601 с включенными инструкциями &lt;code&gt;norm&lt;/code&gt; и 32x16-битного умножения.</target>
        </trans-unit>
        <trans-unit id="5bca932c9c4e343d44b89be260ad06bfe429ab8a" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">Компиляция для процессора ARC 601 с &lt;code&gt;mul64&lt;/code&gt; командами &lt;code&gt;norm&lt;/code&gt; и mul64 -family.</target>
        </trans-unit>
        <trans-unit id="02df7632e889a6c5616971f35e12edcc4a5d8c62" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">Скомпилируйте для ЦП ARC 601 с включенными инструкциями &lt;code&gt;norm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7fdc4d4b7214e5e7819e3d3a90236053d8b22cd" translate="yes" xml:space="preserve">
          <source>Compile for ARC 700 on NPS400 chip.</source>
          <target state="translated">Скомпилируйте для ARC 700 на чипе NPS400.</target>
        </trans-unit>
        <trans-unit id="1e4380f255d2d18d4e8f267e7678f7435eab73b8" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM CPU with no hardware extensions.</source>
          <target state="translated">Скомпилируйте для процессора ARC EM без аппаратных расширений.</target>
        </trans-unit>
        <trans-unit id="d617eff21e80138509c5fb71d3dfb75e71687f6e" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM minimalist configuration featuring reduced register set.</source>
          <target state="translated">Скомпилируйте для ARC EM минималистскую конфигурацию с уменьшенным набором регистров.</target>
        </trans-unit>
        <trans-unit id="75b4e707d87f6b65d51c529906a072e95ff89b29" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM.</source>
          <target state="translated">Скомпилируйте для ARC EM.</target>
        </trans-unit>
        <trans-unit id="da70dd835733600356587db74a19ff09214dbd17" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 CPU.</source>
          <target state="translated">Скомпилируйте для процессора ARC EM4.</target>
        </trans-unit>
        <trans-unit id="a460d3a31969ec154e7b1632e56830c60250b541" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with single-precision floating-point and double assist instructions.</source>
          <target state="translated">Скомпилируйте для процессора ARC EM4 DMIPS с одинарной точностью с плавающей запятой и двойными инструкциями помощи.</target>
        </trans-unit>
        <trans-unit id="a5b00683884602ca4044736a233bc8c892a0f636" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with the single-precision floating-point extension.</source>
          <target state="translated">Скомпилируйте для ARC EM4 DMIPS процессор с расширением с плавающей запятой с одинарной точностью.</target>
        </trans-unit>
        <trans-unit id="88b1ffe9efdf7ea63c9f3422bb5547df94d22ce1" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU.</source>
          <target state="translated">Скомпилируйте для процессора ARC EM4 DMIPS.</target>
        </trans-unit>
        <trans-unit id="086d9196358fe7f0fa7f3e7051ae4fc4f433b7ae" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS CPU with no hardware extensions except the atomic instructions.</source>
          <target state="translated">Скомпилируйте для HS процессора ARC без аппаратных расширений,кроме атомарных инструкций.</target>
        </trans-unit>
        <trans-unit id="cacfee18847f11dad685598d36ea6ee3b6957c02" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS.</source>
          <target state="translated">Соберитесь для ARC HS.</target>
        </trans-unit>
        <trans-unit id="847cd27652d52b58f36a4f2e5ea5cead4371673c" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS34 CPU.</source>
          <target state="translated">Скомпилируйте для процессора ARC HS34.</target>
        </trans-unit>
        <trans-unit id="d44b3581972b8ea0a69f39fb0ebefd762b42bbe7" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU with all hardware extensions on.</source>
          <target state="translated">Скомпилируйте для процессора ARC HS38 со всеми аппаратными расширениями.</target>
        </trans-unit>
        <trans-unit id="4c711906d8e4d4a87fb48440c2cfaa0c80bee620" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU.</source>
          <target state="translated">Скомпилируйте для процессора ARC HS38.</target>
        </trans-unit>
        <trans-unit id="8348ca27592b892d967948ee652e94376f711101" translate="yes" xml:space="preserve">
          <source>Compile for ARC600. Aliases:</source>
          <target state="translated">Соберитесь для ARC600.Псевдонимы:</target>
        </trans-unit>
        <trans-unit id="9c0fc8bbbde2253a58a83a11623bea243e8a7c8b" translate="yes" xml:space="preserve">
          <source>Compile for ARC601. Alias:</source>
          <target state="translated">Сбор для ARC601.Псевдоним:</target>
        </trans-unit>
        <trans-unit id="05e0d990baf06011ef4d82bdf9df53fdce00286b" translate="yes" xml:space="preserve">
          <source>Compile for ARC700. Aliases:</source>
          <target state="translated">Соберитесь для ARC700.Псевдонимы:</target>
        </trans-unit>
        <trans-unit id="e278797da8990f0ccb7f07f045508cd4010b76aa" translate="yes" xml:space="preserve">
          <source>Compile for GCN3 Fiji devices (gfx803).</source>
          <target state="translated">Компиляция для устройств GCN3 Фиджи (gfx803).</target>
        </trans-unit>
        <trans-unit id="713b8f86530a1c2d9a5d702e486321c4dc351849" translate="yes" xml:space="preserve">
          <source>Compile for GCN5 Vega 10 devices (gfx900).</source>
          <target state="translated">Компиляция для устройств GCN5 Vega 10 (gfx900).</target>
        </trans-unit>
        <trans-unit id="b90b725a08b6d96eebe36b77a50cd90bcf52390d" translate="yes" xml:space="preserve">
          <source>Compile for GCN5 Vega 20 devices (gfx906).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c48f84ed7faf104f474152b0d3bc268ee56eba" translate="yes" xml:space="preserve">
          <source>Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</source>
          <target state="translated">Скомпилируйте или соберите исходные файлы,но не связывайте их.Этап компоновки просто не завершен.Окончательный результат получается в виде объектного файла для каждого исходного файла.</target>
        </trans-unit>
        <trans-unit id="aada22a2dba27d65c33f8d484ca9df970f74fa8a" translate="yes" xml:space="preserve">
          <source>Compile the source files additionally with</source>
          <target state="translated">Скомпилируйте исходные файлы дополнительно с</target>
        </trans-unit>
        <trans-unit id="8e1d1625ee50b70503b880bddd8c2899625cfd1d" translate="yes" xml:space="preserve">
          <source>Compile the source files with</source>
          <target state="translated">Скомпилируйте исходные файлы с</target>
        </trans-unit>
        <trans-unit id="bae2f3f4c4da22165b65f81f0ab47bfdf72e5a74" translate="yes" xml:space="preserve">
          <source>Compile your code with</source>
          <target state="translated">Скомпилируйте свой код с</target>
        </trans-unit>
        <trans-unit id="61a5380160ff93557be23ea688dad9be208e4dbd" translate="yes" xml:space="preserve">
          <source>Compile your template-using code with</source>
          <target state="translated">Скомпилируйте ваш код использования шаблонов с</target>
        </trans-unit>
        <trans-unit id="bb1fb4ab4c5c8120d8c582a624d0a9ac53f55fe3" translate="yes" xml:space="preserve">
          <source>Compiler encoding</source>
          <target state="translated">Кодировка компилятора</target>
        </trans-unit>
        <trans-unit id="24922f29f09454ba5b177fdcf5e81c9543043eef" translate="yes" xml:space="preserve">
          <source>Compiler support for type traits.</source>
          <target state="translated">Поддержка компилятора для типовых признаков.</target>
        </trans-unit>
        <trans-unit id="2d58377b2111c9408f411d965f3b8abfb37ec05b" translate="yes" xml:space="preserve">
          <source>Compiling C++ programs.</source>
          <target state="translated">Компиляция программ на С++.</target>
        </trans-unit>
        <trans-unit id="ed13de84ad4a0f0cd9e6bd0e630f5cc19d816c7d" translate="yes" xml:space="preserve">
          <source>Compiling a header once, and using it many times.</source>
          <target state="translated">Составить заголовок один раз,и использовать его много раз.</target>
        </trans-unit>
        <trans-unit id="a9cb191f84bf0e0a5fd4e8fafa0cbeb0ce255ebb" translate="yes" xml:space="preserve">
          <source>Compiling with</source>
          <target state="translated">Компиляция с</target>
        </trans-unit>
        <trans-unit id="8097f9a2f49c7bb34a8f3d4a23b5682dee4f13c4" translate="yes" xml:space="preserve">
          <source>Complex multiplication and division follow Fortran rules. Range reduction is done as part of complex division, but there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case.</source>
          <target state="translated">Сложное умножение и деление подчиняются правилам Фортрана. Уменьшение диапазона выполняется как часть сложного деления, но не проверяется, является ли результат сложного умножения или деления &lt;code&gt;NaN + I*NaN&lt;/code&gt; , с попыткой спасти ситуацию в этом случае.</target>
        </trans-unit>
        <trans-unit id="e323088fd5a174d70e9a002849c8a4e688bcae61" translate="yes" xml:space="preserve">
          <source>Complex types</source>
          <target state="translated">Типы комплексов</target>
        </trans-unit>
        <trans-unit id="a513e209b739423b55158eb7f0004ee614ede0ee" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined by Renesas.</source>
          <target state="translated">Выполнять соглашения о вызовах,определенные Ренесасом.</target>
        </trans-unit>
        <trans-unit id="7ca1263e4404b74af40b4e0106fd5b298bab578a" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined for GCC before the Renesas conventions were available. This option is the default for all targets of the SH toolchain.</source>
          <target state="translated">Соблюдать конвенции о призыве,определенные для ССАГПЗ,до того,как появились конвенции Ренезаса.Эта опция является стандартной для всех целей цепочки инструментов SH.</target>
        </trans-unit>
        <trans-unit id="8065b09eb57234d64105b727689f45402502d3a0" translate="yes" xml:space="preserve">
          <source>Compound literals for scalar types and union types are also allowed. In the following example the variable &lt;code&gt;i&lt;/code&gt; is initialized to the value &lt;code&gt;2&lt;/code&gt;, the result of incrementing the unnamed object created by the compound literal.</source>
          <target state="translated">Также разрешены составные литералы для скалярных типов и типов объединения. В следующем примере переменная &lt;code&gt;i&lt;/code&gt; инициализируется значением &lt;code&gt;2&lt;/code&gt; , результатом увеличения безымянного объекта, созданного составным литералом.</target>
        </trans-unit>
        <trans-unit id="a6bff82561ec7274ee97d8914e7822d45d55dda6" translate="yes" xml:space="preserve">
          <source>Compound literals give structures, unions or arrays as values.</source>
          <target state="translated">Сложные буквы дают структуры,союзы или массивы в качестве значений.</target>
        </trans-unit>
        <trans-unit id="9966e73a786b7c65f837b6274e264d2ae3402caf" translate="yes" xml:space="preserve">
          <source>Compress all code using the Ft32B code compression scheme.</source>
          <target state="translated">Сжатие всего кода с помощью схемы сжатия кода Ft32B.</target>
        </trans-unit>
        <trans-unit id="6c77d95794a767632393b14f518d98416da9d81b" translate="yes" xml:space="preserve">
          <source>Compute the overlap score between the two specified profile directories. The overlap score is computed based on the arc profiles. It is defined as the sum of min (p1_counter[i] / p1_sum_all, p2_counter[i] / p2_sum_all), for all arc counter i, where p1_counter[i] and p2_counter[i] are two matched counters and p1_sum_all and p2_sum_all are the sum of counter values in profile 1 and profile 2, respectively.</source>
          <target state="translated">Вычислите оценку перекрытия между двумя указанными каталогами профилей.Счетчик перекрытия вычисляется на основе дуговых профилей.Она определяется как сумма min (p1_counter[i]/p1_sum_all,p2_counter[i]/p2_sum_all),для всех счетчиков дуг i,где p1_counter[i]и p2_counter[i]-два совпадающих счетчика,а p1_sum_all и p2_sum_all-сумма значений счетчиков в профиле 1 и профиле 2 соответственно.</target>
        </trans-unit>
        <trans-unit id="e0428c06ffccfdc67cd165569d403d34631d68a4" translate="yes" xml:space="preserve">
          <source>Condition code register</source>
          <target state="translated">Регистр кодов условий</target>
        </trans-unit>
        <trans-unit id="0ae2a8a1d30f4ab16342776ecad8922a8468db3e" translate="yes" xml:space="preserve">
          <source>Condition register field 0, &lt;code&gt;cr0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7cba93bc22565aab9f967f87bf72c15fbda6979" translate="yes" xml:space="preserve">
          <source>Conditional move based on absolute comparison (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">Условный переход на основе абсолютных сравнения ( &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ef8ee622eb15147934b0f1ea15e7848c0fa98464" translate="yes" xml:space="preserve">
          <source>Conditional move based on floating-point comparison (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">Условный переход на основе сравнения с плавающей точкой ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="34fb4ffc803fecfe4e7aef7908f668b60686f196" translate="yes" xml:space="preserve">
          <source>Configure a board specific runtime. This will be passed to the linker for newlib board library linking. The default is &lt;code&gt;or1ksim&lt;/code&gt;.</source>
          <target state="translated">Настройте среду выполнения для конкретной платы. Он будет передан компоновщику для компоновки библиотеки новой библиотеки. По умолчанию - &lt;code&gt;or1ksim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73691e44c058afa420e3a5b298659ae385093f25" translate="yes" xml:space="preserve">
          <source>Conform to the language syntax of Objective-C 1.0, the language recognized by GCC 4.0. This only affects the Objective-C additions to the C/C++ language; it does not affect conformance to C/C++ standards, which is controlled by the separate C/C++ dialect option flags. When this option is used with the Objective-C or Objective-C++ compiler, any Objective-C syntax that is not recognized by GCC 4.0 is rejected. This is useful if you need to make sure that your Objective-C code can be compiled with older versions of GCC.</source>
          <target state="translated">Соответствует синтаксису языка Objective-C 1.0,язык,признанный GCC 4.0.Это касается только дополнений Objective-C к языку Си/Си++;это не влияет на соответствие стандартам языка Си/Си++,которое контролируется отдельными флагами опций диалекта Си/Си++.При использовании этой опции с компилятором Objective-C или Objective-C++любой синтаксис Objective-C,не распознаваемый GCC 4.0,отвергается.Это полезно,если Вам необходимо убедиться,что Ваш код Objective-C может быть скомпилирован со старыми версиями GCC.</target>
        </trans-unit>
        <trans-unit id="276327c90b14e9bc39dc498e6536c698c6fb7874" translate="yes" xml:space="preserve">
          <source>Conformance to the same ABI and the same behavior of implementation-defined features are both relevant for compatibility.</source>
          <target state="translated">Совместимость с одним и тем же ABI и одинаковое поведение реализации-определенных возможностей имеет значение для совместимости.</target>
        </trans-unit>
        <trans-unit id="af74bda50719fa1b3103b3627d3eb38149eb7313" translate="yes" xml:space="preserve">
          <source>Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration &lt;code&gt;T
D1&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; contains declaration specifiers that specify a type &lt;var&gt;Type&lt;/var&gt; (such as &lt;code&gt;int&lt;/code&gt;) and &lt;code&gt;D1&lt;/code&gt; is a declarator that contains an identifier &lt;var&gt;ident&lt;/var&gt;. The type specified for &lt;var&gt;ident&lt;/var&gt; for derived declarators whose type does not include an attribute specifier is as in the ISO C standard.</source>
          <target state="translated">Рассмотрим (как в подпункте 6.7.5 параграфа 4 C99) объявление &lt;code&gt;T D1&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; содержит спецификаторы объявления, которые определяют тип &lt;var&gt;Type&lt;/var&gt; (например, &lt;code&gt;int&lt;/code&gt; ), а &lt;code&gt;D1&lt;/code&gt; является декларатором, который содержит идентификатор &lt;var&gt;ident&lt;/var&gt; . Тип, указанный для &lt;var&gt;ident&lt;/var&gt; для производных деклараторов, тип которых не включает спецификатор атрибута, соответствует стандарту ISO C.</target>
        </trans-unit>
        <trans-unit id="9b667c089da7e561b4d6f55e12e93a78181226e5" translate="yes" xml:space="preserve">
          <source>Consider all &lt;code&gt;static&lt;/code&gt; functions called once for inlining into their caller even if they are not marked &lt;code&gt;inline&lt;/code&gt;. If a call to a given function is integrated, then the function is not output as assembler code in its own right.</source>
          <target state="translated">Рассмотрим все &lt;code&gt;static&lt;/code&gt; функции, вызываемые один раз для встраивания в вызывающий объект, даже если они не помечены как &lt;code&gt;inline&lt;/code&gt; . Если вызов данной функции интегрирован, то функция не выводится как код ассемблера сама по себе.</target>
        </trans-unit>
        <trans-unit id="35a3be8ed672f20c07ec027046430f867cf3e587" translate="yes" xml:space="preserve">
          <source>Consider all functions for inlining, even if they are not declared inline. The compiler heuristically decides which functions are worth integrating in this way.</source>
          <target state="translated">Рассмотрим все функции для встраивания,даже если они не объявлены в строке.Компилятор эвристически решает,какие функции стоит интегрировать таким образом.</target>
        </trans-unit>
        <trans-unit id="7b85816a30be72db5578a7db246b88f298f1a216" translate="yes" xml:space="preserve">
          <source>Consider that instructions that may throw exceptions but don&amp;rsquo;t otherwise contribute to the execution of the program can be optimized away. This option is enabled by default for the Ada front end, as permitted by the Ada language specification. Optimization passes that cause dead exceptions to be removed are enabled independently at different optimization levels.</source>
          <target state="translated">Учтите, что инструкции, которые могут генерировать исключения, но не вносят иной вклад в выполнение программы, можно оптимизировать. Эта опция включена по умолчанию для внешнего интерфейса Ada, как разрешено спецификацией языка Ada. Этапы оптимизации, которые вызывают удаление мертвых исключений, включаются независимо на разных уровнях оптимизации.</target>
        </trans-unit>
        <trans-unit id="56b80af072fa83ee95788ec24e46c4595598d634" translate="yes" xml:space="preserve">
          <source>Consider the following example,</source>
          <target state="translated">Рассмотрим следующий пример,</target>
        </trans-unit>
        <trans-unit id="a59af01b7f010c19c9dde4af8032ceeec0657a9d" translate="yes" xml:space="preserve">
          <source>Consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide, like &lt;code&gt;short int&lt;/code&gt;. Additionally, parameters passed on the stack are also aligned to a 16-bit boundary even on targets whose API mandates promotion to 32-bit.</source>
          <target state="translated">Считайте, что тип &lt;code&gt;int&lt;/code&gt; имеет ширину 16 бит, например &lt;code&gt;short int&lt;/code&gt; . Кроме того, параметры, передаваемые в стеке, также выравниваются по 16-битной границе даже для целей, API которых требует повышения до 32-битных.</target>
        </trans-unit>
        <trans-unit id="14249be6954dd348580bb1e0a79129f5f1192211" translate="yes" xml:space="preserve">
          <source>Constant 255.</source>
          <target state="translated">Постоянная 255.</target>
        </trans-unit>
        <trans-unit id="7c36129cdf24a616a089dfb7d284688c9138762e" translate="yes" xml:space="preserve">
          <source>Constant 65535.</source>
          <target state="translated">Постоянная 65535.</target>
        </trans-unit>
        <trans-unit id="7ebcf06cc87a00b632c948fbc204e56f0827cd01" translate="yes" xml:space="preserve">
          <source>Constant &lt;var&gt;n&lt;/var&gt;, where &lt;var&gt;n&lt;/var&gt; is a single-digit constant in the range 0 to 4.</source>
          <target state="translated">Константа &lt;var&gt;n&lt;/var&gt; , где &lt;var&gt;n&lt;/var&gt; - однозначная константа в диапазоне от 0 до 4.</target>
        </trans-unit>
        <trans-unit id="37323b42fe56e6f04c3dbbef4d9fbb95b7fc380b" translate="yes" xml:space="preserve">
          <source>Constant for arithmetic/logical operations. This is like &lt;code&gt;i&lt;/code&gt;, except that for position independent code, no symbols / expressions needing relocations are allowed.</source>
          <target state="translated">Константа для арифметических / логических операций. Это похоже на &lt;code&gt;i&lt;/code&gt; , за исключением того, что для независимого от позиции кода не допускаются символы / выражения, требующие перемещения.</target>
        </trans-unit>
        <trans-unit id="c7644d686263ca6ceaeace041caa08f8c6cf68aa" translate="yes" xml:space="preserve">
          <source>Constant greater than -1, less than 64</source>
          <target state="translated">Постоянно больше -1,меньше 64</target>
        </trans-unit>
        <trans-unit id="09c49e4a44186e5736b6b3d234fbcdd1b306818b" translate="yes" xml:space="preserve">
          <source>Constant greater than -64, less than 1</source>
          <target state="translated">Постоянно больше чем -64,меньше чем 1</target>
        </trans-unit>
        <trans-unit id="629c52a6147c82fa4c525c23e4812fa96465cd8a" translate="yes" xml:space="preserve">
          <source>Constant integer -1</source>
          <target state="translated">постоянное целое число -1</target>
        </trans-unit>
        <trans-unit id="721c7841ba7521d9d4cd87f007487a95dabae8a8" translate="yes" xml:space="preserve">
          <source>Constant integer 0</source>
          <target state="translated">Постоянное целое число 0</target>
        </trans-unit>
        <trans-unit id="4c0d77dad954cfa376cbed314919134fe483d92e" translate="yes" xml:space="preserve">
          <source>Constant integer 1</source>
          <target state="translated">постоянное целое число 1</target>
        </trans-unit>
        <trans-unit id="a0be78fc92c33b25cda27188d52e852922b4e406" translate="yes" xml:space="preserve">
          <source>Constant integer 2</source>
          <target state="translated">Постоянное целое число 2</target>
        </trans-unit>
        <trans-unit id="202072b2675376ab5d42618242f422abd21566ab" translate="yes" xml:space="preserve">
          <source>Constant integer 8, 16, or 24</source>
          <target state="translated">Постоянное целое число 8,16 или 24</target>
        </trans-unit>
        <trans-unit id="5bf3f3ad783e97cd6b61e26de5af436d02b8dbc8" translate="yes" xml:space="preserve">
          <source>Constant integer with a value of 0x7fffffff.</source>
          <target state="translated">Постоянное целое число со значением 0x7fffff.</target>
        </trans-unit>
        <trans-unit id="4b2e9b490d5b5f4c17de70d9c9fdf5aa2b4b1450" translate="yes" xml:space="preserve">
          <source>Constant larger than 31</source>
          <target state="translated">Постоянно более 31</target>
        </trans-unit>
        <trans-unit id="47f3d5d59a235c75b0766f99a2edf9666aa348c9" translate="yes" xml:space="preserve">
          <source>Constant that fits in 8 bits</source>
          <target state="translated">Постоянно,что помещается в 8 бит.</target>
        </trans-unit>
        <trans-unit id="719b7b797492e1507d09c13adb21a02c3fe64069" translate="yes" xml:space="preserve">
          <source>Constant whose negation is a signed 16-bit constant</source>
          <target state="translated">Постоянная,отрицание которой является подписанной 16-битной константой.</target>
        </trans-unit>
        <trans-unit id="180e678224087bf03d6c9c2f7ac11f4d9834fa9a" translate="yes" xml:space="preserve">
          <source>Constant zero</source>
          <target state="translated">Постоянный ноль</target>
        </trans-unit>
        <trans-unit id="a9100a8537fb85e4bf388bedae7d5d58f76e7b6e" translate="yes" xml:space="preserve">
          <source>Constant?</source>
          <target state="translated">Constant?</target>
        </trans-unit>
        <trans-unit id="7efcb4b4f328cdb249f8926cb267f61ac8015a9d" translate="yes" xml:space="preserve">
          <source>Constraints for &lt;code&gt;asm&lt;/code&gt; operands</source>
          <target state="translated">Ограничения для операндов &lt;code&gt;asm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e3f7e5411ee0f1fda2ac40b39097fae6a9abb77" translate="yes" xml:space="preserve">
          <source>Constructs webs as commonly used for register allocation purposes and assign each web individual pseudo register. This allows the register allocation pass to operate on pseudos directly, but also strengthens several other optimization passes, such as CSE, loop optimizer and trivial dead code remover. It can, however, make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">Создает сети, которые обычно используются для целей распределения регистров, и назначает каждому вебу индивидуальный псевдореестр. Это позволяет проходу выделения регистров работать с псевдонимами напрямую, но также усиливает несколько других проходов оптимизации, таких как CSE, оптимизатор цикла и тривиальное средство удаления мертвого кода. Однако это может сделать отладку невозможной, поскольку переменные больше не остаются в &amp;laquo;домашнем регистре&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d4f501afecf0b8b5f3993371f4f6074a753dc0e6" translate="yes" xml:space="preserve">
          <source>Contributors to GCC</source>
          <target state="translated">Контрагенты в ССАГПЗ</target>
        </trans-unit>
        <trans-unit id="4648a291e89516ba0f4f56b93d6fdb1d01cfd9c4" translate="yes" xml:space="preserve">
          <source>Control GCC&amp;rsquo;s optimizations to produce output suitable for live-patching.</source>
          <target state="translated">Управляйте оптимизацией GCC, чтобы вывод был пригоден для исправления в реальном времени.</target>
        </trans-unit>
        <trans-unit id="2000010d8fcae415d2b9780e43435379e14ee053" translate="yes" xml:space="preserve">
          <source>Control how GCC aligns variables and constants of array, structure, or union types. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc7b6b362569344fe25ab394774bd26a1bf6f6a" translate="yes" xml:space="preserve">
          <source>Control how GCC aligns variables. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">Управляйте выравниванием переменных в GCC. Поддерживаемые значения для &lt;var&gt;type&lt;/var&gt; : '</target>
        </trans-unit>
        <trans-unit id="7e88213c055c1aca5596a30dea879bf4859e75f5" translate="yes" xml:space="preserve">
          <source>Control how many registers are used to pass integer arguments. By default, no registers are used to pass arguments, and at most 3 registers can be used. You can control this behavior for a specific function by using the function attribute &lt;code&gt;regparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">Управляйте количеством регистров, используемых для передачи целочисленных аргументов. По умолчанию для передачи аргументов не используются регистры, и можно использовать не более 3 регистров. Вы можете управлять этим поведением конкретной функции с помощью атрибута функции &lt;code&gt;regparm&lt;/code&gt; . См. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae31e36dd1f96d1b47c3f78f649f25722c9f1d7b" translate="yes" xml:space="preserve">
          <source>Control if warning triggered by the &lt;code&gt;warn_if_not_aligned&lt;/code&gt; attribute should be issued. This is enabled by default. Use</source>
          <target state="translated">Контролируйте, следует ли выдавать предупреждение, вызванное атрибутом &lt;code&gt;warn_if_not_aligned&lt;/code&gt; . По умолчанию это включено. использование</target>
        </trans-unit>
        <trans-unit id="9e5c3f2f79d503814d4fe18475f20d72c26564d7" translate="yes" xml:space="preserve">
          <source>Control if warnings triggered by the &lt;code&gt;warn_if_not_aligned&lt;/code&gt; attribute should be issued. These warnings are enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7631dd8867c98dbe9aea4e0521ca0a270c9af1bd" translate="yes" xml:space="preserve">
          <source>Control level of reproducibility of profile gathered by &lt;code&gt;-fprofile-generate&lt;/code&gt;. This makes it possible to rebuild program with same outcome which is useful, for example, for distribution packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f461ee948da2dba5ee60b9ffddb2967c79a05b" translate="yes" xml:space="preserve">
          <source>Control the IEEE compliance of floating-point comparisons, which affects the handling of cases where the result of a comparison is unordered. By default</source>
          <target state="translated">Контроль соответствия стандарту IEEE при сравнении с плавающей точкой,что влияет на работу со случаями,когда результат сравнения неупорядочен.По умолчанию</target>
        </trans-unit>
        <trans-unit id="2afb7e07aedef4a32dbbca185426a76a2840c4b0" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of inter-procedural analysis language tree to a file. The file name is generated by appending a switch specific suffix to the source file name, and the file is created in the same directory as the output file. The following dumps are possible:</source>
          <target state="translated">Управление дампингом на различных этапах дерева языка межпроцедурного анализа в файл.Имя файла генерируется добавлением к имени исходного файла специального суффикса коммутатора,и файл создается в том же каталоге,что и выходной файл.Возможны следующие дампы:</target>
        </trans-unit>
        <trans-unit id="f18aaf944d2648faf5bedcbbdbf1ddd945fad607" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of processing the intermediate language tree to a file. If the &amp;lsquo;</source>
          <target state="translated">Управляйте выгрузкой на различных этапах обработки дерева промежуточных языков в файл. Если '</target>
        </trans-unit>
        <trans-unit id="c0a71f6d1404f7b16378e5d31c9c7e2a41e97704" translate="yes" xml:space="preserve">
          <source>Control the dumping of language-specific information. The &lt;var&gt;options&lt;/var&gt; and &lt;var&gt;filename&lt;/var&gt; portions behave as described in the</source>
          <target state="translated">Управляйте сбросом языковой информации. Эти &lt;var&gt;options&lt;/var&gt; и &lt;var&gt;filename&lt;/var&gt; части ведут себя так , как описано в</target>
        </trans-unit>
        <trans-unit id="d78b6d3fd867212c02526e9987edeed79105b1e7" translate="yes" xml:space="preserve">
          <source>Control the probability of the expression having the specified value. This parameter takes a percentage (i.e. 0 ... 100) as input.</source>
          <target state="translated">Контроль вероятности выражения,имеющего указанное значение.Этот параметр принимает на вход в процентах (т.е.0 ...100).</target>
        </trans-unit>
        <trans-unit id="3bc8404322e32343cc4763c8bd1ae2d2c9dab937" translate="yes" xml:space="preserve">
          <source>Control the verbosity of the dump file for the integrated register allocator. The default value is 5. If the value &lt;var&gt;n&lt;/var&gt; is greater or equal to 10, the dump output is sent to stderr using the same format as &lt;var&gt;n&lt;/var&gt; minus 10.</source>
          <target state="translated">Управляйте уровнем детализации файла дампа для интегрированного распределителя регистров. Значение по умолчанию - 5. Если значение &lt;var&gt;n&lt;/var&gt; больше или равно 10, вывод дампа отправляется на stderr в том же формате, что и &lt;var&gt;n&lt;/var&gt; минус 10.</target>
        </trans-unit>
        <trans-unit id="f9bae08f2081e939f273d8f52a1db45d82560f46" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; variables on a two-word boundary or a one-word boundary. Aligning &lt;code&gt;double&lt;/code&gt; variables on a two-word boundary produces code that runs somewhat faster on a Pentium at the expense of more memory.</source>
          <target state="translated">Управляйте выравниванием GCC переменных типа &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; и &lt;code&gt;long long&lt;/code&gt; по границе из двух слов или по границе из одного слова. Выравнивание переменных типа &lt;code&gt;double&lt;/code&gt; по границе из двух слов приводит к тому, что код работает несколько быстрее на Pentium за счет увеличения объема памяти.</target>
        </trans-unit>
        <trans-unit id="8f446d353bc1e77fdd352360a3275f518dfbc090" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; variables on a 32-bit boundary (</source>
          <target state="translated">Управляет выравниванием GCC переменных типа &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;long double&lt;/code&gt; на 32-битной границе (</target>
        </trans-unit>
        <trans-unit id="75311304fc882ae2426d795d34cedb8140da086e" translate="yes" xml:space="preserve">
          <source>Control whether or not the compiler uses IEEE floating-point comparisons. These correctly handle the case where the result of a comparison is unordered.</source>
          <target state="translated">Контроль того,использует ли компилятор сравнения с плавающей точкой IEEE или нет.Они корректно обрабатывают случай,когда результат сравнения неупорядочен.</target>
        </trans-unit>
        <trans-unit id="62bad428ae7c19b0490d45917456075bd42d88a6" translate="yes" xml:space="preserve">
          <source>Controlling header files and macro definitions. Also, getting dependency information for Make.</source>
          <target state="translated">Управление заголовочными файлами и макроопределениями.Также получение информации о зависимостях для Make.</target>
        </trans-unit>
        <trans-unit id="e99744632595e185715acaad17e041aa084fa9ba" translate="yes" xml:space="preserve">
          <source>Controlling how diagnostics should be formatted.</source>
          <target state="translated">Контроль за тем,как должна быть отформатирована диагностика.</target>
        </trans-unit>
        <trans-unit id="e7841aeb7ad7a7b2bbd17b2d58521eec5ba1a4f0" translate="yes" xml:space="preserve">
          <source>Controlling the kind of output: an executable, object files, assembler files, or preprocessed source.</source>
          <target state="translated">Управление типом вывода:исполняемый файл,объектные файлы,ассемблерные файлы или препроцессированный исходный код.</target>
        </trans-unit>
        <trans-unit id="c6ecef85f48d8878d76bfb7e0a0331e88e337d9a" translate="yes" xml:space="preserve">
          <source>Controlling the variant of C language compiled.</source>
          <target state="translated">Управление вариантом скомпилированного языка Си.</target>
        </trans-unit>
        <trans-unit id="35f36b715e771eac424fea4a5652ad0db1feb811" translate="yes" xml:space="preserve">
          <source>Controls optimization dumps from various optimization passes. If the &amp;lsquo;</source>
          <target state="translated">Управляет дампами оптимизации из различных этапов оптимизации. Если '</target>
        </trans-unit>
        <trans-unit id="addf45283fa1231bccd97d1a11480f865b18f29c" translate="yes" xml:space="preserve">
          <source>Controls warnings if a shift count is greater than or equal to the bit width of the type. This warning is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8bc0ebce27c4f8597b1ed37dbc7e6eb2315759" translate="yes" xml:space="preserve">
          <source>Controls warnings if a shift count is negative. This warning is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae41d379a4cfbab73e910f93e19e6f3bad5167f" translate="yes" xml:space="preserve">
          <source>Controls whether TLS variables may be accessed with offsets from the TLS segment register (&lt;code&gt;%gs&lt;/code&gt; for 32-bit, &lt;code&gt;%fs&lt;/code&gt; for 64-bit), or whether the thread base pointer must be added. Whether or not this is valid depends on the operating system, and whether it maps the segment to cover the entire TLS area.</source>
          <target state="translated">Управляет возможностью доступа к переменным TLS со смещениями из регистра сегмента TLS ( &lt;code&gt;%gs&lt;/code&gt; для 32-битной версии , &lt;code&gt;%fs&lt;/code&gt; для 64-битной версии) или необходимость добавления базового указателя потока. Правильно это или нет, зависит от операционной системы и от того, отображает ли она сегмент на всю область TLS.</target>
        </trans-unit>
        <trans-unit id="eb9ef4e6ab162f6fc8a3bf857fc774382a954629" translate="yes" xml:space="preserve">
          <source>Conversely, &lt;code&gt;bar&lt;/code&gt; and the call to &lt;code&gt;foo&lt;/code&gt; in the fourth marked line are used in contexts that do depend on the type of &lt;code&gt;T&lt;/code&gt;, so they are only looked up at the point of instantiation, and you can provide declarations for them after declaring the template, but before instantiating it. In particular, if you instantiate &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt;, the last line will call an overloaded &lt;code&gt;::foo(int)&lt;/code&gt; if one was provided, even if after the declaration of &lt;code&gt;struct A&lt;/code&gt;.</source>
          <target state="translated">И наоборот, &lt;code&gt;bar&lt;/code&gt; и вызов &lt;code&gt;foo&lt;/code&gt; в четвертой отмеченной строке используются в контекстах, которые зависят от типа &lt;code&gt;T&lt;/code&gt; , поэтому они просматриваются только в точке создания экземпляра, и вы можете предоставить для них объявления после объявления шаблона, но перед его созданием. В частности, если вы Instantiate &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt; , последняя строка будет вызывать перегруженную &lt;code&gt;::foo(int)&lt;/code&gt; , если один был обеспечен, даже если после объявления &lt;code&gt;struct A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dbc54a6ca4a64275cd12138ea70589c4f463e73" translate="yes" xml:space="preserve">
          <source>Conversely, if the register is a call-clobbered register, making calls to functions that use standard ABI may lose contents of the variable. Such calls may be created by the compiler even if none are evident in the original program, for example when libgcc functions are used to make up for unavailable instructions.</source>
          <target state="translated">И наоборот,если регистр является позывным,вызовы функций,использующих стандартный ABI,могут привести к потере содержимого переменной.Такие вызовы могут быть созданы компилятором даже в том случае,если в исходной программе ничего не видно,например,когда функции libgcc используются для восполнения недоступных инструкций.</target>
        </trans-unit>
        <trans-unit id="ff7d2b7b709500e425e46256b872f1c524a8fe88" translate="yes" xml:space="preserve">
          <source>Conversely, when you include the same header file in a main source file that declares it as &amp;lsquo;</source>
          <target state="translated">И наоборот, когда вы включаете тот же файл заголовка в основной исходный файл, который объявляет его как '</target>
        </trans-unit>
        <trans-unit id="f8292e36ff2425ba64b2fca8bba18ef8c5d24cbf" translate="yes" xml:space="preserve">
          <source>Conversion from double precision to single precision.</source>
          <target state="translated">Преобразование из двойной точности в единую.</target>
        </trans-unit>
        <trans-unit id="e8f87ba256340926897664cced7edc0ce8ec124d" translate="yes" xml:space="preserve">
          <source>Conversion from floating point to signed or unsigned integer types, with truncation towards zero.</source>
          <target state="translated">Преобразование из плавающей точки в знаковый или беззнаковый целочисленный тип,с усечением в ноль.</target>
        </trans-unit>
        <trans-unit id="e8ec2eea2629558824283e676ad9bac71b3d3e53" translate="yes" xml:space="preserve">
          <source>Conversion from signed or unsigned integer types to floating-point types.</source>
          <target state="translated">Преобразование знаковых и беззнаковых целых типов в типы с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="416cd3e7b0ad0f46f99e977b880dc368db1cdff8" translate="yes" xml:space="preserve">
          <source>Conversion from single precision to double precision.</source>
          <target state="translated">Преобразование из одинарной точности в двойную.</target>
        </trans-unit>
        <trans-unit id="0fc5b8691f90f80b04961e22033d17dee1964933" translate="yes" xml:space="preserve">
          <source>Conversion from single-precision floating point to signed integer, rounding to the nearest integer and ties away from zero. This corresponds to the &lt;code&gt;__builtin_lroundf&lt;/code&gt; function when</source>
          <target state="translated">Преобразование из числа с плавающей запятой одинарной точности в целое число со знаком, округление до ближайшего целого числа и увязка от нуля. Это соответствует функции &lt;code&gt;__builtin_lroundf&lt;/code&gt; , когда</target>
        </trans-unit>
        <trans-unit id="536e910ea0e856f9ebf3793f69bec672bb95cd2c" translate="yes" xml:space="preserve">
          <source>Conversions by prototypes between fixed/floating-point values and vice versa. The absence of these prototypes when compiling with traditional C causes serious problems. This is a subset of the possible conversion warnings; for the full set use</source>
          <target state="translated">Преобразования прототипами между фиксированными/плавающими точками и наоборот.Отсутствие этих прототипов при компиляции с традиционным С вызывает серьезные проблемы.Это подмножество возможных предупреждений о преобразовании;для полноценного использования</target>
        </trans-unit>
        <trans-unit id="0912352accd4bfa1711e2febca470cb4f85bbc4c" translate="yes" xml:space="preserve">
          <source>Conversions:</source>
          <target state="translated">Conversions:</target>
        </trans-unit>
        <trans-unit id="baf1df2f34189a80f5d58da24bff382fe6f23f9c" translate="yes" xml:space="preserve">
          <source>Convert a 128-bit IEEE floating point value to &lt;code&gt;double&lt;/code&gt; using round to odd as the rounding mode.</source>
          <target state="translated">Преобразуйте 128-битное значение с плавающей запятой IEEE в &lt;code&gt;double&lt;/code&gt; используя округление в нечетное в качестве режима округления.</target>
        </trans-unit>
        <trans-unit id="c5f6051eea145ce2adef0c8027dd705cfcc7007e" translate="yes" xml:space="preserve">
          <source>Convert function return with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">Преобразование функции return с &lt;var&gt;choice&lt;/var&gt; . По умолчанию '</target>
        </trans-unit>
        <trans-unit id="454c8084600f90536a1954e8c20d848d81c823ed" translate="yes" xml:space="preserve">
          <source>Convert indirect call and jump with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">Преобразуйте косвенный вызов и прыгайте с &lt;var&gt;choice&lt;/var&gt; . По умолчанию '</target>
        </trans-unit>
        <trans-unit id="e6098cfb721df754afe96180a874c8cc3a1a8ded" translate="yes" xml:space="preserve">
          <source>Convert pair lower to single (&lt;code&gt;cvt.s.pl&lt;/code&gt;).</source>
          <target state="translated">Преобразуйте нижнюю пару в одиночную ( &lt;code&gt;cvt.s.pl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="52f3ab191bdd722d1394008161cded401dd949a0" translate="yes" xml:space="preserve">
          <source>Convert pair to paired single (&lt;code&gt;cvt.ps.s&lt;/code&gt;).</source>
          <target state="translated">Преобразуйте пару в парные одиночные ( &lt;code&gt;cvt.ps.s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dbfe6d8e23313dd7f9196c8cdcc1c08381a49c43" translate="yes" xml:space="preserve">
          <source>Convert pair upper to single (&lt;code&gt;cvt.s.pu&lt;/code&gt;).</source>
          <target state="translated">Преобразуйте верхнюю пару в одиночную ( &lt;code&gt;cvt.s.pu&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="055bbf265923b2e5410a5e939d7297c0c9f2b211" translate="yes" xml:space="preserve">
          <source>Convert paired single to paired word (&lt;code&gt;cvt.pw.ps&lt;/code&gt;).</source>
          <target state="translated">Преобразуйте парное одиночное слово в парное ( &lt;code&gt;cvt.pw.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8b6b177ab15aa362100af3868aea344b1c1501b0" translate="yes" xml:space="preserve">
          <source>Convert paired word to paired single (&lt;code&gt;cvt.ps.pw&lt;/code&gt;).</source>
          <target state="translated">Преобразуйте парное слово в парное одиночное ( &lt;code&gt;cvt.ps.pw&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b04bf1a5e85023c3eed3599d79cb09164690ab2" translate="yes" xml:space="preserve">
          <source>Copy Assignment operators copy virtual bases twice</source>
          <target state="translated">Операторы копирования Операторы копирования Назначения копируют виртуальные базы дважды</target>
        </trans-unit>
        <trans-unit id="d5eae2b9f3ad758ce3ef79fc7015a6ffa9156eac" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 1988-2019 Free Software Foundation, Inc.</source>
          <target state="translated">Авторские права &amp;copy; 1988-2019 Free Software Foundation, Inc.</target>
        </trans-unit>
        <trans-unit id="00d80b436f1c8689f9094a048f0b7d3b3fb4eee4" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 1988-2020 Free Software Foundation, Inc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5bc69c89234b43d34e0f300cbb8e8580610fdc" translate="yes" xml:space="preserve">
          <source>Core control register class.</source>
          <target state="translated">Класс регистра управления ядром.</target>
        </trans-unit>
        <trans-unit id="26ed802e7eb78ff2045b4541fe370087376fea5e" translate="yes" xml:space="preserve">
          <source>Cost to assume for a multiply instruction, with &amp;lsquo;</source>
          <target state="translated">Предполагаемая стоимость для инструкции умножения с '</target>
        </trans-unit>
        <trans-unit id="c2ddd3bb796bfb895719a519a79aeec2d836822b" translate="yes" xml:space="preserve">
          <source>Cost, roughly measured as the cost of a single typical machine instruction, at which GCSE optimizations do not constrain the distance an expression can travel. This is currently supported only in the code hoisting pass. The lesser the cost, the more aggressive code hoisting is. Specifying 0 allows all expressions to travel unrestricted distances.</source>
          <target state="translated">Стоимость,грубо измеряемая как стоимость одной типовой машинной инструкции,при которой оптимизация GCSE не ограничивает расстояние,которое может пройти выражение.В настоящее время это поддерживается только в коде подъемного прохода.Чем меньше стоимость,тем более агрессивный код подъема.Указание 0 позволяет всем выражениям преодолевать неограниченные расстояния.</target>
        </trans-unit>
        <trans-unit id="73a8cda37ae16987b1b76b7dd95bcc1d393efb64" translate="yes" xml:space="preserve">
          <source>Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis. Later optimizations then may determine the number easily. Useful especially in connection with unrolling.</source>
          <target state="translated">Создайте канонический счетчик количества итераций в циклах,для которого определение количества итераций требует сложного анализа.Более поздние оптимизации затем могут легко определить число.Полезно,особенно в связи с разворачиванием.</target>
        </trans-unit>
        <trans-unit id="abd404fec245486ddadc6af0006baee144b9f9b5" translate="yes" xml:space="preserve">
          <source>Create a shared object. It is recommended that</source>
          <target state="translated">Создайте общий объект.Рекомендуется,чтобы</target>
        </trans-unit>
        <trans-unit id="f1fd203b49f15a9115d31d7e6edbf2d093ba7de0" translate="yes" xml:space="preserve">
          <source>Create constant pools in the compiler instead of deferring it to the assembler. This option is the default and required for correct code generation on CK801 and CK802, and is optional on other processors.</source>
          <target state="translated">Создавать константные пулы в компиляторе вместо того,чтобы откладывать их на ассемблере.Эта опция является стандартной и необходима для корректной генерации кода на CK801 и CK802,а также необязательна на других процессорах.</target>
        </trans-unit>
        <trans-unit id="b23e0354f5ad5eff5e150918b9120e5576f9697a" translate="yes" xml:space="preserve">
          <source>Create long file names for included source files. For example, if the header file</source>
          <target state="translated">Создавайте длинные имена файлов для включенных исходных файлов.Например,если заголовочный файл</target>
        </trans-unit>
        <trans-unit id="e38ae255fe9e80cdce8fdaed0460f9c86fe6b8ba" translate="yes" xml:space="preserve">
          <source>Creates a new &amp;lsquo;</source>
          <target state="translated">Создает новый '</target>
        </trans-unit>
        <trans-unit id="99dfbad76db4acc6eb91954940ce7b9993db8870" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint from the release (or stronger) semantic store to this acquire load. Can prevent hoisting of code to before the operation.</source>
          <target state="translated">Создает межпотоковое событие-до того,как появится ограничение от release (или более сильного)семантического хранилища до этой загрузки acquire.Может предотвратить подъем кода перед операцией.</target>
        </trans-unit>
        <trans-unit id="281a58c77cb45edf43cfdf897384199b4ab0a3ee" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint to acquire (or stronger) semantic loads that read from this release store. Can prevent sinking of code to after the operation.</source>
          <target state="translated">Создает межпотоковое событие-до того,как возникнет ограничение на получение (или более сильной)семантической нагрузки,считываемой из этого магазина релизов.Может предотвратить погружение кода после операции.</target>
        </trans-unit>
        <trans-unit id="67ae8f8fb8bba8ab92d3a89b17a6600fa05951e3" translate="yes" xml:space="preserve">
          <source>Creates and defines a register class. These register classes can be used by inline &lt;code&gt;asm&lt;/code&gt; constructs. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">Создает и определяет класс регистров. Эти классы регистров могут использоваться встроенными конструкциями &lt;code&gt;asm&lt;/code&gt; . &lt;var&gt;registers&lt;/var&gt; могут быть одним регистром, диапазоном регистров, разделенным многоточием, или их списком, разделенным запятыми. Пример:</target>
        </trans-unit>
        <trans-unit id="6e67e7d1e719647852b7fdbba193a58bb75ed395" translate="yes" xml:space="preserve">
          <source>Critical functions disable interrupts upon entry and restore the previous interrupt state upon exit. Critical functions cannot also have the &lt;code&gt;naked&lt;/code&gt;, &lt;code&gt;reentrant&lt;/code&gt; or &lt;code&gt;interrupt&lt;/code&gt; attributes.</source>
          <target state="translated">Критические функции отключают прерывания при входе и восстанавливают предыдущее состояние прерывания при выходе. Критические функции также не могут иметь атрибуты &lt;code&gt;naked&lt;/code&gt; , &lt;code&gt;reentrant&lt;/code&gt; или &lt;code&gt;interrupt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3cb5c6e6c93496c35c07eb658977d77e8d997f1" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a library or startup file of some sort. Search for that file in a standard list of directories and substitute the full name found. The current working directory is included in the list of directories scanned.</source>
          <target state="translated">Текущим аргументом является имя библиотеки или загрузочного файла.Ищите этот файл в стандартном списке каталогов и подставляйте найденное полное имя.Текущий рабочий каталог включается в список сканируемых каталогов.</target>
        </trans-unit>
        <trans-unit id="27ed6e70669ea07173e0ff90384757c33382fb6e" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a linker script. Search for that file in the current list of directories to scan for libraries. If the file is located insert a</source>
          <target state="translated">Текущим аргументом является имя скрипта компоновщика.Ищите этот файл в текущем списке каталогов для сканирования библиотек.Если файл расположен,вставьте a</target>
        </trans-unit>
        <trans-unit id="318f590d6974d7ec1e4d3da7f86481fca68df621" translate="yes" xml:space="preserve">
          <source>Current gcov-tool supports the following functionalities:</source>
          <target state="translated">Текущий gcov-tool поддерживает следующие функциональные возможности:</target>
        </trans-unit>
        <trans-unit id="883949fd66aefc2f68b17e769896d2b8ef7a23bf" translate="yes" xml:space="preserve">
          <source>Currently the x86 GNU/Linux target provides an implementation based on Intel Control-flow Enforcement Technology (CET).</source>
          <target state="translated">В настоящее время x86 GNU/Linux мишень предоставляет реализацию,основанную на технологии Intel Control-flow Enforcement Technology (CET).</target>
        </trans-unit>
        <trans-unit id="4e2c32ee916d61bb5fb82fcf33fd745d76fa8899" translate="yes" xml:space="preserve">
          <source>Currently this feature only works for</source>
          <target state="translated">В настоящее время эта функция работает только для</target>
        </trans-unit>
        <trans-unit id="0990f74b9abadf3ef16d92f66dc8a33347d7b30f" translate="yes" xml:space="preserve">
          <source>Currently, ARM and AArch64 back ends do not support ACLE 2.0 fully. Both back ends support CRC32 intrinsics and the ARM back end supports the Coprocessor intrinsics, all from</source>
          <target state="translated">В настоящее время back-концы ARM и AArch64 не поддерживают ACLE 2.0 полностью.Обе задние части поддерживают intrinsics CRC32,а задняя часть ARM поддерживает intrinsics сопроцессора,все из которых относятся к</target>
        </trans-unit>
        <trans-unit id="31736ea72fe4084b8c34c06d50c0f1b2816826be" translate="yes" xml:space="preserve">
          <source>Currently, GCC defines &lt;code&gt;__STDC__&lt;/code&gt; unconditionally. This provides good results in practice.</source>
          <target state="translated">В настоящее время GCC определяет &lt;code&gt;__STDC__&lt;/code&gt; безоговорочно. Это дает хорошие результаты на практике.</target>
        </trans-unit>
        <trans-unit id="2f63ff4fabd516030a0097fd6f4d244c1efad6e8" translate="yes" xml:space="preserve">
          <source>Currently, the attribute is ignored for inlined functions. If the attribute is applied to a symbol &lt;em&gt;definition&lt;/em&gt;, an error is reported. If a symbol previously declared &lt;code&gt;dllimport&lt;/code&gt; is later defined, the attribute is ignored in subsequent references, and a warning is emitted. The attribute is also overridden by a subsequent declaration as &lt;code&gt;dllexport&lt;/code&gt;.</source>
          <target state="translated">В настоящее время атрибут игнорируется для встроенных функций. Если атрибут применяется к определению символа, &lt;em&gt;выдается&lt;/em&gt; сообщение об ошибке. Если символ, ранее объявленный &lt;code&gt;dllimport&lt;/code&gt; , определяется позже, атрибут игнорируется в последующих ссылках и выдается предупреждение. Атрибут также переопределяется последующим объявлением как &lt;code&gt;dllexport&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="590e74950b3a359e45f46ccc033df08293e7e8d0" translate="yes" xml:space="preserve">
          <source>Currently, the preferred dialect makes plain bit-fields signed, because this is simplest. Since &lt;code&gt;int&lt;/code&gt; is the same as &lt;code&gt;signed int&lt;/code&gt; in every other context, it is cleanest for them to be the same in bit-fields as well.</source>
          <target state="translated">В настоящее время предпочтительный диалект делает простые битовые поля подписанными, потому что это проще всего. Поскольку &lt;code&gt;int&lt;/code&gt; во всех других контекстах совпадает со &lt;code&gt;signed int&lt;/code&gt; , для них лучше всего быть одинаковыми и в битовых полях.</target>
        </trans-unit>
        <trans-unit id="62ab12d09721515fc5fde562eb0862cdc8c3be63" translate="yes" xml:space="preserve">
          <source>Currently, there are two Blackfin-specific built-in functions. These are used for generating &lt;code&gt;CSYNC&lt;/code&gt; and &lt;code&gt;SSYNC&lt;/code&gt; machine insns without using inline assembly; by using these built-in functions the compiler can automatically add workarounds for hardware errata involving these instructions. These functions are named as follows:</source>
          <target state="translated">В настоящее время есть две встроенные функции, специфичные для Blackfin. Они используются для генерации &lt;code&gt;CSYNC&lt;/code&gt; &lt;code&gt;SSYNC&lt;/code&gt; CSYNC и SSYNC без использования встроенной сборки; используя эти встроенные функции, компилятор может автоматически добавлять обходные пути для аппаратных ошибок, связанных с этими инструкциями. Эти функции имеют следующие названия:</target>
        </trans-unit>
        <trans-unit id="3463fd1fcbee98183382ce3e6bfb37d05534e64b" translate="yes" xml:space="preserve">
          <source>Custom instruction assignments given by individual</source>
          <target state="translated">Индивидуальные задания инструкций,выдаваемые индивидуальными</target>
        </trans-unit>
        <trans-unit id="f2bc7d2b6265d22c6647e1fcd64c13f072748076" translate="yes" xml:space="preserve">
          <source>D documentation code (Ddoc).</source>
          <target state="translated">Код документации D (Ddoc).</target>
        </trans-unit>
        <trans-unit id="2c7c0a531f3f523f274fda8de9447eb2371b07a9" translate="yes" xml:space="preserve">
          <source>D interface file.</source>
          <target state="translated">Файл интерфейса D.</target>
        </trans-unit>
        <trans-unit id="6e41c2f41f21895821ff2de4b2b537b418d821df" translate="yes" xml:space="preserve">
          <source>D register</source>
          <target state="translated">D регистр</target>
        </trans-unit>
        <trans-unit id="2b608c731b27a1c96a6f8a0e732c2d9673589c56" translate="yes" xml:space="preserve">
          <source>D source code.</source>
          <target state="translated">D исходный код.</target>
        </trans-unit>
        <trans-unit id="6e946b779e60851d5c244c3ad74774cbf9f1d48d" translate="yes" xml:space="preserve">
          <source>DD</source>
          <target state="translated">DD</target>
        </trans-unit>
        <trans-unit id="333132be138ba9ace941111a0f174248952df7a1" translate="yes" xml:space="preserve">
          <source>DF</source>
          <target state="translated">DF</target>
        </trans-unit>
        <trans-unit id="53a81edefe355889dccbacb38a4a1453f4e85785" translate="yes" xml:space="preserve">
          <source>DL</source>
          <target state="translated">DL</target>
        </trans-unit>
        <trans-unit id="8fe69de0441ad2ce15deb455eb1d3b4c6713b22c" translate="yes" xml:space="preserve">
          <source>Data file relocation.</source>
          <target state="translated">Перемещение файла данных.</target>
        </trans-unit>
        <trans-unit id="12293b22c91f6b4096277825dea65487973f1c86" translate="yes" xml:space="preserve">
          <source>Data prefetch does not generate faults if &lt;var&gt;addr&lt;/var&gt; is invalid, but the address expression itself must be valid. For example, a prefetch of &lt;code&gt;p-&amp;gt;next&lt;/code&gt; does not fault if &lt;code&gt;p-&amp;gt;next&lt;/code&gt; is not a valid address, but evaluation faults if &lt;code&gt;p&lt;/code&gt; is not a valid address.</source>
          <target state="translated">Упреждающие данные не генерируют ошибки , если &lt;var&gt;addr&lt;/var&gt; является недействительным, но выражение адреса сам должно быть действительным. Например, предварительная выборка &lt;code&gt;p-&amp;gt;next&lt;/code&gt; не вызывает ошибки, если &lt;code&gt;p-&amp;gt;next&lt;/code&gt; не является допустимым адресом, но дает сбой при оценке, если &lt;code&gt;p&lt;/code&gt; не является допустимым адресом.</target>
        </trans-unit>
        <trans-unit id="c2a93a0b6a01599dcd1bcda6f09bcde290d7a928" translate="yes" xml:space="preserve">
          <source>Data register</source>
          <target state="translated">Регистр данных</target>
        </trans-unit>
        <trans-unit id="46a7bcc6b46e84d9b5870e2cd0ac98f1bdb1402e" translate="yes" xml:space="preserve">
          <source>Data register (arbitrary general purpose register)</source>
          <target state="translated">Регистр данных (произвольный регистр общего назначения)</target>
        </trans-unit>
        <trans-unit id="47be067ca541e17c43e79dffecbcbbad2c9d9a08" translate="yes" xml:space="preserve">
          <source>Data type: &lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</source>
          <target state="translated">Тип данных: &lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2310e7e6984f7b9841fe3043d76bb8748b8032aa" translate="yes" xml:space="preserve">
          <source>Data types for complex numbers.</source>
          <target state="translated">Типы данных для комплексных чисел.</target>
        </trans-unit>
        <trans-unit id="c002fd4f69749774cd614b7282439760b0a132f5" translate="yes" xml:space="preserve">
          <source>Debug dumps can be enabled with a</source>
          <target state="translated">Отладочные дампы могут быть включены с помощью функции</target>
        </trans-unit>
        <trans-unit id="d5a9f22c83f9299405413f6e5e553516a6cf6903" translate="yes" xml:space="preserve">
          <source>Debugging (</source>
          <target state="translated">Отладка (</target>
        </trans-unit>
        <trans-unit id="b7b96436cf5229d16fb5897e129a114445f95678" translate="yes" xml:space="preserve">
          <source>Debugging Options</source>
          <target state="translated">Опции отладки</target>
        </trans-unit>
        <trans-unit id="aff6d1089cf54da46ac69c2183c78d051d04eff0" translate="yes" xml:space="preserve">
          <source>Decimal Floating Types.</source>
          <target state="translated">Десятичные плавающие типы.</target>
        </trans-unit>
        <trans-unit id="6a66960857760a2cd63559ec52ee94a4a711e705" translate="yes" xml:space="preserve">
          <source>Declarations of external variables and functions within a block apply only to the block containing the declaration. In other words, they have the same scope as any other declaration in the same place.</source>
          <target state="translated">Объявления внешних переменных и функций внутри блока применяются только к блоку,содержащему объявление.Другими словами,они имеют ту же область применения,что и любое другое объявление в том же месте.</target>
        </trans-unit>
        <trans-unit id="226f69acb8ae88a869e2645962bf30e8ec7e974f" translate="yes" xml:space="preserve">
          <source>Declares the instruction to be commutative for this operand and the following operand. This means that the compiler may interchange the two operands if that is the cheapest way to make all operands fit the constraints. &amp;lsquo;</source>
          <target state="translated">Объявляет команду коммутативной для этого и следующего операнда. Это означает, что компилятор может поменять местами два операнда, если это самый дешевый способ заставить все операнды соответствовать ограничениям. '</target>
        </trans-unit>
        <trans-unit id="6e381a53c21bfca57ae3c6418395aa6805faa3e6" translate="yes" xml:space="preserve">
          <source>Declaring multiple function versions.</source>
          <target state="translated">Объявление нескольких версий функций.</target>
        </trans-unit>
        <trans-unit id="9df458345b87f143e1443622e3689e81c8f18de5" translate="yes" xml:space="preserve">
          <source>Declaring objects with &lt;code&gt;uncached&lt;/code&gt; allows you to exclude data-cache participation in load and store operations on those objects without involving the additional semantic implications of &lt;code&gt;volatile&lt;/code&gt;. The &lt;code&gt;.di&lt;/code&gt; instruction suffix is used for all loads and stores of data declared &lt;code&gt;uncached&lt;/code&gt;.</source>
          <target state="translated">Объявление объектов с &lt;code&gt;uncached&lt;/code&gt; позволяет исключить участие кэша данных в операциях загрузки и сохранения этих объектов без дополнительных семантических последствий &lt;code&gt;volatile&lt;/code&gt; . &lt;code&gt;.di&lt;/code&gt; суффикс инструкции используется для всех нагрузок и магазины данных объявлены &lt;code&gt;uncached&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea979b67c132bc175e1957da54321717a0b3e04" translate="yes" xml:space="preserve">
          <source>Declaring that functions have no side effects, or that they can never return.</source>
          <target state="translated">Объявляя,что функции не имеют побочных эффектов,или что они никогда не могут вернуться.</target>
        </trans-unit>
        <trans-unit id="63030d3cd1e02a687549d142e20f0269121d2b83" translate="yes" xml:space="preserve">
          <source>Declaring the variable</source>
          <target state="translated">Объявление переменной</target>
        </trans-unit>
        <trans-unit id="b2609010c78f10c37fecace799c32d84a8b0113e" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays in other contexts, including as interior members of structure objects or as non-member objects, is discouraged. Accessing elements of zero-length arrays declared in such contexts is undefined and may be diagnosed.</source>
          <target state="translated">Не рекомендуется объявлять массивы нулевой длины в других контекстах,в том числе в качестве внутренних членов объектов структуры или в качестве объектов,не являющихся членами структуры.Доступ к элементам массивов нулевой длины,объявленным в таких контекстах,является неопределенным и может быть диагностирован.</target>
        </trans-unit>
        <trans-unit id="c0ce91fb53831d435a29b5632774a3c603665597" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays is allowed in GNU C as an extension. A zero-length array can be useful as the last element of a structure that is really a header for a variable-length object:</source>
          <target state="translated">Объявление массивов нулевой длины разрешено в GNU C как расширение.Массив нулевой длины может быть полезен в качестве последнего элемента структуры,который на самом деле является заголовком для объекта переменной длины:</target>
        </trans-unit>
        <trans-unit id="6ccbb003fcbbef0455a040407eca25644a68c8af" translate="yes" xml:space="preserve">
          <source>Default instruction scheduling parameters are used for values that select an architecture and not an implementation. These are &amp;lsquo;</source>
          <target state="translated">Параметры планирования инструкций по умолчанию используются для значений, которые выбирают архитектуру, а не реализацию. Эти '</target>
        </trans-unit>
        <trans-unit id="ba9d931a2de4e95a1c6e18f4c96c1c9b9529c7aa" translate="yes" xml:space="preserve">
          <source>Default to 64-bit memory allocation routines.</source>
          <target state="translated">По умолчанию это 64-битные процедуры выделения памяти.</target>
        </trans-unit>
        <trans-unit id="bc0e52c70e2e3d40aed76c210b466f12c8a6307d" translate="yes" xml:space="preserve">
          <source>Default visibility corresponds to &amp;ldquo;external linkage&amp;rdquo; in the language.</source>
          <target state="translated">Видимость по умолчанию соответствует &amp;laquo;внешней связи&amp;raquo; на языке.</target>
        </trans-unit>
        <trans-unit id="422c626b9da356260a74af4c444e356b1dff1705" translate="yes" xml:space="preserve">
          <source>Default visibility is the normal case for the object file format. This value is available for the visibility attribute to override other options that may change the assumed visibility of entities.</source>
          <target state="translated">Видимость по умолчанию является нормальным случаем для формата объектного файла.Это значение доступно для атрибута видимости,чтобы переопределить другие опции,которые могут изменить предполагаемую видимость объектов.</target>
        </trans-unit>
        <trans-unit id="dcc8364c434a51851187f20fa9cd4e3c3aefb760" translate="yes" xml:space="preserve">
          <source>Define a copy constructor and an assignment operator for classes with dynamically-allocated memory.</source>
          <target state="translated">Определите конструктор копирования и оператор присваивания для классов с динамически выделяемой памятью.</target>
        </trans-unit>
        <trans-unit id="5e2f8d06c00c297c0f950f50c2f9216e48b9c380" translate="yes" xml:space="preserve">
          <source>Define additional macros required for using the POSIX threads library. You should use this option consistently for both compilation and linking. This option is supported on GNU/Linux targets, most other Unix derivatives, and also on x86 Cygwin and MinGW targets.</source>
          <target state="translated">Определите дополнительные макросы,необходимые для использования библиотеки потоков POSIX.Вы должны последовательно использовать эту опцию как для компиляции,так и для линковки.Эта опция поддерживается на GNU/Linux-мишенях,большинстве других производных Unix,а также на x86-мишенях Cygwin и MinGW.</target>
        </trans-unit>
        <trans-unit id="8c097d198bbcce6c15c43b9673925ec2a844aa50" translate="yes" xml:space="preserve">
          <source>Define an argument called &lt;var&gt;key&lt;/var&gt; with a value of &lt;var&gt;value&lt;/var&gt; for the plugin called &lt;var&gt;name&lt;/var&gt;.</source>
          <target state="translated">Определите аргумент с именем &lt;var&gt;key&lt;/var&gt; со значением &lt;var&gt;value&lt;/var&gt; для плагина с именем &lt;var&gt;name&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3b065b864c454ddad2ef2e2ee36967d76b136921" translate="yes" xml:space="preserve">
          <source>Define how many insn groups (cycles) are examined for a dependency on a stalled insn that is a candidate for premature removal from the queue of stalled insns. This has an effect only during the second scheduling pass, and only if</source>
          <target state="translated">Определите,сколько insn групп (циклов)проверяется на зависимость от застрявшей insn,которая является кандидатом на преждевременное удаление из очереди застрявших insns.Это имеет эффект только во время второго прохода по расписанию,и только в том случае,если</target>
        </trans-unit>
        <trans-unit id="d9b9a323e114f08ae98c07403af86c1b8b068b0b" translate="yes" xml:space="preserve">
          <source>Define how many insns (if any) can be moved prematurely from the queue of stalled insns into the ready list during the second scheduling pass.</source>
          <target state="translated">Определите,сколько вставок (если таковые имеются)могут быть преждевременно перемещены из очереди заглохших вставок в готовый список во время второго прохода по расписанию.</target>
        </trans-unit>
        <trans-unit id="c71f73e3c6f3ec478d5a3cb4a896c06575c34175" translate="yes" xml:space="preserve">
          <source>Define the value of the global environment variable &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007a5a1c8e0d06fa894878b70ba1b2c632ffae5b" translate="yes" xml:space="preserve">
          <source>Defined if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461eb2c6003ae0aaa3a339d944fe5cf6fb4d9e9b" translate="yes" xml:space="preserve">
          <source>Defined if the compiler supports 32-bit double resp. 64-bit double. The actual layout is specified by option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02590046df70d51175d1e6e43007843fa86e90a" translate="yes" xml:space="preserve">
          <source>Defining a register variable does not reserve the register. Other than when invoking the Extended &lt;code&gt;asm&lt;/code&gt;, the contents of the specified register are not guaranteed. For this reason, the following uses are explicitly &lt;em&gt;not&lt;/em&gt; supported. If they appear to work, it is only happenstance, and may stop working as intended due to (seemingly) unrelated changes in surrounding code, or even minor changes in the optimization of a future version of gcc:</source>
          <target state="translated">Определение регистровой переменной не резервирует регистр. За исключением вызова Extended &lt;code&gt;asm&lt;/code&gt; , содержимое указанного регистра не гарантируется. По этой причине следующие варианты использования явно &lt;em&gt;не&lt;/em&gt; поддерживаются. Если кажется, что они работают, это всего лишь случайность, и они могут перестать работать должным образом из-за (по-видимому) несвязанных изменений в окружающем коде или даже незначительных изменений в оптимизации будущей версии gcc:</target>
        </trans-unit>
        <trans-unit id="827f9d9fc11f005c60202a566cf0397ae86dd11d" translate="yes" xml:space="preserve">
          <source>Defining inline functions (as fast as macros).</source>
          <target state="translated">Определение встроенных функций (так же быстро,как макросы).</target>
        </trans-unit>
        <trans-unit id="85adcd212de2e338813907851ee4a5662c5f1efc" translate="yes" xml:space="preserve">
          <source>Defining variables residing in specified registers.</source>
          <target state="translated">Определение переменных,находящихся в указанных регистрах.</target>
        </trans-unit>
        <trans-unit id="83ee69015768e1155b22074ebd3a36cc37e95cce" translate="yes" xml:space="preserve">
          <source>Delay execution for &lt;var&gt;ticks&lt;/var&gt; cycles. Note that this built-in does not take into account the effect of interrupts that might increase delay time. &lt;var&gt;ticks&lt;/var&gt; must be a compile-time integer constant; delays with a variable number of cycles are not supported.</source>
          <target state="translated">Задержка выполнения &lt;var&gt;ticks&lt;/var&gt; циклов. Обратите внимание, что эта встроенная функция не принимает во внимание влияние прерываний, которые могут увеличить время задержки. &lt;var&gt;ticks&lt;/var&gt; должны быть целочисленной константой времени компиляции; задержки с переменным количеством циклов не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="1610d19a0a48226750b3049b914e4786781d22cd" translate="yes" xml:space="preserve">
          <source>Deleting &amp;ldquo;empty&amp;rdquo; loops.</source>
          <target state="translated">Удаление &amp;laquo;пустых&amp;raquo; петель.</target>
        </trans-unit>
        <trans-unit id="36a3093d26bbd3d1360751144e1efe12aeac3836" translate="yes" xml:space="preserve">
          <source>Depending on the target and how GCC was configured, a slightly different set of optimizations may be enabled at each</source>
          <target state="translated">В зависимости от цели и того,как был настроен GCC,для каждой из них может быть включен несколько другой набор оптимизаций</target>
        </trans-unit>
        <trans-unit id="c9892e7a514c42b2b22214f98f72a5abf448bce9" translate="yes" xml:space="preserve">
          <source>Describes the type of hardware multiply supported by the target. Accepted values are &amp;lsquo;</source>
          <target state="translated">Описывает тип множителя аппаратного обеспечения, поддерживаемый целью. Допустимые значения: '</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="230a2f1369c19e9bed8580ef0c388abed833d36f" translate="yes" xml:space="preserve">
          <source>Despite the nomenclature, &amp;lsquo;</source>
          <target state="translated">Несмотря на номенклатуру, '</target>
        </trans-unit>
        <trans-unit id="bd519eb03ed0c213fdab64aa985771c57b8bf1cd" translate="yes" xml:space="preserve">
          <source>Detect floating-point division by zero. Unlike other similar options,</source>
          <target state="translated">Обнаружить деление с плавающей точкой на ноль.В отличие от других подобных опций,</target>
        </trans-unit>
        <trans-unit id="f275b676db5ca45003e8d7fdde53e395b48ae26a" translate="yes" xml:space="preserve">
          <source>Detect integer division by zero as well as &lt;code&gt;INT_MIN / -1&lt;/code&gt; division.</source>
          <target state="translated">Обнаруживает целочисленное деление на ноль, а также &lt;code&gt;INT_MIN / -1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f073b8e3005614eac7c90dae6865076fed02ebe" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to a null value being used in a way forbidden by a &lt;code&gt;returns_nonnull&lt;/code&gt; or &lt;code&gt;nonnull&lt;/code&gt; attribute. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This is not currently enabled, but may be enabled by</source>
          <target state="translated">Обнаружение путей , которые вызывают ошибочное или неопределенное поведение из - за нулевое значение используется таким образом , запрещенным в &lt;code&gt;returns_nonnull&lt;/code&gt; или &lt;code&gt;nonnull&lt;/code&gt; атрибутом. Изолируйте эти пути от основного потока управления и превратите оператор с ошибочным или неопределенным поведением в ловушку. В настоящее время это не включено, но может быть включено</target>
        </trans-unit>
        <trans-unit id="6fd69cb31930da8cd040a4ffab1183319f8c09e1" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This flag is enabled by default at</source>
          <target state="translated">Обнаружение путей,которые приводят к ошибочному или неопределенному поведению из-за разыменования нулевого указателя.Изолирует эти пути из основного потока управления и превращает оператор с ошибочным или неопределенным поведением в ловушку.Этот флаг включен по умолчанию при</target>
        </trans-unit>
        <trans-unit id="b579efc699383256e0ea46438d32e07c0012bfb5" translate="yes" xml:space="preserve">
          <source>Determine the language standard. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of these standard versions. This option is currently only supported when compiling C or C++.</source>
          <target state="translated">Определите языковой стандарт. См. Раздел &amp;laquo; &lt;a href=&quot;standards#Standards&quot;&gt;Языковые стандарты, поддерживаемые GCC&amp;raquo;&lt;/a&gt; для получения подробной информации об этих стандартных версиях. Эта опция в настоящее время поддерживается только при компиляции C или C ++.</target>
        </trans-unit>
        <trans-unit id="86070f5116cf4fafa20ed47f8a131328fabf7c26" translate="yes" xml:space="preserve">
          <source>Determined by ABI.</source>
          <target state="translated">Определено ABI.</target>
        </trans-unit>
        <trans-unit id="3673862083301334f396f6717a9c4dfccba740e6" translate="yes" xml:space="preserve">
          <source>Determined by ABI. The options</source>
          <target state="translated">Определено ABI.Варианты</target>
        </trans-unit>
        <trans-unit id="95662524b23c122195f82746bb2090bea580b1d6" translate="yes" xml:space="preserve">
          <source>Determining the alignment of a function, type or variable.</source>
          <target state="translated">Определение выравнивания функции,типа или переменной.</target>
        </trans-unit>
        <trans-unit id="1e53b5ee672acae1a69a324148d3c1bc9485a2b5" translate="yes" xml:space="preserve">
          <source>Developer Options</source>
          <target state="translated">Опции разработчика</target>
        </trans-unit>
        <trans-unit id="76b02b7503c565a218e0634291f3750002ba2b81" translate="yes" xml:space="preserve">
          <source>Devices belonging to &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt; can access flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions because the flash memory is mapped into the RAM address space. There is &lt;em&gt;no need&lt;/em&gt; for language extensions like &lt;code&gt;__flash&lt;/code&gt; or attribute &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;&lt;code&gt;progmem&lt;/code&gt;&lt;/a&gt;. The default linker description files for these devices cater for that feature and &lt;code&gt;.rodata&lt;/code&gt; stays in flash: The compiler just generates &lt;code&gt;LD*&lt;/code&gt; instructions, and the linker script adds core specific offsets to all &lt;code&gt;.rodata&lt;/code&gt; symbols: &lt;code&gt;0x4000&lt;/code&gt; in the case of &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;0x8000&lt;/code&gt; in the case of &lt;code&gt;avrxmega3&lt;/code&gt;. See &lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR Options&lt;/a&gt; for a list of respective devices.</source>
          <target state="translated">Устройства, принадлежащие &lt;code&gt;avrtiny&lt;/code&gt; и &lt;code&gt;avrxmega3&lt;/code&gt; , могут обращаться к флеш-памяти с помощью инструкций &lt;code&gt;LD*&lt;/code&gt; поскольку флеш-память отображается в адресное пространство RAM. Нет &lt;em&gt;необходимости&lt;/em&gt; в языковых расширениях, таких как &lt;code&gt;__flash&lt;/code&gt; или attribute &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt; &lt;code&gt;progmem&lt;/code&gt; &lt;/a&gt; . Файлы описания компоновщика по умолчанию для этих устройств для удовлетворения этой функции и &lt;code&gt;.rodata&lt;/code&gt; пребывания вспышки: компилятор только генерирует &lt;code&gt;LD*&lt;/code&gt; инструкцию, и сценарий линкера добавляет основные смещения , характерные для всех &lt;code&gt;.rodata&lt;/code&gt; символов: &lt;code&gt;0x4000&lt;/code&gt; в случае &lt;code&gt;avrtiny&lt;/code&gt; и &lt;code&gt;0x8000&lt;/code&gt; в случай &lt;code&gt;avrxmega3&lt;/code&gt; . См. Раздел &lt;a href=&quot;avr-options#AVR-Options&quot;&gt;Параметры AVR&lt;/a&gt; для получения списка соответствующих устройств.</target>
        </trans-unit>
        <trans-unit id="ce3941724906083a5cbd3b764ac34bb494078fce" translate="yes" xml:space="preserve">
          <source>Diagnostic Message Formatting Options</source>
          <target state="translated">Параметры форматирования диагностических сообщений</target>
        </trans-unit>
        <trans-unit id="24dd6971b6b8e1e14c204ff9047942c4efd19644" translate="yes" xml:space="preserve">
          <source>Diagnostic messages can optionally have an associated &lt;a href=&quot;https://cwe.mitre.org/index.html&quot;&gt;CWE&lt;/a&gt; identifier. GCC itself only provides such metadata for some of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bef0ef417e13647c36cc079b8003855e534522" translate="yes" xml:space="preserve">
          <source>Diagnostic options such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f68058e1e87ea41d8c9d3c7c1f94f8140abe531" translate="yes" xml:space="preserve">
          <source>Diagnostics can have child diagnostics. For example, this error and note:</source>
          <target state="translated">Диагностика может включать в себя диагностику детей.Например,эта ошибка и примечание:</target>
        </trans-unit>
        <trans-unit id="f2f5c489e6e2397fb8b9f0a64fb5a021b4c96f8f" translate="yes" xml:space="preserve">
          <source>Diagnostics consist of all the output sent to stderr by GCC.</source>
          <target state="translated">Диагностика состоит из всех выходных данных,посылаемых в stderr с помощью GCC.</target>
        </trans-unit>
        <trans-unit id="3545c8182bd90d9cc3755c0e6e77d7f64b0e4f2b" translate="yes" xml:space="preserve">
          <source>Different sets of tools are interoperable if they generate files that can be used in the same program. The set of tools includes compilers, assemblers, linkers, libraries, header files, startup files, and debuggers. Binaries produced by different sets of tools are not interoperable unless they implement the same ABI. This applies to different versions of the same tools as well as tools from different vendors.</source>
          <target state="translated">Различные наборы инструментов являются взаимозаменяемыми,если они генерируют файлы,которые могут быть использованы в одной и той же программе.Набор инструментов включает в себя компиляторы,ассемблеры,компоновщики,библиотеки,заголовочные файлы,файлы запуска и отладчики.Бинарии,создаваемые разными наборами инструментов,не являются взаимозаменяемыми,если они не реализуют один и тот же ABI.Это относится как к разным версиям одних и тех же инструментов,так и к инструментам разных производителей.</target>
        </trans-unit>
        <trans-unit id="356087678cfa620825af09ad133165c6564b44fe" translate="yes" xml:space="preserve">
          <source>Direct the linker to not merge together strings in the debugging information that are identical in different object files. Merging is not supported by all assemblers or linkers. Merging decreases the size of the debug information in the output file at the cost of increasing link processing time. Merging is enabled by default.</source>
          <target state="translated">Направьте компоновщику не сливать вместе строки в отладочной информации,которые идентичны в разных объектных файлах.Слияние поддерживается не всеми ассемблерами или компоновщиками.Слияние уменьшает размер отладочной информации в выходном файле за счет увеличения времени обработки ссылок.По умолчанию включено объединение.</target>
        </trans-unit>
        <trans-unit id="7eb0eda4de9f69bec3e03226fe8296271cfe198f" translate="yes" xml:space="preserve">
          <source>Directories specified with</source>
          <target state="translated">Директории,указанные с</target>
        </trans-unit>
        <trans-unit id="f710acdf8c3a36b577ab367527e400e4e4519a38" translate="yes" xml:space="preserve">
          <source>Directory Options</source>
          <target state="translated">Опции каталога</target>
        </trans-unit>
        <trans-unit id="9a7d4e0687b14e2b7cda406900b802782cd50a62" translate="yes" xml:space="preserve">
          <source>Disable</source>
          <target state="translated">Disable</target>
        </trans-unit>
        <trans-unit id="2d24b1d992d1c4af780c8f9d61b9c942a6314962" translate="yes" xml:space="preserve">
          <source>Disable (do not disable) use of the &lt;code&gt;jal&lt;/code&gt; instruction. Calling functions using &lt;code&gt;jal&lt;/code&gt; is more efficient but requires the caller and callee to be in the same 256 megabyte segment.</source>
          <target state="translated">Отключить (не отключать) использование инструкции &lt;code&gt;jal&lt;/code&gt; . Вызов функций с использованием &lt;code&gt;jal&lt;/code&gt; более эффективен, но требует, чтобы вызывающий и вызываемый абоненты находились в одном сегменте размером 256 мегабайт.</target>
        </trans-unit>
        <trans-unit id="df30c5939a2b24c38598155ef45390b83313cc5d" translate="yes" xml:space="preserve">
          <source>Disable (or enable) optimizations that use the small data section. This may be useful for working around optimizer bugs.</source>
          <target state="translated">Отключите (или включите)оптимизацию,использующую небольшую секцию данных.Это может быть полезно для работы с ошибками оптимизатора.</target>
        </trans-unit>
        <trans-unit id="7f2ac79b60fc58bb07e366adfa0ca3573c94fc1b" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of PC-relative jump instructions.</source>
          <target state="translated">Отключите (или снова включите)генерацию инструкций по ПК-относительному прыжку.</target>
        </trans-unit>
        <trans-unit id="e288cae69ca3cd91f647a069f6407394ee8f11c1" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of hardware floating point instructions. This option is only significant when the target architecture is &amp;lsquo;</source>
          <target state="translated">Отключите (или снова включите) создание аппаратных инструкций с плавающей запятой. Этот параметр имеет значение только в том случае, если целевая архитектура '</target>
        </trans-unit>
        <trans-unit id="b671582f983bdaa2dca5a8611789524ffa3c4ce1" translate="yes" xml:space="preserve">
          <source>Disable &lt;code&gt;lr&lt;/code&gt; and &lt;code&gt;sr&lt;/code&gt; instructions from using FPX extension aux registers.</source>
          <target state="translated">Отключите инструкции &lt;code&gt;lr&lt;/code&gt; и &lt;code&gt;sr&lt;/code&gt; от использования вспомогательных регистров расширения FPX.</target>
        </trans-unit>
        <trans-unit id="c1660e5f22d4c71c2ee4abdaec7f4aef18aa78c9" translate="yes" xml:space="preserve">
          <source>Disable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">Отключить МП пройти &lt;var&gt;pass&lt;/var&gt; . &lt;var&gt;pass&lt;/var&gt; - это имя прохода. Если один и тот же проход статически вызывается в компиляторе несколько раз, к имени прохода следует добавить порядковый номер, начинающийся с 1.</target>
        </trans-unit>
        <trans-unit id="9d85b585d1d05ada062cacb1bc9babcd262635c5" translate="yes" xml:space="preserve">
          <source>Disable RTL pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1. &lt;var&gt;range-list&lt;/var&gt; is a comma-separated list of function ranges or assembler names. Each range is a number pair separated by a colon. The range is inclusive in both ends. If the range is trivial, the number pair can be simplified as a single number. If the function&amp;rsquo;s call graph node&amp;rsquo;s &lt;var&gt;uid&lt;/var&gt; falls within one of the specified ranges, the &lt;var&gt;pass&lt;/var&gt; is disabled for that function. The &lt;var&gt;uid&lt;/var&gt; is shown in the function header of a dump file, and the pass names can be dumped by using option</source>
          <target state="translated">Отключить РТЛ пройти &lt;var&gt;pass&lt;/var&gt; . &lt;var&gt;pass&lt;/var&gt; - это имя прохода. Если один и тот же проход статически вызывается в компиляторе несколько раз, к имени прохода следует добавить порядковый номер, начиная с 1. &lt;var&gt;range-list&lt;/var&gt; - это список диапазонов функций или имен ассемблера, разделенных запятыми. Каждый диапазон представляет собой пару чисел, разделенных двоеточием. Диапазон включает оба конца. Если диапазон тривиален, пару чисел можно упростить как одно число. Если &lt;var&gt;uid&lt;/var&gt; узла графа вызовов функции попадает в один из указанных диапазонов, &lt;var&gt;pass&lt;/var&gt; для этой функции отключен. &lt;var&gt;uid&lt;/var&gt; показано в функции заголовка файла дампа, а имена пасс могут быть сброшены с помощью опции</target>
        </trans-unit>
        <trans-unit id="7472182885a7c5023818095d70ccee0a1003a982" translate="yes" xml:space="preserve">
          <source>Disable Wpedantic warnings about constructs used in MFC, such as implicit int and getting a pointer to member function via non-standard syntax.</source>
          <target state="translated">Отключить предупреждения Wpedantic о конструкциях,используемых в MFC,таких как неявный int и получение указателя на функцию-член через нестандартный синтаксис.</target>
        </trans-unit>
        <trans-unit id="d634773489054e3f820c752b2fe8a75da7d7b819" translate="yes" xml:space="preserve">
          <source>Disable all estimate instructions, equivalent to</source>
          <target state="translated">Отключить все инструкции по оценке,эквивалентные</target>
        </trans-unit>
        <trans-unit id="24c834ead83a4d1ebc3aa24aef6d4685246dfacb" translate="yes" xml:space="preserve">
          <source>Disable any machine-specific peephole optimizations. The difference between</source>
          <target state="translated">Отключите любые машинные оптимизации глазков.Разница между</target>
        </trans-unit>
        <trans-unit id="dd10c462b4994eb3982bf5bd6da47ab31464aa34" translate="yes" xml:space="preserve">
          <source>Disable built-in declarations of functions that are not mandated by ANSI/ISO C. These include &lt;code&gt;ffs&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;_exit&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;bzero&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, and other related functions.</source>
          <target state="translated">Отключите встроенные объявления функций, которые не требуются ANSI / ISO C. К ним относятся &lt;code&gt;ffs&lt;/code&gt; , &lt;code&gt;alloca&lt;/code&gt; , &lt;code&gt;_exit&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;bzero&lt;/code&gt; , &lt;code&gt;conjf&lt;/code&gt; и другие связанные функции.</target>
        </trans-unit>
        <trans-unit id="e02b6f324995da402dd843cdd3b4c4bea9e780ea" translate="yes" xml:space="preserve">
          <source>Disable compilation effects of</source>
          <target state="translated">Отключить эффекты компиляции</target>
        </trans-unit>
        <trans-unit id="4deddc96335abb292813c9ba7387aa150fa39b18" translate="yes" xml:space="preserve">
          <source>Disable compiler generated atomic sequences and emit library calls for atomic operations. This is the default if the target is not &lt;code&gt;sh*-*-linux*&lt;/code&gt;.</source>
          <target state="translated">Отключите генерируемые компилятором атомарные последовательности и испустите библиотечные вызовы для атомарных операций. Это значение по умолчанию, если целью является не &lt;code&gt;sh*-*-linux*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e03c896d7744b1b31e15f0be1dc55290d5dd4d98" translate="yes" xml:space="preserve">
          <source>Disable diagnostics that the standard says a compiler does not need to issue. Currently, the only such diagnostic issued by G++ is the one for a name having multiple meanings within a class.</source>
          <target state="translated">Отключите диагностику,которая,как говорит стандарт,компилятору не нужна.На данный момент единственная такая диагностика,выдаваемая G++-это диагностика имени,имеющего несколько значений внутри класса.</target>
        </trans-unit>
        <trans-unit id="15a8077f24c55fd5c21ad0119861505db428aa18" translate="yes" xml:space="preserve">
          <source>Disable generation of &lt;code&gt;bcnz&lt;/code&gt; instructions.</source>
          <target state="translated">Отключить генерацию инструкций &lt;code&gt;bcnz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5286938aafbdfcae094ead274d86fb0eb12ec590" translate="yes" xml:space="preserve">
          <source>Disable generation of information about every class with virtual functions for use by the C++ run-time type identification features (&lt;code&gt;dynamic_cast&lt;/code&gt; and &lt;code&gt;typeid&lt;/code&gt;). If you don&amp;rsquo;t use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but G++ generates it as needed. The &lt;code&gt;dynamic_cast&lt;/code&gt; operator can still be used for casts that do not require run-time type information, i.e. casts to &lt;code&gt;void *&lt;/code&gt; or to unambiguous base classes.</source>
          <target state="translated">Отключите создание информации о каждом классе с виртуальными функциями для использования функциями идентификации типа во время выполнения C ++ ( &lt;code&gt;dynamic_cast&lt;/code&gt; и &lt;code&gt;typeid&lt;/code&gt; ). Если вы не используете эти части языка, вы можете сэкономить место, используя этот флаг. Обратите внимание, что обработка исключений использует ту же информацию, но G ++ генерирует ее по мере необходимости. Оператор &lt;code&gt;dynamic_cast&lt;/code&gt; по- прежнему может использоваться для приведения типов, которые не требуют информации о типе во время выполнения, т.е. приведения к &lt;code&gt;void *&lt;/code&gt; или однозначным базовым классам.</target>
        </trans-unit>
        <trans-unit id="2c5d893b2d5daa4c819c5a8197085e49914249d8" translate="yes" xml:space="preserve">
          <source>Disable global interrupt.</source>
          <target state="translated">Отключить глобальное прерывание.</target>
        </trans-unit>
        <trans-unit id="5c285b2217d4516708f07171dfd66ed9be6d9834" translate="yes" xml:space="preserve">
          <source>Disable instruction scheduling across basic blocks, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">Отключить планирование инструкций через базовые блоки,которое обычно включается при планировании перед распределением регистров,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="0e98c6ae6e073a4473bf45d5938dfbe138a13b1c" translate="yes" xml:space="preserve">
          <source>Disable interprocedural optimizations between the function with this attribute and its callers, as if the body of the function is not available when optimizing callers and the callers are unavailable when optimizing the body. This attribute implies &lt;code&gt;noinline&lt;/code&gt;, &lt;code&gt;noclone&lt;/code&gt; and &lt;code&gt;no_icf&lt;/code&gt; attributes. However, this attribute is not equivalent to a combination of other attributes, because its purpose is to suppress existing and future optimizations employing interprocedural analysis, including those that do not have an attribute suitable for disabling them individually. This attribute is supported mainly for the purpose of testing the compiler.</source>
          <target state="translated">Отключите межпроцедурную оптимизацию между функцией с этим атрибутом и ее вызывающими объектами, как будто тело функции недоступно при оптимизации вызывающих, а вызывающие объекты недоступны при оптимизации тела. Этот атрибут подразумевает &lt;code&gt;noinline&lt;/code&gt; , &lt;code&gt;noclone&lt;/code&gt; и &lt;code&gt;no_icf&lt;/code&gt; атрибуты. Однако этот атрибут не эквивалентен комбинации других атрибутов, поскольку его цель - подавить существующие и будущие оптимизации с использованием межпроцедурного анализа, включая те, которые не имеют атрибута, подходящего для их отключения по отдельности. Этот атрибут поддерживается в основном с целью тестирования компилятора.</target>
        </trans-unit>
        <trans-unit id="c37151a8e5f5341e877c6066a7b31e954ab243b6" translate="yes" xml:space="preserve">
          <source>Disable lazy binding of function calls. This option is the default and is defined for compatibility with Diab.</source>
          <target state="translated">Отключить ленивую привязку вызовов функций.Эта опция является опцией по умолчанию и определена для совместимости с Diab.</target>
        </trans-unit>
        <trans-unit id="79f399771b0bd71907b7340d736452ada0291344" translate="yes" xml:space="preserve">
          <source>Disable linking effects of</source>
          <target state="translated">Отключить эффекты связывания</target>
        </trans-unit>
        <trans-unit id="609817ad0deecdec8c6b793819e36a0c5e4631a2" translate="yes" xml:space="preserve">
          <source>Disable nested conditional execution optimizations.</source>
          <target state="translated">Отключить вложенные условные оптимизации выполнения.</target>
        </trans-unit>
        <trans-unit id="252fe391b1a4b9d960215788262ee75bfd6c19f6" translate="yes" xml:space="preserve">
          <source>Disable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution.</source>
          <target state="translated">Отключить оптимизацию &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; в условном исполнении.</target>
        </trans-unit>
        <trans-unit id="161926f247c9f892e24d049743fa9253ac876603" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots allocated for pseudo-registers. Each pseudo-register that does not get a hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">Отключить совместное использование стековых слотов,выделенных для псевдорегистров.Каждый псевдорегистр,который не получает жесткий регистр,получает отдельный слот стека,в результате чего рамки стека функций становятся больше.</target>
        </trans-unit>
        <trans-unit id="c4a9a68d37ad2c1a1ec5ead44b9d2a2ec4d10976" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots used for saving call-used hard registers living through a call. Each hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">Отключите совместное использование слотов стека,используемых для сохранения использованных жестких регистров вызовов,переживших вызов.Каждый жесткий регистр получает отдельный слот стека,в результате чего рамки стека функций становятся больше.</target>
        </trans-unit>
        <trans-unit id="64d3adeb52b81d55606f0c9f79019d7885ab8d8f" translate="yes" xml:space="preserve">
          <source>Disable speculative motion of non-load instructions, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">Отключить спекулятивное движение ненагруженных инструкций,которое обычно включается при планировании перед распределением регистров,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="1b9e6a10d7feb88af30d21664dcd930d0d3d0e48" translate="yes" xml:space="preserve">
          <source>Disable the ARCompact-specific pass to generate conditional execution instructions.</source>
          <target state="translated">Отключите передачу ARCompact-specific для генерации условных инструкций по выполнению.</target>
        </trans-unit>
        <trans-unit id="e7b7d0aa54600e475f975b3ad94c992870425a43" translate="yes" xml:space="preserve">
          <source>Disable the ARM-state integer division extension.</source>
          <target state="translated">Отключите расширение целочисленного деления ARM-состояния.</target>
        </trans-unit>
        <trans-unit id="9ae205131ae6c1f0b1ad1d6cdc75d88e53999201" translate="yes" xml:space="preserve">
          <source>Disable the Advanced SIMD instructions (does not disable floating point).</source>
          <target state="translated">Отключите расширенные инструкции SIMD (не отключает плавающую запястье).</target>
        </trans-unit>
        <trans-unit id="57b7e24dd0dd62653de9bd626e4944fa6899e1dd" translate="yes" xml:space="preserve">
          <source>Disable the DSP extension.</source>
          <target state="translated">Отключите расширение DSP.</target>
        </trans-unit>
        <trans-unit id="734f786ab444d8f65fc0c46cdddee12bfda3218d" translate="yes" xml:space="preserve">
          <source>Disable the DSP instructions on &amp;lsquo;</source>
          <target state="translated">Отключите инструкции DSP на '</target>
        </trans-unit>
        <trans-unit id="c7d8376c95023cbfb7c660163253089208b34ece" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic extension.</source>
          <target state="translated">Отключите криптографическое расширение.</target>
        </trans-unit>
        <trans-unit id="7f3f13b931ffd3d75ba124cd726692f8712aa12e" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic instructions.</source>
          <target state="translated">Отключите криптографические инструкции.</target>
        </trans-unit>
        <trans-unit id="354594897b575026e6476d5a01060d1ccbb17336" translate="yes" xml:space="preserve">
          <source>Disable the diagnostic for converting a bound pointer to member function to a plain pointer.</source>
          <target state="translated">Отключите диагностику преобразования связанного указателя в функцию-член в обычный указатель.</target>
        </trans-unit>
        <trans-unit id="c0bf355bf048a8a4bc609b141cbb68d7e3532d66" translate="yes" xml:space="preserve">
          <source>Disable the floating-point and Advanced SIMD instructions.</source>
          <target state="translated">Отключите инструкции по работе с плавающей запятой и расширенные инструкции по работе с SIMD.</target>
        </trans-unit>
        <trans-unit id="f50bf78f4ef90550849e16bf00e7f8fd3e26a980" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extension.</source>
          <target state="translated">Отключите расширение с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="04850fd68730a9ccdd397aa31033dbe8ded5b8ec" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extensions.</source>
          <target state="translated">Отключите расширения с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="c08d0916688b59b4478dd3a8a8d551babc61d679" translate="yes" xml:space="preserve">
          <source>Disable the floating-point instructions.</source>
          <target state="translated">Отключите инструкции по использованию плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="005c34c6f1c2fb8f1d59d1e3c41e0a0a2122f930" translate="yes" xml:space="preserve">
          <source>Disable the floating-point, Advanced SIMD and cryptographic instructions.</source>
          <target state="translated">Отключите плавающую точку,усовершенствованный SIMD и криптографические инструкции.</target>
        </trans-unit>
        <trans-unit id="9c28f6f627d67c9bbae1a8f36d817bb71ee86b5b" translate="yes" xml:space="preserve">
          <source>Disable the insertion of cache barriers. This is the default setting.</source>
          <target state="translated">Отключить вставку барьеров кэша.Это настройка по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f56b2447b6cc6f830b2511a8763a44abd8412f42" translate="yes" xml:space="preserve">
          <source>Disable the optimization pass that scans for opportunities to use &amp;ldquo;decrement and branch&amp;rdquo; instructions on a count register instead of instruction sequences that decrement a register, compare it against zero, and then branch based upon the result. This option is only meaningful on architectures that support such instructions, which include x86, PowerPC, IA-64 and S/390. Note that the</source>
          <target state="translated">Отключите проход оптимизации, который просматривает возможности использования инструкций &amp;laquo;декремента и перехода&amp;raquo; в регистре счетчика вместо последовательностей инструкций, которые уменьшают регистр, сравнивают его с нулем и затем переходят на основе результата. Этот параметр имеет смысл только для архитектур, поддерживающих такие инструкции, включая x86, PowerPC, IA-64 и S / 390. Обратите внимание, что</target>
        </trans-unit>
        <trans-unit id="c15dc65887ffe75f7696788f129ef9f9ee6c4b19" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional execution.</source>
          <target state="translated">Отключить использование условного исполнения.</target>
        </trans-unit>
        <trans-unit id="47a29a4761de80ec38be8a0cf5e531389fb7bc55" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional set instructions.</source>
          <target state="translated">Отключите использование условных заданных инструкций.</target>
        </trans-unit>
        <trans-unit id="5cb2b9c6309800d129c0dac9ca4f0d952c4c16ba" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional-move instructions.</source>
          <target state="translated">Отключите использование инструкций по условному перемещению.</target>
        </trans-unit>
        <trans-unit id="c4ab5898827402073a5b1c951bd92d3ef7f4f26a" translate="yes" xml:space="preserve">
          <source>Disable the warning about a throw-expression that will immediately result in a call to &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">Отключить предупреждение о бросающем выражении, которое немедленно приведет к &lt;code&gt;terminate&lt;/code&gt; вызова .</target>
        </trans-unit>
        <trans-unit id="9e916b556b452967e0dcb5e2d11c70ff45829cad" translate="yes" xml:space="preserve">
          <source>Disable the warning about the case when a conversion function converts an object to the same type, to a base class of that type, or to void; such a conversion function will never be called.</source>
          <target state="translated">Отключите предупреждение о том,что функция приведения приводит объект к тому же самому типу,к базовому классу этого типа или к пустоте;такая функция приведения никогда не будет вызвана.</target>
        </trans-unit>
        <trans-unit id="97813576f6a1f168ea49d44405f937b0428780d3" translate="yes" xml:space="preserve">
          <source>Disable transformations and optimizations that assume default floating-point rounding behavior. This is round-to-zero for all floating point to integer conversions, and round-to-nearest for all other arithmetic truncations. This option should be specified for programs that change the FP rounding mode dynamically, or that may be executed with a non-default rounding mode. This option disables constant folding of floating-point expressions at compile time (which may be affected by rounding mode) and arithmetic transformations that are unsafe in the presence of sign-dependent rounding modes.</source>
          <target state="translated">Отключить трансформации и оптимизации,которые предполагают поведение округления с плавающей точкой по умолчанию.Это округление до нуля для всех преобразований с плавающей точкой в целые числа и округление до ближайшего для всех остальных арифметических преобразований.Эта опция должна быть указана для программ,которые динамически изменяют режим округления FP,или которые могут выполняться с режимом округления не по умолчанию.Эта опция отключает постоянное складывание выражений с плавающей точкой во время компиляции (на которое может повлиять режим округления)и арифметические преобразования,которые небезопасны при наличии знаково-зависимых режимов округления.</target>
        </trans-unit>
        <trans-unit id="fa652af71b1d233eeae7ac973249eb12d16d530a" translate="yes" xml:space="preserve">
          <source>Disable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">Отключить дерево проход &lt;var&gt;pass&lt;/var&gt; . Видеть</target>
        </trans-unit>
        <trans-unit id="c43ef83976903738f93a9dacec55c01d9094fe2c" translate="yes" xml:space="preserve">
          <source>Disable use of the small data area. Variables are put into one of &lt;code&gt;.data&lt;/code&gt;, &lt;code&gt;.bss&lt;/code&gt;, or &lt;code&gt;.rodata&lt;/code&gt; (unless the &lt;code&gt;section&lt;/code&gt; attribute has been specified). This is the default.</source>
          <target state="translated">Отключите использование небольшой области данных. Переменные помещаются в один из &lt;code&gt;.data&lt;/code&gt; , &lt;code&gt;.bss&lt;/code&gt; или &lt;code&gt;.rodata&lt;/code&gt; (если не указан атрибут &lt;code&gt;section&lt;/code&gt; ). Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="dd6879ec12c29349f77ab51cc9ef664f2b926a46" translate="yes" xml:space="preserve">
          <source>Disable warnings when non-template friend functions are declared within a template. In very old versions of GCC that predate implementation of the ISO standard, declarations such as &amp;lsquo;</source>
          <target state="translated">Отключите предупреждения, когда в шаблоне объявляются дружественные функции, не являющиеся шаблонными. В очень старых версиях GCC, предшествующих реализации стандарта ISO, такие объявления, как '</target>
        </trans-unit>
        <trans-unit id="75de5d4a7b64d839362aa8d626128e23f7764239" translate="yes" xml:space="preserve">
          <source>Disabled at level</source>
          <target state="translated">Инвалиды на уровне</target>
        </trans-unit>
        <trans-unit id="bf492e44698b816bac566d70d52b5954c19119dd" translate="yes" xml:space="preserve">
          <source>Disabled by default.</source>
          <target state="translated">По умолчанию отключен.</target>
        </trans-unit>
        <trans-unit id="aac880794e7e82b2a88791e338313ba16ba15074" translate="yes" xml:space="preserve">
          <source>Disables all the optional instructions enabled by</source>
          <target state="translated">Отключает все дополнительные инструкции,включенные</target>
        </trans-unit>
        <trans-unit id="870d995d131280874dc4cc508b91ef24ce1bb25e" translate="yes" xml:space="preserve">
          <source>Disables the SIMD (but not floating-point) instructions on &amp;lsquo;</source>
          <target state="translated">Отключает инструкции SIMD (но не с плавающей запятой) на '</target>
        </trans-unit>
        <trans-unit id="a27996206286cd961e06403639946454e47385b1" translate="yes" xml:space="preserve">
          <source>Disables the double-precision component of the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">Отключает компонент двойной точности инструкций с плавающей запятой на '</target>
        </trans-unit>
        <trans-unit id="f08047d7bdf26e21f60892f7f2f9f2faee1af25c" translate="yes" xml:space="preserve">
          <source>Disables the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">Отключает инструкции с плавающей запятой на '</target>
        </trans-unit>
        <trans-unit id="df9e25965e3555d25ff57722cb18d00af55afb9e" translate="yes" xml:space="preserve">
          <source>Disables warnings about the generation of inefficient code. These warnings can be generated, for example, when compiling code that performs byte-level memory operations on the MAC AE type. The MAC AE has no hardware support for byte-level memory operations, so all byte load/stores must be synthesized from word load/store operations. This is inefficient and a warning is generated to indicate that you should rewrite the code to avoid byte operations, or to target an AE type that has the necessary hardware support. This option disables these warnings.</source>
          <target state="translated">Отключает предупреждения о генерации неэффективного кода.Такие предупреждения могут выдаваться,например,при компиляции кода,выполняющего операции с памятью байт-уровня по типу MAC AE.MAC AE не имеет аппаратной поддержки операций с памятью байт-уровня,поэтому все операции загрузки/хранения байт должны быть синтезированы из операций загрузки/хранения слов.Это неэффективно,и выдается предупреждение,указывающее на необходимость переписать код,чтобы избежать байтовых операций,или нацелиться на тип AE,который имеет необходимую аппаратную поддержку.Данная опция отключает эти предупреждения.</target>
        </trans-unit>
        <trans-unit id="8c83476e13772d4a0c7d47269ca8280ee489e48a" translate="yes" xml:space="preserve">
          <source>Disallow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">Запретить использование расширений более поздней стандартной версии DWARF,чем выбранная с помощью</target>
        </trans-unit>
        <trans-unit id="48fef3c4f4f198a3fc747aaf4241ba4c8fd572a6" translate="yes" xml:space="preserve">
          <source>Discover read-only, write-only and non-addressable static variables. Enabled by default at</source>
          <target state="translated">Откройте для себя статические переменные,доступные только для чтения,только для записи и без адресации.По умолчанию включено в</target>
        </trans-unit>
        <trans-unit id="fcb652ea128e958ac5cce84cb6ef8250a1be8fe4" translate="yes" xml:space="preserve">
          <source>Discover which functions are pure or constant. Enabled by default at</source>
          <target state="translated">Узнайте,какие функции являются чистыми или постоянными.Включено по умолчанию на</target>
        </trans-unit>
        <trans-unit id="a208f773f4cc31e2ce047d428bfcf70af185cc47" translate="yes" xml:space="preserve">
          <source>Discover which static variables do not escape the compilation unit. Enabled by default at</source>
          <target state="translated">Узнайте,какие статические переменные не экранируются от модуля компиляции.По умолчанию включено на</target>
        </trans-unit>
        <trans-unit id="651cd5d45dfead116269d73c1f57b41b4dbd0dc9" translate="yes" xml:space="preserve">
          <source>Dispatching a call to another function.</source>
          <target state="translated">Отправка вызова на другую функцию.</target>
        </trans-unit>
        <trans-unit id="81b470ecff5209cbe640ee9ba4362aba6ca2d2e9" translate="yes" xml:space="preserve">
          <source>Display all of the optimization options supported by the compiler.</source>
          <target state="translated">Отображение всех поддерживаемых компилятором опций оптимизации.</target>
        </trans-unit>
        <trans-unit id="72c8c0bfdf122469f724652953f16cbdb6f10057" translate="yes" xml:space="preserve">
          <source>Display all of the options controlling warning messages produced by the compiler.</source>
          <target state="translated">Отображать все опции управления предупреждающими сообщениями,выдаваемыми компилятором.</target>
        </trans-unit>
        <trans-unit id="aed462cd18dddfb7255b08046613981f43dcc83d" translate="yes" xml:space="preserve">
          <source>Display demangled function names in output. The default is to show mangled function names.</source>
          <target state="translated">Отображение на выходе разобщенных имен функций.По умолчанию отображаются искаженные имена функций.</target>
        </trans-unit>
        <trans-unit id="265008e8627ab28c29c4c783e5dfd9614fe2af35" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-dump&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">Вывести справку об использовании &lt;code&gt;gcov-dump&lt;/code&gt; (в стандартном выводе) и выйти, не выполняя дальнейшую обработку.</target>
        </trans-unit>
        <trans-unit id="e12fbb96aff9cead22e458e9ec3c8f5e63fa5684" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-tool&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">Вывести справку об использовании &lt;code&gt;gcov-tool&lt;/code&gt; (в стандартном выводе) и выйти без дальнейшей обработки.</target>
        </trans-unit>
        <trans-unit id="c2a32dd6399128ea64f2e8805722cf5f0f40906c" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">Отобразить справку об использовании &lt;code&gt;gcov&lt;/code&gt; (в стандартном выводе) и выйти без дальнейшей обработки.</target>
        </trans-unit>
        <trans-unit id="05abc5bf9b915eda30e5f0fa5412f4d00c71675a" translate="yes" xml:space="preserve">
          <source>Display only those options that are undocumented.</source>
          <target state="translated">Отображать только недокументированные варианты.</target>
        </trans-unit>
        <trans-unit id="f03b0f7a546ee49a503453f7975e25ffe065c35f" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears after an equal sign in the same continuous piece of text, such as: &amp;lsquo;</source>
          <target state="translated">Параметры отображения, принимающие аргумент, который появляется после знака равенства в том же непрерывном фрагменте текста, например: '</target>
        </trans-unit>
        <trans-unit id="78dd198d091922fefb8d713c3d97e47984a683e2" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears as a separate word following the original option, such as: &amp;lsquo;</source>
          <target state="translated">Параметры отображения, принимающие аргумент, который отображается как отдельное слово после исходного параметра, например: '</target>
        </trans-unit>
        <trans-unit id="3034576017d5b01854a8c0bd7d19d6bd34b0118e" translate="yes" xml:space="preserve">
          <source>Display target-specific options. Unlike the</source>
          <target state="translated">Отображение опций,специфичных для конкретной цели.В отличие от</target>
        </trans-unit>
        <trans-unit id="344037446b18226df15907aaf4b6b36a2c93c89d" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-dump&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">Отобразите номер версии &lt;code&gt;gcov-dump&lt;/code&gt; (в стандартном выводе) и выйдите, не выполняя никакой дальнейшей обработки.</target>
        </trans-unit>
        <trans-unit id="35cc61bd60aed0586a7ab81a239eee8b50af7443" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-tool&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">Отобразите номер версии &lt;code&gt;gcov-tool&lt;/code&gt; (в стандартном выводе) и выйдите, не выполняя никакой дальнейшей обработки.</target>
        </trans-unit>
        <trans-unit id="b6e074d4004bd50fbdfdcf5bba3331e5f56c291a" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">Отобразите номер версии &lt;code&gt;gcov&lt;/code&gt; (в стандартном выводе) и выйдите, не выполняя никакой дальнейшей обработки.</target>
        </trans-unit>
        <trans-unit id="e1dab73554637fba73ebd51cac08053a6ac2d5d1" translate="yes" xml:space="preserve">
          <source>Display the dump tool help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef9fe7c4ae3fd66d0616ac76fb1a92ba4cf451e" translate="yes" xml:space="preserve">
          <source>Display the options supported for &lt;var&gt;language&lt;/var&gt;, where &lt;var&gt;language&lt;/var&gt; is the name of one of the languages supported in this version of GCC.</source>
          <target state="translated">Отобразите параметры, поддерживаемые для &lt;var&gt;language&lt;/var&gt; , где &lt;var&gt;language&lt;/var&gt; - это название одного из языков, поддерживаемых в данной версии GCC.</target>
        </trans-unit>
        <trans-unit id="ecaf3dad0e5ad7c6fd0a0b9f49a9e6fe224ab8c8" translate="yes" xml:space="preserve">
          <source>Display the options supported for &lt;var&gt;language&lt;/var&gt;, where &lt;var&gt;language&lt;/var&gt; is the name of one of the languages supported in this version of GCC. If an option is supported by all languages, one needs to select &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab2c82abfc8159be6e9fa8d50b69489311c099e" translate="yes" xml:space="preserve">
          <source>Display the options that are common to all languages.</source>
          <target state="translated">Отображение опций,общих для всех языков.</target>
        </trans-unit>
        <trans-unit id="0ec31abb5e51897ba8130f63f01229988bd5728b" translate="yes" xml:space="preserve">
          <source>Display the progress on the standard output.</source>
          <target state="translated">Отображение прогресса на стандартном выходе.</target>
        </trans-unit>
        <trans-unit id="6dbb61eb69b04350133e621d0c73b06d5ccc9c5b" translate="yes" xml:space="preserve">
          <source>Display the values recognized by the</source>
          <target state="translated">Отображение значений,распознанных с помощью</target>
        </trans-unit>
        <trans-unit id="34d093aadfdac161b403733078a63e69c40898c6" translate="yes" xml:space="preserve">
          <source>Display the version number and copyrights of the invoked GCC.</source>
          <target state="translated">Отображать номер версии и авторские права вызываемого GCC.</target>
        </trans-unit>
        <trans-unit id="26dfbbd6de78ea5ea887b6576aa7df3d1cced839" translate="yes" xml:space="preserve">
          <source>Disregard strict standards compliance.</source>
          <target state="translated">Не соблюдайте строгие стандарты.</target>
        </trans-unit>
        <trans-unit id="810ca5fb4bf9b88327a090dfa7228390b8a8933b" translate="yes" xml:space="preserve">
          <source>Distances are measured from the beginning of functions when using the</source>
          <target state="translated">Расстояния измеряются с начала функций при использовании кнопки</target>
        </trans-unit>
        <trans-unit id="700c5d1f81b1eabfd1898baf4899894e603c6ec2" translate="yes" xml:space="preserve">
          <source>Distinguish between prefix and postfix forms of increment and decrement operators.</source>
          <target state="translated">Различать префиксную и постфиксную формы операторов инкремента и декремента.</target>
        </trans-unit>
        <trans-unit id="15d45d388da758d77a316f2815f529d6f4aa8a47" translate="yes" xml:space="preserve">
          <source>Do (don&amp;rsquo;t) generate code that uses the fused multiply/add or multiply/subtract instructions. The default is to use these instructions.</source>
          <target state="translated">Создавайте (не создавайте) код, который использует объединенные инструкции умножения / сложения или умножения / вычитания. По умолчанию используются эти инструкции.</target>
        </trans-unit>
        <trans-unit id="fa3eae74d7b2c9843e7a1a146ef2fdd2dc03d4df" translate="yes" xml:space="preserve">
          <source>Do alignment optimizations for call instructions.</source>
          <target state="translated">Выполните оптимизацию выравнивания для инструкций по вызову.</target>
        </trans-unit>
        <trans-unit id="66402eadff3f8314991b18d5e3fc15f2b633b72a" translate="yes" xml:space="preserve">
          <source>Do not (do) assume that unaligned memory references are handled by the system.</source>
          <target state="translated">Не предполагайте (не предполагайте),что невыровненные ссылки на память обрабатываются системой.</target>
        </trans-unit>
        <trans-unit id="54f30aa11a7322472ca655cc5794b473a6db2cb4" translate="yes" xml:space="preserve">
          <source>Do not affect the &lt;code&gt;long_call&lt;/code&gt; or &lt;code&gt;short_call&lt;/code&gt; attributes of subsequent functions.</source>
          <target state="translated">Не влияет на &lt;code&gt;long_call&lt;/code&gt; или &lt;code&gt;short_call&lt;/code&gt; последующих функций.</target>
        </trans-unit>
        <trans-unit id="1d4def84337c056fee739188d13fda579c041fe7" translate="yes" xml:space="preserve">
          <source>Do not align the destination of inlined string operations. This switch reduces code size and improves performance in case the destination is already aligned, but GCC doesn&amp;rsquo;t know about it.</source>
          <target state="translated">Не выравнивайте назначение встроенных строковых операций. Этот переключатель уменьшает размер кода и повышает производительность в случае, если место назначения уже выровнено, но GCC об этом не знает.</target>
        </trans-unit>
        <trans-unit id="0de4bbafb6a75d9a2bf9d1dffc4ce55c0685a9e6" translate="yes" xml:space="preserve">
          <source>Do not allow constant data to be placed in code sections. Additionally, when compiling for ELF object format give all text sections the ELF processor-specific section attribute &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt;. This option is only available when generating non-pic code for M-profile targets with the MOVT instruction.</source>
          <target state="translated">Не допускайте размещения постоянных данных в разделах кода. Кроме того, при компиляции для объектного формата ELF &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt; всем текстовым разделам специфичный для процессора ELF атрибут раздела SHF_ARM_PURECODE . Эта опция доступна только при генерации кода non-pic для целей M-профиля с помощью инструкции MOVT.</target>
        </trans-unit>
        <trans-unit id="78254c6c406c6c1d161d9cea04f2b296c2dea358" translate="yes" xml:space="preserve">
          <source>Do not allow constant data to be placed in code sections. Additionally, when compiling for ELF object format give all text sections the ELF processor-specific section attribute &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt;. This option is only available when generating non-pic code for M-profile targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d843db312bcca2cdf09a7f1fe7ee427392d62fac" translate="yes" xml:space="preserve">
          <source>Do not allow the built-in functions &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt; and &lt;code&gt;trunc&lt;/code&gt;, and their &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;long
double&lt;/code&gt; variants, to generate code that raises the &amp;ldquo;inexact&amp;rdquo; floating-point exception for noninteger arguments. ISO C99 and C11 allow these functions to raise the &amp;ldquo;inexact&amp;rdquo; exception, but ISO/IEC TS 18661-1:2014, the C bindings to IEEE 754-2008, as integrated into ISO C2X, does not allow these functions to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d8305d540b6aba4d4042404329e432ca465541" translate="yes" xml:space="preserve">
          <source>Do not allow the built-in functions &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt; and &lt;code&gt;trunc&lt;/code&gt;, and their &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;long
double&lt;/code&gt; variants, to generate code that raises the &amp;ldquo;inexact&amp;rdquo; floating-point exception for noninteger arguments. ISO C99 and C11 allow these functions to raise the &amp;ldquo;inexact&amp;rdquo; exception, but ISO/IEC TS 18661-1:2014, the C bindings to IEEE 754-2008, does not allow these functions to do so.</source>
          <target state="translated">Не позволяйте встроенным функциям &lt;code&gt;ceil&lt;/code&gt; , &lt;code&gt;floor&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; и &lt;code&gt;trunc&lt;/code&gt; , а также их вариантам &lt;code&gt;float&lt;/code&gt; и &lt;code&gt;long double&lt;/code&gt; генерировать код, который вызывает &amp;laquo;неточное&amp;raquo; исключение с плавающей запятой для нецелочисленных аргументов. ISO C99 и C11 позволяют этим функциям вызывать &amp;laquo;неточное&amp;raquo; исключение, но ISO / IEC TS 18661-1: 2014, привязки C к IEEE 754-2008, не позволяют этим функциям делать это.</target>
        </trans-unit>
        <trans-unit id="f3ff2c5279a75029bc339b07e7530899c9302db8" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_LIW__&lt;/code&gt;.</source>
          <target state="translated">Не позволяйте компилятору генерировать &lt;em&gt;инструкции Long Instruction Word&lt;/em&gt; . Эта опция определяет макрос препроцессора &lt;code&gt;__NO_LIW__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="308fe4eb96a98c640686f8d44a99dca853e4e2bc" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;SETLB&lt;/em&gt; or &lt;em&gt;Lcc&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_SETLB__&lt;/code&gt;.</source>
          <target state="translated">Не позволяйте компилятору генерировать &lt;em&gt;инструкции SETLB&lt;/em&gt; или &lt;em&gt;Lcc&lt;/em&gt; . Эта опция определяет макрос препроцессора &lt;code&gt;__NO_SETLB__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c30c06515f3c7a9db38f03e0071054e61d0d6bea" translate="yes" xml:space="preserve">
          <source>Do not apply the &lt;code&gt;longcall&lt;/code&gt; attribute to subsequent function declarations.</source>
          <target state="translated">Не применяйте атрибут &lt;code&gt;longcall&lt;/code&gt; к последующим объявлениям функций.</target>
        </trans-unit>
        <trans-unit id="6c726465b100e603972419cccdc343f480a4a19b" translate="yes" xml:space="preserve">
          <source>Do not assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">Не предполагайте большой сегмент TLS при генерации потокового локального кода.</target>
        </trans-unit>
        <trans-unit id="728fc451cc179eebcc18f5c6344c5c0c36dd581d" translate="yes" xml:space="preserve">
          <source>Do not assume that registers saved by the calling function are restored before calling the &lt;code&gt;noreturn&lt;/code&gt; function.</source>
          <target state="translated">Не предполагайте, что регистры, сохраненные вызывающей функцией, восстанавливаются до вызова функции &lt;code&gt;noreturn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e33e43a1033f382fce00f6b8091a2ad6b0b4e974" translate="yes" xml:space="preserve">
          <source>Do not assume that the code being compiled won&amp;rsquo;t link against any ID shared libraries. Slower code is generated for jump and call insns.</source>
          <target state="translated">Не думайте, что компилируемый код не будет связываться с какими-либо разделяемыми библиотеками ID. Более медленный код генерируется для прыжков и вызовов.</target>
        </trans-unit>
        <trans-unit id="91704a7cde69df99e26557a8fcaceedc0c021417" translate="yes" xml:space="preserve">
          <source>Do not assume the width of floating-point registers.</source>
          <target state="translated">Не принимайте на себя ширину регистров с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="56a17068976fe756a1e89e46ec309c06e7526fbb" translate="yes" xml:space="preserve">
          <source>Do not attempt to schedule the preceding instruction into the delay slot of a branch instruction placed at the end of a short loop of six instructions or fewer and always schedule a &lt;code&gt;nop&lt;/code&gt; instruction there instead. The short loop bug under certain conditions causes loops to execute only once or twice, due to a hardware bug in the R5900 chip. The workaround is implemented by the assembler rather than by GCC.</source>
          <target state="translated">Не пытайтесь запланировать предыдущую инструкцию в слоте задержки инструкции ветвления, помещенной в конец короткого цикла из шести инструкций или меньше, и всегда вместо этого &lt;code&gt;nop&lt;/code&gt; инструкцию nop . Ошибка короткого цикла при определенных условиях приводит к тому, что циклы выполняются только один или два раза из-за аппаратной ошибки в микросхеме R5900. Обходной путь реализуется ассемблером, а не GCC.</target>
        </trans-unit>
        <trans-unit id="d2be752bd5c8aabe79c7a8b900f158b404d70833" translate="yes" xml:space="preserve">
          <source>Do not consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide. This is the default.</source>
          <target state="translated">Не считайте тип &lt;code&gt;int&lt;/code&gt; шириной 16 бит. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="08c20a0490ee73056523e456a376bd15da68e3f1" translate="yes" xml:space="preserve">
          <source>Do not create the &lt;code&gt;gcov&lt;/code&gt; output file.</source>
          <target state="translated">Не создавайте выходной файл &lt;code&gt;gcov&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61bd4083e901aa03be2fec075c5a07232b9c93d4" translate="yes" xml:space="preserve">
          <source>Do not discard comments, including during macro expansion. This is like</source>
          <target state="translated">Не отбрасывайте комментарии,в том числе при макрорасширении.Это похоже на</target>
        </trans-unit>
        <trans-unit id="094e1651c852304b7a16e16ed4d0185ecd59b26b" translate="yes" xml:space="preserve">
          <source>Do not discard comments. All comments are passed through to the output file, except for comments in processed directives, which are deleted along with the directive.</source>
          <target state="translated">Не отбрасывайте комментарии.Все комментарии передаются в выходной файл,за исключением комментариев в обрабатываемых директивах,которые удаляются вместе с директивой.</target>
        </trans-unit>
        <trans-unit id="91b2c99fa330a126f06708c6cdfa9c96a1c2ca48" translate="yes" xml:space="preserve">
          <source>Do not emit instructions with side effects in addressing modes other than post-increment.</source>
          <target state="translated">Не излучайте инструкции с побочными эффектами в режимах адресации,отличных от пост-инкрементных.</target>
        </trans-unit>
        <trans-unit id="8e8fcc0f33555f7707b3fe0e2c86d30a856ae4de" translate="yes" xml:space="preserve">
          <source>Do not emit the extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can use this option to reduce code size slightly in code that doesn&amp;rsquo;t need to be thread-safe.</source>
          <target state="translated">Не используйте дополнительный код для использования подпрограмм, указанных в C ++ ABI, для поточно-безопасной инициализации локальной статики. Вы можете использовать этот параметр, чтобы немного уменьшить размер кода в коде, который не обязательно должен быть потокобезопасным.</target>
        </trans-unit>
        <trans-unit id="a50320f9ab85e604d11edb3fea826b2a1de37844" translate="yes" xml:space="preserve">
          <source>Do not enforce a 32-byte alignment for loops. This is the default.</source>
          <target state="translated">Не применяйте 32-байтовое выравнивание для шлейфов.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="891fab210e7a9b122822bf86387a01881f014d38" translate="yes" xml:space="preserve">
          <source>Do not expand any functions inline apart from those marked with the &lt;code&gt;always_inline&lt;/code&gt; attribute. This is the default when not optimizing.</source>
          <target state="translated">Не расширяйте какие-либо встроенные функции, кроме отмеченных атрибутом &lt;code&gt;always_inline&lt;/code&gt; . Это значение по умолчанию, когда не выполняется оптимизация.</target>
        </trans-unit>
        <trans-unit id="e55929ae438e9efde315189f7933071caa5c75d9" translate="yes" xml:space="preserve">
          <source>Do not expand any symbolic links, resolve references to &amp;lsquo;</source>
          <target state="translated">Не раскрывайте символические ссылки, разрешите ссылки на '</target>
        </trans-unit>
        <trans-unit id="76bc4e801782e79c379029a2b2d98ead9b1c58f2" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation, even when you are using the &lt;code&gt;volatile&lt;/code&gt; qualifier. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">Не ожидайте, что последовательность операторов &lt;code&gt;asm&lt;/code&gt; останется безупречной последовательностью после компиляции, даже если вы используете квалификатор &lt;code&gt;volatile&lt;/code&gt; . Если определенные инструкции должны оставаться последовательными в выводе, поместите их в один оператор &lt;code&gt;asm&lt;/code&gt; с несколькими инструкциями .</target>
        </trans-unit>
        <trans-unit id="1357d76978b996f4f01f805d2256a79e656aef14" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement. Note that GCC&amp;rsquo;s optimizers can move &lt;code&gt;asm&lt;/code&gt; statements relative to other code, including across jumps.</source>
          <target state="translated">Не ожидайте, что последовательность операторов &lt;code&gt;asm&lt;/code&gt; останется безупречной последовательностью после компиляции. Если определенные инструкции должны оставаться последовательными в выводе, поместите их в один оператор &lt;code&gt;asm&lt;/code&gt; с несколькими инструкциями . Обратите внимание, что оптимизаторы GCC могут перемещать инструкции &lt;code&gt;asm&lt;/code&gt; относительно другого кода, в том числе между переходами .</target>
        </trans-unit>
        <trans-unit id="84b3d7d09c0c54d717842f06c98dbd62ec42f930" translate="yes" xml:space="preserve">
          <source>Do not generate 16-bit instructions.</source>
          <target state="translated">Не генерируйте 16-битные инструкции.</target>
        </trans-unit>
        <trans-unit id="ad6e921329e0de0a14badc58726b2429a811f03b" translate="yes" xml:space="preserve">
          <source>Do not generate &lt;code&gt;mpy&lt;/code&gt;-family instructions for ARC700. This option is deprecated.</source>
          <target state="translated">Не &lt;code&gt;mpy&lt;/code&gt; семейные инструкции mpy для ARC700. Эта опция устарела.</target>
        </trans-unit>
        <trans-unit id="677bb296fc46c470e0c30284fe52bf50c8bf95e0" translate="yes" xml:space="preserve">
          <source>Do not generate GP-relative accesses.</source>
          <target state="translated">Не генерировать доступ к GP-отношениям.</target>
        </trans-unit>
        <trans-unit id="f71d5f68821b30e885b1156b06fcb682f984e58f" translate="yes" xml:space="preserve">
          <source>Do not generate code that can only run in supervisor mode. This is relevant only for the &lt;code&gt;casa&lt;/code&gt; instruction emitted for the LEON3 processor. This is the default.</source>
          <target state="translated">Не создавайте код, который может работать только в режиме супервизора. Это актуально только для инструкции &lt;code&gt;casa&lt;/code&gt; , выдаваемой процессором LEON3. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0295c6ec8a8e0c073456a9cdaa9ef67d389ca72d" translate="yes" xml:space="preserve">
          <source>Do not generate code that reads program memory.</source>
          <target state="translated">Не генерируйте код,который читает память программы.</target>
        </trans-unit>
        <trans-unit id="2a55e3aa2938e0b388b8a2f34ed44323717c2975" translate="yes" xml:space="preserve">
          <source>Do not generate code to avoid bugs in the multiply instructions for the MN10300 processors.</source>
          <target state="translated">Не генерируйте код,чтобы избежать ошибок в инструкциях по умножению для процессоров MN10300.</target>
        </trans-unit>
        <trans-unit id="6775dd83d160f5e2159511baea19387bf2da721f" translate="yes" xml:space="preserve">
          <source>Do not generate code using features specific to the AM33 processor. This is the default.</source>
          <target state="translated">Не генерируйте код,используя функции,характерные для процессора AM33.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="159947dfd1a4fc3fd4fb823f295379e5ec4d1e29" translate="yes" xml:space="preserve">
          <source>Do not generate conditional move instructions.</source>
          <target state="translated">Не генерируйте условные инструкции по перемещению.</target>
        </trans-unit>
        <trans-unit id="2a7c63697c44693e6c631b03a4bcdf4c623d8e94" translate="yes" xml:space="preserve">
          <source>Do not generate floating-point instructions; use library calls instead. This is the default for 68000, 68010, and 68832 targets. It is also the default for ColdFire devices that have no FPU.</source>
          <target state="translated">Не генерируйте инструкции с плавающей точкой,а используйте вызовы библиотек.По умолчанию это используется для целей 68000,68010 и 68832.Это также является значением по умолчанию для устройств ColdFire,которые не имеют FPU.</target>
        </trans-unit>
        <trans-unit id="2cc223b18a9c8fe85db4c5fdd1a4568ac5523351" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for &lt;code&gt;sqrt&lt;/code&gt;.</source>
          <target state="translated">Не создавайте встроенный код для &lt;code&gt;sqrt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dccee88899cb101fdf1122d7b6f87cc5ad98128" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of floating-point values.</source>
          <target state="translated">Не генерировать строчный код для деления значений с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="db0d6f198e71d6a0581c6b52ba5d158f3703dad4" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of integer values.</source>
          <target state="translated">Не генерировать строчный код для деления целочисленных значений.</target>
        </trans-unit>
        <trans-unit id="5bf145c70d37b823fa320934be3a45f2f5b58879" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension 2 instructions.</source>
          <target state="translated">Не генерируйте инструкции по расширению производительности 2.</target>
        </trans-unit>
        <trans-unit id="3b1b47a62d265ff0109bc6fe295c353c7dfbd942" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension instructions.</source>
          <target state="translated">Не генерируйте инструкции по увеличению производительности.</target>
        </trans-unit>
        <trans-unit id="b028375dbf2397374ef15ae6807634be0bef9937" translate="yes" xml:space="preserve">
          <source>Do not generate sdata references. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">Не создавайте ссылки на sdata. Это значение по умолчанию для цепочек инструментов, созданных для целей &lt;code&gt;arc-linux-uclibc&lt;/code&gt; &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; и arceb-linux-uclibc .</target>
        </trans-unit>
        <trans-unit id="543afe0ee34f2553275fc1e0d4f92ae4d031e11e" translate="yes" xml:space="preserve">
          <source>Do not generate string extension instructions.</source>
          <target state="translated">Не генерируйте инструкции по расширению строк.</target>
        </trans-unit>
        <trans-unit id="35172dff465f7db05c87cd9d0fa618a5943366ff" translate="yes" xml:space="preserve">
          <source>Do not generate v3 push25/pop25 instructions.</source>
          <target state="translated">Не генерируйте инструкции v3 push25/pop25.</target>
        </trans-unit>
        <trans-unit id="57a412ef71d36d080e33196062eae1a348ffd9a5" translate="yes" xml:space="preserve">
          <source>Do not guess branch probabilities using heuristics.</source>
          <target state="translated">Не угадывайте вероятности ветвей с помощью эвристики.</target>
        </trans-unit>
        <trans-unit id="c3b0780d488de79c8fb5609252ace9e026b5485c" translate="yes" xml:space="preserve">
          <source>Do not link in the C run-time initialization object file.</source>
          <target state="translated">Не связывайте в объектном файле инициализации во время выполнения C.</target>
        </trans-unit>
        <trans-unit id="1be7375d07ff18651b91e6f0b8f72660024d9706" translate="yes" xml:space="preserve">
          <source>Do not mark ABI switches in e_flags.</source>
          <target state="translated">Не отмечайте ABI-переключатели в e_flags.</target>
        </trans-unit>
        <trans-unit id="431d0ac813eff431a021eadf038696c3b8c0a701" translate="yes" xml:space="preserve">
          <source>Do not optimize (do optimize) basic blocks that use the same index pointer 4 or more times to copy pointer into the &lt;code&gt;ep&lt;/code&gt; register, and use the shorter &lt;code&gt;sld&lt;/code&gt; and &lt;code&gt;sst&lt;/code&gt; instructions. The</source>
          <target state="translated">Не оптимизируйте (не оптимизируйте) базовые блоки, которые используют один и тот же указатель индекса 4 или более раз для копирования указателя в регистр &lt;code&gt;ep&lt;/code&gt; , и используйте более &lt;code&gt;sst&lt;/code&gt; инструкции &lt;code&gt;sld&lt;/code&gt; и sst .</target>
        </trans-unit>
        <trans-unit id="79c5f07fbe7818d1561eea80118156e770e03da3" translate="yes" xml:space="preserve">
          <source>Do not optimize block moves, use &lt;code&gt;memcpy&lt;/code&gt;.</source>
          <target state="translated">Не оптимизируйте перемещение блоков, используйте &lt;code&gt;memcpy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c81bdb6603f6660bfebcf5b1c10715d6960adf2" translate="yes" xml:space="preserve">
          <source>Do not or do generate unaligned memory accesses. The default is set depending on whether the processor we are optimizing for supports fast unaligned access or not.</source>
          <target state="translated">Не генерируйте или не генерируйте несогласованные обращения к памяти.Значение по умолчанию устанавливается в зависимости от того,поддерживает ли процессор,который мы оптимизируем,быстрый не выровненный доступ или нет.</target>
        </trans-unit>
        <trans-unit id="4a89ae960644f6dae44b3cb05c0d0550f4cbdda0" translate="yes" xml:space="preserve">
          <source>Do not output certain jump instructions (&lt;code&gt;aobleq&lt;/code&gt; and so on) that the Unix assembler for the VAX cannot handle across long ranges.</source>
          <target state="translated">Не &lt;code&gt;aobleq&lt;/code&gt; определенные инструкции перехода ( aobleq и т. Д.), Которые ассемблер Unix для VAX не может обрабатывать на больших расстояниях.</target>
        </trans-unit>
        <trans-unit id="f8a3ee3da0c5dc6481bc333868effaef20cfecb3" translate="yes" xml:space="preserve">
          <source>Do not pack VLIW instructions.</source>
          <target state="translated">Не упаковывайте инструкции VLIW.</target>
        </trans-unit>
        <trans-unit id="5cf0a2e01f314e50aac688fcc0637765ffe183d2" translate="yes" xml:space="preserve">
          <source>Do not predefine any system-specific or GCC-specific macros. The standard predefined macros remain defined.</source>
          <target state="translated">Не предопределяйте макросы,специфичные для системы или GCC.Стандартные предопределенные макросы остаются определенными.</target>
        </trans-unit>
        <trans-unit id="490cb97bfac29c7944f438d394a40917ab27b463" translate="yes" xml:space="preserve">
          <source>Do not print column numbers in diagnostics. This may be necessary if diagnostics are being scanned by a program that does not understand the column numbers, such as &lt;code&gt;dejagnu&lt;/code&gt;.</source>
          <target state="translated">Не печатайте номера столбцов в диагностике. Это может быть необходимо, если диагностические данные сканируются программой, которая не понимает номера столбцов, например &lt;code&gt;dejagnu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a166eec1d3e160d989368c024582f88a817fbe4" translate="yes" xml:space="preserve">
          <source>Do not put function addresses in registers; make each instruction that calls a constant function contain the function&amp;rsquo;s address explicitly.</source>
          <target state="translated">Не помещайте адреса функций в регистры; сделать так, чтобы каждая инструкция, которая вызывает постоянную функцию, явно содержала адрес функции.</target>
        </trans-unit>
        <trans-unit id="42d099b873c7985f112edf3c200fc2a3b03ec5d0" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;asm&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use these words as identifiers. You can use the keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; instead.</source>
          <target state="translated">Не распознавайте &lt;code&gt;asm&lt;/code&gt; , &lt;code&gt;inline&lt;/code&gt; или &lt;code&gt;typeof&lt;/code&gt; как ключевое слово, чтобы код мог использовать эти слова в качестве идентификаторов. &lt;code&gt;__typeof__&lt;/code&gt; этого вы можете использовать ключевые слова &lt;code&gt;__asm__&lt;/code&gt; , &lt;code&gt;__inline__&lt;/code&gt; и __typeof__ .</target>
        </trans-unit>
        <trans-unit id="4748c7a1ef517bb9ba562d1dfbac2e153a84b556" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use this word as an identifier. You can use the keyword &lt;code&gt;__typeof__&lt;/code&gt; instead. This option is implied by the strict ISO C++ dialects:</source>
          <target state="translated">Не распознавайте &lt;code&gt;typeof&lt;/code&gt; как ключевое слово, чтобы код мог использовать это слово в качестве идентификатора. &lt;code&gt;__typeof__&lt;/code&gt; этого вы можете использовать ключевое слово __typeof__ . Этот вариант подразумевается строгими диалектами ISO C ++:</target>
        </trans-unit>
        <trans-unit id="d988b2ea918cdfbb994dc84b28dcc9b828621817" translate="yes" xml:space="preserve">
          <source>Do not remove unused C++ allocations in dead code elimination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0184fc6ad01e42f8636e2c8922ca8fae3a1d46de" translate="yes" xml:space="preserve">
          <source>Do not reorder functions or variables marked &lt;code&gt;no_reorder&lt;/code&gt; against each other or top level assembler statements the executable. The actual order in the program will depend on the linker command line. Static variables marked like this are also not removed. This has a similar effect as the</source>
          <target state="translated">Не переупорядочивайте функции или переменные с пометкой &lt;code&gt;no_reorder&lt;/code&gt; относительно друг друга или операторов ассемблера верхнего уровня исполняемого файла. Фактический порядок в программе будет зависеть от командной строки компоновщика. Статические переменные, отмеченные таким образом, также не удаляются. Это имеет тот же эффект, что и</target>
        </trans-unit>
        <trans-unit id="8ddac79842e7bae2915ad838f14a89d8d6021356" translate="yes" xml:space="preserve">
          <source>Do not reorder top-level functions, variables, and &lt;code&gt;asm&lt;/code&gt; statements. Output them in the same order that they appear in the input file. When this option is used, unreferenced static variables are not removed. This option is intended to support existing code that relies on a particular ordering. For new code, it is better to use attributes when possible.</source>
          <target state="translated">Не меняйте порядок функций верхнего уровня, переменных и операторов &lt;code&gt;asm&lt;/code&gt; . Выведите их в том же порядке, в каком они появляются во входном файле. Когда используется эта опция, статические переменные, на которые нет ссылок, не удаляются. Этот параметр предназначен для поддержки существующего кода, который зависит от определенного порядка. Для нового кода лучше по возможности использовать атрибуты.</target>
        </trans-unit>
        <trans-unit id="e09f89632800cad3603644ff83e1a579b7e4eb4f" translate="yes" xml:space="preserve">
          <source>Do not run a pass to pack branches into VLIW instructions.</source>
          <target state="translated">Не пропускайте ветки для упаковки в инструкции VLIW.</target>
        </trans-unit>
        <trans-unit id="0dba1f61030583d8ab48fd80d73e6a5afaf9d194" translate="yes" xml:space="preserve">
          <source>Do not save registers in &lt;code&gt;main&lt;/code&gt;. The effect is the same like attaching attribute &lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt;&lt;code&gt;OS_task&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;main&lt;/code&gt;. It is activated per default if optimization is on.</source>
          <target state="translated">Не сохраняйте регистры в &lt;code&gt;main&lt;/code&gt; . Эффект такой же, как и при прикреплении атрибута &lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt; &lt;code&gt;OS_task&lt;/code&gt; &lt;/a&gt; к &lt;code&gt;main&lt;/code&gt; . По умолчанию он активирован, если включена оптимизация.</target>
        </trans-unit>
        <trans-unit id="9b74c0ce30e69827202932531a3c2d31b17cec32" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the C++-specific standard directories, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">Не выполняйте поиск заголовочных файлов в стандартных каталогах,специфичных для C++,но продолжайте поиск в других стандартных каталогах.(Эта опция используется при сборке библиотеки С++).</target>
        </trans-unit>
        <trans-unit id="10d644d96645c398a65f49953416f8df18eac09b" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the standard directories specific to C++, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">Не выполняйте поиск заголовочных файлов в стандартных каталогах,специфичных для C++,но продолжайте поиск в других стандартных каталогах.(Эта опция используется при сборке библиотеки С++).</target>
        </trans-unit>
        <trans-unit id="6ee81949a7a2777f7208e1e6ee75bc8ae9472923" translate="yes" xml:space="preserve">
          <source>Do not search the standard system directories for header files. Only the directories explicitly specified with</source>
          <target state="translated">Не выполняйте поиск заголовочных файлов в стандартных системных каталогах.Только каталоги,явно указанные с</target>
        </trans-unit>
        <trans-unit id="eb16433a9f72928c54140581a05d1867ea26ccd7" translate="yes" xml:space="preserve">
          <source>Do not set &lt;code&gt;errno&lt;/code&gt; after calling math functions that are executed with a single instruction, e.g., &lt;code&gt;sqrt&lt;/code&gt;. A program that relies on IEEE exceptions for math error handling may want to use this flag for speed while maintaining IEEE arithmetic compatibility.</source>
          <target state="translated">Не устанавливайте значение &lt;code&gt;errno&lt;/code&gt; после вызова математических функций, которые выполняются с одной инструкцией, например &lt;code&gt;sqrt&lt;/code&gt; . Программа, которая полагается на исключения IEEE для обработки математических ошибок, может захотеть использовать этот флаг для повышения скорости при сохранении арифметической совместимости IEEE.</target>
        </trans-unit>
        <trans-unit id="20c8d2c68cfa75e481382ec2a217fdac468ae476" translate="yes" xml:space="preserve">
          <source>Do not store floating-point variables in registers, and inhibit other options that might change whether a floating-point value is taken from a register or memory.</source>
          <target state="translated">Не храните переменные с плавающей точкой в регистрах и запрещайте другие опции,которые могут изменить,берется ли значение с плавающей точкой из регистра или памяти.</target>
        </trans-unit>
        <trans-unit id="1e223b8f5150edab41b25d5219e57c17c3a59917" translate="yes" xml:space="preserve">
          <source>Do not substitute constants for known return value of formatted output functions such as &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;vsprintf&lt;/code&gt;, and &lt;code&gt;vsnprintf&lt;/code&gt; (but not &lt;code&gt;printf&lt;/code&gt; of &lt;code&gt;fprintf&lt;/code&gt;). This transformation allows GCC to optimize or even eliminate branches based on the known return value of these functions called with arguments that are either constant, or whose values are known to be in a range that makes determining the exact return value possible. For example, when</source>
          <target state="translated">Не заменяйте константами известное возвращаемое значение функций форматированного вывода, таких как &lt;code&gt;sprintf&lt;/code&gt; , &lt;code&gt;snprintf&lt;/code&gt; , &lt;code&gt;vsprintf&lt;/code&gt; и &lt;code&gt;vsnprintf&lt;/code&gt; (но не &lt;code&gt;printf&lt;/code&gt; из &lt;code&gt;fprintf&lt;/code&gt; ). Это преобразование позволяет GCC оптимизировать или даже исключить ветки на основе известного возвращаемого значения этих функций, вызываемых с аргументами, которые либо являются постоянными, либо значения которых, как известно, находятся в диапазоне, позволяющем определить точное возвращаемое значение. Например, когда</target>
        </trans-unit>
        <trans-unit id="cf78eba26b5aa804017da1ef12f012cd3682e1fb" translate="yes" xml:space="preserve">
          <source>Do not treat the operator name keywords &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;bitand&lt;/code&gt;, &lt;code&gt;bitor&lt;/code&gt;, &lt;code&gt;compl&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;xor&lt;/code&gt; as synonyms as keywords.</source>
          <target state="translated">Не рассматривайте ключевые слова имя оператора &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;bitand&lt;/code&gt; , &lt;code&gt;bitor&lt;/code&gt; , &lt;code&gt;compl&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; и &lt;code&gt;xor&lt;/code&gt; в качестве синонимов в качестве ключевых слов.</target>
        </trans-unit>
        <trans-unit id="a51f0c8e8070d0d16a2b1996318508b466a43f6d" translate="yes" xml:space="preserve">
          <source>Do not try to dynamically allocate condition code registers, only use &lt;code&gt;icc0&lt;/code&gt; and &lt;code&gt;fcc0&lt;/code&gt;.</source>
          <target state="translated">Не пытайтесь динамически выделять регистры кода условия, используйте только &lt;code&gt;icc0&lt;/code&gt; и &lt;code&gt;fcc0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4b145e8904eea56f7b19e2cc3eedad3e7a2b834" translate="yes" xml:space="preserve">
          <source>Do not use (do use) external functions to save and restore registers at the prologue and epilogue of a function. The external functions are slower, but use less code space if more than one function saves the same number of registers. The</source>
          <target state="translated">Не используйте (не используйте)внешние функции для сохранения и восстановления регистров в прологе и эпилоге функции.Внешние функции работают медленнее,но используют меньше места в коде,если несколько функций сохраняют одинаковое количество регистров..</target>
        </trans-unit>
        <trans-unit id="00d7092da6abac6816723cc9e024cce735f69d9a" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;__gcc_isr&lt;/code&gt; pseudo instructions in a function with the &lt;code&gt;interrupt&lt;/code&gt; or &lt;code&gt;signal&lt;/code&gt; attribute aka. interrupt service routine (ISR). Use this attribute if the preamble of the ISR prologue should always read</source>
          <target state="translated">Не используйте псевдо-инструкции &lt;code&gt;__gcc_isr&lt;/code&gt; в функции с атрибутом &lt;code&gt;interrupt&lt;/code&gt; или &lt;code&gt;signal&lt;/code&gt; известным как. процедура обслуживания прерывания (ISR). Используйте этот атрибут, если преамбула пролога ISR всегда должна читаться</target>
        </trans-unit>
        <trans-unit id="18d8580e81e8dfe5a32f7016f417e2eb0471dcb3" translate="yes" xml:space="preserve">
          <source>Do not use a so-called &amp;ldquo;red zone&amp;rdquo; for x86-64 code. The red zone is mandated by the x86-64 ABI; it is a 128-byte area beyond the location of the stack pointer that is not modified by signal or interrupt handlers and therefore can be used for temporary data without adjusting the stack pointer. The flag</source>
          <target state="translated">Не используйте так называемую &amp;laquo;красную зону&amp;raquo; для кода x86-64. Красная зона обязана x86-64 ABI; это 128-байтовая область за пределами местоположения указателя стека, которая не изменяется обработчиками сигналов или прерываний и поэтому может использоваться для временных данных без настройки указателя стека. Флаг</target>
        </trans-unit>
        <trans-unit id="18a500f76abd74325a0b47c0d5b69985957db494" translate="yes" xml:space="preserve">
          <source>Do not use condition-code results from previous instruction; always emit compare and test instructions before use of condition codes.</source>
          <target state="translated">Не используйте результаты кодов состояния из предыдущих инструкций;всегда излучайте инструкции по сравнению и тестированию перед использованием кодов состояния.</target>
        </trans-unit>
        <trans-unit id="8b90672d13ea8faf72441a2154876e77530d1d87" translate="yes" xml:space="preserve">
          <source>Do not use div and mod instructions.</source>
          <target state="translated">Не используйте инструкции по погружениям и моделям.</target>
        </trans-unit>
        <trans-unit id="a1c8552434007f4da99e51d45212d527e1753ccf" translate="yes" xml:space="preserve">
          <source>Do not use double word instructions.</source>
          <target state="translated">Не используйте инструкции в двух словах.</target>
        </trans-unit>
        <trans-unit id="3da98d0922de975e727ce6056f533717a8befbdb" translate="yes" xml:space="preserve">
          <source>Do not use floating-point coprocessor instructions. Implement floating-point calculations using library calls instead.</source>
          <target state="translated">Не используйте инструкции сопроцессора с плавающей запятой.Реализовывать вычисления с плавающей точкой,используя вызовы библиотек.</target>
        </trans-unit>
        <trans-unit id="9fdd545e439d4b4617a15eacf8cd9e4f96ac14e8" translate="yes" xml:space="preserve">
          <source>Do not use floating-point double instructions.</source>
          <target state="translated">Не используйте двойные инструкции с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="95fd53c42ee138555aacbc40f7b4326fe9304fd6" translate="yes" xml:space="preserve">
          <source>Do not use hardware floating point.</source>
          <target state="translated">Не используйте аппаратные плавающие запятые.</target>
        </trans-unit>
        <trans-unit id="97b2ddca9650ddbadc66a49ca355676910df5582" translate="yes" xml:space="preserve">
          <source>Do not use jump tables for switch statements even where it would be more efficient than other code generation strategies. This option is of use in conjunction with</source>
          <target state="translated">Не используйте таблицы переходов для переключения операторов даже там,где это было бы более эффективно,чем другие стратегии генерации кода.Этот вариант может быть использован в сочетании с</target>
        </trans-unit>
        <trans-unit id="66b43b46849088f20d198292bf3b1d8b62697198" translate="yes" xml:space="preserve">
          <source>Do not use media instructions.</source>
          <target state="translated">Не используйте инструкции для СМИ.</target>
        </trans-unit>
        <trans-unit id="0a7e7f9ca7cad5a355cdeb3565cfa6b4acd871ea" translate="yes" xml:space="preserve">
          <source>Do not use multiply and add/subtract instructions.</source>
          <target state="translated">Не используйте инструкции по умножению и добавлению/вычитанию.</target>
        </trans-unit>
        <trans-unit id="8d9e83aee940103d590cb767e0456c5b78e32683" translate="yes" xml:space="preserve">
          <source>Do not use table-based fast divide for small numbers. The default is to use the fast divide at</source>
          <target state="translated">Не используйте табличное быстрое разделение для малых чисел.По умолчанию используется быстрое разделение на</target>
        </trans-unit>
        <trans-unit id="05b033596194e8c7885a56cfce16297eb0279fb4" translate="yes" xml:space="preserve">
          <source>Do not use the C library or system libraries tightly coupled with it when linking. Still link with the startup files,</source>
          <target state="translated">Не используйте библиотеку C или системные библиотеки,тесно связанные с ней при линковке.Продолжайте линковку с загрузочными файлами,</target>
        </trans-unit>
        <trans-unit id="7597081c858717e7804a44bce422498f190040a9" translate="yes" xml:space="preserve">
          <source>Do not use the FPU registers for return values of functions.</source>
          <target state="translated">Не используйте регистры FPU для возврата значений функций.</target>
        </trans-unit>
        <trans-unit id="1d16a9b15ecbbe19aaee48f8f83799d98bf40097" translate="yes" xml:space="preserve">
          <source>Do not use the PLT for external function calls in position-independent code. Instead, load the callee address at call sites from the GOT and branch to it. This leads to more efficient code by eliminating PLT stubs and exposing GOT loads to optimizations. On architectures such as 32-bit x86 where PLT stubs expect the GOT pointer in a specific register, this gives more register allocation freedom to the compiler. Lazy binding requires use of the PLT; with</source>
          <target state="translated">Не используйте PLT для внешних вызовов функций в позиционно-независимом коде.Вместо этого загрузите адрес вызывающего абонента в местах вызова из GOT и филиала на него.Это приведет к более эффективному коду за счет устранения шлейфов PLT и оптимизации загрузки GOT.На таких архитектурах,как 32-битный x86,где PLT-шлейфы ожидают,что указатель GOT находится в определенном регистре,это дает компилятору больше свободы распределения регистров.Ленивая привязка требует использования PLT;с помощью</target>
        </trans-unit>
        <trans-unit id="0ea4440b962126227be7707085ba73c227777ab2" translate="yes" xml:space="preserve">
          <source>Do not use the bit-field instructions. The</source>
          <target state="translated">Не используйте инструкции по битовому полю.</target>
        </trans-unit>
        <trans-unit id="be4c2d58ea2c75689a1e197b8bce077dc3baf8e4" translate="yes" xml:space="preserve">
          <source>Do not use the standard system libraries when linking. Only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">Не используйте стандартные системные библиотеки при компоновке.В компоновщик передаются только те библиотеки,которые вы укажете,и опции,определяющие линковку системных библиотек,такие как</target>
        </trans-unit>
        <trans-unit id="1749ead3f9e7878168e9e856a83790c8110a2327" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files or libraries when linking. No startup files and only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">Не используйте при компоновке стандартные файлы запуска системы или библиотеки.В компоновщик не передаются никакие файлы запуска и только указанные вами библиотеки,а также опции,определяющие связывание системных библиотек,такие как</target>
        </trans-unit>
        <trans-unit id="c08b8394a0f77286bf2dfe4eba4ed4f08b60e58a" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files when linking. The standard system libraries are used normally, unless</source>
          <target state="translated">Не используйте при компоновке стандартные файлы запуска системы.Стандартные системные библиотеки используются обычно,если только</target>
        </trans-unit>
        <trans-unit id="52b9f7e2d461f74673bbbc8c6515110fc50b3657" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, using the &lt;code&gt;volatile&lt;/code&gt; qualifier does not fully prevent the compiler from optimizing accesses to the register.</source>
          <target state="translated">Не используйте квалификаторы типа, такие как &lt;code&gt;const&lt;/code&gt; и &lt;code&gt;volatile&lt;/code&gt; , поскольку результат может противоречить ожиданиям. В частности, использование квалификатора &lt;code&gt;volatile&lt;/code&gt; не полностью мешает компилятору оптимизировать доступ к регистру.</target>
        </trans-unit>
        <trans-unit id="78d5320a817e4a255712f70b363a7e985f54d40c" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, when the &lt;code&gt;const&lt;/code&gt; qualifier is used, the compiler may substitute the variable with its initializer in &lt;code&gt;asm&lt;/code&gt; statements, which may cause the corresponding operand to appear in a different register.</source>
          <target state="translated">Не используйте квалификаторы типа, такие как &lt;code&gt;const&lt;/code&gt; и &lt;code&gt;volatile&lt;/code&gt; , поскольку результат может противоречить ожиданиям. В частности, когда используется квалификатор &lt;code&gt;const&lt;/code&gt; , компилятор может заменить переменную ее инициализатором в операторах &lt;code&gt;asm&lt;/code&gt; , что может привести к появлению соответствующего операнда в другом регистре.</target>
        </trans-unit>
        <trans-unit id="4a1518a9d7c5d3a374a0e3380575da8c6a0c3463" translate="yes" xml:space="preserve">
          <source>Do not use weak symbol support, even if it is provided by the linker. By default, G++ uses weak symbols if they are available. This option exists only for testing, and should not be used by end-users; it results in inferior code and has no benefits. This option may be removed in a future release of G++.</source>
          <target state="translated">Не используйте слабую поддержку символов,даже если она предоставляется компоновщиком.По умолчанию G++использует слабые символы,если они доступны.Этот вариант существует только для тестирования и не должен использоваться конечными пользователями,это приводит к уступающему коду и не имеет никаких преимуществ.Эта опция может быть удалена в следующем выпуске G++.</target>
        </trans-unit>
        <trans-unit id="1c6a44b0e85a6edc81e27b7d2eeb886e6e3cf31e" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time integer division by zero. Floating-point division by zero is not warned about, as it can be a legitimate way of obtaining infinities and NaNs.</source>
          <target state="translated">Не предупреждайте о целочисленном делении на ноль.О делении с плавающей точкой на ноль не предупреждают,так как это может быть законным способом получения бесконечности и NaN.</target>
        </trans-unit>
        <trans-unit id="5c0402a3d7a93e89c19d0b2bc886627da9bb7bce" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time overflow in constant expressions.</source>
          <target state="translated">Не предупреждайте о переполнении компиляционного времени в константных выражениях.</target>
        </trans-unit>
        <trans-unit id="f3164f98334eb82394edc2af61f2d8e4ea49e902" translate="yes" xml:space="preserve">
          <source>Do not warn about incompatible integer to pointer and pointer to integer conversions. This warning is about implicit conversions; for explicit conversions the warnings</source>
          <target state="translated">Не предупреждайте о несовместимых целочисленных приведениях к указателю и указателю на целое число.Предупреждение относится к неявным приведениям,а для явных приведений-к целым числам.</target>
        </trans-unit>
        <trans-unit id="9ee34e26cbf6dcdf9bae6a606eba5f147e3812eb" translate="yes" xml:space="preserve">
          <source>Do not warn about misuses of pragmas, such as incorrect parameters, invalid syntax, or conflicts between pragmas. See also</source>
          <target state="translated">Не предупреждайте о неправильном использовании прагм,таких как неправильные параметры,неправильный синтаксис или конфликты между прагмами.См.также</target>
        </trans-unit>
        <trans-unit id="2fba612926859cd3b2ec30d821b233c2c88e411e" translate="yes" xml:space="preserve">
          <source>Do not warn about returning a pointer (or in C++, a reference) to a variable that goes out of scope after the function returns.</source>
          <target state="translated">Не предупреждайте о возвращении указателя (или в Си++-ссылки)на переменную,выходящую за пределы области видимости после возврата функции.</target>
        </trans-unit>
        <trans-unit id="92098da2097ee55c0bcb42fe16576932a7b751af" translate="yes" xml:space="preserve">
          <source>Do not warn about stray tokens after &lt;code&gt;#else&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20062785b98beaefd7db7d397190023d3d7d01c" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of deprecated features. See &lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;Deprecated Features&lt;/a&gt;.</source>
          <target state="translated">Не предупреждать об использовании устаревших функций. См. &lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;Устаревшие функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5741a81d36ae80d4f66c3d238560cf727f6d2221" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) declared with &lt;code&gt;warning&lt;/code&gt; attribute. By default, this warning is enabled.</source>
          <target state="translated">Не предупреждать об использовании функций (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), объявленных с атрибутом &lt;code&gt;warning&lt;/code&gt; . По умолчанию это предупреждение включено.</target>
        </trans-unit>
        <trans-unit id="569882ee6769c783a7c673619d2b596b07ae7884" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of &lt;code&gt;std::initializer_list&lt;/code&gt; that are likely to result in dangling pointers. Since the underlying array for an &lt;code&gt;initializer_list&lt;/code&gt; is handled like a normal C++ temporary object, it is easy to inadvertently keep a pointer to the array past the end of the array&amp;rsquo;s lifetime. For example:</source>
          <target state="translated">Не предупреждайте об использовании &lt;code&gt;std::initializer_list&lt;/code&gt; которое может привести к зависанию указателей. Поскольку базовый массив для &lt;code&gt;initializer_list&lt;/code&gt; обрабатывается как обычный временный объект C ++, легко случайно сохранить указатель на массив после окончания срока его существования. Например:</target>
        </trans-unit>
        <trans-unit id="e7879bd2657e4473a1347324fd997f9cdc3d041e" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;) marked as deprecated by using the &lt;code&gt;deprecated&lt;/code&gt; attribute.</source>
          <target state="translated">Не предупреждать об использовании функций (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), переменных (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ) и типов (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ), отмеченных как устаревшие с помощью &lt;code&gt;deprecated&lt;/code&gt; атрибута.</target>
        </trans-unit>
        <trans-unit id="e33f23c639b6d41c2c3035fff8afee57ebc3fce6" translate="yes" xml:space="preserve">
          <source>Do not warn for calls to bounded string manipulation functions such as &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, and &lt;code&gt;stpncpy&lt;/code&gt; that may either truncate the copied string or leave the destination unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ba657c651e9df665e818d59934ea7360d21f9d" translate="yes" xml:space="preserve">
          <source>Do not warn for conversions between &lt;code&gt;NULL&lt;/code&gt; and non-pointer types.</source>
          <target state="translated">Не предупреждать о преобразованиях между типами &lt;code&gt;NULL&lt;/code&gt; и типами без указателей.</target>
        </trans-unit>
        <trans-unit id="f3c7034f14450f34ae37fb2f3dc3f8309df1df4c" translate="yes" xml:space="preserve">
          <source>Do not warn if a caller of a function marked with attribute &lt;code&gt;warn_unused_result&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) does not use its return value. The default is</source>
          <target state="translated">Не предупреждать, если вызывающий объект функции, отмеченной атрибутом &lt;code&gt;warn_unused_result&lt;/code&gt; (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; ), не использует свое возвращаемое значение. По умолчанию</target>
        </trans-unit>
        <trans-unit id="fb9755e0253eb1306289d1103fce8726c90aae41" translate="yes" xml:space="preserve">
          <source>Do not warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage. If a type A depends on a type B with no or internal linkage, defining it in multiple translation units would be an ODR violation because the meaning of B is different in each translation unit. If A only appears in a single translation unit, the best way to silence the warning is to give it internal linkage by putting it in an anonymous namespace as well. The compiler doesn&amp;rsquo;t give this warning for types defined in the main .C file, as those are unlikely to have multiple definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c44e9dcc0d0d2cc0d4fcbe48e1b3887ed71621" translate="yes" xml:space="preserve">
          <source>Do not warn if a multicharacter constant (&amp;lsquo;</source>
          <target state="translated">Не предупреждать, если многосимвольная константа ('</target>
        </trans-unit>
        <trans-unit id="443e1e0e70a448710aa93209ae6dd62fb7533f28" translate="yes" xml:space="preserve">
          <source>Do not warn if a pointer is compared with a zero character constant. This usually means that the pointer was meant to be dereferenced. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474d345e0c92820e39935346f3f6f08e315a2c69" translate="yes" xml:space="preserve">
          <source>Do not warn if a priority from 0 to 100 is used for constructor or destructor. The use of constructor and destructor attributes allow you to assign a priority to the constructor/destructor to control its order of execution before &lt;code&gt;main&lt;/code&gt; is called or after it returns. The priority values must be greater than 100 as the compiler reserves priority values between 0&amp;ndash;100 for the implementation.</source>
          <target state="translated">Не предупреждать, если для конструктора или деструктора используется приоритет от 0 до 100. Использование атрибутов конструктора и деструктора позволяет вам назначить приоритет конструктору / деструктору для управления порядком его выполнения до вызова &lt;code&gt;main&lt;/code&gt; или после его возврата. Значения приоритета должны быть больше 100, поскольку компилятор резервирует для реализации значения приоритета от 0 до 100.</target>
        </trans-unit>
        <trans-unit id="732973795e8a7e32daa52d09fac5902c9d2be92b" translate="yes" xml:space="preserve">
          <source>Do not warn if a property for an Objective-C object has no assign semantics specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a797405ed28a43b7b96611721ab2d6938e13b2f" translate="yes" xml:space="preserve">
          <source>Do not warn if an initialized field with side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;). This warning is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5958651457da08de9e91cd3ae0fc547368da59b" translate="yes" xml:space="preserve">
          <source>Do not warn if an unexpected &lt;code&gt;__attribute__&lt;/code&gt; is used, such as unrecognized attributes, function attributes applied to variables, etc. This does not stop errors for incorrect use of supported attributes.</source>
          <target state="translated">Не предупреждать, если используется неожиданный атрибут &lt;code&gt;__attribute__&lt;/code&gt; , например нераспознанные атрибуты, атрибуты функций, примененные к переменным и т. Д. Это не останавливает ошибки из-за неправильного использования поддерживаемых атрибутов.</target>
        </trans-unit>
        <trans-unit id="776e98d1dffbde23efe71be5b00aaf8afcebd19f" translate="yes" xml:space="preserve">
          <source>Do not warn if certain built-in macros are redefined. This suppresses warnings for redefinition of &lt;code&gt;__TIMESTAMP__&lt;/code&gt;, &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt;, &lt;code&gt;__FILE__&lt;/code&gt;, and &lt;code&gt;__BASE_FILE__&lt;/code&gt;.</source>
          <target state="translated">Не предупреждать, если некоторые встроенные макросы переопределяются. Это подавляет предупреждения о переопределении &lt;code&gt;__TIMESTAMP__&lt;/code&gt; , &lt;code&gt;__TIME__&lt;/code&gt; , &lt;code&gt;__DATE__&lt;/code&gt; , &lt;code&gt;__FILE__&lt;/code&gt; и &lt;code&gt;__BASE_FILE__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5961961b151110f8171f9f71097fa474a97d41f" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on arrays which are pointer targets are being discarded. Typically, the compiler warns if a &lt;code&gt;const int (*)[]&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;int (*)[]&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">Не предупреждать, если квалификаторы типа для массивов, которые являются целевыми указателями, отбрасываются. Обычно компилятор выдает предупреждение, если переменная &lt;code&gt;const int (*)[]&lt;/code&gt; передается функции, которая принимает параметр &lt;code&gt;int (*)[]&lt;/code&gt; . Этот параметр можно использовать для подавления такого предупреждения.</target>
        </trans-unit>
        <trans-unit id="4f6ac391aa1f66b1759edea5545511d490e350b4" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on pointers are being discarded. Typically, the compiler warns if a &lt;code&gt;const char *&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;char *&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">Не предупреждать, если квалификаторы типа указателей отбрасываются. Обычно компилятор предупреждает, если переменная &lt;code&gt;const char *&lt;/code&gt; передается функции, которая принимает параметр &lt;code&gt;char *&lt;/code&gt; . Этот параметр можно использовать для подавления такого предупреждения.</target>
        </trans-unit>
        <trans-unit id="2237d0ea4af513f919bfca5807318b7adb31ba01" translate="yes" xml:space="preserve">
          <source>Do not warn on suspicious constructs involving reverse scalar storage order.</source>
          <target state="translated">Не предупреждайте о подозрительных конструкциях,связанных с обратным скалярным порядком хранения.</target>
        </trans-unit>
        <trans-unit id="dbb582054a4578d09382786263898193b0ff21b0" translate="yes" xml:space="preserve">
          <source>Do not warn upon questionable usage of the macros used to handle variable arguments like &lt;code&gt;va_start&lt;/code&gt;. These warnings are enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b084ddd7e0fe08b48906115755ffa4e3da32fe0c" translate="yes" xml:space="preserve">
          <source>Do not warn when HSAIL cannot be emitted for the compiled function or OpenMP construct. These warnings are enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7781876bcee57ab05b4c1b6a1db698152f3d5c11" translate="yes" xml:space="preserve">
          <source>Do not warn when a &lt;code&gt;switch&lt;/code&gt; statement contains statements between the controlling expression and the first case label, which will never be executed. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28680d2e20ffb7926eea11f38e1b6b85ce89c733" translate="yes" xml:space="preserve">
          <source>Do not warn when a &lt;code&gt;switch&lt;/code&gt; statement has an index of boolean type and the case values are outside the range of a boolean type. It is possible to suppress this warning by casting the controlling expression to a type other than &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af5475a41b51138661971a42f878b92d42b232b" translate="yes" xml:space="preserve">
          <source>Do not warn when a conversion function converts an object to the same type, to a base class of that type, or to void; such a conversion function will never be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c13e36c06e819c05d426233228bd8a2938fb6e" translate="yes" xml:space="preserve">
          <source>Do not warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore. As a conforming extension, GCC treats such suffixes as separate preprocessing tokens in order to maintain backwards compatibility with code that uses formatting macros from &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505f6f0a22dd44c4b12ed8d2e6a399fe3806c159" translate="yes" xml:space="preserve">
          <source>Do not warn when attempting to free an object that was not allocated on the heap.</source>
          <target state="translated">Не предупреждайте при попытке освободить объект,который не был выделен на кучу.</target>
        </trans-unit>
        <trans-unit id="0eea2eb346314f258d9bd4887c4a7d0ac495ba36" translate="yes" xml:space="preserve">
          <source>Do not warn when deleting a pointer to incomplete type, which may cause undefined behavior at runtime. This warning is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94889f68926578d446953d9dc1636114cf6715d6" translate="yes" xml:space="preserve">
          <source>Do not warn when the &lt;code&gt;sizeof&lt;/code&gt; operator is applied to a parameter that is declared as an array in a function definition. This warning is enabled by default for C and C++ programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d665894bec0cb8c7c615758edc8127e2b609bfec" translate="yes" xml:space="preserve">
          <source>Do not warn when the address of packed member of struct or union is taken, which usually results in an unaligned pointer value. This is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41e5f71b800c0d75e8bc4c789587d50634e7b35" translate="yes" xml:space="preserve">
          <source>Do not warn when there is a conversion between pointers that have incompatible types. This warning is for cases not covered by</source>
          <target state="translated">Не предупреждайте,когда происходит преобразование между указателями,которые имеют несовместимые типы.Это предупреждение предназначено для случаев,не охваченных</target>
        </trans-unit>
        <trans-unit id="7288e67492dfae2c91a3de07cd384be7cd59dcec" translate="yes" xml:space="preserve">
          <source>Do not warn whenever a local variable shadows an instance variable in an Objective-C method.</source>
          <target state="translated">Не предупреждайте,когда локальная переменная затеняет переменную экземпляра в методе Objective-C.</target>
        </trans-unit>
        <trans-unit id="a828e7021a3bac6b8a79dcdabca3402745cfbb45" translate="yes" xml:space="preserve">
          <source>Do not warn whenever an &lt;code&gt;#else&lt;/code&gt; or an &lt;code&gt;#endif&lt;/code&gt; are followed by text. This sometimes happens in older programs with code of the form</source>
          <target state="translated">Не предупреждать, если после &lt;code&gt;#else&lt;/code&gt; или &lt;code&gt;#endif&lt;/code&gt; идет текст. Иногда это происходит в старых программах с кодом вида</target>
        </trans-unit>
        <trans-unit id="12e3a14254e97e0a14b8cdd90a112ee9ef9f78f5" translate="yes" xml:space="preserve">
          <source>Do nothing. Code written for the Borland model works fine, but each translation unit contains instances of each of the templates it uses. The duplicate instances will be discarded by the linker, but in a large program, this can lead to an unacceptable amount of code duplication in object files or shared libraries.</source>
          <target state="translated">Ничего не делай.Код,написанный для модели Borland,работает нормально,но каждая единица трансляции содержит экземпляры каждого из используемых ею шаблонов.Дублирующие экземпляры отбрасываются компоновщиком,но в большой программе это может привести к недопустимому количеству дублирования кода в объектных файлах или разделяемых библиотеках.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
