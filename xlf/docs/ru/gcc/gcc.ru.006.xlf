<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="fec27cce313d8eb12d908932146cca5b44cb0b96" translate="yes" xml:space="preserve">
          <source>8.10.2 Forwarding Hook</source>
          <target state="translated">8.10.2 Пересылочный крюк</target>
        </trans-unit>
        <trans-unit id="c503d0ed0e5cd0f8688e6bc9706ecda7076965e9" translate="yes" xml:space="preserve">
          <source>8.10.2. Forwarding Hook</source>
          <target state="translated">8.10.2.Пересылочный крюк</target>
        </trans-unit>
        <trans-unit id="0d54a093d567e45971dfe60046ab944e71a6dc74" translate="yes" xml:space="preserve">
          <source>8.2 +load: Executing Code before main</source>
          <target state="translated">8.2+нагрузка:Исполняющий код перед основным</target>
        </trans-unit>
        <trans-unit id="4c46829f2755d63494e7358356a171f9c0aa2c92" translate="yes" xml:space="preserve">
          <source>8.2 &lt;code&gt;+load&lt;/code&gt;: Executing Code before &lt;code&gt;main&lt;/code&gt;</source>
          <target state="translated">8.2 &lt;code&gt;+load&lt;/code&gt; : выполнение кода перед &lt;code&gt;main&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6ee8357cf66d468fce21ce87f6e1455c61c9d71" translate="yes" xml:space="preserve">
          <source>8.2. +load: Executing Code before main</source>
          <target state="translated">8.2.+нагрузка:Исполняющий код перед основным</target>
        </trans-unit>
        <trans-unit id="0e37b3bc6a72bc7a45aefe525b01b3bcbc69dc62" translate="yes" xml:space="preserve">
          <source>8.2.1 What You Can and Cannot Do in +load</source>
          <target state="translated">8.2.1 Что ты можешь и не можешь сделать в +загрузке.</target>
        </trans-unit>
        <trans-unit id="7514eae887431bc2b23c9f91ceeb2b8927f90957" translate="yes" xml:space="preserve">
          <source>8.2.1 What You Can and Cannot Do in &lt;code&gt;+load&lt;/code&gt;</source>
          <target state="translated">8.2.1 Что можно и чего нельзя делать в &lt;code&gt;+load&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bc74bfbf57cd10928d01b916e6fa71d6d37346e" translate="yes" xml:space="preserve">
          <source>8.2.1. What You Can and Cannot Do in +load</source>
          <target state="translated">8.2.1.Что ты можешь и не можешь сделать в +загрузить</target>
        </trans-unit>
        <trans-unit id="ac17a28fe0400efdbbf27dc0a3aa19d768882f50" translate="yes" xml:space="preserve">
          <source>8.3 Type Encoding</source>
          <target state="translated">8.3 Кодирование типа</target>
        </trans-unit>
        <trans-unit id="0b5a28a401e5caa1731675ca56a84d444c15fa81" translate="yes" xml:space="preserve">
          <source>8.3. Type Encoding</source>
          <target state="translated">8.3.Кодирование типа</target>
        </trans-unit>
        <trans-unit id="f6228ff4737811227a708bc22b6ff3a77b75cceb" translate="yes" xml:space="preserve">
          <source>8.3.1 Legacy Type Encoding</source>
          <target state="translated">8.3.1 Кодирование типа наследия</target>
        </trans-unit>
        <trans-unit id="7bec6b4bee7afdb83a43730a9fe5c4d6d085e864" translate="yes" xml:space="preserve">
          <source>8.3.1. Legacy Type Encoding</source>
          <target state="translated">8.3.1.Кодирование по типу наследия</target>
        </trans-unit>
        <trans-unit id="5527244afdb6dfb3dca3ad889987c2fef987074e" translate="yes" xml:space="preserve">
          <source>8.3.2 &lt;code&gt;@encode&lt;/code&gt;</source>
          <target state="translated">8.3.2 &lt;code&gt;@encode&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="978fa94702c6bb2aa016de617938fd819d570db4" translate="yes" xml:space="preserve">
          <source>8.3.2 @encode</source>
          <target state="translated">8.3.2 @encode</target>
        </trans-unit>
        <trans-unit id="4493f310bc1651626e01d4c07ee677385159442c" translate="yes" xml:space="preserve">
          <source>8.3.2. @encode</source>
          <target state="translated">8.3.2.@кодировка</target>
        </trans-unit>
        <trans-unit id="e76f8c08ebb07739970dc34b59461ba675ae7b31" translate="yes" xml:space="preserve">
          <source>8.3.3 Method Signatures</source>
          <target state="translated">8.3.3 Метод Подписи</target>
        </trans-unit>
        <trans-unit id="0cd2b9090f85dc474192078b9cdd2977a7b93ce8" translate="yes" xml:space="preserve">
          <source>8.3.3. Method Signatures</source>
          <target state="translated">8.3.3.Метод Подписи</target>
        </trans-unit>
        <trans-unit id="8dc0bdb621513ef296dfe1ccb8a8e69178e55c00" translate="yes" xml:space="preserve">
          <source>8.4 Garbage Collection</source>
          <target state="translated">8,4 Сбор мусора</target>
        </trans-unit>
        <trans-unit id="f07f1c7fc14cbe1fbcf43d8205938600aba5fb3a" translate="yes" xml:space="preserve">
          <source>8.4. Garbage Collection</source>
          <target state="translated">8.4.Сбор мусора</target>
        </trans-unit>
        <trans-unit id="7a1c9992cbe3a8eb5bac4598d41c0f55497fcfd0" translate="yes" xml:space="preserve">
          <source>8.5 Constant String Objects</source>
          <target state="translated">8,5 Объекты с постоянной связью</target>
        </trans-unit>
        <trans-unit id="4a2eeb0e04646c0d1d5dde7596bb4e3ab441cf85" translate="yes" xml:space="preserve">
          <source>8.5. Constant String Objects</source>
          <target state="translated">8.5.Объекты с постоянной струной</target>
        </trans-unit>
        <trans-unit id="1ad03b99d44944113a02e8b2d43422e1fb50690e" translate="yes" xml:space="preserve">
          <source>8.6 &lt;code&gt;compatibility_alias&lt;/code&gt;</source>
          <target state="translated">8.6 &lt;code&gt;compatibility_alias&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16a6371cd4eb99b88acbb876c48214d1528996b9" translate="yes" xml:space="preserve">
          <source>8.6 compatibility_alias</source>
          <target state="translated">8,6 совместимость</target>
        </trans-unit>
        <trans-unit id="68169a32cc1b2c0d8e0fdd12ac28ee8a4f88ccd1" translate="yes" xml:space="preserve">
          <source>8.6. compatibility_alias</source>
          <target state="translated">8.6.совместимость</target>
        </trans-unit>
        <trans-unit id="477e0b2d2877013fc309d42abd04b7a7fac95b0e" translate="yes" xml:space="preserve">
          <source>8.7 Exceptions</source>
          <target state="translated">8.7 Исключения</target>
        </trans-unit>
        <trans-unit id="16af8614813519947458cd70b76429228a166bf8" translate="yes" xml:space="preserve">
          <source>8.7. Exceptions</source>
          <target state="translated">8.7.Исключения</target>
        </trans-unit>
        <trans-unit id="74543d3119c6680f587a9317c42b3e80f7812525" translate="yes" xml:space="preserve">
          <source>8.8 Synchronization</source>
          <target state="translated">8,8 Синхронизация</target>
        </trans-unit>
        <trans-unit id="083f9b1455cca391952297e65a5f3c8e7fb0c091" translate="yes" xml:space="preserve">
          <source>8.8. Synchronization</source>
          <target state="translated">8.8.Синхронизация</target>
        </trans-unit>
        <trans-unit id="7338c2122f2c6512086917a88263a1ffa319037d" translate="yes" xml:space="preserve">
          <source>8.9 Fast Enumeration</source>
          <target state="translated">8,9 Быстрый подсчёт</target>
        </trans-unit>
        <trans-unit id="ec7154738dfa0ae117df4872a446a28e2a0711e7" translate="yes" xml:space="preserve">
          <source>8.9. Fast Enumeration</source>
          <target state="translated">8.9.Быстрый подсчет</target>
        </trans-unit>
        <trans-unit id="c5c48c9ddc1c6eec5370a9f3cc1d2da53b4277bc" translate="yes" xml:space="preserve">
          <source>8.9.1 Using Fast Enumeration</source>
          <target state="translated">8.9.1 Использование быстрого перечисления</target>
        </trans-unit>
        <trans-unit id="6ad2c7a48f39c65d867329ec2c7335528dcac484" translate="yes" xml:space="preserve">
          <source>8.9.1. Using Fast Enumeration</source>
          <target state="translated">8.9.1.Использование быстрого подсчета</target>
        </trans-unit>
        <trans-unit id="d4e4b02de8979958bbc292a9013946837f1fa2de" translate="yes" xml:space="preserve">
          <source>8.9.2 C99-Like Fast Enumeration Syntax</source>
          <target state="translated">8,9,2 С99-синтаксис быстрого пересчета</target>
        </trans-unit>
        <trans-unit id="c0c8d7e4c548cb334b0077b49fb8d7954fa1bc7a" translate="yes" xml:space="preserve">
          <source>8.9.2. C99-Like Fast Enumeration Syntax</source>
          <target state="translated">8.9.2.С99-Синтаксис быстрого перечисления</target>
        </trans-unit>
        <trans-unit id="fc941982a158e238821dd94fbed3bb5cab331767" translate="yes" xml:space="preserve">
          <source>8.9.3 Fast Enumeration Details</source>
          <target state="translated">8.9.3 Быстрое перечисление Подробности</target>
        </trans-unit>
        <trans-unit id="1e69e987b4483c072c99556446bfbd580c89a6c7" translate="yes" xml:space="preserve">
          <source>8.9.3. Fast Enumeration Details</source>
          <target state="translated">8.9.3.Быстрое перечисление Подробности</target>
        </trans-unit>
        <trans-unit id="66afcdf52d12c5936c393d8a7d4415ca40641c8c" translate="yes" xml:space="preserve">
          <source>8.9.4 Fast Enumeration Protocol</source>
          <target state="translated">8.9.4 Протокол ускоренного перечисления</target>
        </trans-unit>
        <trans-unit id="af86351ac19c6a92b0fadb75de17d30680748abf" translate="yes" xml:space="preserve">
          <source>8.9.4. Fast Enumeration Protocol</source>
          <target state="translated">8.9.4.Протокол быстрого пересчета</target>
        </trans-unit>
        <trans-unit id="2a24cd506294a07c6a0446f8badafaf3201f2507" translate="yes" xml:space="preserve">
          <source>9 Binary Compatibility</source>
          <target state="translated">9 Двоичная совместимость</target>
        </trans-unit>
        <trans-unit id="aaf34f43b56348453c9670867bbe710bc4cff1f1" translate="yes" xml:space="preserve">
          <source>9-bit signed integer constant for load and store postincrements</source>
          <target state="translated">9-битная подписанная целочисленная константа для загрузки и хранения постинкрементов</target>
        </trans-unit>
        <trans-unit id="f5866ff425b2380665d4757e884a24f7c0c34afd" translate="yes" xml:space="preserve">
          <source>9. Binary Compatibility</source>
          <target state="translated">9.Двоичная совместимость</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="0e96f6929feaa8c7f7735055f893a7b75a845c22" translate="yes" xml:space="preserve">
          <source>: even though it may help make the global offset table smaller, it trades 1 instruction for 4. With</source>
          <target state="translated">: даже при том, что это может помочь уменьшить глобальную таблицу смещений, он меняет 1 инструкцию на 4. С</target>
        </trans-unit>
        <trans-unit id="63347315fe8e655bf95e9a504d6fcbb0f9ecd9f0" translate="yes" xml:space="preserve">
          <source>: this header declares a public runtime API threading layer that is only provided by the GNU Objective-C runtime. It declares functions such as &lt;code&gt;objc_mutex_lock()&lt;/code&gt;, which provide a platform-independent set of threading functions.</source>
          <target state="translated">: этот заголовок объявляет уровень потоковой передачи общедоступного API среды выполнения, который предоставляется только средой выполнения GNU Objective-C. Он объявляет такие функции, как &lt;code&gt;objc_mutex_lock()&lt;/code&gt; , которые предоставляют независимый от платформы набор функций потоковой передачи.</target>
        </trans-unit>
        <trans-unit id="30dd56b7640731d14fa9ecac2bbbbb504e1a5176" translate="yes" xml:space="preserve">
          <source>: this header declares most of the public runtime API functions allowing you to inspect and manipulate the Objective-C runtime data structures. These functions are fairly standardized across Objective-C runtimes and are almost identical to the Apple/NeXT Objective-C runtime ones. It does not declare functions in some specialized areas (constructing and forwarding message invocations, threading) which are in the other headers below. You have to include</source>
          <target state="translated">: этот заголовок объявляет большинство общедоступных функций API среды выполнения, позволяющих вам проверять и управлять структурами данных среды выполнения Objective-C. Эти функции довольно стандартизированы для среды выполнения Objective-C и почти идентичны функциям среды выполнения Apple / NeXT Objective-C. Он не объявляет функции в некоторых специализированных областях (создание и пересылка вызовов сообщений, потоковая передача), которые находятся в других заголовках ниже. Вы должны включить</target>
        </trans-unit>
        <trans-unit id="26a235338902d41d3db5491024b9576d18742880" translate="yes" xml:space="preserve">
          <source>: this header declares public functions used to construct, deconstruct and forward message invocations. Because messaging is done in quite a different way on different runtimes, functions in this header are specific to the GNU Objective-C runtime implementation.</source>
          <target state="translated">: в этом заголовке объявляются общедоступные функции, используемые для создания, деконструкции и пересылки вызовов сообщений. Поскольку обмен сообщениями осуществляется совершенно по-разному в разных средах выполнения, функции в этом заголовке специфичны для реализации среды выполнения GNU Objective-C.</target>
        </trans-unit>
        <trans-unit id="5a3c29505625144ba68750995731439e9906fdd5" translate="yes" xml:space="preserve">
          <source>: this header declares some public functions related to Objective-C exceptions. For example functions in this header allow you to throw an Objective-C exception from plain C/C++ code.</source>
          <target state="translated">: этот заголовок объявляет некоторые общедоступные функции, связанные с исключениями Objective-C. Например, функции в этом заголовке позволяют генерировать исключение Objective-C из простого кода C / C ++.</target>
        </trans-unit>
        <trans-unit id="9e5ef08f873716700e594dd3a36d7d64d5272d49" translate="yes" xml:space="preserve">
          <source>: this header declares some public functions related to the Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; syntax, allowing you to emulate an Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; block in plain C/C++ code.</source>
          <target state="translated">: в этом заголовке объявляются некоторые общедоступные функции, связанные с синтаксисом Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; , что позволяет вам эмулировать блок Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; в простом коде C / C ++.</target>
        </trans-unit>
        <trans-unit id="7cc9c1a09bf135868f452e4dc5bbf2907bfed13f" translate="yes" xml:space="preserve">
          <source>: this is the basic Objective-C header file, defining the basic Objective-C types such as &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;BOOL&lt;/code&gt;. You have to include this header to do almost anything with Objective-C.</source>
          <target state="translated">: это основной файл заголовка Objective-C, определяющий основные типы Objective-C, такие как &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;Class&lt;/code&gt; и &lt;code&gt;BOOL&lt;/code&gt; . Вы должны включить этот заголовок, чтобы делать почти все с Objective-C.</target>
        </trans-unit>
        <trans-unit id="e8c89b6d4332bd3369abe0522644501e5013a432" translate="yes" xml:space="preserve">
          <source>; higher levels are not, and must be explicitly requested.</source>
          <target state="translated">; более высокие уровни не требуются и должны быть явно запрошены.</target>
        </trans-unit>
        <trans-unit id="a66283a15e09823e79a5c6a663cf680f2ab5e710" translate="yes" xml:space="preserve">
          <source>; however, use of the backchain for debugging purposes usually requires that the whole binary is built with</source>
          <target state="translated">; однако использование backchain для целей отладки обычно требует, чтобы весь двоичный файл был построен с</target>
        </trans-unit>
        <trans-unit id="2e840d8b6d6867941a2eee8b46c7d917829de2b1" translate="yes" xml:space="preserve">
          <source>; it causes the preprocessor to treat comments as tokens in their own right. For example, comments appearing at the start of what would be a directive line have the effect of turning that line into an ordinary source line, since the first token on the line is no longer a &amp;lsquo;</source>
          <target state="translated">; это заставляет препроцессор обрабатывать комментарии как самостоятельные токены. Например, комментарии, появляющиеся в начале строки директивы, превращают эту строку в обычную строку исходного кода, поскольку первый токен в строке больше не является символом '</target>
        </trans-unit>
        <trans-unit id="fe9de4759d0dc5597c891d37b107703d1930a026" translate="yes" xml:space="preserve">
          <source>; it then defines &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; and does not make assumptions about the meanings of function names from the standard library, with exceptions noted below. To build an OS kernel, you may well still need to make your own arrangements for linking and startup. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;.</source>
          <target state="translated">; он затем определяет &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; до &lt;code&gt;0&lt;/code&gt; и не делать предположение о значениях имен функций из стандартной библиотеки, с исключениями , указанными ниже. Чтобы собрать ядро ​​ОС, вам, возможно, все же придется принять меры для компоновки и запуска. См &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Функции контроллинга C Диалектом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd28d9793fcd7e9f0549371e16a97a1f053629f" translate="yes" xml:space="preserve">
          <source>; see &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;.</source>
          <target state="translated">; см. &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Параметры, управляющие диалектом C ++&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50016dac566b707582c4b1fc771e52069b7a937b" translate="yes" xml:space="preserve">
          <source>; the corrections are also applied with</source>
          <target state="translated">; поправки также применяются с</target>
        </trans-unit>
        <trans-unit id="3eb04dcb759dd8c0995915b2a5ccb10d6a327b33" translate="yes" xml:space="preserve">
          <source>; the same rule applies to macros defined this way.</source>
          <target state="translated">; то же правило применяется к макросам, определенным таким образом.</target>
        </trans-unit>
        <trans-unit id="00b878f7746de72103ac67a35f0e1d78575bcec7" translate="yes" xml:space="preserve">
          <source>; they do not have this problem.</source>
          <target state="translated">; у них нет этой проблемы.</target>
        </trans-unit>
        <trans-unit id="39de10441f5a92f5c2ca38349b7c2fdec8841dcf" translate="yes" xml:space="preserve">
          <source>; this option implies</source>
          <target state="translated">; этот вариант подразумевает</target>
        </trans-unit>
        <trans-unit id="1989c55c1ff2b01f4215828caa4538ad66beba83" translate="yes" xml:space="preserve">
          <source>; to obtain all the diagnostics required by the standard, you should also specify</source>
          <target state="translated">; чтобы получить всю диагностику, требуемую стандартом, необходимо также указать</target>
        </trans-unit>
        <trans-unit id="a73b42f7298a4e09fb1e0072c5f63bdced6b9b8c" translate="yes" xml:space="preserve">
          <source>; when linking, it links in a special thread helper library</source>
          <target state="translated">; при компоновке он ссылается на специальную вспомогательную библиотеку потоков</target>
        </trans-unit>
        <trans-unit id="06561510744788a1609ec5f60662cc5908d39e15" translate="yes" xml:space="preserve">
          <source>; you should not need to use it for anything else.</source>
          <target state="translated">; вам не нужно использовать его ни для чего другого.</target>
        </trans-unit>
        <trans-unit id="431058a2491fcbde34064009eece9653a8f5b829" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Example&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Example&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="01d7c1c3eb993c58806b746668090c8a26bb75db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Limitations and caveats&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Ограничения и предостережения&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0424675c89789c8478a359447a9eeb880c777989" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.init]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.init]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e3b972f187fc77684d7b4caf8cb567979becf9f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.main]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.main]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b883af22766032bc16303da205cb38fbd19479e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.term]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.term]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18fcd33e6f11059c9a572ef77f16711d1475704" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc.static]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc.static]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0fc91ea62596ffaa9b88e5f5653a875441113bac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc.thread]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc.thread]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="13e2f1e5179d31ce813b6d9c962af8d8f15a52b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="082e6d5681614613f1cf46008d31795e30341ce2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[class.mem]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[class.mem]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="20a71e88049b10a9036fc51e894c28860a33cdaf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[dcl.stc]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[dcl.stc]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="51818883b235ce777320b575e0bf8025965510ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[intro.execution]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[intro.execution]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1a31fbd2e2b9c5c3bb615b7491f612d5a707c3ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[lex.key]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[lex.key]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cc4701ea1dbc7c0ae0a60db0f72537871372ebf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;![16,16i]&lt;/code&gt; (alignment depends on the machine)</source>
          <target state="translated">&lt;code&gt;![16,16i]&lt;/code&gt; (центровка зависит от машины)</target>
        </trans-unit>
        <trans-unit id="cffc58ac2d212878e6c4d3afeb9026603af158fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma interface&lt;/code&gt; and &lt;code&gt;#pragma implementation&lt;/code&gt; provide the user with a way of explicitly directing the compiler to emit entities with vague linkage (and debugging information) in a particular translation unit.</source>
          <target state="translated">&lt;code&gt;#pragma interface&lt;/code&gt; и &lt;code&gt;#pragma implementation&lt;/code&gt; предоставляют пользователь способом явно направляя компилятор испускать лицо с неопределенной связью (и отладочной информацией) в конкретной единице трансляции.</target>
        </trans-unit>
        <trans-unit id="2569b071a9af441d9b6296aa268b56f40df7cca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct off&lt;/code&gt; turns off the Microsoft layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct off&lt;/code&gt; выключает макет Microsoft.</target>
        </trans-unit>
        <trans-unit id="5e363473f488b7983412e972ce0eac0f09b14174" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct on&lt;/code&gt; turns on the Microsoft layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct on&lt;/code&gt; включает макет Microsoft.</target>
        </trans-unit>
        <trans-unit id="107cfa70f66f6e21716326b44d8c2543bd277a0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct reset&lt;/code&gt; goes back to the default layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct reset&lt;/code&gt; возвращает к макету по умолчанию.</target>
        </trans-unit>
        <trans-unit id="359f3157fca41c8df8f6c827d78d1920672257ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack()&lt;/code&gt; sets the alignment to the one that was in effect when compilation started (see also command-line option</source>
          <target state="translated">&lt;code&gt;#pragma pack()&lt;/code&gt; устанавливает выравнивание на то, которое действовало при запуске компиляции (см. также параметр командной строки</target>
        </trans-unit>
        <trans-unit id="2da8592b5f1ca4f7c8ec146ce07922d1be68b588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; simply sets the new alignment.</source>
          <target state="translated">&lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; просто устанавливает новое выравнивание.</target>
        </trans-unit>
        <trans-unit id="09cd1961f6ec088315967f82b215657a1847a8f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(pop)&lt;/code&gt; restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that &lt;code&gt;#pragma pack([&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; does not influence this internal stack; thus it is possible to have &lt;code&gt;#pragma pack(push)&lt;/code&gt; followed by multiple &lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; instances and finalized by a single &lt;code&gt;#pragma pack(pop)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#pragma pack(pop)&lt;/code&gt; восстанавливает настройку выравнивания до значения, сохраненного в верхней части внутреннего стека (и удаляет эту запись стека). Обратите внимание, что &lt;code&gt;#pragma pack([&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; не влияет на этот внутренний стек; таким образом, можно иметь &lt;code&gt;#pragma pack(push)&lt;/code&gt; за которым следуют несколько экземпляров &lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; и завершаться одним &lt;code&gt;#pragma pack(pop)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1f4e8456ee450b615ff464f6ff9615991f7f956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(push[,&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; pushes the current alignment setting on an internal stack and then optionally sets the new alignment.</source>
          <target state="translated">&lt;code&gt;#pragma pack(push[,&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; помещает текущую настройку выравнивания во внутренний стек, а затем при необходимости устанавливает новое выравнивание.</target>
        </trans-unit>
        <trans-unit id="8d404d78e391f3edc2a1e7fe1018546d3f145abe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order big-endian&lt;/code&gt; sets the storage order of the scalar fields to big-endian.</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order big-endian&lt;/code&gt; устанавливает порядок хранения скалярных полей как big-endian.</target>
        </trans-unit>
        <trans-unit id="791d1af4df580d4926f6784307622e913fe6169f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order default&lt;/code&gt; goes back to the endianness that was in effect when compilation started (see also command-line option</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order default&lt;/code&gt; возвращается к порядку байтов, который был в силе при запуске компиляции (см. также параметр командной строки</target>
        </trans-unit>
        <trans-unit id="9e92ce5f2b8e8dd2da4f3a23c57c175f27849093" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order little-endian&lt;/code&gt; sets the storage order of the scalar fields to little-endian.</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order little-endian&lt;/code&gt; устанавливает порядок хранения скалярных полей как little-endian.</target>
        </trans-unit>
        <trans-unit id="d7b3947b00665c0273f8ee03de6b46c48b82e923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+load&lt;/code&gt; is to be used only as a last resort. Because it is executed very early, most of the Objective-C runtime machinery will not be ready when &lt;code&gt;+load&lt;/code&gt; is executed; hence &lt;code&gt;+load&lt;/code&gt; works best for executing C code that is independent on the Objective-C runtime.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; должна использоваться только в крайнем случае. Поскольку он выполняется очень рано, большая часть исполняющего механизма Objective-C не будет готова при выполнении &lt;code&gt;+load&lt;/code&gt; ; следовательно, &lt;code&gt;+load&lt;/code&gt; лучше всего подходит для выполнения кода C, который не зависит от среды выполнения Objective-C.</target>
        </trans-unit>
        <trans-unit id="2a3b66c50c6331da3456637374283bba0d9341b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-2147483648&lt;/code&gt; is positive.</source>
          <target state="translated">&lt;code&gt;-2147483648&lt;/code&gt; положительный.</target>
        </trans-unit>
        <trans-unit id="ff73f3bc9136cfe683f6e1000d6ea1e5f0b6d324" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0xFF&lt;/code&gt; or &lt;code&gt;0xFFFF&lt;/code&gt;, for andsi as a zero-extending move.</source>
          <target state="translated">&lt;code&gt;0xFF&lt;/code&gt; или &lt;code&gt;0xFFFF&lt;/code&gt; для andsi как ход с нулевым продолжением.</target>
        </trans-unit>
        <trans-unit id="69970b695b65687a239461624104cc1d44b36e13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;100&lt;/code&gt;, &lt;code&gt;102&lt;/code&gt;, &lt;code&gt;103&lt;/code&gt;, &lt;code&gt;104&lt;/code&gt;, &lt;code&gt;105&lt;/code&gt;, &lt;code&gt;106&lt;/code&gt;, &lt;code&gt;107&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;100&lt;/code&gt; , &lt;code&gt;102&lt;/code&gt; , &lt;code&gt;103&lt;/code&gt; , &lt;code&gt;104&lt;/code&gt; , &lt;code&gt;105&lt;/code&gt; , &lt;code&gt;106&lt;/code&gt; , &lt;code&gt;107&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f94cae98ac3d64f04d19f0b2e99e2c0a60564f25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2&lt;/code&gt;, &lt;code&gt;25&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;31&lt;/code&gt;, &lt;code&gt;35&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;51&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;2&lt;/code&gt; , &lt;code&gt;25&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; , &lt;code&gt;31&lt;/code&gt; , &lt;code&gt;35&lt;/code&gt; , &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;5&lt;/code&gt; , &lt;code&gt;51&lt;/code&gt; , &lt;code&gt;6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bd49a42c06dc5b5614602b595d1eb861097847b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;collection expression&lt;/var&gt;&lt;/code&gt; is evaluated exactly once and the result is used as the collection object to iterate over. This means it is safe to write code such as &lt;code&gt;for (object in [NSDictionary
keyEnumerator]) &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;collection expression&lt;/var&gt;&lt;/code&gt; вычисляется ровно один раз, и результат используется как объект коллекции для перебора. Это означает, что можно безопасно писать код, например, &lt;code&gt;for (object in [NSDictionary keyEnumerator]) &amp;hellip;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eba358d191709438321ae5dbb3501eb47389e2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; can contain &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; commands, which will abort the iteration or skip to the next loop iteration as expected.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; могут содержать команды &lt;code&gt;break&lt;/code&gt; и &lt;code&gt;continue&lt;/code&gt; , которые прерывают итерацию или переходят к следующей итерации цикла, как ожидалось.</target>
        </trans-unit>
        <trans-unit id="61531b33eb2db1449ceab15f5f279c4b2f1791b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; must not make any changes to the collection object; if they do, it is a hard error and the fast enumeration terminates by invoking &lt;code&gt;objc_enumerationMutation&lt;/code&gt;, a runtime function that normally aborts the program but which can be customized by Foundation libraries via &lt;code&gt;objc_set_mutation_handler&lt;/code&gt; to do something different, such as raising an exception.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; не должны вносить никаких изменений в объект коллекции; если они это сделают, это &lt;code&gt;objc_enumerationMutation&lt;/code&gt; ошибка, и быстрое перечисление завершается вызовом objc_enumerationMutation , функции времени выполнения, которая обычно прерывает программу, но которая может быть настроена библиотеками Foundation через &lt;code&gt;objc_set_mutation_handler&lt;/code&gt; , чтобы сделать что-то другое, например, вызвать исключение.</target>
        </trans-unit>
        <trans-unit id="9d58742173ee42448629f6db4422e3203e474e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@encode&lt;/code&gt; does not support type qualifiers other than &lt;code&gt;const&lt;/code&gt;. For example, &lt;code&gt;@encode(const char*)&lt;/code&gt; is valid and is compiled into &lt;code&gt;&quot;r*&quot;&lt;/code&gt;, while &lt;code&gt;@encode(bycopy char *)&lt;/code&gt; is invalid and will cause a compilation error.</source>
          <target state="translated">&lt;code&gt;@encode&lt;/code&gt; не поддерживает квалификаторы типов, кроме &lt;code&gt;const&lt;/code&gt; . Например, &lt;code&gt;@encode(const char*)&lt;/code&gt; допустим и компилируется в &lt;code&gt;&quot;r*&quot;&lt;/code&gt; , а &lt;code&gt;@encode(bycopy char *)&lt;/code&gt; недопустим и вызовет ошибку компиляции.</target>
        </trans-unit>
        <trans-unit id="06f7d071955d8af36c31b170590dbc2a8f025b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A&lt;/code&gt; through &lt;code&gt;L&lt;/code&gt; registers.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; Регистры от A до &lt;code&gt;L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80d0c9344feef2e94b4f1747dfadf5bbe5585ef0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CPATH&lt;/code&gt; specifies a list of directories to be searched as if specified with</source>
          <target state="translated">&lt;code&gt;CPATH&lt;/code&gt; указывает список каталогов для поиска, как если бы он был указан с помощью</target>
        </trans-unit>
        <trans-unit id="789e53d1b037b549885585694fb4b6c06a41dc94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GSWApplication&lt;/code&gt; (the real class) must be an existing class.</source>
          <target state="translated">&lt;code&gt;GSWApplication&lt;/code&gt; (настоящий класс) должен быть существующим классом.</target>
        </trans-unit>
        <trans-unit id="372485e67dabbb2f6f7563c915c0d05a5bb7796c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NXConstantString&lt;/code&gt; inherits from &lt;code&gt;Object&lt;/code&gt;; user class libraries may choose to inherit the customized constant string class from a different class than &lt;code&gt;Object&lt;/code&gt;. There is no requirement in the methods the constant string class has to implement, but the final ivar layout of the class must be the compatible with the given structure.</source>
          <target state="translated">&lt;code&gt;NXConstantString&lt;/code&gt; наследуется от &lt;code&gt;Object&lt;/code&gt; ; Библиотеки пользовательских классов могут выбрать наследование настроенного класса постоянной строки от другого класса, чем &lt;code&gt;Object&lt;/code&gt; . Нет требований к методам, которые должен реализовывать класс константной строки, но окончательная структура ivar класса должна быть совместимой с данной структурой.</target>
        </trans-unit>
        <trans-unit id="b73742c69a964b14887fe5c58b748cbc6ead8dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;V&lt;/code&gt; is a special modifier which prints the name of the full integer register without &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; - специальный модификатор, который печатает имя полного целочисленного регистра без &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9680743302272f4d21a0ca0fcf6f7d2fc4b4f89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WOApplication&lt;/code&gt; (the alias) must not be an existing class;</source>
          <target state="translated">&lt;code&gt;WOApplication&lt;/code&gt; (псевдоним) не должен быть существующим классом;</target>
        </trans-unit>
        <trans-unit id="ee6195175737171e4b0021bc7dc79c772162ab99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FUNCTION__&lt;/code&gt; is another name for &lt;code&gt;__func__&lt;/code&gt;, provided for backward compatibility with old versions of GCC.</source>
          <target state="translated">&lt;code&gt;__FUNCTION__&lt;/code&gt; - другое имя для &lt;code&gt;__func__&lt;/code&gt; , предоставленное для обратной совместимости со старыми версиями GCC.</target>
        </trans-unit>
        <trans-unit id="f2c1ea03a8f41c269c203f97859a30953067ac6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__attribute ((const))&lt;/code&gt; and &lt;code&gt;noreturn&lt;/code&gt; were mangled as type qualifiers, and &lt;code&gt;decltype&lt;/code&gt; of a plain declaration was folded away.</source>
          <target state="translated">&lt;code&gt;__attribute ((const))&lt;/code&gt; и &lt;code&gt;noreturn&lt;/code&gt; были искажены как квалификаторы типа, а &lt;code&gt;decltype&lt;/code&gt; простого объявления был свернут.</target>
        </trans-unit>
        <trans-unit id="31d52aa69bfef9deeeff9d7920e4c48f0f233481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__builtin_mips_set_fcsr&lt;/code&gt; can be used to change any bit of the register except the condition codes, which GCC assumes are preserved.</source>
          <target state="translated">&lt;code&gt;__builtin_mips_set_fcsr&lt;/code&gt; может использоваться для изменения любого бита регистра, кроме кодов условий, которые, как предполагает GCC, сохранены.</target>
        </trans-unit>
        <trans-unit id="dd0179ef987e379ce17d15225812657b396c054c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__const__&lt;/code&gt;, &lt;code&gt;__asm__&lt;/code&gt;, etc., for header files.</source>
          <target state="translated">&lt;code&gt;__const__&lt;/code&gt; , &lt;code&gt;__asm__&lt;/code&gt; и т. д. для файлов заголовков.</target>
        </trans-unit>
        <trans-unit id="7473df93d6fe52ceeeb6718adea22f662c95bc6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__float128&lt;/code&gt; is available on i386, x86_64, IA-64, and hppa HP-UX, as well as on PowerPC GNU/Linux targets that enable the vector scalar (VSX) instruction set. &lt;code&gt;__float128&lt;/code&gt; supports the 128-bit floating type. On i386, x86_64, PowerPC, and IA-64 other than HP-UX, &lt;code&gt;__float128&lt;/code&gt; is an alias for &lt;code&gt;_Float128&lt;/code&gt;. On hppa and IA-64 HP-UX, &lt;code&gt;__float128&lt;/code&gt; is an alias for &lt;code&gt;long
double&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__float128&lt;/code&gt; доступен в i386, x86_64, IA-64 и hppa HP-UX, а также в целях PowerPC GNU / Linux, которые включают набор команд векторного скаляра (VSX). &lt;code&gt;__float128&lt;/code&gt; поддерживает 128-битный плавающий тип. В i386, x86_64, PowerPC и IA-64, кроме HP-UX, &lt;code&gt;__float128&lt;/code&gt; является псевдонимом для &lt;code&gt;_Float128&lt;/code&gt; . В hppa и IA-64 HP-UX &lt;code&gt;__float128&lt;/code&gt; - это псевдоним для &lt;code&gt;long double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffb2bf9a670bef293cfa77a116c8f843376e5401" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__float80&lt;/code&gt; is available on the i386, x86_64, and IA-64 targets, and supports the 80-bit (&lt;code&gt;XFmode&lt;/code&gt;) floating type. It is an alias for the type name &lt;code&gt;_Float64x&lt;/code&gt; on these targets.</source>
          <target state="translated">&lt;code&gt;__float80&lt;/code&gt; доступен для целей i386, x86_64 и IA-64 и поддерживает 80-битный ( &lt;code&gt;XFmode&lt;/code&gt; ) плавающий тип. Это псевдоним для имени типа &lt;code&gt;_Float64x&lt;/code&gt; для этих целей.</target>
        </trans-unit>
        <trans-unit id="7ec6ed15db3de1e0e785dbadf3953c59dadef3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__ibm128&lt;/code&gt; is available on PowerPC targets, and provides access to the IBM extended double format which is the current format used for &lt;code&gt;long double&lt;/code&gt;. When &lt;code&gt;long double&lt;/code&gt; transitions to &lt;code&gt;__float128&lt;/code&gt; on PowerPC in the future, &lt;code&gt;__ibm128&lt;/code&gt; will remain for use in conversions between the two types.</source>
          <target state="translated">&lt;code&gt;__ibm128&lt;/code&gt; доступен для целей PowerPC и обеспечивает доступ к расширенному двойному формату IBM, который является текущим форматом, используемым для &lt;code&gt;long double&lt;/code&gt; . Когда в будущем при &lt;code&gt;long double&lt;/code&gt; переходе на &lt;code&gt;__float128&lt;/code&gt; на PowerPC, &lt;code&gt;__ibm128&lt;/code&gt; останется для использования в преобразованиях между двумя типами.</target>
        </trans-unit>
        <trans-unit id="9e3a9ed7baa3bf65df3ff05f513613983a9587ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;acc&lt;/code&gt; arguments are evaluated at compile time and specify the number of an accumulator register. For example, an &lt;code&gt;acc&lt;/code&gt; argument of 2 selects the ACC2 register.</source>
          <target state="translated">&lt;code&gt;acc&lt;/code&gt; Аргументы acc оцениваются во время компиляции и определяют номер регистра аккумулятора. Например, аргумент &lt;code&gt;acc&lt;/code&gt; , равный 2, выбирает регистр ACC2.</target>
        </trans-unit>
        <trans-unit id="15fdbd93cf947c8849cb1d5a35f4090a626ff637" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array&lt;/code&gt; needs to be an Objective-C object (usually a collection object, for example an array, a dictionary or a set) which implements the &amp;ldquo;Fast Enumeration Protocol&amp;rdquo; (see below). If you are using a Foundation library such as GNUstep Base or Apple Cocoa Foundation, all collection objects in the library implement this protocol and can be used in this way.</source>
          <target state="translated">&lt;code&gt;array&lt;/code&gt; должен быть объектом Objective-C (обычно объектом коллекции, например массивом, словарем или набором), который реализует &amp;laquo;Протокол быстрого перечисления&amp;raquo; (см. ниже). Если вы используете библиотеку Foundation, такую ​​как GNUstep Base или Apple Cocoa Foundation, все объекты коллекции в библиотеке реализуют этот протокол и могут использоваться таким образом.</target>
        </trans-unit>
        <trans-unit id="426e3d34f5d2b8cc641dc2d655c2412b3ba31507" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm goto&lt;/code&gt; allows assembly code to jump to one or more C labels. The &lt;var&gt;GotoLabels&lt;/var&gt; section in an &lt;code&gt;asm goto&lt;/code&gt; statement contains a comma-separated list of all C labels to which the assembler code may jump. GCC assumes that &lt;code&gt;asm&lt;/code&gt; execution falls through to the next statement (if this is not the case, consider using the &lt;code&gt;__builtin_unreachable&lt;/code&gt; intrinsic after the &lt;code&gt;asm&lt;/code&gt; statement). Optimization of &lt;code&gt;asm goto&lt;/code&gt; may be improved by using the &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt; label attributes (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;asm goto&lt;/code&gt; позволяет ассемблерному коду переходить к одной или нескольким меткам C. Раздел &lt;var&gt;GotoLabels&lt;/var&gt; в &lt;code&gt;asm goto&lt;/code&gt; содержит разделенный запятыми список всех меток C, к которым может перейти код ассемблера. GCC предполагает, что выполнение &lt;code&gt;asm&lt;/code&gt; переходит к следующему оператору (если это не так, рассмотрите возможность использования встроенного &lt;code&gt;__builtin_unreachable&lt;/code&gt; после оператора &lt;code&gt;asm&lt;/code&gt; ). Оптимизацию &lt;code&gt;asm goto&lt;/code&gt; можно улучшить, используя атрибуты &lt;code&gt;hot&lt;/code&gt; и &lt;code&gt;cold&lt;/code&gt; метки (см. &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Атрибуты метки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c9823fe22f97e1ec190b250dc2a2fdf94a1ee857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; statements may not perform jumps into other &lt;code&gt;asm&lt;/code&gt; statements, only to the listed &lt;var&gt;GotoLabels&lt;/var&gt;. GCC&amp;rsquo;s optimizers do not know about other jumps; therefore they cannot take account of them when deciding how to optimize.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; Операторы asm не могут выполнять переходы к другим операторам &lt;code&gt;asm&lt;/code&gt; , только к перечисленным &lt;var&gt;GotoLabels&lt;/var&gt; . Оптимизаторы GCC не знают о других переходах; поэтому они не могут учитывать их при принятии решения по оптимизации.</target>
        </trans-unit>
        <trans-unit id="62977bb50d3c5a19ea5904a3a299ffd7ea5dbd29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; statements may not perform jumps into other &lt;code&gt;asm&lt;/code&gt; statements. GCC does not know about these jumps, and therefore cannot take account of them when deciding how to optimize. Jumps from &lt;code&gt;asm&lt;/code&gt; to C labels are only supported in extended &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; Операторы asm не могут выполнять переходы в другие операторы &lt;code&gt;asm&lt;/code&gt; . GCC не знает об этих скачках и поэтому не может их учитывать при принятии решения по оптимизации. Переходы с меток &lt;code&gt;asm&lt;/code&gt; на C поддерживаются только в расширенном &lt;code&gt;asm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9448d646265094e46fad56b4a1ad54b2c75f890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; supports operand modifiers on operands (for example &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; поддерживает модификаторы операндов для операндов (например, '</target>
        </trans-unit>
        <trans-unit id="47c475345b4b6683f86ef0bd1304fa403571227e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; followed by the starting position of the bit-field, the type of the bit-field and the size of the bit-field (the bit-fields encoding was changed from the NeXT&amp;rsquo;s compiler encoding, see below)</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; , за которым следует начальная позиция битового поля, тип битового поля и размер битового поля (кодировка битовых полей была изменена по сравнению с кодировкой компилятора NeXT, см. ниже)</target>
        </trans-unit>
        <trans-unit id="fd931d3282f78cf10b6e109fc3d87523a40b1c70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int*&lt;/code&gt; is a pointer to a &lt;code&gt;const int&lt;/code&gt;, and so is encoded as &lt;code&gt;^ri&lt;/code&gt;. &lt;code&gt;int* const&lt;/code&gt;, instead, is a &lt;code&gt;const&lt;/code&gt; pointer to an &lt;code&gt;int&lt;/code&gt;, and so is encoded as &lt;code&gt;r^i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const int*&lt;/code&gt; - указатель на &lt;code&gt;const int&lt;/code&gt; , поэтому кодируется как &lt;code&gt;^ri&lt;/code&gt; . &lt;code&gt;int* const&lt;/code&gt; , напротив, является &lt;code&gt;const&lt;/code&gt; указателем на &lt;code&gt;int&lt;/code&gt; , поэтому кодируется как &lt;code&gt;r^i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc303077f2d42536c4b3baafc5729fd35626b25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; arguments represent immediate operands in the underlying FR-V instructions. They must be compile-time constants.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; Аргументы const представляют непосредственные операнды в базовых инструкциях FR-V. Они должны быть константами времени компиляции.</target>
        </trans-unit>
        <trans-unit id="deb6088d1e3cb9956bb32715c4b9b0433c0fb80e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype(nullptr)&lt;/code&gt; incorrectly had an alignment of 1, leading to unaligned accesses. Note that this did not affect the ABI of a function with a &lt;code&gt;nullptr_t&lt;/code&gt; parameter, as parameters have a minimum alignment.</source>
          <target state="translated">&lt;code&gt;decltype(nullptr)&lt;/code&gt; неправильно имеет выравнивание 1, что приводит к невыровненным доступам. Обратите внимание, что это не повлияло на ABI функции с параметром &lt;code&gt;nullptr_t&lt;/code&gt; , поскольку параметры имеют минимальное выравнивание.</target>
        </trans-unit>
        <trans-unit id="13371da4b8a0998cda9c846517eca9aac42602d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum foo;&lt;/code&gt;, with details to follow.</source>
          <target state="translated">&lt;code&gt;enum foo;&lt;/code&gt; , с подробностями, чтобы следовать.</target>
        </trans-unit>
        <trans-unit id="9e91e48e9653d7d4d932a05bfbd83b09588c7939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;s are always encoded as &amp;rsquo;i&amp;rsquo; (int) even if they are actually unsigned or long.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; всегда кодируются как 'i' (int), даже если они на самом деле беззнаковые или длинные.</target>
        </trans-unit>
        <trans-unit id="9a12395e61d19efb5c294812d6196468603d44b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt; declarations are not affected by</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; объявления extern не влияют</target>
        </trans-unit>
        <trans-unit id="4b6de559d80875c4a2043040ec9b3a928c196dad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; для типа возвращаемого значения и типа параметра</target>
        </trans-unit>
        <trans-unit id="43f52ce2765906e82519d10c80ebb890c471c9d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcc&lt;/code&gt; is a driver program. It performs its job by invoking a sequence of other programs to do the work of compiling, assembling and linking. GCC interprets its command-line parameters and uses these to deduce which programs it should invoke, and which command-line options it ought to place on their command lines. This behavior is controlled by &lt;em&gt;spec strings&lt;/em&gt;. In most cases there is one spec string for each program that GCC can invoke, but a few programs have multiple spec strings to control their behavior. The spec strings built into GCC can be overridden by using the</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; - это программа-драйвер. Он выполняет свою работу, вызывая последовательность других программ для выполнения работы по компиляции, сборке и компоновке. GCC интерпретирует свои параметры командной строки и использует их, чтобы определить, какие программы следует вызывать и какие параметры командной строки следует разместить в своих командных строках. Это поведение контролируется &lt;em&gt;строками спецификации&lt;/em&gt; . В большинстве случаев существует одна строка спецификации для каждой программы, которую может вызывать GCC, но некоторые программы имеют несколько строк спецификации для управления их поведением. Строки спецификации, встроенные в GCC, могут быть переопределены с помощью</target>
        </trans-unit>
        <trans-unit id="78e0e9f2c419ee9f240f0845bc755717d55d3a97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; принимает следующие параметры:</target>
        </trans-unit>
        <trans-unit id="57d6fe4b10a5a2126cbfcec6595777a79798d69e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt; is a tool you can use in conjunction with GCC to dump content of gcda and gcno profile files offline.</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; - это инструмент, который вы можете использовать вместе с GCC для дампа содержимого файлов профиля gcda и gcno в автономном режиме.</target>
        </trans-unit>
        <trans-unit id="2878b99530b4f0ab8508c0886d2f8099475e075b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt;&amp;mdash;an offline gcda and gcno profile dump tool.</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; - автономный инструмент создания дампа профиля gcda и gcno.</target>
        </trans-unit>
        <trans-unit id="8557e16ee11b3bb8a6161e3b196a98d4d9ef3676" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; принимает следующие параметры:</target>
        </trans-unit>
        <trans-unit id="834e3a72a863342de668198a9b180e31689bb9fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; is a tool you can use in conjunction with GCC to manipulate or process gcda profile files offline.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; - это инструмент, который вы можете использовать вместе с GCC для управления или обработки файлов профиля gcda в автономном режиме.</target>
        </trans-unit>
        <trans-unit id="8966e78c51b409536bc0ea171add9c067eaae6cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; is an offline tool to process gcc&amp;rsquo;s gcda profile files.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; - это автономный инструмент для обработки файлов профиля gcc gcda.</target>
        </trans-unit>
        <trans-unit id="70183d08ebe3785a624a3a0d2f54f5da4fcf92c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt;&amp;mdash;an offline gcda profile processing program.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; - автономная программа обработки профиля gcda.</target>
        </trans-unit>
        <trans-unit id="432fd55f9f3348b69e564e9e68b9ac68338b2330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; принимает следующие варианты:</target>
        </trans-unit>
        <trans-unit id="ef7fa5c92c81ba37950cfb7081e034b38df44ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; creates a logfile called</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; создает файл журнала с именем</target>
        </trans-unit>
        <trans-unit id="fa86b3b9c4851aca0143ed5eebf12b37ac982caa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; is a test coverage program. Use it in concert with GCC to analyze your programs to help create more efficient, faster running code and to discover untested parts of your program. You can use &lt;code&gt;gcov&lt;/code&gt; as a profiling tool to help discover where your optimization efforts will best affect your code. You can also use &lt;code&gt;gcov&lt;/code&gt; along with the other profiling tool, &lt;code&gt;gprof&lt;/code&gt;, to assess which parts of your code use the greatest amount of computing time.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; - это программа тестового покрытия. Используйте его вместе с GCC для анализа ваших программ, чтобы помочь создать более эффективный, более быстрый код и обнаружить непроверенные части вашей программы. Вы можете использовать &lt;code&gt;gcov&lt;/code&gt; в качестве инструмента профилирования, чтобы определить, где ваши усилия по оптимизации лучше всего повлияют на ваш код. Вы также можете использовать &lt;code&gt;gcov&lt;/code&gt; вместе с другим инструментом профилирования, &lt;code&gt;gprof&lt;/code&gt; , чтобы оценить, какие части вашего кода используют наибольшее количество вычислительного времени.</target>
        </trans-unit>
        <trans-unit id="ec4c7d87db361b8b7217252e79155f330d87180c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; is a tool you can use in conjunction with GCC to test code coverage in your programs.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; - это инструмент, который вы можете использовать вместе с GCC для тестирования покрытия кода в ваших программах.</target>
        </trans-unit>
        <trans-unit id="74c1eaafeae6a0c3622569a9b97608b21c035122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; should be run with the current directory the same as that when you invoked the compiler. Otherwise it will not be able to locate the source files. &lt;code&gt;gcov&lt;/code&gt; produces files called</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; должен запускаться с текущим каталогом, таким же, как при вызове компилятора. В противном случае он не сможет найти исходные файлы. &lt;code&gt;gcov&lt;/code&gt; создает файлы, называемые</target>
        </trans-unit>
        <trans-unit id="54f992c071dcdc4cf317b5dc2c2e8150dab3baed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; uses two files for profiling. The names of these files are derived from the original &lt;em&gt;object&lt;/em&gt; file by substituting the file suffix with either</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; использует два файла для профилирования. Имена этих файлов являются производными от исходного &lt;em&gt;объектного&lt;/em&gt; файла путем замены суффикса файла на</target>
        </trans-unit>
        <trans-unit id="e0e281a8c455e080b9c9615f521b0af9f3afc81d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; works only on code compiled with GCC. It is not compatible with any other profiling or test coverage mechanism.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; работает только с кодом, скомпилированным с помощью GCC. Он несовместим с другими механизмами профилирования или тестового покрытия.</target>
        </trans-unit>
        <trans-unit id="e18b2104276bf04773cc9483f7f381c6d995630f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt;&amp;mdash;a test coverage program.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; - программа тестового покрытия.</target>
        </trans-unit>
        <trans-unit id="0adbd472f7e4a6a8700ee625ca50b5065e7189f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i32, i64, u32, u64, f32, f64&lt;/code&gt;, defined as follows:</source>
          <target state="translated">&lt;code&gt;i32, i64, u32, u64, f32, f64&lt;/code&gt; , определенные следующим образом:</target>
        </trans-unit>
        <trans-unit id="c651bda5c1e10d455f6b6c7f62a6f71255f9e521" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iacc&lt;/code&gt; arguments are similar to &lt;code&gt;acc&lt;/code&gt; arguments but specify the number of an IACC register. See see &lt;a href=&quot;other-built_002din-functions#Other-Built_002din-Functions&quot;&gt;Other Built-in Functions&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;iacc&lt;/code&gt; Аргументы iacc аналогичны аргументам &lt;code&gt;acc&lt;/code&gt; , но определяют номер регистра IACC. См. Дополнительные сведения в разделе &amp;laquo; &lt;a href=&quot;other-built_002din-functions#Other-Built_002din-Functions&quot;&gt;Другие встроенные функции&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf79502e7b46209589262e2429120814cbb13c52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_15&lt;/code&gt;, an integer literal in range 0 to 15;</source>
          <target state="translated">&lt;code&gt;imm0_15&lt;/code&gt; , целочисленный литерал в диапазоне от 0 до 15;</target>
        </trans-unit>
        <trans-unit id="ccc2033cd80d019d5fd83cb192150729b7904cf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_1&lt;/code&gt;, an integer literal in range 0 to 1;</source>
          <target state="translated">&lt;code&gt;imm0_1&lt;/code&gt; , целочисленный литерал в диапазоне от 0 до 1;</target>
        </trans-unit>
        <trans-unit id="f624a59ec5d313a1c0a203fc5cdfd4a3666bdad5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_255&lt;/code&gt;, an integer literal in range 0 to 255;</source>
          <target state="translated">&lt;code&gt;imm0_255&lt;/code&gt; , целочисленный литерал в диапазоне от 0 до 255;</target>
        </trans-unit>
        <trans-unit id="45c72131be83eef97ea9ee3eff2a0bdba7519f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_31&lt;/code&gt;, an integer literal in range 0 to 31;</source>
          <target state="translated">&lt;code&gt;imm0_31&lt;/code&gt; , целочисленный литерал в диапазоне от 0 до 31;</target>
        </trans-unit>
        <trans-unit id="cde4836239d0583916a4b3f7436c408e99e7f181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_3&lt;/code&gt;, an integer literal in range 0 to 3;</source>
          <target state="translated">&lt;code&gt;imm0_3&lt;/code&gt; , целочисленный литерал в диапазоне от 0 до 3;</target>
        </trans-unit>
        <trans-unit id="51e823a1bbc6ba2a324f7474f9da47e3b2690272" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_63&lt;/code&gt;, an integer literal in range 0 to 63;</source>
          <target state="translated">&lt;code&gt;imm0_63&lt;/code&gt; , целочисленный литерал в диапазоне от 0 до 63;</target>
        </trans-unit>
        <trans-unit id="62f6834f1b1628360d13102cd8355d1bff98dfb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_7&lt;/code&gt;, an integer literal in range 0 to 7;</source>
          <target state="translated">&lt;code&gt;imm0_7&lt;/code&gt; , целочисленный литерал в диапазоне от 0 до 7;</target>
        </trans-unit>
        <trans-unit id="06869e0d4af1794473183f20d27a91d5c322515b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm1_4&lt;/code&gt;, an integer literal in range 1 to 4;</source>
          <target state="translated">&lt;code&gt;imm1_4&lt;/code&gt; , целочисленный литерал в диапазоне от 1 до 4;</target>
        </trans-unit>
        <trans-unit id="26b8f3ccab339df690ac564365568e69734e0e95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n1024_1022&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 1 bit, i.e., -1024, -1022, &amp;hellip;, 1020, 1022;</source>
          <target state="translated">&lt;code&gt;imm_n1024_1022&lt;/code&gt; , целочисленный литерал в диапазоне от -512 до 511, сдвинутый влево на 1 бит, т.е. -1024, -1022,&amp;hellip;, 1020, 1022;</target>
        </trans-unit>
        <trans-unit id="53f347dd23c9ce86f4bf63425a73319aeca2e71a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n16_15&lt;/code&gt;, an integer literal in range -16 to 15;</source>
          <target state="translated">&lt;code&gt;imm_n16_15&lt;/code&gt; , целочисленный литерал в диапазоне от -16 до 15;</target>
        </trans-unit>
        <trans-unit id="c764a9f154679364bdd3af401c15760d950c39d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n2048_2044&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 2 bits, i.e., -2048, -2044, &amp;hellip;, 2040, 2044;</source>
          <target state="translated">&lt;code&gt;imm_n2048_2044&lt;/code&gt; , целочисленный литерал в диапазоне от -512 до 511, сдвинутый влево на 2 бита, т. е. -2048, -2044,&amp;hellip;, 2040, 2044;</target>
        </trans-unit>
        <trans-unit id="d8621ae125b08b357812594db312fcdb8bd2e201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n4096_4088&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 3 bits, i.e., -4096, -4088, &amp;hellip;, 4080, 4088;</source>
          <target state="translated">&lt;code&gt;imm_n4096_4088&lt;/code&gt; , целочисленный литерал в диапазоне от -512 до 511, сдвинутый влево на 3 бита, т. е. -4096, -4088,&amp;hellip;, 4080, 4088;</target>
        </trans-unit>
        <trans-unit id="43bcd7d1a4a29ac9e7f1c73f1912ac48e5ce1624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n512_511&lt;/code&gt;, an integer literal in range -512 to 511;</source>
          <target state="translated">&lt;code&gt;imm_n512_511&lt;/code&gt; , целочисленный литерал в диапазоне от -512 до 511;</target>
        </trans-unit>
        <trans-unit id="f04c7ff5dca47e97ec5511198b36d3aa9615e32d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int16x4_t&lt;/code&gt;, a vector of four signed 16-bit integers;</source>
          <target state="translated">&lt;code&gt;int16x4_t&lt;/code&gt; , вектор из четырех 16-разрядных целых чисел со знаком ;</target>
        </trans-unit>
        <trans-unit id="d63e9df03ecc48a8a23928c599b1004cd533f6d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int32x2_t&lt;/code&gt;, a vector of two signed 32-bit integers.</source>
          <target state="translated">&lt;code&gt;int32x2_t&lt;/code&gt; , вектор из двух 32-битных целых чисел со знаком .</target>
        </trans-unit>
        <trans-unit id="91184ef12147d2f6b1bdaa56fe5d9583a6f4e83a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int8x8_t&lt;/code&gt;, a vector of eight signed 8-bit integers;</source>
          <target state="translated">&lt;code&gt;int8x8_t&lt;/code&gt; , вектор из восьми 8-битных целых чисел со знаком ;</target>
        </trans-unit>
        <trans-unit id="9a7265111af471ce530480c106de4c972fb277fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; для типа возвращаемого значения и типа параметра</target>
        </trans-unit>
        <trans-unit id="3e0d50378937884eeb028aecd3fcc684e4a49b74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;j&lt;/code&gt; followed by the inner type. For example &lt;code&gt;_Complex double&lt;/code&gt; is encoded as &quot;jd&quot;.</source>
          <target state="translated">&lt;code&gt;j&lt;/code&gt; , за которым следует внутренний тип. Например, &lt;code&gt;_Complex double&lt;/code&gt; кодируется как &quot;jd&quot;.</target>
        </trans-unit>
        <trans-unit id="0871af21d28c83f64c804091ade1492e9664c30b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt; accepts the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8422e33957287d90215f0f4f8087a0305f1d44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt; is a tool you can use in conjunction with GCC to dump link time optimization object files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51997ac3a8fdd69732aefc35a59335c494052e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt;&amp;mdash;Tool for dumping LTO object files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f711a37cb98098d461731b92b78a9d7c2b5ec6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;movn.ps&lt;/code&gt;/&lt;code&gt;movz.ps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;movn.ps&lt;/code&gt;/&lt;code&gt;movz.ps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb1626a9beed4fd0495f07220bec199cc6d6bd0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naked&lt;/code&gt; functions do not have a return instruction whereas &lt;code&gt;OS_main&lt;/code&gt; and &lt;code&gt;OS_task&lt;/code&gt; functions have a &lt;code&gt;RET&lt;/code&gt; or &lt;code&gt;RETI&lt;/code&gt; return instruction.</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; функции не имеют инструкции возврата, тогда как функции &lt;code&gt;OS_main&lt;/code&gt; и &lt;code&gt;OS_task&lt;/code&gt; имеют инструкцию возврата &lt;code&gt;RET&lt;/code&gt; или &lt;code&gt;RETI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f91f91e06fe6fe3ed6698c6a7170097cb9c11482" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naked&lt;/code&gt; functions do not set up a frame for local variables or a frame pointer whereas &lt;code&gt;OS_main&lt;/code&gt; and &lt;code&gt;OS_task&lt;/code&gt; do this as needed.</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; функции не устанавливают фрейм для локальных переменных или указателя фрейма, тогда как &lt;code&gt;OS_main&lt;/code&gt; и &lt;code&gt;OS_task&lt;/code&gt; делают это по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="e1ec8966dbb2d024c34ce202400922786b20bf42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q31&lt;/code&gt; and &lt;code&gt;i32&lt;/code&gt; are actually the same as &lt;code&gt;int&lt;/code&gt;, but we use &lt;code&gt;q31&lt;/code&gt; to indicate a Q31 fractional value and &lt;code&gt;i32&lt;/code&gt; to indicate a 32-bit integer value. Similarly, &lt;code&gt;a64&lt;/code&gt; is the same as &lt;code&gt;long long&lt;/code&gt;, but we use &lt;code&gt;a64&lt;/code&gt; to indicate values that are placed in one of the four DSP accumulators (&lt;code&gt;$ac0&lt;/code&gt;, &lt;code&gt;$ac1&lt;/code&gt;, &lt;code&gt;$ac2&lt;/code&gt; or &lt;code&gt;$ac3&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;q31&lt;/code&gt; и &lt;code&gt;i32&lt;/code&gt; на самом деле такие же, как &lt;code&gt;int&lt;/code&gt; , но мы используем &lt;code&gt;q31&lt;/code&gt; для обозначения дробного значения &lt;code&gt;i32&lt;/code&gt; и i32 для обозначения 32-битного целого числа. Аналогично, &lt;code&gt;a64&lt;/code&gt; - то же самое, что и &lt;code&gt;long long&lt;/code&gt; , но мы используем &lt;code&gt;a64&lt;/code&gt; для обозначения значений, которые помещаются в один из четырех аккумуляторов DSP ( &lt;code&gt;$ac0&lt;/code&gt; , &lt;code&gt;$ac1&lt;/code&gt; , &lt;code&gt;$ac2&lt;/code&gt; или &lt;code&gt;$ac3&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ea0054c5fec474c155dbd98ae3adc8592ccc0ad9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strict-align&lt;/code&gt; indicates that the compiler should not assume that unaligned memory references are handled by the system. To allow the compiler to assume that aligned memory references are handled by the system, the inverse attribute &lt;code&gt;no-strict-align&lt;/code&gt; can be specified. The behavior is same as for the command-line option</source>
          <target state="translated">&lt;code&gt;strict-align&lt;/code&gt; указывает, что компилятор не должен предполагать, что невыровненные ссылки на память обрабатываются системой. Чтобы компилятор мог предположить, что выровненные ссылки на память обрабатываются системой, можно указать обратный атрибут &lt;code&gt;no-strict-align&lt;/code&gt; . Поведение такое же, как и для параметра командной строки.</target>
        </trans-unit>
        <trans-unit id="0ce41d50092061190708b7c5fd578471925d484e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tbegin&lt;/code&gt; has been executed as part of normal processing. The transaction body is supposed to be executed.</source>
          <target state="translated">&lt;code&gt;tbegin&lt;/code&gt; был выполнен как часть обычной обработки. Предполагается, что тело транзакции будет выполнено.</target>
        </trans-unit>
        <trans-unit id="90a2359fdefeabe506da21e5ceeb1ec6dfb149dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type_info&lt;/code&gt; objects</source>
          <target state="translated">&lt;code&gt;type_info&lt;/code&gt; объекты type_info</target>
        </trans-unit>
        <trans-unit id="972569711d57266ec65a8196096540c87f973793" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; is often useful in conjunction with statement expressions (see &lt;a href=&quot;statement-exprs#Statement-Exprs&quot;&gt;Statement Exprs&lt;/a&gt;). Here is how the two together can be used to define a safe &amp;ldquo;maximum&amp;rdquo; macro which operates on any arithmetic type and evaluates each of its arguments exactly once:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; часто используется в сочетании с выражениями операторов (см. &amp;laquo; &lt;a href=&quot;statement-exprs#Statement-Exprs&quot;&gt;Эксперты операторов&amp;raquo;&lt;/a&gt; ). Вот как их вместе можно использовать для определения безопасного макроса &amp;laquo;максимума&amp;raquo;, который работает с любым арифметическим типом и оценивает каждый из его аргументов ровно один раз:</target>
        </trans-unit>
        <trans-unit id="01dc66305ee017274a8f90b9afb7de83e8f46c89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt;: referring to the type of an expression.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; : ссылка на тип выражения.</target>
        </trans-unit>
        <trans-unit id="8c7b90f2794ef9994bb660999c0f322a942bf8f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint16x4_t&lt;/code&gt;, a vector of four unsigned 16-bit integers;</source>
          <target state="translated">&lt;code&gt;uint16x4_t&lt;/code&gt; , вектор из четырех 16-разрядных целых чисел без знака;</target>
        </trans-unit>
        <trans-unit id="b0558ac59824429cd7d9d4b1f36c21a2ee0fe3e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint32x2_t&lt;/code&gt;, a vector of two unsigned 32-bit integers;</source>
          <target state="translated">&lt;code&gt;uint32x2_t&lt;/code&gt; , вектор из двух 32-битных целых чисел без знака;</target>
        </trans-unit>
        <trans-unit id="2d69c68962c47d62e79bf31389c4415c2f200ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint8x8_t&lt;/code&gt;, a vector of eight unsigned 8-bit integers;</source>
          <target state="translated">&lt;code&gt;uint8x8_t&lt;/code&gt; , вектор из восьми 8-битных целых чисел без знака;</target>
        </trans-unit>
        <trans-unit id="dbb644e8ba42f8f623407a24fa989ae31fed8572" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union U&lt;/code&gt; is always passed in memory.</source>
          <target state="translated">&lt;code&gt;union U&lt;/code&gt; всегда передается в памяти.</target>
        </trans-unit>
        <trans-unit id="1db4672f93c338ff587750e17356ae256986573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union U&lt;/code&gt; is now always passed in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadc8e6d5e8d31b3a291f79221d6f051c12b8821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v16i8&lt;/code&gt;, a vector of sixteen signed 8-bit integers;</source>
          <target state="translated">&lt;code&gt;v16i8&lt;/code&gt; , вектор из шестнадцати 8-битных целых чисел со знаком ;</target>
        </trans-unit>
        <trans-unit id="131a161af4f7e0b4ea5ae1747e0ea7514b0c83b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v16u8&lt;/code&gt;, a vector of sixteen unsigned 8-bit integers;</source>
          <target state="translated">&lt;code&gt;v16u8&lt;/code&gt; , вектор из шестнадцати беззнаковых 8-битных целых чисел;</target>
        </trans-unit>
        <trans-unit id="1b29406a43f217bd305e13cb54ba71e651d5bba2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2f64&lt;/code&gt;, a vector of two 64-bit doubles.</source>
          <target state="translated">&lt;code&gt;v2f64&lt;/code&gt; , вектор из двух 64-битных двойников.</target>
        </trans-unit>
        <trans-unit id="7512973093e5491713fd6ebd5358156e9bc4a1dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2i64&lt;/code&gt;, a vector of two signed 64-bit integers;</source>
          <target state="translated">&lt;code&gt;v2i64&lt;/code&gt; , вектор из двух 64-битных целых чисел со знаком ;</target>
        </trans-unit>
        <trans-unit id="9db6b88b33ec3aa8ad125c2d46beb5f476bec0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2sf&lt;/code&gt; values are initialized in the same way as aggregates. For example:</source>
          <target state="translated">&lt;code&gt;v2sf&lt;/code&gt; Значения v2sf инициализируются так же, как и агрегаты. Например:</target>
        </trans-unit>
        <trans-unit id="c3855d3df800b3ae2c45c123aa6cb8ce5e785ead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2u64&lt;/code&gt;, a vector of two unsigned 64-bit integers;</source>
          <target state="translated">&lt;code&gt;v2u64&lt;/code&gt; , вектор двух беззнаковых 64-битных целых чисел;</target>
        </trans-unit>
        <trans-unit id="6ad31881d9c216547f22d1f2a2db29238b4dc646" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4f32&lt;/code&gt;, a vector of four 32-bit floats;</source>
          <target state="translated">&lt;code&gt;v4f32&lt;/code&gt; , вектор из четырех 32-битных чисел с плавающей запятой;</target>
        </trans-unit>
        <trans-unit id="31c7877922fb039b6c0292daf271e4981078508f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4i32&lt;/code&gt;, a vector of four signed 32-bit integers;</source>
          <target state="translated">&lt;code&gt;v4i32&lt;/code&gt; , вектор из четырех 32-битных целых чисел со знаком ;</target>
        </trans-unit>
        <trans-unit id="17a0ec2f60a3d3e13fba7b775b40060a5c47ab58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4i8&lt;/code&gt;, &lt;code&gt;v4q7&lt;/code&gt;, &lt;code&gt;v2i16&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; values are initialized in the same way as aggregates. For example:</source>
          <target state="translated">&lt;code&gt;v4i8&lt;/code&gt; , &lt;code&gt;v4q7&lt;/code&gt; , &lt;code&gt;v2i16&lt;/code&gt; и &lt;code&gt;v2q15&lt;/code&gt; инициализируются так же, как и агрегаты. Например:</target>
        </trans-unit>
        <trans-unit id="6b9f0632a60f7e2199e33eae5df860d977b737c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4u32&lt;/code&gt;, a vector of four unsigned 32-bit integers;</source>
          <target state="translated">&lt;code&gt;v4u32&lt;/code&gt; , вектор из четырех 32-битных целых чисел без знака;</target>
        </trans-unit>
        <trans-unit id="15eeca02c95cac6ccf4d38d5e71572806fbe59c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v8i16&lt;/code&gt;, a vector of eight signed 16-bit integers;</source>
          <target state="translated">&lt;code&gt;v8i16&lt;/code&gt; , вектор из восьми 16-разрядных целых чисел со знаком ;</target>
        </trans-unit>
        <trans-unit id="18c14a5e3dac281031739c8daafc626ba35c9efb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v8u16&lt;/code&gt;, a vector of eight unsigned 16-bit integers;</source>
          <target state="translated">&lt;code&gt;v8u16&lt;/code&gt; , вектор из восьми 16-разрядных целых чисел без знака;</target>
        </trans-unit>
        <trans-unit id="d6a4e5bb9ed4a03346a1e5335ca402c064f0fe3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void *&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; для типа возврата и типа параметра</target>
        </trans-unit>
        <trans-unit id="931138ba5a2507ee2e7e0fc42f85c661aad3ee17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; for return type and no parameter for parameter types.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; для типа возвращаемого значения и без параметра для типов параметров.</target>
        </trans-unit>
        <trans-unit id="5a5d5c4a2842d52363078341ffbf5ff1c71da9e6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AArch64 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры AArch64&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ea9b56847cb67e896fe9ed92e829c46db4c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AMD GCN Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры AMD GCN&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="867c24fe4dbfd5ccbf6133610e3056cd4490ebb2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ARC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры ARC&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a804dffc1734b11346a4329fb8b712484dc062a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ARM Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры ARM&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42007853e2d2e5ee57f43b159004f83209e6c120" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AVR Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции AVR&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9aab5cdb90e0e7068aace684de244f8deb97788a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Adapteva Epiphany Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Варианты Богоявления Адаптевой&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae87c6342c250828b19327bd7929eed321e39d53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Blackfin Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры Blackfin&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77196484bdd6bd4585004c0d69f5afd921d39aeb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;C-SKY Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции C-SKY&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be9ad0c2e9c89a60e3ec15f581550300b8820f0d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;C6X Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции C6X&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd379f819a2900908cff60cb928d58f868b9db54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CR16 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;CR16 Опции&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cfc7c2eba72f3e5ff0469155a3c3406b2e006fe3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CRIS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции CRIS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0bcedc624ee2d8bc0dc1dde9e3ffd94d702c3815" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DEC Alpha Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Альфа-параметры DEC&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c720ccb25061b11c148efb66e96f845b91fa6ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Darwin Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Варианты Дарвина&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95f44dfbf82d62481da460c42b5fb7c35274dcea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Errors&lt;/em&gt; report problems that make it impossible to compile your program. GCC reports errors with the source file name and line number where the problem is apparent.</source>
          <target state="translated">&lt;em&gt;Ошибки&lt;/em&gt; сообщают о проблемах, которые делают невозможным компиляцию вашей программы. GCC сообщает об ошибках с указанием имени исходного файла и номера строки, в которой проблема очевидна.</target>
        </trans-unit>
        <trans-unit id="089e6e509d8caabf29e30ec3bbbe964fc2afe250" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FR30 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры FR30&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="091553d3f3e8974e90f05c57755746679c1fdd3a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FRV Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры FRV&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70b7d6e356f2d0708ee860d4fc3fd1c61ab2eed5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FT32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции FT32&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98ffc4ee3ad54f42a4735dcc174d96d9c6c59ac5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;GNU/Linux Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры GNU / Linux&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0822ea35a43e7bcfdcf9fd3e546d607438735455" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;H8/300 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции H8 / 300&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdf83e6772f30030bb2fc1476c4b6aba2fad8a80" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HPPA Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции HPPA&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5c413dcc96c0d8d85ccbfd5c8edb509e5cdc1c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;IA-64 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры IA-64&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72b634d41b068d05c153c5acbd927a150eda46f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LM32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции LM32&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e939059a018e2d2ed5fcec7a81d238219702f1a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M32C Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции M32C&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41423d489b98fe3519ae5cbb7b050e878b6bd6b0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M32R/D Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции M32R / D&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d6bc2eaf8866182e321b20849ed96413e122e84" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M680x0 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M680x0 Опции&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7869c6ee0bb9ef2d45291f35d9736bbbaaacc30a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MCore Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры MCore&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f92ee1798eb5d8b5d7a11c3903d764ec6e437af6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MIPS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры MIPS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6811edeb78aee90d2929700d84423144700748a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MMIX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры MMIX&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c6c421dea99cc933fb54d01b9291e1f3cc15403" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MN10300 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MN10300 Опции&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ae829c80944d42f892c7e2fcafa7795e50814c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MSP430 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции MSP430&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="995202556b55cd172ec8bc628d585bb4f9d60357" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MeP Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции MeP&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d8110270e3200546987d8ee1384e2734ad7589" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MicroBlaze Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры MicroBlaze&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b56c00142a2adf77adfc3b717573e363224b9028" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Moxie Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры Moxie&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56ac1cd6a6c4ddc7383020e1168c9487d3c77648" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NDS32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры NDS32&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0489603a8178bb1a03c11b5a827e58b0d976d54d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nios II Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции Nios II&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a71b3dbe832df819e003067a1cc89679cd5065c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Although the equivalent hardware instructions do not take an SIMD register as an operand, these builtins overwrite the relevant bits of the &lt;code&gt;__v8hi&lt;/code&gt; register provided as the first argument with the value loaded from the &lt;code&gt;[Ib, u8]&lt;/code&gt; location in the SDM.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Хотя эквивалентные аппаратные инструкции не принимают регистр SIMD в качестве операнда, эти встроенные функции перезаписывают соответствующие биты регистра &lt;code&gt;__v8hi&lt;/code&gt; , предоставленные в качестве первого аргумента, значением, загруженным из &lt;code&gt;[Ib, u8]&lt;/code&gt; в SDM.</target>
        </trans-unit>
        <trans-unit id="906695ffc11fbd6c29f6a7c5fffdd87c61dd0062" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; GCC 4.4 and later implement &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; as &lt;code&gt;*ptr = ~(tmp &amp;amp; value)&lt;/code&gt; instead of &lt;code&gt;*ptr = ~tmp &amp;amp; value&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Примечание:&lt;/em&gt; GCC 4.4 и более поздние &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; реализуют __sync_fetch_and_nand как &lt;code&gt;*ptr = ~(tmp &amp;amp; value)&lt;/code&gt; вместо &lt;code&gt;*ptr = ~tmp &amp;amp; value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32481d3d57648f7ac3b59915a8b343ab8f94362a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; GCC 4.4 and later implement &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; as &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; instead of &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Примечание:&lt;/em&gt; GCC 4.4 и более поздние &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; реализуют __sync_nand_and_fetch как &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; вместо &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa1f3ae46628635e862095cde321a13674e15cd0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If GCOV_PREFIX_STRIP is set without GCOV_PREFIX is undefined, then a relative path is made out of the hardwired absolute paths.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Если GCOV_PREFIX_STRIP установлен, а GCOV_PREFIX не определен, то относительный путь создается из зашитых абсолютных путей.</target>
        </trans-unit>
        <trans-unit id="ea491177a79dc64abd09c78a1e151400a239c1ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If a macro is actually used, but only used in skipped conditional blocks, then the preprocessor reports it as unused. To avoid the warning in such a case, you might improve the scope of the macro&amp;rsquo;s definition by, for example, moving it into the first skipped block. Alternatively, you could provide a dummy use with something like:</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Если макрос действительно используется, но используется только в пропущенных условных блоках, препроцессор сообщает о нем как о неиспользованном. Чтобы избежать предупреждения в таком случае, вы можете расширить область определения макроса, например, переместив его в первый пропущенный блок. В качестве альтернативы вы можете предоставить фиктивное использование, например:</target>
        </trans-unit>
        <trans-unit id="513ca629c61e9f50ec1060bb038d882eda72087c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If the chosen key method is later defined as inline, the vtable is still emitted in every translation unit that defines it. Make sure that any inline virtuals are declared inline in the class body, even if they are not defined there.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Если выбранный ключевой метод позже будет определен как встроенный, vtable по-прежнему генерируется в каждой единице перевода, которая его определяет. Убедитесь, что все встроенные виртуальные объекты объявлены встроенными в тело класса, даже если они там не определены.</target>
        </trans-unit>
        <trans-unit id="5909e9b7c2f203286387e1708a17c1db3ad3cfd7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Only the &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; interface is supported. Internally, GCC uses built-in functions to achieve the functionality in the aforementioned header file, but they are not supported and are subject to change without notice.</source>
          <target state="translated">&lt;em&gt;Примечание:&lt;/em&gt; Только &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; интерфейс поддерживается. Внутри GCC использует встроенные функции для достижения функциональности в вышеупомянутом файле заголовка, но они не поддерживаются и могут быть изменены без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="2e7d99f36188d0a0ae9bd36f15a8de72013df3fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Only the interface described in the aforementioned specification is supported. Internally, GCC uses built-in functions to implement the required functionality, but these are not supported and are subject to change without notice.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Поддерживается только интерфейс, описанный в вышеупомянутой спецификации. Внутри GCC использует встроенные функции для реализации необходимых функций, но они не поддерживаются и могут быть изменены без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="60f5a5be3206ed7a5edc1d0306252ee653ebb15f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Q7, Q15 and Q31 values must be initialized with their integer representation. As shown in this example, the integer representation of a Q7 value can be obtained by multiplying the fractional value by &lt;code&gt;0x1.0p7&lt;/code&gt;. The equivalent for Q15 values is to multiply by &lt;code&gt;0x1.0p15&lt;/code&gt;. The equivalent for Q31 values is to multiply by &lt;code&gt;0x1.0p31&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Значения Q7, Q15 и Q31 должны быть инициализированы их целочисленным представлением. Как показано в этом примере, целочисленное представление значения Q7 можно получить, умножив дробное значение на &lt;code&gt;0x1.0p7&lt;/code&gt; . Эквивалент для значений Q15 - умножение на &lt;code&gt;0x1.0p15&lt;/code&gt; . Эквивалент для значений &lt;code&gt;0x1.0p31&lt;/code&gt; - умножение на 0x1.0p31 .</target>
        </trans-unit>
        <trans-unit id="ecefd38e47b465f12582422275b6c1c7fc5ba3d0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. See the documentation of</source>
          <target state="translated">&lt;em&gt;Примечание:&lt;/em&gt; GCC серий 4.1, 4.2 и 4.3 игнорирует &lt;code&gt;packed&lt;/code&gt; атрибут в битовых полях типа &lt;code&gt;char&lt;/code&gt; . Это было исправлено в GCC 4.4, но изменение может привести к различиям в структуре структуры. См. Документацию</target>
        </trans-unit>
        <trans-unit id="83a8626dc0b2f71c9d50349e2149ee36fab186fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The CPU&amp;rsquo;s endianness determines the order in which values are packed. On little-endian targets, the first value is the least significant and the last value is the most significant. The opposite order applies to big-endian targets. For example, the code above sets the lowest byte of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; on little-endian targets and &lt;code&gt;4&lt;/code&gt; on big-endian targets.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Порядок байтов ЦП определяет порядок упаковки значений. Для целей с прямым порядком байтов первое значение является наименее значимым, а последнее значение - наиболее значимым. Противоположный порядок применяется к целевым объектам с прямым порядком байтов. Например, приведенный выше код устанавливает для младшего байта &lt;code&gt;a&lt;/code&gt; значение &lt;code&gt;1&lt;/code&gt; для целей с прямым порядком байтов и &lt;code&gt;4&lt;/code&gt; для целей с прямым порядком байтов.</target>
        </trans-unit>
        <trans-unit id="5b93697e5f9fd5103a0a7f14fc065355825c4168" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The CPU&amp;rsquo;s endianness determines which value is stored in the upper half of a register and which value is stored in the lower half. On little-endian targets, the first value is the lower one and the second value is the upper one. The opposite order applies to big-endian targets. For example, the code above sets the lower half of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;1.5&lt;/code&gt; on little-endian targets and &lt;code&gt;9.1&lt;/code&gt; on big-endian targets.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Порядок байтов ЦП определяет, какое значение хранится в верхней половине регистра, а какое - в нижней. Для целей с прямым порядком байтов первое значение является нижним, а второе значение - верхним. Противоположный порядок применяется к целевым объектам с прямым порядком байтов. Например, приведенный выше код множеств нижняя половина до &lt;code&gt;1.5&lt;/code&gt; на прямой порядок байтов целей и &lt;code&gt;9.1&lt;/code&gt; на тупоконечника целей. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f29631325fd85cd0fed1160021c6ec9cde3b5c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The generic GCC command-line option</source>
          <target state="translated">&lt;em&gt;Примечание:&lt;/em&gt; общий параметр командной строки GCC</target>
        </trans-unit>
        <trans-unit id="ed06dff3e4ef6bf04ce2ce52a8b9fd81cb4cb441" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The value of the third parameter must be 0 or 4 modulo 8, otherwise the result is unpredictable. Please read the instruction description for details.</source>
          <target state="translated">&lt;em&gt;Примечание:&lt;/em&gt; значение третьего параметра должно быть 0 или 4 по модулю 8, иначе результат будет непредсказуемым. Пожалуйста, прочтите описание инструкции для подробностей.</target>
        </trans-unit>
        <trans-unit id="72153d9d5813664a3177200e0649d766dc189c8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; These &lt;code&gt;#pragma&lt;/code&gt;s have been superceded as of GCC 2.7.2 by COMDAT support and the &amp;ldquo;key method&amp;rdquo; heuristic mentioned in &lt;a href=&quot;vague-linkage#Vague-Linkage&quot;&gt;Vague Linkage&lt;/a&gt;. Using them can actually cause your program to grow due to unnecessary out-of-line copies of inline functions.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Эти &lt;code&gt;#pragma&lt;/code&gt; были заменены в GCC 2.7.2 поддержкой COMDAT и эвристикой &amp;laquo;ключевого метода&amp;raquo;, упомянутой в &lt;a href=&quot;vague-linkage#Vague-Linkage&quot;&gt;Vague Linkage&lt;/a&gt; . Их использование может фактически привести к росту вашей программы из-за ненужных внешних копий встроенных функций.</target>
        </trans-unit>
        <trans-unit id="a7b139d88803f100cdd95a55602837bc153be904" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This builtin is only available for C. This builtin can be used to call Go closures from C.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Эта встроенная функция доступна только для C. Эта встроенная функция может использоваться для вызова замыканий Go из C.</target>
        </trans-unit>
        <trans-unit id="2d97839275dd23b736dcd3d659869aced8cae5cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This construct is only available for C.</source>
          <target state="translated">&lt;em&gt;Примечание:&lt;/em&gt; эта конструкция доступна только для C.</target>
        </trans-unit>
        <trans-unit id="eacbc4a00a6df067f8f96e363a35fd76d48bed27" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This construct is only available for C. Furthermore, the unused expression (&lt;var&gt;exp1&lt;/var&gt; or &lt;var&gt;exp2&lt;/var&gt; depending on the value of &lt;var&gt;const_exp&lt;/var&gt;) may still generate syntax errors. This may change in future revisions.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Эта конструкция доступна только для C. Кроме того, неиспользуемое выражение ( &lt;var&gt;exp1&lt;/var&gt; или &lt;var&gt;exp2&lt;/var&gt; в зависимости от значения &lt;var&gt;const_exp&lt;/var&gt; ) все еще может генерировать синтаксические ошибки. Это может измениться в будущих версиях.</target>
        </trans-unit>
        <trans-unit id="5e7e557ba1661093fe7151e1bdc289cf424df86b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Using a built-in to generate an instruction not supported by a target may cause problems. At present the compiler is not guaranteed to detect such misuse, and as a result an internal compiler error may be generated.</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Использование встроенной программы для генерации инструкции, не поддерживаемой целью, может вызвать проблемы. В настоящее время не гарантируется, что компилятор обнаружит такое неправильное использование, и в результате может возникнуть внутренняя ошибка компилятора.</target>
        </trans-unit>
        <trans-unit id="1a1eec5083716264a52a5668d0e808764085fd67" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; When compiling a program using computed gotos, a GCC extension, you may get better run-time performance if you disable the global common subexpression elimination pass by adding</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; При компиляции программы с использованием вычисляемых gotos, расширения GCC, вы можете улучшить производительность во время выполнения, если отключите глобальный проход исключения общих подвыражений, добавив</target>
        </trans-unit>
        <trans-unit id="c3ceb34dafdbbccb7b3f4a9bc3198076a8bb038d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; pseudo instruction represents, in this particular context, an abstract measurement of function&amp;rsquo;s size. In no way does it represent a count of assembly instructions and as such its exact meaning might change from one release to an another.</source>
          <target state="translated">&lt;em&gt;Примечание:&lt;/em&gt; псевдо-инструкция в данном конкретном контексте представляет собой абстрактное измерение размера функции. Он никоим образом не представляет собой количество сборочных инструкций, и поэтому его точное значение может меняться от одного выпуска к другому.</target>
        </trans-unit>
        <trans-unit id="64cd29898900abd284b24ce0046a12f2a889805e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; there may be no value to</source>
          <target state="translated">&lt;em&gt;Примечание:&lt;/em&gt; может не иметь значения</target>
        </trans-unit>
        <trans-unit id="34f20bbbcdb20cd93bc0b28a39e05bcb36620def" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt; If the</source>
          <target state="translated">&lt;em&gt;Примечание.&lt;/em&gt; Если</target>
        </trans-unit>
        <trans-unit id="cc501835fd0037936c2300c5863d1305c99d13dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nvidia PTX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры Nvidia PTX&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7857f3cff032f30c80ecfb8270b8c04e4e9d6efc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OpenRISC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры OpenRISC&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="022f17d65bf2f852a9bf52143c3cab7582dddc12" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PDP-11 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции PDP-11&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc7124a8b758cba8598057dd8d025c193f4f022a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PRU Options&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc36ba8a70957c05f0128aeed8b3ffa01e74a202" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PowerPC Options&lt;/em&gt; See RS/6000 and PowerPC Options.</source>
          <target state="translated">&lt;em&gt;Параметры PowerPC&lt;/em&gt; См. &lt;em&gt;Параметры&lt;/em&gt; RS / 6000 и PowerPC.</target>
        </trans-unit>
        <trans-unit id="7d12212e9493501d271a126a834619cd825cc637" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RISC-V Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры RISC-V&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51deeb74b7040696523eac8e9b50aaa9f0c160b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RL78 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции RL78&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0525fb0f4921d4b454f0867178cc3f2e709dd05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RS/6000 and PowerPC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции RS / 6000 и PowerPC&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39cbc4dfd74b5b6e0fa9efd8a12d1162bb681080" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции RX&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="736a44f00f2782082aa29882ffc21518d1f4a4e8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;S/390 and zSeries Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции S / 390 и zSeries&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41e4a234f5bb49cd0264fa22972792fc9da3bcbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SH Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры SH&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56bc7167620d3c71b9cb584d08f274377f44bf2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SPARC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры SPARC&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc670533970668fe64148e47e0fafdaea94cb03b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SPU Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции SPU&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c56413d87d2da9557912d35dbc2cfbca82836384" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Score Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры оценки&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62b914fb373470c0b2ac9d74fa9f6fe2b909d5de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Solaris 2 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции Solaris 2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d42fb76fd4341ca34cfd6fb2f6c0a0d677895a40" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec files&lt;/em&gt; are plain-text files that are used to construct spec strings. They consist of a sequence of directives separated by blank lines. The type of directive is determined by the first non-whitespace character on the line, which can be one of the following:</source>
          <target state="translated">&lt;em&gt;Файлы спецификации - это файлы&lt;/em&gt; с открытым текстом, которые используются для построения строк спецификации. Они состоят из последовательности директив, разделенных пустыми строками. Тип директивы определяется первым непробельным символом в строке, который может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="db99a02bf9325a0446b3d3660f54ae1be166577f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec strings&lt;/em&gt; are a list of command-line options to be passed to their corresponding program. In addition, the spec strings can contain &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Строки спецификации&lt;/em&gt; - это список параметров командной строки, которые нужно передать соответствующей программе. Кроме того, строки спецификации могут содержать '</target>
        </trans-unit>
        <trans-unit id="5a15016eaf2ae61e798c9e92b569358a39e86710" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;System V Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры System V&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb127030e9fe13464eefbb656da5c5e59f1ec48" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TILE-Gx Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры TILE-Gx&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6e6e9084306dd7d17aba875acb7fea1ed46ce39" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TILEPro Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции TILEPro&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e1e262e710aa664259e0fd18b86e9454a54d4a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;V850 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции V850&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc271d88c785f840f6cf51c476df618f74b1cbef" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VAX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опции VAX&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e143e075ae3bdac97703feadb897d0df26906759" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VMS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры VMS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d28ef093233a29030bf54382ba024a105f45890e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Visium Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры Visium&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe1a73e1bcb98976a3dfe16f3ba0939cee97b5b0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VxWorks Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры VxWorks&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7aee4d537121bb2f423daebb8bdece70ad36a69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning:&lt;/em&gt; In the above example, be aware that a register (for example &lt;code&gt;r0&lt;/code&gt;) can be call-clobbered by subsequent code, including function calls and library calls for arithmetic operators on other variables (for example the initialization of &lt;code&gt;p2&lt;/code&gt;). In this case, use temporary variables for expressions between the register assignments:</source>
          <target state="translated">&lt;em&gt;Предупреждение:&lt;/em&gt; в приведенном выше примере имейте в виду, что регистр (например, &lt;code&gt;r0&lt;/code&gt; ) может быть заблокирован последующим кодом, включая вызовы функций и вызовы библиотек для арифметических операторов над другими переменными (например, инициализация &lt;code&gt;p2&lt;/code&gt; ). В этом случае используйте временные переменные для выражений между назначениями регистров:</target>
        </trans-unit>
        <trans-unit id="816a932da8e0bd79bd86e31e2bb7d68625f97793" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warnings&lt;/em&gt; report other unusual conditions in your code that &lt;em&gt;may&lt;/em&gt; indicate a problem, although compilation can (and does) proceed. Warning messages also report the source file name and line number, but include the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Предупреждения&lt;/em&gt; сообщают о других необычных условиях в вашем коде, которые &lt;em&gt;могут&lt;/em&gt; указывать на проблему, хотя компиляция может (и продолжает) продолжаться. Предупреждающие сообщения также сообщают имя исходного файла и номер строки, но включают текст '</target>
        </trans-unit>
        <trans-unit id="4b143c44f6aab624c938e93ad2f6b4f657e59153" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Xstormy16 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Xstormy16 Параметры&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ac74c0cb677176c306ff128a293af591f367d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Xtensa Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры Xtensa&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="135f91287a5ce57a17a4eafa0bb5f1e2e6a72df9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;eBPF Options&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e5f6791684d95443cdbb8fd6680f023a74362e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;picoChip Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры picoChip&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2dbd6047aac87327270d92252817d5d79e582ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x86 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры x86&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2372ad60b474adcacc8813df7ea55f14799cf6b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x86 Windows Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Параметры Windows x86&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="636b6c51fd4e87f012cdd524f840607ddf80c3c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;zSeries Options&lt;/em&gt; See S/390 and zSeries Options.</source>
          <target state="translated">&lt;em&gt;Параметры zSeries&lt;/em&gt; См. &lt;em&gt;Параметры&lt;/em&gt; S / 390 и zSeries.</target>
        </trans-unit>
        <trans-unit id="05b073d8b145e3b7b4fe9382c836fb5ca8365004" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lsquo;&lt;samp&gt;-mcpu&lt;/samp&gt;&amp;rsquo; arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;'&lt;samp&gt;-mcpu&lt;/samp&gt;аргументы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ca73c3cb15b2a6924f0a26af33432a71a16d184" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be careful:&lt;/strong&gt; Write spaces around the &lt;code&gt;...&lt;/code&gt;, for otherwise it may be parsed wrong when you use it with integer values. For example, write this:</source>
          <target state="translated">&lt;strong&gt;Будьте осторожны:&lt;/strong&gt; пишите пробелы вокруг &lt;code&gt;...&lt;/code&gt; , иначе он может быть неправильно проанализирован, когда вы используете его с целыми значениями. Например, напишите это:</target>
        </trans-unit>
        <trans-unit id="5b296bb4d7e000ba38a77aa5d36e6fe239ea357d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Family&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Family&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ce6e314b705bb119112642204e6ae779116bafe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do &lt;em&gt;not&lt;/em&gt; modify the contents of input-only operands (except for inputs tied to outputs). The compiler assumes that on exit from the &lt;code&gt;asm&lt;/code&gt; statement these operands contain the same values as they had before executing the statement. It is &lt;em&gt;not&lt;/em&gt; possible to use clobbers to inform the compiler that the values in these inputs are changing. One common work-around is to tie the changing input variable to an output variable that never gets used. Note, however, that if the code that follows the &lt;code&gt;asm&lt;/code&gt; statement makes no use of any of the output operands, the GCC optimizers may discard the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; Do &lt;em&gt;не&lt;/em&gt; изменять содержимое только для ввода операндов (для входов , привязанных к выходам за исключением). Компилятор предполагает, что при выходе из инструкции &lt;code&gt;asm&lt;/code&gt; эти операнды содержат те же значения, что и до выполнения инструкции. Это &lt;em&gt;не&lt;/em&gt; возможно использовать затирает , чтобы сообщить компилятору , что значения этих входов меняется. Один из распространенных обходных путей - привязать изменяющуюся входную переменную к выходной переменной, которая никогда не используется. Однако обратите внимание, что если код, следующий за оператором &lt;code&gt;asm&lt;/code&gt; , не использует какие-либо выходные операнды, оптимизаторы GCC могут отбросить оператор &lt;code&gt;asm&lt;/code&gt; как ненужный (см. &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a41c6abd653a33317410ef0db731418bdf245365" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you use this switch, then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если вы используете этот переключатель, вы должны собрать все модули с одинаковым значением, включая любые библиотеки. Сюда входят системные библиотеки и модули запуска.</target>
        </trans-unit>
        <trans-unit id="9f8a7fec506fe7c2f6084ea58dbd6ac51571b5ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since RAX register is used to avoid unnecessarily saving vector registers on stack when passing variable arguments, the impacts of this option are callees may waste some stack space, misbehave or jump to a random location. GCC 4.4 or newer don&amp;rsquo;t have those issues, regardless the RAX register value.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; поскольку регистр RAX используется для предотвращения излишнего сохранения векторных регистров в стеке при передаче переменных аргументов, влияние этой опции заключается в том, что вызываемые объекты могут тратить некоторое пространство стека, вести себя неправильно или переходить в случайное место. GCC 4.4 или новее не имеют этих проблем, независимо от значения регистра RAX.</target>
        </trans-unit>
        <trans-unit id="715534c76b05f27a336cac5eca1f15bb1ba0531b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The</source>
          <target state="translated">&lt;strong&gt;Внимание:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e163e3f64318185967d993e343b277921267102a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The C standards do not specify semantics for &lt;code&gt;asm&lt;/code&gt;, making it a potential source of incompatibilities between compilers. These incompatibilities may not produce compiler warnings/errors.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; стандарты C не определяют семантику для &lt;code&gt;asm&lt;/code&gt; , что делает его потенциальным источником несовместимости между компиляторами. Эти несовместимости могут не вызывать предупреждений / ошибок компилятора.</target>
        </trans-unit>
        <trans-unit id="e86cc1401a696068f7f847fa2efe8d1c2b4f1d91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When an application does not properly join all threads (or creates an detached thread), a profile file can be still corrupted.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; когда приложение не присоединяется ко всем потокам должным образом (или создает отдельный поток), файл профиля может быть поврежден.</target>
        </trans-unit>
        <trans-unit id="edb6152c62df55204f513a2bd268c824cd742794" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When generating code for the x86-64 architecture with SSE extensions disabled,</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; при генерации кода для архитектуры x86-64 с отключенными расширениями SSE,</target>
        </trans-unit>
        <trans-unit id="6d3e02f67e0426840cf2eab0fa386a7a0d8f3f4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; code compiled with the</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; код скомпилирован с</target>
        </trans-unit>
        <trans-unit id="81d77d1a721cb0e9d979c46fa00adb7925430d90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you override the default value for your target ABI, this changes the size of structures and arrays containing &lt;code&gt;long double&lt;/code&gt; variables, as well as modifying the function calling convention for functions taking &lt;code&gt;long double&lt;/code&gt;. Hence they are not binary-compatible with code compiled without that switch.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если вы переопределите значение по умолчанию для вашего целевого ABI, это изменит размер структур и массивов, содержащих &lt;code&gt;long double&lt;/code&gt; переменные типа double , а также изменит соглашение о вызове функций для функций, принимающих &lt;code&gt;long double&lt;/code&gt; . Следовательно, они несовместимы с двоичным кодом с кодом, скомпилированным без этого переключателя.</target>
        </trans-unit>
        <trans-unit id="6aef184d39f03952d172b7102530bc7a9cb2fa3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use the</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если вы используете</target>
        </trans-unit>
        <trans-unit id="b85ec1ce84c8439a9545fb2c1d7bf94b735aa0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use this switch then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если вы используете этот переключатель, вы должны собрать все модули с одинаковым значением, включая любые библиотеки. Сюда входят системные библиотеки и модули запуска.</target>
        </trans-unit>
        <trans-unit id="6580347fe9571154d0b4891b1664cd9202c2acd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use this switch, and &lt;var&gt;num&lt;/var&gt; is nonzero, then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если вы используете этот переключатель, а &lt;var&gt;num&lt;/var&gt; равно нулю, вы должны собрать все модули с одинаковым значением, включая любые библиотеки. Сюда входят системные библиотеки и модули запуска.</target>
        </trans-unit>
        <trans-unit id="f2fa2d1c77dc6f956448ba7d671e1de6cedbcd38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the</source>
          <target state="translated">&lt;strong&gt;Внимание:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88c4d51d8f615f3993e3c0cef840662cb24bb857" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not part of GCC. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; необходимые библиотеки не являются частью GCC. Обычно используются возможности обычного машинного компилятора C, но это невозможно сделать напрямую в кросс-компиляции. Вы должны принять собственные меры, чтобы предоставить подходящие библиотечные функции для кросс-компиляции.</target>
        </trans-unit>
        <trans-unit id="776b38edee53ccd0d1e652426154a9a588a26326" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; this calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; это соглашение о вызовах несовместимо с тем, которое обычно используется в Unix, поэтому вы не можете использовать его, если вам нужно вызывать библиотеки, скомпилированные с помощью компилятора Unix.</target>
        </trans-unit>
        <trans-unit id="8633eef0a9b0178977134e42efd5a0068c9de00b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;KIND&lt;/var&gt; is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136834bf622d717ffa74c10318ba5a8ccd251af2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14be2a02710f49b8ea2b62d8e69b1cad01176b7f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;arch&lt;/var&gt; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c92b0834b3f6e0b0e166db87ccbdb672bb82648" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;auxname&lt;/var&gt;.gcda</source>
          <target state="translated">&lt;var&gt;auxname&lt;/var&gt;.gcda</target>
        </trans-unit>
        <trans-unit id="9e19d8b5ca485e7de26e8b332e442d8fc54664ea" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;auxname&lt;/var&gt;.gcno</source>
          <target state="translated">&lt;var&gt;auxname&lt;/var&gt;.gcno</target>
        </trans-unit>
        <trans-unit id="85165da2ca5194c5347e3eeeb486f7fe2449eb31" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;b&lt;/var&gt;fx</source>
          <target state="translated">&lt;var&gt;b&lt;/var&gt;fx</target>
        </trans-unit>
        <trans-unit id="e61d261ac414ee0ceb16d824496fad9b5acddd85" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;blocks&lt;/var&gt;: number of blocks that are in the function</source>
          <target state="translated">&lt;var&gt;blocks&lt;/var&gt; : количество блоков, которые находятся в функции</target>
        </trans-unit>
        <trans-unit id="8ae8f4fb9cf1118a0551f86c7142bd0ff6bc1464" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;blocks_executed&lt;/var&gt;: number of executed blocks of the function</source>
          <target state="translated">&lt;var&gt;blocks_executed&lt;/var&gt; : количество выполненных блоков функции</target>
        </trans-unit>
        <trans-unit id="b33636a0ba563901664b6c5f838dee23ec7b7447" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;byte-size&lt;/var&gt; works, but with variable-length arrays.</source>
          <target state="translated">&lt;var&gt;byte-size&lt;/var&gt; работает, но с массивами переменной длины.</target>
        </trans-unit>
        <trans-unit id="3908fe32fbee17ab1091dcbbbcc9d95e8c868d21" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;count&lt;/var&gt;: number of executions of the branch</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; : количество выполнений ветки</target>
        </trans-unit>
        <trans-unit id="a5a5b0ddbf193f53659eab4ecc8e6518b23dc55a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;count&lt;/var&gt;: number of executions of the line</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; : количество выполнений строки</target>
        </trans-unit>
        <trans-unit id="6dc66d5a71e8f3349f4206d52eb3738739a10355" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;current_working_directory&lt;/var&gt;: working directory where a compilation unit was compiled</source>
          <target state="translated">&lt;var&gt;current_working_directory&lt;/var&gt; : рабочий каталог, в котором был скомпилирован модуль компиляции</target>
        </trans-unit>
        <trans-unit id="f2f093923378c09906b260d4e4fef642e8bd4c9b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;data_file&lt;/var&gt;: name of the data file (GCDA)</source>
          <target state="translated">&lt;var&gt;data_file&lt;/var&gt; : имя файла данных (GCDA)</target>
        </trans-unit>
        <trans-unit id="82a3c99596c0803b3cd5b5dc5b7d4f7edcb29691" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;demangled_name&lt;/var&gt;: demangled name of the function</source>
          <target state="translated">&lt;var&gt;demangled_name&lt;/var&gt; : разоблаченное имя функции</target>
        </trans-unit>
        <trans-unit id="96756339f8a07464a095163d86ae17ba49c6f2b0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/&lt;var&gt;suffix&lt;/var&gt;/usr/include</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/&lt;var&gt;suffix&lt;/var&gt;/usr/include</target>
        </trans-unit>
        <trans-unit id="457fd18521fb5ee2775888f964e4ddd50de83968" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/usr/include</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/usr/include</target>
        </trans-unit>
        <trans-unit id="a2f5c6f857a964db0e9209dc3bc8af9204a69687" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/usr/lib</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/usr/lib</target>
        </trans-unit>
        <trans-unit id="710f2aaaa57ae08947b2914f307083f5ba6ecc46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;end_column&lt;/var&gt;: column in the source file where the function ends</source>
          <target state="translated">&lt;var&gt;end_column&lt;/var&gt; : столбец в исходном файле, где заканчивается функция</target>
        </trans-unit>
        <trans-unit id="77d6abb0099a7849ef1e3e17b19f0755409a5b5e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;end_line&lt;/var&gt;: line in the source file where the function ends</source>
          <target state="translated">&lt;var&gt;end_line&lt;/var&gt; : строка в исходном файле, где заканчивается функция</target>
        </trans-unit>
        <trans-unit id="bcfb310dcf9e58743c432d6bf3a973817fa1a1e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;execution_count&lt;/var&gt;: number of executions of the function</source>
          <target state="translated">&lt;var&gt;execution_count&lt;/var&gt; : количество выполнений функции</target>
        </trans-unit>
        <trans-unit id="07ced02e11442bdc9f19c2804e52ff736e36f64b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fallthrough&lt;/var&gt;: true when the branch is a fall through branch</source>
          <target state="translated">&lt;var&gt;fallthrough&lt;/var&gt; : истина, если ветвь проваливается</target>
        </trans-unit>
        <trans-unit id="cb068146736527c3f97548042cc209e45a84344b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fieldname&lt;/var&gt;:</source>
          <target state="translated">&lt;var&gt;fieldname&lt;/var&gt;:</target>
        </trans-unit>
        <trans-unit id="bc0ca9277beb7ce53874c5a6ea975087cabd0480" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.&lt;var&gt;passid&lt;/var&gt;.&lt;var&gt;pass&lt;/var&gt;.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.&lt;var&gt;passid&lt;/var&gt;.&lt;var&gt;pass&lt;/var&gt;.dot</target>
        </trans-unit>
        <trans-unit id="185fc61cbdabdd77db10b2b0b60581412f88344f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.analyzer.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.analyzer.txt</target>
        </trans-unit>
        <trans-unit id="355dc9a2a93abc7e552de9fc5978fd259683b69a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.callgraph.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.callgraph.dot</target>
        </trans-unit>
        <trans-unit id="aa2d0b0a626af00705d11416adb8472a02b85335" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg-&lt;var&gt;id&lt;/var&gt;.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg-&lt;var&gt;id&lt;/var&gt;.txt</target>
        </trans-unit>
        <trans-unit id="d51037b1808ab0ab68cf2854624577a0a2363a83" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg.dot</target>
        </trans-unit>
        <trans-unit id="e8c4ee87a95529e92014956c101d08d19626272a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg.txt</target>
        </trans-unit>
        <trans-unit id="434eff9a292fff30f74330fc896652b1272e4265" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.state-purge.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.state-purge.dot</target>
        </trans-unit>
        <trans-unit id="e948a9213200b3530a25cdb5e96fc8a614d0ac69" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.supergraph-eg.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.supergraph-eg.dot</target>
        </trans-unit>
        <trans-unit id="36dd403968851ab1e3b90f91ed5b921efca47df1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.supergraph.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.supergraph.dot</target>
        </trans-unit>
        <trans-unit id="e36ec986d0d68718176ac505f37684283543d3d9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;&lt;var&gt;target&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;&lt;var&gt;target&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="8ec94309621d2424e899ea1b78e55daad7870d18" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file_name&lt;/var&gt;: name of the source file</source>
          <target state="translated">&lt;var&gt;file_name&lt;/var&gt; : имя исходного файла</target>
        </trans-unit>
        <trans-unit id="cd6f65bdf191a64aaefc5c263459a6f075adc163" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt; automatically implies</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; автоматически подразумевает</target>
        </trans-unit>
        <trans-unit id="70afe026807a5e12e476985ab37efbc5dc26d077" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt; does not imply anything.</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; ничего не подразумевает.</target>
        </trans-unit>
        <trans-unit id="46fba837f5408f9512a6c400d555a520081bdffd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt;. However,</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; . Тем не мение,</target>
        </trans-unit>
        <trans-unit id="705042d186415d378755a17325dbc0219d4372f1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;format_version&lt;/var&gt;: semantic version of the format</source>
          <target state="translated">&lt;var&gt;format_version&lt;/var&gt; : семантическая версия формата</target>
        </trans-unit>
        <trans-unit id="58bfbaccb373a1af2e15a00fe6b5acf8e46f5efd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function_name&lt;/var&gt;: a name of a function this &lt;var&gt;line&lt;/var&gt; belongs to (for a line with an inlined statements can be not set)</source>
          <target state="translated">&lt;var&gt;function_name&lt;/var&gt; : имя функции, к которой принадлежит эта &lt;var&gt;line&lt;/var&gt; (для строки со встроенными операторами не может быть установлено)</target>
        </trans-unit>
        <trans-unit id="7150cb8c780083943181393bffe3746be197596d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;gcc_version&lt;/var&gt;: version of the GCC compiler</source>
          <target state="translated">&lt;var&gt;gcc_version&lt;/var&gt; : версия компилятора GCC</target>
        </trans-unit>
        <trans-unit id="ae44b540bd27d10c4dc7e21db41478a671658ee6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;kind&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;kind&lt;/var&gt; '</target>
        </trans-unit>
        <trans-unit id="8b8203cf510dcd89888a7c10446ebe87c2f89369" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;libexecdir&lt;/var&gt;/gcc/&lt;var&gt;target&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/install-tools/</source>
          <target state="translated">&lt;var&gt;libexecdir&lt;/var&gt;/gcc/&lt;var&gt;target&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/install-tools/</target>
        </trans-unit>
        <trans-unit id="7e28a7ea5e6f3cd24974425a7e272dd6dab22c97" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;line_number&lt;/var&gt;: line number</source>
          <target state="translated">&lt;var&gt;line_number&lt;/var&gt; : номер строки</target>
        </trans-unit>
        <trans-unit id="ea29079cba4e83858223a5ec28bdc6d50bd316b0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;machine&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/</source>
          <target state="translated">&lt;var&gt;machine&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/</target>
        </trans-unit>
        <trans-unit id="fb87e55fd40c286be395999f14a4dc6d95b10b8e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;mangledname&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;mangledname&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="f0ce3ea44130cbe877829294966ed36eef7f62f7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;mode&lt;/var&gt; can be set to one the following values:</source>
          <target state="translated">&lt;var&gt;mode&lt;/var&gt; может быть установлен на одно из следующих значений:</target>
        </trans-unit>
        <trans-unit id="0b1b3ce355abf1bec528e4e29cb69b648d32b2c3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f</target>
        </trans-unit>
        <trans-unit id="2956846802a0f3763419f1cd6721396729e2240a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f1_1</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f1_1</target>
        </trans-unit>
        <trans-unit id="d0f528c5f50a3a9ca8a7f4d4becb651762709fc6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f2_1</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f2_1</target>
        </trans-unit>
        <trans-unit id="a64a9113e49c525ccc4593f4075479691d2d779c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f3_2</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f3_2</target>
        </trans-unit>
        <trans-unit id="0f1c1c81fa999d2f5ca3d601e651ccc54a89eb03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;x</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;x</target>
        </trans-unit>
        <trans-unit id="8e4ffce74a745b869371f4d5e4b25a511464db80" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;: name of the function</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; : имя функции</target>
        </trans-unit>
        <trans-unit id="97651fa5ce5e8856932bddb384b35a32ca248309" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;number&lt;/var&gt; can only be 1 or 2. If it is 1 then branches are preferred over conditional code, if it is 2, then the opposite applies.</source>
          <target state="translated">&lt;var&gt;number&lt;/var&gt; может быть только 1 или 2. Если это 1, то ветви предпочтительнее условного кода, если это 2, то применяется противоположное.</target>
        </trans-unit>
        <trans-unit id="50273f37f0b45fd83f80ed0fdeed8ef68524af4d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="d0ce734a96f9558ae28efb50ac75200764dc9df5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;path&lt;/var&gt; is the name of a file containing AutoFDO profile information. If omitted, it defaults to</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; - это имя файла, содержащего информацию профиля AutoFDO. Если опущено, по умолчанию используется</target>
        </trans-unit>
        <trans-unit id="5fc499cb4d5dfe67bd81e09d65c41f73e48f4073" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;path&lt;/var&gt; with &lt;var&gt;path&lt;/var&gt; pointing to the base directory of the build can be used to strip the irrelevant part of the path and keep all file names relative to the main build directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a043823197d8a0d9d4a3dae48ce610f7a8479fd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;/lib/gcc/</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;/lib/gcc/</target>
        </trans-unit>
        <trans-unit id="75da58a5824259553dc7e89b6ec73fadaabdf8c6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;profile_dir&lt;/var&gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ed21f74315a592f7dd2bab8ba025f5ae695175" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;profile_dir&lt;/var&gt; to inform GCC where is the base directory of built source tree. By default &lt;var&gt;profile_dir&lt;/var&gt; will contain files with mangled absolute paths of all object files in the built project. This is not desirable when directory used to build the instrumented binary differs from the directory used to build the binary optimized with profile feedback because the profile data will not be found during the optimized build. In such setups</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575dfa2a337b4bc21315c8f8022717c452a4ae62" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;ptr&lt;/var&gt; is an optional pointer to the object that may be used to determine alignment. A value of 0 indicates typical alignment should be used. The compiler may also ignore this parameter.</source>
          <target state="translated">&lt;var&gt;ptr&lt;/var&gt; - это необязательный указатель на объект, который может использоваться для определения выравнивания. Значение 0 указывает на то, что следует использовать типичное выравнивание. Компилятор также может игнорировать этот параметр.</target>
        </trans-unit>
        <trans-unit id="8b3c5b36be47a0fa932bdb61b7a90e0c4902fd51" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;real&lt;/var&gt; + I * &lt;var&gt;imag&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;real&lt;/var&gt; + я * &lt;var&gt;imag&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="444cf69e0e22b51ba0c19cf554accc4728339634" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reg&lt;/var&gt; must be the name of a register. The register names accepted are machine-specific and are defined in the &lt;code&gt;REGISTER_NAMES&lt;/code&gt; macro in the machine description macro file.</source>
          <target state="translated">&lt;var&gt;reg&lt;/var&gt; должно быть именем реестра. Допустимые имена регистров зависят от машины и определяются в макросе &lt;code&gt;REGISTER_NAMES&lt;/code&gt; в файле макроса описания машины.</target>
        </trans-unit>
        <trans-unit id="9fe1c0acef9a1d0caebcd87a22d3dc35ad3b0448" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source-file&lt;/var&gt;##&lt;var&gt;md5&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;source-file&lt;/var&gt;##&lt;var&gt;md5&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="b880a9e002b5a8cc6ab8e5b60ed026a3bd7b4c0f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="c61509b5e229f01a21d510673ed3415523a72145" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;.gch</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;.gch</target>
        </trans-unit>
        <trans-unit id="70db49065f5eba9055c8c455ae0994a97a7b0ff7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.o</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.o</target>
        </trans-unit>
        <trans-unit id="4b7c7cc9bc07a7bc8b59a106fc41bf34e5bc1bce" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.s</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.s</target>
        </trans-unit>
        <trans-unit id="a72234cee5f73a88a10f2c471d34f2876066e0e2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcefile&lt;/var&gt;.c</source>
          <target state="translated">&lt;var&gt;sourcefile&lt;/var&gt;.c</target>
        </trans-unit>
        <trans-unit id="fca90e9a21f6a50975b13af845d218e0a2f371d9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcefile&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;sourcefile&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="d01d6365317d600e2664fe58c60f8e16adc09101" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcename&lt;/var&gt;.decl</source>
          <target state="translated">&lt;var&gt;sourcename&lt;/var&gt;.decl</target>
        </trans-unit>
        <trans-unit id="273491f96586620c37b4be341e04ca0866ba515f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcename&lt;/var&gt;.gcda</source>
          <target state="translated">&lt;var&gt;sourcename&lt;/var&gt;.gcda</target>
        </trans-unit>
        <trans-unit id="b7a20df9ca0090865388e1ede1a8c313cfa2ec03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start_column&lt;/var&gt;: column in the source file where the function begins</source>
          <target state="translated">&lt;var&gt;start_column&lt;/var&gt; : столбец в исходном файле, где начинается функция</target>
        </trans-unit>
        <trans-unit id="3305d67073def22b0281ddc5b0ab6b21190df394" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start_line&lt;/var&gt;: line in the source file where the function begins</source>
          <target state="translated">&lt;var&gt;start_line&lt;/var&gt; : строка в исходном файле, где начинается функция</target>
        </trans-unit>
        <trans-unit id="cb4cfaac038ae456ad73674888cd5dee273bede8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;startfile&lt;/var&gt; is the file name of the startfile (crt0) to use when linking. This option is only useful in conjunction with</source>
          <target state="translated">&lt;var&gt;startfile&lt;/var&gt; - это имя файла startfile (crt0), которое будет использоваться при компоновке. Эта опция полезна только в сочетании с</target>
        </trans-unit>
        <trans-unit id="92e2c1df29e70248323ce9841f5738d40e347e46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;state&lt;/var&gt; configure option.</source>
          <target state="translated">&lt;var&gt;state&lt;/var&gt; параметр конфигурации состояния .</target>
        </trans-unit>
        <trans-unit id="956c0d57ed11241cf2af6705b81cf132c79d5cf4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;string&lt;/var&gt; may be parenthesized, and is printed with location information. For example,</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; может быть заключена в круглые скобки и печатается с информацией о местоположении. Например,</target>
        </trans-unit>
        <trans-unit id="9eedc4fd2f60aed10814958a1668c96d1c3d2760" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;style&lt;/var&gt; is either &lt;code&gt;c11&lt;/code&gt; or &lt;code&gt;ts-18661-3&lt;/code&gt; as appropriate.</source>
          <target state="translated">&lt;var&gt;style&lt;/var&gt; - &lt;code&gt;c11&lt;/code&gt; или &lt;code&gt;ts-18661-3&lt;/code&gt; , в зависимости от ситуации.</target>
        </trans-unit>
        <trans-unit id="756b0ec3e68649366cd0150c58c2eabc74fb8d54" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;systemlib&lt;/var&gt; is the library name of the library that provides low-level system calls required by the C library, e.g. &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt;. This option is typically used to link with a library provided by a HAL BSP.</source>
          <target state="translated">&lt;var&gt;systemlib&lt;/var&gt; - это имя библиотеки, которая обеспечивает низкоуровневые системные вызовы, требуемые библиотекой C, например &lt;code&gt;read&lt;/code&gt; и &lt;code&gt;write&lt;/code&gt; . Эта опция обычно используется для линковки с библиотекой, предоставляемой HAL BSP.</target>
        </trans-unit>
        <trans-unit id="f3b5c58dcaf93cade01b7328b68fe8d4178ba8da" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;throw&lt;/var&gt;: true when the branch is an exceptional branch</source>
          <target state="translated">&lt;var&gt;throw&lt;/var&gt; : true, если ветвь является исключительной.</target>
        </trans-unit>
        <trans-unit id="745e86448be042dc8edebfc034c56ccccf38a979" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;type&lt;/var&gt; is an integer constant from 0 to 3. If the least significant bit is clear, objects are whole variables, if it is set, a closest surrounding subobject is considered the object a pointer points to. The second bit determines if maximum or minimum of remaining bytes is computed.</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; - целочисленная константа от 0 до 3. Если младший бит не задан, объекты являются целыми переменными, если он установлен, ближайший окружающий подобъект считается объектом, на который указывает указатель. Второй бит определяет, вычисляется ли максимальное или минимальное количество оставшихся байтов.</target>
        </trans-unit>
        <trans-unit id="342fc24f28a056e632a0b35fb86b8d4dd73bc946" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;unexecuted_block&lt;/var&gt;: flag whether the line contains an unexecuted block (not all statements on the line are executed)</source>
          <target state="translated">&lt;var&gt;unexecuted_block&lt;/var&gt; : отметьте , содержит ли строка неисполненный блок (выполняются не все операторы в строке)</target>
        </trans-unit>
        <trans-unit id="6049c35e012365c54216cf4865563ff7b5c3b373" translate="yes" xml:space="preserve">
          <source>=&lt;var&gt;filename&lt;/var&gt;</source>
          <target state="translated">=&lt;var&gt;filename&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="46f10d3b2f96391f996a860a29e922307def05f4" translate="yes" xml:space="preserve">
          <source>=@cc&lt;var&gt;cond&lt;/var&gt;</source>
          <target state="translated">=@cc&lt;var&gt;cond&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2481fc6ffc2fbe4f98d31256e625358325756148" translate="yes" xml:space="preserve">
          <source>=f</source>
          <target state="translated">=f</target>
        </trans-unit>
        <trans-unit id="900f8b38b05989605df65663e5e3869aab5eb789" translate="yes" xml:space="preserve">
          <source>? :</source>
          <target state="translated">? :</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="7025e1843ee6104f357de4a85f21b2b545cac788" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;stable&amp;rdquo; memory operand; that is, one which does not include any automodification of the base register. This used to be useful when &amp;lsquo;</source>
          <target state="translated">&amp;laquo;Стабильный&amp;raquo; операнд памяти; то есть тот, который не включает никаких автоматических модификаций базового регистра. Раньше это было полезно, когда '</target>
        </trans-unit>
        <trans-unit id="b2a6e604c21235a8a2cf39c25b6821bfb403a2f9" translate="yes" xml:space="preserve">
          <source>A 10-bit signed constant (-512 &amp;hellip; 511)</source>
          <target state="translated">10-битная константа со знаком (-512&amp;hellip; 511)</target>
        </trans-unit>
        <trans-unit id="576737d0097b50a261308a427b2851f9873b4e96" translate="yes" xml:space="preserve">
          <source>A 16 bit value with exactly one bit set.</source>
          <target state="translated">Значение 16 бит с точностью до одного бита.</target>
        </trans-unit>
        <trans-unit id="91a340944b7c5084f9cb17cdbbc4b3cfd1b6b8d2" translate="yes" xml:space="preserve">
          <source>A 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">16-битный фрагмент got,tls или pc-реляционной ссылки.</target>
        </trans-unit>
        <trans-unit id="9d079cc97fa73a6ab6e8c28d5a00eebc59ab7c45" translate="yes" xml:space="preserve">
          <source>A 16-bit signed constant (-32768 &amp;hellip; 32767)</source>
          <target state="translated">16-битная константа со знаком (-32768&amp;hellip; 32767)</target>
        </trans-unit>
        <trans-unit id="600f9da68b2b8b3eca45f28f2690b3c739522b91" translate="yes" xml:space="preserve">
          <source>A 16-bit unsigned constant, multiple of 4 (0 &amp;hellip; 65532)</source>
          <target state="translated">16-битная беззнаковая константа, кратная 4 (0&amp;hellip; 65532)</target>
        </trans-unit>
        <trans-unit id="626d08e653ff5fead00da4b2ae1ffdf55de25ac2" translate="yes" xml:space="preserve">
          <source>A 2-element vector constant with identical elements.</source>
          <target state="translated">2-элементная векторная константа с идентичными элементами.</target>
        </trans-unit>
        <trans-unit id="199076609694aaa8dd531a498d6bd24d81a6cc20" translate="yes" xml:space="preserve">
          <source>A 20-bit signed constant (-524288 &amp;hellip; 524287)</source>
          <target state="translated">20-битная константа со знаком (-524288&amp;hellip; 524287)</target>
        </trans-unit>
        <trans-unit id="739e9c986b6796272b083980b6406cba9cf05af2" translate="yes" xml:space="preserve">
          <source>A 3-bit unsigned integer constant.</source>
          <target state="translated">3-битная беззнаковая целочисленная константа.</target>
        </trans-unit>
        <trans-unit id="8d9d9ff6786b090797685cfe7290aeace549fb2c" translate="yes" xml:space="preserve">
          <source>A 4-element vector constant with identical elements.</source>
          <target state="translated">4-элементная векторная константа с идентичными элементами.</target>
        </trans-unit>
        <trans-unit id="809cfd342c5778cebf932a5fb2090f41ac0b8050" translate="yes" xml:space="preserve">
          <source>A 5-bit unsigned immediate for CSR access instructions.</source>
          <target state="translated">5-битный неподписанный немедленный доступ к инструкциям по доступу к CSR.</target>
        </trans-unit>
        <trans-unit id="7a0f592094ae133e28a83db08acb3ad80aaa8c6b" translate="yes" xml:space="preserve">
          <source>A 5-bit unsigned integer constant.</source>
          <target state="translated">5-битная беззнаковая целочисленная константа.</target>
        </trans-unit>
        <trans-unit id="2a19359a80d0f6de7d964e539759745df3e07113" translate="yes" xml:space="preserve">
          <source>A 6-bit unsigned integer constant.</source>
          <target state="translated">6-битная беззнаковая целочисленная константа.</target>
        </trans-unit>
        <trans-unit id="4a1d6a6dcc128bafb39f6e3e6579f2614ede9096" translate="yes" xml:space="preserve">
          <source>A 7-bit unsigned integer constant.</source>
          <target state="translated">7-битная беззнаковая целочисленная константа.</target>
        </trans-unit>
        <trans-unit id="4e392016af47c374eef4f8aaf14822a0c557c367" translate="yes" xml:space="preserve">
          <source>A 8-bit unsigned integer constant.</source>
          <target state="translated">8-битная беззнаковая целочисленная константа.</target>
        </trans-unit>
        <trans-unit id="083fa44b7c5e44320ff4ed2ae01244ea90801a78" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;lo_sum&lt;/code&gt; data-linkage-table memory operand</source>
          <target state="translated">&lt;code&gt;lo_sum&lt;/code&gt; операнд данных связь стол памяти</target>
        </trans-unit>
        <trans-unit id="f9cd2e27d673f56cc94424aa5ac780102659b79a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;switch&lt;/code&gt; statement has an operand of type &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; оператор имеет операнд типа &lt;code&gt;long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0eff00ac09b6d2be5766ddb9515db21e223caed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typeof&lt;/code&gt; construct can be used anywhere a typedef name can be used. For example, you can use it in a declaration, in a cast, or inside of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; конструкция может быть использована везде , где ЬурейеЕ имя может быть использовано. Например, вы можете использовать его в объявлении, в приведении или внутри &lt;code&gt;sizeof&lt;/code&gt; или &lt;code&gt;typeof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fcc11ba29659026ef90972ee49fd236e8ca7461" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;nested function&lt;/em&gt; is a function defined inside another function. Nested functions are supported as an extension in GNU C, but are not supported by GNU C++.</source>
          <target state="translated">&lt;em&gt;Вложенная функция&lt;/em&gt; является функцией , определенной внутри другой функции. Вложенные функции поддерживаются как расширение в GNU C, но не поддерживаются в GNU C ++.</target>
        </trans-unit>
        <trans-unit id="c55a5d7e9e734b9cfd6d5b793b74655af96e5ff3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;preprocessing token&lt;/em&gt; is a &lt;em&gt;preprocessing number&lt;/em&gt; if it begins with a digit and is followed by letters, underscores, digits, periods and &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Предварительная обработка лексемы&lt;/em&gt; является &lt;em&gt;предобработкой числа&lt;/em&gt; , если оно начинается с цифрой и следует буквы, подчеркивание, цифры, периоды и '</target>
        </trans-unit>
        <trans-unit id="226cffe8593eab9de1b46a1badbfea96e62ee6f4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread&lt;/em&gt; is a flow of control within the abstract machine. It is implementation defined whether or not there may be more than one thread.</source>
          <target state="translated">&lt;em&gt;Поток&lt;/em&gt; представляет собой поток управления в пределах абстрактной машины. Реализация определяет, может ли быть более одного потока.</target>
        </trans-unit>
        <trans-unit id="d63439749e9d375a44c13be44c44d3b25a8cbdd3" translate="yes" xml:space="preserve">
          <source>A C++ namespace declaration can also have the visibility attribute.</source>
          <target state="translated">Объявление пространства имён C++также может иметь атрибут видимости.</target>
        </trans-unit>
        <trans-unit id="f6e3cb01289f372ad5685f7b48da04f4e60a84ec" translate="yes" xml:space="preserve">
          <source>A GNU Manual</source>
          <target state="translated">Руководство GNU</target>
        </trans-unit>
        <trans-unit id="e5ae31d72b84a280dea45cc026a21e380e65748b" translate="yes" xml:space="preserve">
          <source>A VSX register (VSR), &lt;code&gt;vs0&lt;/code&gt;&amp;hellip;&lt;code&gt;vs63&lt;/code&gt;. This is either an FPR (&lt;code&gt;vs0&lt;/code&gt;&amp;hellip;&lt;code&gt;vs31&lt;/code&gt; are &lt;code&gt;f0&lt;/code&gt;&amp;hellip;&lt;code&gt;f31&lt;/code&gt;) or a VR (&lt;code&gt;vs32&lt;/code&gt;&amp;hellip;&lt;code&gt;vs63&lt;/code&gt; are &lt;code&gt;v0&lt;/code&gt;&amp;hellip;&lt;code&gt;v31&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5003442624da7a5396a336fd4ef339c3db6eb07" translate="yes" xml:space="preserve">
          <source>A base register. Like &lt;code&gt;r&lt;/code&gt;, but &lt;code&gt;r0&lt;/code&gt; is not allowed, so &lt;code&gt;r1&lt;/code&gt;&amp;hellip;&lt;code&gt;r31&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8fd98a94ad304e430ad561d03982387ab58fa2" translate="yes" xml:space="preserve">
          <source>A basic &lt;code&gt;asm&lt;/code&gt; statement has the following syntax:</source>
          <target state="translated">Базовая инструкция &lt;code&gt;asm&lt;/code&gt; имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="6145aa4e1e7149a673e61fa6c454fd8a42cee7a8" translate="yes" xml:space="preserve">
          <source>A basic block profile count is considered hot if it contributes to the given permillage (i.e. 0...1000) of the entire profiled execution.</source>
          <target state="translated">Профиль основного блока считается горячим,если он вносит вклад в заданную пропускную способность (т.е.0...1000)всего профилированного исполнения.</target>
        </trans-unit>
        <trans-unit id="2df3f34d53b76011b7a6bb1711d67e1df403856d" translate="yes" xml:space="preserve">
          <source>A binary type trait: &lt;code&gt;true&lt;/code&gt; whenever the type arguments are the same.</source>
          <target state="translated">Признак двоичного типа: &lt;code&gt;true&lt;/code&gt; , если аргументы типа совпадают.</target>
        </trans-unit>
        <trans-unit id="61a474d3c8a798ad9f41fbc155178fa260c3cbfd" translate="yes" xml:space="preserve">
          <source>A bit mask suitable for the BFINS instruction.</source>
          <target state="translated">Битовая маска,подходящая для инструкции BFINS.</target>
        </trans-unit>
        <trans-unit id="1c197853a26bb6b9e64cfe3c20fc4b78dab065a2" translate="yes" xml:space="preserve">
          <source>A bit mask suitable for the MM instruction.</source>
          <target state="translated">Битовая маска,подходящая для инструкции MM.</target>
        </trans-unit>
        <trans-unit id="fb82d601263ede6336b3a6d38f27a2db288988de" translate="yes" xml:space="preserve">
          <source>A bitfield mask suitable for bext or bins</source>
          <target state="translated">Маска битфилда,подходящая для битфилда или мусорного контейнера.</target>
        </trans-unit>
        <trans-unit id="95088444b66d4c9478cf588a65f1dca5aa3b6e35" translate="yes" xml:space="preserve">
          <source>A c99-like declaration syntax is also allowed:</source>
          <target state="translated">Допускается также синтаксис декларации c99:</target>
        </trans-unit>
        <trans-unit id="242045c1091165567c1e2bc6642eff026733baf4" translate="yes" xml:space="preserve">
          <source>A call clobbered P register.</source>
          <target state="translated">Звонок забил Р-образный регистр.</target>
        </trans-unit>
        <trans-unit id="6501e67efab2f7c858c0e0f7b446cd704c13a388" translate="yes" xml:space="preserve">
          <source>A call-used register in register file B (B0&amp;ndash;B9, B16&amp;ndash;B31).</source>
          <target state="translated">Регистр использованного вызова в регистровом файле B (B0 &amp;ndash; B9, B16 &amp;ndash; B31).</target>
        </trans-unit>
        <trans-unit id="5a85a53751233b51746da27b56a87b1a58dd44bc" translate="yes" xml:space="preserve">
          <source>A cast from integer to pointer discards most-significant bits if the pointer representation is smaller than the integer type, extends according to the signedness of the integer type if the pointer representation is larger than the integer type, otherwise the bits are unchanged.</source>
          <target state="translated">При приведении от целого к указателю отбрасываются самые незначительные биты,если представление указателя меньше целочисленного типа,расширяется в соответствии со знаком целочисленного типа,если представление указателя больше целочисленного типа,в противном случае биты остаются неизменными.</target>
        </trans-unit>
        <trans-unit id="9579e92267fbbcb00a411d24c34a20ac82cffc52" translate="yes" xml:space="preserve">
          <source>A cast from pointer to integer discards most-significant bits if the pointer representation is larger than the integer type, sign-extends&lt;a href=&quot;#FOOT2&quot; id=&quot;DOCF2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; if the pointer representation is smaller than the integer type, otherwise the bits are unchanged.</source>
          <target state="translated">Приведение указателя к целому числу отбрасывает наиболее значимые биты, если представление указателя больше, чем целочисленный тип, знак расширяет &lt;a href=&quot;#FOOT2&quot; id=&quot;DOCF2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2,&lt;/sup&gt;&lt;/a&gt; если представление указателя меньше целочисленного типа, в противном случае биты не изменяются.</target>
        </trans-unit>
        <trans-unit id="8d607e1d6022f86c3f2fb0150398c8747d6a9a20" translate="yes" xml:space="preserve">
          <source>A cast to a union type is a C extension not available in C++. It looks just like ordinary casts with the constraint that the type specified is a union type. You can specify the type either with the &lt;code&gt;union&lt;/code&gt; keyword or with a &lt;code&gt;typedef&lt;/code&gt; name that refers to a union. The result of a cast to a union is a temporary rvalue of the union type with a member whose type matches that of the operand initialized to the value of the operand. The effect of a cast to a union is similar to a compound literal except that it yields an rvalue like standard casts do. See &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt;.</source>
          <target state="translated">Приведение к типу объединения - это расширение C, недоступное в C ++. Это похоже на обычное приведение типов с ограничением, что указанный тип является типом объединения. Вы можете указать тип либо с помощью ключевого слова &lt;code&gt;union&lt;/code&gt; , либо с именем &lt;code&gt;typedef&lt;/code&gt; , которое относится к объединению. Результатом приведения к объединению является временное r-значение типа объединения с членом, тип которого совпадает с типом операнда, инициализированного значением операнда. Эффект приведения к объединению аналогичен составному литералу, за исключением того, что он возвращает rvalue, как и стандартные приведения. См. &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Составные литералы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75e1479f2ae72adba50e5d40e09a4fb8d576ce4d" translate="yes" xml:space="preserve">
          <source>A combination of</source>
          <target state="translated">Сочетание</target>
        </trans-unit>
        <trans-unit id="de7ce58153dc3aa9a8a53f607567323d0809bd31" translate="yes" xml:space="preserve">
          <source>A comma-separated list of C expressions read by the instructions in the &lt;var&gt;AssemblerTemplate&lt;/var&gt;. An empty list is permitted. See &lt;a href=&quot;#InputOperands&quot;&gt;InputOperands&lt;/a&gt;.</source>
          <target state="translated">Список выражений C, разделенных запятыми, считываемых инструкциями в &lt;var&gt;AssemblerTemplate&lt;/var&gt; . Пустой список разрешен. См. &lt;a href=&quot;#InputOperands&quot;&gt;InputOperands&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b5d944665cc53cab2f2ad1f645c434c5620d068" translate="yes" xml:space="preserve">
          <source>A comma-separated list of registers or other values changed by the &lt;var&gt;AssemblerTemplate&lt;/var&gt;, beyond those listed as outputs. An empty list is permitted. See &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;.</source>
          <target state="translated">Разделенный запятыми список регистров или других значений, измененных &lt;var&gt;AssemblerTemplate&lt;/var&gt; , помимо тех, которые указаны в качестве выходных. Пустой список разрешен. Смотрите &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers и Scratch Registers&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65d21196a0c3e5a9f693ae19ae22931182555110" translate="yes" xml:space="preserve">
          <source>A comma-separated list of the C variables modified by the instructions in the &lt;var&gt;AssemblerTemplate&lt;/var&gt;. An empty list is permitted. See &lt;a href=&quot;#OutputOperands&quot;&gt;OutputOperands&lt;/a&gt;.</source>
          <target state="translated">Список переменных C, разделенных запятыми, измененных инструкциями в &lt;var&gt;AssemblerTemplate&lt;/var&gt; . Пустой список разрешен. Смотрите &lt;a href=&quot;#OutputOperands&quot;&gt;OutputOperands&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57ff1562fe61f1f887425ce2cee86f1d3d93e844" translate="yes" xml:space="preserve">
          <source>A compiler conforms to an ABI if it generates code that follows all of the specifications enumerated by that ABI. A library conforms to an ABI if it is implemented according to that ABI. An application conforms to an ABI if it is built using tools that conform to that ABI and does not contain source code that specifically changes behavior specified by the ABI.</source>
          <target state="translated">Компилятор соответствует ABI,если он генерирует код,который следует всем спецификациям,перечисленным этим ABI.Библиотека соответствует ABI,если она реализована в соответствии с этим ABI.Приложение соответствует ABI,если оно собрано с использованием инструментов,соответствующих этому ABI,и не содержит исходного кода,который специально изменяет поведение,заданное ABI.</target>
        </trans-unit>
        <trans-unit id="41c80a94e954da6243e86405854638e4aa3a6477" translate="yes" xml:space="preserve">
          <source>A compound literal looks like a cast of a brace-enclosed aggregate initializer list. Its value is an object of the type specified in the cast, containing the elements specified in the initializer. Unlike the result of a cast, a compound literal is an lvalue. ISO C99 and later support compound literals. As an extension, GCC supports compound literals also in C90 mode and in C++, although as explained below, the C++ semantics are somewhat different.</source>
          <target state="translated">Буквальный состав выглядит как литье из прилагаемого к скобке списка инициализаторов.Его значение-это объект типа,указанного в заливке,содержащий элементы,указанные в инициализаторе.В отличие от результата литья,составной литерал-это значение.ISO C99 и последующие поддерживают составные литералы.В качестве расширения GCC поддерживает составные литералы также в режиме C90 и в C++,хотя,как поясняется ниже,семантика C++несколько отличается.</target>
        </trans-unit>
        <trans-unit id="f6dd9a1a8f56216b2f65e6b7a8c29b8ee8f55106" translate="yes" xml:space="preserve">
          <source>A compound statement enclosed in parentheses may appear as an expression in GNU C. This allows you to use loops, switches, and local variables within an expression.</source>
          <target state="translated">Составное выражение,заключенное в круглые скобки,может появиться как выражение в GNU C.Это позволяет вам использовать циклы,переключатели и локальные переменные в выражении.</target>
        </trans-unit>
        <trans-unit id="8a72443d4592827fe4ca85bea82301121049b91e" translate="yes" xml:space="preserve">
          <source>A conforming implementation of ISO C is required to document its choice of behavior in each of the areas that are designated &amp;ldquo;implementation defined&amp;rdquo;. The following lists all such areas, along with the section numbers from the ISO/IEC 9899:1990, ISO/IEC 9899:1999 and ISO/IEC 9899:2011 standards. Some areas are only implementation-defined in one version of the standard.</source>
          <target state="translated">Соответствующая реализация ISO C требуется для документирования своего выбора поведения в каждой из областей, обозначенных как &amp;laquo;определение реализации&amp;raquo;. Ниже перечислены все такие области, а также номера разделов из стандартов ISO / IEC 9899: 1990, ISO / IEC 9899: 1999 и ISO / IEC 9899: 2011. Некоторые области определены реализацией только в одной версии стандарта.</target>
        </trans-unit>
        <trans-unit id="d4cb4e2bf524da1d62affddb40dfb630800239af" translate="yes" xml:space="preserve">
          <source>A conforming implementation of ISO C++ is required to document its choice of behavior in each of the areas that are designated &amp;ldquo;implementation defined&amp;rdquo;. The following lists all such areas, along with the section numbers from the ISO/IEC 14882:1998 and ISO/IEC 14882:2003 standards. Some areas are only implementation-defined in one version of the standard.</source>
          <target state="translated">Соответствующая реализация ISO C ++ требуется для документирования своего выбора поведения в каждой из областей, обозначенных как &amp;laquo;определение реализации&amp;raquo;. Ниже перечислены все такие области, а также номера разделов из стандартов ISO / IEC 14882: 1998 и ISO / IEC 14882: 2003. Некоторые области определены реализацией только в одной версии стандарта.</target>
        </trans-unit>
        <trans-unit id="7b29cb3b319ec95ede4a30707c842823bf94b7db" translate="yes" xml:space="preserve">
          <source>A consequence of this is that &lt;code&gt;sizeof&lt;/code&gt; is also allowed on &lt;code&gt;void&lt;/code&gt; and on function types, and returns 1.</source>
          <target state="translated">Следствием этого является то, что &lt;code&gt;sizeof&lt;/code&gt; также разрешен для типов &lt;code&gt;void&lt;/code&gt; и функций и возвращает 1.</target>
        </trans-unit>
        <trans-unit id="7cad9a0baf039ead351d859d05c0365e63661fb9" translate="yes" xml:space="preserve">
          <source>A constant between -255 and 0 inclusive.</source>
          <target state="translated">Константа между -255 и 0 включительно.</target>
        </trans-unit>
        <trans-unit id="4f8cd8bf499f2d6d54a71ffc2d3e21cf7ef45e36" translate="yes" xml:space="preserve">
          <source>A constant between -3 and 0 inclusive.</source>
          <target state="translated">Константа между -3 и 0 включительно.</target>
        </trans-unit>
        <trans-unit id="19428213d0a5f62ee0574191f3ae2f2ddd996015" translate="yes" xml:space="preserve">
          <source>A constant between -4 and -1 inclusive.</source>
          <target state="translated">Константа между -4 и -1 включительно.</target>
        </trans-unit>
        <trans-unit id="d2fbc8414f61903ae333dcf7ac7a844a0c7b23fe" translate="yes" xml:space="preserve">
          <source>A constant between 0 and 255 inclusive.</source>
          <target state="translated">Константа между 0 и 255 включительно.</target>
        </trans-unit>
        <trans-unit id="12f6b4cb352959b8bca5dac3da05fd53e64fa274" translate="yes" xml:space="preserve">
          <source>A constant between 0 and 3 inclusive.</source>
          <target state="translated">Константа между 0 и 3 включительно.</target>
        </trans-unit>
        <trans-unit id="da945b1c391dff3ac6bc6d5fbd2be9149c62266c" translate="yes" xml:space="preserve">
          <source>A constant between 1 and 4 inclusive.</source>
          <target state="translated">Константа между 1 и 4 включительно.</target>
        </trans-unit>
        <trans-unit id="c0aca6087bfc1e63cba0551e38002443555e0fac" translate="yes" xml:space="preserve">
          <source>A constant for a bitfield width (1 &amp;hellip; 16)</source>
          <target state="translated">Константа для ширины битового поля (1&amp;hellip; 16)</target>
        </trans-unit>
        <trans-unit id="6d56856d82b6a91412eed6d7df5c640079002d4d" translate="yes" xml:space="preserve">
          <source>A constant in the range -128 to 127, inclusive.</source>
          <target state="translated">Константа в диапазоне от -128 до 127 включительно.</target>
        </trans-unit>
        <trans-unit id="17b05b4c60ac27d1e72d8030837136d5fa0be31c" translate="yes" xml:space="preserve">
          <source>A constant in the range -256 to 255, inclusive.</source>
          <target state="translated">Константа в диапазоне от -256 до 255 включительно.</target>
        </trans-unit>
        <trans-unit id="695a694abf391bc605e989d6eb5dbacf14f628c2" translate="yes" xml:space="preserve">
          <source>A constant in the range -32768 to 32767, inclusive.</source>
          <target state="translated">Константа в диапазоне от -32768 до 32767 включительно.</target>
        </trans-unit>
        <trans-unit id="2e51455a9b3294a37777151389f3c055d9628f83" translate="yes" xml:space="preserve">
          <source>A constant in the range -65535 to -1 (inclusive).</source>
          <target state="translated">Константа в диапазоне от -65535 до -1 (включительно).</target>
        </trans-unit>
        <trans-unit id="a2eafd56ff7c3244c125e89f98b5047314116000" translate="yes" xml:space="preserve">
          <source>A constant in the range -8388608 to 8388607, inclusive.</source>
          <target state="translated">Постоянная в диапазоне от -8388608 до 8388607 включительно.</target>
        </trans-unit>
        <trans-unit id="097b361ff7733f96fe3db5433e37aba686b852b1" translate="yes" xml:space="preserve">
          <source>A constant in the range 0 to 15, inclusive.</source>
          <target state="translated">Константа в диапазоне от 0 до 15 включительно.</target>
        </trans-unit>
        <trans-unit id="a36455a425b9727ae75ec8f878c7951252ab00ab" translate="yes" xml:space="preserve">
          <source>A constant in the range 1 to 65535 (inclusive).</source>
          <target state="translated">Константа в диапазоне от 1 до 65535 (включительно).</target>
        </trans-unit>
        <trans-unit id="2a58c4a3cc79eb84153470348476e3f269dac278" translate="yes" xml:space="preserve">
          <source>A constant in the range [-64, 63] for shift/rotate instructions.</source>
          <target state="translated">Константа в диапазоне [-64,63]для команд переключения/вращения.</target>
        </trans-unit>
        <trans-unit id="10785db1e9d20c3cdec60f076d95570e2881e446" translate="yes" xml:space="preserve">
          <source>A constant in the range of 0 to -255.</source>
          <target state="translated">Константа в диапазоне от 0 до -255.</target>
        </trans-unit>
        <trans-unit id="5b0495335754f2b58bcc5c273f50a0ad47fb4980" translate="yes" xml:space="preserve">
          <source>A constant in the range of 0 to 255.</source>
          <target state="translated">Константа в диапазоне от 0 до 255.</target>
        </trans-unit>
        <trans-unit id="3df560572af8da9f608ecbfa457628a58591cc1d" translate="yes" xml:space="preserve">
          <source>A constant in the range supported by &lt;code&gt;movcc&lt;/code&gt; instructions (11-bit signed immediate)</source>
          <target state="translated">Константа в диапазоне, поддерживаемом инструкциями &lt;code&gt;movcc&lt;/code&gt; (11-битный немедленный знак )</target>
        </trans-unit>
        <trans-unit id="e6b217cb7e92669add738eef6823abf207c1faff" translate="yes" xml:space="preserve">
          <source>A constant in the range supported by &lt;code&gt;movrcc&lt;/code&gt; instructions (10-bit signed immediate)</source>
          <target state="translated">Константа в диапазоне, поддерживаемом инструкциями &lt;code&gt;movrcc&lt;/code&gt; (10-битный немедленный знак )</target>
        </trans-unit>
        <trans-unit id="f72ba093b9d9c51600024c95028a46b05718f280" translate="yes" xml:space="preserve">
          <source>A constant that cannot be loaded using &lt;code&gt;lui&lt;/code&gt;, &lt;code&gt;addiu&lt;/code&gt; or &lt;code&gt;ori&lt;/code&gt;.</source>
          <target state="translated">Константа, которую нельзя загрузить с помощью &lt;code&gt;lui&lt;/code&gt; , &lt;code&gt;addiu&lt;/code&gt; или &lt;code&gt;ori&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c2d44283a3acc9bdc683ea83a3f874e52a46752" translate="yes" xml:space="preserve">
          <source>A constant that has exactly one bit clear.</source>
          <target state="translated">Константа,которая имеет ровно одну четкую константу.</target>
        </trans-unit>
        <trans-unit id="cfb3a0520f6d9864d7a1976144208cbbd9174378" translate="yes" xml:space="preserve">
          <source>A constant that has exactly one bit set.</source>
          <target state="translated">Константа,которая имеет ровно один бит.</target>
        </trans-unit>
        <trans-unit id="f067235028290b700b44d1ece783ed553e206e2b" translate="yes" xml:space="preserve">
          <source>A constant that is not between 2 and 15 inclusive.</source>
          <target state="translated">Константа,которая не находится между 2 и 15 включительно.</target>
        </trans-unit>
        <trans-unit id="dc8b34473e04adc25852b0eed10f1d174b004494" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for bclr instruction.</source>
          <target state="translated">Константа,которая не находится в диапазоне imm15u,но ok для инструкции bclr.</target>
        </trans-unit>
        <trans-unit id="c6a1b8bc59cee8c8f6571d6cc94e881414d8fd98" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for bset instruction.</source>
          <target state="translated">Константа,которая не находится в диапазоне imm15u,но ok для инструкции bset.</target>
        </trans-unit>
        <trans-unit id="5a081f0e675d939eda6d41b659eb1a4796698f55" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for btgl instruction.</source>
          <target state="translated">Константа,которая не находится в диапазоне imm15u,но ok для инструкции btgl.</target>
        </trans-unit>
        <trans-unit id="739639d0dba642847055adad6d408a8462cefd56" translate="yes" xml:space="preserve">
          <source>A constant whose compliment value is in the range of imm15u and ok for bitci instruction.</source>
          <target state="translated">Константа,значение комплимента которой находится в диапазоне imm15u и ok для инструкции bitci.</target>
        </trans-unit>
        <trans-unit id="772d4006b3b3b9f5dbb1eb8305ae0da40df09812" translate="yes" xml:space="preserve">
          <source>A decimal number representing clock cycles.</source>
          <target state="translated">Десятичное число,представляющее циклы часов.</target>
        </trans-unit>
        <trans-unit id="0e4012d6617bb64507db563d81889013cebe2316" translate="yes" xml:space="preserve">
          <source>A declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached and that is associated with a named &lt;code&gt;target&lt;/code&gt; must be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871d38c63e186ae7cd0f311fcbbf75d49f235704" translate="yes" xml:space="preserve">
          <source>A deprecated synonym for</source>
          <target state="translated">Устаревший синоним для</target>
        </trans-unit>
        <trans-unit id="35b2c49fceb685c2e6ddfd9b7ccde26327c395da" translate="yes" xml:space="preserve">
          <source>A diagnostic can contain zero or more locations. Each location has up to three positions within it: a &lt;code&gt;caret&lt;/code&gt; position and optional &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;finish&lt;/code&gt; positions. A location can also have an optional &lt;code&gt;label&lt;/code&gt; string. For example, this error:</source>
          <target state="translated">Диагностика может содержать ноль или более местоположений. Каждое местоположение может иметь до трех позиций: позиция &lt;code&gt;caret&lt;/code&gt; и дополнительные позиции &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;finish&lt;/code&gt; . Местоположение может также иметь необязательную строку &lt;code&gt;label&lt;/code&gt; . Например, эта ошибка:</target>
        </trans-unit>
        <trans-unit id="1d3956dd1850c8ee01dd888bb0a0a3023c553d32" translate="yes" xml:space="preserve">
          <source>A diagnostic has a &lt;code&gt;kind&lt;/code&gt;. If this is &lt;code&gt;warning&lt;/code&gt;, then there is an &lt;code&gt;option&lt;/code&gt; key describing the command-line option controlling the warning.</source>
          <target state="translated">У диагностики есть &lt;code&gt;kind&lt;/code&gt; . Если это &lt;code&gt;warning&lt;/code&gt; , то есть ключ &lt;code&gt;option&lt;/code&gt; описывающий параметр командной строки, управляющий предупреждением.</target>
        </trans-unit>
        <trans-unit id="64d7123704bf7fa0f1e73d01535513a0dc7c2748" translate="yes" xml:space="preserve">
          <source>A different sort of disaster results from the use of this flag for a register in which function values may be returned.</source>
          <target state="translated">Другой вид катастрофы возникает в результате использования этого флага для регистра,в котором могут быть возвращены значения функции.</target>
        </trans-unit>
        <trans-unit id="c32446d7ea192a83db5ac54835cfe4c3d265fe83" translate="yes" xml:space="preserve">
          <source>A factor for tuning the upper bound that swing modulo scheduler uses for scheduling a loop.</source>
          <target state="translated">Фактор настройки верхней границы,используемый планировщиком модуля качания для планирования цикла.</target>
        </trans-unit>
        <trans-unit id="a7b34a84c6690fd83c05d2fa16fc0c287bb3da1b" translate="yes" xml:space="preserve">
          <source>A feature to report any failure to conform to ISO C might be useful in some instances, but would require considerable additional work and would be quite different from</source>
          <target state="translated">Функция сообщения о любом несоответствии требованиям С ИСО может быть полезной в некоторых случаях,но потребует значительной дополнительной работы и будет сильно отличаться от</target>
        </trans-unit>
        <trans-unit id="b2a29cc3baea0c08d4a825d0752f1c7c91b7a29c" translate="yes" xml:space="preserve">
          <source>A few standard library functions, such as &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;exit&lt;/code&gt;, cannot return. GCC knows this automatically. Some programs define their own functions that never return. You can declare them &lt;code&gt;noreturn&lt;/code&gt; to tell the compiler this fact. For example,</source>
          <target state="translated">Некоторые стандартные библиотечные функции, такие как &lt;code&gt;abort&lt;/code&gt; и &lt;code&gt;exit&lt;/code&gt; , не могут вернуться. GCC знает это автоматически. Некоторые программы определяют свои собственные функции, которые никогда не возвращаются. Вы можете объявить их &lt;code&gt;noreturn&lt;/code&gt; , чтобы сообщить компилятору об этом факте. Например,</target>
        </trans-unit>
        <trans-unit id="cb463f377ea974dd6c90f4d5e14fe7753fa59c05" translate="yes" xml:space="preserve">
          <source>A file name that does not end in a special recognized suffix is considered to name an object file or library. (Object files are distinguished from libraries by the linker according to the file contents.) If linking is done, these object files are used as input to the linker.</source>
          <target state="translated">Имя файла,которое не заканчивается на специальный распознанный суффикс,считается именем объектного файла или библиотеки.(Объектные файлы отличаются от библиотек компоновщиком в соответствии с содержимым файла).При установлении связей эти объектные файлы используются в качестве исходных данных для компоновщика.</target>
        </trans-unit>
        <trans-unit id="31a3ef8a1f914c346a656751b3762e1f23b6d753" translate="yes" xml:space="preserve">
          <source>A file&amp;rsquo;s &lt;em&gt;basename&lt;/em&gt; is the name stripped of all leading path information and of trailing suffixes, such as &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Базовое&lt;/em&gt; имя файла - это имя без всей информации о начальном пути и конечных суффиксов, таких как '</target>
        </trans-unit>
        <trans-unit id="3cb6c35b9f770d58e9e6ae1be71711d84191b278" translate="yes" xml:space="preserve">
          <source>A floating point constant 0.0</source>
          <target state="translated">Константа с плавающей точкой 0.0</target>
        </trans-unit>
        <trans-unit id="ac7c31fdc5f9ddf8dfae82582cc34a55de257130" translate="yes" xml:space="preserve">
          <source>A floating point register (FPR), &lt;code&gt;f0&lt;/code&gt;&amp;hellip;&lt;code&gt;f31&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637820768e2434914c48d73ef03a77823d03c37c" translate="yes" xml:space="preserve">
          <source>A floating point register. This is the same as &lt;code&gt;f&lt;/code&gt; nowadays; historically &lt;code&gt;f&lt;/code&gt; was for single-precision and &lt;code&gt;d&lt;/code&gt; was for double-precision floating point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a05594f7fa158ed7e1a662576eede9b7714efc" translate="yes" xml:space="preserve">
          <source>A floating-point condition code register.</source>
          <target state="translated">Регистр кодов условий с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="6a5e282398dc91c4802485c8333b0a476c54fe7d" translate="yes" xml:space="preserve">
          <source>A floating-point register (if available).</source>
          <target state="translated">Регистр с плавающей точкой (если имеется).</target>
        </trans-unit>
        <trans-unit id="f68f63f0de9f100e3091753e0a87b4bdcab324f8" translate="yes" xml:space="preserve">
          <source>A floating-point register (if availiable).</source>
          <target state="translated">Регистр с плавающей точкой (если доступен).</target>
        </trans-unit>
        <trans-unit id="1d93f84bcb43d9808ea6d43552092e130f8e5d2b" translate="yes" xml:space="preserve">
          <source>A fourth version of the C standard, known as &lt;em&gt;C11&lt;/em&gt;, was published in 2011 as ISO/IEC 9899:2011. (While in development, drafts of this standard version were referred to as &lt;em&gt;C1X&lt;/em&gt;.) GCC has substantially complete support for this standard, enabled with</source>
          <target state="translated">Четвертая версия стандарта C, известная как &lt;em&gt;C11&lt;/em&gt; , была опубликована в 2011 году как ISO / IEC 9899: 2011. (В процессе разработки проекты этой стандартной версии назывались &lt;em&gt;C1X&lt;/em&gt; .) GCC имеет практически полную поддержку этого стандарта, включенную с</target>
        </trans-unit>
        <trans-unit id="55257df904754ff4c13989bc1d064dbb261da350" translate="yes" xml:space="preserve">
          <source>A framework directory is a directory with frameworks in it. A framework is a directory with a</source>
          <target state="translated">Каталог фреймворка-это каталог с фреймворками в нем.Фреймворк-это каталог с</target>
        </trans-unit>
        <trans-unit id="5ba28f66c2dca176d361d13d2cfcd58e64de11b1" translate="yes" xml:space="preserve">
          <source>A function declared external in one block and then used after the end of the block.</source>
          <target state="translated">Функция,объявленная внешней в одном блоке,а затем используемая после его окончания.</target>
        </trans-unit>
        <trans-unit id="31442efa0c2c801bce0a5591e6aced95492894fb" translate="yes" xml:space="preserve">
          <source>A function may be given the attribute &lt;code&gt;no_instrument_function&lt;/code&gt;, in which case this instrumentation is not done. This can be used, for example, for the profiling functions listed above, high-priority interrupt routines, and any functions from which the profiling functions cannot safely be called (perhaps signal handlers, if the profiling routines generate output or allocate memory). See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">Функция может быть присвоена атрибуту &lt;code&gt;no_instrument_function&lt;/code&gt; , и в этом случае это инструментирование не выполняется. Это можно использовать, например, для перечисленных выше функций профилирования, процедур обработки прерываний с высоким приоритетом и любых функций, из которых функции профилирования не могут быть безопасно вызваны (возможно, обработчики сигналов, если подпрограммы профилирования генерируют выходные данные или выделяют память). См. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3b5c7a586587400ee92ec622d45d7b4bfd1b3e3" translate="yes" xml:space="preserve">
          <source>A function parameter is declared without a type specifier in K&amp;amp;R-style functions:</source>
          <target state="translated">Параметр функции объявляется без спецификатора типа в функциях стиля K &amp;amp; R:</target>
        </trans-unit>
        <trans-unit id="4a55e26416d74770259268d8b952c442c03d140f" translate="yes" xml:space="preserve">
          <source>A function-like macro that appears without arguments.</source>
          <target state="translated">Функциональный макрос,который появляется без аргументов.</target>
        </trans-unit>
        <trans-unit id="debf2118f99ae7d5fcef4420f2e62948ac9db34c" translate="yes" xml:space="preserve">
          <source>A further version of the C standard, known as &lt;em&gt;C2X&lt;/em&gt;, is under development; experimental and incomplete support for this is enabled with</source>
          <target state="translated">&lt;em&gt;Следующая&lt;/em&gt; версия стандарта C, известная как &lt;em&gt;C2X&lt;/em&gt; , находится в стадии разработки; экспериментальная и неполная поддержка для этого включена с</target>
        </trans-unit>
        <trans-unit id="dd4d39a738de423b3a8f7321b1548155edc7437d" translate="yes" xml:space="preserve">
          <source>A general purpose register (GPR), &lt;code&gt;r0&lt;/code&gt;&amp;hellip;&lt;code&gt;r31&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8db3cc1b660b8c40d207078f962c2f15753e61" translate="yes" xml:space="preserve">
          <source>A general register (&lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r31&lt;/code&gt;).</source>
          <target state="translated">Общий регистр (от &lt;code&gt;r0&lt;/code&gt; до &lt;code&gt;r31&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4c9d8cf8321530b1a940502b30ac5acf72522d1e" translate="yes" xml:space="preserve">
          <source>A general-purpose register. This is equivalent to &lt;code&gt;r&lt;/code&gt; unless generating MIPS16 code, in which case the MIPS16 register set is used.</source>
          <target state="translated">Реестр общего назначения. Это эквивалентно &lt;code&gt;r&lt;/code&gt; , если не генерируется код MIPS16, и в этом случае используется набор регистров MIPS16.</target>
        </trans-unit>
        <trans-unit id="d2030f94473ff72afe09286a5000f598b54444ee" translate="yes" xml:space="preserve">
          <source>A generic CPU with 64-bit extensions.</source>
          <target state="translated">Общий процессор с 64-битными расширениями.</target>
        </trans-unit>
        <trans-unit id="1e6fe121c0bf0b0f224a8bd42e66a0a587219c64" translate="yes" xml:space="preserve">
          <source>A given program is written in one or the other of these two dialects. The program stands a chance to work on most any machine if it is compiled with the proper dialect. It is unlikely to work at all if compiled with the wrong dialect.</source>
          <target state="translated">Данная программа пишется на том или ином из этих двух диалектов.У программы есть шанс работать на большинстве машин,если она скомпилирована с соответствующим диалектом.Маловероятно,что она вообще будет работать,если скомпилирована с неправильным диалектом.</target>
        </trans-unit>
        <trans-unit id="6c5058629f496fbd3a9b20ab2118be652c13eb69" translate="yes" xml:space="preserve">
          <source>A good explanation of the benefits offered by ensuring ELF symbols have the correct visibility is given by &amp;ldquo;How To Write Shared Libraries&amp;rdquo; by Ulrich Drepper (which can be found at &lt;a href=&quot;https://www.akkadia.org/drepper/&quot;&gt;https://www.akkadia.org/drepper/&lt;/a&gt;)&amp;mdash;however a superior solution made possible by this option to marking things hidden when the default is public is to make the default hidden and mark things public. This is the norm with DLLs on Windows and with</source>
          <target state="translated">Хорошее объяснение преимуществ, которые дает обеспечение правильной видимости символов ELF, дает Ульрих Дреппер &amp;laquo;Как писать общие библиотеки&amp;raquo; (который можно найти по адресу &lt;a href=&quot;https://www.akkadia.org/drepper/&quot;&gt;https://www.akkadia.org/drepper/&lt;/a&gt; ), однако Превосходное решение, которое стало возможным благодаря этой опции для отметки вещей, скрытых, когда по умолчанию является общедоступным, состоит в том, чтобы сделать скрытым по умолчанию и пометить вещи общедоступными. Это норма для DLL в Windows и с</target>
        </trans-unit>
        <trans-unit id="4b92b6d35d4ef9edd4bc988a5b041656a4bfb9c4" translate="yes" xml:space="preserve">
          <source>A local label declaration looks like this:</source>
          <target state="translated">Декларация местного лейбла выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="4eae759733edfeb41cf185aaf992eb0590b9b2a1" translate="yes" xml:space="preserve">
          <source>A local variable or class data member declared both &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;__thread&lt;/code&gt; gives the variable or member thread storage duration.</source>
          <target state="translated">Локальная переменная или член данных класса, объявленные как &lt;code&gt;static&lt;/code&gt; ,так и &lt;code&gt;__thread&lt;/code&gt; ,задают продолжительность хранения переменной или потока-члена.</target>
        </trans-unit>
        <trans-unit id="cbc079ebb13b05a28fc7e6b5c8e9b7e32b012d41" translate="yes" xml:space="preserve">
          <source>A loop expected to iterate at least the selected number of iterations is aligned.</source>
          <target state="translated">Петля,которая,как ожидается,выполнит хотя бы определенное количество итераций,выравнивается.</target>
        </trans-unit>
        <trans-unit id="e6e2fdd4a6e2c1dbe43d588ddf3a77eab778b7d1" translate="yes" xml:space="preserve">
          <source>A member of a union object is accessed using a member of a different type (C90 6.3.2.3).</source>
          <target state="translated">Доступ к члену профсоюзного объекта осуществляется с помощью члена другого типа (С90 6.3.2.3).</target>
        </trans-unit>
        <trans-unit id="d48a8ba2b56e035d8312e0298f36fac9054a9681" translate="yes" xml:space="preserve">
          <source>A memory address based on Y or Z pointer with displacement.</source>
          <target state="translated">Адрес памяти,основанный на указателе Y или Z со смещением.</target>
        </trans-unit>
        <trans-unit id="3b84dcc8ac9137874012ebfd9eadab8bb949fee4" translate="yes" xml:space="preserve">
          <source>A memory address suitable for a load/store pair instruction in SI, DI, SF and DF modes</source>
          <target state="translated">Адрес памяти,подходящий для инструкции по загрузке/хранению пары в режимах SI,DI,SF и DF.</target>
        </trans-unit>
        <trans-unit id="0bb3634ff6bc0ca41e70f28fef8acf81311e449f" translate="yes" xml:space="preserve">
          <source>A memory address that will work with the &lt;code&gt;lq&lt;/code&gt; and &lt;code&gt;stq&lt;/code&gt; instructions.</source>
          <target state="translated">Адрес памяти, который будет работать с инструкциями &lt;code&gt;lq&lt;/code&gt; и &lt;code&gt;stq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e82efce1d813a82c9a30ae4a9287debad5d5c479" translate="yes" xml:space="preserve">
          <source>A memory address which uses a single base register with no offset</source>
          <target state="translated">Адрес памяти,использующий один базовый регистр без смещения.</target>
        </trans-unit>
        <trans-unit id="f6aff7695c779a2c12c72d4158e0a44c684b7687" translate="yes" xml:space="preserve">
          <source>A memory operand accessed with indexed or indirect addressing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa32937bb87c45112562669984946bc4a880e43" translate="yes" xml:space="preserve">
          <source>A memory operand addressed by just a base register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d889b3934276ee507afa50f38217acb1e8a60ca1" translate="yes" xml:space="preserve">
          <source>A memory operand for floating-point loads and stores</source>
          <target state="translated">Операнд памяти для загрузки и хранения данных с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="76dff8679e9a8f7ce2eb5bb8fad71047c6747dbc" translate="yes" xml:space="preserve">
          <source>A memory operand is allowed, but only if the address is &lt;em&gt;offsettable&lt;/em&gt;. This means that adding a small integer (actually, the width in bytes of the operand, as determined by its machine mode) may be added to the address and the result is also a valid memory address.</source>
          <target state="translated">Операнд памяти разрешен, но только если адрес является &lt;em&gt;смещаемым&lt;/em&gt; . Это означает, что добавление небольшого целого числа (фактически, ширина операнда в байтах, определяемая его машинным режимом) может быть добавлено к адресу, и результатом также будет действительный адрес памяти.</target>
        </trans-unit>
        <trans-unit id="388671fe2c36d60a932779a67c16d85d78ac2d17" translate="yes" xml:space="preserve">
          <source>A memory operand is allowed, with any kind of address that the machine supports in general. Note that the letter used for the general memory constraint can be re-defined by a back end using the &lt;code&gt;TARGET_MEM_CONSTRAINT&lt;/code&gt; macro.</source>
          <target state="translated">Допускается операнд памяти с любым типом адреса, который машина поддерживает в целом. Обратите внимание, что буква, используемая для общего ограничения памяти, может быть переопределена серверной частью с &lt;code&gt;TARGET_MEM_CONSTRAINT&lt;/code&gt; макроса TARGET_MEM_CONSTRAINT .</target>
        </trans-unit>
        <trans-unit id="e12c184fcd9f0721bc91e2359dd6f356789155c7" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for Nios II R2 load/store exclusive instructions.</source>
          <target state="translated">Операнд памяти,подходящий для загрузки/хранения эксклюзивных инструкций Nios II R2.</target>
        </trans-unit>
        <trans-unit id="7146411d4e212e3eace6ea02064bc67368c7d22e" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for load/store IO and cache instructions.</source>
          <target state="translated">Операнд памяти,подходящий для загрузки/хранения инструкций ввода-вывода и кэша.</target>
        </trans-unit>
        <trans-unit id="40ed4ba7f90bf88673d73789aca447219b51285c" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for the ISA 3.0 vector d-form instructions.</source>
          <target state="translated">Операнд памяти,подходящий для векторных d-форм инструкций ISA 3.0.</target>
        </trans-unit>
        <trans-unit id="84bfbe27f0967bbd8165fcff340f78cb41e95ca2" translate="yes" xml:space="preserve">
          <source>A memory operand that can be used as the destination operand of an integer store instruction</source>
          <target state="translated">Операнд памяти,который может быть использован в качестве целевого операнда целой инструкции хранилища.</target>
        </trans-unit>
        <trans-unit id="96695f63007ab0923706713901f4b85b969e2a0a" translate="yes" xml:space="preserve">
          <source>A memory operand that is not offsettable. In other words, anything that would fit the &amp;lsquo;</source>
          <target state="translated">Операнд памяти, который не может быть смещен. Другими словами, все, что подошло бы к '</target>
        </trans-unit>
        <trans-unit id="1a801a13c9b53ba2ca78c13cc2cdf8d621afb8bd" translate="yes" xml:space="preserve">
          <source>A memory operand whose address is formed by a base register and offset that is suitable for use in instructions with the same addressing mode as &lt;code&gt;ll&lt;/code&gt; and &lt;code&gt;sc&lt;/code&gt;.</source>
          <target state="translated">Операнд памяти, адрес которого образован базовым регистром и смещением, который подходит для использования в командах с тем же режимом адресации, что и &lt;code&gt;ll&lt;/code&gt; и &lt;code&gt;sc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cf579681538dd24f4c522430fbc1d9db816f237" translate="yes" xml:space="preserve">
          <source>A memory operand with autodecrement addressing (either predecrement or postdecrement) is allowed. In inline &lt;code&gt;asm&lt;/code&gt; this constraint is only allowed if the operand is used exactly once in an instruction that can handle the side effects. Not using an operand with &amp;lsquo;</source>
          <target state="translated">Допускается операнд памяти с автодекрементной адресацией (прединкремент или постдекремент). Во встроенном &lt;code&gt;asm&lt;/code&gt; это ограничение разрешено только в том случае, если операнд используется только один раз в инструкции, которая может обрабатывать побочные эффекты. Не использовать операнд с '</target>
        </trans-unit>
        <trans-unit id="cdc334ade8276d0cf5a4c832b12ab9caa48613bc" translate="yes" xml:space="preserve">
          <source>A memory operand with autoincrement addressing (either preincrement or postincrement) is allowed. In inline &lt;code&gt;asm&lt;/code&gt; the same restrictions as for &amp;lsquo;</source>
          <target state="translated">Допускается операнд памяти с адресацией автоинкремента (либо преинкремент, либо постинкремент). Во встроенном &lt;code&gt;asm&lt;/code&gt; те же ограничения, что и для '</target>
        </trans-unit>
        <trans-unit id="5ac646a0970be5dfa33196ede31cf6694433d2fe" translate="yes" xml:space="preserve">
          <source>A memory operand. Normally, &lt;code&gt;m&lt;/code&gt; does not allow addresses that update the base register. If the &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; constraint is also used, they are allowed and therefore on PowerPC targets in that case it is only safe to use &lt;code&gt;m&amp;lt;&amp;gt;&lt;/code&gt; in an &lt;code&gt;asm&lt;/code&gt; statement if that &lt;code&gt;asm&lt;/code&gt; statement accesses the operand exactly once. The &lt;code&gt;asm&lt;/code&gt; statement must also use &lt;code&gt;%U&lt;var&gt;&amp;lt;opno&amp;gt;&lt;/var&gt;&lt;/code&gt; as a placeholder for the &amp;ldquo;update&amp;rdquo; flag in the corresponding load or store instruction. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c1412da74dea8e31160c68dd4c58d9ddd39d1e" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for VFP load/store insns (reg+constant offset)</source>
          <target state="translated">Образец памяти,подходящий для загрузки/складки VFP (reg+постоянное смещение).</target>
        </trans-unit>
        <trans-unit id="3a8bf2f192d44bf25c5dafeee0b8eaa22bcc9154" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for iWMMXt load/store instructions.</source>
          <target state="translated">Справочник по памяти,подходящий для инструкций по загрузке/хранению iWMMXt.</target>
        </trans-unit>
        <trans-unit id="4b919c81ffb39ef6f8f9eb3d7ccc854afd2048d5" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for the ARMv4 ldrsb instruction.</source>
          <target state="translated">Ссылка на память,подходящую для инструкции ARMv4 ldrsb.</target>
        </trans-unit>
        <trans-unit id="0281e56b013121500cc01f595e9459e28872a62b" translate="yes" xml:space="preserve">
          <source>A memory reference that is a stack pop.</source>
          <target state="translated">Ссылка на память,которая представляет собой всплывающее окно стека.</target>
        </trans-unit>
        <trans-unit id="19169aa6dfaeac0eed19cdca087e18730184a143" translate="yes" xml:space="preserve">
          <source>A memory reference that is a stack push.</source>
          <target state="translated">Ссылка на память,которая представляет собой нажатие стека.</target>
        </trans-unit>
        <trans-unit id="9f8594bf5c6cb542733511c9002f352d41b3d7e8" translate="yes" xml:space="preserve">
          <source>A memory reference that is encoded within the opcode, but not auto-increment or auto-decrement.</source>
          <target state="translated">Ссылка на память,которая закодирована внутри опкода,но не автоинкремент или автодекремент.</target>
        </trans-unit>
        <trans-unit id="261f1d2ca930e0206ac633c0e47452ba885dfea6" translate="yes" xml:space="preserve">
          <source>A memory reference that is encoded within the opcode.</source>
          <target state="translated">Ссылка на память,закодированная внутри опкода.</target>
        </trans-unit>
        <trans-unit id="9cafdb6d926c7b33945a0f45773363bd841f1c97" translate="yes" xml:space="preserve">
          <source>A memory reference that refers to a constant address of known value.</source>
          <target state="translated">Ссылка на память,которая относится к постоянному адресу известного значения.</target>
        </trans-unit>
        <trans-unit id="4d28cbf28c6da1c555a93c693a0088131b65d6af" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;AX&lt;/code&gt;, &lt;code&gt;BC&lt;/code&gt;, &lt;code&gt;DE&lt;/code&gt;, or &lt;code&gt;HL&lt;/code&gt; for the address, for calls.</source>
          <target state="translated">Ссылка на память с использованием &lt;code&gt;AX&lt;/code&gt; , &lt;code&gt;BC&lt;/code&gt; , &lt;code&gt;DE&lt;/code&gt; или &lt;code&gt;HL&lt;/code&gt; в качестве адреса для вызовов.</target>
        </trans-unit>
        <trans-unit id="ccd702a76b4ec6cf431d1b3b13c087fda1a005cc" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;BC&lt;/code&gt; as a base register, with an optional offset.</source>
          <target state="translated">Ссылка на память с использованием &lt;code&gt;BC&lt;/code&gt; в качестве базового регистра с необязательным смещением.</target>
        </trans-unit>
        <trans-unit id="1b8a2311d7274d21eb0ecc9fab5c05d859421673" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;DE&lt;/code&gt; as a base register, with an optional offset.</source>
          <target state="translated">Ссылка на память с использованием &lt;code&gt;DE&lt;/code&gt; в качестве базового регистра с необязательным смещением.</target>
        </trans-unit>
        <trans-unit id="70d9c96a11dbdafd4cd2e7e236553a508e4c91e1" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;DE&lt;/code&gt; as a base register, without any offset.</source>
          <target state="translated">Ссылка на память с использованием &lt;code&gt;DE&lt;/code&gt; в качестве базового регистра без какого-либо смещения.</target>
        </trans-unit>
        <trans-unit id="e072e18db9eb6bf209deec68cb4227fc0ad73751" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, with &lt;code&gt;B&lt;/code&gt; or &lt;code&gt;C&lt;/code&gt; as the index register.</source>
          <target state="translated">Ссылка на память с использованием &lt;code&gt;HL&lt;/code&gt; в качестве базового регистра, с &lt;code&gt;B&lt;/code&gt; или &lt;code&gt;C&lt;/code&gt; в качестве индексного регистра.</target>
        </trans-unit>
        <trans-unit id="df6dc5b742ae15cb0c4a64ea30738791b4c31ce2" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, with an optional one-byte offset.</source>
          <target state="translated">Ссылка на память с использованием &lt;code&gt;HL&lt;/code&gt; в качестве базового регистра с необязательным однобайтовым смещением.</target>
        </trans-unit>
        <trans-unit id="ddc26c1495756f4b844ddb7cea2453b5108af343" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, without any offset.</source>
          <target state="translated">Ссылка на память с использованием &lt;code&gt;HL&lt;/code&gt; в качестве базового регистра без какого-либо смещения.</target>
        </trans-unit>
        <trans-unit id="dd84b756a68010a9ef8c97c933ab58752c08401e" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;SP&lt;/code&gt; as a base register, with an optional one-byte offset.</source>
          <target state="translated">Ссылка на память с использованием &lt;code&gt;SP&lt;/code&gt; в качестве базового регистра с необязательным однобайтовым смещением.</target>
        </trans-unit>
        <trans-unit id="8838226960a63f5221b0e15609b574e60c61f473" translate="yes" xml:space="preserve">
          <source>A memory reference using any 16-bit register pair for the address, for calls.</source>
          <target state="translated">Ссылка на память с использованием любой 16-битной пары регистров для адреса,для вызовов.</target>
        </trans-unit>
        <trans-unit id="4b51e9b71c2545b5652560bf7f6a9647e0035d8a" translate="yes" xml:space="preserve">
          <source>A memory reference where the exact address is in a single register (&amp;lsquo;&amp;lsquo;</source>
          <target state="translated">Ссылка на память, где точный адрес находится в одном регистре (''</target>
        </trans-unit>
        <trans-unit id="0139bd65b0b5d2fe4673870edd7d6641449c58e8" translate="yes" xml:space="preserve">
          <source>A memory reference which requires an additional word (address or offset) after the opcode.</source>
          <target state="translated">Опорный элемент памяти,требующий дополнительного слова (адрес или смещение)после опкода.</target>
        </trans-unit>
        <trans-unit id="9a543e86cece309b6602d80f4120038bbc4ab307" translate="yes" xml:space="preserve">
          <source>A memory reference with an absolute address.</source>
          <target state="translated">Ссылка на память с абсолютным адресом.</target>
        </trans-unit>
        <trans-unit id="287d82bed5f1580615ce42d8bee2ee48ebecfb48" translate="yes" xml:space="preserve">
          <source>A memory transaction commits all changes to memory in an atomic way, as visible to other threads. If the transaction fails it is rolled back and all side effects discarded.</source>
          <target state="translated">Транзакция памяти фиксирует все изменения в памяти атомарным способом,как видимые другим потокам.Если транзакция не удается,она откатывается,и все побочные эффекты отбрасываются.</target>
        </trans-unit>
        <trans-unit id="d7f155128a2791cfe10b2a9e15921858bd575c02" translate="yes" xml:space="preserve">
          <source>A nested function always has no linkage. Declaring one with &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; is erroneous. If you need to declare the nested function before its definition, use &lt;code&gt;auto&lt;/code&gt; (which is otherwise meaningless for function declarations).</source>
          <target state="translated">Вложенная функция всегда не имеет связи. Объявление одного с помощью &lt;code&gt;extern&lt;/code&gt; или &lt;code&gt;static&lt;/code&gt; ошибочно. Если вам нужно объявить вложенную функцию до ее определения, используйте &lt;code&gt;auto&lt;/code&gt; (что в противном случае бессмысленно для объявлений функций).</target>
        </trans-unit>
        <trans-unit id="d26414fbc961f98329967917d426b4cbc2efe330" translate="yes" xml:space="preserve">
          <source>A nested function can jump to a label inherited from a containing function, provided the label is explicitly declared in the containing function (see &lt;a href=&quot;local-labels#Local-Labels&quot;&gt;Local Labels&lt;/a&gt;). Such a jump returns instantly to the containing function, exiting the nested function that did the &lt;code&gt;goto&lt;/code&gt; and any intermediate functions as well. Here is an example:</source>
          <target state="translated">Вложенная функция может перейти к метке, унаследованной от содержащей функцию, при условии, что метка явно объявлена ​​в содержащей функции (см. &lt;a href=&quot;local-labels#Local-Labels&quot;&gt;Локальные метки&lt;/a&gt; ). Такой переход мгновенно возвращается к содержащей его функции, выходя из вложенной функции, которая выполнила &lt;code&gt;goto&lt;/code&gt; а также любых промежуточных функций. Вот пример:</target>
        </trans-unit>
        <trans-unit id="0712d7fc676044f053a72419ea0e38ad815c6a04" translate="yes" xml:space="preserve">
          <source>A new edition of the ISO C standard was published in 1999 as ISO/IEC 9899:1999, and is commonly known as &lt;em&gt;C99&lt;/em&gt;. (While in development, drafts of this standard version were referred to as &lt;em&gt;C9X&lt;/em&gt;.) GCC has substantially complete support for this standard version; see &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for details. To select this standard, use</source>
          <target state="translated">Новая редакция стандарта ISO C была опубликована в 1999 году как ISO / IEC 9899: 1999 и широко известна как &lt;em&gt;C99&lt;/em&gt; . (В процессе разработки черновики этой стандартной версии назывались &lt;em&gt;C9X&lt;/em&gt; .) GCC практически полностью поддерживает эту стандартную версию; подробности см. на &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; . Чтобы выбрать этот стандарт, используйте</target>
        </trans-unit>
        <trans-unit id="e932af27090e43c13363c68073dcb1053749ea87" translate="yes" xml:space="preserve">
          <source>A new edition of the ISO C standard was published in 1999 as ISO/IEC 9899:1999, and is commonly known as &lt;em&gt;C99&lt;/em&gt;. (While in development, drafts of this standard version were referred to as &lt;em&gt;C9X&lt;/em&gt;.) GCC has substantially complete support for this standard version; see &lt;a href=&quot;https://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for details. To select this standard, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d3e8da2b16b837e350778965a42d38a1727ecd" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;static&lt;/code&gt; function declaration follows a &lt;code&gt;static&lt;/code&gt; one. This construct is not accepted by some traditional C compilers.</source>
          <target state="translated">Объявление &lt;code&gt;static&lt;/code&gt; функции следует за объявлением &lt;code&gt;static&lt;/code&gt; . Эта конструкция не поддерживается некоторыми традиционными компиляторами C.</target>
        </trans-unit>
        <trans-unit id="a1561d49e6959fd563ec43b519d5c367906c49ac" translate="yes" xml:space="preserve">
          <source>A number of bytes.</source>
          <target state="translated">Несколько байтов.</target>
        </trans-unit>
        <trans-unit id="c6e4f37a3cc64090cf8998b7f43d11b497869792" translate="yes" xml:space="preserve">
          <source>A operand which is read by the instruction can be tied to an earlyclobber operand if its only use as an input occurs before the early result is written. Adding alternatives of this form often allows GCC to produce better code when only some of the read operands can be affected by the earlyclobber. See, for example, the &amp;lsquo;</source>
          <target state="translated">Операнд, который читается инструкцией, может быть привязан к операнду раннего клоббера, если его использование только в качестве ввода происходит до того, как будет записан ранний результат. Добавление альтернатив этой формы часто позволяет GCC создавать лучший код, когда только некоторые из операндов чтения могут быть затронуты ранним блокировщиком. См., Например, '</target>
        </trans-unit>
        <trans-unit id="33c89233be593b8efaeda5d8e73bec02c063a6ed" translate="yes" xml:space="preserve">
          <source>A parameter to control whether to use function internal id in profile database lookup. If the value is 0, the compiler uses an id that is based on function assembler name and filename, which makes old profile data more tolerant to source changes such as function reordering etc.</source>
          <target state="translated">Параметр для контроля использования внутреннего идентификатора функции в поиске базы данных профилей.Если значение равно 0,компилятор использует id,основанный на имени и фамилии ассемблера функции,что делает старые данные профиля более терпимыми к изменениям в источниках,таким как переупорядочивание функций и т.д.</target>
        </trans-unit>
        <trans-unit id="ac02409b28e4665594149c1f072d2a778a5e74f5" translate="yes" xml:space="preserve">
          <source>A pointer is compared against integer zero with &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">Указатель сравнивается с целым нулем с помощью &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e654ce5ba59b63225116cee29f29b754f51ae4a" translate="yes" xml:space="preserve">
          <source>A possibly empty comma-separated list of expressions. For example, &lt;code&gt;format_arg&lt;/code&gt; attributes use this form with the list being a single integer constant expression, and &lt;code&gt;alias&lt;/code&gt; attributes use this form with the list being a single string constant.</source>
          <target state="translated">Возможно, пустой список выражений, разделенных запятыми. Например, атрибуты &lt;code&gt;format_arg&lt;/code&gt; используют эту форму со списком, представляющим собой одно целочисленное постоянное выражение, а атрибуты &lt;code&gt;alias&lt;/code&gt; используют эту форму со списком, являющимся единственной строковой константой.</target>
        </trans-unit>
        <trans-unit id="6f94ad7a128da59e35cfef4198c05f92370ba7a7" translate="yes" xml:space="preserve">
          <source>A precompiled header cannot be used once the first C token is seen. You can have preprocessor directives before a precompiled header; you cannot include a precompiled header from inside another header.</source>
          <target state="translated">Прекомпилированный заголовок не может быть использован после того,как будет виден первый токен C.Вы можете иметь директивы препроцессора перед прекомпилированным заголовком;вы не можете включить прекомпилированный заголовок из другого заголовка.</target>
        </trans-unit>
        <trans-unit id="967ed292b7da3d9c381bae6f412c1eb711012203" translate="yes" xml:space="preserve">
          <source>A precompiled header file can be used only when these conditions apply:</source>
          <target state="translated">Прекомпилированный заголовочный файл может быть использован только при соблюдении этих условий:</target>
        </trans-unit>
        <trans-unit id="05035041744377e6b9210288a1d05f98595669e6" translate="yes" xml:space="preserve">
          <source>A precompiled header file is searched for when &lt;code&gt;#include&lt;/code&gt; is seen in the compilation. As it searches for the included file (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path&quot;&gt;Search Path&lt;/a&gt; in The C Preprocessor) the compiler looks for a precompiled header in each directory just before it looks for the include file in that directory. The name searched for is the name specified in the &lt;code&gt;#include&lt;/code&gt; with &amp;lsquo;</source>
          <target state="translated">Предварительно скомпилированный заголовочный файл ищется, когда в компиляции встречается &lt;code&gt;#include&lt;/code&gt; . При поиске включенного файла (см. &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path&quot;&gt;Путь поиска&lt;/a&gt; в Препроцессоре C) компилятор ищет предварительно скомпилированный заголовок в каждом каталоге непосредственно перед тем, как искать включаемый файл в этом каталоге. Искомое имя - это имя, указанное в &lt;code&gt;#include&lt;/code&gt; с '</target>
        </trans-unit>
        <trans-unit id="e8ee52aadb3282291e3d6aa56466adcb4fc0eb86" translate="yes" xml:space="preserve">
          <source>A precompiled header file is searched for when &lt;code&gt;#include&lt;/code&gt; is seen in the compilation. As it searches for the included file (see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path&quot;&gt;Search Path&lt;/a&gt; in The C Preprocessor) the compiler looks for a precompiled header in each directory just before it looks for the include file in that directory. The name searched for is the name specified in the &lt;code&gt;#include&lt;/code&gt; with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65201eadf5d675527c7f1ac85fd378b5ccbc08ee" translate="yes" xml:space="preserve">
          <source>A prefix for source file names to remove when generating the output coverage files. This option is useful when building in a separate directory, and the pathname to the source directory is not wanted when determining the output file names. Note that this prefix detection is applied before determining whether the source file is absolute.</source>
          <target state="translated">Префикс имен исходных файлов для удаления при генерации выходных файлов покрытия.Эта опция полезна при сборке в отдельном каталоге,и при определении имен выходных файлов путь к исходному каталогу не требуется.Обратите внимание,что это определение префикса применяется перед определением абсолютного значения исходного файла.</target>
        </trans-unit>
        <trans-unit id="2f9dfd11eaa793c8913662662201289a00fcaafa" translate="yes" xml:space="preserve">
          <source>A program which performs file I/O and is destined to run on an MCM target should be linked with this option. It causes the libraries libc.a and libdebug.a to be linked. The program should be run on the target under the control of the GDB remote debugging stub.</source>
          <target state="translated">Программа,которая выполняет файловый ввод/вывод и предназначена для работы на MCM-мишени,должна быть связана с этой опцией.Это приводит к компоновке библиотек libc.a и libdebug.a.Программа должна выполняться на целевой машине под управлением удаленного отладочного пульта GDB.</target>
        </trans-unit>
        <trans-unit id="06091d7b0985c9e8feba549f19d66a548c218908" translate="yes" xml:space="preserve">
          <source>A program which performs file I/O and is destined to run on the simulator should be linked with option. This causes libraries libc.a and libsim.a to be linked.</source>
          <target state="translated">Программа,которая выполняет файловый ввод/вывод и предназначена для работы на симуляторе,должна быть связана с опцией.Это приводит к компоновке библиотек libc.a и libsim.a.</target>
        </trans-unit>
        <trans-unit id="03bc1b8f8194ecc4bd7cc22529202219ccc55928" translate="yes" xml:space="preserve">
          <source>A redeclaration of an entity must not add new ABI tags, since doing so would change the mangled name.</source>
          <target state="translated">Передекларирование сущности не должно добавлять новые теги ABI,так как это изменит искаженное имя.</target>
        </trans-unit>
        <trans-unit id="72babc8ed783b6f80b238e203c04bb32ab9b7ee7" translate="yes" xml:space="preserve">
          <source>A register indirect memory operand</source>
          <target state="translated">Регистрационный операнд непрямой памяти</target>
        </trans-unit>
        <trans-unit id="822740a74e2ad86073347ee3e0a96d4ea21793b7" translate="yes" xml:space="preserve">
          <source>A register operand is allowed provided that it is in a general register.</source>
          <target state="translated">Реестровый операнд разрешен при условии,что он находится в общем реестре.</target>
        </trans-unit>
        <trans-unit id="c6b4e516f4445d7fd0eb4545cb8bd87379ffb2be" translate="yes" xml:space="preserve">
          <source>A register suitable for use in an indirect jump. This will always be &lt;code&gt;$25&lt;/code&gt; for</source>
          <target state="translated">Регистр, подходящий для косвенного прыжка. Это всегда будет &lt;code&gt;$25&lt;/code&gt; за</target>
        </trans-unit>
        <trans-unit id="bf74def1fd328fca34b37ccd32d0585450fe7d70" translate="yes" xml:space="preserve">
          <source>A register that can hold a 64 bit value.</source>
          <target state="translated">Регистр,который может содержать 64-битное значение.</target>
        </trans-unit>
        <trans-unit id="40b15fdd982b6acc2dbd0ac15c94e31ec3b3ecb8" translate="yes" xml:space="preserve">
          <source>A revised ISO C++ standard was published in 2011 as ISO/IEC 14882:2011, and is referred to as C++11; before its publication it was commonly referred to as C++0x. C++11 contains several changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx11&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx11&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">Пересмотренный стандарт ISO C ++ был опубликован в 2011 году как ISO / IEC 14882: 2011 и упоминается как C ++ 11; до публикации он обычно назывался C ++ 0x. C ++ 11 содержит несколько изменений языка C ++, все из которых реализованы в GCC. Подробнее см. &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx11&quot;&gt;Https://gcc.gnu.org/projects/cxx-status.html#cxx11&lt;/a&gt; . Чтобы выбрать этот стандарт в GCC, используйте опцию</target>
        </trans-unit>
        <trans-unit id="fa1cdaecb062b94545ea6452cf8e926ff17ef618" translate="yes" xml:space="preserve">
          <source>A scalar volatile object is read when it is accessed in a void context:</source>
          <target state="translated">Объект скалярной волатильности считывается при обращении к нему в пустом контексте:</target>
        </trans-unit>
        <trans-unit id="1be35e4d0dcffaec4e53c70345395a20bb71df65" translate="yes" xml:space="preserve">
          <source>A scaled or unscaled indexed memory operand</source>
          <target state="translated">Масштабируемый или немасштабируемый проиндексированный операнд памяти.</target>
        </trans-unit>
        <trans-unit id="7561d823e8220cc1324112197c014a5470da6511" translate="yes" xml:space="preserve">
          <source>A signed 10-bit constant for most arithmetic instructions.</source>
          <target state="translated">Подписанная 10-битная константа для большинства арифметических инструкций.</target>
        </trans-unit>
        <trans-unit id="d4172f55ed8446ca35d32bcd89906fb5748ddaf8" translate="yes" xml:space="preserve">
          <source>A signed 11-bit constant added to -1. Can only match when the</source>
          <target state="translated">Подписанная 11-битная константа,добавленная к -1.Может совпадать только тогда,когда</target>
        </trans-unit>
        <trans-unit id="4dbec6f25e372e0d0975d4d90b4ec971a46651e9" translate="yes" xml:space="preserve">
          <source>A signed 11-bit constant.</source>
          <target state="translated">Подписанная 11-битная константа.</target>
        </trans-unit>
        <trans-unit id="c5fd23196153b5c02da9d3addd039cf5332baffd" translate="yes" xml:space="preserve">
          <source>A signed 12-bit integer constant.</source>
          <target state="translated">Знаковая 12-битная целочисленная константа.</target>
        </trans-unit>
        <trans-unit id="5d45116f20daaebe383530883ac080de0bcc23a5" translate="yes" xml:space="preserve">
          <source>A signed 15-bit constant.</source>
          <target state="translated">Подписанная 15-битная константа.</target>
        </trans-unit>
        <trans-unit id="5e37ec7562e7c67e3ef533934ac18db7a4d66259" translate="yes" xml:space="preserve">
          <source>A signed 16 bit immediate for &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">16-битный знаковый сигнал немедленной &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d1f2bec644b602c55ff93653291917c0bee1cb5" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant (for arithmetic instructions).</source>
          <target state="translated">Подписанная 16-битная константа (для арифметических инструкций).</target>
        </trans-unit>
        <trans-unit id="1040a418b2933ba39c0db5d1c19b995428a5db61" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant shifted left 16 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426c500fe95b660ec71d2075e660305546d46c08" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e07498a95ff964b95b70f9332548c0e101c48af" translate="yes" xml:space="preserve">
          <source>A signed 32-bit constant in which the lower 16 bits are zero. Such constants can be loaded using &lt;code&gt;lui&lt;/code&gt;.</source>
          <target state="translated">32-битная константа со знаком, младшие 16 бит которой равны нулю. Такие константы можно загрузить с помощью &lt;code&gt;lui&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="536e9bf9352073c69bfd1331260c3d50c75e4c4c" translate="yes" xml:space="preserve">
          <source>A signed 34-bit integer constant if prefixed instructions are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a13d86f9687e787e9b67a4048c3e6f6a0a655af" translate="yes" xml:space="preserve">
          <source>A single register. If &lt;var&gt;n&lt;/var&gt; is in the range 0 to 7, the corresponding D register. If it is &lt;code&gt;A&lt;/code&gt;, then the register P0.</source>
          <target state="translated">Единый реестр. Если &lt;var&gt;n&lt;/var&gt; находится в диапазоне от 0 до 7, соответствующий регистр D. Если это &lt;code&gt;A&lt;/code&gt; , то регистр P0.</target>
        </trans-unit>
        <trans-unit id="862eefd77275509cc300d2e8b64b0bd59d6e0627" translate="yes" xml:space="preserve">
          <source>A specification has the syntax [&amp;lsquo;</source>
          <target state="translated">Спецификация имеет синтаксис ['</target>
        </trans-unit>
        <trans-unit id="8b75792a16ebbcbf75343206f45b552f9ca68dac" translate="yes" xml:space="preserve">
          <source>A status register (&lt;code&gt;rmsr&lt;/code&gt;, &lt;code&gt;$fcc1&lt;/code&gt; to &lt;code&gt;$fcc7&lt;/code&gt;).</source>
          <target state="translated">Регистр состояния ( &lt;code&gt;rmsr&lt;/code&gt; , от &lt;code&gt;$fcc1&lt;/code&gt; до &lt;code&gt;$fcc7&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8617da8fc23fdb13a32d7e55b2af3a58c983bdf6" translate="yes" xml:space="preserve">
          <source>A string constant specifying constraints on the placement of the operand; See &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;, for details.</source>
          <target state="translated">Строковая константа, определяющая ограничения на размещение операнда; Подробнее см. &lt;a href=&quot;constraints#Constraints&quot;&gt;Ограничения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bed63450bff092e0c3ca584fb2ddae5e2d82e2a" translate="yes" xml:space="preserve">
          <source>A structure containing a flexible array member, or a union containing such a structure (possibly recursively), may not be a member of a structure or an element of an array. (However, these uses are permitted by GCC as extensions.)</source>
          <target state="translated">Структура,содержащая гибкий член массива,или объединение,содержащее такую структуру (возможно,рекурсивно),не может быть членом структуры или элементом массива.(Однако,эти использования разрешены GCC в качестве расширений).</target>
        </trans-unit>
        <trans-unit id="13f3f44cecb7edd4bea911bfc4063d4f75195a8c" translate="yes" xml:space="preserve">
          <source>A symbol in the text segment of the current file</source>
          <target state="translated">Символ в текстовом сегменте текущего файла</target>
        </trans-unit>
        <trans-unit id="55a9278d05f000d4c7a06aca9fe905b8fb5008bb" translate="yes" xml:space="preserve">
          <source>A symbol reference.</source>
          <target state="translated">Ссылка на символ.</target>
        </trans-unit>
        <trans-unit id="ceac75b89def52cbcbd311ef92b55a54ff3eba6e" translate="yes" xml:space="preserve">
          <source>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">Символический операнд или 16-битный фрагмент got,tls или pc-реляционной ссылки.</target>
        </trans-unit>
        <trans-unit id="bb721a7785396c7acd1586d0fc279449394dcfd8" translate="yes" xml:space="preserve">
          <source>A template with a non-type template parameter of reference type was mangled incorrectly:</source>
          <target state="translated">Шаблон с нетипичным параметром шаблона ссылочного типа был искажен некорректно:</target>
        </trans-unit>
        <trans-unit id="3af936ccb51639cb634f6ac0a1e094ce5a6bd006" translate="yes" xml:space="preserve">
          <source>A text segment (program memory) constant label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2953b18cce576e52d1d65cb76238b4c46802eda8" translate="yes" xml:space="preserve">
          <source>A threshold on the average loop count considered by the swing modulo scheduler.</source>
          <target state="translated">Порог срабатывания среднего количества циклов,учитываемый планировщиком по модулю свинга.</target>
        </trans-unit>
        <trans-unit id="7b4948261ad39b1701b8001a691f2c0f51ef54c3" translate="yes" xml:space="preserve">
          <source>A trampoline is a small piece of code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. Therefore, it requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">Батут-это небольшой кусок кода,который создается во время выполнения на стеке,когда берется адрес вложенной функции,и используется для косвенного вызова вложенной функции.Следовательно,для корректной работы программы требуется,чтобы стек стал исполняемым.</target>
        </trans-unit>
        <trans-unit id="78cd7e495c30fc4bf5a59f6f14ffc8c61dbbd59b" translate="yes" xml:space="preserve">
          <source>A true dependence from store to load is costly.</source>
          <target state="translated">Истинная зависимость от магазина к нагрузке дорогостоящая.</target>
        </trans-unit>
        <trans-unit id="5307fd85f09fc936e5444911a1b34c9fbd27e507" translate="yes" xml:space="preserve">
          <source>A typical use of this option is building a kernel that does not use, and hence need not save and restore, any floating-point registers.</source>
          <target state="translated">Типичным использованием этой опции является сборка ядра,которое не использует и,следовательно,не нуждается в сохранении и восстановлении любых регистров с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="7040b335818f1c7fc002704e20a47588f7532dc4" translate="yes" xml:space="preserve">
          <source>A valid &lt;code&gt;NULL&lt;/code&gt; in this context is defined as zero with any object pointer type. If your system defines the &lt;code&gt;NULL&lt;/code&gt; macro with an integer type then you need to add an explicit cast. During installation GCC replaces the system &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; header with a copy that redefines NULL appropriately.</source>
          <target state="translated">Допустимый &lt;code&gt;NULL&lt;/code&gt; в этом контексте определяется как ноль для любого типа указателя объекта. Если ваша система определяет макрос &lt;code&gt;NULL&lt;/code&gt; с целочисленным типом, вам необходимо добавить явное приведение. Во время установки GCC заменяет системный заголовок &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; копией, которая соответствующим образом переопределяет NULL.</target>
        </trans-unit>
        <trans-unit id="02bba8846c50f28733626cee0f5e6cd6eae5f547" translate="yes" xml:space="preserve">
          <source>A value for this option must be provided; possible values are</source>
          <target state="translated">Для этой опции должно быть предоставлено значение;возможными значениями являются</target>
        </trans-unit>
        <trans-unit id="28bdc15a4774baf30748fb10f9a39ee9576d0acc" translate="yes" xml:space="preserve">
          <source>A value of -1 means we don&amp;rsquo;t have a threshold and therefore prefetch hints can be issued for any constant stride.</source>
          <target state="translated">Значение -1 означает, что у нас нет порога, и поэтому подсказки предварительной выборки могут быть выданы для любого постоянного шага.</target>
        </trans-unit>
        <trans-unit id="77182ee8e74fbc85f274ec34ad0d067f9159c03c" translate="yes" xml:space="preserve">
          <source>A vector constant</source>
          <target state="translated">Векторная константа</target>
        </trans-unit>
        <trans-unit id="25a5a3c85e4d61bb20e699b708ea293eab97d102" translate="yes" xml:space="preserve">
          <source>A vector constant is a list of constant expressions within curly braces.</source>
          <target state="translated">Векторная константа-это список константных выражений в фигурных скобках.</target>
        </trans-unit>
        <trans-unit id="4903fd385e6b83744a3f7241ee469fe297e3d890" translate="yes" xml:space="preserve">
          <source>A vector initializer requires no cast if the vector constant is of the same type as the variable it is initializing.</source>
          <target state="translated">Инициализатор векторной константы не требует приведения,если векторная константа имеет тот же тип,что и инициализируемая переменная.</target>
        </trans-unit>
        <trans-unit id="6ce3f2c4c36ebf953052d74dd8cf41bfa72eda5d" translate="yes" xml:space="preserve">
          <source>A weak reference is an alias that does not by itself require a definition to be given for the target symbol. If the target symbol is only referenced through weak references, then it becomes a &lt;code&gt;weak&lt;/code&gt; undefined symbol. If it is directly referenced, however, then such strong references prevail, and a definition is required for the symbol, not necessarily in the same translation unit.</source>
          <target state="translated">Слабая ссылка - это псевдоним, который сам по себе не требует определения целевого символа. Если на целевой символ ссылаются только через слабые ссылки, он становится &lt;code&gt;weak&lt;/code&gt; неопределенным символом. Однако, если на него есть прямая ссылка, такие сильные ссылки превалируют, и для символа требуется определение, не обязательно в той же единице перевода.</target>
        </trans-unit>
        <trans-unit id="74b379dc012a6dcd931f8c8cdffa0c221d2777a0" translate="yes" xml:space="preserve">
          <source>AArch64</source>
          <target state="translated">AArch64</target>
        </trans-unit>
        <trans-unit id="d83fa522cc15ecf666a6fc12658b5e4cd5fdc010" translate="yes" xml:space="preserve">
          <source>AArch64 family&amp;mdash;</source>
          <target state="translated">Семья AArch64&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="4957a12f9c33bdb7711f6bad443bcf1b59bf30ce" translate="yes" xml:space="preserve">
          <source>ABI conformance</source>
          <target state="translated">соответствие ABI</target>
        </trans-unit>
        <trans-unit id="b14e4cc3f9a03a17ac3f6123a6226b7b7d34c952" translate="yes" xml:space="preserve">
          <source>ADDENDUM: How to use this License for your documents</source>
          <target state="translated">ДОБАВЛЕНИЕ:как использовать эту Лицензию для ваших документов</target>
        </trans-unit>
        <trans-unit id="1f0161097b4d6be2ad809b71f0ab06f4ccc56e03" translate="yes" xml:space="preserve">
          <source>AES instructions.</source>
          <target state="translated">Инструкции AES.</target>
        </trans-unit>
        <trans-unit id="bd84aa567f4fd80f10ee4bdc1fff46ff3f84291a" translate="yes" xml:space="preserve">
          <source>AIX TOC entry</source>
          <target state="translated">AIX TOC запись</target>
        </trans-unit>
        <trans-unit id="00c79d98f4ab13b1e68350376a159f81803c3f05" translate="yes" xml:space="preserve">
          <source>AIX on the RS/6000 provides support (NLS) for environments outside of the United States. Compilers and assemblers use NLS to support locale-specific representations of various objects including floating-point numbers (&amp;lsquo;</source>
          <target state="translated">AIX на RS / 6000 обеспечивает поддержку (NLS) для сред за пределами США. Компиляторы и ассемблеры используют NLS для поддержки локальных представлений различных объектов, включая числа с плавающей запятой ('</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="e38876cb454c616d20b014174318cd23549c31b5" translate="yes" xml:space="preserve">
          <source>AM33</source>
          <target state="translated">AM33</target>
        </trans-unit>
        <trans-unit id="b0f3c857fc3329c9a7706ca2852892a64907ff92" translate="yes" xml:space="preserve">
          <source>AMD Athlon CPU with MMX, 3dNOW!, enhanced 3DNow! and SSE prefetch instructions support.</source>
          <target state="translated">AMD Athlon процессор с MMX,3dNOW!,расширенная поддержка 3DNow! и SSE предварительных инструкций.</target>
        </trans-unit>
        <trans-unit id="9782812fedc19dae1f691ec0b75b46ce928e9504" translate="yes" xml:space="preserve">
          <source>AMD CPU.</source>
          <target state="translated">AMD ПРОЦЕССОР.</target>
        </trans-unit>
        <trans-unit id="4b7804a001f508699c3a5d535226c1c43f89e201" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Barcelona CPU.</source>
          <target state="translated">AMD Семья 10 часов Барселона процессор.</target>
        </trans-unit>
        <trans-unit id="f2f426233bd9b4aec7ad7f0935ada0d98f23dc6d" translate="yes" xml:space="preserve">
          <source>AMD Family 10h CPU.</source>
          <target state="translated">AMD Family 10h CPU.</target>
        </trans-unit>
        <trans-unit id="a221df99534b6cfd9cc25151f5b88b631e6b6c74" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Istanbul CPU.</source>
          <target state="translated">AMD Семья 10 часов Стамбульского процессора.</target>
        </trans-unit>
        <trans-unit id="3c8a317ded567872f2b86eb3a9b2b3142383086c" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Shanghai CPU.</source>
          <target state="translated">AMD Family 10 часов Шанхайский процессор.</target>
        </trans-unit>
        <trans-unit id="3a481ec8025706c39f85bf8a74294ffb3a885a4c" translate="yes" xml:space="preserve">
          <source>AMD Family 14h CPU.</source>
          <target state="translated">Семейный процессор AMD 14 часов.</target>
        </trans-unit>
        <trans-unit id="d69f21954e9736613dfdcb1541757a89581cb747" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 1.</source>
          <target state="translated">Бульдозер AMD Family 15h версия 1.</target>
        </trans-unit>
        <trans-unit id="41ba99ffd8cd8d92353e0abf0591f609003e91a0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 2.</source>
          <target state="translated">Бульдозер AMD Family 15h версия 2.</target>
        </trans-unit>
        <trans-unit id="c106e6d754b124070881cb0e9b5ffaec83f58ff6" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 3.</source>
          <target state="translated">Бульдозер AMD Family 15h версия 3.</target>
        </trans-unit>
        <trans-unit id="162b040bafc7dbe0fec77eb2f6b3a8372fec8cf0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 4.</source>
          <target state="translated">Бульдозер AMD Family 15h версия 4.</target>
        </trans-unit>
        <trans-unit id="8b550c62094801a9eaabc1a10c1588d01074f61b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h CPU.</source>
          <target state="translated">AMD Family 15-часовой процессор.</target>
        </trans-unit>
        <trans-unit id="6adbeef26c0c63ee2016d0b2ac6031e70f73f984" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc29f9ebb58544eff2350911f186ade2077e9e7" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">Семейство процессоров AMD на 15-часовом ядре с поддержкой набора команд x86-64.(Это суперкомпоненты BMI,BMI2,TBM,F16C,FMA,FMA4,FSGSBASE,AVX,AVX2,XOP,LWP,AES,PCL_MUL,CX16,MOVBE,MMX,SSE,SSE2,SSE3,SSE4A,SSSE3,SSE4.1,SSE4.2,ABM и 64-разрядные расширения набора инструкций.</target>
        </trans-unit>
        <trans-unit id="afaafd936d606f23e0204241163cd5538d5327ed" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0473fd00ce817690842cab967b3016ac67c8acc" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">Семейство процессоров AMD на 15-часовом ядре с поддержкой набора команд x86-64.(Это суперкомпоненты BMI,TBM,F16C,FMA,FMA4,AVX,XOP,LWP,AES,PCL_MUL,CX16,MMX,SSE,SSE2,SSE3,SSE4A,SSSE3,SSE4.1,SSE4.2,ABM и 64-битные расширения набора инструкций).</target>
        </trans-unit>
        <trans-unit id="62e14a811063bd0f1e3f0931b760b915b408af1e" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f30ce336c72904fed1286b4744fb02d22539e6b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">Семейство процессоров AMD на 15-часовом ядре с поддержкой набора команд x86-64.(Это суперкомпоненты BMI,TBM,F16C,FMA,FMA4,FSGSBASE,AVX,XOP,LWP,AES,PCL_MUL,CX16,MMX,SSE,SSE2,SSE3,SSE4A,SSSE3,SSE4.1,SSE4.2,ABM и 64-битные расширения набора инструкций.</target>
        </trans-unit>
        <trans-unit id="d1222a05e9ab4d223a98fe2b005e9a8fe6f149c1" translate="yes" xml:space="preserve">
          <source>AMD Family 16h CPU.</source>
          <target state="translated">Семейный процессор AMD 16 часов.</target>
        </trans-unit>
        <trans-unit id="275cd046e8c73f55e5a1e1661fd4caf48dfc118a" translate="yes" xml:space="preserve">
          <source>AMD Family 17h CPU.</source>
          <target state="translated">Семейный процессор AMD 17 часов.</target>
        </trans-unit>
        <trans-unit id="8605196ce8298328039162c5b2196f5f20eefce6" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 1.</source>
          <target state="translated">AMD Family 17h Zen версия 1.</target>
        </trans-unit>
        <trans-unit id="7ac5c90de82cdae73bde8fdf83f5571edc22b502" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 2.</source>
          <target state="translated">AMD Family 17h Zen версии 2.</target>
        </trans-unit>
        <trans-unit id="87a04068ae7b738101f64aab71cef3ecd2846768" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, ,CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="translated">Семейство процессоров AMD на 17-часовом ядре с поддержкой набора команд x86-64.(Это суперсеты BMI,BMI2,,CLWB,F16C,FMA,FSGSBASE,AVX,AVX2,ADCX,RDSEED,MWAITX,SHA,CLZERO,AES,PCL_MUL,CX16,MOVBE,MMX,SSE,SSE2,SSE3,SSE4A,SSSE3,SSE4.1,SSE4.2,ABM,XSAVEC,XSAVES,CLFLUSHOPT,POPCNT и 64-битные расширения набора инструкций)).</target>
        </trans-unit>
        <trans-unit id="26b9464c770316c8957e5f0dd9332edc81fe410d" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, RDPID, WBNOINVD, and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e7bb5b5f5ab7650fa5577e6308f180e065ef83" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae2f9839ab0c946ebf780350ccb8eeef28b2d89" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.</source>
          <target state="translated">Семейство процессоров AMD на 17-часовом ядре с поддержкой набора команд x86-64.(Это суперсеты BMI,BMI2,F16C,FMA,FSGSBASE,AVX,AVX2,ADCX,RDSEED,MWAITX,SHA,CLZERO,AES,PCL_MUL,CX16,MOVBE,MMX,SSE,SSE2,SSE3,SSE4A,SSSE3,SSE4.1,SSE4.2,ABM,XSAVEC,XSAVES,CLFLUSHOPT,POPCNT и 64-битные расширения набора инструкций.</target>
        </trans-unit>
        <trans-unit id="eb46d89908f8744c91b1c4f45dca8a1acd1ccb27" translate="yes" xml:space="preserve">
          <source>AMD GCN &amp;mdash;</source>
          <target state="translated">AMD GCN -</target>
        </trans-unit>
        <trans-unit id="db735b251e571e72d1b413e2700f9028689a9a1f" translate="yes" xml:space="preserve">
          <source>AMD Geode embedded processor with MMX and 3DNow! instruction set support.</source>
          <target state="translated">Встроенный процессор AMD Geode с поддержкой MMX и 3DNow! набора инструкций.</target>
        </trans-unit>
        <trans-unit id="3c8e48e665e983d9bc0d85fc904dca86423a0640" translate="yes" xml:space="preserve">
          <source>AMD K6 CPU with MMX instruction set support.</source>
          <target state="translated">ЦП AMD K6 с поддержкой набора команд MMX.</target>
        </trans-unit>
        <trans-unit id="113a97cdab92673636cc95858168822f55ed3094" translate="yes" xml:space="preserve">
          <source>ANY</source>
          <target state="translated">ANY</target>
        </trans-unit>
        <trans-unit id="c23fd1159b1de92b9f559df33e41326ca8f7ed85" translate="yes" xml:space="preserve">
          <source>ARC &amp;mdash;</source>
          <target state="translated">ARC -</target>
        </trans-unit>
        <trans-unit id="e3246acd95d4fb7aa3011b3fb00ffb954a2152c1" translate="yes" xml:space="preserve">
          <source>ARC FPX (dpfp) 64-bit registers. &lt;code&gt;D0&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;.</source>
          <target state="translated">ARC FPX (dpfp) 64-битные регистры. &lt;code&gt;D0&lt;/code&gt; , &lt;code&gt;D1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ccf1f7f060d37f54120246cfa7dc75a263926f6" translate="yes" xml:space="preserve">
          <source>ARC HS SIMD support.</source>
          <target state="translated">ARC HS SIMD поддержка.</target>
        </trans-unit>
        <trans-unit id="932a7f099a143287c2dab636f78bab3d7a1ac45d" translate="yes" xml:space="preserve">
          <source>ARC600</source>
          <target state="translated">ARC600</target>
        </trans-unit>
        <trans-unit id="4e11187f8fc082bb81a4560953a7d52297f319ca" translate="yes" xml:space="preserve">
          <source>ARC601</source>
          <target state="translated">ARC601</target>
        </trans-unit>
        <trans-unit id="db9b6f8ec7c62bb078c4ccd2086414ec10283d1a" translate="yes" xml:space="preserve">
          <source>ARC700</source>
          <target state="translated">ARC700</target>
        </trans-unit>
        <trans-unit id="69f32b824b4367437b84027bd88885eef21e2693" translate="yes" xml:space="preserve">
          <source>ARC700-xmac</source>
          <target state="translated">ARC700-xmac</target>
        </trans-unit>
        <trans-unit id="f05a45c9726afd143f3f3902e0d21ab2ae48650f" translate="yes" xml:space="preserve">
          <source>ARC725D</source>
          <target state="translated">ARC725D</target>
        </trans-unit>
        <trans-unit id="c4f837ba2f5ad05063a4e03989e3391dddb8bc79" translate="yes" xml:space="preserve">
          <source>ARC750D</source>
          <target state="translated">ARC750D</target>
        </trans-unit>
        <trans-unit id="29d8dec43e88b47582179de53ef2720d981e8ab1" translate="yes" xml:space="preserve">
          <source>ARM</source>
          <target state="translated">ARM</target>
        </trans-unit>
        <trans-unit id="888c2ab0ae2033359c10fd5cfdf58bbe2d0a940c" translate="yes" xml:space="preserve">
          <source>ARM family&amp;mdash;</source>
          <target state="translated">Семья ARM&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8a9b87087c41304359e59fe26411a54c3b656947" translate="yes" xml:space="preserve">
          <source>ARM targets support two incompatible representations for half-precision floating-point values. You must choose one of the representations and use it consistently in your program.</source>
          <target state="translated">Цели ARM поддерживают два несовместимых представления для значений с плавающей запятой с половинной точностью.Вы должны выбрать одно из представлений и последовательно использовать его в своей программе.</target>
        </trans-unit>
        <trans-unit id="c7649225dad7c2a0e06a3df7785837ccbdcddf7e" translate="yes" xml:space="preserve">
          <source>AVR family&amp;mdash;</source>
          <target state="translated">Семейство AVR&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="b6ce34d1fb413b0acbfa365b9e4b9f6fd56b845e" translate="yes" xml:space="preserve">
          <source>AVX instructions.</source>
          <target state="translated">AVX инструкции.</target>
        </trans-unit>
        <trans-unit id="5360c6483b9a9e1df7abdcb4de1b9b5a31a7db4c" translate="yes" xml:space="preserve">
          <source>AVX2 instructions.</source>
          <target state="translated">Инструкции AVX2.</target>
        </trans-unit>
        <trans-unit id="1d10807c0ae95d634b933c4c91561b625fdd7ee8" translate="yes" xml:space="preserve">
          <source>AVX5124FMAPS instructions.</source>
          <target state="translated">AVX5124FMAPS инструкции.</target>
        </trans-unit>
        <trans-unit id="2877f163ba5f992658ca47acc8b1854f3fe91f8e" translate="yes" xml:space="preserve">
          <source>AVX5124VNNIW instructions.</source>
          <target state="translated">AVX5124VNNIW инструкции.</target>
        </trans-unit>
        <trans-unit id="6aaaf18e4ab544cbae42a58b9cf1cac769995f49" translate="yes" xml:space="preserve">
          <source>AVX512BITALG instructions.</source>
          <target state="translated">Инструкции AVX512BITALG.</target>
        </trans-unit>
        <trans-unit id="e6c802e92787ca04a74935e0b7ab771a52b734eb" translate="yes" xml:space="preserve">
          <source>AVX512BW instructions.</source>
          <target state="translated">AVX512BW инструкции.</target>
        </trans-unit>
        <trans-unit id="ed3621c799203e17dc8a8e2affcd32cfee406953" translate="yes" xml:space="preserve">
          <source>AVX512CD instructions.</source>
          <target state="translated">Инструкции AVX512CD.</target>
        </trans-unit>
        <trans-unit id="734e989680da5e12fff96a9678b5efdb7f080ad8" translate="yes" xml:space="preserve">
          <source>AVX512DQ instructions.</source>
          <target state="translated">Инструкции AVX512DQ.</target>
        </trans-unit>
        <trans-unit id="ab4d6a088fb02d341f438d1a8b690b1d06bd6a6f" translate="yes" xml:space="preserve">
          <source>AVX512ER instructions.</source>
          <target state="translated">Инструкции AVX512ER.</target>
        </trans-unit>
        <trans-unit id="9e79b06b712a8ed9dc7a5818dbaa8055049287e6" translate="yes" xml:space="preserve">
          <source>AVX512F instructions.</source>
          <target state="translated">Инструкции AVX512F.</target>
        </trans-unit>
        <trans-unit id="a774d2186ac710be1f1d2b1823b920ecc713d1ba" translate="yes" xml:space="preserve">
          <source>AVX512IFMA instructions.</source>
          <target state="translated">Инструкции AVX512IFMA.</target>
        </trans-unit>
        <trans-unit id="a01464cdaa2c7a778b9758cae6be675e4fe0b633" translate="yes" xml:space="preserve">
          <source>AVX512PF instructions.</source>
          <target state="translated">Инструкции AVX512PF.</target>
        </trans-unit>
        <trans-unit id="90f8339b23ce90729e637c7a3a364d024582dd8c" translate="yes" xml:space="preserve">
          <source>AVX512VBMI instructions.</source>
          <target state="translated">AVX512VBMI инструкции.</target>
        </trans-unit>
        <trans-unit id="60db97c4b4db27b3430715d1af3a5a33414556d6" translate="yes" xml:space="preserve">
          <source>AVX512VBMI2 instructions.</source>
          <target state="translated">AVX512VBMI2 инструкции.</target>
        </trans-unit>
        <trans-unit id="4be842cb121c07bbfe15b74f0e979638742b0293" translate="yes" xml:space="preserve">
          <source>AVX512VL instructions.</source>
          <target state="translated">Инструкции AVX512VL.</target>
        </trans-unit>
        <trans-unit id="644733f8c866e0e47cbcfa44a51986c10011d89b" translate="yes" xml:space="preserve">
          <source>AVX512VNNI instructions.</source>
          <target state="translated">Инструкции AVX512VNNI.</target>
        </trans-unit>
        <trans-unit id="53a0313f00ad630fa2e77fff34864e43bc34cbe7" translate="yes" xml:space="preserve">
          <source>AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">Инструкции AVX512VPOPCNTDQ.</target>
        </trans-unit>
        <trans-unit id="94e869970cd001add8f88d68dc06d771dcf6a716" translate="yes" xml:space="preserve">
          <source>Abort the current transaction. When no transaction is active this is a no-op. The &lt;var&gt;status&lt;/var&gt; is an 8-bit constant; its value is encoded in the return value from &lt;code&gt;_xbegin&lt;/code&gt;.</source>
          <target state="translated">Прервать текущую транзакцию. Когда нет активных транзакций, это не работает. &lt;var&gt;status&lt;/var&gt; представляет собой 8-битовую константу; его значение закодировано в возвращаемом значении из &lt;code&gt;_xbegin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06529d24f685cb943a5ccbec8926618c923b5a20" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two paired-single values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">Абсолютное сравнение двух спаренных-одиночных значения ( &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="df073c7d1c50e06cd4608c23a66611cf902ab538" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two scalar values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">Абсолютное сравнение двух скалярных величин ( &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f722ac4229dd26c3b68dd80d6e1f64e995895dbe" translate="yes" xml:space="preserve">
          <source>Absolute value (&lt;code&gt;abs.ps&lt;/code&gt;).</source>
          <target state="translated">Абсолютное значение ( &lt;code&gt;abs.ps&lt;/code&gt; . / Сек. ).</target>
        </trans-unit>
        <trans-unit id="4daf0f1c1f813e9102db1a5994f1b9e8323b97c9" translate="yes" xml:space="preserve">
          <source>Accept &amp;lsquo;</source>
          <target state="translated">Принять '</target>
        </trans-unit>
        <trans-unit id="1b2da276a5f9c648bf9aca0b0668639225e93b2f" translate="yes" xml:space="preserve">
          <source>Accept imaginary, fixed-point, or machine-defined literal number suffixes as GNU extensions. When this option is turned off these suffixes are treated as C++11 user-defined literal numeric suffixes. This is on by default for all pre-C++11 dialects and all GNU dialects:</source>
          <target state="translated">Принимайте воображаемые,фиксированные или определяемые машиной буквенные суффиксы чисел в качестве расширений GNU.Когда эта опция выключена,эти суффиксы рассматриваются как определяемые пользователем буквенно-цифровые суффиксы на языке C++11.По умолчанию эта опция включена для всех диалектов до C++11 и всех диалектов GNU:</target>
        </trans-unit>
        <trans-unit id="a081bde4daabce186fc90fa0db98f145d7ef25aa" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Microsoft header files.</source>
          <target state="translated">Примите некоторые нестандартные конструкции,используемые в заголовочных файлах Microsoft.</target>
        </trans-unit>
        <trans-unit id="8ce1e6741eac355bc7dded05833655b003ffbcb7" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Plan 9 code.</source>
          <target state="translated">Принять некоторые нестандартные конструкции,используемые в коде Plan 9.</target>
        </trans-unit>
        <trans-unit id="d6ca16d1d2f90084c15b7909650d30bcccb6d876" translate="yes" xml:space="preserve">
          <source>Accept universal character names and extended characters in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be39a99ef887dbe2361b7a8f01c005db47949d8d" translate="yes" xml:space="preserve">
          <source>Accept universal character names in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="translated">Принимать универсальные имена символов в идентификаторах.Эта опция включена по умолчанию для C99 (и более поздних стандартных версий C)и C++.</target>
        </trans-unit>
        <trans-unit id="0f43c08aeb944b0a767a69ba0fb81ec15c2500b4" translate="yes" xml:space="preserve">
          <source>Accept variadic functions without named parameters.</source>
          <target state="translated">Принимать вариадические функции без именованных параметров.</target>
        </trans-unit>
        <trans-unit id="045e8c6e57a163b8d206267b0ad429f37b12bd4b" translate="yes" xml:space="preserve">
          <source>Accesses through pointers to types with this attribute are not subject to type-based alias analysis, but are instead assumed to be able to alias any other type of objects. In the context of section 6.5 paragraph 7 of the C99 standard, an lvalue expression dereferencing such a pointer is treated like having a character type. See</source>
          <target state="translated">Доступы через указатели к типам с данным атрибутом не являются предметом анализа псевдонимов на основе типов,а вместо этого предполагается,что они могут быть псевдонимом любого другого типа объектов.В контексте пункта 7 раздела 6.5 стандарта С99 выражение lvalue,разыменующее такой указатель,рассматривается как имеющее символьный тип.См..</target>
        </trans-unit>
        <trans-unit id="0e0bf5b2a877ef7b91241baabde260a26b7a132e" translate="yes" xml:space="preserve">
          <source>Accesses to bit-fields even in volatile objects works by accessing larger objects, such as a byte or a word. You cannot rely on what size of object is accessed in order to read or write the bit-field; it may even vary for a given bit-field according to the precise usage.</source>
          <target state="translated">Доступ к битовым полям даже в нестабильных объектах работает путем доступа к более крупным объектам,таким как байт или слово.Вы не можете полагаться на то,какой размер объекта доступен для чтения или записи битового поля;он даже может варьироваться для данного битового поля в зависимости от его точного использования.</target>
        </trans-unit>
        <trans-unit id="853e90163908be81a9a0fb1ee291ab1b4ba5a6c2" translate="yes" xml:space="preserve">
          <source>Accesses to non-volatile objects are not ordered with respect to volatile accesses. You cannot use a volatile object as a memory barrier to order a sequence of writes to non-volatile memory. For instance:</source>
          <target state="translated">Доступ к энергонезависимым объектам не заказывается в отношении энергонезависимых объектов.Нельзя использовать энергонезависимый объект в качестве барьера памяти для заказа последовательности записей в энергонезависимую память.Например:</target>
        </trans-unit>
        <trans-unit id="c072e2c48755b5522f29c41ec4ff83f53ff94a3e" translate="yes" xml:space="preserve">
          <source>Accesses to the variable may be optimized as usual and the register remains available for allocation and use in any computations, provided that observable values of the variable are not affected.</source>
          <target state="translated">Доступы к переменной могут быть оптимизированы как обычно,и регистр остается доступным для выделения и использования в любых вычислениях,при условии,что наблюдаемые значения переменной не будут затронуты.</target>
        </trans-unit>
        <trans-unit id="5d925b3885b30b4085b6d48f83637a9fdd674d3f" translate="yes" xml:space="preserve">
          <source>Accessing data from C programs without using input/output operands (such as by using global symbols directly from the assembler template) may not work as expected. Similarly, calling functions directly from an assembler template requires a detailed understanding of the target assembler and ABI.</source>
          <target state="translated">Доступ к данным из программ на языке С без использования операндов ввода/вывода (например,с помощью глобальных символов непосредственно из шаблона ассемблера)может работать не так,как ожидалось.Аналогичным образом,вызов функций непосредственно из ассемблерного шаблона требует детального понимания целевого ассемблера и ABI.</target>
        </trans-unit>
        <trans-unit id="aea1f643245ad21355d1a144988c7b86dcf2187a" translate="yes" xml:space="preserve">
          <source>According to the C standard, such an expression is an rvalue whose type is the unqualified version of its original type, i.e. &lt;code&gt;int&lt;/code&gt;. Whether GCC interprets this as a read of the volatile object being pointed to or only as a request to evaluate the expression for its side effects depends on this type.</source>
          <target state="translated">Согласно стандарту C, таким выражением является rvalue, тип которого является неквалифицированной версией исходного типа, то есть &lt;code&gt;int&lt;/code&gt; . Интерпретирует ли GCC это как чтение изменяемого объекта, на который указывает, или только как запрос на оценку выражения для его побочных эффектов, зависит от этого типа.</target>
        </trans-unit>
        <trans-unit id="35037aeb8678de2c00ed45aeca3de92268d726be" translate="yes" xml:space="preserve">
          <source>Accumulate an option for &amp;lsquo;</source>
          <target state="translated">Накопите опцион на '</target>
        </trans-unit>
        <trans-unit id="a3826f28e4e210d0b17ec990e0a882bb608802f9" translate="yes" xml:space="preserve">
          <source>Accumulate outgoing function arguments and acquire/release the needed stack space for outgoing function arguments once in function prologue/epilogue. Without this option, outgoing arguments are pushed before calling a function and popped afterwards.</source>
          <target state="translated">Соберите исходящие аргументы функции и получите/отпустите необходимое пространство стека для исходящих аргументов функции один раз в функции prologue/epilogue.Без этой опции исходящие аргументы выталкиваются перед вызовом функции,а затем выталкиваются.</target>
        </trans-unit>
        <trans-unit id="dc171ad6354a6828c71d9648018df6749febe991" translate="yes" xml:space="preserve">
          <source>Accumulator register.</source>
          <target state="translated">Регистр аккумулятора.</target>
        </trans-unit>
        <trans-unit id="554b8869b285c571ad11f29cd87ecd2c94a39e50" translate="yes" xml:space="preserve">
          <source>Ada source code file containing a library unit body (a subprogram or package body). Such files are also called &lt;em&gt;bodies&lt;/em&gt;.</source>
          <target state="translated">Файл исходного кода Ada, содержащий тело модуля библиотеки (подпрограмму или тело пакета). Такие файлы еще называют &lt;em&gt;телами&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4b2989ddb4c2391d408222a27d0f7e97c4843dda" translate="yes" xml:space="preserve">
          <source>Ada source code file that contains a library unit declaration (a declaration of a package, subprogram, or generic, or a generic instantiation), or a library unit renaming declaration (a package, generic, or subprogram renaming declaration). Such files are also called &lt;em&gt;specs&lt;/em&gt;.</source>
          <target state="translated">Файл исходного кода Ada, который содержит объявление библиотечного модуля (объявление пакета, подпрограммы, универсального или универсального экземпляра) или объявление переименования библиотечного модуля (объявление переименования пакета, универсального модуля или подпрограммы). Такие файлы также называются &lt;em&gt;спецификациями&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="885d4a696efd6405b314fabe588d5e90299b2183" translate="yes" xml:space="preserve">
          <source>Add &amp;ldquo;thread storage duration&amp;rdquo; to the list in paragraph 1.</source>
          <target state="translated">Добавьте &amp;laquo;продолжительность хранения потока&amp;raquo; в список в пункте 1.</target>
        </trans-unit>
        <trans-unit id="b86ee756f777d093031a2ef7598a20edf7c225e4" translate="yes" xml:space="preserve">
          <source>Add 8 bytes to an offsettable memory reference. Useful when accessing the high 8 bytes of SSE values. For a memref in (%rax), it generates</source>
          <target state="translated">Добавьте 8 байт в опорную память со смещением.Полезно при обращении к высоким 8 байтам SSE-значений.Для запоминающего устройства в (%rax),оно генерирует</target>
        </trans-unit>
        <trans-unit id="4790fd26dc16d553ca9f40c8e3122f144c79668c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list in paragraph 1.</source>
          <target state="translated">Добавьте &lt;code&gt;__thread&lt;/code&gt; в список в пункте 1.</target>
        </trans-unit>
        <trans-unit id="a776e64e6b39926909868acf47332b1f06fea4a3" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of specifiers in paragraph 3.</source>
          <target state="translated">Добавьте &lt;code&gt;__thread&lt;/code&gt; в список спецификаторов в пункте 3.</target>
        </trans-unit>
        <trans-unit id="7ae62118c00710deaec9ef5e1ca04437d3f24b0d" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of storage class specifiers in paragraph 1.</source>
          <target state="translated">Добавьте &lt;code&gt;__thread&lt;/code&gt; в список описателей класса хранения в пункте 1.</target>
        </trans-unit>
        <trans-unit id="ca9035627ef94891bbb5d203d19159bca7ef3d20" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt;.</source>
          <target state="translated">Добавьте &lt;code&gt;__thread&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d24fa0d264612fefce413cb080bc55058598cb7" translate="yes" xml:space="preserve">
          <source>Add after paragraph 3</source>
          <target state="translated">Добавить после пункта 3</target>
        </trans-unit>
        <trans-unit id="69d6be3cf4356a47a61429765c19c67c73985946" translate="yes" xml:space="preserve">
          <source>Add after paragraph 4</source>
          <target state="translated">Добавить после пункта 4</target>
        </trans-unit>
        <trans-unit id="6c93420cec677cdd1b461d1d94e40f0e5ce17fec" translate="yes" xml:space="preserve">
          <source>Add after paragraph 5</source>
          <target state="translated">Добавить после пункта 5</target>
        </trans-unit>
        <trans-unit id="cf5cebdb7710016b6f480e1dcf7594bfb0735ab9" translate="yes" xml:space="preserve">
          <source>Add after paragraph 6</source>
          <target state="translated">Добавить после пункта 6</target>
        </trans-unit>
        <trans-unit id="e6ee990db3ecfcd2015326c23234c180361bb454" translate="yes" xml:space="preserve">
          <source>Add code so that program flow &lt;em&gt;arcs&lt;/em&gt; are instrumented. During execution the program records how many times each branch and call is executed and how many times it is taken or returns. On targets that support constructors with priority support, profiling properly handles constructors, destructors and C++ constructors (and destructors) of classes which are used as a type of a global variable.</source>
          <target state="translated">Добавьте код, чтобы инструментальные &lt;em&gt;дуги&lt;/em&gt; потока программы были инструментами. Во время выполнения программа записывает, сколько раз выполнялось каждое ответвление и вызов и сколько раз они были выполнены или возвращены. На целевых объектах, поддерживающих конструкторы с поддержкой приоритета, профилирование правильно обрабатывает конструкторы, деструкторы и конструкторы C ++ (и деструкторы) классов, которые используются как тип глобальной переменной.</target>
        </trans-unit>
        <trans-unit id="79f504a568cb02675dcb4fa7f761de4ec8eef873" translate="yes" xml:space="preserve">
          <source>Add description attributes to some DWARF DIEs that have no name attribute, such as artificial variables, external references and call site parameter DIEs.</source>
          <target state="translated">Добавьте атрибуты описания к некоторым DWARF DIE,которые не имеют атрибута имени,например,искусственные переменные,внешние ссылки и параметр call site DIE.</target>
        </trans-unit>
        <trans-unit id="71433ea39bacba1c32fb50a6079568ad524eb46d" translate="yes" xml:space="preserve">
          <source>Add directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for</source>
          <target state="translated">Добавить каталог &lt;var&gt;dir&lt;/var&gt; в список каталогов для поиска</target>
        </trans-unit>
        <trans-unit id="548bf62a1540dcbb0f428d7f5c59cbf2987dcf8a" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 1</source>
          <target state="translated">Добавить новый текст после пункта 1</target>
        </trans-unit>
        <trans-unit id="13e160272edc000ac3b59f7e3c239601278b19a4" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 6</source>
          <target state="translated">Добавить новый текст после пункта 6</target>
        </trans-unit>
        <trans-unit id="b0ab0cd8ae6eaeee09a517ab6e0fab22009af14c" translate="yes" xml:space="preserve">
          <source>Add new text before paragraph 3</source>
          <target state="translated">Добавить новый текст перед пунктом 3</target>
        </trans-unit>
        <trans-unit id="09310e0a5ba6730b457158c35b8623195000a4a3" translate="yes" xml:space="preserve">
          <source>Add support for multithreading with the &lt;em&gt;dce thread&lt;/em&gt; library under HP-UX. This option sets flags for both the preprocessor and linker.</source>
          <target state="translated">Добавьте поддержку многопоточности с помощью библиотеки &lt;em&gt;потоков dce&lt;/em&gt; в HP-UX. Эта опция устанавливает флаги как для препроцессора, так и для компоновщика.</target>
        </trans-unit>
        <trans-unit id="2df2581a5423cd3eaf9365ee07a19f72370b3fc1" translate="yes" xml:space="preserve">
          <source>Add the directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for header files during preprocessing. If &lt;var&gt;dir&lt;/var&gt; begins with &amp;lsquo;</source>
          <target state="translated">Добавьте каталог &lt;var&gt;dir&lt;/var&gt; в список каталогов, в которых будет производиться поиск файлов заголовков во время предварительной обработки. Если &lt;var&gt;dir&lt;/var&gt; начинается с '</target>
        </trans-unit>
        <trans-unit id="73c333940f1537361f906bee03e2343442706250" translate="yes" xml:space="preserve">
          <source>Add the framework directory &lt;var&gt;dir&lt;/var&gt; to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by</source>
          <target state="translated">Добавьте каталог фреймворка &lt;var&gt;dir&lt;/var&gt; в начало списка каталогов для поиска файлов заголовков. Эти каталоги чередуются с каталогами, указанными в</target>
        </trans-unit>
        <trans-unit id="6e8c5a8e482b4eb45d5df440bbd4aa57581a1379" translate="yes" xml:space="preserve">
          <source>Additional Floating Types.</source>
          <target state="translated">Дополнительные плавающие типы.</target>
        </trans-unit>
        <trans-unit id="fbfd7f5a311b0863e336e4d5dd611078e4f5f005" translate="yes" xml:space="preserve">
          <source>Additional block information may succeed each line, when requested by command line option. The &lt;var&gt;execution_count&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">Дополнительная информация о блоке может следовать за каждой строкой, если запрашивается параметром командной строки. &lt;var&gt;execution_count&lt;/var&gt; является &quot;</target>
        </trans-unit>
        <trans-unit id="3a265ea53c72053fec1245e548879142e841e602" translate="yes" xml:space="preserve">
          <source>Additional built-in functions are available for the 64-bit PowerPC family of processors, for efficient use of 128-bit floating point (&lt;code&gt;__float128&lt;/code&gt;) values.</source>
          <target state="translated">Дополнительные встроенные функции доступны для 64-битных процессоров семейства PowerPC для эффективного использования 128-битных значений с плавающей запятой ( &lt;code&gt;__float128&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e400fc31f2b8160db0d8588871c49194b1a49e9" translate="yes" xml:space="preserve">
          <source>Additional floating-point exceptions, rounding modes, environments, and classifications, and their macro names (C99 and C11 7.6, C99 and C11 7.12).</source>
          <target state="translated">Дополнительные исключения с плавающей точкой,режимы округления,окружения и классификации,а также их макроимени (C99 и C11 7.6,C99 и C11 7.12).</target>
        </trans-unit>
        <trans-unit id="9b88de1196308385f5d14de9c11ffbabcd4f7f0a" translate="yes" xml:space="preserve">
          <source>Additional post-processing of the returned value may be needed, see &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">Может потребоваться дополнительная постобработка возвращаемого значения, см. &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b6fd1bd03704b21e269c633949f84ccf5e8856f" translate="yes" xml:space="preserve">
          <source>Additional registers typically used only in prologues and epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.</source>
          <target state="translated">Дополнительные регистры обычно используются только в прологах и эпилогах:RETS,RETN,RETI,RETX,RETE,ASTAT,SEQSTAT и USP.</target>
        </trans-unit>
        <trans-unit id="880c2173ff65c5e972a9e4536af68b63da90141d" translate="yes" xml:space="preserve">
          <source>Additional restrictions are enforced for types with the reverse scalar storage order with regard to the scalar storage order of the target:</source>
          <target state="translated">Дополнительные ограничения накладываются на типы с обратным порядком скалярного хранения с учетом порядка скалярного хранения целевого:</target>
        </trans-unit>
        <trans-unit id="09bc67c6276506971828d824b07903a4f5f9de7b" translate="yes" xml:space="preserve">
          <source>Additionally inlining a function compiled with</source>
          <target state="translated">Дополнительно подчеркивая функцию,скомпилированную с</target>
        </trans-unit>
        <trans-unit id="bf8b67741ce8fd715c05645cbb36737b371211d3" translate="yes" xml:space="preserve">
          <source>Additionally on native AArch64 GNU/Linux systems the value &amp;lsquo;</source>
          <target state="translated">Кроме того, в собственных системах AArch64 GNU / Linux значение '</target>
        </trans-unit>
        <trans-unit id="c9983bdb073bd2da3d6b02f0173dccb4761318ac" translate="yes" xml:space="preserve">
          <source>Additionally the &amp;lsquo;</source>
          <target state="translated">Дополнительно</target>
        </trans-unit>
        <trans-unit id="c32c6fe01da4320e1de2565ba6da0578715fa9c4" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;CFStringRefs&lt;/code&gt; (defined by the &lt;code&gt;CoreFoundation&lt;/code&gt; headers) may also be used as format arguments. Note that the relevant headers are only likely to be available on Darwin (OSX) installations. On such installations, the XCode and system documentation provide descriptions of &lt;code&gt;CFString&lt;/code&gt;, &lt;code&gt;CFStringRefs&lt;/code&gt; and associated functions.</source>
          <target state="translated">Кроме того, &lt;code&gt;CFStringRefs&lt;/code&gt; (определяемый заголовками &lt;code&gt;CoreFoundation&lt;/code&gt; ) также может использоваться в качестве аргументов формата. Обратите внимание, что соответствующие заголовки, скорее всего, будут доступны только в установках Darwin (OSX). На таких установках XCode и системная документация предоставляют описания &lt;code&gt;CFString&lt;/code&gt; , &lt;code&gt;CFStringRefs&lt;/code&gt; и связанных функций.</target>
        </trans-unit>
        <trans-unit id="06f45ee380b9da22c173cf9d9231907ee68fe13b" translate="yes" xml:space="preserve">
          <source>Additionally, some messages are logically nested within other messages, reflecting implementation details of the optimization passes.</source>
          <target state="translated">Кроме того,некоторые сообщения логически вложены в другие сообщения,отражающие детали реализации проходов оптимизации.</target>
        </trans-unit>
        <trans-unit id="0c630e5527eda313a2b833dd18abd8307a6cfdbd" translate="yes" xml:space="preserve">
          <source>Additionally, the architectural extension string may be specified on its own. This can be used to turn on and off particular architectural extensions without having to specify a particular architecture version or core. Example:</source>
          <target state="translated">Кроме того,строка архитектурного расширения может быть задана сама по себе.Это может быть использовано для включения и выключения определенных архитектурных расширений без необходимости указания версии или ядра конкретной архитектуры.Пример:</target>
        </trans-unit>
        <trans-unit id="e68df41b1d7fdc52b01b88eeb29e9ccd6bf7ed5e" translate="yes" xml:space="preserve">
          <source>Additionally, the following architectures, which lack support for the Thumb execution state, are recognized but support is deprecated: &amp;lsquo;</source>
          <target state="translated">Кроме того, следующие архитектуры, в которых отсутствует поддержка состояния выполнения Thumb, распознаются, но поддержка не рекомендуется: '</target>
        </trans-unit>
        <trans-unit id="a870075e1e81be429acf073e584f3d7c7e76cfdf" translate="yes" xml:space="preserve">
          <source>Additionally, the options</source>
          <target state="translated">Дополнительно,опции</target>
        </trans-unit>
        <trans-unit id="62846127f56afc07ef1c01a4fc578e26bdf7e831" translate="yes" xml:space="preserve">
          <source>Additionally, this option can specify that GCC should tune the performance of the code for a big.LITTLE system. Permissible names are: &amp;lsquo;</source>
          <target state="translated">Кроме того, этот параметр может указывать, что GCC должен настраивать производительность кода для системы big.LITTLE. Допустимые имена: '</target>
        </trans-unit>
        <trans-unit id="c9b7ac484445343c898ee0befeb5554f44a64e88" translate="yes" xml:space="preserve">
          <source>Additionally, warn when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="translated">Кроме того, предупреждать, когда определяемый пользователем буквальный оператор объявляется с буквальным идентификатором суффикса, который не начинается с символа подчеркивания. Идентификаторы буквального суффикса, которые не начинаются с подчеркивания, зарезервированы для будущей стандартизации.</target>
        </trans-unit>
        <trans-unit id="facde292bf415fbdf09a1828e9e0908e4c617e00" translate="yes" xml:space="preserve">
          <source>Address base register</source>
          <target state="translated">Базовый регистр адресов</target>
        </trans-unit>
        <trans-unit id="ac7731150d1c92cf663f9e708bf71a25213854ca" translate="yes" xml:space="preserve">
          <source>Address base register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">Адрес базового регистра,если включена 64-битная инструкция или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="e3421b8898caa7357be908d1653e3653974d758f" translate="yes" xml:space="preserve">
          <source>Address operand that is an indexed or indirect from a register (&amp;lsquo;</source>
          <target state="translated">Адресный операнд, который является индексированным или косвенным из регистра ('</target>
        </trans-unit>
        <trans-unit id="a7b7013cab33d0bd7c179b9b5712968750a0b395" translate="yes" xml:space="preserve">
          <source>Address operand without segment register.</source>
          <target state="translated">Адрес операнд без сегментного регистра.</target>
        </trans-unit>
        <trans-unit id="e849277f25d3c4f30a01955b54c92b602f3ff3ef" translate="yes" xml:space="preserve">
          <source>Address register</source>
          <target state="translated">регистр адресов</target>
        </trans-unit>
        <trans-unit id="a60bc1681a9f62ef4591ab15398d5eb38a430789" translate="yes" xml:space="preserve">
          <source>Address register (general purpose register except r0)</source>
          <target state="translated">Регистр адресов (регистр общего назначения,кроме r0)</target>
        </trans-unit>
        <trans-unit id="91d4fb05cb0843e13759b8b72edb33693debf000" translate="yes" xml:space="preserve">
          <source>Address register indirect addressing mode</source>
          <target state="translated">Режим косвенной адресации адресного регистра</target>
        </trans-unit>
        <trans-unit id="3a077484bf2c4ff84f71e4199f510082fe999bf3" translate="yes" xml:space="preserve">
          <source>Address registers</source>
          <target state="translated">реестры адресов</target>
        </trans-unit>
        <trans-unit id="5759236ebd061a0e0392b44c51e565f6ce6fcc43" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 16 bits wide.</source>
          <target state="translated">Адресные регистры, если они имеют ширину 16 бит.</target>
        </trans-unit>
        <trans-unit id="fdd0e10bf3a4572e30fda31a40f35542043406cf" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">Регистры адреса, когда они имеют ширину 24 бита.</target>
        </trans-unit>
        <trans-unit id="325382a51fa4bc25157b99f44454696d95890fcb" translate="yes" xml:space="preserve">
          <source>Address space identifiers may be used exactly like any other C type qualifier (e.g., &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;). See the N1275 document for more details.</source>
          <target state="translated">Идентификаторы адресного пространства могут использоваться точно так же, как любой другой квалификатор типа C (например, &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;volatile&lt;/code&gt; ). См. Документ N1275 для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="b5e65d5c203f07ad3d2623301ca2022f82e6bcd0" translate="yes" xml:space="preserve">
          <source>Address space layout randomization (ASLR) can lead to not binary identical PCH files. If you rely on stable PCH file contents disable ASLR when generating PCH files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0d1ee78feebd358e9ac4716831efeab01368b7" translate="yes" xml:space="preserve">
          <source>Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation unit if the integral types are the same size and if the next bit-field fits into the current allocation unit without crossing the boundary imposed by the common alignment requirements of the bit-fields.</source>
          <target state="translated">Прилегающие битовые поля упаковываются в одну и ту же 1-,2-или 4-байтовую единицу распределения,если интегральные типы имеют одинаковый размер и если следующее битовое поле вписывается в текущую единицу распределения,не пересекая границы,накладываемые общими требованиями к выравниванию битовых полей.</target>
        </trans-unit>
        <trans-unit id="94636fe0e41073552acb8d30375f7c2b9b7fa2c2" translate="yes" xml:space="preserve">
          <source>After defining a global register variable, for the current compilation unit:</source>
          <target state="translated">После определения глобальной регистровой переменной,для текущей единицы компиляции:</target>
        </trans-unit>
        <trans-unit id="a160b9211c156fcb59476123ceefb14233c30de0" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic. If possible, eliminate the explicit comparison operation.</source>
          <target state="translated">После распределения регистров и разделения инструкций по распределению регистров,определите арифметические инструкции,которые вычисляют флаги процессора,похожие на операцию сравнения на основе этой арифметики.По возможности исключите операцию явного сравнения.</target>
        </trans-unit>
        <trans-unit id="9cd493414e0c8a63ccc996f89446d267fe9e1e5f" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.</source>
          <target state="translated">После распределения регистров и разделения инструкций по распределению после регистрации выполните передачу copy-propagation,чтобы попытаться уменьшить зависимости планирования и время от времени удалять копию.</target>
        </trans-unit>
        <trans-unit id="a0c15aec2fc1e009f616402ab13a6a8f9c982cca" translate="yes" xml:space="preserve">
          <source>After running a program compiled with</source>
          <target state="translated">После запуска программы,скомпилированной с</target>
        </trans-unit>
        <trans-unit id="1454e9ea83225a76df4ee5fd8a44b04ac91ebb88" translate="yes" xml:space="preserve">
          <source>After the prefix, there must be one or more additional constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;) that describe where the value resides. Common constraints include &amp;lsquo;</source>
          <target state="translated">После префикса должно быть одно или несколько дополнительных ограничений (см. &lt;a href=&quot;constraints#Constraints&quot;&gt;Ограничения&lt;/a&gt; ), которые описывают, где находится значение. Общие ограничения включают '</target>
        </trans-unit>
        <trans-unit id="87d629b413e62d8e858ca1323306d594503312be" translate="yes" xml:space="preserve">
          <source>Again, the call to &lt;code&gt;f()&lt;/code&gt; is not dependent on template arguments (there are no arguments that depend on the type &lt;code&gt;T&lt;/code&gt;, and it is also not otherwise specified that the call should be in a dependent context). Thus a global declaration of such a function must be available, since the one in the base class is not visible until instantiation time. The compiler will consequently produce the following error message:</source>
          <target state="translated">Опять же, вызов &lt;code&gt;f()&lt;/code&gt; не зависит от аргументов шаблона (нет аргументов, зависящих от типа &lt;code&gt;T&lt;/code&gt; , и также не указано иное, что вызов должен быть в зависимом контексте). Таким образом, должно быть доступно глобальное объявление такой функции, так как объявление в базовом классе не отображается до момента создания экземпляра. В результате компилятор выдаст следующее сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="e15a8d239570fd7618da66d01432b0ca503636ad" translate="yes" xml:space="preserve">
          <source>Aggregates with this attribute are invalid, even if they are of the same size as a corresponding scalar. For example, the declaration:</source>
          <target state="translated">Агрегаты с этим атрибутом недействительны,даже если они имеют тот же размер,что и соответствующий скаляр.Например,декларация:</target>
        </trans-unit>
        <trans-unit id="9ffe001744d57fb7d843a75b3de19edfb4a4cd40" translate="yes" xml:space="preserve">
          <source>Aliases of</source>
          <target state="translated">псевдонимы</target>
        </trans-unit>
        <trans-unit id="2f7b5a2fcf03ab39f29a64817524ffd647a4fc18" translate="yes" xml:space="preserve">
          <source>Align all branch targets to a power-of-two boundary.</source>
          <target state="translated">Выровняйте все ветви в соответствии с границей силы двух ветвей.</target>
        </trans-unit>
        <trans-unit id="784e20f54ecda5213d66bcc1bc3f5f199a64e7ea" translate="yes" xml:space="preserve">
          <source>Align all loops to a 32-byte boundary.</source>
          <target state="translated">Выравнивание всех циклов до границы в 32 байта.</target>
        </trans-unit>
        <trans-unit id="a2e1e4cb8c2ddc659aedc1c3a6dfffeb002bdbe7" translate="yes" xml:space="preserve">
          <source>Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping. In this case, no dummy operations need be executed.</source>
          <target state="translated">Выровняйте мишени ветвей до границы силы двоих,для мишеней ветвей,где мишени могут быть достигнуты только с помощью прыжков.В этом случае не требуется выполнение фиктивных операций.</target>
        </trans-unit>
        <trans-unit id="2e8345e97e639fae1caa53fafd777f32b2148811" translate="yes" xml:space="preserve">
          <source>Align doubles at 64-bit boundaries. Note that this changes the calling conventions, and thus some functions from the standard C library do not work unless you recompile it first with</source>
          <target state="translated">Выравнивание удваивается на 64-битных границах.Обратите внимание,что это меняет соглашения по вызову,и поэтому некоторые функции из стандартной библиотеки Си не будут работать,если вы сначала не перекомпилируете их с помощью</target>
        </trans-unit>
        <trans-unit id="36a2b427b91139b8587d4cbfe16eb7a63f8affad" translate="yes" xml:space="preserve">
          <source>Align loops to a power-of-two boundary. If the loops are executed many times, this makes up for any execution of the dummy padding instructions.</source>
          <target state="translated">Выровняйте петли до границы силы двойки.Если шлейфы выполняются многократно,это компенсирует любое выполнение инструкций по набивке манекена.</target>
        </trans-unit>
        <trans-unit id="fb4c088e2c0ec9d07a3a585878097d5ea3d18362" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="translated">Выровняйте начало функций со следующей степенью двойки больше &lt;var&gt;n&lt;/var&gt; , пропуская до &lt;var&gt;m&lt;/var&gt; -1 байтов. Это гарантирует, что по крайней мере первые &lt;var&gt;m&lt;/var&gt; байтов функции могут быть извлечены ЦП без пересечения &lt;var&gt;n&lt;/var&gt; - байтовой границы выравнивания.</target>
        </trans-unit>
        <trans-unit id="c4d41afbffbc15906243cd5ff7feb6499dec3822" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than or equal to &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790e74268060e0e6ade88cfb9c482c2bc048f9d0" translate="yes" xml:space="preserve">
          <source>Align variable (&lt;code&gt;alnv.ps&lt;/code&gt;).</source>
          <target state="translated">Переменная выравнивания ( &lt;code&gt;alnv.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="19bd4f0f0123a61d6b94fd1f26c48a5b466015b1" translate="yes" xml:space="preserve">
          <source>All condition registers: SCC, VCCZ, EXECZ</source>
          <target state="translated">Все регистры условий:SCC,VCCZ,EXECZ</target>
        </trans-unit>
        <trans-unit id="0ebe806ad92438745f4bad14dde213851c8a70c2" translate="yes" xml:space="preserve">
          <source>All dependences are costly.</source>
          <target state="translated">Все зависимости стоят дорого.</target>
        </trans-unit>
        <trans-unit id="0cca1530229b7b9e550b891f9a9b113625c13de2" translate="yes" xml:space="preserve">
          <source>All files specified by</source>
          <target state="translated">Все файлы,указанные в</target>
        </trans-unit>
        <trans-unit id="0eaba1cfa9a00eb4bd0b12d5b7310a8e6e1fa4c5" translate="yes" xml:space="preserve">
          <source>All implicitly popped input registers must be closer to the top of the reg-stack than any input that is not implicitly popped.</source>
          <target state="translated">Все неявно выскакивающие регистры ввода должны быть ближе к вершине рег-стэка,чем любые неявно выскакивающие входные регистры.</target>
        </trans-unit>
        <trans-unit id="3b1c013be47e44ec0e7b3eeaa220c1f24b9203e3" translate="yes" xml:space="preserve">
          <source>All memory orders are valid.</source>
          <target state="translated">Все заказы памяти действительны.</target>
        </trans-unit>
        <trans-unit id="71ff0e08a090942eb8e784cba6de91a4fd99fb49" translate="yes" xml:space="preserve">
          <source>All modules should be compiled with the same</source>
          <target state="translated">Все модули должны быть скомпилированы с одним и тем же</target>
        </trans-unit>
        <trans-unit id="f0bcaa344128e72d0d5e1b94c3b2fa0090b0e882" translate="yes" xml:space="preserve">
          <source>All objects that have neither thread storage duration, dynamic storage duration nor are local [&amp;hellip;].</source>
          <target state="translated">Все объекты, у которых нет ни продолжительности хранения потоков, ни продолжительности динамического хранения, ни локальных [&amp;hellip;].</target>
        </trans-unit>
        <trans-unit id="ec2545f5d42fce7e86616e30c2d782de4749997a" translate="yes" xml:space="preserve">
          <source>All of the routines are described in the Intel documentation to take &amp;ldquo;an optional list of variables protected by the memory barrier&amp;rdquo;. It&amp;rsquo;s not clear what is meant by that; it could mean that &lt;em&gt;only&lt;/em&gt; the listed variables are protected, or it could mean a list of additional variables to be protected. The list is ignored by GCC which treats it as empty. GCC interprets an empty list as meaning that all globally accessible variables should be protected.</source>
          <target state="translated">Все процедуры описаны в документации Intel, чтобы получить &amp;laquo;дополнительный список переменных, защищенных барьером памяти&amp;raquo;. Непонятно, что под этим подразумевается; это может означать, что защищены &lt;em&gt;только&lt;/em&gt; перечисленные переменные, или может означать список дополнительных переменных, которые необходимо защитить. Список игнорируется GCC, который считает его пустым. GCC интерпретирует пустой список как означающий, что все глобально доступные переменные должны быть защищены.</target>
        </trans-unit>
        <trans-unit id="2dc38cb28fe09de761809c6899ec0dfab5c95980" translate="yes" xml:space="preserve">
          <source>All other attributes</source>
          <target state="translated">Все остальные атрибуты</target>
        </trans-unit>
        <trans-unit id="4e1fe3c41d4a92f980feaffab352908a5ae600b4" translate="yes" xml:space="preserve">
          <source>All the above</source>
          <target state="translated">Все вышесказанное</target>
        </trans-unit>
        <trans-unit id="72ca116b6b2d46153e83f38824f95e8a5d694cf5" translate="yes" xml:space="preserve">
          <source>All the basic integer types can be used as base types, both as signed and as unsigned: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;. In addition, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; can be used to build floating-point vector types.</source>
          <target state="translated">Все основные целочисленные типы могут использоваться в качестве базовых типов как со знаком, так и без знака: &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; . Кроме того, для построения векторных типов с плавающей запятой можно использовать &lt;code&gt;float&lt;/code&gt; и &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8115dc4041976655c63e593fd53f619ce3ca975" translate="yes" xml:space="preserve">
          <source>All the data and read-only data segments must be within 512KB addressing space. The text segment must be within 16MB addressing space.</source>
          <target state="translated">Все сегменты данных и данных только для чтения должны находиться в пределах адресного пространства 512 КБ.Текстовый сегмент должен находиться в пределах 16 МБ адресного пространства.</target>
        </trans-unit>
        <trans-unit id="a642a04a04ca54e997a623213186ae992d1e6e8c" translate="yes" xml:space="preserve">
          <source>All the text and data segments can be within 4GB addressing space.</source>
          <target state="translated">Все текстовые сегменты и сегменты данных могут находиться в пределах 4 ГБ адресного пространства.</target>
        </trans-unit>
        <trans-unit id="bd8b82ccf3682d163d774079a9dc8ccb0aa660ee" translate="yes" xml:space="preserve">
          <source>All visibilities are supported on many, but not all, ELF targets (supported when the assembler supports the &amp;lsquo;</source>
          <target state="translated">Все возможности видимости поддерживаются на многих, но не на всех, целевых объектах ELF (поддерживаются, когда ассемблер поддерживает '</target>
        </trans-unit>
        <trans-unit id="622f4dc5287fcd41d6f3a24869b2a0df614a0723" translate="yes" xml:space="preserve">
          <source>Allocate to an &lt;code&gt;enum&lt;/code&gt; type only as many bytes as it needs for the declared range of possible values. Specifically, the &lt;code&gt;enum&lt;/code&gt; type is equivalent to the smallest integer type that has enough room.</source>
          <target state="translated">Выделяйте &lt;code&gt;enum&lt;/code&gt; типу столько байтов, сколько необходимо для объявленного диапазона возможных значений. В частности, тип &lt;code&gt;enum&lt;/code&gt; эквивалентен наименьшему целочисленному типу, в котором достаточно места.</target>
        </trans-unit>
        <trans-unit id="1b577848b6e6ae4af92719e79079d9951a50047f" translate="yes" xml:space="preserve">
          <source>Allocate variables to the read-only data section first if possible, then next in the small data section if possible, otherwise in data. This gives slightly slower code than the default, but reduces the amount of RAM required when executing, and thus may be preferred for some embedded systems.</source>
          <target state="translated">Переменные следует,по возможности,назначать сначала в разделе данных,доступном только для чтения,а затем,по возможности,в разделе малых данных,в противном случае-в данных.Это дает немного более медленный код,чем по умолчанию,но уменьшает объем оперативной памяти,необходимый при выполнении,и,таким образом,может быть предпочтительнее для некоторых встраиваемых систем.</target>
        </trans-unit>
        <trans-unit id="482b6f74ff2eb85ead91bf4d63cb82360d5be63f" translate="yes" xml:space="preserve">
          <source>Allow (or do not allow) GCC to use the LOOP instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f3f43a7ca9147ffe2ba31d63c2ea8ec201486c" translate="yes" xml:space="preserve">
          <source>Allow arbitrary-sized immediates in bit operations.</source>
          <target state="translated">Разрешить произвольный размер немедленных операций в битах.</target>
        </trans-unit>
        <trans-unit id="ac2c75532a2e292a21a77540eaedf29f5c432d5a" translate="yes" xml:space="preserve">
          <source>Allow conditional expressions with mismatched types in the second and third arguments. The value of such an expression is void. This option is not supported for C++.</source>
          <target state="translated">Разрешить условные выражения с несовпадающими типами во втором и третьем аргументах.Значение такого выражения является недействительным.Эта опция не поддерживается для языка Си++.</target>
        </trans-unit>
        <trans-unit id="8d58e8c4bb0f63ea94500caf667ca947fcaa1a82" translate="yes" xml:space="preserve">
          <source>Allow fast jumps to the message dispatcher. On Darwin this is accomplished via the comm page.</source>
          <target state="translated">Разрешить быстрые переходы к диспетчеру сообщений.На Darwin это выполняется через страницу com.</target>
        </trans-unit>
        <trans-unit id="c73dadda8d4b49fb004b5103de76106d4f0b8557" translate="yes" xml:space="preserve">
          <source>Allow implicit conversions between vectors with differing numbers of elements and/or incompatible element types. This option should not be used for new code.</source>
          <target state="translated">Допускают неявные преобразования между векторами с различным количеством элементов и/или несовместимыми типами элементов.Данная опция не должна использоваться для нового кода.</target>
        </trans-unit>
        <trans-unit id="d0dbb659ed768befd508acb2601c588f49ddaa57" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that (a) assume that arguments and results are valid and (b) may violate IEEE or ANSI standards. When used at link time, it may include libraries or startup files that change the default FPU control word or other similar optimizations.</source>
          <target state="translated">Позволяет оптимизировать арифметику с плавающей точкой,которая (а)предполагает,что аргументы и результаты являются достоверными и (b)может нарушать стандарты IEEE или ANSI.При использовании во время линковки она может включать в себя библиотеки или файлы запуска,которые изменяют управляющее слово FPU по умолчанию или другие подобные оптимизации.</target>
        </trans-unit>
        <trans-unit id="773a6288517f96a4a7283887bb99a6fba71c957c" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or +-Infs.</source>
          <target state="translated">Позволяет оптимизировать арифметику с плавающей точкой,предполагая,что аргументы и результаты не являются NaNs или +-Infs.</target>
        </trans-unit>
        <trans-unit id="1e06113b53f739fa9c85ec94358e3f373eb320f8" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that ignore the signedness of zero. IEEE arithmetic specifies the behavior of distinct +0.0 and -0.0 values, which then prohibits simplification of expressions such as x+0.0 or 0.0*x (even with</source>
          <target state="translated">Разрешить оптимизацию арифметики с плавающей точкой,игнорирующей подпись нуля.Арифметика IEEE задает поведение различных значений +0.0 и -0.0,что затем запрещает упрощение таких выражений,как x+0.0 или 0.0*x (даже с учетом</target>
        </trans-unit>
        <trans-unit id="0eea9d2d0ec6a801c6ef5293eae12c7fbb21b59c" translate="yes" xml:space="preserve">
          <source>Allow optimizers to introduce new data races on stores. Set to 1 to allow, otherwise to 0.</source>
          <target state="translated">Позволяет оптимизаторам внедрять новые гонки данных на хранилищах.Для разрешения установите значение 1,в противном случае-0.</target>
        </trans-unit>
        <trans-unit id="c60cf758a077c6f503981387a6b0345419874bea" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsca&lt;/code&gt; instruction for sine and cosine approximations. The option</source>
          <target state="translated">Разрешить или запретить компилятору &lt;code&gt;fsca&lt;/code&gt; инструкцию fsca для аппроксимации синуса и косинуса. Опция</target>
        </trans-unit>
        <trans-unit id="70331cead1dc233186888055e035642315d5054e" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsrra&lt;/code&gt; instruction for reciprocal square root approximations. The option</source>
          <target state="translated">Разрешить или запретить компилятору &lt;code&gt;fsrra&lt;/code&gt; команду fsrra для вычисления обратного квадратного корня. Опция</target>
        </trans-unit>
        <trans-unit id="57cbe965449910b6f59559b0a1874d0d198b696a" translate="yes" xml:space="preserve">
          <source>Allow re-association of operands in series of floating-point operations. This violates the ISO C and C++ language standard by possibly changing computation result. NOTE: re-ordering may change the sign of zero as well as ignore NaNs and inhibit or create underflow or overflow (and thus cannot be used on code that relies on rounding behavior like &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt;. May also reorder floating-point comparisons and thus may not be used when ordered comparisons are required. This option requires that both</source>
          <target state="translated">Разрешить повторное объединение операндов в серии операций с плавающей запятой. Это нарушает стандарты языка ISO C и C ++, возможно, изменяя результат вычислений. ПРИМЕЧАНИЕ: переупорядочение может изменить знак нуля, а также игнорировать NaN и запретить или создать недополнение или переполнение (и, следовательно, не может использоваться в коде, который полагается на поведение округления, например &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt; . Может также изменять порядок сравнений с плавающей запятой и поэтому не может использоваться, когда требуются упорядоченные сравнения. Этот параметр требует, чтобы оба</target>
        </trans-unit>
        <trans-unit id="54ce20d4ec16fad4cd32f197249fdc3fb1dac290" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of more load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">Позвольте спекулятивному движению большего количества инструкций по нагрузке.Это имеет смысл только при планировании перед распределением регистров,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="1b47c26e732fcedac3b1858953b01853eb8422ec" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of some load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">Разрешить спекулятивное движение некоторых нагрузочных инструкций.Это имеет смысл только при планировании перед распределением регистров,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="f926321cb4f3fc49097c6857a3e7d152a19de395" translate="yes" xml:space="preserve">
          <source>Allow stop bits to be placed earlier than immediately preceding the instruction that triggered the stop bit. This can improve instruction scheduling, but does not always do so.</source>
          <target state="translated">Разрешить размещение стоповых битов раньше,чем непосредственно перед командой,сработавшей стоповый бит.Это может улучшить планирование инструкций,но не всегда.</target>
        </trans-unit>
        <trans-unit id="7905fb7386b21750ad5a1d1722446a6fdeb43598" translate="yes" xml:space="preserve">
          <source>Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same. For example, an &lt;code&gt;unsigned int&lt;/code&gt; can alias an &lt;code&gt;int&lt;/code&gt;, but not a &lt;code&gt;void*&lt;/code&gt; or a &lt;code&gt;double&lt;/code&gt;. A character type may alias any other type.</source>
          <target state="translated">Позвольте компилятору принять самые строгие правила псевдонима, применимые к компилируемому языку. Для C (и C ++) это активирует оптимизацию в зависимости от типа выражений. В частности, предполагается, что объект одного типа никогда не будет находиться по тому же адресу, что и объект другого типа, если только типы почти не совпадают. Например, &lt;code&gt;unsigned int&lt;/code&gt; может быть псевдонимом &lt;code&gt;int&lt;/code&gt; , но не &lt;code&gt;void*&lt;/code&gt; или &lt;code&gt;double&lt;/code&gt; . Тип символа может быть псевдонимом любого другого типа.</target>
        </trans-unit>
        <trans-unit id="bc2aa80da8f5ff65f45ae97b354110390c96c42f" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">Разрешить компилятору генерировать &lt;em&gt;инструкции Long Instruction Word,&lt;/em&gt; если целью является '</target>
        </trans-unit>
        <trans-unit id="f39db7389fdae7630a67f4845ba2f639259c8a4a" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate the &lt;em&gt;SETLB&lt;/em&gt; and &lt;em&gt;Lcc&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">Разрешить компилятору сгенерировать инструкции &lt;em&gt;SETLB&lt;/em&gt; и &lt;em&gt;Lcc,&lt;/em&gt; если целью является '</target>
        </trans-unit>
        <trans-unit id="57b9d18f30c753317a363448d4ac2396bae27e7d" translate="yes" xml:space="preserve">
          <source>Allow the compiler to introduce new data races on stores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7a919d8fa035f96c5d1af049879f0dd62e1421" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize using the assumption that a value of enumerated type can only be one of the values of the enumeration (as defined in the C++ standard; basically, a value that can be represented in the minimum number of bits needed to represent all the enumerators). This assumption may not be valid if the program uses a cast to convert an arbitrary integer value to the enumerated type.</source>
          <target state="translated">Позволить компилятору оптимизировать,используя предположение,что значение перечисляемого типа может быть только одним из значений перечисления (как определено в стандарте языка Си++;по сути,значение,которое может быть представлено в минимальном количестве бит,необходимом для представления всех перечислений).Это предположение может оказаться недействительным,если программа использует приведение произвольного целого значения к перечисляемому типу.</target>
        </trans-unit>
        <trans-unit id="33fc8a715b12ca22462902ef833240995e04a5d4" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use all of the available registers. By default registers &lt;code&gt;r24..r31&lt;/code&gt; are reserved for use in interrupt handlers. With this option enabled these registers can be used in ordinary functions as well.</source>
          <target state="translated">Разрешите компилятору использовать все доступные регистры. По умолчанию регистры &lt;code&gt;r24..r31&lt;/code&gt; зарезервированы для использования в обработчиках прерываний. Если эта опция включена, эти регистры также могут использоваться в обычных функциях.</target>
        </trans-unit>
        <trans-unit id="6303c2c94b5f256a55d06aa2be50e19fcb0df737" translate="yes" xml:space="preserve">
          <source>Allow the reciprocal of a value to be used instead of dividing by the value if this enables optimizations. For example &lt;code&gt;x / y&lt;/code&gt; can be replaced with &lt;code&gt;x * (1/y)&lt;/code&gt;, which is useful if &lt;code&gt;(1/y)&lt;/code&gt; is subject to common subexpression elimination. Note that this loses precision and increases the number of flops operating on the value.</source>
          <target state="translated">Разрешить использование обратного значения вместо деления на значение, если это позволяет оптимизацию. Например, &lt;code&gt;x / y&lt;/code&gt; можно заменить на &lt;code&gt;x * (1/y)&lt;/code&gt; , что полезно, если &lt;code&gt;(1/y)&lt;/code&gt; подлежит исключению общего подвыражения. Обратите внимание, что при этом теряется точность и увеличивается количество операций с ошибками.</target>
        </trans-unit>
        <trans-unit id="5cbc7a77a073ec8e91de85701bbe563110739962" translate="yes" xml:space="preserve">
          <source>Allow the store merging pass to introduce unaligned stores if it is legal to do so.</source>
          <target state="translated">Разрешите проездной билет на слияние магазинов для введения не выровненных магазинов,если это законно.</target>
        </trans-unit>
        <trans-unit id="b8c16f16485e58470d06579755ecbd0f929ac7fa" translate="yes" xml:space="preserve">
          <source>Allow to use truncation instead of rounding towards zero for fractional fixed-point types.</source>
          <target state="translated">Позволяет использовать усечение вместо округления до нуля для типов дробных фиксированных точек.</target>
        </trans-unit>
        <trans-unit id="8834a22ee0acee1821ccfc8e148c6cbb34655847" translate="yes" xml:space="preserve">
          <source>Allow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">Разрешить использование расширений более поздней стандартной версии DWARF,чем выбрано с помощью</target>
        </trans-unit>
        <trans-unit id="98ea6e4c4f75e6a8f8033c8b750f3d749cc09003" translate="yes" xml:space="preserve">
          <source>Allow/disallow treating the &lt;code&gt;__ea&lt;/code&gt; address space as superset of the generic address space. This enables explicit type casts between &lt;code&gt;__ea&lt;/code&gt; and generic pointer as well as implicit conversions of generic pointers to &lt;code&gt;__ea&lt;/code&gt; pointers. The default is to allow address space pointer conversions.</source>
          <target state="translated">Разрешить / запретить обработку адресного пространства &lt;code&gt;__ea&lt;/code&gt; как надмножества общего адресного пространства. Это позволяет явное приведение типов между &lt;code&gt;__ea&lt;/code&gt; и универсальным указателем, а также неявное преобразование универсальных указателей в указатели &lt;code&gt;__ea&lt;/code&gt; . По умолчанию разрешено преобразование указателя адресного пространства.</target>
        </trans-unit>
        <trans-unit id="74a5bb83513cc4e38a6504a7eaa0f1d977ac61b9" translate="yes" xml:space="preserve">
          <source>Allowable bit-field types other than &lt;code&gt;_Bool&lt;/code&gt;, &lt;code&gt;signed int&lt;/code&gt;, and &lt;code&gt;unsigned int&lt;/code&gt; (C99 and C11 6.7.2.1).</source>
          <target state="translated">Допустимые типы битовых полей, кроме &lt;code&gt;_Bool&lt;/code&gt; , &lt;code&gt;signed int&lt;/code&gt; и &lt;code&gt;unsigned int&lt;/code&gt; (C99 и C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="9672aa21a92b454bca4334e1b73511ba859e3019" translate="yes" xml:space="preserve">
          <source>Allows calls via function pointers (including virtual functions) to execute correctly regardless of whether the target code has been compiled for interworking or not. There is a small overhead in the cost of executing a function pointer if this option is enabled. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">Позволяет вызовам через указатели функций (в том числе и виртуальных)корректно исполняться вне зависимости от того,был ли целевой код скомпилирован для взаимодействия или нет.Небольшие накладные расходы на выполнение указателя функции,если эта опция включена.В конфигурациях AAPCS эта опция недействительна,так как по умолчанию включено взаимодействие.</target>
        </trans-unit>
        <trans-unit id="9fab16002619dc077a62263507de1c970a51b300" translate="yes" xml:space="preserve">
          <source>Also note that GCC emits the above sequence with additional Newton-Raphson step for vectorized single-float division and vectorized &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; already with</source>
          <target state="translated">Также обратите внимание, что GCC испускает &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; выше последовательность с дополнительным шагом Ньютона-Рафсона для векторизованного деления с одним поплавком и векторизованного sqrtf ( x ) уже с</target>
        </trans-unit>
        <trans-unit id="1a461c1e71dd5c0a03740ad367bc2a7b24233082" translate="yes" xml:space="preserve">
          <source>Also note that an &lt;code&gt;asm goto&lt;/code&gt; statement is always implicitly considered volatile.</source>
          <target state="translated">Также обратите внимание, что &lt;code&gt;asm goto&lt;/code&gt; всегда неявно считается изменчивым.</target>
        </trans-unit>
        <trans-unit id="767bf94dfe72662ddbd8e20120050c8f90e9046e" translate="yes" xml:space="preserve">
          <source>Also warn about cases where the compiler reduces the magnitude of a constant involved in a comparison. For example: &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; is simplified to &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt;. This is reported only at the highest warning level because this simplification applies to many comparisons, so this warning level gives a very large number of false positives.</source>
          <target state="translated">Также предупредите о случаях, когда компилятор уменьшает величину константы, участвующей в сравнении. Например: &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; упрощается до &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt; . Об этом сообщается только на самом высоком уровне предупреждения, потому что это упрощение применяется ко многим сравнениям, поэтому этот уровень предупреждения дает очень большое количество ложных срабатываний.</target>
        </trans-unit>
        <trans-unit id="c15f6772b26643b0ff617a164130fae2096f2324" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified to a constant. For example: &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt;. This can only be simplified when signed integer overflow is undefined, because &lt;code&gt;abs (INT_MIN)&lt;/code&gt; overflows to &lt;code&gt;INT_MIN&lt;/code&gt;, which is less than zero.</source>
          <target state="translated">Также предупредите о других случаях, когда сравнение упрощено до константы. Например: &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt; . Это можно упростить, только если знаковое целочисленное переполнение не определено, потому что &lt;code&gt;abs (INT_MIN)&lt;/code&gt; переполняется до &lt;code&gt;INT_MIN&lt;/code&gt; , которое меньше нуля.</target>
        </trans-unit>
        <trans-unit id="e8e800b6cdd36533f8ba6ba58f938d89e7317e5b" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified. For example: &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; is simplified to &lt;code&gt;x &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">Также предупредите о других случаях, когда сравнение упрощено. Например: &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; упрощается до &lt;code&gt;x &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2eccf451b029841db2d4f52cb1371fa4ffd7cc2" translate="yes" xml:space="preserve">
          <source>Also warn about other simplifications not covered by the above cases. For example: &lt;code&gt;(x * 10) / 5&lt;/code&gt; is simplified to &lt;code&gt;x * 2&lt;/code&gt;.</source>
          <target state="translated">Также предупредите о других упрощениях, не предусмотренных вышеупомянутыми случаями. Например: &lt;code&gt;(x * 10) / 5&lt;/code&gt; упрощается до &lt;code&gt;x * 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaf71652d194ffb84805956fe1b5940083ae517e" translate="yes" xml:space="preserve">
          <source>Also warn for dangerous uses of the GNU extension to &lt;code&gt;?:&lt;/code&gt; with omitted middle operand. When the condition in the &lt;code&gt;?&lt;/code&gt;: operator is a boolean expression, the omitted value is always 1. Often programmers expect it to be a value computed inside the conditional expression instead.</source>
          <target state="translated">Также предупредите об опасном использовании расширения GNU для &lt;code&gt;?:&lt;/code&gt; С опущенным средним операндом. Когда условие в &lt;code&gt;?&lt;/code&gt; : operator - это логическое выражение, опускаемое значение всегда равно 1. Часто программисты ожидают, что это будет значение, вычисленное внутри условного выражения.</target>
        </trans-unit>
        <trans-unit id="0777d5422fc8bc8f5bababa57c28335fb0cdc795" translate="yes" xml:space="preserve">
          <source>Also warn if a comparison like &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; appears; this is equivalent to &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt;, which is a different interpretation from that of ordinary mathematical notation.</source>
          <target state="translated">Также предупреждайте, если появляется сравнение типа &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; ; это эквивалентно &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt; , что отличается от интерпретации обычных математических обозначений.</target>
        </trans-unit>
        <trans-unit id="4e45248057e2324494ad069a7abd8071c0384ad1" translate="yes" xml:space="preserve">
          <source>Also warn when making a cast that introduces a type qualifier in an unsafe way. For example, casting &lt;code&gt;char **&lt;/code&gt; to &lt;code&gt;const char **&lt;/code&gt; is unsafe, as in this example:</source>
          <target state="translated">Также предупреждайте при выполнении приведения, которое небезопасно вводит квалификатор типа. Например, приведение &lt;code&gt;char **&lt;/code&gt; к &lt;code&gt;const char **&lt;/code&gt; небезопасно, как в этом примере:</target>
        </trans-unit>
        <trans-unit id="ebdf7f49c076ed9ff3a97d65da78f8767a5691c7" translate="yes" xml:space="preserve">
          <source>Also, some built-in functions prefer or require immediate numbers as parameters, because the corresponding DSP instructions accept both immediate numbers and register operands, or accept immediate numbers only. The immediate parameters are listed as follows.</source>
          <target state="translated">Кроме того,некоторые встроенные функции предпочитают или требуют в качестве параметров немедленных номеров,потому что соответствующие инструкции DSP принимают как немедленные номера,так и регистрационные операнды,или принимают только немедленные номера.Непосредственные параметры перечислены ниже.</target>
        </trans-unit>
        <trans-unit id="f5b2a9f079522dadbd70f5a362997b267591505d" translate="yes" xml:space="preserve">
          <source>Also, the ABI changed the mangling of template argument packs, &lt;code&gt;const_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, prefix increment/decrement, and a class scope function used as a template argument.</source>
          <target state="translated">Кроме того , ABI изменил коверкание шаблона аргументов пакетов, &lt;code&gt;const_cast&lt;/code&gt; , &lt;code&gt;static_cast&lt;/code&gt; , префикс увеличение / уменьшение, так и функцию видимости класса , используемую в качестве аргумента шаблона.</target>
        </trans-unit>
        <trans-unit id="bedbe72286a46ec20159c0af50884180a15a3619" translate="yes" xml:space="preserve">
          <source>Also, there are two special clobber arguments:</source>
          <target state="translated">Кроме того,есть два особых аргумента насчет клоунады:</target>
        </trans-unit>
        <trans-unit id="1793f4a326dd636d187c7ec419e47dec37d6305e" translate="yes" xml:space="preserve">
          <source>Also, you must provide function prototypes for all functions that take variable numbers of arguments (including &lt;code&gt;printf&lt;/code&gt;); otherwise incorrect code is generated for calls to those functions.</source>
          <target state="translated">Кроме того, вы должны предоставить прототипы функций для всех функций, которые принимают переменное количество аргументов (включая &lt;code&gt;printf&lt;/code&gt; ); в противном случае для вызовов этих функций создается неправильный код.</target>
        </trans-unit>
        <trans-unit id="b85df36ab018e13c039dd34eb2302708663f4af2" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization of loops marked with the OpenMP simd directive. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">Измените модель затрат, используемую для векторизации циклов, отмеченных директивой OpenMP simd. &lt;var&gt;model&lt;/var&gt; аргумент должен быть один из '</target>
        </trans-unit>
        <trans-unit id="f431f1054230ce8fcc7bc5eae8ec9ced8a86a188" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">Измените модель затрат, используемую для векторизации. &lt;var&gt;model&lt;/var&gt; аргумент должен быть один из '</target>
        </trans-unit>
        <trans-unit id="9fc71ca35ab8d8d40760c8ef39bc71ee861a4bcc" translate="yes" xml:space="preserve">
          <source>Alter the thread-local storage model to be used (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;). The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">Измените модель локального хранилища потока, которая будет использоваться (см. &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Локальный&lt;/a&gt; поток ). &lt;var&gt;model&lt;/var&gt; аргумент должен быть один из '</target>
        </trans-unit>
        <trans-unit id="2d63c6f25ef5c2c6707d16e831a6091cc8c50e17" translate="yes" xml:space="preserve">
          <source>Alter the update method for an application instrumented for profile feedback based optimization. The &lt;var&gt;method&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">Измените метод обновления для приложения, приспособленного для оптимизации на основе обратной связи профиля. &lt;var&gt;method&lt;/var&gt; аргумент должен быть одним из '</target>
        </trans-unit>
        <trans-unit id="a7ba2917cba97115bf3adee00dd20256ca8bef51" translate="yes" xml:space="preserve">
          <source>Alternately, you can reference labels using the actual C label name enclosed in brackets. For example, to reference a label named &lt;code&gt;carry&lt;/code&gt;, you can use &amp;lsquo;</source>
          <target state="translated">Кроме того, вы можете ссылаться на метки, используя фактическое имя метки C, заключенное в скобки. Например, чтобы ссылаться на метку с именем &lt;code&gt;carry&lt;/code&gt; , вы можете использовать '</target>
        </trans-unit>
        <trans-unit id="c04a618f555219675642e22c54d794ab28d7300f" translate="yes" xml:space="preserve">
          <source>Alternatively you can discover which binary optimizations are enabled by</source>
          <target state="translated">Кроме того,вы можете узнать,какие бинарные оптимизации включены с помощью</target>
        </trans-unit>
        <trans-unit id="1b2db455af7c311c86d9a9e68fe99ec219f1fdb6" translate="yes" xml:space="preserve">
          <source>Alternatively, the function attribute &lt;code&gt;noplt&lt;/code&gt; can be used to avoid calls through the PLT for specific external functions.</source>
          <target state="translated">В качестве альтернативы можно использовать атрибут функции &lt;code&gt;noplt&lt;/code&gt; , чтобы избежать вызовов через PLT для определенных внешних функций.</target>
        </trans-unit>
        <trans-unit id="724d746f6afeb6dcb4048f896627e2174930b360" translate="yes" xml:space="preserve">
          <source>Alternatively, you might decide to put the precompiled header file in a directory and use</source>
          <target state="translated">В качестве альтернативы,вы можете решить поместить прекомпилированный заголовочный файл в каталог и использовать</target>
        </trans-unit>
        <trans-unit id="95f269cf4efa79d9433eb0cf9a5bd7a136f8f62d" translate="yes" xml:space="preserve">
          <source>Although IRA uses a sophisticated algorithm to compress the conflict table, the table can still require excessive amounts of memory for huge functions. If the conflict table for a function could be more than the size in MB given by this parameter, the register allocator instead uses a faster, simpler, and lower-quality algorithm that does not require building a pseudo-register conflict table.</source>
          <target state="translated">Несмотря на то,что IRA использует сложный алгоритм для сжатия таблицы конфликтов,для выполнения огромных функций таблице все еще может потребоваться избыточный объем памяти.Если таблица конфликтов для функции может быть больше,чем размер в мегабайтах,задаваемый этим параметром,то аллокатор распределения регистров вместо этого использует более быстрый,простой и низкокачественный алгоритм,не требующий построения псевдо-таблицы конфликтов регистров.</target>
        </trans-unit>
        <trans-unit id="9b0be486c711e5de323bb610f3f803e2869a722a" translate="yes" xml:space="preserve">
          <source>Although an effort has been made to warn about all such cases, there are probably some cases that are not warned about, even though G++ is generating incompatible code. There may also be cases where warnings are emitted even though the code that is generated is compatible.</source>
          <target state="translated">Несмотря на то,что была предпринята попытка предупредить обо всех подобных случаях,наверняка есть случаи,о которых не предупреждают,даже если G++генерирует несовместимый код.Также могут быть случаи,когда предупреждения выдаются даже при совместимости генерируемого кода.</target>
        </trans-unit>
        <trans-unit id="91a8f5762db94ffdfef370246b2c12c4c385d73d" translate="yes" xml:space="preserve">
          <source>Although it is possible to define such a function, this is not very useful as it is not possible to read the arguments. This is only supported for C as this construct is allowed by C++.</source>
          <target state="translated">Хотя такую функцию можно определить,это не очень полезно,так как невозможно прочитать аргументы.Это поддерживается только для C,так как эта конструкция разрешена в C++.</target>
        </trans-unit>
        <trans-unit id="3aea130ff16faac0f0a72d4c21d30b19934fa1e8" translate="yes" xml:space="preserve">
          <source>Although the behavior is similar to the Gold Linker&amp;rsquo;s ICF optimization, GCC ICF works on different levels and thus the optimizations are not same - there are equivalences that are found only by GCC and equivalences found only by Gold.</source>
          <target state="translated">Хотя поведение похоже на оптимизацию ICF Gold Linker, GCC ICF работает на разных уровнях, и поэтому оптимизации не одинаковы - есть эквиваленты, которые обнаруживает только GCC, и эквивалентности, обнаруживаемые только Gold.</target>
        </trans-unit>
        <trans-unit id="cf2ebe14b431087c27c2301bbb04cfe4eb87ea4a" translate="yes" xml:space="preserve">
          <source>Although the primary usage of this attribute is for POD types, the attribute can also be applied to global C++ objects that are initialized by a constructor. In this case, the static initialization and destruction code for the object is emitted in each translation defining the object, but the calls to the constructor and destructor are protected by a link-once guard variable.</source>
          <target state="translated">Хотя основное использование этого атрибута происходит для типов POD,атрибут также может быть применен к глобальным объектам C++,которые инициализируются конструктором.В этом случае при каждой трансляции,определяющей объект,генерируется код статической инициализации и деструкции объекта,но вызовы конструктора и деструктора защищены защитной переменной link-once.</target>
        </trans-unit>
        <trans-unit id="419e2ab79b9a72e513efa7d620ba40673796ae3c" translate="yes" xml:space="preserve">
          <source>Although the size of a zero-length array is zero, an array member of this kind may increase the size of the enclosing type as a result of tail padding. The offset of a zero-length array member from the beginning of the enclosing structure is the same as the offset of an array with one or more elements of the same type. The alignment of a zero-length array is the same as the alignment of its elements.</source>
          <target state="translated">Хотя размер массива нулевой длины равен нулю,член массива такого типа может увеличить размер ограждающего типа в результате набивки хвоста.Смещение члена массива нулевой длины от начала структуры ограждения такое же,как и смещение массива с одним или несколькими элементами одного и того же типа.Выравнивание массива нулевой длины аналогично выравниванию его элементов.</target>
        </trans-unit>
        <trans-unit id="48a0b2e6239d57c9c30535eae8caf6619e4d8826" translate="yes" xml:space="preserve">
          <source>Altivec register if</source>
          <target state="translated">Altivec зарегистрировать если</target>
        </trans-unit>
        <trans-unit id="43210ad7cdf91a35ea9e54b8ca8e28c22c6e9fd2" translate="yes" xml:space="preserve">
          <source>Altivec register to use for double loads/stores or NO_REGS.</source>
          <target state="translated">Регистр Altivec,используемый для двойных загрузок/магазинов или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="1e72319ddb65cddc1596b72314174c11a529e4e9" translate="yes" xml:space="preserve">
          <source>Altivec register to use for float/32-bit int loads/stores or NO_REGS.</source>
          <target state="translated">Регистр Altivec,используемый для float/32-bit int load/stores или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="27667baa779021dc30ceb24d0b6298a36d1ae73c" translate="yes" xml:space="preserve">
          <source>Altivec vector register</source>
          <target state="translated">векторный регистр Altivec</target>
        </trans-unit>
        <trans-unit id="7213a39022a1a221aa305b421707bb55dfa13ff8" translate="yes" xml:space="preserve">
          <source>Always treat bit-fields as &lt;code&gt;int&lt;/code&gt;-sized.</source>
          <target state="translated">Всегда относитесь к битовым полям как к &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="549d944304e895a2c1d4531ead649e8cbf5063ad" translate="yes" xml:space="preserve">
          <source>Always use a library call.</source>
          <target state="translated">Всегда звоните в библиотеку.</target>
        </trans-unit>
        <trans-unit id="0b4062f8987d50153e0838000ddb5e4f41ad4e24" translate="yes" xml:space="preserve">
          <source>Among the consequences of these changes are that static data members of the same type with the same name but defined in different shared objects are different, so changing one does not change the other; and that pointers to function members defined in different shared objects may not compare equal. When this flag is given, it is a violation of the ODR to define types with the same name differently.</source>
          <target state="translated">Последствия этих изменений заключаются в том,что статические члены данных одного типа с одинаковым именем,но определенные в разных общих объектах,различаются,поэтому изменение одного не меняет другого;и что указатели на члены функции,определенные в разных общих объектах,могут не сравниваться равными.При установке этого флага,определение типов с одним и тем же именем по-разному является нарушением правил УСО.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="c5009a6f1efb8810f35df0d2766e52237ed673ad" translate="yes" xml:space="preserve">
          <source>An 8 bit value with exactly one bit set.</source>
          <target state="translated">Значение 8 бит с точностью до одного бита.</target>
        </trans-unit>
        <trans-unit id="73fdb3be2e0086894a1e44f055f6c3c5fe05581e" translate="yes" xml:space="preserve">
          <source>An 8-element vector constant with identical elements.</source>
          <target state="translated">8-элементная векторная константа с идентичными элементами.</target>
        </trans-unit>
        <trans-unit id="42e73ea7df5141021212bafc4bcfa0e59c8e090d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm goto&lt;/code&gt; statement cannot have outputs. This is due to an internal restriction of the compiler: control transfer instructions cannot have outputs. If the assembler code does modify anything, use the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber to force the optimizers to flush all register values to memory and reload them if necessary after the &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;asm goto&lt;/code&gt; заявление не может иметь выходы. Это связано с внутренним ограничением компилятора: инструкции передачи управления не могут иметь выходов. Если код ассемблера что-либо модифицирует, используйте &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber, чтобы заставить оптимизаторы сбрасывать все значения регистров в память и при необходимости перезагружать их после оператора &lt;code&gt;asm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04db20c14b6b3a82ba6832f795aabb1d2758d6a2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm&lt;/code&gt; statement has zero or more output operands indicating the names of C variables modified by the assembler code.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; утверждение имеет ноль или большее количество выходных операндов , указывающие имена переменного C , модифицированные с помощью кода ассемблера.</target>
        </trans-unit>
        <trans-unit id="c3ecf57ab1f86499d0414e65689faa519df6b817" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; type is not considered to be compatible with another &lt;code&gt;enum&lt;/code&gt; type even if both are compatible with the same integer type; this is what the C standard specifies. For example, &lt;code&gt;enum {foo, bar}&lt;/code&gt; is not similar to &lt;code&gt;enum {hot, dog}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; типа не считаются , чтобы быть совместимыми с другим &lt;code&gt;enum&lt;/code&gt; типа , даже если оба совместимы с тем же целым типом; это то, что определяет стандарт C. Например, &lt;code&gt;enum {foo, bar}&lt;/code&gt; не похоже на &lt;code&gt;enum {hot, dog}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="197244fadb4ff328f7464f8fb593d34255a64886" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier list&lt;/em&gt; is a sequence of one or more attribute specifiers, not separated by any other tokens.</source>
          <target state="translated">&lt;em&gt;Список атрибутов спецификатора&lt;/em&gt; представляет собой последовательность из одного или нескольких атрибутов спецификаторов, не отделено друг от каких - либо других маркеров.</target>
        </trans-unit>
        <trans-unit id="4db760995f077b22b4a4d97b7a5f59e2f43ffc2f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier&lt;/em&gt; is of the form &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt;. An &lt;em&gt;attribute list&lt;/em&gt; is a possibly empty comma-separated sequence of &lt;em&gt;attributes&lt;/em&gt;, where each attribute is one of the following:</source>
          <target state="translated">Спецификатор &lt;em&gt;атрибута&lt;/em&gt; имеет вид &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt; . &lt;em&gt;Список атрибутов&lt;/em&gt; является пустой , возможно , разделенными запятыми последовательности &lt;em&gt;атрибутов&lt;/em&gt; , где каждый атрибут является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="7298880ccde6d5d2f135cff890ce9dd813a48a5a" translate="yes" xml:space="preserve">
          <source>An Altivec vector register (VR), &lt;code&gt;v0&lt;/code&gt;&amp;hellip;&lt;code&gt;v31&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caef8d867ec8d279c62d15ef41539390101b886c" translate="yes" xml:space="preserve">
          <source>An I-type 12-bit signed immediate.</source>
          <target state="translated">I-тип 12-битный подписанный немедленно.</target>
        </trans-unit>
        <trans-unit id="06327d0e0884e8359c3aeb898ee10e76eb6687a6" translate="yes" xml:space="preserve">
          <source>An absolute address</source>
          <target state="translated">Абсолютный адрес</target>
        </trans-unit>
        <trans-unit id="78c6a7cdfe8551206974bd67b2a089dc6fe26252" translate="yes" xml:space="preserve">
          <source>An absolute symbolic address or a label reference</source>
          <target state="translated">Абсолютный символический адрес или ссылка на этикетку</target>
        </trans-unit>
        <trans-unit id="986b6a4e37803f27663b870d347fe309ea3ea740" translate="yes" xml:space="preserve">
          <source>An address suitable for a &lt;code&gt;prefetch&lt;/code&gt; instruction, or for any other instruction with the same addressing mode as &lt;code&gt;prefetch&lt;/code&gt;.</source>
          <target state="translated">Адрес, подходящий для инструкции &lt;code&gt;prefetch&lt;/code&gt; или любой другой инструкции с тем же режимом адресации, что и &lt;code&gt;prefetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="892155354f6089e8dd5e479a72ea4a1751091291" translate="yes" xml:space="preserve">
          <source>An address that can be used in a non-macro load or store.</source>
          <target state="translated">Адрес,который может быть использован при загрузке или хранении без использования макросов.</target>
        </trans-unit>
        <trans-unit id="ff106250bd6a1ea035dee107e3b2d2773c2aecc2" translate="yes" xml:space="preserve">
          <source>An address that is held in a general-purpose register.</source>
          <target state="translated">Адрес,который хранится в реестре общего назначения.</target>
        </trans-unit>
        <trans-unit id="ebfbf78a988fb6bc16aa1ac07630bba74056e531" translate="yes" xml:space="preserve">
          <source>An address which does not involve register indirect addressing or pre/post increment/decrement addressing.</source>
          <target state="translated">Адрес,который не включает в себя регистрацию косвенной адресации или пре/последнюю инкрементную/декрементную адресацию.</target>
        </trans-unit>
        <trans-unit id="e3211e293506f09ee6205a6286105b13b8dd093c" translate="yes" xml:space="preserve">
          <source>An alternate way to write the above example is</source>
          <target state="translated">Альтернативный способ написания вышеприведенного примера -</target>
        </trans-unit>
        <trans-unit id="7ed98e3e9e5fb257c8559031222af1c4e1303971" translate="yes" xml:space="preserve">
          <source>An alternative syntax for this that has been obsolete since GCC 2.5 but GCC still accepts is to write &amp;lsquo;</source>
          <target state="translated">Альтернативный синтаксис для этого, который устарел с GCC 2.5, но GCC все еще принимает, - это написать '</target>
        </trans-unit>
        <trans-unit id="0ba051ca8ecdb334d29fa5a48a0711170d4503f7" translate="yes" xml:space="preserve">
          <source>An alternative to increasing the size of the destination buffer is to constrain the range of formatted values. The maximum length of string arguments can be bounded by specifying the precision in the format directive. When numeric arguments of format directives can be assumed to be bounded by less than the precision of their type, choosing an appropriate length modifier to the format specifier will reduce the required buffer size. For example, if &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; in the example above can be assumed to be within the precision of the &lt;code&gt;short int&lt;/code&gt; type then using either the &lt;code&gt;%hi&lt;/code&gt; format directive or casting the argument to &lt;code&gt;short&lt;/code&gt; reduces the maximum required size of the buffer to 24 bytes.</source>
          <target state="translated">Альтернативой увеличению размера целевого буфера является ограничение диапазона форматированных значений. Максимальную длину строковых аргументов можно ограничить, указав точность в директиве формата. Когда числовые аргументы директив формата можно предположить, что они ограничены точностью, меньшей, чем точность их типа, выбор соответствующего модификатора длины для спецификатора формата уменьшит требуемый размер буфера. Например, если можно предположить , что &lt;var&gt;a&lt;/var&gt; и &lt;var&gt;b&lt;/var&gt; в приведенном выше примере находятся в пределах точности типа &lt;code&gt;short int&lt;/code&gt; , то использование директивы формата &lt;code&gt;%hi&lt;/code&gt; или приведение аргумента к &lt;code&gt;short&lt;/code&gt; уменьшает максимальный требуемый размер буфера до 24 байтов.</target>
        </trans-unit>
        <trans-unit id="90ac40bd537abd77f944ca782b1d8e24e3e93586" translate="yes" xml:space="preserve">
          <source>An amendment to the 1990 standard was published in 1995. This amendment added digraphs and &lt;code&gt;__STDC_VERSION__&lt;/code&gt; to the language, but otherwise concerned the library. This amendment is commonly known as &lt;em&gt;AMD1&lt;/em&gt;; the amended standard is sometimes known as &lt;em&gt;C94&lt;/em&gt; or &lt;em&gt;C95&lt;/em&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">Поправка к стандарту 1990 года была опубликована в 1995 году. Эта поправка добавляла диграфы и &lt;code&gt;__STDC_VERSION__&lt;/code&gt; к языку, но в остальном касалась библиотеки. Эта поправка широко известна как &lt;em&gt;AMD1&lt;/em&gt; ; измененный стандарт иногда называют &lt;em&gt;C94&lt;/em&gt; или &lt;em&gt;C95&lt;/em&gt; . Чтобы выбрать этот стандарт в GCC, используйте опцию</target>
        </trans-unit>
        <trans-unit id="5ec9ea45e6f6d2866eabdf39502663d30e59ccdc" translate="yes" xml:space="preserve">
          <source>An application can interpose its own definition of functions for functions invoked by</source>
          <target state="translated">Для функций,вызываемых посредством</target>
        </trans-unit>
        <trans-unit id="79eafbcf2b7c5c25e774d3009d7ad66460a67d81" translate="yes" xml:space="preserve">
          <source>An area where the difference is most apparent is name mangling. The use of different name mangling is intentional, to protect you from more subtle problems. Compilers differ as to many internal details of C++ implementation, including: how class instances are laid out, how multiple inheritance is implemented, and how virtual function calls are handled. If the name encoding were made the same, your programs would link against libraries provided from other compilers&amp;mdash;but the programs would then crash when run. Incompatible libraries are then detected at link time, rather than at run time.</source>
          <target state="translated">Область, в которой разница наиболее очевидна, - это искажение имен. Использование различных имен искажений намеренно, чтобы защитить вас от более тонких проблем. Компиляторы различаются по многим внутренним деталям реализации C ++, в том числе по расположению экземпляров классов, реализации множественного наследования и обработке вызовов виртуальных функций. Если бы кодировка имен была сделана такой же, ваши программы могли бы связываться с библиотеками, предоставленными другими компиляторами, но тогда программы вылетали бы при запуске. Несовместимые библиотеки затем обнаруживаются во время компоновки, а не во время выполнения.</target>
        </trans-unit>
        <trans-unit id="a97545d568f0ddabc50a6a6e190b9c96c3da5965" translate="yes" xml:space="preserve">
          <source>An assembler template is a literal string containing assembler instructions. The compiler replaces tokens in the template that refer to inputs, outputs, and goto labels, and then outputs the resulting string to the assembler. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input. However, it does count the statements (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">Шаблон ассемблера - это буквальная строка, содержащая инструкции ассемблера. Компилятор заменяет в шаблоне токены, которые относятся к меткам ввода, вывода и перехода, а затем выводит полученную строку ассемблеру. Строка может содержать любые инструкции, распознаваемые ассемблером, включая директивы. GCC не анализирует сами инструкции ассемблера и не знает, что они означают и даже являются ли они допустимыми входными данными ассемблера. Однако он считает операторы (см. &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Размер asm&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf8ae718bdcb577716b49e495b23a5d728121d19" translate="yes" xml:space="preserve">
          <source>An atomic operation can both constrain code motion and be mapped to hardware instructions for synchronization between threads (e.g., a fence). To which extent this happens is controlled by the memory orders, which are listed here in approximately ascending order of strength. The description of each memory order is only meant to roughly illustrate the effects and is not a specification; see the C++11 memory model for precise semantics.</source>
          <target state="translated">Атомная операция может как сдерживать движение кода,так и отображаться на аппаратные инструкции по синхронизации между потоками (например,забор).В какой степени это происходит,контролируется приказами памяти,которые перечислены здесь в примерно возрастающем порядке возрастания силы.Описание каждого порядка памяти предназначено только для грубой иллюстрации эффектов и не является спецификацией;точную семантику см.в модели памяти C++11.</target>
        </trans-unit>
        <trans-unit id="4d88b31282dc4372978d47c4d528de2e00c16901" translate="yes" xml:space="preserve">
          <source>An attribute name (which may be an identifier such as &lt;code&gt;unused&lt;/code&gt;, or a reserved word such as &lt;code&gt;const&lt;/code&gt;).</source>
          <target state="translated">Имя атрибута (которое может быть идентификатором, например, &lt;code&gt;unused&lt;/code&gt; , или зарезервированным словом, например &lt;code&gt;const&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f65131f3242824d199035927efcf93043285cd45" translate="yes" xml:space="preserve">
          <source>An attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:</source>
          <target state="translated">Имя атрибута,за которым следует список параметров атрибута в скобках.Эти параметры принимают одну из следующих форм:</target>
        </trans-unit>
        <trans-unit id="7d755f91a373e17fad5f0c5626bbbba251cf643a" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear as part of a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; specifier. It may go either immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword, or after the closing brace. The former syntax is preferred. Where attribute specifiers follow the closing brace, they are considered to relate to the structure, union or enumerated type defined, not to any enclosing declaration the type specifier appears in, and the type defined is not complete until after the attribute specifiers.</source>
          <target state="translated">Список спецификаторов атрибута может появляться как часть спецификатора &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;enum&lt;/code&gt; . Он может идти сразу после ключевого слова &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;enum&lt;/code&gt; или после закрывающей скобки. Первый синтаксис является предпочтительным. Если спецификаторы атрибута следуют за закрывающей фигурной скобкой, они считаются относящимися к определенной структуре, объединению или перечислимому типу, а не к какому-либо охватывающему объявлению, в котором появляется спецификатор типа, и определенный тип не является полным до тех пор, пока не будут указаны спецификаторы атрибута.</target>
        </trans-unit>
        <trans-unit id="9e5e73e14616e06a74db1d5feee8111efc621957" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear at the start of a nested declarator. At present, there are some limitations in this usage: the attributes correctly apply to the declarator, but for most individual attributes the semantics this implies are not implemented. When attribute specifiers follow the &lt;code&gt;*&lt;/code&gt; of a pointer declarator, they may be mixed with any type qualifiers present. The following describes the formal semantics of this syntax. It makes the most sense if you are familiar with the formal specification of declarators in the ISO C standard.</source>
          <target state="translated">Список спецификаторов атрибутов может появиться в начале вложенного декларатора. В настоящее время есть некоторые ограничения в этом использовании: атрибуты правильно применяются к декларатору, но для большинства отдельных атрибутов подразумеваемая семантика не реализована. Когда спецификаторы атрибутов следуют за &lt;code&gt;*&lt;/code&gt; декларатора указателя, они могут быть смешаны с любыми имеющимися квалификаторами типа. Ниже описывается формальная семантика этого синтаксиса. Это имеет смысл, если вы знакомы с формальной спецификацией деклараторов в стандарте ISO C.</target>
        </trans-unit>
        <trans-unit id="90c786fbc073ea725818acf8d9cbe4bc390cf984" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before a declarator (other than the first) in a comma-separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers. Such attribute specifiers apply only to the identifier before whose declarator they appear. For example, in</source>
          <target state="translated">Список спецификаторов атрибутов может появляться непосредственно перед декларатором (кроме первого)в списке деклараторов,разделенном запятыми,при объявлении более чем одного идентификатора с помощью одного списка спецификаторов и классификаторов.Такие спецификаторы атрибутов относятся только к тому идентификатору,перед которым они появляются.Например,в</target>
        </trans-unit>
        <trans-unit id="be5978cee71999e28113db755252c2c229b75be6" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before the comma, &lt;code&gt;=&lt;/code&gt; or semicolon terminating the declaration of an identifier other than a function definition. Such attribute specifiers apply to the declared object or function. Where an assembler name for an object or function is specified (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;), the attribute must follow the &lt;code&gt;asm&lt;/code&gt; specification.</source>
          <target state="translated">Список спецификаторов атрибутов может появляться непосредственно перед запятой, &lt;code&gt;=&lt;/code&gt; или точкой с запятой, завершающей объявление идентификатора, отличного от определения функции. Такие спецификаторы атрибутов применяются к объявленному объекту или функции. Если указано имя ассемблера для объекта или функции (см. &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Метки Asm&lt;/a&gt; ), атрибут должен соответствовать спецификации &lt;code&gt;asm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06c400bc0897dcce315e482021ea5ac2d0b133c9" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may, in future, be permitted to appear after the declarator in a function definition (before any old-style parameter declarations or the function body).</source>
          <target state="translated">Список спецификаторов атрибутов может в дальнейшем появляться после декларатора в определении функции (до любых деклараций параметров старого образца или тела функции).</target>
        </trans-unit>
        <trans-unit id="a74a1d3ff08634b1a7446e5738ed8abb53ee53ac" translate="yes" xml:space="preserve">
          <source>An empty replacement string indicates that the given range is to be removed. An empty range (e.g. &amp;ldquo;45:3-45:3&amp;rdquo;) indicates that the string is to be inserted at the given position.</source>
          <target state="translated">Пустая строка замены указывает, что данный диапазон должен быть удален. Пустой диапазон (например, &amp;laquo;45: 3-45: 3&amp;raquo;) указывает, что строка должна быть вставлена ​​в заданную позицию.</target>
        </trans-unit>
        <trans-unit id="0ae58fb99fa1b71a549f28d943d2b614039f2208" translate="yes" xml:space="preserve">
          <source>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example, &lt;code&gt;format&lt;/code&gt; attributes use this form.</source>
          <target state="translated">Идентификатор, за которым следует запятая и непустой список выражений, разделенных запятыми. Например, эту форму используют атрибуты &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68d7bc1885869717ff785880a55a84832370a8cc" translate="yes" xml:space="preserve">
          <source>An identifier. For example, &lt;code&gt;mode&lt;/code&gt; attributes use this form.</source>
          <target state="translated">Идентификатор. Например, эту форму используют атрибуты &lt;code&gt;mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ec5ac33481525fe53d426cd6db6a12a229bec4c" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt; or &lt;code&gt;const_vector&lt;/code&gt;) is allowed.</source>
          <target state="translated">&lt;code&gt;const_double&lt;/code&gt; немедленный плавающий операнд (код выражения const_double или &lt;code&gt;const_vector&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="594d6eba8a97b362385ec37bc0e852d2a80c0ac2" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt;) is allowed, but only if the target floating point format is the same as that of the host machine (on which the compiler is running).</source>
          <target state="translated">Непосредственный операнд с плавающей запятой (код выражения &lt;code&gt;const_double&lt;/code&gt; ) разрешен, но только если целевой формат с плавающей запятой совпадает с форматом хост-машины (на которой работает компилятор).</target>
        </trans-unit>
        <trans-unit id="0c315fd75b55a96544e61998f54c1ece5842737a" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is sign extended as a 128 bit.</source>
          <target state="translated">Знак const_int-это знак,расширенный как 128 бит.</target>
        </trans-unit>
        <trans-unit id="5ccfcfe71dbbefbcc7083b3111e73c588704efb6" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">Непосредственное значение для и/или/и/и инструкции.const_int обрабатывается как 32-битное значение.</target>
        </trans-unit>
        <trans-unit id="37a74b5a5b038401ba585b82ac648a38ee34ae7d" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">Непосредственное значение для и/или/и/и инструкции.const_int обрабатывается как 64-битное значение.</target>
        </trans-unit>
        <trans-unit id="724f31235beec2d91358f29c81609301ddfe064d" translate="yes" xml:space="preserve">
          <source>An immediate for most arithmetic instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">Непосредственно для большинства арифметических инструкций.const_int обрабатывается как 32-битное значение.</target>
        </trans-unit>
        <trans-unit id="ba5952eb86810c12a13a67307b761f420789e80d" translate="yes" xml:space="preserve">
          <source>An immediate for shift and rotate instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">Непосредственно для инструкций сдвига и вращения.const_int обрабатывается как 32-битное значение.</target>
        </trans-unit>
        <trans-unit id="4f576fc6545e2a7ed32b49891eee7158495619f8" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is sign extended to 128 bit.</source>
          <target state="translated">Сразу для инструкции &lt;code&gt;iohl&lt;/code&gt; . const_int - это знак, расширенный до 128 бит.</target>
        </trans-unit>
        <trans-unit id="fa46e8c9174bfc14d1e6484c608422836253b5fc" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 32 bit value.</source>
          <target state="translated">Сразу для инструкции &lt;code&gt;iohl&lt;/code&gt; . const_int рассматривается как 32-битное значение.</target>
        </trans-unit>
        <trans-unit id="a4ad2e9f47c35dba5c3a654586cfbfd37c2d1074" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 64 bit value.</source>
          <target state="translated">Сразу для инструкции &lt;code&gt;iohl&lt;/code&gt; . const_int рассматривается как 64-битное значение.</target>
        </trans-unit>
        <trans-unit id="fb6b5c59189bcd298a8c54b0d5b72012198931a3" translate="yes" xml:space="preserve">
          <source>An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time or later.</source>
          <target state="translated">Допускается немедленный целочисленный операнд (один с постоянным значением).К ним относятся символьные константы,значения которых будут известны только во время сборки или позже.</target>
        </trans-unit>
        <trans-unit id="e84f183cbd16bd54d89a362096c570a83e737d81" translate="yes" xml:space="preserve">
          <source>An immediate integer operand whose value is not an explicit integer is allowed.</source>
          <target state="translated">Допускается немедленный целочисленный операнд,значение которого не является явным целым числом.</target>
        </trans-unit>
        <trans-unit id="3dcd4c571d6303522812fd66511c9efeae10aff4" translate="yes" xml:space="preserve">
          <source>An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use &amp;lsquo;</source>
          <target state="translated">Допускается непосредственный целочисленный операнд с известным числовым значением. Многие системы не могут поддерживать константы времени сборки для операндов шириной менее одного слова. В ограничениях для этих операндов следует использовать '</target>
        </trans-unit>
        <trans-unit id="fead0cb9bc3652a20a6803e3e14fb097bc244e18" translate="yes" xml:space="preserve">
          <source>An immediate operand for R2 andchi/andci instructions.</source>
          <target state="translated">Непосредственный операнд для инструкций R2 andchi/andci.</target>
        </trans-unit>
        <trans-unit id="ac68e335d064a71570d610173f680ac5fbe05513" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">Немедленное, которое можно загрузить с помощью &lt;code&gt;fsmbi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea450ed2fe096f001d0fa25412cdd9e4110db1ae" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is sign extended to 128 bit.</source>
          <target state="translated">Непосредственный,который может быть загружен с помощью инструкций il/ila/ilh/ilhu.const_int-это знак,расширенный до 128 бит.</target>
        </trans-unit>
        <trans-unit id="7c728956eab601b71ea1ef8510f9ed46b01e9678" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">Непосредственный,который может быть загружен с помощью инструкций il/ila/ilh/ilhu.const_int рассматривается как 32-битное значение.</target>
        </trans-unit>
        <trans-unit id="8b91f62ddf90eb3045924f61638e2ed286dc7c16" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">Непосредственный,который может быть загружен с помощью инструкций il/ila/ilh/ilhu.const_int рассматривается как 64-битное значение.</target>
        </trans-unit>
        <trans-unit id="d6e53dc412a13c67bb00bedf4c0eac4f87ba77c1" translate="yes" xml:space="preserve">
          <source>An important caveat is that GCC arranges to save and restore only those registers known to the specific architecture variant being compiled for. This can make &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; more efficient than their library counterparts in some cases, but it can also cause incorrect and mysterious behavior when mixing with code that uses the full register set.</source>
          <target state="translated">Важное предостережение заключается в том, что GCC сохраняет и восстанавливает только те регистры, которые известны для конкретного варианта архитектуры, для которого выполняется компиляция. В некоторых случаях это может сделать &lt;code&gt;__builtin_setjmp&lt;/code&gt; и &lt;code&gt;__builtin_longjmp&lt;/code&gt; более эффективными, чем их библиотечные аналоги, но также может вызвать некорректное и загадочное поведение при смешивании с кодом, который использует полный набор регистров.</target>
        </trans-unit>
        <trans-unit id="4bb50275db5ef990a5c71386c85806595b867df5" translate="yes" xml:space="preserve">
          <source>An indexed or indirect address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86c0eceb044416401abb04a6e463d5b6094cd25" translate="yes" xml:space="preserve">
          <source>An input register that is implicitly popped by the &lt;code&gt;asm&lt;/code&gt; must be explicitly clobbered, unless it is constrained to match an output operand.</source>
          <target state="translated">Входной регистр, который неявно выталкивается &lt;code&gt;asm&lt;/code&gt; , должен быть явно закрыт, если только он не ограничен соответствием выходному операнду.</target>
        </trans-unit>
        <trans-unit id="7c249498e8a7c24a4e363a078596ccff4c5734ab" translate="yes" xml:space="preserve">
          <source>An integer constant in the range -255 &amp;hellip; 0</source>
          <target state="translated">Целочисленная константа в диапазоне -255&amp;hellip; 0.</target>
        </trans-unit>
        <trans-unit id="9dc7773cc8d9e6deceeb329e43d478d46251dfd7" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 0 &amp;hellip; 255.</source>
          <target state="translated">Целочисленная константа в диапазоне 0&amp;hellip; 255.</target>
        </trans-unit>
        <trans-unit id="5b08127ba5b721033e68de80fdaced9cd1b46db8" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 15.</source>
          <target state="translated">Целочисленная константа в диапазоне 1&amp;hellip; 15.</target>
        </trans-unit>
        <trans-unit id="e28d87e9d901db2966f212d84f0e7048b61d9b95" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 7.</source>
          <target state="translated">Целочисленная константа в диапазоне 1&amp;hellip; 7.</target>
        </trans-unit>
        <trans-unit id="bcc6027cc8de73ec51a063277dae667199da440f" translate="yes" xml:space="preserve">
          <source>An integer constant that does not meet the constraints for codes &amp;lsquo;</source>
          <target state="translated">Целочисленная константа, не удовлетворяющая ограничениям для кодов '</target>
        </trans-unit>
        <trans-unit id="c84f7429b210360fa5c85dafb3a76127af085fed" translate="yes" xml:space="preserve">
          <source>An integer constant that fits in 16 bits.</source>
          <target state="translated">Целочисленная константа,которая помещается в 16 бит.</target>
        </trans-unit>
        <trans-unit id="7ea8f3048d5d170816523d297bd8775793dabcbf" translate="yes" xml:space="preserve">
          <source>An integer constant whose low order 16 bits are zero.</source>
          <target state="translated">Целочисленная константа,нижний порядок 16 бит которой равен нулю.</target>
        </trans-unit>
        <trans-unit id="91669a0b9c65d1cc6722fd1ac4e811cb3b9462cf" translate="yes" xml:space="preserve">
          <source>An integer constant with all bits set except exactly one.</source>
          <target state="translated">Целочисленная константа со всеми битами,кроме одного.</target>
        </trans-unit>
        <trans-unit id="21493d2e6936d92d54e34c6a9c53ba6429a374d6" translate="yes" xml:space="preserve">
          <source>An integer constant with exactly a single bit set.</source>
          <target state="translated">Целочисленная константа с точно однобитным набором.</target>
        </trans-unit>
        <trans-unit id="148e29efc3e25eee684ae13925c5fb8932f17d90" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use only with accumulator A1.</source>
          <target state="translated">Целое число,равное одной из констант MACFLAG_XXX,которое подходит только для использования с аккумулятором A1.</target>
        </trans-unit>
        <trans-unit id="f4afba48092a6cec863cdd332d5c5c0ad22e2831" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use with either accumulator.</source>
          <target state="translated">Целое число,равное одной из констант MACFLAG_XXX,которое подходит для использования с любым из аккумуляторов.</target>
        </trans-unit>
        <trans-unit id="ff1c35a13fe5ef99c7a9d9e7d6ae5125aea6469c" translate="yes" xml:space="preserve">
          <source>An interrupt handler must be declared with a mandatory pointer argument:</source>
          <target state="translated">Обработчик прерывания должен быть объявлен с обязательным аргументом указателя:</target>
        </trans-unit>
        <trans-unit id="d371e86b4fb307c14a25adf02422873dfe31a1a2" translate="yes" xml:space="preserve">
          <source>An inverted bitfield mask suitable for bext or bins</source>
          <target state="translated">Маска перевернутого битового поля,подходящая для бекста или мусорного контейнера.</target>
        </trans-unit>
        <trans-unit id="d009fe9b76c291a5aa0c7f6c1e8d1138fabbeb43" translate="yes" xml:space="preserve">
          <source>An item in the constant pool</source>
          <target state="translated">Элемент в постоянном бассейне</target>
        </trans-unit>
        <trans-unit id="4793f292bc93fcd62120f48245f5e44fb822389b" translate="yes" xml:space="preserve">
          <source>An object file to be fed straight into linking. Any file name with no recognized suffix is treated this way.</source>
          <target state="translated">Объектный файл,который будет сразу же передан для линковки.Любое имя файла без распознанного суффикса обрабатывается таким образом.</target>
        </trans-unit>
        <trans-unit id="bf8b9f9703de2f2ca710a30d52808d7dca0bcb72" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;__thread&lt;/code&gt; has &lt;em&gt;thread storage duration&lt;/em&gt;. Its lifetime is the entire execution of the thread, and its stored value is initialized only once, prior to thread startup.</source>
          <target state="translated">Объект, идентификатор которого объявлен с помощью спецификатора класса хранения &lt;code&gt;__thread&lt;/code&gt; , имеет &lt;em&gt;продолжительность хранения потока&lt;/em&gt; . Его время жизни - это полное выполнение потока, а его сохраненное значение инициализируется только один раз перед запуском потока.</target>
        </trans-unit>
        <trans-unit id="52a7967fec1a33e4d839edd6eff5a38decb9b59d" translate="yes" xml:space="preserve">
          <source>An offset address</source>
          <target state="translated">Смещённый адрес</target>
        </trans-unit>
        <trans-unit id="89feeff33c633de750f5bb644b0891d21925addb" translate="yes" xml:space="preserve">
          <source>An offset address.</source>
          <target state="translated">Адрес со смещением.</target>
        </trans-unit>
        <trans-unit id="aa367c1ec44c9cba3102e666432b6606342ed893" translate="yes" xml:space="preserve">
          <source>An operand that is a valid memory address is allowed. This is for &amp;ldquo;load address&amp;rdquo; and &amp;ldquo;push address&amp;rdquo; instructions.</source>
          <target state="translated">Допускается операнд, который является допустимым адресом памяти. Это для инструкций &amp;laquo;адрес загрузки&amp;raquo; и &amp;laquo;адрес отправки&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="44a3bc3b1208cdb1273c2b09519bfd9e1cfc45ea" translate="yes" xml:space="preserve">
          <source>An operand that matches the specified operand number is allowed. If a digit is used together with letters within the same alternative, the digit should come last.</source>
          <target state="translated">Допускается операнд,соответствующий указанному номеру операнда.Если цифра используется вместе с буквами в одной и той же альтернативе,цифра должна идти последней.</target>
        </trans-unit>
        <trans-unit id="d0d03643cf5743c896341a88665563cee4e7f14b" translate="yes" xml:space="preserve">
          <source>An optimization that assumes that signed overflow does not occur is perfectly safe if the values of the variables involved are such that overflow never does, in fact, occur. Therefore this warning can easily give a false positive: a warning about code that is not actually a problem. To help focus on important issues, several warning levels are defined. No warnings are issued for the use of undefined signed overflow when estimating how many iterations a loop requires, in particular when determining whether a loop will be executed at all.</source>
          <target state="translated">Оптимизация,предполагающая,что знаковое переполнение не происходит,совершенно безопасна,если значения задействованных переменных таковы,что переполнение никогда,по сути,не происходит.Поэтому данное предупреждение может легко выдать ложное срабатывание:предупреждение о коде,который на самом деле не является проблемой.Чтобы помочь сконцентрироваться на важных проблемах,определено несколько уровней предупреждений.Предупреждения не выдаются на использование неопределенного знакового переполнения при вычислении,сколько итераций требуется циклу,в частности,при определении,будет ли вообще выполняться цикл.</target>
        </trans-unit>
        <trans-unit id="b187d1cbe2c1e6182a8dd178f33fdc1911f0fd4c" translate="yes" xml:space="preserve">
          <source>An overview of these techniques, their benefits and how to use them is at &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;.</source>
          <target state="translated">Обзор этих методов, их преимуществ и способов их использования можно &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;найти&lt;/a&gt; на http://gcc.gnu.org/wiki/Visibility .</target>
        </trans-unit>
        <trans-unit id="9cf43ee45c3bad94e9675d7a4ec72d4396d0e587" translate="yes" xml:space="preserve">
          <source>An overview of these techniques, their benefits and how to use them is at &lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78963be09ff63d4ade4602b745f27f40ed01fe1b" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant (for logic instructions).</source>
          <target state="translated">Беззнаковая 16-битная константа (для логических инструкций).</target>
        </trans-unit>
        <trans-unit id="5b34b8bcf92baede87b31604702d88f2552f8622" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant for &lt;code&gt;iohl&lt;/code&gt; and &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">16-битная константа без знака для &lt;code&gt;iohl&lt;/code&gt; и &lt;code&gt;fsmbi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c10f415d71c7e7066c4b909d3f1393b2cce4e125" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant shifted left 16 bits (use &lt;code&gt;L&lt;/code&gt; instead for &lt;code&gt;SImode&lt;/code&gt; constants).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb9a0ccfe5c932918592859dcea72edc71b9826" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant.</source>
          <target state="translated">Беззнаковая 16-битная константа.</target>
        </trans-unit>
        <trans-unit id="bb28e9e819d64e02267cdf40ed8e86dabcf29201" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit integer constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ef4bae4950c14cd2a335ebce3f24b00931f1ee" translate="yes" xml:space="preserve">
          <source>An unsigned 3-bit constant for 16-byte rotates and shifts</source>
          <target state="translated">Беззнаковая 3-битная константа для 16-байтовых вращений и сдвигов</target>
        </trans-unit>
        <trans-unit id="95ddaf18fc4d2ab678603464648f03bb8de98a4d" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit constant.</source>
          <target state="translated">Беззнаковая 5-битная константа.</target>
        </trans-unit>
        <trans-unit id="7983abc6cf90ba7d41ddff4f3b8b3d5f6d999d50" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit integer constant (for shift counts).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a00eda1fa05aab415bb11f10e795bf964e4785" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant for conversion/nop/channel instructions.</source>
          <target state="translated">Беззнаковая 7-битная константа для инструкций по преобразованию/подключению/каналам.</target>
        </trans-unit>
        <trans-unit id="5b0bf2d7544790a0320ec8391816f55aa165f088" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant whose 3 least significant bits are 0.</source>
          <target state="translated">Беззнаковая 7-битная константа,3 наименее значащих бита которой равны 0.</target>
        </trans-unit>
        <trans-unit id="d8264da1da251da38e16c7abcf0200adc7f6c27d" translate="yes" xml:space="preserve">
          <source>An unsigned 8-bit integer constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8a3cd83ae17cf2c173ff325905d55cd210117b" translate="yes" xml:space="preserve">
          <source>An x86 example where the string memory argument is of unknown length.</source>
          <target state="translated">Пример x86,где аргумент строковой памяти неизвестной длины.</target>
        </trans-unit>
        <trans-unit id="8157a3070b0a23e585bb72291a5f64fac3066253" translate="yes" xml:space="preserve">
          <source>And the function names are:</source>
          <target state="translated">И названия функций:</target>
        </trans-unit>
        <trans-unit id="cce6aeb578cc150b67e8e4f1acfc181fb9996f38" translate="yes" xml:space="preserve">
          <source>Annotate assembler instructions with estimated addresses.</source>
          <target state="translated">Примечания к инструкциям по сборке с ориентировочными адресами.</target>
        </trans-unit>
        <trans-unit id="295ae69532c434798f968812e2201e5c3fd052fa" translate="yes" xml:space="preserve">
          <source>Annotate assignments to user variables early in the compilation and attempt to carry the annotations over throughout the compilation all the way to the end, in an attempt to improve debug information while optimizing. Use of</source>
          <target state="translated">Присваивать аннотации пользовательским переменным на ранних стадиях компиляции и пытаться перенести аннотации на протяжении всей компиляции до конца,в попытке улучшить отладочную информацию при оптимизации.Использование</target>
        </trans-unit>
        <trans-unit id="71fb5f4abaa1eaa677691ec6945ce018c8d3cc8a" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with a comment indicating which pattern and alternative is used. The length and cost of each instruction are also printed.</source>
          <target state="translated">Примечания к выходу сборщика с комментарием,указывающим,какой образец и какая альтернатива используется.Также печатаются длина и стоимость каждой инструкции.</target>
        </trans-unit>
        <trans-unit id="93a92e7968152fb0b277671cc51df48b140f38ff" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with miscellaneous debugging information.</source>
          <target state="translated">Примечания к выходу ассемблера с различной отладочной информацией.</target>
        </trans-unit>
        <trans-unit id="989a73be7d945cbd818654da9eb44b704400138e" translate="yes" xml:space="preserve">
          <source>Another (simpler) way to enable link-time optimization is:</source>
          <target state="translated">Другим (более простым)способом включения оптимизации времени соединения является оптимизация:</target>
        </trans-unit>
        <trans-unit id="68f160715f630ab62644e4593ac2d81e2aac8d1b" translate="yes" xml:space="preserve">
          <source>Another consequence is that &lt;code&gt;sscanf&lt;/code&gt; does not work on some very old systems when passed a string constant as its format control string or input. This is because &lt;code&gt;sscanf&lt;/code&gt; incorrectly tries to write into the string constant. Likewise &lt;code&gt;fscanf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;.</source>
          <target state="translated">Еще одно последствие заключается в том, что &lt;code&gt;sscanf&lt;/code&gt; не работает в некоторых очень старых системах при передаче строковой константы в качестве строки управления форматом или ввода. Это потому, что &lt;code&gt;sscanf&lt;/code&gt; неправильно пытается записать в строковую константу. Аналогично &lt;code&gt;fscanf&lt;/code&gt; и &lt;code&gt;scanf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">Еще один пример:</target>
        </trans-unit>
        <trans-unit id="3114d5262ea0b2a7df098211946bd465d7ca75ca" translate="yes" xml:space="preserve">
          <source>Another feature of LTO is that it is possible to apply interprocedural optimizations on files written in different languages:</source>
          <target state="translated">Еще одной особенностью LTO является возможность применения межпроцедурных оптимизаций к файлам,написанным на разных языках:</target>
        </trans-unit>
        <trans-unit id="800bcf1831a315ef5fa60f82c87dd864fc821d9c" translate="yes" xml:space="preserve">
          <source>Another restriction is that the clobber list should not contain the stack pointer register. This is because the compiler requires the value of the stack pointer to be the same after an &lt;code&gt;asm&lt;/code&gt; statement as it was on entry to the statement. However, previous versions of GCC did not enforce this rule and allowed the stack pointer to appear in the list, with unclear semantics. This behavior is deprecated and listing the stack pointer may become an error in future versions of GCC.</source>
          <target state="translated">Еще одно ограничение состоит в том, что список clobber не должен содержать регистр указателя стека. Это связано с тем, что компилятор требует, чтобы значение указателя стека после оператора &lt;code&gt;asm&lt;/code&gt; было таким же, как и при входе в оператор. Однако предыдущие версии GCC не применяли это правило и позволяли указателю стека появляться в списке с неясной семантикой. Такое поведение не рекомендуется, и перечисление указателя стека может стать ошибкой в ​​будущих версиях GCC.</target>
        </trans-unit>
        <trans-unit id="06cec1a74ddd904f5065125e6e0eba36e86de4da" translate="yes" xml:space="preserve">
          <source>Another revised ISO C++ standard was published in 2014 as ISO/IEC 14882:2014, and is referred to as C++14; before its publication it was sometimes referred to as C++1y. C++14 contains several further changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">Другой пересмотренный стандарт ISO C ++ был опубликован в 2014 году как ISO / IEC 14882: 2014 и называется C ++ 14; до публикации его иногда называли C ++ 1y. C ++ 14 содержит еще несколько изменений в языке C ++, все из которых реализованы в GCC. Подробнее см. &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;Https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt; . Чтобы выбрать этот стандарт в GCC, используйте опцию</target>
        </trans-unit>
        <trans-unit id="100b9161d8847e18a3c098c1597e4c27bddc1e4a" translate="yes" xml:space="preserve">
          <source>Another syntax that has the same meaning, obsolete since GCC 2.5, is &amp;lsquo;</source>
          <target state="translated">Другой синтаксис с таким же значением, устаревший с GCC 2.5, - '</target>
        </trans-unit>
        <trans-unit id="8d4503c0d7b11d51381b2775fa2f1d0bc68346b0" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;__builtin_unreachable&lt;/code&gt; is following a call a function that never returns but that is not declared &lt;code&gt;__attribute__((noreturn))&lt;/code&gt;, as in this example:</source>
          <target state="translated">Другое использование &lt;code&gt;__builtin_unreachable&lt;/code&gt; - это вызов функции, которая никогда не возвращается, но не объявляется &lt;code&gt;__attribute__((noreturn))&lt;/code&gt; , как в этом примере:</target>
        </trans-unit>
        <trans-unit id="b5c0df1874478fedada2f09d07323584aaf952db" translate="yes" xml:space="preserve">
          <source>Another use of label values is in an interpreter for threaded code. The labels within the interpreter function can be stored in the threaded code for super-fast dispatching.</source>
          <target state="translated">Другое использование значений меток-в интерпретаторе для поточного кода.Метки внутри функции интерпретатора могут быть сохранены в потоковом коде для сверхбыстрой диспетчеризации.</target>
        </trans-unit>
        <trans-unit id="054bb42dabc9a19f68ad68065d19f8cf04a8d0cf" translate="yes" xml:space="preserve">
          <source>Another way to refer to the type of an expression is with &lt;code&gt;typeof&lt;/code&gt;. The syntax of using of this keyword looks like &lt;code&gt;sizeof&lt;/code&gt;, but the construct acts semantically like a type name defined with &lt;code&gt;typedef&lt;/code&gt;.</source>
          <target state="translated">Другой способ указать тип выражения - использовать &lt;code&gt;typeof&lt;/code&gt; . Синтаксис использования этого ключевого слова выглядит как &lt;code&gt;sizeof&lt;/code&gt; , но конструкция действует семантически как имя типа, определенное с помощью &lt;code&gt;typedef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a721e97bbca8eab5f82eabfccb957a729c8f492f" translate="yes" xml:space="preserve">
          <source>Another way to specify a prefix much like the</source>
          <target state="translated">Другой способ указать префикс,похожий на</target>
        </trans-unit>
        <trans-unit id="96409c8e4594c5ca23408453d9c7d3939d189e53" translate="yes" xml:space="preserve">
          <source>Another, similar example involves calling member functions of a base class:</source>
          <target state="translated">Другой,похожий пример связан с вызовом функций-членов базового класса:</target>
        </trans-unit>
        <trans-unit id="53491a8e8187c94a2d02f53706e5a4e898389bcf" translate="yes" xml:space="preserve">
          <source>Any 80387 floating-point (stack) register.</source>
          <target state="translated">Любой регистр 80387 с плавающей точкой (стек).</target>
        </trans-unit>
        <trans-unit id="b3758814c17061e556dad37977ffba674151e160" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;symbol_ref&lt;/code&gt; or &lt;code&gt;label_ref&lt;/code&gt;</source>
          <target state="translated">Любая &lt;code&gt;symbol_ref&lt;/code&gt; или &lt;code&gt;label_ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2f752342a0bbfde2ec460c7e0098752d0a9c8ba" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;unspec&lt;/code&gt;</source>
          <target state="translated">Любые &lt;code&gt;unspec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08321582787b969fc3f46ec2caec6f021be74d45" translate="yes" xml:space="preserve">
          <source>Any D, P, B, M, I or L register.</source>
          <target state="translated">Любой D,P,B,M,I или L зарегистрирован.</target>
        </trans-unit>
        <trans-unit id="a4d7faf7c72e44e81295ee83f9349235dc1598af" translate="yes" xml:space="preserve">
          <source>Any EVEX encodable SSE register (&lt;code&gt;%xmm0-%xmm31&lt;/code&gt;).</source>
          <target state="translated">Любой кодируемый EVEX регистр SSE ( &lt;code&gt;%xmm0-%xmm31&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="162a9ef967e5306147bc46c88126767e87c35020" translate="yes" xml:space="preserve">
          <source>Any MMX register.</source>
          <target state="translated">Любой MMX-регистр.</target>
        </trans-unit>
        <trans-unit id="6c6a18dc34784ab21c4ba11b353b499414254204" translate="yes" xml:space="preserve">
          <source>Any SSE register.</source>
          <target state="translated">Любой регистр SSE.</target>
        </trans-unit>
        <trans-unit id="6050748b38d243b476a4baca6c16743585fafbd7" translate="yes" xml:space="preserve">
          <source>Any SYMBOL_REF.</source>
          <target state="translated">Любой SYMBOL_REF.</target>
        </trans-unit>
        <trans-unit id="458f2948a2c464f5746c7ffc43449a651a2011cd" translate="yes" xml:space="preserve">
          <source>Any VSX register if the</source>
          <target state="translated">Любой VSX-регистр,если</target>
        </trans-unit>
        <trans-unit id="d8389ba5b054471dbefb65e013349dc9adfee3c7" translate="yes" xml:space="preserve">
          <source>Any array can be subscripted, even if not an lvalue.</source>
          <target state="translated">Подписываться можно на любой массив,даже если он не имеет значения.</target>
        </trans-unit>
        <trans-unit id="b906590ae8882826b85c1f14c38d4cf1bfbb5d1f" translate="yes" xml:space="preserve">
          <source>Any condition register field, &lt;code&gt;cr0&lt;/code&gt;&amp;hellip;&lt;code&gt;cr7&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b564784ad63437bf2bebc716f7f298f61a5028" translate="yes" xml:space="preserve">
          <source>Any const_double value.</source>
          <target state="translated">Любое значение const_double.</target>
        </trans-unit>
        <trans-unit id="1e9dc0d4d4d3fa3953a7b89d1659a04266824dc2" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 16 bits wide (nothing if control registers are 24 bits wide)</source>
          <target state="translated">Любой управляющий регистр, если он имеет ширину 16 бит (ничего, если управляющий регистр имеет ширину 24 бита)</target>
        </trans-unit>
        <trans-unit id="dcdd92208f9952a1f355fdf3b7526b8f7a44d2c0" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">Любой управляющий регистр, если он шириной 24 бита.</target>
        </trans-unit>
        <trans-unit id="7e9a960c7b57410e9d4ca5df2e5f2e42c59f7d8b" translate="yes" xml:space="preserve">
          <source>Any data or pointers to the non-generic address spaces must be qualified as &lt;code&gt;const&lt;/code&gt;, i.e. as read-only data. This still applies if the data in one of these address spaces like software version number or calibration lookup table are intended to be changed after load time by, say, a boot loader. In this case the right qualification is &lt;code&gt;const&lt;/code&gt;&lt;code&gt;volatile&lt;/code&gt; so that the compiler must not optimize away known values or insert them as immediates into operands of instructions.</source>
          <target state="translated">Любые данные или указатели на неуниверсальные адресные пространства должны квалифицироваться как &lt;code&gt;const&lt;/code&gt; , т. Е. Как данные только для чтения. Это по-прежнему применяется, если данные в одном из этих адресных пространств, такие как номер версии программного обеспечения или таблица поиска калибровки, предназначены для изменения после времени загрузки, скажем, загрузчиком. В этом случае правильной квалификацией является &lt;code&gt;const&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; , так что компилятор не должен оптимизировать известные значения или вставлять их непосредственно в операнды инструкций.</target>
        </trans-unit>
        <trans-unit id="05a587b8fa898666a201d21b98455df1bf047bae" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialised by the C runtime startup code, or the program loader. Not initialising data in this way can reduce program startup times.</source>
          <target state="translated">Любые данные с атрибутом &lt;code&gt;noinit&lt;/code&gt; не будут инициализированы кодом запуска среды выполнения C или загрузчиком программы. Отсутствие инициализации данных таким образом может сократить время запуска программы.</target>
        </trans-unit>
        <trans-unit id="b31ade70b5b6adb7eda689c140579a407cbd5f8e" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialized by the C runtime startup code, or the program loader. Not initializing data in this way can reduce program startup times. This attribute is specific to ELF targets and relies on the linker to place such data in the right location</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1647cf01ffb6c880e2cc9ddc546cf116110a80e6" translate="yes" xml:space="preserve">
          <source>Any dependence for which the latency is greater than or equal to &lt;var&gt;number&lt;/var&gt; is costly.</source>
          <target state="translated">Любая зависимость, для которой задержка больше или равна &lt;var&gt;number&lt;/var&gt; , требует больших затрат.</target>
        </trans-unit>
        <trans-unit id="54d255d43091079c6ba1e5343929cbd0d4605f04" translate="yes" xml:space="preserve">
          <source>Any dependence from store to load is costly.</source>
          <target state="translated">Любая зависимость от магазина к нагрузке является дорогостоящей.</target>
        </trans-unit>
        <trans-unit id="32b989b6176274d8479bf98d4817d8a49a56f0e0" translate="yes" xml:space="preserve">
          <source>Any directories specified with</source>
          <target state="translated">Любые каталоги,указанные с</target>
        </trans-unit>
        <trans-unit id="1d356594a5d83b50830291445eb406f59dd05afc" translate="yes" xml:space="preserve">
          <source>Any expression of type &lt;code&gt;void *&lt;/code&gt; is allowed.</source>
          <target state="translated">Допускается любое выражение типа &lt;code&gt;void *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68030c2dfbf4d205419f4c53b98009b37766c0cb" translate="yes" xml:space="preserve">
          <source>Any extended integer types that exist in the implementation (C99 and C11 6.2.5).</source>
          <target state="translated">Любые расширенные целые типы,существующие в реализации (C99 и C11 6.2.5).</target>
        </trans-unit>
        <trans-unit id="6f1de0dfba46a4460bfe571dd6ce87a521e49944" translate="yes" xml:space="preserve">
          <source>Any interruptible-without-stack-switch code must be compiled with</source>
          <target state="translated">Любой код прерывания без стека-коммутатора должен быть скомпилирован с помощью</target>
        </trans-unit>
        <trans-unit id="d0a99fee73d1a0400c42d60b6ea95667d276cf8e" translate="yes" xml:space="preserve">
          <source>Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers, whether or not such a list may in that context contain storage class specifiers. (Some attributes, however, are essentially in the nature of storage class specifiers, and only make sense where storage class specifiers may be used; for example, &lt;code&gt;section&lt;/code&gt;.) There is one necessary limitation to this syntax: the first old-style parameter declaration in a function definition cannot begin with an attribute specifier, because such an attribute applies to the function instead by syntax described below (which, however, is not yet implemented in this case). In some other cases, attribute specifiers are permitted by this grammar but not yet supported by the compiler. All attribute specifiers in this place relate to the declaration as a whole. In the obsolescent usage where a type of &lt;code&gt;int&lt;/code&gt; is implied by the absence of type specifiers, such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers.</source>
          <target state="translated">Любой список спецификаторов и квалификаторов в начале объявления может содержать спецификаторы атрибутов, независимо от того, может ли такой список в этом контексте содержать спецификаторы класса хранения. (Однако некоторые атрибуты, по сути, являются спецификаторами класса хранения и имеют смысл только там, где могут использоваться спецификаторы класса хранения; например, &lt;code&gt;section&lt;/code&gt; .) Существует одно необходимое ограничение для этого синтаксиса: первое объявление параметра старого стиля в определении функции не может начинаться со спецификатора атрибута, потому что такой атрибут применяется к функции вместо синтаксиса, описанного ниже (который, однако, еще не реализовано в данном случае). В некоторых других случаях спецификаторы атрибутов разрешены этой грамматикой, но еще не поддерживаются компилятором. Все описатели атрибутов в этом месте относятся к объявлению в целом. В устаревшем использовании, когда тип &lt;code&gt;int&lt;/code&gt; подразумевается из-за отсутствия спецификаторов типа, такой список спецификаторов и квалификаторов может быть списком спецификаторов атрибутов без других спецификаторов или квалификаторов.</target>
        </trans-unit>
        <trans-unit id="c6c0071eb01b7f92c396e6d09604df6a2e8de02f" translate="yes" xml:space="preserve">
          <source>Any macros defined before the precompiled header is included must either be defined in the same way as when the precompiled header was generated, or must not affect the precompiled header, which usually means that they don&amp;rsquo;t appear in the precompiled header at all.</source>
          <target state="translated">Любые макросы, определенные до включения предварительно скомпилированного заголовка, должны быть либо определены так же, как при создании предварительно скомпилированного заголовка, либо не должны влиять на предварительно скомпилированный заголовок, что обычно означает, что они вообще не появляются в предварительно скомпилированном заголовке.</target>
        </trans-unit>
        <trans-unit id="0b92c247ae43e16cb2206e363e27a0e1ea146660" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the far address space.</source>
          <target state="translated">Любая ссылка в памяти на адрес в дальнем адресном пространстве.</target>
        </trans-unit>
        <trans-unit id="e16a334f229304e5f8dc7cc1bd4372e8b13392d9" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the near address space.</source>
          <target state="translated">Любая ссылка в памяти на адрес в ближайшем адресном пространстве.</target>
        </trans-unit>
        <trans-unit id="fd3f2043c21601ac2916c25995530fdcaff3e36d" translate="yes" xml:space="preserve">
          <source>Any mode at function entry is valid, and retained or restored when the function returns, and when it calls other functions. This mode is useful for compiling libraries or other compilation units you might want to incorporate into different programs with different prevailing FPU modes, and the convenience of being able to use a single object file outweighs the size and speed overhead for any extra mode switching that might be needed, compared with what would be needed with a more specific choice of prevailing FPU mode.</source>
          <target state="translated">Любой режим при вводе функции является действительным и сохраняется или восстанавливается при возвращении функции,а также при вызове других функций.Этот режим полезен для компиляции библиотек или других модулей компиляции,которые вы,возможно,захотите включить в различные программы с различными преобладающими режимами FPU,а удобство возможности использования одного объектного файла перевешивает размер и скорость работы любого дополнительного переключения режимов,которое может потребоваться,по сравнению с тем,что может потребоваться при более конкретном выборе преобладающего режима FPU.</target>
        </trans-unit>
        <trans-unit id="22db441873bce8bb93866379f320414a736631d8" translate="yes" xml:space="preserve">
          <source>Any of the SVE predicate registers (&lt;code&gt;P0&lt;/code&gt; to &lt;code&gt;P15&lt;/code&gt;)</source>
          <target state="translated">Любой из регистров предикатов SVE (от &lt;code&gt;P0&lt;/code&gt; до &lt;code&gt;P15&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="adb9f4f59a4cdd5c36fdb71fd2855542ab27a73f" translate="yes" xml:space="preserve">
          <source>Any of the floating point registers (AC0 through AC5).</source>
          <target state="translated">Любой из регистров с плавающей точкой (от AC0 до AC5).</target>
        </trans-unit>
        <trans-unit id="9b07ecf518f850aa2d367035bbfbe9f027595c80" translate="yes" xml:space="preserve">
          <source>Any operand whatsoever is allowed.</source>
          <target state="translated">Любая операция разрешена.</target>
        </trans-unit>
        <trans-unit id="f68eb98cf68489e1273e0a62b2ba59241c457e20" translate="yes" xml:space="preserve">
          <source>Any register</source>
          <target state="translated">Любой регистр</target>
        </trans-unit>
        <trans-unit id="3553311a1c2384ac5d5327beb00f7dd79264da05" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt;: &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Любой регистр, доступный как &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt; : &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0809f627bf7826a77322582ca3922a14c79d5ea4" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt;. In 32-bit mode, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;; in 64-bit mode, any integer register.</source>
          <target state="translated">Любой регистр, доступный как &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt; . В 32-битном режиме - &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; ; в 64-битном режиме - любой целочисленный регистр.</target>
        </trans-unit>
        <trans-unit id="c586b6a4345439cd7c8437d618d713fde64e21d5" translate="yes" xml:space="preserve">
          <source>Any register except accumulators or CC.</source>
          <target state="translated">Любой регистр,кроме аккумуляторов или CC.</target>
        </trans-unit>
        <trans-unit id="6f5e5f5ddbf2830c0d8f5e8f65ca789f3fd09903" translate="yes" xml:space="preserve">
          <source>Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.</source>
          <target state="translated">Допускаются любые регистры,память или непосредственный целочисленный операнд,за исключением регистров,которые не являются общими.</target>
        </trans-unit>
        <trans-unit id="7d047e8a746fffe93cd425189ec60df3684116e7" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;based&lt;/code&gt; attribute is assigned to the &lt;code&gt;.based&lt;/code&gt; section, and is accessed with relative to the &lt;code&gt;$tp&lt;/code&gt; register.</source>
          <target state="translated">Любая переменная с атрибутом &lt;code&gt;based&lt;/code&gt; назначается в раздел &lt;code&gt;.based&lt;/code&gt; , и доступ к ней осуществляется относительно регистра &lt;code&gt;$tp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e967d4316910c49c908407ba08671d2b2599c34" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;persistent&lt;/code&gt; attribute will not be initialised by the C runtime startup code. Instead its value will be set once, when the application is loaded, and then never initialised again, even if the processor is reset or the program restarts. Persistent data is intended to be placed into FLASH RAM, where its value will be retained across resets. The linker script being used to create the application should ensure that persistent data is correctly placed.</source>
          <target state="translated">Любая переменная с &lt;code&gt;persistent&lt;/code&gt; атрибутом не будет инициализирована кодом запуска среды выполнения C. Вместо этого его значение будет установлено один раз при загрузке приложения и никогда больше не будет инициализировано, даже если процессор сброшен или программа перезапустится. Постоянные данные предназначены для размещения во флэш-памяти, где их значение будет сохраняться при сбросах. Сценарий компоновщика, используемый для создания приложения, должен обеспечивать правильное размещение постоянных данных.</target>
        </trans-unit>
        <trans-unit id="6814c1eba0c0bb145d77465185a812135711db30" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;dir&lt;/var&gt; to the prefix specified previously with</source>
          <target state="translated">Добавить &lt;var&gt;dir&lt;/var&gt; к префиксу, указанному ранее, с помощью</target>
        </trans-unit>
        <trans-unit id="812a14ffbe77d828291132cdec93d807373c47c5" translate="yes" xml:space="preserve">
          <source>Application register residing in I-unit</source>
          <target state="translated">Регистр заявлений,проживающих в I-единице</target>
        </trans-unit>
        <trans-unit id="1236d15ff73551e90456786e45b32e0be147101a" translate="yes" xml:space="preserve">
          <source>Application register residing in M-unit</source>
          <target state="translated">Регистр заявлений,проживающих в М-единице</target>
        </trans-unit>
        <trans-unit id="157c651a499c80b5c8fd2d703d99af67d3154b57" translate="yes" xml:space="preserve">
          <source>Apply partitioned execution optimizations. This is the default when any level of optimization is selected.</source>
          <target state="translated">Применить оптимизацию выполнения с разделением.По умолчанию при выборе любого уровня оптимизации.</target>
        </trans-unit>
        <trans-unit id="1782ef9fd22ce5aa8daf22e12703623a7b69b3eb" translate="yes" xml:space="preserve">
          <source>Apply the &lt;code&gt;longcall&lt;/code&gt; attribute to all subsequent function declarations.</source>
          <target state="translated">Примените атрибут &lt;code&gt;longcall&lt;/code&gt; ко всем последующим объявлениям функций.</target>
        </trans-unit>
        <trans-unit id="282eae08ca98891b7edf1b6d8797fd6b87a9eaef" translate="yes" xml:space="preserve">
          <source>Apply unroll and jam transformations on feasible loops. In a loop nest this unrolls the outer loop by some factor and fuses the resulting multiple inner loops. This flag is enabled by default at</source>
          <target state="translated">Применяйте преобразования &quot;разворачивания&quot; и &quot;заклинивания&quot; на возможных циклах.В цикле-гнезде это разворачивает внешний цикл на какой-то фактор и плавит полученный многократный внутренний цикл.Этот флаг включен по умолчанию при</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="5180e6ec8c8c3a9e7de475a7424e90e67f44108f" translate="yes" xml:space="preserve">
          <source>Arguments of type &lt;code&gt;uh&lt;/code&gt;, &lt;code&gt;uw1&lt;/code&gt;, &lt;code&gt;sw1&lt;/code&gt;, &lt;code&gt;uw2&lt;/code&gt; and &lt;code&gt;sw2&lt;/code&gt; are evaluated at run time. They correspond to register operands in the underlying FR-V instructions.</source>
          <target state="translated">Аргументы типа &lt;code&gt;uh&lt;/code&gt; , &lt;code&gt;uw1&lt;/code&gt; , &lt;code&gt;sw1&lt;/code&gt; , &lt;code&gt;uw2&lt;/code&gt; и &lt;code&gt;sw2&lt;/code&gt; оцениваются во время выполнения. Они соответствуют регистровым операндам в базовых инструкциях FR-V.</target>
        </trans-unit>
        <trans-unit id="27b636e6a8cfc32ea746d5e97119c5c9f0abb374" translate="yes" xml:space="preserve">
          <source>Arguments that are documented as &lt;code&gt;const int&lt;/code&gt; require literal integral values within the range required for that operation.</source>
          <target state="translated">Аргументы, задокументированные как &lt;code&gt;const int&lt;/code&gt; , требуют буквальных целочисленных значений в пределах диапазона, необходимого для этой операции.</target>
        </trans-unit>
        <trans-unit id="56dc33ad93362bc115e17a1a1f9e847be1eea766" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;void&lt;/code&gt;-pointers and function pointers.</source>
          <target state="translated">Арифметика над указателями &lt;code&gt;void&lt;/code&gt; и указателями функций.</target>
        </trans-unit>
        <trans-unit id="69bbb6fc13a2914af3927b07e93cd7741bc9feb7" translate="yes" xml:space="preserve">
          <source>Armv8-A</source>
          <target state="translated">Armv8-A</target>
        </trans-unit>
        <trans-unit id="660e1e41a2fb561d4417587f9d3cb0a826807dab" translate="yes" xml:space="preserve">
          <source>Armv8.1-A</source>
          <target state="translated">Armv8.1-A</target>
        </trans-unit>
        <trans-unit id="068702f6b509e3ebf3a7362a3b6109bad1bc317c" translate="yes" xml:space="preserve">
          <source>Armv8.2-A</source>
          <target state="translated">Armv8.2-A</target>
        </trans-unit>
        <trans-unit id="9fe2d2038a9bf766f6b65dbcea4a2090d8403b7b" translate="yes" xml:space="preserve">
          <source>Armv8.3-A</source>
          <target state="translated">Armv8.3-A</target>
        </trans-unit>
        <trans-unit id="0c3f33729a39f559eae20d5545e995ad551dd902" translate="yes" xml:space="preserve">
          <source>Armv8.4-A</source>
          <target state="translated">Armv8.4-A</target>
        </trans-unit>
        <trans-unit id="255ee3b7801398dad2fbbd56f35d7d60c8e0a39d" translate="yes" xml:space="preserve">
          <source>Armv8.5-A</source>
          <target state="translated">Armv8.5-A</target>
        </trans-unit>
        <trans-unit id="4b5d9fa165aea4d969d0093fec00424d91bb68a1" translate="yes" xml:space="preserve">
          <source>Armv8.6-A</source>
          <target state="translated">Armv8.6-A</target>
        </trans-unit>
        <trans-unit id="b47ecbfd9e2fe292a564bf4865f526df3c8781c7" translate="yes" xml:space="preserve">
          <source>Arrays whose length is computed at run time.</source>
          <target state="translated">Массивы,длина которых вычисляется во время выполнения.</target>
        </trans-unit>
        <trans-unit id="62bbe9126770d1f883012b542af60463a81fc16c" translate="yes" xml:space="preserve">
          <source>As a GNU extension, GCC allows initialization of objects with static storage duration by compound literals (which is not possible in ISO C99 because the initializer is not a constant). It is handled as if the object were initialized only with the brace-enclosed list if the types of the compound literal and the object match. The elements of the compound literal must be constant. If the object being initialized has array type of unknown size, the size is determined by the size of the compound literal.</source>
          <target state="translated">Как расширение GNU,GCC позволяет инициализировать объекты со статической длительностью хранения сложными литералами (что невозможно в ISO C99,поскольку инициализатор не является константой).Он обрабатывается так,как если бы объект был инициализирован только с помощью списка,заключенного в скобки,если типы составного литерала и объекта совпадают.Элементы составного литерала должны быть постоянными.Если инициализируемый объект имеет тип массива неизвестного размера,то размер определяется размером составного литерала.</target>
        </trans-unit>
        <trans-unit id="f0b14342b73dd91f2d28adcdc3851266c0e2adc9" translate="yes" xml:space="preserve">
          <source>As a part of ACLE, GCC implements extensions for Advanced SIMD as described in the ARM C Language Extensions Specification. The complete list of Advanced SIMD intrinsics can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt;. The built-in intrinsics for the Advanced SIMD extension are available when NEON is enabled.</source>
          <target state="translated">Как часть ACLE, GCC реализует расширения для Advanced SIMD, как описано в Спецификации расширений языка C. Полный список встроенных функций Advanced SIMD можно найти на &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt; . Встроенные функции расширения Advanced SIMD доступны, когда включен NEON.</target>
        </trans-unit>
        <trans-unit id="3bf025a6b55c5b2b4d36feb2983875ada48832c0" translate="yes" xml:space="preserve">
          <source>As a result, if a function compiled with Sun CC takes the address of an argument of type &lt;code&gt;double&lt;/code&gt; and passes this pointer of type &lt;code&gt;double *&lt;/code&gt; to a function compiled with GCC, dereferencing the pointer may cause a fatal signal.</source>
          <target state="translated">В результате, если функция, скомпилированная с помощью Sun CC, принимает адрес аргумента типа &lt;code&gt;double&lt;/code&gt; и передает этот указатель типа &lt;code&gt;double *&lt;/code&gt; функции, скомпилированной с помощью GCC, разыменование указателя может вызвать фатальный сигнал.</target>
        </trans-unit>
        <trans-unit id="70fe12b60268d72ed32d2dad542457f63b7450a6" translate="yes" xml:space="preserve">
          <source>As a result, when a file is compiled with the</source>
          <target state="translated">В результате,когда файл компилируется с помощью команды</target>
        </trans-unit>
        <trans-unit id="de76cec1a0ee40014e9d6de2336c465c8c2b9403" translate="yes" xml:space="preserve">
          <source>As a special kludge, if the path provided by</source>
          <target state="translated">В качестве особого ключа,если путь,предоставленный</target>
        </trans-unit>
        <trans-unit id="b70ccdaa2f1d44ed8f039d89a64ebf9722e0436b" translate="yes" xml:space="preserve">
          <source>As an alternative to providing a spec string, the text following a suffix directive can be one of the following:</source>
          <target state="translated">В качестве альтернативы предоставлению строки спецификации текст,следующий за суффиксной директивой,может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">В качестве примера:</target>
        </trans-unit>
        <trans-unit id="733120310e3f16a7d9b6ceb479247f71058a2dab" translate="yes" xml:space="preserve">
          <source>As an extension the integer scalar type &lt;code&gt;__int128&lt;/code&gt; is supported for targets which have an integer mode wide enough to hold 128 bits. Simply write &lt;code&gt;__int128&lt;/code&gt; for a signed 128-bit integer, or &lt;code&gt;unsigned __int128&lt;/code&gt; for an unsigned 128-bit integer. There is no support in GCC for expressing an integer constant of type &lt;code&gt;__int128&lt;/code&gt; for targets with &lt;code&gt;long long&lt;/code&gt; integer less than 128 bits wide.</source>
          <target state="translated">В качестве расширения целочисленный скалярный тип &lt;code&gt;__int128&lt;/code&gt; поддерживается для целей, которые имеют целочисленный режим, достаточный для хранения 128 бит. Просто напишите &lt;code&gt;__int128&lt;/code&gt; для 128-битного целого числа со &lt;code&gt;unsigned __int128&lt;/code&gt; или беззнаковое __int128 для 128-битного целого числа без знака. В GCC нет поддержки для выражения целочисленной константы типа &lt;code&gt;__int128&lt;/code&gt; для целей с &lt;code&gt;long long&lt;/code&gt; целым числом менее 128 бит.</target>
        </trans-unit>
        <trans-unit id="a3f87270bea18e65d71a654a8f0baf39b38c480a" translate="yes" xml:space="preserve">
          <source>As an extension to the C language, GCC does not use the latitude given in C99 and C11 only to treat certain aspects of signed &amp;lsquo;</source>
          <target state="translated">Как расширение языка C, GCC не использует широту, указанную в C99 и C11, только для обработки определенных аспектов подписанного '</target>
        </trans-unit>
        <trans-unit id="4513679ee7e9cc2a019ac56fe5e24f303a414ac9" translate="yes" xml:space="preserve">
          <source>As an extension, GCC accepts variable-length arrays as a member of a structure or a union. For example:</source>
          <target state="translated">В качестве расширения GCC принимает массивы переменной длины в качестве члена структуры или союза.Например:</target>
        </trans-unit>
        <trans-unit id="27e4f48620a93a562285a400297cd393c63d1803" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C and GNU C++ support additional floating types, which are not supported by all targets.</source>
          <target state="translated">В качестве расширения GNU C и GNU C++поддерживают дополнительные плавающие типы,которые поддерживаются не всеми целями.</target>
        </trans-unit>
        <trans-unit id="697b66e118a429cde99672cf767b29bbf7517cb2" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports decimal floating types as defined in the N1312 draft of ISO/IEC WDTR24732. Support for decimal floating types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support decimal floating types.</source>
          <target state="translated">В качестве расширения GNU C поддерживает десятичные плавающие типы,как они определены в черновике N1312 стандарта ISO/IEC WDTR24732.Поддержка десятичных плавающих типов в GCC будет развиваться по мере изменения проекта технического отчета.Изменения могут также коснуться призывов к соблюдению конвенций для любой цели.Не все цели поддерживают типы десятичных плавающих знаков.</target>
        </trans-unit>
        <trans-unit id="1e14a45ce2c917a5c2a3b3b95aa86553c2d0d4a7" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports fixed-point types as defined in the N1169 draft of ISO/IEC DTR 18037. Support for fixed-point types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support fixed-point types.</source>
          <target state="translated">В качестве расширения GNU C поддерживает типы фиксированных точек,как они определены в проекте N1169 стандарта ISO/IEC DTR 18037.Поддержка типов фиксированных точек в ССАГПЗ будет развиваться по мере изменения проекта технического отчета.Могут также измениться призывы к соблюдению конвенций для любой цели.Не все целевые группы поддерживают типы фиксированных точек.</target>
        </trans-unit>
        <trans-unit id="6505eef47254e959e5dceda5b17ed5092c6fdad3" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7086d776842151d1d2c42c2e5523eaf5840573e5" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, SPU, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="translated">В качестве расширения GNU C поддерживает именованные адресные пространства,как они определены в проекте N1275 стандарта ISO/IEC DTR 18037.Поддержка именованных адресных пространств в GCC будет развиваться по мере изменения проекта технического отчета.Призыв к конвенции для любой цели также может измениться.В настоящее время только цели AVR,SPU,M32C,RL78 и x86 поддерживают адресные пространства,отличные от общего адресного пространства.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
