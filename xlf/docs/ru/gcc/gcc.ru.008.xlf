<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="aeab84fbb87aa1ae0148d00185bbbe64a7f1de75" translate="yes" xml:space="preserve">
          <source>Do/do not align destination of inlined string operations.</source>
          <target state="translated">Не/не выравнивайте пункт назначения операций с инкрустированной строкой.</target>
        </trans-unit>
        <trans-unit id="bc45e676c4601147aa81205b6b35bbce28a0956f" translate="yes" xml:space="preserve">
          <source>Dollar sign is allowed in identifiers.</source>
          <target state="translated">В идентификаторах допускается использование знака доллара.</target>
        </trans-unit>
        <trans-unit id="68e93316f665d706cb16fce9b665aecabf389d83" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t (or do) generate assembler code for the DWARF line number debugging info. This may be useful when not using the GNU assembler.</source>
          <target state="translated">Не (или не создавайте) код ассемблера для информации об отладке номера строки DWARF. Это может быть полезно, когда не используется ассемблер GNU.</target>
        </trans-unit>
        <trans-unit id="c37914471f4a30f8d34225039b83103b924890c2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51bdbcf76c028728ebe02e5fd8a3a1a4630491b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allocate any register in the range &lt;code&gt;r32&lt;/code&gt;&amp;hellip;&lt;code&gt;r63&lt;/code&gt;. That allows code to run on hardware variants that lack these registers.</source>
          <target state="translated">Не &lt;code&gt;r32&lt;/code&gt; регистры в диапазоне r32 &amp;hellip; &lt;code&gt;r63&lt;/code&gt; . Это позволяет коду работать на вариантах оборудования, в которых отсутствуют эти регистры.</target>
        </trans-unit>
        <trans-unit id="0696f924a6a7aba65bb0c521d005ad21d730a7e5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allow (allow) the compiler generating privileged mode code. Specifying</source>
          <target state="translated">Не разрешать (разрешать) компилятору генерировать код привилегированного режима. Определение</target>
        </trans-unit>
        <trans-unit id="b4aac26fa88db757f99f48797196bd3cbd91bc9d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t emit code for implicit instantiations of inline templates, either. The default is to handle inlines differently so that compiles with and without optimization need the same set of explicit instantiations.</source>
          <target state="translated">Также не создавайте код для неявных экземпляров встроенных шаблонов. По умолчанию встроенные элементы обрабатываются по-разному, поэтому для компиляции с оптимизацией и без нее требуется один и тот же набор явных экземпляров.</target>
        </trans-unit>
        <trans-unit id="c69befd629431a6e029cd45dbc6aab7876d6d7d6" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate code to check for violation of exception specifications at run time. This option violates the C++ standard, but may be useful for reducing code size in production builds, much like defining &lt;code&gt;NDEBUG&lt;/code&gt;. This does not give user code permission to throw exceptions in violation of the exception specifications; the compiler still optimizes based on the specifications, so throwing an unexpected exception results in undefined behavior at run time.</source>
          <target state="translated">Не создавайте код для проверки нарушения спецификаций исключения во время выполнения. Этот параметр нарушает стандарт C ++, но может быть полезен для уменьшения размера кода в производственных сборках, как и определение &lt;code&gt;NDEBUG&lt;/code&gt; . Это не дает пользовательскому коду разрешения создавать исключения в нарушение спецификаций исключений; компилятор по-прежнему оптимизируется на основе спецификаций, поэтому выдача неожиданного исключения приводит к неопределенному поведению во время выполнения.</target>
        </trans-unit>
        <trans-unit id="f8291058c6a41a1212fed5bdc0b889e02ad54e73" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent CSYNC or SSYNC instructions from occurring too soon after a conditional branch.</source>
          <target state="translated">Не создавайте дополнительный код, чтобы предотвратить выполнение инструкций CSYNC или SSYNC слишком быстро после условного перехода.</target>
        </trans-unit>
        <trans-unit id="92fc05375382df9e90695eff3a44465379a9fc8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent speculative loads from occurring.</source>
          <target state="translated">Не создавайте лишний код, чтобы предотвратить возникновение спекулятивных нагрузок.</target>
        </trans-unit>
        <trans-unit id="841b2c5913f27dd6d0a0b75be4041ed9060e2a5b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t indicate any priority for target registers.</source>
          <target state="translated">Не указывайте приоритет для целевых регистров.</target>
        </trans-unit>
        <trans-unit id="316b458b3b915800cc227cb589b8354e8997e031" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t insert NOPs.</source>
          <target state="translated">Не вставляйте NOP.</target>
        </trans-unit>
        <trans-unit id="ff257b74ea5cefc2a6c99dc46dcf1ce2fc00c3e9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up and restore frame pointers and makes an extra register available in leaf functions.</source>
          <target state="translated">Не храните указатель фрейма в регистре для листовых функций. Это позволяет избежать инструкций по сохранению, настройке и восстановлению указателей кадров и делает доступным дополнительный регистр в листовых функциях.</target>
        </trans-unit>
        <trans-unit id="29fcb114afda8378c254d0362fee3390fc31a076" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up, and restore frame pointers and makes an extra register available in leaf functions. The option</source>
          <target state="translated">Не храните указатель фрейма в регистре для листовых функций. Это позволяет избежать инструкций по сохранению, настройке и восстановлению указателей кадров и делает доступным дополнительный регистр в листовых функциях. Опция</target>
        </trans-unit>
        <trans-unit id="ba01c69254f25c86224b738f06e6534bc4f3d911" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t link against AVR-LibC&amp;rsquo;s device specific library &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt;.</source>
          <target state="translated">Не связывайтесь с библиотекой AVR-LibC для конкретного устройства &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e29b08debc2f8c83b43cab1a04eee2f4d727ea03" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t output a &lt;code&gt;.size&lt;/code&gt; assembler directive, or anything else that would cause trouble if the function is split in the middle, and the two halves are placed at locations far apart in memory. This option is used when compiling</source>
          <target state="translated">Не &lt;code&gt;.size&lt;/code&gt; ассемблерную директиву .size или что-либо еще, что могло бы вызвать проблемы, если функция разделена посередине, а две половинки размещены в местах, далеко друг от друга в памяти. Эта опция используется при компиляции</target>
        </trans-unit>
        <trans-unit id="d01cd709102ba1930825f66a542ae471f0249850" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t produce a dynamically linked position independent executable.</source>
          <target state="translated">Не создавайте динамически связанный исполняемый файл, независимый от позиции.</target>
        </trans-unit>
        <trans-unit id="0d7422ae3d66c98a5899ca6447dbd9bcec60457e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t recognize built-in functions that do not begin with &amp;lsquo;</source>
          <target state="translated">Не распознайте встроенные функции, которые не начинаются с '</target>
        </trans-unit>
        <trans-unit id="700e3402560c020ff640d0360da073b7f29b63b2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to return a reference when you must return an object.</source>
          <target state="translated">Не пытайтесь вернуть ссылку, если вы должны вернуть объект.</target>
        </trans-unit>
        <trans-unit id="af0c2963603baeac9b84a7601cb10b5b24bf9b5d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use less than 25-bit addressing range for calls, which is the offset available for an unconditional branch-and-link instruction. Conditional execution of function calls is suppressed, to allow use of the 25-bit range, rather than the 21-bit range with conditional branch-and-link. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">Не используйте для вызовов менее 25-битный диапазон адресации, который является смещением, доступным для безусловной инструкции перехода и ссылки. Условное выполнение вызовов функций подавляется, чтобы разрешить использование 25-битного диапазона, а не 21-битного диапазона с условным переходом и ссылкой. Это значение по умолчанию для цепочек инструментов, созданных для целей &lt;code&gt;arc-linux-uclibc&lt;/code&gt; &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; и arceb-linux-uclibc .</target>
        </trans-unit>
        <trans-unit id="71dc31daaf7ec06b2fa4f05018881b81c4bb5538" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the &lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; runtime routine. This causes &lt;code&gt;std::uncaught_exception&lt;/code&gt; to be incorrect, but is necessary if the runtime routine is not available.</source>
          <target state="translated">Не используйте &lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; времени выполнения __cxa_get_exception_ptr . Это приводит к тому, что &lt;code&gt;std::uncaught_exception&lt;/code&gt; неверен, но это необходимо, если подпрограмма времени выполнения недоступна.</target>
        </trans-unit>
        <trans-unit id="8dcc5d27681a8bdad6a9cb3ee54a8968b968d227" translate="yes" xml:space="preserve">
          <source>Double-precision floating point:</source>
          <target state="translated">Двойная точность с плавающей точкой:</target>
        </trans-unit>
        <trans-unit id="ed1ceb86db6df41816a7c2bb25eb2a7096005f14" translate="yes" xml:space="preserve">
          <source>Double-precision minimum and maximum. These instructions are only generated if</source>
          <target state="translated">Минимальная и максимальная двойная точность.Эти инструкции генерируются только в том случае,если</target>
        </trans-unit>
        <trans-unit id="37d9eb125267c27f5502a1a9d084767dc36a78f0" translate="yes" xml:space="preserve">
          <source>Double-precision trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">Тригонометрические и экспоненциальные функции двойной точности.Эти инструкции генерируются только в том случае,если</target>
        </trans-unit>
        <trans-unit id="6df71cfe44fe533eddb81c22b571782849f6b7cc" translate="yes" xml:space="preserve">
          <source>Double-word integers&amp;mdash;&lt;code&gt;long long int&lt;/code&gt;.</source>
          <target state="translated">Двухсловные целые числа - &lt;code&gt;long long int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc953a7def63cef4cb68fb70c5f14bea1b94cf60" translate="yes" xml:space="preserve">
          <source>Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using</source>
          <target state="translated">Отбросить некоторые диагностики о несоответствующем коде от ошибок к предупреждениям.Таким образом,используя</target>
        </trans-unit>
        <trans-unit id="01180802e3e84af7a4d8039eea60df66e24e2e3d" translate="yes" xml:space="preserve">
          <source>Due to a limitation the &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt; for the &lt;code&gt;mode&lt;/code&gt; attribute even if the type or variable referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument was declared with one. The function is also not supported with labels, and in C with enumerators.</source>
          <target state="translated">Из-за ограничения функция &lt;code&gt;__builtin_has_attribute&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; для атрибута &lt;code&gt;mode&lt;/code&gt; даже если тип или переменная, на которую ссылается аргумент &lt;var&gt;type-or-expression&lt;/var&gt; был объявлен с одним. Функция также не поддерживается с метками, а в C - с перечислителями.</target>
        </trans-unit>
        <trans-unit id="eaa7b08f0e0c97160e76284248f06868dbcb58d2" translate="yes" xml:space="preserve">
          <source>Due to delay slot scheduling and interactions between operand numbers, literal sizes, instruction lengths, and the support for conditional execution, the target-independent pass to generate conditional execution is often lacking, so the ARC port has kept a special pass around that tries to find more conditional execution generation opportunities after register allocation, branch shortening, and delay slot scheduling have been done. This pass generally, but not always, improves performance and code size, at the cost of extra compilation time, which is why there is an option to switch it off. If you have a problem with call instructions exceeding their allowable offset range because they are conditionalized, you should consider using</source>
          <target state="translated">Из-за планирования слотов задержки и взаимодействия между номерами операндов,буквальными размерами,длинами инструкций и поддержкой условного исполнения,часто отсутствует целевой независимый проход для генерации условного исполнения,поэтому порт ARC хранит специальный проход,который пытается найти больше возможностей для генерации условного исполнения после распределения регистров,сокращения ветвей и планирования слотов задержки.Этот проход в целом,но не всегда,улучшает производительность и размер кода,за счет дополнительного времени компиляции,поэтому есть возможность его отключить.Если у вас есть проблема с превышением допустимого диапазона смещения инструкций вызова из-за их условности,вам следует подумать об использовании</target>
        </trans-unit>
        <trans-unit id="8570e266a139eea3cf33870c783885655692c297" translate="yes" xml:space="preserve">
          <source>Due to differences in 64-bit ABIs, any Microsoft ABI function that calls a System V ABI function must consider RSI, RDI and XMM6-15 as clobbered. By default, the code for saving and restoring these registers is emitted inline, resulting in fairly lengthy prologues and epilogues. Using</source>
          <target state="translated">Из-за различий в 64-битных ABI,любая функция Microsoft ABI,вызывающая System V ABI,должна считать RSI,RDI и XMM6-15 забитыми.По умолчанию код для сохранения и восстановления этих регистров выдается встроенным,что приводит к довольно длинным прологам и эпилогам.Используя</target>
        </trans-unit>
        <trans-unit id="408f58f18488b8883676547177ce8b939c3a83db" translate="yes" xml:space="preserve">
          <source>Dump a representation of the &amp;ldquo;exploded graph&amp;rdquo; suitable for viewing with GraphViz to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169bc667798b22c68aedd5d55d686c15e2808baf" translate="yes" xml:space="preserve">
          <source>Dump a representation of the call graph suitable for viewing with GraphViz to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d46471a4ce7f3b77f03f78421a9baa93db393b" translate="yes" xml:space="preserve">
          <source>Dump a textual representation of the &amp;ldquo;exploded graph&amp;rdquo; to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca50a32f407b97e3b5dbaa8c49a491f9e0224426" translate="yes" xml:space="preserve">
          <source>Dump a textual representation of the &amp;ldquo;exploded graph&amp;rdquo; to one dump file per node, to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55dc1ed426258fad4287ccc3186c8799b4478fe2" translate="yes" xml:space="preserve">
          <source>Dump after RTL generation.</source>
          <target state="translated">Сброс после генерации RTL.</target>
        </trans-unit>
        <trans-unit id="55112da270658f739f4dfb65c2070abbe0a2de15" translate="yes" xml:space="preserve">
          <source>Dump after all rtl has been unshared.</source>
          <target state="translated">Сбросить после того,как все РТЛ не были разделены.</target>
        </trans-unit>
        <trans-unit id="17713d860b95f07f88ad9a9c6f46bff3093dd8bf" translate="yes" xml:space="preserve">
          <source>Dump after auto-inc-dec discovery. This pass is only run on architectures that have auto inc or auto dec instructions.</source>
          <target state="translated">Сброс после авто-ин-декс обнаружения.Эта передача выполняется только на архитектурах с инструкциями auto inc или auto dec.</target>
        </trans-unit>
        <trans-unit id="4544c05126cdb19431a178314ee1eee9792fb198" translate="yes" xml:space="preserve">
          <source>Dump after block reordering.</source>
          <target state="translated">Сброс после переупорядочивания блоков.</target>
        </trans-unit>
        <trans-unit id="78c9d4108223d54d2d9b5209aec4c77ba61f990a" translate="yes" xml:space="preserve">
          <source>Dump after branch alignments have been computed.</source>
          <target state="translated">Сброс после расчета выравнивания ветвей.</target>
        </trans-unit>
        <trans-unit id="becf6aa3d2a32b64f568f0ff4ffede5097942c5f" translate="yes" xml:space="preserve">
          <source>Dump after cleaning up the barrier instructions.</source>
          <target state="translated">Сброс после очистки инструкций по установке шлагбаума.</target>
        </trans-unit>
        <trans-unit id="4157bd0dc462fb4b9de6813e4b6322c3ce89115d" translate="yes" xml:space="preserve">
          <source>Dump after combining stack adjustments.</source>
          <target state="translated">Сброс после совмещения регулировок стека.</target>
        </trans-unit>
        <trans-unit id="ca08541014a668445bc90fdf9e0e75729f2449db" translate="yes" xml:space="preserve">
          <source>Dump after common sequence discovery.</source>
          <target state="translated">Сброс после обнаружения общей последовательности.</target>
        </trans-unit>
        <trans-unit id="003a4c3463d2348777de9c3ec96a83fded9a133b" translate="yes" xml:space="preserve">
          <source>Dump after conversion from GCC&amp;rsquo;s &amp;ldquo;flat register file&amp;rdquo; registers to the x87&amp;rsquo;s stack-like registers. This pass is only run on x86 variants.</source>
          <target state="translated">Дамп после преобразования из регистров &amp;laquo;плоского регистрового файла&amp;raquo; GCC в стековые регистры x87. Этот проход работает только на вариантах x86.</target>
        </trans-unit>
        <trans-unit id="83008119d9369fbf18b0ada0441c79a07768ec53" translate="yes" xml:space="preserve">
          <source>Dump after conversion of EH handling range regions.</source>
          <target state="translated">Сброс после переоборудования областей диапазона обработки EH.</target>
        </trans-unit>
        <trans-unit id="3bf729ea33ed64d3ed60d59c687162fd5feb227f" translate="yes" xml:space="preserve">
          <source>Dump after converting from cfglayout mode.</source>
          <target state="translated">Сброс после перехода из режима cfglayout.</target>
        </trans-unit>
        <trans-unit id="8c3c2b3635d622c5e7ba8ea735eb12810fb32bac" translate="yes" xml:space="preserve">
          <source>Dump after converting to cfglayout mode.</source>
          <target state="translated">Сброс после перехода в режим cfglayout.</target>
        </trans-unit>
        <trans-unit id="c3336c59217d8a52dec6ae53e20f9f151f5f642d" translate="yes" xml:space="preserve">
          <source>Dump after converting virtual registers to hard registers.</source>
          <target state="translated">Дамп после преобразования виртуальных регистров в жесткие.</target>
        </trans-unit>
        <trans-unit id="9e4924e7d7139d25008b3b0767ee0c48540ad8c8" translate="yes" xml:space="preserve">
          <source>Dump after delayed branch scheduling.</source>
          <target state="translated">Сброс после задержки планирования филиала.</target>
        </trans-unit>
        <trans-unit id="d2764959e209d321913a6a9e66c4ca5ca11ad126" translate="yes" xml:space="preserve">
          <source>Dump after duplicating the computed gotos.</source>
          <target state="translated">Сброс после дублирования вычисленных гото.</target>
        </trans-unit>
        <trans-unit id="6e4665a9117fc08d9bbcca5529570f4270193b64" translate="yes" xml:space="preserve">
          <source>Dump after finalization of EH handling code.</source>
          <target state="translated">Сброс после доработки кода обработки EH.</target>
        </trans-unit>
        <trans-unit id="0bd2968b703fd689e056f9d8a3839eaca5ddccc9" translate="yes" xml:space="preserve">
          <source>Dump after fixing rtl statements that have unsatisfied in/out constraints.</source>
          <target state="translated">Сброс после фиксации утверждений rtl,которые имеют неудовлетворительные ограничения по входу/выходу.</target>
        </trans-unit>
        <trans-unit id="1f6440e322c9dbaaa59c98dce4c47af3058d32dc" translate="yes" xml:space="preserve">
          <source>Dump after function inlining.</source>
          <target state="translated">Сброс после встраивания функции.</target>
        </trans-unit>
        <trans-unit id="988226cdeaba5c3515016a8a81c5ff5fb6cd975a" translate="yes" xml:space="preserve">
          <source>Dump after generating the function prologues and epilogues.</source>
          <target state="translated">Сброс после генерации функции прологов и эпилогов.</target>
        </trans-unit>
        <trans-unit id="337d4408dd5282e57a077069c98fc55c719caf17" translate="yes" xml:space="preserve">
          <source>Dump after hard register copy propagation.</source>
          <target state="translated">Дампа после распространения жесткой копии реестра.</target>
        </trans-unit>
        <trans-unit id="6cfe830bfa04c4483b1574a46bcfd925bca4b994" translate="yes" xml:space="preserve">
          <source>Dump after iterated register allocation.</source>
          <target state="translated">Сброс после итерационного распределения регистров.</target>
        </trans-unit>
        <trans-unit id="1332404cd20a620c3e5eef9263282d44f935e6c1" translate="yes" xml:space="preserve">
          <source>Dump after jump bypassing and control flow optimizations.</source>
          <target state="translated">Сброс после прыжка в обход и оптимизация управления потоком.</target>
        </trans-unit>
        <trans-unit id="bbeda7ae9b9627b581ee42ee3d7f61a589a6f9b2" translate="yes" xml:space="preserve">
          <source>Dump after live range splitting.</source>
          <target state="translated">Сброс после разделения радиуса действия.</target>
        </trans-unit>
        <trans-unit id="35f1d73925595e51018771690ad76fb0f4a1f233" translate="yes" xml:space="preserve">
          <source>Dump after modulo scheduling. This pass is only run on some architectures.</source>
          <target state="translated">Сброс после составления расписания по модулю.Эта передача выполняется только на некоторых архитектурах.</target>
        </trans-unit>
        <trans-unit id="d76e4430e6a8233563404db6f071f4d94eacdd64" translate="yes" xml:space="preserve">
          <source>Dump after partitioning hot and cold basic blocks.</source>
          <target state="translated">Сброс после разделения горячих и холодных основных блоков.</target>
        </trans-unit>
        <trans-unit id="93dacaa1e7ab1044d9cdae673b25a3808eaccbc6" translate="yes" xml:space="preserve">
          <source>Dump after performing the machine dependent reorganization pass, if that pass exists.</source>
          <target state="translated">Сброс после выполнения зависящего от машины прохода реорганизации,если такой проход существует.</target>
        </trans-unit>
        <trans-unit id="b6bdb28476f2b3244c70b802b4bb64b0a7243f10" translate="yes" xml:space="preserve">
          <source>Dump after post-reload optimizations.</source>
          <target state="translated">Дампа после оптимизации после загрузки.</target>
        </trans-unit>
        <trans-unit id="88e826a50b33b907232b8a297fb0c5a8f9b2749b" translate="yes" xml:space="preserve">
          <source>Dump after register renumbering.</source>
          <target state="translated">Сброс после перенумерации реестра.</target>
        </trans-unit>
        <trans-unit id="ababff05976fea728752ca7d70fe16f292f0407d" translate="yes" xml:space="preserve">
          <source>Dump after removing redundant mode switches.</source>
          <target state="translated">Сброс после удаления переключателей режима резервирования.</target>
        </trans-unit>
        <trans-unit id="017c4f83a9a4f5ea41d958881b5ab4ae0e8a9034" translate="yes" xml:space="preserve">
          <source>Dump after shortening branches.</source>
          <target state="translated">Сброс после укорачивания веток.</target>
        </trans-unit>
        <trans-unit id="b3771d727095e3610636bea776ecdc1fc695644e" translate="yes" xml:space="preserve">
          <source>Dump after sibling call optimizations.</source>
          <target state="translated">Сброс после оптимизации звонков брата и сестры.</target>
        </trans-unit>
        <trans-unit id="c8dbbab140317072ef733bc98b57dcf08d1828c7" translate="yes" xml:space="preserve">
          <source>Dump after sign/zero extension elimination.</source>
          <target state="translated">Сброс после устранения знака/ноля расширения.</target>
        </trans-unit>
        <trans-unit id="e9bbcf22fbbd3795374ba7c5550d62449e5abb59" translate="yes" xml:space="preserve">
          <source>Dump after the RTL instruction combination pass.</source>
          <target state="translated">Сброс после прохождения комбинации команд RTL.</target>
        </trans-unit>
        <trans-unit id="feffc80f8e62ccde9b555546a5afb7ff2768d0f7" translate="yes" xml:space="preserve">
          <source>Dump after the computation of the initial value sets.</source>
          <target state="translated">Дампа после вычисления исходных наборов значений.</target>
        </trans-unit>
        <trans-unit id="5bf6c1aae6940dca8add6967093968d70664b454" translate="yes" xml:space="preserve">
          <source>Dump after the initialization of the registers.</source>
          <target state="translated">Дампа после инициализации регистров.</target>
        </trans-unit>
        <trans-unit id="d22e8f2d8c89989fe194bf7d0b0983f1d445d944" translate="yes" xml:space="preserve">
          <source>Dump after the peephole pass.</source>
          <target state="translated">Сбросьте после прохода в глазок.</target>
        </trans-unit>
        <trans-unit id="9201f61bd4694de8e9a9ab14f3cc717f0cf63945" translate="yes" xml:space="preserve">
          <source>Dump after the second jump optimization.</source>
          <target state="translated">Сброс после второй оптимизации прыжка.</target>
        </trans-unit>
        <trans-unit id="418c902efcddfdb022a1c7b5bf343ea52897c514" translate="yes" xml:space="preserve">
          <source>Dump after the standalone dead code elimination passes.</source>
          <target state="translated">Сбросьте после того,как пройдет самостоятельное удаление мертвого кода.</target>
        </trans-unit>
        <trans-unit id="79702f60e31788035dc7ae01b75a7919074a5bce" translate="yes" xml:space="preserve">
          <source>Dump after variable tracking.</source>
          <target state="translated">Сброс после отслеживания переменных.</target>
        </trans-unit>
        <trans-unit id="907510a3aae3ec8d9be507f0c620d65e786ea7f0" translate="yes" xml:space="preserve">
          <source>Dump all macro definitions, at the end of preprocessing, in addition to normal output.</source>
          <target state="translated">Дампинг всех макроопределений,в конце препроцессирования,в дополнение к нормальному выходу.</target>
        </trans-unit>
        <trans-unit id="c5efd5b60f90b713fff2357c80d7db933b0250ab" translate="yes" xml:space="preserve">
          <source>Dump class hierarchy information. Virtual table information is emitted unless &amp;rsquo;</source>
          <target state="translated">Вывести информацию об иерархии классов. Информация о виртуальной таблице передается, если только '</target>
        </trans-unit>
        <trans-unit id="7bc6ef641876378e44aa64caddde9a5c6398af12" translate="yes" xml:space="preserve">
          <source>Dump content of records.</source>
          <target state="translated">Дампинг содержания записей.</target>
        </trans-unit>
        <trans-unit id="b65d037ae2af66afd4c389367c4bc6cdd9830974" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the debug generation phase.</source>
          <target state="translated">Дампа отладочной информации,сгенерированной на этапе генерации отладки.</target>
        </trans-unit>
        <trans-unit id="c9b2d27d13ca1550be85a391df7269704a34e8f9" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the early debug generation phase.</source>
          <target state="translated">Дампа отладочной информации,генерируемой на ранней стадии отладки.</target>
        </trans-unit>
        <trans-unit id="1abef1a2a1cc464ec73ba64187b2cddb0b1c7d96" translate="yes" xml:space="preserve">
          <source>Dump initial values of the variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5bde1ac03861eb7f209733ddfd1025c1c70bcf" translate="yes" xml:space="preserve">
          <source>Dump instruction size and location in the assembly code.</source>
          <target state="translated">Размер и расположение команды сброса в коде ассемблера.</target>
        </trans-unit>
        <trans-unit id="754b569854e205d185835c2d9673785b92b6f32c" translate="yes" xml:space="preserve">
          <source>Dump interface declarations for all classes seen in the source file to a file named</source>
          <target state="translated">Объявления интерфейса дампа для всех классов,видимых в исходном файле,в файл с именем</target>
        </trans-unit>
        <trans-unit id="71af018e18b101632a18de688096b3fe9f9a731e" translate="yes" xml:space="preserve">
          <source>Dump internal details about what the analyzer is doing to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e377d6eb44f5fb68248439a06aca414e07626287" translate="yes" xml:space="preserve">
          <source>Dump internal details about what the analyzer is doing to stderr. This option overrides</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657cfbab09055c61a05bd93612f91cf2d2f1bab3" translate="yes" xml:space="preserve">
          <source>Dump only the defined symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e881c92154f92df37cd4957d4fba3b310ed362c0" translate="yes" xml:space="preserve">
          <source>Dump out a</source>
          <target state="translated">Сбросить</target>
        </trans-unit>
        <trans-unit id="72d2bf1fd50afe65e57f8ac99ba069fc8e23ed58" translate="yes" xml:space="preserve">
          <source>Dump positions of records.</source>
          <target state="translated">Дампы позиций записей.</target>
        </trans-unit>
        <trans-unit id="62f71366775032a269dc239f7ef38d5ece6fef12" translate="yes" xml:space="preserve">
          <source>Dump representations of the &amp;ldquo;supergraph&amp;rdquo; suitable for viewing with GraphViz to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ac4bde087663de0f3a006b963a6f5235611c2d" translate="yes" xml:space="preserve">
          <source>Dump the RTL in the assembler output as a comment before each instruction. Also turns on</source>
          <target state="translated">Дампируйте RTL в выход ассемблера в качестве комментария перед каждой командой.Также включает</target>
        </trans-unit>
        <trans-unit id="0be5cff07653f79d7c01424690f5d095b8fcbb7d" translate="yes" xml:space="preserve">
          <source>Dump the demangled output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1726ca951812ad3322375de05b128457cc9a8ced" translate="yes" xml:space="preserve">
          <source>Dump the details of LTO objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171aa9511579073802041f0a2e60b1934e57be91" translate="yes" xml:space="preserve">
          <source>Dump the details of specific symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d265d5ceeb36fc58845a8b5aa258590ef02cc80" translate="yes" xml:space="preserve">
          <source>Dump the final internal representation (RTL) to &lt;var&gt;file&lt;/var&gt;. If the optional argument is omitted (or if &lt;var&gt;file&lt;/var&gt; is &lt;code&gt;.&lt;/code&gt;), the name of the dump file is determined by appending &lt;code&gt;.gkd&lt;/code&gt; to the compilation output file name.</source>
          <target state="translated">Выгрузите окончательное внутреннее представление (RTL) в &lt;var&gt;file&lt;/var&gt; . Если необязательный аргумент опущен (или , если &lt;var&gt;file&lt;/var&gt; находится &lt;code&gt;.&lt;/code&gt; ), Имя файла дампа определяется путем добавления &lt;code&gt;.gkd&lt;/code&gt; на имя выходного файла компиляции.</target>
        </trans-unit>
        <trans-unit id="6290582c1c9788e12ed9d3f73eafdd3bbcd4abf7" translate="yes" xml:space="preserve">
          <source>Dump the raw internal tree data. This option is applicable to C++ only.</source>
          <target state="translated">Сбросьте необработанные внутренние данные дерева.Эта опция применима только для C++.</target>
        </trans-unit>
        <trans-unit id="1afb37f8221633019abbbb6e4139e775923345d4" translate="yes" xml:space="preserve">
          <source>Dump the specific gimple body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1097bb2eea2f70c64d4c1cb70ed1c5ba583376" translate="yes" xml:space="preserve">
          <source>Dump the statistics of gimple statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4757ccb92c3f2e13c8881d180d079b3623ccf0" translate="yes" xml:space="preserve">
          <source>Dump the statistics of tree types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4cd598ed5041028b59e01e68f001fefceb7ea6" translate="yes" xml:space="preserve">
          <source>Dump the statistics of trees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b93daf63f806cdb033463ad6f03043c2e411af3" translate="yes" xml:space="preserve">
          <source>Dump the symbols in order of occurrence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389f264332906b0c1d732e39c64a371de3b149c7" translate="yes" xml:space="preserve">
          <source>Dump the symbols in reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c09bbbb574ea9794181ca0910564f4164221e71" translate="yes" xml:space="preserve">
          <source>Dumps information about call-graph optimization, unused function removal, and inlining decisions.</source>
          <target state="translated">Сбрасывает информацию об оптимизации колл-графа,удалении неиспользуемых функций,встраивании решений.</target>
        </trans-unit>
        <trans-unit id="3288dac3087a7accf2fa127698249b8034a173fa" translate="yes" xml:space="preserve">
          <source>Dumps list of details of functions and variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c057075d7f6d1311d665f05607d5a1143e726ae5" translate="yes" xml:space="preserve">
          <source>Duplicate instances of a template can be avoided by defining an explicit instantiation in one object file, and preventing the compiler from doing implicit instantiations in any other object files by using an explicit instantiation declaration, using the &lt;code&gt;extern template&lt;/code&gt; syntax:</source>
          <target state="translated">Дублирования экземпляров шаблона можно избежать, определив явное создание экземпляра в одном объектном файле и запретив компилятору выполнять неявное создание экземпляров в любых других объектных файлах с помощью явного объявления экземпляра с использованием синтаксиса &lt;code&gt;extern template&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="873001cb1e8e159e206fe4747ed8630083de92b7" translate="yes" xml:space="preserve">
          <source>During its analysis of function bodies, IPA-CP employs alias analysis in order to track values pointed to by function parameters. In order not spend too much time analyzing huge functions, it gives up and consider all memory clobbered after examining</source>
          <target state="translated">При анализе функциональных органов IPA-CP использует анализ псевдонимов для отслеживания значений,на которые указывают параметры функции.Для того чтобы не тратить слишком много времени на анализ огромных функций,он отдает и учитывает всю память,забитую после изучения</target>
        </trans-unit>
        <trans-unit id="35ad8603f50d24cddaa26acc281e43114f0f03d6" translate="yes" xml:space="preserve">
          <source>During the incremental link (by</source>
          <target state="translated">Во время инкрементальной связи (по</target>
        </trans-unit>
        <trans-unit id="6e5d8e172227784c44cef25322c1d84b5b1ed089" translate="yes" xml:space="preserve">
          <source>During the link-time optimization warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="translated">При линк-оптимизации предупреждают о несовпадениях типов в глобальных декларациях из различных модулей компиляции.Требуется .</target>
        </trans-unit>
        <trans-unit id="3941436ae2dc30b7d71f0708c7f73c50626caec3" translate="yes" xml:space="preserve">
          <source>During the link-time optimization, do not warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed8a7568d4927beb8ca9fcc2f434426a2ed3775" translate="yes" xml:space="preserve">
          <source>Dynamic rounding mode. A field in the floating-point control register (&lt;var&gt;fpcr&lt;/var&gt;, see Alpha architecture reference manual) controls the rounding mode in effect. The C library initializes this register for rounding towards plus infinity. Thus, unless your program modifies the &lt;var&gt;fpcr&lt;/var&gt;, &amp;lsquo;</source>
          <target state="translated">Режим динамического округления. Поле в регистре управления с плавающей запятой ( &lt;var&gt;fpcr&lt;/var&gt; , см. Справочное руководство по архитектуре Alpha) контролирует действующий режим округления. Библиотека C инициализирует этот регистр для округления в сторону плюс бесконечности. Таким образом, если ваша программа не изменяет &lt;var&gt;fpcr&lt;/var&gt; , '</target>
        </trans-unit>
        <trans-unit id="ee61e1d4359d2101e0207f1f6ab138bc105fa253" translate="yes" xml:space="preserve">
          <source>Dynamically allocate condition code registers.</source>
          <target state="translated">Динамически выделять кодовые регистры условий.</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="8424e737649ba7f5ce9529e01136274dd622c253" translate="yes" xml:space="preserve">
          <source>E+</source>
          <target state="translated">E+</target>
        </trans-unit>
        <trans-unit id="b86bd135c70e92d6b2051a988af8d8fd3b21cb67" translate="yes" xml:space="preserve">
          <source>E-</source>
          <target state="translated">E-</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="180b58cf69b13102962b17f297dd40af5fac3b7a" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdb&lt;/code&gt;</source>
          <target state="translated">Регистр EAM &lt;code&gt;mdb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4183eec55a2657bd56f5a3f286167e22c41277ca" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdc&lt;/code&gt;</source>
          <target state="translated">Регистр EAM &lt;code&gt;mdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042b890a506cb1f86b057af9f2065c60f0543326" translate="yes" xml:space="preserve">
          <source>ESC</source>
          <target state="translated">ESC</target>
        </trans-unit>
        <trans-unit id="db3a4c6dcbc964f457aa623cff604baca1fe6abf" translate="yes" xml:space="preserve">
          <source>ESC \</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef29ed353f79614b0af0aa06877e0e8365ad41a3" translate="yes" xml:space="preserve">
          <source>EV</source>
          <target state="translated">EV</target>
        </trans-unit>
        <trans-unit id="8404c13b819cbc829893e6fcf7e6b011dc8afafa" translate="yes" xml:space="preserve">
          <source>EXEC register (EXEC_LO and EXEC_HI)</source>
          <target state="translated">Регистр EXEC (EXEC_LO и EXEC_HI)</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="ec76a07122ba99b0a9685803ebd0fcbd4bc2bfc8" translate="yes" xml:space="preserve">
          <source>Each &amp;lsquo;</source>
          <target state="translated">Каждый '</target>
        </trans-unit>
        <trans-unit id="7a238e89c65aac1db813f790141cd6a1706499a7" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;branch&lt;/var&gt; has the following form:</source>
          <target state="translated">Каждая &lt;var&gt;branch&lt;/var&gt; имеет следующий вид:</target>
        </trans-unit>
        <trans-unit id="3994e33e5e0917632f9e9de329b4a0f3ad3998af" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;file&lt;/var&gt; has the following form:</source>
          <target state="translated">Каждый &lt;var&gt;file&lt;/var&gt; имеет следующий вид:</target>
        </trans-unit>
        <trans-unit id="c75857c9773e24edc3bfc44893ae2b0b910e079d" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;function&lt;/var&gt; has the following form:</source>
          <target state="translated">Каждая &lt;var&gt;function&lt;/var&gt; имеет следующий вид:</target>
        </trans-unit>
        <trans-unit id="62acae4631fd900e861a22b9b523800b0a789662" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;line&lt;/var&gt; has the following form:</source>
          <target state="translated">Каждая &lt;var&gt;line&lt;/var&gt; имеет следующий вид:</target>
        </trans-unit>
        <trans-unit id="1c50fb88397b0c7346926cd4cd765575f7023e36" translate="yes" xml:space="preserve">
          <source>Each architecture defines additional constraints. These constraints are used by the compiler itself for instruction generation, as well as for &lt;code&gt;asm&lt;/code&gt; statements; therefore, some of the constraints are not particularly useful for &lt;code&gt;asm&lt;/code&gt;. Here is a summary of some of the machine-dependent constraints available on some particular machines; it includes both constraints that are useful for &lt;code&gt;asm&lt;/code&gt; and constraints that aren&amp;rsquo;t. The compiler source file mentioned in the table heading for each architecture is the definitive reference for the meanings of that architecture&amp;rsquo;s constraints.</source>
          <target state="translated">Каждая архитектура определяет дополнительные ограничения. Эти ограничения используются самим компилятором для генерации инструкций, а также для операторов &lt;code&gt;asm&lt;/code&gt; ; поэтому некоторые из ограничений не особенно полезны для &lt;code&gt;asm&lt;/code&gt; . Вот краткое изложение некоторых машинно-зависимых ограничений, доступных на некоторых конкретных машинах; он включает как ограничения, которые полезны для &lt;code&gt;asm&lt;/code&gt; ,так и ограничения, которые нет. Исходный файл компилятора, упомянутый в заголовке таблицы для каждой архитектуры, является исчерпывающим справочным материалом для значений ограничений этой архитектуры.</target>
        </trans-unit>
        <trans-unit id="9a8f7e527e362e2f465669113fa77cfedd4d35d0" translate="yes" xml:space="preserve">
          <source>Each argument to the macro appears only once in the expansion of the macro. This prevents the size of the macro expansion growing exponentially when calls to such macros are nested inside arguments of such macros.</source>
          <target state="translated">Каждый аргумент к макросу появляется только один раз в расширении макроса.Это предотвращает экспоненциальный рост размера макрорасширения,когда вызовы таких макросов вложены в аргументы таких макросов.</target>
        </trans-unit>
        <trans-unit id="76b41f32117ccc7bbc36f4b00ab7cb610cec2b62" translate="yes" xml:space="preserve">
          <source>Each argument, with the type encoding, followed by the offset (in bytes) of the argument in the list of parameters.</source>
          <target state="translated">Каждый аргумент с кодировкой типа,за которым следует смещение (в байтах)аргумента в списке параметров.</target>
        </trans-unit>
        <trans-unit id="e6b2353f285a19086a3e061a5dcfed498d63a240" translate="yes" xml:space="preserve">
          <source>Each identifier is visible from where it is declared until the end of the enclosing block.</source>
          <target state="translated">Каждый идентификатор виден с того места,где он объявлен,до конца ограждающего блока.</target>
        </trans-unit>
        <trans-unit id="01e3221d2b21a8f447ed5a0ced29ddbea2cbee30" translate="yes" xml:space="preserve">
          <source>Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support (C++0x 1.4).</source>
          <target state="translated">Каждая реализация должна включать документацию,идентифицирующую все условно поддерживаемые конструкции,которые она не поддерживает (C++0x 1.4).</target>
        </trans-unit>
        <trans-unit id="701d795fb8ee42f93e3f4a253aa01935ee62e44d" translate="yes" xml:space="preserve">
          <source>Each kind of machine has a default for what &lt;code&gt;char&lt;/code&gt; should be. It is either like &lt;code&gt;unsigned char&lt;/code&gt; by default or like &lt;code&gt;signed char&lt;/code&gt; by default.</source>
          <target state="translated">Каждый тип машины имеет значение по умолчанию для &lt;code&gt;char&lt;/code&gt; . По умолчанию это либо &lt;code&gt;unsigned char&lt;/code&gt; , либо &lt;code&gt;signed char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef05478f4365f65d0ddfa7b0d492a5a495d01714" translate="yes" xml:space="preserve">
          <source>Each of the following options must be the same when building and using the precompiled header:</source>
          <target state="translated">Каждый из следующих вариантов должен быть одинаковым при построении и использовании предварительно скомпилированного заголовка:</target>
        </trans-unit>
        <trans-unit id="12375fa3bc94216fddfb3082e628f5277fd37349" translate="yes" xml:space="preserve">
          <source>Each of these represents a register constraint for an individual register, from r0 to r10.</source>
          <target state="translated">Каждый из них представляет собой ограничение по регистру для отдельного регистра,от r0 до r10.</target>
        </trans-unit>
        <trans-unit id="c7c856c52d5df36a325270b79c39dbe4777d924c" translate="yes" xml:space="preserve">
          <source>Each target machine supported by GCC can have its own options&amp;mdash;for example, to allow you to compile for a particular processor variant or ABI, or to control optimizations specific to that machine. By convention, the names of machine-specific options start with &amp;lsquo;</source>
          <target state="translated">Каждая целевая машина, поддерживаемая GCC, может иметь свои собственные параметры - например, чтобы позволить вам компилировать для конкретного варианта процессора или ABI, или для управления оптимизацией, специфичной для этой машины. По соглашению имена машинно-зависимых опций начинаются с '</target>
        </trans-unit>
        <trans-unit id="e1bf5c8e09d672f359406f3ca337be92c84db460" translate="yes" xml:space="preserve">
          <source>Each variable&amp;rsquo;s value is a list of directories separated by a special character, much like &lt;code&gt;PATH&lt;/code&gt;, in which to look for header files. The special character, &lt;code&gt;PATH_SEPARATOR&lt;/code&gt;, is target-dependent and determined at GCC build time. For Microsoft Windows-based targets it is a semicolon, and for almost all other targets it is a colon.</source>
          <target state="translated">Значение каждой переменной - это список каталогов, разделенных специальным символом, во многом как &lt;code&gt;PATH&lt;/code&gt; , в котором можно искать файлы заголовков. Специальный символ &lt;code&gt;PATH_SEPARATOR&lt;/code&gt; зависит от цели и определяется во время сборки GCC. Для целей на базе Microsoft Windows это точка с запятой, а почти для всех других целей - двоеточие.</target>
        </trans-unit>
        <trans-unit id="9fc7669bba8b360ced14bcd0e63ab75ab5c8df7f" translate="yes" xml:space="preserve">
          <source>Embedded statements are not allowed in constant expressions, such as the value of an enumeration constant, the width of a bit-field, or the initial value of a static variable.</source>
          <target state="translated">Встраиваемые выражения не допускаются в константных выражениях,таких как значение константы перечисления,ширина битового поля или начальное значение статической переменной.</target>
        </trans-unit>
        <trans-unit id="948e9b48ea593e051a4153362a7090d684f2c222" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) RISC-V attribute to record extra information into ELF objects. This feature requires at least binutils 2.32.</source>
          <target state="translated">Испускать (не испускать)атрибут RISC-V для записи дополнительной информации в ELF-объекты.Эта функция требует как минимум бинутилей 2.32.</target>
        </trans-unit>
        <trans-unit id="070ac08031f3d1c435e4576ba37695a82ca0786d" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) code that allows &lt;code&gt;_mcount&lt;/code&gt; to modify the calling function&amp;rsquo;s return address. When enabled, this option extends the usual &lt;code&gt;_mcount&lt;/code&gt; interface with a new &lt;var&gt;ra-address&lt;/var&gt; parameter, which has type &lt;code&gt;intptr_t *&lt;/code&gt; and is passed in register &lt;code&gt;$12&lt;/code&gt;. &lt;code&gt;_mcount&lt;/code&gt; can then modify the return address by doing both of the following:</source>
          <target state="translated">Выдавать (не &lt;code&gt;_mcount&lt;/code&gt; ) код, который позволяет _mcount изменять адрес возврата вызывающей функции. Если этот параметр включен, обычный интерфейс &lt;code&gt;_mcount&lt;/code&gt; расширяется новым параметром &lt;var&gt;ra-address&lt;/var&gt; , который имеет тип &lt;code&gt;intptr_t *&lt;/code&gt; и передается в регистре &lt;code&gt;$12&lt;/code&gt; . &lt;code&gt;_mcount&lt;/code&gt; может изменить адрес возврата, выполнив оба следующих действия:</target>
        </trans-unit>
        <trans-unit id="ff5e30537593e35e64b6a16b2c1bdbe42c087863" translate="yes" xml:space="preserve">
          <source>Emit .gnu_attribute assembly directives to set tag/value pairs in a .gnu.attributes section that specify ABI variations in function parameters or return values.</source>
          <target state="translated">Использовать директивы сборки .gnu_attribute для установки пар тег/значение в секции .gnu.attributes,которые указывают ABI вариации в параметрах функции или возвращаемые значения.</target>
        </trans-unit>
        <trans-unit id="20bf9a915993aa5a7a1666c72b879d8cd3f7ac3e" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;.stack_size&lt;/code&gt; directives for each function in the assembly output. This option defaults to off.</source>
          <target state="translated">Испустите &lt;code&gt;.stack_size&lt;/code&gt; директивы для каждой функции на выходе сборки. По умолчанию эта опция выключена.</target>
        </trans-unit>
        <trans-unit id="2f04fa21301da1a9e382b512bcad8e362a751619" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;static&lt;/code&gt; functions into the object file, even if the function is never used.</source>
          <target state="translated">Отправляйте &lt;code&gt;static&lt;/code&gt; функции в объектный файл, даже если функция никогда не используется.</target>
        </trans-unit>
        <trans-unit id="cb38e0a4e398a1b8eae664d56e6c229db862f612" translate="yes" xml:space="preserve">
          <source>Emit &lt;var&gt;num&lt;/var&gt; NOPs before every other generated instruction.</source>
          <target state="translated">Испустите &lt;var&gt;num&lt;/var&gt; NOPS перед любой другой генерируемой инструкцией.</target>
        </trans-unit>
        <trans-unit id="3da3562e4f5b4b2c349aec3c276d4ecf1abb3a7e" translate="yes" xml:space="preserve">
          <source>Emit DWARF unwind info as compiler generated &lt;code&gt;.eh_frame&lt;/code&gt; section instead of using GAS &lt;code&gt;.cfi_*&lt;/code&gt; directives.</source>
          <target state="translated">Выдавайте DWARF-информацию о &lt;code&gt;.eh_frame&lt;/code&gt; раздела .eh_frame, созданного компилятором, вместо использования директив GAS &lt;code&gt;.cfi_*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="661cfa361d4a5be25ea38381adeec0544f3162ba" translate="yes" xml:space="preserve">
          <source>Emit a special marker instructing &lt;code&gt;ld(1)&lt;/code&gt; not to statically link in the resulting object file, and allow &lt;code&gt;dyld(1)&lt;/code&gt; to load it in at run time instead. This is used in conjunction with the Fix-and-Continue debugging mode, where the object file in question may be recompiled and dynamically reloaded in the course of program execution, without the need to restart the program itself. Currently, Fix-and-Continue functionality is only available in conjunction with the NeXT runtime on Mac OS X 10.3 and later.</source>
          <target state="translated">Создайте специальный маркер, инструктирующий &lt;code&gt;ld(1)&lt;/code&gt; не связывать статически полученный объектный файл и разрешить &lt;code&gt;dyld(1)&lt;/code&gt; загружать его во время выполнения. Это используется в сочетании с режимом отладки Fix-and-Continue, в котором рассматриваемый объектный файл может быть перекомпилирован и динамически перезагружен в ходе выполнения программы без необходимости перезапуска самой программы. В настоящее время функция &amp;laquo;Исправить и продолжить&amp;raquo; доступна только в сочетании со средой выполнения NeXT в Mac OS X 10.3 и новее.</target>
        </trans-unit>
        <trans-unit id="7e8645e36e17a7945813986a8d0a71d3821820d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the current function exceeds the given frame size. Because this is a compile-time check it doesn&amp;rsquo;t need to be a real problem when the program runs. It is intended to identify functions that most probably cause a stack overflow. It is useful to be used in an environment with limited stack size e.g. the linux kernel.</source>
          <target state="translated">Выдавать предупреждение, если текущая функция превышает заданный размер кадра. Поскольку это проверка во время компиляции, она не должна быть реальной проблемой при запуске программы. Он предназначен для определения функций, которые, скорее всего, вызывают переполнение стека. Это полезно для использования в среде с ограниченным размером стека, например, в ядре Linux.</target>
        </trans-unit>
        <trans-unit id="e60a4bf4bc37e66d9947816b7195c8391e4776d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the function calls &lt;code&gt;alloca&lt;/code&gt; or uses dynamically-sized arrays. This is generally a bad idea with a limited stack size.</source>
          <target state="translated">Выдавать предупреждение, если функция вызывает &lt;code&gt;alloca&lt;/code&gt; или использует массивы динамического размера. Обычно это плохая идея с ограниченным размером стека.</target>
        </trans-unit>
        <trans-unit id="9b489883dd494ef67ae3146bb7729487672712a9" translate="yes" xml:space="preserve">
          <source>Emit callgraph information.</source>
          <target state="translated">Изображать информацию в виде календаря.</target>
        </trans-unit>
        <trans-unit id="f2b5ec1d50c73d9342d0da2e8de77ea3e8b06bfb" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the struct is defined.</source>
          <target state="translated">Отправлять отладочную информацию для структуроподобных типов только в том случае,если базовое имя исходного файла компиляции совпадает с базовым именем файла,в котором определена структура.</target>
        </trans-unit>
        <trans-unit id="ea8ad7a3ce89000c68597a212e3b7e178630bf37" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the type is defined, unless the struct is a template or defined in a system header.</source>
          <target state="translated">Отправлять отладочную информацию для структурно-подобных типов только в том случае,если базовое имя исходного файла компиляции совпадает с базовым именем файла,в котором определен тип,если только структура не является шаблоном или не определена в системном заголовке.</target>
        </trans-unit>
        <trans-unit id="bcf9409c139607d0741250959d86960d9d3fc823" translate="yes" xml:space="preserve">
          <source>Emit debugging information for all symbols and types.</source>
          <target state="translated">Использует отладочную информацию для всех символов и типов.</target>
        </trans-unit>
        <trans-unit id="8a7c3f8e8609e257b077878b6041fc34297f5e52" translate="yes" xml:space="preserve">
          <source>Emit debugging information for symbols that are used. For stabs debugging format, this enables</source>
          <target state="translated">Использовать отладочную информацию для используемых символов.Для отладочного формата ударных,это включает в себя</target>
        </trans-unit>
        <trans-unit id="c7be7022731d1d4e89f739d3f084947002265870" translate="yes" xml:space="preserve">
          <source>Emit diagnostics showing where nodes in the &amp;ldquo;exploded graph&amp;rdquo; are in relation to the program source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01323833aaf7728ad582d052fc8f41810ddeadf" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits.</source>
          <target state="translated">Выпустите дополнительный код для проверки переполнения буфера, например атак с разбиванием стека. Это делается путем добавления охранной переменной к функциям с уязвимыми объектами. Сюда входят функции, вызывающие &lt;code&gt;alloca&lt;/code&gt; , и функции с буферами размером более 8 байтов. Охранники инициализируются при входе в функцию и затем проверяются при выходе из функции. В случае сбоя проверки защиты выводится сообщение об ошибке и программа закрывается.</target>
        </trans-unit>
        <trans-unit id="0b4704d417754dd3e2fa8536b703ca97736ecd33" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than or equal to 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits. Only variables that are actually allocated on the stack are considered, optimized away variables or variables allocated in registers don&amp;rsquo;t count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141c4b8396ef386665e92dca002cbfbddd934501" translate="yes" xml:space="preserve">
          <source>Emit fix-it hints in a machine-parseable format, suitable for consumption by IDEs. For each fix-it, a line will be printed after the relevant diagnostic, starting with the string &amp;ldquo;fix-it:&amp;rdquo;. For example:</source>
          <target state="translated">Создавать подсказки для исправления ошибок в машиночитаемом формате, пригодном для использования в IDE. Для каждого fix-it после соответствующей диагностики будет напечатана строка, начинающаяся со строки &amp;laquo;fix-it:&amp;raquo;. Например:</target>
        </trans-unit>
        <trans-unit id="1a5a47bca88794809e7e2a3bb7e287c60614c83b" translate="yes" xml:space="preserve">
          <source>Emit function prologues only before parts of the function that need it, rather than at the top of the function. This flag is enabled by default at</source>
          <target state="translated">Функция излучения прологуливается только перед теми частями функции,которые в ней нуждаются,а не в верхней части функции.Этот флаг включен по умолчанию на</target>
        </trans-unit>
        <trans-unit id="7a29575e26772eb5ddc3404ae8049245b33348e5" translate="yes" xml:space="preserve">
          <source>Emit location column information into DWARF debugging information, rather than just file and line. This option is enabled by default.</source>
          <target state="translated">Высылайте информацию о местоположении столбца в отладочную информацию DWARF,а не только в файл и строку.Эта опция включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="669b4b85cda6e8d55a22a680d295c7c66356a584" translate="yes" xml:space="preserve">
          <source>Emit perf-like colored output for hot lines. Legend of the color scale is printed at the very beginning of the output file.</source>
          <target state="translated">Разрешите цветной вывод для горячих линий.Легенда цветовой шкалы печатается в самом начале выходного файла.</target>
        </trans-unit>
        <trans-unit id="bf88babe6e871b26c963f43a03a560a58bbbd726" translate="yes" xml:space="preserve">
          <source>Emit statistics about front-end processing at the end of the compilation. This option is supported only by the C++ front end, and the information is generally only useful to the G++ development team.</source>
          <target state="translated">Публикуйте статистику о фронтовой обработке в конце компиляции.Эта опция поддерживается только фронтендом C++,а информация,как правило,полезна только команде разработчиков G++.</target>
        </trans-unit>
        <trans-unit id="986149807dd103440d26581e0c8034fe654a931b" translate="yes" xml:space="preserve">
          <source>Emit variables declared &lt;code&gt;static const&lt;/code&gt; when optimization isn&amp;rsquo;t turned on, even if the variables aren&amp;rsquo;t referenced.</source>
          <target state="translated">Испускать переменные, объявленные &lt;code&gt;static const&lt;/code&gt; , когда оптимизация не включена, даже если на переменные нет ссылок.</target>
        </trans-unit>
        <trans-unit id="7039662b9ecdfee8f51909b1bca797f2d5646847" translate="yes" xml:space="preserve">
          <source>Empty. Empty attributes are ignored.</source>
          <target state="translated">Пусто.Пустые атрибуты игнорируются.</target>
        </trans-unit>
        <trans-unit id="dee5764f5fbac8ea9eadf819b59721dd60ce4b7b" translate="yes" xml:space="preserve">
          <source>En_US</source>
          <target state="translated">En_US</target>
        </trans-unit>
        <trans-unit id="20063ad9053289cecaa20ae630ed2dd758282a07" translate="yes" xml:space="preserve">
          <source>Enable</source>
          <target state="translated">Enable</target>
        </trans-unit>
        <trans-unit id="4fa0f6fb6e440f220b80c6c2d4888a44c80062d9" translate="yes" xml:space="preserve">
          <source>Enable &amp;lsquo;</source>
          <target state="translated">Включить '</target>
        </trans-unit>
        <trans-unit id="e92d7b5eafccf1d9c2c8bae0da3467a97bfe43eb" translate="yes" xml:space="preserve">
          <source>Enable (disable) an optimization that pairs consecutive load or store instructions to enable load/store bonding. This option is enabled by default but only takes effect when the selected architecture is known to support bonding.</source>
          <target state="translated">Включите (отключите)оптимизацию,при которой пары последовательных инструкций по загрузке или хранению включаются в загрузку/складку.Эта опция включена по умолчанию,но вступает в силу только в том случае,если известно,что выбранная архитектура поддерживает связывание.</target>
        </trans-unit>
        <trans-unit id="a5876c1f4b70b8a6258f54ff9e4b48ce21c8e2cc" translate="yes" xml:space="preserve">
          <source>Enable (disable) frame header optimization in the o32 ABI. When using the o32 ABI, calling functions will allocate 16 bytes on the stack for the called function to write out register arguments. When enabled, this optimization will suppress the allocation of the frame header if it can be determined that it is unused.</source>
          <target state="translated">Включить (выключить)оптимизацию заголовков кадров в o32 ABI.При использовании o32 ABI,вызывающие функции будут выделять 16 байт на стеке,чтобы вызываемая функция записала аргументы регистра.При включении данная оптимизация будет подавлять выделение заголовка кадра,если будет установлено,что он не используется.</target>
        </trans-unit>
        <trans-unit id="69fa958a8a2e61f2783ede1c3821c1af600c12f1" translate="yes" xml:space="preserve">
          <source>Enable (disable) generation of &lt;code&gt;synci&lt;/code&gt; instructions on architectures that support it. The &lt;code&gt;synci&lt;/code&gt; instructions (if enabled) are generated when &lt;code&gt;__builtin___clear_cache&lt;/code&gt; is compiled.</source>
          <target state="translated">Включите (отключите) создание инструкций &lt;code&gt;synci&lt;/code&gt; на архитектурах, которые его поддерживают. В &lt;code&gt;synci&lt;/code&gt; инструкции (если он включен) генерируются при &lt;code&gt;__builtin___clear_cache&lt;/code&gt; компиляции.</target>
        </trans-unit>
        <trans-unit id="affa7a90abe6524cdcc085355a0cf87de25de669" translate="yes" xml:space="preserve">
          <source>Enable (disable) the use of the built-in functions that allow direct access to the Hardware Transactional Memory (HTM) instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">Включите (отключите)использование встроенных функций,обеспечивающих прямой доступ к инструкциям по аппаратной транзакционной памяти (HTM),которые были добавлены в версию 2.07 PowerPC ISA.</target>
        </trans-unit>
        <trans-unit id="a9d43112761b398944fa6b8aebeadd62b27a6873" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;%hi()&lt;/code&gt; and &lt;code&gt;%lo()&lt;/code&gt; assembler relocation operators. This option has been superseded by</source>
          <target state="translated">Включите (отключите) использование операторов перемещения ассемблера &lt;code&gt;%hi()&lt;/code&gt; и &lt;code&gt;%lo()&lt;/code&gt; . Этот вариант был заменен</target>
        </trans-unit>
        <trans-unit id="22e717c26fa88a4531e1982fba5a0708a2d39b81" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;mad&lt;/code&gt;, &lt;code&gt;madu&lt;/code&gt; and &lt;code&gt;mul&lt;/code&gt; instructions, as provided by the R4650 ISA.</source>
          <target state="translated">Включите (отключите) использование инструкций &lt;code&gt;mad&lt;/code&gt; , &lt;code&gt;madu&lt;/code&gt; и &lt;code&gt;mul&lt;/code&gt; , как это предусмотрено ISA R4650.</target>
        </trans-unit>
        <trans-unit id="d7e0884ba3d3cc932c864d47a1ad9e75ce9d3f27" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;madd&lt;/code&gt; and &lt;code&gt;msub&lt;/code&gt; integer instructions. The default is</source>
          <target state="translated">Включение (отключение) использования целочисленных инструкций &lt;code&gt;madd&lt;/code&gt; и &lt;code&gt;msub&lt;/code&gt; . По умолчанию</target>
        </trans-unit>
        <trans-unit id="fb69f64525577d36a129060c4be04db4c7157197" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the floating-point multiply-accumulate instructions, when they are available. The default is</source>
          <target state="translated">Включите (отключите)использование инструкций по накоплению с плавающей запятой,когда они доступны.По умолчанию</target>
        </trans-unit>
        <trans-unit id="b555e3f0b555bfa87127103aa19a5b771c06eb1e" translate="yes" xml:space="preserve">
          <source>Enable 32-bit Floating point Matrix Multiply instructions. This also enables SVE instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72dea94649019bb860dd9ef3c4021f60f45fa32" translate="yes" xml:space="preserve">
          <source>Enable 64-bit AIX ABI and calling convention: 64-bit pointers, 64-bit &lt;code&gt;long&lt;/code&gt; type, and the infrastructure needed to support them. Specifying</source>
          <target state="translated">Включите 64-битный ABI AIX и соглашение о вызовах: 64-битные указатели, 64-битный &lt;code&gt;long&lt;/code&gt; тип и инфраструктуру, необходимую для их поддержки. Определение</target>
        </trans-unit>
        <trans-unit id="7b3c726da78dba7ee2a5726b767895d7cdc32731" translate="yes" xml:space="preserve">
          <source>Enable 64-bit Floating point Matrix Multiply instructions. This also enables SVE instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ded79f10cf70cf5831bdeffd10c676f4e368113" translate="yes" xml:space="preserve">
          <source>Enable 8-bit Integer Matrix Multiply instructions. This also enables Advanced SIMD and floating-point instructions. This option is enabled by default for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bed769cd5303c03eac96915f98c0018f45868e" translate="yes" xml:space="preserve">
          <source>Enable &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; instructions for ARCv2 cores.</source>
          <target state="translated">Включите инструкции &lt;code&gt;div&lt;/code&gt; и &lt;code&gt;rem&lt;/code&gt; для ядер ARCv2.</target>
        </trans-unit>
        <trans-unit id="2b739befdde9d37b726baa741659e214041a11f0" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer for Linux kernel. See &lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt; for more details.</source>
          <target state="translated">Включите AddressSanitizer для ядра Linux. См. &lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;Https://github.com/google/kasan/wiki&lt;/a&gt; для получения дополнительных сведений.</target>
        </trans-unit>
        <trans-unit id="dd5750bb548742f5f6797880a8c614d311fe2963" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer, a fast memory error detector. Memory access instructions are instrumented to detect out-of-bounds and use-after-free bugs. The option enables</source>
          <target state="translated">Включите AddressSanitizer,быстрый детектор ошибок памяти.Инструкции по доступу к памяти предназначены для обнаружения ошибок,не связанных с памятью,а также ошибок,не требующих дальнейшего использования.Опция позволяет</target>
        </trans-unit>
        <trans-unit id="b884f9df2c0fdf875f501de19eb4a43163aded4e" translate="yes" xml:space="preserve">
          <source>Enable Advanced SIMD instructions. This also enables floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">Включите расширенные инструкции по SIMD.Это также позволяет использовать инструкции с плавающей запятой.По умолчанию она включена для всех возможных значений для опций</target>
        </trans-unit>
        <trans-unit id="1737ee87e4af9d47c80e040e08ffbf40c4cf4499" translate="yes" xml:space="preserve">
          <source>Enable C-SKY DSP, Enhanced DSP, or Vector DSP instructions, respectively. All of these options default to off.</source>
          <target state="translated">Включите инструкции C-SKY DSP,Enhanced DSP или Vector DSP соответственно.Все эти опции по умолчанию выключены.</target>
        </trans-unit>
        <trans-unit id="460dd2625e669a6da5fd8971a359142b70341354" translate="yes" xml:space="preserve">
          <source>Enable C-SKY security instructions; the default is off.</source>
          <target state="translated">Включите инструкции по безопасности C-SKY;по умолчанию выключен.</target>
        </trans-unit>
        <trans-unit id="be1993c993457eac4e123ff5ca8683dff8eb6707" translate="yes" xml:space="preserve">
          <source>Enable C-SKY trust instructions; the default is off.</source>
          <target state="translated">Включите инструкции по доверительному управлению C-SKY;по умолчанию выключен.</target>
        </trans-unit>
        <trans-unit id="db19cd91956a3cc7c7ec589751c003754ab24a04" translate="yes" xml:space="preserve">
          <source>Enable CFG-sensitive rematerialization in LRA. Instead of loading values of spilled pseudos, LRA tries to rematerialize (recalculate) values if it is profitable.</source>
          <target state="translated">Включить чувствительную к ОФГ рематериализацию в ЛРА.Вместо загрузки значений пролитых псевдонимов,LRA пытается рематериализовать (пересчитать)значения,если это выгодно.</target>
        </trans-unit>
        <trans-unit id="3228c63b76a89731a999face742dbc8e98e43fb7" translate="yes" xml:space="preserve">
          <source>Enable CRC extension. This is on by default for</source>
          <target state="translated">Включить расширение CRC.По умолчанию оно включено для</target>
        </trans-unit>
        <trans-unit id="6f57bb69abaacf2d80f6a8ad9ba44e14d8d03b75" translate="yes" xml:space="preserve">
          <source>Enable CRIS-specific verbose debug-related information in the assembly code. This option also has the effect of turning off the &amp;lsquo;</source>
          <target state="translated">Включите специфичную для CRIS подробную информацию, связанную с отладкой, в коде сборки. Эта опция также отключает '</target>
        </trans-unit>
        <trans-unit id="a77b829448e4eeb6288384fb17669c5c039a4b5e" translate="yes" xml:space="preserve">
          <source>Enable Crypto extension. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Включить расширение Крипто.Это также позволяет использовать расширенные SIMD и инструкции с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="c34f6f6c7e11aa9f0332985736de3e72e193f5ba" translate="yes" xml:space="preserve">
          <source>Enable FP16 extension. This also enables floating-point instructions.</source>
          <target state="translated">Включите расширение FP16.Это также позволяет использовать инструкции с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="2babb7d5abaf4060eeca52d7ae4316df315816d6" translate="yes" xml:space="preserve">
          <source>Enable FP16 fmla extension. This also enables FP16 extensions and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">Включить расширение FP16 fmla.Это также позволяет использовать расширения FP16 и инструкции с плавающей запятой.Эта опция включена по умолчанию для</target>
        </trans-unit>
        <trans-unit id="3a8ba9a41b704d15493ebc76a0b1f017540a81f2" translate="yes" xml:space="preserve">
          <source>Enable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">Включить IPA прохода &lt;var&gt;pass&lt;/var&gt; . &lt;var&gt;pass&lt;/var&gt; - это имя прохода. Если один и тот же проход статически вызывается в компиляторе несколько раз, к имени прохода следует добавить порядковый номер, начинающийся с 1.</target>
        </trans-unit>
        <trans-unit id="17d5ca6696a8cdc79b6dc05a7cd14c4945472844" translate="yes" xml:space="preserve">
          <source>Enable Large System Extension instructions. This is on by default for</source>
          <target state="translated">Включите инструкции по расширению системы.По умолчанию это включено для</target>
        </trans-unit>
        <trans-unit id="5313db34f510b6a28a51ef561341a7742309082f" translate="yes" xml:space="preserve">
          <source>Enable LeakSanitizer, a memory leak detector. This option only matters for linking of executables and the executable is linked against a library that overrides &lt;code&gt;malloc&lt;/code&gt; and other allocator functions. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; environment variable. The option cannot be combined with</source>
          <target state="translated">Включите LeakSanitizer, детектор утечек памяти. Этот параметр имеет значение только для связывания исполняемых файлов, а исполняемый файл связан с библиотекой, которая переопределяет &lt;code&gt;malloc&lt;/code&gt; и другие функции распределителя. См. &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;Https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt; для получения дополнительных сведений. На поведение во время выполнения можно влиять с помощью переменной среды &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; . Опцию нельзя комбинировать с</target>
        </trans-unit>
        <trans-unit id="963f7996b716be1c17df5a79ae31f2f9bb23a517" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for ARC, so by default the compiler uses standard reload (i.e.</source>
          <target state="translated">Включить локальное распределение регистраций.Для ARC это все еще экспериментально,поэтому по умолчанию компилятор использует стандартную перезагрузку (т.е.</target>
        </trans-unit>
        <trans-unit id="3bd13a89a3ec768d816679409bb63a5907cc342b" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for FT32, so by default the compiler uses standard reload.</source>
          <target state="translated">Включить локальное распределение регистраций.Для FT32 это все еще экспериментально,поэтому по умолчанию компилятор использует стандартную перезагрузку.</target>
        </trans-unit>
        <trans-unit id="7fa9e4dd118db6c43acdd9765995f0465281818a" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is the default for SPARC since GCC 7 so</source>
          <target state="translated">Включить локальное распределение регистраций.По умолчанию это для SPARC,начиная с GCC 7,поэтому</target>
        </trans-unit>
        <trans-unit id="89bbfd96b1406df4e9daca603ac86b980c364e5c" translate="yes" xml:space="preserve">
          <source>Enable RTL pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">Включить RTL пасс &lt;var&gt;pass&lt;/var&gt; . Видеть</target>
        </trans-unit>
        <trans-unit id="f44412802c3209f5d9e4e5d01f1b31cdf41ef7c0" translate="yes" xml:space="preserve">
          <source>Enable Round Double Multiply Accumulate instructions. This is on by default for</source>
          <target state="translated">Включите инструкцию &quot;Круглый двойной умножить нарастающий итог&quot;.По умолчанию это включено для</target>
        </trans-unit>
        <trans-unit id="d370af9affe58a56b9b5454d4d92570e141e8b8f" translate="yes" xml:space="preserve">
          <source>Enable SVE2 aes instructions. This also enables SVE2 instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f75e37c4e4e45b9963ff233f2e2820dcfb4fb8" translate="yes" xml:space="preserve">
          <source>Enable SVE2 bitperm instructions. This also enables SVE2 instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbf22cee4e50726f4cae0a5e266998649407231" translate="yes" xml:space="preserve">
          <source>Enable SVE2 sha3 instructions. This also enables SVE2 instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7cde27311588c6804e4c9ac9068d7a4af84b22" translate="yes" xml:space="preserve">
          <source>Enable SVE2 sm4 instructions. This also enables SVE2 instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1332af3411aa268a3ef4a1b41bc0ae5d1edc2594" translate="yes" xml:space="preserve">
          <source>Enable Scalable Vector Extension instructions. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Включите инструкции по масштабируемому векторному расширению.Это также позволяет использовать расширенные SIMD-карты и инструкции с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="082f6e4a45595d5f7a3a2a560115400fb4ee2b89" translate="yes" xml:space="preserve">
          <source>Enable ThreadSanitizer, a fast data race detector. Memory access instructions are instrumented to detect data race bugs. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; environment variable; see &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt; for a list of supported options. The option cannot be combined with</source>
          <target state="translated">Включите ThreadSanitizer, быстрый детектор гонки данных. Инструкции по доступу к памяти предназначены для обнаружения ошибок гонки данных. См. &lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;Https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt; для получения дополнительных сведений. На поведение во время выполнения можно влиять с помощью переменной среды &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; ; см. &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt; для получения списка поддерживаемых параметров. Опцию нельзя комбинировать с</target>
        </trans-unit>
        <trans-unit id="949a1a6c2112a203d7294b63f617d43e64b4229c" translate="yes" xml:space="preserve">
          <source>Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector. Various computations are instrumented to detect undefined behavior at runtime. Current suboptions are:</source>
          <target state="translated">Включите UndefinedBehaviorSanitizer,быстрый детектор неопределенного поведения.Для обнаружения неопределённого поведения во время работы детектора используются различные вычисления.Текущие подопции:</target>
        </trans-unit>
        <trans-unit id="96f5c056cf8c5a806da05ed8b96789bc0b6d048b" translate="yes" xml:space="preserve">
          <source>Enable all estimate instructions.</source>
          <target state="translated">Включите все инструкции по оценке.</target>
        </trans-unit>
        <trans-unit id="df3c7c5cb30d8d0e87829e7d5c48c82259c25cb7" translate="yes" xml:space="preserve">
          <source>Enable all language-specific dumps.</source>
          <target state="translated">Включить все языковые отбросы.</target>
        </trans-unit>
        <trans-unit id="ae518ed7bc949ae822d65bcaeff9c7041fb826a6" translate="yes" xml:space="preserve">
          <source>Enable allocation of values to registers that are clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code.</source>
          <target state="translated">Разрешить выделение значений регистров,которые забиты вызовами функций,путем выдачи дополнительных инструкций по сохранению и восстановлению регистров вокруг таких вызовов.Такое распределение производится только тогда,когда кажется,что это приводит к лучшему коду.</target>
        </trans-unit>
        <trans-unit id="0a0fd86a97f36ba3d21ddbe6e9254e7a16fbfe18" translate="yes" xml:space="preserve">
          <source>Enable and control dumping of pass statistics in a separate file. The file name is generated by appending a suffix ending in &amp;lsquo;</source>
          <target state="translated">Включение и управление выгрузкой статистики проходов в отдельный файл. Имя файла создается добавлением суффикса, заканчивающегося на '</target>
        </trans-unit>
        <trans-unit id="f6804494e75f7aaede40247da0a4be9cdb7a84eb" translate="yes" xml:space="preserve">
          <source>Enable asan allocas/VLAs protection.</source>
          <target state="translated">Включить защиту аллокаторов асан/VLAs.</target>
        </trans-unit>
        <trans-unit id="61fd83dce0b4c24f54b3d95d0aba14e424d6bcbf" translate="yes" xml:space="preserve">
          <source>Enable automatic template instantiation at link time. This option also implies</source>
          <target state="translated">Включить автоматическое инстанцирование шаблона во время ссылки.Эта опция также подразумевает</target>
        </trans-unit>
        <trans-unit id="803437b7c125524ce44c25382c66dec8a107376e" translate="yes" xml:space="preserve">
          <source>Enable barrel-shift instructions.</source>
          <target state="translated">Включить инструкции по смене ствола.</target>
        </trans-unit>
        <trans-unit id="dd1a569881fabce4df110c82ea43f4ea0973b717" translate="yes" xml:space="preserve">
          <source>Enable bbit peephole2.</source>
          <target state="translated">Включить глазок2.</target>
        </trans-unit>
        <trans-unit id="180b32141a3f8a46f27f030b1d9db7ce44e7c46b" translate="yes" xml:space="preserve">
          <source>Enable brain half-precision floating-point instructions. This also enables Advanced SIMD and floating-point instructions. This option is enabled by default for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e317e7bf07e0ef1d8933e0c682ab5ffc4c86dfe" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for global objects. This kind of protection is enabled by default if you are using</source>
          <target state="translated">Включить обнаружение переполнения буфера для глобальных объектов.Этот вид защиты включен по умолчанию,если вы используете</target>
        </trans-unit>
        <trans-unit id="0ff2936ea712569b3e61003e75e4a3a94ca881aa" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory reads. This kind of protection is enabled by default when using</source>
          <target state="translated">Включить обнаружение переполнения буфера при чтении памяти.Этот вид защиты включен по умолчанию при использовании</target>
        </trans-unit>
        <trans-unit id="c11c559ccc97fad4b1acec42a5bfc66eb0c4fd61" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory writes. This kind of protection is enabled by default when using</source>
          <target state="translated">Включить обнаружение переполнения буфера при записи в память.Данный вид защиты включен по умолчанию при использовании</target>
        </trans-unit>
        <trans-unit id="c2ab49f5ce7f3d41ded69401c310972e445af621" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for stack objects. This kind of protection is enabled by default when using</source>
          <target state="translated">Включить обнаружение переполнения буфера для объектов стека.Этот вид защиты включен по умолчанию при использовании</target>
        </trans-unit>
        <trans-unit id="bcd2fc731b6ca5ce8904f8dd2548970ab5fbc93a" translate="yes" xml:space="preserve">
          <source>Enable cache bypass for volatile references.</source>
          <target state="translated">Включить обход кэша для нестабильных ссылок.</target>
        </trans-unit>
        <trans-unit id="dc4973bdf3e5300316096cd00a6ec0877e4070c6" translate="yes" xml:space="preserve">
          <source>Enable code density instructions for ARC EM. This option is on by default for ARC HS.</source>
          <target state="translated">Включите инструкции по плотности кода для ARC EM.Эта опция включена по умолчанию для ARC HS.</target>
        </trans-unit>
        <trans-unit id="6f26f87d795cdafd882a37f7cf6106b44c65db50" translate="yes" xml:space="preserve">
          <source>Enable code instrumentation of control-flow transfers to increase program security by checking that target addresses of control-flow transfer instructions (such as indirect function call, function return, indirect jump) are valid. This prevents diverting the flow of control to an unexpected target. This is intended to protect against such threats as Return-oriented Programming (ROP), and similarly call/jmp-oriented programming (COP/JOP).</source>
          <target state="translated">Включите кодовое приборостроение передачи управляющих потоков для повышения безопасности программы,проверив,что целевые адреса команд передачи управляющих потоков (такие как непрямой вызов функции,возврат функции,непрямой прыжок)действительны.Это предотвращает перенаправление потока управления на неожиданную цель.Это предназначено для защиты от таких угроз,как программирование,ориентированное на возврат (ROP),и аналогичное программирование,ориентированное на вызов/прыжок (COP/JOP).</target>
        </trans-unit>
        <trans-unit id="b04ea9a65f69d1ed270cd68689d1e12352618b80" translate="yes" xml:space="preserve">
          <source>Enable compact &lt;code&gt;casesi&lt;/code&gt; pattern. This is the default for</source>
          <target state="translated">Включить компактный шаблон &lt;code&gt;casesi&lt;/code&gt; . Это значение по умолчанию для</target>
        </trans-unit>
        <trans-unit id="0c57839724a2712f31a1af12f90ff1f615581733" translate="yes" xml:space="preserve">
          <source>Enable constructor/destructor feature.</source>
          <target state="translated">Включение функции конструктора/деструктора.</target>
        </trans-unit>
        <trans-unit id="975ccca01950f97ce533ac489aa7f20116354de0" translate="yes" xml:space="preserve">
          <source>Enable coprocessor instructions; the default is off.</source>
          <target state="translated">Включите инструкции сопроцессора;по умолчанию выключено.</target>
        </trans-unit>
        <trans-unit id="133e4f830a510ad1f945a9a4b1965c6cdd0bf2e0" translate="yes" xml:space="preserve">
          <source>Enable coverage-guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; into every basic block.</source>
          <target state="translated">Включение инструментария кода фаззинга на основе покрытия. Вставляет вызов &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; в каждый базовый блок.</target>
        </trans-unit>
        <trans-unit id="787d37d09881b29ce95c34e07e7021e04de78815" translate="yes" xml:space="preserve">
          <source>Enable dataflow guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; for integral comparison with both operands variable or &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; for integral comparison with one operand constant, &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; for float or double comparisons and &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; for switch statements.</source>
          <target state="translated">Включите инструментарий кода фаззинга, управляемый потоком данных. Вставки призыва к &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; или &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; для интегрального сравнения как с переменными операндами или &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; или &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; для интегрального сравнения с одним операндом константой, &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; или &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; для поплавка или двойных сравнений и &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; для операторов переключения.</target>
        </trans-unit>
        <trans-unit id="1af777f40a3150cb8ba378da9ca8aedaaf114176" translate="yes" xml:space="preserve">
          <source>Enable deduction of a template type parameter as &lt;code&gt;std::initializer_list&lt;/code&gt; from a brace-enclosed initializer list, i.e.</source>
          <target state="translated">Включите вывод параметра типа шаблона как &lt;code&gt;std::initializer_list&lt;/code&gt; из списка инициализаторов, заключенного в фигурные скобки, т.е.</target>
        </trans-unit>
        <trans-unit id="699beaa366dd56ec35a2702d45f2103e1f67c4dc" translate="yes" xml:space="preserve">
          <source>Enable detection for built-in functions. This kind of protection is enabled by default when using</source>
          <target state="translated">Включение обнаружения для встроенных функций.Этот вид защиты включен по умолчанию при использовании</target>
        </trans-unit>
        <trans-unit id="d53fecd502038ea015d9795c95247289bc1d17ab" translate="yes" xml:space="preserve">
          <source>Enable detection of use-after-return. This kind of protection is enabled by default when using the</source>
          <target state="translated">Позволяет обнаружить использование после возвращения.Этот вид защиты включен по умолчанию при использовании параметра</target>
        </trans-unit>
        <trans-unit id="22325b2d023fcd4619a9818a760c689af219e959" translate="yes" xml:space="preserve">
          <source>Enable divide and modulus instructions.</source>
          <target state="translated">Включите инструкции по разделению и модулю.</target>
        </trans-unit>
        <trans-unit id="6860f8ad3c912d9de1bc957db83ae37ff4acd2f1" translate="yes" xml:space="preserve">
          <source>Enable double load/store operations for ARC HS cores.</source>
          <target state="translated">Включить двойную загрузку/хранение для сердечников ARC HS.</target>
        </trans-unit>
        <trans-unit id="f30747b51f35d511a8324038d0ec742af8852f12" translate="yes" xml:space="preserve">
          <source>Enable dumping various statistics about the pass (not honored by every dump option).</source>
          <target state="translated">Включить дампинг различной статистики о проходе (не учитывается каждый дамп).</target>
        </trans-unit>
        <trans-unit id="e61159e5abc9e858d3e7dc68248bef77e7e66569" translate="yes" xml:space="preserve">
          <source>Enable dumps from all OMP (Offloading and Multi Processing) optimizations.</source>
          <target state="translated">Включение дампов из всех оптимизаций OMP (разгрузка и многократная обработка).</target>
        </trans-unit>
        <trans-unit id="126e933efdf810fc684f2a27ed78c7f4a97f9db5" translate="yes" xml:space="preserve">
          <source>Enable dumps from all inlining optimizations.</source>
          <target state="translated">Включить дампы из всех встраиваемых оптимизаций.</target>
        </trans-unit>
        <trans-unit id="d0c94685fdabc0e86d42873897a8642d64c915a0" translate="yes" xml:space="preserve">
          <source>Enable dumps from all interprocedural optimizations.</source>
          <target state="translated">Включить дампы от всех межпроцедурных оптимизаций.</target>
        </trans-unit>
        <trans-unit id="f4a495e6ab007e96555960123af4b2e049e343cb" translate="yes" xml:space="preserve">
          <source>Enable dumps from all loop optimizations.</source>
          <target state="translated">Включить дампы из всех оптимизаций цикла.</target>
        </trans-unit>
        <trans-unit id="da404a0e7964dc17445f8eab1557032d44193e2a" translate="yes" xml:space="preserve">
          <source>Enable dumps from all optimizations. This is a superset of the optimization groups listed above.</source>
          <target state="translated">Включить дампы из всех оптимизаций.Это суперсет из вышеперечисленных групп оптимизации.</target>
        </trans-unit>
        <trans-unit id="82fd093708bd37548045d3e8dc300297a204bb93" translate="yes" xml:space="preserve">
          <source>Enable dumps from all vectorization optimizations.</source>
          <target state="translated">Включить дампы всех оптимизаций векторизации.</target>
        </trans-unit>
        <trans-unit id="1ca26bbd13d508b47dfc0ff9aedfd700309873f0" translate="yes" xml:space="preserve">
          <source>Enable emission of special debug stores within HSA kernels which are then read and reported by libgomp plugin. Generation of these stores is disabled by default, use</source>
          <target state="translated">Включить выделение специальных хранилищ отладки внутри HSA ядер,которые затем считываются и сообщаются плагином libgomp.Генерация этих хранилищ отключена по умолчанию,использование</target>
        </trans-unit>
        <trans-unit id="92b0248c8870fe4857fc02d723bd02f0d5d911ee" translate="yes" xml:space="preserve">
          <source>Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC generates frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC enables it by default for languages like C++ that normally require exception handling, and disables it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++. You may also wish to disable this option if you are compiling older C++ programs that don&amp;rsquo;t use exception handling.</source>
          <target state="translated">Включить обработку исключений. Создает дополнительный код, необходимый для распространения исключений. Для некоторых целей это означает, что GCC генерирует информацию раскрутки кадра для всех функций, что может привести к значительным накладным расходам на размер данных, хотя это не влияет на выполнение. Если вы не укажете эту опцию, GCC включает ее по умолчанию для таких языков, как C ++, которые обычно требуют обработки исключений, и отключает ее для таких языков, как C, для которых она обычно не требуется. Однако вам может потребоваться включить эту опцию при компиляции кода C, который должен правильно взаимодействовать с обработчиками исключений, написанными на C ++. Вы также можете отключить эту опцию, если вы компилируете старые программы на C ++, которые не используют обработку исключений.</target>
        </trans-unit>
        <trans-unit id="291b92d09ee9fff716f8b0be8063487213868bdd" translate="yes" xml:space="preserve">
          <source>Enable floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">Включите инструкции с плавающей запятой.По умолчанию она включена для всех возможных значений для опций</target>
        </trans-unit>
        <trans-unit id="39904b8795d477fdb077dab2b449e06a2b1bd74a" translate="yes" xml:space="preserve">
          <source>Enable garbage collection (GC) in Objective-C and Objective-C++ programs. This option is only available with the NeXT runtime; the GNU runtime has a different garbage collection implementation that does not require special compiler flags.</source>
          <target state="translated">Включить сбор мусора (GC)в программах Objective-C и Objective-C++.Эта опция доступна только во время выполнения NeXT;во время выполнения GNU есть другая реализация сборки мусора,которая не требует специальных флагов компилятора.</target>
        </trans-unit>
        <trans-unit id="eb9fbffb72277aaa3548891dbb1b3b1153391a9e" translate="yes" xml:space="preserve">
          <source>Enable generation of ARC SIMD instructions via target-specific builtins. Only valid for</source>
          <target state="translated">Возможность генерации SIMD-инструкций ARC с помощью специальных встроенных модулей.Действительно только для</target>
        </trans-unit>
        <trans-unit id="3476de902c479834e38b15661f3b7c3cc2032cce" translate="yes" xml:space="preserve">
          <source>Enable generation of compare and set flag with immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions. By default extra instructions will be generated to store the immediate to a register first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50921b35a0d76feb95a28aea9efb5fcae7e1038" translate="yes" xml:space="preserve">
          <source>Enable generation of conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instructions. By default the equivalent will be generated using set and branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64de54a950fd518ed74414f068843cdf15d9e810" translate="yes" xml:space="preserve">
          <source>Enable generation of linemarkers in the preprocessor output that let the compiler know the current working directory at the time of preprocessing. When this option is enabled, the preprocessor emits, after the initial linemarker, a second linemarker with the current working directory followed by two slashes. GCC uses this directory, when it&amp;rsquo;s present in the preprocessed input, as the directory emitted as the current working directory in some debugging information formats. This option is implicitly enabled if debugging information is enabled, but this can be inhibited with the negated form</source>
          <target state="translated">Включите создание маркеров линий в выводе препроцессора, которые позволяют компилятору знать текущий рабочий каталог во время предварительной обработки. Когда эта опция включена, препроцессор выдает после начального линейного маркера второй линейный маркер с текущим рабочим каталогом, за которым следуют две косые черты. GCC использует этот каталог, когда он присутствует в предварительно обработанных входных данных, как каталог, созданный как текущий рабочий каталог в некоторых форматах отладочной информации. Эта опция неявно включена, если включена отладочная информация, но это можно запретить с помощью отрицательной формы</target>
        </trans-unit>
        <trans-unit id="588970c3346f8b21ca330055ce039842b7c95dc3" translate="yes" xml:space="preserve">
          <source>Enable generation of rotate right (&lt;code&gt;l.ror&lt;/code&gt;) instructions. By default functions from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4410c960b2144b2a5392d7e9052119e5a2916ace" translate="yes" xml:space="preserve">
          <source>Enable generation of rotate right with immediate (&lt;code&gt;l.rori&lt;/code&gt;) instructions. By default functions from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2f560a395cf8229af315865d428228064bb2c4" translate="yes" xml:space="preserve">
          <source>Enable generation of shift with immediate (&lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;) instructions. By default extra instructions will be generated to store the immediate to a register first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64d914c46ba456fccc83d7a0d7c17c411a4e40e" translate="yes" xml:space="preserve">
          <source>Enable generation of sign extension (&lt;code&gt;l.ext*&lt;/code&gt;) instructions. By default memory loads are used to perform sign extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6c2330300990f23059abacc5ecdfe5f1dc0281" translate="yes" xml:space="preserve">
          <source>Enable generation of unaligned load and store instructions.</source>
          <target state="translated">Позволяет генерировать выровненную нагрузку и инструкции по хранению.</target>
        </trans-unit>
        <trans-unit id="d26f3d711c1a65ce5ae7ed795204b286f03213ae" translate="yes" xml:space="preserve">
          <source>Enable global interrupt.</source>
          <target state="translated">Включить глобальное прерывание.</target>
        </trans-unit>
        <trans-unit id="2f452efb25c68aa75fbb01603256e25885a6060f" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenACC directives &lt;code&gt;#pragma acc&lt;/code&gt; in C/C++ and &lt;code&gt;!$acc&lt;/code&gt; in Fortran. When</source>
          <target state="translated">Включите обработку директив OpenACC &lt;code&gt;#pragma acc&lt;/code&gt; в C / C ++ и &lt;code&gt;!$acc&lt;/code&gt; в Фортране. когда</target>
        </trans-unit>
        <trans-unit id="2ca92300312c8fc1987b891433bf16fbf5350717" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP directives &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. When</source>
          <target state="translated">Включите обработку директив OpenMP &lt;code&gt;#pragma omp&lt;/code&gt; в C / C ++ и &lt;code&gt;!$omp&lt;/code&gt; в Fortran. когда</target>
        </trans-unit>
        <trans-unit id="f764c2e81a54602d1c0862a3fd8d88c71c27e5ef" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP&amp;rsquo;s SIMD directives with &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. Other OpenMP directives are ignored.</source>
          <target state="translated">Включите обработку директив SIMD OpenMP с помощью &lt;code&gt;#pragma omp&lt;/code&gt; в C / C ++ и &lt;code&gt;!$omp&lt;/code&gt; в Fortran. Другие директивы OpenMP игнорируются.</target>
        </trans-unit>
        <trans-unit id="325afe18f0a625fafbd824b05e823388581382ad" translate="yes" xml:space="preserve">
          <source>Enable inlining of PLT entries in function calls to functions that are not known to bind locally. It has no effect without</source>
          <target state="translated">Разрешить встраивание записей PLT в вызовах функций,которые,как известно,не привязываются локально.Это не имеет эффекта без</target>
        </trans-unit>
        <trans-unit id="26c34a078cd9b46fb0bd484cd235d46f5c53f46b" translate="yes" xml:space="preserve">
          <source>Enable internal consistency checking. The default depends on the compiler configuration.</source>
          <target state="translated">Включить проверку внутренней согласованности.Значение по умолчанию зависит от конфигурации компилятора.</target>
        </trans-unit>
        <trans-unit id="b40ab07f35e9ecebed6c91979cb9c80321b2c600" translate="yes" xml:space="preserve">
          <source>Enable interrupt stack instructions; the default is off.</source>
          <target state="translated">Включите инструкции по прерыванию стека;по умолчанию выключен.</target>
        </trans-unit>
        <trans-unit id="fd58b676d0e4ba40cac9f6295490ba16f891fad5" translate="yes" xml:space="preserve">
          <source>Enable kernel development mode. The</source>
          <target state="translated">Включить режим разработки ядра.</target>
        </trans-unit>
        <trans-unit id="6942946c621ac80c436737b7a31ee339272c871d" translate="yes" xml:space="preserve">
          <source>Enable lazy binding of function calls. This option is equivalent to</source>
          <target state="translated">Включите ленивую привязку вызовов функций.Эта опция эквивалентна</target>
        </trans-unit>
        <trans-unit id="c3e68f8f7d9888cb3d2e2d66e5738f0a5b7bffcf" translate="yes" xml:space="preserve">
          <source>Enable linker relaxation. Linker relaxation is a process whereby the linker attempts to reduce the size of a program by finding shorter versions of various instructions. Disabled by default.</source>
          <target state="translated">Включить линкер релаксации.Расслабление компоновщика-это процесс,при котором компоновщик пытается уменьшить размер программы,находя более короткие версии различных инструкций.По умолчанию отключен.</target>
        </trans-unit>
        <trans-unit id="0765f61b18fd9b0cd981b0d3115e02320dabdb7a" translate="yes" xml:space="preserve">
          <source>Enable loop epilogue vectorization using smaller vector size.</source>
          <target state="translated">Включить векторизацию петли эпилога,используя меньший размер вектора.</target>
        </trans-unit>
        <trans-unit id="04769dddbdca1dd3af29e66b89d9df24ccfdaae0" translate="yes" xml:space="preserve">
          <source>Enable more detailed dumps (not honored by every dump option). Also include information from the optimization passes.</source>
          <target state="translated">Включите более подробные дампы (не учитывается каждый вариант дампа).Также включить информацию из проходов оптимизации.</target>
        </trans-unit>
        <trans-unit id="9f3bf571af4fb133a9ed845eaa94347bdecede5e" translate="yes" xml:space="preserve">
          <source>Enable multiply instructions.</source>
          <target state="translated">Включите инструкции по умножению.</target>
        </trans-unit>
        <trans-unit id="6bdc85b650029e698104b9394508a12676ccb6ec" translate="yes" xml:space="preserve">
          <source>Enable multiprocessor instructions; the default is off.</source>
          <target state="translated">Включить многопроцессорные инструкции;по умолчанию выключен.</target>
        </trans-unit>
        <trans-unit id="dae98acaa0a30e3960a49dff4e2a8d6c6a98eb29" translate="yes" xml:space="preserve">
          <source>Enable nested conditional execution optimizations (default).</source>
          <target state="translated">Включить вложенные условные оптимизации выполнения (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="0523e9bf64ec1c9137b9f17ae48ec467d581e674" translate="yes" xml:space="preserve">
          <source>Enable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution (default).</source>
          <target state="translated">Включите оптимизацию &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; в условном исполнении (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="43cad454d19cf94092ebd0b65a6a9f9c7c63ffa9" translate="yes" xml:space="preserve">
          <source>Enable options usually used for instrumenting application to produce profile useful for later recompilation with profile feedback based optimization. You must use</source>
          <target state="translated">Включение опций,обычно используемых для инструментального применения,для получения профиля,полезного для последующей перекомпиляции с оптимизацией на основе обратной связи по профилю.Вы должны использовать</target>
        </trans-unit>
        <trans-unit id="9425982687d5465084a29222f1e8d83738debfbc" translate="yes" xml:space="preserve">
          <source>Enable or disable PC-relative literal loads. With this option literal pools are accessed using a single instruction and emitted after each function. This limits the maximum size of functions to 1MB. This is enabled by default for</source>
          <target state="translated">Включение или выключение буквенных нагрузок,связанных с ПК.При этой опции доступ к буквальным пулам осуществляется с помощью одной инструкции и выдается после каждой функции.Это ограничивает максимальный размер функций 1МБ.По умолчанию это включено для</target>
        </trans-unit>
        <trans-unit id="37cd8da3fdbfa9f8188d860129119fec2bfd100c" translate="yes" xml:space="preserve">
          <source>Enable or disable calls to out-of-line helpers to implement atomic operations. These helpers will, at runtime, determine if the LSE instructions from ARMv8.1-A can be used; if not, they will use the load/store-exclusive instructions that are present in the base ARMv8.0 ISA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a34d5bdfa8a40aec1348063e5f43f0a38a44e4b" translate="yes" xml:space="preserve">
          <source>Enable or disable calls to out-of-line helpers to implement atomic operations. This corresponds to the behavior of the command line options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f213f1158c65a76a7da3e44d0dfb546afeb1c37d" translate="yes" xml:space="preserve">
          <source>Enable or disable emitting &lt;code&gt;mul&lt;/code&gt;, &lt;code&gt;mulx&lt;/code&gt; and &lt;code&gt;div&lt;/code&gt; family of instructions by the compiler. The default is to emit &lt;code&gt;mul&lt;/code&gt; and not emit &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;mulx&lt;/code&gt;.</source>
          <target state="translated">Включение или отключение &lt;code&gt;mulx&lt;/code&gt; компилятором команд &lt;code&gt;mul&lt;/code&gt; , mulx и &lt;code&gt;div&lt;/code&gt; . По умолчанию испускается &lt;code&gt;mul&lt;/code&gt; , а не &lt;code&gt;div&lt;/code&gt; и &lt;code&gt;mulx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0c735f45199333d31330ebeb1c39ca77bf91fab" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of Nios II R2 BMX (bit manipulation) and CDX (code density) instructions. Enabling these instructions also requires</source>
          <target state="translated">Включение или отключение генерации инструкций Nios II R2 BMX (манипулирование битами)и CDX (плотность кода).Включение этих инструкций также требует</target>
        </trans-unit>
        <trans-unit id="e82224b52a26ba48a5b113f09b7fcf8cc858a9c2" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of additional code to track speculative execution through conditional branches. The tracking state can then be used by the compiler when expanding calls to &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; to permit a more efficient code sequence to be generated.</source>
          <target state="translated">Включение или отключение генерации дополнительного кода для отслеживания спекулятивного выполнения через условные переходы. Затем состояние отслеживания может использоваться компилятором при расширенных вызовах &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; , чтобы обеспечить создание более эффективной кодовой последовательности.</target>
        </trans-unit>
        <trans-unit id="8588fb4dd2a8d4f96274711c0f8a3dcffa809a3b" translate="yes" xml:space="preserve">
          <source>Enable or disable the division approximation. This option only has an effect if</source>
          <target state="translated">Включить или выключить аппроксимацию деления.Эта опция действует только в том случае,если</target>
        </trans-unit>
        <trans-unit id="da4836dd8fd423982dc5d807088aa304a1a7fb40" translate="yes" xml:space="preserve">
          <source>Enable or disable the reciprocal square root approximation. This option only has an effect if</source>
          <target state="translated">Включить или выключить аппроксимацию обратного квадратного корня.Эта опция действует только в том случае,если</target>
        </trans-unit>
        <trans-unit id="6cd2e01bcd6daa77f123d3562e525b53f2208b99" translate="yes" xml:space="preserve">
          <source>Enable or disable the square root approximation. This option only has an effect if</source>
          <target state="translated">Включите или выключите аппроксимацию квадратного корня.Эта опция действует только в том случае,если</target>
        </trans-unit>
        <trans-unit id="f6d5d7b63171cb59117cb5da0b6d0ce6a7318345" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 835769. This involves inserting a NOP instruction between memory instructions and 64-bit integer multiply-accumulate instructions.</source>
          <target state="translated">Включить или отключить обходной путь для ошибки ARM Cortex-A53 номер 835769.Это предполагает вставку NOP-инструкции между инструкциями памяти и 64-битными целочисленными инструкциями умножения.</target>
        </trans-unit>
        <trans-unit id="1b8e841a5a6d9c6fdc72f5d2c3b9462219761996" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 843419. This erratum workaround is made at link time and this will only pass the corresponding flag to the linker.</source>
          <target state="translated">Включить или отключить обходной путь для ошибки ARM Cortex-A53 номер 843419.Этот обходной путь производится во время работы ссылки,при этом линкеру будет передан только соответствующий флаг.</target>
        </trans-unit>
        <trans-unit id="e8d2c7af76155c379ab5d5ec1df26431744e4771" translate="yes" xml:space="preserve">
          <source>Enable or disable use of &lt;code&gt;CONST16&lt;/code&gt; instructions for loading constant values. The &lt;code&gt;CONST16&lt;/code&gt; instruction is currently not a standard option from Tensilica. When enabled, &lt;code&gt;CONST16&lt;/code&gt; instructions are always used in place of the standard &lt;code&gt;L32R&lt;/code&gt; instructions. The use of &lt;code&gt;CONST16&lt;/code&gt; is enabled by default only if the &lt;code&gt;L32R&lt;/code&gt; instruction is not available.</source>
          <target state="translated">Включение или отключение использования инструкций &lt;code&gt;CONST16&lt;/code&gt; для загрузки постоянных значений. &lt;code&gt;CONST16&lt;/code&gt; инструкция в настоящее время не является стандартной опцией от Tensilica. Когда включено, инструкции &lt;code&gt;CONST16&lt;/code&gt; всегда используются вместо стандартных инструкций &lt;code&gt;L32R&lt;/code&gt; . Использование &lt;code&gt;CONST16&lt;/code&gt; разрешено по умолчанию, только если инструкция &lt;code&gt;L32R&lt;/code&gt; недоступна.</target>
        </trans-unit>
        <trans-unit id="87ea222da3a42af40a5b89fab414b5a2466d4691" translate="yes" xml:space="preserve">
          <source>Enable or disable use of Branch Likely instructions, regardless of the default for the selected architecture. By default, Branch Likely instructions may be generated if they are supported by the selected architecture. An exception is for the MIPS32 and MIPS64 architectures and processors that implement those architectures; for those, Branch Likely instructions are not be generated by default because the MIPS32 and MIPS64 architectures specifically deprecate their use.</source>
          <target state="translated">Включите или отключите использование инструкций Branch Likely,независимо от того,что установлено по умолчанию для выбранной архитектуры.По умолчанию команды Branch Likely могут генерироваться,если они поддерживаются выбранной архитектурой.Исключение составляют архитектуры MIPS32 и MIPS64 и процессоры,реализующие эти архитектуры;для них команды Branch Likely не генерируются по умолчанию,поскольку архитектуры MIPS32 и MIPS64 специально не поддерживают их использование.</target>
        </trans-unit>
        <trans-unit id="6f7c7366f13d27cab3029da7a7c328e36fbdbb28" translate="yes" xml:space="preserve">
          <source>Enable or disable use of fused multiply/add and multiply/subtract instructions in the floating-point option. This has no effect if the floating-point option is not also enabled. Disabling fused multiply/add and multiply/subtract instructions forces the compiler to use separate instructions for the multiply and add/subtract operations. This may be desirable in some cases where strict IEEE 754-compliant results are required: the fused multiply add/subtract instructions do not round the intermediate result, thereby producing results with &lt;em&gt;more&lt;/em&gt; bits of precision than specified by the IEEE standard. Disabling fused multiply add/subtract instructions also ensures that the program output is not sensitive to the compiler&amp;rsquo;s ability to combine multiply and add/subtract operations.</source>
          <target state="translated">Включите или отключите использование совмещенных команд умножения / сложения и умножения / вычитания в параметре с плавающей запятой. Это не действует, если опция с плавающей запятой также не включена. Отключение слитных инструкций умножения / сложения и умножения / вычитания вынуждает компилятор использовать отдельные инструкции для операций умножения и сложения / вычитания. Это может быть желательно в некоторых случаях, когда требуются результаты, строго соответствующие стандарту IEEE 754: объединенные команды умножения и вычитания не округляют промежуточный результат, тем самым давая результаты с &lt;em&gt;большей&lt;/em&gt; точностью, чем указано в стандарте IEEE. Отключение инструкций сложения / вычитания слитного умножения также гарантирует, что вывод программы нечувствителен к способности компилятора комбинировать операции умножения и сложения / вычитания.</target>
        </trans-unit>
        <trans-unit id="f2d29f4186409cdd0269837c4398f5ca04568394" translate="yes" xml:space="preserve">
          <source>Enable other detailed optimization information (only available in certain passes).</source>
          <target state="translated">Включите другую подробную информацию по оптимизации (доступно только в определенных проходах).</target>
        </trans-unit>
        <trans-unit id="338cf5f95ce763c97fbfe82953390f719fbef967" translate="yes" xml:space="preserve">
          <source>Enable parsing of function definitions marked with &lt;code&gt;__GIMPLE&lt;/code&gt;. This is an experimental feature that allows unit testing of GIMPLE passes.</source>
          <target state="translated">Включите анализ определений функций, отмеченных &lt;code&gt;__GIMPLE&lt;/code&gt; . Это экспериментальная функция, которая позволяет модульное тестирование проходов GIMPLE.</target>
        </trans-unit>
        <trans-unit id="f3fcc68975389b930adf047407384e4de7afa86d" translate="yes" xml:space="preserve">
          <source>Enable pre-reload use of the &lt;code&gt;cbranchsi&lt;/code&gt; pattern.</source>
          <target state="translated">Включите использование шаблона &lt;code&gt;cbranchsi&lt;/code&gt; перед перезагрузкой .</target>
        </trans-unit>
        <trans-unit id="7aca1894ee9ae073c5e50327164b18c35adaf0e4" translate="yes" xml:space="preserve">
          <source>Enable profile feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">Включите оптимизации,направленные на обратную связь с профилем,и следующие оптимизации,многие из которых,как правило,выгодны только при наличии обратной связи с профилем:</target>
        </trans-unit>
        <trans-unit id="dd16226a248d7401935b2178b12d750c5c2d817f" translate="yes" xml:space="preserve">
          <source>Enable reduced code size &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;puts&lt;/code&gt; library functions. The &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b22143dddf716e38b0694ad2ca7a60178731d02" translate="yes" xml:space="preserve">
          <source>Enable register pressure sensitive insn scheduling before register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with</source>
          <target state="translated">Включите планирование insn,чувствительное к давлению регистров,перед распределением регистров.Это имеет смысл только в том случае,если включено планирование перед распределением регистров,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="c0432e33b5c323c92ba751b7a0171493013f8ec2" translate="yes" xml:space="preserve">
          <source>Enable sampling-based feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">Включение оптимизаций,основанных на выборке и направленных на обратную связь,а также следующих оптимизаций,многие из которых,как правило,выгодны только при наличии обратной связи по профилю:</target>
        </trans-unit>
        <trans-unit id="9201f89c6bef5151370e84b69891107c6c6b6ade" translate="yes" xml:space="preserve">
          <source>Enable sanitization of local variables to detect use-after-scope bugs. The option sets</source>
          <target state="translated">Позволяет проводить санобработку локальных переменных для обнаружения ошибок,которые могут быть обнаружены после использования.Наборы опций</target>
        </trans-unit>
        <trans-unit id="37f6c409f5734729b3dae114f8c39805c8586c4f" translate="yes" xml:space="preserve">
          <source>Enable showing basic block boundaries (disabled in raw dumps).</source>
          <target state="translated">Включить отображение границ основных блоков (отключено в необработанных отвалах).</target>
        </trans-unit>
        <trans-unit id="92f2f939a0618b052e264a0ddefa5df5b7f5e756" translate="yes" xml:space="preserve">
          <source>Enable showing line numbers for statements.</source>
          <target state="translated">Включить отображение номеров строк для заявлений.</target>
        </trans-unit>
        <trans-unit id="fd380e6ae8aa5c4cc3cef79ab2ea9026b97f5fbd" translate="yes" xml:space="preserve">
          <source>Enable showing missed optimization information (only available in certain passes).</source>
          <target state="translated">Включить показ пропущенной оптимизационной информации (доступно только в определенных проходах).</target>
        </trans-unit>
        <trans-unit id="0d329eb30c66df2a8bec3e0f68514d20ab1b9f92" translate="yes" xml:space="preserve">
          <source>Enable showing optimization information (only available in certain passes).</source>
          <target state="translated">Включить отображение оптимизационной информации (доступно только в определенных проходах).</target>
        </trans-unit>
        <trans-unit id="f10fcf4d31c6a2b2451c140a8a88da810228a75d" translate="yes" xml:space="preserve">
          <source>Enable showing scalar evolution analysis details.</source>
          <target state="translated">Позволяет показать детали анализа скалярной эволюции.</target>
        </trans-unit>
        <trans-unit id="1fa4da5aa5a1df45f7fc17506d98a1fa44e7ec97" translate="yes" xml:space="preserve">
          <source>Enable showing the EH region number holding each statement.</source>
          <target state="translated">Включить отображение номера региона EH,в котором хранится каждое утверждение.</target>
        </trans-unit>
        <trans-unit id="c8bfc39b577282d7a982b0609ca5e212d2e36522" translate="yes" xml:space="preserve">
          <source>Enable showing the tree dump for each statement.</source>
          <target state="translated">Включите показ свалки деревьев для каждого утверждения.</target>
        </trans-unit>
        <trans-unit id="c1965c688248d83e371ce542160789f937fce791" translate="yes" xml:space="preserve">
          <source>Enable showing the unique ID (&lt;code&gt;DECL_UID&lt;/code&gt;) for each variable.</source>
          <target state="translated">Включите отображение уникального идентификатора ( &lt;code&gt;DECL_UID&lt;/code&gt; ) для каждой переменной.</target>
        </trans-unit>
        <trans-unit id="2c8e86f5a7b56d45f646fe90ecd4602077ea1bdc" translate="yes" xml:space="preserve">
          <source>Enable showing virtual operands for every statement.</source>
          <target state="translated">Включить показ виртуальных операндов для каждого утверждения.</target>
        </trans-unit>
        <trans-unit id="7287e0e84335a843622d1b816ceb09d5c05aa749" translate="yes" xml:space="preserve">
          <source>Enable sign extend instructions.</source>
          <target state="translated">Включите знак &quot;Расширить инструкцию&quot;.</target>
        </trans-unit>
        <trans-unit id="2106aa3d9fb87ebeededad40a76e40f9c935fadd" translate="yes" xml:space="preserve">
          <source>Enable software pipelining of innermost loops during selective scheduling. This option has no effect unless one of</source>
          <target state="translated">Включить программную обвязку внутренних контуров во время селективного планирования.Эта опция не имеет никакого эффекта,если только один из</target>
        </trans-unit>
        <trans-unit id="523a4757398235b8bbb90229026fc9eed157dbee" translate="yes" xml:space="preserve">
          <source>Enable special code to work around file systems which only permit very short file names, such as MS-DOS.</source>
          <target state="translated">Включите специальный код для работы с файловыми системами,которые допускают только очень короткие имена файлов,такие как MS-DOS.</target>
        </trans-unit>
        <trans-unit id="3536f2d6d38314050bafe0d10aa71b6595a43eae" translate="yes" xml:space="preserve">
          <source>Enable streaming of mangled types names of C++ types and their unification at link time. This increases size of LTO object files, but enables diagnostics about One Definition Rule violations.</source>
          <target state="translated">Включить потоковое воспроизведение имен искаженных типов С++и их унификацию во время линковки.Это увеличивает размер файлов объектов LTO,но позволяет диагностировать нарушения правила One Definition Rule.</target>
        </trans-unit>
        <trans-unit id="07a4edd982a3edcc355177edde03a13c0e84c57f" translate="yes" xml:space="preserve">
          <source>Enable support for &lt;code&gt;char8_t&lt;/code&gt; as adopted for C++2a. This includes the addition of a new &lt;code&gt;char8_t&lt;/code&gt; fundamental type, changes to the types of UTF-8 string and character literals, new signatures for user-defined literals, associated standard library updates, and new &lt;code&gt;__cpp_char8_t&lt;/code&gt; and &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; feature test macros.</source>
          <target state="translated">Включите поддержку &lt;code&gt;char8_t&lt;/code&gt; , как принято для C ++ 2a. Это включает добавление нового фундаментального типа &lt;code&gt;char8_t&lt;/code&gt; , изменения типов строковых и символьных литералов UTF-8, новые сигнатуры для определяемых пользователем литералов, связанные обновления стандартной библиотеки и новые &lt;code&gt;__cpp_char8_t&lt;/code&gt; &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; функций __cpp_char8_t и __cpp_lib_char8_t .</target>
        </trans-unit>
        <trans-unit id="86deb01ddbea29be60b5e5fa22319efa9cd9ea02" translate="yes" xml:space="preserve">
          <source>Enable support for C++17 &lt;code&gt;new&lt;/code&gt; of types that require more alignment than &lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; provides. A numeric argument such as &lt;code&gt;-faligned-new=32&lt;/code&gt; can be used to specify how much alignment (in bytes) is provided by that function, but few users will need to override the default of &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt;.</source>
          <target state="translated">Включите поддержку &lt;code&gt;new&lt;/code&gt; типов C ++ 17, которые требуют большего выравнивания, чем обеспечивает &lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; . Числовой аргумент, такой как &lt;code&gt;-faligned-new=32&lt;/code&gt; , может использоваться для указания, сколько выравнивания (в байтах) обеспечивается этой функцией, но немногим пользователям потребуется переопределить значение по умолчанию &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e96dd7f9b95634f8def4cef0c03097523e0ad470" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ Extensions for Concepts Technical Specification, ISO 19217 (2015), which allows code like</source>
          <target state="translated">Включение поддержки расширения C++для Concepts Technical Specification,ISO 19217 (2015),которое позволяет код типа</target>
        </trans-unit>
        <trans-unit id="14e7ef08a35724e34d06ae98a57c52f37db35541" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ coroutines extension (experimental).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f069479e84a1d7c81e6433a171bacdd46bd05f77" translate="yes" xml:space="preserve">
          <source>Enable syntactic support for structured exception handling in Objective-C, similar to what is offered by C++. This option is required to use the Objective-C keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;. This option is available with both the GNU runtime and the NeXT runtime (but not available in conjunction with the NeXT runtime on Mac OS X 10.2 and earlier).</source>
          <target state="translated">Включите синтаксическую поддержку для структурированной обработки исключений в Objective-C, аналогично тому, что предлагает C ++. Эта опция требуется для использования ключевых слов Objective-C &lt;code&gt;@try&lt;/code&gt; , &lt;code&gt;@throw&lt;/code&gt; , &lt;code&gt;@catch&lt;/code&gt; , &lt;code&gt;@finally&lt;/code&gt; и &lt;code&gt;@synchronized&lt;/code&gt; . Этот параметр доступен как для среды выполнения GNU, так и для среды выполнения NeXT (но не доступен в сочетании со средой выполнения NeXT в Mac OS X 10.2 и ранее).</target>
        </trans-unit>
        <trans-unit id="2d795a0556dc7d4b23ca50c7c054a8e91a0bb9da" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Execution and Data Prediction Restriction instructions. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Включите инструкции Armv8-a по выполнению и ограничению прогнозирования данных.Эта опция предназначена только для включения расширения на уровне ассемблера и не влияет на генерацию кода.Эта опция включена по умолчанию для</target>
        </trans-unit>
        <trans-unit id="9fdfa6853fe490f741b25fcc657be1e589731130" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Scalable Vector Extension 2. This also enables SVE instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d449b6d30f1777aba3aa927c43beb1ba1eca16be" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculation Barrier instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Включите инструкцию Armv8-а &quot;Барьер спекуляции&quot;.Эта опция предназначена только для включения расширения на уровне ассемблера и не влияет на генерацию кода.Эта опция включена по умолчанию для</target>
        </trans-unit>
        <trans-unit id="9f3b4e86290c1a4d9bac5d679d03a802d662a426" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculative Store Bypass Safe instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Включите инструкцию Armv8-a Speculative Store Bypass Safe.Эта опция предназначена только для включения расширения на уровне ассемблера и не влияет на генерацию кода.Данная опция включена по умолчанию для</target>
        </trans-unit>
        <trans-unit id="cb4dff47dd10c4d2d29138894fb337bf731a4703" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a aes and pmull crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">Включите Armv8-a aes и pmull crypto расширение.Это также позволяет использовать расширенные инструкции SIMD.</target>
        </trans-unit>
        <trans-unit id="e878790ea268c6c3c0f09ca24b1f8d32605101d6" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a sha2 crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">Включить Armv8-a sha2 криптоудлинитель.Это также позволяет использовать расширенные инструкции SIMD.</target>
        </trans-unit>
        <trans-unit id="712d78d3897110fb983a6b1ce64ceb649bbc8b13" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">Включите удлинители для маркировки памяти Armv8.5-a.Эта опция предназначена только для включения расширения на уровне ассемблера и не влияет на генерацию кода.</target>
        </trans-unit>
        <trans-unit id="9079a098e5a352f9d4734819ee7434e8414e46a7" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. Use of this option with architectures prior to Armv8.5-A is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95fc60e33111a67c5486993a8b351f8b44d07966" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Random Number instructions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">Включите инструкцию Armv8.5-a Случайный номер.Эта опция предназначена только для включения расширения на уровне ассемблера и не влияет на генерацию кода.</target>
        </trans-unit>
        <trans-unit id="180be0b78efe4d6cb3cafec86af33875c8613d90" translate="yes" xml:space="preserve">
          <source>Enable the Custom Datapath Extension (CDE) on selected coprocessors according to the numbers given in the options in the range 0 to 7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5baad961c199027af6ce41f297ba396c80d7b6e4" translate="yes" xml:space="preserve">
          <source>Enable the Dot Product extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">Включите расширение Dot Product.Это также позволяет использовать расширенные SIMD-инструкции.</target>
        </trans-unit>
        <trans-unit id="75d41529d8ccf751d43eb43b131c2899752ea6dc" translate="yes" xml:space="preserve">
          <source>Enable the P0136 adjustment to the semantics of C++11 constructor inheritance. This is part of C++17 but also considered to be a Defect Report against C++11 and C++14. This flag is enabled by default unless</source>
          <target state="translated">Включить настройку P0136 на семантику наследования конструктора C++11.Это часть C++17,но также считается дефектным сообщением против C++11 и C++14.Этот флаг включен по умолчанию,если только</target>
        </trans-unit>
        <trans-unit id="3336547cc155fdebeb020d2a6fd267e14851b493" translate="yes" xml:space="preserve">
          <source>Enable the P0522 resolution to Core issue 150, template template parameters and default arguments: this allows a template with default template arguments as an argument for a template template parameter with fewer template parameters. This flag is enabled by default for</source>
          <target state="translated">Включите разрешение P0522 в Core issue 150,параметры шаблона и аргументы по умолчанию:это позволяет использовать шаблон с аргументами шаблона по умолчанию в качестве аргумента для параметра шаблона с меньшим количеством параметров шаблона.Этот флаг включен по умолчанию для</target>
        </trans-unit>
        <trans-unit id="e10cb464cd66cc6979f0f2bd645896f8d79b1002" translate="yes" xml:space="preserve">
          <source>Enable the RcPc extension. This does not change code generation from GCC, but is passed on to the assembler, enabling inline asm statements to use instructions from the RcPc extension.</source>
          <target state="translated">Включите расширение RcPc.Это не меняет генерацию кода из GCC,а передается ассемблеру,позволяя встроенным операторам asm использовать инструкции из расширения RcPc.</target>
        </trans-unit>
        <trans-unit id="b8bb0e2cd28800659cbb25749c903e1e45881bcd" translate="yes" xml:space="preserve">
          <source>Enable the Statistical Profiling extension. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">Включите расширение статистического профилирования.Данная опция предназначена только для включения расширения на уровне ассемблера и не влияет на генерацию кода.</target>
        </trans-unit>
        <trans-unit id="1fe6b0760edee391f1d108920f04662238f04b99" translate="yes" xml:space="preserve">
          <source>Enable the Transactional Memory Extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bf0d0b92eedbfd9d708906c85f1c2c0761dac3" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar division.</source>
          <target state="translated">Включите аппроксимацию для скалярного деления.</target>
        </trans-unit>
        <trans-unit id="089b193263b191426125d1b838990e7a8cad6bd6" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar square root.</source>
          <target state="translated">Включите аппроксимацию для скалярного квадратного корня.</target>
        </trans-unit>
        <trans-unit id="9c93085948ceb9475fc7f62f768a72b094e0ccf8" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized division.</source>
          <target state="translated">Включите аппроксимацию для векторного деления.</target>
        </trans-unit>
        <trans-unit id="57c9384569cf978709f6ae7436442c4140ae097a" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized square root.</source>
          <target state="translated">Включите аппроксимацию для векторизованного квадратного корня.</target>
        </trans-unit>
        <trans-unit id="a491c3894437f3620a7562cbc06a8ae940a33c10" translate="yes" xml:space="preserve">
          <source>Enable the built-in global declarations</source>
          <target state="translated">Включить встроенные глобальные декларации</target>
        </trans-unit>
        <trans-unit id="2237d50ade0b28ca43195c6d9a72499aa22da748" translate="yes" xml:space="preserve">
          <source>Enable the compiler to directly use a symbol name as an address in a load/store instruction, without first loading it into a register. Typically, the use of this option generates larger programs, which run faster than when the option isn&amp;rsquo;t used. However, the results vary from program to program, so it is left as a user option, rather than being permanently enabled.</source>
          <target state="translated">Разрешите компилятору напрямую использовать имя символа в качестве адреса в инструкции загрузки / сохранения без предварительной загрузки его в регистр. Как правило, использование этого параметра приводит к созданию более крупных программ, которые работают быстрее, чем когда этот параметр не используется. Тем не менее, результаты варьируются от программы к программе, поэтому она остается в качестве опции пользователя, а не постоянно.</target>
        </trans-unit>
        <trans-unit id="41ed1ab2ec5c1611d830306ad10031d9f9977d65" translate="yes" xml:space="preserve">
          <source>Enable the critical-path heuristic in the scheduler. This heuristic favors instructions on the critical path. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">Включите эвристический критический путь в планировщике.Эта эвристика благоприятствует инструкциям на критическом пути.Это включено по умолчанию,когда включено планирование,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="4067ddde2438b48af6e32a24a3e86763ffbd4275" translate="yes" xml:space="preserve">
          <source>Enable the default instructions, equivalent to</source>
          <target state="translated">Включите инструкции по умолчанию,эквивалентные</target>
        </trans-unit>
        <trans-unit id="8f1e0508bfc454c7d53eb8b99b0581386011e857" translate="yes" xml:space="preserve">
          <source>Enable the dependent-count heuristic in the scheduler. This heuristic favors the instruction that has more instructions depending on it. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">Включите в планировщике эвризм зависимого счета.Этот эвристический показатель благоприятствует той инструкции,которая имеет больше инструкций,зависящих от нее.Это включено по умолчанию,когда включено планирование,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="507033c0f31508a95a83480597cd9ac155e65d9c" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the GR712RC processor.</source>
          <target state="translated">Включить документированный обходной путь для устранения ошибок в резервном хранилище процессора GR712RC.</target>
        </trans-unit>
        <trans-unit id="eef2a052e4462aff6add94764479243457e98b05" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the UT699E/UT700 processor.</source>
          <target state="translated">Включите документированный обходной путь для ошибок резервного хранилища процессора UT699E/UT700.</target>
        </trans-unit>
        <trans-unit id="decf2a901923b7e9eb5ca1ab92693295f143a06a" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the single erratum of the Atmel AT697F processor (which corresponds to erratum #13 of the AT697E processor).</source>
          <target state="translated">Включите документированное обходное решение для одиночной ошибки процессора Atmel AT697F (которая соответствует ошибке № 13 процессора AT697E).</target>
        </trans-unit>
        <trans-unit id="bcb5bb2598740b13546a58b17f6d5aa7c7ba6853" translate="yes" xml:space="preserve">
          <source>Enable the documented workarounds for the floating-point errata and the data cache nullify errata of the UT699 processor.</source>
          <target state="translated">Включите документированные обходные пути для ошибок с плавающей точкой и кэш данных,чтобы свести к нулю ошибки процессора UT699.</target>
        </trans-unit>
        <trans-unit id="43eeb910cdee4c766507663e6e771a799fe37d3f" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal approximation instructions.</source>
          <target state="translated">Включите инструкции по взаимному приближению с двойной точностью.</target>
        </trans-unit>
        <trans-unit id="446e6f12ce2775419c21aa646c548678ff1569c1" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal square root approximation instructions.</source>
          <target state="translated">Включите инструкции по аппроксимации обратного квадратного корня с двойной точностью.</target>
        </trans-unit>
        <trans-unit id="71718fe9aa5b48da1b26c519c152f829f75fb0c0" translate="yes" xml:space="preserve">
          <source>Enable the extended &lt;code&gt;lrw&lt;/code&gt; instruction. This option defaults to on for CK801 and off otherwise.</source>
          <target state="translated">Включите расширенную инструкцию &lt;code&gt;lrw&lt;/code&gt; . Этот параметр по умолчанию включен для CK801 и выключен в противном случае.</target>
        </trans-unit>
        <trans-unit id="26a17bc6f3de31676776135a782cd9c993e95087" translate="yes" xml:space="preserve">
          <source>Enable the generation of conditional moves.</source>
          <target state="translated">Включить генерацию условных ходов.</target>
        </trans-unit>
        <trans-unit id="04969a109a871e39815667dea2edea4731968533" translate="yes" xml:space="preserve">
          <source>Enable the group heuristic in the scheduler. This heuristic favors the instruction that belongs to a schedule group. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">Включите групповую эвристику в планировщике.Эта эвристика благоприятствует инструкциям,принадлежащим к группе расписания.Это включено по умолчанию,когда включено планирование,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="74416a1c4632bd2c9719e7f267cc78921917bec4" translate="yes" xml:space="preserve">
          <source>Enable the identity transformation for graphite. For every SCoP we generate the polyhedral representation and transform it back to gimple. Using</source>
          <target state="translated">Включите трансформацию идентичности для графита.Для каждого SCoP мы генерируем многогранное представление и преобразовываем его обратно в гимпл.Используя</target>
        </trans-unit>
        <trans-unit id="d52969e42d36857a708d794bd442398a6f2b1d5e" translate="yes" xml:space="preserve">
          <source>Enable the isl based loop nest optimizer. This is a generic loop nest optimizer based on the Pluto optimization algorithms. It calculates a loop structure optimized for data-locality and parallelism. This option is experimental.</source>
          <target state="translated">Включите оптимизатор кольцевого гнезда на основе isl.Это универсальный оптимизатор циклического гнезда,основанный на алгоритмах оптимизации Плутона.Он вычисляет структуру цикла,оптимизированную на локальность и параллельность данных.Этот вариант является экспериментальным.</target>
        </trans-unit>
        <trans-unit id="08b7ee5bf2b0eaab5c12a44d79b227e23ee0c0f5" translate="yes" xml:space="preserve">
          <source>Enable the last-instruction heuristic in the scheduler. This heuristic favors the instruction that is less dependent on the last instruction scheduled. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">Включите в планировщике эвризм последних инструкций.Этот эвристический режим благоприятствует инструкциям,которые меньше зависят от последней запланированной инструкции.Это включено по умолчанию,когда включено планирование,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="dc56e6084e464db3d7d083e493fb69fc336bcfc3" translate="yes" xml:space="preserve">
          <source>Enable the optimization pass in the HP-UX linker. Note this makes symbolic debugging impossible. It also triggers a bug in the HP-UX 8 and HP-UX 9 linkers in which they give bogus error messages when linking some programs.</source>
          <target state="translated">Включите передачу оптимизации в линкере HP-UX.Обратите внимание,что это делает отладку символов невозможной.Это также приводит к ошибке в компоновщиках HP-UX 8 и HP-UX 9,в которых они выдают ложные сообщения об ошибках при компоновке некоторых программ.</target>
        </trans-unit>
        <trans-unit id="8008915ad05d64b6cc01c8698eac6fdda560f6c1" translate="yes" xml:space="preserve">
          <source>Enable the rank heuristic in the scheduler. This heuristic favors the instruction belonging to a basic block with greater size or frequency. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">Включите эвристическое ранжирование в планировщике.При этом эвристика благоприятствует тому,чтобы инструкция принадлежала базовому блоку с большим размером или частотой.Это включено по умолчанию,когда включено планирование,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="e6ed1ceef09b312da3bb73bea4902c46d06845e0" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal approximation instructions for both single and double precision.</source>
          <target state="translated">Включите инструкции по взаимному приближению как для одинарной,так и для двойной точности.</target>
        </trans-unit>
        <trans-unit id="4c8e53d3299e21b3cf3fba9ff55c2082c7b6b1ec" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal square root approximation instructions for both single and double precision.</source>
          <target state="translated">Включите инструкции по аппроксимации обратного квадратного корня как для одинарной,так и для двойной точности.</target>
        </trans-unit>
        <trans-unit id="21fb72c5396788f3586c523b20f25c7cd0196802" translate="yes" xml:space="preserve">
          <source>Enable the sha512 and sha3 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">Включите шифровальные удлинители sha512 и sha3.Это также позволяет использовать расширенные SIMD-инструкции.Использование этой опции в архитектурах до Armv8.2-A не поддерживается.</target>
        </trans-unit>
        <trans-unit id="ac17a049cdd1860b9740d6573dbf1dae4507b37b" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal approximation instructions.</source>
          <target state="translated">Включите инструкции по взаимному приближению с одинаковой точностью.</target>
        </trans-unit>
        <trans-unit id="a4aef85fc3ef145e7cf3738dcc41b55cc33d82a4" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal square root approximation instructions.</source>
          <target state="translated">Включите инструкции по аппроксимации обратного квадратного корня с одинаковой точностью.</target>
        </trans-unit>
        <trans-unit id="0a29cdf0e1f32dd82e6b20680fbd0f552bb364b2" translate="yes" xml:space="preserve">
          <source>Enable the sm3 and sm4 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">Включите криптографическое расширение sm3 и sm4.Это также позволяет использовать расширенные инструкции SIMD.Использование этого параметра с архитектурами,существовавшими до Armv8.2-A,не поддерживается.</target>
        </trans-unit>
        <trans-unit id="cab5f01ba7747ba0641df8f437ad352196c1c6d3" translate="yes" xml:space="preserve">
          <source>Enable the speculative instruction heuristic in the scheduler. This heuristic favors speculative instructions with greater dependency weakness. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">Включите эвристическую инструкцию в планировщике.Этот эвризм благоприятствует спекулятивным инструкциям со слабой зависимостью.Это включено по умолчанию,когда включено планирование,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="e847a09656f326765748affab74d130a0fbbbfb3" translate="yes" xml:space="preserve">
          <source>Enable the use (disable) of the built-in functions that allow direct access to the cryptographic instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">Разрешить использование (отключить)встроенных функций,разрешающих прямой доступ к криптографическим инструкциям,которые были добавлены в версию 2.07 PowerPC ISA.</target>
        </trans-unit>
        <trans-unit id="0beb7325ebbd427ff6f653a5586006076fc19189" translate="yes" xml:space="preserve">
          <source>Enable the use of &lt;code&gt;GPREL&lt;/code&gt; relocations in the FDPIC ABI for data that is known to be in read-only sections. It&amp;rsquo;s enabled by default, except for</source>
          <target state="translated">Включите использование перемещений &lt;code&gt;GPREL&lt;/code&gt; в FDPIC ABI для данных, которые, как известно, находятся в разделах только для чтения. По умолчанию он включен, кроме</target>
        </trans-unit>
        <trans-unit id="4b3e38bf3ad012b6637b58a91ae68d4399ef997c" translate="yes" xml:space="preserve">
          <source>Enable the use of a minimum runtime environment - no static initializers or constructors. This is intended for memory-constrained devices. The compiler includes special symbols in some objects that tell the linker and runtime which code fragments are required.</source>
          <target state="translated">Разрешить использование минимального окружения выполнения-без статических инициализаторов и конструкторов.Это предназначено для устройств с ограниченной памятью.Компилятор включает в некоторые объекты специальные символы,которые сообщают компоновщику и времени исполнения,какие фрагменты кода необходимы.</target>
        </trans-unit>
        <trans-unit id="2e3906c56ec37b4268552279d6414d35519910f2" translate="yes" xml:space="preserve">
          <source>Enable the use of assembler directives only GAS understands.</source>
          <target state="translated">Включите использование директив ассемблера,которые понимает только GAS.</target>
        </trans-unit>
        <trans-unit id="8315949440093bd19b322b38da5ef593bd5c1273" translate="yes" xml:space="preserve">
          <source>Enable the use of bit manipulation instructions on SH2A.</source>
          <target state="translated">Включите использование инструкций по работе с битами на SH2A.</target>
        </trans-unit>
        <trans-unit id="776b7d037afae7efec8fa9845c5ffbd3bad3e0de" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional execution (default).</source>
          <target state="translated">Разрешить использование условного исполнения (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="3f92036c53e4d3d87aa05d99ffc56331dbaf7cbe" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional set instructions (default).</source>
          <target state="translated">Разрешить использование условных заданных инструкций (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="f02a7f12f7eb0e41accd67fcdeeacad0f7a7fbae" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional-move instructions (default).</source>
          <target state="translated">Разрешить использование команд условного перемещения (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="8bd8c14864a3dc22ad6416f43c205d177280cc14" translate="yes" xml:space="preserve">
          <source>Enable the use of indexed loads. This can be problematic because some optimizers then assume that indexed stores exist, which is not the case.</source>
          <target state="translated">Разрешить использование индексированных нагрузок.Это может быть проблематично,так как некоторые оптимизаторы тогда предполагают,что индексированные хранилища существуют,что не так.</target>
        </trans-unit>
        <trans-unit id="fa24f968931ae6f6108870656a7843c7774cc339" translate="yes" xml:space="preserve">
          <source>Enable the use of multiply-accumulate instructions. Disabled by default.</source>
          <target state="translated">Включите использование инструкций по многократному накоплению.По умолчанию отключен.</target>
        </trans-unit>
        <trans-unit id="d7a1f017f17fab4284673c060b8b2143eec98325" translate="yes" xml:space="preserve">
          <source>Enable the use of odd-numbered single-precision floating-point registers for the o32 ABI. This is the default for processors that are known to support these registers. When using the o32 FPXX ABI,</source>
          <target state="translated">Разрешить использование нечетных одноточных регистров с плавающей запятой для o32 ABI.Это умолчание для процессоров,которые,как известно,поддерживают эти регистры.При использовании o32 FPXX ABI,</target>
        </trans-unit>
        <trans-unit id="ea76b09fecc8949f24ae03f9a3f42c9fa0287c50" translate="yes" xml:space="preserve">
          <source>Enable the use of pre/post modify with register displacement.</source>
          <target state="translated">Разрешить использование пре/пост модификаций со смещением регистра.</target>
        </trans-unit>
        <trans-unit id="6635132d2079387847468168f8edcfc7554ca84f" translate="yes" xml:space="preserve">
          <source>Enable the use of the instruction &lt;code&gt;fmovd&lt;/code&gt;. Check</source>
          <target state="translated">Включите использование инструкции &lt;code&gt;fmovd&lt;/code&gt; . Проверьте</target>
        </trans-unit>
        <trans-unit id="a2fdf0058d830cee1f93b69f832936392dc9ed46" translate="yes" xml:space="preserve">
          <source>Enable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">Включить проход &lt;var&gt;pass&lt;/var&gt; дерева . Видеть</target>
        </trans-unit>
        <trans-unit id="b8f020346acd5709653f3c40d525659258a1b9db" translate="yes" xml:space="preserve">
          <source>Enable use of &lt;code&gt;bi&lt;/code&gt; or &lt;code&gt;bih&lt;/code&gt; instructions to implement jump tables.</source>
          <target state="translated">Разрешить использование инструкций &lt;code&gt;bi&lt;/code&gt; или &lt;code&gt;bih&lt;/code&gt; для реализации таблиц переходов.</target>
        </trans-unit>
        <trans-unit id="79a73d3f193a6e6ff330a4b9de3265b919526bff" translate="yes" xml:space="preserve">
          <source>Enable use of the extended instructions of the FT32B processor.</source>
          <target state="translated">Разрешить использование расширенных инструкций процессора FT32B.</target>
        </trans-unit>
        <trans-unit id="6d0438ac8bb52c3d5f5f9c3df1e29694d4f64211" translate="yes" xml:space="preserve">
          <source>Enable user-defined instructions.</source>
          <target state="translated">Включите инструкции пользователя.</target>
        </trans-unit>
        <trans-unit id="289e8ab3bafc79cd3d4d7a33238e966c5c4d7a05" translate="yes" xml:space="preserve">
          <source>Enable verbose cost model dumping in the debug dump files. This option is provided for use in debugging the compiler.</source>
          <target state="translated">Включить подробный дампинг модели стоимости в файлах отладочного дампа.Данная опция предусмотрена для использования при отладке компилятора.</target>
        </trans-unit>
        <trans-unit id="5698cf3230e865992f3f27c124b887d7d8c62160" translate="yes" xml:space="preserve">
          <source>Enable/disable bit-field layout compatible with the native Microsoft Windows compiler.</source>
          <target state="translated">Включение/выключение компоновки битовых полей,совместимой с родным компилятором Microsoft Windows.</target>
        </trans-unit>
        <trans-unit id="ec1922decad109f864b4cf7878296aa732c83b64" translate="yes" xml:space="preserve">
          <source>Enable/disable inlining of string operations.</source>
          <target state="translated">Включение/выключение встраивания операций со строками.</target>
        </trans-unit>
        <trans-unit id="77a9782fdfbab35d94a1e98b3a7fd934623ad240" translate="yes" xml:space="preserve">
          <source>Enable/disable the &lt;var&gt;__float128&lt;/var&gt; keyword for IEEE 128-bit floating point and use either software emulation for IEEE 128-bit floating point or hardware instructions.</source>
          <target state="translated">Включите / отключите ключевое слово &lt;var&gt;__float128&lt;/var&gt; для 128-битных операций с плавающей запятой IEEE и используйте либо программную эмуляцию для 128-битных операций с плавающей запятой IEEE, либо аппаратные инструкции.</target>
        </trans-unit>
        <trans-unit id="eef257e319b773e37c267992617c97ed3ff87e5c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and RSQRTPS instructions followed an additional Newton-Raphson step instead of doing a floating-point division.</source>
          <target state="translated">Включите/отключите генерацию инструкций RCPSS,RCPPS,RSQRTSS и RSQRTPS,которые следуют за дополнительным шагом Ньютона-Рафсона вместо деления с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="ce9687705ccc627a85aa74c6222e1c475cf39951" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of floating point that depends on IEEE arithmetic.</source>
          <target state="translated">Включить/выключить генерацию плавающей запятой,зависящей от арифметики IEEE.</target>
        </trans-unit>
        <trans-unit id="e06af20ef568b69c3362691eda73268a45b5e6fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the 3DNow! instructions.</source>
          <target state="translated">Включите/отключите генерацию инструкций 3DNow!</target>
        </trans-unit>
        <trans-unit id="8ea30fdab63dafe3dc7fc652cf67136424f3b625" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, and &lt;code&gt;sqrt&lt;/code&gt; instructions on the 387 floating-point unit.</source>
          <target state="translated">Включение / отключение генерации инструкций &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; и &lt;code&gt;sqrt&lt;/code&gt; в модуле 387 с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="d2ce898ea3fbbf85aca7bdcebad5257c4339a871" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the ADX instructions.</source>
          <target state="translated">Включите/отключите генерацию инструкций ADX.</target>
        </trans-unit>
        <trans-unit id="8c51cd7ffa80497e01030865d76bb3aa852e4b11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AES instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AES.</target>
        </trans-unit>
        <trans-unit id="139f5148751f41ac5e236f52ce09ecaba429fae5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX.</target>
        </trans-unit>
        <trans-unit id="c03537f2a6f562c3bdf507ee0385caa610905340" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX2 instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX2.</target>
        </trans-unit>
        <trans-unit id="2f46ca2cd644ae06703a20fd137f758ec86b545b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124FMAPS instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX5124FMAPS.</target>
        </trans-unit>
        <trans-unit id="07c3fb12af13a9cd69b78d9bc8b1bf44bce2f703" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124VNNIW instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX5124VNNIW.</target>
        </trans-unit>
        <trans-unit id="3754f28eb3ff315a901b1086241414b36cdc2445" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BITALG instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512BITALG.</target>
        </trans-unit>
        <trans-unit id="9d757b2f48a6a1b6957e3c46cfd35f8cef5e43f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BW instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512BW.</target>
        </trans-unit>
        <trans-unit id="d3c2cb946f575c062fed2315966b199b452fa19e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512CD instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512CD.</target>
        </trans-unit>
        <trans-unit id="55f4758594e3826b45c045f868cd0c0b6fe314a5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512DQ instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512DQ.</target>
        </trans-unit>
        <trans-unit id="868a5a7c9ba2cab10b4dbee05b59b72caa86a0f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512ER instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512ER.</target>
        </trans-unit>
        <trans-unit id="40cf4ec0c6bc30ab932552059f3f09cac003af63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512F instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512F.</target>
        </trans-unit>
        <trans-unit id="ba0e32798c4a1b18ba185f7a8c7a840f7e7480c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512IFMA instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512IFMA.</target>
        </trans-unit>
        <trans-unit id="cfee43efb9eef88de6b588ce9a55a47d1e02ac8b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512PF instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512PF.</target>
        </trans-unit>
        <trans-unit id="1d9376176900a884770b47d4b38ffe3800952fda" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512VBMI.</target>
        </trans-unit>
        <trans-unit id="5315cd056026db5157cf29bd04c56d18b6d556b6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI2 instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512VBMI2.</target>
        </trans-unit>
        <trans-unit id="ddf56de8dc48259cd81ab8285e90003fb25e73e2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VL instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512VL.</target>
        </trans-unit>
        <trans-unit id="26241a02deae96e24160a0ca3f3cc5c41033dbf3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VNNI instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512VNNI.</target>
        </trans-unit>
        <trans-unit id="84a8ab5234b9fa4c56baeffdaee98c552e89549f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций AVX512VPOPCNTDQ.</target>
        </trans-unit>
        <trans-unit id="dae7d1054e24eee8d8b487043aaad1fc5f1db574" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций BMI.</target>
        </trans-unit>
        <trans-unit id="3d72a8758536f6a87e94a41fe37b66f09beef533" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI2 instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций BMI2.</target>
        </trans-unit>
        <trans-unit id="b738e70323169015d6a48d84ae40dd6c29e5217d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLD before string moves.</source>
          <target state="translated">Включение/выключение генерации CLD перед перемещением строки.</target>
        </trans-unit>
        <trans-unit id="d65d8d65a18d1cfa6dc9c78ebdaad5ad563343cb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLDEMOTE instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций CLDEMOTE.</target>
        </trans-unit>
        <trans-unit id="ccb6f558360b355b894e7ea63cd154a997ed12e8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLFLUSHOPT instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций CLFLUSHOPT.</target>
        </trans-unit>
        <trans-unit id="f0801d5d70f8b9df1efe3aea49e8a0671ca5bfec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLWB instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций CLWB.</target>
        </trans-unit>
        <trans-unit id="94ecea85bbdafb56613082f3e5be7c02237756ed" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLZERO instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций CLZERO.</target>
        </trans-unit>
        <trans-unit id="f8d79a3c698ec42fbe32e73864266b011f951b2f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CMPXCHG16B instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций CMPXCHG16B.</target>
        </trans-unit>
        <trans-unit id="b0bd05f01479f2861886a517faf455f95df939c9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CRC32 instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций CRC32.</target>
        </trans-unit>
        <trans-unit id="d6440333fc0c90bc6217f92335430eaed3b0c3e6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the F16C instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций F16C.</target>
        </trans-unit>
        <trans-unit id="5cea65073f4a60c1177a3414fc29a42c91b72246" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций FMA.</target>
        </trans-unit>
        <trans-unit id="99871ac8f6615a85bb6ff6e756bf21d0a7db8138" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA4 instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций FMA4.</target>
        </trans-unit>
        <trans-unit id="4820cc9a7748ec354eac413d8f383da9dd67e717" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FSGSBASE instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций FSGSBASE.</target>
        </trans-unit>
        <trans-unit id="60644d857fe08e2846e93707df49f0bca9fb4a3e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FXSR instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций FXSR.</target>
        </trans-unit>
        <trans-unit id="0d58cb597f94125b583603aeaf0cb6d6fac80c1b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the GFNI instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций GFNI.</target>
        </trans-unit>
        <trans-unit id="9578e9d5e6eece4df004759dd7fc90f39eea18e0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the HLE instruction prefixes.</source>
          <target state="translated">Включить/выключить генерацию префиксов команд HLE.</target>
        </trans-unit>
        <trans-unit id="549533ddadf886e04d518c98906dae343a33a8ce" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LWP instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций LWP.</target>
        </trans-unit>
        <trans-unit id="8c3785d4101d06b824b0b36311920e0a30ccd2d9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LZCNT instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций LZCNT.</target>
        </trans-unit>
        <trans-unit id="574261210d9c97190453b59ddf32621dc2c86c69" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MMX instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций MMX.</target>
        </trans-unit>
        <trans-unit id="45a7da12e51c3e52b7908907f0dfac053d1882c4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVBE instructions.</source>
          <target state="translated">Включите/выключите генерацию инструкций MOVBE.</target>
        </trans-unit>
        <trans-unit id="75cfc04edcd4dee4218a715cae2bd3ac7fa16a7e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIR64B instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций MOVDIR64B.</target>
        </trans-unit>
        <trans-unit id="c6371db2050fdd103c6d197692dfd64140187f4a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIRI instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций MOVDIRI.</target>
        </trans-unit>
        <trans-unit id="6e98e7f5d53a1e3439a31b14070244368aebebfe" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MWAITX instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций MWAITX.</target>
        </trans-unit>
        <trans-unit id="dc37894f7a2ce025aaeba83cdca8f3ca819436f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCLMUL instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций PCLMUL.</target>
        </trans-unit>
        <trans-unit id="c6ecdb5d5fff5ea045de6d2ca8023861f04ebc4d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCONFIG instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций PCONFIG.</target>
        </trans-unit>
        <trans-unit id="a081a1e7a08745213d7883c3b5236130fe755e13" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PKU instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций PKU.</target>
        </trans-unit>
        <trans-unit id="e9e69747966699a82f308dbbadb71d6e9fb92d92" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the POPCNT instruction.</source>
          <target state="translated">Включение/выключение генерации инструкции POPCNT.</target>
        </trans-unit>
        <trans-unit id="f9ed3efe60bd11688e60a3f2cb5a1ff252d812d0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHW instruction.</source>
          <target state="translated">Включите/отключите генерацию команды PREFETCHW.</target>
        </trans-unit>
        <trans-unit id="006748470b229e9088cb61bc26a1257f2c9a8615" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHWT1 instructions.</source>
          <target state="translated">Включите/выключите генерацию инструкций PREFETCHWT1.</target>
        </trans-unit>
        <trans-unit id="2447c34a50f2bd64c3943526353f34051a55f5aa" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PTWRITE instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций PTWRITE.</target>
        </trans-unit>
        <trans-unit id="5735ee8db2baf84da1ef868849fd1bf84c1f8c11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDPID instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций RDPID.</target>
        </trans-unit>
        <trans-unit id="0b0a5749ac92e20b8e558766d0dd8d71d8adeeaf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDRND instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций RDRND.</target>
        </trans-unit>
        <trans-unit id="4913a7bcb28cb1f12173c4058eaf61ab9315d7d3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDSEED instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций RDSEED.</target>
        </trans-unit>
        <trans-unit id="300142c2ef84f7df525c1aa21af494a1e7bead9f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RTM instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций МРВ.</target>
        </trans-unit>
        <trans-unit id="0d2ad4e123ffd7abb18aa9c974df2646f0d5508c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SAHF instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций SAHF.</target>
        </trans-unit>
        <trans-unit id="632f005a4b74a3843a3298d0871cbe50c5ad6aa9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SGX instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций SGX.</target>
        </trans-unit>
        <trans-unit id="6b57bd12c5e2df48fa7d7e43ba31d0995c7f5553" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SHA instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций SHA.</target>
        </trans-unit>
        <trans-unit id="b5d7ecf6e517427fea4ad12abde111a42bd74cea" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций SSE.</target>
        </trans-unit>
        <trans-unit id="1f0972ae163067735798e2e6f4187300ae1137e4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE2 instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций SSE2.</target>
        </trans-unit>
        <trans-unit id="b03632fda4a2d3d92f1cf4eac7cca05dbc5a7516" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE3 instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций SSE3.</target>
        </trans-unit>
        <trans-unit id="5e9b999ddb7457a054d66bdaa2de1a8f647ad215" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4 instructions (both SSE4.1 and SSE4.2).</source>
          <target state="translated">Включение/выключение генерации инструкций SSE4 (как SSE4.1,так и SSE4.2).</target>
        </trans-unit>
        <trans-unit id="21d0ef801e5d8043d92d8c50dd3d6daaddab55a0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4A instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций SSE4A.</target>
        </trans-unit>
        <trans-unit id="ab7b78506bfd06d655fee8ea1068706000cbeacf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSSE3 instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций SSSE3.</target>
        </trans-unit>
        <trans-unit id="f0e97c519b39b4830d04c86470ddf48b233a76c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the TBM instructions.</source>
          <target state="translated">Включить/выключить генерацию инструкций по TBM.</target>
        </trans-unit>
        <trans-unit id="f3acd83d7172837bca3d0b44672674470b67ff86" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VAES instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций VAES.</target>
        </trans-unit>
        <trans-unit id="9789894eea8adf6b88ad98db26058bba573138b8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VPCLMULQDQ instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций VPCLMULQDQ.</target>
        </trans-unit>
        <trans-unit id="b524ba4aef3ce6873b5b0e11048e23307db06122" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WAITPKG instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций WAITPKG.</target>
        </trans-unit>
        <trans-unit id="a045e3b2a45d14170b9039170f7578c3d2713015" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WBNOINVD instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций WBNOINVD.</target>
        </trans-unit>
        <trans-unit id="e40cfbce647b2c7f9ddf7f4f626656cc3a1bc167" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XOP instructions.</source>
          <target state="translated">Включение/выключение генерации XOP инструкций.</target>
        </trans-unit>
        <trans-unit id="af8da63fa2d12d8f18afd42b233c4d37ee867c63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVE instructions.</source>
          <target state="translated">Включите/отключите генерацию инструкций XSAVE.</target>
        </trans-unit>
        <trans-unit id="1233b5b867e3f5dba2db3c438d3d6df18bde5ef8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEC instructions.</source>
          <target state="translated">Включите/отключите генерацию инструкций XSAVEC.</target>
        </trans-unit>
        <trans-unit id="a0a9e371f8da9a97cd65e604007429c825f18769" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEOPT instructions.</source>
          <target state="translated">Включение/выключение генерации инструкций XSAVEOPT.</target>
        </trans-unit>
        <trans-unit id="40e3ea0db494aa36d313e852fcbfd0f81556503b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVES instructions.</source>
          <target state="translated">Включите/отключите генерацию инструкций XSAVES.</target>
        </trans-unit>
        <trans-unit id="fe009b6bf64ee12df513906e2d5837b5e1c97910" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the advanced bit instructions.</source>
          <target state="translated">Включение/выключение генерации расширенных битовых инструкций.</target>
        </trans-unit>
        <trans-unit id="da867b2b85cc94070610ef36f96c5698f745a3ec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the enhanced 3DNow! instructions.</source>
          <target state="translated">Включите/отключите генерацию расширенных инструкций 3DNow!</target>
        </trans-unit>
        <trans-unit id="7b3bd531bffe003f20aeec31cfccd8602793b41a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the inline code to do small string operations and calling the library routines for large operations.</source>
          <target state="translated">Включение/выключение генерации встроенного кода для выполнения небольших строковых операций и вызова библиотечных процедур для больших операций.</target>
        </trans-unit>
        <trans-unit id="902acc4f79ae76c2d32a7b6c514f8deac67c62fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.1 instructions.</source>
          <target state="translated">Включите/отключите генерацию инструкций sse4.1.</target>
        </trans-unit>
        <trans-unit id="2a2818a0c367c053dac063d194f234ec531d06f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.2 instructions.</source>
          <target state="translated">Включите/отключите генерацию инструкций sse4.2.</target>
        </trans-unit>
        <trans-unit id="37e917a07fa74d7e4e6dadb9579fbc16f97ae659" translate="yes" xml:space="preserve">
          <source>Enable/disable the shadow stack built-in functions from CET.</source>
          <target state="translated">Включение/выключение встроенных функций теневого стека из CET.</target>
        </trans-unit>
        <trans-unit id="e907f9b58bf0706e2b41d509db8ed99ad239f467" translate="yes" xml:space="preserve">
          <source>Enable/disable using ISA 3.0 hardware instructions to support the &lt;var&gt;__float128&lt;/var&gt; data type.</source>
          <target state="translated">Включение / отключение с помощью аппаратных инструкций ISA 3.0 для поддержки &lt;var&gt;__float128&lt;/var&gt; данных __float128 .</target>
        </trans-unit>
        <trans-unit id="41e598e82b094b60e50ff17f84b1a81de5e43516" translate="yes" xml:space="preserve">
          <source>Enabled at level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b32f2d1dc57603e53cae07a8b8cf8dd5b0f7205" translate="yes" xml:space="preserve">
          <source>Enabled at levels</source>
          <target state="translated">Включено на уровнях</target>
        </trans-unit>
        <trans-unit id="a2d7a1ae5b45c7663ff5c6c74c01638ab9ca0806" translate="yes" xml:space="preserve">
          <source>Enabled by</source>
          <target state="translated">Приглашаем</target>
        </trans-unit>
        <trans-unit id="87971a35b8aed293eb3378e3d8ac5721ecb5cb96" translate="yes" xml:space="preserve">
          <source>Enabled by default at</source>
          <target state="translated">По умолчанию включено на</target>
        </trans-unit>
        <trans-unit id="bcd7c586f5c724dfc09404aaf2a878d0206e9f76" translate="yes" xml:space="preserve">
          <source>Enabled by default when</source>
          <target state="translated">Включено по умолчанию,когда</target>
        </trans-unit>
        <trans-unit id="4f94ea1c93e5664c46cd416ea64f7cc9936467d8" translate="yes" xml:space="preserve">
          <source>Enabled by default with</source>
          <target state="translated">По умолчанию включено с</target>
        </trans-unit>
        <trans-unit id="261c7b9c3b776bec501c26a9d2fe4d480d9d16f7" translate="yes" xml:space="preserve">
          <source>Enabled by default.</source>
          <target state="translated">Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d3d5b773827f9c4413a2fc452aae96dd06f591fd" translate="yes" xml:space="preserve">
          <source>Enabled for Alpha, AArch64 and x86 at levels</source>
          <target state="translated">Включено для Alpha,AArch64 и x86 на уровнях</target>
        </trans-unit>
        <trans-unit id="217f8e562e876828812e90f53725615d6901cc9d" translate="yes" xml:space="preserve">
          <source>Enabled for x86 at levels</source>
          <target state="translated">Включено для x86 на уровнях</target>
        </trans-unit>
        <trans-unit id="44ce21fc6a64ad296ee8e3cda3bcb2b9759adebf" translate="yes" xml:space="preserve">
          <source>Enabled with</source>
          <target state="translated">Включено с</target>
        </trans-unit>
        <trans-unit id="979f6df4ed2e6e9238efa8b3ebc9f087264e476a" translate="yes" xml:space="preserve">
          <source>Enables (</source>
          <target state="translated">Позволяет (</target>
        </trans-unit>
        <trans-unit id="7eae3793cec99e5fa487fe453e12770d55076d5b" translate="yes" xml:space="preserve">
          <source>Enables (or disables) reading and writing of 16- and 32- bit values from addresses that are not 16- or 32- bit aligned. By default unaligned access is disabled for all pre-ARMv6, all ARMv6-M and for ARMv8-M Baseline architectures, and enabled for all other architectures. If unaligned access is not enabled then words in packed data structures are accessed a byte at a time.</source>
          <target state="translated">Разрешает (или запрещает)чтение и запись 16-и 32-битных значений из адресов,которые не выровнены по 16-или 32-битным параметрам.По умолчанию доступ без выравнивания отключен для всех архитектур preARMv6,всех ARMv6-M и ARMv8-M Baseline,а также включен для всех остальных архитектур.Если не включен не выровненный доступ,то доступ к словам в структурах упакованных данных осуществляется по одному байту за раз.</target>
        </trans-unit>
        <trans-unit id="b65eaeca3be0a544da578e950cb68230b9d67b03" translate="yes" xml:space="preserve">
          <source>Enables IVC2 scheduling. IVC2 is a 64-bit VLIW coprocessor.</source>
          <target state="translated">Включает планирование IVC2.IVC2-64-битный сопроцессор VLIW.</target>
        </trans-unit>
        <trans-unit id="f8bfc926b8449de54aa34c3f95b4955d0fe52d4e" translate="yes" xml:space="preserve">
          <source>Enables all inter-procedural analysis dumps.</source>
          <target state="translated">Включает все свалки межпроцедурного анализа.</target>
        </trans-unit>
        <trans-unit id="39e032a23d350be5be02b628822ab23ba3864dfe" translate="yes" xml:space="preserve">
          <source>Enables all the optional instructions&amp;mdash;average, multiply, divide, bit operations, leading zero, absolute difference, min/max, clip, and saturation.</source>
          <target state="translated">Включает все необязательные инструкции - усреднение, умножение, деление, битовые операции, начальный ноль, абсолютную разность, мин. / Макс., Обрезку и насыщенность.</target>
        </trans-unit>
        <trans-unit id="dcd06b68e12a4e252dc788f4fd7792582f994c23" translate="yes" xml:space="preserve">
          <source>Enables expression of values of induction variables in later iterations of the unrolled loop using the value in the first iteration. This breaks long dependency chains, thus improving efficiency of the scheduling passes.</source>
          <target state="translated">Позволяет выражать значения индукционных переменных в последующих итерациях разворачиваемого цикла,используя значение в первой итерации.Это разбивает длинные цепочки зависимостей,повышая тем самым эффективность проходов по расписанию.</target>
        </trans-unit>
        <trans-unit id="7564b980df27ae9794a4d64f8c88854f784c151d" translate="yes" xml:space="preserve">
          <source>Enables or disables the use of the string manipulation instructions &lt;code&gt;SMOVF&lt;/code&gt;, &lt;code&gt;SCMPU&lt;/code&gt;, &lt;code&gt;SMOVB&lt;/code&gt;, &lt;code&gt;SMOVU&lt;/code&gt;, &lt;code&gt;SUNTIL&lt;/code&gt;&lt;code&gt;SWHILE&lt;/code&gt; and also the &lt;code&gt;RMPA&lt;/code&gt; instruction. These instructions may prefetch data, which is not safe to do if accessing an I/O register. (See section 12.2.7 of the RX62N Group User&amp;rsquo;s Manual for more information).</source>
          <target state="translated">Включает или отключает использование команд &lt;code&gt;SMOVF&lt;/code&gt; строк SMOVF , &lt;code&gt;SCMPU&lt;/code&gt; , &lt;code&gt;SMOVB&lt;/code&gt; , &lt;code&gt;SMOVU&lt;/code&gt; , &lt;code&gt;SUNTIL&lt;/code&gt; &lt;code&gt;SWHILE&lt;/code&gt; , а также инструкции &lt;code&gt;RMPA&lt;/code&gt; . Эти инструкции могут выполнять предварительную выборку данных, что небезопасно при доступе к регистру ввода-вывода. (Для получения дополнительной информации см. Раздел 12.2.7 Руководства пользователя RX62N Group).</target>
        </trans-unit>
        <trans-unit id="b2d56a3e8dc64cdea92b5b177de5eee2ddc022a5" translate="yes" xml:space="preserve">
          <source>Enables support for &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;long long&lt;/code&gt; types to be aligned on 8-byte boundaries. The default is to restrict the alignment of all objects to at most 4-bytes. When</source>
          <target state="translated">Включает поддержку типов &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;long long&lt;/code&gt; для выравнивания по 8-байтовым границам. По умолчанию выравнивание всех объектов ограничивается 4 байтами. когда</target>
        </trans-unit>
        <trans-unit id="85b9ecfc95ed087be71f719ded533eb947f09555" translate="yes" xml:space="preserve">
          <source>Enables support for all single- and double-precision floating-point hardware extensions. Not available for ARC EM.</source>
          <target state="translated">Обеспечивает поддержку всех аппаратных расширений с плавающей запятой одинарной и двойной точности.Не доступно для ARC EM.</target>
        </trans-unit>
        <trans-unit id="f75e5afbbe9ab70b1263a70cb8894e0664caf0b1" translate="yes" xml:space="preserve">
          <source>Enables support for all single-precision floating-point hardware extensions.</source>
          <target state="translated">Обеспечивает поддержку всех аппаратных расширений с плавающей запятой с одинаковой точностью.</target>
        </trans-unit>
        <trans-unit id="7883565cb4fb9258e363d1f2d7f38e140fa66bc4" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point and fused multiply and add hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">Обеспечивает поддержку операций с плавающей запятой двойной точности и объединенного умножения и добавления аппаратных расширений. Эта опция включает опцию '</target>
        </trans-unit>
        <trans-unit id="09688a51318111fb1133a1873f85c86a0dd2d24a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. All single-precision floating-point hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">Обеспечивает поддержку аппаратных расширений с плавающей запятой двойной точности с помощью вспомогательных инструкций двойной точности.Также включены все аппаратные расширения с плавающей запятой с одинарной точностью.Эта опция доступна только для ARC EM.</target>
        </trans-unit>
        <trans-unit id="998d962adb014531e7dc98dfd0f68752292543ee" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point and fused multiply and add hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">Обеспечивает поддержку аппаратных расширений с плавающей запятой двойной точности с помощью вспомогательных инструкций двойной точности.Также включена поддержка умножения и добавления аппаратных расширений с плавающей запятой с одинарной точностью.Эта опция доступна только для ARC EM.</target>
        </trans-unit>
        <trans-unit id="4d9fab6d5bc5404d7e456a561365555b9e55a46b" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point extension is also enabled. This option is only available for ARC EM.</source>
          <target state="translated">Обеспечивает поддержку аппаратных расширений с плавающей запятой двойной точности с помощью вспомогательных инструкций двойной точности.Также включено расширение с плавающей запятой с одинарной точностью.Эта опция доступна только для ARC EM.</target>
        </trans-unit>
        <trans-unit id="8714aef39627cf0d1b3a7e36332dd7526fef4382" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point, square-root, and divide extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">Обеспечивает поддержку аппаратных расширений с плавающей запятой двойной точности с помощью вспомогательных инструкций двойной точности.Также включены расширения с плавающей точкой одинарной точности,квадратного корня и разделения.Эта опция доступна только для ARC EM.</target>
        </trans-unit>
        <trans-unit id="88614dbf859eb550fe6ea83089c08ee2a35b6c5a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions. The single-precision floating-point extension is also enabled. Not available for ARC EM.</source>
          <target state="translated">Обеспечивает поддержку аппаратных расширений с плавающей запятой двойной точности.Также включено расширение с плавающей запятой с одинарной точностью.Не доступно для ARC EM.</target>
        </trans-unit>
        <trans-unit id="ed75b445d9416dbdcca6532a5b9e4ba16b46347a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point, square-root and divide hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">Включает поддержку аппаратных расширений двойной точности с плавающей запятой, извлечения квадратного корня и деления. Эта опция включает опцию '</target>
        </trans-unit>
        <trans-unit id="4020a8753a0799a59f9043cec8f1b76a8cbf21f5" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point and fused multiply and add hardware extensions.</source>
          <target state="translated">Обеспечивает поддержку одноточного умножения с плавающей запятой и умножения с плавающей запятой,а также добавления аппаратных расширений.</target>
        </trans-unit>
        <trans-unit id="739ef3a6f4ad193608707def042ed976fbb38794" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point hardware extensions.</source>
          <target state="translated">Обеспечивает поддержку аппаратных расширений с плавающей запятой с одинарной точностью.</target>
        </trans-unit>
        <trans-unit id="69030e58955d3b24f425bf1f743dd072b9ea41e4" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point, square-root and divide hardware extensions.</source>
          <target state="translated">Обеспечивает поддержку аппаратных расширений с плавающей точкой,квадратным корнем и разделением с одинарной точностью.</target>
        </trans-unit>
        <trans-unit id="dd589dcd1e2f89f81d2aa1944b9d5b300d0537d9" translate="yes" xml:space="preserve">
          <source>Enables support for specific floating-point hardware extensions for ARCv2 cores. Supported values for &lt;var&gt;fpu&lt;/var&gt; are:</source>
          <target state="translated">Включает поддержку определенных аппаратных расширений с плавающей запятой для ядер ARCv2. Поддерживаемые значения для &lt;var&gt;fpu&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="40edc654abf50990a91d4feb4df5e9d34bf7f47f" translate="yes" xml:space="preserve">
          <source>Enables support for the RH850 version of the V850 ABI. This is the default. With this version of the ABI the following rules apply:</source>
          <target state="translated">Включает поддержку RH850 версии V850 ABI.По умолчанию.К этой версии ABI применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="a3ccc0d52f2a100abeb7168c2966e22df181fb16" translate="yes" xml:space="preserve">
          <source>Enables support for the old GCC version of the V850 ABI. With this version of the ABI the following rules apply:</source>
          <target state="translated">Включает поддержку старой GCC версии V850 ABI.К этой версии ABI применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="13d14b8a88583d4801772d41f78d731f585ac76d" translate="yes" xml:space="preserve">
          <source>Enables the 32-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">Включает инструкции 32-битного сопроцессора.</target>
        </trans-unit>
        <trans-unit id="37f8bcfc01e8c9f171283b3e6b96664748ea2f0b" translate="yes" xml:space="preserve">
          <source>Enables the 64-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">Включает инструкции 64-битного сопроцессора.</target>
        </trans-unit>
        <trans-unit id="866afe4dc503faaed460c73ebf4e30e8a9116810" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;abs&lt;/code&gt; instruction, which is the absolute difference between two registers.</source>
          <target state="translated">Включает инструкцию &lt;code&gt;abs&lt;/code&gt; , которая представляет собой абсолютную разницу между двумя регистрами.</target>
        </trans-unit>
        <trans-unit id="50cf3b6e541adf62bd77b142fc53a61d05fc7c9c" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;ave&lt;/code&gt; instruction, which computes the average of two registers.</source>
          <target state="translated">Включает инструкцию &lt;code&gt;ave&lt;/code&gt; , которая вычисляет среднее значение двух регистров.</target>
        </trans-unit>
        <trans-unit id="2e8478914d75d996b9e9464d4ca7119db6662af4" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;clip&lt;/code&gt; instruction. Note that</source>
          <target state="translated">Включает инструкцию &lt;code&gt;clip&lt;/code&gt; . Обратите внимание, что</target>
        </trans-unit>
        <trans-unit id="e97f2d1656d0f25d2a745cdd7d099a3de6f71833" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions.</source>
          <target state="translated">Включает инструкции &lt;code&gt;div&lt;/code&gt; и &lt;code&gt;divu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13fbaebc3f1567a809a1ff5ab5607726671f6a6a" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;leadz&lt;/code&gt; (leading zero) instruction.</source>
          <target state="translated">Включает &lt;code&gt;leadz&lt;/code&gt; (ведущий ноль).</target>
        </trans-unit>
        <trans-unit id="1da519d84df5ff1b705dd7abe77d948ec006a771" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; instructions.</source>
          <target state="translated">Включает инструкции &lt;code&gt;min&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4da5357bac4df4fb4da7516696ce5726e90631ac" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;repeat&lt;/code&gt; and &lt;code&gt;erepeat&lt;/code&gt; instructions, used for low-overhead looping.</source>
          <target state="translated">Включает инструкции &lt;code&gt;repeat&lt;/code&gt; и &lt;code&gt;erepeat&lt;/code&gt; , используемые для цикла с низкими накладными расходами.</target>
        </trans-unit>
        <trans-unit id="b4f230bdb2809992da1b8ee11728eb1397ea6487" translate="yes" xml:space="preserve">
          <source>Enables the bit operation instructions&amp;mdash;bit test (&lt;code&gt;btstm&lt;/code&gt;), set (&lt;code&gt;bsetm&lt;/code&gt;), clear (&lt;code&gt;bclrm&lt;/code&gt;), invert (&lt;code&gt;bnotm&lt;/code&gt;), and test-and-set (&lt;code&gt;tas&lt;/code&gt;).</source>
          <target state="translated">Включает инструкции битовых операций - битовая проверка ( &lt;code&gt;btstm&lt;/code&gt; ), установка ( &lt;code&gt;bsetm&lt;/code&gt; ), очистка ( &lt;code&gt;bclrm&lt;/code&gt; ), инвертирование ( &lt;code&gt;bnotm&lt;/code&gt; ) и проверка и установка ( &lt;code&gt;tas&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="650b34422af73f1c39adc7884ebaf0f44be9cbe6" translate="yes" xml:space="preserve">
          <source>Enables the coprocessor instructions. By default, this is a 32-bit coprocessor. Note that the coprocessor is normally enabled via the</source>
          <target state="translated">Включает инструкции сопроцессора.По умолчанию это 32-битный сопроцессор.Обратите внимание,что обычно сопроцессор включается через команду</target>
        </trans-unit>
        <trans-unit id="849d54c65b67142ad3610bf0ff41505e124671a1" translate="yes" xml:space="preserve">
          <source>Enables the cryptographic instructions on &amp;lsquo;</source>
          <target state="translated">Включает криптографические инструкции на '</target>
        </trans-unit>
        <trans-unit id="e300897cde7331a4be041e33bbcd7fc9ca650ebe" translate="yes" xml:space="preserve">
          <source>Enables the generation of position independent data. When enabled any access to constant data is done via an offset from a base address held in a register. This allows the location of constant data to be determined at run time without requiring the executable to be relocated, which is a benefit to embedded applications with tight memory constraints. Data that can be modified is not affected by this option.</source>
          <target state="translated">Позволяет генерировать данные,не зависящие от позиции.При включении любой доступ к постоянным данным осуществляется через смещение от базового адреса,находящегося в регистре.Это позволяет определять местоположение постоянных данных во время выполнения,не требуя перемещения исполняемого файла,что является преимуществом для встроенных приложений с жесткими ограничениями по памяти.На данные,которые могут быть изменены,эта опция не влияет.</target>
        </trans-unit>
        <trans-unit id="cf1918bfd22c209206d2846ea3d88a19e3a73f7d" translate="yes" xml:space="preserve">
          <source>Enables the loop invariant motion pass in the RTL loop optimizer. Enabled at level</source>
          <target state="translated">Включает проход инвариантного движения в цикле RTL-оптимизатора.Включено на уровне</target>
        </trans-unit>
        <trans-unit id="ecd974872f6eca7f7d4ae7dac04ee2a0a333973d" translate="yes" xml:space="preserve">
          <source>Enables the multiplication and multiply-accumulate instructions.</source>
          <target state="translated">Включает инструкции по умножению и умножению.</target>
        </trans-unit>
        <trans-unit id="7fc40693c14939b54a70a171fa80eb19af8d1f4b" translate="yes" xml:space="preserve">
          <source>Enables the saturation instructions. Note that the compiler does not currently generate these itself, but this option is included for compatibility with other tools, like &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">Включает инструкции по насыщению. Обратите внимание, что компилятор в настоящее время не генерирует их сам, но эта опция включена для совместимости с другими инструментами, такими &lt;code&gt;as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d7284a520ac6d5afcc167354eeade161094006" translate="yes" xml:space="preserve">
          <source>Enables the use of a linker plugin during link-time optimization. This option relies on plugin support in the linker, which is available in gold or in GNU ld 2.21 or newer.</source>
          <target state="translated">Позволяет использовать плагин компоновщика во время линковой оптимизации.Этот вариант полагается на поддержку подключаемых модулей в компоновщике,который доступен в золоте или в GNU ld 2.21 или новее.</target>
        </trans-unit>
        <trans-unit id="118989c6873866bc4e811127fbd742299b49d5aa" translate="yes" xml:space="preserve">
          <source>Enables the use of the e3v5 LOOP instruction. The use of this instruction is not enabled by default when the e3v5 architecture is selected because its use is still experimental.</source>
          <target state="translated">Позволяет использовать инструкцию LOOP e3v5.Использование этой инструкции не включено по умолчанию,когда выбрана архитектура e3v5,так как ее использование все еще экспериментальное.</target>
        </trans-unit>
        <trans-unit id="e218c1fa9772e443eea87ffbfc5f0dee5a840cd5" translate="yes" xml:space="preserve">
          <source>Enables using Neon to handle scalar 64-bits operations. This is disabled by default since the cost of moving data from core registers to Neon is high.</source>
          <target state="translated">Позволяет использовать Neon для обработки скалярных 64-битных операций.По умолчанию это отключено,так как стоимость переноса данных из регистров ядра в Неон высока.</target>
        </trans-unit>
        <trans-unit id="93ce405e36a27a5a639a5f340a06317ff8160589" translate="yes" xml:space="preserve">
          <source>Enabling profiling and extra run-time error checking.</source>
          <target state="translated">Включение профилирования и дополнительной проверки на ошибки во время выполнения.</target>
        </trans-unit>
        <trans-unit id="e90d4bd4a0cd6ad11d1267ee1ab362b6754a6129" translate="yes" xml:space="preserve">
          <source>Enabling this option effectively enables the following warnings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="1819780111faf7544a66daa1d16d7611734230e4" translate="yes" xml:space="preserve">
          <source>End lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; or stronger.</source>
          <target state="translated">Завершение снятия блокировки по переменной блокировки. Порядок памяти должен быть &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; или выше.</target>
        </trans-unit>
        <trans-unit id="69cc11cd813a9fd03e4e1fc6cf5b510b36e19495" translate="yes" xml:space="preserve">
          <source>Enforces total ordering with all other &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; operations.</source>
          <target state="translated">Обеспечивает полное упорядочение со всеми другими операциями &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73b1dc6c07adcccbcc5d5e8b0eff931a874c6d38" translate="yes" xml:space="preserve">
          <source>Enumerator Attributes</source>
          <target state="translated">Атрибуты регистратора</target>
        </trans-unit>
        <trans-unit id="761809a73bf6c1d0fb389d9bcb324c7d577436ca" translate="yes" xml:space="preserve">
          <source>Env vars that affect GCC.</source>
          <target state="translated">Энва-вары,которые влияют на GCC.</target>
        </trans-unit>
        <trans-unit id="ea26afcbc28cf64cc5104756e2576f023e89221a" translate="yes" xml:space="preserve">
          <source>Epiphany&amp;mdash;</source>
          <target state="translated">Epiphany&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="fdd6abe4d3e43555fd6a8a4c1cf45b848e487e53" translate="yes" xml:space="preserve">
          <source>Equivalent to</source>
          <target state="translated">Эквивалентно</target>
        </trans-unit>
        <trans-unit id="0492deafa8eba22fc0afe8f6e0c0ba64239ba223" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;r&lt;/code&gt;; retained for backwards compatibility.</source>
          <target state="translated">Эквивалентно &lt;code&gt;r&lt;/code&gt; ; сохранен для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="5ca07fcd394d3a2e5866991bf00cbd021a139de4" translate="yes" xml:space="preserve">
          <source>Errors in the 1990 ISO C standard were corrected in two Technical Corrigenda published in 1994 and 1996. GCC does not support the uncorrected version.</source>
          <target state="translated">Ошибки в стандарте ИСО С 1990 года были исправлены в двух технических исправлениях,опубликованных в 1994 и 1996 годах.GCC не поддерживает неисправленную версию.</target>
        </trans-unit>
        <trans-unit id="9bd134a89f5b4b95f3127d3f912224b4af14b70c" translate="yes" xml:space="preserve">
          <source>Errors in the 1999 ISO C standard were corrected in three Technical Corrigenda published in 2001, 2004 and 2007. GCC does not support the uncorrected version.</source>
          <target state="translated">Ошибки в стандарте ISO C 1999 года были исправлены в трех технических исправлениях,опубликованных в 2001,2004 и 2007 годах.GCC не поддерживает неисправленную версию.</target>
        </trans-unit>
        <trans-unit id="6e25566cabac14a5da9bfa8653af8b052717aff4" translate="yes" xml:space="preserve">
          <source>Estimate on average number of instructions that are executed before prefetch finishes. The distance prefetched ahead is proportional to this constant. Increasing this number may also lead to less streams being prefetched (see</source>
          <target state="translated">Оцените среднее количество инструкций,которые выполняются до окончания предварительной трассировки.Расстояние,заданное впереди,пропорционально этой константе.Увеличение этого числа может также привести к уменьшению количества потоков,которые будут предварительно выбраны (см.</target>
        </trans-unit>
        <trans-unit id="72b4ac99601ca6a847d5bc2efd8309225cad447d" translate="yes" xml:space="preserve">
          <source>Evaluate member access, array subscripting, and shift expressions in left-to-right order, and evaluate assignment in right-to-left order, as adopted for C++17. Enabled by default with</source>
          <target state="translated">Оцените доступ к членам,подписывание массивов и сдвиг выражений в порядке слева направо,а также оцените присваивание в порядке справа налево,как это принято для C++17.По умолчанию включено с</target>
        </trans-unit>
        <trans-unit id="ed6e92089eb6b24b347c4f30cb7670720994b11e" translate="yes" xml:space="preserve">
          <source>Even if</source>
          <target state="translated">пусть даже и</target>
        </trans-unit>
        <trans-unit id="8ba62c67150da80165ae50905d020111dae00562" translate="yes" xml:space="preserve">
          <source>Even if a recovery mode is turned on the compiler side, it needs to be also enabled on the runtime library side, otherwise the failures are still fatal. The runtime library defaults to &lt;code&gt;halt_on_error=0&lt;/code&gt; for ThreadSanitizer and UndefinedBehaviorSanitizer, while default value for AddressSanitizer is &lt;code&gt;halt_on_error=1&lt;/code&gt;. This can be overridden through setting the &lt;code&gt;halt_on_error&lt;/code&gt; flag in the corresponding environment variable.</source>
          <target state="translated">Даже если режим восстановления включен на стороне компилятора, его необходимо также включить на стороне библиотеки времени выполнения, в противном случае сбои все равно будут фатальными. По умолчанию для библиотеки времени выполнения &lt;code&gt;halt_on_error=0&lt;/code&gt; для ThreadSanitizer и UndefinedBehaviorSanitizer, а значение по умолчанию для AddressSanitizer - &lt;code&gt;halt_on_error=1&lt;/code&gt; . Это можно &lt;code&gt;halt_on_error&lt;/code&gt; установив флаг halt_on_error в соответствующей переменной среды.</target>
        </trans-unit>
        <trans-unit id="da53370f643fa43e1823dc15023009c950cb897a" translate="yes" xml:space="preserve">
          <source>Even if a zero-length bit-field is not followed by a normal bit-field, it may still affect the alignment of the structure:</source>
          <target state="translated">Даже если за битовым полем нулевой длины не следует обычное битовое поле,это все равно может повлиять на выравнивание структуры:</target>
        </trans-unit>
        <trans-unit id="9b825b64ce454de632ebee37b594db5436e47422" translate="yes" xml:space="preserve">
          <source>Even if this switch is enabled, not all function calls are turned into long calls. The heuristic is that static functions, functions that have the &lt;code&gt;short_call&lt;/code&gt; attribute, functions that are inside the scope of a &lt;code&gt;#pragma no_long_calls&lt;/code&gt; directive, and functions whose definitions have already been compiled within the current compilation unit are not turned into long calls. The exceptions to this rule are that weak function definitions, functions with the &lt;code&gt;long_call&lt;/code&gt; attribute or the &lt;code&gt;section&lt;/code&gt; attribute, and functions that are within the scope of a &lt;code&gt;#pragma long_calls&lt;/code&gt; directive are always turned into long calls.</source>
          <target state="translated">Даже если этот переключатель включен, не все вызовы функций превращаются в длинные вызовы. Эвристика состоит в том, что статические функции, функции с атрибутом &lt;code&gt;short_call&lt;/code&gt; , функции, находящиеся в области действия директивы &lt;code&gt;#pragma no_long_calls&lt;/code&gt; , и функции, определения которых уже были скомпилированы в текущей единице компиляции, не превращаются в длинные вызовы. Исключения из этого правила состоят в том, что слабые определения функций, функции с атрибутом &lt;code&gt;long_call&lt;/code&gt; или атрибутом &lt;code&gt;section&lt;/code&gt; , а также функции, &lt;code&gt;#pragma long_calls&lt;/code&gt; в область действия директивы #pragma long_calls , всегда превращаются в длинные вызовы.</target>
        </trans-unit>
        <trans-unit id="a177b98fd2580c16f017a412cd7670171b404cf0" translate="yes" xml:space="preserve">
          <source>Even if you specify</source>
          <target state="translated">Даже если вы укажете</target>
        </trans-unit>
        <trans-unit id="026e995923c6387a8240f24bd1c3774f9d66883c" translate="yes" xml:space="preserve">
          <source>Even register</source>
          <target state="translated">Равномерный регистр</target>
        </trans-unit>
        <trans-unit id="1873ee5db4140cfb18dab53240c9f43c6ee8669a" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;sum&lt;/code&gt; is accumulated in the loop, no use is made of that summation, so the accumulation can be removed.</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;sum&lt;/code&gt; накапливается в цикле, это суммирование не используется, поэтому накопление можно удалить.</target>
        </trans-unit>
        <trans-unit id="0b22f73b585732fa4671fb4003533ee7b0a1cf1d" translate="yes" xml:space="preserve">
          <source>Even-numbered D register</source>
          <target state="translated">Чётный D-образный регистр</target>
        </trans-unit>
        <trans-unit id="7a684983474ccc7c72520e56a87f8aeb051b1c6b" translate="yes" xml:space="preserve">
          <source>Even-numbered accumulator register.</source>
          <target state="translated">Равномерный регистр аккумулятора.</target>
        </trans-unit>
        <trans-unit id="5d57aa9755d20359a2247e4c26c56f18f53bb2c4" translate="yes" xml:space="preserve">
          <source>Every data object has an alignment requirement. The alignment requirement for all data except structures, unions, and arrays is either the size of the object or the current packing size (specified with either the &lt;code&gt;aligned&lt;/code&gt; attribute or the &lt;code&gt;pack&lt;/code&gt; pragma), whichever is less. For structures, unions, and arrays, the alignment requirement is the largest alignment requirement of its members. Every object is allocated an offset so that:</source>
          <target state="translated">Каждый объект данных требует выравнивания. Требование выравнивания для всех данных, кроме структур, объединений и массивов, - это либо размер объекта, либо текущий размер упаковки (указанный либо с помощью атрибута &lt;code&gt;aligned&lt;/code&gt; либо с помощью прагмы &lt;code&gt;pack&lt;/code&gt; ), в зависимости от того, что меньше. Для структур, объединений и массивов требование выравнивания является самым большим требованием выравнивания их элементов. Каждому объекту назначается смещение, чтобы:</target>
        </trans-unit>
        <trans-unit id="f8971cb366f8a5972e5437f17d61872668933fb6" translate="yes" xml:space="preserve">
          <source>Exact power of 2</source>
          <target state="translated">Точная мощность 2</target>
        </trans-unit>
        <trans-unit id="54ce059465b2a026c1f41bec2bf7eb93331ac554" translate="yes" xml:space="preserve">
          <source>Exactly like</source>
          <target state="translated">В точности как</target>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
        <trans-unit id="861245b8779c3c0a240081e66f72046983ca7d16" translate="yes" xml:space="preserve">
          <source>Example usage</source>
          <target state="translated">Пример использования</target>
        </trans-unit>
        <trans-unit id="98859dfb330cbeca8950e6e5316d288484dfa387" translate="yes" xml:space="preserve">
          <source>Example usage of these low level built-in functions may look like:</source>
          <target state="translated">Пример использования этих низкоуровневых встроенных функций может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="3203ec56f6623a12f68979ebebcaf218b0674056" translate="yes" xml:space="preserve">
          <source>Examples of code with undefined behavior are &lt;code&gt;a = a++;&lt;/code&gt;, &lt;code&gt;a[n]
= b[n++]&lt;/code&gt; and &lt;code&gt;a[i++] = i;&lt;/code&gt;. Some more complicated cases are not diagnosed by this option, and it may give an occasional false positive result, but in general it has been found fairly effective at detecting this sort of problem in programs.</source>
          <target state="translated">Примеры кода с неопределенным поведением: &lt;code&gt;a = a++;&lt;/code&gt; , &lt;code&gt;a[n] = b[n++]&lt;/code&gt; и &lt;code&gt;a[i++] = i;&lt;/code&gt; , Некоторые более сложные случаи не диагностируются с помощью этой опции, и иногда она может давать ложноположительный результат, но в целом она оказалась достаточно эффективной для обнаружения такого рода проблем в программах.</target>
        </trans-unit>
        <trans-unit id="ac2978569b0d96ea67fa55ae3fcac3a58dbeaa7e" translate="yes" xml:space="preserve">
          <source>Examples of the use cases for this tool are:</source>
          <target state="translated">Примеры использования этого инструмента:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="911d893025886382ab91769b068aa06459b40499" translate="yes" xml:space="preserve">
          <source>Exception handlers differ from interrupt handlers because the system pushes an error code on the stack. An exception handler declaration is similar to that for an interrupt handler, but with a different mandatory function signature. The compiler arranges to pop the error code off the stack before the &lt;code&gt;IRET&lt;/code&gt; instruction.</source>
          <target state="translated">Обработчики исключений отличаются от обработчиков прерываний, поскольку система помещает код ошибки в стек. Объявление обработчика исключений аналогично объявлению обработчика прерывания, но с другой обязательной сигнатурой функции. Компилятор организует выталкивание кода ошибки из стека перед инструкцией &lt;code&gt;IRET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d60ce999e28bc42ef5590e1790afd26bd6f33f60" translate="yes" xml:space="preserve">
          <source>Exception handlers should only be used for exceptions that push an error code; you should use an interrupt handler in other cases. The system will crash if the wrong kind of handler is used.</source>
          <target state="translated">Обработчики исключений должны использоваться только для исключений,которые подталкивают код ошибки;в других случаях следует использовать обработчики прерываний.При использовании ошибочного обработчика система аварийно завершает свою работу.</target>
        </trans-unit>
        <trans-unit id="61c358f1bb209146fb6ebbb188045ae7738fdddb" translate="yes" xml:space="preserve">
          <source>Execution and Data Prediction Restriction Instructions.</source>
          <target state="translated">Инструкции по ограничению исполнения и прогнозирования данных.</target>
        </trans-unit>
        <trans-unit id="cd06a6fd64c8b50d4558cb3316fd26ee9feb5746" translate="yes" xml:space="preserve">
          <source>Expand &lt;code&gt;adddi3&lt;/code&gt; and &lt;code&gt;subdi3&lt;/code&gt; at RTL generation time into &lt;code&gt;add.f&lt;/code&gt;, &lt;code&gt;adc&lt;/code&gt; etc. This option is deprecated.</source>
          <target state="translated">Expand &lt;code&gt;adddi3&lt;/code&gt; и &lt;code&gt;subdi3&lt;/code&gt; в RTL времени генерации в &lt;code&gt;add.f&lt;/code&gt; , &lt;code&gt;adc&lt;/code&gt; и т.д. Этот вариант является устаревшим.</target>
        </trans-unit>
        <trans-unit id="ad01d735326a2f6603f39ee595dd5b05ec416e8b" translate="yes" xml:space="preserve">
          <source>Expand into an inline loop.</source>
          <target state="translated">Раскройте петлю.</target>
        </trans-unit>
        <trans-unit id="5ddf0ba44f58c348b4ec4063056d25a8b4689f7a" translate="yes" xml:space="preserve">
          <source>Expand using i386 &lt;code&gt;rep&lt;/code&gt; prefix of the specified size.</source>
          <target state="translated">Разверните с помощью префикса i386 &lt;code&gt;rep&lt;/code&gt; указанного размера.</target>
        </trans-unit>
        <trans-unit id="7720f0269a2d383f2dd786328047f312351d0105" translate="yes" xml:space="preserve">
          <source>Explain what alignment considerations lead to the decision to make an instruction short or long.</source>
          <target state="translated">Объясните,какие соображения,связанные с выравниванием,приводят к решению сделать инструкцию короткой или длинной.</target>
        </trans-unit>
        <trans-unit id="69ccd30207ce48099a948be1541f4d6a441981f8" translate="yes" xml:space="preserve">
          <source>Explicit instantiations can be used for the largest or most frequently duplicated instances, without having to know exactly which other instances are used in the rest of the program. You can scatter the explicit instantiations throughout your program, perhaps putting them in the translation units where the instances are used or the translation units that define the templates themselves; you can put all of the explicit instantiations you need into one big file; or you can create small files like</source>
          <target state="translated">Явные экземпляры могут быть использованы для самых больших или наиболее часто дублируемых экземпляров,без необходимости точно знать,какие другие экземпляры используются в остальной части программы.Вы можете разбросать явные инстанцинации по всей программе,возможно,поместив их в модули перевода,где используются экземпляры,или в модули перевода,которые определяют сами шаблоны;вы можете поместить все нужные вам явные инстанцинации в один большой файл;или вы можете создать маленькие файлы типа</target>
        </trans-unit>
        <trans-unit id="83042939fc50e1e36ef864fc1e78eae1c62725bf" translate="yes" xml:space="preserve">
          <source>Explicitly instantiated inline methods are unaffected by this option as their linkage might otherwise cross a shared library boundary. See &lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;Template Instantiation&lt;/a&gt;.</source>
          <target state="translated">Явно созданные экземпляры встроенных методов не затрагиваются этой опцией, поскольку в противном случае их связывание могло бы пересечь границу разделяемой библиотеки. См. &lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;Создание экземпляра шаблона&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61bd3ccba4b2c3767215774893d82391e0bc09ab" translate="yes" xml:space="preserve">
          <source>Expressions are currently only contracted if</source>
          <target state="translated">Экспрессии в настоящее время заключены только в том случае,если</target>
        </trans-unit>
        <trans-unit id="83c4bb072fc47e954ad84b1ea046adec27e854fd" translate="yes" xml:space="preserve">
          <source>Expressions that may be cast to the union type are those whose type matches at least one of the members of the union. Thus, given the following union and variables:</source>
          <target state="translated">Выражения,которые могут быть брошены к типу профсоюза,являются теми,чей тип совпадает,по крайней мере,с одним из членов профсоюза.Таким образом,учитывая следующий союз и переменные:</target>
        </trans-unit>
        <trans-unit id="ed9daef21d2e4305e648aee577dd1d6036550745" translate="yes" xml:space="preserve">
          <source>Extend (do not extend) the</source>
          <target state="translated">Увеличить (не увеличивать)</target>
        </trans-unit>
        <trans-unit id="20891f4ff37ed22f4675dae3faaf487875cf701e" translate="yes" xml:space="preserve">
          <source>Extend the current ABI with a particular extension, or remove such extension. Valid values are &amp;lsquo;</source>
          <target state="translated">Расширить текущий ABI с помощью определенного расширения или удалить такое расширение. Допустимые значения: '</target>
        </trans-unit>
        <trans-unit id="91653b5f0401d6aa2a22ebdd6efdf9699bdaeb42" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;asm&lt;/code&gt; statements have to be inside a C function, so to write inline assembly language at file scope (&amp;ldquo;top-level&amp;rdquo;), outside of C functions, you must use basic &lt;code&gt;asm&lt;/code&gt;. You can use this technique to emit assembler directives, define assembly language macros that can be invoked elsewhere in the file, or write entire functions in assembly language. Basic &lt;code&gt;asm&lt;/code&gt; statements outside of functions may not use any qualifiers.</source>
          <target state="translated">Расширенные операторы &lt;code&gt;asm&lt;/code&gt; должны находиться внутри функции C, поэтому для написания встроенного языка ассемблера в области видимости файла (&amp;laquo;верхнего уровня&amp;raquo;) вне функций C вы должны использовать базовый &lt;code&gt;asm&lt;/code&gt; . Вы можете использовать эту технику для создания директив ассемблера, определения макросов языка ассемблера, которые можно вызывать в другом месте файла, или для написания целых функций на языке ассемблера. Базовые инструкции &lt;code&gt;asm&lt;/code&gt; вне функций не могут использовать квалификаторы.</target>
        </trans-unit>
        <trans-unit id="04a315d0cc75470cd36dfd3cb992c3efb5b94ebf" translate="yes" xml:space="preserve">
          <source>Extended alignments up to &lt;em&gt;2^{28}&lt;/em&gt; (bytes) are supported for objects of automatic storage duration. Alignments supported for objects of static and thread storage duration are determined by the ABI.</source>
          <target state="translated">Расширенное выравнивание до &lt;em&gt;2 ^ {28}&lt;/em&gt; (байтов) поддерживается для объектов с длительностью автоматического хранения. Выравнивания, поддерживаемые для статических объектов и продолжительности хранения потоков, определяются ABI.</target>
        </trans-unit>
        <trans-unit id="342b07a4e48b541946d49b2270415ae84b1aef83" translate="yes" xml:space="preserve">
          <source>Extended registers are not stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">Расширенные регистры не хранятся в стеке до выполнения функции с атрибутом монитора.Опция по умолчанию</target>
        </trans-unit>
        <trans-unit id="57cf6f586241383946ebaa10651980906e2e7008" translate="yes" xml:space="preserve">
          <source>Extended registers are stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">Расширенные регистры хранятся в стеке перед выполнением функции с атрибутом монитора.Опция по умолчанию</target>
        </trans-unit>
        <trans-unit id="c9dbca1f0ee851a1a4128829e444f15ff917ef20" translate="yes" xml:space="preserve">
          <source>Extra time accounted by inliner for function overhead such as time needed to execute function prologue and epilogue</source>
          <target state="translated">Дополнительное время,учитываемое в лайнере для накладных расходов,таких как время,необходимое для выполнения функции пролога и эпилога</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="6b84b9421bc7074ef9cc3088b04a6a18d77c5b2a" translate="yes" xml:space="preserve">
          <source>FMA instructions.</source>
          <target state="translated">Инструкции FMA.</target>
        </trans-unit>
        <trans-unit id="cbf2cb3fe36db407f3a3f0c5e7fef7fc69c6ce00" translate="yes" xml:space="preserve">
          <source>FMA4 instructions.</source>
          <target state="translated">Инструкции FMA4.</target>
        </trans-unit>
        <trans-unit id="b911450c0baee87cf3722095b3e43b717fb436bb" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.</source>
          <target state="translated">Регистр FP или VSX для хранения 64-битных удвоений для прямого перемещения или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="faed2456bafb04f8c1fb3d816c3c01f0fb54a75c" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.</source>
          <target state="translated">Регистр FP или VSX для хранения 64-битных целых чисел для VSX вставок или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="09f3e1a89b6305e70a6393d549d66dbbcfd2f8f3" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.</source>
          <target state="translated">Регистр FP или VSX для хранения 64-битных целых чисел для прямых перемещений или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="ec3d1f378b46e7073f89e8d2b44ffed3f4925fb8" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform ISA 2.07 float ops or NO_REGS.</source>
          <target state="translated">Регистр FP или VSX для выполнения ISA 2.07 float ops или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="c07c5ae5e3671f1039b7da098eb0348a7624af7b" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform float operations under</source>
          <target state="translated">Регистр FP или VSX для выполнения операций с плавающей точкой в разделе</target>
        </trans-unit>
        <trans-unit id="a924751782c4ee4b5b496793046fc57512ab59f9" translate="yes" xml:space="preserve">
          <source>FP register if</source>
          <target state="translated">Регистрация FP,если</target>
        </trans-unit>
        <trans-unit id="5b1d99e5f9118d7c70848e6ad6167bba8b0b23d3" translate="yes" xml:space="preserve">
          <source>FPSCR</source>
          <target state="translated">FPSCR</target>
        </trans-unit>
        <trans-unit id="ff875f9855f1361e4b30af2d77d0d9c23d4bdca2" translate="yes" xml:space="preserve">
          <source>FRV&amp;mdash;</source>
          <target state="translated">FRV&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="230d241b3d82558160cd5187f1fe9d9c435b18d5" translate="yes" xml:space="preserve">
          <source>FSF GCC on Darwin does not create &amp;ldquo;fat&amp;rdquo; object files; it creates an object file for the single architecture that GCC was built to target. Apple&amp;rsquo;s GCC on Darwin does create &amp;ldquo;fat&amp;rdquo; files if multiple</source>
          <target state="translated">FSF GCC на Дарвине не создает &amp;laquo;толстых&amp;raquo; объектных файлов; он создает объектный файл для единой архитектуры, для которой был создан GCC. GCC от Apple на Дарвине действительно создает &amp;laquo;толстые&amp;raquo; файлы, если их несколько</target>
        </trans-unit>
        <trans-unit id="7a156574143e4ca84e24da6dfdb279cf456cca04" translate="yes" xml:space="preserve">
          <source>FT32&amp;mdash;</source>
          <target state="translated">FT32&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="599d4afb33240eb91ea2840bb9ba8f1ff44bf581" translate="yes" xml:space="preserve">
          <source>Fat LTO objects are object files that contain both the intermediate language and the object code. This makes them usable for both LTO linking and normal linking. This option is effective only when compiling with</source>
          <target state="translated">Жирные объекты LTO-это объектные файлы,содержащие как промежуточный язык,так и объектный код.Это делает их пригодными как для связывания LTO,так и для обычного связывания.Эта опция эффективна только при компиляции с</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="909a10c01414726d2e86792cc51fea9d589c8fb6" translate="yes" xml:space="preserve">
          <source>Feature Modifiers</source>
          <target state="translated">Модификаторы функций</target>
        </trans-unit>
        <trans-unit id="c796b811ac5dce8d8e36d70db0e07e63b27d5eab" translate="yes" xml:space="preserve">
          <source>Feature modifiers used with</source>
          <target state="translated">Модификаторы функций,используемые с</target>
        </trans-unit>
        <trans-unit id="aa0dd17c258c743dbea5c193ddf09bb6cebf5964" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;branch&lt;/var&gt; element have following semantics:</source>
          <target state="translated">Поля элемента &lt;var&gt;branch&lt;/var&gt; имеют следующую семантику:</target>
        </trans-unit>
        <trans-unit id="9cc6e9443d376e5757bc3441d57c3f310bf11770" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;file&lt;/var&gt; element have following semantics:</source>
          <target state="translated">Поля элемента &lt;var&gt;file&lt;/var&gt; имеют следующую семантику:</target>
        </trans-unit>
        <trans-unit id="95d9f92882f18f3b5a67ac3eeafb040cc8cd3ea3" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;function&lt;/var&gt; element have following semantics:</source>
          <target state="translated">Поля &lt;var&gt;function&lt;/var&gt; элемента имеют следующую семантику:</target>
        </trans-unit>
        <trans-unit id="55692b6d4a213073df2d182e70897f1d18b6852c" translate="yes" xml:space="preserve">
          <source>Fields of the root element have following semantics:</source>
          <target state="translated">Поля корневого элемента имеют следующую семантику:</target>
        </trans-unit>
        <trans-unit id="fba211bc33a4751c92e11eae269c5fe4195a12b5" translate="yes" xml:space="preserve">
          <source>Finally &amp;lsquo;</source>
          <target state="translated">В заключение '</target>
        </trans-unit>
        <trans-unit id="24e09f2eaae1d9afb97c63e8aa6a65a24f91f73b" translate="yes" xml:space="preserve">
          <source>Finally if the parameter is &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; then in addition to creating a symbol version (as if &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; was used) the version will be also used to resolve &lt;var&gt;name2&lt;/var&gt; by the linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889bce84d14bf80370f700a385229e627febe04d" translate="yes" xml:space="preserve">
          <source>Finally, GCC will examine &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa45d699cd27babdae75f4a8d69ed2b5379e7a87" translate="yes" xml:space="preserve">
          <source>Finally, consider:</source>
          <target state="translated">Наконец,подумайте:</target>
        </trans-unit>
        <trans-unit id="6901050dc8495daab10889e0ec9cf3617e7fb433" translate="yes" xml:space="preserve">
          <source>Finally, note how we declared the &lt;code&gt;len&lt;/code&gt; argument and the return value to be of type &lt;code&gt;unsigned long&lt;/code&gt;. They could also be declared to be of type &lt;code&gt;unsigned int&lt;/code&gt; and everything would still work.</source>
          <target state="translated">Наконец, обратите внимание, как мы объявили аргумент &lt;code&gt;len&lt;/code&gt; и возвращаемое значение типа &lt;code&gt;unsigned long&lt;/code&gt; . Они также могут быть объявлены как типы &lt;code&gt;unsigned int&lt;/code&gt; , и все будет работать.</target>
        </trans-unit>
        <trans-unit id="e5f1ab577d27769ef2407d2da5789ec6bcd34e2a" translate="yes" xml:space="preserve">
          <source>Finally, there is a complication when encoding &lt;code&gt;const char *&lt;/code&gt; versus &lt;code&gt;char * const&lt;/code&gt;. Because &lt;code&gt;char *&lt;/code&gt; is encoded as &lt;code&gt;*&lt;/code&gt; and not as &lt;code&gt;^c&lt;/code&gt;, there is no way to express the fact that &lt;code&gt;r&lt;/code&gt; applies to the pointer or to the pointee.</source>
          <target state="translated">Наконец, существует сложность при кодировании &lt;code&gt;const char *&lt;/code&gt; сравнению с &lt;code&gt;char * const&lt;/code&gt; . Поскольку &lt;code&gt;char *&lt;/code&gt; кодируется как &lt;code&gt;*&lt;/code&gt; , а не как &lt;code&gt;^c&lt;/code&gt; , нет никакого способа выразить тот факт, что &lt;code&gt;r&lt;/code&gt; применяется к указателю или к указателю.</target>
        </trans-unit>
        <trans-unit id="8d30428380add9f793c9b319edf17d149e4e4f73" translate="yes" xml:space="preserve">
          <source>Find the pass dump in a file whose name is composed of three components separated by a period: the name of the source file GCC was invoked to compile, a numeric suffix indicating the pass number followed by the letter &amp;lsquo;</source>
          <target state="translated">Найдите дамп прохода в файле, имя которого состоит из трех компонентов, разделенных точкой: имя исходного файла, который GCC был вызван для компиляции, числовой суффикс, указывающий номер прохода, за которым следует буква '</target>
        </trans-unit>
        <trans-unit id="e29b12881247aeb3ff64dc0cee23e3331d67217f" translate="yes" xml:space="preserve">
          <source>Fine-tune size optimization with regards to instruction lengths and alignment. The recognized values for &lt;var&gt;level&lt;/var&gt; are:</source>
          <target state="translated">Точная оптимизация размера в отношении длины команд и выравнивания. Признанные значения &lt;var&gt;level&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="ac0c5ec00d58b3e74a205bd50ea7108335fcb5b8" translate="yes" xml:space="preserve">
          <source>First SSE register (&lt;code&gt;%xmm0&lt;/code&gt;).</source>
          <target state="translated">Первый регистр SSE ( &lt;code&gt;%xmm0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="846211171f7db5bd2bab9f64d61f4530995ca5a0" translate="yes" xml:space="preserve">
          <source>First, the argument corresponding to a transparent union type can be of any type in the union; no cast is required. Also, if the union contains a pointer type, the corresponding argument can be a null pointer constant or a void pointer expression; and if the union contains a void pointer type, the corresponding argument can be any pointer expression. If the union member type is a pointer, qualifiers like &lt;code&gt;const&lt;/code&gt; on the referenced type must be respected, just as with normal pointer conversions.</source>
          <target state="translated">Во-первых, аргумент, соответствующий прозрачному типу объединения, может быть любого типа в объединении; Приведение не требуется. Кроме того, если объединение содержит тип указателя, соответствующий аргумент может быть константой нулевого указателя или выражением указателя void; и если объединение содержит тип указателя void, соответствующий аргумент может быть любым выражением указателя. Если тип члена union является указателем, должны соблюдаться квалификаторы, такие как &lt;code&gt;const&lt;/code&gt; для ссылочного типа, как и при обычных преобразованиях указателя.</target>
        </trans-unit>
        <trans-unit id="15ab13a54971de84d7939a64c563f0a383d5df53" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">Исправлена форма исходного кода Fortran,который должен быть препроцессирован (с помощью традиционного препроцессора).</target>
        </trans-unit>
        <trans-unit id="5552528a96a767723e84e4196dd1b4ccd0182f5d" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that should not be preprocessed.</source>
          <target state="translated">Исправлена форма исходного кода Fortran,не подлежащая препроцессированию.</target>
        </trans-unit>
        <trans-unit id="a31ce070cf9649524c3cf990ab1f1ab74aaffaa3" translate="yes" xml:space="preserve">
          <source>Fixed limit on the size of the static frame of functions: when it is topped by a particular function, stack checking is not reliable and a warning is issued by the compiler.</source>
          <target state="translated">Исправлено ограничение на размер статического кадра функций:при его захвате конкретной функцией проверка стека не является надежной и выдается предупреждение компилятором.</target>
        </trans-unit>
        <trans-unit id="85452dd45f77555cfc8a81ff291dd73781c80f82" translate="yes" xml:space="preserve">
          <source>Fixed-Point Types.</source>
          <target state="translated">Типы с фиксированной точкой.</target>
        </trans-unit>
        <trans-unit id="9f75981b930fd7189960fca9ba3bbc1796113fd3" translate="yes" xml:space="preserve">
          <source>Fixed-point data values contain fractional and optional integral parts. The format of fixed-point data varies and depends on the target machine.</source>
          <target state="translated">Значения данных с фиксированной точкой содержат дробные и необязательные интегральные части.Формат данных с фиксированной точкой варьируется и зависит от целевой машины.</target>
        </trans-unit>
        <trans-unit id="cb9fd0ce1881fdc78c0697ef42b75b52d214196d" translate="yes" xml:space="preserve">
          <source>Fixed-point types are supported by the DWARF debug information format.</source>
          <target state="translated">Типы с фиксированной точкой поддерживаются форматом отладочной информации DWARF.</target>
        </trans-unit>
        <trans-unit id="265c5eecf02fb4f371ef39bcfe52b0dfc566b452" translate="yes" xml:space="preserve">
          <source>Flag the first routine whose name starts with &lt;var&gt;prefix&lt;/var&gt; as the main routine for the debugger.</source>
          <target state="translated">Отметьте первую подпрограмму, имя которой начинается с &lt;var&gt;prefix&lt;/var&gt; как основную подпрограмму отладчика.</target>
        </trans-unit>
        <trans-unit id="b3390bf7e3c55aee432834653f4b1f941089ffde" translate="yes" xml:space="preserve">
          <source>Flexible array members are written as &lt;code&gt;contents[]&lt;/code&gt; without the &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Члены гибкого массива записываются как &lt;code&gt;contents[]&lt;/code&gt; без &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78dbcf864480c990f48bdd0342e3500b8c1282bd" translate="yes" xml:space="preserve">
          <source>Flexible array members have incomplete type, and so the &lt;code&gt;sizeof&lt;/code&gt; operator may not be applied. As a quirk of the original implementation of zero-length arrays, &lt;code&gt;sizeof&lt;/code&gt; evaluates to zero.</source>
          <target state="translated">Гибкие элементы массива имеют неполный тип, поэтому оператор &lt;code&gt;sizeof&lt;/code&gt; не может применяться. Как причуда оригинальной реализации массивов нулевой длины, &lt;code&gt;sizeof&lt;/code&gt; оценивается как ноль.</target>
        </trans-unit>
        <trans-unit id="417d40e05d0999fe399d7881ccf242563a660e4a" translate="yes" xml:space="preserve">
          <source>Flexible array members may only appear as the last member of a &lt;code&gt;struct&lt;/code&gt; that is otherwise non-empty.</source>
          <target state="translated">Члены гибкого массива могут появляться только как последний член &lt;code&gt;struct&lt;/code&gt; которая в противном случае непуста.</target>
        </trans-unit>
        <trans-unit id="7ffa11ebef97287859a0bb0cd563e4e8b95df556" translate="yes" xml:space="preserve">
          <source>Floating point constant 0.</source>
          <target state="translated">Константа с плавающей точкой 0.</target>
        </trans-unit>
        <trans-unit id="4560e48bbc91965a1ad028ff4792c55d56a0a598" translate="yes" xml:space="preserve">
          <source>Floating point constant that can be loaded into a register with one instruction per word</source>
          <target state="translated">Константа с плавающей точкой,которая может быть загружена в регистр с одной командой на слово</target>
        </trans-unit>
        <trans-unit id="c516f23fc0c0d103a2cd7b68a6433df4fc2451d6" translate="yes" xml:space="preserve">
          <source>Floating point constant that is legal for store immediate</source>
          <target state="translated">Константа с плавающей точкой,которая является законной для магазина немедленно</target>
        </trans-unit>
        <trans-unit id="32a95fa9a487a375449247a65d3193bb1004c1f0" translate="yes" xml:space="preserve">
          <source>Floating point constant that is not a 68881 constant</source>
          <target state="translated">Константа с плавающей точкой,которая не является константой 68881.</target>
        </trans-unit>
        <trans-unit id="79fb00b4bc62aed23a250b86e31fbd72d18840a5" translate="yes" xml:space="preserve">
          <source>Floating point constant zero</source>
          <target state="translated">Постоянная с плавающей точкой ноль</target>
        </trans-unit>
        <trans-unit id="af1bda543b578583ca4289ffad142bd3d77692c3" translate="yes" xml:space="preserve">
          <source>Floating point register</source>
          <target state="translated">Регистр с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="573ca6d44dc3da178f33a1539aefbe9a7a969613" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 32-bit value)</source>
          <target state="translated">Регистр с плавающей точкой (содержащий 32-битное значение)</target>
        </trans-unit>
        <trans-unit id="b5c02f93e377f6b8a0b2a78a784d0d990452bae9" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 64-bit value)</source>
          <target state="translated">Регистр с плавающей точкой (содержащий 64-битное значение)</target>
        </trans-unit>
        <trans-unit id="ef449f8f1e197b3fc12f9a7bbd29815185c01715" translate="yes" xml:space="preserve">
          <source>Floating point register (deprecated)</source>
          <target state="translated">Регистр с плавающей точкой (устаревший)</target>
        </trans-unit>
        <trans-unit id="f7558c1a4bb9c6d833aca45e4903e960fa15f358" translate="yes" xml:space="preserve">
          <source>Floating point register if</source>
          <target state="translated">Регистр с плавающей точкой,если</target>
        </trans-unit>
        <trans-unit id="c165ca40457d305eb7d330afdb797521f5de1b77" translate="yes" xml:space="preserve">
          <source>Floating point register if direct moves are available, or NO_REGS.</source>
          <target state="translated">Регистр с плавающей точкой,если доступны прямые перемещения,или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="5262899d7f774e7136ab629899288cb3977b1a82" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWAX instruction is enabled or NO_REGS.</source>
          <target state="translated">Регистр с плавающей точкой,если инструкция LFIWAX включена или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="37f6e14594705b3a931f7fb11f09da2da0b4cf9c" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWZX instruction is enabled or NO_REGS.</source>
          <target state="translated">Регистр с плавающей точкой,если инструкция LFIWZX включена или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="92eb4ccc2dc9e99f2247ac815df53adacfbc08da" translate="yes" xml:space="preserve">
          <source>Floating point register if the STFIWX instruction is enabled or NO_REGS.</source>
          <target state="translated">Регистр с плавающей точкой,если инструкция STFIWX включена или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="aaae0bc8bed9980f091aa46b02c6dcb5a52b76ec" translate="yes" xml:space="preserve">
          <source>Floating point register, Advanced SIMD vector register or SVE vector register</source>
          <target state="translated">Регистр с плавающей точкой,расширенный векторный регистр SIMD или векторный регистр SVE</target>
        </trans-unit>
        <trans-unit id="16c68eba878493a77d0c164e7869af76e99d9145" translate="yes" xml:space="preserve">
          <source>Floating point registers AC0 through AC3. These can be loaded from/to memory with a single instruction.</source>
          <target state="translated">Регистры с плавающей точкой регистрируют от AC0 до AC3.Они могут быть загружены из/в память с помощью одной инструкции.</target>
        </trans-unit>
        <trans-unit id="83ce48a9f40c05895bc4e20f6bb82f032e76933d" translate="yes" xml:space="preserve">
          <source>Floating point registers AC4 and AC5. These cannot be loaded from/to memory with a single instruction.</source>
          <target state="translated">Регистры с плавающей точкой AC4 и AC5.Они не могут быть загружены из/в память с помощью одной команды.</target>
        </trans-unit>
        <trans-unit id="f58b0d70fd4d764630301aac0286ba68330e3308" translate="yes" xml:space="preserve">
          <source>Floating-point condition code register.</source>
          <target state="translated">Регистр кодов условий с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="b56c9d5aa5cba048b4016e56db5b37a9156be6f1" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0</source>
          <target state="translated">Константа с плавающей точкой 0.0</target>
        </trans-unit>
        <trans-unit id="11ca0595ff5b1cee498ed130d48a9d7ef77d2ce2" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0 or 1.0</source>
          <target state="translated">Константа с плавающей точкой 0.0 или 1.0</target>
        </trans-unit>
        <trans-unit id="3af5f60b6556d63fbe7c6434e046d0c15fe3ffe1" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a high/lo_sum instruction sequence</source>
          <target state="translated">Константа с плавающей точкой,интегральное представление которой может быть перемещено в целочисленный регистр с помощью последовательности инструкций high/lo_sum</target>
        </trans-unit>
        <trans-unit id="c0e1876d49ff7a36e4b65c8a5784d9cd7a8e4781" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single mov instruction</source>
          <target state="translated">Константа с плавающей точкой,интегральное представление которой может быть перемещено в целочисленный регистр с помощью единственной команды перемещения</target>
        </trans-unit>
        <trans-unit id="500223502156611a39a78dc4c23517d86e8a772f" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single sethi instruction</source>
          <target state="translated">Константа с плавающей точкой,интегральное представление которой может быть перемещено в целочисленный регистр с помощью единственной инструкции sethi</target>
        </trans-unit>
        <trans-unit id="95fef479c80cb031fff0832cf86c7d5b4d064fb7" translate="yes" xml:space="preserve">
          <source>Floating-point instructions are only generated for 32-bit floating-point values, however, so the FPU hardware is not used for doubles if the</source>
          <target state="translated">Однако инструкции с плавающей запятой генерируются только для 32-битных значений с плавающей запятой,поэтому аппаратное обеспечение FPU не используется для удвоений,если</target>
        </trans-unit>
        <trans-unit id="f213ef5758f227bd35596edf6ff5e36aed746a21" translate="yes" xml:space="preserve">
          <source>Floating-point minimum and maximum. These instructions are only generated if</source>
          <target state="translated">Минимум и максимум с плавающей точкой.Эти инструкции генерируются только в том случае,если</target>
        </trans-unit>
        <trans-unit id="92610c4245848bdded34c9ee994e62b738188b93" translate="yes" xml:space="preserve">
          <source>Floating-point register</source>
          <target state="translated">Регистр с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="e5380eea89f6db263d5d241526df6bedd0bd11ff" translate="yes" xml:space="preserve">
          <source>Floating-point register on the SPARC-V8 architecture and lower floating-point register on the SPARC-V9 architecture.</source>
          <target state="translated">Регистр с плавающей точкой на архитектуре SPARC-V8 и регистр с нижней плавающей точкой на архитектуре SPARC-V9.</target>
        </trans-unit>
        <trans-unit id="2b69cf45a938c9e06197f0424f9a02b9aa9f002d" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is equivalent to &amp;lsquo;</source>
          <target state="translated">Регистр с плавающей точкой. Это эквивалентно '</target>
        </trans-unit>
        <trans-unit id="8ed13acd5482c325b73e858b30874f469fb342d2" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available.</source>
          <target state="translated">Регистр с плавающей точкой.Он действует на архитектуре SPARC-V9 только тогда,когда доступен набор визуальных инструкций.</target>
        </trans-unit>
        <trans-unit id="d0d6928cc5c4254d825994f1f03f5fa64bf43b02" translate="yes" xml:space="preserve">
          <source>Floating-point trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">Тригонометрические и экспоненциальные функции с плавающей точкой.Эти инструкции генерируются только в том случае,если</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="translated">Плавающая запятая ноль</target>
        </trans-unit>
        <trans-unit id="c245efe80db566f234058018cbe48e4698e1bcb0" translate="yes" xml:space="preserve">
          <source>Floating-point zero.</source>
          <target state="translated">Плавающая точка ноль.</target>
        </trans-unit>
        <trans-unit id="bc0561e46ee46f1370ce39f7bd133e69f6b47448" translate="yes" xml:space="preserve">
          <source>Flushing registers to memory has performance implications and may be an issue for time-sensitive code. You can provide better information to GCC to avoid this, as shown in the following examples. At a minimum, aliasing rules allow GCC to know what memory &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; need to be flushed.</source>
          <target state="translated">Сброс регистров в память влияет на производительность и может быть проблемой для кода, чувствительного ко времени. Вы можете предоставить GCC более подробную информацию, чтобы избежать этого, как показано в следующих примерах. Как минимум, правила псевдонима позволяют GCC знать, какую память &lt;em&gt;не&lt;/em&gt; нужно очищать.</target>
        </trans-unit>
        <trans-unit id="7d035cae4646bbea859b3aa6a64d528d7a19fea6" translate="yes" xml:space="preserve">
          <source>Follow the EABI requirement of always creating a frame pointer whenever a stack frame is allocated. This option is enabled by default and can be disabled with</source>
          <target state="translated">Следуйте требованиям EABI,чтобы всегда создавать указатель на кадр,когда выделяется кадр стека.Эта опция включена по умолчанию и может быть отключена с помощью параметра</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="9203a30acc55d5bd89f275fd6b63f1da488b512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is placed at offset 2, rather than offset 1. Accordingly, the size of &lt;code&gt;t2&lt;/code&gt; is 4. For &lt;code&gt;t3&lt;/code&gt;, the zero-length bit-field does not affect the alignment of &lt;code&gt;bar&lt;/code&gt; or, as a result, the size of the structure.</source>
          <target state="translated">Для &lt;code&gt;t2&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; помещается со смещением 2, а не смещением 1. Соответственно, размер &lt;code&gt;t2&lt;/code&gt; равно 4. Для &lt;code&gt;t3&lt;/code&gt; , нулевой длины битового поля не влияет на выравнивание &lt;code&gt;bar&lt;/code&gt; или, как результат, размер структура.</target>
        </trans-unit>
        <trans-unit id="c0e04e76cdfed448d6c782b7f817b6eea03c0f50" translate="yes" xml:space="preserve">
          <source>For &lt;var&gt;n&lt;/var&gt; greater than zero,</source>
          <target state="translated">Если &lt;var&gt;n&lt;/var&gt; больше нуля,</target>
        </trans-unit>
        <trans-unit id="fda527468e7c30de6308efd890e87b3a3fff811b" translate="yes" xml:space="preserve">
          <source>For ARC, a function marked with the &lt;code&gt;long_call&lt;/code&gt; attribute is always called using register-indirect jump-and-link instructions, thereby enabling the called function to be placed anywhere within the 32-bit address space. A function marked with the &lt;code&gt;medium_call&lt;/code&gt; attribute will always be close enough to be called with an unconditional branch-and-link instruction, which has a 25-bit offset from the call site. A function marked with the &lt;code&gt;short_call&lt;/code&gt; attribute will always be close enough to be called with a conditional branch-and-link instruction, which has a 21-bit offset from the call site.</source>
          <target state="translated">Для ARC функция, отмеченная атрибутом &lt;code&gt;long_call&lt;/code&gt; , всегда вызывается с использованием косвенных регистров инструкций перехода и связывания, что позволяет разместить вызываемую функцию в любом месте 32-битного адресного пространства. Функция, отмеченная атрибутом &lt;code&gt;medium_call&lt;/code&gt; , всегда будет достаточно близкой для вызова с помощью безусловной инструкции перехода и ссылки, которая имеет 25-битное смещение от места вызова. Функция, отмеченная атрибутом &lt;code&gt;short_call&lt;/code&gt; , всегда будет достаточно близкой для вызова с помощью условной инструкции перехода и ссылки, которая имеет 21-битное смещение от места вызова.</target>
        </trans-unit>
        <trans-unit id="6adc57b693c8942df2cd231eba32d27dd15cba72" translate="yes" xml:space="preserve">
          <source>For C and C++ source and include files, generate corresponding Ada specs. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;Generating Ada Bindings for C and C++ headers&lt;/a&gt; in GNAT User&amp;rsquo;s Guide, which provides detailed documentation on this feature.</source>
          <target state="translated">Для исходных и включаемых файлов C и C ++ сгенерируйте соответствующие спецификации Ada. См. Раздел &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;Создание привязок Ada для заголовков C и C ++&lt;/a&gt; в Руководстве пользователя GNAT, где представлена ​​подробная документация по этой функции.</target>
        </trans-unit>
        <trans-unit id="a54d6337d3721d977a537facc549a93425ea6c7b" translate="yes" xml:space="preserve">
          <source>For C only, warn about a &lt;code&gt;return&lt;/code&gt; statement with an expression in a function whose return type is &lt;code&gt;void&lt;/code&gt;, unless the expression type is also &lt;code&gt;void&lt;/code&gt;. As a GNU extension, the latter case is accepted without a warning unless</source>
          <target state="translated">Только для C: предупреждать об операторе &lt;code&gt;return&lt;/code&gt; с выражением в функции, тип возврата которой &lt;code&gt;void&lt;/code&gt; , если тип выражения также &lt;code&gt;void&lt;/code&gt; является void . В качестве расширения GNU последний случай принимается без предупреждения, если только</target>
        </trans-unit>
        <trans-unit id="2ec28d96fea6d9177d31ee6cda12fa27a81380e2" translate="yes" xml:space="preserve">
          <source>For C++ this also warns for some cases of unnecessary parentheses in declarations, which can indicate an attempt at a function call instead of a declaration:</source>
          <target state="translated">Для языка Си++это также предупреждает в некоторых случаях о лишних скобках в объявлениях,которые могут указывать на попытку вызова функции вместо объявления:</target>
        </trans-unit>
        <trans-unit id="a1ba0033d082d3c48e09cd4d28a77031c040292c" translate="yes" xml:space="preserve">
          <source>For C++ types with non-trivial constructors and/or destructors it is impossible for the compiler to determine whether a variable of this type is truly unused if it is not referenced. This type attribute informs the compiler that variables of this type should be warned about if they appear to be unused, just like variables of fundamental types.</source>
          <target state="translated">Для типов Си++с нетривиальными конструкторами и/или деструкторами компилятор не может определить,действительно ли переменная этого типа не используется,если на нее не сделана ссылка.Данный атрибут типа информирует компилятор о том,что переменные данного типа должны быть предупреждены,если они кажутся неиспользуемыми,точно так же,как и переменные фундаментальных типов.</target>
        </trans-unit>
        <trans-unit id="0ae259ea1be0c205a219871342f05ea5c73b071c" translate="yes" xml:space="preserve">
          <source>For C++, also warn for confusing overload resolution for user-defined conversions; and conversions that never use a type conversion operator: conversions to &lt;code&gt;void&lt;/code&gt;, the same type, a base class or a reference to them. Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless</source>
          <target state="translated">Для C ++ также предупреждайте о путанице при разрешении перегрузки для пользовательских преобразований; и преобразования, которые никогда не используют оператор преобразования типа: преобразования в &lt;code&gt;void&lt;/code&gt; , тот же тип, базовый класс или ссылку на них. Предупреждения о преобразованиях между целыми числами со знаком и без знака по умолчанию отключены в C ++, если только</target>
        </trans-unit>
        <trans-unit id="e062686eecb3f26c45c0833c30627154026b2d61" translate="yes" xml:space="preserve">
          <source>For C++11 and later standards, narrowing conversions are diagnosed by default, as required by the standard. A narrowing conversion from a constant produces an error, and a narrowing conversion from a non-constant produces a warning, but</source>
          <target state="translated">Для C++11 и более поздних стандартов сужение преобразований диагностируется по умолчанию,как того требует стандарт.Сужающееся преобразование от константы приводит к ошибке,а сужающееся преобразование от не константы приводит к предупреждению,но</target>
        </trans-unit>
        <trans-unit id="f97e8575f9ec69703e8c96b79759e90bcf7fbfd5" translate="yes" xml:space="preserve">
          <source>For C, overloaded functions are implemented with macros so the following does not work:</source>
          <target state="translated">Для C перегруженные функции реализуются с помощью макросов,поэтому следующее не работает:</target>
        </trans-unit>
        <trans-unit id="9bcf8fa5038512fc6bcb9ac1f639a794219e10dd" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets the use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on functions is not necessary, but provides a small performance benefit by eliminating a thunk in the DLL. The use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on imported variables can be avoided by passing the</source>
          <target state="translated">Для целей Microsoft Windows использование атрибута &lt;code&gt;dllimport&lt;/code&gt; в функциях не обязательно, но дает небольшое преимущество в производительности за счет устранения преобразователя в DLL. Использование атрибута &lt;code&gt;dllimport&lt;/code&gt; для импортированных переменных можно избежать, передав</target>
        </trans-unit>
        <trans-unit id="9b439766be6cedb98071044e5f74180de17ccd28" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets there are alternative methods for including the symbol in the DLL&amp;rsquo;s export table such as using a</source>
          <target state="translated">Для целей Microsoft Windows существуют альтернативные методы включения символа в таблицу экспорта DLL, например, использование</target>
        </trans-unit>
        <trans-unit id="c0f97011eddc4db6c5d876ee996866a2e41c88d5" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, &lt;code&gt;NSString&lt;/code&gt; (or &lt;code&gt;__NSString__&lt;/code&gt;) is recognized in the same context. Declarations including these format attributes are parsed for correct syntax, however the result of checking of such format strings is not yet defined, and is not carried out by this version of the compiler.</source>
          <target state="translated">Для диалектов Objective-C &lt;code&gt;NSString&lt;/code&gt; (или &lt;code&gt;__NSString__&lt;/code&gt; ) распознается в том же контексте. Объявления, включающие эти атрибуты формата, анализируются на предмет правильного синтаксиса, однако результат проверки таких строк формата еще не определен и не выполняется этой версией компилятора.</target>
        </trans-unit>
        <trans-unit id="7b8c007aa57d34905e4e1143a8c9e0a695e59978" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, the &lt;code&gt;format-arg&lt;/code&gt; attribute may refer to an &lt;code&gt;NSString&lt;/code&gt; reference for compatibility with the &lt;code&gt;format&lt;/code&gt; attribute above.</source>
          <target state="translated">Для диалектов Objective-C атрибут &lt;code&gt;format-arg&lt;/code&gt; может ссылаться на ссылку &lt;code&gt;NSString&lt;/code&gt; для совместимости с указанным выше атрибутом &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92a499e6d28c647e0ab66f857f55afedfae35b1a" translate="yes" xml:space="preserve">
          <source>For PMF constants (i.e. expressions of the form &amp;lsquo;</source>
          <target state="translated">Для констант PMF (т.е. выражений формы '</target>
        </trans-unit>
        <trans-unit id="da58c329594be0295cc2415f6a69d9838ef88a83" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. For example:</source>
          <target state="translated">Для SysV / x86-64 объединения с &lt;code&gt;long double&lt;/code&gt; членами передаются в память, как указано в psABI. Например:</target>
        </trans-unit>
        <trans-unit id="1f5fce8a743c71e90680bcbdd5fc42205fc0e24c" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. Prior to GCC 4.4, this was not the case. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5082f805fe556d28e82883360f1cc9602556d6" translate="yes" xml:space="preserve">
          <source>For a branch, if it was executed at least once, then a percentage indicating the number of times the branch was taken divided by the number of times the branch was executed will be printed. Otherwise, the message &amp;ldquo;never executed&amp;rdquo; is printed.</source>
          <target state="translated">Для ветки, если она была выполнена хотя бы один раз, будет напечатано процентное значение, указывающее количество раз, когда ветвление было выполнено, деленное на количество раз, когда ветвь выполнялась. В противном случае печатается сообщение &amp;laquo;никогда не выполняется&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c55de54fa0492ae593f558830d0cb1158609d3e6" translate="yes" xml:space="preserve">
          <source>For a call, if it was executed at least once, then a percentage indicating the number of times the call returned divided by the number of times the call was executed will be printed. This will usually be 100%, but may be less for functions that call &lt;code&gt;exit&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;, and thus may not return every time they are called.</source>
          <target state="translated">Для вызова, если он был выполнен хотя бы один раз, будет напечатано процентное значение, указывающее количество возвращенных вызовов, деленное на количество раз, когда вызов был выполнен. Обычно это 100%, но может быть меньше для функций, вызывающих &lt;code&gt;exit&lt;/code&gt; или &lt;code&gt;longjmp&lt;/code&gt; , и поэтому они могут не возвращаться каждый раз при их вызове.</target>
        </trans-unit>
        <trans-unit id="0b932ff19c99d589baf49f81de1fc444d2d6fe68" translate="yes" xml:space="preserve">
          <source>For a full description of what the helpers do, the arguments they take, and the returned value, see the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3a2fcd90b12dd021860d8f2094fd5bb769b990" translate="yes" xml:space="preserve">
          <source>For all builtins, &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt;, the header file</source>
          <target state="translated">Для всех встроенных &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; __builtin_arc_ someinsn , файл заголовка</target>
        </trans-unit>
        <trans-unit id="faea18cdbc9f914fc830faf9ab42ccd57286882b" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0b11d5fd63069d7902f804e3faa32968adf01d" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="translated">Для всех из них, кроме последнего, компилятор автоматически игнорирует предварительно скомпилированный заголовок, если условия не выполняются. Если вы обнаружите комбинацию опций, которая не работает и не приводит к игнорированию предварительно скомпилированного заголовка, рассмотрите возможность отправки отчета об ошибке, см. &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;Ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58f02a64f2f86869e0c0753651765b098a5d48fc" translate="yes" xml:space="preserve">
          <source>For an automatic (i.e. local) variable, if there exists a path from the function entry to a use of the variable that is initialized, but there exist some other paths for which the variable is not initialized, the compiler emits a warning if it cannot prove the uninitialized paths are not executed at run time.</source>
          <target state="translated">Для автоматической (т.е.локальной)переменной,если существует путь от записи функции до использования инициализированной переменной,но существуют другие пути,для которых переменная не инициализирована,компилятор выдает предупреждение,если не может доказать,что неинициализированные пути не выполняются во время выполнения.</target>
        </trans-unit>
        <trans-unit id="66413344ffac4ff8769f77f6b83c7166f806eb53" translate="yes" xml:space="preserve">
          <source>For any declared symbols matching &lt;var&gt;name&lt;/var&gt;, this does three things to that symbol: it forces the symbol to be located at the given address (a number), it forces the symbol to be volatile, and it changes the symbol&amp;rsquo;s scope to be static. This pragma exists for compatibility with other compilers, but note that the common &lt;code&gt;1234H&lt;/code&gt; numeric syntax is not supported (use &lt;code&gt;0x1234&lt;/code&gt; instead). Example:</source>
          <target state="translated">Для любого объявленного символа, совпадающего с &lt;var&gt;name&lt;/var&gt; , это делает три вещи с этим символом: он заставляет символ располагаться по заданному адресу (номеру), он заставляет символ быть изменчивым и он изменяет область действия символа на статическую. Эта прагма существует для совместимости с другими компиляторами, но обратите внимание, что общий числовой синтаксис &lt;code&gt;1234H&lt;/code&gt; не поддерживается ( вместо этого используйте &lt;code&gt;0x1234&lt;/code&gt; ). Пример:</target>
        </trans-unit>
        <trans-unit id="a150049db7b708562952c9c177d8b88f32edb151" translate="yes" xml:space="preserve">
          <source>For any given input file, the file name suffix determines what kind of compilation is done:</source>
          <target state="translated">Для любого заданного входного файла суффикс имени файла определяет,какая компиляция выполняется:</target>
        </trans-unit>
        <trans-unit id="07d18512cc77ea85f9b39807bf636696e007c1f0" translate="yes" xml:space="preserve">
          <source>For any input register that is implicitly popped by an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know how to adjust the stack to compensate for the pop. If any non-popped input is closer to the top of the reg-stack than the implicitly popped register, it would not be possible to know what the stack looked like&amp;mdash;it&amp;rsquo;s not clear how the rest of the stack &amp;ldquo;slides up&amp;rdquo;.</source>
          <target state="translated">Для любого входного регистра, который неявно выталкивается &lt;code&gt;asm&lt;/code&gt; , необходимо знать, как настроить стек, чтобы компенсировать выталкивание. Если какой-либо не извлекаемый ввод находится ближе к вершине стека рег, чем неявно извлекаемый регистр, невозможно узнать, как выглядит стек - неясно, как остальная часть стека &amp;laquo;скользит вверх&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f70c821669087836df1b08a79652756521c81032" translate="yes" xml:space="preserve">
          <source>For basic &lt;code&gt;asm&lt;/code&gt; with non-empty assembler string GCC assumes the assembler block does not change any general purpose registers, but it may read or write any globally accessible variable.</source>
          <target state="translated">Для базового &lt;code&gt;asm&lt;/code&gt; с непустой строкой ассемблера GCC предполагает, что блок ассемблера не изменяет регистры общего назначения, но может читать или записывать любую глобально доступную переменную.</target>
        </trans-unit>
        <trans-unit id="5e325c0c804529598de8767ff4c99ad5a3e91e4a" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports &amp;lsquo;</source>
          <target state="translated">Для совместимости с компиляторами Microsoft Windows GCC поддерживает '</target>
        </trans-unit>
        <trans-unit id="2e68646242b9dd84443ad785c99336fb66a4c416" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives that change the maximum alignment of members of structures (other than zero-width bit-fields), unions, and classes subsequently defined. The &lt;var&gt;n&lt;/var&gt; value below always is required to be a small power of two and specifies the new alignment in bytes.</source>
          <target state="translated">Для совместимости с компиляторами Microsoft Windows GCC поддерживает набор директив &lt;code&gt;#pragma&lt;/code&gt; , которые изменяют максимальное выравнивание элементов структур (кроме битовых полей нулевой ширины), объединений и классов, определенных впоследствии. Приведенное ниже значение &lt;var&gt;n&lt;/var&gt; всегда должно быть малой степенью двойки и указывает новое выравнивание в байтах.</target>
        </trans-unit>
        <trans-unit id="2922cd58b39e0ff05824f3d77b79c0fe7423d78f" translate="yes" xml:space="preserve">
          <source>For compatibility with SVR4, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives for declaring symbols to be weak, and defining weak aliases.</source>
          <target state="translated">Для совместимости с SVR4 GCC поддерживает набор директив &lt;code&gt;#pragma&lt;/code&gt; для объявления символов слабыми и определения слабых псевдонимов.</target>
        </trans-unit>
        <trans-unit id="47783006d3b2d24697c7b14be6b4ca265bdb02d0" translate="yes" xml:space="preserve">
          <source>For compatibility with existing code written for compiler versions that did not implement attributes on nested declarators, some laxity is allowed in the placing of attributes. If an attribute that only applies to types is applied to a declaration, it is treated as applying to the type of that declaration. If an attribute that only applies to declarations is applied to the type of a declaration, it is treated as applying to that declaration; and, for compatibility with code placing the attributes immediately before the identifier declared, such an attribute applied to a function return type is treated as applying to the function type, and such an attribute applied to an array element type is treated as applying to the array type. If an attribute that only applies to function types is applied to a pointer-to-function type, it is treated as applying to the pointer target type; if such an attribute is applied to a function return type that is not a pointer-to-function type, it is treated as applying to the function type.</source>
          <target state="translated">Для совместимости с существующим кодом,написанным для версий компилятора,которые не реализовывали атрибуты на вложенных деклараторах,допускается некоторая дряблость при размещении атрибутов.Если к декларации применяется атрибут,применимый только к типам,то он рассматривается как применимый к типу декларации.Если к типу объявления применяется атрибут,который применяется только к объявлениям,то он рассматривается как применяющийся к данному объявлению;а для совместимости с кодом,размещающим атрибуты непосредственно перед объявленным идентификатором,такой атрибут,применяемый к возвращаемому типу функции,рассматривается как применяемый к типу функции,а такой атрибут,применяемый к типу элемента массива,рассматривается как применяемый к типу массива.Если атрибут,который применяется только к типам функций,применяется к типу &quot;указатель в функцию&quot;,то он рассматривается как применяющийся к целевому типу указателя;если такой атрибут применяется к возвращаемому типу функции,который не является типом &quot;указатель в функцию&quot;,то он рассматривается как применяющийся к типу функции.</target>
        </trans-unit>
        <trans-unit id="55c454a21201bdfc3a9a886c367d99786c9c4842" translate="yes" xml:space="preserve">
          <source>For compatibility, it&amp;rsquo;s always newlib for elf now.</source>
          <target state="translated">Для совместимости теперь всегда используется newlib для elf.</target>
        </trans-unit>
        <trans-unit id="4859bddb1e6f097bf4875ee4cd32afb8f33d13e6" translate="yes" xml:space="preserve">
          <source>For convenience, it is allowed to use a binary vector operation where one operand is a scalar. In that case the compiler transforms the scalar operand into a vector where each element is the scalar from the operation. The transformation happens only if the scalar could be safely converted to the vector-element type. Consider the following code.</source>
          <target state="translated">Для удобства разрешается использовать двоичную векторную операцию,где один операнд является скаляром.В этом случае компилятор преобразует скалярный операнд в вектор,где каждый элемент является скаляром от операции.Преобразование происходит только в том случае,если скаляр можно безопасно преобразовать в векторный тип элемента.Рассмотрим следующий код.</target>
        </trans-unit>
        <trans-unit id="3d923f6f173753b3c978292a218e04d22288b211" translate="yes" xml:space="preserve">
          <source>For conversion to a type of width &lt;em&gt;N&lt;/em&gt;, the value is reduced modulo &lt;em&gt;2^N&lt;/em&gt; to be within range of the type; no signal is raised.</source>
          <target state="translated">Для преобразования в тип ширины &lt;em&gt;N&lt;/em&gt; значение уменьшается по модулю &lt;em&gt;2 ^ N,&lt;/em&gt; чтобы находиться в пределах диапазона типа; сигнал не подается.</target>
        </trans-unit>
        <trans-unit id="c0bc316f0ef750b2316cb1b5e8278752dde4a8ca" translate="yes" xml:space="preserve">
          <source>For deciding the optimization level of body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3216191fb385483c1e97afafeea464af935a4944" translate="yes" xml:space="preserve">
          <source>For devices not in &lt;code&gt;avrtiny&lt;/code&gt; or &lt;code&gt;avrxmega3&lt;/code&gt;, any data including read-only data is located in RAM (the generic address space) because flash memory is not visible in the RAM address space. In order to locate read-only data in flash memory &lt;em&gt;and&lt;/em&gt; to generate the right instructions to access this data without using (inline) assembler code, special address spaces are needed.</source>
          <target state="translated">Для устройств, не &lt;code&gt;avrtiny&lt;/code&gt; в avrtiny или &lt;code&gt;avrxmega3&lt;/code&gt; , любые данные, включая данные только для чтения, находятся в ОЗУ (общее адресное пространство), поскольку флэш-память не видна в адресном пространстве ОЗУ. Чтобы найти данные только для чтения во флэш-памяти &lt;em&gt;и&lt;/em&gt; сгенерировать правильные инструкции для доступа к этим данным без использования (встроенного) кода ассемблера, необходимы специальные адресные пространства.</target>
        </trans-unit>
        <trans-unit id="0733ee9be6e082cc123e5464c02486573ae7f9cd" translate="yes" xml:space="preserve">
          <source>For documentation of &lt;code&gt;altivec&lt;/code&gt; attribute please see the documentation in &lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;PowerPC Type Attributes&lt;/a&gt;.</source>
          <target state="translated">Для документации по &lt;code&gt;altivec&lt;/code&gt; см. Документацию в разделе &lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;Атрибуты типа PowerPC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3f33ef599bbcb991ed9de189514be3fb2765a7" translate="yes" xml:space="preserve">
          <source>For each Objective-C class, check if any of its instance variables is a C++ object with a non-trivial default constructor. If so, synthesize a special &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; instance method which runs non-trivial default constructors on any such instance variables, in order, and then return &lt;code&gt;self&lt;/code&gt;. Similarly, check if any instance variable is a C++ object with a non-trivial destructor, and if so, synthesize a special &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; method which runs all such default destructors, in reverse order.</source>
          <target state="translated">Для каждого класса Objective-C проверьте, является ли какая-либо из его переменных экземпляра объектом C ++ с нетривиальным конструктором по умолчанию. Если это так, синтезируйте специальный метод экземпляра &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; который запускает нетривиальные конструкторы по умолчанию для любых таких переменных экземпляра по порядку, а затем возвращает &lt;code&gt;self&lt;/code&gt; . Точно так же проверьте, является ли какая-либо переменная экземпляра объектом C ++ с нетривиальным деструктором, и если да, синтезируйте специальный метод &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; который запускает все такие деструкторы по умолчанию в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="ecabcf6fb487210c3e414abe28454af79991a5a8" translate="yes" xml:space="preserve">
          <source>For each basic block, a line is printed after the last line of the basic block describing the branch or call that ends the basic block. There can be multiple branches and calls listed for a single source line if there are multiple basic blocks that end on that line. In this case, the branches and calls are each given a number. There is no simple way to map these branches and calls back to source constructs. In general, though, the lowest numbered branch or call will correspond to the leftmost construct on the source line.</source>
          <target state="translated">Для каждого базового блока выводится строка после последней строки базового блока,описывающей ответвление или вызов,заканчивающийся базовым блоком.Если на этой строке находится несколько основных блоков,заканчивающихся базовым блоком,то для одной исходной линии может быть выведено несколько ветвей и вызовов.В этом случае ответвлениям и вызовам присваивается номер.Нет простого способа сопоставить эти ветки и вызовы исходных конструкций.В общем случае,однако,наименьшая пронумерованная ветка или вызов будет соответствовать самой левой конструкции на исходной линии.</target>
        </trans-unit>
        <trans-unit id="7d57dddd1f25be9ff5b83775303a0d6d59fce852" translate="yes" xml:space="preserve">
          <source>For each built-in function for AVR, there is an equally named, uppercase built-in macro defined. That way users can easily query if or if not a specific built-in is implemented or not. For example, if &lt;code&gt;__builtin_avr_nop&lt;/code&gt; is available the macro &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; is defined to &lt;code&gt;1&lt;/code&gt; and undefined otherwise.</source>
          <target state="translated">Для каждой встроенной функции AVR определен встроенный макрос с одинаковым именем в верхнем регистре. Таким образом, пользователи могут легко запросить, реализована ли конкретная встроенная функция или нет. Например, если &lt;code&gt;__builtin_avr_nop&lt;/code&gt; доступен, макрос &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; определяется как &lt;code&gt;1&lt;/code&gt; и не определен в противном случае.</target>
        </trans-unit>
        <trans-unit id="d11a6b019eb02c22d6e7924e271f0d952fce8600" translate="yes" xml:space="preserve">
          <source>For each function, a line is printed showing how many times the function is called, how many times it returns and what percentage of the function&amp;rsquo;s blocks were executed.</source>
          <target state="translated">Для каждой функции печатается строка, показывающая, сколько раз функция вызывалась, сколько раз она возвращалась и какой процент блоков функции был выполнен.</target>
        </trans-unit>
        <trans-unit id="4bcb841b4282f8986587d3e6966d3ed8c8dbe585" translate="yes" xml:space="preserve">
          <source>For each language compiled by GCC for which there is a standard, GCC attempts to follow one or more versions of that standard, possibly with some exceptions, and possibly with some extensions.</source>
          <target state="translated">Для каждого языка,скомпилированного GCC,для которого существует стандарт,GCC пытается следовать одной или более версиям этого стандарта,возможно,с некоторыми исключениями,и,возможно,с некоторыми расширениями.</target>
        </trans-unit>
        <trans-unit id="454897cc2fe9ad183bab2f7040fb6e5f25d9835d" translate="yes" xml:space="preserve">
          <source>For each named address space supported by avr-gcc there is an equally named but uppercase built-in macro defined. The purpose is to facilitate testing if respective address space support is available or not:</source>
          <target state="translated">Для каждого именованного адресного пространства,поддерживаемого avr-gcc,задан одинаково именованный,но заглавный встроенный макрос.Целью является облегчение тестирования при наличии или отсутствии поддержки соответствующего адресного пространства:</target>
        </trans-unit>
        <trans-unit id="a3f4882138b251f321ad16e203354e1a8d314d76" translate="yes" xml:space="preserve">
          <source>For each of the other indicated dump files (</source>
          <target state="translated">Для каждого из указанных файлов дампа (</target>
        </trans-unit>
        <trans-unit id="52f8ea439a283b5dc96c21715d0fefc3004bcf28" translate="yes" xml:space="preserve">
          <source>For each subprogram to be run, the compiler driver first tries the</source>
          <target state="translated">Для каждой выполняемой подпрограммы драйвер компилятора сначала пытается выполнить команду</target>
        </trans-unit>
        <trans-unit id="fdc4fc8f69b51e6f564843d4ff6b4102d66402dd" translate="yes" xml:space="preserve">
          <source>For even more AVR-specific built-in macros see &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR Named Address Spaces&lt;/a&gt; and &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR Built-in Functions&lt;/a&gt;.</source>
          <target state="translated">Для еще большего AVR-специфического встроенного макросов см &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR Именованные адресных пространств&lt;/a&gt; и &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR Встроенные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1baa0cc1603bf61303a12aa930a0094973d11cab" translate="yes" xml:space="preserve">
          <source>For example in the structure below, the member array &lt;code&gt;x&lt;/code&gt; is packed so that it immediately follows &lt;code&gt;a&lt;/code&gt; with no intervening padding:</source>
          <target state="translated">Например, в приведенной ниже структуре массив элементов &lt;code&gt;x&lt;/code&gt; упакован так, что он сразу следует за &lt;code&gt;a&lt;/code&gt; без промежуточного заполнения:</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="67c7bfe6911146baef42ccf95311646fa6de1225" translate="yes" xml:space="preserve">
          <source>For example, &amp;lsquo;</source>
          <target state="translated">Например, '</target>
        </trans-unit>
        <trans-unit id="f35aae572eaa511b9e1fec745e2f41aff9a397c4" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; might give</source>
          <target state="translated">Например, &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; может дать</target>
        </trans-unit>
        <trans-unit id="687851312bf05d13456ec79c098b24da9ffe5635" translate="yes" xml:space="preserve">
          <source>For example, GCC warns about &lt;code&gt;i&lt;/code&gt; being uninitialized in the following snippet only when</source>
          <target state="translated">Например, GCC предупреждает о том, что &lt;code&gt;i&lt;/code&gt; не инициализирован в следующем фрагменте, только когда</target>
        </trans-unit>
        <trans-unit id="481bf59d3e774632a4ae291477b6e304f7e4939c" translate="yes" xml:space="preserve">
          <source>For example, a bounded case of &lt;code&gt;alloca&lt;/code&gt; could be:</source>
          <target state="translated">Например, ограниченный случай &lt;code&gt;alloca&lt;/code&gt; может быть:</target>
        </trans-unit>
        <trans-unit id="b71521cff46dbe352ddadd34594ed3081919fa62" translate="yes" xml:space="preserve">
          <source>For example, a method with no arguments and returning &lt;code&gt;int&lt;/code&gt; would have the signature &lt;code&gt;i8@0:4&lt;/code&gt; if the size of a pointer is 4. The signature is interpreted as follows: the &lt;code&gt;i&lt;/code&gt; is the return type (an &lt;code&gt;int&lt;/code&gt;), the &lt;code&gt;8&lt;/code&gt; is the total size of the parameters in bytes (two pointers each of size 4), the &lt;code&gt;@0&lt;/code&gt; is the first parameter (an object at byte offset &lt;code&gt;0&lt;/code&gt;) and &lt;code&gt;:4&lt;/code&gt; is the second parameter (a &lt;code&gt;SEL&lt;/code&gt; at byte offset &lt;code&gt;4&lt;/code&gt;).</source>
          <target state="translated">Например, метод без аргументов и возвращающий &lt;code&gt;int&lt;/code&gt; будет иметь подпись &lt;code&gt;i8@0:4&lt;/code&gt; если размер указателя равен 4. Подпись интерпретируется следующим образом: &lt;code&gt;i&lt;/code&gt; - это тип возвращаемого значения ( &lt;code&gt;int&lt;/code&gt; ), &lt;code&gt;8&lt;/code&gt; - это общий размер параметров в байтах (два указателя размера 4 каждый), &lt;code&gt;@0&lt;/code&gt; - первый параметр (объект со смещением байта &lt;code&gt;0&lt;/code&gt; ) и &lt;code&gt;:4&lt;/code&gt; - второй параметр ( &lt;code&gt;SEL&lt;/code&gt; со смещением байта &lt;code&gt;4&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="68ba042328cca36e153d2c8dab7d8879565e3845" translate="yes" xml:space="preserve">
          <source>For example, a program may use a function &lt;code&gt;strfunc&lt;/code&gt; that returns &lt;code&gt;string&lt;/code&gt; objects, and another function &lt;code&gt;charfunc&lt;/code&gt; that operates on pointers to &lt;code&gt;char&lt;/code&gt;:</source>
          <target state="translated">Например, программа может использовать функцию &lt;code&gt;strfunc&lt;/code&gt; , которая возвращает &lt;code&gt;string&lt;/code&gt; объекты, и другую функцию &lt;code&gt;charfunc&lt;/code&gt; , которая работает с указателями на &lt;code&gt;char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88bf56d21a567365b50f7c0d1260f3e77c253d14" translate="yes" xml:space="preserve">
          <source>For example, a spec string like this:</source>
          <target state="translated">Например,такая спецификационная строка:</target>
        </trans-unit>
        <trans-unit id="9636aa78a9470d85d5322503884f630474bbcbd8" translate="yes" xml:space="preserve">
          <source>For example, an address which is constant is offsettable; so is an address that is the sum of a register and a constant (as long as a slightly larger constant is also within the range of address-offsets supported by the machine); but an autoincrement or autodecrement address is not offsettable. More complicated indirect/indexed addresses may or may not be offsettable depending on the other addressing modes that the machine supports.</source>
          <target state="translated">Например,адрес,который является константным,является смещённым;так же как и адрес,который является суммой регистра и константы (до тех пор,пока немного большая константа также находится в диапазоне смещений адресов,поддерживаемых машиной);но адрес автоинкремента или автодекрементации не является смещённым.Более сложные косвенные/индексированные адреса могут быть или не быть смещены в зависимости от других режимов адресации,поддерживаемых машиной.</target>
        </trans-unit>
        <trans-unit id="bb39fad998b5526c7cd037c77aee5706a45b5058" translate="yes" xml:space="preserve">
          <source>For example, by default a structure containing nothing but 8 &lt;code&gt;unsigned&lt;/code&gt; bit-fields of length 1 is aligned to a 4-byte boundary and has a size of 4 bytes. By using</source>
          <target state="translated">Например, по умолчанию структура, содержащая только 8 битовых полей &lt;code&gt;unsigned&lt;/code&gt; длиной 1, выровнена по 4-байтовой границе и имеет размер 4 байта. Используя</target>
        </trans-unit>
        <trans-unit id="44c92e45a35c2e3631a1416540d7623d393688e2" translate="yes" xml:space="preserve">
          <source>For example, code using the standard ISA encoding cannot jump directly to MIPS16 or microMIPS code; it must either use a call or an indirect jump.</source>
          <target state="translated">Например,код,использующий стандартную кодировку ISA,не может перейти непосредственно на MIPS16 или microMIPS-код;он должен использовать либо вызов,либо непрямой переход.</target>
        </trans-unit>
        <trans-unit id="6d3c95f985f19da9d6dbc1a830c9da53b0e26416" translate="yes" xml:space="preserve">
          <source>For example, given this C source file:</source>
          <target state="translated">Например,учитывая этот исходный файл на C:</target>
        </trans-unit>
        <trans-unit id="f0defbb763ebb18b66cf3162b2b446b84c5034e8" translate="yes" xml:space="preserve">
          <source>For example, if an x86 compiler supports two dialects (&amp;lsquo;</source>
          <target state="translated">Например, если компилятор x86 поддерживает два диалекта ('</target>
        </trans-unit>
        <trans-unit id="9b3c7e9c23ebc44c980aef19936a5699e234861d" translate="yes" xml:space="preserve">
          <source>For example, if the object file</source>
          <target state="translated">Например,если объектный файл</target>
        </trans-unit>
        <trans-unit id="6277fc8469340ab02cc75749b9fdf00e3b3028a6" translate="yes" xml:space="preserve">
          <source>For example, if the target machine requires a &lt;code&gt;double&lt;/code&gt; value to be aligned on an 8-byte boundary, then &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 8. This is true on many RISC machines. On more traditional machine designs, &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 4 or even 2.</source>
          <target state="translated">Например, если целевой компьютер требует, чтобы значение типа &lt;code&gt;double&lt;/code&gt; было выровнено по 8-байтовой границе, тогда &lt;code&gt;__alignof__ (double)&lt;/code&gt; равно 8. Это верно для многих RISC-машин. На более традиционных &lt;code&gt;__alignof__ (double)&lt;/code&gt; равно 4 или даже 2.</target>
        </trans-unit>
        <trans-unit id="ace71a372dd9faf87968abc19f07a8c712084e3c" translate="yes" xml:space="preserve">
          <source>For example, in the following function the call to &lt;code&gt;g&lt;/code&gt; is unsafe because when &lt;code&gt;overalign&lt;/code&gt; is non-zero, the space allocated by &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; may have been released at the end of the &lt;code&gt;if&lt;/code&gt; statement in which it was called.</source>
          <target state="translated">Например, в следующей функции вызов &lt;code&gt;g&lt;/code&gt; небезопасен, потому что, когда &lt;code&gt;overalign&lt;/code&gt; не равно нулю, пространство, выделенное &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; , могло быть освобождено в конце оператора &lt;code&gt;if&lt;/code&gt; , в котором он был вызван.</target>
        </trans-unit>
        <trans-unit id="b982bcc761519bf794d14c5f76ed85a5c03967e1" translate="yes" xml:space="preserve">
          <source>For example, in the following, each call to function &lt;code&gt;foo&lt;/code&gt; will print a line similar to &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; with the name of the file and the line number of the &lt;code&gt;printf&lt;/code&gt; call, the name of the function &lt;code&gt;foo&lt;/code&gt;, followed by the word &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">Например, в следующем примере каждый вызов функции &lt;code&gt;foo&lt;/code&gt; будет печатать строку, похожую на &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; с именем файла и номером строки вызова &lt;code&gt;printf&lt;/code&gt; , именем функции &lt;code&gt;foo&lt;/code&gt; , за которым следует слово &lt;code&gt;message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55f28e4d67f6e114f470b97bac400ac0e25f6328" translate="yes" xml:space="preserve">
          <source>For example, on the 68000 in a fullword instruction it is possible to use an immediate operand; but if the immediate value is between -128 and 127, better code results from loading the value into a register and using the register. This is because the load into the register can be done with a &amp;lsquo;</source>
          <target state="translated">Например, на 68000 в инструкции полного слова можно использовать непосредственный операнд; но если непосредственное значение находится между -128 и 127, лучший код получается при загрузке значения в регистр и использовании этого регистра. Это потому, что загрузка в регистр может быть выполнена с помощью символа '</target>
        </trans-unit>
        <trans-unit id="2f76b920d411b7e136fa4f9061e5e0a37ad6c0c4" translate="yes" xml:space="preserve">
          <source>For example, since the declaration of the primary function template below makes use of both attribute &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;alloc_size&lt;/code&gt; the declaration of the explicit specialization of the template is diagnosed because it is missing one of the attributes.</source>
          <target state="translated">Например, поскольку в &lt;code&gt;alloc_size&lt;/code&gt; шаблона основной функции ниже используются атрибуты &lt;code&gt;malloc&lt;/code&gt; и alloc_size, объявление явной специализации шаблона диагностируется, поскольку в нем отсутствует один из атрибутов.</target>
        </trans-unit>
        <trans-unit id="c1b19cb164dc1a4ab8a759ac490b8fde220e9c5e" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;struct A&lt;/code&gt; below is defined in some third party library header to have the alignment requirement &lt;code&gt;N&lt;/code&gt; and to force a warning whenever a variable of the type is not so aligned due to attribute &lt;code&gt;packed&lt;/code&gt;. Specifying the &lt;code&gt;copy&lt;/code&gt; attribute on the definition on the unrelated &lt;code&gt;struct B&lt;/code&gt; has the effect of copying all relevant attributes from the type referenced by the pointer expression to &lt;code&gt;struct B&lt;/code&gt;.</source>
          <target state="translated">Например, предположим, что &lt;code&gt;struct A&lt;/code&gt; ниже определена в заголовке какой-то сторонней библиотеки, чтобы иметь требование выравнивания &lt;code&gt;N&lt;/code&gt; и выдавать предупреждение всякий раз, когда переменная типа не выровнена таким образом из-за &lt;code&gt;packed&lt;/code&gt; атрибута . Задание &lt;code&gt;copy&lt;/code&gt; атрибута по определению на несвязанной &lt;code&gt;struct B&lt;/code&gt; имеет эффект копирования все соответствующие атрибуты типа , на который ссылается выражение указатель на &lt;code&gt;struct B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0be048f3761817dd96f745d3c57100422574646" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sprintf&lt;/code&gt; function on SunOS 4.1.3 returns &lt;code&gt;char *&lt;/code&gt; while the C standard says that &lt;code&gt;sprintf&lt;/code&gt; returns an &lt;code&gt;int&lt;/code&gt;. The &lt;code&gt;fixincludes&lt;/code&gt; program could make the prototype for this function match the Standard, but that would be wrong, since the function will still return &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">Например, функция &lt;code&gt;sprintf&lt;/code&gt; в SunOS 4.1.3 возвращает &lt;code&gt;char *&lt;/code&gt; ,в то время как стандарт C говорит, что &lt;code&gt;sprintf&lt;/code&gt; возвращает &lt;code&gt;int&lt;/code&gt; . Программа &lt;code&gt;fixincludes&lt;/code&gt; может заставить прототип этой функции соответствовать Стандарту, но это было бы неправильно, поскольку функция все равно будет возвращать &lt;code&gt;char *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd82a792fa22143d94897d2b758fc399175bbe0e" translate="yes" xml:space="preserve">
          <source>For example, the &lt;var&gt;StrongAlias&lt;/var&gt; macro below makes use of the &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;copy&lt;/code&gt; attributes to define an alias named &lt;var&gt;alloc&lt;/var&gt; for function &lt;var&gt;allocate&lt;/var&gt; declared with attributes &lt;var&gt;alloc_size&lt;/var&gt;, &lt;var&gt;malloc&lt;/var&gt;, and &lt;var&gt;nothrow&lt;/var&gt;. Thanks to the &lt;code&gt;__typeof__&lt;/code&gt; operator the alias has the same type as the target function. As a result of the &lt;code&gt;copy&lt;/code&gt; attribute the alias also shares the same attributes as the target.</source>
          <target state="translated">Например, &lt;var&gt;StrongAlias&lt;/var&gt; макроса ниже использует &lt;code&gt;alias&lt;/code&gt; и &lt;code&gt;copy&lt;/code&gt; атрибуты для определения псевдонима с именем &lt;var&gt;alloc&lt;/var&gt; для функции &lt;var&gt;allocate&lt;/var&gt; объявлена с атрибутами &lt;var&gt;alloc_size&lt;/var&gt; , &lt;var&gt;malloc&lt;/var&gt; и &lt;var&gt;nothrow&lt;/var&gt; . Благодаря оператору &lt;code&gt;__typeof__&lt;/code&gt; псевдоним имеет тот же тип, что и целевая функция. В результате использования атрибута &lt;code&gt;copy&lt;/code&gt; псевдоним также имеет те же атрибуты, что и целевой объект.</target>
        </trans-unit>
        <trans-unit id="5df659eda3281e74be2356574e1b1c1a2ec73bd0" translate="yes" xml:space="preserve">
          <source>For example, the call to &lt;code&gt;memset&lt;/code&gt; below is diagnosed by the warning because the function expects a value of type &lt;code&gt;size_t&lt;/code&gt; as its argument but the type of &lt;code&gt;32&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;. With</source>
          <target state="translated">Например, вызов &lt;code&gt;memset&lt;/code&gt; ниже диагностируется предупреждением, потому что функция ожидает значение типа &lt;code&gt;size_t&lt;/code&gt; в качестве аргумента, а тип &lt;code&gt;32&lt;/code&gt; - &lt;code&gt;int&lt;/code&gt; . С участием</target>
        </trans-unit>
        <trans-unit id="aa585d900b6a1decabca1b2daabff17e2775d789" translate="yes" xml:space="preserve">
          <source>For example, the compiler can only unconditionally vectorize the following loop with the pragma:</source>
          <target state="translated">Например,компилятор может только безоговорочно векторизовать следующий цикл с помощью прагмы:</target>
        </trans-unit>
        <trans-unit id="46fb01ed368f209c80511e7fc1fb91adc3f606e1" translate="yes" xml:space="preserve">
          <source>For example, the declaration of &lt;code&gt;struct Object&lt;/code&gt; in the argument list of &lt;code&gt;draw&lt;/code&gt; triggers the warning. To avoid it, either remove the redundant class-key &lt;code&gt;struct&lt;/code&gt; or replace it with &lt;code&gt;class&lt;/code&gt; to match its definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f069ed5ba8ea293548f32b787eaedf45bdbd11" translate="yes" xml:space="preserve">
          <source>For example, the declaration:</source>
          <target state="translated">Например,декларация:</target>
        </trans-unit>
        <trans-unit id="40a677ec7a2740cf56a10d8e5968835578281034" translate="yes" xml:space="preserve">
          <source>For example, the first two stores in function &lt;code&gt;bad&lt;/code&gt; are diagnosed because the array elements overlap the subsequent members &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. The third store is diagnosed by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ea9d42bbb55f00657375149871784a78c15592" translate="yes" xml:space="preserve">
          <source>For example, the following function allocates eight objects of &lt;code&gt;n&lt;/code&gt; bytes each on the stack, storing a pointer to each in consecutive elements of the array &lt;code&gt;a&lt;/code&gt;. It then passes the array to function &lt;code&gt;g&lt;/code&gt; which can safely use the storage pointed to by each of the array elements.</source>
          <target state="translated">Например, следующая функция выделяет восемь объектов по &lt;code&gt;n&lt;/code&gt; байтов каждый в стеке, сохраняя указатель на каждый из последовательных элементов массива &lt;code&gt;a&lt;/code&gt; . Затем он передает массив функции &lt;code&gt;g&lt;/code&gt; , которая может безопасно использовать хранилище, на которое указывает каждый из элементов массива.</target>
        </trans-unit>
        <trans-unit id="46ff8877e2ba5b3ad38e512c93a9f9393792e49a" translate="yes" xml:space="preserve">
          <source>For example, the following macro can be used to portably check, at compile-time, whether or not adding two constant integers will overflow, and perform the addition only when it is known to be safe and not to trigger a</source>
          <target state="translated">Например,следующий макрос может быть использован для портной проверки во время компиляции,будет ли переполняться добавление двух константных целых чисел или нет,и выполнять сложение только тогда,когда известно,что оно безопасно и не приводит в действие</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">Например,следующее:</target>
        </trans-unit>
        <trans-unit id="f3e3332c2d5e42f3076c20bce36d2593f9127ee9" translate="yes" xml:space="preserve">
          <source>For example, the implementation of the following function &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">Например, реализация следующей функции &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0e188aff9d720764d35dd90d13b53f0b69cd5a6e" translate="yes" xml:space="preserve">
          <source>For example, the intraprocedural example shown for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4fa7f73b59dbaab5c10c7cbf8d1067ea1077b7" translate="yes" xml:space="preserve">
          <source>For example, the same events as above might be printed as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a4e8c7eb0a1fa15ef7a86f7ffb6699626c80d0" translate="yes" xml:space="preserve">
          <source>For example, this function has to be used in &lt;code&gt;ifunc&lt;/code&gt; resolvers that check for CPU type using the built-in functions &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, or in constructors on targets that don&amp;rsquo;t support constructor priority.</source>
          <target state="translated">Например, эту функцию необходимо использовать в преобразователях &lt;code&gt;ifunc&lt;/code&gt; , которые проверяют тип ЦП с помощью встроенных функций &lt;code&gt;__builtin_cpu_is&lt;/code&gt; и &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; , или в конструкторах для целей, которые не поддерживают приоритет конструктора.</target>
        </trans-unit>
        <trans-unit id="1dddf36660113e27ff669ff510c160e144321d93" translate="yes" xml:space="preserve">
          <source>For example, when the compiler encounters a method invocation such as &lt;code&gt;[object init]&lt;/code&gt;, it compiles it into a call to &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; followed by a cast of the returned value to the appropriate function pointer type, and then it calls it.</source>
          <target state="translated">Например, когда компилятор встречает вызов метода, такого как &lt;code&gt;[object init]&lt;/code&gt; , он компилирует его в вызов &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; за которым следует приведение возвращаемого значения к соответствующему типу указателя функции и затем он называет это.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="25bb7aced1792aec854f4198d7d0398ca1d4713d" translate="yes" xml:space="preserve">
          <source>For full documentation of the struct attributes please see the documentation in &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">Полную документацию по атрибутам структуры см. В документации по &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;атрибутам переменных x86&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3dc81c80b4604ccbc276f437a5ccc2aaa2515f6c" translate="yes" xml:space="preserve">
          <source>For indirect calls to functions and computed goto, the linker generates &lt;em&gt;stubs&lt;/em&gt;. Stubs are jump pads sometimes also called &lt;em&gt;trampolines&lt;/em&gt;. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address.</source>
          <target state="translated">Для косвенных вызовов функций и вычисленного goto компоновщик создает &lt;em&gt;заглушки&lt;/em&gt; . Коклейки - это прыжковые площадки, иногда также называемые &lt;em&gt;батутами&lt;/em&gt; . Таким образом, косвенный вызов / переход перескакивает на такую ​​заглушку. Заглушка содержит прямой переход к нужному адресу.</target>
        </trans-unit>
        <trans-unit id="b91d6fa4ba31d00f68a512834bc7eb5f8c52df71" translate="yes" xml:space="preserve">
          <source>For information about the O64 ABI, see &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;.</source>
          <target state="translated">Для получения информации о o64 ABI см &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56ee49f1a1b16838ed8d136422788b22655be9ea" translate="yes" xml:space="preserve">
          <source>For input files in any language, generate corresponding Go declarations in &lt;var&gt;file&lt;/var&gt;. This generates Go &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; declarations which may be a useful way to start writing a Go interface to code written in some other language.</source>
          <target state="translated">Для входных файлов на любом языке сгенерируйте соответствующие объявления Go в &lt;var&gt;file&lt;/var&gt; . Это генерирует объявления Go &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;func&lt;/code&gt; , которые могут быть полезным способом начать писать интерфейс Go для кода, написанного на другом языке.</target>
        </trans-unit>
        <trans-unit id="c8ce6c094048677a9f8423fec4581d4ef1bd1e5b" translate="yes" xml:space="preserve">
          <source>For instance</source>
          <target state="translated">Например</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="a8e07e43db118dd56bbb97b1f96ccc89bac7f5fd" translate="yes" xml:space="preserve">
          <source>For instance, if the stack starts at absolute address &amp;lsquo;</source>
          <target state="translated">Например, если стек начинается с абсолютного адреса '</target>
        </trans-unit>
        <trans-unit id="6abfd7e7f05346e1123b7bf2021cc93c61b8fbd5" translate="yes" xml:space="preserve">
          <source>For instance, if you have &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt;, and you have</source>
          <target state="translated">Например, если у вас есть &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt; , и у вас есть</target>
        </trans-unit>
        <trans-unit id="5b9b6fe2256c52fcd89c847ec80034c7cbe3d49d" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could compile a function with &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt;. GCC creates two function clones, one compiled with</source>
          <target state="translated">Например, на x86 вы можете скомпилировать функцию с &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt; . GCC создает два клона функции, одна из которых скомпилирована с</target>
        </trans-unit>
        <trans-unit id="175bbce2fc22d4ed1ec7614154a0e449231ccaf1" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could declare one function with the &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; attribute and another with &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt;. This is equivalent to compiling the first function with</source>
          <target state="translated">Например, на x86, вы можете объявить одну функцию с &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; атрибут , а другой с &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt; . Это эквивалентно компиляции первой функции с</target>
        </trans-unit>
        <trans-unit id="60600b26a9fa03b6c3650e82a7d4514147301ef9" translate="yes" xml:space="preserve">
          <source>For instance, on the SB-1, if FP exceptions are disabled, and we are emitting 64-bit code, then we can use both FP pipes. Otherwise, we can only use one FP pipe.</source>
          <target state="translated">Например,на SB-1,если исключения из FP отключены,и мы излучаем 64-битный код,то мы можем использовать оба FP канала.В противном случае,мы можем использовать только одну трубу FP.</target>
        </trans-unit>
        <trans-unit id="4d64dcd6f25c2f8e61dbb8fbe7c56bdb2499ab6d" translate="yes" xml:space="preserve">
          <source>For instance, the following declarations</source>
          <target state="translated">Например,следующие заявления</target>
        </trans-unit>
        <trans-unit id="fd17d596f35be2211443642e76ceab4e5f526b5c" translate="yes" xml:space="preserve">
          <source>For internal names, all characters are significant. For external names, the number of significant characters are defined by the linker; for almost all targets, all characters are significant.</source>
          <target state="translated">Для внутренних имен все символы значимы.Для внешних имён количество значащих символов определяется компоновщиком;почти для всех целей все символы являются значащими.</target>
        </trans-unit>
        <trans-unit id="9f99386843936f29083f4368b21c1771def8a251" translate="yes" xml:space="preserve">
          <source>For library code, if you want the library to provide all of the template instantiations it needs, just try to link all of its object files together; the link will fail, but cause the instantiations to be generated as a side effect. Be warned, however, that this may cause conflicts if multiple libraries try to provide the same instantiations. For greater control, use explicit instantiation as described in the next option.</source>
          <target state="translated">Для библиотечного кода,если вы хотите,чтобы библиотека предоставила все нужные ей инстанцинации шаблона,просто попробуйте связать все ее объектные файлы вместе;связь не удастся,но приведет к тому,что инстанцинации будут сгенерированы как побочный эффект.Предупреждаем,однако,что это может привести к конфликтам,если несколько библиотек попытаются предоставить одни и те же инстанцинации.Для большего контроля используйте явные инстанцинации,как описано в следующем варианте.</target>
        </trans-unit>
        <trans-unit id="275df5c8ab338eac0891dfd5fcb7ca333c414d1c" translate="yes" xml:space="preserve">
          <source>For machines that must pop arguments after a function call, always pop the arguments as soon as each function returns. At levels</source>
          <target state="translated">Для машин,которые должны выскакивать аргументы после вызова функции,всегда выскакивайте аргументы,как только возвращается каждая функция.На уровнях</target>
        </trans-unit>
        <trans-unit id="4ab62f1721d989066bd88fccf2cddf5cca6c289c" translate="yes" xml:space="preserve">
          <source>For more information concerning the history of Objective-C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">Для получения дополнительной информации об истории Objective-C, доступной в Интернете, см. &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;Http://gcc.gnu.org/readings.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af9da95259f3bd0345f2ca30bdb8d3f07bd5caf4" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445882425cb6a5526123dcb90201317cd797b812" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">Дополнительные сведения о поддержке транзакционной памяти GCC см. &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;В&lt;/a&gt; разделе Библиотека транзакционной памяти GNU в библиотеке транзакционной памяти GNU.</target>
        </trans-unit>
        <trans-unit id="530d01e06da63e3ae60755b1d0e0664f37ce4c56" translate="yes" xml:space="preserve">
          <source>For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus</source>
          <target state="translated">Для профильных оптимизаций скомпилируйте исходные файлы снова с теми же опциями оптимизации и генерации кода плюс</target>
        </trans-unit>
        <trans-unit id="1552bee1f905030b453e9bc73123ec457682d5d2" translate="yes" xml:space="preserve">
          <source>For references to Technical Corrigenda, Rationale documents and information concerning the history of C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">Ссылки на технические исправления, документы с обоснованием и информацию об истории C, доступную в Интернете, см. На &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa91b9c573243f46d98173cb5c6bc69a14f37e" translate="yes" xml:space="preserve">
          <source>For run-time identification, the starting addresses of these areas, which correspond to their respective function entries minus &lt;var&gt;M&lt;/var&gt;, are additionally collected in the &lt;code&gt;__patchable_function_entries&lt;/code&gt; section of the resulting binary.</source>
          <target state="translated">Для идентификации во время выполнения начальные адреса этих областей, которые соответствуют их соответствующим записям функций за вычетом &lt;var&gt;M&lt;/var&gt; , дополнительно собираются в разделе &lt;code&gt;__patchable_function_entries&lt;/code&gt; результирующего двоичного файла .</target>
        </trans-unit>
        <trans-unit id="ee4662af110f3d316db91e4c9bf088b26f37f6fc" translate="yes" xml:space="preserve">
          <source>For single-precision floating-point comparisons, emit an &lt;code&gt;fsub&lt;/code&gt; instruction and test the flags. This is faster than a software comparison, but can get incorrect results in the presence of NaNs, or when two different small numbers are compared such that their difference is calculated as zero. The default is</source>
          <target state="translated">Для сравнений с плавающей запятой одинарной точности испустите инструкцию &lt;code&gt;fsub&lt;/code&gt; и проверьте флаги. Это быстрее, чем сравнение программного обеспечения, но может привести к неверным результатам при наличии NaN или при сравнении двух разных небольших чисел, так что их разница рассчитывается как ноль. По умолчанию</target>
        </trans-unit>
        <trans-unit id="629fb7062147649cb1707cc8cbe18549c87c4fce" translate="yes" xml:space="preserve">
          <source>For some target machines, GCC supports additional options to the format attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;).</source>
          <target state="translated">Для некоторых целевых машин GCC поддерживает дополнительные параметры атрибута формата (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Объявление атрибутов функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f693ccd95fd0352057c89a84d6dca28111b1d8d" translate="yes" xml:space="preserve">
          <source>For some targets, a suffix is added to the root directory specified with</source>
          <target state="translated">Для некоторых целей в корневую директорию,указанную с помощью параметра</target>
        </trans-unit>
        <trans-unit id="1eef11d2e0af6679534eba00e39380a79330c652" translate="yes" xml:space="preserve">
          <source>For string operations of unknown size, use run-time checks with inline code for small blocks and a library call for large blocks.</source>
          <target state="translated">Для строковых операций неизвестного размера используйте проверку времени выполнения с встроенным кодом для маленьких блоков и библиотечный вызов для больших блоков.</target>
        </trans-unit>
        <trans-unit id="c54c726dd72dd80b773414b86e870a30d193ec02" translate="yes" xml:space="preserve">
          <source>For systems that use the GNU C Library, the default is on.</source>
          <target state="translated">Для систем,использующих библиотеку Си GNU,по умолчанию включена.</target>
        </trans-unit>
        <trans-unit id="90889da6f3749d2d8e7f525edbcff60563fc34f5" translate="yes" xml:space="preserve">
          <source>For targets that do not support either COMDAT or weak symbols, most entities with vague linkage are emitted as local symbols to avoid duplicate definition errors from the linker. This does not happen for local statics in inlines, however, as having multiple copies almost certainly breaks things.</source>
          <target state="translated">Для целей,которые не поддерживают ни COMDAT,ни слабые символы,большинство сущностей с расплывчатой связью излучаются как локальные символы,чтобы избежать дублирования ошибок определения из компоновщика.Однако это не происходит для локальной статики в строках,так как наличие нескольких копий почти наверняка ломает вещи.</target>
        </trans-unit>
        <trans-unit id="db393fbd5a98ab60023bfd22b5dbbadca9023150" translate="yes" xml:space="preserve">
          <source>For targets that normally need trampolines for nested functions, always generate them instead of using descriptors. Otherwise, for targets that do not need them, like for example HP-PA or IA-64, do nothing.</source>
          <target state="translated">Для целей,которые обычно нуждаются в батутах для вложенных функций,всегда генерируйте их вместо использования дескрипторов.В противном случае,для целей,которые не нуждаются в них,например,HP-PA или IA-64,ничего не делать.</target>
        </trans-unit>
        <trans-unit id="3a882a0a0f801f0c1cb983c784834a8c5870b59e" translate="yes" xml:space="preserve">
          <source>For targets, like GNU/Linux, where all user-mode Xtensa code must be position-independent code (PIC), this option disables PIC for compiling kernel code.</source>
          <target state="translated">Для целей,таких как GNU/Linux,где все исходные тексты Xtensa пользовательского режима должны быть позиционно-независимыми (PIC),эта опция отключает PIC для компиляции исходных текстов ядра.</target>
        </trans-unit>
        <trans-unit id="8b8c7be3bb5a9384ba78f18abd2ee5fc45978a5a" translate="yes" xml:space="preserve">
          <source>For test coverage analysis, use &lt;code&gt;gcov&lt;/code&gt; to produce human readable information from the</source>
          <target state="translated">Для анализа тестового покрытия используйте &lt;code&gt;gcov&lt;/code&gt; для получения удобочитаемой информации из</target>
        </trans-unit>
        <trans-unit id="cdf3f70fc86ab5862691992f6df51e7ca5f5489e" translate="yes" xml:space="preserve">
          <source>For the NeXT runtime with version 2 of the ABI, check for a nil receiver in method invocations before doing the actual method call. This is the default and can be disabled using</source>
          <target state="translated">Для выполнения NeXT с версией 2 ABI,перед выполнением фактического вызова метода,проверьте нулевой приемник в вызовах методов.Это настройка по умолчанию,и ее можно отключить с помощью</target>
        </trans-unit>
        <trans-unit id="96b6c6242e369e6ead381c1d4d982f9072cadf3b" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler adds code to disable interrupts for the duration of those functions. If any functions so named are not encountered in the source, a warning is emitted that the pragma is not used. Examples:</source>
          <target state="translated">Для именованных функций компилятор добавляет код для отключения прерываний на время работы этих функций.Если какие-либо функции с таким именем в исходном коде не встречаются,выдается предупреждение о том,что прагма не используется.Примеры:</target>
        </trans-unit>
        <trans-unit id="b4ae72d8349f09925e7db4912a4034594f70873f" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler always uses a register-indirect call model when calling the named functions. Examples:</source>
          <target state="translated">Для именованных функций компилятор всегда использует модель прямого вызова из регистра при вызове именованных функций.Примеры:</target>
        </trans-unit>
        <trans-unit id="b9c34f2bc66483d538061a0df9fde1756b31b97d" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f569d15217aa1a086b40826e8ecc6305b091d9b" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%. You can also use &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; to explicitly assign a probability value to individual expressions.</source>
          <target state="translated">Для целей оптимизации прогнозирования ветвлений вероятность того, что выражение &lt;code&gt;__builtin_expect&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; , контролируется параметром &lt;code&gt;builtin-expect-probability&lt;/code&gt; GCC , который по умолчанию равен 90%. Вы также можете использовать &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; , чтобы явно присвоить значение вероятности отдельным выражениям.</target>
        </trans-unit>
        <trans-unit id="bf219c0d4bab1b7372e20c5005cc97b0b9e1bb77" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directories specified by</source>
          <target state="translated">Для формы кавычек директивы include,каталоги,указанные в каталоге</target>
        </trans-unit>
        <trans-unit id="754ebda73d52810694ef0086a8c959916039f5fd" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directory of the current file is searched first.</source>
          <target state="translated">Для формы кавычек директивы include сначала выполняется поиск директории текущего файла.</target>
        </trans-unit>
        <trans-unit id="1d70b004544bcb6341f32cbd058f337db34bac6c" translate="yes" xml:space="preserve">
          <source>For the x86-32 compiler, you must use</source>
          <target state="translated">Для компилятора x86-32 необходимо использовать</target>
        </trans-unit>
        <trans-unit id="9e1a32426c586349d0aa1e4bc4474f828e773b55" translate="yes" xml:space="preserve">
          <source>For those adding visibility support to existing code, you may find &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. This works by you enclosing the declarations you wish to set visibility for with (for example) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; and &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt;. Bear in mind that symbol visibility should be viewed &lt;strong&gt;as part of the API interface contract&lt;/strong&gt; and thus all new code should always specify visibility when it is not the default; i.e., declarations only for use within the local DSO should &lt;strong&gt;always&lt;/strong&gt; be marked explicitly as hidden as so to avoid PLT indirection overheads&amp;mdash;making this abundantly clear also aids readability and self-documentation of the code. Note that due to ISO C++ specification requirements, &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; must always be of default visibility.</source>
          <target state="translated">Для тех, кто добавляет поддержку видимости в существующий код, вы можете найти &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. Это работает, если вы включаете объявления, для которых хотите установить видимость, с помощью (например) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; и &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt; . Имейте в виду, что видимость символа должна рассматриваться &lt;strong&gt;как часть контракта интерфейса API,&lt;/strong&gt; и поэтому весь новый код всегда должен указывать видимость, если она не задана по умолчанию; т. е. объявления только для использования в локальном DSO &lt;strong&gt;всегда&lt;/strong&gt; должны быть явно помечены как скрытые, чтобы избежать косвенных накладных расходов PLT - делая это предельно ясным, также способствует удобочитаемости и самодокументированию кода. Обратите внимание, что в соответствии с требованиями спецификации ISO C ++, &lt;code&gt;operator new&lt;/code&gt; и &lt;code&gt;operator delete&lt;/code&gt; всегда должны иметь видимость по умолчанию.</target>
        </trans-unit>
        <trans-unit id="bb6de8937de1ff830849ca65a0b4291fa1ceadf7" translate="yes" xml:space="preserve">
          <source>Force (do not force) generated code to have a single exit point in each function.</source>
          <target state="translated">Принудительная (не принудительная)генерация кода,чтобы иметь единую точку выхода в каждой функции.</target>
        </trans-unit>
        <trans-unit id="acd5ffdf657527d019579abefcb2cc6ad1c27289" translate="yes" xml:space="preserve">
          <source>Force (do not force) the use of &lt;code&gt;memcpy&lt;/code&gt; for non-trivial block moves. The default is</source>
          <target state="translated">Принудительное (не принудительное) использование &lt;code&gt;memcpy&lt;/code&gt; для нетривиальных перемещений блоков. По умолчанию</target>
        </trans-unit>
        <trans-unit id="f35628fb15f3c423c03af2c93b844cb43e594383" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt; types to be 64 bits wide. See</source>
          <target state="translated">Сделать &lt;code&gt;long&lt;/code&gt; типы шириной 64 бита. Видеть</target>
        </trans-unit>
        <trans-unit id="df341c9e8e9829ab23b420935fbc32e82bb7a353" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and pointer types to be 32 bits wide.</source>
          <target state="translated">Force &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; и типы указателей 32 бита в ширину.</target>
        </trans-unit>
        <trans-unit id="a65d4b81903833686ba857ca6166053cb9c8d543" translate="yes" xml:space="preserve">
          <source>Force GCC to assign view numbers internally, if</source>
          <target state="translated">Заставить GCC присвоить внутренние номера просмотров,если</target>
        </trans-unit>
        <trans-unit id="5c6c2109c0abfbfad2c57ae80b233af1137f54d6" translate="yes" xml:space="preserve">
          <source>Force GCC to generate DWARF2+ line number tables internally, if DWARF2+ line number tables are to be generated.</source>
          <target state="translated">Заставьте GCC создавать внутренние таблицы номеров строк DWARF2+,если необходимо создать таблицы номеров строк DWARF2+.</target>
        </trans-unit>
        <trans-unit id="e05ff97a2114aff3fe8702e99f968b0b9b270faf" translate="yes" xml:space="preserve">
          <source>Force all calls to functions to be indirect. This is useful when using Intel Processor Trace where it generates more precise timing information for function calls.</source>
          <target state="translated">Заставьте все вызовы к функциям быть косвенными.Это полезно при использовании Intel Processor Trace,где он генерирует более точную временную информацию для вызовов функций.</target>
        </trans-unit>
        <trans-unit id="c6aa1876252f253f5c49c98017976af7ef3a9f80" translate="yes" xml:space="preserve">
          <source>Force all functions to be aligned to a 4-byte boundary.</source>
          <target state="translated">Принудительно выровнять все функции по 4-байтовой границе.</target>
        </trans-unit>
        <trans-unit id="5376700e1a5ed02b4facb60bd51b070a514bbd9d" translate="yes" xml:space="preserve">
          <source>Force all load and store instructions to always bypass cache by using I/O variants of the instructions. The default is not to bypass the cache.</source>
          <target state="translated">Заставьте все инструкции по загрузке и хранению всегда обходить кэш-память,используя варианты инструкций по вводу/выводу.По умолчанию не следует обходить кэш.</target>
        </trans-unit>
        <trans-unit id="6ba14189273ea29b59425c68e227901a2b9a86ef" translate="yes" xml:space="preserve">
          <source>Force assembly output to always use hex constants. Normally such constants are signed decimals, but this option is available for testsuite and/or aesthetic purposes.</source>
          <target state="translated">Выход силовой сборки,чтобы всегда использовать шестнадцатиричные константы.Обычно такие константы представляют собой подписанные десятичные знаки,но этот вариант доступен для тестовых и/или эстетических целей.</target>
        </trans-unit>
        <trans-unit id="a09ed1d5a3164af1580e37f843c9d03a7f3d9584" translate="yes" xml:space="preserve">
          <source>Force code generation in the ARM (A32) ISA.</source>
          <target state="translated">Форсированная генерация кода в ARM (A32)ISA.</target>
        </trans-unit>
        <trans-unit id="8cf31b1c6efcebcf276d6ea54117f6f86a1ab3b3" translate="yes" xml:space="preserve">
          <source>Force code generation in the Thumb (T16/T32) ISA, depending on the architecture level.</source>
          <target state="translated">Форсированное генерирование кода на большом пальце (T16/T32)ISA,в зависимости от уровня архитектуры.</target>
        </trans-unit>
        <trans-unit id="57fc3d2f95e9a264681cfb6c086d3f11381e6d22" translate="yes" xml:space="preserve">
          <source>Force indirect call and jump via register.</source>
          <target state="translated">Принудительный косвенный вызов и прыжок через регистр.</target>
        </trans-unit>
        <trans-unit id="c2234a2c2c6fa572bb9aaff40c528a12cc4c9fff" translate="yes" xml:space="preserve">
          <source>Force the usage of delay slots for conditional branches, which stuffs the delay slot with a &lt;code&gt;nop&lt;/code&gt; if a suitable instruction cannot be found. By default this option is disabled. It can be enabled to work around hardware bugs as found in the original SH7055.</source>
          <target state="translated">Принудительное использование слотов задержки для условных переходов, при котором слот задержки &lt;code&gt;nop&lt;/code&gt; если подходящая инструкция не может быть найдена. По умолчанию эта опция отключена. Его можно включить для обхода аппаратных ошибок, обнаруженных в исходном SH7055.</target>
        </trans-unit>
        <trans-unit id="accd79a6ab2ab26b14a5acf0e4624a9287eb4f98" translate="yes" xml:space="preserve">
          <source>Force to call a function using jli_s instruction. This option is valid only for ARCv2 architecture.</source>
          <target state="translated">Принудительный вызов функции с помощью команды jli_s.Эта опция действительна только для архитектуры ARCv2.</target>
        </trans-unit>
        <trans-unit id="bda8d8b269a45b97f862176d65bac6c1e4f4afe4" translate="yes" xml:space="preserve">
          <source>Forces a particular function to be called using &lt;code&gt;jli&lt;/code&gt; instruction. The &lt;code&gt;jli&lt;/code&gt; instruction makes use of a table stored into &lt;code&gt;.jlitab&lt;/code&gt; section, which holds the location of the functions which are addressed using this instruction.</source>
          <target state="translated">&lt;code&gt;jli&lt;/code&gt; конкретную функцию с помощью инструкции jli . В &lt;code&gt;jli&lt;/code&gt; инструкции используют таблицы , хранящиеся в &lt;code&gt;.jlitab&lt;/code&gt; секцию, которая содержит расположение функций , которые рассматриваются с помощью этой инструкции.</target>
        </trans-unit>
        <trans-unit id="2f084ee73c513d8f966bbd0c40980e7ab5210b2e" translate="yes" xml:space="preserve">
          <source>Formal syntax for attributes.</source>
          <target state="translated">Формальный синтаксис для атрибутов.</target>
        </trans-unit>
        <trans-unit id="6e97cc41857aff390c1d1352f1580ff15ac71869" translate="yes" xml:space="preserve">
          <source>Format checks specific to particular targets.</source>
          <target state="translated">Формат проверяет конкретные цели.</target>
        </trans-unit>
        <trans-unit id="c4653752f8662d9cf50820b53f4f92b88244d0b2" translate="yes" xml:space="preserve">
          <source>Formerly the &lt;code&gt;hi&lt;/code&gt; register. This constraint is no longer supported.</source>
          <target state="translated">Раньше &lt;code&gt;hi&lt;/code&gt; регистр. Это ограничение больше не поддерживается.</target>
        </trans-unit>
        <trans-unit id="fb001b2c292ad2f619c8caf6e0ac8afd191aaa76" translate="yes" xml:space="preserve">
          <source>Framework</source>
          <target state="translated">Framework</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="a4a10834211c2c0fbcb7eeb4d7d706ce399ad1a9" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">Свободная форма исходного кода Fortran,который должен быть препроцессирован (с помощью традиционного препроцессора).</target>
        </trans-unit>
        <trans-unit id="ab1de10d533c059aa65605ce6bb4a93b10329a51" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that should not be preprocessed.</source>
          <target state="translated">Свободная форма исходных текстов Fortran,которые не должны препроцессироваться.</target>
        </trans-unit>
        <trans-unit id="79c3d4c459214fa53411ede2a681be19e9178e25" translate="yes" xml:space="preserve">
          <source>Fully split wide types early, instead of very late. This option has no effect unless</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3ade0ff4647a9f20d6dba70ea3a9f2cb1aec15" translate="yes" xml:space="preserve">
          <source>Function Pointer Size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5888490bf4ce1fb3617e200efdb6835e0c4faa44" translate="yes" xml:space="preserve">
          <source>Function attributes are introduced by the &lt;code&gt;__attribute__&lt;/code&gt; keyword in the declaration of a function, followed by an attribute specification enclosed in double parentheses. You can specify multiple attributes in a declaration by separating them by commas within the double parentheses or by immediately following one attribute specification with another. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for the exact rules on attribute syntax and placement. Compatible attribute specifications on distinct declarations of the same function are merged. An attribute specification that is not compatible with attributes already applied to a declaration of the same function is ignored with a warning.</source>
          <target state="translated">Атрибуты функции вводятся ключевым словом &lt;code&gt;__attribute__&lt;/code&gt; в объявлении функции, за которым следует спецификация атрибута, заключенная в двойные круглые скобки. Вы можете указать несколько атрибутов в объявлении, разделив их запятыми в двойных скобках или сразу после одной спецификации атрибута за другой. См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; точные правила синтаксиса и размещения атрибутов. Совместимые спецификации атрибутов для разных объявлений одной и той же функции объединяются. Спецификация атрибута, несовместимая с атрибутами, уже примененными к объявлению той же функции, игнорируется с предупреждением.</target>
        </trans-unit>
        <trans-unit id="f93ed46e6d86f7b87373026d5e663168479db390" translate="yes" xml:space="preserve">
          <source>Function precision. The trap handler can determine the function that caused a floating-point exception.</source>
          <target state="translated">Точность функционирования.Обработчик ловушки может определить функцию,которая вызвала исключение с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="d3d655b1f77fc46f162e436abc252a9dc6d8148d" translate="yes" xml:space="preserve">
          <source>Function prototype</source>
          <target state="translated">Прототип функции</target>
        </trans-unit>
        <trans-unit id="9e039f9c7013d88c23a38a281ed14037c4166f2d" translate="yes" xml:space="preserve">
          <source>Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.</source>
          <target state="translated">Переупорядочивание функций на основе профильных приборов собирает первый раз выполнения функции и упорядочивает эти функции в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="84a74152b608e42b8dbf493e4c08ff7789383e02" translate="yes" xml:space="preserve">
          <source>Function return values larger than 64 bits are passed by using a hidden pointer as the first argument of the function. TI ABI, though, mandates that the pointer can be NULL in case the caller is not using the returned value. GNU always passes and expects a valid return value pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33f90e4120ff23ca44b34b56f5771105ef3b24d" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 16-bit boundaries.</source>
          <target state="translated">Функции выравниваются по 16-битным границам.</target>
        </trans-unit>
        <trans-unit id="34be57d225a7e4b91308288bf7b00a21a76d0703" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 32-bit boundaries, unless optimizing for size.</source>
          <target state="translated">Функции выравниваются по 32-битным границам,если не оптимизировать размер.</target>
        </trans-unit>
        <trans-unit id="5a29ddf72dc39612a3206ea0dfa0993bffe35aee" translate="yes" xml:space="preserve">
          <source>Functions declared with the &lt;code&gt;naked&lt;/code&gt; attribute also require basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">Функции, объявленные с атрибутом &lt;code&gt;naked&lt;/code&gt; , также требуют базового &lt;code&gt;asm&lt;/code&gt; (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b405d9a1c02455968daea5fb86ad7161a05b238c" translate="yes" xml:space="preserve">
          <source>Functions from different modes can be inlined in the caller&amp;rsquo;s mode.</source>
          <target state="translated">Функции из разных режимов могут быть встроены в режим вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="a51173ce4592b6408dafbf5dcd763cb00409451e" translate="yes" xml:space="preserve">
          <source>Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller.</source>
          <target state="translated">Функции прологов/эпилогов расширяются по мере вызова соответствующих подпрограмм.Размер кода меньше.</target>
        </trans-unit>
        <trans-unit id="958942a81a4fb21510019af4adcbaec4037ab18c" translate="yes" xml:space="preserve">
          <source>Functions that are normally built in but do not have semantics defined by ISO C (such as &lt;code&gt;alloca&lt;/code&gt; and &lt;code&gt;ffs&lt;/code&gt;) are not built-in functions when</source>
          <target state="translated">Функции, которые обычно встроены, но не имеют семантики, определенной ISO C (например, &lt;code&gt;alloca&lt;/code&gt; и &lt;code&gt;ffs&lt;/code&gt; ), не являются встроенными функциями, когда</target>
        </trans-unit>
        <trans-unit id="a77748cc250a919f08dac1cbb97eb54cbd2d36e9" translate="yes" xml:space="preserve">
          <source>Funding Free Software</source>
          <target state="translated">Финансирование свободного программного обеспечения</target>
        </trans-unit>
        <trans-unit id="ad51c11605482040955d96c2db6f7d9f4eca570e" translate="yes" xml:space="preserve">
          <source>Furthermore, if the &lt;em&gt;earlyclobber&lt;/em&gt; operand is also a read/write operand, then that operand is written only after it&amp;rsquo;s used.</source>
          <target state="translated">Более того, если операнд &lt;em&gt;Earlyclobber&lt;/em&gt; также является операндом чтения / записи, то этот операнд записывается только после его использования.</target>
        </trans-unit>
        <trans-unit id="8c1a9865dc580dc97d71f0ac34525d7ff40826cf" translate="yes" xml:space="preserve">
          <source>Future versions of GCC may zero-extend, or use a target-defined &lt;code&gt;ptr_extend&lt;/code&gt; pattern. Do not rely on sign extension.</source>
          <target state="translated">Будущие версии GCC могут расширяться с нуля или использовать определенный &lt;code&gt;ptr_extend&lt;/code&gt; шаблон ptr_extend . Не полагайтесь на расширение знака.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="6ed55690929b9e60aff3a9282723cba6d9ce77ea" translate="yes" xml:space="preserve">
          <source>G++ allows a virtual function returning &amp;lsquo;</source>
          <target state="translated">G ++ позволяет возвращать виртуальную функцию '</target>
        </trans-unit>
        <trans-unit id="5114ba459fc06431a44841ea4654eb2a26a6c91e" translate="yes" xml:space="preserve">
          <source>G++ allows anonymous structs and unions to have members that are not public non-static data members (i.e. fields). These extensions are deprecated.</source>
          <target state="translated">G++позволяет анонимным структурам и объединениям иметь членов,не являющихся публичными нестатистическими членами данных (т.е.полей).Эти расширения являются устаревшими.</target>
        </trans-unit>
        <trans-unit id="de3e575c048ce4bfb45f20c4e2302053983a6e85" translate="yes" xml:space="preserve">
          <source>G++ allows attributes to follow a parenthesized direct initializer, e.g. &amp;lsquo;</source>
          <target state="translated">G ++ позволяет атрибутам следовать за прямым инициализатором в скобках, например '</target>
        </trans-unit>
        <trans-unit id="4279ad338a301cce60cdfae7e5135ebd09b1878c" translate="yes" xml:space="preserve">
          <source>G++ allows floating-point literals to appear in integral constant expressions, e.g. &amp;lsquo;</source>
          <target state="translated">G ++ позволяет использовать литералы с плавающей запятой в целочисленных константных выражениях, например '</target>
        </trans-unit>
        <trans-unit id="c5b988dd39fdeb99ab7e438425f37e6884df0f08" translate="yes" xml:space="preserve">
          <source>G++ allows static data members of const floating-point type to be declared with an initializer in a class definition. The standard only allows initializers for static members of const integral types and const enumeration types so this extension has been deprecated and will be removed from a future version.</source>
          <target state="translated">G++позволяет объявлять статические члены данных типа const с плавающей точкой с инициализатором в определении класса.Стандарт допускает только инициализаторы статических членов const интегральных типов и типов перечисления const,поэтому данное расширение было устарело и будет удалено из будущей версии.</target>
        </trans-unit>
        <trans-unit id="63f7f4841ad757c79aac590be15aedf6621086d6" translate="yes" xml:space="preserve">
          <source>G++ implements the &amp;ldquo;intuitive&amp;rdquo; algorithm for copy-assignment: assign all direct bases, then assign all members. In that algorithm, the virtual base subobject can be encountered more than once. In the example, copying proceeds in the following order: &amp;lsquo;</source>
          <target state="translated">G ++ реализует &amp;laquo;интуитивно понятный&amp;raquo; алгоритм для копирования-присваивания: присваивает все прямые базы, затем присваивает всем членам. В этом алгоритме виртуальный базовый подобъект может встречаться более одного раза. В этом примере копирование происходит в следующем порядке: '</target>
        </trans-unit>
        <trans-unit id="67e3c9106f6559177c33511b2d979e92d246d3b0" translate="yes" xml:space="preserve">
          <source>G++ implements the Borland model on targets where the linker supports it, including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows. Otherwise G++ implements neither automatic model.</source>
          <target state="translated">G++реализует модель Borland на объектах,где компоновщик поддерживает ее,в том числе на объектах ELF (таких как GNU/Linux),Mac OS X и Microsoft Windows.В противном случае G++не реализует автоматическую модель.</target>
        </trans-unit>
        <trans-unit id="31ff568d5d2e9d2f6743afcdc5f3a983bc913e2f" translate="yes" xml:space="preserve">
          <source>G++ implements the same behavior as GCC does when assigning to a volatile object&amp;mdash;there is no reread of the assigned-to object, the assigned rvalue is reused. Note that in C++ assignment expressions are lvalues, and if used as an lvalue, the volatile object is referred to. For instance, &lt;var&gt;vref&lt;/var&gt; refers to &lt;var&gt;vobj&lt;/var&gt;, as expected, in the following example:</source>
          <target state="translated">G ++ реализует то же поведение, что и GCC, при назначении изменчивому объекту - повторное считывание назначенного объекта не выполняется, назначенное rvalue используется повторно. Обратите внимание, что в выражениях присваивания C ++ используются lvalue, и если они используются в качестве lvalue, происходит ссылка на изменчивый объект. Например, &lt;var&gt;vref&lt;/var&gt; ссылается на &lt;var&gt;vobj&lt;/var&gt; , как и ожидалось, в следующем примере:</target>
        </trans-unit>
        <trans-unit id="a1650ba68fd434ff4571a3ae6e0e946daaa36507" translate="yes" xml:space="preserve">
          <source>G3</source>
          <target state="translated">G3</target>
        </trans-unit>
        <trans-unit id="57c24c56c83113e722078337cfe2d513db43c570" translate="yes" xml:space="preserve">
          <source>G4</source>
          <target state="translated">G4</target>
        </trans-unit>
        <trans-unit id="75cc572d557c39d31a9a311423998e30b6913f73" translate="yes" xml:space="preserve">
          <source>G5</source>
          <target state="translated">G5</target>
        </trans-unit>
        <trans-unit id="47bc5f06e2bc84be8cac3eeae94be31fd0bb67f8" translate="yes" xml:space="preserve">
          <source>GBR</source>
          <target state="translated">GBR</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="2128b3c47a543c2fd225378159dcf1cee572dc1a" translate="yes" xml:space="preserve">
          <source>GCC aims towards being usable as a conforming freestanding implementation, or as the compiler for a conforming hosted implementation. By default, it acts as the compiler for a hosted implementation, defining &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard. To make it act as a conforming freestanding implementation for a freestanding environment, use the option</source>
          <target state="translated">GCC стремится к тому, чтобы его можно было использовать как соответствующую автономную реализацию или как компилятор для соответствующей размещенной реализации. По умолчанию он действует как компилятор для размещенной реализации, определяя &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; как &lt;code&gt;1&lt;/code&gt; и предполагая, что, когда используются имена функций ISO C, они имеют семантику, определенную в стандарте. Чтобы заставить его работать как соответствующую автономную реализацию для автономной среды, используйте параметр</target>
        </trans-unit>
        <trans-unit id="a09efcf4281abbe557aa1d8c0037c8b8db485c71" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on C labels. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC позволяет устанавливать атрибуты на метках C. См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; подробную информацию о точном синтаксисе использования атрибутов. Другие атрибуты доступны для функций (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), переменных (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ), счетчиков (см. &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Атрибуты перечислителя&lt;/a&gt; ), операторов (см. &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Атрибуты&lt;/a&gt; операторов ) и для типов (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="188d2c46ce847222650ff9a197ae21b6d36834fd" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on enumerators. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC позволяет устанавливать атрибуты для счетчиков. См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; подробную информацию о точном синтаксисе использования атрибутов. Другие атрибуты доступны для функций (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), переменных (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ), меток (см. &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Атрибуты меток&lt;/a&gt; ), операторов (см. &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Атрибуты&lt;/a&gt; операторов ) и типов (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1318f5f0c876968e4d22801744660b2a68a5dbc1" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on null statements. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC позволяет устанавливать атрибуты для пустых операторов. См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; подробную информацию о точном синтаксисе использования атрибутов. Другие атрибуты доступны для функций (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), переменных (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ), меток (см. &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Атрибуты меток&lt;/a&gt; ), счетчиков (см. &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Атрибуты перечислителя&lt;/a&gt; ) и для типов (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f7518a10a612c3aa4683ccb174e0aca674b8c50" translate="yes" xml:space="preserve">
          <source>GCC allows static initialization of flexible array members. This is equivalent to defining a new structure containing the original structure followed by an array of sufficient size to contain the data. E.g. in the following, &lt;code&gt;f1&lt;/code&gt; is constructed as if it were declared like &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">GCC позволяет статическую инициализацию гибких элементов массива. Это эквивалентно определению новой структуры, содержащей исходную структуру, за которой следует массив достаточного размера для хранения данных. Например, в дальнейшем &lt;code&gt;f1&lt;/code&gt; создается так, как если бы он был объявлен как &lt;code&gt;f2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f25be809d122cad042e0db0bcc9a75b7e95df2b" translate="yes" xml:space="preserve">
          <source>GCC allows the user to selectively enable or disable certain types of diagnostics, and change the kind of the diagnostic. For example, a project&amp;rsquo;s policy might require that all sources compile with</source>
          <target state="translated">GCC позволяет пользователю выборочно включать или отключать определенные типы диагностики и изменять тип диагностики. Например, политика проекта может требовать, чтобы все источники компилировались с</target>
        </trans-unit>
        <trans-unit id="095246dfc125cf940fca19907500328219191dc3" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type, but only under the following circumstances:</source>
          <target state="translated">GCC позволяет использовать имя &lt;code&gt;typedef&lt;/code&gt; в качестве спецификатора типа для векторного типа, но только при следующих обстоятельствах:</target>
        </trans-unit>
        <trans-unit id="118ab2384628648bceb8c24d3c1faa22f9cfc67a" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type.</source>
          <target state="translated">GCC позволяет использовать имя &lt;code&gt;typedef&lt;/code&gt; в качестве спецификатора типа для векторного типа.</target>
        </trans-unit>
        <trans-unit id="4dbc0782ac4d82d0f286d4feca2e87d560c81769" translate="yes" xml:space="preserve">
          <source>GCC allows you to declare &lt;em&gt;local labels&lt;/em&gt; in any nested block scope. A local label is just like an ordinary label, but you can only reference it (with a &lt;code&gt;goto&lt;/code&gt; statement, or by taking its address) within the block in which it is declared.</source>
          <target state="translated">GCC позволяет объявлять &lt;em&gt;локальные метки&lt;/em&gt; в любой вложенной области блока. Локальная метка похожа на обычную метку, но вы можете ссылаться на нее (с помощью &lt;code&gt;goto&lt;/code&gt; или взяв ее адрес) только в блоке, в котором она объявлена.</target>
        </trans-unit>
        <trans-unit id="11edda20db587e9081a40a5791b651f14e5edef4" translate="yes" xml:space="preserve">
          <source>GCC allows you to use</source>
          <target state="translated">GCC позволяет использовать</target>
        </trans-unit>
        <trans-unit id="cb8172c4270b6a56a430a2344a1d357df8a89c7e" translate="yes" xml:space="preserve">
          <source>GCC already has an extensive list of suffixes built into it. This directive adds an entry to the end of the list of suffixes, but since the list is searched from the end backwards, it is effectively possible to override earlier entries using this technique.</source>
          <target state="translated">В GCC уже есть обширный список суффиксов,встроенных в него.Эта директива добавляет запись в конец списка суффиксов,но так как поиск в списке выполняется с конца в обратном направлении,то,по сути,с помощью этой техники можно переопределить более ранние записи.</target>
        </trans-unit>
        <trans-unit id="4946c9e7401c541aac6237c0b11a4f8762636048" translate="yes" xml:space="preserve">
          <source>GCC also defines the macro &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; when tuning for ColdFire microarchitecture &lt;var&gt;uarch&lt;/var&gt;, where &lt;var&gt;uarch&lt;/var&gt; is one of the arguments given above.</source>
          <target state="translated">GCC также определяет макрос &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; при настройке для ColdFire микроархитектуры &lt;var&gt;uarch&lt;/var&gt; , где &lt;var&gt;uarch&lt;/var&gt; является одним из приведенных выше аргументов.</target>
        </trans-unit>
        <trans-unit id="bd57161c41c158f961b92f3f1147120413b6477d" translate="yes" xml:space="preserve">
          <source>GCC also knows implicitly that arguments starting in</source>
          <target state="translated">GCC также неявно знает,что аргументы,начинающиеся с</target>
        </trans-unit>
        <trans-unit id="5590aa7708108855eef5df246b0491a821f68f35" translate="yes" xml:space="preserve">
          <source>GCC also offers a simple mechanism for printing messages during compilation.</source>
          <target state="translated">GCC также предлагает простой механизм печати сообщений во время компиляции.</target>
        </trans-unit>
        <trans-unit id="ff5eb1c7d3d1103b9c01d9df5e0e050903b1adc0" translate="yes" xml:space="preserve">
          <source>GCC also provides a target specific macro &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;, which is the largest alignment ever used for any data type on the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">GCC также предоставляет целевой макрос &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; , который является самым большим выравниванием, когда-либо используемым для любого типа данных на целевой машине, для которой вы компилируете. Например, вы можете написать:</target>
        </trans-unit>
        <trans-unit id="1ce6a581ce58e7b0e52deb0ba48b6684312e9d7c" translate="yes" xml:space="preserve">
          <source>GCC also provides intrinsics to directly access the network registers. The intrinsics are:</source>
          <target state="translated">GCC также предоставляет встроенные средства прямого доступа к сетевым регистрам.Искреннеприсущие:</target>
        </trans-unit>
        <trans-unit id="028d66aa5e30f9984efa701c3d35086edefd3f65" translate="yes" xml:space="preserve">
          <source>GCC also supports attributes on variable declarations (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC также поддерживает атрибуты в объявлениях переменных (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ), метках (см. &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Атрибуты меток&lt;/a&gt; ), счетчиках (см. &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Атрибуты перечислителя&lt;/a&gt; ), операторах (см. &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Атрибуты&lt;/a&gt; операторов ) и типах (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="51353b73f0da65e20b68eea37e8d612e8b885954" translate="yes" xml:space="preserve">
          <source>GCC also warns about function definitions that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Again, these are only possible candidates. GCC guesses that &lt;code&gt;format&lt;/code&gt; attributes might be appropriate for any function that calls a function like &lt;code&gt;vprintf&lt;/code&gt; or &lt;code&gt;vscanf&lt;/code&gt;, but this might not always be the case, and some functions for which &lt;code&gt;format&lt;/code&gt; attributes are appropriate may not be detected.</source>
          <target state="translated">GCC также предупреждает об определениях функций, которые могут быть кандидатами на атрибуты &lt;code&gt;format&lt;/code&gt; . Опять же, это только возможные кандидаты. GCC предполагает, что атрибуты &lt;code&gt;format&lt;/code&gt; могут быть подходящими для любой функции, которая вызывает такую ​​функцию, как &lt;code&gt;vprintf&lt;/code&gt; или &lt;code&gt;vscanf&lt;/code&gt; , но это может быть не всегда так, и некоторые функции, для которых подходят атрибуты &lt;code&gt;format&lt;/code&gt; , могут не обнаруживаться.</target>
        </trans-unit>
        <trans-unit id="e6346f95ac263c787786ddc66b5d9c0bcd8bac71" translate="yes" xml:space="preserve">
          <source>GCC always follows the C99 and C11 requirement that the result of division is truncated towards zero.</source>
          <target state="translated">GCC всегда следует требованиям C99 и C11 о том,чтобы результат деления был усечен до нуля.</target>
        </trans-unit>
        <trans-unit id="71e58c529399ec16a2da4be1a53c86f1d271b88e" translate="yes" xml:space="preserve">
          <source>GCC always tries to compile your program if possible; it never gratuitously rejects a program whose meaning is clear merely because (for instance) it fails to conform to a standard. In some cases, however, the C and C++ standards specify that certain extensions are forbidden, and a diagnostic &lt;em&gt;must&lt;/em&gt; be issued by a conforming compiler. The</source>
          <target state="translated">GCC всегда пытается скомпилировать вашу программу, если это возможно; он никогда не отвергает необоснованно программу, смысл которой ясен, просто потому, что (например) она не соответствует стандарту. Однако в некоторых случаях стандарты C и C ++ указывают, что определенные расширения запрещены, и соответствующий компилятор &lt;em&gt;должен&lt;/em&gt; выдать диагностику .</target>
        </trans-unit>
        <trans-unit id="3d850d85ff9e9c0132b4336d9517c8233fd73c22" translate="yes" xml:space="preserve">
          <source>GCC by default uses the GNU Objective-C runtime library, which is part of GCC and is not the same as the Apple/NeXT Objective-C runtime library used on Apple systems. There are a number of differences documented in this manual. The options</source>
          <target state="translated">GCC по умолчанию пользуется библиотекой времени исполнения GNU Objective-C,которая является частью GCC и не совпадает с библиотекой времени исполнения Apple/NeXT Objective-C,используемой в системах Apple.В этом руководстве документально зафиксирован ряд различий.Варианты</target>
        </trans-unit>
        <trans-unit id="1c0b38c968b6ef5ec06e42505963f829a108bef3" translate="yes" xml:space="preserve">
          <source>GCC by itself attempts to be a conforming freestanding implementation. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of what this means. Beyond the library facilities required of such an implementation, the rest of the C library is supplied by the vendor of the operating system. If that C library doesn&amp;rsquo;t conform to the C standards, then your programs might get warnings (especially when using</source>
          <target state="translated">GCC сам по себе пытается быть соответствующей автономной реализацией. См. &amp;laquo; &lt;a href=&quot;standards#Standards&quot;&gt;Языковые стандарты, поддерживаемые GCC&amp;raquo;&lt;/a&gt; , чтобы узнать, что это означает. Помимо средств библиотеки, требуемых для такой реализации, остальная часть библиотеки C предоставляется поставщиком операционной системы. Если эта библиотека C не соответствует стандартам C, ваши программы могут получать предупреждения (особенно при использовании</target>
        </trans-unit>
        <trans-unit id="a367622db7093a4cc9943cb9b928ad16a228659d" translate="yes" xml:space="preserve">
          <source>GCC can allocate complex automatic variables in a noncontiguous fashion; it&amp;rsquo;s even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF debug info format can represent this, so use of DWARF is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable&amp;rsquo;s actual name is &lt;code&gt;foo&lt;/code&gt;, the two fictitious variables are named &lt;code&gt;foo$real&lt;/code&gt; and &lt;code&gt;foo$imag&lt;/code&gt;. You can examine and set these two fictitious variables with your debugger.</source>
          <target state="translated">GCC может распределять сложные автоматические переменные несмежным образом; возможно даже, что реальная часть находится в регистре, а мнимая часть находится в стеке (или наоборот). Это может представлять только формат отладочной информации DWARF, поэтому рекомендуется использовать DWARF. Если вы используете формат отладочной информации stabs, GCC описывает несмежную сложную переменную, как если бы это были две отдельные переменные несложного типа. Если фактическое имя переменной - &lt;code&gt;foo&lt;/code&gt; , две фиктивные переменные называются &lt;code&gt;foo$real&lt;/code&gt; и &lt;code&gt;foo$imag&lt;/code&gt; . Вы можете проверить и установить эти две фиктивные переменные с помощью отладчика.</target>
        </trans-unit>
        <trans-unit id="8c74211307275623a7dfd79983ff1fca91bf2ce8" translate="yes" xml:space="preserve">
          <source>GCC can also be configured (via the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f3d3d856350fe50d86862ccf0921b96281e6bd" translate="yes" xml:space="preserve">
          <source>GCC can compile the binary representation (BRIG) of the HSAIL text format as described in HSA Programmer&amp;rsquo;s Reference Manual version 1.0.1. This capability is typically utilized to implement the HSA runtime API&amp;rsquo;s HSAIL finalization extension for a gcc supported processor. HSA standards are freely available at &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;.</source>
          <target state="translated">GCC может компилировать двоичное представление (BRIG) текстового формата HSAIL, как описано в Справочном руководстве программиста HSA версии 1.0.1. Эта возможность обычно используется для реализации расширения финализации HSAIL API среды выполнения HSA для процессора, поддерживаемого gcc. Стандарты HSA находятся в свободном доступе по адресу &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87356dae6f4ed6235c36eedc0fe148afee6229d9" translate="yes" xml:space="preserve">
          <source>GCC can generate code for both VxWorks kernels and real time processes (RTPs). This option switches from the former to the latter. It also defines the preprocessor macro &lt;code&gt;__RTP__&lt;/code&gt;.</source>
          <target state="translated">GCC может генерировать код как для ядер VxWorks, так и для процессов реального времени (RTP). Эта опция переключается с первого на второй. Он также определяет макрос препроцессора &lt;code&gt;__RTP__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb9f5282eec43cb95e4c422b1995ae6896ab686c" translate="yes" xml:space="preserve">
          <source>GCC can only handle one commutative pair in an asm; if you use more, the compiler may fail. Note that you need not use the modifier if the two alternatives are strictly identical; this would only waste time in the reload pass.</source>
          <target state="translated">GCC может обрабатывать только одну коммутативную пару в asm;если вы используете больше,компилятор может выйти из строя.Обратите внимание,что вам не нужно использовать модификатор,если две альтернативы строго идентичны;это только потратит время на перезагрузку.</target>
        </trans-unit>
        <trans-unit id="78d74922e82c5075040c6a08c44444ac34a5ad2a" translate="yes" xml:space="preserve">
          <source>GCC comes with shell scripts to fix certain known problems in system header files. They install corrected copies of various header files in a special directory where only GCC will normally look for them. The scripts adapt to various systems by searching all the system header files for the problem cases that we know about.</source>
          <target state="translated">GCC поставляется со скриптами оболочки для исправления некоторых известных проблем в системных заголовочных файлах.Они устанавливают исправленные копии различных заголовочных файлов в специальный каталог,где их обычно ищет только GCC.Скрипты приспосабливаются к различным системам путем поиска во всех системных заголовочных файлах известных нам проблемных случаев.</target>
        </trans-unit>
        <trans-unit id="cd976cd951c888839dc15c99651c6a379e4c0cac" translate="yes" xml:space="preserve">
          <source>GCC compiled code sometimes emits warnings from the HP-UX assembler of the form:</source>
          <target state="translated">Иногда скомпилированный GCC код выдает предупреждения от ассемблера формы HP-UX:</target>
        </trans-unit>
        <trans-unit id="81e4ed9eaf205df3f6c599be30d212f56ac91924" translate="yes" xml:space="preserve">
          <source>GCC complains about program fragments such as &amp;lsquo;</source>
          <target state="translated">GCC жалуется на такие фрагменты программы, как '</target>
        </trans-unit>
        <trans-unit id="67982454dd3e3b7d64f34362d5f739d9716bb143" translate="yes" xml:space="preserve">
          <source>GCC complains about unterminated character constants inside of preprocessing conditionals that fail. Some programs have English comments enclosed in conditionals that are guaranteed to fail; if these comments contain apostrophes, GCC will probably report an error. For example, this code would produce an error:</source>
          <target state="translated">GCC жалуется на непрекращающиеся константы характера внутри условий препроцессирования,которые выходят из строя.Некоторые программы имеют английские комментарии,заключенные в условия,которые гарантированно терпят неудачу;если эти комментарии содержат апострофы,GCC,вероятно,сообщит об ошибке.Например,этот код выдаст ошибку:</target>
        </trans-unit>
        <trans-unit id="e4bb7adbf45dc4a3fb687d7313280a86480960d6" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCC соответствует спецификации OpenPOWER 64-Bit ELF V2 ABI, которую можно найти по адресу &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt; . В Приложении A к этому документу перечислены векторные интерфейсы API, которые должны предоставляться совместимыми компиляторами. Программисты должны предпочтительно использовать описанные в нем интерфейсы. Однако исторически GCC предоставлял дополнительные интерфейсы для доступа к векторным инструкциям. Они кратко описаны ниже.</target>
        </trans-unit>
        <trans-unit id="c80707819ec65b1cb82541da2d3b9e30cf2076e3" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&quot;&gt;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f9b929facca207bcc2021009f1c0587b957cbf" translate="yes" xml:space="preserve">
          <source>GCC currently emits calls to &lt;code&gt;vmldExp2&lt;/code&gt;, &lt;code&gt;vmldLn2&lt;/code&gt;, &lt;code&gt;vmldLog102&lt;/code&gt;, &lt;code&gt;vmldPow2&lt;/code&gt;, &lt;code&gt;vmldTanh2&lt;/code&gt;, &lt;code&gt;vmldTan2&lt;/code&gt;, &lt;code&gt;vmldAtan2&lt;/code&gt;, &lt;code&gt;vmldAtanh2&lt;/code&gt;, &lt;code&gt;vmldCbrt2&lt;/code&gt;, &lt;code&gt;vmldSinh2&lt;/code&gt;, &lt;code&gt;vmldSin2&lt;/code&gt;, &lt;code&gt;vmldAsinh2&lt;/code&gt;, &lt;code&gt;vmldAsin2&lt;/code&gt;, &lt;code&gt;vmldCosh2&lt;/code&gt;, &lt;code&gt;vmldCos2&lt;/code&gt;, &lt;code&gt;vmldAcosh2&lt;/code&gt;, &lt;code&gt;vmldAcos2&lt;/code&gt;, &lt;code&gt;vmlsExp4&lt;/code&gt;, &lt;code&gt;vmlsLn4&lt;/code&gt;, &lt;code&gt;vmlsLog104&lt;/code&gt;, &lt;code&gt;vmlsPow4&lt;/code&gt;, &lt;code&gt;vmlsTanh4&lt;/code&gt;, &lt;code&gt;vmlsTan4&lt;/code&gt;, &lt;code&gt;vmlsAtan4&lt;/code&gt;, &lt;code&gt;vmlsAtanh4&lt;/code&gt;, &lt;code&gt;vmlsCbrt4&lt;/code&gt;, &lt;code&gt;vmlsSinh4&lt;/code&gt;, &lt;code&gt;vmlsSin4&lt;/code&gt;, &lt;code&gt;vmlsAsinh4&lt;/code&gt;, &lt;code&gt;vmlsAsin4&lt;/code&gt;, &lt;code&gt;vmlsCosh4&lt;/code&gt;, &lt;code&gt;vmlsCos4&lt;/code&gt;, &lt;code&gt;vmlsAcosh4&lt;/code&gt; and &lt;code&gt;vmlsAcos4&lt;/code&gt; for corresponding function type when</source>
          <target state="translated">GCC в настоящее время излучает звонки на &lt;code&gt;vmldExp2&lt;/code&gt; , &lt;code&gt;vmldLn2&lt;/code&gt; , &lt;code&gt;vmldLog102&lt;/code&gt; , &lt;code&gt;vmldPow2&lt;/code&gt; , &lt;code&gt;vmldTanh2&lt;/code&gt; , &lt;code&gt;vmldTan2&lt;/code&gt; , &lt;code&gt;vmldAtan2&lt;/code&gt; , &lt;code&gt;vmldAtanh2&lt;/code&gt; , &lt;code&gt;vmldCbrt2&lt;/code&gt; , &lt;code&gt;vmldSinh2&lt;/code&gt; , &lt;code&gt;vmldSin2&lt;/code&gt; , &lt;code&gt;vmldAsinh2&lt;/code&gt; , &lt;code&gt;vmldAsin2&lt;/code&gt; , &lt;code&gt;vmldCosh2&lt;/code&gt; , &lt;code&gt;vmldCos2&lt;/code&gt; , &lt;code&gt;vmldAcosh2&lt;/code&gt; , &lt;code&gt;vmldAcos2&lt;/code&gt; , &lt;code&gt;vmlsExp4&lt;/code&gt; , &lt;code&gt;vmlsLn4&lt;/code&gt; , &lt;code&gt;vmlsLog104&lt;/code&gt; , &lt;code&gt;vmlsPow4&lt;/code&gt; , &lt;code&gt;vmlsTanh4&lt;/code&gt; , &lt;code&gt;vmlsTan4&lt;/code&gt; , &lt;code&gt;vmlsAtan4&lt;/code&gt; , &lt;code&gt;vmlsAtanh4&lt;/code&gt; , &lt;code&gt;vmlsCbrt4&lt;/code&gt; , &lt;code&gt;vmlsSinh4&lt;/code&gt; , &lt;code&gt;vmlsSin4&lt;/code&gt; , &lt;code&gt;vmlsAsinh4&lt;/code&gt; , &lt;code&gt;vmlsAsin4&lt;/code&gt; , &lt;code&gt;vmlsCosh4&lt;/code&gt; , &lt;code&gt;vmlsCos4&lt;/code&gt; , &lt;code&gt;vmlsAcosh4&lt;/code&gt; и &lt;code&gt;vmlsAcos4&lt;/code&gt; для соответствующего типа функции, когда</target>
        </trans-unit>
        <trans-unit id="16f9d8d14967dad5157f0d4d4177e77917294c63" translate="yes" xml:space="preserve">
          <source>GCC defines a macro &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; whenever it is generating code for a ColdFire target. The &lt;var&gt;arch&lt;/var&gt; in this macro is one of the</source>
          <target state="translated">GCC определяет макрос &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; всякий раз, когда он генерирует код для цели ColdFire. &lt;var&gt;arch&lt;/var&gt; в этих макрокомандах является одним из</target>
        </trans-unit>
        <trans-unit id="9690667ebb3c4d196426b91a67e183bca646b7c4" translate="yes" xml:space="preserve">
          <source>GCC defines a preprocessor macro for the specified &lt;var&gt;cpu&lt;/var&gt;. For the &amp;lsquo;</source>
          <target state="translated">GCC определяет макрос препроцессора для указанного &lt;var&gt;cpu&lt;/var&gt; . Для '</target>
        </trans-unit>
        <trans-unit id="1ee4979d83e119fc65d0b3ce42180431e0b52daf" translate="yes" xml:space="preserve">
          <source>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the</source>
          <target state="translated">GCC определяет несколько встроенных макросов,чтобы пользовательский код мог проверить наличие или отсутствие возможностей.Практически любой из следующих встроенных макросов выводится из возможностей устройства и,таким образом,запускается по команде</target>
        </trans-unit>
        <trans-unit id="07c2bb68cb370eca1e6a61c97987834533dcec03" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; when ColdFire target &lt;var&gt;cpu&lt;/var&gt; is selected. It also defines &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt;, where the value of &lt;var&gt;family&lt;/var&gt; is given by the table above.</source>
          <target state="translated">GCC определяет макрос &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; , когда выбран целевой &lt;var&gt;cpu&lt;/var&gt; ColdFire . Он также определяет &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt; __mcf_family_ , где значение &lt;var&gt;family&lt;/var&gt; указано в таблице выше.</target>
        </trans-unit>
        <trans-unit id="57340a71d3d941522f73fea99d6d51e3e8ce6ff1" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcfhwdiv__&lt;/code&gt; when this option is enabled.</source>
          <target state="translated">GCC определяет макрос &lt;code&gt;__mcfhwdiv__&lt;/code&gt; , когда эта опция включена.</target>
        </trans-unit>
        <trans-unit id="6a9b1f894460a8c96f48083896afccfe85c9be79" translate="yes" xml:space="preserve">
          <source>GCC defines the macros &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; when tuning for 680x0 architecture &lt;var&gt;arch&lt;/var&gt;. It also defines &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; unless either</source>
          <target state="translated">GCC определяет макросы &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; и &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; при настройке для 680x0 архитектуры &lt;var&gt;arch&lt;/var&gt; . Он также определяет &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; если только</target>
        </trans-unit>
        <trans-unit id="2885698109b0288d9891eaf5f6f566e33bc93a28" translate="yes" xml:space="preserve">
          <source>GCC defines the preprocessor macro &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; for targets that have been updated to support this builtin.</source>
          <target state="translated">GCC определяет макрос препроцессора &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; для целей, которые были обновлены для поддержки этой встроенной функции.</target>
        </trans-unit>
        <trans-unit id="9502202879d2e8497b3ab7402351c2cfb4aba65d" translate="yes" xml:space="preserve">
          <source>GCC defines two macros based on the value of this option. The first is &lt;code&gt;_MIPS_ARCH&lt;/code&gt;, which gives the name of target architecture, as a string. The second has the form &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;foo&lt;/var&gt; is the capitalized value of &lt;code&gt;_MIPS_ARCH&lt;/code&gt;. For example,</source>
          <target state="translated">GCC определяет два макроса на основе значения этой опции. Первый - это &lt;code&gt;_MIPS_ARCH&lt;/code&gt; , который дает имя целевой архитектуры в виде строки. Второй имеет форму &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt; , где &lt;var&gt;foo&lt;/var&gt; - это значение &lt;code&gt;_MIPS_ARCH&lt;/code&gt; с заглавной буквы . Например,</target>
        </trans-unit>
        <trans-unit id="a26b5e085873721291414d2146a69ef3ff2df942" translate="yes" xml:space="preserve">
          <source>GCC depresses SSEx instructions when</source>
          <target state="translated">GCC нажимает на инструкции SSEx,когда</target>
        </trans-unit>
        <trans-unit id="f00d9db0f7babc17a8b2e93a16eaa154dca9484f" translate="yes" xml:space="preserve">
          <source>GCC does not inline any functions when not optimizing unless you specify the &amp;lsquo;</source>
          <target state="translated">GCC не встраивает какие-либо функции, если не оптимизируется, если вы не укажете '</target>
        </trans-unit>
        <trans-unit id="d979e47341cf32b9e9788a98df7db938c53659aa" translate="yes" xml:space="preserve">
          <source>GCC does not parse basic &lt;code&gt;asm&lt;/code&gt;&amp;rsquo;s &lt;var&gt;AssemblerInstructions&lt;/var&gt;, which means there is no way to communicate to the compiler what is happening inside them. GCC has no visibility of symbols in the &lt;code&gt;asm&lt;/code&gt; and may discard them as unreferenced. It also does not know about side effects of the assembler code, such as modifications to memory or registers. Unlike some compilers, GCC assumes that no changes to general purpose registers occur. This assumption may change in a future release.</source>
          <target state="translated">GCC не анализирует &lt;var&gt;AssemblerInstructions&lt;/var&gt; &lt;code&gt;asm&lt;/code&gt; базового asm , а это значит, что нет способа сообщить компилятору, что происходит внутри них. GCC не имеет видимости символов в &lt;code&gt;asm&lt;/code&gt; и может отбрасывать их как неиспользуемые. Он также не знает о побочных эффектах кода ассемблера, таких как модификации памяти или регистров. В отличие от некоторых компиляторов, GCC предполагает, что никаких изменений регистров общего назначения не происходит. Это предположение может измениться в будущем выпуске.</target>
        </trans-unit>
        <trans-unit id="cd46297b79a48028b406a3a22f8df3c38f23ed53" translate="yes" xml:space="preserve">
          <source>GCC does not provide the C library functionality associated with</source>
          <target state="translated">GCC не предоставляет функциональность библиотеки C,связанную с</target>
        </trans-unit>
        <trans-unit id="96d71d57d6177ab6f3fc682f6b185f4541d680d8" translate="yes" xml:space="preserve">
          <source>GCC does not provide the library facilities required only of hosted implementations, nor yet all the facilities required by C99 of freestanding implementations on all platforms. To use the facilities of a hosted environment, you need to find them elsewhere (for example, in the GNU C library). See &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Standard Libraries&lt;/a&gt;.</source>
          <target state="translated">GCC не предоставляет ни библиотечных средств, необходимых только для размещенных реализаций, ни всех средств, требуемых C99 для автономных реализаций на всех платформах. Чтобы использовать возможности размещенной среды, вам нужно найти их в другом месте (например, в библиотеке GNU C). См. &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Стандартные библиотеки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86c923d0a51125464840f7ea1874cf6ab2974fb7" translate="yes" xml:space="preserve">
          <source>GCC does not substitute macro arguments when they appear inside of string constants. For example, the following macro in GCC</source>
          <target state="translated">GCC не подставляет аргументы макросов,когда они появляются внутри строковых констант.Например,следующий макрос в GCC</target>
        </trans-unit>
        <trans-unit id="42a91da8639ee03ec161a4bd756ad60809129b66" translate="yes" xml:space="preserve">
          <source>GCC does not support any extended integer types.</source>
          <target state="translated">GCC не поддерживает расширенные целочисленные типы.</target>
        </trans-unit>
        <trans-unit id="3ce5b628a549292da4090df5538cf2cd3541c673" translate="yes" xml:space="preserve">
          <source>GCC does not support using this feature with a non-static local variable since such variables do not have assembler names. If you are trying to put the variable in a particular register, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">GCC не поддерживает использование этой функции с нестатической локальной переменной, поскольку такие переменные не имеют имен ассемблера. Если вы пытаетесь поместить переменную в конкретный регистр, см. &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Явные переменные регистра&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="057dd4b479d4087929d93c02eca9edfef895599b" translate="yes" xml:space="preserve">
          <source>GCC does not use such values.</source>
          <target state="translated">GCC не использует такие значения.</target>
        </trans-unit>
        <trans-unit id="6b22e4a77b39e5fcd62364faba592ec172555481" translate="yes" xml:space="preserve">
          <source>GCC emits warnings based on this attribute by default; use</source>
          <target state="translated">GCC по умолчанию выдает предупреждения,основанные на этом атрибуте;используйте</target>
        </trans-unit>
        <trans-unit id="6213b35197bfb3bb104e08212f01a4cf35332f2f" translate="yes" xml:space="preserve">
          <source>GCC enables this option by default. If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the</source>
          <target state="translated">GCC включает эту опцию по умолчанию.Если вы хотите заставить компилятор проверить,есть ли ссылка на переменную,независимо от того,включена оптимизация или нет,используйте параметр</target>
        </trans-unit>
        <trans-unit id="d7b2a859b296fb3f8914b78d7834ccf3e648a510" translate="yes" xml:space="preserve">
          <source>GCC has currently no support for non-fragile instance variables.</source>
          <target state="translated">В настоящее время GCC не имеет поддержки для нестойких переменных экземпляров.</target>
        </trans-unit>
        <trans-unit id="9b64961814c7627599dfb66d9541dfbc1c55e8a3" translate="yes" xml:space="preserve">
          <source>GCC has long supported variadic macros, and used a different syntax that allowed you to give a name to the variable arguments just like any other argument. Here is an example:</source>
          <target state="translated">GCC долгое время поддерживал вариадические макросы,и использовал другой синтаксис,который позволял давать имя переменным аргументам,как и любому другому аргументу.Вот пример:</target>
        </trans-unit>
        <trans-unit id="e677a4ecf07d49ec983c792d6fd35d17489c7528" translate="yes" xml:space="preserve">
          <source>GCC has the following spec strings built into it. Spec files can override these strings or create their own. Note that individual targets can also add their own spec strings to this list.</source>
          <target state="translated">В GCC встроены следующие спецификации.Спецификационные файлы могут переопределять эти строки или создавать свои собственные.Обратите внимание,что отдельные цели также могут добавлять свои собственные спецификационные строки в этот список.</target>
        </trans-unit>
        <trans-unit id="ed8411601030aef9d10cc9d6209db6260f4d910d" translate="yes" xml:space="preserve">
          <source>GCC implements a limited buffer overflow protection mechanism that can prevent some buffer overflow attacks by determining the sizes of objects into which data is about to be written and preventing the writes when the size isn&amp;rsquo;t sufficient. The built-in functions described below yield the best results when used together and when optimization is enabled. For example, to detect object sizes across function boundaries or to follow pointer assignments through non-trivial control flow they rely on various optimization passes enabled with</source>
          <target state="translated">GCC реализует ограниченный механизм защиты от переполнения буфера, который может предотвратить некоторые атаки переполнения буфера, определяя размеры объектов, в которые будут записаны данные, и предотвращая запись, когда размер недостаточен. Встроенные функции, описанные ниже, дают наилучшие результаты при совместном использовании и при включенной оптимизации. Например, для определения размеров объектов через границы функций или отслеживания назначений указателей через нетривиальный поток управления они полагаются на различные проходы оптимизации, включенные с помощью</target>
        </trans-unit>
        <trans-unit id="c63f8d617f5fcd74378c430997fb1de4655a5a57" translate="yes" xml:space="preserve">
          <source>GCC implements extensions for C as described in the ARM C Language Extensions (ACLE) specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC реализует расширения для C, как описано в спецификации ARM C Language Extensions (ACLE), которую можно найти по &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;адресу http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="293bbd3b2e69a9d930833e11f1b427e7997876a6" translate="yes" xml:space="preserve">
          <source>GCC implements for both C and C++ a syntactic extension to implement the &lt;code&gt;offsetof&lt;/code&gt; macro.</source>
          <target state="translated">GCC реализует как для C, так и для C ++ синтаксическое расширение для реализации макроса &lt;code&gt;offsetof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322077390825044afaea930b7263992ddcea81e8" translate="yes" xml:space="preserve">
          <source>GCC implements taking the address of a nested function using a technique called &lt;em&gt;trampolines&lt;/em&gt;. This technique was described in Lexical Closures for C++ (Thomas M. Breuel, USENIX C++ Conference Proceedings, October 17-21, 1988).</source>
          <target state="translated">GCC реализует получение адреса вложенной функции с помощью техники, называемой &lt;em&gt;трамплинами&lt;/em&gt; . Этот метод был описан в Lexical Closures for C ++ (Thomas M. Breuel, USENIX C ++ Conference Proceedings, 17-21 октября 1988 г.).</target>
        </trans-unit>
        <trans-unit id="239348ac99d6992297a72fcc17bd9b383a471db0" translate="yes" xml:space="preserve">
          <source>GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC реализует расширения безопасности ARMv8-M, как описано в разделе &amp;laquo;Расширения безопасности ARMv8-M: требования к технической спецификации средств разработки&amp;raquo;, который можно найти по &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;адресу http://infocenter.arm.com/help/topic/com.arm.doc. ecm0359818 / ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c1d6efdb055c03457ac985aa41eeb676f9d1c1c" translate="yes" xml:space="preserve">
          <source>GCC implements three different semantics of declaring a function inline. One is available with</source>
          <target state="translated">GCC реализует три различные семантики объявления функции в строке.Одна из них доступна с</target>
        </trans-unit>
        <trans-unit id="16fab68e571685f848321494bfa65aa76fa12ecf" translate="yes" xml:space="preserve">
          <source>GCC includes built-in versions of many of the functions in the standard C library. These functions come in two forms: one whose names start with the &lt;code&gt;__builtin_&lt;/code&gt; prefix, and the other without. Both forms have the same type (including prototype), the same address (when their address is taken), and the same meaning as the C library functions even if you specify the</source>
          <target state="translated">GCC включает встроенные версии многих функций стандартной библиотеки C. Эти функции бывают двух форм: одна, имена которой начинаются с префикса &lt;code&gt;__builtin_&lt;/code&gt; , а другая - без префикса. Обе формы имеют один и тот же тип (включая прототип), один и тот же адрес (если используется их адрес) и то же значение, что и функции библиотеки C, даже если вы укажете</target>
        </trans-unit>
        <trans-unit id="6ddb06bf023a460b3469518f6828ceb9799c46e8" translate="yes" xml:space="preserve">
          <source>GCC is incompatible with traditional C.</source>
          <target state="translated">GCC несовместим с традиционной C.</target>
        </trans-unit>
        <trans-unit id="d28b24326033740593178727cd1510ca18099b74" translate="yes" xml:space="preserve">
          <source>GCC is only limited by available memory.</source>
          <target state="translated">GCC ограничен только доступной памятью.</target>
        </trans-unit>
        <trans-unit id="e1b7ed70d92a385236df81656270c5df961819cc" translate="yes" xml:space="preserve">
          <source>GCC needs to install corrected versions of some system header files. This is because most target systems have some header files that won&amp;rsquo;t work with GCC unless they are changed. Some have bugs, some are incompatible with ISO C, and some depend on special features of other compilers.</source>
          <target state="translated">GCC необходимо установить исправленные версии некоторых файлов системных заголовков. Это связано с тем, что в большинстве целевых систем есть файлы заголовков, которые не будут работать с GCC, если их не изменить. Некоторые из них содержат ошибки, некоторые несовместимы с ISO C, а некоторые зависят от специальных возможностей других компиляторов.</target>
        </trans-unit>
        <trans-unit id="6fec00d5e695a6ba7008f039024af2f2354b9175" translate="yes" xml:space="preserve">
          <source>GCC no longer supports DWARF Version 1, which is substantially different than Version 2 and later. For historical reasons, some other DWARF-related options such as</source>
          <target state="translated">GCC больше не поддерживает DWARF версии 1,которая существенно отличается от версии 2 и более поздних.По историческим причинам,некоторые другие связанные с DWARF опции,такие как</target>
        </trans-unit>
        <trans-unit id="9571fcf4d32ba7634429d5420351196a13337bf1" translate="yes" xml:space="preserve">
          <source>GCC normally defines &lt;code&gt;__STDC__&lt;/code&gt; to be 1, and in addition defines &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; if you specify the</source>
          <target state="translated">GCC обычно определяет &lt;code&gt;__STDC__&lt;/code&gt; равным 1 и, кроме того, определяет &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; , если вы указываете</target>
        </trans-unit>
        <trans-unit id="d2a04d28db5bb4fd272285d6f2261f1af937b1aa" translate="yes" xml:space="preserve">
          <source>GCC normally generates special code to handle certain built-in functions more efficiently; for instance, calls to &lt;code&gt;alloca&lt;/code&gt; may become single instructions which adjust the stack directly, and calls to &lt;code&gt;memcpy&lt;/code&gt; may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a built-in function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with</source>
          <target state="translated">GCC обычно генерирует специальный код для более эффективной обработки определенных встроенных функций; например, вызовы &lt;code&gt;alloca&lt;/code&gt; могут стать отдельными инструкциями, которые напрямую регулируют стек, а вызовы &lt;code&gt;memcpy&lt;/code&gt; могут стать встроенными циклами копирования. Результирующий код часто меньше и быстрее, но поскольку вызовы функций больше не отображаются как таковые, вы не можете установить точку останова для этих вызовов, а также вы не можете изменить поведение функций, связавшись с другой библиотекой. Кроме того, когда функция распознается как встроенная, GCC может использовать информацию об этой функции, чтобы предупреждать о проблемах с вызовами этой функции или для генерации более эффективного кода, даже если полученный код все еще содержит вызовы этой функции. , Например, предупреждения даются с</target>
        </trans-unit>
        <trans-unit id="7e6e1ac548faaad8ae2131d82037c03b74f72b7e" translate="yes" xml:space="preserve">
          <source>GCC normally makes string constants read-only. If several identical-looking string constants are used, GCC stores only one copy of the string.</source>
          <target state="translated">Обычно GCC делает строковые константы доступными только для чтения.Если используется несколько одинаковых строковых констант,то GCC хранит только одну копию строки.</target>
        </trans-unit>
        <trans-unit id="11a713f18e4fa0802eb282a6537925d48c0259a3" translate="yes" xml:space="preserve">
          <source>GCC normally uses a single instruction to load values from the GOT. While this is relatively efficient, it only works if the GOT is smaller than about 64k. Anything larger causes the linker to report an error such as:</source>
          <target state="translated">Обычно GCC использует одну единственную инструкцию для загрузки значений из GOT.Хотя это относительно эффективно,это работает только в том случае,если GOT меньше 64k.Любое увеличение приводит к тому,что компоновщик сообщает об ошибке,например:</target>
        </trans-unit>
        <trans-unit id="be424d75f5ffc48b72e433597659af0ae3069a92" translate="yes" xml:space="preserve">
          <source>GCC option.</source>
          <target state="translated">Опция GCC.</target>
        </trans-unit>
        <trans-unit id="0cb280cc3350dd85b51b4e6912bba246b1815ba4" translate="yes" xml:space="preserve">
          <source>GCC permits a C structure to have no members:</source>
          <target state="translated">GCC разрешает структуре С не иметь членов:</target>
        </trans-unit>
        <trans-unit id="410ccd5268fc842081ec500688897d4eab9d507c" translate="yes" xml:space="preserve">
          <source>GCC provides a couple of special builtin functions to aid in the writing of interrupt handlers in C.</source>
          <target state="translated">GCC предоставляет пару специальных встроенных функций для помощи в написании обработчиков прерываний в C.</target>
        </trans-unit>
        <trans-unit id="9a84666be4b2834544f27c65de6a453c576dd60a" translate="yes" xml:space="preserve">
          <source>GCC provides a large number of built-in functions other than the ones mentioned above. Some of these are for internal use in the processing of exceptions or variable-length argument lists and are not documented here because they may change from time to time; we do not recommend general use of these functions.</source>
          <target state="translated">GCC предоставляет большое количество встроенных функций,отличных от упомянутых выше.Некоторые из них предназначены для внутреннего использования при обработке исключений или списков аргументов переменной длины и не документируются здесь,так как они могут время от времени изменяться;мы не рекомендуем общее использование этих функций.</target>
        </trans-unit>
        <trans-unit id="dd6c408349b302ebed79b324cb6148ad8750cb77" translate="yes" xml:space="preserve">
          <source>GCC provides an interface for the PowerPC family of processors to access the AltiVec operations described in Motorola&amp;rsquo;s AltiVec Programming Interface Manual. The interface is made available by including &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC предоставляет интерфейс для процессоров семейства PowerPC для доступа к операциям AltiVec, описанным в Руководстве по интерфейсу программирования AltiVec компании Motorola. Интерфейс становится доступным путем включения &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; и использования</target>
        </trans-unit>
        <trans-unit id="f17fd1e9e7781f60f577293ffbb0fbe50f2aa38c" translate="yes" xml:space="preserve">
          <source>GCC provides an interface to selected machine instructions from the picoChip instruction set.</source>
          <target state="translated">GCC предоставляет интерфейс к выбранным машинным инструкциям из набора инструкций picoChip.</target>
        </trans-unit>
        <trans-unit id="5ddbeccb51a8011bd71cee78329676c8768e012d" translate="yes" xml:space="preserve">
          <source>GCC provides built-in versions of the ISO C99 floating-point comparison macros that avoid raising exceptions for unordered operands. They have the same names as the standard macros ( &lt;code&gt;isgreater&lt;/code&gt;, &lt;code&gt;isgreaterequal&lt;/code&gt;, &lt;code&gt;isless&lt;/code&gt;, &lt;code&gt;islessequal&lt;/code&gt;, &lt;code&gt;islessgreater&lt;/code&gt;, and &lt;code&gt;isunordered&lt;/code&gt;) , with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. We intend for a library implementor to be able to simply &lt;code&gt;#define&lt;/code&gt; each standard macro to its built-in equivalent. In the same fashion, GCC provides &lt;code&gt;fpclassify&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;, &lt;code&gt;isinf_sign&lt;/code&gt;, &lt;code&gt;isnormal&lt;/code&gt; and &lt;code&gt;signbit&lt;/code&gt; built-ins used with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. The &lt;code&gt;isinf&lt;/code&gt; and &lt;code&gt;isnan&lt;/code&gt; built-in functions appear both with and without the &lt;code&gt;__builtin_&lt;/code&gt; prefix.</source>
          <target state="translated">GCC предоставляет встроенные версии макросов сравнения с плавающей запятой ISO C99, которые позволяют избежать возникновения исключений для неупорядоченных операндов. Они имеют те же имена, что и стандартные макросы ( &lt;code&gt;isgreater&lt;/code&gt; , &lt;code&gt;isgreaterequal&lt;/code&gt; , &lt;code&gt;isless&lt;/code&gt; , &lt;code&gt;islessequal&lt;/code&gt; , &lt;code&gt;islessgreater&lt;/code&gt; и &lt;code&gt;isunordered&lt;/code&gt; ), с префиксом &lt;code&gt;__builtin_&lt;/code&gt; . Мы хотим, чтобы разработчик библиотеки мог просто &lt;code&gt;#define&lt;/code&gt; определять каждый стандартный макрос до его встроенного эквивалента. Таким же образом GCC предоставляет &lt;code&gt;fpclassify&lt;/code&gt; , &lt;code&gt;isfinite&lt;/code&gt; , &lt;code&gt;isinf_sign&lt;/code&gt; , &lt;code&gt;isnormal&lt;/code&gt; и &lt;code&gt;signbit&lt;/code&gt; .встроенные модули, используемые с префиксом &lt;code&gt;__builtin_&lt;/code&gt; . &lt;code&gt;isinf&lt;/code&gt; и &lt;code&gt;isnan&lt;/code&gt; встроенных функций появляются как с и без &lt;code&gt;__builtin_&lt;/code&gt; префикса.</target>
        </trans-unit>
        <trans-unit id="2050dfe83adc5c7628805205b83a18bf6445e1ea" translate="yes" xml:space="preserve">
          <source>GCC provides extensions for the SPU processor as described in the Sony/Toshiba/IBM SPU Language Extensions Specification. GCC&amp;rsquo;s implementation differs in several ways.</source>
          <target state="translated">GCC предоставляет расширения для процессора SPU, как описано в спецификации Sony / Toshiba / IBM SPU Language Extensions Specification. Реализация GCC отличается по нескольким причинам.</target>
        </trans-unit>
        <trans-unit id="e32059373d4f323b9500c52b6c9f30c837d92c67" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access certain instructions of the TI C6X processors. These intrinsics, listed below, are available after inclusion of the &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; header file. They map directly to C6X instructions.</source>
          <target state="translated">GCC предоставляет встроенные функции для доступа к определенным инструкциям процессоров TI C6X. Эти встроенные функции, перечисленные ниже, доступны после включения &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; заголовка c6x_intrinsics.h . Они отображаются непосредственно на инструкции C6X.</target>
        </trans-unit>
        <trans-unit id="4b78e24ee2fcd774983a8458d70a096c1f01f9ae" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILE-Gx processor. The intrinsics are of the form:</source>
          <target state="translated">GCC предоставляет intrinsics для доступа к каждой инструкции процессора TILE-Gx.Исключительные характеристики имеют форму:</target>
        </trans-unit>
        <trans-unit id="9929eef1ea9191b05967ff4d40ec8ba33acf1914" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILEPro processor. The intrinsics are of the form:</source>
          <target state="translated">GCC предоставляет встроенные средства доступа к каждой инструкции процессора TILEPro.Свойства имеют свою форму:</target>
        </trans-unit>
        <trans-unit id="ce1f47a40b55c4bca6e7d75e5dd0559de5a981c1" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the MSA MIPS SIMD Architecture. The interface is made available by including &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC предоставляет встроенные средства для доступа к инструкциям SIMD, предоставляемым архитектурой MSA MIPS SIMD. Интерфейс доступен путем включения &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; и использования</target>
        </trans-unit>
        <trans-unit id="40749dfbc24dc6f5a0b131fccc39dc31c09ec61c" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the ST Microelectronics Loongson-2E and -2F processors. These intrinsics, available after inclusion of the &lt;code&gt;loongson.h&lt;/code&gt; header file, operate on the following 64-bit vector types:</source>
          <target state="translated">GCC предоставляет встроенные функции для доступа к инструкциям SIMD, предоставляемым процессорами ST Microelectronics Loongson-2E и -2F. Эти встроенные функции, доступные после включения &lt;code&gt;loongson.h&lt;/code&gt; заголовка loongson.h , работают со следующими 64-битными векторными типами:</target>
        </trans-unit>
        <trans-unit id="924dd6007d38ce7b6e1d6cc29626f87cdabebfe1" translate="yes" xml:space="preserve">
          <source>GCC provides many FR-V-specific built-in functions. In general, these functions are intended to be compatible with those described by FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor. The two exceptions are &lt;code&gt;__MDUNPACKH&lt;/code&gt; and &lt;code&gt;__MBTOHE&lt;/code&gt;, the GCC forms of which pass 128-bit values by pointer rather than by value.</source>
          <target state="translated">GCC предоставляет множество встроенных функций, специфичных для FR-V. В общем, эти функции предназначены для совместимости с функциями, описанными в FR-V Family, Softune C / C ++ Compiler Manual (V6), Fujitsu Semiconductor. Двумя исключениями являются &lt;code&gt;__MDUNPACKH&lt;/code&gt; и &lt;code&gt;__MBTOHE&lt;/code&gt; , формы GCC которых передают 128-битные значения по указателю, а не по значению.</target>
        </trans-unit>
        <trans-unit id="9e2fa02f56a7975c68bfa6e70c41727409fe7b0c" translate="yes" xml:space="preserve">
          <source>GCC provides other MIPS-specific built-in functions:</source>
          <target state="translated">GCC предоставляет другие встроенные функции,специфичные для MIPS:</target>
        </trans-unit>
        <trans-unit id="c10a95a94bae56390209bcb97b207903625a1bc4" translate="yes" xml:space="preserve">
          <source>GCC provides the built-in functions &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; which are similar to, but not interchangeable with, the C library functions &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;. The built-in versions are used internally by GCC&amp;rsquo;s libraries to implement exception handling on some targets. You should use the standard C library functions declared in &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; in user code instead of the builtins.</source>
          <target state="translated">GCC предоставляет встроенные функции &lt;code&gt;__builtin_setjmp&lt;/code&gt; и &lt;code&gt;__builtin_longjmp&lt;/code&gt; , которые похожи на функции библиотеки C &lt;code&gt;setjmp&lt;/code&gt; и &lt;code&gt;longjmp&lt;/code&gt; , но не взаимозаменяемы . Встроенные версии используются внутри библиотек GCC для реализации обработки исключений для некоторых целей. Вы должны использовать стандартные функции библиотеки C, объявленные в &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; , в пользовательском коде вместо встроенных функций.</target>
        </trans-unit>
        <trans-unit id="9735e9559d39719652bb957e983b7d2a3d2f7126" translate="yes" xml:space="preserve">
          <source>GCC provides three magic constants that hold the name of the current function as a string. In C++11 and later modes, all three are treated as constant expressions and can be used in &lt;code&gt;constexpr&lt;/code&gt; constexts. The first of these constants is &lt;code&gt;__func__&lt;/code&gt;, which is part of the C99 standard:</source>
          <target state="translated">GCC предоставляет три магические константы, которые содержат имя текущей функции в виде строки. В режимах C ++ 11 и более поздних все три обрабатываются как константные выражения и могут использоваться в &lt;code&gt;constexpr&lt;/code&gt; constexts. Первая из этих констант - &lt;code&gt;__func__&lt;/code&gt; , которая является частью стандарта C99:</target>
        </trans-unit>
        <trans-unit id="2948277f494886df96fe31449754e2666c1dabe5" translate="yes" xml:space="preserve">
          <source>GCC provides two interfaces for accessing the Hardware Transactional Memory (HTM) instructions available on some of the PowerPC family of processors (eg, POWER8). The two interfaces come in a low level interface, consisting of built-in functions specific to PowerPC and a higher level interface consisting of inline functions that are common between PowerPC and S/390.</source>
          <target state="translated">GCC предоставляет два интерфейса для доступа к инструкциям аппаратной транзакционной памяти (HTM),доступным на некоторых процессорах семейства PowerPC (например,POWER8).Эти два интерфейса имеют низкоуровневый интерфейс,состоящий из встроенных функций,специфичных для PowerPC,и высокоуровневый интерфейс,состоящий из встроенных функций,общих для PowerPC и S/390.</target>
        </trans-unit>
        <trans-unit id="0504373821c4265dbbe47258f3675e81d3bda382" translate="yes" xml:space="preserve">
          <source>GCC searches for the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29e392d59a7180cc6e4238e88b7157ffcf6417f" translate="yes" xml:space="preserve">
          <source>GCC stands for &amp;ldquo;GNU Compiler Collection&amp;rdquo;. GCC is an integrated distribution of compilers for several major programming languages. These languages currently include C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL).</source>
          <target state="translated">GCC означает &amp;laquo;Коллекция компиляторов GNU&amp;raquo;. GCC - это интегрированный дистрибутив компиляторов для нескольких основных языков программирования. Эти языки в настоящее время включают C, C ++, Objective-C, Objective-C ++, Fortran, Ada, D, Go и BRIG (HSAIL).</target>
        </trans-unit>
        <trans-unit id="1d5a85fa7b27fa126424357ffe5ddd8aadcd2aa6" translate="yes" xml:space="preserve">
          <source>GCC support of decimal float as specified by the draft technical report is incomplete:</source>
          <target state="translated">Поддержка десятичного поплавка ССАГПЗ,как указано в проекте технического отчета,является неполной:</target>
        </trans-unit>
        <trans-unit id="28561e4b3e7debdbfb6dbdfe238413f5b85b54ce" translate="yes" xml:space="preserve">
          <source>GCC support of fixed-point types as specified by the draft technical report is incomplete:</source>
          <target state="translated">Поддержка типов ССАГПЗ с фиксированной точкой,указанных в проекте технического отчета,является неполной:</target>
        </trans-unit>
        <trans-unit id="1fa5de60932a0f2deade437763dee9d9034d0c2f" translate="yes" xml:space="preserve">
          <source>GCC supports &amp;ldquo;traditional&amp;rdquo; Objective-C (also known as &amp;ldquo;Objective-C 1.0&amp;rdquo;) and contains support for the Objective-C exception and synchronization syntax. It has also support for a number of &amp;ldquo;Objective-C 2.0&amp;rdquo; language extensions, including properties, fast enumeration (only for Objective-C), method attributes and the @optional and @required keywords in protocols. GCC supports Objective-C++ and features available in Objective-C are also available in Objective-C++.</source>
          <target state="translated">GCC поддерживает &amp;laquo;традиционный&amp;raquo; Objective-C (также известный как &amp;laquo;Objective-C 1.0&amp;raquo;) и содержит поддержку исключений Objective-C и синтаксиса синхронизации. Он также поддерживает ряд языковых расширений &amp;laquo;Objective-C 2.0&amp;raquo;, включая свойства, быстрое перечисление (только для Objective-C), атрибуты методов и ключевые слова @optional и @required в протоколах. GCC поддерживает Objective-C ++, а функции, доступные в Objective-C, также доступны в Objective-C ++.</target>
        </trans-unit>
        <trans-unit id="830690076ebfb70e332b381ddb9fe46655004637" translate="yes" xml:space="preserve">
          <source>GCC supports MIPS DSP operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC поддерживает операции MIPS DSP, используя как общие векторные расширения (см. &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Векторные расширения&lt;/a&gt; ), так и набор встроенных функций, специфичных для MIPS. Оба вида поддержки включены в</target>
        </trans-unit>
        <trans-unit id="8d83e55eff0bd290fe83057edfb4aff0d4da11fc" translate="yes" xml:space="preserve">
          <source>GCC supports SIMD operations on the SPARC using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) as well as built-in functions for the SPARC Visual Instruction Set (VIS). When you use the</source>
          <target state="translated">GCC поддерживает операции SIMD на SPARC, используя как общие векторные расширения (см. &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Векторные расширения&lt;/a&gt; ), так и встроенные функции для набора визуальных инструкций SPARC (VIS). Когда вы используете</target>
        </trans-unit>
        <trans-unit id="76e5e7f27add586f752fd2c88bf216b480271ed7" translate="yes" xml:space="preserve">
          <source>GCC supports a &lt;code&gt;#pragma&lt;/code&gt; directive that changes the name used in assembly for a given declaration. While this pragma is supported on all platforms, it is intended primarily to provide compatibility with the Solaris system headers. This effect can also be achieved using the asm labels extension (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;).</source>
          <target state="translated">GCC поддерживает директиву &lt;code&gt;#pragma&lt;/code&gt; , которая изменяет имя, используемое в сборке для данного объявления. Хотя эта прагма поддерживается на всех платформах, она предназначена в первую очередь для обеспечения совместимости с заголовками системы Solaris. Этого эффекта также можно добиться с помощью расширения asm-меток (см. &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm-метки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="498314540c8d67676764e9f766eda8fd96a7daed" translate="yes" xml:space="preserve">
          <source>GCC supports a number of command-line options that control adding run-time instrumentation to the code it normally generates. For example, one purpose of instrumentation is collect profiling statistics for use in finding program hot spots, code coverage analysis, or profile-guided optimizations. Another class of program instrumentation is adding run-time checking to detect programming errors like invalid pointer dereferences or out-of-bounds array accesses, as well as deliberately hostile attacks such as stack smashing or C++ vtable hijacking. There is also a general hook which can be used to implement other forms of tracing or function-level instrumentation for debug or program analysis purposes.</source>
          <target state="translated">GCC поддерживает ряд опций командной строки,которые управляют добавлением приборов выполнения в код,который он обычно генерирует.Например,одной из целей приборостроения является сбор профилирующей статистики для использования в поиске &quot;горячих точек&quot; программ,анализе покрытия кода или оптимизациях под профиль.Другой класс программных инструментов-это добавление проверки времени исполнения для обнаружения ошибок программирования,таких как некорректные разыменования указателей или несанкционированный доступ к массивам,а также умышленно враждебные атаки,такие как разбиение стека или перехват таблиц C++.Существует также общий крюк,который может быть использован для реализации других форм трассировки или инструментов на уровне функций для отладки или анализа программы.</target>
        </trans-unit>
        <trans-unit id="1030e6dea2c81b69bdc7270b03b39b5f569ad6fa" translate="yes" xml:space="preserve">
          <source>GCC supports a variant of the o32 ABI in which floating-point registers are 64 rather than 32 bits wide. You can select this combination with</source>
          <target state="translated">GCC поддерживает вариант o32 ABI,в котором регистры с плавающей точкой имеют ширину 64,а не 32 бита.Вы можете выбрать эту комбинацию с помощью</target>
        </trans-unit>
        <trans-unit id="c3965449e7a5dc4d5ed8a9dc3199dec909c35dc5" translate="yes" xml:space="preserve">
          <source>GCC supports only two&amp;rsquo;s complement integer types, and all bit patterns are ordinary values.</source>
          <target state="translated">GCC поддерживает только два дополнительных целых типа, и все битовые шаблоны являются обычными значениями.</target>
        </trans-unit>
        <trans-unit id="83dd0c21621e0a6e0dd523c863cbfaef04449bd4" translate="yes" xml:space="preserve">
          <source>GCC supports paired-single operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC поддерживает парно-одиночные операции, используя как общие векторные расширения (см. &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Векторные расширения&lt;/a&gt; ), так и набор встроенных функций, специфичных для MIPS. Оба вида поддержки включены в</target>
        </trans-unit>
        <trans-unit id="b55fc398fe2655fec7265522ba909be632a50b88" translate="yes" xml:space="preserve">
          <source>GCC supports several types of pragmas, primarily in order to compile code originally written for other compilers. Note that in general we do not recommend the use of pragmas; See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for further explanation.</source>
          <target state="translated">GCC поддерживает несколько типов прагм, в первую очередь для компиляции кода, изначально написанного для других компиляторов. Обратите внимание, что в целом мы не рекомендуем использовать прагмы; См. &amp;laquo; &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&amp;raquo;&lt;/a&gt; для дальнейшего объяснения.</target>
        </trans-unit>
        <trans-unit id="653525fcb8a016916ca28e1dd65b18ab8839e4b5" translate="yes" xml:space="preserve">
          <source>GCC supports some of the RX instructions which cannot be expressed in the C programming language via the use of built-in functions. The following functions are supported:</source>
          <target state="translated">GCC поддерживает некоторые инструкции RX,которые не могут быть выражены на языке программирования C с помощью встроенных функций.Поддерживаются следующие функции:</target>
        </trans-unit>
        <trans-unit id="4b0cba78b946248aec959caf8a965144462518ce" translate="yes" xml:space="preserve">
          <source>GCC supports the D 2.0 programming language. The D language itself is currently defined by its reference implementation and supporting language specification, described at &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;.</source>
          <target state="translated">GCC поддерживает язык программирования D 2.0. Сам язык D в настоящее время определяется его эталонной реализацией и спецификацией поддерживающего языка, описанной на &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="359d53772696a2b7864fe27fe3565593d8a4b28c" translate="yes" xml:space="preserve">
          <source>GCC supports the following AVR devices and ISAs:</source>
          <target state="translated">GCC поддерживает следующие устройства AVR и ISA:</target>
        </trans-unit>
        <trans-unit id="2ea7c76cda0c4fbb899bd829aa15b4c8a69297f6" translate="yes" xml:space="preserve">
          <source>GCC supports the original ISO C++ standard published in 1998, and the 2011 and 2014 revisions.</source>
          <target state="translated">GCC поддерживает оригинальный стандарт ISO C++,опубликованный в 1998 году,а также редакции 2011 и 2014 годов.</target>
        </trans-unit>
        <trans-unit id="858a69c7492112ce45741ecc79e61821fd61a803" translate="yes" xml:space="preserve">
          <source>GCC supports these options when compiling for C-SKY V2 processors.</source>
          <target state="translated">GCC поддерживает эти опции при компиляции для процессоров C-SKY V2.</target>
        </trans-unit>
        <trans-unit id="0dc67ad6d4b46256a65720385ae1177b91b75554" translate="yes" xml:space="preserve">
          <source>GCC supports two forms of SVE code generation: &amp;ldquo;vector-length agnostic&amp;rdquo; output that works with any size of vector register and &amp;ldquo;vector-length specific&amp;rdquo; output that allows GCC to make assumptions about the vector length when it is useful for optimization reasons. The possible values of &amp;lsquo;</source>
          <target state="translated">GCC поддерживает две формы генерации кода SVE: вывод &amp;laquo;независимо от длины вектора&amp;raquo;, который работает с любым размером векторного регистра, и вывод &amp;laquo;зависящий от длины вектора&amp;raquo;, который позволяет GCC делать предположения о длине вектора, когда это полезно по причинам оптимизации. Возможные значения '</target>
        </trans-unit>
        <trans-unit id="5b3ded850043ac176423c8bd10dd3fbbab6dc5cd" translate="yes" xml:space="preserve">
          <source>GCC treats all characters of identifiers as significant. According to K&amp;amp;R-1 (2.2), &amp;ldquo;No more than the first eight characters are significant, although more may be used.&amp;rdquo;. Also according to K&amp;amp;R-1 (2.2), &amp;ldquo;An identifier is a sequence of letters and digits; the first character must be a letter. The underscore _ counts as a letter.&amp;rdquo;, but GCC also allows dollar signs in identifiers.</source>
          <target state="translated">GCC рассматривает все символы идентификаторов как значимые. Согласно K&amp;amp;R-1 (2.2), &amp;laquo;не более первых восьми символов имеют значение, хотя могут использоваться и другие&amp;raquo;. Также согласно K&amp;amp;R-1 (2.2), &amp;laquo;идентификатор - это последовательность букв и цифр; первый символ должен быть буквой. Знак подчеркивания _ считается буквой. &amp;raquo;, Но GCC также допускает использование знаков доллара в идентификаторах.</target>
        </trans-unit>
        <trans-unit id="feaee8cb866302ba1b5ec59a1ce37d673602a1f3" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code (as if by</source>
          <target state="translated">GCC использует &lt;var&gt;name&lt;/var&gt; чтобы определить, какие инструкции он может выдавать при генерации кода сборки (как если бы</target>
        </trans-unit>
        <trans-unit id="66e1ddf3758925ad2362fd6f220c229932999055" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code. If</source>
          <target state="translated">GCC использует &lt;var&gt;name&lt;/var&gt; чтобы определить, какие инструкции он может выдавать при генерации кода сборки. Если</target>
        </trans-unit>
        <trans-unit id="813ae2789d4b6769128e82ee496ab87522d87f2b" translate="yes" xml:space="preserve">
          <source>GCC uses a garbage collector to manage its own memory allocation. This parameter specifies the minimum percentage by which the garbage collector&amp;rsquo;s heap should be allowed to expand between collections. Tuning this may improve compilation speed; it has no effect on code generation.</source>
          <target state="translated">GCC использует сборщик мусора для управления выделением собственной памяти. Этот параметр указывает минимальный процент, на который куче сборщика мусора должно быть разрешено расширяться между сборками. Настройка этого может улучшить скорость компиляции; это не влияет на генерацию кода.</target>
        </trans-unit>
        <trans-unit id="ae9ac11b129e57b155bc25157be869b1b76e80ad" translate="yes" xml:space="preserve">
          <source>GCC uses corrected versions of system header files. This is necessary, but doesn&amp;rsquo;t always work smoothly.</source>
          <target state="translated">GCC использует исправленные версии файлов системных заголовков. Это необходимо, но не всегда гладко.</target>
        </trans-unit>
        <trans-unit id="819a72ed7eaf70f991d756c9fa760994a62ab526" translate="yes" xml:space="preserve">
          <source>GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (</source>
          <target state="translated">GCC использует эвристику для угадывания вероятностей ветвей,если они не обеспечиваются обратной связью по профилированию (</target>
        </trans-unit>
        <trans-unit id="1a8376e3c4e7645e0b124141064b06d15d9df6a1" translate="yes" xml:space="preserve">
          <source>GCC uses the system C library, which might not be compliant with the ISO C standard.</source>
          <target state="translated">GCC использует библиотеку систем С,которая может не соответствовать стандарту ISO C.</target>
        </trans-unit>
        <trans-unit id="ca6cd448f1a33799ac2da1a0d9dfa000cd6841ec" translate="yes" xml:space="preserve">
          <source>GCC will not inline any functions if the</source>
          <target state="translated">GCC не будет встраивать никакие функции,если</target>
        </trans-unit>
        <trans-unit id="8a47996357771546a1d05e5991be4fe03520b6e5" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s default behavior is to emit all inline functions with the &lt;code&gt;dllexport&lt;/code&gt; attribute. Since this can cause object file-size bloat, you can use</source>
          <target state="translated">По умолчанию GCC создает все встроенные функции с атрибутом &lt;code&gt;dllexport&lt;/code&gt; . Поскольку это может вызвать раздувание размера файла объекта, вы можете использовать</target>
        </trans-unit>
        <trans-unit id="af8e45be98e36024842dc1bd8893718108d0574b" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s implementation of the high-level language interface available from C and C++ code differs from Motorola&amp;rsquo;s documentation in several ways.</source>
          <target state="translated">Реализация GCC интерфейса высокого уровня, доступного из кода C и C ++, отличается от документации Motorola по нескольким причинам.</target>
        </trans-unit>
        <trans-unit id="e78ca1e1182b55c5bde4b195b5d85015058a98d0" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers do not treat this code like the non-volatile code in the earlier examples. They do not move it out of loops or omit it on the assumption that the result from a previous call is still valid.</source>
          <target state="translated">Оптимизаторы GCC не обрабатывают этот код как энергонезависимый код в предыдущих примерах. Они не выводят его из циклов и не пропускают, полагая, что результат предыдущего вызова все еще действителен.</target>
        </trans-unit>
        <trans-unit id="dbc61f28ee0b681eff97897cb82a2c8d282dc076" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers sometimes discard &lt;code&gt;asm&lt;/code&gt; statements if they determine there is no need for the output variables. Also, the optimizers may move code out of loops if they believe that the code will always return the same result (i.e. none of its input values change between calls). Using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables these optimizations. &lt;code&gt;asm&lt;/code&gt; statements that have no output operands, including &lt;code&gt;asm goto&lt;/code&gt; statements, are implicitly volatile.</source>
          <target state="translated">Оптимизаторы GCC иногда отбрасывают операторы &lt;code&gt;asm&lt;/code&gt; , если они определяют, что выходные переменные не нужны. Кроме того, оптимизаторы могут вывести код из циклов, если они считают, что код всегда будет возвращать один и тот же результат (т.е. ни одно из его входных значений не меняется между вызовами). Использование квалификатора &lt;code&gt;volatile&lt;/code&gt; отключает эти оптимизации. Операторы &lt;code&gt;asm&lt;/code&gt; , у которых нет выходных операндов, включая &lt;code&gt;asm goto&lt;/code&gt; , неявно изменчивы.</target>
        </trans-unit>
        <trans-unit id="1e750d3c829a6b818589899b42ede982312a7f98" translate="yes" xml:space="preserve">
          <source>GCOV_ERROR_FILE</source>
          <target state="translated">GCOV_ERROR_FILE</target>
        </trans-unit>
        <trans-unit id="e485aa772b73ea7b58dcf4966c0a2d3b9c745805" translate="yes" xml:space="preserve">
          <source>GCOV_EXIT_AT_ERROR</source>
          <target state="translated">GCOV_EXIT_AT_ERROR</target>
        </trans-unit>
        <trans-unit id="80aecc9b56754f32438dd132183cddc7e4df32f1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX contains the prefix to add to the absolute paths in the object file. Prefix can be absolute, or relative. The default is no prefix.</source>
          <target state="translated">GCOV_PREFIX содержит префикс для добавления в объектный файл абсолютных путей.Префикс может быть абсолютным или относительным.По умолчанию префикс отсутствует.</target>
        </trans-unit>
        <trans-unit id="891aee4538b1a332bb00b85c9e7c43d1cf40d1d1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX=/target/run</source>
          <target state="translated">GCOV_PREFIX=/target/run</target>
        </trans-unit>
        <trans-unit id="f0bcf8de4466a3194e31ce81577ad85f4f449ccb" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP indicates the how many initial directory names to strip off the hardwired absolute paths. Default value is 0.</source>
          <target state="translated">GCOV_PREFIX_STRIP показывает,сколько исходных имён каталогов нужно снять с жёстко закреплённых абсолютных путей.Значение по умолчанию равно 0.</target>
        </trans-unit>
        <trans-unit id="7069713a73584b12e5e1b6c6673abb78172fe103" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP=1</source>
          <target state="translated">GCOV_PREFIX_STRIP=1</target>
        </trans-unit>
        <trans-unit id="a007084938316d2847460b0f869fd2dab151324f" translate="yes" xml:space="preserve">
          <source>GFNI instructions.</source>
          <target state="translated">Инструкции ГФНИ.</target>
        </trans-unit>
        <trans-unit id="768001d59e5da45e8ce2de4652950a5db0123cf5" translate="yes" xml:space="preserve">
          <source>GNU C allows you to associate specific hardware registers with C variables. In almost all cases, allowing the compiler to assign registers produces the best code. However under certain unusual circumstances, more precise control over the variable storage is required.</source>
          <target state="translated">GNU C позволяет связывать определенные аппаратные регистры с переменными Си.Почти во всех случаях,позволяя компилятору присваивать регистры,получается лучший код.Однако при определённых необычных обстоятельствах требуется более точный контроль над хранением переменных.</target>
        </trans-unit>
        <trans-unit id="1282a7948680a82fce143391cee57deb8d315356" translate="yes" xml:space="preserve">
          <source>GNU C extends ISO C to allow a function prototype to override a later old-style non-prototype definition. Consider the following example:</source>
          <target state="translated">GNU C расширяет ISO C,чтобы позволить прототипу функции переопределить более позднее определение непрототипа в старом стиле.Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="e77e07d95404402b67fc9bef0aec0c9a34ecc38f" translate="yes" xml:space="preserve">
          <source>GNU C provides several language features not found in ISO standard C. (The</source>
          <target state="translated">GNU C предоставляет несколько языковых возможностей,не встречающихся в стандарте ISO C.(The</target>
        </trans-unit>
        <trans-unit id="d45fbb49066a76f230e9020bfe458e74293358d2" translate="yes" xml:space="preserve">
          <source>GNU C++ does not support old-style function definitions, so this extension is irrelevant.</source>
          <target state="translated">GNU C++не поддерживает определения функций в старом стиле,так что это расширение не имеет значения.</target>
        </trans-unit>
        <trans-unit id="2ba257a10dfda1a80f343df43a5f9faccbca64b3" translate="yes" xml:space="preserve">
          <source>GNU CPP has two further variadic macro extensions, and permits them to be used with either of the above forms of macro definition.</source>
          <target state="translated">GNU CPP имеет два дополнительных вариадических макрорасширения и позволяет использовать их с любой из вышеперечисленных форм макроопределения.</target>
        </trans-unit>
        <trans-unit id="9dbaa828d6809d3452cb2a6728f3023aae5a8b22" translate="yes" xml:space="preserve">
          <source>GNU CPP permits you to completely omit the variable arguments in this way. In the above examples, the compiler would complain, though since the expansion of the macro still has the extra comma after the format string.</source>
          <target state="translated">GNU CPP позволяет вам полностью опускать аргументы переменных таким образом.В приведенных выше примерах компилятор будет жаловаться,хотя поскольку в расширении макроса все равно есть лишняя запятая после строки форматирования.</target>
        </trans-unit>
        <trans-unit id="0e4ec8a54cfff9c2845fa38842cb6cd1bdea197d" translate="yes" xml:space="preserve">
          <source>GNU Free Documentation License</source>
          <target state="translated">Лицензия свободной документации GNU</target>
        </trans-unit>
        <trans-unit id="d9cbf0740e34d88c506fb7df6e17deeabd18660c" translate="yes" xml:space="preserve">
          <source>GNU General Public License</source>
          <target state="translated">Стандартная общественная лицензия GNU</target>
        </trans-unit>
        <trans-unit id="ea5447d52819458fc788d8fe66484dcf6f8b58c5" translate="yes" xml:space="preserve">
          <source>GNU General Public License says how you can copy and share GCC.</source>
          <target state="translated">В Стандартной общественной лицензии GNU сказано,как вы можете копировать GCC и обмениваться им.</target>
        </trans-unit>
        <trans-unit id="a21d2651a31b14abba6b9f4cc89e6d16156a2f47" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides constant string objects that are generated directly by the compiler. You declare a constant string object by prefixing a C constant string with the character &amp;lsquo;</source>
          <target state="translated">GNU Objective-C предоставляет постоянные строковые объекты, которые генерируются непосредственно компилятором. Вы объявляете объект константной строки, добавляя к константной строке C символ '</target>
        </trans-unit>
        <trans-unit id="d4b0f24c5578d309a3a80bcf9db1efef7dc80491" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides exception support built into the language, as in the following example:</source>
          <target state="translated">GNU Objective-C предоставляет поддержку исключений,встроенных в язык,как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="183b8b6fa7f0ebe7cc24b6e6b64ea37e46538bc2" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for synchronized blocks:</source>
          <target state="translated">GNU Objective-C обеспечивает поддержку синхронизированных блоков:</target>
        </trans-unit>
        <trans-unit id="5a76f04c435b8a53e2673208f47df13d27337155" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for the fast enumeration syntax:</source>
          <target state="translated">GNU Objective-C обеспечивает поддержку синтаксиса быстрого перечисления:</target>
        </trans-unit>
        <trans-unit id="bd8453bc7fd0b5c5a5eb0b2fb1cc7653d6106ce4" translate="yes" xml:space="preserve">
          <source>GNU Objective-C runtime features.</source>
          <target state="translated">Возможности GNU Objective-C во время выполнения.</target>
        </trans-unit>
        <trans-unit id="dc4139cbd1ca2e4ec1fdbaf154a309856bbea2a6" translate="yes" xml:space="preserve">
          <source>GNU Objective-C supports the &lt;code&gt;@encode&lt;/code&gt; syntax that allows you to create a type encoding from a C/Objective-C type. For example, &lt;code&gt;@encode(int)&lt;/code&gt; is compiled by the compiler into &lt;code&gt;&quot;i&quot;&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-C поддерживает синтаксис &lt;code&gt;@encode&lt;/code&gt; , который позволяет вам создавать кодировку типа из типа C / Objective-C. Например, &lt;code&gt;@encode(int)&lt;/code&gt; компилируется компилятором в &lt;code&gt;&quot;i&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72bdab580bf81d58abe49ef7feb3d22b198aca72" translate="yes" xml:space="preserve">
          <source>GNU dialect of</source>
          <target state="translated">диалект GNU</target>
        </trans-unit>
        <trans-unit id="0cce44d2e046653755b9171f853b5aa7f7510c0f" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C11. The name &amp;lsquo;</source>
          <target state="translated">GNU-диалект ISO C11. Имя '</target>
        </trans-unit>
        <trans-unit id="17c597be9d56a306b84e8b735a051e0b49bf682b" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C17. This is the default for C code.</source>
          <target state="translated">GNU диалект ISO C17.Это код C по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cd7ba84a6cf37a43cdd1bd215e060138c20d80ef" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C90 (including some C99 features).</source>
          <target state="translated">GNU диалект ISO C90 (включая некоторые функции C99).</target>
        </trans-unit>
        <trans-unit id="5a96bf0e0eb1648d92a5415bbf82f314f50fc95d" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C99. The name &amp;lsquo;</source>
          <target state="translated">GNU-диалект ISO C99. Имя '</target>
        </trans-unit>
        <trans-unit id="c7513a88e6766734c8fff0b65e9260cb06e07819" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C language family.</source>
          <target state="translated">Расширения GNU к семейству языков Си.</target>
        </trans-unit>
        <trans-unit id="90b8cbfe3e7aa922a28ad77fd2468b165d25db6d" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C++ language.</source>
          <target state="translated">Расширения GNU к языку Си++.</target>
        </trans-unit>
        <trans-unit id="73a49c549f68005dbe48c29ca2788c5808080012" translate="yes" xml:space="preserve">
          <source>General purpose register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">Регистр общего назначения,если включены 64-битные инструкции или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="005c5bd36bc2dae00112330a475935d63f7703b1" translate="yes" xml:space="preserve">
          <source>General register 1</source>
          <target state="translated">Главный регистр 1</target>
        </trans-unit>
        <trans-unit id="b09ef9c6988403ff1cf426fea1c658c5b1f6be6e" translate="yes" xml:space="preserve">
          <source>General register &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r3&lt;/code&gt; for &lt;code&gt;addl&lt;/code&gt; instruction</source>
          <target state="translated">Общий регистр от &lt;code&gt;r0&lt;/code&gt; до &lt;code&gt;r3&lt;/code&gt; для инструкции &lt;code&gt;addl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e89cc1c76441abdf1cb24c29330f5f35d304a8e7" translate="yes" xml:space="preserve">
          <source>General register, but not &lt;code&gt;r29&lt;/code&gt;, &lt;code&gt;r30&lt;/code&gt; and &lt;code&gt;r31&lt;/code&gt;</source>
          <target state="translated">Общий регистр, но не &lt;code&gt;r29&lt;/code&gt; , &lt;code&gt;r30&lt;/code&gt; и &lt;code&gt;r31&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10bd548f00f5df8e11316ab27529f8ec0d489ead" translate="yes" xml:space="preserve">
          <source>General-purpose 32-bit register</source>
          <target state="translated">32-битный регистр общего назначения</target>
        </trans-unit>
        <trans-unit id="d86490a439329533a7fda073910d458d177b7499" translate="yes" xml:space="preserve">
          <source>Generally there is no guarantee that a memory transaction ever succeeds and suitable fallback code always needs to be supplied.</source>
          <target state="translated">Как правило,нет гарантии,что операция с памятью когда-нибудь будет успешной,и всегда должен быть предоставлен подходящий запасной код.</target>
        </trans-unit>
        <trans-unit id="c220eb05478a76fade659e7f472b8e896908bfb7" translate="yes" xml:space="preserve">
          <source>Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function independent of any restrictions that otherwise apply to inlining. Failure to inline such a function is diagnosed as an error. Note that if such a function is called indirectly the compiler may or may not inline it depending on optimization level and a failure to inline an indirect call may or may not be diagnosed.</source>
          <target state="translated">Как правило,функции не подставляются,если не указана оптимизация.Для функций,объявленных inline,данный атрибут встраивает функцию независимо от каких-либо ограничений,которые в противном случае применяются к встраиванию.Отказ от встраивания такой функции диагностируется как ошибка.Обратите внимание,что при косвенном вызове такой функции компилятор может встраивать или не встраивать ее в зависимости от уровня оптимизации,а при непрямом вызове может диагностироваться или не диагностироваться отказ от встраивания.</target>
        </trans-unit>
        <trans-unit id="84a7c319c3d7d28e18ecbf416836eecf761297c6" translate="yes" xml:space="preserve">
          <source>Generally, inlining into a function is limited. For a function marked with this attribute, every call inside this function is inlined, if possible. Functions declared with attribute &lt;code&gt;noinline&lt;/code&gt; and similar are not inlined. Whether the function itself is considered for inlining depends on its size and the current inlining parameters.</source>
          <target state="translated">Как правило, встраивание в функцию ограничено. Для функции, отмеченной этим атрибутом, каждый вызов внутри этой функции, если это возможно, является встроенным. Функции, объявленные с атрибутом &lt;code&gt;noinline&lt;/code&gt; и т.п., не встроены. Будет ли сама функция рассматриваться для встраивания, зависит от ее размера и текущих параметров встраивания.</target>
        </trans-unit>
        <trans-unit id="da79890df831b8b599903d6736d5d918432eda2d" translate="yes" xml:space="preserve">
          <source>Generally, options specified at link time override those specified at compile time, although in some cases GCC attempts to infer link-time options from the settings used to compile the input files.</source>
          <target state="translated">Обычно опции,заданные во время компиляции,перекрывают опции,заданные во время компиляции,хотя в некоторых случаях GCC пытается вывести опции времени компиляции из настроек,используемых для компиляции входных файлов.</target>
        </trans-unit>
        <trans-unit id="ba4adeb327e032d99cfca5b51d0fd4daaa9b56fc" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) ColdFire hardware divide and remainder instructions. If</source>
          <target state="translated">Сгенерируйте (не генерируйте)инструкции по разделению аппаратного обеспечения ColdFire и остаток.Если</target>
        </trans-unit>
        <trans-unit id="0fe80a59bc1a906ccb8af3fc3416cadc3264624c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) GP-relative accesses. The following &lt;var&gt;option&lt;/var&gt; names are recognized:</source>
          <target state="translated">Генерировать (не генерировать) доступы, относящиеся к GP. Распознаются следующие названия &lt;var&gt;option&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="09abd950717c564f7150fc3aedac403b36224304" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) MIPS16 code. If GCC is targeting a MIPS32 or MIPS64 architecture, it makes use of the MIPS16e ASE.</source>
          <target state="translated">Сгенерировать (не генерировать)MIPS16 код.Если GCC нацелен на архитектуру MIPS32 или MIPS64,он использует MIPS16e ASE.</target>
        </trans-unit>
        <trans-unit id="7322f1cb41e6457edd178c659eebf99bfcbafd3c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) addressing modes using prefixed load and store instructions when the option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188ec1e266203e4853a13748340fc36d3e35234e" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is fully position-independent, and that can therefore be linked into shared libraries. This option only affects</source>
          <target state="translated">Генерируйте (не генерируйте)код,который полностью не зависит от позиции и поэтому может быть скомпонован в общие библиотеки.Этот вариант влияет только на</target>
        </trans-unit>
        <trans-unit id="0a056a294949b854726ab099acb14488ae9baeac" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is suitable for SVR4-style dynamic objects.</source>
          <target state="translated">Сгенерировать (не генерировать)код,подходящий для динамических объектов в стиле SVR4.</target>
        </trans-unit>
        <trans-unit id="200f92cbd3d74fb5f3e648ecaaea7b69d566f040" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that uses &lt;em&gt;base addresses&lt;/em&gt;. Using a base address automatically generates a request (handled by the assembler and the linker) for a constant to be set up in a global register. The register is used for one or more base address requests within the range 0 to 255 from the value held in the register. The generally leads to short and fast code, but the number of different data items that can be addressed is limited. This means that a program that uses lots of static data may require</source>
          <target state="translated">Генерировать (не генерировать) код, использующий &lt;em&gt;базовые адреса&lt;/em&gt; . Использование базового адреса автоматически генерирует запрос (обрабатываемый ассемблером и компоновщиком) для константы, которая будет установлена ​​в глобальном регистре. Регистр используется для одного или нескольких запросов базового адреса в диапазоне от 0 до 255 от значения, хранящегося в регистре. Обычно это приводит к короткому и быстрому коду, но количество различных элементов данных, которые могут быть адресованы, ограничено. Это означает, что программе, использующей много статических данных, может потребоваться</target>
        </trans-unit>
        <trans-unit id="fc8c5a89f214acd8179a09f487fb87bbd0d7c872" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to load up the static chain register (&lt;code&gt;r11&lt;/code&gt;) when calling through a pointer on AIX and 64-bit Linux systems where a function pointer points to a 3-word descriptor giving the function address, TOC value to be loaded in register &lt;code&gt;r2&lt;/code&gt;, and static chain value to be loaded in register &lt;code&gt;r11&lt;/code&gt;. The</source>
          <target state="translated">Сгенерировать (не генерировать) код для загрузки статического регистра цепочки ( &lt;code&gt;r11&lt;/code&gt; ) при вызове через указатель в AIX и 64-битных системах Linux, где указатель функции указывает на трехсловный дескриптор, дающий адрес функции, значение TOC должно быть загружается в регистр &lt;code&gt;r2&lt;/code&gt; , а статическое значение цепочки загружается в регистр &lt;code&gt;r11&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="813e9e6ca1642f726fee97bfddf02338960484b7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to pass structure parameters with a maximum alignment of 64 bits, for compatibility with older versions of GCC.</source>
          <target state="translated">Сгенерировать (не генерировать)код для передачи параметров структуры с максимальным выравниванием 64 бита,для совместимости со старыми версиями GCC.</target>
        </trans-unit>
        <trans-unit id="55cac71e3fa8543a26a5b7f404ac565adfa17f28" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to save the TOC value in the reserved stack location in the function prologue if the function calls through a pointer on AIX and 64-bit Linux systems. If the TOC value is not saved in the prologue, it is saved just before the call through the pointer. The</source>
          <target state="translated">Сгенерировать (не генерировать)код для сохранения значения TOC в зарезервированном месте стека в прологе функции в случае вызова функции по указателю на AIX и 64-битных Linux системах.Если значение TOC не сохраняется в прологе,оно сохраняется непосредственно перед вызовом через указатель..</target>
        </trans-unit>
        <trans-unit id="492f533f0926b6f12aa3c20775f6e3689bd7771b" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) microMIPS code.</source>
          <target state="translated">Сгенерируйте (не генерируйте)микроМИПС-код.</target>
        </trans-unit>
        <trans-unit id="3996f10552777a166b0e49d921b421c578c5e2f7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) pc-relative addressing when the option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38ed93b70630b073ac9de0cd53b30eca713a227" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the &lt;code&gt;friz&lt;/code&gt; instruction when the</source>
          <target state="translated">Сгенерировать (не генерировать) инструкцию &lt;code&gt;friz&lt;/code&gt; , когда</target>
        </trans-unit>
        <trans-unit id="59dec4f42737e1a4ee2b102faf59b8bbec911145" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the MMA instructions when the option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87be6d200ff57766f2cf75cef2026526e7116620" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;bras&lt;/code&gt; instruction to do subroutine calls. This only works reliably if the total executable size does not exceed 64k. The default is to use the &lt;code&gt;basr&lt;/code&gt; instruction instead, which does not have this limitation.</source>
          <target state="translated">Сгенерируйте (или не генерируйте) код, используя инструкцию &lt;code&gt;bras&lt;/code&gt; для выполнения вызовов подпрограмм. Это работает надежно, только если общий размер исполняемого файла не превышает 64 КБ. По умолчанию вместо этого используется инструкция &lt;code&gt;basr&lt;/code&gt; , которая не имеет этого ограничения.</target>
        </trans-unit>
        <trans-unit id="dac8cd11137e120330b4b9ae84e6593137818e9a" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;mvcle&lt;/code&gt; instruction to perform block moves. When</source>
          <target state="translated">Сгенерируйте (или не генерируйте) код с &lt;code&gt;mvcle&lt;/code&gt; инструкции mvcle для выполнения перемещений блоков. когда</target>
        </trans-unit>
        <trans-unit id="2e0545421416cf516c0b942352accf8dc6b0a0d5" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) &amp;lsquo;</source>
          <target state="translated">Создавать (или не создавать) '</target>
        </trans-unit>
        <trans-unit id="05dd2841d03433fc0ea5db0c7e0df3c7599676c8" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) a stop bit immediately before and after volatile asm statements.</source>
          <target state="translated">Создавать (или не генерировать) стоп-бит непосредственно перед и после volatile asm-операторов.</target>
        </trans-unit>
        <trans-unit id="a0784cc5b984b19815bf9eec6e275ae1a59c3b0f" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU assembler. This is the default.</source>
          <target state="translated">Создавать (или не создавать) код для ассемблера GNU. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2516ed040d38a5388dd7fe01c44239d79052cf2e" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU linker. This is the default.</source>
          <target state="translated">Создавать (или не создавать) код для компоновщика GNU. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3e316b54c0eaa7bda512b60e40414c689d945ab8" translate="yes" xml:space="preserve">
          <source>Generate 16-bit instructions.</source>
          <target state="translated">Сгенерировать 16-битные инструкции.</target>
        </trans-unit>
        <trans-unit id="a52620c65360885e469f926c554c75bd50dd9583" translate="yes" xml:space="preserve">
          <source>Generate 3-instruction load and store sequences as sometimes required by the HP-UX 10 linker. This is equivalent to the &amp;lsquo;</source>
          <target state="translated">Создание последовательностей загрузки и сохранения с 3 инструкциями, как иногда требуется компоновщику HP-UX 10. Это эквивалентно '</target>
        </trans-unit>
        <trans-unit id="b384dbdcdcc6be12f32b73f9469c3ba6b9f1dccf" translate="yes" xml:space="preserve">
          <source>Generate 32x16-bit multiply and multiply-accumulate instructions.</source>
          <target state="translated">Сгенерируйте инструкции по умножению и накоплению 32x16 бит.</target>
        </trans-unit>
        <trans-unit id="0ccaaa46afb8881f4f3a477c92bc05eae68e0c4a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections in a format suitable for conversion into a GDB index. This option is only useful with a linker that can produce GDB index version 7.</source>
          <target state="translated">Сгенерируйте &lt;code&gt;.debug_pubnames&lt;/code&gt; и &lt;code&gt;.debug_pubtypes&lt;/code&gt; в формате, подходящем для преобразования в индекс GDB. Эта опция полезна только с компоновщиком, который может создавать индекс GDB версии 7.</target>
        </trans-unit>
        <trans-unit id="828612c6e2cc35cf1bee3972f49446cb2047aba1" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;mul64&lt;/code&gt; and &lt;code&gt;mulu64&lt;/code&gt; instructions. Only valid for</source>
          <target state="translated">Сгенерируйте &lt;code&gt;mul64&lt;/code&gt; и &lt;code&gt;mulu64&lt;/code&gt; . Действительно только для</target>
        </trans-unit>
        <trans-unit id="f37d583fd1aea916d55ab9e91fa3002c399aaf84" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;norm&lt;/code&gt; instructions. This is the default if</source>
          <target state="translated">Сгенерируйте инструкции &lt;code&gt;norm&lt;/code&gt; . Это значение по умолчанию, если</target>
        </trans-unit>
        <trans-unit id="2934019de0c741342611be8077a1571f0c44928a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;swap&lt;/code&gt; instructions.</source>
          <target state="translated">Сгенерируйте инструкции по &lt;code&gt;swap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="586858db58f3f2f4e0ba5be27cc76fd1d37e386f" translate="yes" xml:space="preserve">
          <source>Generate &lt;var&gt;N&lt;/var&gt; NOPs right at the beginning of each function, with the function entry point before the &lt;var&gt;M&lt;/var&gt;th NOP. If &lt;var&gt;M&lt;/var&gt; is omitted, it defaults to &lt;code&gt;0&lt;/code&gt; so the function entry points to the address just at the first NOP. The NOP instructions reserve extra space which can be used to patch in any desired instrumentation at run time, provided that the code segment is writable. The amount of space is controllable indirectly via the number of NOPs; the NOP instruction used corresponds to the instruction emitted by the internal GCC back-end interface &lt;code&gt;gen_nop&lt;/code&gt;. This behavior is target-specific and may also depend on the architecture variant and/or other compilation options.</source>
          <target state="translated">Генерируйте &lt;var&gt;N&lt;/var&gt; NOP в самом начале каждой функции, с точкой входа в функцию перед &lt;var&gt;M&lt;/var&gt; - й NOP. Если &lt;var&gt;M&lt;/var&gt; опущено, по умолчанию он равен &lt;code&gt;0&lt;/code&gt; , поэтому вход функции указывает на адрес только в первом NOP. Инструкции NOP резервируют дополнительное пространство, которое можно использовать для исправления любого желаемого инструментария во время выполнения, при условии, что сегмент кода доступен для записи. Объем пространства регулируется косвенно через количество NOP; используемая инструкция NOP соответствует инструкции, выпущенной внутренним внутренним интерфейсом &lt;code&gt;gen_nop&lt;/code&gt; . Это поведение зависит от цели и также может зависеть от варианта архитектуры и / или других параметров компиляции.</target>
        </trans-unit>
        <trans-unit id="b56d0340e46553074756e8938fdcc9bc10345ee9" translate="yes" xml:space="preserve">
          <source>Generate C header describing the largest structure that is passed by value, if any.</source>
          <target state="translated">Сгенерируйте заголовок C,описывающий самую большую структуру,которая передается по значению,если таковое имеется.</target>
        </trans-unit>
        <trans-unit id="497d1946c219789282a881eeb57aa9b71f210579" translate="yes" xml:space="preserve">
          <source>Generate DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections.</source>
          <target state="translated">Создайте разделы DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; и &lt;code&gt;.debug_pubtypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f0d6b717c142d078ddbdb831a6e380bea411850" translate="yes" xml:space="preserve">
          <source>Generate GNU/Linux compatible gUSA software atomic sequences for the atomic built-in functions. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for SH3* and SH4* single-core systems. This option is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH3* or SH4*. When the target is SH4A, this option also partially utilizes the hardware atomic instructions &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; to create more efficient code, unless &amp;lsquo;</source>
          <target state="translated">Генерация совместимых с GNU / Linux атомарных последовательностей программного обеспечения gUSA для атомарных встроенных функций. Сгенерированные атомарные последовательности требуют дополнительной поддержки со стороны кода системы обработки прерываний / исключений и подходят только для одноядерных систем SH3 * и SH4 *. Этот параметр включен по умолчанию, если целью является &lt;code&gt;sh*-*-linux*&lt;/code&gt; и SH3 * или SH4 *. Когда целью является SH4A, эта опция также частично использует аппаратные атомарные инструкции &lt;code&gt;movli.l&lt;/code&gt; и &lt;code&gt;movco.l&lt;/code&gt; для создания более эффективного кода, если только '</target>
        </trans-unit>
        <trans-unit id="bf2d938e1c1ea97f318900579ce3c50a9ae898af" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for all data objects in the program. If you use this option, the entire data and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">Сгенерировать GP-относительные доступы для всех объектов данных в программе.Если вы используете эту опцию,то все сегменты данных и BSS вашей программы должны поместиться в 64К памяти,и вы должны использовать соответствующий линковочный скрипт для их выделения в адресном диапазоне глобального указателя.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
