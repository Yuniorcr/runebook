<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="2f76b920d411b7e136fa4f9061e5e0a37ad6c0c4" translate="yes" xml:space="preserve">
          <source>For example, since the declaration of the primary function template below makes use of both attribute &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;alloc_size&lt;/code&gt; the declaration of the explicit specialization of the template is diagnosed because it is missing one of the attributes.</source>
          <target state="translated">Например, поскольку в &lt;code&gt;alloc_size&lt;/code&gt; шаблона основной функции ниже используются атрибуты &lt;code&gt;malloc&lt;/code&gt; и alloc_size, объявление явной специализации шаблона диагностируется, поскольку в нем отсутствует один из атрибутов.</target>
        </trans-unit>
        <trans-unit id="c1b19cb164dc1a4ab8a759ac490b8fde220e9c5e" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;struct A&lt;/code&gt; below is defined in some third party library header to have the alignment requirement &lt;code&gt;N&lt;/code&gt; and to force a warning whenever a variable of the type is not so aligned due to attribute &lt;code&gt;packed&lt;/code&gt;. Specifying the &lt;code&gt;copy&lt;/code&gt; attribute on the definition on the unrelated &lt;code&gt;struct B&lt;/code&gt; has the effect of copying all relevant attributes from the type referenced by the pointer expression to &lt;code&gt;struct B&lt;/code&gt;.</source>
          <target state="translated">Например, предположим, что &lt;code&gt;struct A&lt;/code&gt; ниже определена в заголовке какой-то сторонней библиотеки, чтобы иметь требование выравнивания &lt;code&gt;N&lt;/code&gt; и выдавать предупреждение всякий раз, когда переменная типа не выровнена таким образом из-за &lt;code&gt;packed&lt;/code&gt; атрибута . Задание &lt;code&gt;copy&lt;/code&gt; атрибута по определению на несвязанной &lt;code&gt;struct B&lt;/code&gt; имеет эффект копирования все соответствующие атрибуты типа , на который ссылается выражение указатель на &lt;code&gt;struct B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0be048f3761817dd96f745d3c57100422574646" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sprintf&lt;/code&gt; function on SunOS 4.1.3 returns &lt;code&gt;char *&lt;/code&gt; while the C standard says that &lt;code&gt;sprintf&lt;/code&gt; returns an &lt;code&gt;int&lt;/code&gt;. The &lt;code&gt;fixincludes&lt;/code&gt; program could make the prototype for this function match the Standard, but that would be wrong, since the function will still return &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">Например, функция &lt;code&gt;sprintf&lt;/code&gt; в SunOS 4.1.3 возвращает &lt;code&gt;char *&lt;/code&gt; ,в то время как стандарт C говорит, что &lt;code&gt;sprintf&lt;/code&gt; возвращает &lt;code&gt;int&lt;/code&gt; . Программа &lt;code&gt;fixincludes&lt;/code&gt; может заставить прототип этой функции соответствовать Стандарту, но это было бы неправильно, поскольку функция все равно будет возвращать &lt;code&gt;char *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd82a792fa22143d94897d2b758fc399175bbe0e" translate="yes" xml:space="preserve">
          <source>For example, the &lt;var&gt;StrongAlias&lt;/var&gt; macro below makes use of the &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;copy&lt;/code&gt; attributes to define an alias named &lt;var&gt;alloc&lt;/var&gt; for function &lt;var&gt;allocate&lt;/var&gt; declared with attributes &lt;var&gt;alloc_size&lt;/var&gt;, &lt;var&gt;malloc&lt;/var&gt;, and &lt;var&gt;nothrow&lt;/var&gt;. Thanks to the &lt;code&gt;__typeof__&lt;/code&gt; operator the alias has the same type as the target function. As a result of the &lt;code&gt;copy&lt;/code&gt; attribute the alias also shares the same attributes as the target.</source>
          <target state="translated">Например, &lt;var&gt;StrongAlias&lt;/var&gt; макроса ниже использует &lt;code&gt;alias&lt;/code&gt; и &lt;code&gt;copy&lt;/code&gt; атрибуты для определения псевдонима с именем &lt;var&gt;alloc&lt;/var&gt; для функции &lt;var&gt;allocate&lt;/var&gt; объявлена с атрибутами &lt;var&gt;alloc_size&lt;/var&gt; , &lt;var&gt;malloc&lt;/var&gt; и &lt;var&gt;nothrow&lt;/var&gt; . Благодаря оператору &lt;code&gt;__typeof__&lt;/code&gt; псевдоним имеет тот же тип, что и целевая функция. В результате использования атрибута &lt;code&gt;copy&lt;/code&gt; псевдоним также имеет те же атрибуты, что и целевой объект.</target>
        </trans-unit>
        <trans-unit id="5df659eda3281e74be2356574e1b1c1a2ec73bd0" translate="yes" xml:space="preserve">
          <source>For example, the call to &lt;code&gt;memset&lt;/code&gt; below is diagnosed by the warning because the function expects a value of type &lt;code&gt;size_t&lt;/code&gt; as its argument but the type of &lt;code&gt;32&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;. With</source>
          <target state="translated">Например, вызов &lt;code&gt;memset&lt;/code&gt; ниже диагностируется предупреждением, потому что функция ожидает значение типа &lt;code&gt;size_t&lt;/code&gt; в качестве аргумента, а тип &lt;code&gt;32&lt;/code&gt; - &lt;code&gt;int&lt;/code&gt; . С участием</target>
        </trans-unit>
        <trans-unit id="aa585d900b6a1decabca1b2daabff17e2775d789" translate="yes" xml:space="preserve">
          <source>For example, the compiler can only unconditionally vectorize the following loop with the pragma:</source>
          <target state="translated">Например,компилятор может только безоговорочно векторизовать следующий цикл с помощью прагмы:</target>
        </trans-unit>
        <trans-unit id="99f069ed5ba8ea293548f32b787eaedf45bdbd11" translate="yes" xml:space="preserve">
          <source>For example, the declaration:</source>
          <target state="translated">Например,декларация:</target>
        </trans-unit>
        <trans-unit id="b9ea9d42bbb55f00657375149871784a78c15592" translate="yes" xml:space="preserve">
          <source>For example, the following function allocates eight objects of &lt;code&gt;n&lt;/code&gt; bytes each on the stack, storing a pointer to each in consecutive elements of the array &lt;code&gt;a&lt;/code&gt;. It then passes the array to function &lt;code&gt;g&lt;/code&gt; which can safely use the storage pointed to by each of the array elements.</source>
          <target state="translated">Например, следующая функция выделяет восемь объектов по &lt;code&gt;n&lt;/code&gt; байтов каждый в стеке, сохраняя указатель на каждый из последовательных элементов массива &lt;code&gt;a&lt;/code&gt; . Затем он передает массив функции &lt;code&gt;g&lt;/code&gt; , которая может безопасно использовать хранилище, на которое указывает каждый из элементов массива.</target>
        </trans-unit>
        <trans-unit id="46ff8877e2ba5b3ad38e512c93a9f9393792e49a" translate="yes" xml:space="preserve">
          <source>For example, the following macro can be used to portably check, at compile-time, whether or not adding two constant integers will overflow, and perform the addition only when it is known to be safe and not to trigger a</source>
          <target state="translated">Например,следующий макрос может быть использован для портной проверки во время компиляции,будет ли переполняться добавление двух константных целых чисел или нет,и выполнять сложение только тогда,когда известно,что оно безопасно и не приводит в действие</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">Например,следующее:</target>
        </trans-unit>
        <trans-unit id="f3e3332c2d5e42f3076c20bce36d2593f9127ee9" translate="yes" xml:space="preserve">
          <source>For example, the implementation of the following function &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">Например, реализация следующей функции &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="71a4e8c7eb0a1fa15ef7a86f7ffb6699626c80d0" translate="yes" xml:space="preserve">
          <source>For example, this function has to be used in &lt;code&gt;ifunc&lt;/code&gt; resolvers that check for CPU type using the built-in functions &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, or in constructors on targets that don&amp;rsquo;t support constructor priority.</source>
          <target state="translated">Например, эту функцию необходимо использовать в преобразователях &lt;code&gt;ifunc&lt;/code&gt; , которые проверяют тип ЦП с помощью встроенных функций &lt;code&gt;__builtin_cpu_is&lt;/code&gt; и &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; , или в конструкторах для целей, которые не поддерживают приоритет конструктора.</target>
        </trans-unit>
        <trans-unit id="1dddf36660113e27ff669ff510c160e144321d93" translate="yes" xml:space="preserve">
          <source>For example, when the compiler encounters a method invocation such as &lt;code&gt;[object init]&lt;/code&gt;, it compiles it into a call to &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; followed by a cast of the returned value to the appropriate function pointer type, and then it calls it.</source>
          <target state="translated">Например, когда компилятор встречает вызов метода, такого как &lt;code&gt;[object init]&lt;/code&gt; , он компилирует его в вызов &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; за которым следует приведение возвращаемого значения к соответствующему типу указателя функции и затем он называет это.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="25bb7aced1792aec854f4198d7d0398ca1d4713d" translate="yes" xml:space="preserve">
          <source>For full documentation of the struct attributes please see the documentation in &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">Полную документацию по атрибутам структуры см. В документации по &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;атрибутам переменных x86&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3dc81c80b4604ccbc276f437a5ccc2aaa2515f6c" translate="yes" xml:space="preserve">
          <source>For indirect calls to functions and computed goto, the linker generates &lt;em&gt;stubs&lt;/em&gt;. Stubs are jump pads sometimes also called &lt;em&gt;trampolines&lt;/em&gt;. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address.</source>
          <target state="translated">Для косвенных вызовов функций и вычисленного goto компоновщик создает &lt;em&gt;заглушки&lt;/em&gt; . Коклейки - это прыжковые площадки, иногда также называемые &lt;em&gt;батутами&lt;/em&gt; . Таким образом, косвенный вызов / переход перескакивает на такую ​​заглушку. Заглушка содержит прямой переход к нужному адресу.</target>
        </trans-unit>
        <trans-unit id="b91d6fa4ba31d00f68a512834bc7eb5f8c52df71" translate="yes" xml:space="preserve">
          <source>For information about the O64 ABI, see &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;.</source>
          <target state="translated">Для получения информации о o64 ABI см &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56ee49f1a1b16838ed8d136422788b22655be9ea" translate="yes" xml:space="preserve">
          <source>For input files in any language, generate corresponding Go declarations in &lt;var&gt;file&lt;/var&gt;. This generates Go &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; declarations which may be a useful way to start writing a Go interface to code written in some other language.</source>
          <target state="translated">Для входных файлов на любом языке сгенерируйте соответствующие объявления Go в &lt;var&gt;file&lt;/var&gt; . Это генерирует объявления Go &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;func&lt;/code&gt; , которые могут быть полезным способом начать писать интерфейс Go для кода, написанного на другом языке.</target>
        </trans-unit>
        <trans-unit id="c8ce6c094048677a9f8423fec4581d4ef1bd1e5b" translate="yes" xml:space="preserve">
          <source>For instance</source>
          <target state="translated">Например</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="a8e07e43db118dd56bbb97b1f96ccc89bac7f5fd" translate="yes" xml:space="preserve">
          <source>For instance, if the stack starts at absolute address &amp;lsquo;</source>
          <target state="translated">Например, если стек начинается с абсолютного адреса '</target>
        </trans-unit>
        <trans-unit id="6abfd7e7f05346e1123b7bf2021cc93c61b8fbd5" translate="yes" xml:space="preserve">
          <source>For instance, if you have &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt;, and you have</source>
          <target state="translated">Например, если у вас есть &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt; , и у вас есть</target>
        </trans-unit>
        <trans-unit id="5b9b6fe2256c52fcd89c847ec80034c7cbe3d49d" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could compile a function with &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt;. GCC creates two function clones, one compiled with</source>
          <target state="translated">Например, на x86 вы можете скомпилировать функцию с &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt; . GCC создает два клона функции, одна из которых скомпилирована с</target>
        </trans-unit>
        <trans-unit id="175bbce2fc22d4ed1ec7614154a0e449231ccaf1" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could declare one function with the &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; attribute and another with &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt;. This is equivalent to compiling the first function with</source>
          <target state="translated">Например, на x86, вы можете объявить одну функцию с &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; атрибут , а другой с &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt; . Это эквивалентно компиляции первой функции с</target>
        </trans-unit>
        <trans-unit id="60600b26a9fa03b6c3650e82a7d4514147301ef9" translate="yes" xml:space="preserve">
          <source>For instance, on the SB-1, if FP exceptions are disabled, and we are emitting 64-bit code, then we can use both FP pipes. Otherwise, we can only use one FP pipe.</source>
          <target state="translated">Например,на SB-1,если исключения из FP отключены,и мы излучаем 64-битный код,то мы можем использовать оба FP канала.В противном случае,мы можем использовать только одну трубу FP.</target>
        </trans-unit>
        <trans-unit id="4d64dcd6f25c2f8e61dbb8fbe7c56bdb2499ab6d" translate="yes" xml:space="preserve">
          <source>For instance, the following declarations</source>
          <target state="translated">Например,следующие заявления</target>
        </trans-unit>
        <trans-unit id="fd17d596f35be2211443642e76ceab4e5f526b5c" translate="yes" xml:space="preserve">
          <source>For internal names, all characters are significant. For external names, the number of significant characters are defined by the linker; for almost all targets, all characters are significant.</source>
          <target state="translated">Для внутренних имен все символы значимы.Для внешних имён количество значащих символов определяется компоновщиком;почти для всех целей все символы являются значащими.</target>
        </trans-unit>
        <trans-unit id="9f99386843936f29083f4368b21c1771def8a251" translate="yes" xml:space="preserve">
          <source>For library code, if you want the library to provide all of the template instantiations it needs, just try to link all of its object files together; the link will fail, but cause the instantiations to be generated as a side effect. Be warned, however, that this may cause conflicts if multiple libraries try to provide the same instantiations. For greater control, use explicit instantiation as described in the next option.</source>
          <target state="translated">Для библиотечного кода,если вы хотите,чтобы библиотека предоставила все нужные ей инстанцинации шаблона,просто попробуйте связать все ее объектные файлы вместе;связь не удастся,но приведет к тому,что инстанцинации будут сгенерированы как побочный эффект.Предупреждаем,однако,что это может привести к конфликтам,если несколько библиотек попытаются предоставить одни и те же инстанцинации.Для большего контроля используйте явные инстанцинации,как описано в следующем варианте.</target>
        </trans-unit>
        <trans-unit id="275df5c8ab338eac0891dfd5fcb7ca333c414d1c" translate="yes" xml:space="preserve">
          <source>For machines that must pop arguments after a function call, always pop the arguments as soon as each function returns. At levels</source>
          <target state="translated">Для машин,которые должны выскакивать аргументы после вызова функции,всегда выскакивайте аргументы,как только возвращается каждая функция.На уровнях</target>
        </trans-unit>
        <trans-unit id="4ab62f1721d989066bd88fccf2cddf5cca6c289c" translate="yes" xml:space="preserve">
          <source>For more information concerning the history of Objective-C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">Для получения дополнительной информации об истории Objective-C, доступной в Интернете, см. &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;Http://gcc.gnu.org/readings.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="445882425cb6a5526123dcb90201317cd797b812" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">Дополнительные сведения о поддержке транзакционной памяти GCC см. &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;В&lt;/a&gt; разделе Библиотека транзакционной памяти GNU в библиотеке транзакционной памяти GNU.</target>
        </trans-unit>
        <trans-unit id="530d01e06da63e3ae60755b1d0e0664f37ce4c56" translate="yes" xml:space="preserve">
          <source>For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus</source>
          <target state="translated">Для профильных оптимизаций скомпилируйте исходные файлы снова с теми же опциями оптимизации и генерации кода плюс</target>
        </trans-unit>
        <trans-unit id="1552bee1f905030b453e9bc73123ec457682d5d2" translate="yes" xml:space="preserve">
          <source>For references to Technical Corrigenda, Rationale documents and information concerning the history of C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">Ссылки на технические исправления, документы с обоснованием и информацию об истории C, доступную в Интернете, см. На &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa91b9c573243f46d98173cb5c6bc69a14f37e" translate="yes" xml:space="preserve">
          <source>For run-time identification, the starting addresses of these areas, which correspond to their respective function entries minus &lt;var&gt;M&lt;/var&gt;, are additionally collected in the &lt;code&gt;__patchable_function_entries&lt;/code&gt; section of the resulting binary.</source>
          <target state="translated">Для идентификации во время выполнения начальные адреса этих областей, которые соответствуют их соответствующим записям функций за вычетом &lt;var&gt;M&lt;/var&gt; , дополнительно собираются в разделе &lt;code&gt;__patchable_function_entries&lt;/code&gt; результирующего двоичного файла .</target>
        </trans-unit>
        <trans-unit id="ee4662af110f3d316db91e4c9bf088b26f37f6fc" translate="yes" xml:space="preserve">
          <source>For single-precision floating-point comparisons, emit an &lt;code&gt;fsub&lt;/code&gt; instruction and test the flags. This is faster than a software comparison, but can get incorrect results in the presence of NaNs, or when two different small numbers are compared such that their difference is calculated as zero. The default is</source>
          <target state="translated">Для сравнений с плавающей запятой одинарной точности испустите инструкцию &lt;code&gt;fsub&lt;/code&gt; и проверьте флаги. Это быстрее, чем сравнение программного обеспечения, но может привести к неверным результатам при наличии NaN или при сравнении двух разных небольших чисел, так что их разница рассчитывается как ноль. По умолчанию</target>
        </trans-unit>
        <trans-unit id="629fb7062147649cb1707cc8cbe18549c87c4fce" translate="yes" xml:space="preserve">
          <source>For some target machines, GCC supports additional options to the format attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;).</source>
          <target state="translated">Для некоторых целевых машин GCC поддерживает дополнительные параметры атрибута формата (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Объявление атрибутов функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f693ccd95fd0352057c89a84d6dca28111b1d8d" translate="yes" xml:space="preserve">
          <source>For some targets, a suffix is added to the root directory specified with</source>
          <target state="translated">Для некоторых целей в корневую директорию,указанную с помощью параметра</target>
        </trans-unit>
        <trans-unit id="1eef11d2e0af6679534eba00e39380a79330c652" translate="yes" xml:space="preserve">
          <source>For string operations of unknown size, use run-time checks with inline code for small blocks and a library call for large blocks.</source>
          <target state="translated">Для строковых операций неизвестного размера используйте проверку времени выполнения с встроенным кодом для маленьких блоков и библиотечный вызов для больших блоков.</target>
        </trans-unit>
        <trans-unit id="c54c726dd72dd80b773414b86e870a30d193ec02" translate="yes" xml:space="preserve">
          <source>For systems that use the GNU C Library, the default is on.</source>
          <target state="translated">Для систем,использующих библиотеку Си GNU,по умолчанию включена.</target>
        </trans-unit>
        <trans-unit id="90889da6f3749d2d8e7f525edbcff60563fc34f5" translate="yes" xml:space="preserve">
          <source>For targets that do not support either COMDAT or weak symbols, most entities with vague linkage are emitted as local symbols to avoid duplicate definition errors from the linker. This does not happen for local statics in inlines, however, as having multiple copies almost certainly breaks things.</source>
          <target state="translated">Для целей,которые не поддерживают ни COMDAT,ни слабые символы,большинство сущностей с расплывчатой связью излучаются как локальные символы,чтобы избежать дублирования ошибок определения из компоновщика.Однако это не происходит для локальной статики в строках,так как наличие нескольких копий почти наверняка ломает вещи.</target>
        </trans-unit>
        <trans-unit id="db393fbd5a98ab60023bfd22b5dbbadca9023150" translate="yes" xml:space="preserve">
          <source>For targets that normally need trampolines for nested functions, always generate them instead of using descriptors. Otherwise, for targets that do not need them, like for example HP-PA or IA-64, do nothing.</source>
          <target state="translated">Для целей,которые обычно нуждаются в батутах для вложенных функций,всегда генерируйте их вместо использования дескрипторов.В противном случае,для целей,которые не нуждаются в них,например,HP-PA или IA-64,ничего не делать.</target>
        </trans-unit>
        <trans-unit id="3a882a0a0f801f0c1cb983c784834a8c5870b59e" translate="yes" xml:space="preserve">
          <source>For targets, like GNU/Linux, where all user-mode Xtensa code must be position-independent code (PIC), this option disables PIC for compiling kernel code.</source>
          <target state="translated">Для целей,таких как GNU/Linux,где все исходные тексты Xtensa пользовательского режима должны быть позиционно-независимыми (PIC),эта опция отключает PIC для компиляции исходных текстов ядра.</target>
        </trans-unit>
        <trans-unit id="8b8c7be3bb5a9384ba78f18abd2ee5fc45978a5a" translate="yes" xml:space="preserve">
          <source>For test coverage analysis, use &lt;code&gt;gcov&lt;/code&gt; to produce human readable information from the</source>
          <target state="translated">Для анализа тестового покрытия используйте &lt;code&gt;gcov&lt;/code&gt; для получения удобочитаемой информации из</target>
        </trans-unit>
        <trans-unit id="cdf3f70fc86ab5862691992f6df51e7ca5f5489e" translate="yes" xml:space="preserve">
          <source>For the NeXT runtime with version 2 of the ABI, check for a nil receiver in method invocations before doing the actual method call. This is the default and can be disabled using</source>
          <target state="translated">Для выполнения NeXT с версией 2 ABI,перед выполнением фактического вызова метода,проверьте нулевой приемник в вызовах методов.Это настройка по умолчанию,и ее можно отключить с помощью</target>
        </trans-unit>
        <trans-unit id="96b6c6242e369e6ead381c1d4d982f9072cadf3b" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler adds code to disable interrupts for the duration of those functions. If any functions so named are not encountered in the source, a warning is emitted that the pragma is not used. Examples:</source>
          <target state="translated">Для именованных функций компилятор добавляет код для отключения прерываний на время работы этих функций.Если какие-либо функции с таким именем в исходном коде не встречаются,выдается предупреждение о том,что прагма не используется.Примеры:</target>
        </trans-unit>
        <trans-unit id="b4ae72d8349f09925e7db4912a4034594f70873f" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler always uses a register-indirect call model when calling the named functions. Examples:</source>
          <target state="translated">Для именованных функций компилятор всегда использует модель прямого вызова из регистра при вызове именованных функций.Примеры:</target>
        </trans-unit>
        <trans-unit id="0f569d15217aa1a086b40826e8ecc6305b091d9b" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%. You can also use &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; to explicitly assign a probability value to individual expressions.</source>
          <target state="translated">Для целей оптимизации прогнозирования ветвлений вероятность того, что выражение &lt;code&gt;__builtin_expect&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; , контролируется параметром &lt;code&gt;builtin-expect-probability&lt;/code&gt; GCC , который по умолчанию равен 90%. Вы также можете использовать &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; , чтобы явно присвоить значение вероятности отдельным выражениям.</target>
        </trans-unit>
        <trans-unit id="bf219c0d4bab1b7372e20c5005cc97b0b9e1bb77" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directories specified by</source>
          <target state="translated">Для формы кавычек директивы include,каталоги,указанные в каталоге</target>
        </trans-unit>
        <trans-unit id="754ebda73d52810694ef0086a8c959916039f5fd" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directory of the current file is searched first.</source>
          <target state="translated">Для формы кавычек директивы include сначала выполняется поиск директории текущего файла.</target>
        </trans-unit>
        <trans-unit id="1d70b004544bcb6341f32cbd058f337db34bac6c" translate="yes" xml:space="preserve">
          <source>For the x86-32 compiler, you must use</source>
          <target state="translated">Для компилятора x86-32 необходимо использовать</target>
        </trans-unit>
        <trans-unit id="9e1a32426c586349d0aa1e4bc4474f828e773b55" translate="yes" xml:space="preserve">
          <source>For those adding visibility support to existing code, you may find &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. This works by you enclosing the declarations you wish to set visibility for with (for example) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; and &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt;. Bear in mind that symbol visibility should be viewed &lt;strong&gt;as part of the API interface contract&lt;/strong&gt; and thus all new code should always specify visibility when it is not the default; i.e., declarations only for use within the local DSO should &lt;strong&gt;always&lt;/strong&gt; be marked explicitly as hidden as so to avoid PLT indirection overheads&amp;mdash;making this abundantly clear also aids readability and self-documentation of the code. Note that due to ISO C++ specification requirements, &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; must always be of default visibility.</source>
          <target state="translated">Для тех, кто добавляет поддержку видимости в существующий код, вы можете найти &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. Это работает, если вы включаете объявления, для которых хотите установить видимость, с помощью (например) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; и &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt; . Имейте в виду, что видимость символа должна рассматриваться &lt;strong&gt;как часть контракта интерфейса API,&lt;/strong&gt; и поэтому весь новый код всегда должен указывать видимость, если она не задана по умолчанию; т. е. объявления только для использования в локальном DSO &lt;strong&gt;всегда&lt;/strong&gt; должны быть явно помечены как скрытые, чтобы избежать косвенных накладных расходов PLT - делая это предельно ясным, также способствует удобочитаемости и самодокументированию кода. Обратите внимание, что в соответствии с требованиями спецификации ISO C ++, &lt;code&gt;operator new&lt;/code&gt; и &lt;code&gt;operator delete&lt;/code&gt; всегда должны иметь видимость по умолчанию.</target>
        </trans-unit>
        <trans-unit id="bb6de8937de1ff830849ca65a0b4291fa1ceadf7" translate="yes" xml:space="preserve">
          <source>Force (do not force) generated code to have a single exit point in each function.</source>
          <target state="translated">Принудительная (не принудительная)генерация кода,чтобы иметь единую точку выхода в каждой функции.</target>
        </trans-unit>
        <trans-unit id="acd5ffdf657527d019579abefcb2cc6ad1c27289" translate="yes" xml:space="preserve">
          <source>Force (do not force) the use of &lt;code&gt;memcpy&lt;/code&gt; for non-trivial block moves. The default is</source>
          <target state="translated">Принудительное (не принудительное) использование &lt;code&gt;memcpy&lt;/code&gt; для нетривиальных перемещений блоков. По умолчанию</target>
        </trans-unit>
        <trans-unit id="f35628fb15f3c423c03af2c93b844cb43e594383" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt; types to be 64 bits wide. See</source>
          <target state="translated">Сделать &lt;code&gt;long&lt;/code&gt; типы шириной 64 бита. Видеть</target>
        </trans-unit>
        <trans-unit id="df341c9e8e9829ab23b420935fbc32e82bb7a353" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and pointer types to be 32 bits wide.</source>
          <target state="translated">Force &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; и типы указателей 32 бита в ширину.</target>
        </trans-unit>
        <trans-unit id="a65d4b81903833686ba857ca6166053cb9c8d543" translate="yes" xml:space="preserve">
          <source>Force GCC to assign view numbers internally, if</source>
          <target state="translated">Заставить GCC присвоить внутренние номера просмотров,если</target>
        </trans-unit>
        <trans-unit id="5c6c2109c0abfbfad2c57ae80b233af1137f54d6" translate="yes" xml:space="preserve">
          <source>Force GCC to generate DWARF2+ line number tables internally, if DWARF2+ line number tables are to be generated.</source>
          <target state="translated">Заставьте GCC создавать внутренние таблицы номеров строк DWARF2+,если необходимо создать таблицы номеров строк DWARF2+.</target>
        </trans-unit>
        <trans-unit id="e05ff97a2114aff3fe8702e99f968b0b9b270faf" translate="yes" xml:space="preserve">
          <source>Force all calls to functions to be indirect. This is useful when using Intel Processor Trace where it generates more precise timing information for function calls.</source>
          <target state="translated">Заставьте все вызовы к функциям быть косвенными.Это полезно при использовании Intel Processor Trace,где он генерирует более точную временную информацию для вызовов функций.</target>
        </trans-unit>
        <trans-unit id="c6aa1876252f253f5c49c98017976af7ef3a9f80" translate="yes" xml:space="preserve">
          <source>Force all functions to be aligned to a 4-byte boundary.</source>
          <target state="translated">Принудительно выровнять все функции по 4-байтовой границе.</target>
        </trans-unit>
        <trans-unit id="5376700e1a5ed02b4facb60bd51b070a514bbd9d" translate="yes" xml:space="preserve">
          <source>Force all load and store instructions to always bypass cache by using I/O variants of the instructions. The default is not to bypass the cache.</source>
          <target state="translated">Заставьте все инструкции по загрузке и хранению всегда обходить кэш-память,используя варианты инструкций по вводу/выводу.По умолчанию не следует обходить кэш.</target>
        </trans-unit>
        <trans-unit id="6ba14189273ea29b59425c68e227901a2b9a86ef" translate="yes" xml:space="preserve">
          <source>Force assembly output to always use hex constants. Normally such constants are signed decimals, but this option is available for testsuite and/or aesthetic purposes.</source>
          <target state="translated">Выход силовой сборки,чтобы всегда использовать шестнадцатиричные константы.Обычно такие константы представляют собой подписанные десятичные знаки,но этот вариант доступен для тестовых и/или эстетических целей.</target>
        </trans-unit>
        <trans-unit id="a09ed1d5a3164af1580e37f843c9d03a7f3d9584" translate="yes" xml:space="preserve">
          <source>Force code generation in the ARM (A32) ISA.</source>
          <target state="translated">Форсированная генерация кода в ARM (A32)ISA.</target>
        </trans-unit>
        <trans-unit id="8cf31b1c6efcebcf276d6ea54117f6f86a1ab3b3" translate="yes" xml:space="preserve">
          <source>Force code generation in the Thumb (T16/T32) ISA, depending on the architecture level.</source>
          <target state="translated">Форсированное генерирование кода на большом пальце (T16/T32)ISA,в зависимости от уровня архитектуры.</target>
        </trans-unit>
        <trans-unit id="57fc3d2f95e9a264681cfb6c086d3f11381e6d22" translate="yes" xml:space="preserve">
          <source>Force indirect call and jump via register.</source>
          <target state="translated">Принудительный косвенный вызов и прыжок через регистр.</target>
        </trans-unit>
        <trans-unit id="c2234a2c2c6fa572bb9aaff40c528a12cc4c9fff" translate="yes" xml:space="preserve">
          <source>Force the usage of delay slots for conditional branches, which stuffs the delay slot with a &lt;code&gt;nop&lt;/code&gt; if a suitable instruction cannot be found. By default this option is disabled. It can be enabled to work around hardware bugs as found in the original SH7055.</source>
          <target state="translated">Принудительное использование слотов задержки для условных переходов, при котором слот задержки &lt;code&gt;nop&lt;/code&gt; если подходящая инструкция не может быть найдена. По умолчанию эта опция отключена. Его можно включить для обхода аппаратных ошибок, обнаруженных в исходном SH7055.</target>
        </trans-unit>
        <trans-unit id="accd79a6ab2ab26b14a5acf0e4624a9287eb4f98" translate="yes" xml:space="preserve">
          <source>Force to call a function using jli_s instruction. This option is valid only for ARCv2 architecture.</source>
          <target state="translated">Принудительный вызов функции с помощью команды jli_s.Эта опция действительна только для архитектуры ARCv2.</target>
        </trans-unit>
        <trans-unit id="bda8d8b269a45b97f862176d65bac6c1e4f4afe4" translate="yes" xml:space="preserve">
          <source>Forces a particular function to be called using &lt;code&gt;jli&lt;/code&gt; instruction. The &lt;code&gt;jli&lt;/code&gt; instruction makes use of a table stored into &lt;code&gt;.jlitab&lt;/code&gt; section, which holds the location of the functions which are addressed using this instruction.</source>
          <target state="translated">&lt;code&gt;jli&lt;/code&gt; конкретную функцию с помощью инструкции jli . В &lt;code&gt;jli&lt;/code&gt; инструкции используют таблицы , хранящиеся в &lt;code&gt;.jlitab&lt;/code&gt; секцию, которая содержит расположение функций , которые рассматриваются с помощью этой инструкции.</target>
        </trans-unit>
        <trans-unit id="2f084ee73c513d8f966bbd0c40980e7ab5210b2e" translate="yes" xml:space="preserve">
          <source>Formal syntax for attributes.</source>
          <target state="translated">Формальный синтаксис для атрибутов.</target>
        </trans-unit>
        <trans-unit id="6e97cc41857aff390c1d1352f1580ff15ac71869" translate="yes" xml:space="preserve">
          <source>Format checks specific to particular targets.</source>
          <target state="translated">Формат проверяет конкретные цели.</target>
        </trans-unit>
        <trans-unit id="c4653752f8662d9cf50820b53f4f92b88244d0b2" translate="yes" xml:space="preserve">
          <source>Formerly the &lt;code&gt;hi&lt;/code&gt; register. This constraint is no longer supported.</source>
          <target state="translated">Раньше &lt;code&gt;hi&lt;/code&gt; регистр. Это ограничение больше не поддерживается.</target>
        </trans-unit>
        <trans-unit id="fb001b2c292ad2f619c8caf6e0ac8afd191aaa76" translate="yes" xml:space="preserve">
          <source>Framework</source>
          <target state="translated">Framework</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="a4a10834211c2c0fbcb7eeb4d7d706ce399ad1a9" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">Свободная форма исходного кода Fortran,который должен быть препроцессирован (с помощью традиционного препроцессора).</target>
        </trans-unit>
        <trans-unit id="ab1de10d533c059aa65605ce6bb4a93b10329a51" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that should not be preprocessed.</source>
          <target state="translated">Свободная форма исходных текстов Fortran,которые не должны препроцессироваться.</target>
        </trans-unit>
        <trans-unit id="5888490bf4ce1fb3617e200efdb6835e0c4faa44" translate="yes" xml:space="preserve">
          <source>Function attributes are introduced by the &lt;code&gt;__attribute__&lt;/code&gt; keyword in the declaration of a function, followed by an attribute specification enclosed in double parentheses. You can specify multiple attributes in a declaration by separating them by commas within the double parentheses or by immediately following one attribute specification with another. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for the exact rules on attribute syntax and placement. Compatible attribute specifications on distinct declarations of the same function are merged. An attribute specification that is not compatible with attributes already applied to a declaration of the same function is ignored with a warning.</source>
          <target state="translated">Атрибуты функции вводятся ключевым словом &lt;code&gt;__attribute__&lt;/code&gt; в объявлении функции, за которым следует спецификация атрибута, заключенная в двойные круглые скобки. Вы можете указать несколько атрибутов в объявлении, разделив их запятыми в двойных скобках или сразу после одной спецификации атрибута за другой. См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; точные правила синтаксиса и размещения атрибутов. Совместимые спецификации атрибутов для разных объявлений одной и той же функции объединяются. Спецификация атрибута, несовместимая с атрибутами, уже примененными к объявлению той же функции, игнорируется с предупреждением.</target>
        </trans-unit>
        <trans-unit id="f93ed46e6d86f7b87373026d5e663168479db390" translate="yes" xml:space="preserve">
          <source>Function precision. The trap handler can determine the function that caused a floating-point exception.</source>
          <target state="translated">Точность функционирования.Обработчик ловушки может определить функцию,которая вызвала исключение с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="d3d655b1f77fc46f162e436abc252a9dc6d8148d" translate="yes" xml:space="preserve">
          <source>Function prototype</source>
          <target state="translated">Прототип функции</target>
        </trans-unit>
        <trans-unit id="9e039f9c7013d88c23a38a281ed14037c4166f2d" translate="yes" xml:space="preserve">
          <source>Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.</source>
          <target state="translated">Переупорядочивание функций на основе профильных приборов собирает первый раз выполнения функции и упорядочивает эти функции в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="d33f90e4120ff23ca44b34b56f5771105ef3b24d" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 16-bit boundaries.</source>
          <target state="translated">Функции выравниваются по 16-битным границам.</target>
        </trans-unit>
        <trans-unit id="34be57d225a7e4b91308288bf7b00a21a76d0703" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 32-bit boundaries, unless optimizing for size.</source>
          <target state="translated">Функции выравниваются по 32-битным границам,если не оптимизировать размер.</target>
        </trans-unit>
        <trans-unit id="5a29ddf72dc39612a3206ea0dfa0993bffe35aee" translate="yes" xml:space="preserve">
          <source>Functions declared with the &lt;code&gt;naked&lt;/code&gt; attribute also require basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">Функции, объявленные с атрибутом &lt;code&gt;naked&lt;/code&gt; , также требуют базового &lt;code&gt;asm&lt;/code&gt; (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b405d9a1c02455968daea5fb86ad7161a05b238c" translate="yes" xml:space="preserve">
          <source>Functions from different modes can be inlined in the caller&amp;rsquo;s mode.</source>
          <target state="translated">Функции из разных режимов могут быть встроены в режим вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="a51173ce4592b6408dafbf5dcd763cb00409451e" translate="yes" xml:space="preserve">
          <source>Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller.</source>
          <target state="translated">Функции прологов/эпилогов расширяются по мере вызова соответствующих подпрограмм.Размер кода меньше.</target>
        </trans-unit>
        <trans-unit id="958942a81a4fb21510019af4adcbaec4037ab18c" translate="yes" xml:space="preserve">
          <source>Functions that are normally built in but do not have semantics defined by ISO C (such as &lt;code&gt;alloca&lt;/code&gt; and &lt;code&gt;ffs&lt;/code&gt;) are not built-in functions when</source>
          <target state="translated">Функции, которые обычно встроены, но не имеют семантики, определенной ISO C (например, &lt;code&gt;alloca&lt;/code&gt; и &lt;code&gt;ffs&lt;/code&gt; ), не являются встроенными функциями, когда</target>
        </trans-unit>
        <trans-unit id="a77748cc250a919f08dac1cbb97eb54cbd2d36e9" translate="yes" xml:space="preserve">
          <source>Funding Free Software</source>
          <target state="translated">Финансирование свободного программного обеспечения</target>
        </trans-unit>
        <trans-unit id="ad51c11605482040955d96c2db6f7d9f4eca570e" translate="yes" xml:space="preserve">
          <source>Furthermore, if the &lt;em&gt;earlyclobber&lt;/em&gt; operand is also a read/write operand, then that operand is written only after it&amp;rsquo;s used.</source>
          <target state="translated">Более того, если операнд &lt;em&gt;Earlyclobber&lt;/em&gt; также является операндом чтения / записи, то этот операнд записывается только после его использования.</target>
        </trans-unit>
        <trans-unit id="8c1a9865dc580dc97d71f0ac34525d7ff40826cf" translate="yes" xml:space="preserve">
          <source>Future versions of GCC may zero-extend, or use a target-defined &lt;code&gt;ptr_extend&lt;/code&gt; pattern. Do not rely on sign extension.</source>
          <target state="translated">Будущие версии GCC могут расширяться с нуля или использовать определенный &lt;code&gt;ptr_extend&lt;/code&gt; шаблон ptr_extend . Не полагайтесь на расширение знака.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="6ed55690929b9e60aff3a9282723cba6d9ce77ea" translate="yes" xml:space="preserve">
          <source>G++ allows a virtual function returning &amp;lsquo;</source>
          <target state="translated">G ++ позволяет возвращать виртуальную функцию '</target>
        </trans-unit>
        <trans-unit id="5114ba459fc06431a44841ea4654eb2a26a6c91e" translate="yes" xml:space="preserve">
          <source>G++ allows anonymous structs and unions to have members that are not public non-static data members (i.e. fields). These extensions are deprecated.</source>
          <target state="translated">G++позволяет анонимным структурам и объединениям иметь членов,не являющихся публичными нестатистическими членами данных (т.е.полей).Эти расширения являются устаревшими.</target>
        </trans-unit>
        <trans-unit id="de3e575c048ce4bfb45f20c4e2302053983a6e85" translate="yes" xml:space="preserve">
          <source>G++ allows attributes to follow a parenthesized direct initializer, e.g. &amp;lsquo;</source>
          <target state="translated">G ++ позволяет атрибутам следовать за прямым инициализатором в скобках, например '</target>
        </trans-unit>
        <trans-unit id="4279ad338a301cce60cdfae7e5135ebd09b1878c" translate="yes" xml:space="preserve">
          <source>G++ allows floating-point literals to appear in integral constant expressions, e.g. &amp;lsquo;</source>
          <target state="translated">G ++ позволяет использовать литералы с плавающей запятой в целочисленных константных выражениях, например '</target>
        </trans-unit>
        <trans-unit id="c5b988dd39fdeb99ab7e438425f37e6884df0f08" translate="yes" xml:space="preserve">
          <source>G++ allows static data members of const floating-point type to be declared with an initializer in a class definition. The standard only allows initializers for static members of const integral types and const enumeration types so this extension has been deprecated and will be removed from a future version.</source>
          <target state="translated">G++позволяет объявлять статические члены данных типа const с плавающей точкой с инициализатором в определении класса.Стандарт допускает только инициализаторы статических членов const интегральных типов и типов перечисления const,поэтому данное расширение было устарело и будет удалено из будущей версии.</target>
        </trans-unit>
        <trans-unit id="63f7f4841ad757c79aac590be15aedf6621086d6" translate="yes" xml:space="preserve">
          <source>G++ implements the &amp;ldquo;intuitive&amp;rdquo; algorithm for copy-assignment: assign all direct bases, then assign all members. In that algorithm, the virtual base subobject can be encountered more than once. In the example, copying proceeds in the following order: &amp;lsquo;</source>
          <target state="translated">G ++ реализует &amp;laquo;интуитивно понятный&amp;raquo; алгоритм для копирования-присваивания: присваивает все прямые базы, затем присваивает всем членам. В этом алгоритме виртуальный базовый подобъект может встречаться более одного раза. В этом примере копирование происходит в следующем порядке: '</target>
        </trans-unit>
        <trans-unit id="67e3c9106f6559177c33511b2d979e92d246d3b0" translate="yes" xml:space="preserve">
          <source>G++ implements the Borland model on targets where the linker supports it, including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows. Otherwise G++ implements neither automatic model.</source>
          <target state="translated">G++реализует модель Borland на объектах,где компоновщик поддерживает ее,в том числе на объектах ELF (таких как GNU/Linux),Mac OS X и Microsoft Windows.В противном случае G++не реализует автоматическую модель.</target>
        </trans-unit>
        <trans-unit id="31ff568d5d2e9d2f6743afcdc5f3a983bc913e2f" translate="yes" xml:space="preserve">
          <source>G++ implements the same behavior as GCC does when assigning to a volatile object&amp;mdash;there is no reread of the assigned-to object, the assigned rvalue is reused. Note that in C++ assignment expressions are lvalues, and if used as an lvalue, the volatile object is referred to. For instance, &lt;var&gt;vref&lt;/var&gt; refers to &lt;var&gt;vobj&lt;/var&gt;, as expected, in the following example:</source>
          <target state="translated">G ++ реализует то же поведение, что и GCC, при назначении изменчивому объекту - повторное считывание назначенного объекта не выполняется, назначенное rvalue используется повторно. Обратите внимание, что в выражениях присваивания C ++ используются lvalue, и если они используются в качестве lvalue, происходит ссылка на изменчивый объект. Например, &lt;var&gt;vref&lt;/var&gt; ссылается на &lt;var&gt;vobj&lt;/var&gt; , как и ожидалось, в следующем примере:</target>
        </trans-unit>
        <trans-unit id="a1650ba68fd434ff4571a3ae6e0e946daaa36507" translate="yes" xml:space="preserve">
          <source>G3</source>
          <target state="translated">G3</target>
        </trans-unit>
        <trans-unit id="57c24c56c83113e722078337cfe2d513db43c570" translate="yes" xml:space="preserve">
          <source>G4</source>
          <target state="translated">G4</target>
        </trans-unit>
        <trans-unit id="75cc572d557c39d31a9a311423998e30b6913f73" translate="yes" xml:space="preserve">
          <source>G5</source>
          <target state="translated">G5</target>
        </trans-unit>
        <trans-unit id="47bc5f06e2bc84be8cac3eeae94be31fd0bb67f8" translate="yes" xml:space="preserve">
          <source>GBR</source>
          <target state="translated">GBR</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="2128b3c47a543c2fd225378159dcf1cee572dc1a" translate="yes" xml:space="preserve">
          <source>GCC aims towards being usable as a conforming freestanding implementation, or as the compiler for a conforming hosted implementation. By default, it acts as the compiler for a hosted implementation, defining &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard. To make it act as a conforming freestanding implementation for a freestanding environment, use the option</source>
          <target state="translated">GCC стремится к тому, чтобы его можно было использовать как соответствующую автономную реализацию или как компилятор для соответствующей размещенной реализации. По умолчанию он действует как компилятор для размещенной реализации, определяя &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; как &lt;code&gt;1&lt;/code&gt; и предполагая, что, когда используются имена функций ISO C, они имеют семантику, определенную в стандарте. Чтобы заставить его работать как соответствующую автономную реализацию для автономной среды, используйте параметр</target>
        </trans-unit>
        <trans-unit id="a09efcf4281abbe557aa1d8c0037c8b8db485c71" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on C labels. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC позволяет устанавливать атрибуты на метках C. См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; подробную информацию о точном синтаксисе использования атрибутов. Другие атрибуты доступны для функций (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), переменных (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ), счетчиков (см. &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Атрибуты перечислителя&lt;/a&gt; ), операторов (см. &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Атрибуты&lt;/a&gt; операторов ) и для типов (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="188d2c46ce847222650ff9a197ae21b6d36834fd" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on enumerators. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC позволяет устанавливать атрибуты для счетчиков. См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; подробную информацию о точном синтаксисе использования атрибутов. Другие атрибуты доступны для функций (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), переменных (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ), меток (см. &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Атрибуты меток&lt;/a&gt; ), операторов (см. &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Атрибуты&lt;/a&gt; операторов ) и типов (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1318f5f0c876968e4d22801744660b2a68a5dbc1" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on null statements. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC позволяет устанавливать атрибуты для пустых операторов. См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; подробную информацию о точном синтаксисе использования атрибутов. Другие атрибуты доступны для функций (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), переменных (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ), меток (см. &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Атрибуты меток&lt;/a&gt; ), счетчиков (см. &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Атрибуты перечислителя&lt;/a&gt; ) и для типов (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f7518a10a612c3aa4683ccb174e0aca674b8c50" translate="yes" xml:space="preserve">
          <source>GCC allows static initialization of flexible array members. This is equivalent to defining a new structure containing the original structure followed by an array of sufficient size to contain the data. E.g. in the following, &lt;code&gt;f1&lt;/code&gt; is constructed as if it were declared like &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">GCC позволяет статическую инициализацию гибких элементов массива. Это эквивалентно определению новой структуры, содержащей исходную структуру, за которой следует массив достаточного размера для хранения данных. Например, в дальнейшем &lt;code&gt;f1&lt;/code&gt; создается так, как если бы он был объявлен как &lt;code&gt;f2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f25be809d122cad042e0db0bcc9a75b7e95df2b" translate="yes" xml:space="preserve">
          <source>GCC allows the user to selectively enable or disable certain types of diagnostics, and change the kind of the diagnostic. For example, a project&amp;rsquo;s policy might require that all sources compile with</source>
          <target state="translated">GCC позволяет пользователю выборочно включать или отключать определенные типы диагностики и изменять тип диагностики. Например, политика проекта может требовать, чтобы все источники компилировались с</target>
        </trans-unit>
        <trans-unit id="095246dfc125cf940fca19907500328219191dc3" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type, but only under the following circumstances:</source>
          <target state="translated">GCC позволяет использовать имя &lt;code&gt;typedef&lt;/code&gt; в качестве спецификатора типа для векторного типа, но только при следующих обстоятельствах:</target>
        </trans-unit>
        <trans-unit id="118ab2384628648bceb8c24d3c1faa22f9cfc67a" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type.</source>
          <target state="translated">GCC позволяет использовать имя &lt;code&gt;typedef&lt;/code&gt; в качестве спецификатора типа для векторного типа.</target>
        </trans-unit>
        <trans-unit id="4dbc0782ac4d82d0f286d4feca2e87d560c81769" translate="yes" xml:space="preserve">
          <source>GCC allows you to declare &lt;em&gt;local labels&lt;/em&gt; in any nested block scope. A local label is just like an ordinary label, but you can only reference it (with a &lt;code&gt;goto&lt;/code&gt; statement, or by taking its address) within the block in which it is declared.</source>
          <target state="translated">GCC позволяет объявлять &lt;em&gt;локальные метки&lt;/em&gt; в любой вложенной области блока. Локальная метка похожа на обычную метку, но вы можете ссылаться на нее (с помощью &lt;code&gt;goto&lt;/code&gt; или взяв ее адрес) только в блоке, в котором она объявлена.</target>
        </trans-unit>
        <trans-unit id="11edda20db587e9081a40a5791b651f14e5edef4" translate="yes" xml:space="preserve">
          <source>GCC allows you to use</source>
          <target state="translated">GCC позволяет использовать</target>
        </trans-unit>
        <trans-unit id="cb8172c4270b6a56a430a2344a1d357df8a89c7e" translate="yes" xml:space="preserve">
          <source>GCC already has an extensive list of suffixes built into it. This directive adds an entry to the end of the list of suffixes, but since the list is searched from the end backwards, it is effectively possible to override earlier entries using this technique.</source>
          <target state="translated">В GCC уже есть обширный список суффиксов,встроенных в него.Эта директива добавляет запись в конец списка суффиксов,но так как поиск в списке выполняется с конца в обратном направлении,то,по сути,с помощью этой техники можно переопределить более ранние записи.</target>
        </trans-unit>
        <trans-unit id="4946c9e7401c541aac6237c0b11a4f8762636048" translate="yes" xml:space="preserve">
          <source>GCC also defines the macro &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; when tuning for ColdFire microarchitecture &lt;var&gt;uarch&lt;/var&gt;, where &lt;var&gt;uarch&lt;/var&gt; is one of the arguments given above.</source>
          <target state="translated">GCC также определяет макрос &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; при настройке для ColdFire микроархитектуры &lt;var&gt;uarch&lt;/var&gt; , где &lt;var&gt;uarch&lt;/var&gt; является одним из приведенных выше аргументов.</target>
        </trans-unit>
        <trans-unit id="bd57161c41c158f961b92f3f1147120413b6477d" translate="yes" xml:space="preserve">
          <source>GCC also knows implicitly that arguments starting in</source>
          <target state="translated">GCC также неявно знает,что аргументы,начинающиеся с</target>
        </trans-unit>
        <trans-unit id="5590aa7708108855eef5df246b0491a821f68f35" translate="yes" xml:space="preserve">
          <source>GCC also offers a simple mechanism for printing messages during compilation.</source>
          <target state="translated">GCC также предлагает простой механизм печати сообщений во время компиляции.</target>
        </trans-unit>
        <trans-unit id="ff5eb1c7d3d1103b9c01d9df5e0e050903b1adc0" translate="yes" xml:space="preserve">
          <source>GCC also provides a target specific macro &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;, which is the largest alignment ever used for any data type on the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">GCC также предоставляет целевой макрос &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; , который является самым большим выравниванием, когда-либо используемым для любого типа данных на целевой машине, для которой вы компилируете. Например, вы можете написать:</target>
        </trans-unit>
        <trans-unit id="1ce6a581ce58e7b0e52deb0ba48b6684312e9d7c" translate="yes" xml:space="preserve">
          <source>GCC also provides intrinsics to directly access the network registers. The intrinsics are:</source>
          <target state="translated">GCC также предоставляет встроенные средства прямого доступа к сетевым регистрам.Искреннеприсущие:</target>
        </trans-unit>
        <trans-unit id="028d66aa5e30f9984efa701c3d35086edefd3f65" translate="yes" xml:space="preserve">
          <source>GCC also supports attributes on variable declarations (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC также поддерживает атрибуты в объявлениях переменных (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ), метках (см. &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Атрибуты меток&lt;/a&gt; ), счетчиках (см. &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Атрибуты перечислителя&lt;/a&gt; ), операторах (см. &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Атрибуты&lt;/a&gt; операторов ) и типах (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="51353b73f0da65e20b68eea37e8d612e8b885954" translate="yes" xml:space="preserve">
          <source>GCC also warns about function definitions that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Again, these are only possible candidates. GCC guesses that &lt;code&gt;format&lt;/code&gt; attributes might be appropriate for any function that calls a function like &lt;code&gt;vprintf&lt;/code&gt; or &lt;code&gt;vscanf&lt;/code&gt;, but this might not always be the case, and some functions for which &lt;code&gt;format&lt;/code&gt; attributes are appropriate may not be detected.</source>
          <target state="translated">GCC также предупреждает об определениях функций, которые могут быть кандидатами на атрибуты &lt;code&gt;format&lt;/code&gt; . Опять же, это только возможные кандидаты. GCC предполагает, что атрибуты &lt;code&gt;format&lt;/code&gt; могут быть подходящими для любой функции, которая вызывает такую ​​функцию, как &lt;code&gt;vprintf&lt;/code&gt; или &lt;code&gt;vscanf&lt;/code&gt; , но это может быть не всегда так, и некоторые функции, для которых подходят атрибуты &lt;code&gt;format&lt;/code&gt; , могут не обнаруживаться.</target>
        </trans-unit>
        <trans-unit id="e6346f95ac263c787786ddc66b5d9c0bcd8bac71" translate="yes" xml:space="preserve">
          <source>GCC always follows the C99 and C11 requirement that the result of division is truncated towards zero.</source>
          <target state="translated">GCC всегда следует требованиям C99 и C11 о том,чтобы результат деления был усечен до нуля.</target>
        </trans-unit>
        <trans-unit id="71e58c529399ec16a2da4be1a53c86f1d271b88e" translate="yes" xml:space="preserve">
          <source>GCC always tries to compile your program if possible; it never gratuitously rejects a program whose meaning is clear merely because (for instance) it fails to conform to a standard. In some cases, however, the C and C++ standards specify that certain extensions are forbidden, and a diagnostic &lt;em&gt;must&lt;/em&gt; be issued by a conforming compiler. The</source>
          <target state="translated">GCC всегда пытается скомпилировать вашу программу, если это возможно; он никогда не отвергает необоснованно программу, смысл которой ясен, просто потому, что (например) она не соответствует стандарту. Однако в некоторых случаях стандарты C и C ++ указывают, что определенные расширения запрещены, и соответствующий компилятор &lt;em&gt;должен&lt;/em&gt; выдать диагностику .</target>
        </trans-unit>
        <trans-unit id="3d850d85ff9e9c0132b4336d9517c8233fd73c22" translate="yes" xml:space="preserve">
          <source>GCC by default uses the GNU Objective-C runtime library, which is part of GCC and is not the same as the Apple/NeXT Objective-C runtime library used on Apple systems. There are a number of differences documented in this manual. The options</source>
          <target state="translated">GCC по умолчанию пользуется библиотекой времени исполнения GNU Objective-C,которая является частью GCC и не совпадает с библиотекой времени исполнения Apple/NeXT Objective-C,используемой в системах Apple.В этом руководстве документально зафиксирован ряд различий.Варианты</target>
        </trans-unit>
        <trans-unit id="1c0b38c968b6ef5ec06e42505963f829a108bef3" translate="yes" xml:space="preserve">
          <source>GCC by itself attempts to be a conforming freestanding implementation. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of what this means. Beyond the library facilities required of such an implementation, the rest of the C library is supplied by the vendor of the operating system. If that C library doesn&amp;rsquo;t conform to the C standards, then your programs might get warnings (especially when using</source>
          <target state="translated">GCC сам по себе пытается быть соответствующей автономной реализацией. См. &amp;laquo; &lt;a href=&quot;standards#Standards&quot;&gt;Языковые стандарты, поддерживаемые GCC&amp;raquo;&lt;/a&gt; , чтобы узнать, что это означает. Помимо средств библиотеки, требуемых для такой реализации, остальная часть библиотеки C предоставляется поставщиком операционной системы. Если эта библиотека C не соответствует стандартам C, ваши программы могут получать предупреждения (особенно при использовании</target>
        </trans-unit>
        <trans-unit id="a367622db7093a4cc9943cb9b928ad16a228659d" translate="yes" xml:space="preserve">
          <source>GCC can allocate complex automatic variables in a noncontiguous fashion; it&amp;rsquo;s even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF debug info format can represent this, so use of DWARF is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable&amp;rsquo;s actual name is &lt;code&gt;foo&lt;/code&gt;, the two fictitious variables are named &lt;code&gt;foo$real&lt;/code&gt; and &lt;code&gt;foo$imag&lt;/code&gt;. You can examine and set these two fictitious variables with your debugger.</source>
          <target state="translated">GCC может распределять сложные автоматические переменные несмежным образом; возможно даже, что реальная часть находится в регистре, а мнимая часть находится в стеке (или наоборот). Это может представлять только формат отладочной информации DWARF, поэтому рекомендуется использовать DWARF. Если вы используете формат отладочной информации stabs, GCC описывает несмежную сложную переменную, как если бы это были две отдельные переменные несложного типа. Если фактическое имя переменной - &lt;code&gt;foo&lt;/code&gt; , две фиктивные переменные называются &lt;code&gt;foo$real&lt;/code&gt; и &lt;code&gt;foo$imag&lt;/code&gt; . Вы можете проверить и установить эти две фиктивные переменные с помощью отладчика.</target>
        </trans-unit>
        <trans-unit id="f1f3d3d856350fe50d86862ccf0921b96281e6bd" translate="yes" xml:space="preserve">
          <source>GCC can compile the binary representation (BRIG) of the HSAIL text format as described in HSA Programmer&amp;rsquo;s Reference Manual version 1.0.1. This capability is typically utilized to implement the HSA runtime API&amp;rsquo;s HSAIL finalization extension for a gcc supported processor. HSA standards are freely available at &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;.</source>
          <target state="translated">GCC может компилировать двоичное представление (BRIG) текстового формата HSAIL, как описано в Справочном руководстве программиста HSA версии 1.0.1. Эта возможность обычно используется для реализации расширения финализации HSAIL API среды выполнения HSA для процессора, поддерживаемого gcc. Стандарты HSA находятся в свободном доступе по адресу &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87356dae6f4ed6235c36eedc0fe148afee6229d9" translate="yes" xml:space="preserve">
          <source>GCC can generate code for both VxWorks kernels and real time processes (RTPs). This option switches from the former to the latter. It also defines the preprocessor macro &lt;code&gt;__RTP__&lt;/code&gt;.</source>
          <target state="translated">GCC может генерировать код как для ядер VxWorks, так и для процессов реального времени (RTP). Эта опция переключается с первого на второй. Он также определяет макрос препроцессора &lt;code&gt;__RTP__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb9f5282eec43cb95e4c422b1995ae6896ab686c" translate="yes" xml:space="preserve">
          <source>GCC can only handle one commutative pair in an asm; if you use more, the compiler may fail. Note that you need not use the modifier if the two alternatives are strictly identical; this would only waste time in the reload pass.</source>
          <target state="translated">GCC может обрабатывать только одну коммутативную пару в asm;если вы используете больше,компилятор может выйти из строя.Обратите внимание,что вам не нужно использовать модификатор,если две альтернативы строго идентичны;это только потратит время на перезагрузку.</target>
        </trans-unit>
        <trans-unit id="78d74922e82c5075040c6a08c44444ac34a5ad2a" translate="yes" xml:space="preserve">
          <source>GCC comes with shell scripts to fix certain known problems in system header files. They install corrected copies of various header files in a special directory where only GCC will normally look for them. The scripts adapt to various systems by searching all the system header files for the problem cases that we know about.</source>
          <target state="translated">GCC поставляется со скриптами оболочки для исправления некоторых известных проблем в системных заголовочных файлах.Они устанавливают исправленные копии различных заголовочных файлов в специальный каталог,где их обычно ищет только GCC.Скрипты приспосабливаются к различным системам путем поиска во всех системных заголовочных файлах известных нам проблемных случаев.</target>
        </trans-unit>
        <trans-unit id="cd976cd951c888839dc15c99651c6a379e4c0cac" translate="yes" xml:space="preserve">
          <source>GCC compiled code sometimes emits warnings from the HP-UX assembler of the form:</source>
          <target state="translated">Иногда скомпилированный GCC код выдает предупреждения от ассемблера формы HP-UX:</target>
        </trans-unit>
        <trans-unit id="81e4ed9eaf205df3f6c599be30d212f56ac91924" translate="yes" xml:space="preserve">
          <source>GCC complains about program fragments such as &amp;lsquo;</source>
          <target state="translated">GCC жалуется на такие фрагменты программы, как '</target>
        </trans-unit>
        <trans-unit id="67982454dd3e3b7d64f34362d5f739d9716bb143" translate="yes" xml:space="preserve">
          <source>GCC complains about unterminated character constants inside of preprocessing conditionals that fail. Some programs have English comments enclosed in conditionals that are guaranteed to fail; if these comments contain apostrophes, GCC will probably report an error. For example, this code would produce an error:</source>
          <target state="translated">GCC жалуется на непрекращающиеся константы характера внутри условий препроцессирования,которые выходят из строя.Некоторые программы имеют английские комментарии,заключенные в условия,которые гарантированно терпят неудачу;если эти комментарии содержат апострофы,GCC,вероятно,сообщит об ошибке.Например,этот код выдаст ошибку:</target>
        </trans-unit>
        <trans-unit id="e4bb7adbf45dc4a3fb687d7313280a86480960d6" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCC соответствует спецификации OpenPOWER 64-Bit ELF V2 ABI, которую можно найти по адресу &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt; . В Приложении A к этому документу перечислены векторные интерфейсы API, которые должны предоставляться совместимыми компиляторами. Программисты должны предпочтительно использовать описанные в нем интерфейсы. Однако исторически GCC предоставлял дополнительные интерфейсы для доступа к векторным инструкциям. Они кратко описаны ниже.</target>
        </trans-unit>
        <trans-unit id="65f9b929facca207bcc2021009f1c0587b957cbf" translate="yes" xml:space="preserve">
          <source>GCC currently emits calls to &lt;code&gt;vmldExp2&lt;/code&gt;, &lt;code&gt;vmldLn2&lt;/code&gt;, &lt;code&gt;vmldLog102&lt;/code&gt;, &lt;code&gt;vmldPow2&lt;/code&gt;, &lt;code&gt;vmldTanh2&lt;/code&gt;, &lt;code&gt;vmldTan2&lt;/code&gt;, &lt;code&gt;vmldAtan2&lt;/code&gt;, &lt;code&gt;vmldAtanh2&lt;/code&gt;, &lt;code&gt;vmldCbrt2&lt;/code&gt;, &lt;code&gt;vmldSinh2&lt;/code&gt;, &lt;code&gt;vmldSin2&lt;/code&gt;, &lt;code&gt;vmldAsinh2&lt;/code&gt;, &lt;code&gt;vmldAsin2&lt;/code&gt;, &lt;code&gt;vmldCosh2&lt;/code&gt;, &lt;code&gt;vmldCos2&lt;/code&gt;, &lt;code&gt;vmldAcosh2&lt;/code&gt;, &lt;code&gt;vmldAcos2&lt;/code&gt;, &lt;code&gt;vmlsExp4&lt;/code&gt;, &lt;code&gt;vmlsLn4&lt;/code&gt;, &lt;code&gt;vmlsLog104&lt;/code&gt;, &lt;code&gt;vmlsPow4&lt;/code&gt;, &lt;code&gt;vmlsTanh4&lt;/code&gt;, &lt;code&gt;vmlsTan4&lt;/code&gt;, &lt;code&gt;vmlsAtan4&lt;/code&gt;, &lt;code&gt;vmlsAtanh4&lt;/code&gt;, &lt;code&gt;vmlsCbrt4&lt;/code&gt;, &lt;code&gt;vmlsSinh4&lt;/code&gt;, &lt;code&gt;vmlsSin4&lt;/code&gt;, &lt;code&gt;vmlsAsinh4&lt;/code&gt;, &lt;code&gt;vmlsAsin4&lt;/code&gt;, &lt;code&gt;vmlsCosh4&lt;/code&gt;, &lt;code&gt;vmlsCos4&lt;/code&gt;, &lt;code&gt;vmlsAcosh4&lt;/code&gt; and &lt;code&gt;vmlsAcos4&lt;/code&gt; for corresponding function type when</source>
          <target state="translated">GCC в настоящее время излучает звонки на &lt;code&gt;vmldExp2&lt;/code&gt; , &lt;code&gt;vmldLn2&lt;/code&gt; , &lt;code&gt;vmldLog102&lt;/code&gt; , &lt;code&gt;vmldPow2&lt;/code&gt; , &lt;code&gt;vmldTanh2&lt;/code&gt; , &lt;code&gt;vmldTan2&lt;/code&gt; , &lt;code&gt;vmldAtan2&lt;/code&gt; , &lt;code&gt;vmldAtanh2&lt;/code&gt; , &lt;code&gt;vmldCbrt2&lt;/code&gt; , &lt;code&gt;vmldSinh2&lt;/code&gt; , &lt;code&gt;vmldSin2&lt;/code&gt; , &lt;code&gt;vmldAsinh2&lt;/code&gt; , &lt;code&gt;vmldAsin2&lt;/code&gt; , &lt;code&gt;vmldCosh2&lt;/code&gt; , &lt;code&gt;vmldCos2&lt;/code&gt; , &lt;code&gt;vmldAcosh2&lt;/code&gt; , &lt;code&gt;vmldAcos2&lt;/code&gt; , &lt;code&gt;vmlsExp4&lt;/code&gt; , &lt;code&gt;vmlsLn4&lt;/code&gt; , &lt;code&gt;vmlsLog104&lt;/code&gt; , &lt;code&gt;vmlsPow4&lt;/code&gt; , &lt;code&gt;vmlsTanh4&lt;/code&gt; , &lt;code&gt;vmlsTan4&lt;/code&gt; , &lt;code&gt;vmlsAtan4&lt;/code&gt; , &lt;code&gt;vmlsAtanh4&lt;/code&gt; , &lt;code&gt;vmlsCbrt4&lt;/code&gt; , &lt;code&gt;vmlsSinh4&lt;/code&gt; , &lt;code&gt;vmlsSin4&lt;/code&gt; , &lt;code&gt;vmlsAsinh4&lt;/code&gt; , &lt;code&gt;vmlsAsin4&lt;/code&gt; , &lt;code&gt;vmlsCosh4&lt;/code&gt; , &lt;code&gt;vmlsCos4&lt;/code&gt; , &lt;code&gt;vmlsAcosh4&lt;/code&gt; и &lt;code&gt;vmlsAcos4&lt;/code&gt; для соответствующего типа функции, когда</target>
        </trans-unit>
        <trans-unit id="16f9d8d14967dad5157f0d4d4177e77917294c63" translate="yes" xml:space="preserve">
          <source>GCC defines a macro &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; whenever it is generating code for a ColdFire target. The &lt;var&gt;arch&lt;/var&gt; in this macro is one of the</source>
          <target state="translated">GCC определяет макрос &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; всякий раз, когда он генерирует код для цели ColdFire. &lt;var&gt;arch&lt;/var&gt; в этих макрокомандах является одним из</target>
        </trans-unit>
        <trans-unit id="9690667ebb3c4d196426b91a67e183bca646b7c4" translate="yes" xml:space="preserve">
          <source>GCC defines a preprocessor macro for the specified &lt;var&gt;cpu&lt;/var&gt;. For the &amp;lsquo;</source>
          <target state="translated">GCC определяет макрос препроцессора для указанного &lt;var&gt;cpu&lt;/var&gt; . Для '</target>
        </trans-unit>
        <trans-unit id="1ee4979d83e119fc65d0b3ce42180431e0b52daf" translate="yes" xml:space="preserve">
          <source>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the</source>
          <target state="translated">GCC определяет несколько встроенных макросов,чтобы пользовательский код мог проверить наличие или отсутствие возможностей.Практически любой из следующих встроенных макросов выводится из возможностей устройства и,таким образом,запускается по команде</target>
        </trans-unit>
        <trans-unit id="07c2bb68cb370eca1e6a61c97987834533dcec03" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; when ColdFire target &lt;var&gt;cpu&lt;/var&gt; is selected. It also defines &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt;, where the value of &lt;var&gt;family&lt;/var&gt; is given by the table above.</source>
          <target state="translated">GCC определяет макрос &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; , когда выбран целевой &lt;var&gt;cpu&lt;/var&gt; ColdFire . Он также определяет &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt; __mcf_family_ , где значение &lt;var&gt;family&lt;/var&gt; указано в таблице выше.</target>
        </trans-unit>
        <trans-unit id="57340a71d3d941522f73fea99d6d51e3e8ce6ff1" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcfhwdiv__&lt;/code&gt; when this option is enabled.</source>
          <target state="translated">GCC определяет макрос &lt;code&gt;__mcfhwdiv__&lt;/code&gt; , когда эта опция включена.</target>
        </trans-unit>
        <trans-unit id="6a9b1f894460a8c96f48083896afccfe85c9be79" translate="yes" xml:space="preserve">
          <source>GCC defines the macros &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; when tuning for 680x0 architecture &lt;var&gt;arch&lt;/var&gt;. It also defines &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; unless either</source>
          <target state="translated">GCC определяет макросы &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; и &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; при настройке для 680x0 архитектуры &lt;var&gt;arch&lt;/var&gt; . Он также определяет &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; если только</target>
        </trans-unit>
        <trans-unit id="2885698109b0288d9891eaf5f6f566e33bc93a28" translate="yes" xml:space="preserve">
          <source>GCC defines the preprocessor macro &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; for targets that have been updated to support this builtin.</source>
          <target state="translated">GCC определяет макрос препроцессора &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; для целей, которые были обновлены для поддержки этой встроенной функции.</target>
        </trans-unit>
        <trans-unit id="9502202879d2e8497b3ab7402351c2cfb4aba65d" translate="yes" xml:space="preserve">
          <source>GCC defines two macros based on the value of this option. The first is &lt;code&gt;_MIPS_ARCH&lt;/code&gt;, which gives the name of target architecture, as a string. The second has the form &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;foo&lt;/var&gt; is the capitalized value of &lt;code&gt;_MIPS_ARCH&lt;/code&gt;. For example,</source>
          <target state="translated">GCC определяет два макроса на основе значения этой опции. Первый - это &lt;code&gt;_MIPS_ARCH&lt;/code&gt; , который дает имя целевой архитектуры в виде строки. Второй имеет форму &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt; , где &lt;var&gt;foo&lt;/var&gt; - это значение &lt;code&gt;_MIPS_ARCH&lt;/code&gt; с заглавной буквы . Например,</target>
        </trans-unit>
        <trans-unit id="a26b5e085873721291414d2146a69ef3ff2df942" translate="yes" xml:space="preserve">
          <source>GCC depresses SSEx instructions when</source>
          <target state="translated">GCC нажимает на инструкции SSEx,когда</target>
        </trans-unit>
        <trans-unit id="f00d9db0f7babc17a8b2e93a16eaa154dca9484f" translate="yes" xml:space="preserve">
          <source>GCC does not inline any functions when not optimizing unless you specify the &amp;lsquo;</source>
          <target state="translated">GCC не встраивает какие-либо функции, если не оптимизируется, если вы не укажете '</target>
        </trans-unit>
        <trans-unit id="d979e47341cf32b9e9788a98df7db938c53659aa" translate="yes" xml:space="preserve">
          <source>GCC does not parse basic &lt;code&gt;asm&lt;/code&gt;&amp;rsquo;s &lt;var&gt;AssemblerInstructions&lt;/var&gt;, which means there is no way to communicate to the compiler what is happening inside them. GCC has no visibility of symbols in the &lt;code&gt;asm&lt;/code&gt; and may discard them as unreferenced. It also does not know about side effects of the assembler code, such as modifications to memory or registers. Unlike some compilers, GCC assumes that no changes to general purpose registers occur. This assumption may change in a future release.</source>
          <target state="translated">GCC не анализирует &lt;var&gt;AssemblerInstructions&lt;/var&gt; &lt;code&gt;asm&lt;/code&gt; базового asm , а это значит, что нет способа сообщить компилятору, что происходит внутри них. GCC не имеет видимости символов в &lt;code&gt;asm&lt;/code&gt; и может отбрасывать их как неиспользуемые. Он также не знает о побочных эффектах кода ассемблера, таких как модификации памяти или регистров. В отличие от некоторых компиляторов, GCC предполагает, что никаких изменений регистров общего назначения не происходит. Это предположение может измениться в будущем выпуске.</target>
        </trans-unit>
        <trans-unit id="cd46297b79a48028b406a3a22f8df3c38f23ed53" translate="yes" xml:space="preserve">
          <source>GCC does not provide the C library functionality associated with</source>
          <target state="translated">GCC не предоставляет функциональность библиотеки C,связанную с</target>
        </trans-unit>
        <trans-unit id="96d71d57d6177ab6f3fc682f6b185f4541d680d8" translate="yes" xml:space="preserve">
          <source>GCC does not provide the library facilities required only of hosted implementations, nor yet all the facilities required by C99 of freestanding implementations on all platforms. To use the facilities of a hosted environment, you need to find them elsewhere (for example, in the GNU C library). See &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Standard Libraries&lt;/a&gt;.</source>
          <target state="translated">GCC не предоставляет ни библиотечных средств, необходимых только для размещенных реализаций, ни всех средств, требуемых C99 для автономных реализаций на всех платформах. Чтобы использовать возможности размещенной среды, вам нужно найти их в другом месте (например, в библиотеке GNU C). См. &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Стандартные библиотеки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86c923d0a51125464840f7ea1874cf6ab2974fb7" translate="yes" xml:space="preserve">
          <source>GCC does not substitute macro arguments when they appear inside of string constants. For example, the following macro in GCC</source>
          <target state="translated">GCC не подставляет аргументы макросов,когда они появляются внутри строковых констант.Например,следующий макрос в GCC</target>
        </trans-unit>
        <trans-unit id="42a91da8639ee03ec161a4bd756ad60809129b66" translate="yes" xml:space="preserve">
          <source>GCC does not support any extended integer types.</source>
          <target state="translated">GCC не поддерживает расширенные целочисленные типы.</target>
        </trans-unit>
        <trans-unit id="3ce5b628a549292da4090df5538cf2cd3541c673" translate="yes" xml:space="preserve">
          <source>GCC does not support using this feature with a non-static local variable since such variables do not have assembler names. If you are trying to put the variable in a particular register, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">GCC не поддерживает использование этой функции с нестатической локальной переменной, поскольку такие переменные не имеют имен ассемблера. Если вы пытаетесь поместить переменную в конкретный регистр, см. &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Явные переменные регистра&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="057dd4b479d4087929d93c02eca9edfef895599b" translate="yes" xml:space="preserve">
          <source>GCC does not use such values.</source>
          <target state="translated">GCC не использует такие значения.</target>
        </trans-unit>
        <trans-unit id="6b22e4a77b39e5fcd62364faba592ec172555481" translate="yes" xml:space="preserve">
          <source>GCC emits warnings based on this attribute by default; use</source>
          <target state="translated">GCC по умолчанию выдает предупреждения,основанные на этом атрибуте;используйте</target>
        </trans-unit>
        <trans-unit id="6213b35197bfb3bb104e08212f01a4cf35332f2f" translate="yes" xml:space="preserve">
          <source>GCC enables this option by default. If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the</source>
          <target state="translated">GCC включает эту опцию по умолчанию.Если вы хотите заставить компилятор проверить,есть ли ссылка на переменную,независимо от того,включена оптимизация или нет,используйте параметр</target>
        </trans-unit>
        <trans-unit id="d7b2a859b296fb3f8914b78d7834ccf3e648a510" translate="yes" xml:space="preserve">
          <source>GCC has currently no support for non-fragile instance variables.</source>
          <target state="translated">В настоящее время GCC не имеет поддержки для нестойких переменных экземпляров.</target>
        </trans-unit>
        <trans-unit id="9b64961814c7627599dfb66d9541dfbc1c55e8a3" translate="yes" xml:space="preserve">
          <source>GCC has long supported variadic macros, and used a different syntax that allowed you to give a name to the variable arguments just like any other argument. Here is an example:</source>
          <target state="translated">GCC долгое время поддерживал вариадические макросы,и использовал другой синтаксис,который позволял давать имя переменным аргументам,как и любому другому аргументу.Вот пример:</target>
        </trans-unit>
        <trans-unit id="e677a4ecf07d49ec983c792d6fd35d17489c7528" translate="yes" xml:space="preserve">
          <source>GCC has the following spec strings built into it. Spec files can override these strings or create their own. Note that individual targets can also add their own spec strings to this list.</source>
          <target state="translated">В GCC встроены следующие спецификации.Спецификационные файлы могут переопределять эти строки или создавать свои собственные.Обратите внимание,что отдельные цели также могут добавлять свои собственные спецификационные строки в этот список.</target>
        </trans-unit>
        <trans-unit id="ed8411601030aef9d10cc9d6209db6260f4d910d" translate="yes" xml:space="preserve">
          <source>GCC implements a limited buffer overflow protection mechanism that can prevent some buffer overflow attacks by determining the sizes of objects into which data is about to be written and preventing the writes when the size isn&amp;rsquo;t sufficient. The built-in functions described below yield the best results when used together and when optimization is enabled. For example, to detect object sizes across function boundaries or to follow pointer assignments through non-trivial control flow they rely on various optimization passes enabled with</source>
          <target state="translated">GCC реализует ограниченный механизм защиты от переполнения буфера, который может предотвратить некоторые атаки переполнения буфера, определяя размеры объектов, в которые будут записаны данные, и предотвращая запись, когда размер недостаточен. Встроенные функции, описанные ниже, дают наилучшие результаты при совместном использовании и при включенной оптимизации. Например, для определения размеров объектов через границы функций или отслеживания назначений указателей через нетривиальный поток управления они полагаются на различные проходы оптимизации, включенные с помощью</target>
        </trans-unit>
        <trans-unit id="c63f8d617f5fcd74378c430997fb1de4655a5a57" translate="yes" xml:space="preserve">
          <source>GCC implements extensions for C as described in the ARM C Language Extensions (ACLE) specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC реализует расширения для C, как описано в спецификации ARM C Language Extensions (ACLE), которую можно найти по &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;адресу http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="293bbd3b2e69a9d930833e11f1b427e7997876a6" translate="yes" xml:space="preserve">
          <source>GCC implements for both C and C++ a syntactic extension to implement the &lt;code&gt;offsetof&lt;/code&gt; macro.</source>
          <target state="translated">GCC реализует как для C, так и для C ++ синтаксическое расширение для реализации макроса &lt;code&gt;offsetof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322077390825044afaea930b7263992ddcea81e8" translate="yes" xml:space="preserve">
          <source>GCC implements taking the address of a nested function using a technique called &lt;em&gt;trampolines&lt;/em&gt;. This technique was described in Lexical Closures for C++ (Thomas M. Breuel, USENIX C++ Conference Proceedings, October 17-21, 1988).</source>
          <target state="translated">GCC реализует получение адреса вложенной функции с помощью техники, называемой &lt;em&gt;трамплинами&lt;/em&gt; . Этот метод был описан в Lexical Closures for C ++ (Thomas M. Breuel, USENIX C ++ Conference Proceedings, 17-21 октября 1988 г.).</target>
        </trans-unit>
        <trans-unit id="239348ac99d6992297a72fcc17bd9b383a471db0" translate="yes" xml:space="preserve">
          <source>GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC реализует расширения безопасности ARMv8-M, как описано в разделе &amp;laquo;Расширения безопасности ARMv8-M: требования к технической спецификации средств разработки&amp;raquo;, который можно найти по &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;адресу http://infocenter.arm.com/help/topic/com.arm.doc. ecm0359818 / ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c1d6efdb055c03457ac985aa41eeb676f9d1c1c" translate="yes" xml:space="preserve">
          <source>GCC implements three different semantics of declaring a function inline. One is available with</source>
          <target state="translated">GCC реализует три различные семантики объявления функции в строке.Одна из них доступна с</target>
        </trans-unit>
        <trans-unit id="16fab68e571685f848321494bfa65aa76fa12ecf" translate="yes" xml:space="preserve">
          <source>GCC includes built-in versions of many of the functions in the standard C library. These functions come in two forms: one whose names start with the &lt;code&gt;__builtin_&lt;/code&gt; prefix, and the other without. Both forms have the same type (including prototype), the same address (when their address is taken), and the same meaning as the C library functions even if you specify the</source>
          <target state="translated">GCC включает встроенные версии многих функций стандартной библиотеки C. Эти функции бывают двух форм: одна, имена которой начинаются с префикса &lt;code&gt;__builtin_&lt;/code&gt; , а другая - без префикса. Обе формы имеют один и тот же тип (включая прототип), один и тот же адрес (если используется их адрес) и то же значение, что и функции библиотеки C, даже если вы укажете</target>
        </trans-unit>
        <trans-unit id="6ddb06bf023a460b3469518f6828ceb9799c46e8" translate="yes" xml:space="preserve">
          <source>GCC is incompatible with traditional C.</source>
          <target state="translated">GCC несовместим с традиционной C.</target>
        </trans-unit>
        <trans-unit id="d28b24326033740593178727cd1510ca18099b74" translate="yes" xml:space="preserve">
          <source>GCC is only limited by available memory.</source>
          <target state="translated">GCC ограничен только доступной памятью.</target>
        </trans-unit>
        <trans-unit id="e1b7ed70d92a385236df81656270c5df961819cc" translate="yes" xml:space="preserve">
          <source>GCC needs to install corrected versions of some system header files. This is because most target systems have some header files that won&amp;rsquo;t work with GCC unless they are changed. Some have bugs, some are incompatible with ISO C, and some depend on special features of other compilers.</source>
          <target state="translated">GCC необходимо установить исправленные версии некоторых файлов системных заголовков. Это связано с тем, что в большинстве целевых систем есть файлы заголовков, которые не будут работать с GCC, если их не изменить. Некоторые из них содержат ошибки, некоторые несовместимы с ISO C, а некоторые зависят от специальных возможностей других компиляторов.</target>
        </trans-unit>
        <trans-unit id="6fec00d5e695a6ba7008f039024af2f2354b9175" translate="yes" xml:space="preserve">
          <source>GCC no longer supports DWARF Version 1, which is substantially different than Version 2 and later. For historical reasons, some other DWARF-related options such as</source>
          <target state="translated">GCC больше не поддерживает DWARF версии 1,которая существенно отличается от версии 2 и более поздних.По историческим причинам,некоторые другие связанные с DWARF опции,такие как</target>
        </trans-unit>
        <trans-unit id="9571fcf4d32ba7634429d5420351196a13337bf1" translate="yes" xml:space="preserve">
          <source>GCC normally defines &lt;code&gt;__STDC__&lt;/code&gt; to be 1, and in addition defines &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; if you specify the</source>
          <target state="translated">GCC обычно определяет &lt;code&gt;__STDC__&lt;/code&gt; равным 1 и, кроме того, определяет &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; , если вы указываете</target>
        </trans-unit>
        <trans-unit id="d2a04d28db5bb4fd272285d6f2261f1af937b1aa" translate="yes" xml:space="preserve">
          <source>GCC normally generates special code to handle certain built-in functions more efficiently; for instance, calls to &lt;code&gt;alloca&lt;/code&gt; may become single instructions which adjust the stack directly, and calls to &lt;code&gt;memcpy&lt;/code&gt; may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a built-in function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with</source>
          <target state="translated">GCC обычно генерирует специальный код для более эффективной обработки определенных встроенных функций; например, вызовы &lt;code&gt;alloca&lt;/code&gt; могут стать отдельными инструкциями, которые напрямую регулируют стек, а вызовы &lt;code&gt;memcpy&lt;/code&gt; могут стать встроенными циклами копирования. Результирующий код часто меньше и быстрее, но поскольку вызовы функций больше не отображаются как таковые, вы не можете установить точку останова для этих вызовов, а также вы не можете изменить поведение функций, связавшись с другой библиотекой. Кроме того, когда функция распознается как встроенная, GCC может использовать информацию об этой функции, чтобы предупреждать о проблемах с вызовами этой функции или для генерации более эффективного кода, даже если полученный код все еще содержит вызовы этой функции. , Например, предупреждения даются с</target>
        </trans-unit>
        <trans-unit id="7e6e1ac548faaad8ae2131d82037c03b74f72b7e" translate="yes" xml:space="preserve">
          <source>GCC normally makes string constants read-only. If several identical-looking string constants are used, GCC stores only one copy of the string.</source>
          <target state="translated">Обычно GCC делает строковые константы доступными только для чтения.Если используется несколько одинаковых строковых констант,то GCC хранит только одну копию строки.</target>
        </trans-unit>
        <trans-unit id="11a713f18e4fa0802eb282a6537925d48c0259a3" translate="yes" xml:space="preserve">
          <source>GCC normally uses a single instruction to load values from the GOT. While this is relatively efficient, it only works if the GOT is smaller than about 64k. Anything larger causes the linker to report an error such as:</source>
          <target state="translated">Обычно GCC использует одну единственную инструкцию для загрузки значений из GOT.Хотя это относительно эффективно,это работает только в том случае,если GOT меньше 64k.Любое увеличение приводит к тому,что компоновщик сообщает об ошибке,например:</target>
        </trans-unit>
        <trans-unit id="be424d75f5ffc48b72e433597659af0ae3069a92" translate="yes" xml:space="preserve">
          <source>GCC option.</source>
          <target state="translated">Опция GCC.</target>
        </trans-unit>
        <trans-unit id="0cb280cc3350dd85b51b4e6912bba246b1815ba4" translate="yes" xml:space="preserve">
          <source>GCC permits a C structure to have no members:</source>
          <target state="translated">GCC разрешает структуре С не иметь членов:</target>
        </trans-unit>
        <trans-unit id="410ccd5268fc842081ec500688897d4eab9d507c" translate="yes" xml:space="preserve">
          <source>GCC provides a couple of special builtin functions to aid in the writing of interrupt handlers in C.</source>
          <target state="translated">GCC предоставляет пару специальных встроенных функций для помощи в написании обработчиков прерываний в C.</target>
        </trans-unit>
        <trans-unit id="9a84666be4b2834544f27c65de6a453c576dd60a" translate="yes" xml:space="preserve">
          <source>GCC provides a large number of built-in functions other than the ones mentioned above. Some of these are for internal use in the processing of exceptions or variable-length argument lists and are not documented here because they may change from time to time; we do not recommend general use of these functions.</source>
          <target state="translated">GCC предоставляет большое количество встроенных функций,отличных от упомянутых выше.Некоторые из них предназначены для внутреннего использования при обработке исключений или списков аргументов переменной длины и не документируются здесь,так как они могут время от времени изменяться;мы не рекомендуем общее использование этих функций.</target>
        </trans-unit>
        <trans-unit id="dd6c408349b302ebed79b324cb6148ad8750cb77" translate="yes" xml:space="preserve">
          <source>GCC provides an interface for the PowerPC family of processors to access the AltiVec operations described in Motorola&amp;rsquo;s AltiVec Programming Interface Manual. The interface is made available by including &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC предоставляет интерфейс для процессоров семейства PowerPC для доступа к операциям AltiVec, описанным в Руководстве по интерфейсу программирования AltiVec компании Motorola. Интерфейс становится доступным путем включения &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; и использования</target>
        </trans-unit>
        <trans-unit id="f17fd1e9e7781f60f577293ffbb0fbe50f2aa38c" translate="yes" xml:space="preserve">
          <source>GCC provides an interface to selected machine instructions from the picoChip instruction set.</source>
          <target state="translated">GCC предоставляет интерфейс к выбранным машинным инструкциям из набора инструкций picoChip.</target>
        </trans-unit>
        <trans-unit id="5ddbeccb51a8011bd71cee78329676c8768e012d" translate="yes" xml:space="preserve">
          <source>GCC provides built-in versions of the ISO C99 floating-point comparison macros that avoid raising exceptions for unordered operands. They have the same names as the standard macros ( &lt;code&gt;isgreater&lt;/code&gt;, &lt;code&gt;isgreaterequal&lt;/code&gt;, &lt;code&gt;isless&lt;/code&gt;, &lt;code&gt;islessequal&lt;/code&gt;, &lt;code&gt;islessgreater&lt;/code&gt;, and &lt;code&gt;isunordered&lt;/code&gt;) , with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. We intend for a library implementor to be able to simply &lt;code&gt;#define&lt;/code&gt; each standard macro to its built-in equivalent. In the same fashion, GCC provides &lt;code&gt;fpclassify&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;, &lt;code&gt;isinf_sign&lt;/code&gt;, &lt;code&gt;isnormal&lt;/code&gt; and &lt;code&gt;signbit&lt;/code&gt; built-ins used with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. The &lt;code&gt;isinf&lt;/code&gt; and &lt;code&gt;isnan&lt;/code&gt; built-in functions appear both with and without the &lt;code&gt;__builtin_&lt;/code&gt; prefix.</source>
          <target state="translated">GCC предоставляет встроенные версии макросов сравнения с плавающей запятой ISO C99, которые позволяют избежать возникновения исключений для неупорядоченных операндов. Они имеют те же имена, что и стандартные макросы ( &lt;code&gt;isgreater&lt;/code&gt; , &lt;code&gt;isgreaterequal&lt;/code&gt; , &lt;code&gt;isless&lt;/code&gt; , &lt;code&gt;islessequal&lt;/code&gt; , &lt;code&gt;islessgreater&lt;/code&gt; и &lt;code&gt;isunordered&lt;/code&gt; ), с префиксом &lt;code&gt;__builtin_&lt;/code&gt; . Мы хотим, чтобы разработчик библиотеки мог просто &lt;code&gt;#define&lt;/code&gt; определять каждый стандартный макрос до его встроенного эквивалента. Таким же образом GCC предоставляет &lt;code&gt;fpclassify&lt;/code&gt; , &lt;code&gt;isfinite&lt;/code&gt; , &lt;code&gt;isinf_sign&lt;/code&gt; , &lt;code&gt;isnormal&lt;/code&gt; и &lt;code&gt;signbit&lt;/code&gt; .встроенные модули, используемые с префиксом &lt;code&gt;__builtin_&lt;/code&gt; . &lt;code&gt;isinf&lt;/code&gt; и &lt;code&gt;isnan&lt;/code&gt; встроенных функций появляются как с и без &lt;code&gt;__builtin_&lt;/code&gt; префикса.</target>
        </trans-unit>
        <trans-unit id="2050dfe83adc5c7628805205b83a18bf6445e1ea" translate="yes" xml:space="preserve">
          <source>GCC provides extensions for the SPU processor as described in the Sony/Toshiba/IBM SPU Language Extensions Specification. GCC&amp;rsquo;s implementation differs in several ways.</source>
          <target state="translated">GCC предоставляет расширения для процессора SPU, как описано в спецификации Sony / Toshiba / IBM SPU Language Extensions Specification. Реализация GCC отличается по нескольким причинам.</target>
        </trans-unit>
        <trans-unit id="e32059373d4f323b9500c52b6c9f30c837d92c67" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access certain instructions of the TI C6X processors. These intrinsics, listed below, are available after inclusion of the &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; header file. They map directly to C6X instructions.</source>
          <target state="translated">GCC предоставляет встроенные функции для доступа к определенным инструкциям процессоров TI C6X. Эти встроенные функции, перечисленные ниже, доступны после включения &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; заголовка c6x_intrinsics.h . Они отображаются непосредственно на инструкции C6X.</target>
        </trans-unit>
        <trans-unit id="4b78e24ee2fcd774983a8458d70a096c1f01f9ae" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILE-Gx processor. The intrinsics are of the form:</source>
          <target state="translated">GCC предоставляет intrinsics для доступа к каждой инструкции процессора TILE-Gx.Исключительные характеристики имеют форму:</target>
        </trans-unit>
        <trans-unit id="9929eef1ea9191b05967ff4d40ec8ba33acf1914" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILEPro processor. The intrinsics are of the form:</source>
          <target state="translated">GCC предоставляет встроенные средства доступа к каждой инструкции процессора TILEPro.Свойства имеют свою форму:</target>
        </trans-unit>
        <trans-unit id="ce1f47a40b55c4bca6e7d75e5dd0559de5a981c1" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the MSA MIPS SIMD Architecture. The interface is made available by including &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC предоставляет встроенные средства для доступа к инструкциям SIMD, предоставляемым архитектурой MSA MIPS SIMD. Интерфейс доступен путем включения &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; и использования</target>
        </trans-unit>
        <trans-unit id="40749dfbc24dc6f5a0b131fccc39dc31c09ec61c" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the ST Microelectronics Loongson-2E and -2F processors. These intrinsics, available after inclusion of the &lt;code&gt;loongson.h&lt;/code&gt; header file, operate on the following 64-bit vector types:</source>
          <target state="translated">GCC предоставляет встроенные функции для доступа к инструкциям SIMD, предоставляемым процессорами ST Microelectronics Loongson-2E и -2F. Эти встроенные функции, доступные после включения &lt;code&gt;loongson.h&lt;/code&gt; заголовка loongson.h , работают со следующими 64-битными векторными типами:</target>
        </trans-unit>
        <trans-unit id="924dd6007d38ce7b6e1d6cc29626f87cdabebfe1" translate="yes" xml:space="preserve">
          <source>GCC provides many FR-V-specific built-in functions. In general, these functions are intended to be compatible with those described by FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor. The two exceptions are &lt;code&gt;__MDUNPACKH&lt;/code&gt; and &lt;code&gt;__MBTOHE&lt;/code&gt;, the GCC forms of which pass 128-bit values by pointer rather than by value.</source>
          <target state="translated">GCC предоставляет множество встроенных функций, специфичных для FR-V. В общем, эти функции предназначены для совместимости с функциями, описанными в FR-V Family, Softune C / C ++ Compiler Manual (V6), Fujitsu Semiconductor. Двумя исключениями являются &lt;code&gt;__MDUNPACKH&lt;/code&gt; и &lt;code&gt;__MBTOHE&lt;/code&gt; , формы GCC которых передают 128-битные значения по указателю, а не по значению.</target>
        </trans-unit>
        <trans-unit id="9e2fa02f56a7975c68bfa6e70c41727409fe7b0c" translate="yes" xml:space="preserve">
          <source>GCC provides other MIPS-specific built-in functions:</source>
          <target state="translated">GCC предоставляет другие встроенные функции,специфичные для MIPS:</target>
        </trans-unit>
        <trans-unit id="c10a95a94bae56390209bcb97b207903625a1bc4" translate="yes" xml:space="preserve">
          <source>GCC provides the built-in functions &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; which are similar to, but not interchangeable with, the C library functions &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;. The built-in versions are used internally by GCC&amp;rsquo;s libraries to implement exception handling on some targets. You should use the standard C library functions declared in &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; in user code instead of the builtins.</source>
          <target state="translated">GCC предоставляет встроенные функции &lt;code&gt;__builtin_setjmp&lt;/code&gt; и &lt;code&gt;__builtin_longjmp&lt;/code&gt; , которые похожи на функции библиотеки C &lt;code&gt;setjmp&lt;/code&gt; и &lt;code&gt;longjmp&lt;/code&gt; , но не взаимозаменяемы . Встроенные версии используются внутри библиотек GCC для реализации обработки исключений для некоторых целей. Вы должны использовать стандартные функции библиотеки C, объявленные в &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; , в пользовательском коде вместо встроенных функций.</target>
        </trans-unit>
        <trans-unit id="9735e9559d39719652bb957e983b7d2a3d2f7126" translate="yes" xml:space="preserve">
          <source>GCC provides three magic constants that hold the name of the current function as a string. In C++11 and later modes, all three are treated as constant expressions and can be used in &lt;code&gt;constexpr&lt;/code&gt; constexts. The first of these constants is &lt;code&gt;__func__&lt;/code&gt;, which is part of the C99 standard:</source>
          <target state="translated">GCC предоставляет три магические константы, которые содержат имя текущей функции в виде строки. В режимах C ++ 11 и более поздних все три обрабатываются как константные выражения и могут использоваться в &lt;code&gt;constexpr&lt;/code&gt; constexts. Первая из этих констант - &lt;code&gt;__func__&lt;/code&gt; , которая является частью стандарта C99:</target>
        </trans-unit>
        <trans-unit id="2948277f494886df96fe31449754e2666c1dabe5" translate="yes" xml:space="preserve">
          <source>GCC provides two interfaces for accessing the Hardware Transactional Memory (HTM) instructions available on some of the PowerPC family of processors (eg, POWER8). The two interfaces come in a low level interface, consisting of built-in functions specific to PowerPC and a higher level interface consisting of inline functions that are common between PowerPC and S/390.</source>
          <target state="translated">GCC предоставляет два интерфейса для доступа к инструкциям аппаратной транзакционной памяти (HTM),доступным на некоторых процессорах семейства PowerPC (например,POWER8).Эти два интерфейса имеют низкоуровневый интерфейс,состоящий из встроенных функций,специфичных для PowerPC,и высокоуровневый интерфейс,состоящий из встроенных функций,общих для PowerPC и S/390.</target>
        </trans-unit>
        <trans-unit id="f29e392d59a7180cc6e4238e88b7157ffcf6417f" translate="yes" xml:space="preserve">
          <source>GCC stands for &amp;ldquo;GNU Compiler Collection&amp;rdquo;. GCC is an integrated distribution of compilers for several major programming languages. These languages currently include C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL).</source>
          <target state="translated">GCC означает &amp;laquo;Коллекция компиляторов GNU&amp;raquo;. GCC - это интегрированный дистрибутив компиляторов для нескольких основных языков программирования. Эти языки в настоящее время включают C, C ++, Objective-C, Objective-C ++, Fortran, Ada, D, Go и BRIG (HSAIL).</target>
        </trans-unit>
        <trans-unit id="1d5a85fa7b27fa126424357ffe5ddd8aadcd2aa6" translate="yes" xml:space="preserve">
          <source>GCC support of decimal float as specified by the draft technical report is incomplete:</source>
          <target state="translated">Поддержка десятичного поплавка ССАГПЗ,как указано в проекте технического отчета,является неполной:</target>
        </trans-unit>
        <trans-unit id="28561e4b3e7debdbfb6dbdfe238413f5b85b54ce" translate="yes" xml:space="preserve">
          <source>GCC support of fixed-point types as specified by the draft technical report is incomplete:</source>
          <target state="translated">Поддержка типов ССАГПЗ с фиксированной точкой,указанных в проекте технического отчета,является неполной:</target>
        </trans-unit>
        <trans-unit id="1fa5de60932a0f2deade437763dee9d9034d0c2f" translate="yes" xml:space="preserve">
          <source>GCC supports &amp;ldquo;traditional&amp;rdquo; Objective-C (also known as &amp;ldquo;Objective-C 1.0&amp;rdquo;) and contains support for the Objective-C exception and synchronization syntax. It has also support for a number of &amp;ldquo;Objective-C 2.0&amp;rdquo; language extensions, including properties, fast enumeration (only for Objective-C), method attributes and the @optional and @required keywords in protocols. GCC supports Objective-C++ and features available in Objective-C are also available in Objective-C++.</source>
          <target state="translated">GCC поддерживает &amp;laquo;традиционный&amp;raquo; Objective-C (также известный как &amp;laquo;Objective-C 1.0&amp;raquo;) и содержит поддержку исключений Objective-C и синтаксиса синхронизации. Он также поддерживает ряд языковых расширений &amp;laquo;Objective-C 2.0&amp;raquo;, включая свойства, быстрое перечисление (только для Objective-C), атрибуты методов и ключевые слова @optional и @required в протоколах. GCC поддерживает Objective-C ++, а функции, доступные в Objective-C, также доступны в Objective-C ++.</target>
        </trans-unit>
        <trans-unit id="830690076ebfb70e332b381ddb9fe46655004637" translate="yes" xml:space="preserve">
          <source>GCC supports MIPS DSP operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC поддерживает операции MIPS DSP, используя как общие векторные расширения (см. &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Векторные расширения&lt;/a&gt; ), так и набор встроенных функций, специфичных для MIPS. Оба вида поддержки включены в</target>
        </trans-unit>
        <trans-unit id="8d83e55eff0bd290fe83057edfb4aff0d4da11fc" translate="yes" xml:space="preserve">
          <source>GCC supports SIMD operations on the SPARC using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) as well as built-in functions for the SPARC Visual Instruction Set (VIS). When you use the</source>
          <target state="translated">GCC поддерживает операции SIMD на SPARC, используя как общие векторные расширения (см. &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Векторные расширения&lt;/a&gt; ), так и встроенные функции для набора визуальных инструкций SPARC (VIS). Когда вы используете</target>
        </trans-unit>
        <trans-unit id="76e5e7f27add586f752fd2c88bf216b480271ed7" translate="yes" xml:space="preserve">
          <source>GCC supports a &lt;code&gt;#pragma&lt;/code&gt; directive that changes the name used in assembly for a given declaration. While this pragma is supported on all platforms, it is intended primarily to provide compatibility with the Solaris system headers. This effect can also be achieved using the asm labels extension (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;).</source>
          <target state="translated">GCC поддерживает директиву &lt;code&gt;#pragma&lt;/code&gt; , которая изменяет имя, используемое в сборке для данного объявления. Хотя эта прагма поддерживается на всех платформах, она предназначена в первую очередь для обеспечения совместимости с заголовками системы Solaris. Этого эффекта также можно добиться с помощью расширения asm-меток (см. &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm-метки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="498314540c8d67676764e9f766eda8fd96a7daed" translate="yes" xml:space="preserve">
          <source>GCC supports a number of command-line options that control adding run-time instrumentation to the code it normally generates. For example, one purpose of instrumentation is collect profiling statistics for use in finding program hot spots, code coverage analysis, or profile-guided optimizations. Another class of program instrumentation is adding run-time checking to detect programming errors like invalid pointer dereferences or out-of-bounds array accesses, as well as deliberately hostile attacks such as stack smashing or C++ vtable hijacking. There is also a general hook which can be used to implement other forms of tracing or function-level instrumentation for debug or program analysis purposes.</source>
          <target state="translated">GCC поддерживает ряд опций командной строки,которые управляют добавлением приборов выполнения в код,который он обычно генерирует.Например,одной из целей приборостроения является сбор профилирующей статистики для использования в поиске &quot;горячих точек&quot; программ,анализе покрытия кода или оптимизациях под профиль.Другой класс программных инструментов-это добавление проверки времени исполнения для обнаружения ошибок программирования,таких как некорректные разыменования указателей или несанкционированный доступ к массивам,а также умышленно враждебные атаки,такие как разбиение стека или перехват таблиц C++.Существует также общий крюк,который может быть использован для реализации других форм трассировки или инструментов на уровне функций для отладки или анализа программы.</target>
        </trans-unit>
        <trans-unit id="1030e6dea2c81b69bdc7270b03b39b5f569ad6fa" translate="yes" xml:space="preserve">
          <source>GCC supports a variant of the o32 ABI in which floating-point registers are 64 rather than 32 bits wide. You can select this combination with</source>
          <target state="translated">GCC поддерживает вариант o32 ABI,в котором регистры с плавающей точкой имеют ширину 64,а не 32 бита.Вы можете выбрать эту комбинацию с помощью</target>
        </trans-unit>
        <trans-unit id="c3965449e7a5dc4d5ed8a9dc3199dec909c35dc5" translate="yes" xml:space="preserve">
          <source>GCC supports only two&amp;rsquo;s complement integer types, and all bit patterns are ordinary values.</source>
          <target state="translated">GCC поддерживает только два дополнительных целых типа, и все битовые шаблоны являются обычными значениями.</target>
        </trans-unit>
        <trans-unit id="83dd0c21621e0a6e0dd523c863cbfaef04449bd4" translate="yes" xml:space="preserve">
          <source>GCC supports paired-single operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC поддерживает парно-одиночные операции, используя как общие векторные расширения (см. &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Векторные расширения&lt;/a&gt; ), так и набор встроенных функций, специфичных для MIPS. Оба вида поддержки включены в</target>
        </trans-unit>
        <trans-unit id="b55fc398fe2655fec7265522ba909be632a50b88" translate="yes" xml:space="preserve">
          <source>GCC supports several types of pragmas, primarily in order to compile code originally written for other compilers. Note that in general we do not recommend the use of pragmas; See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for further explanation.</source>
          <target state="translated">GCC поддерживает несколько типов прагм, в первую очередь для компиляции кода, изначально написанного для других компиляторов. Обратите внимание, что в целом мы не рекомендуем использовать прагмы; См. &amp;laquo; &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&amp;raquo;&lt;/a&gt; для дальнейшего объяснения.</target>
        </trans-unit>
        <trans-unit id="653525fcb8a016916ca28e1dd65b18ab8839e4b5" translate="yes" xml:space="preserve">
          <source>GCC supports some of the RX instructions which cannot be expressed in the C programming language via the use of built-in functions. The following functions are supported:</source>
          <target state="translated">GCC поддерживает некоторые инструкции RX,которые не могут быть выражены на языке программирования C с помощью встроенных функций.Поддерживаются следующие функции:</target>
        </trans-unit>
        <trans-unit id="4b0cba78b946248aec959caf8a965144462518ce" translate="yes" xml:space="preserve">
          <source>GCC supports the D 2.0 programming language. The D language itself is currently defined by its reference implementation and supporting language specification, described at &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;.</source>
          <target state="translated">GCC поддерживает язык программирования D 2.0. Сам язык D в настоящее время определяется его эталонной реализацией и спецификацией поддерживающего языка, описанной на &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="359d53772696a2b7864fe27fe3565593d8a4b28c" translate="yes" xml:space="preserve">
          <source>GCC supports the following AVR devices and ISAs:</source>
          <target state="translated">GCC поддерживает следующие устройства AVR и ISA:</target>
        </trans-unit>
        <trans-unit id="2ea7c76cda0c4fbb899bd829aa15b4c8a69297f6" translate="yes" xml:space="preserve">
          <source>GCC supports the original ISO C++ standard published in 1998, and the 2011 and 2014 revisions.</source>
          <target state="translated">GCC поддерживает оригинальный стандарт ISO C++,опубликованный в 1998 году,а также редакции 2011 и 2014 годов.</target>
        </trans-unit>
        <trans-unit id="858a69c7492112ce45741ecc79e61821fd61a803" translate="yes" xml:space="preserve">
          <source>GCC supports these options when compiling for C-SKY V2 processors.</source>
          <target state="translated">GCC поддерживает эти опции при компиляции для процессоров C-SKY V2.</target>
        </trans-unit>
        <trans-unit id="0dc67ad6d4b46256a65720385ae1177b91b75554" translate="yes" xml:space="preserve">
          <source>GCC supports two forms of SVE code generation: &amp;ldquo;vector-length agnostic&amp;rdquo; output that works with any size of vector register and &amp;ldquo;vector-length specific&amp;rdquo; output that allows GCC to make assumptions about the vector length when it is useful for optimization reasons. The possible values of &amp;lsquo;</source>
          <target state="translated">GCC поддерживает две формы генерации кода SVE: вывод &amp;laquo;независимо от длины вектора&amp;raquo;, который работает с любым размером векторного регистра, и вывод &amp;laquo;зависящий от длины вектора&amp;raquo;, который позволяет GCC делать предположения о длине вектора, когда это полезно по причинам оптимизации. Возможные значения '</target>
        </trans-unit>
        <trans-unit id="5b3ded850043ac176423c8bd10dd3fbbab6dc5cd" translate="yes" xml:space="preserve">
          <source>GCC treats all characters of identifiers as significant. According to K&amp;amp;R-1 (2.2), &amp;ldquo;No more than the first eight characters are significant, although more may be used.&amp;rdquo;. Also according to K&amp;amp;R-1 (2.2), &amp;ldquo;An identifier is a sequence of letters and digits; the first character must be a letter. The underscore _ counts as a letter.&amp;rdquo;, but GCC also allows dollar signs in identifiers.</source>
          <target state="translated">GCC рассматривает все символы идентификаторов как значимые. Согласно K&amp;amp;R-1 (2.2), &amp;laquo;не более первых восьми символов имеют значение, хотя могут использоваться и другие&amp;raquo;. Также согласно K&amp;amp;R-1 (2.2), &amp;laquo;идентификатор - это последовательность букв и цифр; первый символ должен быть буквой. Знак подчеркивания _ считается буквой. &amp;raquo;, Но GCC также допускает использование знаков доллара в идентификаторах.</target>
        </trans-unit>
        <trans-unit id="feaee8cb866302ba1b5ec59a1ce37d673602a1f3" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code (as if by</source>
          <target state="translated">GCC использует &lt;var&gt;name&lt;/var&gt; чтобы определить, какие инструкции он может выдавать при генерации кода сборки (как если бы</target>
        </trans-unit>
        <trans-unit id="66e1ddf3758925ad2362fd6f220c229932999055" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code. If</source>
          <target state="translated">GCC использует &lt;var&gt;name&lt;/var&gt; чтобы определить, какие инструкции он может выдавать при генерации кода сборки. Если</target>
        </trans-unit>
        <trans-unit id="813ae2789d4b6769128e82ee496ab87522d87f2b" translate="yes" xml:space="preserve">
          <source>GCC uses a garbage collector to manage its own memory allocation. This parameter specifies the minimum percentage by which the garbage collector&amp;rsquo;s heap should be allowed to expand between collections. Tuning this may improve compilation speed; it has no effect on code generation.</source>
          <target state="translated">GCC использует сборщик мусора для управления выделением собственной памяти. Этот параметр указывает минимальный процент, на который куче сборщика мусора должно быть разрешено расширяться между сборками. Настройка этого может улучшить скорость компиляции; это не влияет на генерацию кода.</target>
        </trans-unit>
        <trans-unit id="ae9ac11b129e57b155bc25157be869b1b76e80ad" translate="yes" xml:space="preserve">
          <source>GCC uses corrected versions of system header files. This is necessary, but doesn&amp;rsquo;t always work smoothly.</source>
          <target state="translated">GCC использует исправленные версии файлов системных заголовков. Это необходимо, но не всегда гладко.</target>
        </trans-unit>
        <trans-unit id="819a72ed7eaf70f991d756c9fa760994a62ab526" translate="yes" xml:space="preserve">
          <source>GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (</source>
          <target state="translated">GCC использует эвристику для угадывания вероятностей ветвей,если они не обеспечиваются обратной связью по профилированию (</target>
        </trans-unit>
        <trans-unit id="1a8376e3c4e7645e0b124141064b06d15d9df6a1" translate="yes" xml:space="preserve">
          <source>GCC uses the system C library, which might not be compliant with the ISO C standard.</source>
          <target state="translated">GCC использует библиотеку систем С,которая может не соответствовать стандарту ISO C.</target>
        </trans-unit>
        <trans-unit id="ca6cd448f1a33799ac2da1a0d9dfa000cd6841ec" translate="yes" xml:space="preserve">
          <source>GCC will not inline any functions if the</source>
          <target state="translated">GCC не будет встраивать никакие функции,если</target>
        </trans-unit>
        <trans-unit id="8a47996357771546a1d05e5991be4fe03520b6e5" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s default behavior is to emit all inline functions with the &lt;code&gt;dllexport&lt;/code&gt; attribute. Since this can cause object file-size bloat, you can use</source>
          <target state="translated">По умолчанию GCC создает все встроенные функции с атрибутом &lt;code&gt;dllexport&lt;/code&gt; . Поскольку это может вызвать раздувание размера файла объекта, вы можете использовать</target>
        </trans-unit>
        <trans-unit id="af8e45be98e36024842dc1bd8893718108d0574b" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s implementation of the high-level language interface available from C and C++ code differs from Motorola&amp;rsquo;s documentation in several ways.</source>
          <target state="translated">Реализация GCC интерфейса высокого уровня, доступного из кода C и C ++, отличается от документации Motorola по нескольким причинам.</target>
        </trans-unit>
        <trans-unit id="e78ca1e1182b55c5bde4b195b5d85015058a98d0" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers do not treat this code like the non-volatile code in the earlier examples. They do not move it out of loops or omit it on the assumption that the result from a previous call is still valid.</source>
          <target state="translated">Оптимизаторы GCC не обрабатывают этот код как энергонезависимый код в предыдущих примерах. Они не выводят его из циклов и не пропускают, полагая, что результат предыдущего вызова все еще действителен.</target>
        </trans-unit>
        <trans-unit id="dbc61f28ee0b681eff97897cb82a2c8d282dc076" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers sometimes discard &lt;code&gt;asm&lt;/code&gt; statements if they determine there is no need for the output variables. Also, the optimizers may move code out of loops if they believe that the code will always return the same result (i.e. none of its input values change between calls). Using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables these optimizations. &lt;code&gt;asm&lt;/code&gt; statements that have no output operands, including &lt;code&gt;asm goto&lt;/code&gt; statements, are implicitly volatile.</source>
          <target state="translated">Оптимизаторы GCC иногда отбрасывают операторы &lt;code&gt;asm&lt;/code&gt; , если они определяют, что выходные переменные не нужны. Кроме того, оптимизаторы могут вывести код из циклов, если они считают, что код всегда будет возвращать один и тот же результат (т.е. ни одно из его входных значений не меняется между вызовами). Использование квалификатора &lt;code&gt;volatile&lt;/code&gt; отключает эти оптимизации. Операторы &lt;code&gt;asm&lt;/code&gt; , у которых нет выходных операндов, включая &lt;code&gt;asm goto&lt;/code&gt; , неявно изменчивы.</target>
        </trans-unit>
        <trans-unit id="1e750d3c829a6b818589899b42ede982312a7f98" translate="yes" xml:space="preserve">
          <source>GCOV_ERROR_FILE</source>
          <target state="translated">GCOV_ERROR_FILE</target>
        </trans-unit>
        <trans-unit id="e485aa772b73ea7b58dcf4966c0a2d3b9c745805" translate="yes" xml:space="preserve">
          <source>GCOV_EXIT_AT_ERROR</source>
          <target state="translated">GCOV_EXIT_AT_ERROR</target>
        </trans-unit>
        <trans-unit id="80aecc9b56754f32438dd132183cddc7e4df32f1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX contains the prefix to add to the absolute paths in the object file. Prefix can be absolute, or relative. The default is no prefix.</source>
          <target state="translated">GCOV_PREFIX содержит префикс для добавления в объектный файл абсолютных путей.Префикс может быть абсолютным или относительным.По умолчанию префикс отсутствует.</target>
        </trans-unit>
        <trans-unit id="891aee4538b1a332bb00b85c9e7c43d1cf40d1d1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX=/target/run</source>
          <target state="translated">GCOV_PREFIX=/target/run</target>
        </trans-unit>
        <trans-unit id="f0bcf8de4466a3194e31ce81577ad85f4f449ccb" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP indicates the how many initial directory names to strip off the hardwired absolute paths. Default value is 0.</source>
          <target state="translated">GCOV_PREFIX_STRIP показывает,сколько исходных имён каталогов нужно снять с жёстко закреплённых абсолютных путей.Значение по умолчанию равно 0.</target>
        </trans-unit>
        <trans-unit id="7069713a73584b12e5e1b6c6673abb78172fe103" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP=1</source>
          <target state="translated">GCOV_PREFIX_STRIP=1</target>
        </trans-unit>
        <trans-unit id="a007084938316d2847460b0f869fd2dab151324f" translate="yes" xml:space="preserve">
          <source>GFNI instructions.</source>
          <target state="translated">Инструкции ГФНИ.</target>
        </trans-unit>
        <trans-unit id="768001d59e5da45e8ce2de4652950a5db0123cf5" translate="yes" xml:space="preserve">
          <source>GNU C allows you to associate specific hardware registers with C variables. In almost all cases, allowing the compiler to assign registers produces the best code. However under certain unusual circumstances, more precise control over the variable storage is required.</source>
          <target state="translated">GNU C позволяет связывать определенные аппаратные регистры с переменными Си.Почти во всех случаях,позволяя компилятору присваивать регистры,получается лучший код.Однако при определённых необычных обстоятельствах требуется более точный контроль над хранением переменных.</target>
        </trans-unit>
        <trans-unit id="1282a7948680a82fce143391cee57deb8d315356" translate="yes" xml:space="preserve">
          <source>GNU C extends ISO C to allow a function prototype to override a later old-style non-prototype definition. Consider the following example:</source>
          <target state="translated">GNU C расширяет ISO C,чтобы позволить прототипу функции переопределить более позднее определение непрототипа в старом стиле.Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="e77e07d95404402b67fc9bef0aec0c9a34ecc38f" translate="yes" xml:space="preserve">
          <source>GNU C provides several language features not found in ISO standard C. (The</source>
          <target state="translated">GNU C предоставляет несколько языковых возможностей,не встречающихся в стандарте ISO C.(The</target>
        </trans-unit>
        <trans-unit id="d45fbb49066a76f230e9020bfe458e74293358d2" translate="yes" xml:space="preserve">
          <source>GNU C++ does not support old-style function definitions, so this extension is irrelevant.</source>
          <target state="translated">GNU C++не поддерживает определения функций в старом стиле,так что это расширение не имеет значения.</target>
        </trans-unit>
        <trans-unit id="2ba257a10dfda1a80f343df43a5f9faccbca64b3" translate="yes" xml:space="preserve">
          <source>GNU CPP has two further variadic macro extensions, and permits them to be used with either of the above forms of macro definition.</source>
          <target state="translated">GNU CPP имеет два дополнительных вариадических макрорасширения и позволяет использовать их с любой из вышеперечисленных форм макроопределения.</target>
        </trans-unit>
        <trans-unit id="9dbaa828d6809d3452cb2a6728f3023aae5a8b22" translate="yes" xml:space="preserve">
          <source>GNU CPP permits you to completely omit the variable arguments in this way. In the above examples, the compiler would complain, though since the expansion of the macro still has the extra comma after the format string.</source>
          <target state="translated">GNU CPP позволяет вам полностью опускать аргументы переменных таким образом.В приведенных выше примерах компилятор будет жаловаться,хотя поскольку в расширении макроса все равно есть лишняя запятая после строки форматирования.</target>
        </trans-unit>
        <trans-unit id="0e4ec8a54cfff9c2845fa38842cb6cd1bdea197d" translate="yes" xml:space="preserve">
          <source>GNU Free Documentation License</source>
          <target state="translated">Лицензия свободной документации GNU</target>
        </trans-unit>
        <trans-unit id="d9cbf0740e34d88c506fb7df6e17deeabd18660c" translate="yes" xml:space="preserve">
          <source>GNU General Public License</source>
          <target state="translated">Стандартная общественная лицензия GNU</target>
        </trans-unit>
        <trans-unit id="ea5447d52819458fc788d8fe66484dcf6f8b58c5" translate="yes" xml:space="preserve">
          <source>GNU General Public License says how you can copy and share GCC.</source>
          <target state="translated">В Стандартной общественной лицензии GNU сказано,как вы можете копировать GCC и обмениваться им.</target>
        </trans-unit>
        <trans-unit id="a21d2651a31b14abba6b9f4cc89e6d16156a2f47" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides constant string objects that are generated directly by the compiler. You declare a constant string object by prefixing a C constant string with the character &amp;lsquo;</source>
          <target state="translated">GNU Objective-C предоставляет постоянные строковые объекты, которые генерируются непосредственно компилятором. Вы объявляете объект константной строки, добавляя к константной строке C символ '</target>
        </trans-unit>
        <trans-unit id="d4b0f24c5578d309a3a80bcf9db1efef7dc80491" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides exception support built into the language, as in the following example:</source>
          <target state="translated">GNU Objective-C предоставляет поддержку исключений,встроенных в язык,как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="183b8b6fa7f0ebe7cc24b6e6b64ea37e46538bc2" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for synchronized blocks:</source>
          <target state="translated">GNU Objective-C обеспечивает поддержку синхронизированных блоков:</target>
        </trans-unit>
        <trans-unit id="5a76f04c435b8a53e2673208f47df13d27337155" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for the fast enumeration syntax:</source>
          <target state="translated">GNU Objective-C обеспечивает поддержку синтаксиса быстрого перечисления:</target>
        </trans-unit>
        <trans-unit id="bd8453bc7fd0b5c5a5eb0b2fb1cc7653d6106ce4" translate="yes" xml:space="preserve">
          <source>GNU Objective-C runtime features.</source>
          <target state="translated">Возможности GNU Objective-C во время выполнения.</target>
        </trans-unit>
        <trans-unit id="dc4139cbd1ca2e4ec1fdbaf154a309856bbea2a6" translate="yes" xml:space="preserve">
          <source>GNU Objective-C supports the &lt;code&gt;@encode&lt;/code&gt; syntax that allows you to create a type encoding from a C/Objective-C type. For example, &lt;code&gt;@encode(int)&lt;/code&gt; is compiled by the compiler into &lt;code&gt;&quot;i&quot;&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-C поддерживает синтаксис &lt;code&gt;@encode&lt;/code&gt; , который позволяет вам создавать кодировку типа из типа C / Objective-C. Например, &lt;code&gt;@encode(int)&lt;/code&gt; компилируется компилятором в &lt;code&gt;&quot;i&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72bdab580bf81d58abe49ef7feb3d22b198aca72" translate="yes" xml:space="preserve">
          <source>GNU dialect of</source>
          <target state="translated">диалект GNU</target>
        </trans-unit>
        <trans-unit id="0cce44d2e046653755b9171f853b5aa7f7510c0f" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C11. The name &amp;lsquo;</source>
          <target state="translated">GNU-диалект ISO C11. Имя '</target>
        </trans-unit>
        <trans-unit id="17c597be9d56a306b84e8b735a051e0b49bf682b" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C17. This is the default for C code.</source>
          <target state="translated">GNU диалект ISO C17.Это код C по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cd7ba84a6cf37a43cdd1bd215e060138c20d80ef" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C90 (including some C99 features).</source>
          <target state="translated">GNU диалект ISO C90 (включая некоторые функции C99).</target>
        </trans-unit>
        <trans-unit id="5a96bf0e0eb1648d92a5415bbf82f314f50fc95d" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C99. The name &amp;lsquo;</source>
          <target state="translated">GNU-диалект ISO C99. Имя '</target>
        </trans-unit>
        <trans-unit id="c7513a88e6766734c8fff0b65e9260cb06e07819" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C language family.</source>
          <target state="translated">Расширения GNU к семейству языков Си.</target>
        </trans-unit>
        <trans-unit id="90b8cbfe3e7aa922a28ad77fd2468b165d25db6d" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C++ language.</source>
          <target state="translated">Расширения GNU к языку Си++.</target>
        </trans-unit>
        <trans-unit id="73a49c549f68005dbe48c29ca2788c5808080012" translate="yes" xml:space="preserve">
          <source>General purpose register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">Регистр общего назначения,если включены 64-битные инструкции или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="005c5bd36bc2dae00112330a475935d63f7703b1" translate="yes" xml:space="preserve">
          <source>General register 1</source>
          <target state="translated">Главный регистр 1</target>
        </trans-unit>
        <trans-unit id="b09ef9c6988403ff1cf426fea1c658c5b1f6be6e" translate="yes" xml:space="preserve">
          <source>General register &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r3&lt;/code&gt; for &lt;code&gt;addl&lt;/code&gt; instruction</source>
          <target state="translated">Общий регистр от &lt;code&gt;r0&lt;/code&gt; до &lt;code&gt;r3&lt;/code&gt; для инструкции &lt;code&gt;addl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e89cc1c76441abdf1cb24c29330f5f35d304a8e7" translate="yes" xml:space="preserve">
          <source>General register, but not &lt;code&gt;r29&lt;/code&gt;, &lt;code&gt;r30&lt;/code&gt; and &lt;code&gt;r31&lt;/code&gt;</source>
          <target state="translated">Общий регистр, но не &lt;code&gt;r29&lt;/code&gt; , &lt;code&gt;r30&lt;/code&gt; и &lt;code&gt;r31&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10bd548f00f5df8e11316ab27529f8ec0d489ead" translate="yes" xml:space="preserve">
          <source>General-purpose 32-bit register</source>
          <target state="translated">32-битный регистр общего назначения</target>
        </trans-unit>
        <trans-unit id="d86490a439329533a7fda073910d458d177b7499" translate="yes" xml:space="preserve">
          <source>Generally there is no guarantee that a memory transaction ever succeeds and suitable fallback code always needs to be supplied.</source>
          <target state="translated">Как правило,нет гарантии,что операция с памятью когда-нибудь будет успешной,и всегда должен быть предоставлен подходящий запасной код.</target>
        </trans-unit>
        <trans-unit id="c220eb05478a76fade659e7f472b8e896908bfb7" translate="yes" xml:space="preserve">
          <source>Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function independent of any restrictions that otherwise apply to inlining. Failure to inline such a function is diagnosed as an error. Note that if such a function is called indirectly the compiler may or may not inline it depending on optimization level and a failure to inline an indirect call may or may not be diagnosed.</source>
          <target state="translated">Как правило,функции не подставляются,если не указана оптимизация.Для функций,объявленных inline,данный атрибут встраивает функцию независимо от каких-либо ограничений,которые в противном случае применяются к встраиванию.Отказ от встраивания такой функции диагностируется как ошибка.Обратите внимание,что при косвенном вызове такой функции компилятор может встраивать или не встраивать ее в зависимости от уровня оптимизации,а при непрямом вызове может диагностироваться или не диагностироваться отказ от встраивания.</target>
        </trans-unit>
        <trans-unit id="84a7c319c3d7d28e18ecbf416836eecf761297c6" translate="yes" xml:space="preserve">
          <source>Generally, inlining into a function is limited. For a function marked with this attribute, every call inside this function is inlined, if possible. Functions declared with attribute &lt;code&gt;noinline&lt;/code&gt; and similar are not inlined. Whether the function itself is considered for inlining depends on its size and the current inlining parameters.</source>
          <target state="translated">Как правило, встраивание в функцию ограничено. Для функции, отмеченной этим атрибутом, каждый вызов внутри этой функции, если это возможно, является встроенным. Функции, объявленные с атрибутом &lt;code&gt;noinline&lt;/code&gt; и т.п., не встроены. Будет ли сама функция рассматриваться для встраивания, зависит от ее размера и текущих параметров встраивания.</target>
        </trans-unit>
        <trans-unit id="da79890df831b8b599903d6736d5d918432eda2d" translate="yes" xml:space="preserve">
          <source>Generally, options specified at link time override those specified at compile time, although in some cases GCC attempts to infer link-time options from the settings used to compile the input files.</source>
          <target state="translated">Обычно опции,заданные во время компиляции,перекрывают опции,заданные во время компиляции,хотя в некоторых случаях GCC пытается вывести опции времени компиляции из настроек,используемых для компиляции входных файлов.</target>
        </trans-unit>
        <trans-unit id="ba4adeb327e032d99cfca5b51d0fd4daaa9b56fc" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) ColdFire hardware divide and remainder instructions. If</source>
          <target state="translated">Сгенерируйте (не генерируйте)инструкции по разделению аппаратного обеспечения ColdFire и остаток.Если</target>
        </trans-unit>
        <trans-unit id="0fe80a59bc1a906ccb8af3fc3416cadc3264624c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) GP-relative accesses. The following &lt;var&gt;option&lt;/var&gt; names are recognized:</source>
          <target state="translated">Генерировать (не генерировать) доступы, относящиеся к GP. Распознаются следующие названия &lt;var&gt;option&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="09abd950717c564f7150fc3aedac403b36224304" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) MIPS16 code. If GCC is targeting a MIPS32 or MIPS64 architecture, it makes use of the MIPS16e ASE.</source>
          <target state="translated">Сгенерировать (не генерировать)MIPS16 код.Если GCC нацелен на архитектуру MIPS32 или MIPS64,он использует MIPS16e ASE.</target>
        </trans-unit>
        <trans-unit id="188ec1e266203e4853a13748340fc36d3e35234e" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is fully position-independent, and that can therefore be linked into shared libraries. This option only affects</source>
          <target state="translated">Генерируйте (не генерируйте)код,который полностью не зависит от позиции и поэтому может быть скомпонован в общие библиотеки.Этот вариант влияет только на</target>
        </trans-unit>
        <trans-unit id="0a056a294949b854726ab099acb14488ae9baeac" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is suitable for SVR4-style dynamic objects.</source>
          <target state="translated">Сгенерировать (не генерировать)код,подходящий для динамических объектов в стиле SVR4.</target>
        </trans-unit>
        <trans-unit id="200f92cbd3d74fb5f3e648ecaaea7b69d566f040" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that uses &lt;em&gt;base addresses&lt;/em&gt;. Using a base address automatically generates a request (handled by the assembler and the linker) for a constant to be set up in a global register. The register is used for one or more base address requests within the range 0 to 255 from the value held in the register. The generally leads to short and fast code, but the number of different data items that can be addressed is limited. This means that a program that uses lots of static data may require</source>
          <target state="translated">Генерировать (не генерировать) код, использующий &lt;em&gt;базовые адреса&lt;/em&gt; . Использование базового адреса автоматически генерирует запрос (обрабатываемый ассемблером и компоновщиком) для константы, которая будет установлена ​​в глобальном регистре. Регистр используется для одного или нескольких запросов базового адреса в диапазоне от 0 до 255 от значения, хранящегося в регистре. Обычно это приводит к короткому и быстрому коду, но количество различных элементов данных, которые могут быть адресованы, ограничено. Это означает, что программе, использующей много статических данных, может потребоваться</target>
        </trans-unit>
        <trans-unit id="fc8c5a89f214acd8179a09f487fb87bbd0d7c872" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to load up the static chain register (&lt;code&gt;r11&lt;/code&gt;) when calling through a pointer on AIX and 64-bit Linux systems where a function pointer points to a 3-word descriptor giving the function address, TOC value to be loaded in register &lt;code&gt;r2&lt;/code&gt;, and static chain value to be loaded in register &lt;code&gt;r11&lt;/code&gt;. The</source>
          <target state="translated">Сгенерировать (не генерировать) код для загрузки статического регистра цепочки ( &lt;code&gt;r11&lt;/code&gt; ) при вызове через указатель в AIX и 64-битных системах Linux, где указатель функции указывает на трехсловный дескриптор, дающий адрес функции, значение TOC должно быть загружается в регистр &lt;code&gt;r2&lt;/code&gt; , а статическое значение цепочки загружается в регистр &lt;code&gt;r11&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="813e9e6ca1642f726fee97bfddf02338960484b7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to pass structure parameters with a maximum alignment of 64 bits, for compatibility with older versions of GCC.</source>
          <target state="translated">Сгенерировать (не генерировать)код для передачи параметров структуры с максимальным выравниванием 64 бита,для совместимости со старыми версиями GCC.</target>
        </trans-unit>
        <trans-unit id="55cac71e3fa8543a26a5b7f404ac565adfa17f28" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to save the TOC value in the reserved stack location in the function prologue if the function calls through a pointer on AIX and 64-bit Linux systems. If the TOC value is not saved in the prologue, it is saved just before the call through the pointer. The</source>
          <target state="translated">Сгенерировать (не генерировать)код для сохранения значения TOC в зарезервированном месте стека в прологе функции в случае вызова функции по указателю на AIX и 64-битных Linux системах.Если значение TOC не сохраняется в прологе,оно сохраняется непосредственно перед вызовом через указатель..</target>
        </trans-unit>
        <trans-unit id="492f533f0926b6f12aa3c20775f6e3689bd7771b" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) microMIPS code.</source>
          <target state="translated">Сгенерируйте (не генерируйте)микроМИПС-код.</target>
        </trans-unit>
        <trans-unit id="c38ed93b70630b073ac9de0cd53b30eca713a227" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the &lt;code&gt;friz&lt;/code&gt; instruction when the</source>
          <target state="translated">Сгенерировать (не генерировать) инструкцию &lt;code&gt;friz&lt;/code&gt; , когда</target>
        </trans-unit>
        <trans-unit id="87be6d200ff57766f2cf75cef2026526e7116620" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;bras&lt;/code&gt; instruction to do subroutine calls. This only works reliably if the total executable size does not exceed 64k. The default is to use the &lt;code&gt;basr&lt;/code&gt; instruction instead, which does not have this limitation.</source>
          <target state="translated">Сгенерируйте (или не генерируйте) код, используя инструкцию &lt;code&gt;bras&lt;/code&gt; для выполнения вызовов подпрограмм. Это работает надежно, только если общий размер исполняемого файла не превышает 64 КБ. По умолчанию вместо этого используется инструкция &lt;code&gt;basr&lt;/code&gt; , которая не имеет этого ограничения.</target>
        </trans-unit>
        <trans-unit id="dac8cd11137e120330b4b9ae84e6593137818e9a" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;mvcle&lt;/code&gt; instruction to perform block moves. When</source>
          <target state="translated">Сгенерируйте (или не генерируйте) код с &lt;code&gt;mvcle&lt;/code&gt; инструкции mvcle для выполнения перемещений блоков. когда</target>
        </trans-unit>
        <trans-unit id="2e0545421416cf516c0b942352accf8dc6b0a0d5" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) &amp;lsquo;</source>
          <target state="translated">Создавать (или не создавать) '</target>
        </trans-unit>
        <trans-unit id="05dd2841d03433fc0ea5db0c7e0df3c7599676c8" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) a stop bit immediately before and after volatile asm statements.</source>
          <target state="translated">Создавать (или не генерировать) стоп-бит непосредственно перед и после volatile asm-операторов.</target>
        </trans-unit>
        <trans-unit id="a0784cc5b984b19815bf9eec6e275ae1a59c3b0f" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU assembler. This is the default.</source>
          <target state="translated">Создавать (или не создавать) код для ассемблера GNU. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2516ed040d38a5388dd7fe01c44239d79052cf2e" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU linker. This is the default.</source>
          <target state="translated">Создавать (или не создавать) код для компоновщика GNU. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3e316b54c0eaa7bda512b60e40414c689d945ab8" translate="yes" xml:space="preserve">
          <source>Generate 16-bit instructions.</source>
          <target state="translated">Сгенерировать 16-битные инструкции.</target>
        </trans-unit>
        <trans-unit id="a52620c65360885e469f926c554c75bd50dd9583" translate="yes" xml:space="preserve">
          <source>Generate 3-instruction load and store sequences as sometimes required by the HP-UX 10 linker. This is equivalent to the &amp;lsquo;</source>
          <target state="translated">Создание последовательностей загрузки и сохранения с 3 инструкциями, как иногда требуется компоновщику HP-UX 10. Это эквивалентно '</target>
        </trans-unit>
        <trans-unit id="b384dbdcdcc6be12f32b73f9469c3ba6b9f1dccf" translate="yes" xml:space="preserve">
          <source>Generate 32x16-bit multiply and multiply-accumulate instructions.</source>
          <target state="translated">Сгенерируйте инструкции по умножению и накоплению 32x16 бит.</target>
        </trans-unit>
        <trans-unit id="0ccaaa46afb8881f4f3a477c92bc05eae68e0c4a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections in a format suitable for conversion into a GDB index. This option is only useful with a linker that can produce GDB index version 7.</source>
          <target state="translated">Сгенерируйте &lt;code&gt;.debug_pubnames&lt;/code&gt; и &lt;code&gt;.debug_pubtypes&lt;/code&gt; в формате, подходящем для преобразования в индекс GDB. Эта опция полезна только с компоновщиком, который может создавать индекс GDB версии 7.</target>
        </trans-unit>
        <trans-unit id="828612c6e2cc35cf1bee3972f49446cb2047aba1" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;mul64&lt;/code&gt; and &lt;code&gt;mulu64&lt;/code&gt; instructions. Only valid for</source>
          <target state="translated">Сгенерируйте &lt;code&gt;mul64&lt;/code&gt; и &lt;code&gt;mulu64&lt;/code&gt; . Действительно только для</target>
        </trans-unit>
        <trans-unit id="f37d583fd1aea916d55ab9e91fa3002c399aaf84" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;norm&lt;/code&gt; instructions. This is the default if</source>
          <target state="translated">Сгенерируйте инструкции &lt;code&gt;norm&lt;/code&gt; . Это значение по умолчанию, если</target>
        </trans-unit>
        <trans-unit id="2934019de0c741342611be8077a1571f0c44928a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;swap&lt;/code&gt; instructions.</source>
          <target state="translated">Сгенерируйте инструкции по &lt;code&gt;swap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="586858db58f3f2f4e0ba5be27cc76fd1d37e386f" translate="yes" xml:space="preserve">
          <source>Generate &lt;var&gt;N&lt;/var&gt; NOPs right at the beginning of each function, with the function entry point before the &lt;var&gt;M&lt;/var&gt;th NOP. If &lt;var&gt;M&lt;/var&gt; is omitted, it defaults to &lt;code&gt;0&lt;/code&gt; so the function entry points to the address just at the first NOP. The NOP instructions reserve extra space which can be used to patch in any desired instrumentation at run time, provided that the code segment is writable. The amount of space is controllable indirectly via the number of NOPs; the NOP instruction used corresponds to the instruction emitted by the internal GCC back-end interface &lt;code&gt;gen_nop&lt;/code&gt;. This behavior is target-specific and may also depend on the architecture variant and/or other compilation options.</source>
          <target state="translated">Генерируйте &lt;var&gt;N&lt;/var&gt; NOP в самом начале каждой функции, с точкой входа в функцию перед &lt;var&gt;M&lt;/var&gt; - й NOP. Если &lt;var&gt;M&lt;/var&gt; опущено, по умолчанию он равен &lt;code&gt;0&lt;/code&gt; , поэтому вход функции указывает на адрес только в первом NOP. Инструкции NOP резервируют дополнительное пространство, которое можно использовать для исправления любого желаемого инструментария во время выполнения, при условии, что сегмент кода доступен для записи. Объем пространства регулируется косвенно через количество NOP; используемая инструкция NOP соответствует инструкции, выпущенной внутренним внутренним интерфейсом &lt;code&gt;gen_nop&lt;/code&gt; . Это поведение зависит от цели и также может зависеть от варианта архитектуры и / или других параметров компиляции.</target>
        </trans-unit>
        <trans-unit id="b56d0340e46553074756e8938fdcc9bc10345ee9" translate="yes" xml:space="preserve">
          <source>Generate C header describing the largest structure that is passed by value, if any.</source>
          <target state="translated">Сгенерируйте заголовок C,описывающий самую большую структуру,которая передается по значению,если таковое имеется.</target>
        </trans-unit>
        <trans-unit id="497d1946c219789282a881eeb57aa9b71f210579" translate="yes" xml:space="preserve">
          <source>Generate DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections.</source>
          <target state="translated">Создайте разделы DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; и &lt;code&gt;.debug_pubtypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f0d6b717c142d078ddbdb831a6e380bea411850" translate="yes" xml:space="preserve">
          <source>Generate GNU/Linux compatible gUSA software atomic sequences for the atomic built-in functions. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for SH3* and SH4* single-core systems. This option is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH3* or SH4*. When the target is SH4A, this option also partially utilizes the hardware atomic instructions &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; to create more efficient code, unless &amp;lsquo;</source>
          <target state="translated">Генерация совместимых с GNU / Linux атомарных последовательностей программного обеспечения gUSA для атомарных встроенных функций. Сгенерированные атомарные последовательности требуют дополнительной поддержки со стороны кода системы обработки прерываний / исключений и подходят только для одноядерных систем SH3 * и SH4 *. Этот параметр включен по умолчанию, если целью является &lt;code&gt;sh*-*-linux*&lt;/code&gt; и SH3 * или SH4 *. Когда целью является SH4A, эта опция также частично использует аппаратные атомарные инструкции &lt;code&gt;movli.l&lt;/code&gt; и &lt;code&gt;movco.l&lt;/code&gt; для создания более эффективного кода, если только '</target>
        </trans-unit>
        <trans-unit id="bf2d938e1c1ea97f318900579ce3c50a9ae898af" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for all data objects in the program. If you use this option, the entire data and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">Сгенерировать GP-относительные доступы для всех объектов данных в программе.Если вы используете эту опцию,то все сегменты данных и BSS вашей программы должны поместиться в 64К памяти,и вы должны использовать соответствующий линковочный скрипт для их выделения в адресном диапазоне глобального указателя.</target>
        </trans-unit>
        <trans-unit id="1fc88c33c3fc53124fa0f92092082efc85a7cdc0" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for small data objects that are not external, weak, or uninitialized common symbols. Also use GP-relative addressing for objects that have been explicitly placed in a small data section via a &lt;code&gt;section&lt;/code&gt; attribute.</source>
          <target state="translated">Создание относительного доступа GP для небольших объектов данных, которые не являются внешними, слабыми или неинициализированными общими символами. Также используйте относительную адресацию GP для объектов, которые были явно помещены в небольшой раздел данных с помощью атрибута &lt;code&gt;section&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="548a87f5ac4837154b7b55bf3a0684dbbd7b3056" translate="yes" xml:space="preserve">
          <source>Generate GP-relative addresses for function pointers as well as data pointers. If you use this option, the entire text, data, and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">Сгенерируйте GP-относительные адреса для указателей функций,а также указателей данных.Если вы используете эту опцию,то весь текст,данные и BSS-сегменты вашей программы должны поместиться в 64К памяти,и вы должны использовать соответствующий компоновщик скрипта для их выделения в адресном диапазоне глобального указателя.</target>
        </trans-unit>
        <trans-unit id="9f3a196b430f925ff0ff89b9ccb1a7bf625049d2" translate="yes" xml:space="preserve">
          <source>Generate MIPS16 code on alternating functions. This option is provided for regression testing of mixed MIPS16/non-MIPS16 code generation, and is not intended for ordinary use in compiling user code.</source>
          <target state="translated">Сгенерировать код MIPS16 на чередующихся функциях.Данная опция предусмотрена для регрессионного тестирования смешанного кода MIPS16/не-MIPS16 и не предназначена для обычного использования при компиляции пользовательского кода.</target>
        </trans-unit>
        <trans-unit id="b7aa3b59b611b18a6a4ec60f9d9a319cc049bd6b" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the large model: The TOC may be up to 4G in size. Other data and code is only limited by the 64-bit address space.</source>
          <target state="translated">Сгенерировать код PowerPC64 для большой модели:TOC может быть до 4 Гбит/с.Остальные данные и код ограничены только 64-битным адресным пространством.</target>
        </trans-unit>
        <trans-unit id="c7a74518f21d3c00aafcfd3b084cf7c00aee1848" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the medium model: The TOC and other static data may be up to a total of 4G in size. This is the default for 64-bit Linux.</source>
          <target state="translated">Сгенерировать код PowerPC64 для средней модели:TOC и другие статические данные могут быть до 4 Гбит/с.По умолчанию это для 64-битного Linux.</target>
        </trans-unit>
        <trans-unit id="8cfde8c4df8b2eb989bc818febefc0e7c28874e7" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the small model: The TOC is limited to 64k.</source>
          <target state="translated">Сгенерировать код PowerPC64 для небольшой модели:TOC ограничен 64k.</target>
        </trans-unit>
        <trans-unit id="c7ea62356cd3157102c66b58a868e34df2a5c060" translate="yes" xml:space="preserve">
          <source>Generate VRSAVE instructions when generating AltiVec code.</source>
          <target state="translated">Сгенерировать инструкции VRSAVE при генерации кода AltiVec.</target>
        </trans-unit>
        <trans-unit id="0bd45272345d657871ab9cf111cdd01907672885" translate="yes" xml:space="preserve">
          <source>Generate a __return_loc section pointing to all return instrumentation code.</source>
          <target state="translated">Сгенерировать участок __return_loc,указывающий на весь код прибора возврата.</target>
        </trans-unit>
        <trans-unit id="2cf42b0393916fe85d4396c2a4ea44c0c0b17c4a" translate="yes" xml:space="preserve">
          <source>Generate a call to the function &lt;code&gt;abort&lt;/code&gt; at the end of a &lt;code&gt;noreturn&lt;/code&gt; function. It is executed if the function tries to return.</source>
          <target state="translated">Сгенерируйте вызов функции &lt;code&gt;abort&lt;/code&gt; в конце функции &lt;code&gt;noreturn&lt;/code&gt; . Он выполняется, если функция пытается вернуться.</target>
        </trans-unit>
        <trans-unit id="0bfebab0f7716c6c7d48b3db2e26f828205f2eb0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying</source>
          <target state="translated">Сгенерируйте фрейм стека,соответствующий стандарту ARM Procedure Call Standard для всех функций,даже если это не является строго необходимым для корректного выполнения кода.Указание .</target>
        </trans-unit>
        <trans-unit id="09e70235b2ae102fe1ff7ae3b745820674b997a0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">Сгенерируйте рамку стека,которая соответствует Стандарту вызова процедур большого пальца для всех функций листа.(Функция листа-это такая функция,которая не вызывает никаких других функций.)По умолчанию установлено следующее значение</target>
        </trans-unit>
        <trans-unit id="4e955728a6de82a9bddec4fed62b648dcfc40e9a" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all non-leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">Сгенерируйте рамку стека,соответствующую Стандарту вызова процедур большого пальца для всех нелистовых функций.(Функция листа-это такая функция,которая не вызывает никаких других функций.)По умолчанию установлено следующее значение</target>
        </trans-unit>
        <trans-unit id="4839b3bf0bbd769aa7c0e4fcd67cdaaed9746bd5" translate="yes" xml:space="preserve">
          <source>Generate an executable in the ELF format, rather than the default &amp;lsquo;</source>
          <target state="translated">Сгенерировать исполняемый файл в формате ELF, а не в формате по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6c98697c08dfd7f201b6b9c98efc4af59466b6c7" translate="yes" xml:space="preserve">
          <source>Generate an inline expansion using loop code for all block compares that are less than or equal to &lt;var&gt;num&lt;/var&gt; bytes, but greater than the limit for non-loop inline block compare expansion. If the block length is not constant, at most &lt;var&gt;num&lt;/var&gt; bytes will be compared before &lt;code&gt;memcmp&lt;/code&gt; is called to compare the remainder of the block. The default value is target-specific.</source>
          <target state="translated">Генерировать расширение инлайн , используя код цикла для всех блоков сравнивают, которые меньше или равен &lt;var&gt;num&lt;/var&gt; байты, но больше , чем предел для не-петлевого рядного блока сравнения расширения. Если длина блока не постоянна, перед &lt;code&gt;memcmp&lt;/code&gt; для сравнения оставшейся части блока будет сравниваться не более &lt;var&gt;num&lt;/var&gt; байтов . Значение по умолчанию зависит от цели.</target>
        </trans-unit>
        <trans-unit id="ee53ff6577ff7bdeec45265bba557ddc96dc42d1" translate="yes" xml:space="preserve">
          <source>Generate big-endian code.</source>
          <target state="translated">Сгенерируй биг-ендианский код.</target>
        </trans-unit>
        <trans-unit id="faa1ec28121e6f94c7459039f3f456a29482ffe4" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код с прямым порядком байтов. Это значение по умолчанию для '</target>
        </trans-unit>
        <trans-unit id="497dec8a0e83106900bb3f13f33208ac13cc564e" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код с прямым порядком байтов. Это значение по умолчанию, когда GCC настроен для '</target>
        </trans-unit>
        <trans-unit id="9f5c216ca40ddba6d0b7e0356dfb54eddd239c13" translate="yes" xml:space="preserve">
          <source>Generate calls as register indirect calls, thus providing access to the full 32-bit address range.</source>
          <target state="translated">Генерируйте вызовы как регистр косвенных вызовов,обеспечивая тем самым доступ ко всему 32-битному диапазону адресов.</target>
        </trans-unit>
        <trans-unit id="daf711e932fbd2a210fbf658c2ed048fe589f322" translate="yes" xml:space="preserve">
          <source>Generate checks for control speculation in selective scheduling. This flag is disabled by default.</source>
          <target state="translated">Генерировать проверки для контрольной спекуляции в селективном планировании.Этот флаг отключен по умолчанию.</target>
        </trans-unit>
        <trans-unit id="340f82c2c0a45e961b4cd414df01b6dcda27429e" translate="yes" xml:space="preserve">
          <source>Generate code containing floating-point instructions. This is the default.</source>
          <target state="translated">Сгенерируйте код,содержащий инструкции с плавающей точкой.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="d1eb9be83c7705dec7853ee52d8e983f54f63d2c" translate="yes" xml:space="preserve">
          <source>Generate code containing library calls for floating-point.</source>
          <target state="translated">Сгенерировать код,содержащий вызовы библиотек с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="ffda305054ff95e7394bd4003326530b52f9583d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit ABI.</source>
          <target state="translated">Сгенерировать код для 32-битного или 64-битного ABI.</target>
        </trans-unit>
        <trans-unit id="b67c6b7cf041ab09d12159e623bf4650fd97244d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit environments of Darwin and SVR4 targets (including GNU/Linux). The 32-bit environment sets int, long and pointer to 32 bits and generates code that runs on any PowerPC variant. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits, and generates code for PowerPC64, as for</source>
          <target state="translated">Сгенерировать код для 32-битных или 64-битных сред Darwin и SVR4 целей (включая GNU/Linux).32-битное окружение устанавливает int,long и указатель на 32 бита и генерирует код,который работает на любом варианте PowerPC.64-битное окружение устанавливает int на 32 бита и long и указатель на 64 бита,а также генерирует код для PowerPC64,как для</target>
        </trans-unit>
        <trans-unit id="a4491a667cb7d0b6c838f6faaee6a864eadc20bd" translate="yes" xml:space="preserve">
          <source>Generate code for CR16C or CR16C+ architecture. CR16C+ architecture is default.</source>
          <target state="translated">Сгенерировать код для архитектуры CR16C или CR16C+.По умолчанию используется архитектура CR16C+.</target>
        </trans-unit>
        <trans-unit id="67648931cfe6b959b11bf696abb5438c66a26217" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">Сгенерируйте код для SH4-100,предполагая,что блок с плавающей точкой по умолчанию находится в режиме одинарной точности.</target>
        </trans-unit>
        <trans-unit id="de1af2a9972c47a564f5e7fcce23d995d6ae1b8b" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">Сгенерируйте код для SH4-100 таким образом,чтобы не использовать операции с плавающей точкой двойной точности.</target>
        </trans-unit>
        <trans-unit id="107ca25d9739e824d4175850436b6598a742f5a1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that the floating-point unit is not used.</source>
          <target state="translated">Сгенерируйте код для SH4-100 таким образом,чтобы устройство с плавающей запятой не использовалось.</target>
        </trans-unit>
        <trans-unit id="f4838bc707d842b8a2b2e768456d1b164bf348d3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100.</source>
          <target state="translated">Сгенерируйте код для SH4-100.</target>
        </trans-unit>
        <trans-unit id="eb7eb15dc4aa3c46b2283b182c63acf0a395433d" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">Сгенерируйте код для SH4-200,предполагая,что блок с плавающей точкой по умолчанию находится в режиме одинарной точности.</target>
        </trans-unit>
        <trans-unit id="c7c33168087299c03364283296e9feb1a533b788" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">Сгенерируйте код для SH4-200 таким образом,чтобы не использовать операции с плавающей точкой двойной точности.</target>
        </trans-unit>
        <trans-unit id="b14c102c6af7d5f6fb411b3d326830a45f2aceb0" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">Сгенерируйте код для SH4-200 таким образом,чтобы устройство с плавающей запятой не использовалось.</target>
        </trans-unit>
        <trans-unit id="5283c23e1460ff21798ade4588312627145b49aa" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200.</source>
          <target state="translated">Сгенерировать код для SH4-200.</target>
        </trans-unit>
        <trans-unit id="2fb0dbc9dfbf231f5e57962b75a086351c1f46b3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">Сгенерируйте код для SH4-300 таким образом,чтобы не использовать операции с плавающей точкой двойной точности.</target>
        </trans-unit>
        <trans-unit id="ff44e3f28e2fd7daaa679641ff86e04eab85fb68" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">Сгенерируйте код для SH4-300 таким образом,чтобы устройство с плавающей запятой не использовалось.</target>
        </trans-unit>
        <trans-unit id="5dd69911ae792e28eb1d16efd78aa149dec9b0b1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300.</source>
          <target state="translated">Сгенерируйте код для SH4-300.</target>
        </trans-unit>
        <trans-unit id="3190f28d97b238beea538765e992a0880400111e" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-340 (no MMU, no FPU).</source>
          <target state="translated">Сгенерировать код для SH4-340 (в MMU,FPU).</target>
        </trans-unit>
        <trans-unit id="964d89eec4f49e488b7e663bfb784df7de2d9807" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-500 (no FPU). Passes</source>
          <target state="translated">Сгенерируйте код для SH4-500 (без FPU).Пасс</target>
        </trans-unit>
        <trans-unit id="bd07f25b5dfd9dc83556617396ced4ced292840d" translate="yes" xml:space="preserve">
          <source>Generate code for Smart Mode, using only registers numbered 0-7 to allow use of 16-bit instructions. This option is ignored for CK801 where this is the required behavior, and it defaults to on for CK802. For other targets, the default is off.</source>
          <target state="translated">Сгенерируйте код для Smart Mode,используя только регистры,пронумерованные 0-7,что позволит использовать 16-битные инструкции.Эта опция игнорируется для CK801,где это является требуемым поведением,и по умолчанию включена для CK802.Для других целей по умолчанию выключен.</target>
        </trans-unit>
        <trans-unit id="d1ef13a03c7e2ed855aab73fe845bb318c6bf94c" translate="yes" xml:space="preserve">
          <source>Generate code for a 16-bit, 32-bit or 64-bit environment. The</source>
          <target state="translated">Сгенерировать код для 16-битной,32-битной или 64-битной среды.</target>
        </trans-unit>
        <trans-unit id="6f846bc35b4ddbb63662daaf0b8a0b9a36eafb1b" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit environment, which sets int, long, and pointer to 32 bits. This is the only supported behavior so the flag is essentially ignored.</source>
          <target state="translated">Сгенерировать код для 32-битного окружения,которое устанавливает int,long и указатель на 32 бита.Это единственное поддерживаемое поведение,поэтому флаг по существу игнорируется.</target>
        </trans-unit>
        <trans-unit id="c70fb6bc63f54c3dd3b6636fb15aabdae1032dda" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">Сгенерировать код для 32-битной или 64-битной среды.32-битное окружение устанавливает int,long и указатель на 32 бита.64-битное окружение устанавливает int в 32 бита и long и указатель в 64 бита.</target>
        </trans-unit>
        <trans-unit id="25466413f97413255c5d54e631be1e6a23f5330d" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits. These are HP-UX specific flags.</source>
          <target state="translated">Сгенерировать код для 32-битной или 64-битной среды.32-битное окружение устанавливает int,long и указатель на 32 бита.64-битное окружение устанавливает int в 32 бита и long и указатель в 64 бита.Это флаги,специфичные для HP-UX.</target>
        </trans-unit>
        <trans-unit id="89222a0849ae48c73c6bd1624ef4d88ea3c84874" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long, and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">Сгенерировать код для 32-битной или 64-битной среды.32-битное окружение устанавливает int,long и указатель на 32 бита.64-битное окружение устанавливает int в 32 бита и long и указатель в 64 бита.</target>
        </trans-unit>
        <trans-unit id="7a6899675bc409f91ebf1c2951874d09f2171d0a" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/10. Implies -msoft-float -mno-split.</source>
          <target state="translated">Сгенерируйте код для PDP-11/10.Подразумевает -msoft-float -mno-split.</target>
        </trans-unit>
        <trans-unit id="bee1deaf455b6a6b4cdb2bb13d6ee23ad81f5012" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/40. Implies -msoft-float -mno-split.</source>
          <target state="translated">Сгенерируйте код для PDP-11/40.Подразумевает -msoft-float -mno-split.</target>
        </trans-unit>
        <trans-unit id="d9780d13a5a51c47480c939a428413699ac3ed17" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/45. This is the default.</source>
          <target state="translated">Сгенерируйте код для PDP-11/45.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="92b920e8ba8535d90a16588551ee999d568f0291" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target.</source>
          <target state="translated">Сгенерируйте код для биг-ендианской цели.</target>
        </trans-unit>
        <trans-unit id="d68254cfeddff60f3b9cadfb72e8acbde8b8a455" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target. This is the default for HP-UX.</source>
          <target state="translated">Сгенерируйте код для биг-ендианской цели.Это стандартный код для HP-UX.</target>
        </trans-unit>
        <trans-unit id="5fbe216af63a08f8f99c457d81f72aa33271a249" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target.</source>
          <target state="translated">Сгенерируйте код для маленькой цели.</target>
        </trans-unit>
        <trans-unit id="7fec6c67ff3977f6cbf34379a4b039899b9238d9" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default for AIX5 and GNU/Linux.</source>
          <target state="translated">Сгенерируйте код для маленькой цели.По умолчанию это для AIX5 и GNU/Linux.</target>
        </trans-unit>
        <trans-unit id="12a32136f06def3f80692a9e99c0d8f9b7d0b140" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default.</source>
          <target state="translated">Сгенерируйте код для маленькой цели.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="86cf4bd8b15db1a7bae18b7503fdfe578d14ff3d" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in big-endian mode; the default is to compile code for a little-endian processor.</source>
          <target state="translated">Сгенерировать код для процессора,работающего в режиме big-endian;по умолчанию скомпилировать код для процессора little-endian.</target>
        </trans-unit>
        <trans-unit id="b9c63b6f7dde24a56bfd3b0c8c39dff387d09612" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in little-endian mode. This is the default for all standard configurations.</source>
          <target state="translated">Сгенерируйте код для процессора,работающего в режиме little-endian.Это стандартная настройка по умолчанию для всех стандартных конфигураций.</target>
        </trans-unit>
        <trans-unit id="7c9d614db21563decf26e4450a12e8ff0db080a3" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire instruction set architecture. Permissible values of &lt;var&gt;arch&lt;/var&gt; for M680x0 architectures are: &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код для определенной архитектуры набора инструкций M680x0 или ColdFire. Допустимые значения &lt;var&gt;arch&lt;/var&gt; для архитектур M680x0: '</target>
        </trans-unit>
        <trans-unit id="4756b1c10e780d22755d4efd055be671187986d0" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire processor. The M680x0 &lt;var&gt;cpu&lt;/var&gt;s are: &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код для конкретного процессора M680x0 или ColdFire. В M680x0 &lt;var&gt;cpu&lt;/var&gt; s являются: '</target>
        </trans-unit>
        <trans-unit id="cf0efda24e55f61b98734329e006dab8159c05d8" translate="yes" xml:space="preserve">
          <source>Generate code for given RISC-V ISA (e.g. &amp;lsquo;</source>
          <target state="translated">Сгенерировать код для данного RISC-V ISA (например, '</target>
        </trans-unit>
        <trans-unit id="1cc9f255978b92385d0966d847bc3f1f4feff36e" translate="yes" xml:space="preserve">
          <source>Generate code for given the specified PTX ISA (e.g. &amp;lsquo;</source>
          <target state="translated">Сгенерировать код для указанного PTX ISA (например, '</target>
        </trans-unit>
        <trans-unit id="4b8a962abd2bc5357f263a724ad7ce6201860ac4" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires divide instruction emulation.</source>
          <target state="translated">Сгенерировать код для аппаратного обеспечения,требующего эмуляции команд разделения.</target>
        </trans-unit>
        <trans-unit id="0ff05f7bfb6de148dd31e5b918468ff58be8cc2b" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires multiply instruction emulation.</source>
          <target state="translated">Сгенерировать код для аппаратного обеспечения,требующего эмуляции многократных инструкций.</target>
        </trans-unit>
        <trans-unit id="9d141b4aab656e3ada981384fd6736554ccf4fe3" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports divide instructions. This is the default.</source>
          <target state="translated">Сгенерируйте код для аппаратного обеспечения,поддерживающего команды разделения.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="63b8cd12a9a7b77524e7516bc8342264efc809e2" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports multiply instructions. This is the default.</source>
          <target state="translated">Сгенерируйте код для аппаратного обеспечения,поддерживающего инструкции по умножению.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="f67b905d0c7d601714b6d40130d650c8841556d5" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports rotate right instructions.</source>
          <target state="translated">Сгенерируйте код для аппаратного обеспечения,поддерживающего правильное вращение инструкций.</target>
        </trans-unit>
        <trans-unit id="d8901265c038359c4cabcecef69c62a4ad403284" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports set flag immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions.</source>
          <target state="translated">Сгенерируйте код для оборудования, которое поддерживает инструкции немедленной установки флага ( &lt;code&gt;l.sf*i&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cb0dc185d9cce6eac6a0da7c5fde4468c232eb00" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports shift immediate related instructions (i.e. &lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;, &lt;code&gt;1.rori&lt;/code&gt;). Note, to enable generation of the &lt;code&gt;l.rori&lt;/code&gt; instruction the</source>
          <target state="translated">Сгенерируйте код для оборудования, которое поддерживает инструкции, связанные с немедленным сдвигом (например, &lt;code&gt;l.srai&lt;/code&gt; , &lt;code&gt;l.srli&lt;/code&gt; , &lt;code&gt;l.slli&lt;/code&gt; , &lt;code&gt;1.rori&lt;/code&gt; ). Обратите внимание: для включения генерации инструкции &lt;code&gt;l.rori&lt;/code&gt; необходимо</target>
        </trans-unit>
        <trans-unit id="56c0dd74c2b5f08d1195605802098a996d48ddaa" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports sign-extension instructions.</source>
          <target state="translated">Сгенерируйте код для оборудования,которое поддерживает инструкции по расширению знаков.</target>
        </trans-unit>
        <trans-unit id="c6c9d0431f616f47453feb5bcfe61cef592a68b7" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports the conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instruction.</source>
          <target state="translated">Сгенерируйте код для оборудования, поддерживающего инструкцию условного перемещения ( &lt;code&gt;l.cmov&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf79d7ac3430cd100137adc751a91365b039edd3" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the maximum throughput algorithm.</source>
          <target state="translated">Сгенерировать код для строчных делений значений с плавающей точкой,используя алгоритм максимальной пропускной способности.</target>
        </trans-unit>
        <trans-unit id="3cedd11fcbf120218332b498654e7e4160f8c76d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the minimum latency algorithm.</source>
          <target state="translated">Сгенерировать код для строчных делений значений с плавающей точкой,используя алгоритм минимальной латентности.</target>
        </trans-unit>
        <trans-unit id="1cc7790f16d0c4d4d91471e6f5d653df0c747e44" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the maximum throughput algorithm.</source>
          <target state="translated">Сгенерировать код для строчных делений целочисленных значений,используя алгоритм максимальной пропускной способности.</target>
        </trans-unit>
        <trans-unit id="faf94b4d20f983cdf533f47ec33942d0ce63586d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the minimum latency algorithm.</source>
          <target state="translated">Сгенерировать код для строчных делений целочисленных значений с использованием алгоритма минимальной латентности.</target>
        </trans-unit>
        <trans-unit id="5418fa0a1b1b281d2485d7060d2309afdebd6ff4" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the maximum throughput algorithm.</source>
          <target state="translated">Сгенерируйте код для встраиваемых квадратных корней,используя алгоритм максимальной пропускной способности.</target>
        </trans-unit>
        <trans-unit id="83ef176a0741f8d1f5fe6e111f7583e6807956ad" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the minimum latency algorithm.</source>
          <target state="translated">Сгенерируйте код для строчных квадратных корней,используя алгоритм минимальной латентности.</target>
        </trans-unit>
        <trans-unit id="00979759a61ef121145bed1163bfbd0399a7b98b" translate="yes" xml:space="preserve">
          <source>Generate code for long address mode. This is only supported for 64-bit and x32 environments. It is the default address mode for 64-bit environments.</source>
          <target state="translated">Сгенерируйте код для длинного адресного режима.Поддерживается только для 64-битных и x32 окружений.Это режим адресации по умолчанию для 64-битных сред.</target>
        </trans-unit>
        <trans-unit id="8adaf3135394010293585c029db12629ab7fdcf7" translate="yes" xml:space="preserve">
          <source>Generate code for short address mode. This is only supported for 32-bit and x32 environments. It is the default address mode for 32-bit and x32 environments.</source>
          <target state="translated">Сгенерируйте код для режима короткого адреса.Поддерживается только для 32-битных и x32 окружений.Это режим адресации по умолчанию для 32-битных и x32 окружений.</target>
        </trans-unit>
        <trans-unit id="694f6014654115d073cccf62f6b995dc2510f9c1" translate="yes" xml:space="preserve">
          <source>Generate code for the 210 processor.</source>
          <target state="translated">Сгенерируйте код для процессора 210.</target>
        </trans-unit>
        <trans-unit id="85e35fc91e0af86a193c565f8d6f2a96d089e373" translate="yes" xml:space="preserve">
          <source>Generate code for the C-SKY compiler runtime instead of libgcc. This option defaults to off.</source>
          <target state="translated">Сгенерировать код для выполнения компилятора C-SKY вместо libgcc.По умолчанию эта опция выключена.</target>
        </trans-unit>
        <trans-unit id="27e854c2e0908c3f4c936f01364c648aa32b367c" translate="yes" xml:space="preserve">
          <source>Generate code for the H8/300H.</source>
          <target state="translated">Сгенерируйте код для H8/300H.</target>
        </trans-unit>
        <trans-unit id="bb83090e60c2fc757a89c80487c241185ee5d95a" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S and H8/300H in the normal mode. This switch must be used either with</source>
          <target state="translated">Сгенерируйте код для H8S и H8/300H в нормальном режиме.Этот переключатель должен использоваться либо с</target>
        </trans-unit>
        <trans-unit id="d052e6239d8f301fe0a2b7da20c249087f96d45d" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S.</source>
          <target state="translated">Сгенерируйте код для H8S.</target>
        </trans-unit>
        <trans-unit id="6d5ff3e2bd91c0a262161bf6efa2cdef6971233e" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S/2600. This switch must be used with</source>
          <target state="translated">Сгенерируйте код для H8S/2600.Этот переключатель должен использоваться с</target>
        </trans-unit>
        <trans-unit id="d28ff0fda5a5612fbf86e8ebd7c80cabd4110b85" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R. This is the default.</source>
          <target state="translated">Сгенерируйте код для M32R.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="20e08fc2eddd3584a33dc2a59b26172bf1281828" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/2.</source>
          <target state="translated">Сгенерируйте код для M32R/2.</target>
        </trans-unit>
        <trans-unit id="1939be789de09c47e008a34d88743773021de724" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/X.</source>
          <target state="translated">Сгенерируйте код для M32R/X.</target>
        </trans-unit>
        <trans-unit id="df8817f533054f34d7acf449e4e33f38657d304e" translate="yes" xml:space="preserve">
          <source>Generate code for the SH1.</source>
          <target state="translated">Сгенерируйте код для SH1.</target>
        </trans-unit>
        <trans-unit id="050479be73754de25483a6e1712e26489d053e34" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2.</source>
          <target state="translated">Сгенерируйте код для SH2.</target>
        </trans-unit>
        <trans-unit id="3723c95f415c4a4c6a69d66a7f758a27732147a1" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a without FPU, or for a SH2a-FPU in such a way that the floating-point unit is not used.</source>
          <target state="translated">Сгенерируйте код для SH2a без FPU или для SH2a-FPU таким образом,чтобы устройство с плавающей запятой не использовалось.</target>
        </trans-unit>
        <trans-unit id="bc412156cf20c916e946ffa4cbe84584eb6567a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in double-precision mode by default.</source>
          <target state="translated">Сгенерируйте код для SH2a-FPU,предполагая,что устройство с плавающей запятой по умолчанию находится в режиме двойной точности.</target>
        </trans-unit>
        <trans-unit id="34abdbdae2fa95db6713e96853be2eca7e9c05eb" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">Сгенерируйте код для SH2a-FPU,предполагая,что устройство с плавающей запятой по умолчанию находится в режиме одинарной точности.</target>
        </trans-unit>
        <trans-unit id="1f2673d8ddd54030d4d4878de69f24422a5fdba0" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">Сгенерируйте код для SH2a-FPU таким образом,чтобы не использовать операции с плавающей запятой двойной точности.</target>
        </trans-unit>
        <trans-unit id="483cb3ca44e923a4b1df433858f80751ca9f93aa" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2e.</source>
          <target state="translated">Сгенерируйте код для SH2e.</target>
        </trans-unit>
        <trans-unit id="1a936c359ffaab90c574043388b2920044ce94c5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3.</source>
          <target state="translated">Сгенерируйте код для SH3.</target>
        </trans-unit>
        <trans-unit id="52624bfb24aef64a24903a711fc58d43129edfce" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3e.</source>
          <target state="translated">Сгенерируйте код для SH3e.</target>
        </trans-unit>
        <trans-unit id="3974fd9acf25ff513cb6f41c5bd4a7bda9784a55" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">Сгенерируйте код для SH4,предполагая,что блок с плавающей точкой по умолчанию находится в режиме одинарной точности.</target>
        </trans-unit>
        <trans-unit id="75d92b5b6d76cda99c6a173e1dd53216d0ca8f31" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 with a floating-point unit that only supports single-precision arithmetic.</source>
          <target state="translated">Сгенерируйте код для SH4 с помощью устройства с плавающей запятой,поддерживающего только арифметику с одинарной точностью.</target>
        </trans-unit>
        <trans-unit id="162b02716f568279c8d0d5122c58fd1e1d0d9f75" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 without a floating-point unit.</source>
          <target state="translated">Сгенерируйте код для SH4 без устройства с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="63daf68bdeb08d26dfc7feca667cc330215f1c9b" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4.</source>
          <target state="translated">Сгенерируйте код для SH4.</target>
        </trans-unit>
        <trans-unit id="e752d163eaf5a23bc2b7e20cedab4af27f30919d" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">Сгенерируйте код для SH4a,предполагая,что блок с плавающей точкой по умолчанию находится в режиме одинарной точности.</target>
        </trans-unit>
        <trans-unit id="9bfcba29114940deb31d10a6d0e6239fe06706a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">Сгенерируйте код для SH4a таким образом,чтобы не использовать операции с плавающей точкой двойной точности.</target>
        </trans-unit>
        <trans-unit id="c9b792a4628ba5fbcf5191ba54ebda633615fe85" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a.</source>
          <target state="translated">Сгенерируйте код для SH4a.</target>
        </trans-unit>
        <trans-unit id="e7ae153f4f4ad9faa39e7795dea14788da791715" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4al-dsp, or for a SH4a in such a way that the floating-point unit is not used.</source>
          <target state="translated">Сгенерируйте код для SH4al-dsp,или для SH4a таким образом,чтобы устройство с плавающей запятой не использовалось.</target>
        </trans-unit>
        <trans-unit id="b868662932b00739d50db318aa2ddd01fc4bd249" translate="yes" xml:space="preserve">
          <source>Generate code for the given ABI.</source>
          <target state="translated">Сгенерируйте код для данного ABI.</target>
        </trans-unit>
        <trans-unit id="54f462554c550dbd112a2f944735d38c4f45d0bc" translate="yes" xml:space="preserve">
          <source>Generate code for the kernel code model. The kernel runs in the negative 2 GB of the address space. This model has to be used for Linux kernel code.</source>
          <target state="translated">Сгенерировать код для модели кода кернела.Кернел запускается в отрицательном 2 гигабайтах адресного пространства.Эта модель должна использоваться для кода кернела Linux.</target>
        </trans-unit>
        <trans-unit id="9f7119380ad6e8c2c7924710a3b532b63b7c448f" translate="yes" xml:space="preserve">
          <source>Generate code for the large code model. This makes no assumptions about addresses and sizes of sections. Programs can be statically linked only.</source>
          <target state="translated">Сгенерируйте код для большой модели кода.При этом не делается никаких предположений об адресах и размерах секций.Программы могут быть только статически связаны.</target>
        </trans-unit>
        <trans-unit id="e3f449db1f29f06f736e88f3d496de39caace854" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. There is no limitation on call distance, pc-relative addresses, or absolute addresses.</source>
          <target state="translated">Сгенерируйте код для большой модели.Нет ограничений по расстоянию вызова,pc-относительным адресам или абсолютным адресам.</target>
        </trans-unit>
        <trans-unit id="9e0fcd5ba89af087e24036d07076369bc21de870" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. This model makes no assumptions about addresses and sizes of sections.</source>
          <target state="translated">Сгенерируйте код для большой модели.В данной модели не делается никаких предположений об адресах и размерах секций.</target>
        </trans-unit>
        <trans-unit id="0971940cc08a4932dadb19e61d4f634d86124a27" translate="yes" xml:space="preserve">
          <source>Generate code for the medium model: the program is linked in the lower 2 GB of the address space. Small symbols are also placed there. Symbols with sizes larger than</source>
          <target state="translated">Сгенерируйте код для средней модели:программа связана в нижних 2 ГБ адресного пространства.Туда же помещаются небольшие символы.Символы размером больше</target>
        </trans-unit>
        <trans-unit id="59ca259d5568c2d002dd2ccbe8f095a11b92f1df" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-any code model. The program and its statically defined symbols must be within any single 2 GiB address range. Programs can be statically or dynamically linked.</source>
          <target state="translated">Сгенерируйте код для средней модели кода.Программа и ее статически определенные символы должны находиться в пределах любого одного диапазона адресов 2 Гб.Программы могут быть статически или динамически связаны.</target>
        </trans-unit>
        <trans-unit id="504796a714036a0c76db86fa41cc45a9fb08427c" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-low code model. The program and its statically defined symbols must lie within a single 2 GiB address range and must lie between absolute addresses -2 GiB and +2 GiB. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">Сгенерируйте код для средне-низкой модели кода.Программа и ее статически определенные символы должны лежать в пределах одного диапазона адресов 2 Гб и находиться между абсолютными адресами -2 Гб и +2 Гб.Программы могут быть статически или динамически связаны.Это модель кода по умолчанию.</target>
        </trans-unit>
        <trans-unit id="071c751072fdeed9625e903fca26e27c829fa3e5" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model. The program and its statically defined symbols must be within 4GB of each other. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">Сгенерируйте код для небольшой модели кода.Программа и ее статически определенные символы должны находиться в пределах 4 Гб друг от друга.Программы могут быть статически или динамически связаны.Это модель кода по умолчанию.</target>
        </trans-unit>
        <trans-unit id="051a1860ec3526f5a9b8c1256cff7e9959d2ec61" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space. Pointers are 64 bits. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">Сгенерируйте код для небольшой модели кода:программа и ее символы должны быть связаны в нижних 2 Гб адресного пространства.Указатели-64 бита.Программы могут быть статически или динамически связаны.Это модель кода по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fccb732c10311c882aff8903c1dae6926a19b9e0" translate="yes" xml:space="preserve">
          <source>Generate code for the small model. The distance for direct calls is limited to 500M in either direction. PC-relative addresses are 32 bits. Absolute addresses support the full address range.</source>
          <target state="translated">Сгенерируйте код для небольшой модели.Расстояние для прямых звонков ограничено до 500М в любом направлении.Относительные адреса-32 бита.Абсолютные адреса поддерживают полный диапазон адресов.</target>
        </trans-unit>
        <trans-unit id="245e4a42ebe1fc23a573492e82ac616ceb7b3a60" translate="yes" xml:space="preserve">
          <source>Generate code for the specified ABI. Permissible values are: &amp;lsquo;</source>
          <target state="translated">Сгенерировать код для указанного ABI. Допустимые значения: '</target>
        </trans-unit>
        <trans-unit id="62cd08507f5129c0313b216b3b312e1f38339400" translate="yes" xml:space="preserve">
          <source>Generate code for the specified architecture. The choices for &lt;var&gt;architecture-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код для указанной архитектуры. Выбор &lt;var&gt;architecture-type&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="fa0e2168d621855d66b05e248a41636b81294293" translate="yes" xml:space="preserve">
          <source>Generate code for the specified calling convention. Permissible values are &amp;lsquo;</source>
          <target state="translated">Сгенерировать код для указанного соглашения о вызовах. Допустимые значения: '</target>
        </trans-unit>
        <trans-unit id="d43b1f64836a5b0a5d775d2376c530695500c9a6" translate="yes" xml:space="preserve">
          <source>Generate code for the specified data model. Permissible values are &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код для указанной модели данных. Допустимые значения: '</target>
        </trans-unit>
        <trans-unit id="e12f5237878118905a68ef1df9fd8353d31db89f" translate="yes" xml:space="preserve">
          <source>Generate code for the supervisor mode, where there are no restrictions on the access to general registers. This is the default.</source>
          <target state="translated">Сгенерируйте код для режима супервизора,где нет ограничений на доступ к общим регистрам.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="e6c40e69179c553d840354dee8e09afd6afb670e" translate="yes" xml:space="preserve">
          <source>Generate code for the tiny code model. The program and its statically defined symbols must be within 1MB of each other. Programs can be statically or dynamically linked.</source>
          <target state="translated">Сгенерируйте код для крошечной модели кода.Программа и ее статически определенные символы должны находиться в пределах 1MB друг от друга.Программы могут быть статически или динамически связаны.</target>
        </trans-unit>
        <trans-unit id="9e11e5ef71d66be04277bc1f01b5f5278d9a40a3" translate="yes" xml:space="preserve">
          <source>Generate code for the user mode, where the access to some general registers is forbidden: on the GR5, registers r24 to r31 cannot be accessed in this mode; on the GR6, only registers r29 to r31 are affected.</source>
          <target state="translated">Сгенерируйте код для пользовательского режима,где доступ к некоторым общим регистрам запрещен:на GR5 в этом режиме нельзя получить доступ к регистрам с r24 по r31;на GR6 затрагиваются только регистры с r29 по r31.</target>
        </trans-unit>
        <trans-unit id="bd8c4bf394db1eaf7b115e9a97579b1aa69d5063" translate="yes" xml:space="preserve">
          <source>Generate code for use in OpenMP offloading: enables</source>
          <target state="translated">Сгенерировать код для использования в OpenMP offloading:включает</target>
        </trans-unit>
        <trans-unit id="16c4c1a05d2b765d07aab8ca18577dc3fd7c3686" translate="yes" xml:space="preserve">
          <source>Generate code in big-endian mode.</source>
          <target state="translated">Сгенерируйте код в режиме big-endian.</target>
        </trans-unit>
        <trans-unit id="617c48669c81ce32d047fdd88ab6cc36cefe714c" translate="yes" xml:space="preserve">
          <source>Generate code in big/little endian mode, respectively.</source>
          <target state="translated">Сгенерируйте код в режиме big/little endian,соответственно.</target>
        </trans-unit>
        <trans-unit id="f467368c82a003e89d9528f03fca80cb77bf1e51" translate="yes" xml:space="preserve">
          <source>Generate code in little-endian mode.</source>
          <target state="translated">Сгенерируйте код в режиме little-endian.</target>
        </trans-unit>
        <trans-unit id="d2870658bf99f10270c562aaa0ce69afd3724aea" translate="yes" xml:space="preserve">
          <source>Generate code suitable for big switch tables. Use this option only if the assembler/linker complain about out of range branches within a switch table.</source>
          <target state="translated">Сгенерируйте код,подходящий для больших таблиц переключателей.Используйте эту опцию только в том случае,если ассемблер/слинкер пожалуется на ветви вне диапазона внутри таблицы коммутаторов.</target>
        </trans-unit>
        <trans-unit id="31742c20f6d08e41957b4759da6c2e20cfa33560" translate="yes" xml:space="preserve">
          <source>Generate code suitable for fast turnaround development, such as to allow GDB to dynamically load</source>
          <target state="translated">Генерируйте код,подходящий для быстрой разработки,например,чтобы GDB мог динамически загружаться</target>
        </trans-unit>
        <trans-unit id="f9c5e3444f60e6e1d269aebfea1614af0e0ffa27" translate="yes" xml:space="preserve">
          <source>Generate code that adds (does not add) in TPF OS specific branches to trace routines in the operating system. This option is off by default, even when compiling for the TPF OS.</source>
          <target state="translated">Сгенерировать код,который добавляет (не добавляет)в TPF специфические ветви ОС для трассировки процедур в операционной системе.Эта опция отключена по умолчанию,даже при компиляции для ОС TPF.</target>
        </trans-unit>
        <trans-unit id="cf132e8fd4ca1bac8a3c035b0896be35d4f95248" translate="yes" xml:space="preserve">
          <source>Generate code that allows (does not allow) a static executable to be relocated to a different address at run time. A simple embedded PowerPC system loader should relocate the entire contents of &lt;code&gt;.got2&lt;/code&gt; and 4-byte locations listed in the &lt;code&gt;.fixup&lt;/code&gt; section, a table of 32-bit addresses generated by this option. For this to work, all objects linked together must be compiled with</source>
          <target state="translated">Сгенерируйте код, который позволяет (не позволяет) перемещать статический исполняемый файл на другой адрес во время выполнения. Простой встроенный системный загрузчик PowerPC должен переместить все содержимое &lt;code&gt;.got2&lt;/code&gt; и 4-байтовых местоположений, перечисленных в разделе &lt;code&gt;.fixup&lt;/code&gt; , таблице 32-разрядных адресов, сгенерированных этой опцией. Чтобы это работало, все связанные вместе объекты должны быть скомпилированы с</target>
        </trans-unit>
        <trans-unit id="86d1c7c8ebb812df3d75ca440f1dd938fb6de6fb" translate="yes" xml:space="preserve">
          <source>Generate code that allows &lt;code&gt;ld&lt;/code&gt; and &lt;code&gt;ld.so&lt;/code&gt; to build executables and shared libraries with non-executable &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">Сгенерируйте код, который позволяет &lt;code&gt;ld&lt;/code&gt; и &lt;code&gt;ld.so&lt;/code&gt; создавать исполняемые файлы и разделяемые библиотеки с неисполняемыми разделами &lt;code&gt;.plt&lt;/code&gt; и &lt;code&gt;.got&lt;/code&gt; . Это 32-битная опция SYSV ABI PowerPC.</target>
        </trans-unit>
        <trans-unit id="2493e6ad3aa4a2943864620cf6ffd109b6ddb3da" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute in place in an environment without virtual memory management by eliminating relocations against the text section.</source>
          <target state="translated">Сгенерируйте код,позволяющий расположить сегмент данных в другой области памяти,отличной от текстового сегмента.Это позволяет выполнить в среде без управления виртуальной памятью,устраняя перемещения относительно текстового сегмента.</target>
        </trans-unit>
        <trans-unit id="eb6f87eee15c30331198259c5e0fa884666e3b45" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute-in-place in an environment without virtual memory management. This option implies</source>
          <target state="translated">Сгенерируйте код,позволяющий расположить сегмент данных в другой области памяти,отличной от текстового сегмента.Это позволяет выполнить в среде без управления виртуальной памятью.Данная опция подразумевает</target>
        </trans-unit>
        <trans-unit id="338b24d92797baf1f472014c3eb7e81cad28ab15" translate="yes" xml:space="preserve">
          <source>Generate code that allows trapping instructions to throw exceptions. Note that this requires platform-specific runtime support that does not exist everywhere. Moreover, it only allows &lt;em&gt;trapping&lt;/em&gt; instructions to throw exceptions, i.e. memory references or floating-point instructions. It does not allow exceptions to be thrown from arbitrary signal handlers such as &lt;code&gt;SIGALRM&lt;/code&gt;.</source>
          <target state="translated">Сгенерируйте код, который позволяет командам перехвата вызывать исключения. Обратите внимание, что для этого требуется поддержка среды выполнения для конкретной платформы, которая существует не везде. Более того, он позволяет только командам &lt;em&gt;перехвата&lt;/em&gt; вызывать исключения, то есть ссылки на память или инструкции с плавающей запятой. Он не позволяет создавать исключения из произвольных обработчиков сигналов, таких как &lt;code&gt;SIGALRM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd1ec35fb62e61a3c0c9ad20b949b97f631374a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes (does not assume) that all calls are far away so that a longer more expensive calling sequence is required.</source>
          <target state="translated">Сгенерируйте код,который предполагает (не предполагает),что все вызовы находятся далеко,так что требуется более длительная и дорогая последовательность вызовов.</target>
        </trans-unit>
        <trans-unit id="8f709a2890cb93e8763f592a97bd90453baa9bc3" translate="yes" xml:space="preserve">
          <source>Generate code that assumes calls never cross space boundaries. This allows GCC to emit code that performs faster indirect calls.</source>
          <target state="translated">Сгенерируйте код,который предполагает,что вызовы никогда не пересекают границы пространства.Это позволяет GCC излучать код,который быстрее выполняет косвенные вызовы.</target>
        </trans-unit>
        <trans-unit id="16b9beb60bdc4afff878eec93b064cf17ba08cf6" translate="yes" xml:space="preserve">
          <source>Generate code that assumes that the data segment follows the text segment. This is the default.</source>
          <target state="translated">Сгенерируйте код,который предполагает,что сегмент данных следует за текстовым сегментом.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="336489e1da74ce723400b7df9bbae17f47d7009a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes the target has no space registers. This allows GCC to generate faster indirect calls and use unscaled index address modes.</source>
          <target state="translated">Сгенерируйте код,который предполагает,что у цели нет пробельных регистров.Это позволяет GCC генерировать более быстрые косвенные вызовы и использовать режимы немасштабируемых индексных адресов.</target>
        </trans-unit>
        <trans-unit id="918ffaae0c58edeaaf21af8db9990d1e80c480af" translate="yes" xml:space="preserve">
          <source>Generate code that does not use (uses) the floating-point register set. Software floating-point emulation is provided if you use the</source>
          <target state="translated">Сгенерировать код,который не использует (не использует)набор регистров с плавающей точкой.Программная эмуляция с плавающей запятой предоставляется,если Вы используете набор регистров с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="c1d77eef17962d23aa2b64213060026efae223d1" translate="yes" xml:space="preserve">
          <source>Generate code that does not use &lt;code&gt;.local&lt;/code&gt; memory directly for stack storage. Instead, a per-warp stack pointer is maintained explicitly. This enables variable-length stack allocation (with variable-length arrays or &lt;code&gt;alloca&lt;/code&gt;), and when global memory is used for underlying storage, makes it possible to access automatic variables from other threads, or with atomic instructions. This code generation variant is used for OpenMP offloading, but the option is exposed on its own for the purpose of testing the compiler; to generate code suitable for linking into programs using OpenMP offloading, use option</source>
          <target state="translated">Сгенерируйте код, который не использует &lt;code&gt;.local&lt;/code&gt; память напрямую для хранения стека. Вместо этого явно поддерживается указатель стека для каждой деформации. Это позволяет выделять стек переменной длины (с массивами переменной длины или &lt;code&gt;alloca&lt;/code&gt; ), а когда глобальная память используется для базового хранилища, дает возможность доступа к автоматическим переменным из других потоков или с помощью атомарных инструкций. Этот вариант генерации кода используется для разгрузки OpenMP, но этот вариант предоставляется отдельно с целью тестирования компилятора; чтобы сгенерировать код, подходящий для компоновки в программы с использованием разгрузки OpenMP, используйте опцию</target>
        </trans-unit>
        <trans-unit id="44ab5ca5f8364ad55909ace91a8c6e880674fbc6" translate="yes" xml:space="preserve">
          <source>Generate code that does not use a global pointer register. The result is not position independent code, and violates the IA-64 ABI.</source>
          <target state="translated">Сгенерировать код,который не использует глобальный регистр указателей.Результат не является позиционно-независимым кодом и нарушает IA-64 ABI.</target>
        </trans-unit>
        <trans-unit id="60de4e859809d0c4dc8e855c46af0110311ff144" translate="yes" xml:space="preserve">
          <source>Generate code that doesn&amp;rsquo;t assume ID-based shared libraries are being used. This is the default.</source>
          <target state="translated">Сгенерируйте код, который не предполагает использования общих библиотек на основе идентификаторов. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="354fbc6c3e514e9f7e68643c90303161a363d508" translate="yes" xml:space="preserve">
          <source>Generate code that is self-relocatable. This implies</source>
          <target state="translated">Сгенерируйте код,который будет самоустанавливающимся.Это подразумевает</target>
        </trans-unit>
        <trans-unit id="13b5daaeeae847dab7bba6f104ed44e1ab6ee054" translate="yes" xml:space="preserve">
          <source>Generate code that keeps (does not keeps) some integer operations adjacent so that the instructions can be fused together on power8 and later processors.</source>
          <target state="translated">Сгенерируйте код,который хранит (не хранит)некоторые целочисленные операции рядом,чтобы инструкции могли быть объединены на процессорах power8 и более поздних версиях.</target>
        </trans-unit>
        <trans-unit id="ebb2d4ebaa412c3ca6bb8549fd5605ffef2b8a3c" translate="yes" xml:space="preserve">
          <source>Generate code that passes function parameters and return values that (in the called function) are seen as registers &lt;code&gt;$0&lt;/code&gt; and up, as opposed to the GNU ABI which uses global registers &lt;code&gt;$231&lt;/code&gt; and up.</source>
          <target state="translated">Сгенерируйте код, который передает параметры функции и возвращаемые значения, которые (в вызываемой функции) рассматриваются как регистры от &lt;code&gt;$0&lt;/code&gt; и выше, в отличие от GNU ABI, который использует глобальные регистры &lt;code&gt;$231&lt;/code&gt; и выше.</target>
        </trans-unit>
        <trans-unit id="572a137e555b3b3423721fc0e3626b6e8b160c46" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;arch&lt;/var&gt;, which can be the name of a generic MIPS ISA, or the name of a particular processor. The ISA names are: &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код, работающий на &lt;var&gt;arch&lt;/var&gt; , который может быть именем общего MIPS ISA или именем конкретного процессора. Имена ISA: '</target>
        </trans-unit>
        <trans-unit id="e20973741c69f13efd8aaaa56fd8109762470570" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;cpu-type&lt;/var&gt;, which is the name of a system representing a certain processor type. Possible values for &lt;var&gt;cpu-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код, который работает с &lt;var&gt;cpu-type&lt;/var&gt; , который является именем системы, представляющей определенный тип процессора. Возможные значения для &lt;var&gt;cpu-type&lt;/var&gt; : '</target>
        </trans-unit>
        <trans-unit id="2afe5cce361ce178d21f1f9e300c77965e025f71" translate="yes" xml:space="preserve">
          <source>Generate code that supports calling between the ARM and Thumb instruction sets. Without this option, on pre-v5 architectures, the two instruction sets cannot be reliably used inside one program. The default is</source>
          <target state="translated">Сгенерируйте код,поддерживающий вызов между наборами инструкций ARM и Thumb.Без этой опции на архитектурах доv5 эти два набора команд не могут быть надежно использованы внутри одной программы.По умолчанию</target>
        </trans-unit>
        <trans-unit id="1e1b0c53abd34ffe18acaa9b5781550d29a84379" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method, but assumes that this library or executable won&amp;rsquo;t link against any other ID shared libraries. That allows the compiler to use faster code for jumps and calls.</source>
          <target state="translated">Сгенерируйте код, который поддерживает общие библиотеки с помощью метода идентификатора библиотеки, но предполагает, что эта библиотека или исполняемый файл не будет связываться с другими разделяемыми библиотеками идентификатора. Это позволяет компилятору использовать более быстрый код для переходов и вызовов.</target>
        </trans-unit>
        <trans-unit id="19a4d4ef1ca305d055c2c43578e68d17e9af2a97" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute in place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">Сгенерировать код,поддерживающий разделяемые библиотеки,с помощью метода библиотечного идентификатора.Это позволяет выполнять библиотеки на месте и разделяемые библиотеки в среде без управления виртуальной памятью.Этот вариант подразумевает</target>
        </trans-unit>
        <trans-unit id="d499e8859196b03e31f4b5d6d30e4cb073e79ae2" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute-in-place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">Сгенерировать код,поддерживающий разделяемые библиотеки,с помощью метода библиотечного идентификатора.Это позволяет использовать исполняемые и разделяемые библиотеки в среде без управления виртуальной памятью.Этот вариант подразумевает</target>
        </trans-unit>
        <trans-unit id="3080019b4a448b8d2f42e11601716bd17c75e272" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions.</source>
          <target state="translated">Сгенерируйте код,который пытается избежать (не избежать)использования индексированной загрузки или хранения инструкций.</target>
        </trans-unit>
        <trans-unit id="1d7d0f8dbe32444b165a61440094a0d21d656220" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions. These instructions can incur a performance penalty on Power6 processors in certain situations, such as when stepping through large arrays that cross a 16M boundary. This option is enabled by default when targeting Power6 and disabled otherwise.</source>
          <target state="translated">Сгенерируйте код,который пытается избежать (не избежать)использования индексированной загрузки или хранения инструкций.В некоторых ситуациях,например,при прохождении через большие массивы,пересекающие границу в 16М,эти инструкции могут привести к снижению производительности процессоров Power6.Этот параметр включен по умолчанию при нацеливании на Power6 и отключен в противном случае.</target>
        </trans-unit>
        <trans-unit id="bf98fe716d964a094592ad1d59afe4951cb9d36f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions, and also enable the use of built-in functions that allow more direct access to the AltiVec instruction set. You may also need to set</source>
          <target state="translated">Сгенерировать код,использующий (не использующий)инструкции AltiVec,а также разрешить использование встроенных функций,обеспечивающих более прямой доступ к набору инструкций AltiVec.Вам также может понадобиться установить</target>
        </trans-unit>
        <trans-unit id="2f5b28537613ef22817b9ba8bf63c4e1f2104514" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions. In 32-bit code, you cannot enable AltiVec instructions unless</source>
          <target state="translated">Сгенерировать код,который использует (не использует)инструкции AltiVec.В 32-битном коде вы не можете включить инструкции AltiVec,если только</target>
        </trans-unit>
        <trans-unit id="8c04238a31ea4511a013025b49118e3c3e42e84e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) ISEL instruction.</source>
          <target state="translated">Сгенерировать код,который использует (не использует)инструкцию ISEL.</target>
        </trans-unit>
        <trans-unit id="92155be900bc9933add2300c7a5d23503087ce0e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) VAX F and G floating-point arithmetic instead of IEEE single and double precision.</source>
          <target state="translated">Сгенерировать код,который использует (не использует)арифметику VAX F и G с плавающей точкой вместо арифметики одинарной и двойной точности IEEE.</target>
        </trans-unit>
        <trans-unit id="b95c7c98a27a75ea4aed9a1312a1f6d81d84fc5d" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP move to/from general purpose register instructions implemented on the POWER6X processor and other processors that support the extended PowerPC V2.05 architecture.</source>
          <target state="translated">Сгенерировать код,который использует (не использует)перемещение FP в/из регистров общего назначения,реализованных на процессоре POWER6X и других процессорах,поддерживающих расширенную архитектуру PowerPC V2.05.</target>
        </trans-unit>
        <trans-unit id="a2c4f9d3a1eb191b5662b1d07619055360c468c4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP round to integer instructions implemented on the POWER5+ processor and other processors that support the PowerPC V2.03 architecture.</source>
          <target state="translated">Генерируйте код,использующий (не использующий)FP-раунд к целочисленным инструкциям,реализованным на процессоре POWER5+и других процессорах,поддерживающих архитектуру PowerPC V2.03.</target>
        </trans-unit>
        <trans-unit id="46d6eec21f4fa802b85560d860276b9199fed94b" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the atomic quad word memory instructions. The</source>
          <target state="translated">Сгенерировать код,использующий (не использующий)атомарную инструкцию памяти из четырех слов.</target>
        </trans-unit>
        <trans-unit id="262e0fd3e027fbfbead855b3f29a870f608f4f72" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the compare bytes instruction implemented on the POWER6 processor and other processors that support the PowerPC V2.05 architecture.</source>
          <target state="translated">Генерировать код,использующий (не использующий)инструкцию сравнения байт,реализованную на процессоре POWER6 и других процессорах,поддерживающих архитектуру PowerPC V2.05.</target>
        </trans-unit>
        <trans-unit id="08b86aae00b13e22b96514a69b5b064be8919eb4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the decimal floating-point instructions implemented on some POWER processors.</source>
          <target state="translated">Сгенерируйте код,использующий (не использующий)десятичные инструкции с плавающей запятой,реализованные на некоторых процессорах POWER.</target>
        </trans-unit>
        <trans-unit id="3131d9ab648d637f7f2b9519e03b551e9a374743" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used.</source>
          <target state="translated">Сгенерировать код,использующий (не использующий)умножение с плавающей точкой,и накопить инструкции.Эти инструкции генерируются по умолчанию,если используется аппаратная плавающая запятая.</target>
        </trans-unit>
        <trans-unit id="c04a8a825b0f94e2eb07f4e8f21cb84241b2efaf" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used. The machine-dependent</source>
          <target state="translated">Сгенерировать код,использующий (не использующий)умножение с плавающей точкой,и накопить инструкции.Эти инструкции генерируются по умолчанию,если используется аппаратная плавающая запятая.Машинно-зависимый</target>
        </trans-unit>
        <trans-unit id="61eadf2cc65c85da3c9ba20e0d77a3b18047c546" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point register set.</source>
          <target state="translated">Сгенерировать код,который использует (не использует)набор регистров с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="32b3b39a373f02faec1c8e47cea1029610f3648e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the generation of PAIRED simd instructions.</source>
          <target state="translated">Сгенерировать код,который использует (не использует)генерацию PAIRED simd инструкций.</target>
        </trans-unit>
        <trans-unit id="a16384b2cc48decd8d149f4edeab3b4637c6c2dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the half-word multiply and multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors. These instructions are generated by default when targeting those processors.</source>
          <target state="translated">Сгенерируйте код,использующий (не использующий)инструкции по умножению полуслова и умножению на процессорах IBM 405,440,464 и 476.Эти инструкции генерируются по умолчанию при нацеливании на эти процессоры.</target>
        </trans-unit>
        <trans-unit id="0ae0cd2b0200a8b41b70cb257df1cc0c71cf4ea9" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions.</source>
          <target state="translated">Сгенерируйте код,который использует (не использует)инструкцию по загрузке нескольких слов и сохраняет инструкцию по загрузке нескольких слов.</target>
        </trans-unit>
        <trans-unit id="2c52b95b537c53566c2534b67e93882f9aca68b1" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions. These instructions are generated by default on POWER systems, and not generated on PowerPC systems. Do not use</source>
          <target state="translated">Сгенерируйте код,который использует (не использует)инструкцию по загрузке нескольких слов и сохраняет инструкцию по загрузке нескольких слов.Эти инструкции генерируются по умолчанию в системах POWER,а не в системах PowerPC.Не использовать</target>
        </trans-unit>
        <trans-unit id="fd774e2be13b8cb13d5052ff903f2b6dbbaa0be4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location.</source>
          <target state="translated">Сгенерировать код,использующий (не использующий)инструкции по загрузке или хранению,которые обновляют базовый регистр по адресу вычисленной ячейки памяти.</target>
        </trans-unit>
        <trans-unit id="a22e11f108e540ae0805ccbff5751fce923b96a4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location. These instructions are generated by default. If you use</source>
          <target state="translated">Сгенерировать код,использующий (не использующий)инструкции по загрузке или хранению,которые обновляют базовый регистр по адресу вычисленной ячейки памяти.Эти инструкции генерируются по умолчанию.Если вы используете</target>
        </trans-unit>
        <trans-unit id="0770f3e5c30f3b0aaaeba94f431ff5516808b06c" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load string instructions and the store string word instructions to save multiple registers and do small block moves.</source>
          <target state="translated">Сгенерируйте код,который использует (не использует)инструкции загрузочной строки и инструкции строкового слова хранилища для сохранения нескольких регистров и выполнения небольших блочных перемещений.</target>
        </trans-unit>
        <trans-unit id="386b3e18aecf301e2272c3303cef5b3408b3d72f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the move from condition register field instruction implemented on the POWER4 processor and other processors that support the PowerPC V2.01 architecture.</source>
          <target state="translated">Сгенерируйте код,использующий (не использующий)переход из поля регистров условий,реализованный на процессоре POWER4 и других процессорах,поддерживающих архитектуру PowerPC V2.01.</target>
        </trans-unit>
        <trans-unit id="87adae88954ee8917f3f31be376d9936d82cd4bc" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the non-atomic quad word memory instructions. The</source>
          <target state="translated">Сгенерировать код,использующий (не использующий)неатомные инструкции по памяти из четырех слов.</target>
        </trans-unit>
        <trans-unit id="fc8745a466eb796ef7f9c5a441c7003ed311977e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root.</source>
          <target state="translated">Сгенерируйте код,который использует (не использует)дополнительные инструкции архитектуры PowerPC в группе общего назначения,включая квадратный корень с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="27810752cbb1f58324d02017084ca261477ff314" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">Сгенерируйте код,который использует (не использует)дополнительные инструкции по архитектуре PowerPC в группе Графики,включая выбор с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="98f0227605ad4df08722181505cb7a14d55e9799" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount and double-precision FP reciprocal estimate instruction implemented on the POWER5 processor and other processors that support the PowerPC V2.02 architecture.</source>
          <target state="translated">Генерируйте код,использующий (не использующий)попконт и двойную прецизионную инструкцию взаимной оценки FP,реализованную на процессоре POWER5 и других процессорах,поддерживающих архитектуру PowerPC V2.02.</target>
        </trans-unit>
        <trans-unit id="c07537f1993a55be984ad5f397058498e67120dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount instruction implemented on the POWER7 processor and other processors that support the PowerPC V2.06 architecture.</source>
          <target state="translated">Сгенерируйте код,который использует (не использует)инструкцию popcount,реализованную на процессоре POWER7 и других процессорах,поддерживающих архитектуру PowerPC V2.06.</target>
        </trans-unit>
        <trans-unit id="4b15de7f2b7f03ed6e1790dbf982c588fb5b3528" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the string-search &amp;lsquo;</source>
          <target state="translated">Сгенерировать код, который использует (не использует) поиск по строке '</target>
        </trans-unit>
        <trans-unit id="ab7a2922566d7313797a3ac188f3c0be7688df71" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the vector and scalar instructions that were added in version 2.07 of the PowerPC ISA. Also enable the use of built-in functions that allow more direct access to the vector instructions.</source>
          <target state="translated">Сгенерируйте код,который использует (не использует)векторные и скалярные инструкции,которые были добавлены в версию 2.07 PowerPC ISA.Также включить использование встроенных функций,обеспечивающих более прямой доступ к векторным инструкциям.</target>
        </trans-unit>
        <trans-unit id="f7dd4f67d21a30765965ab7e7de435cac230ac64" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set.</source>
          <target state="translated">Сгенерировать код,использующий (не использующий)векторные/скалярные (VSX)инструкции,а также разрешить использование встроенных функций,обеспечивающих более прямой доступ к набору инструкций VSX.</target>
        </trans-unit>
        <trans-unit id="05ca89c3814bc0cbed05cab7398d230442544564" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set. In 32-bit code, you cannot enable VSX or AltiVec instructions unless</source>
          <target state="translated">Сгенерировать код,использующий (не использующий)векторные/скалярные (VSX)инструкции,а также разрешить использование встроенных функций,обеспечивающих более прямой доступ к набору инструкций VSX.В 32-битном коде нельзя включить инструкции VSX или AltiVec,если только</target>
        </trans-unit>
        <trans-unit id="67b86bb995294b5ded4deb3fb6384281013e8cde" translate="yes" xml:space="preserve">
          <source>Generate code that uses a BSS &lt;code&gt;.plt&lt;/code&gt; section that &lt;code&gt;ld.so&lt;/code&gt; fills in, and requires &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections that are both writable and executable. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">Сгенерируйте код, который использует раздел BSS &lt;code&gt;.plt&lt;/code&gt; , который заполняет &lt;code&gt;ld.so&lt;/code&gt; , и требует, &lt;code&gt;.got&lt;/code&gt; разделы &lt;code&gt;.plt&lt;/code&gt; и .got были как записываемыми, так и исполняемыми. Это 32-битная опция SYSV ABI PowerPC.</target>
        </trans-unit>
        <trans-unit id="6beeb427ddc734bea4c58516baa43a91d09099d2" translate="yes" xml:space="preserve">
          <source>Generate code that uses a single constant global pointer value. This is useful when compiling kernel code.</source>
          <target state="translated">Сгенерировать код,использующий одно постоянное значение глобального указателя.Это полезно при компиляции кода кернела.</target>
        </trans-unit>
        <trans-unit id="6f2e6ea4728870634a5f76e2497b052f725aed62" translate="yes" xml:space="preserve">
          <source>Generate code that uses long call sequences. This ensures that a call is always able to reach linker generated stubs. The default is to generate long calls only when the distance from the call site to the beginning of the function or translation unit, as the case may be, exceeds a predefined limit set by the branch type being used. The limits for normal calls are 7,600,000 and 240,000 bytes, respectively for the PA 2.0 and PA 1.X architectures. Sibcalls are always limited at 240,000 bytes.</source>
          <target state="translated">Сгенерировать код,использующий длинные последовательности вызовов.Это гарантирует,что вызов всегда сможет связаться с корешками,сгенерированными компоновщиком.По умолчанию генерировать длинные вызовы можно только в том случае,если расстояние от места вызова до начала функции или блока трансляции,в зависимости от случая,превышает предопределенный предел,установленный используемым типом ветки.Пределы для обычных вызовов составляют 7 600 000 и 240 000 байт соответственно для архитектур PA 2.0 и PA 1.X.Ограничение Sibcalls всегда составляет 240 000 байт.</target>
        </trans-unit>
        <trans-unit id="0ddfa4b3d16d23a89e5776522951b15e62426fdc" translate="yes" xml:space="preserve">
          <source>Generate code that uses only the general-purpose registers. This prevents the compiler from using floating-point, vector, mask and bound registers.</source>
          <target state="translated">Сгенерировать код,использующий только регистры общего назначения.Это не позволяет компилятору использовать регистры с плавающей точкой,векторные,масочные и связанные регистры.</target>
        </trans-unit>
        <trans-unit id="baac973b3b5994adc6aef021db0133816bd28382" translate="yes" xml:space="preserve">
          <source>Generate code to access thread-local storage using the &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код для доступа к локальному хранилищу потока с помощью '</target>
        </trans-unit>
        <trans-unit id="c88cdcf77b77d16255b95669179f017ca5ceda39" translate="yes" xml:space="preserve">
          <source>Generate code to automatically split the stack before it overflows. The resulting program has a discontiguous stack which can only overflow if the program is unable to allocate any more memory. This is most useful when running threaded programs, as it is no longer necessary to calculate a good stack size to use for each thread. This is currently only implemented for the x86 targets running GNU/Linux.</source>
          <target state="translated">Сгенерировать код для автоматического разделения стека до его переполнения.Результирующая программа имеет запутанный стек,который может переполниться только в том случае,если программа не сможет выделить больше памяти.Это наиболее полезно при выполнении потоковых программ,так как больше нет необходимости рассчитывать хороший размер стека для каждого потока.В настоящее время это реализовано только для x86-мишеней под управлением GNU/Linux.</target>
        </trans-unit>
        <trans-unit id="915ccec10fdc8928f52708c97467282540464b8a" translate="yes" xml:space="preserve">
          <source>Generate code to avoid bugs in the multiply instructions for the MN10300 processors. This is the default.</source>
          <target state="translated">Сгенерируйте код,чтобы избежать ошибок в инструкциях по умножению для процессоров MN10300.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="0df3e04d22344e23f6649b40a52c7d6f0c186350" translate="yes" xml:space="preserve">
          <source>Generate code to ensure that the stack does not grow beyond a certain value, either the value of a register or the address of a symbol. If a larger stack is required, a signal is raised at run time. For most targets, the signal is raised before the stack overruns the boundary, so it is possible to catch the signal without taking special precautions.</source>
          <target state="translated">Сгенерируйте код,чтобы гарантировать,что стек не вырастет за пределы определенного значения,как значения регистра,так и адреса символа.Если требуется увеличение стека,сигнал поднимается во время выполнения.Для большинства целей сигнал поднимается до того,как стек преодолеет границу,поэтому можно поймать сигнал,не принимая специальных мер предосторожности.</target>
        </trans-unit>
        <trans-unit id="1b66c9f22b9ae2f51f7b68dcb90be43a732528ba" translate="yes" xml:space="preserve">
          <source>Generate code to prevent stack clash style attacks. When this option is enabled, the compiler will only allocate one page of stack space at a time and each page is accessed immediately after allocation. Thus, it prevents allocations from jumping over any stack guard page provided by the operating system.</source>
          <target state="translated">Сгенерировать код для предотвращения атак в стиле стека.Когда эта опция включена,компилятор будет выделять только одну страницу стекового пространства за раз,и доступ к каждой странице будет осуществляться сразу после выделения.Таким образом,это предотвращает перепрыгивание выделенного пространства через любую страницу защиты стека,предоставляемую операционной системой.</target>
        </trans-unit>
        <trans-unit id="dd0c489c581360afbf7f7a5091b3992e53e109af" translate="yes" xml:space="preserve">
          <source>Generate code to verify that you do not go beyond the boundary of the stack. You should specify this flag if you are running in an environment with multiple threads, but you only rarely need to specify it in a single-threaded environment since stack overflow is automatically detected on nearly all systems if there is only one stack.</source>
          <target state="translated">Сгенерируйте код,чтобы убедиться,что вы не выходите за границы стека.Этот флаг следует указывать,если вы работаете в окружении с несколькими потоками,но в однопоточном окружении он требуется лишь в редких случаях,так как переполнение стека автоматически обнаруживается почти на всех системах,если есть только один стек.</target>
        </trans-unit>
        <trans-unit id="f09658f66e71e4832575a43871e37604d20cbdbd" translate="yes" xml:space="preserve">
          <source>Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator cannot use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma.</source>
          <target state="translated">Сгенерируйте код,обрабатывающий данный диапазон регистров как фиксированные регистры.Фиксированный регистр-это регистр,который аллокатор регистра не может использовать.Это полезно при компиляции кода кернела.Диапазон регистров указывается как два регистра,разделенных тире.Несколько диапазонов регистров можно указать,разделенных запятой.</target>
        </trans-unit>
        <trans-unit id="69365c978ad182890bcb4e65e053170c8830231a" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; instructions. This option defaults to on.</source>
          <target state="translated">Сгенерируйте код с &lt;code&gt;push&lt;/code&gt; инструкций push и &lt;code&gt;pop&lt;/code&gt; . По умолчанию эта опция включена.</target>
        </trans-unit>
        <trans-unit id="7f296d4ed278effc8fa87bfb0e530628874d3432" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;stm&lt;/code&gt; and &lt;code&gt;ldm&lt;/code&gt; instructions. This option isn&amp;rsquo;t supported on CK801 but is enabled by default on other processors.</source>
          <target state="translated">Сгенерируйте код, используя инструкции &lt;code&gt;stm&lt;/code&gt; и &lt;code&gt;ldm&lt;/code&gt; . Эта опция не поддерживается на CK801, но включена по умолчанию на других процессорах.</target>
        </trans-unit>
        <trans-unit id="ba4d33b91d9e6ab2d69e87dce44c7244b439ed9e" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33 processor.</source>
          <target state="translated">Сгенерируйте код,используя функции,характерные для процессора AM33.</target>
        </trans-unit>
        <trans-unit id="b0f3f1a0016506b7432a6808d95156263172db1a" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33/2.0 processor.</source>
          <target state="translated">Сгенерируйте код,используя функции,характерные для процессора AM33/2.0.</target>
        </trans-unit>
        <trans-unit id="4d51b4beaa1d3a18f186ce7d15002cb82d47e204" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM34 processor.</source>
          <target state="translated">Сгенерируйте код,используя функции,характерные для процессора AM34.</target>
        </trans-unit>
        <trans-unit id="c282f618bb7db95f0feff29b3266b2478e4e252b" translate="yes" xml:space="preserve">
          <source>Generate code using global anchor symbol addresses.</source>
          <target state="translated">Сгенерировать код,используя глобальные адреса символов якоря.</target>
        </trans-unit>
        <trans-unit id="cb509e9252b480e0a1aeb49faf8b1ef18fa7edf6" translate="yes" xml:space="preserve">
          <source>Generate code using the FDPIC ABI.</source>
          <target state="translated">Сгенерируйте код,используя FDPIC ABI.</target>
        </trans-unit>
        <trans-unit id="404e8a65099de95616c40afb1bc863ffa2523650" translate="yes" xml:space="preserve">
          <source>Generate code using the high registers numbered 16-31. This option is not supported on CK801, CK802, or CK803, and is enabled by default for other processors.</source>
          <target state="translated">Сгенерируйте код,используя высокие регистры,пронумерованные 16-31.Эта опция не поддерживается на CK801,CK802 или CK803,и включена по умолчанию для других процессоров.</target>
        </trans-unit>
        <trans-unit id="4cb05ce3f6ef091d20d86e01a77fc7f4a59d0bcc" translate="yes" xml:space="preserve">
          <source>Generate code which uses only the general-purpose registers. This will prevent the compiler from using floating-point and Advanced SIMD registers but will not impose any restrictions on the assembler.</source>
          <target state="translated">Сгенерировать код,который использует только регистры общего назначения.Это не позволит компилятору использовать регистры с плавающей точкой и расширенные SIMD,но не наложит никаких ограничений на ассемблер.</target>
        </trans-unit>
        <trans-unit id="9cce76ef82a38c3b96967249a0f61e0fb26b9334" translate="yes" xml:space="preserve">
          <source>Generate compiler predefines and select a startfile for the specified UNIX standard. The choices for &lt;var&gt;unix-std&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">Сгенерируйте предопределения компилятора и выберите начальный файл для указанного стандарта UNIX. Варианты для &lt;var&gt;unix-std&lt;/var&gt; : '</target>
        </trans-unit>
        <trans-unit id="a678e34a31471d170303da9eda1b930e2324a992" translate="yes" xml:space="preserve">
          <source>Generate conditional move instructions.</source>
          <target state="translated">Сгенерировать условные инструкции по перемещению.</target>
        </trans-unit>
        <trans-unit id="d72e8c8e0f9b51ca898631ea4a5646d5c76664c2" translate="yes" xml:space="preserve">
          <source>Generate divide instructions. Default is off.</source>
          <target state="translated">Сгенерируйте инструкции по разделению.По умолчанию выключено.</target>
        </trans-unit>
        <trans-unit id="16d77d1fe0a8bda494d3925636feea2c269c0e3f" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">Сгенерируйте инструкции по FPX с двойной точностью,настроенные для компактной реализации.</target>
        </trans-unit>
        <trans-unit id="c229df63f7c476d6f9fecd75b4ac0f6491159589" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">Сгенерируйте инструкции по FPX с двойной точностью,настроенные для быстрой реализации.</target>
        </trans-unit>
        <trans-unit id="efd3351263c1d9caa26ca401350421bfc7b35243" translate="yes" xml:space="preserve">
          <source>Generate extended arithmetic instructions. Currently only &lt;code&gt;divaw&lt;/code&gt;, &lt;code&gt;adds&lt;/code&gt;, &lt;code&gt;subs&lt;/code&gt;, and &lt;code&gt;sat16&lt;/code&gt; are supported. This is always enabled for</source>
          <target state="translated">Создавайте расширенные арифметические инструкции. В настоящее время только &lt;code&gt;divaw&lt;/code&gt; , &lt;code&gt;adds&lt;/code&gt; , &lt;code&gt;subs&lt;/code&gt; и &lt;code&gt;sat16&lt;/code&gt; поддерживаются. Это всегда включено для</target>
        </trans-unit>
        <trans-unit id="6856e99222352076039e94fbdf5c31806c05feaa" translate="yes" xml:space="preserve">
          <source>Generate extended debug information for inlined functions. Location view tracking markers are inserted at inlined entry points, so that address and view numbers can be computed and output in debug information. This can be enabled independently of location views, in which case the view numbers won&amp;rsquo;t be output, but it can only be enabled along with statement frontiers, and it is only enabled by default if location views are enabled.</source>
          <target state="translated">Создание расширенной отладочной информации для встроенных функций. Маркеры отслеживания представления местоположения вставляются во встроенные точки входа, так что номера адресов и представлений могут быть вычислены и выведены в отладочной информации. Это можно включить независимо от представлений местоположения, и в этом случае номера представлений не будут выводиться, но его можно включить только вместе с границами операторов, и он включен по умолчанию, только если включены представления местоположения.</target>
        </trans-unit>
        <trans-unit id="5d0b2408362730cc5b4ed897b120cdb4b4cc4031" translate="yes" xml:space="preserve">
          <source>Generate extra code to write profile information suitable for the analysis program &lt;code&gt;prof&lt;/code&gt; (for</source>
          <target state="translated">Сгенерируйте дополнительный код для записи информации профиля, подходящей для программы анализа &lt;code&gt;prof&lt;/code&gt; (для</target>
        </trans-unit>
        <trans-unit id="c6eeb91a33862dbf10594e59a0033583feb5fde5" translate="yes" xml:space="preserve">
          <source>Generate floating-point arithmetic for selected unit &lt;var&gt;unit&lt;/var&gt;. The choices for &lt;var&gt;unit&lt;/var&gt; are:</source>
          <target state="translated">Сгенерировать арифметику с плавающей запятой для выбранной единицы &lt;var&gt;unit&lt;/var&gt; . Выбор для &lt;var&gt;unit&lt;/var&gt; являются:</target>
        </trans-unit>
        <trans-unit id="79ec4a91ff56b1468e2e0960559756f702528e59" translate="yes" xml:space="preserve">
          <source>Generate floating-point comparison instructions that compare with respect to the &lt;code&gt;rE&lt;/code&gt; epsilon register.</source>
          <target state="translated">Сгенерируйте инструкции сравнения с плавающей запятой, которые сравнивают относительно регистра &lt;code&gt;rE&lt;/code&gt; epsilon.</target>
        </trans-unit>
        <trans-unit id="5184b7fbfd727379c1835aa4d91abffedcc6f989" translate="yes" xml:space="preserve">
          <source>Generate floating-point instructions. This is the default for 68020 and above, and for ColdFire devices that have an FPU. It defines the macro &lt;code&gt;__HAVE_68881__&lt;/code&gt; on M680x0 targets and &lt;code&gt;__mcffpu__&lt;/code&gt; on ColdFire targets.</source>
          <target state="translated">Сгенерируйте инструкции с плавающей запятой. Это значение по умолчанию для 68020 и выше, а также для устройств ColdFire с FPU. Он определяет макрос &lt;code&gt;__HAVE_68881__&lt;/code&gt; для целей &lt;code&gt;__mcffpu__&lt;/code&gt; и __mcffpu__ для целей ColdFire.</target>
        </trans-unit>
        <trans-unit id="6ff3989b144109cfd18ff049af7f71f4c3c9f86e" translate="yes" xml:space="preserve">
          <source>Generate hardware atomic sequences using the &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; instructions only. This is only available on SH4A and is suitable for multi-core systems. Since the hardware instructions support only 32 bit atomic variables access to 8 or 16 bit variables is emulated with 32 bit accesses. Code compiled with this option is also compatible with other software atomic model interrupt/exception handling systems if executed on an SH4A system. Additional support from the interrupt/exception handling code of the system is not required for this model.</source>
          <target state="translated">Создавайте аппаратные атомарные последовательности, используя только инструкции &lt;code&gt;movli.l&lt;/code&gt; и &lt;code&gt;movco.l&lt;/code&gt; . Это доступно только на SH4A и подходит для многоядерных систем. Поскольку аппаратные инструкции поддерживают только 32-битные атомарные переменные, доступ к 8- или 16-битным переменным эмулируется с 32-битным доступом. Код, скомпилированный с этой опцией, также совместим с другими системами обработки прерываний / исключений атомарной модели, если он выполняется в системе SH4A. Дополнительная поддержка со стороны кода обработки прерываний / исключений системы для этой модели не требуется.</target>
        </trans-unit>
        <trans-unit id="d8debf693e895754ae8dfa412a7398684e52957b" translate="yes" xml:space="preserve">
          <source>Generate instructions for the machine type &lt;var&gt;cpu-type&lt;/var&gt;. In contrast to</source>
          <target state="translated">Сгенерируйте инструкции для машины типа &lt;var&gt;cpu-type&lt;/var&gt; . В отличие от</target>
        </trans-unit>
        <trans-unit id="4d9806e63398f5c7206d46ddf2dd393879704321" translate="yes" xml:space="preserve">
          <source>Generate instructions supported by barrel shifter. This is the default unless</source>
          <target state="translated">Сгенерируйте инструкции,поддерживаемые перекидчиком ствола.По умолчанию,если только</target>
        </trans-unit>
        <trans-unit id="a86b264be3b7927eef8b4d4ec32bd6e0abb23e9a" translate="yes" xml:space="preserve">
          <source>Generate instrumentation calls for entry and exit to functions. Just after function entry and just before function exit, the following profiling functions are called with the address of the current function and its call site. (On some platforms, &lt;code&gt;__builtin_return_address&lt;/code&gt; does not work beyond the current function, so the call site information may not be available to the profiling functions otherwise.)</source>
          <target state="translated">Генерация инструментальных вызовов для входа и выхода из функций. Сразу после входа в функцию и непосредственно перед выходом из функции вызываются следующие функции профилирования с адресом текущей функции и местом ее вызова. (На некоторых платформах &lt;code&gt;__builtin_return_address&lt;/code&gt; не работает за пределами текущей функции, поэтому в противном случае информация о сайте вызова может быть недоступна для функций профилирования.)</target>
        </trans-unit>
        <trans-unit id="a558056c364dd801f66dea4bd9ff5d7025049fb1" translate="yes" xml:space="preserve">
          <source>Generate little-endian (default) or big-endian (experimental) code, respectively.</source>
          <target state="translated">Сгенерировать little-endian (по умолчанию)или big-endian (экспериментальный)код,соответственно.</target>
        </trans-unit>
        <trans-unit id="8c624983438064d33fb3b88653aa23aaa51afa20" translate="yes" xml:space="preserve">
          <source>Generate little-endian code.</source>
          <target state="translated">Сгенерируй мелкомасштабный код.</target>
        </trans-unit>
        <trans-unit id="d362bc65e7c53091f19c9e25dc0b1f5baf698d4a" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код с прямым порядком байтов. Это значение по умолчанию для '</target>
        </trans-unit>
        <trans-unit id="66047ec2f64b4bd1b8fdd5fa2877f3f85b442eac" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код с прямым порядком байтов. Это значение по умолчанию, когда GCC настроен для '</target>
        </trans-unit>
        <trans-unit id="e76d98abdce9e7fa1b4a7b7f0a6241f584dc592c" translate="yes" xml:space="preserve">
          <source>Generate mul.x and umul.x instructions. This is the default for &amp;lsquo;</source>
          <target state="translated">Сгенерируйте инструкции mul.x и umul.x. Это значение по умолчанию для '</target>
        </trans-unit>
        <trans-unit id="11b3830c8f1fe1ef2c6dc043ba7fa4b0665f2d6d" translate="yes" xml:space="preserve">
          <source>Generate non-looping inline code for all block compares (such as calls to &lt;code&gt;memcmp&lt;/code&gt; or structure compares) less than or equal to &lt;var&gt;num&lt;/var&gt; bytes. If &lt;var&gt;num&lt;/var&gt; is 0, all inline expansion (non-loop and loop) of block compare is disabled. The default value is target-specific.</source>
          <target state="translated">Сформировать без зацикливания встроенного кода для всех блоков сравнения (например, вызовы &lt;code&gt;memcmp&lt;/code&gt; или структура сравнивает) меньше или равно &lt;var&gt;num&lt;/var&gt; байты. Если &lt;var&gt;num&lt;/var&gt; равно 0, все встроенные расширения (без цикла и цикла) сравнения блоков отключены. Значение по умолчанию зависит от цели.</target>
        </trans-unit>
        <trans-unit id="726e8e558f2a846b8999b9aeb3c7faa8d320b08e" translate="yes" xml:space="preserve">
          <source>Generate object code compatible with the standard GNU Objective-C runtime. This is the default for most types of systems.</source>
          <target state="translated">Сгенерируйте объектный код,совместимый со стандартной средой выполнения GNU Objective-C.Это стандартное время выполнения для большинства типов систем.</target>
        </trans-unit>
        <trans-unit id="5f828fdb836a3167f3a117e320f8c23966c29566" translate="yes" xml:space="preserve">
          <source>Generate output compatible with the NeXT runtime. This is the default for NeXT-based systems, including Darwin and Mac OS X. The macro &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; is predefined if (and only if) this option is used.</source>
          <target state="translated">Создавайте выходные данные, совместимые со средой выполнения NeXT. Это значение по умолчанию для систем на основе NeXT, включая Darwin и Mac OS X. Макрос &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; предопределен, если (и только если) используется этот параметр.</target>
        </trans-unit>
        <trans-unit id="3b10b8584ef5629375b0697c006157af2562811c" translate="yes" xml:space="preserve">
          <source>Generate output containing 80387 instructions for floating point.</source>
          <target state="translated">Сгенерируйте выход,содержащий 80387 инструкций для плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="4ac64fa385d79df6893e650d3c87094e5fab8e8d" translate="yes" xml:space="preserve">
          <source>Generate output containing floating-point instructions. This is the default.</source>
          <target state="translated">Сгенерируйте выход,содержащий инструкции с плавающей запятой.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="a54c9d559afdf54011312401dae184f34851998d" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point.</source>
          <target state="translated">Сгенерировать вывод,содержащий вызовы библиотек с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="b68715959fa47ba0ff79de672b756a42be41a84c" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all HPPA targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">Создание вывода, содержащего вызовы библиотеки для чисел с плавающей запятой. &lt;strong&gt;Предупреждение:&lt;/strong&gt; необходимые библиотеки доступны не для всех целей HPPA. Обычно используются возможности обычного машинного компилятора C, но это невозможно сделать напрямую в кросс-компиляции. Вы должны принять собственные меры, чтобы предоставить подходящие библиотечные функции для кросс-компиляции.</target>
        </trans-unit>
        <trans-unit id="123686fdd6543b04616633629545ce470b234181" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all SPARC targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation. The embedded targets &amp;lsquo;</source>
          <target state="translated">Создание вывода, содержащего вызовы библиотеки для чисел с плавающей запятой. &lt;strong&gt;Предупреждение:&lt;/strong&gt; необходимые библиотеки доступны не для всех целей SPARC. Обычно используются возможности обычного машинного компилятора C, но это невозможно сделать напрямую в кросс-компиляции. Вы должны принять собственные меры, чтобы предоставить подходящие библиотечные функции для кросс-компиляции. Встроенные цели '</target>
        </trans-unit>
        <trans-unit id="374b214aae9f131ecd8bd8fbf3ba7e20116baf86" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for quad-word (long double) floating-point instructions. The functions called are those specified in the SPARC ABI. This is the default.</source>
          <target state="translated">Сгенерировать вывод,содержащий библиотечные вызовы для четырехсловных (длинных двойных)инструкций с плавающей точкой.Вызванные функции являются функциями,указанными в ABI SPARC.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="e778386ad4f7c29303d76d557065f8b2cddd1a1e" translate="yes" xml:space="preserve">
          <source>Generate output containing quad-word (long double) floating-point instructions.</source>
          <target state="translated">Сгенерируйте выход,содержащий четырехсловную (длинную двойную)инструкцию с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="72b8d6815f1c63fef196e30ed85ba66e28021cd2" translate="yes" xml:space="preserve">
          <source>Generate output for a 5206e ColdFire CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">Сгенерируйте выход для процессора ColdFire 5206e.Опция теперь устарела в пользу эквивалента</target>
        </trans-unit>
        <trans-unit id="64050f292f81abd70f3bb1391b078794170aa43c" translate="yes" xml:space="preserve">
          <source>Generate output for a 520X ColdFire CPU. This is the default when the compiler is configured for 520X-based systems. It is equivalent to</source>
          <target state="translated">Сгенерируйте выход для процессора 520X ColdFire.По умолчанию компилятор сконфигурирован для систем на базе 520X.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="4e6125bf5e16c60081ffba73c18391756b953da9" translate="yes" xml:space="preserve">
          <source>Generate output for a 68000. This is the default when the compiler is configured for 68000-based systems. It is equivalent to</source>
          <target state="translated">Сгенерируйте мощность для 68000.По умолчанию компилятор сконфигурирован для систем на базе 68000.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="293fc36513894f8af34456d5d4568e3a8a660df3" translate="yes" xml:space="preserve">
          <source>Generate output for a 68010. This is the default when the compiler is configured for 68010-based systems. It is equivalent to</source>
          <target state="translated">Сгенерируйте выход для 68010.По умолчанию компилятор сконфигурирован для систем на базе 68010.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="3de0124e7fb5a143b3bdb1e5bf42ea00b8dc1041" translate="yes" xml:space="preserve">
          <source>Generate output for a 68020. This is the default when the compiler is configured for 68020-based systems. It is equivalent to</source>
          <target state="translated">Генерируйте мощность для 68020.По умолчанию компилятор сконфигурирован для систем на базе 68020.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="a2125889bc447fbbe5141c63e65b9cc93af2774c" translate="yes" xml:space="preserve">
          <source>Generate output for a 68030. This is the default when the compiler is configured for 68030-based systems. It is equivalent to</source>
          <target state="translated">Генерируйте мощность для 68030.По умолчанию компилятор сконфигурирован для систем на базе 68030.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="dcd8a9aedf0282928a86db993cf8d4ff8070b038" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68040.</source>
          <target state="translated">Сгенерируйте выход для 68040,без использования новой инструкции.В результате получается код,который может относительно эффективно работать либо на 68020/68881,либо на 68030 или 68040.Генерируемый код использует инструкции 68881,которые эмулируются на 68040.</target>
        </trans-unit>
        <trans-unit id="dd4119d908a2b18c651ef46f26b46cd2bc8b0de2" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040. This is the default when the compiler is configured for 68040-based systems. It is equivalent to</source>
          <target state="translated">Генерируйте мощность для 68040.По умолчанию компилятор сконфигурирован для систем на базе 68040.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="c0e33f0f063c998bb9f2f1ad28f52830efcc367f" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68060.</source>
          <target state="translated">Сгенерируйте выход для 68060,без использования каких-либо новых инструкций.В результате получается код,который может относительно эффективно работать либо на 68020/68881,либо на 68030 или 68040.Генерируемый код использует инструкции 68881,которые эмулируются на 68060.</target>
        </trans-unit>
        <trans-unit id="4e0aa817ee3651021250220786d7a8ddadf8d908" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060. This is the default when the compiler is configured for 68060-based systems. It is equivalent to</source>
          <target state="translated">Генерируйте мощность для 68060.По умолчанию компилятор сконфигурирован для систем на базе 68060.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="ea5be8485d83583c41e5d8584b5916331ad44880" translate="yes" xml:space="preserve">
          <source>Generate output for a CPU32. This is the default when the compiler is configured for CPU32-based systems. It is equivalent to</source>
          <target state="translated">Сгенерируйте выход для CPU32.По умолчанию компилятор сконфигурирован для систем на базе CPU32.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="e1d15ac03ce80d2a7972245b867ea55ebdb92c9b" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5307 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">Сгенерируйте выход для процессора ColdFire 5307.Опция теперь устарела в пользу эквивалента</target>
        </trans-unit>
        <trans-unit id="8e01c68482064d3161a9a189e69a1cae2c323dfb" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5407 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">Сгенерируйте выход для процессора ColdFire 5407.Опция теперь устарела в пользу эквивалента</target>
        </trans-unit>
        <trans-unit id="0aa9f4c3f64933730b3c4adacac26f4b2456673a" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire V4e family CPU (e.g. 547x/548x). This includes use of hardware floating-point instructions. The option is equivalent to</source>
          <target state="translated">Сгенерируйте выход для процессора семейства ColdFire V4e (например,547x/548x).Это включает в себя использование аппаратных инструкций с плавающей запятой.Опция эквивалентна</target>
        </trans-unit>
        <trans-unit id="e7347e49e1182821745b1b659d00df4d824a3e04" translate="yes" xml:space="preserve">
          <source>Generate output for a member of the ColdFire 528X family. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">Сгенерируйте выход для члена семейства ColdFire 528X.Опция теперь устарела в пользу эквивалента</target>
        </trans-unit>
        <trans-unit id="18dcb26797382565521c621a512430444b4e53d3" translate="yes" xml:space="preserve">
          <source>Generate performance extension 2 instructions.</source>
          <target state="translated">Сгенерировать расширение производительности 2 инструкции.</target>
        </trans-unit>
        <trans-unit id="bd6544f4b4eb02ec7c1103af517606738fd2ba09" translate="yes" xml:space="preserve">
          <source>Generate performance extension instructions.</source>
          <target state="translated">Сгенерируйте инструкции по увеличению производительности.</target>
        </trans-unit>
        <trans-unit id="d399ee7f07dc0a2fb4ab33398b031c9b688f806f" translate="yes" xml:space="preserve">
          <source>Generate position-independent EABI code.</source>
          <target state="translated">Сгенерировать позиционно-независимый код EABI.</target>
        </trans-unit>
        <trans-unit id="1d1142004c8111e7c50b740035c14c26ae3a4d40" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine. Such code accesses all constant addresses through a global offset table (GOT). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system). If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that</source>
          <target state="translated">Сгенерируйте позиционно-независимый код (PIC),подходящий для использования в общей библиотеке,если он поддерживается для целевой машины.Такой код получает доступ ко всем постоянным адресам через глобальную таблицу смещения (GOT).Динамический загрузчик разрешает записи GOT при запуске программы (динамический загрузчик не является частью GCC;он является частью операционной системы).Если размер GOT для связанного исполняемого файла превышает максимальный размер для конкретной машины,то линкер выдает сообщение об ошибке,указывающее на то,что</target>
        </trans-unit>
        <trans-unit id="48b952028eaadcc5cf5b2652a4f09475aac1135d" translate="yes" xml:space="preserve">
          <source>Generate secure code as per the &quot;ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification&quot;, which can be found on &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">Сгенерируйте безопасный код в соответствии со &amp;laquo;Расширениями безопасности ARMv8-M: Требования к технической спецификации средств разработки&amp;raquo;, которые можно найти по &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;адресу http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0. pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61825c7f7fe0283dfaa12a0bf7f79986a97151b2" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">Сгенерируйте инструкции по FPX с одинаковой точностью,настроенные для компактной реализации.</target>
        </trans-unit>
        <trans-unit id="57fc66010a803fb795da295b4fbe9fac5a8dbfd1" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">Сгенерируйте инструкции по FPX с одинарной точностью,настроенные для быстрого выполнения.</target>
        </trans-unit>
        <trans-unit id="03e730324ac713e9445bac5587ed90df17b4e2e3" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that temporarily disable interrupts by setting &lt;code&gt;SR.IMASK = 1111&lt;/code&gt;. This model works only when the program runs in privileged mode and is only suitable for single-core systems. Additional support from the interrupt/exception handling code of the system is not required. This model is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH1* or SH2*.</source>
          <target state="translated">Сгенерируйте программные атомарные последовательности, которые временно отключают прерывания, задав &lt;code&gt;SR.IMASK = 1111&lt;/code&gt; . Эта модель работает только при запуске программы в привилегированном режиме и подходит только для одноядерных систем. Дополнительная поддержка со стороны кода обработки прерываний / исключений системы не требуется. Эта модель включена по умолчанию, если целью является &lt;code&gt;sh*-*-linux*&lt;/code&gt; и SH1 * или SH2 *.</target>
        </trans-unit>
        <trans-unit id="adcbfbeac80cfe6a3e4b55a0bdfaf3f19f30fbea" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that use a variable in the thread control block. This is a variation of the gUSA sequences which can also be used on SH1* and SH2* targets. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for single-core systems. When using this model, the &amp;lsquo;</source>
          <target state="translated">Сгенерируйте программные атомарные последовательности, которые используют переменную в блоке управления потоком. Это вариант последовательностей gUSA, который также можно использовать на мишенях SH1 * и SH2 *. Сгенерированные атомарные последовательности требуют дополнительной поддержки со стороны кода обработки прерываний / исключений системы и подходят только для одноядерных систем. При использовании этой модели '</target>
        </trans-unit>
        <trans-unit id="7e273affad800c8c4cf1d009bbdccfc4d50d0a21" translate="yes" xml:space="preserve">
          <source>Generate stack protection code using canary at &lt;var&gt;guard&lt;/var&gt;. Supported locations are &amp;lsquo;</source>
          <target state="translated">Сгенерируйте код защиты стека с помощью canary at &lt;var&gt;guard&lt;/var&gt; . Поддерживаемые местоположения: '</target>
        </trans-unit>
        <trans-unit id="b8a639f56facade8c98595f71ed5d4db9ac64830" translate="yes" xml:space="preserve">
          <source>Generate string extension instructions.</source>
          <target state="translated">Сгенерировать инструкции по расширению строк.</target>
        </trans-unit>
        <trans-unit id="8a1f94259681f1ae170bbb57344c845c25fbbd90" translate="yes" xml:space="preserve">
          <source>Generate the &lt;code&gt;tas.b&lt;/code&gt; opcode for &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. Notice that depending on the particular hardware and software configuration this can degrade overall performance due to the operand cache line flushes that are implied by the &lt;code&gt;tas.b&lt;/code&gt; instruction. On multi-core SH4A processors the &lt;code&gt;tas.b&lt;/code&gt; instruction must be used with caution since it can result in data corruption for certain cache configurations.</source>
          <target state="translated">Генерирование &lt;code&gt;tas.b&lt;/code&gt; опкод для &lt;code&gt;__atomic_test_and_set&lt;/code&gt; . Обратите внимание, что в зависимости от конкретной конфигурации оборудования и программного обеспечения это может ухудшить общую производительность из-за &lt;code&gt;tas.b&lt;/code&gt; строк кэша операндов, которые подразумеваются инструкцией tas.b. На многоядерных процессорах &lt;code&gt;tas.b&lt;/code&gt; инструкцию tas.b следует использовать с осторожностью, поскольку это может привести к повреждению данных для определенных конфигураций кеша.</target>
        </trans-unit>
        <trans-unit id="33b6af1538444b86d0ad7d0fedaceadc538e6781" translate="yes" xml:space="preserve">
          <source>Generate the predefine, &lt;code&gt;_SIO&lt;/code&gt;, for server IO. The default is</source>
          <target state="translated">Создайте предопределенный &lt;code&gt;_SIO&lt;/code&gt; для ввода-вывода сервера. По умолчанию</target>
        </trans-unit>
        <trans-unit id="556e10b173cc8258302ad6ae7353988cc9258bb9" translate="yes" xml:space="preserve">
          <source>Generate unwind table in DWARF format, if supported by target machine. The table is exact at each instruction boundary, so it can be used for stack unwinding from asynchronous events (such as debugger or garbage collector).</source>
          <target state="translated">Сгенерируйте таблицу размотки в формате DWARF,если поддерживается целевой машиной.Таблица точна на границе каждой команды,поэтому ее можно использовать для размотки стека от асинхронных событий (таких как отладчик или сборщик мусора).</target>
        </trans-unit>
        <trans-unit id="57527d83fd3616a340b11bb579911dbfd64f477e" translate="yes" xml:space="preserve">
          <source>Generate v3 push25/pop25 instructions.</source>
          <target state="translated">Сгенерировать инструкции v3 push25/pop25.</target>
        </trans-unit>
        <trans-unit id="fb9942d737ee06d15159ff521f994cc01ae69210" translate="yes" xml:space="preserve">
          <source>Generated code is not compatible with hardware interrupts. Code size is smaller.</source>
          <target state="translated">Сгенерированный код не совместим с аппаратными прерываниями.Размер кода меньше.</target>
        </trans-unit>
        <trans-unit id="95fc43dc3dce502b8d3a439f3daa647aaa660090" translate="yes" xml:space="preserve">
          <source>Generates</source>
          <target state="translated">Generates</target>
        </trans-unit>
        <trans-unit id="847361d2a7401aea217f81327402896d9c474e00" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;sbit&lt;/code&gt;/&lt;code&gt;cbit&lt;/code&gt; instructions for bit manipulations.</source>
          <target state="translated">Генерирует &lt;code&gt;sbit&lt;/code&gt; / &lt;code&gt;cbit&lt;/code&gt; для битовых манипуляций.</target>
        </trans-unit>
        <trans-unit id="8c23e71aebd89fa525027dc7a4570046a7a64ce0" translate="yes" xml:space="preserve">
          <source>Generates an error message. This pragma &lt;em&gt;is&lt;/em&gt; considered to indicate an error in the compilation, and it will be treated as such.</source>
          <target state="translated">Выдает сообщение об ошибке. Прагма &lt;em&gt;это&lt;/em&gt; считается указывает на ошибку в компиляции, и он будет рассматриваться как таковые.</target>
        </trans-unit>
        <trans-unit id="b4a08a286760cba742dec264941903cd2180c988" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;brk&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует машинную инструкцию &lt;code&gt;brk&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0ffdd1afe0ff10e18f301f3481e988ec1af918" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;clrpsw&lt;/code&gt; machine instruction to clear the specified bit in the processor status word.</source>
          <target state="translated">Генерирует &lt;code&gt;clrpsw&lt;/code&gt; инструкцию clrpsw для очистки указанного бита в слове состояния процессора.</target>
        </trans-unit>
        <trans-unit id="e384966166fe10a7e3cda9622b8d991e42dbafb8" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32b&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;crc32b&lt;/code&gt; инструкцию crc32b .</target>
        </trans-unit>
        <trans-unit id="097e8495f2e00512011587a86cec2af02faf3293" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32l&lt;/code&gt; machine instruction.</source>
          <target state="translated">Создает &lt;code&gt;crc32l&lt;/code&gt; инструкцию crc32l .</target>
        </trans-unit>
        <trans-unit id="257268a989f9b93ff19c2d7c87cb2336d607cc4f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32q&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;crc32q&lt;/code&gt; инструкцию crc32q .</target>
        </trans-unit>
        <trans-unit id="b6ee9ffc23cac162df8a9b520916fe8eb4063947" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32w&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;crc32w&lt;/code&gt; инструкцию crc32w .</target>
        </trans-unit>
        <trans-unit id="9c0298bd9ac40c51cad36ed168d5ebaa6178f1de" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;etnd&lt;/code&gt; machine instruction. The current nesting depth is returned as integer value. For a nesting depth of 0 the code is not executed as part of an transaction.</source>
          <target state="translated">Генерирует &lt;code&gt;etnd&lt;/code&gt; инструкцию etnd . Текущая глубина вложенности возвращается как целое число. При глубине вложенности 0 код не выполняется как часть транзакции.</target>
        </trans-unit>
        <trans-unit id="ba9daaa604a3528f1838ae3869b5e548870970eb" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;extractps&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;extractps&lt;/code&gt; инструкцию extractps .</target>
        </trans-unit>
        <trans-unit id="89f2857c101ed877edbedb096cf0c5b70642f1a6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;insertps&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;insertps&lt;/code&gt; инструкцию вставки .</target>
        </trans-unit>
        <trans-unit id="bddf0335c49f41b446b0994e140cc0b296730b66" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;int&lt;/code&gt; machine instruction to generate an interrupt with the specified value.</source>
          <target state="translated">Создает машинную инструкцию &lt;code&gt;int&lt;/code&gt; для генерации прерывания с указанным значением.</target>
        </trans-unit>
        <trans-unit id="cc578c8838d75de69df84505da3623cd37d917cc" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;machi&lt;/code&gt; machine instruction to add the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">Генерирует машинную инструкцию &lt;code&gt;machi&lt;/code&gt; для сложения результата умножения верхних 16 бит двух аргументов в аккумулятор.</target>
        </trans-unit>
        <trans-unit id="99eacdb7a1185745b3f8d3546aa5c195c4ffc120" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;maclo&lt;/code&gt; machine instruction to add the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">Создает &lt;code&gt;maclo&lt;/code&gt; команду макло для сложения результата умножения нижних 16 бит двух аргументов в аккумулятор.</target>
        </trans-unit>
        <trans-unit id="7a0ca51423d0e24c5de865392e13bff92dec8a47" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">Генерирует &lt;code&gt;movhps&lt;/code&gt; инструкцию movhps как загрузку из памяти.</target>
        </trans-unit>
        <trans-unit id="a6336fc5b41c1f5923ae66b48c6856394b9f7d5d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">Создает &lt;code&gt;movhps&lt;/code&gt; инструкцию movhps для сохранения в памяти.</target>
        </trans-unit>
        <trans-unit id="81a1c47a7ece45e98596dc9420085617e89d6661" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a load from memory</source>
          <target state="translated">Генерирует &lt;code&gt;movlps&lt;/code&gt; инструкцию movlps как загрузку из памяти</target>
        </trans-unit>
        <trans-unit id="1e491626b2ecf306727f7b2f326dde340a6befb6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">Генерирует &lt;code&gt;movlps&lt;/code&gt; инструкцию movlps для сохранения в памяти.</target>
        </trans-unit>
        <trans-unit id="ac79e7ffaaf077d95a6d1ffa3d8fb253edbeb451" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movss&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">Генерирует &lt;code&gt;movss&lt;/code&gt; инструкцию movss как загрузку из памяти.</target>
        </trans-unit>
        <trans-unit id="2dc4d75da1c01f01ac98af15d63b74a7af18475d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">Генерирует машинную инструкцию &lt;code&gt;movups&lt;/code&gt; как загрузку из памяти.</target>
        </trans-unit>
        <trans-unit id="363646d48f8bc2356c5c4e7f637ebc00c96d25d3" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">Генерирует машинную инструкцию &lt;code&gt;movups&lt;/code&gt; для сохранения в памяти.</target>
        </trans-unit>
        <trans-unit id="bc35453eece3fefcd1bc15a0d478b36419def393" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mulhi&lt;/code&gt; machine instruction to place the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">Создает &lt;code&gt;mulhi&lt;/code&gt; инструкцию mulhi для помещения результата умножения старших 16 бит двух аргументов в аккумулятор.</target>
        </trans-unit>
        <trans-unit id="52d614340e6bcb9b13e27d9daf3f3ec4c3e7003e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mullo&lt;/code&gt; machine instruction to place the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">Генерирует &lt;code&gt;mullo&lt;/code&gt; инструкцию mullo для помещения результата умножения нижних 16 бит двух аргументов в аккумулятор.</target>
        </trans-unit>
        <trans-unit id="37702a0f744e0973c9767b2a0ae0b071d0ab6011" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfachi&lt;/code&gt; machine instruction to read the top 32 bits of the accumulator.</source>
          <target state="translated">Генерирует &lt;code&gt;mvfachi&lt;/code&gt; инструкцию mvfachi для чтения верхних 32 бита аккумулятора.</target>
        </trans-unit>
        <trans-unit id="e5e940957ba8e9f4e4a5a9b38f5ec9bacccdcd1d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfacmi&lt;/code&gt; machine instruction to read the middle 32 bits of the accumulator.</source>
          <target state="translated">Генерирует &lt;code&gt;mvfacmi&lt;/code&gt; инструкцию mvfacmi для чтения средних 32 бита аккумулятора.</target>
        </trans-unit>
        <trans-unit id="84ea7bb4390bbd29b42442b2c0df648769428770" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfc&lt;/code&gt; machine instruction which reads the control register specified in its argument and returns its value.</source>
          <target state="translated">Генерирует &lt;code&gt;mvfc&lt;/code&gt; инструкцию mvfc, которая читает регистр управления, указанный в его аргументе, и возвращает его значение.</target>
        </trans-unit>
        <trans-unit id="9a7f85fadc166c23e3a73720a98d17ae8d98c867" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtachi&lt;/code&gt; machine instruction to set the top 32 bits of the accumulator.</source>
          <target state="translated">Генерирует &lt;code&gt;mvtachi&lt;/code&gt; инструкцию mvtachi для установки верхних 32 бита аккумулятора.</target>
        </trans-unit>
        <trans-unit id="c2fa5a8c449853ed0e286fabb00686c6c4684432" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtaclo&lt;/code&gt; machine instruction to set the bottom 32 bits of the accumulator.</source>
          <target state="translated">Генерирует &lt;code&gt;mvtaclo&lt;/code&gt; инструкцию mvtaclo для установки нижних 32 бита аккумулятора.</target>
        </trans-unit>
        <trans-unit id="0c726977269ab1aef450eb4579a182f674e2891b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtc&lt;/code&gt; machine instruction which sets control register number &lt;code&gt;reg&lt;/code&gt; to &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">Генерирует &lt;code&gt;mvtc&lt;/code&gt; команду mvtc, которая устанавливает для номера регистра управления &lt;code&gt;reg&lt;/code&gt; значение &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e73288099a5726fcb09aeebaa5734e10714eb5f2" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtipl&lt;/code&gt; machine instruction set the interrupt priority level.</source>
          <target state="translated">Генерирует &lt;code&gt;mvtipl&lt;/code&gt; инструкцию mvtipl, задает уровень приоритета прерывания.</target>
        </trans-unit>
        <trans-unit id="c95405f984d5d6abab06b81618d6b2d88c6bce16" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ntstg&lt;/code&gt; machine instruction. The second argument is written to the first arguments location. The store operation will not be rolled-back in case of an transaction abort.</source>
          <target state="translated">Генерирует &lt;code&gt;ntstg&lt;/code&gt; инструкцию ntstg . Второй аргумент записывается в место первого аргумента. Операция хранилища не будет отменена в случае прерывания транзакции.</target>
        </trans-unit>
        <trans-unit id="221810e17f3f5b7b6eee2c597dcc35e9560d5c1a" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pause&lt;/code&gt; machine instruction with a compiler memory barrier.</source>
          <target state="translated">Создает машинную инструкцию &lt;code&gt;pause&lt;/code&gt; с барьером памяти компилятора.</target>
        </trans-unit>
        <trans-unit id="fabcc577b37bbc75f15d4acfc478723f40e312bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pclmulqdq&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;pclmulqdq&lt;/code&gt; инструкцию pclmulqdq .</target>
        </trans-unit>
        <trans-unit id="138581c28238370fdca095f892b8bcc2f037ebde" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;pextrb&lt;/code&gt; инструкцию pextrb .</target>
        </trans-unit>
        <trans-unit id="cc89464fd0e0ffc62121a43ea4c78a22a765f79b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;pextrd&lt;/code&gt; инструкцию pextrd .</target>
        </trans-unit>
        <trans-unit id="6995305b1713c32c1cb9c1c29aa123fa501311ad" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">Генерирует &lt;code&gt;pextrq&lt;/code&gt; инструкцию pextrq в 64- битном режиме.</target>
        </trans-unit>
        <trans-unit id="7afd0d12563bc8ecde0ac65ab4ecf09a6388cc0c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;pinsrb&lt;/code&gt; инструкцию pinsrb .</target>
        </trans-unit>
        <trans-unit id="587eac9a0053b04618284992d46512728f7465b0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;pinsrd&lt;/code&gt; инструкцию pinsrd .</target>
        </trans-unit>
        <trans-unit id="e89f9467a7fdb5f2511c4d93da028b6494b1db2e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">Генерирует &lt;code&gt;pinsrq&lt;/code&gt; инструкцию pinsrq в 64- битном режиме.</target>
        </trans-unit>
        <trans-unit id="167d17fe5058f3ef0cb33d59903eebaaf6162e68" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;popcntl&lt;/code&gt; инструкцию popcntl .</target>
        </trans-unit>
        <trans-unit id="6cb126029514e2d5bfcb6bca148eb150b8aba8a4" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; or &lt;code&gt;popcntq&lt;/code&gt; machine instruction, depending on the size of &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">Создает машинную инструкцию &lt;code&gt;popcntl&lt;/code&gt; или &lt;code&gt;popcntq&lt;/code&gt; в зависимости от размера &lt;code&gt;unsigned long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c32c9ad948f2048e1fcb6de749499d83eb38bfdd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntq&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует &lt;code&gt;popcntq&lt;/code&gt; инструкцию popcntq .</target>
        </trans-unit>
        <trans-unit id="c6a384a17f6c55681ebb99e208e7e76367ba0a5f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ppa rX,rY,1&lt;/code&gt; machine instruction. Where the integer parameter is loaded into rX and a value of zero is loaded into rY. The integer parameter specifies the number of times the transaction repeatedly aborted.</source>
          <target state="translated">Генерирует машинную инструкцию &lt;code&gt;ppa rX,rY,1&lt;/code&gt; . Где целочисленный параметр загружается в rX, а нулевое значение загружается в rY. Целочисленный параметр указывает, сколько раз транзакция неоднократно прерывалась.</target>
        </trans-unit>
        <trans-unit id="2ad4e7198804a310937a6c8bd6ea66807f131d33" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;racw&lt;/code&gt; machine instruction to round the accumulator according to the specified mode.</source>
          <target state="translated">Генерирует &lt;code&gt;racw&lt;/code&gt; инструкцию racw для округления аккумулятора в соответствии с указанным режимом.</target>
        </trans-unit>
        <trans-unit id="94afa89c73a482e7f60ea3534ec6652b684e5611" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;revw&lt;/code&gt; machine instruction which swaps the bytes in the argument so that bits 0&amp;ndash;7 now occupy bits 8&amp;ndash;15 and vice versa, and also bits 16&amp;ndash;23 occupy bits 24&amp;ndash;31 and vice versa.</source>
          <target state="translated">Генерирует &lt;code&gt;revw&lt;/code&gt; команду revw, которая меняет местами байты в аргументе, так что биты 0&amp;ndash;7 теперь занимают биты 8&amp;ndash;15 и наоборот, а также биты 16&amp;ndash;23 занимают биты 24&amp;ndash;31 и наоборот.</target>
        </trans-unit>
        <trans-unit id="6d19e7f0e193910eff939ea1df5fd508cf81e1dd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;rmpa&lt;/code&gt; machine instruction which initiates a repeated multiply and accumulate sequence.</source>
          <target state="translated">Генерирует &lt;code&gt;rmpa&lt;/code&gt; инструкцию rmpa, которая инициирует повторяющуюся последовательность умножения и накопления.</target>
        </trans-unit>
        <trans-unit id="3a3c845817720a1abf8f57c24608a050c45caf15" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;round&lt;/code&gt; machine instruction which returns the floating-point argument rounded according to the current rounding mode set in the floating-point status word register.</source>
          <target state="translated">Генерирует &lt;code&gt;round&lt;/code&gt; машинную команду, которая возвращает аргумент с плавающей запятой, округленный в соответствии с текущим режимом округления, установленным в регистре слова состояния с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="693bacff2407833725bfd8a8b85cfbf1bb7e034c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;sat&lt;/code&gt; machine instruction which returns the saturated value of the argument.</source>
          <target state="translated">Генерирует машинную инструкцию &lt;code&gt;sat&lt;/code&gt; , которая возвращает насыщенное значение аргумента.</target>
        </trans-unit>
        <trans-unit id="0bd4f2535ab0460fd7e26bbf4e95465d1caef5d0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;setpsw&lt;/code&gt; machine instruction to set the specified bit in the processor status word.</source>
          <target state="translated">Генерирует &lt;code&gt;setpsw&lt;/code&gt; инструкцию setpsw для установки указанного бита в слове состояния процессора.</target>
        </trans-unit>
        <trans-unit id="86af23191f84ff6e1646de29e1379a9fa322b441" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tabort&lt;/code&gt; machine instruction with the specified abort code. Abort codes from 0 through 255 are reserved and will result in an error message.</source>
          <target state="translated">Создает &lt;code&gt;tabort&lt;/code&gt; инструкцию табуляции с указанным кодом прерывания. Коды прерывания от 0 до 255 зарезервированы и приведут к сообщению об ошибке.</target>
        </trans-unit>
        <trans-unit id="41fafa8bbaf148ec213bd90ff158b6b99b4cd68d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbegin&lt;/code&gt; machine instruction starting a non-constrained hardware transaction. If the parameter is non-NULL the memory area is used to store the transaction diagnostic buffer and will be passed as first operand to &lt;code&gt;tbegin&lt;/code&gt;. This buffer can be defined using the &lt;code&gt;struct __htm_tdb&lt;/code&gt; C struct defined in &lt;code&gt;htmintrin.h&lt;/code&gt; and must reside on a double-word boundary. The second tbegin operand is set to &lt;code&gt;0xff0c&lt;/code&gt;. This enables save/restore of all GPRs and disables aborts for FPR and AR manipulations inside the transaction body. The condition code set by the tbegin instruction is returned as integer value. The tbegin instruction by definition overwrites the content of all FPRs. The compiler will generate code which saves and restores the FPRs. For soft-float code it is recommended to used the &lt;code&gt;*_nofloat&lt;/code&gt; variant. In order to prevent a TDB from being written it is required to pass a constant zero value as parameter. Passing a zero value through a variable is not sufficient. Although modifications of access registers inside the transaction will not trigger an transaction abort it is not supported to actually modify them. Access registers do not get saved when entering a transaction. They will have undefined state when reaching the abort code.</source>
          <target state="translated">Генерирует &lt;code&gt;tbegin&lt;/code&gt; инструкцию tbegin, запускающую аппаратную транзакцию без ограничений. Если параметр не равен NULL, область памяти используется для хранения диагностического буфера транзакции и будет передана в качестве первого операнда в &lt;code&gt;tbegin&lt;/code&gt; . Этот буфер может быть определен с помощью &lt;code&gt;struct __htm_tdb&lt;/code&gt; C struct __htm_tdb, определенной в &lt;code&gt;htmintrin.h&lt;/code&gt; , и должен располагаться на границе двойного слова. Второй операнд tbegin установлен на &lt;code&gt;0xff0c&lt;/code&gt; , Это позволяет сохранять / восстанавливать все GPR и отключает прерывания для FPR и AR манипуляций внутри тела транзакции. Код условия, установленный инструкцией tbegin, возвращается как целочисленное значение. Инструкция tbegin по определению перезаписывает содержимое всех FPR. Компилятор сгенерирует код, который сохраняет и восстанавливает FPR. Для кода soft-float рекомендуется использовать &lt;code&gt;*_nofloat&lt;/code&gt; вариант. Чтобы предотвратить запись TDB, необходимо передать постоянное нулевое значение в качестве параметра. Передачи нулевого значения через переменную недостаточно. Хотя изменения регистров доступа внутри транзакции не вызывают прерывания транзакции, их фактическое изменение не поддерживается. Регистры доступа не сохраняются при входе в транзакцию. При достижении кода прерывания они будут иметь неопределенное состояние.</target>
        </trans-unit>
        <trans-unit id="e6827eb1aea4f7107218c612803fe4d6ada64dff" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbeginc&lt;/code&gt; machine instruction starting a constrained hardware transaction. The second operand is set to &lt;code&gt;0xff08&lt;/code&gt;.</source>
          <target state="translated">Создает &lt;code&gt;tbeginc&lt;/code&gt; инструкцию tbeginc, запускающую ограниченную аппаратную транзакцию. Второй операнд установлен на &lt;code&gt;0xff08&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1623696be46dd23fac7b3be91a9dabc88baaf7ab" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tend&lt;/code&gt; machine instruction finishing a transaction and making the changes visible to other threads. The condition code generated by tend is returned as integer value.</source>
          <target state="translated">Генерирует , как &lt;code&gt;tend&lt;/code&gt; , машинная окончания сделки и внесения изменений видимых для других потоков. Код условия, сгенерированный функциейtend, возвращается в виде целого числа.</target>
        </trans-unit>
        <trans-unit id="98be0f38fb4c5ac278186b26e4d1c15696ff51bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;wait&lt;/code&gt; machine instruction.</source>
          <target state="translated">Генерирует машинную инструкцию &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="ea3f79632679059de141d66e9dca3bc06851d467" translate="yes" xml:space="preserve">
          <source>Generic VIA Nano CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Общий процессор VIA Nano с поддержкой наборов команд x86-64,MMX,SSE,SSE2,SSE3 и SSSE3.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="9aea01d94f58ef40baf7a92523ddcc334efa83d3" translate="yes" xml:space="preserve">
          <source>Get and set the contents of the floating-point control and status register (FPU control register 31). These functions are only available in hard-float code but can be called in both MIPS16 and non-MIPS16 contexts.</source>
          <target state="translated">Получите и установите содержимое регистра управления и статуса с плавающей запятой (управляющий регистр 31 ППУ).Эти функции доступны только в жестком коде,но могут быть вызваны как в контексте MIPS16,так и в контексте,отличном от MIPS16.</target>
        </trans-unit>
        <trans-unit id="93019384bd85aa8984f35ea4b05d12346052144c" translate="yes" xml:space="preserve">
          <source>Get the current value of shadow stack pointer if shadow stack support from Intel CET is enabled in the hardware or &lt;code&gt;0&lt;/code&gt; otherwise. The &lt;code&gt;ret_type&lt;/code&gt; is &lt;code&gt;unsigned long long&lt;/code&gt; for 64-bit targets and &lt;code&gt;unsigned int&lt;/code&gt; for 32-bit targets.</source>
          <target state="translated">Получить текущее значение указателя теневого стека, если на оборудовании включена поддержка теневого стека от Intel CET, или &lt;code&gt;0&lt;/code&gt; в противном случае. &lt;code&gt;ret_type&lt;/code&gt; будет &lt;code&gt;unsigned long long&lt;/code&gt; для 64-битных целей и &lt;code&gt;unsigned int&lt;/code&gt; для 32-битных целей.</target>
        </trans-unit>
        <trans-unit id="242390092876b4a7227130b506459512d744c5bd" translate="yes" xml:space="preserve">
          <source>Getting pointers to labels, and computed gotos.</source>
          <target state="translated">Наведение указателей на ярлыки и вычисление гото.</target>
        </trans-unit>
        <trans-unit id="fbec048bbd1449a0bc11388da4d5291473184989" translate="yes" xml:space="preserve">
          <source>Getting the return or frame address of a function.</source>
          <target state="translated">Получение адреса возврата или кадра функции.</target>
        </trans-unit>
        <trans-unit id="5bde8fdcb7065ba19c1a32d2b6a67073b7fb1601" translate="yes" xml:space="preserve">
          <source>Give a warning when a value of type &lt;code&gt;float&lt;/code&gt; is implicitly promoted to &lt;code&gt;double&lt;/code&gt;. CPUs with a 32-bit &amp;ldquo;single-precision&amp;rdquo; floating-point unit implement &lt;code&gt;float&lt;/code&gt; in hardware, but emulate &lt;code&gt;double&lt;/code&gt; in software. On such a machine, doing computations using &lt;code&gt;double&lt;/code&gt; values is much more expensive because of the overhead required for software emulation.</source>
          <target state="translated">Выдает предупреждение, когда значение типа &lt;code&gt;float&lt;/code&gt; неявно повышается до &lt;code&gt;double&lt;/code&gt; . Процессоры с 32-битным модулем с плавающей запятой одинарной точности реализуют &lt;code&gt;float&lt;/code&gt; аппаратно, но эмулируют &lt;code&gt;double&lt;/code&gt; в программном обеспечении. На такой машине выполнение вычислений с использованием &lt;code&gt;double&lt;/code&gt; значений намного дороже из-за накладных расходов, необходимых для программной эмуляции.</target>
        </trans-unit>
        <trans-unit id="133654b9660498348bca9e7a9d9666b1d3206bc1" translate="yes" xml:space="preserve">
          <source>Give a warning whenever a function is used before being declared. In C99 mode (</source>
          <target state="translated">Предупреждать всякий раз,когда какая-либо функция используется перед объявлением.В режиме C99 (</target>
        </trans-unit>
        <trans-unit id="ce9ec4f1d36927037e489058adc0d7c699b3e5d0" translate="yes" xml:space="preserve">
          <source>Give an error whenever the &lt;em&gt;base standard&lt;/em&gt; (see</source>
          <target state="translated">Выдает ошибку всякий раз, когда &lt;em&gt;базовый стандарт&lt;/em&gt; (см.</target>
        </trans-unit>
        <trans-unit id="10288103238e1aab071f91b995853a568ee8af72" translate="yes" xml:space="preserve">
          <source>Given a set of input registers that die in an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know which are implicitly popped by the &lt;code&gt;asm&lt;/code&gt;, and which must be explicitly popped by GCC.</source>
          <target state="translated">Учитывая набор входных регистров, которые умирают в &lt;code&gt;asm&lt;/code&gt; , необходимо знать, какие из них неявно извлекаются из &lt;code&gt;asm&lt;/code&gt; , а какие должны быть явно извлечены GCC.</target>
        </trans-unit>
        <trans-unit id="d87967442824754978f26c181e17cc9e46db44dd" translate="yes" xml:space="preserve">
          <source>Gives all externally visible functions in the file being compiled an ARM instruction set header which switches to Thumb mode before executing the rest of the function. This allows these functions to be called from non-interworking code. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">Дает всем внешним видимым функциям в компилируемом файле заголовок набора инструкций ARM,который переключается в режим Thumb перед выполнением остальной функции.Это позволяет вызывать эти функции из нерабочего кода.Эта опция недействительна в конфигурациях AAPCS,так как по умолчанию включено взаимодействие.</target>
        </trans-unit>
        <trans-unit id="28fd2d80d56f82ae132cdb0c4269c770aa941c82" translate="yes" xml:space="preserve">
          <source>Global register variables cannot have initial values, because an executable file has no means to supply initial contents for a register.</source>
          <target state="translated">Переменные глобального регистра не могут иметь начальных значений,потому что исполняемый файл не имеет средств для предоставления начального содержимого для регистра.</target>
        </trans-unit>
        <trans-unit id="e1edbfbe92e2bd9d3f1182eb37f4bcfb20acdde5" translate="yes" xml:space="preserve">
          <source>Go source code.</source>
          <target state="translated">Иди с исходным кодом.</target>
        </trans-unit>
        <trans-unit id="0104e918e01eb5413cf5e7e2b781b5b40dca1b8d" translate="yes" xml:space="preserve">
          <source>Guide linker to relax instructions.</source>
          <target state="translated">Руководство по установке ссылок для расслабления инструкций.</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="c2d31434fb0f344cb4feeec0b0e57232ab31c7ad" translate="yes" xml:space="preserve">
          <source>HI and LO registers.</source>
          <target state="translated">HI и LO зарегистрированы.</target>
        </trans-unit>
        <trans-unit id="ae1313e0d197443a538cfdaa0498460e61bc9b40" translate="yes" xml:space="preserve">
          <source>HI register.</source>
          <target state="translated">HI зарегистрировался.</target>
        </trans-unit>
        <trans-unit id="9ffcbdd38d89bcb3eaa62489fe7281d06ece8295" translate="yes" xml:space="preserve">
          <source>HIGH register class $r12 to $r14, $r20 to $r31.</source>
          <target state="translated">Высокий регистрационный класс $r12-$14,$20-$31.</target>
        </trans-unit>
        <trans-unit id="3cb15a163b8ebe83004d3a7496bed1214d5c34ea" translate="yes" xml:space="preserve">
          <source>HK</source>
          <target state="translated">HK</target>
        </trans-unit>
        <trans-unit id="f187928fdb223e7f3b7b0396e72e2d59a5f12b29" translate="yes" xml:space="preserve">
          <source>HR</source>
          <target state="translated">HR</target>
        </trans-unit>
        <trans-unit id="85df07a121977d0d0044781e9eeed44012e5da35" translate="yes" xml:space="preserve">
          <source>Half-Precision Floating Point.</source>
          <target state="translated">Полуточная плавающая точка.</target>
        </trans-unit>
        <trans-unit id="98b9b2da1252ae05155633eda47b6a7d5cf72927" translate="yes" xml:space="preserve">
          <source>Halt. The processor stops execution. This built-in is useful for implementing assertions.</source>
          <target state="translated">Стоять.Процессор останавливает выполнение.Эта встроенная функция полезна для реализации утверждений.</target>
        </trans-unit>
        <trans-unit id="04a52ed9fb0a2eefbc17a28c7b4e166c12cd47d4" translate="yes" xml:space="preserve">
          <source>Hardware autoprefetcher scheduler model control flag. Number of lookahead cycles the model looks into; at &amp;rsquo; &amp;rsquo; only enable instruction sorting heuristic.</source>
          <target state="translated">Флаг управления моделью планировщика аппаратного автозапуска. Количество циклов просмотра вперед, в которые смотрит модель; at '' разрешить только эвристику сортировки инструкций.</target>
        </trans-unit>
        <trans-unit id="073339b2e7c4ff717e46d7be967106262132c9d4" translate="yes" xml:space="preserve">
          <source>Hardware multiplies are normally performed by calling a library routine. This saves space in the generated code. When compiling at</source>
          <target state="translated">Умножение аппаратного обеспечения обычно выполняется путем вызова библиотечной рутины.Это экономит место в генерируемом коде.При компиляции при</target>
        </trans-unit>
        <trans-unit id="f483db45c59b64e904de79b67a44935e8bf546fe" translate="yes" xml:space="preserve">
          <source>Have &lt;code&gt;operator=&lt;/code&gt; return a reference to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Пусть &lt;code&gt;operator=&lt;/code&gt; возвращать ссылку на &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="42b05fc1afa3da7a89484cda5a6cb36dbe6e8a78" translate="yes" xml:space="preserve">
          <source>Hence, it is assumed as a convention that &lt;code&gt;r*&lt;/code&gt; means &lt;code&gt;const
char *&lt;/code&gt; (since it is what is most often meant), and there is no way to encode &lt;code&gt;char *const&lt;/code&gt;. &lt;code&gt;char *const&lt;/code&gt; would simply be encoded as &lt;code&gt;*&lt;/code&gt;, and the &lt;code&gt;const&lt;/code&gt; is lost.</source>
          <target state="translated">Следовательно, принято в качестве соглашения, что &lt;code&gt;r*&lt;/code&gt; означает &lt;code&gt;const char *&lt;/code&gt; (поскольку это то, что чаще всего имеется в виду), и нет способа кодировать &lt;code&gt;char *const&lt;/code&gt; . &lt;code&gt;char *const&lt;/code&gt; будет просто закодировано как &lt;code&gt;*&lt;/code&gt; , а &lt;code&gt;const&lt;/code&gt; будет потеряна.</target>
        </trans-unit>
        <trans-unit id="c6ff03b9e0183ccfd153d29e4ebb71b3afc43687" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;</source>
          <target state="translated">Вот '</target>
        </trans-unit>
        <trans-unit id="63fa474126b5fb0e84bc0e1276f71b4f5949c4a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; may or may not be restored to its first value when the &lt;code&gt;longjmp&lt;/code&gt; occurs. If &lt;code&gt;a&lt;/code&gt; is allocated in a register, then its first value is restored; otherwise, it keeps the last value stored in it.</source>
          <target state="translated">Здесь &lt;code&gt;a&lt;/code&gt; может быть восстановлен или не восстановлен до своего первого значения при возникновении &lt;code&gt;longjmp&lt;/code&gt; . Если &lt;code&gt;a&lt;/code&gt; размещается в регистре, то восстанавливается его первое значение; в противном случае он сохраняет последнее сохраненное в нем значение.</target>
        </trans-unit>
        <trans-unit id="6c22abcd7bcbe4b705f9506a92dff2b4514bc0a5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining global register variables, but for a local variable the declaration appears within a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">Здесь &lt;code&gt;r12&lt;/code&gt; - это имя регистра, который следует использовать. Обратите внимание, что это тот же синтаксис, который используется для определения переменных глобального регистра, но для локальной переменной объявление появляется внутри функции. &lt;code&gt;register&lt;/code&gt; ключевых слов требуются, и не могут быть объединены с &lt;code&gt;static&lt;/code&gt; . Имя регистра должно быть действительным именем регистра для целевой платформы.</target>
        </trans-unit>
        <trans-unit id="e629674ac2ffa8c8e6f920770dda44cae02f866e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining local register variables, but for a global variable the declaration appears outside a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">Здесь &lt;code&gt;r12&lt;/code&gt; - это имя регистра, который следует использовать. Обратите внимание, что это тот же синтаксис, который используется для определения переменных локального регистра, но для глобальной переменной объявление появляется вне функции. &lt;code&gt;register&lt;/code&gt; ключевых слов требуются, и не могут быть объединены с &lt;code&gt;static&lt;/code&gt; . Имя регистра должно быть действительным именем регистра для целевой платформы.</target>
        </trans-unit>
        <trans-unit id="1bd41698f09a234c8d3f5259448a5e29c338b76f" translate="yes" xml:space="preserve">
          <source>Here are constraint modifier characters.</source>
          <target state="translated">Вот символы модификаторов ограничений.</target>
        </trans-unit>
        <trans-unit id="13c7c696c96d9253d198dc3e9c528b8ff4863b3b" translate="yes" xml:space="preserve">
          <source>Here are some examples showing uses of these options.</source>
          <target state="translated">Вот несколько примеров использования этих опций.</target>
        </trans-unit>
        <trans-unit id="a2f0dcf3cf944a4192020c4b10f40e42e5e117ae" translate="yes" xml:space="preserve">
          <source>Here are some more examples of output operands.</source>
          <target state="translated">Вот еще несколько примеров выходных операндов.</target>
        </trans-unit>
        <trans-unit id="25efdeb982b817cc2032012465d473ceaf58d073" translate="yes" xml:space="preserve">
          <source>Here are some types and their encodings, as they are generated by the compiler on an i386 machine:</source>
          <target state="translated">Вот некоторые типы и их кодировки,так как они генерируются компилятором на машине i386:</target>
        </trans-unit>
        <trans-unit id="807544d18135eba132f45e4832519a518a98b736" translate="yes" xml:space="preserve">
          <source>Here are specific details on what constraint letters you can use with &lt;code&gt;asm&lt;/code&gt; operands. Constraints can say whether an operand may be in a register, and which kinds of register; whether the operand can be a memory reference, and which kinds of address; whether the operand may be an immediate constant, and which possible values it may have. Constraints can also require two operands to match. Side-effects aren&amp;rsquo;t allowed in operands of inline &lt;code&gt;asm&lt;/code&gt;, unless &amp;lsquo;</source>
          <target state="translated">Вот конкретные подробности о том, какие буквы ограничений вы можете использовать с операндами &lt;code&gt;asm&lt;/code&gt; . Ограничения могут сказать, может ли операнд быть в регистре и какие типы регистров; может ли операнд быть ссылкой на память и какие адреса; может ли операнд быть непосредственной константой и какие возможные значения он может иметь. Ограничения также могут требовать совпадения двух операндов. Побочные эффекты не допускаются в операндах встроенного &lt;code&gt;asm&lt;/code&gt; , если только '</target>
        </trans-unit>
        <trans-unit id="8169e79c24e48ad827616f09316f377a5693db58" translate="yes" xml:space="preserve">
          <source>Here is a fictitious &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; instruction. Notice that the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; pointer registers must be specified as input/output because the &lt;code&gt;asm&lt;/code&gt; modifies them.</source>
          <target state="translated">Вот вымышленная инструкция &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; . Обратите внимание, что регистры указателя &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; должны быть указаны как ввод / вывод, потому что &lt;code&gt;asm&lt;/code&gt; изменяет их.</target>
        </trans-unit>
        <trans-unit id="b840ee95bd53e4b94e99eb87178d11fd9afdba38" translate="yes" xml:space="preserve">
          <source>Here is a fictitious sum of squares instruction, that takes two pointers to floating point values in memory and produces a floating point register output. Notice that &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; both appear twice in the &lt;code&gt;asm&lt;/code&gt; parameters, once to specify memory accessed, and once to specify a base register used by the &lt;code&gt;asm&lt;/code&gt;. You won&amp;rsquo;t normally be wasting a register by doing this as GCC can use the same register for both purposes. However, it would be foolish to use both &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%3&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; in this &lt;code&gt;asm&lt;/code&gt; and expect them to be the same. In fact, &lt;code&gt;%3&lt;/code&gt; may well not be a register. It might be a symbolic memory reference to the object pointed to by &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Вот команда фиктивной суммы квадратов, которая принимает два указателя на значения с плавающей запятой в памяти и производит вывод регистра с плавающей запятой. Обратите внимание, что &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; появляются дважды в параметрах &lt;code&gt;asm&lt;/code&gt; : один раз для указания памяти, к которой осуществляется доступ, и один раз для указания базового регистра, используемого &lt;code&gt;asm&lt;/code&gt; . Обычно вы не будете тратить зря регистр, делая это, поскольку GCC может использовать один и тот же регистр для обеих целей. Однако было бы глупо использовать и &lt;code&gt;%1&lt;/code&gt; и &lt;code&gt;%3&lt;/code&gt; для &lt;code&gt;x&lt;/code&gt; в этом &lt;code&gt;asm&lt;/code&gt; и ожидать, что они будут одинаковыми. Фактически, &lt;code&gt;%3&lt;/code&gt; вполне может быть не регистр. Это может быть символическая ссылка в памяти на объект, на который указывает &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="989c5915dce017df7249cda1058c0a0b75ec727b" translate="yes" xml:space="preserve">
          <source>Here is a fully worked-out example using a Foundation library (which provides the implementation of &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSString&lt;/code&gt; and &lt;code&gt;NSLog&lt;/code&gt;):</source>
          <target state="translated">Вот полностью проработанный пример с использованием библиотеки Foundation (которая обеспечивает реализацию &lt;code&gt;NSArray&lt;/code&gt; , &lt;code&gt;NSString&lt;/code&gt; и &lt;code&gt;NSLog&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="0837d871cde10d5f686c43af16d467ea239dcffc" translate="yes" xml:space="preserve">
          <source>Here is a list of each supported architecture and their supported implementations.</source>
          <target state="translated">Ниже приведен список поддерживаемых архитектур и их реализаций.</target>
        </trans-unit>
        <trans-unit id="6bbe295750387ad466f92bad763fdcf85832b55b" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling C++ programs:</source>
          <target state="translated">Вот список параметров, предназначенных &lt;em&gt;только&lt;/em&gt; для компиляции программ на C ++:</target>
        </trans-unit>
        <trans-unit id="9c6de7709b9bd71702ea864b6b84c7a93a1c5dfe" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling Objective-C and Objective-C++ programs:</source>
          <target state="translated">Вот список параметров, которые предназначены &lt;em&gt;только&lt;/em&gt; для компиляции программ Objective-C и Objective-C ++:</target>
        </trans-unit>
        <trans-unit id="3d287577ba4a1613932b539025d50b64c148479a" translate="yes" xml:space="preserve">
          <source>Here is a more technical description with the gory details. Consider the code</source>
          <target state="translated">Вот более техническое описание с кровавыми подробностями.Рассмотрим код</target>
        </trans-unit>
        <trans-unit id="1f5c95b6edb6a49dd54cd8ace0a3af7f6b8efa6e" translate="yes" xml:space="preserve">
          <source>Here is a realistic example for the VAX showing the use of clobbered registers:</source>
          <target state="translated">Вот реалистичный пример для VAX,показывающий использование забитых регистров:</target>
        </trans-unit>
        <trans-unit id="fab100c4848d525a51e3c94ffe939c5c90d217c1" translate="yes" xml:space="preserve">
          <source>Here is a small example of a spec file:</source>
          <target state="translated">Вот небольшой пример спецификационного файла:</target>
        </trans-unit>
        <trans-unit id="fd38f38bfeb097a932215690af5b2bcebdd18296" translate="yes" xml:space="preserve">
          <source>Here is a summary of all the options, grouped by type. Explanations are in the following sections.</source>
          <target state="translated">Вот краткое описание всех опций,сгруппированных по типам.Пояснения приведены в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="776e1d0b1f7cf817731495ac8a0bb9e5528c2c48" translate="yes" xml:space="preserve">
          <source>Here is a table of all defined &amp;lsquo;</source>
          <target state="translated">Вот таблица всех определенных '</target>
        </trans-unit>
        <trans-unit id="72ec126b11c4f7e2b3f6db181072684dbe3a798e" translate="yes" xml:space="preserve">
          <source>Here is a truncated example from the ARM port of &lt;code&gt;gcc&lt;/code&gt;:</source>
          <target state="translated">Вот усеченный пример из ARM-порта &lt;code&gt;gcc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="816eebea82d67ac72ae8e305241f89073b0b966e" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;asm goto&lt;/code&gt; for i386:</source>
          <target state="translated">Вот пример &lt;code&gt;asm goto&lt;/code&gt; для i386:</target>
        </trans-unit>
        <trans-unit id="ddf77123eb0a199270833915774797e456c51dd3" translate="yes" xml:space="preserve">
          <source>Here is an example of a PowerPC vector scale implemented in assembly, complete with vector and condition code clobbers, and some initialized offset registers that are unchanged by the &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">Вот пример векторной шкалы PowerPC, реализованной в сборке, в комплекте с блокировщиками векторных и условных кодов, а также некоторыми инициализированными регистрами смещения, которые не изменяются &lt;code&gt;asm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="874ef7a4fb34e57091c1bf1216dfbb76680c0a4d" translate="yes" xml:space="preserve">
          <source>Here is an example of basic &lt;code&gt;asm&lt;/code&gt; for i386:</source>
          <target state="translated">Вот пример базового &lt;code&gt;asm&lt;/code&gt; для i386:</target>
        </trans-unit>
        <trans-unit id="578c29000b6f8a220ff3bd98b1f6dac59cfc8f4c" translate="yes" xml:space="preserve">
          <source>Here is an example of constructing a &lt;code&gt;struct foo&lt;/code&gt; with a compound literal:</source>
          <target state="translated">Вот пример построения &lt;code&gt;struct foo&lt;/code&gt; с составным литералом:</target>
        </trans-unit>
        <trans-unit id="b487a854c417efabdfc0cd516c584d94dc1d4a11" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use this feature. Suppose you want to implement a class whose instances hold a weak pointer reference; the following class does this:</source>
          <target state="translated">Вот пример использования этой функции.Предположим,вы хотите реализовать класс,в экземплярах которого есть слабая ссылка на указатель;следующий класс делает это:</target>
        </trans-unit>
        <trans-unit id="ab5b5e88b81c892525543bbf2b441bfb5667f5c0" translate="yes" xml:space="preserve">
          <source>Here is an example showing handling for &lt;code&gt;_XABORT_RETRY&lt;/code&gt; and a fallback path for other failures:</source>
          <target state="translated">Вот пример, показывающий обработку для &lt;code&gt;_XABORT_RETRY&lt;/code&gt; и запасной путь для других сбоев:</target>
        </trans-unit>
        <trans-unit id="156d8468259daa1a9f530dd9ec7054117c896faf" translate="yes" xml:space="preserve">
          <source>Here is an example using symbolic names.</source>
          <target state="translated">Вот пример использования символических названий.</target>
        </trans-unit>
        <trans-unit id="aa58661567f951b6e91b047e11c73d9fb7a1db05" translate="yes" xml:space="preserve">
          <source>Here is an example with a typename as the argument:</source>
          <target state="translated">Вот пример с именем типа в качестве аргумента:</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="26a60c8be4c01c6ccc45bd8984830035c8dc1a26" translate="yes" xml:space="preserve">
          <source>Here the two output filenames</source>
          <target state="translated">Здесь два выходных файла</target>
        </trans-unit>
        <trans-unit id="00b4a6c83965e727380186cb35a7faefe39e2601" translate="yes" xml:space="preserve">
          <source>Here the type described is that of pointers to &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Здесь описывается тип указателей на &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df28516bc4139f3f069071685fe09b0059baa73c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;d&lt;/code&gt; may either be in a register or in memory. Since the compiler might already have the current value of the &lt;code&gt;uint32_t&lt;/code&gt; location pointed to by &lt;code&gt;e&lt;/code&gt; in a register, you can enable it to choose the best location for &lt;code&gt;d&lt;/code&gt; by specifying both constraints.</source>
          <target state="translated">Здесь &lt;code&gt;d&lt;/code&gt; может быть либо в регистре, либо в памяти. Поскольку компилятор может уже иметь текущее значение местоположения &lt;code&gt;uint32_t&lt;/code&gt; ,на которое указывает &lt;code&gt;e&lt;/code&gt; в регистре, вы можете разрешить ему выбрать лучшее местоположение для &lt;code&gt;d&lt;/code&gt; , указав оба ограничения.</target>
        </trans-unit>
        <trans-unit id="d245b0ad9046b148b54dc212babce2d8a4b44886" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t4&lt;/code&gt; takes up 4 bytes.</source>
          <target state="translated">Здесь &lt;code&gt;t4&lt;/code&gt; занимает 4 байта.</target>
        </trans-unit>
        <trans-unit id="46a3f0b1a7f9b9f0c9d86a3230e304304bee1bda" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t5&lt;/code&gt; takes up 2 bytes.</source>
          <target state="translated">Здесь &lt;code&gt;t5&lt;/code&gt; занимает 2 байта.</target>
        </trans-unit>
        <trans-unit id="f9dddf42b68435ab0aa7d4d6b86db289bd3db824" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;std::move&lt;/code&gt; call is redundant. Because G++ implements Core Issue 1579, another example is:</source>
          <target state="translated">Здесь вызов &lt;code&gt;std::move&lt;/code&gt; избыточен. Поскольку G ++ реализует Core Issue 1579, другой пример:</target>
        </trans-unit>
        <trans-unit id="94a1520d218a1c0edb195732392c054a4dc1a61d" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;intermediate&lt;/code&gt; receives the address of &lt;code&gt;store&lt;/code&gt; as an argument. If &lt;code&gt;intermediate&lt;/code&gt; calls &lt;code&gt;store&lt;/code&gt;, the arguments given to &lt;code&gt;store&lt;/code&gt; are used to store into &lt;code&gt;array&lt;/code&gt;. But this technique works only so long as the containing function (&lt;code&gt;hack&lt;/code&gt;, in this example) does not exit.</source>
          <target state="translated">Здесь &lt;code&gt;intermediate&lt;/code&gt; функция получает адрес &lt;code&gt;store&lt;/code&gt; в качестве аргумента. Если &lt;code&gt;intermediate&lt;/code&gt; вызовы &lt;code&gt;store&lt;/code&gt; , аргументы, передаваемые &lt;code&gt;store&lt;/code&gt; , используются для сохранения в &lt;code&gt;array&lt;/code&gt; . Но этот метод работает только до тех пор, пока содержащая функция ( в данном примере &lt;code&gt;hack&lt;/code&gt; ) не завершается.</target>
        </trans-unit>
        <trans-unit id="8e86d7a0668faeeae59dff730b5c0908c7e965fa" translate="yes" xml:space="preserve">
          <source>Here, the names &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; appear in a context that does not depend on the type of &lt;code&gt;T&lt;/code&gt;. The compiler will thus require that they are defined in the context of use in the template, not only before the point of instantiation, and will here use &lt;code&gt;::foo(double)&lt;/code&gt; and &lt;code&gt;A::N&lt;/code&gt;, respectively. In particular, it will convert the integer value to a &lt;code&gt;double&lt;/code&gt; when passing it to &lt;code&gt;::foo(double)&lt;/code&gt;.</source>
          <target state="translated">Здесь имена &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;N&lt;/code&gt; появляются в контексте , который не зависит от типа &lt;code&gt;T&lt;/code&gt; . Таким образом, компилятор потребует, чтобы они были определены в контексте использования в шаблоне, а не только до точки создания экземпляра, и здесь будет использовать &lt;code&gt;::foo(double)&lt;/code&gt; и &lt;code&gt;A::N&lt;/code&gt; соответственно. В частности, он преобразует целочисленное значение в &lt;code&gt;double&lt;/code&gt; при передаче его в &lt;code&gt;::foo(double)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a9da0e5c138e6d84a3e4a12f0c523bc1f369e0f" translate="yes" xml:space="preserve">
          <source>Hewlett-Packard PA-RISC&amp;mdash;</source>
          <target state="translated">Hewlett-Packard PA-RISC&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9e735341d337ae137df7758e8465bb4d998cc55a" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point constants.</source>
          <target state="translated">Шестнадцатеричные константы с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="26e165ccce457fee42636ec531aa349640cf4392" translate="yes" xml:space="preserve">
          <source>Hidden visibility indicates that the entity declared has a new form of linkage, which we call &amp;ldquo;hidden linkage&amp;rdquo;. Two declarations of an object with hidden linkage refer to the same object if they are in the same shared object.</source>
          <target state="translated">Скрытая видимость указывает на то, что объявленный объект имеет новую форму связи, которую мы называем &amp;laquo;скрытой связью&amp;raquo;. Два объявления объекта со скрытой связью относятся к одному и тому же объекту, если они находятся в одном общем объекте.</target>
        </trans-unit>
        <trans-unit id="29464505836db623029950c0312fcb03cbd85481" translate="yes" xml:space="preserve">
          <source>Historically, GCC has not deleted &amp;ldquo;empty&amp;rdquo; loops under the assumption that the most likely reason you would put one in a program is to have a delay, so deleting them will not make real programs run any faster.</source>
          <target state="translated">Исторически GCC не удалял &amp;laquo;пустые&amp;raquo; циклы, исходя из предположения, что наиболее вероятная причина, по которой вы добавляете их в программу, - это задержка, поэтому их удаление не заставит реальные программы работать быстрее.</target>
        </trans-unit>
        <trans-unit id="25855108b662a0e8c1ed703787f979b815d2d1a6" translate="yes" xml:space="preserve">
          <source>Historically, compilers for many languages, including C++ and Fortran, have been implemented as &amp;ldquo;preprocessors&amp;rdquo; which emit another high level language such as C. None of the compilers included in GCC are implemented this way; they all generate machine code directly. This sort of preprocessor should not be confused with the &lt;em&gt;C preprocessor&lt;/em&gt;, which is an integral feature of the C, C++, Objective-C and Objective-C++ languages.</source>
          <target state="translated">Исторически компиляторы для многих языков, включая C ++ и Fortran, были реализованы как &amp;laquo;препроцессоры&amp;raquo;, которые генерируют другой язык высокого уровня, такой как C. Ни один из компиляторов, включенных в GCC, не реализован таким образом; все они напрямую генерируют машинный код. Препроцессор такого типа не следует путать с &lt;em&gt;препроцессором C&lt;/em&gt; , который является неотъемлемой частью языков C, C ++, Objective-C и Objective-C ++.</target>
        </trans-unit>
        <trans-unit id="1df0e52c96207e60432f242eee2da9b8ff549d2b" translate="yes" xml:space="preserve">
          <source>How GCC calculates the size of an &lt;code&gt;asm&lt;/code&gt; block.</source>
          <target state="translated">Как GCC вычисляет размер блока &lt;code&gt;asm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9040ed129a83c15932559ac6449ffd679075c3" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C specification.</source>
          <target state="translated">Как GCC реализует спецификацию ISO C.</target>
        </trans-unit>
        <trans-unit id="f79f60bc97ae69f938083d6bd71809804c4831c5" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C++ specification.</source>
          <target state="translated">Как GCC реализует спецификацию ISO C++.</target>
        </trans-unit>
        <trans-unit id="62fab6a3b6832fb352405ce63e5b735618b3cef7" translate="yes" xml:space="preserve">
          <source>How To Get Help with GCC</source>
          <target state="translated">Как получить помощь с GCC</target>
        </trans-unit>
        <trans-unit id="3e63c682de797883ae23802bc327411231cc31a8" translate="yes" xml:space="preserve">
          <source>How a diagnostic is identified (C90 3.7, C99 and C11 3.10, C90, C99 and C11 5.1.1.3).</source>
          <target state="translated">Как определяется диагностика (C90 3.7,C99 и C11 3.10,C90,C99 и C11 5.1.1.3).</target>
        </trans-unit>
        <trans-unit id="a123b2bec235da6dad3dc58f234c2574673ff822" translate="yes" xml:space="preserve">
          <source>How much optimization?</source>
          <target state="translated">Сколько оптимизации?</target>
        </trans-unit>
        <trans-unit id="31524a9fb30368b64541b8aeb51e1826b2eb3b0a" translate="yes" xml:space="preserve">
          <source>How picky should the compiler be?</source>
          <target state="translated">Насколько придирчивым должен быть компилятор?</target>
        </trans-unit>
        <trans-unit id="1e2b472e6c532fe8af4932714956f74293f46083" translate="yes" xml:space="preserve">
          <source>How sequences in both forms of header names are mapped to headers or external source file names (C90 6.1.7, C99 and C11 6.4.7).</source>
          <target state="translated">Как последовательности в обеих формах имен заголовков отображаются в заголовках или именах внешних файлов-источников (C90 6.1.7,C99 и C11 6.4.7).</target>
        </trans-unit>
        <trans-unit id="848f6ad2348dcee59d13596577066e141ef4d0ad" translate="yes" xml:space="preserve">
          <source>How the named source file is searched for in an included &amp;lsquo;</source>
          <target state="translated">Как названный исходный файл ищется во включенном '</target>
        </trans-unit>
        <trans-unit id="130378b21f742b32140465d74f388cb06f5001cf" translate="yes" xml:space="preserve">
          <source>How the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value is chosen for certain floating constants (C90 6.1.3.1, C99 and C11 6.4.4.2).</source>
          <target state="translated">Как для определенных плавающих констант (С90 6.1.3.1,С99 и С11 6.4.4.2)выбирается ближайшее по репрезентативности значение или большее или меньшее по репрезентативности значение,непосредственно примыкающее к ближайшему по репрезентативности значению.</target>
        </trans-unit>
        <trans-unit id="606b9fa050c9f5a8165f3052560ba0c7d8b85fa0" translate="yes" xml:space="preserve">
          <source>How to contribute to testing and developing GCC.</source>
          <target state="translated">Как внести свой вклад в тестирование и разработку GCC.</target>
        </trans-unit>
        <trans-unit id="25170558e581aabef161dcb92e9a6de67ff5f448" translate="yes" xml:space="preserve">
          <source>How to help assure funding for free software.</source>
          <target state="translated">Как помочь обеспечить финансирование свободных программ.</target>
        </trans-unit>
        <trans-unit id="488dee81569b2dc10244c6b537b50c3cc87269e1" translate="yes" xml:space="preserve">
          <source>How to pass switches to sub-processes.</source>
          <target state="translated">Как передать коммутаторы в подпроцессы.</target>
        </trans-unit>
        <trans-unit id="8c1e8efdd3392d7ad8138bb7223322e34b90c240" translate="yes" xml:space="preserve">
          <source>How to use gcov-dump.</source>
          <target state="translated">Как использовать gcov-dump.</target>
        </trans-unit>
        <trans-unit id="f7d8be53e9f165a3a11bb6dadca7af891ced365f" translate="yes" xml:space="preserve">
          <source>How to use gcov-tool.</source>
          <target state="translated">Как использовать gcov-tool.</target>
        </trans-unit>
        <trans-unit id="dde16118c9faa27675fdfe5cf0405564b55597c4" translate="yes" xml:space="preserve">
          <source>How to use gcov.</source>
          <target state="translated">Как использовать gcov.</target>
        </trans-unit>
        <trans-unit id="4e461b3cc6748ec681eab8b558da86d4b08a95ab" translate="yes" xml:space="preserve">
          <source>How you can copy and share this manual.</source>
          <target state="translated">Как вы можете скопировать и поделиться этим руководством.</target>
        </trans-unit>
        <trans-unit id="9e8e4dbcb1b211f7b5ab31c6c59b3a79ec59dd4f" translate="yes" xml:space="preserve">
          <source>How, why and where to report bugs.</source>
          <target state="translated">Как,почему и где сообщать об ошибках.</target>
        </trans-unit>
        <trans-unit id="0e3275b465f023e98f74ae720920ad438e50264c" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; is not a valid cast because the union has no member of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">Однако &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; не является допустимым приведением, потому что объединение не имеет члена типа &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ea71fd7ca0b24f50560578a479dbd93975ddc25" translate="yes" xml:space="preserve">
          <source>However, if a library or main executable is supposed to throw or catch exceptions, you must link it using the G++ driver, or using the option</source>
          <target state="translated">Однако,если библиотека или основной исполняемый файл должен бросать или ловить исключения,вы должны связать его с помощью драйвера G++,или с помощью опции</target>
        </trans-unit>
        <trans-unit id="68ad5ea0590b2a354fce31707da021a7a4908783" translate="yes" xml:space="preserve">
          <source>However, if the volatile storage is not being modified, and the value of the volatile storage is not used, then the situation is less obvious. For example</source>
          <target state="translated">Однако,если волатильное хранилище не модифицируется,а значение волатильного хранилища не используется,то ситуация становится менее очевидной.Например</target>
        </trans-unit>
        <trans-unit id="3955f23a3aaffbcd48d8f54a3969fb80a9687bcd" translate="yes" xml:space="preserve">
          <source>However, the rationale here is that optimization of a nonempty loop cannot produce an empty one. This held for carefully written C compiled with less powerful optimizers but is not always the case for carefully written C++ or with more powerful optimizers. Thus GCC will remove operations from loops whenever it can determine those operations are not externally visible (apart from the time taken to execute them, of course). In case the loop can be proved to be finite, GCC will also remove the loop itself.</source>
          <target state="translated">Однако,логика здесь заключается в том,что оптимизация непустого цикла не может привести к пустому циклу.Это относится к аккуратно написанному Си,скомпилированному с использованием менее мощных оптимизаторов,но не всегда это относится к аккуратно написанному Си++или к более мощным оптимизаторам.Таким образом,GCC будет удалять из циклов операции всякий раз,когда он сможет определить,что эти операции не видны извне (за исключением,конечно,времени,затраченного на их выполнение).В случае,если цикл может быть доказан как конечный,GCC также удалит и сам цикл.</target>
        </trans-unit>
        <trans-unit id="9091ae1dd68a17c85dd2a3885c0a623d65f81f37" translate="yes" xml:space="preserve">
          <source>However, the use of &lt;code&gt;gcc&lt;/code&gt; does not add the C++ library. &lt;code&gt;g++&lt;/code&gt; is a program that calls GCC and automatically specifies linking against the C++ library. It treats &amp;lsquo;</source>
          <target state="translated">Однако использование &lt;code&gt;gcc&lt;/code&gt; не добавляет библиотеки C ++. &lt;code&gt;g++&lt;/code&gt; - это программа, которая вызывает GCC и автоматически указывает ссылку на библиотеку C ++. Лечит '</target>
        </trans-unit>
        <trans-unit id="25970c1ebc6bb12a4ef702c744afb1bf31667e71" translate="yes" xml:space="preserve">
          <source>However, these built-in functions may interact badly with some sophisticated features or other extensions of the language. It is, therefore, not recommended to use them outside very simple functions acting as mere forwarders for their arguments.</source>
          <target state="translated">Однако эти встроенные функции могут плохо взаимодействовать с некоторыми сложными функциями или другими расширениями языка.Поэтому не рекомендуется использовать их вне очень простых функций,выступающих в качестве простых пересылающих их аргументы.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="5035ba1d98ecd402c64867de896608b2100e61c1" translate="yes" xml:space="preserve">
          <source>I register</source>
          <target state="translated">я регистрируюсь</target>
        </trans-unit>
        <trans-unit id="0d25569c1c1c38b68b7adac7a2691f92a581fc48" translate="yes" xml:space="preserve">
          <source>IBM 970 Server CPU (ie, Apple G5).</source>
          <target state="translated">Серверный процессор IBM 970 (т.е.Apple G5).</target>
        </trans-unit>
        <trans-unit id="7ff989fdaf3c65fbe049204ca8d2d3b298dcd55a" translate="yes" xml:space="preserve">
          <source>IBM A2 64-bit Embedded CPU</source>
          <target state="translated">64-битный встроенный процессор IBM A2</target>
        </trans-unit>
        <trans-unit id="7ebf129d97228e5e38b88ee3a2bf7cb0f28dd1fe" translate="yes" xml:space="preserve">
          <source>IBM POWER4 Server CPU.</source>
          <target state="translated">Серверный процессор IBM POWER4.</target>
        </trans-unit>
        <trans-unit id="60fedee6d379816b90140e69a6cb94f8d8a8d0f3" translate="yes" xml:space="preserve">
          <source>IBM POWER5 Server CPU.</source>
          <target state="translated">Серверный процессор IBM POWER5.</target>
        </trans-unit>
        <trans-unit id="d3878c6f9c9f4047fa51bbea5fff4ce5c35e5af1" translate="yes" xml:space="preserve">
          <source>IBM POWER5+ Server CPU.</source>
          <target state="translated">Серверный процессор IBM POWER5+.</target>
        </trans-unit>
        <trans-unit id="738e9fd792342dee79476051b27ac20d78ee9cda" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (Architected mode).</source>
          <target state="translated">Серверный процессор IBM POWER6 (Архитектурный режим).</target>
        </trans-unit>
        <trans-unit id="a1d93b9cb2926fb05ec1f665abf51961f777a207" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (RAW mode).</source>
          <target state="translated">Серверный процессор IBM POWER6 (режим RAW).</target>
        </trans-unit>
        <trans-unit id="dbb9a20762f1a0c1106412992e6cc65c84bffc0f" translate="yes" xml:space="preserve">
          <source>IBM POWER7 Server CPU.</source>
          <target state="translated">Серверный процессор IBM POWER7.</target>
        </trans-unit>
        <trans-unit id="a9a9c9a90077a9f8cbd67dc15b93836e1c987d49" translate="yes" xml:space="preserve">
          <source>IBM POWER8 Server CPU.</source>
          <target state="translated">Серверный процессор IBM POWER8.</target>
        </trans-unit>
        <trans-unit id="c65507ef531be00847ba2a33296dc99803a18664" translate="yes" xml:space="preserve">
          <source>IBM POWER9 Server CPU.</source>
          <target state="translated">Серверный процессор IBM POWER9.</target>
        </trans-unit>
        <trans-unit id="5ad8015703e3cb16c9df6da3a8d9e97de8f9cd44" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 464 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 464 32-разрядный встроенный процессор.</target>
        </trans-unit>
        <trans-unit id="a548cb73c6f0d35ac7d906f9a02a9350c2eb6114" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 476FP 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 476FP 32-разрядный встроенный процессор.</target>
        </trans-unit>
        <trans-unit id="f3afdcbb4bda95413d989775a1a1f73e05c37f36" translate="yes" xml:space="preserve">
          <source>IBM PowerPC Cell Broadband Engine Architecture CPU.</source>
          <target state="translated">ЦПУ IBM PowerPC Cell Broadband Engine Architecture.</target>
        </trans-unit>
        <trans-unit id="981e760991adb048080be646b9e1438966c192d0" translate="yes" xml:space="preserve">
          <source>IDT WinChip 2 CPU, dealt in same way as i486 with additional MMX and 3DNow! instruction set support.</source>
          <target state="translated">IDT WinChip 2 CPU,работает так же,как и i486 с дополнительной поддержкой MMX и 3DNow! набора инструкций.</target>
        </trans-unit>
        <trans-unit id="e642e2d5acc8e35a06fd449f3d95c2b4f1486f5e" translate="yes" xml:space="preserve">
          <source>IDT WinChip C6 CPU, dealt in same way as i486 with additional MMX instruction set support.</source>
          <target state="translated">IDT WinChip C6 процессор,работающий так же,как и i486,с дополнительной поддержкой MMX набора инструкций.</target>
        </trans-unit>
        <trans-unit id="ec8566180afc9d36e3493dbd47d7e2d1e9ae9485" translate="yes" xml:space="preserve">
          <source>IPA-CP attempts to track all possible values and types passed to a function&amp;rsquo;s parameter in order to propagate them and perform devirtualization.</source>
          <target state="translated">IPA-CP пытается отслеживать все возможные значения и типы, передаваемые параметру функции, чтобы распространить их и выполнить девиртуализацию.</target>
        </trans-unit>
        <trans-unit id="f55eb535889fe2d3f53ef9f4b4a57453862d05ea" translate="yes" xml:space="preserve">
          <source>IPA-CP calculates its own score of cloning profitability heuristics and performs those cloning opportunities with scores that exceed</source>
          <target state="translated">IPA-CP рассчитывает свою собственную эвристику рентабельности клонирования и реализует возможности клонирования с баллами,превышающими</target>
        </trans-unit>
        <trans-unit id="18432c18c0adba44c26c2a586731fb98a9d6d897" translate="yes" xml:space="preserve">
          <source>IPA-CP is also capable to propagate a number of scalar values passed in an aggregate.</source>
          <target state="translated">IPA-CP также способен распространять ряд скалярных значений,передаваемых в совокупности.</target>
        </trans-unit>
        <trans-unit id="6522b0ebe1c355ebd160511e9d28107d63eb735d" translate="yes" xml:space="preserve">
          <source>IPA-SRA replaces a pointer to an aggregate with one or more new parameters only when their cumulative size is less or equal to</source>
          <target state="translated">IPA-SRA заменяет указатель на агрегат одним или несколькими новыми параметрами только в том случае,если их кумулятивный размер меньше или равен</target>
        </trans-unit>
        <trans-unit id="b5db770cbd54ca7a4734eeb3ccbfba61d7f93149" translate="yes" xml:space="preserve">
          <source>IRA can be used to evaluate more accurate register pressure in loops for decisions to move loop invariants (see</source>
          <target state="translated">IRA может быть использована для оценки более точного давления регистра в петлях для принятия решений о перемещении инвариантов петли (см.</target>
        </trans-unit>
        <trans-unit id="3c1b099cab9d31b532499457a148771feb1ef850" translate="yes" xml:space="preserve">
          <source>IRA uses regional register allocation by default. If a function contains more loops than the number given by this parameter, only at most the given number of the most frequently-executed loops form regions for regional register allocation.</source>
          <target state="translated">По умолчанию НРУ использует распределение региональных регистров.Если функция содержит больше циклов,чем задано этим параметром,то только в крайнем случае из числа наиболее часто исполняемых циклов формируются регионы для распределения региональных регистров.</target>
        </trans-unit>
        <trans-unit id="e1a35fb9a6e6329c3bd0cf9dd057013f4b706fa3" translate="yes" xml:space="preserve">
          <source>ISA 3.0 of the PowerPC added new atomic memory operation (amo) instructions. GCC provides support for these instructions in 64-bit environments. All of the functions are declared in the include file &lt;code&gt;amo.h&lt;/code&gt;.</source>
          <target state="translated">В ISA 3.0 PowerPC добавлены новые инструкции для работы с атомарной памятью (amo). GCC обеспечивает поддержку этих инструкций в 64-битных средах. Все функции объявлены в инклюдник &lt;code&gt;amo.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc00c6a2a5486718b4fd3642b097add2ed40af8" translate="yes" xml:space="preserve">
          <source>ISO C does not permit such a construct.</source>
          <target state="translated">ИСО С не разрешает такую конструкцию.</target>
        </trans-unit>
        <trans-unit id="fff460d30b4f47f8adc19f1a9e29c9166acd036b" translate="yes" xml:space="preserve">
          <source>ISO C requires a &amp;ldquo;diagnostic&amp;rdquo; message for certain kinds of invalid programs, but a warning is defined by GCC to count as a diagnostic. If GCC produces a warning but not an error, that is correct ISO C support. If testsuites call this &amp;ldquo;failure&amp;rdquo;, they should be run with the GCC option</source>
          <target state="translated">ISO C требует &amp;laquo;диагностического&amp;raquo; сообщения для определенных видов недействительных программ, но GCC определяет предупреждение, которое считается диагностическим. Если GCC выдает предупреждение, но не ошибку, это значит, что поддержка ISO C. Если наборы тестов называют это &amp;laquo;отказом&amp;raquo;, их следует запускать с опцией GCC.</target>
        </trans-unit>
        <trans-unit id="50648f88649c1f5dd7bf2cb4554ff39825b6b2bb" translate="yes" xml:space="preserve">
          <source>ISO C11, the 2011 revision of the ISO C standard. This standard is substantially completely supported, modulo bugs, floating-point issues (mainly but not entirely relating to optional C11 features from Annexes F and G) and the optional Annexes K (Bounds-checking interfaces) and L (Analyzability). The name &amp;lsquo;</source>
          <target state="translated">ISO C11, версия стандарта ISO C 2011 г. Этот стандарт практически полностью поддерживается, включая ошибки по модулю, проблемы с плавающей запятой (в основном, но не полностью относящиеся к дополнительным функциям C11 из приложений F и G) и дополнительным приложениям K (интерфейсы проверки границ) и L (анализируемость). Имя '</target>
        </trans-unit>
        <trans-unit id="a94be837facd76378c47084c4afa22ac2ddb78d6" translate="yes" xml:space="preserve">
          <source>ISO C17, the 2017 revision of the ISO C standard (published in 2018). This standard is same as C11 except for corrections of defects (all of which are also applied with</source>
          <target state="translated">ИСО С17,пересмотренный в 2017 году стандарт ИСО С (опубликован в 2018 году).Этот стандарт такой же,как и С11,за исключением исправления дефектов (все они также применяются с помощью</target>
        </trans-unit>
        <trans-unit id="835b0fe47c2b2521e64ab3b466f790da05e1cf2c" translate="yes" xml:space="preserve">
          <source>ISO C90 as modified in amendment 1.</source>
          <target state="translated">ISO C90 с изменениями в поправке 1.</target>
        </trans-unit>
        <trans-unit id="dd3ae16769f5e30cd0e25b181c241be07701badf" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++ allow declarations and code to be freely mixed within compound statements. As an extension, GNU C also allows this in C90 mode. For example, you could do:</source>
          <target state="translated">ISO C99 и ISO C++позволяют свободно смешивать декларации и код внутри составных заявлений.В качестве расширения GNU C также допускает это в режиме C90.Например,это можно сделать:</target>
        </trans-unit>
        <trans-unit id="fd9df382c7a9e275bf54293954eb3cea3a9394da" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++11 support data types for integers that are at least 64 bits wide, and as an extension GCC supports them in C90 and C++98 modes. Simply write &lt;code&gt;long long int&lt;/code&gt; for a signed integer, or &lt;code&gt;unsigned long long int&lt;/code&gt; for an unsigned integer. To make an integer constant of type &lt;code&gt;long long int&lt;/code&gt;, add the suffix &amp;lsquo;</source>
          <target state="translated">ISO C99 и ISO C ++ 11 поддерживают типы данных для целых чисел шириной не менее 64 бит, а в качестве расширения GCC поддерживает их в режимах C90 и C ++ 98. Просто напишите &lt;code&gt;long long int&lt;/code&gt; для целого числа со &lt;code&gt;unsigned long long int&lt;/code&gt; или unsigned long long int для целого числа без знака. Чтобы сделать целочисленную константу типа &lt;code&gt;long long int&lt;/code&gt; , добавьте суффикс '</target>
        </trans-unit>
        <trans-unit id="8b83453de486a892e712e76d4673bb12ab84c153" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++17 support floating-point numbers written not only in the usual decimal notation, such as &lt;code&gt;1.55e1&lt;/code&gt;, but also numbers such as &lt;code&gt;0x1.fp3&lt;/code&gt; written in hexadecimal format. As a GNU extension, GCC supports this in C90 mode (except in some cases when strictly conforming) and in C++98, C++11 and C++14 modes. In that format the &amp;lsquo;</source>
          <target state="translated">ISO C99 и ISO C ++ 17 поддерживают числа с плавающей запятой, записанные не только в обычном десятичном &lt;code&gt;1.55e1&lt;/code&gt; , например 1.55e1 , но и в шестнадцатеричном формате, например &lt;code&gt;0x1.fp3&lt;/code&gt; . Как расширение GNU, GCC поддерживает это в режиме C90 (за исключением некоторых случаев, когда оно строго соответствует) и в режимах C ++ 98, C ++ 11 и C ++ 14. В этом формате '</target>
        </trans-unit>
        <trans-unit id="f45bb32dfebc99db4671808e81b5e06e1a3ae3f3" translate="yes" xml:space="preserve">
          <source>ISO C99 supports complex floating data types, and as an extension GCC supports them in C90 mode and in C++. GCC also supports complex integer data types which are not part of ISO C99. You can declare complex types using the keyword &lt;code&gt;_Complex&lt;/code&gt;. As an extension, the older GNU keyword &lt;code&gt;__complex__&lt;/code&gt; is also supported.</source>
          <target state="translated">ISO C99 поддерживает сложные типы данных с плавающей запятой, и как расширение GCC поддерживает их в режиме C90 и в C ++. GCC также поддерживает сложные целочисленные типы данных, которые не являются частью ISO C99. Вы можете объявлять сложные типы с помощью ключевого слова &lt;code&gt;_Complex&lt;/code&gt; . В качестве расширения также поддерживается старое ключевое слово GNU &lt;code&gt;__complex__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84c793c819960394587c5cc12a67f14b20b38119" translate="yes" xml:space="preserve">
          <source>ISO C99. This standard is substantially completely supported, modulo bugs and floating-point issues (mainly but not entirely relating to optional C99 features from Annexes F and G). See &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for more information. The names &amp;lsquo;</source>
          <target state="translated">ISO C99. Этот стандарт практически полностью поддерживается, включая ошибки по модулю и проблемы с плавающей точкой (в основном, но не полностью относящиеся к дополнительным функциям C99 из приложений F и G). См. &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;Http://gcc.gnu.org/c99status.html&lt;/a&gt; для получения дополнительной информации. Имена '</target>
        </trans-unit>
        <trans-unit id="b19dfb0d72b128922f94144b3b4ef7616d4f13d5" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3 defines new permissible values for &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; that indicate that operations and constants with a semantic type that is an interchange or extended format should be evaluated to the precision and range of that type. These new values are a superset of those permitted under C99/C11, which does not specify the meaning of other positive values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt;. As such, code conforming to C11 may not have been written expecting the possibility of the new values.</source>
          <target state="translated">ISO / IEC TS 18661-3 определяет новые допустимые значения для &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; , которые указывают, что операции и константы с семантическим типом, который является обменом или расширенным форматом, должны оцениваться с точностью и диапазоном этого типа. Эти новые значения являются расширенным набором тех, которые разрешены в C99 / C11, который не определяет значение других положительных значений &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; . Таким образом, код, соответствующий C11, возможно, не был написан с ожиданием возможности новых значений.</target>
        </trans-unit>
        <trans-unit id="0704127df0a170eee2b3d8c1f35e3e35e1e33e3c" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3:2015 defines C support for additional floating types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, and GCC supports these type names; the set of types supported depends on the target architecture. These types are not supported when compiling C++. Constants with these types use suffixes &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;. These type names can be used together with &lt;code&gt;_Complex&lt;/code&gt; to declare complex types.</source>
          <target state="translated">ISO / IEC TS 18661-3: 2015 определяет поддержку C для дополнительных плавающих типов &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; и &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; , а GCC поддерживает эти имена типов; набор поддерживаемых типов зависит от целевой архитектуры. Эти типы не поддерживаются при компиляции C ++. Константы с этими типами используют суффиксы &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; или &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; и &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; или &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; . Эти имена типов можно использовать вместе с &lt;code&gt;_Complex&lt;/code&gt; для объявления сложных типов.</target>
        </trans-unit>
        <trans-unit id="beeb64c7eeaed20d36a340ce018bf60cf4a13bf4" translate="yes" xml:space="preserve">
          <source>Ideally, a portable program should always use &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; when it depends on the signedness of an object. But many programs have been written to use plain &lt;code&gt;char&lt;/code&gt; and expect it to be signed, or expect it to be unsigned, depending on the machines they were written for. This option, and its inverse, let you make such a program work with the opposite default.</source>
          <target state="translated">В идеале переносимая программа всегда должна использовать &lt;code&gt;signed char&lt;/code&gt; или &lt;code&gt;unsigned char&lt;/code&gt; если это зависит от подписи объекта. Но многие программы были написаны с использованием простого &lt;code&gt;char&lt;/code&gt; и ожидают, что он будет подписан, или ожидают, что он будет без подписи, в зависимости от машин, для которых они были написаны. Этот и обратный ему вариант позволяют заставить такую ​​программу работать с противоположным значением по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ab2f71fc75bf24fc42ea67b7b9de3bc2377f68da" translate="yes" xml:space="preserve">
          <source>Identical like the above one, but the location of the function in the &lt;code&gt;jli&lt;/code&gt; table is known and given as an attribute parameter.</source>
          <target state="translated">Идентичен приведенному выше, но расположение функции в таблице &lt;code&gt;jli&lt;/code&gt; известно и указывается в качестве параметра атрибута.</target>
        </trans-unit>
        <trans-unit id="06758e7fffb077a661e9d5cfb54c15702892df80" translate="yes" xml:space="preserve">
          <source>Identifier conflicts with labels. Traditional C lacks a separate namespace for labels.</source>
          <target state="translated">Идентификатор конфликтует с этикетками.В традиционном C отсутствует отдельное пространство имён для этикеток.</target>
        </trans-unit>
        <trans-unit id="5a6386123e656c29d067b76006564d3382accf62" translate="yes" xml:space="preserve">
          <source>Identify the versions of each tool used by the compiler, in a &lt;code&gt;.ident&lt;/code&gt; assembler directive in the output.</source>
          <target state="translated">Определите версии каждого инструмента, используемого компилятором, в директиве ассемблера &lt;code&gt;.ident&lt;/code&gt; в выходных данных.</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="b94b85388613ff812132cfe4fbfdcb534fff787e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;</source>
          <target state="translated">Если '</target>
        </trans-unit>
        <trans-unit id="8cfab80fece1ea34402901dd4726bddf817b9cff" translate="yes" xml:space="preserve">
          <source>If 3DNow! extensions are enabled, &lt;code&gt;V2SF&lt;/code&gt; is used as a mode for a vector of two 32-bit floating-point values.</source>
          <target state="translated">Если 3DNow! расширения включены, &lt;code&gt;V2SF&lt;/code&gt; используется как режим для вектора из двух 32-битных значений с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="23030af34d65c4d0b445c2e6bf477bf6b1f5c071" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%*&lt;/code&gt; appears as the last part of a spec sequence then a space is added after the end of the last substitution. If there is more text in the sequence, however, then a space is not generated. This allows the &lt;code&gt;%*&lt;/code&gt; substitution to be used as part of a larger string. For example, a spec string like this:</source>
          <target state="translated">Если &lt;code&gt;%*&lt;/code&gt; появляется как последняя часть последовательности спецификации, то после конца последней замены добавляется пробел. Однако, если в последовательности больше текста, то пробел не создается. Это позволяет использовать замену &lt;code&gt;%*&lt;/code&gt; как часть большей строки. Например, такая строка спецификации:</target>
        </trans-unit>
        <trans-unit id="539ea1d3aa99e1f5670827ce3f6d748af1cde993" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) is not implemented or returns &lt;code&gt;NO&lt;/code&gt;, the runtime then tries the forwarding hook.</source>
          <target state="translated">Если &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (или &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ) не реализовано или возвращает &lt;code&gt;NO&lt;/code&gt; , среда выполнения пробует переадресацию.</target>
        </trans-unit>
        <trans-unit id="3f8dd7c3c9fed3437a52aa9c603d614b32cf2d92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; were passed, the above would trigger a warning, but this time because of the lack of bounds checking.</source>
          <target state="translated">Если было &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; , то приведенное выше вызовет предупреждение, но на этот раз из-за отсутствия проверки границ.</target>
        </trans-unit>
        <trans-unit id="ca79581e5d9acfa9f2b20401cffd3a6d08f404f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;attribute-specifier-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">Если &lt;code&gt;D1&lt;/code&gt; имеет форму &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt; , а объявление &lt;code&gt;T D&lt;/code&gt; определяет тип &amp;laquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; &amp;raquo; для &lt;var&gt;ident&lt;/var&gt; , то &lt;code&gt;T D1&lt;/code&gt; определяет тип &amp;laquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;attribute-specifier-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; &amp;raquo;для &lt;var&gt;ident&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="bce12bf3e38781beccd90d07d87af63b34ed169d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;*
&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; pointer to &lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">Если &lt;code&gt;D1&lt;/code&gt; имеет форму &lt;code&gt;* &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt; , а объявление &lt;code&gt;T D&lt;/code&gt; указывает тип &amp;laquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; &amp;raquo; для &lt;var&gt;ident&lt;/var&gt; , то &lt;code&gt;T D1&lt;/code&gt; определяет тип &amp;laquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; указатель -списка-спецификатора-атрибута на &lt;var&gt;Type&lt;/var&gt; &amp;raquo;для &lt;var&gt;ident&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fdf6957ed3c287429ab808fa75095697e4d021d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; has been set for a given decl, use that in the dump instead of &lt;code&gt;DECL_NAME&lt;/code&gt;. Its primary use is ease of use working backward from mangled names in the assembly file.</source>
          <target state="translated">Если &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; был установлен для данного объявления, используйте его в дампе вместо &lt;code&gt;DECL_NAME&lt;/code&gt; . Его основное использование - простота использования, работая в обратном направлении от искаженных имен в файле сборки.</target>
        </trans-unit>
        <trans-unit id="647ff2c6b0ee66be47ceb0fe277c3fe135fc84e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is not set, GCC attempts to figure out an appropriate prefix to use based on the pathname it is invoked with.</source>
          <target state="translated">Если &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; не установлен, GCC пытается определить подходящий префикс для использования на основе имени пути, с которым он вызывается.</target>
        </trans-unit>
        <trans-unit id="7fc3d06e6177481bf26c022c74076e71f4e1f421" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is set, it specifies a prefix to use in the names of the subprograms executed by the compiler. No slash is added when this prefix is combined with the name of a subprogram, but you can specify a prefix that ends with a slash if you wish.</source>
          <target state="translated">Если установлен &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; , он указывает префикс для использования в именах подпрограмм, выполняемых компилятором. Когда этот префикс комбинируется с именем подпрограммы, косая черта не добавляется, но вы можете указать префикс, который заканчивается косой чертой, если хотите.</target>
        </trans-unit>
        <trans-unit id="dec8a7933acf37b1c0fdc778b779b3f382d54a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LANG&lt;/code&gt; is not defined, or if it has some other value, then the compiler uses &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbtowc&lt;/code&gt; as defined by the default locale to recognize and translate multibyte characters.</source>
          <target state="translated">Если &lt;code&gt;LANG&lt;/code&gt; не определен или имеет другое значение, то компилятор использует &lt;code&gt;mblen&lt;/code&gt; и &lt;code&gt;mbtowc&lt;/code&gt; , как определено локалью по умолчанию, для распознавания и перевода многобайтовых символов.</target>
        </trans-unit>
        <trans-unit id="e1943099aece965452d744a5c53ffc07f2bc9f16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;X&lt;/code&gt;; else if &lt;code&gt;T&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;Y&lt;/code&gt;; else substitutes &lt;code&gt;D&lt;/code&gt;. There can be as many clauses as you need. This may be combined with &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt; as needed.</source>
          <target state="translated">Если &lt;code&gt;S&lt;/code&gt; дан GCC, заменяет &lt;code&gt;X&lt;/code&gt; ; иначе, если &lt;code&gt;T&lt;/code&gt; дан GCC, заменяет &lt;code&gt;Y&lt;/code&gt; ; остальные заменители &lt;code&gt;D&lt;/code&gt; . Пунктов может быть сколько угодно. Это можно комбинировать с &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;,&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , и &lt;code&gt;*&lt;/code&gt; по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="404ec67951a627fb06995708ad6a0e24dc041fa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TMPDIR&lt;/code&gt; is set, it specifies the directory to use for temporary files. GCC uses temporary files to hold the output of one stage of compilation which is to be used as input to the next stage: for example, the output of the preprocessor, which is the input to the compiler proper.</source>
          <target state="translated">Если установлен &lt;code&gt;TMPDIR&lt;/code&gt; , он указывает каталог, который будет использоваться для временных файлов. GCC использует временные файлы для хранения выходных данных одного этапа компиляции, которые должны использоваться в качестве входных данных для следующего этапа: например, выходных данных препроцессора, которые являются входными данными для собственно компилятора.</target>
        </trans-unit>
        <trans-unit id="1953caa75083ee28850ca171a34b26fd4eb8373f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a default constructor that is known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , то черта &lt;code&gt;true&lt;/code&gt; , в противном случае , если &lt;code&gt;type&lt;/code&gt; является классом сорта или типа союза (или их массив) с конструктором по умолчанию , который , как известно , не сгенерирует исключение , то черта &lt;code&gt;true&lt;/code&gt; , иначе это &lt;code&gt;false&lt;/code&gt; , Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="763c1f95adec0e6f2c3d89c3c9b77ea1bcae352d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy constructors that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , то черта &lt;code&gt;true&lt;/code&gt; , в противном случае , если &lt;code&gt;type&lt;/code&gt; является резюме квалифицированных класса или объединения типа с копией конструкторов , которые , как известно , не сгенерирует исключение , то черта &lt;code&gt;true&lt;/code&gt; , иначе это &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="348b274e4746ccb17d0ad8ccc31192a6601178b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_class (type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is considered empty if and only if: &lt;code&gt;type&lt;/code&gt; has no non-static data members, or all non-static data members, if any, are bit-fields of length 0, and &lt;code&gt;type&lt;/code&gt; has no virtual members, and &lt;code&gt;type&lt;/code&gt; has no virtual base classes, and &lt;code&gt;type&lt;/code&gt; has no base classes &lt;code&gt;base_type&lt;/code&gt; for which &lt;code&gt;__is_empty (base_type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;__is_class (type)&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; , то черта &lt;code&gt;false&lt;/code&gt; . В противном случае &lt;code&gt;type&lt;/code&gt; считается пустым тогда и только тогда, когда: &lt;code&gt;type&lt;/code&gt; не имеет нестатических элементов данных, или все нестатические элементы данных, если они есть, являются битовыми полями длины 0, а &lt;code&gt;type&lt;/code&gt; не имеет виртуальных членов, а &lt;code&gt;type&lt;/code&gt; не имеет виртуальных базовые классы, а &lt;code&gt;type&lt;/code&gt; не имеет базовых классов &lt;code&gt;base_type&lt;/code&gt; , для которых &lt;code&gt;__is_empty (base_type)&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="3fb256b452a67db2fcf29b7d6c9eb3c3b57425ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a trivial destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;__is_pod (type)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;type&lt;/code&gt; является ссылочным типом , то черта &lt;code&gt;true&lt;/code&gt; , иначе , если &lt;code&gt;type&lt;/code&gt; является классом сорта или типа объединения (или их массива) с тривиальным деструктором ([class.dtor]) , то черта &lt;code&gt;true&lt;/code&gt; , иначе это &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="d1bf9587539b51be90adc4a1e785e99e947f0059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type with a trivial copy constructor ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;__is_pod (type)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;type&lt;/code&gt; является ссылочным типом , то черта &lt;code&gt;true&lt;/code&gt; , в противном случае , если &lt;code&gt;type&lt;/code&gt; является резюме класс или объединение типа с конструктором тривиальным копирования ([class.copy]) , то черта &lt;code&gt;true&lt;/code&gt; , иначе это &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="2f38bb6a2ade7b8693787a1194261c7451943ac5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type (or array thereof) with a trivial default constructor ([class.ctor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;__is_pod (type)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , то черта &lt;code&gt;true&lt;/code&gt; , в противном случае , если &lt;code&gt;type&lt;/code&gt; является резюме квалифицированного класса или типа союза (или их массив) с тривиальным конструктором по умолчанию ([class.ctor]) , то черта &lt;code&gt;true&lt;/code&gt; , иначе является &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="d19955ce7ffa6060ce61b406573fd7fa063dda62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base_type&lt;/code&gt; is a base class of &lt;code&gt;derived_type&lt;/code&gt; ([class.derived]) then the trait is &lt;code&gt;true&lt;/code&gt;, otherwise it is &lt;code&gt;false&lt;/code&gt;. Top-level cv-qualifications of &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are ignored. For the purposes of this trait, a class type is considered is own base. Requires: if &lt;code&gt;__is_class (base_type)&lt;/code&gt; and &lt;code&gt;__is_class (derived_type)&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are not the same type (disregarding cv-qualifiers), &lt;code&gt;derived_type&lt;/code&gt; shall be a complete type. A diagnostic is produced if this requirement is not met.</source>
          <target state="translated">Если &lt;code&gt;base_type&lt;/code&gt; является базовым классом &lt;code&gt;derived_type&lt;/code&gt; ([class.dehibited]), тогда признак &lt;code&gt;true&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; . Высокопоставленные CV-квалификация &lt;code&gt;base_type&lt;/code&gt; и &lt;code&gt;derived_type&lt;/code&gt; игнорируется. Для этого признака тип класса считается собственной базой. Требуется: если &lt;code&gt;__is_class (base_type)&lt;/code&gt; и &lt;code&gt;__is_class (derived_type)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;base_type&lt;/code&gt; и &lt;code&gt;derived_type&lt;/code&gt; не тот же типа (без учета CV-определители), &lt;code&gt;derived_type&lt;/code&gt; должен быть полным типом. Если это требование не выполняется, выдается диагностика.</target>
        </trans-unit>
        <trans-unit id="9ad52c7e701f6b6ac16fc011e5c3a814b836cace" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;objc_msg_lookup()&lt;/code&gt; does not find a suitable method implementation, because the receiver does not implement the required method, it tries to see if the class can dynamically register the method.</source>
          <target state="translated">Если &lt;code&gt;objc_msg_lookup()&lt;/code&gt; не находит подходящую реализацию метода, поскольку получатель не реализует требуемый метод, он пытается проверить, может ли класс динамически зарегистрировать метод.</target>
        </trans-unit>
        <trans-unit id="de0324724a4ecec17009f5551872ea4de764d9cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;packed&lt;/code&gt; is used on a structure, or if bit-fields are used, it may be that the Microsoft ABI lays out the structure differently than the way GCC normally does. Particularly when moving packed data between functions compiled with GCC and the native Microsoft compiler (either via function call or as data in a file), it may be necessary to access either format.</source>
          <target state="translated">Если в структуре используется &lt;code&gt;packed&lt;/code&gt; , или если используются битовые поля, может случиться так, что Microsoft ABI размещает структуру иначе, чем обычно это делает GCC. В частности, при перемещении упакованных данных между функциями, скомпилированными с помощью GCC, и встроенным компилятором Microsoft (либо через вызов функции, либо как данные в файле), может потребоваться доступ к любому формату.</target>
        </trans-unit>
        <trans-unit id="6f7ba7dbf5e57d92bfe72102ff6203af39a12a8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; is omitted, the signedness of the vector type is the default signedness of the base type. The default varies depending on the operating system, so a portable program should always specify the signedness.</source>
          <target state="translated">Если &lt;code&gt;signed&lt;/code&gt; или &lt;code&gt;unsigned&lt;/code&gt; опущен, подписанность векторного типа является подписью по умолчанию для базового типа. Значение по умолчанию зависит от операционной системы, поэтому переносимая программа всегда должна указывать подпись.</target>
        </trans-unit>
        <trans-unit id="ffd246c0a3fbb949c1fa9d8cc2260944e77a3bfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;- qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with a trivial copy assignment ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; квалифицирован как &lt;code&gt;const&lt;/code&gt; или является ссылочным типом, тогда признак &lt;code&gt;false&lt;/code&gt; . В противном случае , если &lt;code&gt;__is_pod (type)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , то черта &lt;code&gt;true&lt;/code&gt; , в противном случае , если &lt;code&gt;type&lt;/code&gt; является резюме квалифицированного класса или объединений типа с тривиальным назначением копии ([class.copy]) , то эта черта является &lt;code&gt;true&lt;/code&gt; , иначе это &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="283cf2672e55770fc0551d9647cca120a4bb630b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;-qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy assignment operators that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; определен как &lt;code&gt;const&lt;/code&gt; или является ссылочным типом, тогда признак &lt;code&gt;false&lt;/code&gt; . В противном случае , если &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , то черта &lt;code&gt;true&lt;/code&gt; , в противном случае , если &lt;code&gt;type&lt;/code&gt; является резюме квалифицированных класса или типа союза с операторами присваивания копии , которые , как известно , не сгенерирует исключение , то черта &lt;code&gt;true&lt;/code&gt; , иначе это &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="63c11c8bb0212d553ee20398c564d16b6ec7e69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a class type with a virtual destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; является типом класса с виртуальным деструктором ([class.dtor]), тогда признак &lt;code&gt;true&lt;/code&gt; , иначе - &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="3c2e0cd65d0655c5ce8c12d2d2d4a097d810e389" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv POD type ([basic.types]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; является типом cv POD ([basic.types]), тогда признак &lt;code&gt;true&lt;/code&gt; , иначе - &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="723863e0b5a8fce8c661ff18582b201e84983629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv enumeration type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; - это перечислимый тип cv ([basic.compound]), свойство имеет значение &lt;code&gt;true&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b7975a53cee041123902e4671962591f8c2cbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; является типом cv union ([basic.compound]), признак &lt;code&gt;true&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89ab4b13f03f8e9b77ccbec6378e569d290932f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv-qualified class type, and not a union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; является типом класса с квалификацией cv, а не типом объединения ([basic.compound]), свойство имеет значение &lt;code&gt;true&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c08c113aac15208c2698077a3dc6d2ee08e364" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a literal type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; - это буквальный тип ([basic.types]), признак &lt;code&gt;true&lt;/code&gt; , иначе - &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="44c42d9c3a648a4586d6d80ed2afeb43acc1f98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a polymorphic class ([class.virtual]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; является полиморфным классом ([class.virtual]), тогда признак &lt;code&gt;true&lt;/code&gt; , иначе - &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="902c4582059f6f78c8c47e8d4db16bfd414011e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a standard-layout type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; является типом стандартного макета ([basic.types]), свойство &lt;code&gt;true&lt;/code&gt; , иначе - &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="c53c71f1f92604372ad3a40e885b3e290ad04715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a trivial type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; - это тривиальный тип ([basic.types]), признак &lt;code&gt;true&lt;/code&gt; , иначе - &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="ffe6e21bc41957ab0a00219c12663528f239f642" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an abstract class ([class.abstract]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; - абстрактный класс ([class.abstract]), тогда признак &lt;code&gt;true&lt;/code&gt; , иначе - &lt;code&gt;false&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть полным типом (возможно, с квалификацией cv) &lt;code&gt;void&lt;/code&gt; или массивом с неизвестной границей.</target>
        </trans-unit>
        <trans-unit id="911911ebb73f24baa4568a362dcf6545a5e8bd9f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;X&lt;/var&gt; is &lt;code&gt;0xf&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th bit of &lt;var&gt;val&lt;/var&gt; is returned unaltered.</source>
          <target state="translated">Если &lt;var&gt;X&lt;/var&gt; равен &lt;code&gt;0xf&lt;/code&gt; , то &lt;var&gt;n&lt;/var&gt; -й бит &lt;var&gt;val&lt;/var&gt; возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="529d14d76239ac927a58af9240682db818e156fc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;desired&lt;/var&gt; is written into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; then &lt;code&gt;true&lt;/code&gt; is returned and memory is affected according to the memory order specified by &lt;var&gt;success_memorder&lt;/var&gt;. There are no restrictions on what memory order can be used here.</source>
          <target state="translated">Если &lt;var&gt;desired&lt;/var&gt; , записывается в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; , тогда возвращается &lt;code&gt;true&lt;/code&gt; и память &lt;var&gt;success_memorder&lt;/var&gt; соответствии с порядком памяти, указанным в success_memorder . Здесь нет ограничений на то, какой порядок памяти можно использовать.</target>
        </trans-unit>
        <trans-unit id="90eefc597dfd05335fdc76d585991dd479f5699e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;device&lt;/var&gt; is not a device but only a core architecture like &amp;lsquo;</source>
          <target state="translated">Если &lt;var&gt;device&lt;/var&gt; не является устройством, а имеет только базовую архитектуру, например '</target>
        </trans-unit>
        <trans-unit id="37aede7b841b819868fc3f607fc7588d32233439" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;exp1&lt;/var&gt; is returned, the return type is the same as &lt;var&gt;exp1&lt;/var&gt;&amp;rsquo;s type. Similarly, if &lt;var&gt;exp2&lt;/var&gt; is returned, its return type is the same as &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">Если возвращается &lt;var&gt;exp1&lt;/var&gt; , тип возвращаемого значения такой же, как и тип &lt;var&gt;exp1&lt;/var&gt; . Точно так же, если возвращается &lt;var&gt;exp2&lt;/var&gt; , его тип возврата такой же, как и &lt;var&gt;exp2&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="43726f9389a16cd86ccc87693856924d076a1cd7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file&lt;/var&gt; is</source>
          <target state="translated">Если &lt;var&gt;file&lt;/var&gt; является</target>
        </trans-unit>
        <trans-unit id="5b94a494d8a93062d1fb2f08cf22419880d46ae7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;m&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n&lt;/var&gt;.</source>
          <target state="translated">Если &lt;var&gt;m&lt;/var&gt; не указано, по умолчанию используется &lt;var&gt;n&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="96e30c03c390fa37f95beff815a87bdc5f2296a9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default which is very likely to be &amp;lsquo;</source>
          <target state="translated">Если &lt;var&gt;n&lt;/var&gt; не указано или равно нулю, используйте машинно-зависимое значение по умолчанию, которое, скорее всего, будет '</target>
        </trans-unit>
        <trans-unit id="4f4c9abfe6823ac3226b1f95cfb68ae207a767d4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default.</source>
          <target state="translated">Если &lt;var&gt;n&lt;/var&gt; не указано или равно нулю, используйте машинно-зависимое значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="edea744d98224ea825d53a93f917e0198d6b4e4e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default. The maximum allowed &lt;var&gt;n&lt;/var&gt; option value is 65536.</source>
          <target state="translated">Если &lt;var&gt;n&lt;/var&gt; не указано или равно нулю, используйте машинно-зависимое значение по умолчанию. Максимально допустимое значение параметра &lt;var&gt;n&lt;/var&gt; - 65536.</target>
        </trans-unit>
        <trans-unit id="759dfcc7101124f098c766f1c7cd00bcc6b949db" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;options&lt;/var&gt; is omitted, it defaults to &amp;lsquo;</source>
          <target state="translated">Если &lt;var&gt;options&lt;/var&gt; не указаны, по умолчанию используется '</target>
        </trans-unit>
        <trans-unit id="4a58d0d422304ea0f155ce08523224eb514fe6b5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;path&lt;/var&gt; is specified, GCC looks at the &lt;var&gt;path&lt;/var&gt; to find the profile feedback data files. See</source>
          <target state="translated">Если &lt;var&gt;path&lt;/var&gt; указан, GCC просматривает &lt;var&gt;path&lt;/var&gt; чтобы найти файлы данных обратной связи профиля. Видеть</target>
        </trans-unit>
        <trans-unit id="424b9b0e5144f1c216be7ac998c97fd4f7a0b3fa" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;type&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">Если &lt;var&gt;type&lt;/var&gt; '</target>
        </trans-unit>
        <trans-unit id="a48f8bd6ddf94d7b46204690dc61b7e1c17bca21" translate="yes" xml:space="preserve">
          <source>If GCC cannot find the subprogram using the specified prefix, it tries looking in the usual places for the subprogram.</source>
          <target state="translated">Если GCC не может найти подпрограмму,используя указанный префикс,он пытается искать в обычных местах для подпрограммы.</target>
        </trans-unit>
        <trans-unit id="49e516aa2892d9e488e19e4de501aef3c975c28a" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_is&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">Если GCC был настроен на использование GLIBC до версии 2.23, встроенная функция &lt;code&gt;__builtin_cpu_is&lt;/code&gt; всегда возвращает 0, и компилятор выдает предупреждение.</target>
        </trans-unit>
        <trans-unit id="009bc2728024c27e5f3a38c77a771a92e70da809" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">Если GCC был настроен на использование GLIBC до версии 2.23, встроенная функция &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; всегда возвращает 0, и компилятор выдает предупреждение.</target>
        </trans-unit>
        <trans-unit id="3d3dbe293db43d1939fa63d41a62ea0fb70dc054" translate="yes" xml:space="preserve">
          <source>If LTO encounters objects with C linkage declared with incompatible types in separate translation units to be linked together (undefined behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be issued. The behavior is still undefined at run time. Similar diagnostics may be raised for other languages.</source>
          <target state="translated">Если в LTO встречаются объекты со связью на языке С,объявленные с несовместимыми типами в отдельных единицах перевода,которые должны быть связаны (неопределенное поведение в соответствии с ISO C99 6.2.7),то может быть выдана несмертельная диагностика.Поведение остается неопределенным во время выполнения.Аналогичная диагностика может быть поднята и для других языков.</target>
        </trans-unit>
        <trans-unit id="8064195381cae5ba1afd9e1080f901756518ee59" translate="yes" xml:space="preserve">
          <source>If SSE extensions are enabled, &lt;code&gt;V4SF&lt;/code&gt; is used for a vector of four 32-bit floating-point values. Some instructions use a vector of four 32-bit integers, these use &lt;code&gt;V4SI&lt;/code&gt;. Finally, some instructions operate on an entire vector register, interpreting it as a 128-bit integer, these use mode &lt;code&gt;TI&lt;/code&gt;.</source>
          <target state="translated">Если расширения SSE включены, &lt;code&gt;V4SF&lt;/code&gt; используется для вектора из четырех 32-битных значений с плавающей запятой. В некоторых инструкциях используется вектор из четырех 32-битных целых чисел, в этих - &lt;code&gt;V4SI&lt;/code&gt; . Наконец, некоторые инструкции работают со всем векторным регистром, интерпретируя его как 128-битное целое число, они используют режим &lt;code&gt;TI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8aa3d549316941fe06d6dfd92787397e613a82c" translate="yes" xml:space="preserve">
          <source>If X is in the range 0&amp;hellip;7, then the &lt;var&gt;n&lt;/var&gt;-th result bit is set to the &lt;var&gt;X&lt;/var&gt;-th bit of &lt;var&gt;bits&lt;/var&gt;</source>
          <target state="translated">Если X находится в диапазоне 0&amp;hellip; 7, то &lt;var&gt;n&lt;/var&gt; -й бит результата устанавливается в &lt;var&gt;X&lt;/var&gt; -й &lt;var&gt;bits&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4795ba768ec1950f8dcd780b40f59791bb2c3400" translate="yes" xml:space="preserve">
          <source>If X is in the range 8&amp;hellip;&lt;code&gt;0xe&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th result bit is undefined.</source>
          <target state="translated">Если X находится в диапазоне 8&amp;hellip; &lt;code&gt;0xe&lt;/code&gt; , то &lt;var&gt;n&lt;/var&gt; -й бит результата не определен.</target>
        </trans-unit>
        <trans-unit id="77a0a28430753763f9053f0aed3455f25006e137" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;named address space&lt;/a&gt; other than generic or &lt;code&gt;__flash&lt;/code&gt; is used, then &lt;code&gt;RAMPZ&lt;/code&gt; is set as needed before the operation.</source>
          <target state="translated">Если используется &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;именованное адресное пространство,&lt;/a&gt; отличное от универсального или &lt;code&gt;__flash&lt;/code&gt; , то &lt;code&gt;RAMPZ&lt;/code&gt; устанавливается по мере необходимости перед операцией.</target>
        </trans-unit>
        <trans-unit id="e78a838d8422ed3d9e1991db7c391d81f3fd283d" translate="yes" xml:space="preserve">
          <source>If a class is declared to implement a protocol, a warning is issued for every method in the protocol that is not implemented by the class. The default behavior is to issue a warning for every method not explicitly implemented in the class, even if a method implementation is inherited from the superclass. If you use the</source>
          <target state="translated">Если класс объявлен для реализации протокола,то предупреждение выдается для каждого метода в протоколе,который не реализован классом.По умолчанию предупреждение выдается для каждого метода,явно не реализованного в классе,даже если реализация метода наследуется от суперкласса.При использовании метода</target>
        </trans-unit>
        <trans-unit id="29f23802437b44fdcdb64561f47637459cfd3577" translate="yes" xml:space="preserve">
          <source>If a diagnostic contains fix-it hints, it has a &lt;code&gt;fixits&lt;/code&gt; array, consisting of half-open intervals, similar to the output of</source>
          <target state="translated">Если диагностика содержит подсказки fix-it, у нее есть массив &lt;code&gt;fixits&lt;/code&gt; , состоящий из полуоткрытых интервалов, аналогичный выходным данным</target>
        </trans-unit>
        <trans-unit id="e94ab481666483b349181850cc8e39b26f438c5d" translate="yes" xml:space="preserve">
          <source>If a function returns a temporary &lt;code&gt;initializer_list&lt;/code&gt;, or a local &lt;code&gt;initializer_list&lt;/code&gt; variable, the array&amp;rsquo;s lifetime ends at the end of the return statement, so the value returned has a dangling pointer.</source>
          <target state="translated">Если функция возвращает временный &lt;code&gt;initializer_list&lt;/code&gt; или локальную переменную &lt;code&gt;initializer_list&lt;/code&gt; , время жизни массива заканчивается в конце оператора return, поэтому возвращаемое значение имеет висящий указатель.</target>
        </trans-unit>
        <trans-unit id="51be4d38853f3a30d7f15e3610ea69ae54265c4e" translate="yes" xml:space="preserve">
          <source>If a loop iterates over an array with a variable stride, create another version of the loop that assumes the stride is always one. For example:</source>
          <target state="translated">Если в цикле выполняется итерация по массиву с переменным шагом,создайте другую версию цикла,которая предполагает,что шаг всегда один.Например:</target>
        </trans-unit>
        <trans-unit id="e603935699eb5e105e69e65a9021ca2022ac4213" translate="yes" xml:space="preserve">
          <source>If a new-expression creates an &lt;code&gt;initializer_list&lt;/code&gt;, the array only lives until the end of the enclosing full-expression, so the &lt;code&gt;initializer_list&lt;/code&gt; in the heap has a dangling pointer.</source>
          <target state="translated">Если новое-выражение создает &lt;code&gt;initializer_list&lt;/code&gt; , массив живет только до конца включающего полного выражения, поэтому &lt;code&gt;initializer_list&lt;/code&gt; в куче имеет висящий указатель.</target>
        </trans-unit>
        <trans-unit id="dcc181452125b891816dee9715c4c073b739c819" translate="yes" xml:space="preserve">
          <source>If a program must use a different C++ library and it&amp;rsquo;s not possible to do the final link using a C++ driver that uses that library by default, it is necessary to tell &lt;code&gt;g++&lt;/code&gt; the location and name of that library. It might also be necessary to specify different startup files and other runtime support libraries, and to suppress the use of GCC&amp;rsquo;s support libraries with one or more of the options</source>
          <target state="translated">Если программа должна использовать другую библиотеку C ++ и невозможно выполнить окончательную компоновку с помощью драйвера C ++, который использует эту библиотеку по умолчанию, необходимо указать &lt;code&gt;g++&lt;/code&gt; расположение и имя этой библиотеки. Также может потребоваться указать другие файлы запуска и другие библиотеки поддержки времени выполнения, а также запретить использование библиотек поддержки GCC с помощью одного или нескольких параметров.</target>
        </trans-unit>
        <trans-unit id="e84c4785b4be9bc72195941ed1f8c2b45255457e" translate="yes" xml:space="preserve">
          <source>If a standard system include directory, or a directory specified with</source>
          <target state="translated">Если стандартная система включает в себя каталог,или каталог,указанный с помощью</target>
        </trans-unit>
        <trans-unit id="5c3be2ab717ecd782733ce9b93456fcb31fc4af7" translate="yes" xml:space="preserve">
          <source>If a variable has the &lt;code&gt;below100&lt;/code&gt; attribute (&lt;code&gt;BELOW100&lt;/code&gt; is allowed also), GCC places the variable in the first 0x100 bytes of memory and use special opcodes to access it. Such variables are placed in either the &lt;code&gt;.bss_below100&lt;/code&gt; section or the &lt;code&gt;.data_below100&lt;/code&gt; section.</source>
          <target state="translated">Если переменная имеет &lt;code&gt;below100&lt;/code&gt; атрибут ( &lt;code&gt;BELOW100&lt;/code&gt; допускается также), GCC помещает переменную в первые 0x100 байт памяти и использовать специальные опкоды для доступа к нему. Такие переменные помещаются либо в раздел &lt;code&gt;.bss_below100&lt;/code&gt; , либо в раздел &lt;code&gt;.data_below100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38c3454c59e77e91336081ab769819e7fd53ba65" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field follows a normal bit-field, the type of the zero-length bit-field may affect the alignment of the structure as whole. For example, &lt;code&gt;t2&lt;/code&gt; has a size of 4 bytes, since the zero-length bit-field follows a normal bit-field, and is of type short.</source>
          <target state="translated">Если битовое поле нулевой длины следует за нормальным битовым полем, тип битового поля нулевой длины может повлиять на выравнивание структуры в целом. Например, &lt;code&gt;t2&lt;/code&gt; имеет размер 4 байта, поскольку битовое поле нулевой длины следует за обычным битовым полем и имеет тип short.</target>
        </trans-unit>
        <trans-unit id="3930dc0fc00c26bd7cfbb87588dd5cf1e2064acf" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted after a bit-field, &lt;code&gt;foo&lt;/code&gt;, and the alignment of the zero-length bit-field is greater than the member that follows it, &lt;code&gt;bar&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is aligned as the type of the zero-length bit-field.</source>
          <target state="translated">Если битовое поле нулевой длины вставлено после битового поля, &lt;code&gt;foo&lt;/code&gt; , и выравнивание битового поля нулевой длины больше, чем элемент, следующий за ним, &lt;code&gt;bar&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; выравнивается как тип нулевого длина битового поля.</target>
        </trans-unit>
        <trans-unit id="487b9fa86178ee0fe71d79bf284c4ff7466101a0" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted between two bit-fields that are normally coalesced, the bit-fields are not coalesced.</source>
          <target state="translated">Если между двумя битонными полями,которые обычно коалесцируются,вставляется битонное поле нулевой длины,то битонные поля не коалесцируются.</target>
        </trans-unit>
        <trans-unit id="fce50e2e3a2f90483694041f1d50957c036fd376" translate="yes" xml:space="preserve">
          <source>If accessing any memory location is potentially unsafe when speculative execution is incorrect, then the code can be rewritten as</source>
          <target state="translated">Если доступ к какому-либо участку памяти потенциально опасен при некорректном выполнении спекулятивных операций,то код может быть переписан как</target>
        </trans-unit>
        <trans-unit id="19dee42123d1606545b47bdc1aee4dced42d70ef" translate="yes" xml:space="preserve">
          <source>If all calls to a given function are integrated, and the function is declared &lt;code&gt;static&lt;/code&gt;, then the function is normally not output as assembler code in its own right.</source>
          <target state="translated">Если все вызовы данной функции интегрированы и функция объявлена &lt;code&gt;static&lt;/code&gt; , то функция обычно не выводится как код ассемблера сама по себе.</target>
        </trans-unit>
        <trans-unit id="6747ee18a18040e35fcb4f80dbfe422de83e0b1d" translate="yes" xml:space="preserve">
          <source>If an explicit version number is provided and</source>
          <target state="translated">Если предоставлен явный номер версии и</target>
        </trans-unit>
        <trans-unit id="2a42f93a55377bd2fb4570f085c309d8859bae77" translate="yes" xml:space="preserve">
          <source>If an instruction only takes Altivec registers, you do not want to use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если инструкция принимает только регистры Altivec, вы не хотите использовать &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="364981cd1f151ee605ed86bfcc1747b52ebe7a19" translate="yes" xml:space="preserve">
          <source>If any of</source>
          <target state="translated">Если что-нибудь из</target>
        </trans-unit>
        <trans-unit id="d4335275a2f1edfde414bbe1e986ac43ea3a56a9" translate="yes" xml:space="preserve">
          <source>If any of the enabled test conditions is true, the corresponding entry in the result vector is -1. Otherwise (all of the enabled test conditions are false), the corresponding entry of the result vector is 0.</source>
          <target state="translated">Если одно из включенных условий теста истинно,то соответствующая запись в векторе результата равна -1.В противном случае (все включенные условия теста ложны),соответствующая запись в векторе результата равна 0.</target>
        </trans-unit>
        <trans-unit id="b0cb0b3f3853386544ffbd0fa1ea4935f0522535" translate="yes" xml:space="preserve">
          <source>If any of these options is used, then the linker is not run, and object file names should not be used as arguments. See &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;Overall Options&lt;/a&gt;.</source>
          <target state="translated">Если используется какой-либо из этих параметров, компоновщик не запускается, и имена объектных файлов не должны использоваться в качестве аргументов. См. &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;Общие параметры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66bff0fe442c04caa45d8e4b29fa05e61e69952b" translate="yes" xml:space="preserve">
          <source>If application code relies on copy-assignment, a user-defined copy-assignment operator removes any uncertainties. With such an operator, the application can define whether and how the virtual base subobject is assigned.</source>
          <target state="translated">Если код приложения полагается на задание копирования,пользовательский оператор задания копирования устраняет любые неопределенности.С помощью такого оператора приложение может определить,назначается ли виртуальный базовый подобъект,и если да,то каким образом.</target>
        </trans-unit>
        <trans-unit id="3e6fe2d65d6ae8e8dddd4d9d96db3ba491946874" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;interrupt&lt;/code&gt; are specified for the same function, &lt;code&gt;signal&lt;/code&gt; is silently ignored.</source>
          <target state="translated">Если для одной и той же функции указаны и &lt;code&gt;signal&lt;/code&gt; и &lt;code&gt;interrupt&lt;/code&gt; , &lt;code&gt;signal&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="9edaf55b500443b684dd1328cbcf6a8752769f40" translate="yes" xml:space="preserve">
          <source>If both arguments are zero, hotpatching is disabled.</source>
          <target state="translated">Если оба аргумента равны нулю,хотпатч отключается.</target>
        </trans-unit>
        <trans-unit id="32b3bc364441ca8a7ce5db371cd86527cc2b0b55" translate="yes" xml:space="preserve">
          <source>If both the template and enclosing class have explicit visibility, the visibility from the template is used.</source>
          <target state="translated">Если и шаблон,и класс-оболочка имеют явную видимость,то используется видимость из шаблона.</target>
        </trans-unit>
        <trans-unit id="02529d20c3d2e23aefd28ee9dcdbc7281d16eb72" translate="yes" xml:space="preserve">
          <source>If combined with</source>
          <target state="translated">В сочетании с</target>
        </trans-unit>
        <trans-unit id="af3104b1407804a82ad43f4fa2a84131be37f920" translate="yes" xml:space="preserve">
          <source>If control flow reaches the point of the &lt;code&gt;__builtin_unreachable&lt;/code&gt;, the program is undefined. It is useful in situations where the compiler cannot deduce the unreachability of the code.</source>
          <target state="translated">Если поток управления достигает точки &lt;code&gt;__builtin_unreachable&lt;/code&gt; , программа не определена. Это полезно в ситуациях, когда компилятор не может определить недостижимость кода.</target>
        </trans-unit>
        <trans-unit id="36b8c90f4b777d0cb2020f4d21e6ac15532c3ad9" translate="yes" xml:space="preserve">
          <source>If debugging information is output when using the precompiled header, using</source>
          <target state="translated">Если отладочная информация выводится при использовании прекомпилированного заголовка,то при использовании</target>
        </trans-unit>
        <trans-unit id="402b191a6d5b620de512d8843ce1f34d7777a814" translate="yes" xml:space="preserve">
          <source>If either of the ways of changing the assembly name of a declaration are applied to a declaration whose assembly name has already been determined (either by a previous use of one of these features, or because the compiler needed the assembly name in order to generate code), and the new name is different, a warning issues and the name does not change.</source>
          <target state="translated">Если любой из способов изменения имени ассемблера декларации применяется к декларации,имя ассемблера которой уже было определено (либо в результате предыдущего использования одной из этих возможностей,либо потому,что компилятору для генерации кода понадобилось имя ассемблера),а новое имя отличается,то выдается предупреждение,и имя не меняется.</target>
        </trans-unit>
        <trans-unit id="8e6cf380114ced6b961e13544b6be03dfc3354e5" translate="yes" xml:space="preserve">
          <source>If enabled, control-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the control speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">Если включено,то команды управления-спекулятивные выбираются для расписания только в том случае,если на данный момент нет других вариантов.Это делает использование спекулятивных команд более консервативным.Установка по умолчанию отключена.</target>
        </trans-unit>
        <trans-unit id="c9aeee8753743f519ff715357d9285071a0d9d86" translate="yes" xml:space="preserve">
          <source>If enabled, data-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the data speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">Если эта функция включена,то команды-спекулятивные по данным выбираются для расписания только в том случае,если на данный момент нет других вариантов.Это делает использование спекуляции данными гораздо более консервативным.Настройка по умолчанию отключена.</target>
        </trans-unit>
        <trans-unit id="12c5281bb30137f5a28029f336bddc2453ae8835" translate="yes" xml:space="preserve">
          <source>If enabled, speculative dependencies are considered during computation of the instructions priorities. This makes the use of the speculation a bit more conservative. The default setting is disabled.</source>
          <target state="translated">Если она включена,то при расчете приоритетов инструкций учитываются спекулятивные зависимости.Это делает использование спекуляции более консервативным.Настройка по умолчанию отключена.</target>
        </trans-unit>
        <trans-unit id="9d63d7ff73f8a910b7cb613706af4cc8bb2d95b9" translate="yes" xml:space="preserve">
          <source>If enabled, the maximum amount of space required for outgoing arguments is computed in the function prologue. This is faster on most modern CPUs because of reduced dependencies, improved scheduling and reduced stack usage when the preferred stack boundary is not equal to 2. The drawback is a notable increase in code size. This switch implies</source>
          <target state="translated">Если включено,то в прологе функции вычисляется максимальное количество места,требуемое для исходящих аргументов.Это быстрее на большинстве современных процессоров из-за уменьшения зависимостей,улучшения планирования и уменьшения использования стека,когда граница предпочтительного стека не равна 2.Недостатком является заметное увеличение размера кода.Данный переключатель подразумевает</target>
        </trans-unit>
        <trans-unit id="40d23331ec805b8693bd0e7ed41af8f41bbbeef4" translate="yes" xml:space="preserve">
          <source>If functions are defined in one file and are called in another file, then be sure to write this declaration in both files.</source>
          <target state="translated">Если функции определены в одном файле и вызваны в другом файле,то обязательно запишите это объявление в оба файла.</target>
        </trans-unit>
        <trans-unit id="5a84ad9332942b0583d76324d55388fa827b1dc5" translate="yes" xml:space="preserve">
          <source>If it is a scalar type, or on most targets an aggregate type whose only member object is of a scalar type, or a union type whose member objects are of scalar types, the expression is interpreted by GCC as a read of the volatile object; in the other cases, the expression is only evaluated for its side effects.</source>
          <target state="translated">Если это скалярный тип,или на большинстве целей агрегированный тип,чей единственный объект-член имеет скалярный тип,или объединенный тип,чьи объекты-члены имеют скалярные типы,выражение интерпретируется GCC как чтение волатильного объекта;в других случаях выражение оценивается только на предмет его побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="79c1054be8ddf1396d899393bbaa81764a2eed88" translate="yes" xml:space="preserve">
          <source>If multiple</source>
          <target state="translated">Если несколько</target>
        </trans-unit>
        <trans-unit id="e94921c7bd35daddf444608f5259a29f5f4c8cc8" translate="yes" xml:space="preserve">
          <source>If neither</source>
          <target state="translated">Если ни то,ни другое</target>
        </trans-unit>
        <trans-unit id="afb8c1ba0a7e5bf800f44e5494e9d700db801b00" translate="yes" xml:space="preserve">
          <source>If new system header files are installed, nothing automatically arranges to update the corrected header files. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">Если установлены новые системные файлы заголовков, ничего автоматически не обновляет исправленные файлы заголовков. Их можно обновить с &lt;code&gt;mkheaders&lt;/code&gt; скрипта mkheaders, установленного в</target>
        </trans-unit>
        <trans-unit id="b7def704de696eb922c5e5ba1f5217476d727ef7" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is defined in your code, the compiler will automatically replace &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; with &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt;, where that type is silently defined by the compiler in an identical way. This can be confusing and we recommend that you define &lt;code&gt;NSFastEnumerationState&lt;/code&gt; (as shown above) instead.</source>
          <target state="translated">Если в вашем коде не определено &lt;code&gt;NSFastEnumerationState&lt;/code&gt; , компилятор автоматически заменит &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; на &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt; , где этот тип автоматически определяется компилятором таким же образом. Это может сбивать с толку, и мы рекомендуем вместо этого определить &lt;code&gt;NSFastEnumerationState&lt;/code&gt; (как показано выше).</target>
        </trans-unit>
        <trans-unit id="089bb39031737c14c4b1a0b430296a1926daaea0" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;arg-index&lt;/var&gt; is given to the &lt;code&gt;nonnull&lt;/code&gt; attribute, all pointer arguments are marked as non-null. To illustrate, the following declaration is equivalent to the previous example:</source>
          <target state="translated">Если атрибуту, &lt;code&gt;nonnull&lt;/code&gt; NULL, не задан &lt;var&gt;arg-index&lt;/var&gt; , все аргументы указателя помечаются как ненулевые. Для иллюстрации следующее объявление эквивалентно предыдущему примеру:</target>
        </trans-unit>
        <trans-unit id="73b44337d5bc4559e8e1c4b6db36d411b8aef133" translate="yes" xml:space="preserve">
          <source>If no error occurs during compilation, run the compiler a second time, adding &lt;var&gt;opts&lt;/var&gt; and</source>
          <target state="translated">Если во время компиляции ошибок не возникает, запустите компилятор второй раз, добавив &lt;var&gt;opts&lt;/var&gt; и</target>
        </trans-unit>
        <trans-unit id="0e662391588b3d6a0fd25b9abb8a35c922931e60" translate="yes" xml:space="preserve">
          <source>If no fixup is needed, this function simply passes through &lt;var&gt;addr&lt;/var&gt;.</source>
          <target state="translated">Если исправление не требуется, эта функция просто проходит через &lt;var&gt;addr&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0304f8188faa2beb1f6913883824900b9fd415" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all calls might be beyond the offset range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, and therefore load the function address into a register before performing a (otherwise direct) call. This is the default.</source>
          <target state="translated">Если иное не указано в атрибуте, предположим, что все вызовы могут быть вне диапазона смещения инструкций &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; , и поэтому загрузите адрес функции в регистр перед выполнением (в противном случае прямого) вызова. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4019c8219c3b5cd2dda4dbb0cb3bf4c2a485adff" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all direct calls are in the range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, so use these instructions for direct calls. The default is</source>
          <target state="translated">Если иное не указано в атрибуте, предположим, что все прямые вызовы находятся в диапазоне инструкций &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; , поэтому используйте эти инструкции для прямых вызовов. По умолчанию</target>
        </trans-unit>
        <trans-unit id="12a28d9821da145a465f7298f6e4c4d208680d82" translate="yes" xml:space="preserve">
          <source>If number of memory accesses in function being instrumented is greater or equal to this number, use callbacks instead of inline checks. E.g. to disable inline code use</source>
          <target state="translated">Если количество обращений к памяти в инструментируемой функции больше или равно этому числу,используйте обратные вызовы вместо встроенных проверок.Например,чтобы отключить использование встроенного кода</target>
        </trans-unit>
        <trans-unit id="5104c1df665f6fc4dddeb5595f01af321de5cad6" translate="yes" xml:space="preserve">
          <source>If object files containing GIMPLE bytecode are stored in a library archive, say</source>
          <target state="translated">Если объектные файлы,содержащие байткод GIMPLE,хранятся в архиве библиотеки,скажем</target>
        </trans-unit>
        <trans-unit id="1debeabea3e55864c791086673e07af5641e2395" translate="yes" xml:space="preserve">
          <source>If patchable function entries are enabled globally using the command-line option</source>
          <target state="translated">Если записи патч-функций включены глобально с помощью опции командной строки</target>
        </trans-unit>
        <trans-unit id="7ae6684dfcfa35ba16cecacd5ec92f0fb9e0c04e" translate="yes" xml:space="preserve">
          <source>If profiling is active (</source>
          <target state="translated">Если профилирование активно (</target>
        </trans-unit>
        <trans-unit id="88f3c4dd1f2c3c978031ca46886480a0ad40a791" translate="yes" xml:space="preserve">
          <source>If supported by the target machine, generate instructions to prefetch memory to improve the performance of loops that access large arrays.</source>
          <target state="translated">Если это поддерживается целевой машиной,сгенерируйте инструкции по предварительной выборке памяти для улучшения производительности циклов доступа к большим массивам.</target>
        </trans-unit>
        <trans-unit id="8bfe7e580871525d66e6234642f97096fcdef387" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable. This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating-point instruction is required.</source>
          <target state="translated">Если это поддерживается для целевой машины,попробуйте переупорядочить инструкции для устранения сбоев в работе из-за недоступности необходимых данных.Это помогает машинам с медленной загрузкой инструкций с плавающей запятой или с плавающей запятой,позволяя выдавать другие инструкции до тех пор,пока результат загрузки или инструкции с плавающей запятой не понадобится.</target>
        </trans-unit>
        <trans-unit id="3428a2e4a1d11936eea0f07c36277bc2aa02d581" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.</source>
          <target state="translated">Если поддерживается для целевой машины,попробуйте переупорядочить инструкции для использования слотов команд,доступных после отложенных инструкций в ответвлении.</target>
        </trans-unit>
        <trans-unit id="324f5e0a0812879119b6243a7b551f6c87385665" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, emit position-independent code, suitable for dynamic linking and avoiding any limit on the size of the global offset table. This option makes a difference on AArch64, m68k, PowerPC and SPARC.</source>
          <target state="translated">При поддержке целевой машины излучайте код,не зависящий от положения,подходящий для динамической привязки и позволяющий избежать ограничения размера глобальной таблицы смещения.Эта опция имеет значение для AArch64,m68k,PowerPC и SPARC.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="848af5bfa5ce573c8e5c9af3ee618628d308338c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LC_ALL&lt;/code&gt; environment variable is set, it overrides the value of &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt;; otherwise, &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; default to the value of the &lt;code&gt;LANG&lt;/code&gt; environment variable. If none of these variables are set, GCC defaults to traditional C English behavior.</source>
          <target state="translated">Если &lt;code&gt;LC_ALL&lt;/code&gt; переменная среды LC_ALL , она переопределяет значение &lt;code&gt;LC_CTYPE&lt;/code&gt; и &lt;code&gt;LC_MESSAGES&lt;/code&gt; ; в противном случае &lt;code&gt;LC_CTYPE&lt;/code&gt; и &lt;code&gt;LC_MESSAGES&lt;/code&gt; по умолчанию равны значению переменной среды &lt;code&gt;LANG&lt;/code&gt; . Если ни одна из этих переменных не установлена, GCC по умолчанию использует традиционное поведение C English.</target>
        </trans-unit>
        <trans-unit id="927b034e0a10d14fe57f4acd375117bf77534e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt; attribute is used on a function declaration and a call to such a function is not eliminated through dead code elimination or other optimizations, an error or warning (respectively) that includes &lt;var&gt;message&lt;/var&gt; is diagnosed. This is useful for compile-time checking, especially together with &lt;code&gt;__builtin_constant_p&lt;/code&gt; and inline functions where checking the inline function arguments is not possible through &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; tricks.</source>
          <target state="translated">Если атрибут &lt;code&gt;error&lt;/code&gt; или &lt;code&gt;warning&lt;/code&gt; используется в объявлении функции и вызов такой функции не устраняется путем исключения мертвого кода или других оптимизаций, диагностируется ошибка или предупреждение (соответственно), содержащее &lt;var&gt;message&lt;/var&gt; . Это полезно для проверки во время компиляции, особенно вместе с &lt;code&gt;__builtin_constant_p&lt;/code&gt; и встроенными функциями, где проверка аргументов встроенной функции невозможна с помощью &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; ухищрения.</target>
        </trans-unit>
        <trans-unit id="20d0c6878745134aa8d904b0690e4fcbddc7d599" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;filename&lt;/var&gt; is provided, then the dumps from all the applicable optimizations are concatenated into the &lt;var&gt;filename&lt;/var&gt;. Otherwise the dump is output onto</source>
          <target state="translated">Если указано &lt;var&gt;filename&lt;/var&gt; , то дампы всех применимых оптимизаций объединяются в &lt;var&gt;filename&lt;/var&gt; . В противном случае дамп выводится на</target>
        </trans-unit>
        <trans-unit id="9215ad70f2e3e9c6cab1765215d93885159eaa97" translate="yes" xml:space="preserve">
          <source>If the C code that follows the &lt;code&gt;asm&lt;/code&gt; makes no use of any of the output operands, use &lt;code&gt;volatile&lt;/code&gt; for the &lt;code&gt;asm&lt;/code&gt; statement to prevent the optimizers from discarding the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">Если код C, следующий за &lt;code&gt;asm&lt;/code&gt; , не использует ни один из выходных операндов, используйте &lt;code&gt;volatile&lt;/code&gt; для оператора &lt;code&gt;asm&lt;/code&gt; , чтобы не дать оптимизаторам отбросить оператор &lt;code&gt;asm&lt;/code&gt; как ненужный (см. &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2aa76d6986dfd258dee402c2c95ca11459599c59" translate="yes" xml:space="preserve">
          <source>If the CPU is executing speculatively then either:</source>
          <target state="translated">Если процессор работает спекулятивно,то и он тоже:</target>
        </trans-unit>
        <trans-unit id="8fe995e077eb81e27ea124938efd43a017d00001" translate="yes" xml:space="preserve">
          <source>If the CPU is not speculatively executing the code, then &lt;var&gt;val&lt;/var&gt; is returned.</source>
          <target state="translated">Если ЦП не выполняет код предположительно, возвращается значение &lt;var&gt;val&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c68ba352d7c54da4de70d37cd280b24a3feb4442" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for 64-bit targets. New vector types (&lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt;) are available to hold the &lt;var&gt;__int128&lt;/var&gt; and &lt;var&gt;__uint128&lt;/var&gt; types to use these builtins.</source>
          <target state="translated">Если в ISA 2.07 доступны дополнения к набору векторных / скалярных (power8-vector) команд, для 64-битных целей доступны следующие дополнительные функции. &lt;var&gt;vector __int128&lt;/var&gt; новые векторные типы ( vector __int128 и &lt;var&gt;vector __uint128&lt;/var&gt; ) для хранения типов &lt;var&gt;__int128&lt;/var&gt; и &lt;var&gt;__uint128&lt;/var&gt; для использования этих встроенных функций .</target>
        </trans-unit>
        <trans-unit id="7ad5ced5d695028f0b739572f683d981d7b325cd" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for both 32-bit and 64-bit targets. For 64-bit targets, you can use &lt;var&gt;vector long&lt;/var&gt; instead of &lt;var&gt;vector long long&lt;/var&gt;, &lt;var&gt;vector bool long&lt;/var&gt; instead of &lt;var&gt;vector bool long long&lt;/var&gt;, and &lt;var&gt;vector unsigned long&lt;/var&gt; instead of &lt;var&gt;vector unsigned long long&lt;/var&gt;.</source>
          <target state="translated">Если дополнения ISA 2.07 к набору векторных / скалярных (power8-vector) команд доступны, следующие дополнительные функции доступны как для 32-битных, так и для 64-битных целей. Для 64-битных целей вы можете использовать &lt;var&gt;vector long&lt;/var&gt; вместо &lt;var&gt;vector long long&lt;/var&gt; , &lt;var&gt;vector bool long&lt;/var&gt; вместо &lt;var&gt;vector bool long long&lt;/var&gt; и &lt;var&gt;vector unsigned long&lt;/var&gt; вместо &lt;var&gt;vector unsigned long long&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c22a3317bedd3145de7eb3a31ecc603e64eb80be" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions (</source>
          <target state="translated">Если набор инструкций ISA 3.0 добавляет (</target>
        </trans-unit>
        <trans-unit id="424b99254d8407b86c2beca1ac6e71a6fca8ab99" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions are enabled (</source>
          <target state="translated">Если включено добавление набора команд ISA 3.0 (</target>
        </trans-unit>
        <trans-unit id="b3ba2117601e3a207db62aaa0d548209b490cb82" translate="yes" xml:space="preserve">
          <source>If the argument to the macro has variably modified type, it is evaluated only once when using &lt;code&gt;__auto_type&lt;/code&gt;, but twice if &lt;code&gt;typeof&lt;/code&gt; is used.</source>
          <target state="translated">Если аргумент макроса имеет изменяемый тип, он оценивается только один раз при использовании &lt;code&gt;__auto_type&lt;/code&gt; и дважды, если используется &lt;code&gt;typeof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5db05160eb702af65a65d649789a2509aade574" translate="yes" xml:space="preserve">
          <source>If the attribute is specified and &lt;code&gt;#pragma omp declare simd&lt;/code&gt; is present on a declaration and the</source>
          <target state="translated">Если атрибут указан и &lt;code&gt;#pragma omp declare simd&lt;/code&gt; присутствует в объявлении и</target>
        </trans-unit>
        <trans-unit id="d120c6bfa80fbe55cec1d9862d7e2421db795ea2" translate="yes" xml:space="preserve">
          <source>If the compiler was built to use the system&amp;rsquo;s headers by default, then the default for this option is the system version on which the compiler is running, otherwise the default is to make choices that are compatible with as many systems and code bases as possible.</source>
          <target state="translated">Если компилятор был построен для использования заголовков системы по умолчанию, то по умолчанию для этого параметра используется версия системы, на которой работает компилятор, в противном случае по умолчанию выбираются варианты, совместимые с максимально возможным количеством систем и баз кода.</target>
        </trans-unit>
        <trans-unit id="d67b52944ba9df1fde368725db64f0de08228c75" translate="yes" xml:space="preserve">
          <source>If the compiler&amp;rsquo;s optimization uses a function&amp;rsquo;s body or information extracted from its body to optimize/change another function, the latter is called an impacted function of the former. If a function is patched, its impacted functions should be patched too.</source>
          <target state="translated">Если при оптимизации компилятора используется тело функции или информация, извлеченная из его тела, для оптимизации / изменения другой функции, последняя называется затронутой функцией первой. Если функция исправлена, ее затронутые функции также должны быть исправлены.</target>
        </trans-unit>
        <trans-unit id="b237760180d1507d3e5ec309754cc736d88da667" translate="yes" xml:space="preserve">
          <source>If the cryptographic instructions are enabled (</source>
          <target state="translated">Если включены криптографические инструкции (</target>
        </trans-unit>
        <trans-unit id="4fb7464a62433bc1b1813aee95893c7c7b12fed7" translate="yes" xml:space="preserve">
          <source>If the device comes with a specific &lt;code&gt;RAMP&lt;/code&gt; register, the ISR prologue/epilogue saves/restores that SFR and initializes it with zero in case the ISR code might (implicitly) use it.</source>
          <target state="translated">Если устройство поставляется с определенным регистром &lt;code&gt;RAMP&lt;/code&gt; , пролог / эпилог ISR сохраняет / восстанавливает этот SFR и инициализирует его нулем на случай, если код ISR может (неявно) использовать его.</target>
        </trans-unit>
        <trans-unit id="f359291701f84a5c952e96591467d10e46106142" translate="yes" xml:space="preserve">
          <source>If the device supports RAM larger than 64 KiB and the compiler needs to change &lt;code&gt;RAMPZ&lt;/code&gt; to accomplish an operation, &lt;code&gt;RAMPZ&lt;/code&gt; is reset to zero after the operation.</source>
          <target state="translated">Если устройство поддерживает RAM размером более 64 КиБ, и компилятору необходимо изменить &lt;code&gt;RAMPZ&lt;/code&gt; для выполнения операции, &lt;code&gt;RAMPZ&lt;/code&gt; сбрасывается в ноль после операции.</target>
        </trans-unit>
        <trans-unit id="4b99e2eb0f30f6704cb82d8729d610b9c040ff67" translate="yes" xml:space="preserve">
          <source>If the equal sign is omitted, the default</source>
          <target state="translated">Если знак равенства опущен,то по умолчанию</target>
        </trans-unit>
        <trans-unit id="d2b152efe933ab511c3240207de045545a59413b" translate="yes" xml:space="preserve">
          <source>If the forwarding hook does not exist or returns &lt;code&gt;NULL&lt;/code&gt;, the runtime currently attempts forwarding using an older, deprecated API, and if that fails, it aborts the program. In future versions of the GNU Objective-C runtime, the runtime will immediately abort.</source>
          <target state="translated">Если ловушка пересылки не существует или возвращает &lt;code&gt;NULL&lt;/code&gt; , среда выполнения в настоящее время пытается пересылку с использованием более старого, устаревшего API, и если это не удается, она прерывает программу. В будущих версиях среды выполнения GNU Objective-C среда выполнения будет немедленно прервана.</target>
        </trans-unit>
        <trans-unit id="fb3ee17ffd6e7e71752206840400cc69026ba54d" translate="yes" xml:space="preserve">
          <source>If the function is called repeatedly with &lt;code&gt;untrusted_index&lt;/code&gt; less than the limit of 500, then a branch predictor will learn that the block of code that returns a value stored in &lt;code&gt;array&lt;/code&gt; will be executed. If the function is subsequently called with an out-of-range value it will still try to execute that block of code first until the CPU determines that the prediction was incorrect (the CPU will unwind any incorrect operations at that point). However, depending on how the result of the function is used, it might be possible to leave traces in the cache that can reveal what was stored at the out-of-bounds location. The built-in function can be used to provide some protection against leaking data in this way by changing the code to:</source>
          <target state="translated">Если функция вызывается повторно с &lt;code&gt;untrusted_index&lt;/code&gt; меньше предела 500, то предсказатель ветвления узнает, что будет выполнен блок кода, который возвращает значение, хранящееся в &lt;code&gt;array&lt;/code&gt; . Если функция впоследствии вызывается со значением, выходящим за пределы допустимого диапазона, она все равно будет пытаться сначала выполнить этот блок кода, пока ЦП не определит, что прогноз был неверным (ЦП отмотает все некорректные операции в этот момент). Однако, в зависимости от того, как используется результат функции, можно оставить следы в кэше, которые могут показать, что было сохранено в расположении вне пределов. Встроенную функцию можно использовать для обеспечения некоторой защиты от утечки данных таким образом, изменив код на:</target>
        </trans-unit>
        <trans-unit id="4966bfe90659d4fba00a57263dad419daa50166b" translate="yes" xml:space="preserve">
          <source>If the function is declared &lt;code&gt;extern&lt;/code&gt;, then this definition of the function is used only for inlining. In no case is the function compiled as a standalone function, not even if you take its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it. This has almost the effect of a macro. The way to use this is to put a function definition in a header file with this attribute, and put another copy of the function, without &lt;code&gt;extern&lt;/code&gt;, in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library. Note that the two definitions of the functions need not be precisely the same, although if they do not have the same effect your program may behave oddly.</source>
          <target state="translated">Если функция объявлена ​​как &lt;code&gt;extern&lt;/code&gt; , то это определение функции используется только для встраивания. Ни в коем случае функция не компилируется как отдельная функция, даже если вы явно укажете ее адрес. Такой адрес становится внешней ссылкой, как если бы вы только объявили функцию, а не определили ее. Это почти похоже на макрос. Способ использовать это - поместить определение функции в файл заголовка с этим атрибутом и поместить другую копию функции без &lt;code&gt;extern&lt;/code&gt; в файле библиотеки. Определение в файле заголовка заставляет большинство вызовов функции быть встроенными. Если какие-либо варианты использования функции остаются, они относятся к единственной копии в библиотеке. Обратите внимание, что два определения функций не обязательно должны быть в точности одинаковыми, хотя, если они не имеют одинакового эффекта, ваша программа может вести себя странно.</target>
        </trans-unit>
        <trans-unit id="b771c97ff2c33b584d16ad8091b88c7d383e2d71" translate="yes" xml:space="preserve">
          <source>If the function is inlined in several places, the block structure in each location might not be the same. For instance, a condition might now be calculable at compile time in some instances. Because the coverage of all the uses of the inline function will be shown for the same source lines, the line counts themselves might seem inconsistent.</source>
          <target state="translated">Если функция вставлена в несколько мест,то структура блоков в каждом из них может отличаться.Например,в некоторых случаях условие может быть вычислено во время компиляции.Так как покрытие всех видов использования функции inline будет показано для одних и тех же исходных строк,количество строк в самих строках может показаться непоследовательным.</target>
        </trans-unit>
        <trans-unit id="f54a0365a2045222faa9a6a632a364c211ec115e" translate="yes" xml:space="preserve">
          <source>If the function is not inlined, the compiler must emit an out of line copy of the function, in any object file that needs it. If</source>
          <target state="translated">Если функция не подстроена,компилятор должен выдать внестрочную копию функции,в любом объектном файле,который в ней нуждается.Если</target>
        </trans-unit>
        <trans-unit id="1d41e4e5598657e0dd5a304d5f9d42468e2c3eb3" translate="yes" xml:space="preserve">
          <source>If the hotpatch option is enabled, a &amp;ldquo;hot-patching&amp;rdquo; function prologue is generated for all functions in the compilation unit. The funtion label is prepended with the given number of two-byte NOP instructions (&lt;var&gt;pre-halfwords&lt;/var&gt;, maximum 1000000). After the label, 2 * &lt;var&gt;post-halfwords&lt;/var&gt; bytes are appended, using the largest NOP like instructions the architecture allows (maximum 1000000).</source>
          <target state="translated">Если опция &amp;laquo;горячего исправления&amp;raquo; включена, пролог функции &amp;laquo;горячего исправления&amp;raquo; создается для всех функций в модуле компиляции. К метке функции добавляется заданное количество двухбайтовых инструкций NOP ( &lt;var&gt;pre-halfwords&lt;/var&gt; , максимум 1000000). После метки добавляются 2 * &lt;var&gt;post-halfwords&lt;/var&gt; байта, используя самые большие NOP-подобные инструкции, которые позволяет архитектура (максимум 1000000).</target>
        </trans-unit>
        <trans-unit id="1afbfd9c64402361ab2fa39f9fdbd1e3be8c266e" translate="yes" xml:space="preserve">
          <source>If the input program contains a function declaration such as:</source>
          <target state="translated">Если программа ввода содержит декларацию функций,например:</target>
        </trans-unit>
        <trans-unit id="d87ca5a862edf69ec778f2863678b3c80b02aa1b" translate="yes" xml:space="preserve">
          <source>If the linker complains that an application is using too much small data, you might want to try rebuilding the less performance-critical parts with</source>
          <target state="translated">Если компоновщик жалуется,что приложение использует слишком много маленьких данных,вы можете попробовать воссоздать менее критичные для производительности части с помощью</target>
        </trans-unit>
        <trans-unit id="2bf1dd3a359ed16413542f38135a6d9bd4288cff" translate="yes" xml:space="preserve">
          <source>If the number of candidates in the set is smaller than this value, always try to remove unnecessary ivs from the set when adding a new one.</source>
          <target state="translated">Если количество кандидатов в наборе меньше этого значения,всегда старайтесь удалять ненужные ivs из набора при добавлении нового.</target>
        </trans-unit>
        <trans-unit id="e7428a6a85aa26ccfc1d34f1f1cde51cd5cd4798" translate="yes" xml:space="preserve">
          <source>If the operand of &lt;code&gt;__alignof__&lt;/code&gt; is an lvalue rather than a type, its value is the required alignment for its type, taking into account any minimum alignment specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;). For example, after this declaration:</source>
          <target state="translated">Если операнд &lt;code&gt;__alignof__&lt;/code&gt; является lvalue, а не типом, его значение является требуемым выравниванием для его типа с учетом любого минимального выравнивания, заданного атрибутом &lt;code&gt;aligned&lt;/code&gt; (см. &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Общие атрибуты переменных&lt;/a&gt; ). Например, после этого объявления:</target>
        </trans-unit>
        <trans-unit id="a5fda9cca36b52c744155ff2696d3cbfb80c2db1" translate="yes" xml:space="preserve">
          <source>If the operand of the &lt;code&gt;__alignof__&lt;/code&gt; expression is a function, the expression evaluates to the alignment of the function which may be specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;).</source>
          <target state="translated">Если операнд выражения &lt;code&gt;__alignof__&lt;/code&gt; является функцией, выражение оценивает выравнивание функции, которое может быть определено с помощью атрибута &lt;code&gt;aligned&lt;/code&gt; (см. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="716641ab8a53f52206a358470c323b2f23eaf7fa" translate="yes" xml:space="preserve">
          <source>If the ratio of expression insertions to deletions is larger than this value for any expression, then RTL PRE inserts or removes the expression and thus leaves partially redundant computations in the instruction stream.</source>
          <target state="translated">Если отношение количества вставок выражений к количеству удалений больше,чем это значение для любого выражения,то RTL PRE вставляет или удаляет выражение и,таким образом,оставляет частично избыточные вычисления в потоке команд.</target>
        </trans-unit>
        <trans-unit id="05912318b76a1009d770bd192ecd133075c5fc90" translate="yes" xml:space="preserve">
          <source>If the register is a call-saved register, call ABI is affected: the register will not be restored in function epilogue sequences after the variable has been assigned. Therefore, functions cannot safely return to callers that assume standard ABI.</source>
          <target state="translated">Если регистр является регистром с сохранением вызовов,то это влияет на вызов ABI:регистр не будет восстановлен в последовательностях эпилога функции после присвоения переменной.Поэтому функции не могут безопасно вернуться к вызывающим,которые принимают стандартный ABI.</target>
        </trans-unit>
        <trans-unit id="9d80c0f0c0e0e7931ed927bbb4a8416d7ae0d80f" translate="yes" xml:space="preserve">
          <source>If the same field is initialized multiple times, or overlapping fields of a union are initialized, the value from the last initialization is used. When a field of a union is itself a structure, the entire structure from the last field initialized is used. If any previous initializer has side effect, it is unspecified whether the side effect happens or not. Currently, GCC discards the side-effecting initializer expressions and issues a warning.</source>
          <target state="translated">Если одно и то же поле инициализируется несколько раз или инициализируются перекрывающиеся поля объединения,используется значение из последней инициализации.Если поле объединения само по себе является структурой,то используется вся структура из последнего инициализированного поля.Если какая-либо предыдущая инициализация имеет побочный эффект,то неизвестно,происходит ли этот побочный эффект или нет.В настоящее время GCC отбрасывает связанные с побочным эффектом выражения инициализатора и выдает предупреждение.</target>
        </trans-unit>
        <trans-unit id="60d643b079de10a712e4f0092195d4a678550bd1" translate="yes" xml:space="preserve">
          <source>If the second argument of a shift operation is within range, check that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc.</source>
          <target state="translated">Если второй аргумент операции сдвига находится в пределах диапазона,проверьте,что результат операции сдвига не неопределен.Обратите внимание,что то,что именно считается неопределенным,немного различается между С и С++,а также между ISO C90 и C99,и т.д.</target>
        </trans-unit>
        <trans-unit id="a31cdc2866161da54d441996165823d561084f93" translate="yes" xml:space="preserve">
          <source>If the selected floating-point hardware includes the NEON extension (e.g.</source>
          <target state="translated">Если выбранное аппаратное обеспечение с плавающей запятой включает в себя расширение NEON (например</target>
        </trans-unit>
        <trans-unit id="ba7e4ec3c7ed6c8b730bc79d728df15242bb6315" translate="yes" xml:space="preserve">
          <source>If the size of a local variable in bytes is smaller or equal to this number, directly poison (or unpoison) shadow memory instead of using run-time callbacks.</source>
          <target state="translated">Если размер локальной переменной в байтах меньше или равен этому числу,непосредственно отравить (или не отравить)теневую память вместо использования обратных вызовов во время выполнения.</target>
        </trans-unit>
        <trans-unit id="417bd3fd4051d252d11a2c9158594ed0d6e39230" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic and not bounded, it&amp;rsquo;s:</source>
          <target state="translated">Если использование стека (частично) динамическое и не ограничено, это:</target>
        </trans-unit>
        <trans-unit id="b6665e1bf11576c0ed34f60f152094f72a6d33b1" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic but bounded, it&amp;rsquo;s:</source>
          <target state="translated">Если использование стека (частично) динамическое, но ограниченное, оно:</target>
        </trans-unit>
        <trans-unit id="6185bf1adb7da0baa58ee0f68d56a9ef418a48d1" translate="yes" xml:space="preserve">
          <source>If the stack usage is fully static but exceeds the specified amount, it&amp;rsquo;s:</source>
          <target state="translated">Если использование стека полностью статично, но превышает указанное количество, оно:</target>
        </trans-unit>
        <trans-unit id="d70267f0ff1a52892efb70d9a08fcf6abe326706" translate="yes" xml:space="preserve">
          <source>If the target does not require instruction cache flushes, &lt;code&gt;__builtin___clear_cache&lt;/code&gt; has no effect. Otherwise either instructions are emitted in-line to clear the instruction cache or a call to the &lt;code&gt;__clear_cache&lt;/code&gt; function in libgcc is made.</source>
          <target state="translated">Если цель не требует сброса кэша инструкций, &lt;code&gt;__builtin___clear_cache&lt;/code&gt; не имеет никакого эффекта. В противном случае либо инструкции выбрасываются в линии , чтобы очистить кэш команд или вызов на &lt;code&gt;__clear_cache&lt;/code&gt; функция в libgcc производятся.</target>
        </trans-unit>
        <trans-unit id="095e473e81d277e85bb1ebdb8df1dacc96479003" translate="yes" xml:space="preserve">
          <source>If the target does not support data prefetch, the address expression is evaluated if it includes side effects but no other code is generated and GCC does not issue a warning.</source>
          <target state="translated">Если цель не поддерживает предварительную выборку данных,выражение адреса вычисляется,если оно включает побочные эффекты,но другой код не генерируется,и GCC не выдает предупреждение.</target>
        </trans-unit>
        <trans-unit id="063fcca71547a7fd5efc66500b8f981bd9c39ed3" translate="yes" xml:space="preserve">
          <source>If the target supports a BSS section, GCC by default puts variables that are initialized to zero into BSS. This can save space in the resulting code.</source>
          <target state="translated">Если цель поддерживает раздел BSS,GCC по умолчанию помещает в BSS переменные,которые инициализируются в ноль.Это может сэкономить место в результирующем коде.</target>
        </trans-unit>
        <trans-unit id="3918a65b7ea046bcd3f9722a5e8050706b67b421" translate="yes" xml:space="preserve">
          <source>If the transaction aborts, all side effects are undone and an abort code encoded as a bit mask is returned. The following macros are defined:</source>
          <target state="translated">Если транзакция прерывается,все побочные эффекты отменяются и возвращается код прерывания,закодированный как битовая маска.Определяются следующие макросы:</target>
        </trans-unit>
        <trans-unit id="52878fb9a18ac14d0e8c56cabf2833c060108631" translate="yes" xml:space="preserve">
          <source>If the value in it has side effects, the side effects happen only once, not for each initialized field by the range initializer.</source>
          <target state="translated">Если значение в нем имеет побочные эффекты,то побочные эффекты происходят только один раз,а не для каждого инициализированного поля инициализатором диапазона.</target>
        </trans-unit>
        <trans-unit id="eea091306a656215179432ee609d12ba3a9d954d" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;y&lt;/code&gt; is always 1, 2 or 3, then &lt;code&gt;x&lt;/code&gt; is always initialized, but GCC doesn&amp;rsquo;t know this. To suppress the warning, you need to provide a default case with assert(0) or similar code.</source>
          <target state="translated">Если значение &lt;code&gt;y&lt;/code&gt; всегда равно 1, 2 или 3, то &lt;code&gt;x&lt;/code&gt; всегда инициализируется, но GCC этого не знает. Чтобы подавить предупреждение, вам необходимо указать случай по умолчанию с помощью assert (0) или аналогичного кода.</target>
        </trans-unit>
        <trans-unit id="6a0552d924c971b406818fb3dc8c14b487a51639" translate="yes" xml:space="preserve">
          <source>If the variable is referenced in inline assembly, the type of access must be provided to the compiler via constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;). Accesses from basic asms are not supported.</source>
          <target state="translated">Если на переменную есть ссылка во встроенной сборке, тип доступа должен быть предоставлен компилятору через ограничения (см. &lt;a href=&quot;constraints#Constraints&quot;&gt;Ограничения&lt;/a&gt; ). Доступ из базовых asms не поддерживается.</target>
        </trans-unit>
        <trans-unit id="710a7177647056e46d73c6a14fa58cb0a4d39cb4" translate="yes" xml:space="preserve">
          <source>If there are no output operands but there are input operands, place two consecutive colons where the output operands would go:</source>
          <target state="translated">Если выходных операндов нет,но есть входные операндов,поместите два последовательных двоеточия,куда будут идти выходные операндов:</target>
        </trans-unit>
        <trans-unit id="ba1e7edd0bd3070d7470d6998361492b87d52104" translate="yes" xml:space="preserve">
          <source>If there is no pattern or mechanism to provide a lock-free instruction sequence, a call is made to an external routine with the same parameters to be resolved at run time.</source>
          <target state="translated">При отсутствии шаблона или механизма,обеспечивающего бесблокировочную последовательность команд,производится вызов внешней рутины с теми же параметрами,которые должны быть разрешены во время выполнения.</target>
        </trans-unit>
        <trans-unit id="76caf5beb996fc90102a47daa7e154a5cb406f3a" translate="yes" xml:space="preserve">
          <source>If these options are provided the S/390 back end emits additional instructions in the function prologue that trigger a trap if the stack size is &lt;var&gt;stack-guard&lt;/var&gt; bytes above the &lt;var&gt;stack-size&lt;/var&gt; (remember that the stack on S/390 grows downward). If the &lt;var&gt;stack-guard&lt;/var&gt; option is omitted the smallest power of 2 larger than the frame size of the compiled function is chosen. These options are intended to be used to help debugging stack overflow problems. The additionally emitted code causes only little overhead and hence can also be used in production-like systems without greater performance degradation. The given values have to be exact powers of 2 and &lt;var&gt;stack-size&lt;/var&gt; has to be greater than &lt;var&gt;stack-guard&lt;/var&gt; without exceeding 64k. In order to be efficient the extra code makes the assumption that the stack starts at an address aligned to the value given by &lt;var&gt;stack-size&lt;/var&gt;. The &lt;var&gt;stack-guard&lt;/var&gt; option can only be used in conjunction with &lt;var&gt;stack-size&lt;/var&gt;.</source>
          <target state="translated">Если эти параметры предоставлены, серверная часть S / 390 излучает дополнительные инструкции в прологе функции, которые запускают ловушку, если размер &lt;var&gt;stack-guard&lt;/var&gt; байтах защиты &lt;var&gt;stack-size&lt;/var&gt; (помните, что стек на S / 390 растет вниз). Если опция &lt;var&gt;stack-guard&lt;/var&gt; не указана, выбирается наименьшая степень двойки, превышающая размер кадра скомпилированной функции. Эти параметры предназначены для помощи в устранении проблем с переполнением стека. Дополнительный испускаемый код вызывает лишь небольшие накладные расходы и, следовательно, также может использоваться в производственных системах без значительного снижения производительности. Указанные значения должны быть точными степенями 2, а &lt;var&gt;stack-size&lt;/var&gt; должен быть больше, чем &lt;var&gt;stack-guard&lt;/var&gt; .не превышая 64к. Чтобы быть эффективным, дополнительный код предполагает, что стек начинается с адреса, выровненного со значением, заданным &lt;var&gt;stack-size&lt;/var&gt; . Опция &lt;var&gt;stack-guard&lt;/var&gt; может использоваться только вместе с &lt;var&gt;stack-size&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a905ee4ba472cb30116f3f77a848f112c04b6376" translate="yes" xml:space="preserve">
          <source>If this happens, you should recompile your code with</source>
          <target state="translated">Если это случится,вы должны перекомпилировать код с помощью</target>
        </trans-unit>
        <trans-unit id="1cc1d69b5f6b24d749c4393c1e5384e6327ba002" translate="yes" xml:space="preserve">
          <source>If this option appears multiple times in the command line with different values specified, &amp;lsquo;</source>
          <target state="translated">Если этот параметр появляется в командной строке несколько раз с разными значениями, &quot;</target>
        </trans-unit>
        <trans-unit id="7d789a669772c260255b8f486a50720c5dbf98e3" translate="yes" xml:space="preserve">
          <source>If this option is disabled, the compiler uses the most efficient instruction. In the previous example, that might be a 32-bit load instruction, even though that accesses bytes that do not contain any portion of the bit-field, or memory-mapped registers unrelated to the one being updated.</source>
          <target state="translated">Если эта опция отключена,компилятор использует наиболее эффективную инструкцию.В предыдущем примере это может быть 32-битная загрузочная инструкция,даже если она обращается к байтам,которые не содержат никакой части битового поля,или к реестрам,отображенным на карте памяти,не связанным с обновляемым.</target>
        </trans-unit>
        <trans-unit id="eaaa3704bd89671f3908d72dc5973515cc911101" translate="yes" xml:space="preserve">
          <source>If this option is enabled, the compiler tries to avoid unnecessarily overaligning functions. It attempts to instruct the assembler to align by the amount specified by</source>
          <target state="translated">Если эта опция включена,компилятор пытается избежать излишней спецодежды функций.Он пытается инструктировать ассемблера выравнивать по количеству,указанному в параметре</target>
        </trans-unit>
        <trans-unit id="7074bcc3f488dbf4492fda0d639c0f8273ca6d14" translate="yes" xml:space="preserve">
          <source>If this option is not provided but</source>
          <target state="translated">Если эта опция не предусмотрена,но</target>
        </trans-unit>
        <trans-unit id="b89db9dde06a530a5dff7a4661614320224ef048" translate="yes" xml:space="preserve">
          <source>If this option is not used, the single-core application programming model is used.</source>
          <target state="translated">Если эта опция не используется,то используется одноядерная модель прикладного программирования.</target>
        </trans-unit>
        <trans-unit id="58f2a7b1d53a81872af6e83acac9efe5419c83d5" translate="yes" xml:space="preserve">
          <source>If this option is set it also selects the type of hardware multiply support to use, unless this is overridden by an explicit</source>
          <target state="translated">Если этот параметр установлен,то он также выбирает тип поддержки аппаратного умножения,если только это не отменяется явным выражением</target>
        </trans-unit>
        <trans-unit id="13cec7c0becaf2d393aabd05cb427709a6c05830" translate="yes" xml:space="preserve">
          <source>If this option is used, the compiler will warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed &lt;var&gt;byte-size&lt;/var&gt; bytes. This is similar to how</source>
          <target state="translated">Если этот параметр используется, компилятор предупредит для деклараций переменной длиной массивов, размер которых либо неограничен, либо ограниченных аргументом , что позволяет размер массива превышает &lt;var&gt;byte-size&lt;/var&gt; байт. Это похоже на то, как</target>
        </trans-unit>
        <trans-unit id="c3115ee12356444486b8dfe277e34da87b4c9653" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies a UNIX timestamp to be used in replacement of the current date and time in the &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; macros, so that the embedded timestamps become reproducible.</source>
          <target state="translated">Если эта переменная установлена, ее значение указывает временную метку UNIX, которая будет использоваться вместо текущей даты и времени в макросах &lt;code&gt;__DATE__&lt;/code&gt; и &lt;code&gt;__TIME__&lt;/code&gt; , чтобы встроенные временные метки стали воспроизводимыми.</target>
        </trans-unit>
        <trans-unit id="9e2fd261f951c508769059b9f0362dce31b86177" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies how to output dependencies for Make based on the non-system header files processed by the compiler. System header files are ignored in the dependency output.</source>
          <target state="translated">Если эта переменная установлена,то ее значение указывает,как выводить зависимости для Make на основе несистемных заголовочных файлов,обрабатываемых компилятором.Системные заголовочные файлы игнорируются в выводе зависимостей.</target>
        </trans-unit>
        <trans-unit id="a402efdff3876f11c94bdea172224e741634fd39" translate="yes" xml:space="preserve">
          <source>If used for a function, print the PLT suffix and generate PIC code. For example, emit &lt;code&gt;foo@PLT&lt;/code&gt; instead of &amp;rsquo;foo&amp;rsquo; for the function foo(). If used for a constant, drop all syntax-specific prefixes and issue the bare constant. See &lt;code&gt;p&lt;/code&gt; above.</source>
          <target state="translated">Если используется для функции, распечатайте суффикс PLT и сгенерируйте код PIC. Например, используйте &lt;code&gt;foo@PLT&lt;/code&gt; вместо foo для функции foo (). Если используется для константы, отбросьте все префиксы, зависящие от синтаксиса, и выдайте пустую константу. См. &lt;code&gt;p&lt;/code&gt; Выше.</target>
        </trans-unit>
        <trans-unit id="0aee4afea693faf480212e1e7dfd95c798d52751" translate="yes" xml:space="preserve">
          <source>If you are invoking the preprocessor from a shell or shell-like program you may need to use the shell&amp;rsquo;s quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.</source>
          <target state="translated">Если вы вызываете препроцессор из оболочки или программы, подобной оболочке, вам может потребоваться использовать синтаксис кавычек оболочки для защиты символов, таких как пробелы, которые имеют значение в синтаксисе оболочки.</target>
        </trans-unit>
        <trans-unit id="12dd6be4f44a03f04923a3d7c38a665528824bfc" translate="yes" xml:space="preserve">
          <source>If you are not using a linker with plugin support and/or do not enable the linker plugin, then the objects inside</source>
          <target state="translated">Если вы не используете линкер с поддержкой плагина и/или не включаете плагин линкера,то объекты внутри</target>
        </trans-unit>
        <trans-unit id="dadbd9ac438963390bc7bff3cc4c1fa602dc81f8" translate="yes" xml:space="preserve">
          <source>If you are not using some other optimization option, consider using</source>
          <target state="translated">Если вы не используете какой-либо другой вариант оптимизации,подумайте об использовании</target>
        </trans-unit>
        <trans-unit id="c0c121f354142152248081fdee3df09a5e0cff31" translate="yes" xml:space="preserve">
          <source>If you are using Cfront-model code, you can probably get away with not using</source>
          <target state="translated">Если вы используете код модели Cfront,вам,вероятно,сойдет с рук отказ от использования</target>
        </trans-unit>
        <trans-unit id="670c5a80eac2c68f98a0b7952c25d85ec989c07c" translate="yes" xml:space="preserve">
          <source>If you are using a &amp;ldquo;Foundation&amp;rdquo; library such as GNUstep-Base, this library will provide you with a rich set of functionality to do most of the inspection tasks, and you probably will only need direct access to the GNU Objective-C runtime API to define new classes or methods.</source>
          <target state="translated">Если вы используете библиотеку &amp;laquo;Foundation&amp;raquo;, такую ​​как GNUstep-Base, эта библиотека предоставит вам богатый набор функций для выполнения большинства задач проверки, и вам, вероятно, потребуется только прямой доступ к API среды выполнения GNU Objective-C. для определения новых классов или методов.</target>
        </trans-unit>
        <trans-unit id="f60cfeeeec61609632220d7b04102d2cfb0874a6" translate="yes" xml:space="preserve">
          <source>If you are writing a header file that must work when included in ISO C programs, write &lt;code&gt;__typeof__&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">Если вы пишете файл заголовка, который должен работать при включении в программы ISO C, напишите &lt;code&gt;__typeof__&lt;/code&gt; вместо &lt;code&gt;typeof&lt;/code&gt; . См. &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Альтернативные ключевые слова&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="047e86cc1cc9d18346ee9ad5f63aecd5602b5f99" translate="yes" xml:space="preserve">
          <source>If you are writing a header file to be included in ISO C90 programs, write &lt;code&gt;__inline__&lt;/code&gt; instead of &lt;code&gt;inline&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">Если вы пишете файл заголовка для включения в программы ISO C90, пишите &lt;code&gt;__inline__&lt;/code&gt; вместо &lt;code&gt;inline&lt;/code&gt; . См. &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Альтернативные ключевые слова&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbd2d15a4f5e85df131685d7eb92f6861e37e279" translate="yes" xml:space="preserve">
          <source>If you care about controlling the amount of memory that is accessed, use volatile but do not use bit-fields.</source>
          <target state="translated">Если вы заботитесь о том,чтобы контролировать объем доступной памяти,используйте волатильные,но не битовые поля.</target>
        </trans-unit>
        <trans-unit id="0103e1abfe788f8d50e7fc73d958416e72e0b9c1" translate="yes" xml:space="preserve">
          <source>If you compile a module &lt;var&gt;Mod&lt;/var&gt; with</source>
          <target state="translated">Если вы компилируете модуль &lt;var&gt;Mod&lt;/var&gt; с</target>
        </trans-unit>
        <trans-unit id="47d85eced409c6f6fef0defc52869795ed0b0f14" translate="yes" xml:space="preserve">
          <source>If you define a class in a header file marked with &amp;lsquo;</source>
          <target state="translated">Если вы определяете класс в файле заголовка, помеченном как '</target>
        </trans-unit>
        <trans-unit id="8af3483bb66c1cf78841141fb90f1ef9efc295a7" translate="yes" xml:space="preserve">
          <source>If you do not specify an optimization level option</source>
          <target state="translated">Если не указать опцию уровня оптимизации</target>
        </trans-unit>
        <trans-unit id="0524dbf059780b836548e3795cd65f22c493bbb4" translate="yes" xml:space="preserve">
          <source>If you do use differing options when generating and using the precompiled header, the actual behavior is a mixture of the behavior for the options. For instance, if you use</source>
          <target state="translated">Если вы используете различные опции при генерации и использовании прекомпилированного заголовка,фактическое поведение-это смесь поведения опций.Например,если вы используете</target>
        </trans-unit>
        <trans-unit id="6615402a003808b60f77e922f8fff7dc102cea3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know the type of the operand, you can still do this, but you must use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;__auto_type&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;).</source>
          <target state="translated">Если вы не знаете тип операнда, вы все равно можете это сделать, но вы должны использовать &lt;code&gt;typeof&lt;/code&gt; или &lt;code&gt;__auto_type&lt;/code&gt; (см. &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c085ab8b04d2de8c46788dc7f554d15750ff8940" translate="yes" xml:space="preserve">
          <source>If you have trouble using GCC.</source>
          <target state="translated">Если у тебя проблемы с использованием GCC.</target>
        </trans-unit>
        <trans-unit id="4152886dce97a4266954e0590ef45338d28d4f3b" translate="yes" xml:space="preserve">
          <source>If you invoke &lt;code&gt;gcov&lt;/code&gt; with multiple input files, the contributions from each input file are summed. Typically you would invoke it with the same list of files as the final link of your executable.</source>
          <target state="translated">Если вы вызываете &lt;code&gt;gcov&lt;/code&gt; с несколькими входными файлами, вклад каждого входного файла суммируется. Обычно вы вызываете его с тем же списком файлов, что и последняя ссылка вашего исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="f78ebb50b8c8401143c21ca977cd992331a9d441" translate="yes" xml:space="preserve">
          <source>If you invoke GCC in parallel, compiling several different source files that share a common base name in different subdirectories or the same source file compiled for multiple output destinations, it is likely that the different parallel compilers will interfere with each other, and overwrite the temporary files. For instance:</source>
          <target state="translated">Если параллельно вызывать GCC,компилируя несколько разных исходных файлов с общим базовым именем в разных подкаталогах или один и тот же исходный файл,скомпилированный для нескольких выходных адресов,то,скорее всего,разные параллельные компиляторы будут мешать друг другу и перезаписывать временные файлы.Например:</target>
        </trans-unit>
        <trans-unit id="339873ba9c437ffb773ea97b43d76bef2cd414b1" translate="yes" xml:space="preserve">
          <source>If you know the above will only be reading a ten byte array then you could instead use a memory input like: &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt;.</source>
          <target state="translated">Если вы знаете, что приведенное выше будет считывать только десятибайтовый массив, вы можете вместо этого использовать ввод в память, например: &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="888965c4f3b549f1f0054a0f4c6ff67115a7146e" translate="yes" xml:space="preserve">
          <source>If you need a Standard compliant library, then you need to find one, as GCC does not provide one. The GNU C library (called &lt;code&gt;glibc&lt;/code&gt;) provides ISO C, POSIX, BSD, SystemV and X/Open compatibility for GNU/Linux and HURD-based GNU systems; no recent version of it supports other systems, though some very old versions did. Version 2.2 of the GNU C library includes nearly complete C99 support. You could also ask your operating system vendor if newer libraries are available.</source>
          <target state="translated">Если вам нужна стандартная библиотека, вам нужно ее найти, поскольку GCC ее не предоставляет. Библиотека GNU C (называемая &lt;code&gt;glibc&lt;/code&gt; ) обеспечивает совместимость ISO C, POSIX, BSD, SystemV и X / Open для систем GNU на основе GNU / Linux и HURD; ни одна последняя версия не поддерживает другие системы, хотя некоторые очень старые версии поддерживали. Версия 2.2 библиотеки GNU C включает почти полную поддержку C99. Вы также можете узнать у поставщика операционной системы, доступны ли новые библиотеки.</target>
        </trans-unit>
        <trans-unit id="2295b8a8afca796af761f37955429fb2dfb303ab" translate="yes" xml:space="preserve">
          <source>If you need to precompile the same header file for different languages, targets, or compiler options, you can instead make a &lt;em&gt;directory&lt;/em&gt; named like</source>
          <target state="translated">Если вам нужно предварительно скомпилировать один и тот же файл заголовка для разных языков, целей или параметров компилятора, вы можете вместо этого создать &lt;em&gt;каталог с&lt;/em&gt; именем</target>
        </trans-unit>
        <trans-unit id="66af9e4f8d685ec9e9b50745c5edb5982da51a9b" translate="yes" xml:space="preserve">
          <source>If you need to read the volatile object after an assignment has occurred, you must use a separate expression with an intervening sequence point.</source>
          <target state="translated">Если необходимо прочитать волатильный объект после того,как произошло присваивание,необходимо использовать отдельное выражение с промежуточной точкой следования.</target>
        </trans-unit>
        <trans-unit id="4adf572d889db0dbe74d88ef8bb1d09b3f0a1cca" translate="yes" xml:space="preserve">
          <source>If you only want some of the stages of compilation, you can use</source>
          <target state="translated">Если вам нужны только некоторые этапы компиляции,вы можете использовать</target>
        </trans-unit>
        <trans-unit id="0a3a127b379e27c78040de67c2f4f38df68d44ac" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;gcov&lt;/code&gt; to help optimize your code, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">Если вы планируете использовать &lt;code&gt;gcov&lt;/code&gt; для оптимизации вашего кода, вы должны сначала скомпилировать свою программу со специальной опцией GCC '</target>
        </trans-unit>
        <trans-unit id="89a00b1663443b615a5e906a67310faf3ab9d3e4" translate="yes" xml:space="preserve">
          <source>If you receive a linker error message that saying you have overflowed the available TOC space, you can reduce the amount of TOC space used with the</source>
          <target state="translated">Если Вы получите сообщение об ошибке линкера,в котором говорится,что Вы переполнили доступное пространство TOC,Вы можете уменьшить количество используемого пространства TOC с помощью функции</target>
        </trans-unit>
        <trans-unit id="be0941cee2405a3cef991d81a7e61b7d98631fbb" translate="yes" xml:space="preserve">
          <source>If you replaced &lt;code&gt;short_a&lt;/code&gt; with &lt;code&gt;short&lt;/code&gt; in the variable declaration, the above program would abort when compiled with</source>
          <target state="translated">Если вы заменили &lt;code&gt;short_a&lt;/code&gt; на &lt;code&gt;short&lt;/code&gt; в объявлении переменной, вышеуказанная программа прервется при компиляции с</target>
        </trans-unit>
        <trans-unit id="35d1d8ed39d0b8c7b146243c81d4152cdc148fcf" translate="yes" xml:space="preserve">
          <source>If you specify &amp;lsquo;</source>
          <target state="translated">Если вы укажете '</target>
        </trans-unit>
        <trans-unit id="4ecc2b870bc1bb7d3b980a000c9f6dcec5995fb9" translate="yes" xml:space="preserve">
          <source>If you specify both &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; in the function definition, then the definition is used only for inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it.</source>
          <target state="translated">Если вы укажете в определении функции и &lt;code&gt;inline&lt;/code&gt; , и &lt;code&gt;extern&lt;/code&gt; , то определение будет использоваться только для встраивания. Ни в коем случае функция не компилируется сама по себе, даже если вы явно ссылаетесь на ее адрес. Такой адрес становится внешней ссылкой, как если бы вы только объявили функцию, а не определили ее.</target>
        </trans-unit>
        <trans-unit id="5d47cb731371550330a13465931e86c5d293dfdf" translate="yes" xml:space="preserve">
          <source>If you specify command-line switches such as</source>
          <target state="translated">Если вы укажете переключатели командной строки,такие как</target>
        </trans-unit>
        <trans-unit id="6dac1f1fb59b9ffca6f761fa60561e481b2e6270" translate="yes" xml:space="preserve">
          <source>If you specify neither</source>
          <target state="translated">Если вы не укажете ни того,ни другого</target>
        </trans-unit>
        <trans-unit id="c921e7f4f95a0df5eb637ba56c7aabab978aaee6" translate="yes" xml:space="preserve">
          <source>If you specify the optional &lt;var&gt;n&lt;/var&gt;, the optimization and code generation done at link time is executed in parallel using &lt;var&gt;n&lt;/var&gt; parallel jobs by utilizing an installed &lt;code&gt;make&lt;/code&gt; program. The environment variable &lt;code&gt;MAKE&lt;/code&gt; may be used to override the program used. The default value for &lt;var&gt;n&lt;/var&gt; is 1.</source>
          <target state="translated">Если вы укажете необязательный параметр &lt;var&gt;n&lt;/var&gt; , оптимизация и генерация кода, выполняемые во время компоновки, будут выполняться параллельно с использованием &lt;var&gt;n&lt;/var&gt; параллельных заданий с использованием установленной программы &lt;code&gt;make&lt;/code&gt; . Переменная среды &lt;code&gt;MAKE&lt;/code&gt; может использоваться для отмены используемой программы. По умолчанию значение &lt;var&gt;n&lt;/var&gt; равно 1.</target>
        </trans-unit>
        <trans-unit id="925aa9cac99e94c7e1b3007e94e2857fd742f461" translate="yes" xml:space="preserve">
          <source>If you still run out of space in the TOC even when you specify both of these options, specify</source>
          <target state="translated">Если у вас все еще не хватает места в TOC,даже если вы укажите обе эти опции,укажите</target>
        </trans-unit>
        <trans-unit id="e9f3b7bcc19fa8799f793151f5d918c0eb44cc5c" translate="yes" xml:space="preserve">
          <source>If you try to call the nested function through its address after the containing function exits, all hell breaks loose. If you try to call it after a containing scope level exits, and if it refers to some of the variables that are no longer in scope, you may be lucky, but it&amp;rsquo;s not wise to take the risk. If, however, the nested function does not refer to anything that has gone out of scope, you should be safe.</source>
          <target state="translated">Если вы попытаетесь вызвать вложенную функцию по ее адресу после выхода из содержащей ее функции, все вырвется наружу. Если вы попытаетесь вызвать его после выхода из содержащего уровня области видимости, и если он ссылается на некоторые из переменных, которые больше не входят в область видимости, вам может повезти, но не стоит рисковать. Однако, если вложенная функция не относится ни к чему, что вышло за рамки, вы должны быть в безопасности.</target>
        </trans-unit>
        <trans-unit id="f927a3385a1b1e51d949287257534f3a4443c5fc" translate="yes" xml:space="preserve">
          <source>If you update the system&amp;rsquo;s header files, such as by installing a new system version, the fixed header files of GCC are not automatically updated. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">Если вы обновляете файлы заголовков системы, например, устанавливая новую версию системы, фиксированные файлы заголовков GCC не обновляются автоматически. Их можно обновить с &lt;code&gt;mkheaders&lt;/code&gt; скрипта mkheaders, установленного в</target>
        </trans-unit>
        <trans-unit id="41fb10bf832524090b9ab05176d0ed5567a508f5" translate="yes" xml:space="preserve">
          <source>If you use</source>
          <target state="translated">Если вы используете</target>
        </trans-unit>
        <trans-unit id="6a51a2c7443f8a2b859ded2344689b9dd5a96d35" translate="yes" xml:space="preserve">
          <source>If you use &amp;lsquo;</source>
          <target state="translated">Если вы используете '</target>
        </trans-unit>
        <trans-unit id="1eb60252a45f0973d8c5683aecd8b85683d307d3" translate="yes" xml:space="preserve">
          <source>If you use both this option and the</source>
          <target state="translated">Если вы используете и эту опцию,и</target>
        </trans-unit>
        <trans-unit id="daf14f5a30ee5ca1525b7be167b116e92944e7ce" translate="yes" xml:space="preserve">
          <source>If you use multiple</source>
          <target state="translated">Если вы используете несколько</target>
        </trans-unit>
        <trans-unit id="9b9352d7bdc60d6db5e3f97a4150de5fffc4de3b" translate="yes" xml:space="preserve">
          <source>If you use one big file to do the instantiations, you may want to compile it without</source>
          <target state="translated">Если вы используете один большой файл для выполнения инстанцинаций,вы можете захотеть скомпилировать его без</target>
        </trans-unit>
        <trans-unit id="d5658f3cda5684fd922808fa10e4319b5a492e30" translate="yes" xml:space="preserve">
          <source>If you use one of the &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; address spaces you must arrange your linker script to locate the &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; sections according to your needs.</source>
          <target state="translated">Если вы используете одно из адресных пространств &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; вы должны настроить сценарий компоновщика так, чтобы он &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; разделы .progmem N .data в соответствии с вашими потребностями.</target>
        </trans-unit>
        <trans-unit id="d09fff5b63f8a00b0aa50a2fbc9e05727d5eaa55" translate="yes" xml:space="preserve">
          <source>If you use the</source>
          <target state="translated">Если вы используете</target>
        </trans-unit>
        <trans-unit id="0c2eabb891cc235e2e02c3ade4b4c6be5a7c7761" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;inline&lt;/code&gt; qualifier, then for inlining purposes the size of the &lt;code&gt;asm&lt;/code&gt; statement is taken as the smallest size possible (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">Если вы используете &lt;code&gt;inline&lt;/code&gt; квалификатор, то для целей встраивания размер инструкции &lt;code&gt;asm&lt;/code&gt; принимается как наименьший возможный размер (см. &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Размер asm&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d0a1d145962ca52d117f00e82a8a34efa685f04" translate="yes" xml:space="preserve">
          <source>If you use the ISA 3.0 instruction set (</source>
          <target state="translated">Если вы используете набор команд ISA 3.0 (</target>
        </trans-unit>
        <trans-unit id="3b409b718d6983a24e16eccb9909125cc43f2697" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes a separate argument, you must use</source>
          <target state="translated">Если вы хотите передать опцию,которая принимает отдельный аргумент,вы должны использовать</target>
        </trans-unit>
        <trans-unit id="01e57dac3d1293541430d1619103f3be6de91e09" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes an argument, you must use</source>
          <target state="translated">Если вы хотите передать опцию,которая принимает аргумент,вы должны использовать</target>
        </trans-unit>
        <trans-unit id="57c0d52053735b1deca65f8fe95302a40e91aba4" translate="yes" xml:space="preserve">
          <source>If you want to pass the array first and the length afterward, you can use a forward declaration in the parameter list&amp;mdash;another GNU extension.</source>
          <target state="translated">Если вы хотите сначала передать массив, а затем длину, вы можете использовать предварительное объявление в списке параметров - еще одно расширение GNU.</target>
        </trans-unit>
        <trans-unit id="714721fbe0a57745166a774e2ee80658db42639e" translate="yes" xml:space="preserve">
          <source>If you want to recompile source files that do not actually use your global register variable so they do not use the specified register for any other purpose, you need not actually add the global register declaration to their source code. It suffices to specify the compiler option</source>
          <target state="translated">Если вы хотите перекомпилировать исходные файлы,которые на самом деле не используют переменную глобального регистра,чтобы они не использовали указанный регистр для каких-либо других целей,вам не нужно на самом деле добавлять декларацию глобального регистра в их исходный код.Достаточно указать опцию компилятора.</target>
        </trans-unit>
        <trans-unit id="63035fe8f0fef33a809f5df21a239bff0f434564" translate="yes" xml:space="preserve">
          <source>If you want to warn about code that uses the uninitialized value of the variable in its own initializer, use the</source>
          <target state="translated">Если вы хотите предупредить о коде,использующем неинициализированное значение переменной в своем инициализаторе,используйте параметр</target>
        </trans-unit>
        <trans-unit id="1f9d39a0d621d29f6b4df2f19650e527eb6087e6" translate="yes" xml:space="preserve">
          <source>If you want your own collection object to be usable with fast enumeration, you need to have it implement the method</source>
          <target state="translated">Если вы хотите,чтобы ваш собственный объект коллекции был пригоден для использования с быстрым перечислением,вам нужно,чтобы он реализовывал метод</target>
        </trans-unit>
        <trans-unit id="66ce7bf0d3f3a0ea10a8e8123399a75d9055c922" translate="yes" xml:space="preserve">
          <source>If you wish to define a function-like macro on the command line, write its argument list with surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells, so you should quote the option. With &lt;code&gt;sh&lt;/code&gt; and &lt;code&gt;csh&lt;/code&gt;,</source>
          <target state="translated">Если вы хотите определить макрос, подобный функции, в командной строке, запишите его список аргументов, заключив его в круглые скобки перед знаком равенства (если есть). Круглые скобки имеют значение для большинства оболочек, поэтому вам следует заключить этот параметр в кавычки. С &lt;code&gt;sh&lt;/code&gt; и &lt;code&gt;csh&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="344eca13d4f5455ce9ed14a9174152844b040aa2" translate="yes" xml:space="preserve">
          <source>If your code needs to support multiple assembler dialects (for example, if you are writing public headers that need to support a variety of compilation options), use constructs of this form:</source>
          <target state="translated">Если ваш код должен поддерживать несколько диалектов ассемблера (например,если вы пишете публичные заголовки,которые должны поддерживать различные варианты компиляции),используйте конструкции этой формы:</target>
        </trans-unit>
        <trans-unit id="489624b43d62801c5096e0cef6c84a4128aa3f2e" translate="yes" xml:space="preserve">
          <source>If, for some reason, you want to include letter &amp;lsquo;</source>
          <target state="translated">Если по какой-то причине вы хотите включить букву '</target>
        </trans-unit>
        <trans-unit id="8ae25dcd1480cd59f0776f409a8f3b4cc8c76dee" translate="yes" xml:space="preserve">
          <source>If, instead, you use the GCC driver to create shared libraries, you may find that they are not always linked with the shared</source>
          <target state="translated">Если вместо этого вы используете драйвер GCC для создания разделяемых библиотек,вы можете обнаружить,что они не всегда связаны с разделяемыми библиотеками</target>
        </trans-unit>
        <trans-unit id="7d34e1e1ae89800680b004320ebb086b09cf39f6" translate="yes" xml:space="preserve">
          <source>Ignore the &lt;code&gt;#ident&lt;/code&gt; directive.</source>
          <target state="translated">Игнорируйте директиву &lt;code&gt;#ident&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e82df27ea7fceb83aac6e28c3926e8f714c2de0" translate="yes" xml:space="preserve">
          <source>Immediate 15-bit unsigned integer</source>
          <target state="translated">Немедленное 15-битное беззнаковое целое число</target>
        </trans-unit>
        <trans-unit id="25ebf6700b63624d3804d20faa7de74e2dccc87c" translate="yes" xml:space="preserve">
          <source>Immediate 16-bit signed integer</source>
          <target state="translated">Немедленное 16-битное подписанное целое число</target>
        </trans-unit>
        <trans-unit id="c2ce26e27211c1d69d3a406bee1c55a3cfc3b488" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit integer in range -16..4294967295 (i.e. 32-bit unsigned integer or &amp;lsquo;</source>
          <target state="translated">Непосредственное 32-битное целое число в диапазоне -16..4294967295 (т.е. 32-битное целое число без знака или '</target>
        </trans-unit>
        <trans-unit id="7ce04d3df5932775f166ab61ebe67634f6cff4f5" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit signed integer that can be attached to an instruction encoding</source>
          <target state="translated">Немедленное 32-битное подписанное целое число,которое может быть прикреплено к кодировке инструкции.</target>
        </trans-unit>
        <trans-unit id="95af07c0237447c6b15292985f8e2b14ec413d35" translate="yes" xml:space="preserve">
          <source>Immediate 64-bit constant that can be split into two &amp;lsquo;</source>
          <target state="translated">Непосредственная 64-битная константа, которую можно разделить на две '</target>
        </trans-unit>
        <trans-unit id="aea4f97beb4642aabcdf84f409c00fa5cd5c2c91" translate="yes" xml:space="preserve">
          <source>Immediate constant -1</source>
          <target state="translated">Немедленная постоянная -1</target>
        </trans-unit>
        <trans-unit id="293172a51e9ef5dbf0bb7e7f454796275cc1f905" translate="yes" xml:space="preserve">
          <source>Immediate constant that can be inlined in an instruction encoding: integer -16..64, or float 0.0, +/-0.5, +/-1.0, +/-2.0, +/-4.0, 1.0/(2.0*PI)</source>
          <target state="translated">Немедленная константа,которая может быть инкапсулирована в кодировку инструкции:целое число -16...64,или плавающая 0.0,+/-0.5,+/-1.0,+/-2.0,+/-4.0,1.0/(2.0*PI).</target>
        </trans-unit>
        <trans-unit id="a56a5101429aaf4e851ed409b055e85e8d91d6b8" translate="yes" xml:space="preserve">
          <source>Immediate integer in the range -16 to 64</source>
          <target state="translated">Немедленное целое число в диапазоне от -16 до 64</target>
        </trans-unit>
        <trans-unit id="bf320f9d296e81a49f73cab866d640531aefcfad" translate="yes" xml:space="preserve">
          <source>Implement (do not implement) -fno-plt and long calls using an inline PLT call sequence that supports lazy linking and long calls to functions in dlopen&amp;rsquo;d shared libraries. Inline PLT calls are only supported on PowerPC64 ELFv2 and 32-bit PowerPC systems with newer GNU linkers, and are enabled by default if the support is detected when configuring GCC, and, in the case of 32-bit PowerPC, if GCC is configured with</source>
          <target state="translated">Реализуйте (не реализуйте) -fno-plt и длинные вызовы, используя встроенную последовательность вызовов PLT, которая поддерживает ленивое связывание и длинные вызовы функций в разделяемых библиотеках dlopen. Встроенные вызовы PLT поддерживаются только в PowerPC64 ELFv2 и 32-разрядных системах PowerPC с новыми компоновщиками GNU и включены по умолчанию, если поддержка обнаружена при настройке GCC, и в случае 32-разрядного PowerPC, если GCC настроен с</target>
        </trans-unit>
        <trans-unit id="f6c8b1a3b3ce20b0f24d10325bb5a9fda3cc0723" translate="yes" xml:space="preserve">
          <source>Implies no inter-thread ordering constraints.</source>
          <target state="translated">Не влечет за собой никаких ограничений по межпоточному заказу.</target>
        </trans-unit>
        <trans-unit id="fe96af122b5bf84f1ddc818f1e5f57ac3e7dac8c" translate="yes" xml:space="preserve">
          <source>Improved AMD Athlon CPU with MMX, 3DNow!, enhanced 3DNow! and full SSE instruction set support.</source>
          <target state="translated">Улучшенный процессор AMD Athlon с MMX,3DNow,улучшенная поддержка 3DNow и полный набор инструкций SSE.</target>
        </trans-unit>
        <trans-unit id="6774c0ca18d629c919e07781b4bc4345f81613ce" translate="yes" xml:space="preserve">
          <source>Improved support for generic programming.</source>
          <target state="translated">Улучшенная поддержка общего программирования.</target>
        </trans-unit>
        <trans-unit id="bb701b014b08c67fb59b6b752448015c50d54c43" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with 64-bit extensions, MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">Улучшенная версия процессора Intel Pentium 4 с 64-битными расширениями,поддержкой наборов команд MMX,SSE,SSE2 и SSE3.</target>
        </trans-unit>
        <trans-unit id="ed782143dc7e1163d3eb2323e646f10006e40097" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">Улучшенная версия процессора Intel Pentium 4 с поддержкой наборов команд MMX,SSE,SSE2 и SSE3.</target>
        </trans-unit>
        <trans-unit id="8a73deb51d5b08d19d0486183c731c2e4df58a6c" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K6 CPU with MMX and 3DNow! instruction set support.</source>
          <target state="translated">Улучшенные версии процессора AMD K6 с поддержкой MMX и 3DNow! набора инструкций.</target>
        </trans-unit>
        <trans-unit id="0640019f239b6c731b94ce729c56eafeb42fbdce" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K8 cores with SSE3 instruction set support.</source>
          <target state="translated">Улучшенные версии ядер AMD K8 с поддержкой набора инструкций SSE3.</target>
        </trans-unit>
        <trans-unit id="faa77d9eb98f8c3bb3a99e6c2fd6a673c7a1ef4f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; expands to &lt;code&gt;((void *)0)&lt;/code&gt;. GCC does not provide the other headers which define &lt;code&gt;NULL&lt;/code&gt; and some library implementations may use other definitions in those headers.</source>
          <target state="translated">В &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; , &lt;code&gt;NULL&lt;/code&gt; расширяется до &lt;code&gt;((void *)0)&lt;/code&gt; . GCC не предоставляет другие заголовки, которые определяют &lt;code&gt;NULL&lt;/code&gt; , и некоторые реализации библиотеки могут использовать другие определения в этих заголовках.</target>
        </trans-unit>
        <trans-unit id="94f792f5735cf258c95fd93f04f6f7c58a83d70b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;get_i()&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; is not used in a dependent context, so the compiler will look for a name declared at the enclosing namespace scope (which is the global scope here). It will not look into the base class, since that is dependent and you may declare specializations of &lt;code&gt;Base&lt;/code&gt; even after declaring &lt;code&gt;Derived&lt;/code&gt;, so the compiler cannot really know what &lt;code&gt;i&lt;/code&gt; would refer to. If there is no global variable &lt;code&gt;i&lt;/code&gt;, then you will get an error message.</source>
          <target state="translated">В &lt;code&gt;get_i()&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; не используется в зависимом контексте, так что компилятор будет искать имя объявленного в рамках вшита пространства имен (что глобальный масштаб здесь). Он не будет смотреть на базовый класс, поскольку он зависит, и вы можете объявить специализации &lt;code&gt;Base&lt;/code&gt; даже после объявления &lt;code&gt;Derived&lt;/code&gt; , поэтому компилятор не может действительно знать, что &lt;code&gt;i&lt;/code&gt; буду иметь в виду. Если глобальной переменной &lt;code&gt;i&lt;/code&gt; нет , вы получите сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="1efd435b2fd7ff4eeb1d3caefe51e97ec2eabff1" translate="yes" xml:space="preserve">
          <source>In C code, this option controls the placement of global variables defined without an initializer, known as &lt;em&gt;tentative definitions&lt;/em&gt; in the C standard. Tentative definitions are distinct from declarations of a variable with the &lt;code&gt;extern&lt;/code&gt; keyword, which do not allocate storage.</source>
          <target state="translated">В коде C этот параметр управляет размещением глобальных переменных, определенных без инициализатора, что в стандарте C называется &lt;em&gt;предварительными определениями&lt;/em&gt; . Предварительные определения отличаются от объявлений переменных с ключевым словом &lt;code&gt;extern&lt;/code&gt; , которые не выделяют память.</target>
        </trans-unit>
        <trans-unit id="986d71cafa07e6d2f235ac194e79a8e70cb9cccf" translate="yes" xml:space="preserve">
          <source>In C mode, this is equivalent to</source>
          <target state="translated">В режиме С это эквивалентно</target>
        </trans-unit>
        <trans-unit id="6e29cf5656ff22cce837fe364a063ee35412d5b9" translate="yes" xml:space="preserve">
          <source>In C this option does not warn about the universal zero initializer &amp;lsquo;</source>
          <target state="translated">В C эта опция не предупреждает об универсальном инициализаторе нуля '</target>
        </trans-unit>
        <trans-unit id="2f3a5ba446573452e29640c8fc16cb4e894d48dc" translate="yes" xml:space="preserve">
          <source>In C++ code, this allows member names in structures to be similar to previous types declarations.</source>
          <target state="translated">В Си++коде это позволяет именам членов в структурах быть похожими на предыдущие типы деклараций.</target>
        </trans-unit>
        <trans-unit id="c8175f71005ecf03750f6f6a8eb8dfe31c736137" translate="yes" xml:space="preserve">
          <source>In C++ the value of an object is only affected by changes within its lifetime: when the constructor begins, the object has an indeterminate value, and any changes during the lifetime of the object are dead when the object is destroyed. Normally dead store elimination will take advantage of this; if your code relies on the value of the object storage persisting beyond the lifetime of the object, you can use this flag to disable this optimization. To preserve stores before the constructor starts (e.g. because your operator new clears the object storage) but still treat the object as dead after the destructor you, can use</source>
          <target state="translated">В языке С++на значение объекта влияют только изменения за время его жизни:при запуске конструктора объект имеет неопределенное значение,а любые изменения за время жизни объекта становятся мертвыми,когда объект разрушается.Обычно этим пользуется устранение мертвого хранилища;если ваш код полагается на значение хранилища объекта,сохраняющееся за время жизни объекта,то вы можете использовать этот флаг,чтобы отключить эту оптимизацию.Для сохранения хранилищ до запуска конструктора (например,потому,что ваш оператор new очищает хранилище объекта),но все равно рассматривать объект как мертвое после деструктора,вы можете использовать параметр</target>
        </trans-unit>
        <trans-unit id="168fb41a49baf3aa442f73f3ecb6a40cd4d6ca59" translate="yes" xml:space="preserve">
          <source>In C++, &amp;lsquo;</source>
          <target state="translated">В C ++ '</target>
        </trans-unit>
        <trans-unit id="1bcce97889f7dbf32fa6b64e8c64b08099b3f7a1" translate="yes" xml:space="preserve">
          <source>In C++, attribute visibility (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) can also be applied to class, struct, union and enum types. Unlike other type attributes, the attribute must appear between the initial keyword and the name of the type; it cannot appear after the body of the type.</source>
          <target state="translated">В C ++ видимость атрибутов (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ) также может применяться к типам class, struct, union и enum. В отличие от других атрибутов типа, атрибут должен располагаться между начальным ключевым словом и именем типа; он не может появляться после тела типа.</target>
        </trans-unit>
        <trans-unit id="41407820aea4af6aceb3725e14d20bcfa5717ed8" translate="yes" xml:space="preserve">
          <source>In C++, if a template argument has limited visibility, this restriction is implicitly propagated to the template instantiation. Otherwise, template instantiations and specializations default to the visibility of their template.</source>
          <target state="translated">В C++,если аргумент шаблона имеет ограниченную видимость,это ограничение неявно распространяется на инстанцирование шаблона.В противном случае,инстанцирование и специализация шаблона по умолчанию распространяется на видимость его шаблона.</target>
        </trans-unit>
        <trans-unit id="453e27477f405b0f81788514a49ffd79d08ff550" translate="yes" xml:space="preserve">
          <source>In C++, if an initializer is present for a thread-local variable, it must be a &lt;var&gt;constant-expression&lt;/var&gt;, as defined in 5.19.2 of the ANSI/ISO C++ standard.</source>
          <target state="translated">В C ++, если инициализатор присутствует для локальной переменной потока, он должен быть &lt;var&gt;constant-expression&lt;/var&gt; , как определено в 5.19.2 стандарта ANSI / ISO C ++.</target>
        </trans-unit>
        <trans-unit id="9e8da9f4a402f87aeb0e1e0768c85b6e521a3ae7" translate="yes" xml:space="preserve">
          <source>In C++, pointer to member functions (PMFs) are implemented using a wide pointer of sorts to handle all the possible call mechanisms; the PMF needs to store information about how to adjust the &amp;lsquo;</source>
          <target state="translated">В C ++ указатель на функции-члены (PMF) реализован с использованием широких указателей для обработки всех возможных механизмов вызова; PMF необходимо хранить информацию о том, как настроить '</target>
        </trans-unit>
        <trans-unit id="34a26947af0331ebcf8b3ff5e4127f49a113bd19" translate="yes" xml:space="preserve">
          <source>In C++, the &lt;code&gt;ifunc&lt;/code&gt; attribute takes a string that is the mangled name of the resolver function. A C++ resolver for a non-static member function of class &lt;code&gt;C&lt;/code&gt; should be declared to return a pointer to a non-member function taking pointer to &lt;code&gt;C&lt;/code&gt; as the first argument, followed by the same arguments as of the implementation function. G++ checks the signatures of the two functions and issues a</source>
          <target state="translated">В C ++ атрибут &lt;code&gt;ifunc&lt;/code&gt; принимает строку, которая представляет собой искаженное имя функции преобразователя. Преобразователь C ++ для нестатической функции-члена класса &lt;code&gt;C&lt;/code&gt; должен быть объявлен так, чтобы он возвращал указатель на функцию, не являющуюся членом, принимающей указатель на &lt;code&gt;C&lt;/code&gt; в качестве первого аргумента, за которым следуют те же аргументы, что и у функции реализации. G ++ проверяет подписи двух функций и выдает</target>
        </trans-unit>
        <trans-unit id="dae3c25a08855a03a679edfb667679b322123fbc" translate="yes" xml:space="preserve">
          <source>In C++, the logic operators &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; are available for vectors. &lt;code&gt;!v&lt;/code&gt; is equivalent to &lt;code&gt;v == 0&lt;/code&gt;, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; and &lt;code&gt;a || b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 | b!=0&lt;/code&gt;. For mixed operations between a scalar &lt;code&gt;s&lt;/code&gt; and a vector &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; is equivalent to &lt;code&gt;s?v!=0:0&lt;/code&gt; (the evaluation is short-circuit) and &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; is equivalent to &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt;.</source>
          <target state="translated">В C ++ логические операторы &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; доступны для векторов. &lt;code&gt;!v&lt;/code&gt; эквивалентно &lt;code&gt;v == 0&lt;/code&gt; , &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; эквивалентно &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; и &lt;code&gt;a || b&lt;/code&gt; эквивалентно &lt;code&gt;a!=0 | b!=0&lt;/code&gt; . Для смешанных операций между скаляром &lt;code&gt;s&lt;/code&gt; и вектором &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; эквивалентно &lt;code&gt;s?v!=0:0&lt;/code&gt; (оценка - короткое замыкание), а &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; эквивалентно &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="260b901dabc2f639a1fcfb92f83b3a8bfc6792cb" translate="yes" xml:space="preserve">
          <source>In C++, the ternary operator &lt;code&gt;?:&lt;/code&gt; is available. &lt;code&gt;a?b:c&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are vectors of the same type and &lt;code&gt;a&lt;/code&gt; is an integer vector with the same number of elements of the same size as &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, computes all three arguments and creates a vector &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt;. Note that unlike in OpenCL, &lt;code&gt;a&lt;/code&gt; is thus interpreted as &lt;code&gt;a != 0&lt;/code&gt; and not &lt;code&gt;a &amp;lt; 0&lt;/code&gt;. As in the case of binary operations, this syntax is also accepted when one of &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; is a scalar that is then transformed into a vector. If both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are scalars and the type of &lt;code&gt;true?b:c&lt;/code&gt; has the same size as the element type of &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are converted to a vector type whose elements have this type and with the same number of elements as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">В C ++ доступен тернарный оператор &lt;code&gt;?:&lt;/code&gt; . &lt;code&gt;a?b:c&lt;/code&gt; , где &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; - векторы одного типа, а &lt;code&gt;a&lt;/code&gt; - целочисленный вектор с таким же количеством элементов того же размера, что и &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , вычисляет все три аргумента и создает вектор &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt; . Обратите внимание, что в отличие от OpenCL, &lt;code&gt;a&lt;/code&gt; интерпретируется как &lt;code&gt;a != 0&lt;/code&gt; а не как &lt;code&gt;a &amp;lt; 0&lt;/code&gt; . Как и в случае с бинарными операциями, этот синтаксис также принимается, когда один из &lt;code&gt;b&lt;/code&gt; или &lt;code&gt;c&lt;/code&gt; является скаляром, который затем преобразуется в вектор. Если оба &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; - скаляры, а тип &lt;code&gt;true?b:c&lt;/code&gt; имеет тот же размер, что и тип элемента &lt;code&gt;a&lt;/code&gt; , тогда &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; преобразуются в векторный тип, элементы которого имеют этот тип и с тем же количеством элементов, что и &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e8e3384895cb64dc59dfb4ef3c2eae30e005995" translate="yes" xml:space="preserve">
          <source>In C++, the visibility attribute applies to types as well as functions and objects, because in C++ types have linkage. A class must not have greater visibility than its non-static data member types and bases, and class members default to the visibility of their class. Also, a declaration without explicit visibility is limited to the visibility of its type.</source>
          <target state="translated">В С++атрибут видимости применяется как к типам,так и к функциям и объектам,поскольку в С++типы имеют связь.Класс не должен иметь большую видимость,чем его нестатические типы и базы-члены данных,а члены класса по умолчанию имеют видимость своего класса.Также объявление без явной видимости ограничивается видимостью его типа.</target>
        </trans-unit>
        <trans-unit id="9870b14c476e69190f3f39c0be8be66122cac26a" translate="yes" xml:space="preserve">
          <source>In C++, the warning is issued when an explicit specialization of a primary template declared with attribute &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;assume_aligned&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;format_arg&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, or &lt;code&gt;nonnull&lt;/code&gt; is declared without it. Attributes &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;warning&lt;/code&gt; suppress the warning. (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">В C ++, предупреждение выдается , когда явная специализация основного шаблона объявлен с атрибутом &lt;code&gt;alloc_align&lt;/code&gt; , &lt;code&gt;alloc_size&lt;/code&gt; , &lt;code&gt;assume_aligned&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;format_arg&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; или &lt;code&gt;nonnull&lt;/code&gt; объявляется без него. Атрибуты &lt;code&gt;deprecated&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; и &lt;code&gt;warning&lt;/code&gt; подавляют предупреждение. (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9914fa32f31272fbd1b3c9fd5655fe7c161328ef" translate="yes" xml:space="preserve">
          <source>In C++, this attribute does not depend on &lt;code&gt;extern&lt;/code&gt; in any way, but it still requires the &lt;code&gt;inline&lt;/code&gt; keyword to enable its special behavior.</source>
          <target state="translated">В C ++ этот атрибут никоим образом не зависит от &lt;code&gt;extern&lt;/code&gt; , но для его особого поведения по- прежнему требуется ключевое слово &lt;code&gt;inline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1330ec9305a2cf36952504f041eeaa71d08a1559" translate="yes" xml:space="preserve">
          <source>In C++, this pragma silently applies only to declarations with &amp;ldquo;C&amp;rdquo; linkage. Again, &lt;code&gt;asm&lt;/code&gt; labels do not have this restriction.</source>
          <target state="translated">В C ++ эта прагма молча применяется только к объявлениям со связью &amp;laquo;C&amp;raquo;. Опять же, метки &lt;code&gt;asm&lt;/code&gt; не имеют этого ограничения.</target>
        </trans-unit>
        <trans-unit id="4f1560146bfb02b0050b7346bcee56f1168f8456" translate="yes" xml:space="preserve">
          <source>In C++, this switch only affects the &lt;code&gt;typeof&lt;/code&gt; keyword, since &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt; are standard keywords. You may want to use the</source>
          <target state="translated">В C ++ этот переключатель влияет только на ключевое слово &lt;code&gt;typeof&lt;/code&gt; , поскольку &lt;code&gt;asm&lt;/code&gt; и &lt;code&gt;inline&lt;/code&gt; являются стандартными ключевыми словами. Вы можете использовать</target>
        </trans-unit>
        <trans-unit id="83513182660c016337c6a43ced48177d4ad0ef0c" translate="yes" xml:space="preserve">
          <source>In C++, you can mark member functions and static member variables of a class with the visibility attribute. This is useful if you know a particular method or static member variable should only be used from one shared object; then you can mark it hidden while the rest of the class has default visibility. Care must be taken to avoid breaking the One Definition Rule; for example, it is usually not useful to mark an inline method as hidden without marking the whole class as hidden.</source>
          <target state="translated">В С++можно пометить функции-члены и статические переменные-члены класса атрибутом видимости.Это полезно,если вы знаете,что конкретный метод или статическую переменную-членов следует использовать только от одного общего объекта,тогда вы можете пометить его скрытым,в то время как остальная часть класса имеет видимость по умолчанию.Следует позаботиться о том,чтобы не нарушить правило One Definition Rule;например,обычно нецелесообразно помечать встроенный метод как скрытый,не пометив весь класс как скрытый.</target>
        </trans-unit>
        <trans-unit id="1263d4b3bd19eaa09ddd9de78312a5a79d915aa7" translate="yes" xml:space="preserve">
          <source>In C++14, &lt;code&gt;f&lt;/code&gt; calls &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt;, but in C++17 it calls &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В C ++ 14 &lt;code&gt;f&lt;/code&gt; вызывает &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt; , но в C ++ 17 он вызывает &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3eaf8f9d1fd2934be9e06d429d221c630b5bf0a" translate="yes" xml:space="preserve">
          <source>In C++17, the compiler is required to omit these temporaries, but this option still affects trivial member functions.</source>
          <target state="translated">В Си++17 компилятор должен опускать эти временные файлы,но эта опция все равно влияет на тривиальные членские функции.</target>
        </trans-unit>
        <trans-unit id="2fd9362a64ee90151b4f33ed9f7535e5f0047820" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is yet another name for &lt;code&gt;__func__&lt;/code&gt;, except that at file (or, in C++, namespace scope), it evaluates to the string &lt;code&gt;&quot;top level&quot;&lt;/code&gt;. In addition, in C++, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; contains the signature of the function as well as its bare name. For example, this program:</source>
          <target state="translated">В C &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; - это еще одно имя для &lt;code&gt;__func__&lt;/code&gt; , за исключением того, что в файле (или, в C ++, в области пространства имен) оно оценивается как строка &lt;code&gt;&quot;top level&quot;&lt;/code&gt; . Кроме того, в C ++ &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; содержит подпись функции, а также ее простое имя. Например, эта программа:</target>
        </trans-unit>
        <trans-unit id="89c3cbeabc9fb0c94d32392b571a5dbe1ffa12b0" translate="yes" xml:space="preserve">
          <source>In C, a compound literal designates an unnamed object with static or automatic storage duration. In C++, a compound literal designates a temporary object that only lives until the end of its full-expression. As a result, well-defined C code that takes the address of a subobject of a compound literal can be undefined in C++, so G++ rejects the conversion of a temporary array to a pointer. For instance, if the array compound literal example above appeared inside a function, any subsequent use of &lt;code&gt;foo&lt;/code&gt; in C++ would have undefined behavior because the lifetime of the array ends after the declaration of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">В языке C составной литерал обозначает безымянный объект со статической или автоматической продолжительностью хранения. В C ++ составной литерал обозначает временный объект, который живет только до конца своего полного выражения. В результате четко определенный код C, который принимает адрес подобъекта составного литерала, может быть неопределенным в C ++, поэтому G ++ отклоняет преобразование временного массива в указатель. Например, если приведенный выше пример составного литерала массива появился внутри функции, любое последующее использование &lt;code&gt;foo&lt;/code&gt; в C ++ будет иметь неопределенное поведение, поскольку время жизни массива заканчивается после объявления &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b955553d29e649b19193fbacbc412a24a27d538d" translate="yes" xml:space="preserve">
          <source>In C, emit &lt;code&gt;static&lt;/code&gt; functions that are declared &lt;code&gt;inline&lt;/code&gt; into the object file, even if the function has been inlined into all of its callers. This switch does not affect functions using the &lt;code&gt;extern inline&lt;/code&gt; extension in GNU C90. In C++, emit any and all inline functions into the object file.</source>
          <target state="translated">В C испускайте &lt;code&gt;static&lt;/code&gt; функции, которые объявлены &lt;code&gt;inline&lt;/code&gt; в объектный файл, даже если функция встроена во все вызывающие объекты. Этот переключатель не влияет на функции, использующие &lt;code&gt;extern inline&lt;/code&gt; расширение extern в GNU C90. В C ++ передайте все встроенные функции в объектный файл.</target>
        </trans-unit>
        <trans-unit id="3058a9d60ea1ade68bb14049e675f5bf83c7026b" translate="yes" xml:space="preserve">
          <source>In C, if the function is neither &lt;code&gt;extern&lt;/code&gt; nor &lt;code&gt;static&lt;/code&gt;, then the function is compiled as a standalone function, as well as being inlined where possible.</source>
          <target state="translated">В C, если функция не является ни &lt;code&gt;extern&lt;/code&gt; ни &lt;code&gt;static&lt;/code&gt; , тогда функция компилируется как отдельная функция, а также встраивается, где это возможно.</target>
        </trans-unit>
        <trans-unit id="e352da7bd9ce1ec016de9e2458664a9340519a89" translate="yes" xml:space="preserve">
          <source>In C/C++, every &lt;code&gt;else&lt;/code&gt; branch belongs to the innermost possible &lt;code&gt;if&lt;/code&gt; statement, which in this example is &lt;code&gt;if (b)&lt;/code&gt;. This is often not what the programmer expected, as illustrated in the above example by indentation the programmer chose. When there is the potential for this confusion, GCC issues a warning when this flag is specified. To eliminate the warning, add explicit braces around the innermost &lt;code&gt;if&lt;/code&gt; statement so there is no way the &lt;code&gt;else&lt;/code&gt; can belong to the enclosing &lt;code&gt;if&lt;/code&gt;. The resulting code looks like this:</source>
          <target state="translated">В C / C ++ каждая ветвь &lt;code&gt;else&lt;/code&gt; принадлежит самому внутреннему возможному оператору &lt;code&gt;if&lt;/code&gt; , которым в этом примере является &lt;code&gt;if (b)&lt;/code&gt; . Часто это не то, чего ожидал программист, как показано в приведенном выше примере отступом, выбранным программистом. Когда есть вероятность такой путаницы, GCC выдает предупреждение, когда указан этот флаг. Чтобы устранить это предупреждение, добавьте явные скобки вокруг самого внутреннего оператора &lt;code&gt;if&lt;/code&gt; , чтобы исключить принадлежность &lt;code&gt;else&lt;/code&gt; к включающему &lt;code&gt;if&lt;/code&gt; . Полученный код выглядит так:</target>
        </trans-unit>
        <trans-unit id="69cc3b441acbdbe11472c325735b27c046d27c5c" translate="yes" xml:space="preserve">
          <source>In G++, the result value of a statement expression undergoes array and function pointer decay, and is returned by value to the enclosing expression. For instance, if &lt;code&gt;A&lt;/code&gt; is a class, then</source>
          <target state="translated">В G ++ результирующее значение выражения оператора подвергается распаду указателя на массив и функцию и возвращается по значению в включающее выражение. Например, если &lt;code&gt;A&lt;/code&gt; - класс, то</target>
        </trans-unit>
        <trans-unit id="2b79b7c58963843a8ca543d9e2a4ed22f6af9388" translate="yes" xml:space="preserve">
          <source>In GNU C and C++, you can use function attributes to specify certain function properties that may help the compiler optimize calls or check code more carefully for correctness. For example, you can use attributes to specify that a function never returns (&lt;code&gt;noreturn&lt;/code&gt;), returns a value depending only on the values of its arguments (&lt;code&gt;const&lt;/code&gt;), or has &lt;code&gt;printf&lt;/code&gt;-style arguments (&lt;code&gt;format&lt;/code&gt;).</source>
          <target state="translated">В GNU C и C ++ вы можете использовать атрибуты функции для указания определенных свойств функции, которые могут помочь компилятору оптимизировать вызовы или более тщательно проверять код на правильность. Например, вы можете использовать атрибуты, чтобы указать, что функция никогда не возвращает ( &lt;code&gt;noreturn&lt;/code&gt; ), возвращает значение, зависящее только от значений ее аргументов ( &lt;code&gt;const&lt;/code&gt; ), или имеет аргументы в стиле &lt;code&gt;printf&lt;/code&gt; ( &lt;code&gt;format&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="099e4a52fb6ed11fab7818dcdc84803658fe6ac9" translate="yes" xml:space="preserve">
          <source>In GNU C, addition and subtraction operations are supported on pointers to &lt;code&gt;void&lt;/code&gt; and on pointers to functions. This is done by treating the size of a &lt;code&gt;void&lt;/code&gt; or of a function as 1.</source>
          <target state="translated">В GNU C операции сложения и вычитания поддерживаются для указателей на &lt;code&gt;void&lt;/code&gt; и для указателей на функции. Это делается путем обработки размера &lt;code&gt;void&lt;/code&gt; или функции как 1.</target>
        </trans-unit>
        <trans-unit id="cca3c66936552d4dc4ee0493549030694bbe3a79" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear after the colon following a label, other than a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label. GNU C++ only permits attributes on labels if the attribute specifier is immediately followed by a semicolon (i.e., the label applies to an empty statement). If the semicolon is missing, C++ label attributes are ambiguous, as it is permissible for a declaration, which could begin with an attribute list, to be labelled in C++. Declarations cannot be labelled in C90 or C99, so the ambiguity does not arise there.</source>
          <target state="translated">В GNU C список спецификаторов атрибутов может появляться после двоеточия после метки, кроме &lt;code&gt;case&lt;/code&gt; или метки по &lt;code&gt;default&lt;/code&gt; . GNU C ++ разрешает атрибуты на метках только в том случае, если после спецификатора атрибута сразу ставится точка с запятой (т. Е. Метка применяется к пустому оператору). Если точка с запятой отсутствует, атрибуты метки C ++ являются неоднозначными, поскольку в C ++ допустимо помечать объявление, которое может начинаться со списка атрибутов. Объявления не могут быть помечены в C90 или C99, поэтому двусмысленности здесь не возникает.</target>
        </trans-unit>
        <trans-unit id="00f091378926e345c0e4332aa146832525cddb05" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of a null statement. The attribute goes before the semicolon.</source>
          <target state="translated">В GNU C список спецификаторов атрибутов может появиться как часть нулевого утверждения.Атрибут идет перед точкой с запятой.</target>
        </trans-unit>
        <trans-unit id="1b43625a41fcbb3b41411d6343924dd766870911" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of an enumerator. The attribute goes after the enumeration constant, before &lt;code&gt;=&lt;/code&gt;, if present. The optional attribute in the enumerator appertains to the enumeration constant. It is not possible to place the attribute after the constant expression, if present.</source>
          <target state="translated">В GNU C список спецификаторов атрибутов может появляться как часть перечислителя. Атрибут идет после константы перечисления, перед &lt;code&gt;=&lt;/code&gt; , если он присутствует. Необязательный атрибут в перечислителе принадлежит константе перечисления. Невозможно разместить атрибут после константного выражения, если оно есть.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
