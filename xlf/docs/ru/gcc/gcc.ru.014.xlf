<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="bd8e6c5371362aa092aae0b0592e55198f1c8b9c" translate="yes" xml:space="preserve">
          <source>This section documents the encoding of method types, which is rarely needed to use Objective-C. You should skip it at a first reading; the runtime provides functions that will work on methods and can walk through the list of parameters and interpret them for you. These functions are part of the public &amp;ldquo;API&amp;rdquo; and are the preferred way to interact with method signatures from user code.</source>
          <target state="translated">В этом разделе описывается кодирование типов методов, которое редко требуется для использования Objective-C. Вы должны пропустить его при первом чтении; среда выполнения предоставляет функции, которые будут работать с методами и могут просматривать список параметров и интерпретировать их за вас. Эти функции являются частью общедоступного &amp;laquo;API&amp;raquo; и являются предпочтительным способом взаимодействия с подписями методов из пользовательского кода.</target>
        </trans-unit>
        <trans-unit id="92bc19fae671586234add4d5e1d253df22100b8a" translate="yes" xml:space="preserve">
          <source>This section intentionally empty.</source>
          <target state="translated">Эта секция намеренно пуста.</target>
        </trans-unit>
        <trans-unit id="9dcc691a02a9391b7e0c30aab063927ea00a125c" translate="yes" xml:space="preserve">
          <source>This section is specific for the GNU Objective-C runtime. If you are using a different runtime, you can skip it.</source>
          <target state="translated">Этот раздел специфичен для среды выполнения GNU Objective-C.Если вы используете другое время выполнения,вы можете его пропустить.</target>
        </trans-unit>
        <trans-unit id="4d2663a3da2126761e59e5b901038db322ae02e2" translate="yes" xml:space="preserve">
          <source>This section lists changes that people frequently request, but which we do not make because we think GCC is better without them.</source>
          <target state="translated">В этом разделе перечислены изменения,которые люди часто запрашивают,но которые мы не делаем,потому что считаем,что GCC лучше без них.</target>
        </trans-unit>
        <trans-unit id="6be9fd8a27bd882ee2957a5506f02578eed902d6" translate="yes" xml:space="preserve">
          <source>This section lists various difficulties encountered in using GCC together with other compilers or with the assemblers, linkers, libraries and debuggers on certain systems.</source>
          <target state="translated">В этом разделе перечислены различные трудности,возникающие при использовании GCC совместно с другими компиляторами или с ассемблерами,компоновщиками,библиотеками и отладчиками на определенных системах.</target>
        </trans-unit>
        <trans-unit id="fc5c464b4c99442f66523b49fbd84dd32d4a9f33" translate="yes" xml:space="preserve">
          <source>This sections describes built-in functions related to read and write instructions to access memory. These functions generate &lt;code&gt;membar&lt;/code&gt; instructions to flush the I/O load and stores where appropriate, as described in Fujitsu&amp;rsquo;s manual described above.</source>
          <target state="translated">В этом разделе описаны встроенные функции, связанные с инструкциями чтения и записи для доступа к памяти. Эти функции генерируют &lt;code&gt;membar&lt;/code&gt; инструкции для сброса нагрузки ввода-вывода и сохраняют их там, где это необходимо, как описано в руководстве Fujitsu, описанном выше.</target>
        </trans-unit>
        <trans-unit id="657a9d90f9f4dd0b4af1725dd023d864364a9a6d" translate="yes" xml:space="preserve">
          <source>This selects the CPU to generate code for at compilation time by determining the processor type of the compiling machine. Using</source>
          <target state="translated">При этом выбирается процессор для генерации кода на этапе компиляции путем определения типа процессора компилирующей машины.Используя .</target>
        </trans-unit>
        <trans-unit id="52fbcd0192529b61aa6e52c7943fcf31e0d69f81" translate="yes" xml:space="preserve">
          <source>This sets the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">При этом устанавливаются указанные биты в сохраненной копии реестра состояния,находящейся в стеке в настоящее время.Это работает только внутри обработчиков прерываний,и изменения в статусном регистре будут действовать только после возвращения обработчика.</target>
        </trans-unit>
        <trans-unit id="c8206cbbb17dc4eed11021be8e812bfcaf18d27d" translate="yes" xml:space="preserve">
          <source>This setting is only useful for strides that are known and constant.</source>
          <target state="translated">Эта настройка полезна только для известных и постоянных успехов.</target>
        </trans-unit>
        <trans-unit id="efe46d223c613fd1d939a40a5c5d5b8742ce8085" translate="yes" xml:space="preserve">
          <source>This setting is useful for processors that have hardware prefetchers, in which case there may be conflicts between the hardware prefetchers and the software prefetchers. If the hardware prefetchers have a maximum stride they can handle, it should be used here to improve the use of software prefetchers.</source>
          <target state="translated">Эта настройка полезна для процессоров,имеющих аппаратные префикторы,в этом случае могут возникнуть конфликты между аппаратными префикторами и программными префикторами.Если аппаратные префетчеры имеют максимальный шаг,с которым они могут справиться,его следует использовать здесь для улучшения использования программных префетчеров.</target>
        </trans-unit>
        <trans-unit id="23f9a68d34fdcbac9802d87e4691f1d481ccdb61" translate="yes" xml:space="preserve">
          <source>This size is also used for inlining decisions. If you use &lt;code&gt;asm inline&lt;/code&gt; instead of just &lt;code&gt;asm&lt;/code&gt;, then for inlining purposes the size of the asm is taken as the minimum size, ignoring how many instructions GCC thinks it is.</source>
          <target state="translated">Этот размер также используется для встраивания решений. Если вы используете &lt;code&gt;asm inline&lt;/code&gt; вместо просто &lt;code&gt;asm&lt;/code&gt; , то для целей встраивания размер asm принимается как минимальный размер, игнорируя, сколько инструкций GCC считает его.</target>
        </trans-unit>
        <trans-unit id="6436ee6603a6a283bb34edc1a40e3b3faa54b98d" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the function &lt;code&gt;func&lt;/code&gt; in the assembler code should be &lt;code&gt;MYFUNC&lt;/code&gt;.</source>
          <target state="translated">Это указывает, что имя, которое будет использоваться для функции &lt;code&gt;func&lt;/code&gt; в коде ассемблера, должно быть &lt;code&gt;MYFUNC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="232e23ab36d2ae531cc928cda4ab49d45def08c5" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the variable &lt;code&gt;foo&lt;/code&gt; in the assembler code should be &amp;lsquo;</source>
          <target state="translated">Это указывает, что имя, которое будет использоваться для переменной &lt;code&gt;foo&lt;/code&gt; в коде ассемблера, должно быть '</target>
        </trans-unit>
        <trans-unit id="a3c554fdfb8d610626cac613dfe8c644012d6c11" translate="yes" xml:space="preserve">
          <source>This specifies the hard limit for frame sizes, in bytes. Currently, the value that can be specified should be less than or equal to &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157c3a5d700741dba8b972ce366b3872db0f98d9" translate="yes" xml:space="preserve">
          <source>This specifies the minimum version of the kernel that will run the compiled program. GCC uses this version to determine which instructions to use, what kernel helpers to allow, etc. Currently, &lt;var&gt;version&lt;/var&gt; can be one of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e7d4d12b96a2f9b08b67a67b6c05ae9677d81f" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. This option can be used in conjunction with or instead of the</source>
          <target state="translated">Здесь указывается имя целевой архитектуры ARM.GCC использует это имя для определения того,какие инструкции он может выдавать при генерации ассемблерного кода.Эта опция может быть использована в сочетании с или вместо</target>
        </trans-unit>
        <trans-unit id="5f5ffdf441cdde0f8b6e9e4c7fe02c1f21c8c411" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM processor. GCC uses this name to derive the name of the target ARM architecture (as if specified by</source>
          <target state="translated">Здесь указывается имя целевого ARM-процессора.GCC использует это имя для получения имени целевой ARM-архитектуры (как если бы оно было задано с помощью</target>
        </trans-unit>
        <trans-unit id="8e151a0bdb560628cb5ddbb4913dc14cfb482f53" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target Nios II architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">Это определяет имя целевой архитектуры Nios II. GCC использует это имя, чтобы определить, какие инструкции он может выдавать при генерации кода сборки. Допустимые имена: '</target>
        </trans-unit>
        <trans-unit id="085bdfa0f8d1afe6178b912d6185b5a3f9cb191a" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">Это определяет имя целевой архитектуры. GCC использует это имя, чтобы определить, какие инструкции он может выдавать при генерации кода сборки. Допустимые имена: '</target>
        </trans-unit>
        <trans-unit id="64aaf23d10b975a481227888a0c489eb1e3c16c0" translate="yes" xml:space="preserve">
          <source>This specifies what floating-point hardware (or hardware emulation) is available on the target. Permissible names are: &amp;lsquo;</source>
          <target state="translated">Это указывает, какое оборудование с плавающей запятой (или аппаратная эмуляция) доступно на целевом устройстве. Допустимые имена: '</target>
        </trans-unit>
        <trans-unit id="345d1833d12c5392425b9eb5b3c8d3be49244d38" translate="yes" xml:space="preserve">
          <source>This switch causes the command line used to invoke the compiler to be recorded into the object file that is being created. This switch is only implemented on some targets and the exact format of the recording is target and binary file format dependent, but it usually takes the form of a section containing ASCII text. This switch is related to the</source>
          <target state="translated">Этот переключатель приводит к тому,что командная строка,используемая для вызова компилятора,записывается в создаваемый объектный файл.Этот переключатель реализован только на некоторых объектах,и точный формат записи зависит от формата целевого и двоичного файла,но обычно он принимает форму раздела,содержащего ASCII-текст.Этот переключатель связан с</target>
        </trans-unit>
        <trans-unit id="fcef4a45435978f94ac21ce5b4ddc80a97324665" translate="yes" xml:space="preserve">
          <source>This switch causes the command-line options used to invoke the compiler that may affect code generation to be appended to the DW_AT_producer attribute in DWARF debugging information. The options are concatenated with spaces separating them from each other and from the compiler version. It is enabled by default. See also</source>
          <target state="translated">Данный переключатель приводит к тому,что к атрибуту DW_AT_producer в отладочной информации DWARF добавляются опции командной строки,которые могут повлиять на генерацию кода.Опции конкапсулированы пробелами,отделяющими их друг от друга и от версии компилятора.По умолчанию она включена.См.также</target>
        </trans-unit>
        <trans-unit id="a3ef7cfaa3693eda0200855e73487a3931ad86b9" translate="yes" xml:space="preserve">
          <source>This switch declares that the user does not attempt to compare pointers to inline functions or methods where the addresses of the two functions are taken in different shared objects.</source>
          <target state="translated">Этот переключатель заявляет,что пользователь не пытается сравнивать указатели с встроенными функциями или методами,где адреса двух функций берутся в разных общих объектах.</target>
        </trans-unit>
        <trans-unit id="9d12a205f2d4388bb6e6b2aa9be08da33c955f0c" translate="yes" xml:space="preserve">
          <source>This switch disables the automatic removal of redundant &lt;code&gt;membar&lt;/code&gt; instructions from the generated code.</source>
          <target state="translated">Этот переключатель отключает автоматическое удаление избыточных инструкций &lt;code&gt;membar&lt;/code&gt; из сгенерированного кода.</target>
        </trans-unit>
        <trans-unit id="fb214efcf15f2eebcb5c8359308da41aee1bb7a5" translate="yes" xml:space="preserve">
          <source>This switch enables or disables the generation of ISEL instructions.</source>
          <target state="translated">Этот переключатель включает или отключает генерацию инструкций ISEL.</target>
        </trans-unit>
        <trans-unit id="121380ba5bbee8a3b6396891291392c7f45ab990" translate="yes" xml:space="preserve">
          <source>This switch is mainly for debugging the compiler and will likely be removed in a future version.</source>
          <target state="translated">Этот ключ в основном предназначен для отладки компилятора и,скорее всего,будет удален в следующей версии.</target>
        </trans-unit>
        <trans-unit id="83b61792d6d517f0567ee609808598af69f30e65" translate="yes" xml:space="preserve">
          <source>This switch removes redundant &lt;code&gt;membar&lt;/code&gt; instructions from the compiler-generated code. It is enabled by default.</source>
          <target state="translated">Этот переключатель удаляет избыточные инструкции &lt;code&gt;membar&lt;/code&gt; из кода, созданного компилятором. По умолчанию он включен.</target>
        </trans-unit>
        <trans-unit id="2700c0c5f6842561acacd13d2b72a8353682aa23" translate="yes" xml:space="preserve">
          <source>This syntax is defined in the C++ 2011 standard, but has been supported by G++ and other compilers since well before 2011.</source>
          <target state="translated">Этот синтаксис определен в стандарте C++2011,но поддерживается G++и другими компиляторами задолго до 2011 года.</target>
        </trans-unit>
        <trans-unit id="82fcb60fefcb3dd52763982ecf7c2e7bdfe84505" translate="yes" xml:space="preserve">
          <source>This tells the compiler that a function is &lt;code&gt;malloc&lt;/code&gt;-like, i.e., that the pointer &lt;var&gt;P&lt;/var&gt; returned by the function cannot alias any other pointer valid when the function returns, and moreover no pointers to valid objects occur in any storage addressed by &lt;var&gt;P&lt;/var&gt;.</source>
          <target state="translated">Это говорит компилятору , что функция является &lt;code&gt;malloc&lt;/code&gt; -кака, то есть, что указатель &lt;var&gt;P&lt;/var&gt; возвращенная функция не может псевдоним любого другого указателя действительного , когда функция возвращает, и кроме того нет указателей на действительные объекты возникают в любом хранилище , адресованного &lt;var&gt;P&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="57ca8b09b0bd70a0af88532cce8b6c0a57af5ea7" translate="yes" xml:space="preserve">
          <source>This tells the compiler to create, override or delete the named spec string. All lines after this directive up to the next directive or blank line are considered to be the text for the spec string. If this results in an empty string then the spec is deleted. (Or, if the spec did not exist, then nothing happens.) Otherwise, if the spec does not currently exist a new spec is created. If the spec does exist then its contents are overridden by the text of this directive, unless the first character of that text is the &amp;lsquo;</source>
          <target state="translated">Это указывает компилятору создать, переопределить или удалить указанную строку спецификации. Все строки после этой директивы до следующей директивы или пустой строки считаются текстом для строки спецификации. Если это приводит к пустой строке, спецификация удаляется. (Или, если спецификация не существует, ничего не происходит.) В противном случае, если спецификация в настоящее время не существует, создается новая спецификация. Если спецификация действительно существует, то ее содержимое заменяется текстом этой директивы, если только первый символ этого текста не является '</target>
        </trans-unit>
        <trans-unit id="ad4018bf7af9477c8687cfe9f142d2504a7341b9" translate="yes" xml:space="preserve">
          <source>This turns off certain features of GCC that are incompatible with ISO C90 (when compiling C code), or of standard C++ (when compiling C++ code), such as the &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;typeof&lt;/code&gt; keywords, and predefined macros such as &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;vax&lt;/code&gt; that identify the type of system you are using. It also enables the undesirable and rarely used ISO trigraph feature. For the C compiler, it disables recognition of C++ style &amp;lsquo;</source>
          <target state="translated">Это отключает некоторые функции GCC, которые несовместимы с ISO C90 (при компиляции кода C) или стандартного C ++ (при компиляции кода C ++), такие как ключевые слова &lt;code&gt;asm&lt;/code&gt; и &lt;code&gt;typeof&lt;/code&gt; , а также предопределенные макросы, такие как &lt;code&gt;unix&lt;/code&gt; и &lt;code&gt;vax&lt;/code&gt; , которые определяют тип используемой вами системы. Он также включает нежелательную и редко используемую функцию триграфа ISO. Для компилятора C он отключает распознавание стиля C ++ '</target>
        </trans-unit>
        <trans-unit id="92dd1276eca8dc32a61b9ef6e7b622bea22fa0aa" translate="yes" xml:space="preserve">
          <source>This value is used to limit superblock formation once the given percentage of executed instructions is covered. This limits unnecessary code size expansion.</source>
          <target state="translated">Это значение используется для ограничения образования суперблоков после покрытия заданного процента выполненных инструкций.Это ограничивает ненужное расширение размера кода.</target>
        </trans-unit>
        <trans-unit id="25d25d25b176faf62dac7b5023bc142fa458d69e" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; (see above), except that system header files are not ignored, so it implies</source>
          <target state="translated">Эта переменная такая же, как &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; (см. Выше), за исключением того, что файлы системных заголовков не игнорируются, поэтому подразумевается</target>
        </trans-unit>
        <trans-unit id="1ac6e7ae8cc06c38e89aed855dd5fc2e644da6f4" translate="yes" xml:space="preserve">
          <source>This variable is used to pass locale information to the compiler. One way in which this information is used is to determine the character set to be used when character literals, string literals and comments are parsed in C and C++. When the compiler is configured to allow multibyte characters, the following values for &lt;code&gt;LANG&lt;/code&gt; are recognized:</source>
          <target state="translated">Эта переменная используется для передачи компилятору информации о локали. Один из способов использования этой информации - определение набора символов, который будет использоваться при анализе символьных литералов, строковых литералов и комментариев в C и C ++. Когда компилятор настроен на разрешение многобайтовых символов, распознаются следующие значения для &lt;code&gt;LANG&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4be1995e1045ff6bbec640e0a942d94152cfdec6" translate="yes" xml:space="preserve">
          <source>This warning also warns about bitwise comparisons that always evaluate to true or false, for instance:</source>
          <target state="translated">Это предупреждение также предупреждает о битовых сравнениях,которые всегда оцениваются,например,до правды или до ложности:</target>
        </trans-unit>
        <trans-unit id="0b2459c9299d10d23b0470cd3490145629414a5b" translate="yes" xml:space="preserve">
          <source>This warning can be disabled by</source>
          <target state="translated">Это предупреждение может быть отключено</target>
        </trans-unit>
        <trans-unit id="89ed913f904a95674da23281b17b4ea693c54b25" translate="yes" xml:space="preserve">
          <source>This warning does not warn when the last statement of a case cannot fall through, e.g. when there is a return statement or a call to function declared with the noreturn attribute.</source>
          <target state="translated">Это предупреждение не предупреждает,когда последнее утверждение случая не может выпасть,например,когда есть утверждение возврата или вызов функции,объявленной с атрибутом noreturn.</target>
        </trans-unit>
        <trans-unit id="89fc4cf85fe382aeb62fa09febecbde3a95eefc5" translate="yes" xml:space="preserve">
          <source>This warning is also enabled by</source>
          <target state="translated">Это предупреждение также включается при помощи</target>
        </trans-unit>
        <trans-unit id="fced7dacfde6a232424563218b69038bcd4ee559" translate="yes" xml:space="preserve">
          <source>This warning is enabled by</source>
          <target state="translated">Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="36a47c11f1d7801640a4ce272fb734796af5acce" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">Данное предупреждение включено по умолчанию для программ на Си и Си++.</target>
        </trans-unit>
        <trans-unit id="ee676e87db234394e662704c0ac8d7b78ce3a041" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default in C++ and by</source>
          <target state="translated">Это предупреждение включено по умолчанию на C++и на</target>
        </trans-unit>
        <trans-unit id="29cc8455b15f952933dbc6b5c4dcaaac18069659" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default.</source>
          <target state="translated">Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3917b2a596783248383561094f2cc2f726e9521a" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default. Use</source>
          <target state="translated">Это предупреждение включено по умолчанию.Использовать</target>
        </trans-unit>
        <trans-unit id="73d860a0af5ebf8266139b884b360d37bd26034c" translate="yes" xml:space="preserve">
          <source>This warning is included in</source>
          <target state="translated">Это предупреждение включено в</target>
        </trans-unit>
        <trans-unit id="db92bbc8f99766a5d4907234d529494e443089db" translate="yes" xml:space="preserve">
          <source>This warning level also warns about left-shifting 1 into the sign bit, unless C++14 mode (or newer) is active.</source>
          <target state="translated">Этот уровень предупреждений также предупреждает о том,что левое смещение 1 в знаковый бит,если только не активен режим C++14 (или более новый).</target>
        </trans-unit>
        <trans-unit id="ab7fb5cdceb183a69c6c48efdc3d5a84a181e3f7" translate="yes" xml:space="preserve">
          <source>This warning level also warns about out of bounds access for arrays at the end of a struct and for arrays accessed through pointers. This warning level may give a larger number of false positives and is deactivated by default.</source>
          <target state="translated">Этот уровень предупреждений также предупреждает о выходе за рамки доступа для массивов в конце структуры и для массивов,доступ к которым осуществляется через указатели.Данный уровень предупреждений может давать большее количество ложных срабатываний и по умолчанию отключен.</target>
        </trans-unit>
        <trans-unit id="3bc3c9fc8962f0931c9fc06c074ee037fa301f84" translate="yes" xml:space="preserve">
          <source>This warning level also warns for unused constant static variables in headers (excluding system headers). This is the warning level of</source>
          <target state="translated">Этот уровень предупреждений также предупреждает о неиспользуемых постоянных статических переменных в заголовках (исключая системные заголовки).Это уровень предупреждений</target>
        </trans-unit>
        <trans-unit id="1ba36fa783ccd0a5d3f8a140c9e1e59cead13162" translate="yes" xml:space="preserve">
          <source>This warning requires</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21507bd41b7915853fd4be309aa1b572305449d0" translate="yes" xml:space="preserve">
          <source>This warning requires both</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39d91280d86f2477375c576c702edeea7de99cb" translate="yes" xml:space="preserve">
          <source>This warning warns about redundant calls to &lt;code&gt;std::move&lt;/code&gt;; that is, when a move operation would have been performed even without the &lt;code&gt;std::move&lt;/code&gt; call. This happens because the compiler is forced to treat the object as if it were an rvalue in certain situations such as returning a local variable, where copy elision isn&amp;rsquo;t applicable. Consider:</source>
          <target state="translated">Это предупреждение предупреждает об избыточных вызовах &lt;code&gt;std::move&lt;/code&gt; ; то есть, когда операция перемещения была бы выполнена даже без вызова &lt;code&gt;std::move&lt;/code&gt; . Это происходит потому, что компилятор вынужден обрабатывать объект, как если бы он был rvalue в определенных ситуациях, например, при возврате локальной переменной, где исключение копирования неприменимо. Рассматривать:</target>
        </trans-unit>
        <trans-unit id="8ff927821e46493382415b836b1d222941ef02c3" translate="yes" xml:space="preserve">
          <source>This warning warns when a call to &lt;code&gt;std::move&lt;/code&gt; prevents copy elision. A typical scenario when copy elision can occur is when returning in a function with a class return type, when the expression being returned is the name of a non-volatile automatic object, and is not a function parameter, and has the same type as the function return type.</source>
          <target state="translated">Это предупреждение предупреждает, когда вызов &lt;code&gt;std::move&lt;/code&gt; предотвращает удаление копии. Типичный сценарий, когда может произойти исключение копирования, - это возврат в функции с типом возвращаемого класса, когда возвращаемое выражение является именем энергонезависимого автоматического объекта, а не параметром функции и имеет тот же тип, что и тип тип возвращаемого значения функции.</target>
        </trans-unit>
        <trans-unit id="bfc144d25fb3262e883d5de6746ba99b3d72080d" translate="yes" xml:space="preserve">
          <source>This was fixed in</source>
          <target state="translated">Это было исправлено</target>
        </trans-unit>
        <trans-unit id="8b70ca57c3342f65e65169286b191ac23c6458f6" translate="yes" xml:space="preserve">
          <source>This would cause storage layout to be incompatible with most other C compilers. And it doesn&amp;rsquo;t seem very important, given that you can get the same result in other ways. The case where it matters most is when the enumeration-valued object is inside a structure, and in that case you can specify a field width explicitly.</source>
          <target state="translated">Это может привести к несовместимости схемы хранения с большинством других компиляторов C. И это не кажется очень важным, учитывая, что вы можете получить тот же результат другими способами. Случай, когда это имеет наибольшее значение, - это когда объект, оценивающий перечисление, находится внутри структуры, и в этом случае вы можете явно указать ширину поля.</target>
        </trans-unit>
        <trans-unit id="470b7fe94fb9f173a78fa935734e2192a8d7646b" translate="yes" xml:space="preserve">
          <source>Thread, static, and automatic storage durations are associated with objects introduced by declarations [&amp;hellip;].</source>
          <target state="translated">Продолжительность потокового, статического и автоматического хранения связана с объектами, представленными объявлениями [&amp;hellip;].</target>
        </trans-unit>
        <trans-unit id="62f3324c9a09465697eb233a889b15dae55b7e07" translate="yes" xml:space="preserve">
          <source>Thread-local storage (TLS) is a mechanism by which variables are allocated such that there is one instance of the variable per extant thread. The runtime model GCC uses to implement this originates in the IA-64 processor-specific ABI, but has since been migrated to other processors as well. It requires significant support from the linker (&lt;code&gt;ld&lt;/code&gt;), dynamic linker (&lt;code&gt;ld.so&lt;/code&gt;), and system libraries (</source>
          <target state="translated">Локальное хранилище потока (TLS) - это механизм, с помощью которого переменные выделяются таким образом, чтобы на каждый существующий поток приходился один экземпляр переменной. Модель времени выполнения, которую GCC использует для реализации этого, берет начало в ABI, специфичном для процессора IA-64, но с тех пор была перенесена и на другие процессоры. Для этого требуется значительная поддержка компоновщика ( &lt;code&gt;ld&lt;/code&gt; ), динамического компоновщика ( &lt;code&gt;ld.so&lt;/code&gt; ) и системных библиотек (</target>
        </trans-unit>
        <trans-unit id="f7f55e84b2ac7e71c677017ee5269595545ce154" translate="yes" xml:space="preserve">
          <source>Three attributes are currently defined for the Blackfin.</source>
          <target state="translated">В настоящее время для Blackfin определены три атрибута.</target>
        </trans-unit>
        <trans-unit id="74960e7e5c9e31cbbbc884f673c931b0f550d460" translate="yes" xml:space="preserve">
          <source>Three attributes currently are defined for PowerPC configurations: &lt;code&gt;altivec&lt;/code&gt;, &lt;code&gt;ms_struct&lt;/code&gt; and &lt;code&gt;gcc_struct&lt;/code&gt;.</source>
          <target state="translated">В настоящее время для конфигураций PowerPC определены три атрибута: &lt;code&gt;altivec&lt;/code&gt; , &lt;code&gt;ms_struct&lt;/code&gt; и &lt;code&gt;gcc_struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0729e6343a03b33102b145d1d69f011d2c64e5f" translate="yes" xml:space="preserve">
          <source>Ths option is deprecated. Enable &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb2dbbb4a85c3866aff412bba9f2a41a060bb7f" translate="yes" xml:space="preserve">
          <source>Thus for example to display all the undocumented target-specific switches supported by the compiler, use:</source>
          <target state="translated">Таким образом,например,для отображения всех недокументированных целевых специфических ключей,поддерживаемых компилятором,используйте:</target>
        </trans-unit>
        <trans-unit id="1a580d726772cc97718ddf7d30a624c944acce67" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;array (pointer (char), 4)&lt;/code&gt; is the type of arrays of 4 pointers to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Таким образом, &lt;code&gt;array (pointer (char), 4)&lt;/code&gt; - это тип массивов из 4 указателей на &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5de79caa39ed0efb8d6ccb9be9f4f52d25b8a9e8" translate="yes" xml:space="preserve">
          <source>To avoid complications from future changes to the semantics and the compatibility issues between compilers, consider replacing basic &lt;code&gt;asm&lt;/code&gt; with extended &lt;code&gt;asm&lt;/code&gt;. See &lt;a href=&quot;https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended&quot;&gt;How to convert from basic asm to extended asm&lt;/a&gt; for information about how to perform this conversion.</source>
          <target state="translated">Чтобы избежать осложнений из-за будущих изменений семантики и проблем совместимости между компиляторами, подумайте о замене базового &lt;code&gt;asm&lt;/code&gt; на расширенный &lt;code&gt;asm&lt;/code&gt; . См. &lt;a href=&quot;https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended&quot;&gt;Как преобразовать из базового asm в расширенный asm&lt;/a&gt; для получения информации о том, как выполнить это преобразование.</target>
        </trans-unit>
        <trans-unit id="ac3300fdd0a6bd75b07beded4de93f16de3369a5" translate="yes" xml:space="preserve">
          <source>To avoid exponential effects in the Graphite loop transforms, the number of parameters in a Static Control Part (SCoP) is bounded. A value of zero can be used to lift the bound. A variable whose value is unknown at compilation time and defined outside a SCoP is a parameter of the SCoP.</source>
          <target state="translated">Чтобы избежать экспоненциальных эффектов при преобразовании Графитового контура,количество параметров в статической управляющей части (SCoP)ограничено.Значение нуля может быть использовано для снятия границы.Переменная,значение которой неизвестно во время компиляции и определено вне SCoP,является параметром SCoP.</target>
        </trans-unit>
        <trans-unit id="9b629b2d987ad7e3698e47dd90332bddf769c0ae" translate="yes" xml:space="preserve">
          <source>To be fully SVR4 ABI-compliant at the cost of some performance loss, specify</source>
          <target state="translated">Чтобы быть полностью совместимым с SVR4 ABI за счет некоторой потери производительности,укажите</target>
        </trans-unit>
        <trans-unit id="80464eace90374e03d32650091e615c04e6c4a1e" translate="yes" xml:space="preserve">
          <source>To configure the hook, you set the global variable &lt;code&gt;__objc_msg_forward2&lt;/code&gt; to a function with the same argument and return types of &lt;code&gt;objc_msg_lookup()&lt;/code&gt;. When &lt;code&gt;objc_msg_lookup()&lt;/code&gt; cannot find a method implementation, it invokes the hook function you provided to get a method implementation to return. So, in practice &lt;code&gt;__objc_msg_forward2&lt;/code&gt; allows you to extend &lt;code&gt;objc_msg_lookup()&lt;/code&gt; by adding some custom code that is called to do a further lookup when no standard method implementation can be found using the normal lookup.</source>
          <target state="translated">Чтобы настроить ловушку, вы устанавливаете глобальную переменную &lt;code&gt;__objc_msg_forward2&lt;/code&gt; на функцию с тем же аргументом и возвращаемыми типами &lt;code&gt;objc_msg_lookup()&lt;/code&gt; . Когда &lt;code&gt;objc_msg_lookup()&lt;/code&gt; не может найти реализацию метода, он вызывает функцию-перехватчик, которую вы предоставили, чтобы вернуть реализацию метода. Итак, на практике &lt;code&gt;__objc_msg_forward2&lt;/code&gt; позволяет вам расширить &lt;code&gt;objc_msg_lookup()&lt;/code&gt; , добавив некоторый настраиваемый код, который вызывается для дальнейшего поиска, когда стандартная реализация метода не может быть найдена с помощью обычного поиска.</target>
        </trans-unit>
        <trans-unit id="d0892f6a61a5ddf8739ac6a9df58e9ff15e317ea" translate="yes" xml:space="preserve">
          <source>To create a precompiled header file, simply compile it as you would any other file, if necessary using the</source>
          <target state="translated">Чтобы создать прекомпилированный заголовочный файл,просто скомпилируйте его,как любой другой файл,если необходимо,с помощью кнопки</target>
        </trans-unit>
        <trans-unit id="3088551494e7c8fccec2e166c87f205757a7fee0" translate="yes" xml:space="preserve">
          <source>To declare a function inline, use the &lt;code&gt;inline&lt;/code&gt; keyword in its declaration, like this:</source>
          <target state="translated">Чтобы объявить функцию встроенной, используйте ключевое слово &lt;code&gt;inline&lt;/code&gt; в ее объявлении, например:</target>
        </trans-unit>
        <trans-unit id="5797514daed065cb1f475967a5b0ae2a149a5bab" translate="yes" xml:space="preserve">
          <source>To determine what tree dumps are available or find the dump for a pass of interest follow the steps below.</source>
          <target state="translated">Чтобы определить,какие свалки деревьев доступны,или найти свалку для перевала,выполните следующие действия.</target>
        </trans-unit>
        <trans-unit id="f1d8395854f85aca3686a491adc6bbc80456cbb1" translate="yes" xml:space="preserve">
          <source>To disable &lt;code&gt;__gcc_isr&lt;/code&gt; generation for the whole compilation unit, there is option</source>
          <target state="translated">Чтобы отключить генерацию &lt;code&gt;__gcc_isr&lt;/code&gt; для всего модуля компиляции, есть опция</target>
        </trans-unit>
        <trans-unit id="e0828348cc00b4bf17581e2c7550f1489803bf22" translate="yes" xml:space="preserve">
          <source>To do so, the runtime checks if the class of the receiver implements the method</source>
          <target state="translated">Для этого во время выполнения проверяется,реализует ли класс получателя метод</target>
        </trans-unit>
        <trans-unit id="501cee73b869b34929279976263c51903d154366" translate="yes" xml:space="preserve">
          <source>To enable debug info generation you need to supply</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881e567632131aa4c0fe4b9dfaf489bcd70667c6" translate="yes" xml:space="preserve">
          <source>To enable the creation of the dump file, append the pass code to the</source>
          <target state="translated">Чтобы включить создание файла дампа,добавьте пароль к</target>
        </trans-unit>
        <trans-unit id="0aa9530acd994c840dc3d2acd1762406cfa124f4" translate="yes" xml:space="preserve">
          <source>To enable the support for it you have to configure the compiler using an additional argument, &lt;code&gt;--enable-objc-gc&lt;/code&gt;. This will build the boehm-gc library, and build an additional runtime library which has several enhancements to support the garbage collector. The new library has a new name,</source>
          <target state="translated">Чтобы включить его поддержку, вам необходимо настроить компилятор с помощью дополнительного аргумента &lt;code&gt;--enable-objc-gc&lt;/code&gt; . Это создаст библиотеку boehm-gc и дополнительную библиотеку времени выполнения, которая имеет несколько улучшений для поддержки сборщика мусора. У новой библиотеки новое имя,</target>
        </trans-unit>
        <trans-unit id="a03cac0a42ba20ca789fab6e33a836d7beda4b6b" translate="yes" xml:space="preserve">
          <source>To ensure proper alignment of this values on the stack, the stack boundary must be as aligned as that required by any value stored on the stack. Further, every function must be generated such that it keeps the stack aligned. Thus calling a function compiled with a higher preferred stack boundary from a function compiled with a lower preferred stack boundary most likely misaligns the stack. It is recommended that libraries that use callbacks always use the default setting.</source>
          <target state="translated">Для обеспечения правильного выравнивания этих значений на стеке,граница стека должна быть выровнена так,как это требуется для любого значения,хранящегося на стеке.Кроме того,каждая функция должна быть сгенерирована таким образом,чтобы она поддерживала выравнивание стека.Таким образом,вызов функции,скомпилированной с более высокой предпочтительной границей стека,из функции,скомпилированной с более низкой предпочтительной границей стека,скорее всего,приведет к неправильному выравниванию стека.Рекомендуется,чтобы библиотеки,использующие обратные вызовы,всегда использовали настройку по умолчанию.</target>
        </trans-unit>
        <trans-unit id="71f72a9196daa0aa6fe25defa0d854e178b76e7c" translate="yes" xml:space="preserve">
          <source>To extract the real part of a complex-valued expression &lt;var&gt;exp&lt;/var&gt;, write &lt;code&gt;__real__ &lt;var&gt;exp&lt;/var&gt;&lt;/code&gt;. Likewise, use &lt;code&gt;__imag__&lt;/code&gt; to extract the imaginary part. This is a GNU extension; for values of floating type, you should use the ISO C99 functions &lt;code&gt;crealf&lt;/code&gt;, &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;creall&lt;/code&gt;, &lt;code&gt;cimagf&lt;/code&gt;, &lt;code&gt;cimag&lt;/code&gt; and &lt;code&gt;cimagl&lt;/code&gt;, declared in &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and also provided as built-in functions by GCC.</source>
          <target state="translated">Для того, чтобы извлечь реальную часть комплекснозначного выражения &lt;var&gt;exp&lt;/var&gt; , написать &lt;code&gt;__real__ &lt;var&gt;exp&lt;/var&gt;&lt;/code&gt; . Аналогичным образом используйте &lt;code&gt;__imag__&lt;/code&gt; для извлечения мнимой части. Это расширение GNU; для значений плавающего типа вы должны использовать функции ISO C99 &lt;code&gt;crealf&lt;/code&gt; , &lt;code&gt;creal&lt;/code&gt; , &lt;code&gt;creall&lt;/code&gt; , &lt;code&gt;cimagf&lt;/code&gt; , &lt;code&gt;cimag&lt;/code&gt; и &lt;code&gt;cimagl&lt;/code&gt; , объявленные в &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; , а также предоставляемые GCC как встроенные функции.</target>
        </trans-unit>
        <trans-unit id="7d03d577b7b5a669a7c4822e1a0edd45b2f8702a" translate="yes" xml:space="preserve">
          <source>To generate SSE/SSE2 instructions automatically from floating-point code (as opposed to 387 instructions), see</source>
          <target state="translated">Для автоматической генерации инструкций SSE/SSE2 из кода с плавающей точкой (в отличие от 387 инструкций),см.</target>
        </trans-unit>
        <trans-unit id="0e0fe141c8ecdca866163a97026bd7dfee64a0ff" translate="yes" xml:space="preserve">
          <source>To help solve this problem, CPP behaves specially for variable arguments used with the token paste operator, &amp;lsquo;</source>
          <target state="translated">Чтобы помочь решить эту проблему, CPP ведет себя специально для переменных аргументов, используемых с оператором вставки токена, '</target>
        </trans-unit>
        <trans-unit id="fccb76de9b13c0e702133668a7f3b6ce8851c913" translate="yes" xml:space="preserve">
          <source>To help with returning the objects, the &lt;code&gt;objects&lt;/code&gt; array is a C array preallocated by the caller (on the stack) of size &lt;code&gt;len&lt;/code&gt;. In many cases you can put the objects you want to return in that &lt;code&gt;objects&lt;/code&gt; array, then do &lt;code&gt;itemsPtr = objects&lt;/code&gt;. But you don&amp;rsquo;t have to; if your collection already has the objects to return in some form of C array, it could return them from there instead.</source>
          <target state="translated">Чтобы помочь с возвратом объектов, массив &lt;code&gt;objects&lt;/code&gt; представляет собой массив C, предварительно выделенный вызывающей стороной (в стеке) размером &lt;code&gt;len&lt;/code&gt; . Во многих случаях вы можете поместить объекты, которые хотите вернуть, в этот массив &lt;code&gt;objects&lt;/code&gt; , а затем сделать &lt;code&gt;itemsPtr = objects&lt;/code&gt; . Но вам не обязательно; если в вашей коллекции уже есть возвращаемые объекты в виде массива C, она может вернуть их оттуда.</target>
        </trans-unit>
        <trans-unit id="36d0f609e4fa3e2ba377279a7e5054298d93e189" translate="yes" xml:space="preserve">
          <source>To initialize a range of elements to the same value, write &amp;lsquo;</source>
          <target state="translated">Чтобы инициализировать диапазон элементов одним и тем же значением, напишите '</target>
        </trans-unit>
        <trans-unit id="9469a3d15175030b71c43e9782eac80132b4e50b" translate="yes" xml:space="preserve">
          <source>To make the above program fragment valid, place whitespace in front of the minus sign. This whitespace will end the preprocessing number.</source>
          <target state="translated">Чтобы сделать приведенный выше фрагмент программы корректным,поставьте пробел перед знаком минус.Этим пробелом закончится номер препроцессинга.</target>
        </trans-unit>
        <trans-unit id="1cff9fedec936f586685a14aa955b37f35f7182a" translate="yes" xml:space="preserve">
          <source>To make the code valid either use &lt;code&gt;this-&amp;gt;f()&lt;/code&gt;, or &lt;code&gt;Base&amp;lt;T&amp;gt;::f()&lt;/code&gt;. Using the</source>
          <target state="translated">Чтобы сделать код действительным, используйте &lt;code&gt;this-&amp;gt;f()&lt;/code&gt; или &lt;code&gt;Base&amp;lt;T&amp;gt;::f()&lt;/code&gt; . Используя</target>
        </trans-unit>
        <trans-unit id="9c492c2aa61afe70cee904ba589c05bee91367f4" translate="yes" xml:space="preserve">
          <source>To make whole program optimization effective, it is necessary to make certain whole program assumptions. The compiler needs to know what functions and variables can be accessed by libraries and runtime outside of the link-time optimized unit. When supported by the linker, the linker plugin (see</source>
          <target state="translated">Для того чтобы оптимизация программы в целом была эффективной,необходимо сделать определенные предположения о программе в целом.Компилятору необходимо знать,к каким функциям и переменным могут обращаться библиотеки и время выполнения вне модуля,оптимизированного по времени компоновки.При поддержке компоновщика,плагин компоновщика (см.</target>
        </trans-unit>
        <trans-unit id="b10f010a5357171b19c82dd57547e3f7673eff6e" translate="yes" xml:space="preserve">
          <source>To obtain all the diagnostics required by any of the standard versions described above you should specify</source>
          <target state="translated">Для получения всех диагностических данных,необходимых для любой из описанных выше стандартных версий,необходимо указать следующее</target>
        </trans-unit>
        <trans-unit id="e4aa89809c1011def5d99d621c233ec275d1953d" translate="yes" xml:space="preserve">
          <source>To optimize the program based on the collected profile information, use</source>
          <target state="translated">Для оптимизации программы на основе собранной профильной информации используйте</target>
        </trans-unit>
        <trans-unit id="60b4fed3cfe7ddfce1a0ca3458206394c1a66615" translate="yes" xml:space="preserve">
          <source>To prevent this from happening, if any input operand uses the &amp;lsquo;</source>
          <target state="translated">Чтобы этого не произошло, если какой-либо входной операнд использует '</target>
        </trans-unit>
        <trans-unit id="b232f82880621b972c64ec90d9ff0ca83f771650" translate="yes" xml:space="preserve">
          <source>To reference a label in the assembler template, prefix it with &amp;lsquo;</source>
          <target state="translated">Для ссылки на метку в шаблоне ассемблера поставьте перед ней префикс '</target>
        </trans-unit>
        <trans-unit id="da66ae5379009e523ed502eead6298d0e166f13e" translate="yes" xml:space="preserve">
          <source>To save space, do not emit out-of-line copies of inline functions controlled by &lt;code&gt;#pragma implementation&lt;/code&gt;. This causes linker errors if these functions are not inlined everywhere they are called.</source>
          <target state="translated">Чтобы сэкономить место, не создавайте автономные копии встроенных функций, контролируемых &lt;code&gt;#pragma implementation&lt;/code&gt; . Это вызывает ошибки компоновщика, если эти функции не встроены везде, где они вызываются.</target>
        </trans-unit>
        <trans-unit id="dd8d976d0714f674e209f146cbbc7e6de34ae80c" translate="yes" xml:space="preserve">
          <source>To see the meaning of the declaration using &lt;code&gt;typeof&lt;/code&gt;, and why it might be a useful way to write, rewrite it with these macros:</source>
          <target state="translated">Чтобы увидеть значение объявления с использованием &lt;code&gt;typeof&lt;/code&gt; и почему его можно использовать, перепишите его с помощью следующих макросов:</target>
        </trans-unit>
        <trans-unit id="40f035db3f8f044bbb0c622fe1fb92f16b378d0b" translate="yes" xml:space="preserve">
          <source>To specify an array index, write &amp;lsquo;</source>
          <target state="translated">Чтобы указать индекс массива, напишите '</target>
        </trans-unit>
        <trans-unit id="acb678e44477baccb18d5369a48bd2b0b5ec0599" translate="yes" xml:space="preserve">
          <source>To specify multiple attributes, separate them by commas within the double parentheses: for example, &amp;lsquo;</source>
          <target state="translated">Чтобы указать несколько атрибутов, разделите их запятыми в двойных скобках: например, '</target>
        </trans-unit>
        <trans-unit id="279b8a3b8509796e74c2ff0e52b4b2a1757b661c" translate="yes" xml:space="preserve">
          <source>To specify the assembler name for functions, write a declaration for the function before its definition and put &lt;code&gt;asm&lt;/code&gt; there, like this:</source>
          <target state="translated">Чтобы указать имя ассемблера для функций, напишите объявление функции перед ее определением и поместите туда &lt;code&gt;asm&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="3dcbee28f5f060da3b68aea636eb26d6ab9b499b" translate="yes" xml:space="preserve">
          <source>To support cross-profiling, a program compiled with</source>
          <target state="translated">Для поддержки перекрестного профилирования,программа,скомпилированная с помощью</target>
        </trans-unit>
        <trans-unit id="96365bc4676b236073f125730e587d433f50ff7e" translate="yes" xml:space="preserve">
          <source>To suppress this warning use the &lt;code&gt;unused&lt;/code&gt; attribute (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;).</source>
          <target state="translated">Чтобы подавить это предупреждение, используйте &lt;code&gt;unused&lt;/code&gt; атрибут (см. &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Атрибуты переменных&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4e4279a59e510b02bce48ca083689c7becefcae" translate="yes" xml:space="preserve">
          <source>To tell GCC to emit extra information for use by a debugger, in almost all cases you need only to add</source>
          <target state="translated">Чтобы сказать GCC излучать дополнительную информацию для использования отладчиком,почти во всех случаях нужно только добавить</target>
        </trans-unit>
        <trans-unit id="c0b5eb5cc6d2fda96d56fc807ba5364d278d6687" translate="yes" xml:space="preserve">
          <source>To use the link-time optimizer,</source>
          <target state="translated">Для использования линк-оптимизатора времени,</target>
        </trans-unit>
        <trans-unit id="89d57caa2b7e4b18d64025af8cb99faf45ba1cb2" translate="yes" xml:space="preserve">
          <source>To use these values, you need to be able to jump to one. This is done with the computed goto statement&lt;a href=&quot;#FOOT3&quot; id=&quot;DOCF3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;goto *&lt;var&gt;exp&lt;/var&gt;;&lt;/code&gt;. For example,</source>
          <target state="translated">Чтобы использовать эти значения, вы должны иметь возможность перейти к одному из них. Это делается с помощью вычисляемого оператора goto &lt;a href=&quot;#FOOT3&quot; id=&quot;DOCF3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; , &lt;code&gt;goto *&lt;var&gt;exp&lt;/var&gt;;&lt;/code&gt; , Например,</target>
        </trans-unit>
        <trans-unit id="9a059b55deba4fe3359e7e786d89afe0aa93dd23" translate="yes" xml:space="preserve">
          <source>To verify full coverage during</source>
          <target state="translated">Для проверки полного покрытия во время</target>
        </trans-unit>
        <trans-unit id="ec197d950172e34ea76227a1a78e887c52db9d18" translate="yes" xml:space="preserve">
          <source>To write a constant with a complex data type, use the suffix &amp;lsquo;</source>
          <target state="translated">Чтобы написать константу со сложным типом данных, используйте суффикс '</target>
        </trans-unit>
        <trans-unit id="38062ec8cfdea338e4b4a324dec29b0cd9799659" translate="yes" xml:space="preserve">
          <source>Together with a linker garbage collection (linker</source>
          <target state="translated">Вместе с компоновщиком для сбора мусора (компоновщик</target>
        </trans-unit>
        <trans-unit id="d5e14b063514cb6630e55f0aeb0ad3b37897efca" translate="yes" xml:space="preserve">
          <source>Toggle</source>
          <target state="translated">Toggle</target>
        </trans-unit>
        <trans-unit id="e6173ef9d580540f096dfe977ae2b3f003d86077" translate="yes" xml:space="preserve">
          <source>Top of 80387 floating-point stack (&lt;code&gt;%st(0)&lt;/code&gt;).</source>
          <target state="translated">Верх стека с плавающей запятой 80387 ( &lt;code&gt;%st(0)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="55f1f61607f8ef773d398fa71f442e01700f516d" translate="yes" xml:space="preserve">
          <source>Total Store Order</source>
          <target state="translated">Общий заказ магазина</target>
        </trans-unit>
        <trans-unit id="6bc1b3768ce894366a90239dc16d691ba72ece66" translate="yes" xml:space="preserve">
          <source>Track locations of tokens across macro expansions. This allows the compiler to emit diagnostic about the current macro expansion stack when a compilation error occurs in a macro expansion. Using this option makes the preprocessor and the compiler consume more memory. The &lt;var&gt;level&lt;/var&gt; parameter can be used to choose the level of precision of token location tracking thus decreasing the memory consumption if necessary. Value &amp;lsquo;</source>
          <target state="translated">Отслеживайте расположение токенов в расширениях макросов. Это позволяет компилятору выдавать диагностику о текущем стеке раскрытия макроса при возникновении ошибки компиляции в раскрытии макроса. Использование этой опции заставляет препроцессор и компилятор потреблять больше памяти. Параметр &lt;var&gt;level&lt;/var&gt; может использоваться для выбора уровня точности отслеживания местоположения токена, что при необходимости снижает потребление памяти. Стоимость '</target>
        </trans-unit>
        <trans-unit id="4293c6fc2d0c550f24f6474e968d410857105e2b" translate="yes" xml:space="preserve">
          <source>Track top N target addresses in indirect-call profile.</source>
          <target state="translated">Отслеживать верхние N целевых адресов в профиле непрямого вызова.</target>
        </trans-unit>
        <trans-unit id="723c149c69cf2602683e7f446ef904f72610c870" translate="yes" xml:space="preserve">
          <source>Tracks stack adjustments (pushes and pops) and stack memory references and then tries to find ways to combine them.</source>
          <target state="translated">Отслеживает корректировки стека (толкает и показывает)и ссылки в стеке памяти,а затем пытается найти способы их объединения.</target>
        </trans-unit>
        <trans-unit id="e7d7d66b6e955c972dc5701e4823af12fb85cdf2" translate="yes" xml:space="preserve">
          <source>Traditional C allows the following erroneous pair of declarations to appear together in a given scope:</source>
          <target state="translated">Традиционный C позволяет следующим ошибочным парам деклараций появляться вместе в заданной области применения:</target>
        </trans-unit>
        <trans-unit id="510d795979a46696182ad87a63664d2658cf856e" translate="yes" xml:space="preserve">
          <source>Traditionally, diagnostic messages have been formatted irrespective of the output device&amp;rsquo;s aspect (e.g. its width, &amp;hellip;). You can use the options described below to control the formatting algorithm for diagnostic messages, e.g. how many characters per line, how often source location information should be reported. Note that some language front ends may not honor these options.</source>
          <target state="translated">Традиционно диагностические сообщения форматируются независимо от вида устройства вывода (например, его ширины,&amp;hellip;). Вы можете использовать параметры, описанные ниже, для управления алгоритмом форматирования диагностических сообщений, например, сколько символов в строке, как часто должна сообщаться информация о местоположении источника. Обратите внимание, что некоторые языковые интерфейсы могут не учитывать эти параметры.</target>
        </trans-unit>
        <trans-unit id="1ab7709810cc2dcfdfcf719c4862cab474121c8b" translate="yes" xml:space="preserve">
          <source>Transaction abort due to a debug trap.</source>
          <target state="translated">Сделка прерывается из-за отладочной ловушки.</target>
        </trans-unit>
        <trans-unit id="cd7b3249c42fccf913301a9808dd3e7980d5264e" translate="yes" xml:space="preserve">
          <source>Transaction abort due to a memory conflict with another thread.</source>
          <target state="translated">Сделка прерывается из-за конфликта памяти с другим потоком.</target>
        </trans-unit>
        <trans-unit id="049238f821868925f76adff4fc7870e16eef0c6a" translate="yes" xml:space="preserve">
          <source>Transaction abort due to the transaction using too much memory.</source>
          <target state="translated">Сделка прерывается из-за того,что транзакция использует слишком много памяти.</target>
        </trans-unit>
        <trans-unit id="ead551a83f5f5bb74300da039b768d5b00d30187" translate="yes" xml:space="preserve">
          <source>Transaction abort in an inner nested transaction.</source>
          <target state="translated">Сделка прерывается во внутренней вложенной сделке.</target>
        </trans-unit>
        <trans-unit id="485e36de3e4a7d7cfcfa7ddabb0a849c973eb7dd" translate="yes" xml:space="preserve">
          <source>Transaction retry is possible.</source>
          <target state="translated">Возможна повторная попытка транзакции.</target>
        </trans-unit>
        <trans-unit id="4c0bda536dbe2634713edf7ae5619b61d4b2b7ec" translate="yes" xml:space="preserve">
          <source>Transaction was explicitly aborted with &lt;code&gt;_xabort&lt;/code&gt;. The parameter passed to &lt;code&gt;_xabort&lt;/code&gt; is available with &lt;code&gt;_XABORT_CODE(status)&lt;/code&gt;.</source>
          <target state="translated">Транзакция была явно прервана с помощью &lt;code&gt;_xabort&lt;/code&gt; . Параметр, переданный в &lt;code&gt;_xabort&lt;/code&gt; , доступен с &lt;code&gt;_XABORT_CODE(status)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50f4a1ebc38e5d0f03feed213fa084a39f1c4ca1" translate="yes" xml:space="preserve">
          <source>Transparent unions are designed for library functions that have multiple interfaces for compatibility reasons. For example, suppose the &lt;code&gt;wait&lt;/code&gt; function must accept either a value of type &lt;code&gt;int *&lt;/code&gt; to comply with POSIX, or a value of type &lt;code&gt;union wait *&lt;/code&gt; to comply with the 4.1BSD interface. If &lt;code&gt;wait&lt;/code&gt;&amp;rsquo;s parameter were &lt;code&gt;void *&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt; would accept both kinds of arguments, but it would also accept any other pointer type and this would make argument type checking less useful. Instead, &lt;code&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/code&gt; might define the interface as follows:</source>
          <target state="translated">Прозрачные объединения предназначены для библиотечных функций, которые имеют несколько интерфейсов по соображениям совместимости. Например, предположим, что функция &lt;code&gt;wait&lt;/code&gt; должна принимать либо значение типа &lt;code&gt;int *&lt;/code&gt; , чтобы соответствовать POSIX, либо значение типа &lt;code&gt;union wait *&lt;/code&gt; , чтобы соответствовать интерфейсу 4.1BSD. Если бы параметр &lt;code&gt;wait&lt;/code&gt; был &lt;code&gt;void *&lt;/code&gt; , &lt;code&gt;wait&lt;/code&gt; принял бы оба типа аргументов, но он также принял бы любой другой тип указателя, и это сделало бы проверку типа аргумента менее полезной. Вместо этого &lt;code&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/code&gt; мог бы определять интерфейс следующим образом:</target>
        </trans-unit>
        <trans-unit id="cc0f9c4ade227657a2baa1dad9f725c64aa01d3a" translate="yes" xml:space="preserve">
          <source>Trap (do not trap) on integer division by zero.</source>
          <target state="translated">Ловушка (не ловушка)при целочисленном делении на ноль.</target>
        </trans-unit>
        <trans-unit id="6d00c4acc18e3548fcbf61342f9558417419f4a6" translate="yes" xml:space="preserve">
          <source>Treat a &lt;code&gt;throw()&lt;/code&gt; exception specification as if it were a &lt;code&gt;noexcept&lt;/code&gt; specification to reduce or eliminate the text size overhead relative to a function with no exception specification. If the function has local variables of types with non-trivial destructors, the exception specification actually makes the function smaller because the EH cleanups for those variables can be optimized away. The semantic effect is that an exception thrown out of a function with such an exception specification results in a call to &lt;code&gt;terminate&lt;/code&gt; rather than &lt;code&gt;unexpected&lt;/code&gt;.</source>
          <target state="translated">Относитесь к спецификации исключения &lt;code&gt;throw()&lt;/code&gt; как если бы это была спецификация &lt;code&gt;noexcept&lt;/code&gt; , чтобы уменьшить или устранить накладные расходы на размер текста по сравнению с функцией без спецификации исключения. Если функция имеет локальные переменные типов с нетривиальными деструкторами, спецификация исключения фактически делает функцию меньше, поскольку очистку EH для этих переменных можно оптимизировать. Семантический эффект заключается в том, что исключение, выброшенное из функции с такой спецификацией исключения, приводит к &lt;code&gt;terminate&lt;/code&gt; вызова, а не к &lt;code&gt;unexpected&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efcf63ae910bd65526e3a00af5485e708789997f" translate="yes" xml:space="preserve">
          <source>Treat all calls as being far away (near). If calls are assumed to be far away, the compiler always loads the function&amp;rsquo;s address into a register, and calls indirect through the pointer.</source>
          <target state="translated">Считайте все звонки далекими (близкими). Если предполагается, что вызовы находятся далеко, компилятор всегда загружает адрес функции в регистр и вызывает косвенные вызовы через указатель.</target>
        </trans-unit>
        <trans-unit id="e657b1f5ccca3a3f8f766ebdbdec5db7187eaa45" translate="yes" xml:space="preserve">
          <source>Treat floating-point constants as single precision instead of implicitly converting them to double-precision constants.</source>
          <target state="translated">Обращайтесь с константами с плавающей точкой как с единичной точностью,вместо того,чтобы неявно преобразовывать их в константы двойной точности.</target>
        </trans-unit>
        <trans-unit id="b9730fd8c54eee8a380dfaa34a9eb35908c0edfe" translate="yes" xml:space="preserve">
          <source>Treat the register named &lt;var&gt;reg&lt;/var&gt; as a fixed register; generated code should never refer to it (except perhaps as a stack pointer, frame pointer or in some other fixed role).</source>
          <target state="translated">Рассматривайте регистр с именем &lt;var&gt;reg&lt;/var&gt; как фиксированный регистр; сгенерированный код никогда не должен ссылаться на него (кроме, возможно, указателя стека, указателя кадра или какой-либо другой фиксированной роли).</target>
        </trans-unit>
        <trans-unit id="24bec37045b31ff86b0699b95df9d95df0bb7391" translate="yes" xml:space="preserve">
          <source>Treat the register named &lt;var&gt;reg&lt;/var&gt; as an allocable register saved by functions. It may be allocated even for temporaries or variables that live across a call. Functions compiled this way save and restore the register &lt;var&gt;reg&lt;/var&gt; if they use it.</source>
          <target state="translated">Рассматривайте регистр с именем &lt;var&gt;reg&lt;/var&gt; как доступный регистр, сохраненный функциями. Он может быть выделен даже для временных или переменных, находящихся в вызове. Скомпилированные таким образом функции сохраняют и восстанавливают регистр &lt;var&gt;reg&lt;/var&gt; , если они его используют.</target>
        </trans-unit>
        <trans-unit id="9ed7e368cac1e3940cdf973c2d7cc16201bdbf48" translate="yes" xml:space="preserve">
          <source>Treat the register named &lt;var&gt;reg&lt;/var&gt; as an allocable register that is clobbered by function calls. It may be allocated for temporaries or variables that do not live across a call. Functions compiled this way do not save and restore the register &lt;var&gt;reg&lt;/var&gt;.</source>
          <target state="translated">Рассматривайте регистр с именем &lt;var&gt;reg&lt;/var&gt; как выделяемый регистр, который затирается вызовами функций. Он может быть выделен для временных или переменных, которые не используются в вызове. Скомпилированные таким образом функции не сохраняют и не восстанавливают регистр &lt;var&gt;reg&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b7012f8bdb10f107e038866fe0f141acd75a5071" translate="yes" xml:space="preserve">
          <source>Treat the register used for PIC addressing as read-only, rather than loading it in the prologue for each function. The runtime system is responsible for initializing this register with an appropriate value before execution begins.</source>
          <target state="translated">Считайте регистр,используемый для адресации PIC,доступным только для чтения,а не загружайте его в пролог для каждой функции.Система исполнения отвечает за инициализацию этого регистра соответствующим значением перед началом выполнения.</target>
        </trans-unit>
        <trans-unit id="d6dc381ff0b0eaf3a75a3644a1928e76a876add7" translate="yes" xml:space="preserve">
          <source>Treat the stack pointer register as an 8-bit register, i.e. assume the high byte of the stack pointer is zero. In general, you don&amp;rsquo;t need to set this option by hand.</source>
          <target state="translated">Рассматривайте регистр указателя стека как 8-битный регистр, т.е. предполагайте, что старший байт указателя стека равен нулю. В общем, вам не нужно устанавливать этот параметр вручную.</target>
        </trans-unit>
        <trans-unit id="18a09707746246ab1f81f3b198c6fce704d60805" translate="yes" xml:space="preserve">
          <source>Try to align labels to an 8-byte boundary by inserting NOPs into the previous packet. This option only has an effect when VLIW packing is enabled. It doesn&amp;rsquo;t create new packets; it merely adds NOPs to existing ones.</source>
          <target state="translated">Попробуйте выровнять метки по 8-байтовой границе, вставив NOP в предыдущий пакет. Этот параметр действует, только если включена упаковка VLIW. Он не создает новых пакетов; он просто добавляет NOP к существующим.</target>
        </trans-unit>
        <trans-unit id="5d7f1893937b8021a0b45b38ecc6c5c5982860f9" translate="yes" xml:space="preserve">
          <source>Try to format error messages so that they fit on lines of about &lt;var&gt;n&lt;/var&gt; characters. If &lt;var&gt;n&lt;/var&gt; is zero, then no line-wrapping is done; each error message appears on a single line. This is the default for all front ends.</source>
          <target state="translated">Постарайтесь отформатировать сообщения об ошибках так, чтобы они умещались в строках примерно из &lt;var&gt;n&lt;/var&gt; символов. Если &lt;var&gt;n&lt;/var&gt; равно нулю, перенос строки не выполняется; каждое сообщение об ошибке отображается в отдельной строке. Это значение по умолчанию для всех внешних интерфейсов.</target>
        </trans-unit>
        <trans-unit id="51ead7ad6ca24e037be309703712bdaf58fe0308" translate="yes" xml:space="preserve">
          <source>Try to imitate the behavior of pre-standard C preprocessors, as opposed to ISO C preprocessors. See the GNU CPP manual for details.</source>
          <target state="translated">Попробуйте подражать поведению препроцессоров стандарта С,в отличие от препроцессоров ISO C.Подробности см.в руководстве GNU CPP.</target>
        </trans-unit>
        <trans-unit id="c8878a439f989aa10bd1de06d6919d9cd9fccd45" translate="yes" xml:space="preserve">
          <source>Try to make the code as small as possible. At present, this just turns on the</source>
          <target state="translated">Постарайтесь сделать код как можно меньше.В настоящее время это просто включает</target>
        </trans-unit>
        <trans-unit id="2943824dd1677f0ee45e17f3ad727f59c256ccaf" translate="yes" xml:space="preserve">
          <source>Try to reduce the number of symbolic address calculations by using shared &amp;ldquo;anchor&amp;rdquo; symbols to address nearby objects. This transformation can help to reduce the number of GOT entries and GOT accesses on some targets.</source>
          <target state="translated">Постарайтесь уменьшить количество вычислений символьных адресов, используя общие &amp;laquo;якорные&amp;raquo; символы для адресации ближайших объектов. Это преобразование может помочь уменьшить количество записей GOT и доступов GOT для некоторых целей.</target>
        </trans-unit>
        <trans-unit id="71689cce79c81b27513c53eda29d40ea96948251" translate="yes" xml:space="preserve">
          <source>Try to replace &lt;code&gt;CALL&lt;/code&gt; resp. &lt;code&gt;JMP&lt;/code&gt; instruction by the shorter &lt;code&gt;RCALL&lt;/code&gt; resp. &lt;code&gt;RJMP&lt;/code&gt; instruction if applicable. Setting</source>
          <target state="translated">Попробуйте заменить &lt;code&gt;CALL&lt;/code&gt; resp. Инструкция &lt;code&gt;JMP&lt;/code&gt; более коротким &lt;code&gt;RCALL&lt;/code&gt; соответственно. Инструкция &lt;code&gt;RJMP&lt;/code&gt; , если применимо. настройка</target>
        </trans-unit>
        <trans-unit id="7f5db504e6f50390be7556b15f1e06e74d98003b" translate="yes" xml:space="preserve">
          <source>Try to turn PIC calls that are normally dispatched via register &lt;code&gt;$25&lt;/code&gt; into direct calls. This is only possible if the linker can resolve the destination at link time and if the destination is within range for a direct call.</source>
          <target state="translated">Попробуйте превратить вызовы PIC, которые обычно отправляются через регистр &lt;code&gt;$25&lt;/code&gt; в прямые вызовы. Это возможно только в том случае, если компоновщик может разрешить назначение во время связывания и если место назначения находится в пределах диапазона для прямого вызова.</target>
        </trans-unit>
        <trans-unit id="d986cee6514cc454cabe1b04f373619d70b76947" translate="yes" xml:space="preserve">
          <source>Tune for ARC600 CPU.</source>
          <target state="translated">Настройка для процессора ARC600.</target>
        </trans-unit>
        <trans-unit id="cd581f56e3b57950cd6ef9a480d293254a2ecd23" translate="yes" xml:space="preserve">
          <source>Tune for ARC601 CPU.</source>
          <target state="translated">Настройка для процессора ARC601.</target>
        </trans-unit>
        <trans-unit id="3d1d8bffb14bf81b97f78406c7f3b23782c05dcc" translate="yes" xml:space="preserve">
          <source>Tune for ARC700 CPU with XMAC block.</source>
          <target state="translated">Настройка для процессора ARC700 с блоком XMAC.</target>
        </trans-unit>
        <trans-unit id="eb447e923ad8db257fca3ee02ccc66a1cc26b9c9" translate="yes" xml:space="preserve">
          <source>Tune for ARC700 CPU with standard multiplier block.</source>
          <target state="translated">Настройка для процессора ARC700 со стандартным блоком множителей.</target>
        </trans-unit>
        <trans-unit id="0124418dee31dd7297585683b0a95e9f65f2e8cc" translate="yes" xml:space="preserve">
          <source>Tune for ARC725D CPU.</source>
          <target state="translated">Настройка для процессора ARC725D.</target>
        </trans-unit>
        <trans-unit id="a99d4307ca5e0f869f7793d383503e6ec8def3af" translate="yes" xml:space="preserve">
          <source>Tune for ARC750D CPU.</source>
          <target state="translated">Настройка для процессора ARC750D.</target>
        </trans-unit>
        <trans-unit id="57d5b9e241148e9c20bf6639665bc7f5200a0c7a" translate="yes" xml:space="preserve">
          <source>Tune the code for a particular microarchitecture within the constraints set by</source>
          <target state="translated">Настройте код для конкретной микроархитектуры в рамках ограничений,установленных параметрами</target>
        </trans-unit>
        <trans-unit id="e11fd75fe2998bc88e3a55f06c902e5e06c31f2d" translate="yes" xml:space="preserve">
          <source>Tune the instruction scheduling for a particular CPU, Valid values are &amp;lsquo;</source>
          <target state="translated">Настройте расписание инструкций для конкретного ЦП. Допустимые значения:</target>
        </trans-unit>
        <trans-unit id="73d6ee31240249a6f0e63fbef357f9d54da8845d" translate="yes" xml:space="preserve">
          <source>Tune to &lt;var&gt;architecture-type&lt;/var&gt; everything applicable about the generated code, except for the ABI and the set of available instructions. The choices for &lt;var&gt;architecture-type&lt;/var&gt; are the same as for</source>
          <target state="translated">Настройтесь на &lt;var&gt;architecture-type&lt;/var&gt; всего, что применимо в сгенерированном коде, кроме ABI и набора доступных инструкций. Выбор &lt;var&gt;architecture-type&lt;/var&gt; такой же, как и для</target>
        </trans-unit>
        <trans-unit id="abe7006b22b302a45d8adf679048506cceec6621" translate="yes" xml:space="preserve">
          <source>Tune to &lt;var&gt;cpu-type&lt;/var&gt; everything applicable about the generated code, except for the ABI and the set of available instructions. The list of &lt;var&gt;cpu-type&lt;/var&gt; values is the same as for</source>
          <target state="translated">Настройтесь на &lt;var&gt;cpu-type&lt;/var&gt; всего, что применимо в сгенерированном коде, кроме ABI и набора доступных инструкций. Список значений &lt;var&gt;cpu-type&lt;/var&gt; ЦП такой же, как и для</target>
        </trans-unit>
        <trans-unit id="8ce8ad1c804c3f77bbd9eaaa6bff5e1dd657796d" translate="yes" xml:space="preserve">
          <source>Tune to &lt;var&gt;cpu-type&lt;/var&gt; everything applicable about the generated code, except for the ABI and the set of available instructions. While picking a specific &lt;var&gt;cpu-type&lt;/var&gt; schedules things appropriately for that particular chip, the compiler does not generate any code that cannot run on the default machine type unless you use a</source>
          <target state="translated">Настройтесь на &lt;var&gt;cpu-type&lt;/var&gt; всего, что применимо в сгенерированном коде, кроме ABI и набора доступных инструкций. При выборе определенного &lt;var&gt;cpu-type&lt;/var&gt; планирование действий для этого конкретного чипа, компилятор не генерирует код, который не может работать на компьютере по умолчанию, если вы не используете</target>
        </trans-unit>
        <trans-unit id="2ff319ca41c83d456fd2660af1ba3a0a39ead43b" translate="yes" xml:space="preserve">
          <source>Turn off all access checking. This switch is mainly useful for working around bugs in the access control code.</source>
          <target state="translated">Отключите все проверки доступа.Этот переключатель в основном полезен для работы с ошибками в коде контроля доступа.</target>
        </trans-unit>
        <trans-unit id="5aa7ded6e9138148782165f8ff6c917050fd8448" translate="yes" xml:space="preserve">
          <source>Turn off any specification of a language, so that subsequent files are handled according to their file name suffixes (as they are if</source>
          <target state="translated">Выключите любую спецификацию языка,чтобы последующие файлы обрабатывались в соответствии с суффиксами имен файлов (как если бы они были</target>
        </trans-unit>
        <trans-unit id="05599d87457784f5e8fcf58f82a82201f42c5e95" translate="yes" xml:space="preserve">
          <source>Turn off generation of debug info, if leaving out this option generates it, or turn it on at level 2 otherwise. The position of this argument in the command line does not matter; it takes effect after all other options are processed, and it does so only once, no matter how many times it is given. This is mainly intended to be used with</source>
          <target state="translated">Выключите генерацию отладочной информации,если убрать эту опцию,или включите ее на 2-м уровне в противном случае.Положение этого аргумента в командной строке не имеет значения,он вступает в силу после обработки всех остальных опций,и делает это только один раз,независимо от того,сколько раз он был задан.В основном он предназначен для использования с</target>
        </trans-unit>
        <trans-unit id="c6b5015cd05574d36521c886faa5f1fe72388eb1" translate="yes" xml:space="preserve">
          <source>Turn on all optimization options, i.e.,</source>
          <target state="translated">Включите все опции оптимизации,т.е,</target>
        </trans-unit>
        <trans-unit id="1f38ffe59dc7af4e39268866c9d6bf540ff3e935" translate="yes" xml:space="preserve">
          <source>Turn on all options, except</source>
          <target state="translated">Включите все опции,кроме</target>
        </trans-unit>
        <trans-unit id="addc4296812df31340ecc8097c6637d705b4dc51" translate="yes" xml:space="preserve">
          <source>Turning on optimization flags makes the compiler attempt to improve the performance and/or code size at the expense of compilation time and possibly the ability to debug the program.</source>
          <target state="translated">Включение флагов оптимизации заставляет компилятор пытаться улучшить производительность и/или объем кода за счет времени компиляции и,возможно,возможности отладки программы.</target>
        </trans-unit>
        <trans-unit id="0abd8c32d9b5b449c21960750d5d9b900609a45e" translate="yes" xml:space="preserve">
          <source>Tweak register allocation to help 16-bit instruction generation. This generally has the effect of decreasing the average instruction size while increasing the instruction count.</source>
          <target state="translated">Твик распределения регистров для помощи в генерации 16-битных инструкций.Как правило,это приводит к уменьшению среднего размера команд при увеличении их количества.</target>
        </trans-unit>
        <trans-unit id="cc2345bb4c5df388b03bf38fa376e4f8708c805d" translate="yes" xml:space="preserve">
          <source>Two 16x16 multipliers, blocking, sequential. The following instructions are additionally enabled: &lt;code&gt;mpy&lt;/code&gt;, &lt;code&gt;mpyu&lt;/code&gt;, &lt;code&gt;mpym&lt;/code&gt;, &lt;code&gt;mpymu&lt;/code&gt;, and &lt;code&gt;mpy_s&lt;/code&gt;.</source>
          <target state="translated">Два множителя 16x16, блокирующие, последовательные. Дополнительно включены следующие инструкции: &lt;code&gt;mpy&lt;/code&gt; , &lt;code&gt;mpyu&lt;/code&gt; , &lt;code&gt;mpym&lt;/code&gt; , &lt;code&gt;mpymu&lt;/code&gt; и &lt;code&gt;mpy_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b000d97aa40706cbe471fe85b50413fb0224467" translate="yes" xml:space="preserve">
          <source>Two additional variants of the o32 ABI are supported to enable a transition from 32-bit to 64-bit registers. These are FPXX (</source>
          <target state="translated">Поддерживаются два дополнительных варианта o32 ABI для перехода с 32-битных на 64-битные регистры.Это FPXX (</target>
        </trans-unit>
        <trans-unit id="2bc5d51eed63377e23ba7ef70163b3178b799fe5" translate="yes" xml:space="preserve">
          <source>Two&amp;rsquo;s complement of a 6-bit unsigned integer constant.</source>
          <target state="translated">Дополнение до двух 6-битовой целочисленной константы без знака.</target>
        </trans-unit>
        <trans-unit id="65d021ad85f9ecc2bd4449ee63312946ef7cb6cb" translate="yes" xml:space="preserve">
          <source>Two-stage name lookup sometimes leads to situations with behavior different from non-template codes. The most common is probably this:</source>
          <target state="translated">Двухэтапный поиск имени иногда приводит к ситуациям с поведением,отличным от поведения нешаблонных кодов.Самая распространенная из них-это,наверное,это:</target>
        </trans-unit>
        <trans-unit id="575680b4fbe2bb6b6d519cf112b732f205e5669e" translate="yes" xml:space="preserve">
          <source>Type Attributes</source>
          <target state="translated">Атрибуты типа</target>
        </trans-unit>
        <trans-unit id="8492437da1bd59c92bb55d3921577991dfd8045e" translate="yes" xml:space="preserve">
          <source>Types &lt;code&gt;_Decimal32&lt;/code&gt;, &lt;code&gt;_Decimal64&lt;/code&gt;, and &lt;code&gt;_Decimal128&lt;/code&gt; are supported by the DWARF debug information format.</source>
          <target state="translated">Типы &lt;code&gt;_Decimal32&lt;/code&gt; , &lt;code&gt;_Decimal64&lt;/code&gt; и &lt;code&gt;_Decimal128&lt;/code&gt; поддерживаются форматом отладочной информации DWARF.</target>
        </trans-unit>
        <trans-unit id="92c5b269a787c7229d4b1731f191eb104665ea8a" translate="yes" xml:space="preserve">
          <source>Types, but not their members, are not hidden by default.</source>
          <target state="translated">Типы,но не их члены,не скрыты по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="2f40553950efdfee2da54d1ec023b02b81e2bf58" translate="yes" xml:space="preserve">
          <source>UHK</source>
          <target state="translated">UHK</target>
        </trans-unit>
        <trans-unit id="f1d002b3861d02936136d383f32b05c7363677ef" translate="yes" xml:space="preserve">
          <source>UHR</source>
          <target state="translated">UHR</target>
        </trans-unit>
        <trans-unit id="7770d04c7bfb791e7c95959f12d6797bee87a8d8" translate="yes" xml:space="preserve">
          <source>UK</source>
          <target state="translated">UK</target>
        </trans-unit>
        <trans-unit id="c297964acee362f7f2dba4952f8bafc43415d17b" translate="yes" xml:space="preserve">
          <source>UL</source>
          <target state="translated">UL</target>
        </trans-unit>
        <trans-unit id="f02a449aa1e45687b9dd404230f554d77889736a" translate="yes" xml:space="preserve">
          <source>ULK</source>
          <target state="translated">ULK</target>
        </trans-unit>
        <trans-unit id="23068141b1ba54cf3def8562e3144f8201f1de6d" translate="yes" xml:space="preserve">
          <source>ULL</source>
          <target state="translated">ULL</target>
        </trans-unit>
        <trans-unit id="ea3c4fdc7ae483f6eeee71767d6d7c25afd3b747" translate="yes" xml:space="preserve">
          <source>ULLK</source>
          <target state="translated">ULLK</target>
        </trans-unit>
        <trans-unit id="bd9c57578a5fa70fa2923dfa1948bb1047652950" translate="yes" xml:space="preserve">
          <source>ULLR</source>
          <target state="translated">ULLR</target>
        </trans-unit>
        <trans-unit id="181f09b6cf6ff48fe2bced4f8717c409974c7ccb" translate="yes" xml:space="preserve">
          <source>ULR</source>
          <target state="translated">ULR</target>
        </trans-unit>
        <trans-unit id="fdf943dd853f60e8f066b9ff1db365525dfa7714" translate="yes" xml:space="preserve">
          <source>UR</source>
          <target state="translated">UR</target>
        </trans-unit>
        <trans-unit id="b92dcc34c6f88a2b085f0fcf11324b5c2cf08f22" translate="yes" xml:space="preserve">
          <source>Unary absolute value.</source>
          <target state="translated">Унарное абсолютное значение.</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">Унарное отрицание.</target>
        </trans-unit>
        <trans-unit id="5b74b98336e7267fb4f37f0b361c833e21dc0aa0" translate="yes" xml:space="preserve">
          <source>Unary square root operation.</source>
          <target state="translated">Унарный квадратный корень.</target>
        </trans-unit>
        <trans-unit id="00399f106390204b9e8a47f8e8e78be426150d13" translate="yes" xml:space="preserve">
          <source>Unbounded uses, on the other hand, are uses of &lt;code&gt;alloca&lt;/code&gt; with no controlling predicate constraining its integer argument. For example:</source>
          <target state="translated">С другой стороны, неограниченное использование - это использование &lt;code&gt;alloca&lt;/code&gt; без управляющего предиката, ограничивающего его целочисленный аргумент. Например:</target>
        </trans-unit>
        <trans-unit id="d6ba59d2b5ffc5c4e08397a280a30fb560e8436a" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; when</source>
          <target state="translated">Неопределение &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; , когда</target>
        </trans-unit>
        <trans-unit id="f070a98f1b801c2b6e78c0be33c88683a70671cf" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code&gt;__STDC__&lt;/code&gt; in C++.</source>
          <target state="translated">Неопределение &lt;code&gt;__STDC__&lt;/code&gt; в C ++.</target>
        </trans-unit>
        <trans-unit id="ca3f9bb4feba0ac0f3a9b154b20506b4c489b2f4" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your &lt;code&gt;asm&lt;/code&gt; code defines symbols or labels. Using &amp;lsquo;</source>
          <target state="translated">При определенных обстоятельствах GCC может дублировать (или удалять дубликаты) ваш ассемблерный код при оптимизации. Это может привести к неожиданным ошибкам дублирования символов во время компиляции, если ваш код &lt;code&gt;asm&lt;/code&gt; определяет символы или метки. С помощью '</target>
        </trans-unit>
        <trans-unit id="199aae5416e814ba38647e12711c671c6b6db5a1" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your assembly code defines symbols or labels.</source>
          <target state="translated">При определенных обстоятельствах GCC может дублировать (или удалять дубликаты)вашего ассемблерного кода при оптимизации.Это может привести к неожиданным ошибкам при дублировании символов во время компиляции,если ваш ассемблерный код определяет символы или метки.</target>
        </trans-unit>
        <trans-unit id="72b29a25fd6f124cae730e139b0e10b10a80e560" translate="yes" xml:space="preserve">
          <source>Unfortunately, historically GCC used to have a number of bugs in its encoding code. The NeXT runtime expects GCC to emit type encodings in this historical format (compatible with GCC-3.3), so when using the NeXT runtime, GCC will introduce on purpose a number of incorrect encodings:</source>
          <target state="translated">К сожалению,исторически GCC имел ряд ошибок в своем кодировочном коде.Во время выполнения NeXT GCC ожидает,что в этом историческом формате (совместимом с GCC-3.3)будут излучаться кодировки типа,поэтому при использовании времени выполнения NeXT GCC будет специально вводить ряд неправильных кодировок:</target>
        </trans-unit>
        <trans-unit id="aeee418a8137652ee6d9ab3008a38b4d74bc2a2f" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are some characters allowed in identifiers by ISO C and ISO C++ that, when turned into NFC, are not allowed in identifiers. That is, there&amp;rsquo;s no way to use these symbols in portable ISO C or C++ and have all your identifiers in NFC.</source>
          <target state="translated">К сожалению, в идентификаторах ISO C и ISO C ++ разрешены некоторые символы, которые при преобразовании в NFC не допускаются в идентификаторах. То есть нет возможности использовать эти символы в переносимых ISO C или C ++ и иметь все ваши идентификаторы в NFC.</target>
        </trans-unit>
        <trans-unit id="5ddc1e63d4f989177759a83df41bd4b7dad20371" translate="yes" xml:space="preserve">
          <source>Unix C compilers have traditionally allocated storage for uninitialized global variables in a common block. This allows the linker to resolve all tentative definitions of the same variable in different compilation units to the same object, or to a non-tentative definition. This is the behavior specified by</source>
          <target state="translated">Компиляторы Unix C традиционно выделяют хранилище для неинициализированных глобальных переменных в общем блоке.Это позволяет компоновщику разрешать все условные определения одной и той же переменной в разных единицах компиляции в один и тот же объект или в не условное определение.Это поведение определяется</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="d6a3e0eb54ec1efd8ae1e1735e817354b9b6421f" translate="yes" xml:space="preserve">
          <source>Unless &lt;var&gt;*ptr&lt;/var&gt; and &lt;var&gt;vobj&lt;/var&gt; can be aliased, it is not guaranteed that the write to &lt;var&gt;*ptr&lt;/var&gt; occurs by the time the update of &lt;var&gt;vobj&lt;/var&gt; happens. If you need this guarantee, you must use a stronger memory barrier such as:</source>
          <target state="translated">Если только &lt;var&gt;*ptr&lt;/var&gt; и &lt;var&gt;vobj&lt;/var&gt; не могут иметь псевдонимы, не гарантируется, что запись в &lt;var&gt;*ptr&lt;/var&gt; произойдет к моменту обновления &lt;var&gt;vobj&lt;/var&gt; . Если вам нужна эта гарантия, вы должны использовать более сильный барьер памяти, например:</target>
        </trans-unit>
        <trans-unit id="c9e3382936f0af0d7125a8bf9b98d564d02b82c4" translate="yes" xml:space="preserve">
          <source>Unless specified explicitly (with</source>
          <target state="translated">Если не указано прямо (с</target>
        </trans-unit>
        <trans-unit id="5eaa8563a22dc64db7ac666eb5d3e5ba11cc1996" translate="yes" xml:space="preserve">
          <source>Unlike Java, Objective-C does not allow for entire methods to be marked &lt;code&gt;@synchronized&lt;/code&gt;. Note that throwing exceptions out of &lt;code&gt;@synchronized&lt;/code&gt; blocks is allowed, and will cause the guarding object to be unlocked properly.</source>
          <target state="translated">В отличие от Java, Objective-C не позволяет помечать целые методы как &lt;code&gt;@synchronized&lt;/code&gt; . Обратите внимание, что выброс исключений из блоков &lt;code&gt;@synchronized&lt;/code&gt; разрешен и приведет к правильной разблокировке объекта защиты.</target>
        </trans-unit>
        <trans-unit id="0cd317bbd72a217068977127c104995a9862be9b" translate="yes" xml:space="preserve">
          <source>Unlike for floating-point numbers in the decimal notation the exponent is always required in the hexadecimal notation. Otherwise the compiler would not be able to resolve the ambiguity of, e.g., &lt;code&gt;0x1.f&lt;/code&gt;. This could mean &lt;code&gt;1.0f&lt;/code&gt; or &lt;code&gt;1.9375&lt;/code&gt; since &amp;lsquo;</source>
          <target state="translated">В отличие от чисел с плавающей запятой в десятичной системе счисления показатель степени всегда требуется в шестнадцатеричной системе счисления. В противном случае компилятор не сможет разрешить неоднозначность, например, &lt;code&gt;0x1.f&lt;/code&gt; . Это может означать &lt;code&gt;1.0f&lt;/code&gt; или &lt;code&gt;1.9375&lt;/code&gt; , поскольку '</target>
        </trans-unit>
        <trans-unit id="c540371c5127336fc94b6b29fa3c46f81c44897b" translate="yes" xml:space="preserve">
          <source>Unlike in C, in C++, flowing off the end of a non-&lt;code&gt;void&lt;/code&gt; function other than &lt;code&gt;main&lt;/code&gt; results in undefined behavior even when the value of the function is not used.</source>
          <target state="translated">В отличие от C, в C ++ переход за конец &lt;code&gt;void&lt;/code&gt; функции, отличной от &lt;code&gt;main&lt;/code&gt; , приводит к неопределенному поведению, даже если значение функции не используется.</target>
        </trans-unit>
        <trans-unit id="2a830c95434f7db0cbf0fd8fd9277c1d051a3f31" translate="yes" xml:space="preserve">
          <source>Unnamed struct/union fields within structs/unions.</source>
          <target state="translated">Неназванные структурные/союзные поля внутри структур/союзов.</target>
        </trans-unit>
        <trans-unit id="205edf29824c8a0cb244fc56417458952c504c66" translate="yes" xml:space="preserve">
          <source>Unrecognized input files, not requiring compilation or assembly, are ignored.</source>
          <target state="translated">Нераспознанные входные файлы,не требующие компиляции или сборки,игнорируются.</target>
        </trans-unit>
        <trans-unit id="a51fd22f926dc0631cc272a22033e9d7fec59c36" translate="yes" xml:space="preserve">
          <source>Unroll all loops, even if their number of iterations is uncertain when the loop is entered. This usually makes programs run more slowly.</source>
          <target state="translated">Разворачивать все циклы,даже если количество их итераций при входе в цикл неизвестно.Обычно это заставляет программы работать медленнее.</target>
        </trans-unit>
        <trans-unit id="fc450b83181b0c2161a73acfdbf2dc658513bec3" translate="yes" xml:space="preserve">
          <source>Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop.</source>
          <target state="translated">Развертывание циклов,количество итераций которых можно определить во время компиляции или при входе в цикл.</target>
        </trans-unit>
        <trans-unit id="ad4d059f80e723b4d81766ec66adc71e8b2e5c48" translate="yes" xml:space="preserve">
          <source>Unsigned 12-bit constant (0&amp;ndash;4095)</source>
          <target state="translated">12-битная константа без знака (0&amp;ndash;4095)</target>
        </trans-unit>
        <trans-unit id="aec081f8e4cecc49f843970cd77df1a02a1c1643" translate="yes" xml:space="preserve">
          <source>Unsigned 16 bit integer (in the range 0 to 65535)</source>
          <target state="translated">Беззнаковое 16-битное целое число (в диапазоне от 0 до 65535)</target>
        </trans-unit>
        <trans-unit id="01dcb67eb6663625a6596ec55251e6ebe419078e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant</source>
          <target state="translated">Беззнаковая 16-битная константа</target>
        </trans-unit>
        <trans-unit id="005d69054eb4a9d53e3d7fc838909272fcdf1d1e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant shifted left 16 bits (use &amp;lsquo;</source>
          <target state="translated">16-битная константа без знака, сдвинутая влево на 16 бит (используйте '</target>
        </trans-unit>
        <trans-unit id="803ea2cff434611bd7a889a5f8f4e2a80e2f6534" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit integer constant.</source>
          <target state="translated">Беззнаковая 16-битная целочисленная константа.</target>
        </trans-unit>
        <trans-unit id="baffe105924a920d4f7c404a4974ebe483612051" translate="yes" xml:space="preserve">
          <source>Unsigned 3 bit integer (in the range 0 to 7)</source>
          <target state="translated">Беззнаковое 3-х битное целое число (в диапазоне от 0 до 7)</target>
        </trans-unit>
        <trans-unit id="5d0b43b79f775a23c99274c057849b2132918314" translate="yes" xml:space="preserve">
          <source>Unsigned 5 bit integer (in the range 0 to 31)</source>
          <target state="translated">Беззнаковое 5-битное целое число (в диапазоне от 0 до 31)</target>
        </trans-unit>
        <trans-unit id="ee9e535a39880e194545226484f376dc9293656d" translate="yes" xml:space="preserve">
          <source>Unsigned 7 bit integer (in the range 0 to 127)</source>
          <target state="translated">Беззнаковое 7-битное целое число (в диапазоне от 0 до 127)</target>
        </trans-unit>
        <trans-unit id="64587bc80a139da54c64da1869304a4854d6ae7d" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit constant (0&amp;ndash;255)</source>
          <target state="translated">8-битная константа без знака (0&amp;ndash;255)</target>
        </trans-unit>
        <trans-unit id="389b98b2eb7e556938b37c1b397214bf77e480bb" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer constant (for &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; instructions).</source>
          <target state="translated">Знака 8-битовое целое число константа (для &lt;code&gt;in&lt;/code&gt; и &lt;code&gt;out&lt;/code&gt; инструкции).</target>
        </trans-unit>
        <trans-unit id="8f0359d8e4b83d3d17663b1351a70fc1f8166d35" translate="yes" xml:space="preserve">
          <source>Unsigned constant that fits in 4 bits</source>
          <target state="translated">Беззнаковая константа,которая помещается в 4 бита.</target>
        </trans-unit>
        <trans-unit id="2b90c224883efa79af0519ac0faa9b9d93afd6a8" translate="yes" xml:space="preserve">
          <source>Unsigned constant valid for BccUI instructions</source>
          <target state="translated">Беззнаковая константа,действительная для инструкций BccUI</target>
        </trans-unit>
        <trans-unit id="6f39b25ebfb39b4238321ae23982857dd100a843" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 15-bit value.</source>
          <target state="translated">Непосредственное 15-битное значение без подписи.</target>
        </trans-unit>
        <trans-unit id="643476a0dd6f53437ba7e1cc7fb664b7f588a51c" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 3-bit value.</source>
          <target state="translated">Непосредственное 3-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="45a42311f5f53acd8a7d22cb085352156026813a" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 4-bit value.</source>
          <target state="translated">Непосредственное 4-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="39b8bb86545b9e829db3c4d0a8f246e834af0861" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value for movpi45 instruction with range 16&amp;ndash;47.</source>
          <target state="translated">Непосредственное 5-битное значение без знака для инструкции movpi45 в диапазоне 16&amp;ndash;47.</target>
        </trans-unit>
        <trans-unit id="899fe6e57441b37398096e6133a6ef0bf027d95b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value.</source>
          <target state="translated">Непосредственное 5-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="deb14acda231f891d200f45725f5e7e68bae6ef4" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 6-bit value constraint for addri36.sp instruction.</source>
          <target state="translated">Непосредственное неподписанное 6-битное ограничение по значению для инструкции addri36.sp.</target>
        </trans-unit>
        <trans-unit id="4d84bf34896cf4e54d3ca29c18d4eaac197e6b98" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 8-bit value.</source>
          <target state="translated">Непосредственное 8-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="0063ff83a123db3db2d8d12d6f824ef8fd590f5b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 9-bit value.</source>
          <target state="translated">Непосредственное 9-битное неподписанное значение.</target>
        </trans-unit>
        <trans-unit id="8bdb4e7b09e73d7ee3c4ef9a2ccb4802ec157dc3" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;Executing code before main&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e06dafd3f0aedfc6583e0a42cd32ba3116cfa2" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;Executing code before main&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Вверх: &lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;Выполнение кода перед основным&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;Содержание&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Индекс&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="1ec7d1b7c940e2acb25ef09724a102d90464172d" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;MIPS SIMD Architecture (MSA) Support&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a632eb28fbdc638221eda735f91ebefbd97cd0d5" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;MIPS SIMD Architecture (MSA) Support&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Вверх: &lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;Поддержка архитектуры MIPS SIMD (MSA)&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;Содержание&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Индекс&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="62c310f2ecc602f87c21d2fd813dc1c5d88ab539" translate="yes" xml:space="preserve">
          <source>Upon entering the &lt;code&gt;@synchronized&lt;/code&gt; block, a thread of execution shall first check whether a lock has been placed on the corresponding &lt;code&gt;guard&lt;/code&gt; object by another thread. If it has, the current thread shall wait until the other thread relinquishes its lock. Once &lt;code&gt;guard&lt;/code&gt; becomes available, the current thread will place its own lock on it, execute the code contained in the &lt;code&gt;@synchronized&lt;/code&gt; block, and finally relinquish the lock (thereby making &lt;code&gt;guard&lt;/code&gt; available to other threads).</source>
          <target state="translated">При входе в блок &lt;code&gt;@synchronized&lt;/code&gt; поток выполнения должен сначала проверить, была ли установлена ​​блокировка на соответствующий объект &lt;code&gt;guard&lt;/code&gt; другим потоком. Если да, текущий поток должен ждать, пока другой поток не освободит свою блокировку. Когда &lt;code&gt;guard&lt;/code&gt; становится доступной, текущий поток устанавливает на нее свою собственную блокировку, выполняет код, содержащийся в блоке &lt;code&gt;@synchronized&lt;/code&gt; , и, наконец, снимает блокировку (тем самым делая &lt;code&gt;guard&lt;/code&gt; доступной для других потоков).</target>
        </trans-unit>
        <trans-unit id="b8aaa5b821490b029c1a6fe5ed310256ca59552f" translate="yes" xml:space="preserve">
          <source>Upper floating point register (32-bit), floating point register (64-bit)</source>
          <target state="translated">Верхний регистр с плавающей точкой (32 бита),регистр с плавающей точкой (64 бита)</target>
        </trans-unit>
        <trans-unit id="06ee1205db8b9a4061f4febc2c51ef1b19f3d539" translate="yes" xml:space="preserve">
          <source>Usage of ISO string concatenation is detected.</source>
          <target state="translated">Обнаружено использование конкатенирования ISO-строк.</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="89c2b631459be5cbc1277d90f51cb2dcbd76dfd6" translate="yes" xml:space="preserve">
          <source>Use (do not use) &amp;lsquo;</source>
          <target state="translated">Использовать (не использовать) '</target>
        </trans-unit>
        <trans-unit id="6c996ac92914ff016f27df663925672950a9f247" translate="yes" xml:space="preserve">
          <source>Use (do not use) GP-relative accesses for symbols that are known to be in a small data section; see</source>
          <target state="translated">Используйте (не используйте)GP-относительные доступы для символов,которые,как известно,находятся в небольшом разделе данных;смотрите</target>
        </trans-unit>
        <trans-unit id="841162f62263bc7378cda3013dbe47b1df4ab93e" translate="yes" xml:space="preserve">
          <source>Use (do not use) MIPS Digital Media Extension instructions. This option can only be used when generating 64-bit code and requires hardware floating-point support to be enabled.</source>
          <target state="translated">Использовать (не использовать)инструкции по расширению MIPS цифровых носителей.Данная опция может быть использована только при генерации 64-битного кода и требует аппаратной поддержки с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="b20024dc2d601c71b4e717f07d0f9b2a6822d063" translate="yes" xml:space="preserve">
          <source>Use (do not use) MT Multithreading instructions.</source>
          <target state="translated">Использовать (не использовать)инструкции по многопоточности MT.</target>
        </trans-unit>
        <trans-unit id="4c4c87eb21af6765217c1c52b2b2d0c31fe5b0c7" translate="yes" xml:space="preserve">
          <source>Use (do not use) assembler relocation operators when dealing with symbolic addresses. The alternative, selected by</source>
          <target state="translated">Используйте (не используйте)операторы перемещения ассемблера при работе с символьными адресами.Альтернатива,выбранная</target>
        </trans-unit>
        <trans-unit id="e2fb9fc1fd117af3b437fc4e8c7a5214e20addd7" translate="yes" xml:space="preserve">
          <source>Use (do not use) paired-single floating-point instructions. See &lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;MIPS Paired-Single Support&lt;/a&gt;. This option requires hardware floating-point support to be enabled.</source>
          <target state="translated">Используйте (не используйте) пары одинарных инструкций с плавающей запятой. См. Раздел &amp;laquo; &lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;Поддержка одиночной пары MIPS&amp;raquo;&lt;/a&gt; . Эта опция требует, чтобы была включена аппаратная поддержка с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="f6259aa651c4c62a1528ed119090031f79dd3a9c" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 1 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macro &lt;code&gt;__mips_dsp&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 1.</source>
          <target state="translated">Используйте (не используйте) версию 1 MIPS DSP ASE. См. &amp;laquo; &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;Встроенные функции MIPS DSP&amp;raquo;&lt;/a&gt; . Эта опция определяет макрос препроцессора &lt;code&gt;__mips_dsp&lt;/code&gt; . Он также определяет &lt;code&gt;__mips_dsp_rev&lt;/code&gt; равным 1.</target>
        </trans-unit>
        <trans-unit id="84f11c6cd6e5cf30011af44cf15833421d85ad29" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 2 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macros &lt;code&gt;__mips_dsp&lt;/code&gt; and &lt;code&gt;__mips_dspr2&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 2.</source>
          <target state="translated">Используйте (не используйте) версию 2 MIPS DSP ASE. См. &amp;laquo; &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;Встроенные функции MIPS DSP&amp;raquo;&lt;/a&gt; . Этот параметр определяет макросы препроцессора &lt;code&gt;__mips_dsp&lt;/code&gt; и &lt;code&gt;__mips_dspr2&lt;/code&gt; . Он также определяет &lt;code&gt;__mips_dsp_rev&lt;/code&gt; равным 2.</target>
        </trans-unit>
        <trans-unit id="f05f23d689cc06c1b3087b4a4cee4ab4e3b531c1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="translated">Используйте (не используйте)инструкции по MIPS-цикловой проверке избыточности (CRC).</target>
        </trans-unit>
        <trans-unit id="41957dbedef9adbd80884a4e90cb75e57229baa1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Enhanced Virtual Addressing instructions.</source>
          <target state="translated">Используйте (не используйте)инструкции по виртуальной адресации MIPS Enhanced Virtual Addressing.</target>
        </trans-unit>
        <trans-unit id="d449a2af21b4cd68389988954d474d0704ce78ae" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Global INValidate (GINV) instructions.</source>
          <target state="translated">Использовать (не использовать)инструкцию MIPS Global INValidate (GINV).</target>
        </trans-unit>
        <trans-unit id="321d2808ff8ddfa8d27e08fae5ef2b18bb82a26d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions (EXT) instructions.</source>
          <target state="translated">Используйте (не используйте)инструкцию MIPS Loongson EXTensions (EXT).</target>
        </trans-unit>
        <trans-unit id="7e1498ad7af62c3d7182f6f503ffa752981eda71" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions r2 (EXT2) instructions.</source>
          <target state="translated">Используйте (не используйте)инструкцию MIPS Loongson EXTensions r2 (EXT2).</target>
        </trans-unit>
        <trans-unit id="2dd360e823e7db9203619f4657c5c205b972d79d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson MultiMedia extensions Instructions (MMI).</source>
          <target state="translated">Используйте (не используйте)Инструкцию по расширению MIPS Loongson MultiMedia (MMI).</target>
        </trans-unit>
        <trans-unit id="5f61baef9b142c63c1358980a670d3440a0eab96" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS MCU ASE instructions.</source>
          <target state="translated">Использовать (не использовать)инструкцию MIPS MCU ASE.</target>
        </trans-unit>
        <trans-unit id="8ec8692f1855f7387d01c2d894055d7cd55aa28a" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS SmartMIPS ASE.</source>
          <target state="translated">Используйте (не используйте)MIPS SmartMIPS ASE.</target>
        </trans-unit>
        <trans-unit id="5ea0be9e9db2179c015e95d8d46f2c8b505a9fe4" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Virtualization (VZ) instructions.</source>
          <target state="translated">Использовать (не использовать)инструкции по MIPS-виртуализации (VZ).</target>
        </trans-unit>
        <trans-unit id="a2cdb6f5e1b2e85269c8ddd06af937bfeb499e18" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS eXtended Physical Address (XPA) instructions.</source>
          <target state="translated">Используйте (не используйте)инструкции MIPS eXtended Physical Address (XPA).</target>
        </trans-unit>
        <trans-unit id="36354659118438f767b17fe9c67973e669f59454" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS-3D ASE. See &lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;MIPS-3D Built-in Functions&lt;/a&gt;. The option</source>
          <target state="translated">Используйте (не используйте) MIPS-3D ASE. См. Раздел &amp;laquo; &lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;Встроенные функции MIPS-3D&amp;raquo;&lt;/a&gt; . Опция</target>
        </trans-unit>
        <trans-unit id="9ef75b208cd56b64585639240694bc21bc152e3d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware decimal-floating-point instructions for decimal-floating-point operations. When</source>
          <target state="translated">Для операций с десятичными запятыми используйте (не используйте)аппаратные инструкции по операциям с десятичными запятыми.При</target>
        </trans-unit>
        <trans-unit id="bf41f711c39d909ef84416fdb9864104894d7725" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions and registers for floating-point operations. When</source>
          <target state="translated">Для операций с плавающей запятой используйте (не используйте)аппаратные инструкции и регистры.При</target>
        </trans-unit>
        <trans-unit id="de7cd0fb38e7a6dbf8bf51e3e0d617effe989eb9" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions for floating-point operations. When</source>
          <target state="translated">Для операций с плавающей запятой используйте (не используйте)инструкции по эксплуатации аппаратных средств с плавающей запятой.При</target>
        </trans-unit>
        <trans-unit id="bd5d0dcb1bead4c9931bcc516462cf8c519e7f83" translate="yes" xml:space="preserve">
          <source>Use (do not use) the packed stack layout. When</source>
          <target state="translated">Используйте (не используйте)компоновку упакованного стека.Когда</target>
        </trans-unit>
        <trans-unit id="cbc7bc66fe33b21f66fff87d1b33e82b9091e241" translate="yes" xml:space="preserve">
          <source>Use (do not use) the probable-branch instructions, when static branch prediction indicates a probable branch.</source>
          <target state="translated">Используйте (не используйте)инструкции по вероятной ветке,когда статическое предсказание ветки указывает на вероятную ветку.</target>
        </trans-unit>
        <trans-unit id="f319b3952ec422e138086d2e7e1d3e6616dd87b3" translate="yes" xml:space="preserve">
          <source>Use 16-bit &lt;code&gt;int&lt;/code&gt;. This is the default.</source>
          <target state="translated">Используйте 16-битное &lt;code&gt;int&lt;/code&gt; . Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="89aa31a04c6ac47e58631515dc9a5eacae0d2be9" translate="yes" xml:space="preserve">
          <source>Use 32-bit &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Используйте 32-битное &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41a727b715072a7a83f64450d014d46413f9d7b5" translate="yes" xml:space="preserve">
          <source>Use 32-bit offsets in &lt;code&gt;switch&lt;/code&gt; tables. The default is to use 16-bit offsets.</source>
          <target state="translated">Используйте 32-битные смещения в таблицах &lt;code&gt;switch&lt;/code&gt; . По умолчанию используется 16-битное смещение.</target>
        </trans-unit>
        <trans-unit id="88f9f3c158d922b7a42c33cd301395b97a6091ab" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;brk_interrupt&lt;/code&gt; instead of &lt;code&gt;interrupt&lt;/code&gt; for handlers intended to be used with the &lt;code&gt;BRK&lt;/code&gt; opcode (i.e. those that must end with &lt;code&gt;RETB&lt;/code&gt; instead of &lt;code&gt;RETI&lt;/code&gt;).</source>
          <target state="translated">Используйте &lt;code&gt;brk_interrupt&lt;/code&gt; вместо &lt;code&gt;interrupt&lt;/code&gt; для обработчиков, предназначенных для использования с &lt;code&gt;BRK&lt;/code&gt; операции BRK (то есть тех, которые должны заканчиваться &lt;code&gt;RETB&lt;/code&gt; вместо &lt;code&gt;RETI&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a90fcb500090afb38bb3e24622641ed3199bfbe3" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;class-name&lt;/var&gt; as the name of the class to instantiate for each literal string specified with the syntax &lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt;. The default class name is &lt;code&gt;NXConstantString&lt;/code&gt; if the GNU runtime is being used, and &lt;code&gt;NSConstantString&lt;/code&gt; if the NeXT runtime is being used (see below). The</source>
          <target state="translated">Используйте &lt;var&gt;class-name&lt;/var&gt; в качестве имени класса, который нужно создать для каждой буквальной строки, указанной с помощью синтаксиса &lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt; . Имя класса по умолчанию - &lt;code&gt;NXConstantString&lt;/code&gt; , если используется среда выполнения GNU, и &lt;code&gt;NSConstantString&lt;/code&gt; , если используется среда выполнения NeXT (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="eb4639975214bd02baed9aee7811250d9713b6c2" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as a subdirectory of the directory containing target-specific C++ headers.</source>
          <target state="translated">Используйте &lt;var&gt;dir&lt;/var&gt; как подкаталог каталога, содержащего заголовки C ++ для конкретных целей.</target>
        </trans-unit>
        <trans-unit id="6e0e3e325ab15f9c4ea6c1c5a12adf0dc5651ccc" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as the logical root directory for headers and libraries. For example, if the compiler normally searches for headers in</source>
          <target state="translated">Используйте &lt;var&gt;dir&lt;/var&gt; как логический корневой каталог для заголовков и библиотек. Например, если компилятор обычно ищет заголовки в</target>
        </trans-unit>
        <trans-unit id="6f28e148765dfa527c350e4d6f8a2d064b3f5447" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;script&lt;/var&gt; as the linker script. This option is supported by most systems using the GNU linker. On some targets, such as bare-board targets without an operating system, the</source>
          <target state="translated">Используйте &lt;var&gt;script&lt;/var&gt; как сценарий компоновщика. Эта опция поддерживается большинством систем, использующих компоновщик GNU. На некоторых задачах, таких как цели без операционной системы,</target>
        </trans-unit>
        <trans-unit id="603c63161e45119aff170517df5f944adaf08316" translate="yes" xml:space="preserve">
          <source>Use Bionic C library. This is the default on &amp;lsquo;</source>
          <target state="translated">Используйте библиотеку Bionic C. Это значение по умолчанию включено '</target>
        </trans-unit>
        <trans-unit id="e1b7e66656ee6fc5c3b9eff78bd1af4ab51c4a01" translate="yes" xml:space="preserve">
          <source>Use DEC assembler syntax.</source>
          <target state="translated">Используйте синтаксис ассемблера DEC.</target>
        </trans-unit>
        <trans-unit id="cf5c1a8e637cc6c211fb5b791033642a96c7344a" translate="yes" xml:space="preserve">
          <source>Use GNU assembler syntax. This is the default.</source>
          <target state="translated">Используйте синтаксис ассемблера GNU.Это настройка по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4ca68a7754f649f50b2ce419251af4261f6f0855" translate="yes" xml:space="preserve">
          <source>Use GP-relative &lt;code&gt;.sdata&lt;/code&gt;/&lt;code&gt;.sbss&lt;/code&gt; sections.</source>
          <target state="translated">Используйте разделы &lt;code&gt;.sdata&lt;/code&gt; / &lt;code&gt;.sbss&lt;/code&gt; ,относящиеся к GP .</target>
        </trans-unit>
        <trans-unit id="5a4f813886fea8ad38a8f2df1482e30df599c3e3" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in loops for decisions to move loop invariants. This option usually results in generation of faster and smaller code on machines with large register files (&amp;gt;= 32 registers), but it can slow the compiler down.</source>
          <target state="translated">Используйте IRA для оценки давления в контурах для принятия решений о перемещении инвариантов контура. Этот параметр обычно приводит к созданию более быстрого и меньшего кода на машинах с большими файлами регистров (&amp;gt; = 32 регистров), но он может замедлить работу компилятора.</target>
        </trans-unit>
        <trans-unit id="9fa83817840cfc83225757a8f388ff5927c560a5" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in the code hoisting pass for decisions to hoist expressions. This option usually results in smaller code, but it can slow the compiler down.</source>
          <target state="translated">Используйте IRA для оценки давления регистра в коде подъемного прохода для принятия решений о подъеме выражений.Этот вариант обычно приводит к уменьшению кода,но может замедлить работу компилятора.</target>
        </trans-unit>
        <trans-unit id="cf05afd7829c886cb42acb12e1e8f5c401d38cca" translate="yes" xml:space="preserve">
          <source>Use PC-relative switch case tables to enable case table shortening. This is the default for</source>
          <target state="translated">Используйте PC-относительные коммутационные таблицы корпусов,чтобы обеспечить сокращение таблиц корпусов.По умолчанию для</target>
        </trans-unit>
        <trans-unit id="00b72e087f73e29c719a0c570f2c43c4886f6d49" translate="yes" xml:space="preserve">
          <source>Use PUSH operations to store outgoing parameters. This method is shorter and usually equally fast as method using SUB/MOV operations and is enabled by default. In some cases disabling it may improve performance because of improved scheduling and reduced dependencies.</source>
          <target state="translated">Используйте операции PUSH для сохранения исходящих параметров.Этот метод короче и обычно не менее быстр,чем метод,использующий операции SUB/MOV,и включен по умолчанию.В некоторых случаях его отключение может повысить производительность за счет улучшения планирования и уменьшения зависимостей.</target>
        </trans-unit>
        <trans-unit id="3d45d39c4ac78022d817a61ee97d331c721c6435" translate="yes" xml:space="preserve">
          <source>Use SSE register passing conventions for float and double arguments and return values. You can control this behavior for a specific function by using the function attribute &lt;code&gt;sseregparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">Используйте соглашения о передаче регистров SSE для аргументов типа float и double и возвращаемых значений. Вы можете управлять этим поведением конкретной функции с помощью атрибута функции &lt;code&gt;sseregparm&lt;/code&gt; . См. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b404c19baa5a518d1cdcd1a18e31cedc71ed3a2b" translate="yes" xml:space="preserve">
          <source>Use TLS descriptors as the thread-local storage mechanism for dynamic accesses of TLS variables. This is the default.</source>
          <target state="translated">Используйте дескрипторы TLS как потоколокальный механизм хранения для динамического доступа к переменным TLS.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="e3576757916332969b16cf2fe6a0dad2cf57cc25" translate="yes" xml:space="preserve">
          <source>Use Unix assembler syntax.</source>
          <target state="translated">Используйте синтаксис ассемблера Unix.</target>
        </trans-unit>
        <trans-unit id="203b2b8006e8188de9ec3c4dca584f80e20ca5d1" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">Используйте другое соглашение о вызове функций, в котором функции, которые принимают фиксированное количество аргументов, возвращаются с помощью инструкции &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; , которая выталкивает свои аргументы при возврате. Это сохраняет одну инструкцию в вызывающей программе, поскольку нет необходимости вставлять туда аргументы.</target>
        </trans-unit>
        <trans-unit id="da4193d8552139570f953ba462e87b5070659dde" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;rtd&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">Используйте другое соглашение о вызове функций, в котором функции, которые принимают фиксированное количество аргументов, возвращаются с &lt;code&gt;rtd&lt;/code&gt; инструкции rtd , которая выдвигает свои аргументы при возврате. Это сохраняет одну инструкцию в вызывающей программе, поскольку нет необходимости вставлять туда аргументы.</target>
        </trans-unit>
        <trans-unit id="331cc29755f1e26195a1d5ecc670eb6f5d017ee2" translate="yes" xml:space="preserve">
          <source>Use a simple check for control speculation. This option is on by default.</source>
          <target state="translated">Используйте простую проверку для контрольной спекуляции.Эта опция включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d6f85727b6057ae83760d6f97594f9ace81b0f7f" translate="yes" xml:space="preserve">
          <source>Use a simple data speculation check. This option is on by default.</source>
          <target state="translated">Используйте простую проверку спекуляции данными.Эта опция включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ca6587349df9a9ae271539d7763d513420cd65bb" translate="yes" xml:space="preserve">
          <source>Use a suffix in a fixed-point literal constant:</source>
          <target state="translated">Используйте суффикс в буквенной константе с фиксированной точкой:</target>
        </trans-unit>
        <trans-unit id="0eca7aa56a0b3e6cf63ecaa0b25877af246ac580" translate="yes" xml:space="preserve">
          <source>Use address register &lt;code&gt;X&lt;/code&gt; in a way proposed by the hardware. This means that &lt;code&gt;X&lt;/code&gt; is only used in indirect, post-increment or pre-decrement addressing.</source>
          <target state="translated">Используйте регистр адреса &lt;code&gt;X&lt;/code&gt; способом, предлагаемым оборудованием. Это означает, что &lt;code&gt;X&lt;/code&gt; используется только для косвенной адресации, адресации с постинкрементом или до декремента.</target>
        </trans-unit>
        <trans-unit id="3b89385a22047536803090fc547fb07c50377d4f" translate="yes" xml:space="preserve">
          <source>Use all 64 floating-point registers.</source>
          <target state="translated">Используйте все 64 регистра с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="feaeb911667dc1becc91e63f2c1dd1a8d7da1545" translate="yes" xml:space="preserve">
          <source>Use all 64 general-purpose registers.</source>
          <target state="translated">Используйте все 64 регистра общего назначения.</target>
        </trans-unit>
        <trans-unit id="b82e484b31c31a6751f032044a77e4b8d923804b" translate="yes" xml:space="preserve">
          <source>Use all eight media accumulator registers.</source>
          <target state="translated">Используйте все восемь регистров аккумуляторов носителей.</target>
        </trans-unit>
        <trans-unit id="2f6df81f72a01bee304049bedcc53aa9e70e7e34" translate="yes" xml:space="preserve">
          <source>Use all functions as a single region. This typically results in the smallest code size, and is enabled by default for</source>
          <target state="translated">Используйте все функции как единый регион.Как правило,это приводит к наименьшим размерам кода,и по умолчанию включена функция для</target>
        </trans-unit>
        <trans-unit id="ba424a2a390669d654a999945050b535cb620662" translate="yes" xml:space="preserve">
          <source>Use all loops as register allocation regions. This can give the best results for machines with a small and/or irregular register set.</source>
          <target state="translated">Используйте все петли как регионы распределения регистров.Это может дать наилучшие результаты для машин с небольшим и/или нерегулярным набором регистров.</target>
        </trans-unit>
        <trans-unit id="a043a5ff8ff9ce3ddafabde6a2ea3b417ae65cc6" translate="yes" xml:space="preserve">
          <source>Use all loops except for loops with small register pressure as the regions. This value usually gives the best results in most cases and for most architectures, and is enabled by default when compiling with optimization for speed (</source>
          <target state="translated">Используйте в качестве регионов все петли,за исключением петель с малым давлением регистра.Это значение обычно дает наилучшие результаты в большинстве случаев и для большинства архитектур,и включено по умолчанию при компиляции с оптимизацией на скорость (</target>
        </trans-unit>
        <trans-unit id="812a6d3805650c2a1098b0f9c55012ae713394e0" translate="yes" xml:space="preserve">
          <source>Use caller save registers for allocation if those registers are not used by any called function. In that case it is not necessary to save and restore them around calls. This is only possible if called functions are part of same compilation unit as current function and they are compiled before it.</source>
          <target state="translated">Используйте сохраненные регистры вызывающего абонента для распределения,если эти регистры не используются ни одной вызываемой функцией.В этом случае нет необходимости сохранять и восстанавливать их вокруг вызовов.Это возможно только в том случае,если вызываемые функции являются частью той же компиляционной единицы,что и текущая функция,и они компилируются перед ней.</target>
        </trans-unit>
        <trans-unit id="4382016563c1274a421ee87c295b12ebd4559c24" translate="yes" xml:space="preserve">
          <source>Use color in diagnostics. &lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">Используйте цвет в диагностике. &lt;var&gt;WHEN&lt;/var&gt; это &quot;</target>
        </trans-unit>
        <trans-unit id="40d7328de5846368928e724db703acd82494276b" translate="yes" xml:space="preserve">
          <source>Use colors for lines of code that have zero coverage. We use red color for non-exceptional lines and cyan for exceptional. Same colors are used for basic blocks with</source>
          <target state="translated">Используйте цвета для строк кода,которые имеют нулевое покрытие.Для неисключительных линий мы используем красный цвет,а для исключительных-голубой.Те же цвета используются для основных блоков с</target>
        </trans-unit>
        <trans-unit id="b78480b3c04e31f02a22c6b9fc0432c39f656a99" translate="yes" xml:space="preserve">
          <source>Use conditional execution (where available) to transform conditional jumps into branch-less equivalents.</source>
          <target state="translated">Использовать условное исполнение (при наличии)для преобразования условных переходов в эквиваленты без ветвей.</target>
        </trans-unit>
        <trans-unit id="85a97254c7906a25c6960b526316473bbe3b12e4" translate="yes" xml:space="preserve">
          <source>Use escape sequences to embed URLs in diagnostics. For example, when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd175a21aedd34017c2ac1e6f5bcb8597ba832d" translate="yes" xml:space="preserve">
          <source>Use features of, and schedule code for, the given CPU. Supported values are in the format &amp;lsquo;</source>
          <target state="translated">Используйте функции и код расписания для данного ЦП. Поддерживаемые значения имеют формат '</target>
        </trans-unit>
        <trans-unit id="3784fc1428664a00120c0092c2a68e1d52938803" translate="yes" xml:space="preserve">
          <source>Use floating-point coprocessor instructions.</source>
          <target state="translated">Используйте инструкции сопроцессора с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="b74dc5c253b5d41873111acddddd0a6e12b4df73" translate="yes" xml:space="preserve">
          <source>Use floating-point double instructions.</source>
          <target state="translated">Используйте двойную инструкцию с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="92af032aeee5f8e42b7b1aaa0f92eee3c63e96e3" translate="yes" xml:space="preserve">
          <source>Use full-set registers for register allocation.</source>
          <target state="translated">Используйте полные регистры для распределения регистров.</target>
        </trans-unit>
        <trans-unit id="16451ea3ea1710752acecdfbc9b28aca9f971795" translate="yes" xml:space="preserve">
          <source>Use hardware FPP floating point. This is the default. (FIS floating point on the PDP-11/40 is not supported.) Implies -m45.</source>
          <target state="translated">Используйте аппаратные FPP с плавающей запятой.Это значение установлено по умолчанию.(FIS с плавающей запятой на PDP-11/40 не поддерживается.)Подразумевает -m45.</target>
        </trans-unit>
        <trans-unit id="1d53b0a05bad4ee0582a36e272217d96ad44c641" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point conversion instructions.</source>
          <target state="translated">Используйте инструкции по аппаратурному пересчету с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="7c8d9f72c2a09e8bf637992aee381f0538cc91ce" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point instructions.</source>
          <target state="translated">Используйте инструкции по аппаратным средствам с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="0a53c63d0196fe12e50c8354a0f08f23a9436376" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point square root instruction.</source>
          <target state="translated">Используйте аппаратную инструкцию квадратного корня с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="9299be4448e9c807bf8ea8d91a628cfcd14cfa8d" translate="yes" xml:space="preserve">
          <source>Use hardware instructions for floating-point operations.</source>
          <target state="translated">Для работы с плавающей запятой используйте инструкции по эксплуатации оборудования.</target>
        </trans-unit>
        <trans-unit id="d1208904e1c443035a1b8ffe0c523b26cf7b7a8b" translate="yes" xml:space="preserve">
          <source>Use indirect addressing to call functions outside the current compilation unit. This allows the functions to be placed anywhere within the 32-bit address space.</source>
          <target state="translated">Для вызова функций вне текущего компилятора используйте косвенную адресацию.Это позволяет разместить функции в любом месте 32-битного адресного пространства.</target>
        </trans-unit>
        <trans-unit id="78fc9788b47e65039b1b1b871970de2bb141152a" translate="yes" xml:space="preserve">
          <source>Use large-model addressing (20-bit pointers, 32-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">Используйте адресацию большой модели (20-битные указатели, 32-битный &lt;code&gt;size_t&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="da84f773a2b422eeb1cc59880ada32d1f5127685" translate="yes" xml:space="preserve">
          <source>Use library routines for floating-point operations.</source>
          <target state="translated">Используйте библиотечные подпрограммы для операций с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="089ac39a7bb68a3ed32ee7b6986eee393acae4e9" translate="yes" xml:space="preserve">
          <source>Use media instructions.</source>
          <target state="translated">Используйте инструкции для СМИ.</target>
        </trans-unit>
        <trans-unit id="0eb15f40fe2c97b8f815cbb7844e284b610d0dac" translate="yes" xml:space="preserve">
          <source>Use multiply and add/subtract instructions.</source>
          <target state="translated">Используйте инструкции по умножению и добавлению/вычитанию.</target>
        </trans-unit>
        <trans-unit id="3113eba3d237f18c9452620ae8a871803037c9fe" translate="yes" xml:space="preserve">
          <source>Use multiply high instructions for high part of 32x32 multiply.</source>
          <target state="translated">Используйте инструкции по умножению для умножения высокой части 32x32.</target>
        </trans-unit>
        <trans-unit id="274542aa04ed64b151c2d6a22c787feacea52bb1" translate="yes" xml:space="preserve">
          <source>Use of ISO C style function definitions. This warning intentionally is &lt;em&gt;not&lt;/em&gt; issued for prototype declarations or variadic functions because these ISO C features appear in your code when using libiberty&amp;rsquo;s traditional C compatibility macros, &lt;code&gt;PARAMS&lt;/code&gt; and &lt;code&gt;VPARAMS&lt;/code&gt;. This warning is also bypassed for nested functions because that feature is already a GCC extension and thus not relevant to traditional C compatibility.</source>
          <target state="translated">Использование определений функций в стиле ISO C. Это предупреждение намеренно &lt;em&gt;не&lt;/em&gt; выдается для объявлений прототипов или вариативных функций, потому что эти возможности ISO C появляются в вашем коде при использовании традиционных макросов совместимости C &lt;code&gt;VPARAMS&lt;/code&gt; , &lt;code&gt;PARAMS&lt;/code&gt; и VPARAMS . Это предупреждение также игнорируется для вложенных функций, поскольку эта функция уже является расширением GCC и, следовательно, не имеет отношения к традиционной совместимости с C.</target>
        </trans-unit>
        <trans-unit id="158fc2002245113de73abd265a7ea7ceaec3a883" translate="yes" xml:space="preserve">
          <source>Use of these options requires the</source>
          <target state="translated">Использование этих опций требует</target>
        </trans-unit>
        <trans-unit id="c4cc269c9473450b3919e9b442477125758842d4" translate="yes" xml:space="preserve">
          <source>Use only (or not only) &lt;code&gt;JSR&lt;/code&gt; instructions to access functions. This option can be used when code size exceeds the range of &lt;code&gt;BSR&lt;/code&gt; instructions. Note that</source>
          <target state="translated">Используйте только (или не только) инструкции &lt;code&gt;JSR&lt;/code&gt; для доступа к функциям. Эта опция может использоваться, когда размер кода превышает диапазон инструкций &lt;code&gt;BSR&lt;/code&gt; . Обратите внимание, что</target>
        </trans-unit>
        <trans-unit id="3d7a23d4b8552ff506438fdaad793f73e9ba8b5c" translate="yes" xml:space="preserve">
          <source>Use only the first 32 floating-point registers.</source>
          <target state="translated">Используйте только первые 32 регистра с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="514349ebdaf390b152f0baa20866afbb16f28603" translate="yes" xml:space="preserve">
          <source>Use only the first four media accumulator registers.</source>
          <target state="translated">Используйте только первые четыре регистра аккумулятора носителей.</target>
        </trans-unit>
        <trans-unit id="dbcdb22850ebf5d2eaa31bb7774cbe3b9ea3b9b1" translate="yes" xml:space="preserve">
          <source>Use options specific to GNU &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">Используйте параметры, специфичные для GNU &lt;code&gt;ld&lt;/code&gt; . Это проходит</target>
        </trans-unit>
        <trans-unit id="d0990e1967b634e363212e972c2e0f4cff8a380b" translate="yes" xml:space="preserve">
          <source>Use options specific to HP &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">Используйте параметры, специфичные для HP &lt;code&gt;ld&lt;/code&gt; . Это проходит</target>
        </trans-unit>
        <trans-unit id="b612fc229c98c8b45507f89276f4127d6c212de2" translate="yes" xml:space="preserve">
          <source>Use or do not use assembler relocation operators when dealing with symbolic addresses. The alternative is to use assembler macros instead, which may limit optimization.</source>
          <target state="translated">Используйте или не используйте операторы перемещения ассемблера при работе с символьными адресами.Альтернативой является использование вместо них ассемблерных макросов,что может ограничить оптимизацию.</target>
        </trans-unit>
        <trans-unit id="0d238a2890f95ffe47564d56929f04ca231d7f2f" translate="yes" xml:space="preserve">
          <source>Use ordinarily cached memory accesses for volatile references. This is the default.</source>
          <target state="translated">Использовать обычный доступ к кэшированной памяти для нестабильных ссылок.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="561289d64c63454cbaa3cc42d60da8f4f3023750" translate="yes" xml:space="preserve">
          <source>Use pattern compare instructions.</source>
          <target state="translated">Используйте инструкции по сопоставлению шаблонов.</target>
        </trans-unit>
        <trans-unit id="040518cc797faf0101d0aa9c313c620444e4ee87" translate="yes" xml:space="preserve">
          <source>Use pipes rather than temporary files for communication between the various stages of compilation. This fails to work on some systems where the assembler is unable to read from a pipe; but the GNU assembler has no trouble.</source>
          <target state="translated">Для связи между различными этапами компиляции используйте трубы,а не временные файлы.Это не работает на некоторых системах,где ассемблер не может читать из трубы;но у ассемблера GNU нет проблем.</target>
        </trans-unit>
        <trans-unit id="f48e58d8b4ccb76ce170698e169b17f602f7b800" translate="yes" xml:space="preserve">
          <source>Use reduced-set registers for register allocation.</source>
          <target state="translated">Используйте регистры с сокращенными настройками для распределения регистров.</target>
        </trans-unit>
        <trans-unit id="2593d8520ea117d76ab84232fac04161f6934239" translate="yes" xml:space="preserve">
          <source>Use reorder instructions (swap and byte reversed load/store).</source>
          <target state="translated">Используйте инструкции по перезаказу (замена и байтовая перезагрузка/хранение).</target>
        </trans-unit>
        <trans-unit id="e07ac16585fa1254cfa0cb9da67063979e26bb7c" translate="yes" xml:space="preserve">
          <source>Use scalar floating-point instructions present in the SSE instruction set. This instruction set is supported by Pentium III and newer chips, and in the AMD line by Athlon-4, Athlon XP and Athlon MP chips. The earlier version of the SSE instruction set supports only single-precision arithmetic, thus the double and extended-precision arithmetic are still done using 387. A later version, present only in Pentium 4 and AMD x86-64 chips, supports double-precision arithmetic too.</source>
          <target state="translated">Используйте скалярные инструкции с плавающей запятой,содержащиеся в наборе инструкций SSE.Данный набор инструкций поддерживается микросхемами Pentium III и более новыми микросхемами,а в линии AMD-микросхемами Athlon-4,Athlon XP и Athlon MP.Более ранняя версия набора инструкций SSE поддерживает только арифметику с одинарной точностью,таким образом,двойная и расширенная арифметика точности все еще выполняется с использованием 387.Более поздняя версия,представленная только в микросхемах Pentium 4 и AMD x86-64,также поддерживает арифметику двойной точности.</target>
        </trans-unit>
        <trans-unit id="d6e4ef6e570b37c45555a81f6cdc377b4bae049b" translate="yes" xml:space="preserve">
          <source>Use small-model addressing (16-bit pointers, 16-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">Используйте адресацию малой модели (16-битные указатели, 16-битный &lt;code&gt;size_t&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="427046297d0e2e2fa23aa9bbce2f51b1069e5680" translate="yes" xml:space="preserve">
          <source>Use software emulation for divides (default).</source>
          <target state="translated">Используйте программную эмуляцию разделителей (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="28d4c98240044920040873705d9156aeeb423961" translate="yes" xml:space="preserve">
          <source>Use software emulation for floating point (default).</source>
          <target state="translated">Используйте программную эмуляцию с плавающей точкой (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="1da6f7e54a7af9cc7e53be95e1caa19cec640f21" translate="yes" xml:space="preserve">
          <source>Use software multiply emulation (default).</source>
          <target state="translated">Использовать программную эмуляцию умножения (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="51ebd4110af8f919b9d1120fda4a348de24109ee" translate="yes" xml:space="preserve">
          <source>Use specified regions for the integrated register allocator. The &lt;var&gt;region&lt;/var&gt; argument should be one of the following:</source>
          <target state="translated">Используйте указанные регионы для интегрированного распределителя регистров. &lt;var&gt;region&lt;/var&gt; аргумент должен быть один из следующих:</target>
        </trans-unit>
        <trans-unit id="8bf48e2b51779d631071d9653fad6d3f53bf023b" translate="yes" xml:space="preserve">
          <source>Use table lookup optimization for small signed integer divisions.</source>
          <target state="translated">Используйте оптимизацию поиска таблиц для малых знаковых целочисленных делений.</target>
        </trans-unit>
        <trans-unit id="22aeb5074275903d6cc2bc285a95ec6de6392b7d" translate="yes" xml:space="preserve">
          <source>Use the &amp;lsquo;</source>
          <target state="translated">Использовать '</target>
        </trans-unit>
        <trans-unit id="4c08ac9947cb5cb5ba71955417b6bbe576595e7e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bfd&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">Используйте компоновщик &lt;code&gt;bfd&lt;/code&gt; вместо компоновщика по умолчанию.</target>
        </trans-unit>
        <trans-unit id="49f654b96f5c6203d75686fb510717eb4b09cb8c" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;dcpl&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache.</source>
          <target state="translated">Используйте команду &lt;code&gt;dcpl&lt;/code&gt; , чтобы загрузить содержимое адреса &lt;var&gt;x&lt;/var&gt; в кэш данных.</target>
        </trans-unit>
        <trans-unit id="bf6f4ab92454be3b8a7530a2bda919c27587ed37" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;gold&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">Используйте &lt;code&gt;gold&lt;/code&gt; компоновщик вместо компоновщика по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6ce5962b43b6bd52ef348d693006572a8183c27a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;nldub&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache. The instruction is issued in slot I1.</source>
          <target state="translated">Используйте инструкцию &lt;code&gt;nldub&lt;/code&gt; , чтобы загрузить содержимое адреса &lt;var&gt;x&lt;/var&gt; в кэш данных. Инструкция выдается в слоте I1.</target>
        </trans-unit>
        <trans-unit id="867d5a75d613034d3b5e7a22efb5a5d5d0038d5f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;section&lt;/code&gt; attribute with &lt;em&gt;global&lt;/em&gt; variables and not &lt;em&gt;local&lt;/em&gt; variables, as shown in the example.</source>
          <target state="translated">Используйте атрибут &lt;code&gt;section&lt;/code&gt; с &lt;em&gt;глобальными&lt;/em&gt; переменными, а не с &lt;em&gt;локальными&lt;/em&gt; переменными, как показано в примере.</target>
        </trans-unit>
        <trans-unit id="9a7c0df6001ba89f4adccf5164b3cb2c7ebaeebd" translate="yes" xml:space="preserve">
          <source>Use the GNU C library. This is the default except on &amp;lsquo;</source>
          <target state="translated">Используйте библиотеку GNU C. Это значение по умолчанию, за исключением '</target>
        </trans-unit>
        <trans-unit id="750d7f5d1705c279b333b6c74a4ba7e65ef492b9" translate="yes" xml:space="preserve">
          <source>Use the Graphite data dependence analysis to identify loops that can be parallelized. Parallelize all the loops that can be analyzed to not contain loop carried dependences without checking that it is profitable to parallelize the loops.</source>
          <target state="translated">Используйте анализ зависимости данных от графита для выявления циклов,которые можно распараллелить.Распараллелить все циклы,которые могут быть проанализированы,чтобы не содержать переносимых циклов зависимостей,не проверяя,выгодно ли распараллеливать циклы.</target>
        </trans-unit>
        <trans-unit id="7a211de8053eb75fc4551a2253a98b04c844e3fd" translate="yes" xml:space="preserve">
          <source>Use the LLVM &lt;code&gt;lld&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">Используйте компоновщик LLVM &lt;code&gt;lld&lt;/code&gt; вместо компоновщика по умолчанию.</target>
        </trans-unit>
        <trans-unit id="04b872414955ba2ec914569c9ca7e852388533f1" translate="yes" xml:space="preserve">
          <source>Use the divide instruction. (Enabled by default).</source>
          <target state="translated">Используйте инструкцию разделения.(Включено по умолчанию).</target>
        </trans-unit>
        <trans-unit id="558e68bc0e42df73038edd83e1eeba8d09d26633" translate="yes" xml:space="preserve">
          <source>Use the hardware barrel shifter.</source>
          <target state="translated">Используйте аппаратный переключатель ствола.</target>
        </trans-unit>
        <trans-unit id="3ddc7c28193ef0a55228689dee7a52062a4edc76" translate="yes" xml:space="preserve">
          <source>Use the musl C library. This is the default on &amp;lsquo;</source>
          <target state="translated">Используйте библиотеку musl C. Это значение по умолчанию включено '</target>
        </trans-unit>
        <trans-unit id="1f0e93cc02e9fe65de10db69a6186e0dc79df964" translate="yes" xml:space="preserve">
          <source>Use the new LRA register allocator. By default, the old &amp;ldquo;reload&amp;rdquo; allocator is used.</source>
          <target state="translated">Используйте новый распределитель регистров LRA. По умолчанию используется старый распределитель &amp;laquo;перезагрузки&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b8160c2417cc8a5cdcd5adcb2b4ace153689638e" translate="yes" xml:space="preserve">
          <source>Use the pc-relative addressing mode of the 68000 directly, instead of using a global offset table. At present, this option implies</source>
          <target state="translated">Используйте режим pc-реляционной адресации 68000 напрямую,вместо использования глобальной таблицы смещения.В настоящее время этот вариант подразумевает</target>
        </trans-unit>
        <trans-unit id="f07a2b31cfd22ad424266d7caad833e89dee9597" translate="yes" xml:space="preserve">
          <source>Use the portable calling conventions proposed by HP for ELF systems.</source>
          <target state="translated">Используйте портативные соглашения по вызову,предложенные HP для систем ELF.</target>
        </trans-unit>
        <trans-unit id="0b4db49c13b2cd9f44e64e88aadae4892b55bc28" translate="yes" xml:space="preserve">
          <source>Use the simulator runtime. The default is to use the libgloss board-specific runtime.</source>
          <target state="translated">Используйте время работы симулятора.По умолчанию используется специфическое для libgloss время выполнения.</target>
        </trans-unit>
        <trans-unit id="41338fd388f1668b19ad991f249f38977077076b" translate="yes" xml:space="preserve">
          <source>Use the small address space model. This can produce smaller code, but it does assume that all symbolic values and addresses fit into a 20-bit range.</source>
          <target state="translated">Используйте модель небольшого адресного пространства.Это может привести к меньшему коду,но предполагает,что все символьные значения и адреса помещаются в 20-битный диапазон.</target>
        </trans-unit>
        <trans-unit id="13568366d19d7f746b8b97efedd41fb9de7088bc" translate="yes" xml:space="preserve">
          <source>Use the specified algorithm for basic block reordering. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">Используйте указанный алгоритм для переупорядочения базового блока. &lt;var&gt;algorithm&lt;/var&gt; аргумент может быть &quot;</target>
        </trans-unit>
        <trans-unit id="ab53cd8c99a5cd67bf095646da8562b04af28820" translate="yes" xml:space="preserve">
          <source>Use the specified coloring algorithm for the integrated register allocator. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">Используйте указанный алгоритм окраски для встроенного распределителя регистров. &lt;var&gt;algorithm&lt;/var&gt; аргумент может быть &quot;</target>
        </trans-unit>
        <trans-unit id="c25bc5036e9135cfbfa139415172d379794c44f1" translate="yes" xml:space="preserve">
          <source>Use the standard 387 floating-point coprocessor present on the majority of chips and emulated otherwise. Code compiled with this option runs almost everywhere. The temporary results are computed in 80-bit precision instead of the precision specified by the type, resulting in slightly different results compared to most of other chips. See</source>
          <target state="translated">Используйте стандартный сопроцессор с плавающей запятой 387,присутствующий на большинстве микросхем,и эмулируйте его по-другому.Код,скомпилированный с этой опцией,запускается практически везде.Временные результаты вычисляются с точностью до 80 бит вместо точности,заданной типом,в результате чего результаты немного отличаются от результатов большинства других микросхем.См..</target>
        </trans-unit>
        <trans-unit id="5c3eebf40b38ef456cf7b33dffd08d0bed4ad5c6" translate="yes" xml:space="preserve">
          <source>Use the string argument if you want a single implementation file to include code from multiple header files. (You must also use &amp;lsquo;</source>
          <target state="translated">Используйте строковый аргумент, если вы хотите, чтобы один файл реализации включал код из нескольких файлов заголовков. (Вы также должны использовать '</target>
        </trans-unit>
        <trans-unit id="8b250eb8bd58bde677af68374494bb2406d4bfb9" translate="yes" xml:space="preserve">
          <source>Use the timing characteristics of the indicated CPU type when scheduling instructions. This does not change the targeted processor type. The CPU type must be one of &amp;lsquo;</source>
          <target state="translated">При планировании инструкций используйте временные характеристики указанного типа ЦП. Это не меняет целевой тип процессора. Тип процессора должен быть одним из '</target>
        </trans-unit>
        <trans-unit id="e509cf065cb591da77c6d1b119a1c9955ae2884c" translate="yes" xml:space="preserve">
          <source>Use these attributes on the Blackfin to place the variable into L1 Data SRAM. Variables with &lt;code&gt;l1_data&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data&lt;/code&gt;. Those with &lt;code&gt;l1_data_A&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.A&lt;/code&gt;. Those with &lt;code&gt;l1_data_B&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.B&lt;/code&gt;.</source>
          <target state="translated">Используйте эти атрибуты на Blackfin, чтобы поместить переменную в L1 Data SRAM. Переменные с атрибутом &lt;code&gt;l1_data&lt;/code&gt; помещаются в специальный раздел с именем &lt;code&gt;.l1.data&lt;/code&gt; . Те, у &lt;code&gt;l1_data_A&lt;/code&gt; атрибут l1_data_A , помещаются в специальный раздел с именем &lt;code&gt;.l1.data.A&lt;/code&gt; . Те, у &lt;code&gt;l1_data_B&lt;/code&gt; атрибут l1_data_B , помещаются в специальный раздел с именем &lt;code&gt;.l1.data.B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="160cca57d4e5e0f9858135c86f73f6c1abb97d0c" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either attribute is present.</source>
          <target state="translated">Используйте эти атрибуты,чтобы показать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии любого из атрибутов.</target>
        </trans-unit>
        <trans-unit id="bf93b175e1b39a6bc44235ab705a17a9dd4f6b45" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either of these attributes are present.</source>
          <target state="translated">Используйте эти атрибуты,чтобы показать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания,когда присутствует один из этих атрибутов.</target>
        </trans-unit>
        <trans-unit id="713ae23784c01f8e2dec060c72284704315954a7" translate="yes" xml:space="preserve">
          <source>Use these options on systems where the linker can perform optimizations to improve locality of reference in the instruction space. Most systems using the ELF object format have linkers with such optimizations. On AIX, the linker rearranges sections (CSECTs) based on the call graph. The performance impact varies.</source>
          <target state="translated">Используйте эти опции на системах,где компоновщик может выполнять оптимизацию для улучшения расположения ссылок в пространстве инструкций.В большинстве систем,использующих формат ELF-объектов,есть компоновщики с такими оптимизациями.В AIX компоновщик переставляет секции (CSECTs)на основе графика вызовов.Влияние производительности варьируется.</target>
        </trans-unit>
        <trans-unit id="78e3ee99ed9959a22e988df0584ccd7d00c7b9a6" translate="yes" xml:space="preserve">
          <source>Use this attribute on ARM to write Interrupt Service Routines. This is an alias to the &lt;code&gt;interrupt&lt;/code&gt; attribute above.</source>
          <target state="translated">Используйте этот атрибут в ARM для записи подпрограмм обслуживания прерываний. Это псевдоним атрибута &lt;code&gt;interrupt&lt;/code&gt; указанного выше.</target>
        </trans-unit>
        <trans-unit id="6c570cb3577b10adeb554e34c1e75804adbd4ff0" translate="yes" xml:space="preserve">
          <source>Use this attribute on SH targets to indicate that an &lt;code&gt;interrupt_handler&lt;/code&gt; function should not save and restore registers R0..R7. This can be used on SH3* and SH4* targets that have a second R0..R7 register bank for non-reentrant interrupt handlers.</source>
          <target state="translated">Используйте этот атрибут для целей SH, чтобы указать, что функция &lt;code&gt;interrupt_handler&lt;/code&gt; не должна сохранять и восстанавливать регистры R0..R7. Это можно использовать для целей SH3 * и SH4 *, которые имеют второй банк регистров R0..R7 для обработчиков прерываний без повторного входа.</target>
        </trans-unit>
        <trans-unit id="f5c77347991d0824e6e1b28414143e53ed7d053c" translate="yes" xml:space="preserve">
          <source>Use this attribute on fido, a subarchitecture of the m68k, to indicate that the specified function is an interrupt handler that is designed to run as a thread. The compiler omits generate prologue/epilogue sequences and replaces the return instruction with a &lt;code&gt;sleep&lt;/code&gt; instruction. This attribute is available only on fido.</source>
          <target state="translated">Используйте этот атрибут в fido, субархитектуре m68k, чтобы указать, что указанная функция является обработчиком прерывания, предназначенным для работы в виде потока. Компилятор пропускает создание последовательностей пролога / эпилога и заменяет инструкцию возврата инструкцией &lt;code&gt;sleep&lt;/code&gt; . Этот атрибут доступен только на fido.</target>
        </trans-unit>
        <trans-unit id="d1f324113425943e40b53dec4caee6bc8c992d2f" translate="yes" xml:space="preserve">
          <source>Use this attribute on the AVR to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут на AVR,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии данного атрибута.</target>
        </trans-unit>
        <trans-unit id="a5bf0a65e4d4990ce1711a80366a15b5a93d0b22" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an NMI handler. The compiler generates function entry and exit sequences suitable for use in an NMI handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут на Blackfin,чтобы указать,что указанная функция является обработчиком NMI.Компилятор генерирует входные и выходные последовательности функций,подходящие для использования в обработчике NMI,когда данный атрибут присутствует.</target>
        </trans-unit>
        <trans-unit id="dfb0dab0829881fae4719db2bc2a5d4b0371e0d9" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an exception handler. The compiler generates function entry and exit sequences suitable for use in an exception handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут на Blackfin,чтобы указать,что указанная функция является обработчиком исключения.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике исключения,когда данный атрибут присутствует.</target>
        </trans-unit>
        <trans-unit id="8869ad65102c3d5175ee58c9a5d4d12dd9377ae3" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to place the variable into L2 SRAM. Variables with &lt;code&gt;l2&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l2.data&lt;/code&gt;.</source>
          <target state="translated">Используйте этот атрибут на Blackfin, чтобы поместить переменную в L2 SRAM. Переменные с атрибутом &lt;code&gt;l2&lt;/code&gt; помещаются в специальный раздел с именем &lt;code&gt;.l2.data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77ba6ef03647597caec122d43f2ce8b19030a7ba" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">Используйте этот атрибут на H8/300,H8/300H,и H8S,чтобы указать,что все регистры,кроме указателя стека,должны быть сохранены в прологе независимо от того,используются они или нет.</target>
        </trans-unit>
        <trans-unit id="df02a088eeed2ddabe9512b735b51f56751782bf" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут на H8/300,H8/300H и H8S,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания,когда данный атрибут присутствует.</target>
        </trans-unit>
        <trans-unit id="fd7a5bf8f68787afcff36ce2f74606dfa6e83fb2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function should be called through the function vector. Calling a function through the function vector reduces code size; however, the function vector has a limited size (maximum 128 entries on the H8/300 and 64 entries on the H8/300H and H8S) and shares space with the interrupt vector.</source>
          <target state="translated">Используйте этот атрибут на H8/300,H8/300H и H8S,чтобы указать,что указанная функция должна быть вызвана через вектор функции.Вызов функции через вектор функции уменьшает размер кода,однако вектор функции имеет ограниченный размер (максимум 128 записей на H8/300 и 64 записи на H8/300H и H8S)и разделяет пространство с вектором прерывания.</target>
        </trans-unit>
        <trans-unit id="599c44ccc726a6980df5cc0406dd5d4d98bf81c0" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified variable should be placed into the eight-bit data section. The compiler generates more efficient code for certain operations on data in the eight-bit data area. Note the eight-bit data area is limited to 256 bytes of data.</source>
          <target state="translated">Используйте этот атрибут на H8/300,H8/300H и H8S,чтобы указать,что указанная переменная должна быть помещена в восьмибитную секцию данных.Компилятор генерирует более эффективный код для определенных операций с данными в восьмиразрядной области данных.Обратите внимание,что восьмибитная область данных ограничена 256 байтами данных.</target>
        </trans-unit>
        <trans-unit id="a601987d8058a933f8472ba9226cb9a2f96a02f6" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300H and H8S to indicate that the specified variable should be placed into the tiny data section. The compiler generates more efficient code for loads and stores on data in the tiny data section. Note the tiny data area is limited to slightly under 32KB of data.</source>
          <target state="translated">Используйте этот атрибут на H8/300H и H8S для того чтобы указать что указанная переменная должна быть помещена в крошечную секцию данных.Компилятор генерирует более эффективный код для загрузки и хранения данных в крошечной секции данных.Обратите внимание,что крошечная область данных ограничена чуть менее 32KB данных.</target>
        </trans-unit>
        <trans-unit id="85d60dec57fe15c501fdf7e341a3a258fde629e1" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32C port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">Используйте этот атрибут на порту M32C, чтобы указать, что указанная функция является быстрым обработчиком прерывания. Это так же , как &lt;code&gt;interrupt&lt;/code&gt; атрибута, за исключением того, что &lt;code&gt;freit&lt;/code&gt; используется для возврата вместо &lt;code&gt;reit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="297c80fc49a65c78b7920bfb2bee0762b9925dea" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32R/D to set the addressability of an object. The identifier &lt;var&gt;model-name&lt;/var&gt; is one of &lt;code&gt;small&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;large&lt;/code&gt;, representing each of the code models.</source>
          <target state="translated">Используйте этот атрибут на M32R / D для установки адресуемости объекта. Идентификатор &lt;var&gt;model-name&lt;/var&gt; может быть &lt;code&gt;small&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; или &lt;code&gt;large&lt;/code&gt; , представляя каждую из моделей кода.</target>
        </trans-unit>
        <trans-unit id="96da4205ef51f9f643ebc02b337015bd75a20bc4" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is a reset handler. The compiler will generate corresponding sections for use in a reset handler. You can use the following attributes to provide extra exception handling:</source>
          <target state="translated">Используйте этот атрибут на цели NDS32,чтобы указать,что указанная функция является обработчиком сброса.Компилятор сгенерирует соответствующие секции для использования в обработчике сброса.Для дополнительной обработки исключений можно использовать следующие атрибуты:</target>
        </trans-unit>
        <trans-unit id="baa8e68af06ff2588951a9683b9bf9ad21db1c70" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is an exception handler. The compiler will generate corresponding sections for use in an exception handler.</source>
          <target state="translated">Используйте этот атрибут на цели NDS32,чтобы указать,что указанная функция является обработчиком исключений.Компилятор сгенерирует соответствующие секции для использования в обработчике исключения.</target>
        </trans-unit>
        <trans-unit id="420b4fa6a036410c655f106a939e0146c5f824c7" translate="yes" xml:space="preserve">
          <source>Use this attribute on the RX port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">Используйте этот атрибут на порту RX, чтобы указать, что указанная функция является быстрым обработчиком прерывания. Это так же , как &lt;code&gt;interrupt&lt;/code&gt; атрибута, за исключением того, что &lt;code&gt;freit&lt;/code&gt; используется для возврата вместо &lt;code&gt;reit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8551dfbdf943cb7774be60c5de8ba39aba7167f2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH for an &lt;code&gt;interrupt_handler&lt;/code&gt; to return using &lt;code&gt;trapa&lt;/code&gt; instead of &lt;code&gt;rte&lt;/code&gt;. This attribute expects an integer argument specifying the trap number to be used.</source>
          <target state="translated">Используйте этот атрибут в SH, чтобы &lt;code&gt;trapa&lt;/code&gt; &lt;code&gt;interrupt_handler&lt;/code&gt; возвращался с использованием trapa вместо &lt;code&gt;rte&lt;/code&gt; . Этот атрибут ожидает целочисленный аргумент, указывающий номер прерывания, который будет использоваться.</target>
        </trans-unit>
        <trans-unit id="96f131ead8b3e83868bdd55e3669cea512c61c77" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH to indicate an &lt;code&gt;interrupt_handler&lt;/code&gt; function should switch to an alternate stack. It expects a string argument that names a global variable holding the address of the alternate stack.</source>
          <target state="translated">Используйте этот атрибут в SH, чтобы указать, что функция &lt;code&gt;interrupt_handler&lt;/code&gt; должна переключиться на альтернативный стек. Он ожидает строковый аргумент, который называет глобальную переменную, содержащую адрес альтернативного стека.</target>
        </trans-unit>
        <trans-unit id="7835a2a9ca1e1170ad95a6f19a530b6da32924fa" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the first 32 kilobytes of memory.</source>
          <target state="translated">Используйте этот атрибут для явного помещения переменной в первые 32 килобайта памяти.</target>
        </trans-unit>
        <trans-unit id="6f81bc7b08ff6f3b4d15b67ecb7306d1b4cac77a" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the small data area, which can hold up to 64 kilobytes.</source>
          <target state="translated">Используйте этот атрибут для явного размещения переменной в небольшой области данных,которая может вмещать до 64 килобайт.</target>
        </trans-unit>
        <trans-unit id="25a478a508b894220fe0716716b37246794c924f" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the tiny data area, which can hold up to 256 bytes in total.</source>
          <target state="translated">Используйте этот атрибут,чтобы явно поместить переменную в крошечную область данных,которая может вместить до 256 байт в целом.</target>
        </trans-unit>
        <trans-unit id="236f15e780f5078ecf100afe1366fac4aadd1410" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что все регистры,кроме указателя стека,должны быть сохранены в прологе независимо от того,используются они или нет.</target>
        </trans-unit>
        <trans-unit id="764c3380316fc59c0e08f071dd7a44fb3d9e29ae" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the function is an interrupt handler. All volatile registers (in addition to non-volatile registers) are saved in the function prologue. If the function is a leaf function, only volatiles used by the function are saved. A normal function return is generated instead of a return from interrupt.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что функция является обработчиком прерываний.Все энергонезависимые регистры (в дополнение к энергонезависимым)сохраняются в прологе функции.Если функция является функцией листа,то сохраняются только летучие регистры,используемые функцией.Вместо возврата по прерыванию генерируется обычный возврат функции.</target>
        </trans-unit>
        <trans-unit id="e7371ecf2ac4e4a5beb340500a4170b79e5aeb2e" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function has no caller-saved registers. That is, all registers are callee-saved. For example, this attribute can be used for a function called from an interrupt handler. The compiler generates proper function entry and exit sequences to save and restore any modified registers, except for the EFLAGS register. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">Используйте этот атрибут, чтобы указать, что указанная функция не имеет регистров, сохраненных вызывающей стороной. То есть все регистры сохраняются вызываемым пользователем. Например, этот атрибут можно использовать для функции, вызываемой из обработчика прерывания. Компилятор генерирует правильные последовательности входа и выхода функции для сохранения и восстановления любых измененных регистров, кроме регистра EFLAGS. Поскольку GCC не сохраняет состояния SSE, MMX или x87, параметр GCC</target>
        </trans-unit>
        <trans-unit id="7d075359795fbb683e03390ae2ab96a3eb2f08a2" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is a break handler. The compiler generates function entry and exit sequences suitable for use in an break handler when this attribute is present. The return from &lt;code&gt;break_handler&lt;/code&gt; is done through the &lt;code&gt;rtbd&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">Используйте этот атрибут, чтобы указать, что указанная функция является обработчиком прерывания. Компилятор генерирует последовательности входа и выхода функции, подходящие для использования в обработчике прерывания, когда этот атрибут присутствует. Возврат от &lt;code&gt;break_handler&lt;/code&gt; осуществляется через &lt;code&gt;rtbd&lt;/code&gt; вместо &lt;code&gt;rtsd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2edc9f687349668f0ff9d21a9fd536ad89ad9e2f" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler or an exception handler (depending on parameters passed to the function, explained further). The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. The &lt;code&gt;IRET&lt;/code&gt; instruction, instead of the &lt;code&gt;RET&lt;/code&gt; instruction, is used to return from interrupt handlers. All registers, except for the EFLAGS register which is restored by the &lt;code&gt;IRET&lt;/code&gt; instruction, are preserved by the compiler. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">Используйте этот атрибут, чтобы указать, что указанная функция является обработчиком прерывания или обработчиком исключений (в зависимости от параметров, переданных в функцию, как описано ниже). Компилятор генерирует последовательности входа и выхода функции, подходящие для использования в обработчике прерывания, когда этот атрибут присутствует. &lt;code&gt;IRET&lt;/code&gt; инструкцию, вместо &lt;code&gt;RET&lt;/code&gt; инструкции, используются для возврата из обработчиков прерываний. Все регистры, кроме регистра EFLAGS, который восстанавливается инструкцией &lt;code&gt;IRET&lt;/code&gt; , сохраняются компилятором. Поскольку GCC не сохраняет состояния SSE, MMX или x87, параметр GCC</target>
        </trans-unit>
        <trans-unit id="0c30254e85a0958ba0ac7ce6feb29ae31661d530" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии данного атрибута.</target>
        </trans-unit>
        <trans-unit id="d47a65245a7242658fd94eba35172dfdbe8eccc4" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. An optional argument is supported for the interrupt attribute which allows the interrupt mode to be described. By default GCC assumes the external interrupt controller (EIC) mode is in use, this can be explicitly set using &lt;code&gt;eic&lt;/code&gt;. When interrupts are non-masked then the requested Interrupt Priority Level (IPL) is copied to the current IPL which has the effect of only enabling higher priority interrupts. To use vectored interrupt mode use the argument &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt;, this will change the behavior of the non-masked interrupt support and GCC will arrange to mask all interrupts from sw0 up to and including the specified interrupt vector.</source>
          <target state="translated">Используйте этот атрибут, чтобы указать, что указанная функция является обработчиком прерывания. Компилятор генерирует последовательности входа и выхода функции, подходящие для использования в обработчике прерывания, когда этот атрибут присутствует. Для атрибута прерывания поддерживается необязательный аргумент, который позволяет описать режим прерывания. По умолчанию GCC предполагает, что используется режим внешнего контроллера прерываний (EIC), это можно явно установить с помощью &lt;code&gt;eic&lt;/code&gt; . Если прерывания немаскированы, запрошенный уровень приоритета прерывания (IPL) копируется в текущую IPL, в результате чего разрешаются только прерывания с более высоким приоритетом. Чтобы использовать режим векторного прерывания, используйте &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt; аргументов = [sw0 | sw1 | hw0 | hw1 | hw2 | hw3 | hw4 | hw5], это изменит поведение поддержки немаскированных прерываний, и GCC будет маскировать все прерывания от sw0 до указанного вектора прерывания включительно.</target>
        </trans-unit>
        <trans-unit id="0ace02ca61dedf94a751682f5d4174fdf42f160d" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. Either name may be used.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии данного атрибута.Может быть использовано любое из имен.</target>
        </trans-unit>
        <trans-unit id="bb60152fa1da7627a1b21880311cc9395167dfd1" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. It may also generate a special section with code to initialize the interrupt vector table.</source>
          <target state="translated">Используйте этот атрибут,чтобы указать,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии данного атрибута.Он также может генерировать специальную секцию с кодом для инициализации таблицы векторов прерываний.</target>
        </trans-unit>
        <trans-unit id="ea92b79a9f3c03589b9a2bec6c52bb535643eb63" translate="yes" xml:space="preserve">
          <source>Use this attribute to place a variable in the &lt;code&gt;.shared&lt;/code&gt; memory space. This memory space is private to each cooperative thread array; only threads within one thread block refer to the same instance of the variable. The runtime does not initialize variables in this memory space.</source>
          <target state="translated">Используйте этот атрибут, чтобы поместить переменную в область &lt;code&gt;.shared&lt;/code&gt; памяти. Это пространство памяти принадлежит каждому массиву взаимодействующих потоков; только потоки в одном блоке потока ссылаются на один и тот же экземпляр переменной. Среда выполнения не инициализирует переменные в этом пространстве памяти.</target>
        </trans-unit>
        <trans-unit id="b1ecdb3757207ea0940932cf33695720d7e7f73c" translate="yes" xml:space="preserve">
          <source>Use this attribute together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt; to indicate that the function entry code should enable nested interrupts or exceptions.</source>
          <target state="translated">Используйте этот атрибут вместе с &lt;code&gt;interrupt_handler&lt;/code&gt; , &lt;code&gt;exception_handler&lt;/code&gt; или &lt;code&gt;nmi_handler&lt;/code&gt; , чтобы указать, что код входа функции должен разрешать вложенные прерывания или исключения.</target>
        </trans-unit>
        <trans-unit id="01448e4d9272cc29bf3907d177e8611ce1e38ee0" translate="yes" xml:space="preserve">
          <source>Use this directive in &lt;em&gt;header files&lt;/em&gt; that define object classes, to save space in most of the object files that use those classes. Normally, local copies of certain information (backup copies of inline member functions, debugging information, and the internal tables that implement virtual functions) must be kept in each object file that includes class definitions. You can use this pragma to avoid such duplication. When a header file containing &amp;lsquo;</source>
          <target state="translated">Используйте эту директиву в &lt;em&gt;файлах заголовков,&lt;/em&gt; которые определяют классы объектов, чтобы сэкономить место в большинстве объектных файлов, которые используют эти классы. Обычно локальные копии определенной информации (резервные копии встроенных функций-членов, отладочная информация и внутренние таблицы, реализующие виртуальные функции) должны храниться в каждом объектном файле, который включает определения классов. Вы можете использовать эту прагму, чтобы избежать такого дублирования. Когда файл заголовка, содержащий '</target>
        </trans-unit>
        <trans-unit id="d280eeca70b31bee4ab8a083eaebf1bfa7fbe798" translate="yes" xml:space="preserve">
          <source>Use this option for microcontroller with a 5200 core, including the MCF5202, MCF5203, MCF5204 and MCF5206.</source>
          <target state="translated">Используйте эту опцию для микроконтроллера с ядром 5200,включая MCF5202,MCF5203,MCF5204 и MCF5206.</target>
        </trans-unit>
        <trans-unit id="a112527843e5614605b4e3f46e7e6138969c47d8" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a 68000 or EC000 core, including the 68008, 68302, 68306, 68307, 68322, 68328 and 68356.</source>
          <target state="translated">Используйте эту опцию для микроконтроллеров с ядром 68000 или EC000,включая 68008,68302,68306,68307,68322,68328 и 68356.</target>
        </trans-unit>
        <trans-unit id="63187c5307bd577a4586510b3b1f06b54dea5f9f" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a CPU32 or CPU32+ core, including the 68330, 68331, 68332, 68333, 68334, 68336, 68340, 68341, 68349 and 68360.</source>
          <target state="translated">Используйте эту опцию для микроконтроллеров с ядром CPU32 или CPU32+,включая 68330,68331,68332,68333,68334,68336,68340,68341,68349 и 68360.</target>
        </trans-unit>
        <trans-unit id="41f23198542e0d6a3a5d2900310d1b7abe9d3260" translate="yes" xml:space="preserve">
          <source>Use this option to require GCC to construct &lt;em&gt;all&lt;/em&gt; integer constants using code, even if it takes more instructions (the maximum is six).</source>
          <target state="translated">Используйте этот параметр, чтобы GCC создавал &lt;em&gt;все&lt;/em&gt; целочисленные константы с использованием кода, даже если для этого требуется больше инструкций (максимум шесть).</target>
        </trans-unit>
        <trans-unit id="6aa829df1806f0740110776091d0764dbe5ca6cc" translate="yes" xml:space="preserve">
          <source>Use this pragma in a &lt;em&gt;main input file&lt;/em&gt;, when you want full output from included header files to be generated (and made globally visible). The included header file, in turn, should use &amp;lsquo;</source>
          <target state="translated">Используйте эту прагму в &lt;em&gt;основном входном файле&lt;/em&gt; , если вы хотите, чтобы был сгенерирован полный вывод из включенных файлов заголовков (и был сделан глобально видимым). Включенный файл заголовка, в свою очередь, должен использовать '</target>
        </trans-unit>
        <trans-unit id="cf5e8f8ca29a0892846d7e7fbb28cf80ccb1a6dd" translate="yes" xml:space="preserve">
          <source>Use traditional TLS as the thread-local storage mechanism for dynamic accesses of TLS variables.</source>
          <target state="translated">Используйте традиционный TLS в качестве потоколокального механизма хранения для динамического доступа к переменным TLS.</target>
        </trans-unit>
        <trans-unit id="d8a60407e03b2ced230c36ef1b80cb979fd89c1c" translate="yes" xml:space="preserve">
          <source>Use uClibc C library. This is the default on &amp;lsquo;</source>
          <target state="translated">Используйте библиотеку uClibc C. Это значение по умолчанию включено '</target>
        </trans-unit>
        <trans-unit id="5a7b4e094ebc57080c3754943807a6fa36611b6e" translate="yes" xml:space="preserve">
          <source>Use uids starting at this parameter for nondebug insns. The range below the parameter is reserved exclusively for debug insns created by</source>
          <target state="translated">Для отладочных вставок используйте uids,начинающиеся с этого параметра.Диапазон,приведенный ниже параметра,зарезервирован исключительно для отладочных вставок,созданных с помощью</target>
        </trans-unit>
        <trans-unit id="5c902a2c872ceeb654d592edec56cf917fe25417" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the C++ ABI. The default is version 0.</source>
          <target state="translated">Используйте версию &lt;var&gt;n&lt;/var&gt; C ++ ABI. По умолчанию - версия 0.</target>
        </trans-unit>
        <trans-unit id="80654292da05f375c19f860e1835e2717583ea50" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the Objective-C ABI for the selected runtime. This option is currently supported only for the NeXT runtime. In that case, Version 0 is the traditional (32-bit) ABI without support for properties and other Objective-C 2.0 additions. Version 1 is the traditional (32-bit) ABI with support for properties and other Objective-C 2.0 additions. Version 2 is the modern (64-bit) ABI. If nothing is specified, the default is Version 0 on 32-bit target machines, and Version 2 on 64-bit target machines.</source>
          <target state="translated">Используйте версию &lt;var&gt;n&lt;/var&gt; Objective-C ABI для выбранной среды выполнения. Эта опция в настоящее время поддерживается только для среды выполнения NeXT. В этом случае Версия 0 является традиционным (32-битным) ABI без поддержки свойств и других дополнений Objective-C 2.0. Версия 1 - это традиционный (32-битный) ABI с поддержкой свойств и других дополнений Objective-C 2.0. Версия 2 - это современный (64-битный) ABI. Если ничего не указано, по умолчанию используется Версия 0 на 32-разрядных целевых машинах и Версия 2 на 64-разрядных целевых машинах.</target>
        </trans-unit>
        <trans-unit id="60277ce820e41f7e776a5ef4d10492797080b9c8" translate="yes" xml:space="preserve">
          <source>User defined libraries may want to implement their own constant string class. To be able to support them, the GNU Objective-C compiler provides a new command line options</source>
          <target state="translated">Определенные пользователем библиотеки могут захотеть реализовать свой собственный класс константной строки.Чтобы иметь возможность их поддерживать,компилятор GNU Objective-C предоставляет новые опции командной строки</target>
        </trans-unit>
        <trans-unit id="6d924128c5dfe7331fc4ebe7adabf4aa651b95c3" translate="yes" xml:space="preserve">
          <source>Users often think it is a bug when GCC reports an error for code like this:</source>
          <target state="translated">Пользователи часто думают,что это ошибка,когда GCC сообщает об ошибке для такого кода:</target>
        </trans-unit>
        <trans-unit id="af3138cc282360a8600ef75867abc1b680f535c7" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;</source>
          <target state="translated">С помощью '</target>
        </trans-unit>
        <trans-unit id="c673f0c8f99a2c8acaf1de1f7743b24ea2d61bf5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;__auto_type&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt; has two advantages:</source>
          <target state="translated">Использование &lt;code&gt;__auto_type&lt;/code&gt; вместо &lt;code&gt;typeof&lt;/code&gt; имеет два преимущества:</target>
        </trans-unit>
        <trans-unit id="ae16306fd8fc8ae70da39e8eba7d569ba5d4c5f6" translate="yes" xml:space="preserve">
          <source>Using extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) typically produces smaller, safer, and more efficient code, and in most cases it is a better solution than basic &lt;code&gt;asm&lt;/code&gt;. However, there are two situations where only basic &lt;code&gt;asm&lt;/code&gt; can be used:</source>
          <target state="translated">Использование расширенного &lt;code&gt;asm&lt;/code&gt; (см. &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt; ) обычно дает меньший, более безопасный и более эффективный код, и в большинстве случаев это лучшее решение, чем базовое &lt;code&gt;asm&lt;/code&gt; . Однако есть две ситуации, когда можно использовать только базовый &lt;code&gt;asm&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fdb3b64210e267abb96c2653531b3f456e595b0e" translate="yes" xml:space="preserve">
          <source>Using floating point parameters for indirect calls to static functions will not work when using the HP assembler. There simply is no way for GCC to specify what registers hold arguments for static functions when using the HP assembler. GAS for the PA does not have this problem.</source>
          <target state="translated">Использование параметров с плавающей точкой для косвенного вызова статических функций не будет работать при использовании ассемблера HP.Просто GCC не может указать,в каких регистрах хранятся аргументы для статических функций при использовании ассемблера HP.GAS для ПА не имеет этой проблемы.</target>
        </trans-unit>
        <trans-unit id="7f26807350569d85ac77ce79b84cf07a635bf81a" translate="yes" xml:space="preserve">
          <source>Using gcov with GCC optimization.</source>
          <target state="translated">Использование gcov с GCC оптимизацией.</target>
        </trans-unit>
        <trans-unit id="057195ec8f49950ab0bbd7ddf35c8adeaad3604e" translate="yes" xml:space="preserve">
          <source>Using that same compiler, this code:</source>
          <target state="translated">Используя тот же компилятор,этот код:</target>
        </trans-unit>
        <trans-unit id="2e7015f3209d38900be9cab70f20fe385b6b0e2e" translate="yes" xml:space="preserve">
          <source>Using the GNU Compiler Collection (GCC)</source>
          <target state="translated">Использование коллекции компиляторов GNU (GCC)</target>
        </trans-unit>
        <trans-unit id="e084cdbad1b5de611e7b01b9c20a68e2bf4e6eb3" translate="yes" xml:space="preserve">
          <source>Using the argument forms of the &lt;code&gt;constructor&lt;/code&gt; and &lt;code&gt;destructor&lt;/code&gt; attributes on targets where the feature is not supported is rejected with an error.</source>
          <target state="translated">Использование форм аргументов атрибутов &lt;code&gt;constructor&lt;/code&gt; и &lt;code&gt;destructor&lt;/code&gt; для целей, где функция не поддерживается, отклоняется с ошибкой.</target>
        </trans-unit>
        <trans-unit id="b7a3e4a21bb4f065c09ef23587c979ac36262bbb" translate="yes" xml:space="preserve">
          <source>Using the built-in functions described below, you can record the arguments a function received, and call another function with the same arguments, without knowing the number or types of the arguments.</source>
          <target state="translated">Используя встроенные функции,описанные ниже,вы можете записать аргументы,полученные функцией,и вызвать другую функцию с теми же аргументами,не зная количество или типы аргументов.</target>
        </trans-unit>
        <trans-unit id="4a1d87094917525e3f4fb29e2aa35aa01c301737" translate="yes" xml:space="preserve">
          <source>Using the cast as the right-hand side of an assignment to a variable of union type is equivalent to storing in a member of the union with the same type</source>
          <target state="translated">Использование кастинга в качестве правой стороны присваивания переменной типа союза эквивалентно хранению в члене союза с таким же типом</target>
        </trans-unit>
        <trans-unit id="db9a503a051e32ac0fce6e9c55331f5affaaa22c" translate="yes" xml:space="preserve">
          <source>Using the variable</source>
          <target state="translated">Использование переменной</target>
        </trans-unit>
        <trans-unit id="b34c5d037644130f54f15d5f39b3ad23e6aef200" translate="yes" xml:space="preserve">
          <source>Using these common set of HTM inline functions, we can create a more portable version of the HTM example in the previous section that will work on either PowerPC or S/390:</source>
          <target state="translated">Используя этот общий набор встроенных функций HTM,в предыдущем разделе мы можем создать более портативную версию примера HTM,которая будет работать либо на PowerPC,либо на S/390:</target>
        </trans-unit>
        <trans-unit id="e5427ab978358d5a7992aa85bab4f2f802b870d2" translate="yes" xml:space="preserve">
          <source>Using this attribute can improve optimization. Compiler predicts that a function with the attribute returns non-null in most cases. Functions like &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;calloc&lt;/code&gt; have this property because they return a pointer to uninitialized or zeroed-out storage. However, functions like &lt;code&gt;realloc&lt;/code&gt; do not have this property, as they can return a pointer to storage containing pointers.</source>
          <target state="translated">Использование этого атрибута может улучшить оптимизацию. Компилятор предсказывает, что функция с атрибутом в большинстве случаев возвращает ненулевое значение. Такие функции, как &lt;code&gt;malloc&lt;/code&gt; и &lt;code&gt;calloc&lt;/code&gt; , имеют это свойство, потому что они возвращают указатель на неинициализированное или обнуленное хранилище. Однако такие функции, как &lt;code&gt;realloc&lt;/code&gt; , не имеют этого свойства, поскольку они могут возвращать указатель на хранилище, содержащее указатели.</target>
        </trans-unit>
        <trans-unit id="e9444c5f053236b2bc826f3e11776a49a60bc5ff" translate="yes" xml:space="preserve">
          <source>Using unpacked vectors includes storing smaller elements in larger containers and accessing elements with extending loads and truncating stores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b49b124c3d34a77d39d66c92e391e732c60826d" translate="yes" xml:space="preserve">
          <source>Using vector instructions through built-in functions.</source>
          <target state="translated">Использование векторных инструкций через встроенные функции.</target>
        </trans-unit>
        <trans-unit id="2dfe46da755d749792dfc6596d3900b7c7d1225d" translate="yes" xml:space="preserve">
          <source>Usually, the more IPA optimizations enabled, the larger the number of impacted functions for each function. In order to control the number of impacted functions and more easily compute the list of impacted function, IPA optimizations can be partially enabled at two different levels.</source>
          <target state="translated">Обычно,чем больше включено оптимизаций IPA,тем больше количество затрагиваемых функций для каждой функции.Для того,чтобы контролировать количество затрагиваемых функций и легче вычислять список затрагиваемых функций,оптимизация IPA может быть частично включена на двух различных уровнях.</target>
        </trans-unit>
        <trans-unit id="75ec5cdb7f54185163f339da83a6bb1078cb8cdf" translate="yes" xml:space="preserve">
          <source>Usually, the specified type of a compound literal is a structure. Assume that &lt;code&gt;struct foo&lt;/code&gt; and &lt;code&gt;structure&lt;/code&gt; are declared as shown:</source>
          <target state="translated">Обычно указанный тип составного литерала - это структура. Предположим, что &lt;code&gt;struct foo&lt;/code&gt; и &lt;code&gt;structure&lt;/code&gt; объявлены, как показано:</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="c3931c23034ae49c597b98c1e269c48a1c09a3b0" translate="yes" xml:space="preserve">
          <source>V flag clear</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4cc43f43927e75f6b3fae22012121ade60802d" translate="yes" xml:space="preserve">
          <source>V flag set or signed overflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574d16a752ab33d0cef891f9de30707743042305" translate="yes" xml:space="preserve">
          <source>V850E2V3</source>
          <target state="translated">V850E2V3</target>
        </trans-unit>
        <trans-unit id="18daea8d25a1ff1128b31b35345423541b18cfb9" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d31&lt;/code&gt; and the appropriate subset &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d15&lt;/code&gt; based on command line options. Used for 64 bit values only. Not valid for Thumb1.</source>
          <target state="translated">Регистры с плавающей запятой VFP &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d31&lt;/code&gt; и соответствующее подмножество &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d15&lt;/code&gt; на основе параметров командной строки. Используется только для 64-битных значений. Недействительно для Thumb1.</target>
        </trans-unit>
        <trans-unit id="9cbb2d892b07e55db914e77fcb2ce30c1ce00bae" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;s0&lt;/code&gt;-&lt;code&gt;s31&lt;/code&gt;. Used for 32 bit values.</source>
          <target state="translated">Регистры с плавающей запятой VFP &lt;code&gt;s0&lt;/code&gt; - &lt;code&gt;s31&lt;/code&gt; . Используется для 32-битных значений.</target>
        </trans-unit>
        <trans-unit id="3d910167fb4f24dfbb3904aef13e596ce47de5f7" translate="yes" xml:space="preserve">
          <source>VGPR register</source>
          <target state="translated">регистр VGPR</target>
        </trans-unit>
        <trans-unit id="d5387553aab64197b27321b5224709eacf46c07a" translate="yes" xml:space="preserve">
          <source>VIA C3 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA C3 с поддержкой MMX и 3DNow! набора инструкций.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="488b543fd950a74701b966446818fb5fe7d6e4bc" translate="yes" xml:space="preserve">
          <source>VIA C3-2 (Nehemiah/C5XL) CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">ЦП VIA C3-2 (Nehemiah/C5XL)с поддержкой MMX и набора команд SSE.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="ea585482eb4a4acc3a6360d2898743a7c9373beb" translate="yes" xml:space="preserve">
          <source>VIA C7 (Esther) CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">ЦП VIA C7 (Esther)с поддержкой наборов команд MMX,SSE,SSE2 и SSE3.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="f935a35014da34c94c36f4bd8a1a050285f9d495" translate="yes" xml:space="preserve">
          <source>VIA Eden Esther CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Esther процессор с поддержкой наборов команд MMX,SSE,SSE2 и SSE3.(Планирование для этого чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="c111443ef87aeb29107b8a68909620c76e8f94c1" translate="yes" xml:space="preserve">
          <source>VIA Eden Nehemiah CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Nehemiah CPU с поддержкой набора команд MMX и SSE.(Планирование для этого чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="8cce1c624bb9c2543acc6d544b6d1ed27c2158a4" translate="yes" xml:space="preserve">
          <source>VIA Eden Samuel 2 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Samuel 2 CPU с поддержкой MMX и 3DNow! набора инструкций.(Планирование для этого чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="2151cc7927e87e8f1c1dda8e6327ac4e0a64b7a2" translate="yes" xml:space="preserve">
          <source>VIA Eden X2 CPU with x86-64, MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Eden X2 с поддержкой наборов команд x86-64,MMX,SSE,SSE2 и SSE3.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="1d98ef012706e83dddd4d35e5d791491017f3e46" translate="yes" xml:space="preserve">
          <source>VIA Eden X4 CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX and AVX2 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Eden X4 с поддержкой наборов команд x86-64,MMX,SSE,SSE2,SSE3,SSSE3,SSE4.1,SSE4.2,AVX и AVX2.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="b8b4d4a862d49f8ff0f8c10fa3fdc814a539ab87" translate="yes" xml:space="preserve">
          <source>VIA Nano 1xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Nano 1xxx с поддержкой набора команд x86-64,MMX,SSE,SSE2,SSE3 и SSSE3.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="dd719c7a93195bbf6d07de4c172b28d8c80267d3" translate="yes" xml:space="preserve">
          <source>VIA Nano 2xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Nano 2xxx с поддержкой набора команд x86-64,MMX,SSE,SSE2,SSE3 и SSSE3.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="01f9fedc3d4f11e857e6f0d9dcaa2b13176b8f56" translate="yes" xml:space="preserve">
          <source>VIA Nano 3xxx CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Процессор VIA Nano 3xxx с поддержкой набора команд x86-64,MMX,SSE,SSE2,SSE3,SSSE3 и SSE4.1.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="06b544d4bdd7d18ca4149d3c750f4127e9f983b2" translate="yes" xml:space="preserve">
          <source>VIA Nano Dual Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">Двухъядерный процессор VIA Nano с поддержкой наборов команд x86-64,MMX,SSE,SSE2,SSE3,SSSE3 и SSE4.1.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="a67ea4083339300c1d547f346d07c9d5764525af" translate="yes" xml:space="preserve">
          <source>VIA Nano Quad Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Nano Quad Core CPU с поддержкой набора команд x86-64,MMX,SSE,SSE2,SSE3,SSSE3 и SSE4.1.(Планирование для данного чипа не реализовано).</target>
        </trans-unit>
        <trans-unit id="04026107ef9bdc35c4d06c69d4d8d9bd034df2b9" translate="yes" xml:space="preserve">
          <source>VPCLMULQDQ instructions.</source>
          <target state="translated">VPCLMULQDQ инструкции.</target>
        </trans-unit>
        <trans-unit id="47b598fadc542503a4dfb3ab0e7c08963d810a39" translate="yes" xml:space="preserve">
          <source>VRSAVE</source>
          <target state="translated">VRSAVE</target>
        </trans-unit>
        <trans-unit id="55aa2f856c0f4ab3cdcac26a348778a588a6f8d7" translate="yes" xml:space="preserve">
          <source>VSIB address operand.</source>
          <target state="translated">Адресный операнд ВСИБ.</target>
        </trans-unit>
        <trans-unit id="1e028c813fc89395b126781b62fe740e1e2e5612" translate="yes" xml:space="preserve">
          <source>VSX register if direct move instructions are enabled, or NO_REGS.</source>
          <target state="translated">VSX-регистр,если включены прямые указания по перемещению,или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="b1bf4ce917ea0e342c5ba87416d3c1425045396d" translate="yes" xml:space="preserve">
          <source>VSX register if the</source>
          <target state="translated">Регистрация VSX,если</target>
        </trans-unit>
        <trans-unit id="fa37e771ee1559b7e1a74968d2d6f9d21bbad3f8" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point TFmode, or NO_REGS.</source>
          <target state="translated">Регистр VSX,используемый для IEEE 128-битного TFmode с плавающей точкой,или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="dceb09e56dc6976e2ceb44b306b90d48c16cdbfa" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point, or NO_REGS.</source>
          <target state="translated">Регистр VSX,используемый для IEEE 128-битной вычисленной точки с плавающей запятой,или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="5f2931cf969db5dec892ea6c97702a431f737f4f" translate="yes" xml:space="preserve">
          <source>VSX register to use for ISA 3.0 vector instructions, or NO_REGS.</source>
          <target state="translated">Регистр VSX для использования векторных инструкций ISA 3.0,или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="e1e2b74202b4df2a34423d711c880f4bed5b3b14" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold 128 bit integer or NO_REGS.</source>
          <target state="translated">VSX векторный регистр для хранения 128-битного целого числа или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="f3dc5e0d7bbebef3893829b42a25b08c256dd4d8" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold scalar double values or NO_REGS.</source>
          <target state="translated">VSX векторный регистр для хранения скалярных двойных значений или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="dc350e1093c1db7d408d43c001ed04b73c029f23" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector double data or NO_REGS.</source>
          <target state="translated">VSX векторный регистр для хранения векторных двойных данных или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="167ef2a892b4ddc57b82f58074b39f524e5008e6" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector float data or NO_REGS.</source>
          <target state="translated">VSX векторный регистр для хранения векторных данных с плавающей запятой или NO_REGS.</target>
        </trans-unit>
        <trans-unit id="81969f619b07a96e38c916b9993cc433143a784f" translate="yes" xml:space="preserve">
          <source>VTables</source>
          <target state="translated">VTables</target>
        </trans-unit>
        <trans-unit id="f5f8e1247b6f26b263b34207afe669cb4ac9de15" translate="yes" xml:space="preserve">
          <source>Valid ISO C and ISO C++ programs should compile properly with or without this option (though a rare few require</source>
          <target state="translated">Действительные программы на ISO C и ISO C++должны компилироваться правильно с этой опцией или без нее (хотя некоторые редкие программы требуют</target>
        </trans-unit>
        <trans-unit id="6c1f687862693a87865ad97fba05738669eac5ce" translate="yes" xml:space="preserve">
          <source>Valid alignment values other than those returned by an _Alignof expression for fundamental types, if any (C11 6.2.8).</source>
          <target state="translated">Действительные значения выравнивания,отличные от значений,возвращаемых выражением _Alignof для фундаментальных типов,если таковые имеются (С11 6.2.8).</target>
        </trans-unit>
        <trans-unit id="b8f1ffda93c672ca444e36a4f56d16e63e5832c4" translate="yes" xml:space="preserve">
          <source>Valid alignments are powers of 2 up to and including &lt;em&gt;2^{28}&lt;/em&gt;.</source>
          <target state="translated">Допустимые варианты выравнивания: степени от 2 до &lt;em&gt;2 ^ {28}&lt;/em&gt; включительно .</target>
        </trans-unit>
        <trans-unit id="e0567df87b1ea75cda27929ada4a4306a0c755cd" translate="yes" xml:space="preserve">
          <source>Valid options for &lt;var&gt;time&lt;/var&gt; are</source>
          <target state="translated">Допустимые варианты &lt;var&gt;time&lt;/var&gt; являются</target>
        </trans-unit>
        <trans-unit id="bd15e3ace5dbddf7a0573a3f99038d776bddea91" translate="yes" xml:space="preserve">
          <source>Value appropriate as displacement.</source>
          <target state="translated">Значение соответствует смещению.</target>
        </trans-unit>
        <trans-unit id="bb6561e8ab01989a094611590f0602e85a6c5513" translate="yes" xml:space="preserve">
          <source>Values &amp;lsquo;</source>
          <target state="translated">Ценности '</target>
        </trans-unit>
        <trans-unit id="d206078a63cff7bace258bb1f4bb9507b5cf8d12" translate="yes" xml:space="preserve">
          <source>Variable, function, and type attributes for C++ only.</source>
          <target state="translated">Атрибуты переменной,функции и типа только для C++.</target>
        </trans-unit>
        <trans-unit id="02b16fb34038c0c62719510ede0c2e29dc2b90fc" translate="yes" xml:space="preserve">
          <source>Variable-length automatic arrays are allowed in ISO C99, and as an extension GCC accepts them in C90 mode and in C++. These arrays are declared like any other automatic arrays, but with a length that is not a constant expression. The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits. For example:</source>
          <target state="translated">Автоматические массивы переменной длины разрешены в ISO C99,а в качестве расширения GCC принимает их в режиме C90 и в C++.Эти массивы объявляются,как и любые другие автоматические массивы,но с длиной,не являющейся константным выражением.Хранилище выделяется в момент объявления и деблокируется при выходе из области видимости блока,содержащего объявление.Например:</target>
        </trans-unit>
        <trans-unit id="c1cafb0eff03f52681f175e65218139665f9ce2c" translate="yes" xml:space="preserve">
          <source>Variables declared at global scope.</source>
          <target state="translated">Переменные,объявленные в глобальном масштабе.</target>
        </trans-unit>
        <trans-unit id="5c01cb4a8cb1760f9b45c63f7213bd015da5c74c" translate="yes" xml:space="preserve">
          <source>Variables declared within a function.</source>
          <target state="translated">Переменные,объявленные в рамках функции.</target>
        </trans-unit>
        <trans-unit id="b8da0198222d30500868466badddd4041e14cce0" translate="yes" xml:space="preserve">
          <source>Variables of size &lt;var&gt;n&lt;/var&gt; bytes or smaller are placed in the &lt;code&gt;.based&lt;/code&gt; section by default. Based variables use the &lt;code&gt;$tp&lt;/code&gt; register as a base register, and there is a 128-byte limit to the &lt;code&gt;.based&lt;/code&gt; section.</source>
          <target state="translated">Переменные размером &lt;var&gt;n&lt;/var&gt; байт или меньше по умолчанию помещаются в раздел &lt;code&gt;.based&lt;/code&gt; . Базовые переменные используют регистр &lt;code&gt;$tp&lt;/code&gt; как базовый регистр, а для секции &lt;code&gt;.based&lt;/code&gt; существует ограничение в 128 байт .</target>
        </trans-unit>
        <trans-unit id="10abea2eed8c32edbb792ccf39c883573091a3b2" translate="yes" xml:space="preserve">
          <source>Variables that are &lt;var&gt;n&lt;/var&gt; bytes or smaller are allocated to the &lt;code&gt;.tiny&lt;/code&gt; section. These variables use the &lt;code&gt;$gp&lt;/code&gt; base register. The default for this option is 4, but note that there&amp;rsquo;s a 65536-byte limit to the &lt;code&gt;.tiny&lt;/code&gt; section.</source>
          <target state="translated">Переменные размером &lt;var&gt;n&lt;/var&gt; байтов или меньше выделяются в раздел &lt;code&gt;.tiny&lt;/code&gt; . Эти переменные используют базовый регистр &lt;code&gt;$gp&lt;/code&gt; . По умолчанию для этого параметра установлено значение 4, но обратите внимание, что для раздела &lt;code&gt;.tiny&lt;/code&gt; существует ограничение в 65536 байт .</target>
        </trans-unit>
        <trans-unit id="fd3f9d35c079daab2745eafe9db9775e6794913e" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;cb&lt;/code&gt; attribute are used to access the control bus, using special instructions. &lt;code&gt;addr&lt;/code&gt; indicates the control bus address. Example:</source>
          <target state="translated">Переменные с атрибутом &lt;code&gt;cb&lt;/code&gt; используются для доступа к шине управления с помощью специальных инструкций. &lt;code&gt;addr&lt;/code&gt; указывает адрес шины управления. Пример:</target>
        </trans-unit>
        <trans-unit id="de934aeb77c58838cc9846aadb82fbd1b8f30e96" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;far&lt;/code&gt; attribute are addressed using a full 32-bit address. Since this covers the entire memory space, this allows modules to make no assumptions about where variables might be stored.</source>
          <target state="translated">Переменные с атрибутом &lt;code&gt;far&lt;/code&gt; адресуются с использованием полного 32-битного адреса. Поскольку это охватывает все пространство памяти, это позволяет модулям не делать предположений о том, где могут храниться переменные.</target>
        </trans-unit>
        <trans-unit id="36905cf24c84385c4961b4619b30de52faf8e512" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;io&lt;/code&gt; attribute are used to address memory-mapped peripherals. If an address is specified, the variable is assigned that address, else it is not assigned an address (it is assumed some other module assigns an address). Example:</source>
          <target state="translated">Переменные с атрибутом &lt;code&gt;io&lt;/code&gt; используются для адресации периферийных устройств с отображением памяти. Если адрес указан, переменной назначается этот адрес, в противном случае ему не назначается адрес (предполагается, что какой-то другой модуль назначает адрес). Пример:</target>
        </trans-unit>
        <trans-unit id="8908399e90d6597694e9414404cf146058083fc2" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;near&lt;/code&gt; attribute are assumed to have addresses that fit in a 24-bit addressing mode. This is the default for large variables (&lt;code&gt;-mtiny=4&lt;/code&gt; is the default) but this attribute can override &lt;code&gt;-mtiny=&lt;/code&gt; for small variables, or override &lt;code&gt;-ml&lt;/code&gt;.</source>
          <target state="translated">Предполагается, что переменные с атрибутом &lt;code&gt;near&lt;/code&gt; имеют адреса, соответствующие 24-битному режиму адресации. Это значение по умолчанию для больших переменных ( &lt;code&gt;-mtiny=4&lt;/code&gt; по умолчанию), но этот атрибут может переопределить &lt;code&gt;-mtiny=&lt;/code&gt; для малых переменных или &lt;code&gt;-ml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f34701193da16d128be7840c2b5e27cdc6209c0" translate="yes" xml:space="preserve">
          <source>Variadic functions always use the &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; calling convention and the compiler rejects attempts to specify an alternative.</source>
          <target state="translated">Функции Variadic всегда используют &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; и компилятор отклоняет попытки указать альтернативу.</target>
        </trans-unit>
        <trans-unit id="c34add3442e320001d71a4acf459f90b84551e3c" translate="yes" xml:space="preserve">
          <source>Variations on C++.</source>
          <target state="translated">Вариации на С++.</target>
        </trans-unit>
        <trans-unit id="0125a3430008ecbd7c8a33ef91916cf2ea436c9e" translate="yes" xml:space="preserve">
          <source>Variations on Objective-C and Objective-C++.</source>
          <target state="translated">Вариации на тему &quot;Цель-С&quot; и &quot;Цель-С++&quot;.</target>
        </trans-unit>
        <trans-unit id="eb5d846c7919ee0bdc2338a4cc38cee42f3c00b6" translate="yes" xml:space="preserve">
          <source>Vector comparison is supported with standard comparison operators: &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt;. Comparison operands can be vector expressions of integer-type or real-type. Comparison between integer-type vectors and real-type vectors are not supported. The result of the comparison is a vector of the same width and number of elements as the comparison operands with a signed integral element type.</source>
          <target state="translated">Сравнение векторов поддерживается стандартными операторами сравнения: &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; . Операнды сравнения могут быть векторными выражениями целочисленного или вещественного типа. Сравнение между векторами целочисленного типа и векторами действительного типа не поддерживается. Результатом сравнения является вектор той же ширины и количества элементов, что и операнды сравнения со знаком целочисленного типа элемента.</target>
        </trans-unit>
        <trans-unit id="5abc95e73e06fb4a5dc5582edf5afa312b0850ca" translate="yes" xml:space="preserve">
          <source>Vector condition register: VCC, VCC_LO, VCC_HI</source>
          <target state="translated">Векторный регистр состояния:VCC,VCC_LO,VCC_HI</target>
        </trans-unit>
        <trans-unit id="53804d00035aa75837541b3ccf479dca992da7d5" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with XXSPLTIB &amp;amp; sign extension.</source>
          <target state="translated">Векторная константа, которую можно загрузить с помощью расширения XXSPLTIB и знака.</target>
        </trans-unit>
        <trans-unit id="82f741b1697518a50ba54947e1a23cae2eaec1c0" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with the XXSPLTIB instruction.</source>
          <target state="translated">Векторная константа,которая может быть загружена с инструкцией XXSPLTIB.</target>
        </trans-unit>
        <trans-unit id="46e517c61990308718dcf40277ed1d92f620280a" translate="yes" xml:space="preserve">
          <source>Vector constant that does not require memory</source>
          <target state="translated">Векторная константа,не требующая памяти</target>
        </trans-unit>
        <trans-unit id="b42c5127757a32ed5d06d2b5cf09ce9893f82ec9" translate="yes" xml:space="preserve">
          <source>Vector constant that is all zeros.</source>
          <target state="translated">Векторная константа,то есть все нули.</target>
        </trans-unit>
        <trans-unit id="9c36bdfc3b8d0b06a49e5ef972497ba956ef9bbc" translate="yes" xml:space="preserve">
          <source>Vector conversion is available using the &lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; function. &lt;var&gt;vec&lt;/var&gt; must be an expression with integral or floating vector type and &lt;var&gt;vectype&lt;/var&gt; an integral or floating vector type with the same number of elements. The result has &lt;var&gt;vectype&lt;/var&gt; type and value of a C cast of every element of &lt;var&gt;vec&lt;/var&gt; to the element type of &lt;var&gt;vectype&lt;/var&gt;.</source>
          <target state="translated">Векторное преобразование доступно с помощью функции &lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; . &lt;var&gt;vec&lt;/var&gt; должно быть выражением с целочисленным или плавающим векторным типом, а &lt;var&gt;vectype&lt;/var&gt; - с целым или плавающим векторным типом с тем же числом элементов. Результат имеет тип &lt;var&gt;vectype&lt;/var&gt; и значение преобразования C каждого элемента &lt;var&gt;vec&lt;/var&gt; в тип элемента &lt;var&gt;vectype&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bad6bdbaf23ec0df51bc6d85940b036ecbab94" translate="yes" xml:space="preserve">
          <source>Vector registers.</source>
          <target state="translated">Векторные регистры.</target>
        </trans-unit>
        <trans-unit id="8e0df7cd51c0d162c1fce7156e6eae770327c8c2" translate="yes" xml:space="preserve">
          <source>Vector shuffling is available using functions &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; and &lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt;. Both functions construct a permutation of elements from one or two vectors and return a vector of the same type as the input vector(s). The &lt;var&gt;mask&lt;/var&gt; is an integral vector with the same width (&lt;var&gt;W&lt;/var&gt;) and element count (&lt;var&gt;N&lt;/var&gt;) as the output vector.</source>
          <target state="translated">&lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt; доступно с использованием функций &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; и __builtin_shuffle (vec0, vec1, mask) . Обе функции создают перестановку элементов из одного или двух векторов и возвращают вектор того же типа, что и входной вектор (ы). &lt;var&gt;mask&lt;/var&gt; является составным вектором с такой же шириной ( &lt;var&gt;W&lt;/var&gt; ) и числом элементов ( &lt;var&gt;N&lt;/var&gt; ) в качестве выходного вектора.</target>
        </trans-unit>
        <trans-unit id="58128c4d1de4d0a51bf04fac4cddbc549bd01efb" translate="yes" xml:space="preserve">
          <source>Vector zero</source>
          <target state="translated">вектор нуля</target>
        </trans-unit>
        <trans-unit id="73c5f8f62b1af06d2d8df3f66347a1a059d5cf24" translate="yes" xml:space="preserve">
          <source>Vectors are compared element-wise producing 0 when comparison is false and -1 (constant of the appropriate type where all bits are set) otherwise. Consider the following example.</source>
          <target state="translated">Векторы сравниваются по элементам,производя 0,если сравнение ложное,и -1 (константа соответствующего типа,где все биты установлены)в противном случае.Рассмотрим следующий пример.</target>
        </trans-unit>
        <trans-unit id="fcd23bd0a88ba1a503b10ed5edf55ece81978ffc" translate="yes" xml:space="preserve">
          <source>Vectors can be subscripted as if the vector were an array with the same number of elements and base type. Out of bound accesses invoke undefined behavior at run time. Warnings for out of bound accesses for vector subscription can be enabled with</source>
          <target state="translated">Векторы можно подписывать так,как если бы вектор был массивом с таким же количеством элементов и базовым типом.Внеграничные обращения вызывают неопределенное поведение во время выполнения.Предупреждения о выходе из-под привязки для векторной подписки можно включить с помощью параметра</target>
        </trans-unit>
        <trans-unit id="e368f0bdb096cdc80b942de26edde7361d633b14" translate="yes" xml:space="preserve">
          <source>Version 0 refers to the version conforming most closely to the C++ ABI specification. Therefore, the ABI obtained using version 0 will change in different versions of G++ as ABI bugs are fixed.</source>
          <target state="translated">Версия 0 относится к версии,наиболее близкой к спецификации C++ABI.Поэтому ABI,полученный с использованием версии 0,будет изменяться в разных версиях G++,так как ошибки ABI исправлены.</target>
        </trans-unit>
        <trans-unit id="4d24a59e560f384b23499b32746ec055716a43ab" translate="yes" xml:space="preserve">
          <source>Version 1 is the version of the C++ ABI that first appeared in G++ 3.2.</source>
          <target state="translated">Версия 1-это версия C++ABI,которая впервые появилась в G++3.2.</target>
        </trans-unit>
        <trans-unit id="3c0b003b505c0ed05512e30de5602e0fe9cf92cd" translate="yes" xml:space="preserve">
          <source>Version 10, which first appeared in G++ 6.1, adds mangling of attributes that affect type identity, such as ia32 calling convention attributes (e.g. &amp;lsquo;</source>
          <target state="translated">Версия 10, впервые появившаяся в G ++ 6.1, добавляет изменение атрибутов, влияющих на идентичность типа, например атрибутов соглашения о вызовах ia32 (например, '</target>
        </trans-unit>
        <trans-unit id="663092bb020840a15939c0d6a393bb5154dcf611" translate="yes" xml:space="preserve">
          <source>Version 11, which first appeared in G++ 7, corrects the mangling of sizeof... expressions and operator names. For multiple entities with the same name within a function, that are declared in different scopes, the mangling now changes starting with the twelfth occurrence. It also implies</source>
          <target state="translated">Версия 11,впервые появившаяся в G++7,исправляет искажение размеров...выражений и имен операторов.Для множества сущностей с одним и тем же именем внутри функции,которые объявлены в разных диапазонах,искажение теперь меняется,начиная с двенадцатого вхождения.Это также подразумевает</target>
        </trans-unit>
        <trans-unit id="0ca6a1ee7b0905689803a926babe92130837b997" translate="yes" xml:space="preserve">
          <source>Version 12, which first appeared in G++ 8, corrects the calling conventions for empty classes on the x86_64 target and for classes with only deleted copy/move constructors. It accidentally changes the calling convention for classes with a deleted copy constructor and a trivial move constructor.</source>
          <target state="translated">Версия 12,впервые появившаяся в G++8,исправляет соглашения о вызове для пустых классов на x86_64 цели и для классов с только удаленными конструкторами копирования/перемещения.Случайно изменяется соглашение о вызове для классов с конструктором удаленного копирования и тривиальным конструктором перемещения.</target>
        </trans-unit>
        <trans-unit id="50a009d60ade6b341d095db62ce8f2e0c4f1391a" translate="yes" xml:space="preserve">
          <source>Version 13, which first appeared in G++ 8.2, fixes the accidental change in version 12.</source>
          <target state="translated">Версия 13,впервые появившаяся в G++8.2,исправляет случайное изменение в версии 12.</target>
        </trans-unit>
        <trans-unit id="7772e904596ec4170f5e5d5dda9d718d4516ab59" translate="yes" xml:space="preserve">
          <source>Version 14, which first appeared in G++ 10, corrects the mangling of the nullptr expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b38c5970d57d0e95ac144e09f14ebe98042886d" translate="yes" xml:space="preserve">
          <source>Version 2 is the version of the C++ ABI that first appeared in G++ 3.4, and was the default through G++ 4.9.</source>
          <target state="translated">Версия 2-это версия C++ABI,которая впервые появилась в G++3.4,и была по умолчанию через G++4.9.</target>
        </trans-unit>
        <trans-unit id="b724fbb5aa7b15b70d72eb03063512067a94eeca" translate="yes" xml:space="preserve">
          <source>Version 3 corrects an error in mangling a constant address as a template argument.</source>
          <target state="translated">Версия 3 исправляет ошибку при использовании постоянного адреса в качестве аргумента шаблона.</target>
        </trans-unit>
        <trans-unit id="01a6ae459293959ae77cf0ff9e1fc859781779ed" translate="yes" xml:space="preserve">
          <source>Version 4 may require GDB 7.0 and</source>
          <target state="translated">Для версии 4 может потребоваться GDB 7.0 и</target>
        </trans-unit>
        <trans-unit id="dd83630f9225432d363943045fc9c9e3da8fa1fd" translate="yes" xml:space="preserve">
          <source>Version 4, which first appeared in G++ 4.5, implements a standard mangling for vector types.</source>
          <target state="translated">Версия 4,впервые появившаяся в G++4.5,реализует стандартное управление векторными типами.</target>
        </trans-unit>
        <trans-unit id="bcd8e454766585098e98a3f378e25d4a3a094eb0" translate="yes" xml:space="preserve">
          <source>Version 5, which first appeared in G++ 4.6, corrects the mangling of attribute const/volatile on function pointer types, decltype of a plain decl, and use of a function parameter in the declaration of another parameter.</source>
          <target state="translated">Версия 5,впервые появившаяся в G++4.6,исправляет искажение атрибута const/volatile на типы указателей функций,тип склонения простого объявления,а также использование параметра функции в объявлении другого параметра.</target>
        </trans-unit>
        <trans-unit id="b60149f703c30d6cd13e3a5cac7ff5559e1b4439" translate="yes" xml:space="preserve">
          <source>Version 6, which first appeared in G++ 4.7, corrects the promotion behavior of C++11 scoped enums and the mangling of template argument packs, const/static_cast, prefix ++ and &amp;ndash;, and a class scope function used as a template argument.</source>
          <target state="translated">Версия 6, которая впервые появилась в G ++ 4.7, исправляет продвижение перечислений с областью видимости C ++ 11 и искажение пакетов аргументов шаблона, const / static_cast, prefix ++ и -, а также функцию области действия класса, используемую в качестве аргумента шаблона.</target>
        </trans-unit>
        <trans-unit id="4782295af04ef7af5fe54b3ee6d18f5a34a794e5" translate="yes" xml:space="preserve">
          <source>Version 7, which first appeared in G++ 4.8, that treats nullptr_t as a builtin type and corrects the mangling of lambdas in default argument scope.</source>
          <target state="translated">Версия 7,впервые появившаяся в G++4.8,рассматривает nullptr_t как тип builtin и исправляет искажение lambdas в области аргументов по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d1c84e5d1ca1394d2ffa2a327b111624fb731bc7" translate="yes" xml:space="preserve">
          <source>Version 8, which first appeared in G++ 4.9, corrects the substitution behavior of function types with function-cv-qualifiers.</source>
          <target state="translated">Версия 8,впервые появившаяся в G++4.9,корректирует поведение подстановки типов функций с помощью функций-cv-квалификаторов.</target>
        </trans-unit>
        <trans-unit id="4ac00f95e84165203755f6a82a57d89ac3c1bab9" translate="yes" xml:space="preserve">
          <source>Version 9, which first appeared in G++ 5.2, corrects the alignment of &lt;code&gt;nullptr_t&lt;/code&gt;.</source>
          <target state="translated">Версия 9, которая впервые появилась в G ++ 5.2, исправляет выравнивание &lt;code&gt;nullptr_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cbaf9a36f9cc94b3082b235b02920043f217806" translate="yes" xml:space="preserve">
          <source>Visium&amp;mdash;</source>
          <target state="translated">Visium&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="ea87a96f76fbda4a0ceea67f5b82b7da4f4e2ed4" translate="yes" xml:space="preserve">
          <source>Volatile memory access bypass the cache using the I/O variants of the load and store instructions. The default is not to bypass the cache.</source>
          <target state="translated">Энергонезависимый доступ к памяти обходит кэш,используя варианты загрузки и хранения инструкций ввода/вывода.По умолчанию обхода кэша не производится.</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="1b1d16cb93f0aa2689c3eb4f6494e062863aa127" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011, e.g., identifiers in ISO C++ 1998 that are keywords in ISO C++ 2011. This warning turns on</source>
          <target state="translated">Предупреждаем о конструкциях С++,значение которых отличается между ISO C++1998 и ISO C++2011,например,идентификаторы в ISO C++1998,которые являются ключевыми словами в ISO C++2011.Это предупреждение включает</target>
        </trans-unit>
        <trans-unit id="a16be8e81dda2e7fc6c8f9439ff0fc768831de14" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014. This warning is enabled by</source>
          <target state="translated">Предупреждаем о конструкциях C++,значение которых отличается от ISO C++2011 и ISO C++2014.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="7632b789c4deefeb017ad2d53cdd4160afd5fe89" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2014 and ISO C++ 2017. This warning is enabled by</source>
          <target state="translated">Предупреждаем о конструкциях С++,значение которых отличается между ISO C++2014 и ISO C++2017.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="37c06d70e5569a9e9b9033370c9cd0224cd25471" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2017 and ISO C++ 2020. This warning is enabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b51f298dc17e10801636bad5bebb8011117716" translate="yes" xml:space="preserve">
          <source>Warn about ISO C constructs that are outside of the common subset of ISO C and ISO C++, e.g. request for implicit conversion from &lt;code&gt;void *&lt;/code&gt; to a pointer to non-&lt;code&gt;void&lt;/code&gt; type.</source>
          <target state="translated">Предупреждать о конструкциях ISO C, которые выходят за рамки общего подмножества ISO C и ISO C ++, например, о запросе неявного преобразования из &lt;code&gt;void *&lt;/code&gt; в указатель на &lt;code&gt;void&lt;/code&gt; тип.</target>
        </trans-unit>
        <trans-unit id="9b3c94b4023e357765dfc7eacc4bb32be69223f6" translate="yes" xml:space="preserve">
          <source>Warn about One Definition Rule violations during link-time optimization. Enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7de69bb81f9d506bfb6d47f928c946ab6b330c" translate="yes" xml:space="preserve">
          <source>Warn about One Definition Rule violations during link-time optimization. Requires</source>
          <target state="translated">Предупреждать о нарушении правила One Definition Rule при оптимизации времени соединения.Требуется</target>
        </trans-unit>
        <trans-unit id="f7cf98ad983fadf59ea9d8e55fff149a4d55f39b" translate="yes" xml:space="preserve">
          <source>Warn about a comparison between values of different enumerated types. In C++ enumerated type mismatches in conditional expressions are also diagnosed and the warning is enabled by default. In C this warning is enabled by</source>
          <target state="translated">Предупреждать о сравнении значений различных перечисленных типов.В Си++также диагностируется несовпадение перечисляемых типов в условных выражениях и по умолчанию включено предупреждение.В Си это предупреждение включается по</target>
        </trans-unit>
        <trans-unit id="5887fb5f81adf7425e8f523309718b847865d42f" translate="yes" xml:space="preserve">
          <source>Warn about a definition of an unsized deallocation function</source>
          <target state="translated">Предупредить об определении негабаритной функции распределения сделок.</target>
        </trans-unit>
        <trans-unit id="a4b22fdd430cf26b4eb0550ba2a6437e719969f1" translate="yes" xml:space="preserve">
          <source>Warn about a new-expression of a type that requires greater alignment than the &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; but uses an allocation function without an explicit alignment parameter. This option is enabled by</source>
          <target state="translated">Предупреждать о новом выражении типа, который требует большего выравнивания, чем &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; но использует функцию распределения без явного параметра выравнивания. Эта опция включена</target>
        </trans-unit>
        <trans-unit id="70d1fda65cb9a9be06885b2cf4259d9b30a0bf3a" translate="yes" xml:space="preserve">
          <source>Warn about accesses to elements of zero-length array members that might overlap other members of the same object. Declaring interior zero-length arrays is discouraged because accesses to them are undefined. See See &lt;a href=&quot;zero-length#Zero-Length&quot;&gt;Zero Length&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57392da628b0c1cb78f8e90a0ce56848a537dcc1" translate="yes" xml:space="preserve">
          <source>Warn about anything that depends on the &amp;ldquo;size of&amp;rdquo; a function type or of &lt;code&gt;void&lt;/code&gt;. GNU C assigns these types a size of 1, for convenience in calculations with &lt;code&gt;void *&lt;/code&gt; pointers and pointers to functions. In C++, warn also when an arithmetic operation involves &lt;code&gt;NULL&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">Предупреждать обо всем, что зависит от &amp;laquo;размера&amp;raquo; типа функции или &lt;code&gt;void&lt;/code&gt; . GNU C присваивает этим типам размер 1 для удобства вычислений с указателями &lt;code&gt;void *&lt;/code&gt; и указателями на функции. В C ++ предупреждать также, когда в арифметической операции используется &lt;code&gt;NULL&lt;/code&gt; . Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="a808a76d216f717246383427b89eff52c9b874ec" translate="yes" xml:space="preserve">
          <source>Warn about boolean expression compared with an integer value different from &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;. For instance, the following comparison is always false:</source>
          <target state="translated">Предупредить о сравнении логического выражения с целочисленным значением, отличным от &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; . Например, следующее сравнение всегда неверно:</target>
        </trans-unit>
        <trans-unit id="a9d532ae5e4af7c1749f0187b9a6c681cd5f881a" translate="yes" xml:space="preserve">
          <source>Warn about calls to allocation functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that specify zero bytes, including those to the built-in forms of the functions &lt;code&gt;aligned_alloc&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, and &lt;code&gt;realloc&lt;/code&gt;. Because the behavior of these functions when called with a zero size differs among implementations (and in the case of &lt;code&gt;realloc&lt;/code&gt; has been deprecated) relying on it may result in subtle portability bugs and should be avoided.</source>
          <target state="translated">Предупреждать о вызовах функций распределения, украшенных атрибутом &lt;code&gt;alloc_size&lt;/code&gt; , которые указывают нулевые байты, в том числе для встроенных форм функций &lt;code&gt;aligned_alloc&lt;/code&gt; , &lt;code&gt;alloca&lt;/code&gt; , &lt;code&gt;calloc&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; и &lt;code&gt;realloc&lt;/code&gt; . Поскольку поведение этих функций при вызове с нулевым размером различается в разных реализациях (а в случае &lt;code&gt;realloc&lt;/code&gt; не рекомендуется), использование этого метода может привести к незначительным ошибкам переносимости, и его следует избегать.</target>
        </trans-unit>
        <trans-unit id="3cff65779e3725cfbc2854d42263f2ace49a0bba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;snprintf&lt;/code&gt; and &lt;code&gt;vsnprintf&lt;/code&gt; that might result in output truncation. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives. Except as noted otherwise, the option uses the same logic</source>
          <target state="translated">Предупреждать о вызовах форматированных функций ввода / вывода, таких как &lt;code&gt;snprintf&lt;/code&gt; и &lt;code&gt;vsnprintf&lt;/code&gt; , которые могут привести к усечению вывода. Когда точное количество байтов, записанных директивой формата, не может быть определено во время компиляции, оно оценивается на основе эвристики, которая зависит от аргумента &lt;var&gt;level&lt;/var&gt; и от оптимизации. Хотя включение оптимизации в большинстве случаев повысит точность предупреждения, оно также может привести к ложным срабатываниям. Если не указано иное, опция использует ту же логику</target>
        </trans-unit>
        <trans-unit id="66472dc4cd87cc63c73cb46419c0fd90cf1906ba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;sprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; that might overflow the destination buffer. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives.</source>
          <target state="translated">Предупреждать о вызовах форматированных функций ввода / вывода, таких как &lt;code&gt;sprintf&lt;/code&gt; и &lt;code&gt;vsprintf&lt;/code&gt; , которые могут переполнить целевой буфер. Когда точное количество байтов, записанных директивой формата, не может быть определено во время компиляции, оно оценивается на основе эвристики, которая зависит от аргумента &lt;var&gt;level&lt;/var&gt; и от оптимизации. Хотя включение оптимизации в большинстве случаев повысит точность предупреждения, оно также может привести к ложным срабатываниям.</target>
        </trans-unit>
        <trans-unit id="8986e7105a9ec8665e2dbbf6296adf8b057bee04" translate="yes" xml:space="preserve">
          <source>Warn about calls to functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that attempt to allocate objects larger than the specified number of bytes, or where the result of the size computation in an integer type with infinite precision would exceed the value of &amp;lsquo;</source>
          <target state="translated">Предупреждать о вызовах функций, украшенных атрибутом &lt;code&gt;alloc_size&lt;/code&gt; , которые пытаются выделить объекты, размер которых превышает указанное количество байтов, или когда результат вычисления размера в целочисленном типе с бесконечной точностью превысит значение '</target>
        </trans-unit>
        <trans-unit id="88c937d55912c756c7716e6f943b38520ff30020" translate="yes" xml:space="preserve">
          <source>Warn about cases that are both questionable and easy to avoid. For example the compiler simplifies &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;. This level of</source>
          <target state="translated">Предупреждайте о случаях, которые одновременно сомнительны и которых легко избежать. Например, компилятор упрощает &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; до &lt;code&gt;1&lt;/code&gt; . Этот уровень</target>
        </trans-unit>
        <trans-unit id="179fecfde091b7cc90c5093c0b77e7c3ec453920" translate="yes" xml:space="preserve">
          <source>Warn about catch handlers that do not catch via reference. With</source>
          <target state="translated">Предупреждайте об обработчиках уловов,которые не ловят по ссылке.С помощью .</target>
        </trans-unit>
        <trans-unit id="5d56df9ae38e57af735866e84e0cdb01862c2396" translate="yes" xml:space="preserve">
          <source>Warn about certain constructs that behave differently in traditional and ISO C. Also warn about ISO C constructs that have no traditional C equivalent, and/or problematic constructs that should be avoided.</source>
          <target state="translated">Предупреждать об определенных конструкциях,которые ведут себя по-разному в традиционных и ИСО С.Также предупреждать о конструкциях ИСО С,которые не имеют традиционного С-эквивалента,и/или проблемных конструкциях,которых следует избегать.</target>
        </trans-unit>
        <trans-unit id="a5d45d6bdb2da602561cf609a54b37f21eccd57b" translate="yes" xml:space="preserve">
          <source>Warn about code affected by ABI changes. This includes code that may not be compatible with the vendor-neutral C++ ABI as well as the psABI for the particular target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208feed4ba7b2db7b751737e5df71463aa2d59a9" translate="yes" xml:space="preserve">
          <source>Warn about code that may have undefined semantics because of violations of sequence point rules in the C and C++ standards.</source>
          <target state="translated">Предупреждать о коде,который может иметь неопределенную семантику из-за нарушения правил точек следования в стандартах Си и Си++.</target>
        </trans-unit>
        <trans-unit id="120296c8df6378a5551d4a8157d2634bb8869dc7" translate="yes" xml:space="preserve">
          <source>Warn about constructions where there may be confusion to which &lt;code&gt;if&lt;/code&gt; statement an &lt;code&gt;else&lt;/code&gt; branch belongs. Here is an example of such a case:</source>
          <target state="translated">Предупреждать о конструкциях, в которых может возникнуть путаница, к которой принадлежит оператор &lt;code&gt;if&lt;/code&gt; и ветвь &lt;code&gt;else&lt;/code&gt; . Вот пример такого случая:</target>
        </trans-unit>
        <trans-unit id="5a68fb773b2ee57c56ecf208d21e354737b77e2a" translate="yes" xml:space="preserve">
          <source>Warn about conversions between address spaces in the case where the resulting address space is not contained in the incoming address space.</source>
          <target state="translated">Предупреждает о преобразовании между адресными пространствами в том случае,если результирующее адресное пространство не содержится во входящем адресном пространстве.</target>
        </trans-unit>
        <trans-unit id="0761a82a1e056ee411ecf4ae535a9dfad8b30dfc" translate="yes" xml:space="preserve">
          <source>Warn about declarations using the &lt;code&gt;alias&lt;/code&gt; and similar attributes whose target is incompatible with the type of the alias. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;.</source>
          <target state="translated">Предупреждать об объявлениях с использованием &lt;code&gt;alias&lt;/code&gt; и подобных атрибутов, цель которых несовместима с типом псевдонима. См. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Объявление атрибутов функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dad72b4f2b69c2d3e0c4a7712258c5c2819e85b8" translate="yes" xml:space="preserve">
          <source>Warn about deprecated uses of the &lt;code&gt;volatile&lt;/code&gt; qualifier. This includes postfix and prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; expressions of &lt;code&gt;volatile&lt;/code&gt;-qualified types, using simple assignments where the left operand is a &lt;code&gt;volatile&lt;/code&gt;-qualified non-class type for their value, compound assignments where the left operand is a &lt;code&gt;volatile&lt;/code&gt;-qualified non-class type, &lt;code&gt;volatile&lt;/code&gt;-qualified function return type, &lt;code&gt;volatile&lt;/code&gt;-qualified parameter type, and structured bindings of a &lt;code&gt;volatile&lt;/code&gt;-qualified type. This usage was deprecated in C++20.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f643480f69fb1c621533ba0cdd904776e7e1ef4b" translate="yes" xml:space="preserve">
          <source>Warn about duplicated conditions in an if-else-if chain. For instance, warn for the following code:</source>
          <target state="translated">Предупреждаю о дублировании условий в цепочке if-else-if.Например,предупредите о следующем коде:</target>
        </trans-unit>
        <trans-unit id="df67fcaf7adda5b83231c43ba06288b76e6d8f0b" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C11, but present in ISO C2X. For instance, warn about omitting the string in &lt;code&gt;_Static_assert&lt;/code&gt;, use of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7359f7ae633c3c242379554307ef603621fed1e" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C90, but present in ISO C99. For instance, warn about use of variable length arrays, &lt;code&gt;long long&lt;/code&gt; type, &lt;code&gt;bool&lt;/code&gt; type, compound literals, designated initializers, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">Предупредить о функциях, отсутствующих в ISO C90, но присутствующих в ISO C99. Например, предупреждать об использовании массивов переменной длины, типа &lt;code&gt;long long&lt;/code&gt; , типа &lt;code&gt;bool&lt;/code&gt; , составных литералов, назначенных инициализаторов и т. Д. Эта опция не зависит от стандартного режима. Предупреждения отключены в выражении, которое следует за &lt;code&gt;__extension__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="626c854c9715d516c67e89068f1bb76234cf669a" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C99, but present in ISO C11. For instance, warn about use of anonymous structures and unions, &lt;code&gt;_Atomic&lt;/code&gt; type qualifier, &lt;code&gt;_Thread_local&lt;/code&gt; storage-class specifier, &lt;code&gt;_Alignas&lt;/code&gt; specifier, &lt;code&gt;Alignof&lt;/code&gt; operator, &lt;code&gt;_Generic&lt;/code&gt; keyword, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">Предупредить о функциях, отсутствующих в ISO C99, но присутствующих в ISO C11. Например, предупреждать об использовании анонимных структур и объединений, квалификатора типа &lt;code&gt;_Atomic&lt;/code&gt; , &lt;code&gt;_Thread_local&lt;/code&gt; класса хранения &lt;code&gt;_Alignas&lt;/code&gt; спецификатора &lt;code&gt;Alignof&lt;/code&gt; оператора &lt;code&gt;_Generic&lt;/code&gt; ключевого слова _Generic и т. Д. Эта опция не зависит от стандартного режима. Предупреждения отключены в выражении, которое следует за &lt;code&gt;__extension__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="643ea2b6cbf0ea1bcfec495e08e3195164382b91" translate="yes" xml:space="preserve">
          <source>Warn about function pointers that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Note these are only possible candidates, not absolute ones. GCC guesses that function pointers with &lt;code&gt;format&lt;/code&gt; attributes that are used in assignment, initialization, parameter passing or return statements should have a corresponding &lt;code&gt;format&lt;/code&gt; attribute in the resulting type. I.e. the left-hand side of the assignment or initialization, the type of the parameter variable, or the return type of the containing function respectively should also have a &lt;code&gt;format&lt;/code&gt; attribute to avoid the warning.</source>
          <target state="translated">Предупреждать об указателях функций, которые могут быть кандидатами на атрибуты &lt;code&gt;format&lt;/code&gt; . Обратите внимание, что это только возможные кандидаты, а не абсолютные. GCC предполагает, что указатели функций с атрибутами &lt;code&gt;format&lt;/code&gt; , которые используются в операторах присваивания, инициализации, передачи параметров или возврата, должны иметь соответствующий атрибут &lt;code&gt;format&lt;/code&gt; в результирующем типе. Т.е. левая часть присвоения или инициализации, тип переменной параметра или тип возвращаемого значения содержащейся функции, соответственно, также должны иметь атрибут &lt;code&gt;format&lt;/code&gt; чтобы избежать предупреждения.</target>
        </trans-unit>
        <trans-unit id="bf987ef83f5d02774e29caf5a84aa7aa67743d4e" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for &lt;code&gt;cold&lt;/code&gt; attribute. This is based on static detection and generally only warns about functions which always leads to a call to another &lt;code&gt;cold&lt;/code&gt; function such as wrappers of C++ &lt;code&gt;throw&lt;/code&gt; or fatal error reporting functions leading to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3534585cbc01893459375a2f73a721f1390a46" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for &lt;code&gt;cold&lt;/code&gt; attribute. This is based on static detection and generally will only warn about functions which always leads to a call to another &lt;code&gt;cold&lt;/code&gt; function such as wrappers of C++ &lt;code&gt;throw&lt;/code&gt; or fatal error reporting functions leading to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">Предупреждать о функциях, которые могут быть кандидатами на атрибут &lt;code&gt;cold&lt;/code&gt; . Это основано на статическом обнаружении и обычно предупреждает только о функциях, которые всегда приводят к вызову другой &lt;code&gt;cold&lt;/code&gt; функции, такой как обертки C ++ &lt;code&gt;throw&lt;/code&gt; или функции сообщения о фатальных ошибках, приводящие к &lt;code&gt;abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5773c66378dee79865728b1022e5f1ddb94781" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for attributes &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;noreturn&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt;. The compiler only warns for functions visible in other compilation units or (in the case of &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;) if it cannot prove that the function returns normally. A function returns normally if it doesn&amp;rsquo;t contain an infinite loop or return abnormally by throwing, calling &lt;code&gt;abort&lt;/code&gt; or trapping. This analysis requires option</source>
          <target state="translated">Предупреждать о функциях , которые могут быть кандидатами для атрибутов &lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;noreturn&lt;/code&gt; или &lt;code&gt;malloc&lt;/code&gt; . Компилятор предупреждает только о функциях, видимых в других единицах компиляции или (в случае &lt;code&gt;pure&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; ), если он не может доказать, что функция возвращается нормально. Функция возвращается нормально, если она не содержит бесконечного цикла или ненормально возвращается, бросая, вызывая &lt;code&gt;abort&lt;/code&gt; или захват. Этот анализ требует опции</target>
        </trans-unit>
        <trans-unit id="97272a64aa6772a9d1f50422c6dbb8adfe294518" translate="yes" xml:space="preserve">
          <source>Warn about left shift overflows. This warning is enabled by default in C99 and C++11 modes (and newer).</source>
          <target state="translated">Предупреждаю о переполнении левой смены.Данное предупреждение включено по умолчанию в режимах C99 и C++11 (и более новых).</target>
        </trans-unit>
        <trans-unit id="cab17a3fd72f34df7821e30e584c4c51a37bba48" translate="yes" xml:space="preserve">
          <source>Warn about logical not used on the left hand side operand of a comparison. This option does not warn if the right operand is considered to be a boolean expression. Its purpose is to detect suspicious code like the following:</source>
          <target state="translated">Предупредить о логическом не используется на левой стороне операнд сравнения.Эта опция не предупреждает,если правый операнд считается булевым выражением.Ее целью является обнаружение подозрительного кода,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="48b82c0283a2915829a3ee6a3436cc1017b5ea05" translate="yes" xml:space="preserve">
          <source>Warn about macros defined in the main file that are unused. A macro is &lt;em&gt;used&lt;/em&gt; if it is expanded or tested for existence at least once. The preprocessor also warns if the macro has not been used at the time it is redefined or undefined.</source>
          <target state="translated">Предупреждать о неиспользуемых макросах, определенных в основном файле. Макрос &lt;em&gt;используется,&lt;/em&gt; если он раскрывается или проверяется на наличие хотя бы один раз. Препроцессор также предупреждает, если макрос не использовался во время переопределения или не определен.</target>
        </trans-unit>
        <trans-unit id="95a820d2e7a0805e0aa090310d1571c21efbd8ea" translate="yes" xml:space="preserve">
          <source>Warn about overriding virtual functions that are not marked with the &lt;code&gt;override&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b8fd61bdb1f1846bd01a97a7bd276155ea4f4c" translate="yes" xml:space="preserve">
          <source>Warn about overriding virtual functions that are not marked with the override keyword.</source>
          <target state="translated">Предупреждать о переопределении виртуальных функций,которые не отмечены ключевым словом переопределения.</target>
        </trans-unit>
        <trans-unit id="b83b9745dc97dfb351a27bd912c00da1a8c7a2f9" translate="yes" xml:space="preserve">
          <source>Warn about passing a null pointer for arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">Предупредить о передаче нулевого указателя для аргументов, отмеченных как требующие &lt;code&gt;nonnull&lt;/code&gt; атрибутом функции, отличным от NULL .</target>
        </trans-unit>
        <trans-unit id="6aa9959edf6bc4922ebb912c9a250384b3090f7c" translate="yes" xml:space="preserve">
          <source>Warn about placement new expressions with undefined behavior, such as constructing an object in a buffer that is smaller than the type of the object. For example, the placement new expression below is diagnosed because it attempts to construct an array of 64 integers in a buffer only 64 bytes large.</source>
          <target state="translated">Предупреждать о размещении новых выражений с неопределенным поведением,например,построение объекта в буфере,который меньше типа объекта.Например,приведенное ниже размещение нового выражения диагностируется,так как оно пытается построить массив из 64 целых чисел в буфере размером всего 64 байта.</target>
        </trans-unit>
        <trans-unit id="74d68b577061b92d5200eece3bb4104ac09a502f" translate="yes" xml:space="preserve">
          <source>Warn about redundant class-key and enum-key in references to class types and enumerated types in contexts where the key can be eliminated without causing an ambiguity. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185c654029973156a2e707b7e9ffcc02226e09a9" translate="yes" xml:space="preserve">
          <source>Warn about redundant semicolon after in-class function definition.</source>
          <target state="translated">Предупреждайте о избыточной точке с запятой после определения функции в классе.</target>
        </trans-unit>
        <trans-unit id="1ac1501030f2851b2643bb992cffb387fb33e66a" translate="yes" xml:space="preserve">
          <source>Warn about redundant semicolons after in-class function definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083bdeb1c857ab3b93f3cbf9b4f7687d0f51ffb4" translate="yes" xml:space="preserve">
          <source>Warn about string constants that are longer than the &amp;ldquo;minimum maximum&amp;rdquo; length specified in the C standard. Modern compilers generally allow string constants that are much longer than the standard&amp;rsquo;s minimum limit, but very portable programs should avoid using longer strings.</source>
          <target state="translated">Предупреждать о строковых константах, длина которых превышает &amp;laquo;минимальную максимальную&amp;raquo; длину, указанную в стандарте C. Современные компиляторы обычно допускают строковые константы, которые намного длиннее минимального предела стандарта, но очень переносимые программы должны избегать использования более длинных строк.</target>
        </trans-unit>
        <trans-unit id="e453618f3508cc5c8f222f7ad7869db1fe428a6f" translate="yes" xml:space="preserve">
          <source>Warn about suspicious operations on expressions of a boolean type. For instance, bitwise negation of a boolean is very likely a bug in the program. For C, this warning also warns about incrementing or decrementing a boolean, which rarely makes sense. (In C++, decrementing a boolean is always invalid. Incrementing a boolean is invalid in C++17, and deprecated otherwise.)</source>
          <target state="translated">Предупреждать о подозрительных операциях на выражениях булевого типа.Например,битовое отрицание булева типа очень вероятно является ошибкой в программе.Для C это предупреждение также предупреждает об инкременте или декременте булева,что редко имеет смысл.(В Си++декремент булева всегда недействителен.В Си++17 инкремент булева недействителен,а в противном случае он недействителен).</target>
        </trans-unit>
        <trans-unit id="2336eb6d6105fde77f9d067a2cdcc81228032540" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of logical operators in expressions. This includes using logical operators in contexts where a bit-wise operator is likely to be expected. Also warns when the operands of a logical operator are the same:</source>
          <target state="translated">Предупреждать о подозрительном использовании логических операторов в выражениях.Это включает в себя использование логических операторов в контекстах,где,скорее всего,ожидается битовый оператор.Также предупреждает,когда операндов логического оператора одно и то же:</target>
        </trans-unit>
        <trans-unit id="47cf408f4ecd083d50c4f6fada7dd8bdd9b93bb0" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of memory addresses. These include using the address of a function in a conditional expression, such as &lt;code&gt;void func(void); if (func)&lt;/code&gt;, and comparisons against the memory address of a string literal, such as &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt;. Such uses typically indicate a programmer error: the address of a function always evaluates to true, so their use in a conditional usually indicate that the programmer forgot the parentheses in a function call; and comparisons against string literals result in unspecified behavior and are not portable in C, so they usually indicate that the programmer intended to use &lt;code&gt;strcmp&lt;/code&gt;. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительном использовании адресов памяти. К ним относятся использование адреса функции в условном выражении, например &lt;code&gt;void func(void); if (func)&lt;/code&gt; и сравнения с адресом памяти строкового литерала, например &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt; . Такое использование обычно указывает на ошибку программиста: адрес функции всегда принимает значение true, поэтому их использование в условном выражении обычно указывает на то, что программист забыл круглые скобки в вызове функции; а сравнения со строковыми литералами приводят к неопределенному поведению и не переносятся в C, поэтому обычно указывают, что программист намеревался использовать &lt;code&gt;strcmp&lt;/code&gt; . Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="693b5ffe72b40cbff2e2c2d99e95d2c139392a00" translate="yes" xml:space="preserve">
          <source>Warn about the use of an uncasted &lt;code&gt;NULL&lt;/code&gt; as sentinel. When compiling only with GCC this is a valid sentinel, as &lt;code&gt;NULL&lt;/code&gt; is defined to &lt;code&gt;__null&lt;/code&gt;. Although it is a null pointer constant rather than a null pointer, it is guaranteed to be of the same size as a pointer. But this use is not portable across different compilers.</source>
          <target state="translated">Предупредить об использовании в качестве контрольного значения &lt;code&gt;NULL&lt;/code&gt; без преобразования . При компиляции только с GCC это действительный дозорный, поскольку &lt;code&gt;NULL&lt;/code&gt; определен как &lt;code&gt;__null&lt;/code&gt; . Хотя это константа нулевого указателя, а не нулевой указатель, гарантированно будет такого же размера, что и указатель. Но это использование не переносимо между разными компиляторами.</target>
        </trans-unit>
        <trans-unit id="047e09655cbc00205404926996b3c4d4165e9649" translate="yes" xml:space="preserve">
          <source>Warn about trampolines generated for pointers to nested functions. A trampoline is a small piece of data or code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. For some targets, it is made up of data only and thus requires no special treatment. But, for most targets, it is made up of code and thus requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">Предупреждайте о батутах,генерируемых для указателей на вложенные функции.Батут-это небольшой кусок данных или кода,который создаётся во время выполнения на стеке,когда берется адрес вложенной функции,и используется для косвенного вызова вложенной функции.Для некоторых целей он состоит только из данных и не требует специальной обработки.Но для большинства целей он состоит из кода и,таким образом,требует,чтобы стек был исполняемым,чтобы программа корректно работала.</target>
        </trans-unit>
        <trans-unit id="038f9bc926635b6b8fb6c2afe2d9bffe1c8b0f31" translate="yes" xml:space="preserve">
          <source>Warn about types with virtual methods where code quality would be improved if the type were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, declared in an anonymous namespace. This allows GCC to more aggressively devirtualize the polymorphic calls. This warning is more effective with link time optimization, where the information about the class hierarchy graph is more complete.</source>
          <target state="translated">Предупреждать о типах с виртуальными методами, в которых качество кода могло бы быть улучшено, если бы тип был объявлен с помощью спецификатора C ++ 11 &lt;code&gt;final&lt;/code&gt; или, если возможно, объявлен в анонимном пространстве имен. Это позволяет GCC более агрессивно девиртуализировать полиморфные вызовы. Это предупреждение более эффективно при оптимизации времени компоновки, когда информация о графе иерархии классов более полная.</target>
        </trans-unit>
        <trans-unit id="73632e708525f71bd06b07d2ceeba095433fda5a" translate="yes" xml:space="preserve">
          <source>Warn about types with virtual methods where code quality would be improved if the type were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, declared in an anonymous namespace. This allows GCC to more aggressively devirtualize the polymorphic calls. This warning is more effective with link-time optimization, where the information about the class hierarchy graph is more complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb96b1bde565bfb0748c8483dc57189a3190e4d" translate="yes" xml:space="preserve">
          <source>Warn about uninitialized variables that are initialized with themselves. Note this option can only be used with the</source>
          <target state="translated">Предупреждать об неинициализированных переменных,которые инициализируются сами собой.Обратите внимание,что эта опция может быть использована только с</target>
        </trans-unit>
        <trans-unit id="3e4a4254c8cb8b052f1898488cd3d24c1bac24c2" translate="yes" xml:space="preserve">
          <source>Warn about unsafe multiple statement macros that appear to be guarded by a clause such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, or &lt;code&gt;while&lt;/code&gt;, in which only the first statement is actually guarded after the macro is expanded.</source>
          <target state="translated">Предупреждать о небезопасных макросах с несколькими операторами, которые кажутся защищенными таким предложением, как &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; или &lt;code&gt;while&lt;/code&gt; , в котором только первый оператор фактически защищен после раскрытия макроса.</target>
        </trans-unit>
        <trans-unit id="f8ee6c4d50d98f8c61cc7719e0fc954354382683" translate="yes" xml:space="preserve">
          <source>Warn about uses of a comma expression within a subscripting expression. This usage was deprecated in C++2a. However, a comma expression wrapped in &lt;code&gt;( )&lt;/code&gt; is not deprecated. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c815119ab8450282a6819d07553d786431d0bc98" translate="yes" xml:space="preserve">
          <source>Warn about violations of the following style guidelines from Scott Meyers&amp;rsquo; Effective C++ series of books:</source>
          <target state="translated">Предупреждайте о нарушениях следующих рекомендаций по стилю из серии книг Скотта Мейерса по эффективному C ++:</target>
        </trans-unit>
        <trans-unit id="44cda8e3e380e8f31dd971fc6b0f31b237513dcc" translate="yes" xml:space="preserve">
          <source>Warn about virtual methods where code quality would be improved if the method were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, its type were declared in an anonymous namespace or with the &lt;code&gt;final&lt;/code&gt; specifier. This warning is more effective with link-time optimization, where the information about the class hierarchy graph is more complete. It is recommended to first consider suggestions of</source>
          <target state="translated">Предупреждать о виртуальных методах, где качество кода могло бы быть улучшено, если бы метод был объявлен с помощью спецификатора &lt;code&gt;final&lt;/code&gt; C ++ 11 или, если возможно, его тип был объявлен в анонимном пространстве имен или с помощью спецификатора &lt;code&gt;final&lt;/code&gt; . Это предупреждение более эффективно при оптимизации времени компоновки, когда информация о графе иерархии классов более полная. Рекомендуется в первую очередь рассмотреть предложения</target>
        </trans-unit>
        <trans-unit id="a7afe94e27a31f1703de27fbd7f470c3a1318706" translate="yes" xml:space="preserve">
          <source>Warn for any shadowing. Same as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0054cd94b54785ab2123fe3874e7e050ab2b5ebb" translate="yes" xml:space="preserve">
          <source>Warn for calls to &lt;code&gt;strcmp&lt;/code&gt; and &lt;code&gt;strncmp&lt;/code&gt; whose result is determined to be either zero or non-zero in tests for such equality owing to the length of one argument being greater than the size of the array the other argument is stored in (or the bound in the case of &lt;code&gt;strncmp&lt;/code&gt;). Such calls could be mistakes. For example, the call to &lt;code&gt;strcmp&lt;/code&gt; below is diagnosed because its result is necessarily non-zero irrespective of the contents of the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3e052e75298edad5e44ae2d0677574dff86d7c" translate="yes" xml:space="preserve">
          <source>Warn for calls to bounded string manipulation functions such as &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, and &lt;code&gt;stpncpy&lt;/code&gt; that may either truncate the copied string or leave the destination unchanged.</source>
          <target state="translated">Предупреждать о вызовах функций обработки ограниченной строки, таких как &lt;code&gt;strncat&lt;/code&gt; , &lt;code&gt;strncpy&lt;/code&gt; и &lt;code&gt;stpncpy&lt;/code&gt; , которые могут либо усечь скопированную строку, либо оставить место назначения без изменений.</target>
        </trans-unit>
        <trans-unit id="97f52c63875e1d71f753bc97c51fe3992eac28f3" translate="yes" xml:space="preserve">
          <source>Warn for calls to standard functions that compute the absolute value of an argument when a more appropriate standard function is available. For example, calling &lt;code&gt;abs(3.14)&lt;/code&gt; triggers the warning because the appropriate function to call to compute the absolute value of a double argument is &lt;code&gt;fabs&lt;/code&gt;. The option also triggers warnings when the argument in a call to such a function has an unsigned type. This warning can be suppressed with an explicit type cast and it is also enabled by</source>
          <target state="translated">Предупреждать о вызовах стандартных функций, которые вычисляют абсолютное значение аргумента, когда доступна более подходящая стандартная функция. Например, вызов &lt;code&gt;abs(3.14)&lt;/code&gt; вызывает предупреждение, потому что соответствующая функция, вызываемая для вычисления абсолютного значения двойного аргумента, - это &lt;code&gt;fabs&lt;/code&gt; . Эта опция также вызывает предупреждения, когда аргумент в вызове такой функции имеет беззнаковый тип. Это предупреждение можно подавить с помощью явного приведения типа, и оно также включается</target>
        </trans-unit>
        <trans-unit id="9ad10a9456bb52278d89d1d0fb57ad0944a92b5e" translate="yes" xml:space="preserve">
          <source>Warn for calls to string manipulation functions such as &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;strcpy&lt;/code&gt; that are determined to overflow the destination buffer. The optional argument is one greater than the type of Object Size Checking to perform to determine the size of the destination. See &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Object Size Checking&lt;/a&gt;. The argument is meaningful only for functions that operate on character arrays but not for raw memory functions like &lt;code&gt;memcpy&lt;/code&gt; which always make use of Object Size type-0. The option also warns for calls that specify a size in excess of the largest possible object or at most &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; bytes. The option produces the best results with optimization enabled but can detect a small subset of simple buffer overflows even without optimization in calls to the GCC built-in functions like &lt;code&gt;__builtin_memcpy&lt;/code&gt; that correspond to the standard functions. In any case, the option warns about just a subset of buffer overflows detected by the corresponding overflow checking built-ins. For example, the option issues a warning for the &lt;code&gt;strcpy&lt;/code&gt; call below because it copies at least 5 characters (the string &lt;code&gt;&quot;blue&quot;&lt;/code&gt; including the terminating NUL) into the buffer of size 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5733f483a0e2d12a12ef399d58192ff21069495" translate="yes" xml:space="preserve">
          <source>Warn for calls to string manipulation functions such as &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;strcpy&lt;/code&gt; that are determined to overflow the destination buffer. The optional argument is one greater than the type of Object Size Checking to perform to determine the size of the destination. See &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Object Size Checking&lt;/a&gt;. The argument is meaningful only for functions that operate on character arrays but not for raw memory functions like &lt;code&gt;memcpy&lt;/code&gt; which always make use of Object Size type-0. The option also warns for calls that specify a size in excess of the largest possible object or at most &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; bytes. The option produces the best results with optimization enabled but can detect a small subset of simple buffer overflows even without optimization in calls to the GCC built-in functions like &lt;code&gt;__builtin_memcpy&lt;/code&gt; that correspond to the standard functions. In any case, the option warns about just a subset of buffer overflows detected by the corresponding overflow checking built-ins. For example, the option will issue a warning for the &lt;code&gt;strcpy&lt;/code&gt; call below because it copies at least 5 characters (the string &lt;code&gt;&quot;blue&quot;&lt;/code&gt; including the terminating NUL) into the buffer of size 4.</source>
          <target state="translated">Предупреждать о вызовах функций обработки строк, таких как &lt;code&gt;memcpy&lt;/code&gt; и &lt;code&gt;strcpy&lt;/code&gt; , которые определены как переполнение целевого буфера. Необязательный аргумент на единицу больше, чем тип проверки размера объекта, выполняемой для определения размера места назначения. См. &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Проверка размера объекта&lt;/a&gt; . Аргумент имеет смысл только для функций, которые работают с массивами символов, но не для функций необработанной памяти, таких как &lt;code&gt;memcpy&lt;/code&gt; , которые всегда используют тип 0 размера объекта. Эта опция также предупреждает о вызовах, в которых указан размер, превышающий максимально возможный объект или не более &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; байт. Этот параметр дает наилучшие результаты при включенной оптимизации, но может обнаруживать небольшое подмножество простых переполнений буфера даже без оптимизации при вызовах встроенных функций GCC, таких как &lt;code&gt;__builtin_memcpy&lt;/code&gt; , которые соответствуют стандартным функциям. В любом случае эта опция предупреждает только о подмножестве переполнений буфера, обнаруженных соответствующими встроенными модулями проверки переполнения. Например, опция выдаст предупреждение для приведенного ниже вызова &lt;code&gt;strcpy&lt;/code&gt; , потому что он копирует не менее 5 символов (строка &lt;code&gt;&quot;blue&quot;&lt;/code&gt; включая завершающий NUL) в буфер размером 4.</target>
        </trans-unit>
        <trans-unit id="ea89d9fe51cb214a220766e4af0abed7f830d316" translate="yes" xml:space="preserve">
          <source>Warn for cases where adding an attribute may be beneficial. The attributes currently supported are listed below.</source>
          <target state="translated">Предупреждение для случаев,когда добавление атрибута может быть полезным.Поддерживаемые в настоящее время атрибуты перечислены ниже.</target>
        </trans-unit>
        <trans-unit id="8436e41e82368d15262acc8884e5704ddb1ce7dc" translate="yes" xml:space="preserve">
          <source>Warn for conditionally-supported (C++11 [intro.defs]) constructs.</source>
          <target state="translated">Предупреждение для условно поддерживаемых (C++11 [intro.defs])конструкций.</target>
        </trans-unit>
        <trans-unit id="dfa0757341b82b17ea7e94be689ca4eb4aea75d9" translate="yes" xml:space="preserve">
          <source>Warn for declarations of structs, classes, and class templates and their specializations with a class-key that does not match either the definition or the first declaration if no definition is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd0db7c59c0ac572b0cd3ff62ca85c741d9e547" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may alter a value. This includes conversions between real and integer, like &lt;code&gt;abs (x)&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;; conversions between signed and unsigned, like &lt;code&gt;unsigned ui = -1&lt;/code&gt;; and conversions to smaller types, like &lt;code&gt;sqrtf (M_PI)&lt;/code&gt;. Do not warn for explicit casts like &lt;code&gt;abs
((int) x)&lt;/code&gt; and &lt;code&gt;ui = (unsigned) -1&lt;/code&gt;, or if the value is not changed by the conversion like in &lt;code&gt;abs (2.0)&lt;/code&gt;. Warnings about conversions between signed and unsigned integers can be disabled by using</source>
          <target state="translated">Предупреждать о неявных преобразованиях, которые могут изменить значение. Это включает преобразование между действительным и целым числом, например, &lt;code&gt;abs (x)&lt;/code&gt; , когда &lt;code&gt;x&lt;/code&gt; равно &lt;code&gt;double&lt;/code&gt; ; преобразования между знаком и без знака, например, &lt;code&gt;unsigned ui = -1&lt;/code&gt; ; и преобразование в более мелкие типы, например &lt;code&gt;sqrtf (M_PI)&lt;/code&gt; . Не предупреждать о явных приведениях, таких как &lt;code&gt;abs ((int) x)&lt;/code&gt; и &lt;code&gt;ui = (unsigned) -1&lt;/code&gt; , или если значение не изменяется в результате преобразования, как в &lt;code&gt;abs (2.0)&lt;/code&gt; . Предупреждения о преобразованиях между целыми числами со знаком и без знака можно отключить с помощью</target>
        </trans-unit>
        <trans-unit id="ec1638cbd7bdbbe5cf0d16d8253b596c446311e3" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may change the sign of an integer value, like assigning a signed integer expression to an unsigned integer variable. An explicit cast silences the warning. In C, this option is enabled also by</source>
          <target state="translated">Предупреждать о неявных превращениях,которые могут изменить знак целочисленного значения,например,присваивание знакового целого выражения беззнаковой целочисленной переменной.Явное приведение замалчивает предупреждение.В языке C эта опция также включается с помощью</target>
        </trans-unit>
        <trans-unit id="97be0057bd1773b0bcfe31a7fd58f64b07846102" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that reduce the precision of a real value. This includes conversions from real to integer, and from higher precision real to lower precision real values. This option is also enabled by</source>
          <target state="translated">Предупреждайте за неявные преобразования,которые снижают точность реального значения.Это включает в себя преобразования из вещественного в целое,а также из вещественного с большей точностью в вещественное с меньшей точностью.Эта опция также включается при помощи</target>
        </trans-unit>
        <trans-unit id="fba779234a6e85d8e28133f5b96c546a4b460be1" translate="yes" xml:space="preserve">
          <source>Warn for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</source>
          <target state="translated">Предупреждать о &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;вызовах __atomic Builtins&lt;/a&gt; , &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt; и атомарных универсальных функций C11 с аргументом согласованности памяти, который либо недопустим для операции, либо выходит за пределы диапазона значений перечисления &lt;code&gt;memory_order&lt;/code&gt; . Например, поскольку встроенные модули &lt;code&gt;__atomic_store&lt;/code&gt; и &lt;code&gt;__atomic_store_n&lt;/code&gt; определены только для ослабленных, освобожденных и последовательно согласованных порядков памяти, диагностируется следующий код:</target>
        </trans-unit>
        <trans-unit id="588f265a9e502d85c1dc2042e355d13326591d0f" translate="yes" xml:space="preserve">
          <source>Warn for obsolescent usages, according to the C Standard, in a declaration. For example, warn if storage-class specifiers like &lt;code&gt;static&lt;/code&gt; are not the first things in a declaration. This warning is also enabled by</source>
          <target state="translated">Предупреждать об устаревшем использовании в соответствии со стандартом C. Например, предупредите, если спецификаторы класса хранения, такие как &lt;code&gt;static&lt;/code&gt; , не являются первыми в объявлении. Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="e259b4649f2c39d620aa79263dfa4900b1e91328" translate="yes" xml:space="preserve">
          <source>Warn for pointer argument passing or assignment with different signedness. This option is only supported for C and Objective-C. It is implied by</source>
          <target state="translated">Предупреждение о передаче аргумента указателя или присваивании с различной подписью.Эта опция поддерживается только для C и Objective-C.Это подразумевается</target>
        </trans-unit>
        <trans-unit id="9ff91ea12bc4958bf94b9d94062e90a35c47ff2b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function where the second argument is not zero and the third argument is zero. For example, the call &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; is diagnosed because &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; was meant instead. The diagnostic is only emitted if the third argument is a literal zero. Otherwise, if it is an expression that is folded to zero, or a cast of zero to some type, it is far less likely that the arguments have been mistakenly transposed and no warning is emitted. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительных вызовах встроенной функции &lt;code&gt;memset&lt;/code&gt; , когда второй аргумент не равен нулю, а третий аргумент равен нулю. Например, вызов &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; диагностируется, потому что вместо него имелось в виду &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; . Диагностическое сообщение выдается только в том случае, если третий аргумент равен нулю. В противном случае, если это выражение, свернутое до нуля, или приведение нуля к какому-либо типу, гораздо менее вероятно, что аргументы были ошибочно транспонированы и предупреждение не выдается. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="bc6dbae9a566682d74e9a96f0ac749b8042dc5bb" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function, if the first argument references an array, and the third argument is a number equal to the number of elements, but not equal to the size of the array in memory. This indicates that the user has omitted a multiplication by the element size. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительных вызовах встроенной функции &lt;code&gt;memset&lt;/code&gt; , если первый аргумент ссылается на массив, а третий аргумент является числом, равным количеству элементов, но не равным размеру массива в памяти. Это означает, что пользователь пропустил умножение на размер элемента. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="d71f136265b6596c9fcf21bacafb65164bba32b6" translate="yes" xml:space="preserve">
          <source>Warn for suspicious divisions of two sizeof expressions that divide the pointer size by the element size, which is the usual way to compute the array size but won&amp;rsquo;t work out correctly with pointers. This warning warns e.g. about &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительных делениях двух выражений sizeof, которые делят размер указателя на размер элемента, что является обычным способом вычисления размера массива, но не работает правильно с указателями. Это предупреждение предупреждает, например, о &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; если &lt;code&gt;ptr&lt;/code&gt; не массив, а указатель. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="eb46193b49397250439f9bab61fa46107f1cb89b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious length parameters to certain string and memory built-in functions if the argument uses &lt;code&gt;sizeof&lt;/code&gt;. This warning triggers for example for &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer, and suggests a possible fix, or about &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt;.</source>
          <target state="translated">Предупреждать о параметрах подозрительной длины для определенных строковых и встроенных функций памяти, если аргумент использует &lt;code&gt;sizeof&lt;/code&gt; . Это предупреждение срабатывает, например, для &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; если &lt;code&gt;ptr&lt;/code&gt; - не массив, а указатель и предлагает возможное исправление, или о &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="474691b4f69f5e3fa5e5d8572e94d30c04b806ca" translate="yes" xml:space="preserve">
          <source>Warn for suspicious use of integer values where boolean values are expected, such as conditional expressions (?:) using non-boolean integer constants in boolean context, like &lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt;. Or left shifting of signed integers in boolean context, like &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt;. Likewise for all kinds of multiplications regardless of the data type. This warning is enabled by</source>
          <target state="translated">Предупреждать о подозрительном использовании целочисленных значений, где ожидаются логические значения, например условных выражений (? :) с использованием небулевых целочисленных констант в логическом контексте, например &lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt; . Или сдвиг влево целых чисел со знаком в логическом контексте, например &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt; , То же самое для всех видов умножения независимо от типа данных. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="ef3f0d67d9be730bb5bb60eec12cdf29a3590cd3" translate="yes" xml:space="preserve">
          <source>Warn for variables that might be changed by &lt;code&gt;longjmp&lt;/code&gt; or &lt;code&gt;vfork&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">Предупреждать о переменных, которые могут быть изменены &lt;code&gt;longjmp&lt;/code&gt; или &lt;code&gt;vfork&lt;/code&gt; . Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="3e9c6b5adfd39a2b86ea4ceeac61ae5e6ae30cf1" translate="yes" xml:space="preserve">
          <source>Warn if &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2e7578a65337ecde9cfa288e81a35cf44426a6" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;long long&lt;/code&gt; type is used. This is enabled by either</source>
          <target state="translated">Предупреждать, если используется &lt;code&gt;long long&lt;/code&gt; шрифт. Это обеспечивается либо</target>
        </trans-unit>
        <trans-unit id="e19f1630667f871b7fea15d47a722bf79ecb0d1d" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, either explicitly in an &lt;code&gt;@interface&lt;/code&gt; or &lt;code&gt;@protocol&lt;/code&gt; declaration, or implicitly in an &lt;code&gt;@implementation&lt;/code&gt; section. This option always performs its checks as soon as a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression is found, while</source>
          <target state="translated">Предупреждать, если &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; выражение @selector (&amp;hellip;), относящееся к необъявленному селектору. Селектор считаются необъявленным , если ни один метод с таким именем не был объявлен до &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; выражения, либо в явном виде в &lt;code&gt;@interface&lt;/code&gt; или &lt;code&gt;@protocol&lt;/code&gt; декларации, или неявно в &lt;code&gt;@implementation&lt;/code&gt; разделе. Эта опция всегда выполняет свои проверки, как только будет найдено выражение &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; , а</target>
        </trans-unit>
        <trans-unit id="004d33c975e481dfebbcb509835b3167b8da9eba" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;goto&lt;/code&gt; statement or a &lt;code&gt;switch&lt;/code&gt; statement jumps forward across the initialization of a variable, or jumps backward to a label after the variable has been initialized. This only warns about variables that are initialized when they are declared. This warning is only supported for C and Objective-C; in C++ this sort of branch is an error in any case.</source>
          <target state="translated">Предупреждать, если &lt;code&gt;goto&lt;/code&gt; или оператор &lt;code&gt;switch&lt;/code&gt; перескакивает вперед через инициализацию переменной или перескакивает назад к метке после инициализации переменной. Это только предупреждает о переменных, которые инициализируются при объявлении. Это предупреждение поддерживается только для C и Objective-C; в C ++ такая ветвь в любом случае является ошибкой.</target>
        </trans-unit>
        <trans-unit id="70a205e11ff52468e2abea9748f0e8471729efe0" translate="yes" xml:space="preserve">
          <source>Warn if a built-in function is declared with an incompatible signature or as a non-function, or when a built-in function declared with a type that does not include a prototype is called with arguments whose promoted types do not match those expected by the function. When</source>
          <target state="translated">Предупреждать,если встроенная функция объявлена с несовместимой сигнатурой или как нефункция,или если встроенная функция,объявленная с типом,не включающим прототип,вызывается с аргументами,чьи продвигаемые типы не соответствуют ожидаемым функцией.Когда .</target>
        </trans-unit>
        <trans-unit id="7e0b0c17d1b6ef946e72a0839cb1ce3047e47301" translate="yes" xml:space="preserve">
          <source>Warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage. If a type A depends on a type B with no or internal linkage, defining it in multiple translation units would be an ODR violation because the meaning of B is different in each translation unit. If A only appears in a single translation unit, the best way to silence the warning is to give it internal linkage by putting it in an anonymous namespace as well. The compiler doesn&amp;rsquo;t give this warning for types defined in the main .C file, as those are unlikely to have multiple definitions.</source>
          <target state="translated">Предупреждать, если тип класса имеет базу или поле, тип которого использует анонимное пространство имен или зависит от типа без связи. Если тип A зависит от типа B, не имеющего внутренней связи или не имеющего внутренней связи, определение его в нескольких единицах трансляции будет нарушением ODR, поскольку значение B отличается в каждой единице трансляции. Если A появляется только в одной единице перевода, лучший способ заглушить предупреждение - это дать ему внутреннюю ссылку, поместив его также в анонимное пространство имен. Компилятор не выдает это предупреждение для типов, определенных в основном файле .C, поскольку они вряд ли будут иметь несколько определений.</target>
        </trans-unit>
        <trans-unit id="f50d7f18228e548a744dc4a11054b6259740a50d" translate="yes" xml:space="preserve">
          <source>Warn if a comparison is always true or always false due to the limited range of the data type, but do not warn for constant expressions. For example, warn if an unsigned variable is compared against zero with &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">Предупреждать, если сравнение всегда верно или всегда ложно из-за ограниченного диапазона типа данных, но не предупреждать о постоянных выражениях. Например, предупредить, если беззнаковая переменная сравнивается с нулем с помощью &lt;code&gt;&amp;lt;&lt;/code&gt; или &lt;code&gt;&amp;gt;=&lt;/code&gt; . Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="2a11d0f858be1c6e9bc24aa3b844f38a2b441160" translate="yes" xml:space="preserve">
          <source>Warn if a declaration has duplicate &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restrict&lt;/code&gt; or &lt;code&gt;_Atomic&lt;/code&gt; specifier. This warning is enabled by</source>
          <target state="translated">Предупреждать, если в объявлении есть повторяющиеся спецификаторы &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; , &lt;code&gt;restrict&lt;/code&gt; или &lt;code&gt;_Atomic&lt;/code&gt; . Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="435844d61c42ac3708481fd4e2d3779e1e2c4fcb" translate="yes" xml:space="preserve">
          <source>Warn if a function is declared or defined without specifying the argument types. (An old-style function definition is permitted without a warning if preceded by a declaration that specifies the argument types.)</source>
          <target state="translated">Предупреждать,если функция объявлена или определена без указания типов аргументов.(Определение функции по старому стилю допускается без предупреждения,если ему предшествует объявление,в котором указываются типы аргументов).</target>
        </trans-unit>
        <trans-unit id="a760172e23a18bb5477be698491bcdf520546606" translate="yes" xml:space="preserve">
          <source>Warn if a function that is declared as inline cannot be inlined. Even with this option, the compiler does not warn about failures to inline functions declared in system headers.</source>
          <target state="translated">Предупреждать,если функция,объявленная как inline,не может быть включена.Даже при такой опции компилятор не предупреждает о сбоях встроенных функций,объявленных в системных заголовках.</target>
        </trans-unit>
        <trans-unit id="8022445f9b194569635957ab8997ae493df541b3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous declaration. Do so even if the definition itself provides a prototype. Use this option to detect global functions that are not declared in header files. In C, no warnings are issued for functions with previous non-prototype declarations; use</source>
          <target state="translated">Предупреждать,если глобальная функция определена без предыдущего объявления.Делайте это,даже если само определение предоставляет прототип.Использовать эту опцию для обнаружения глобальных функций,которые не объявлены в заголовочных файлах.В C предупреждение не выдается для функций с предыдущим непрототипным объявлением;использовать</target>
        </trans-unit>
        <trans-unit id="8accbb9b2caefa3a198b26af7aaf7ecef01e8cb3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous prototype declaration. This warning is issued even if the definition itself provides a prototype. Use this option to detect global functions that do not have a matching prototype declaration in a header file. This option is not valid for C++ because all function declarations provide prototypes and a non-matching declaration declares an overload rather than conflict with an earlier declaration. Use</source>
          <target state="translated">Предупреждать,если глобальная функция определена без предыдущего объявления прототипа.Это предупреждение выдается,даже если само определение предоставляет прототип.Используйте эту опцию для обнаружения глобальных функций,которые не имеют соответствующего объявления прототипа в заголовочном файле.Эта опция не действительна для C++,так как все объявления функций предоставляют прототипы,а несовпадающее объявление декларирует перегрузку,а не конфликт с более ранним объявлением.Использовать .</target>
        </trans-unit>
        <trans-unit id="158841ec1502166264ebd7700487b8265d3a7024" translate="yes" xml:space="preserve">
          <source>Warn if a pointer is compared with a zero character constant. This usually means that the pointer was meant to be dereferenced. For example:</source>
          <target state="translated">Предупредить,если указатель сравнивается с нулевой символьной константой.Обычно это означает,что указатель должен быть разыменован.Например:</target>
        </trans-unit>
        <trans-unit id="cc6737ba51245ef04a02acb681eeef00c75f1a8a" translate="yes" xml:space="preserve">
          <source>Warn if a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) is found in the search path but cannot be used.</source>
          <target state="translated">Предупреждать, если предварительно скомпилированный заголовок (см. &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Предварительно скомпилированные заголовки&lt;/a&gt; ) найден в пути поиска, но не может быть использован.</target>
        </trans-unit>
        <trans-unit id="0939e5ffcf8a00c23be50c55ee10373ce78e992e" translate="yes" xml:space="preserve">
          <source>Warn if a prototype causes a type conversion that is different from what would happen to the same argument in the absence of a prototype. This includes conversions of fixed point to floating and vice versa, and conversions changing the width or signedness of a fixed-point argument except when the same as the default promotion.</source>
          <target state="translated">Предупредить,если прототип вызывает приведение типа,отличное от того,что случилось бы с тем же аргументом при отсутствии прототипа.Это включает в себя приведение фиксированной точки к плавающей и наоборот,а также приведение,изменяющее ширину или подпись аргумента с фиксированной точкой,за исключением случаев,когда оно совпадает с прототипом по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f0026b1975a3aa571d75e5560f23067faee1ed8d" translate="yes" xml:space="preserve">
          <source>Warn if a register variable is declared volatile. The volatile modifier does not inhibit all optimizations that may eliminate reads and/or writes to register variables. This warning is enabled by</source>
          <target state="translated">Предупреждать,если переменная регистра объявлена волатильной.Модификатор volatile не запрещает все оптимизации,которые могут устранить чтение и/или запись в регистровые переменные.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="3798bc740d5ed1fe194f654e04bcdb3d1c47efb1" translate="yes" xml:space="preserve">
          <source>Warn if a requested optimization pass is disabled. This warning does not generally indicate that there is anything wrong with your code; it merely indicates that GCC&amp;rsquo;s optimizers are unable to handle the code effectively. Often, the problem is that your code is too big or too complex; GCC refuses to optimize programs when the optimization itself is likely to take inordinate amounts of time.</source>
          <target state="translated">Предупреждать, если запрошенный проход оптимизации отключен. Это предупреждение обычно не означает, что с вашим кодом что-то не так; это просто указывает на то, что оптимизаторы GCC не могут эффективно обрабатывать код. Часто проблема в том, что ваш код слишком большой или слишком сложный; GCC отказывается оптимизировать программы, когда сама оптимизация может занять чрезмерно много времени.</target>
        </trans-unit>
        <trans-unit id="13c5db18900b8a64496f744ccfd5e2648bd6cc79" translate="yes" xml:space="preserve">
          <source>Warn if a self-comparison always evaluates to true or false. This warning detects various mistakes such as:</source>
          <target state="translated">Предупреждайте,если самосравнение всегда оценивается как истинное или ложное.Это предупреждение обнаруживает различные ошибки,например:</target>
        </trans-unit>
        <trans-unit id="3ddcbce9d2796dc0f4331ea0e609fc2579e95907" translate="yes" xml:space="preserve">
          <source>Warn if a structure field with explicitly specified alignment in a packed struct or union is misaligned. For example, a warning will be issued on &lt;code&gt;struct S&lt;/code&gt;, like, &lt;code&gt;warning: alignment 1 of
'struct S' is less than 8&lt;/code&gt;, in this code:</source>
          <target state="translated">Предупреждать, если поле структуры с явно указанным выравниванием в упакованной структуре или объединении не выровнено. Например, для &lt;code&gt;struct S&lt;/code&gt; будет выдано предупреждение , например, &lt;code&gt;warning: alignment 1 of 'struct S' is less than 8&lt;/code&gt; в этом коде:</target>
        </trans-unit>
        <trans-unit id="4090da0abd58db5d6b3c1df786fa78fbd44ccb0c" translate="yes" xml:space="preserve">
          <source>Warn if a structure is given the packed attribute, but the packed attribute has no effect on the layout or size of the structure. Such structures may be mis-aligned for little benefit. For instance, in this code, the variable &lt;code&gt;f.x&lt;/code&gt; in &lt;code&gt;struct bar&lt;/code&gt; is misaligned even though &lt;code&gt;struct bar&lt;/code&gt; does not itself have the packed attribute:</source>
          <target state="translated">Предупреждать, если структуре задан упакованный атрибут, но упакованный атрибут не влияет на макет или размер структуры. Такие структуры могут быть неправильно выровнены с небольшой выгодой. Например, в этом коде переменная &lt;code&gt;f.x&lt;/code&gt; в &lt;code&gt;struct bar&lt;/code&gt; смещена, хотя сама &lt;code&gt;struct bar&lt;/code&gt; не имеет упакованного атрибута:</target>
        </trans-unit>
        <trans-unit id="25445489d5b31008c73b432793637e0936c19aa4" translate="yes" xml:space="preserve">
          <source>Warn if a structure&amp;rsquo;s initializer has some fields missing. For example, the following code causes such a warning, because &lt;code&gt;x.h&lt;/code&gt; is implicitly zero:</source>
          <target state="translated">Предупреждать, если в инициализаторе структуры отсутствуют некоторые поля. Например, следующий код вызывает такое предупреждение, потому что &lt;code&gt;x.h&lt;/code&gt; неявно равен нулю:</target>
        </trans-unit>
        <trans-unit id="ff8391aca57a7124434de4ac423b8ea2b9835ac5" translate="yes" xml:space="preserve">
          <source>Warn if a user-supplied include directory does not exist.</source>
          <target state="translated">Предупреждайте,если пользовательский каталог include не существует.</target>
        </trans-unit>
        <trans-unit id="3fc14a4903f34179ede0f1ca4ae1ec5c8d1b70b1" translate="yes" xml:space="preserve">
          <source>Warn if a variable-length array is used in the code.</source>
          <target state="translated">Предупредить,если в коде используется массив переменной длины.</target>
        </trans-unit>
        <trans-unit id="36f8e0d2c860d788d014b0fd6079fd78b6555ede" translate="yes" xml:space="preserve">
          <source>Warn if an &lt;code&gt;extern&lt;/code&gt; declaration is encountered within a function.</source>
          <target state="translated">Предупреждать, если в функции встречается объявление &lt;code&gt;extern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c855533d1ec7d76088394ed75a6651912c2d055e" translate="yes" xml:space="preserve">
          <source>Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for &lt;code&gt;a&lt;/code&gt; is not fully bracketed, but that for &lt;code&gt;b&lt;/code&gt; is fully bracketed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a938c70ebc261d86f7b298216ca1b2a1c719c46" translate="yes" xml:space="preserve">
          <source>Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for &lt;code&gt;a&lt;/code&gt; is not fully bracketed, but that for &lt;code&gt;b&lt;/code&gt; is fully bracketed. This warning is enabled by</source>
          <target state="translated">Предупреждать, если инициализатор агрегата или объединения не полностью заключен в квадратные скобки. В следующем примере инициализатор для &lt;code&gt;a&lt;/code&gt; не полностью заключен в квадратные скобки, но для &lt;code&gt;b&lt;/code&gt; полностью заключен в квадратные скобки. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="13b8026e8132cdf11c73019d5520d0d0def0ca31" translate="yes" xml:space="preserve">
          <source>Warn if an array subscript has type &lt;code&gt;char&lt;/code&gt;. This is a common cause of error, as programmers often forget that this type is signed on some machines. This warning is enabled by</source>
          <target state="translated">Предупреждать, если индекс массива имеет тип &lt;code&gt;char&lt;/code&gt; . Это частая причина ошибок, поскольку программисты часто забывают, что этот тип подписан на некоторых машинах. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="4eadd49680011e5fcccbd2afb576905c49ae4f6b" translate="yes" xml:space="preserve">
          <source>Warn if an automatic variable is used without first being initialized or if a variable may be clobbered by a &lt;code&gt;setjmp&lt;/code&gt; call. In C++, warn if a non-static reference or non-static &lt;code&gt;const&lt;/code&gt; member appears in a class without constructors.</source>
          <target state="translated">Предупреждать, если автоматическая переменная используется без предварительной инициализации или если переменная может быть заблокирована вызовом &lt;code&gt;setjmp&lt;/code&gt; . В C ++ предупреждать, если нестатическая ссылка или нестатический &lt;code&gt;const&lt;/code&gt; член появляется в классе без конструкторов.</target>
        </trans-unit>
        <trans-unit id="2a9ffd06ffd4ebefd83ee96ccd8e667d7dde6ed0" translate="yes" xml:space="preserve">
          <source>Warn if an automatic variable is used without first being initialized. In C++, warn if a non-static reference or non-static &lt;code&gt;const&lt;/code&gt; member appears in a class without constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1ee512cf2decbbe83cea7bedf87603b46e0326" translate="yes" xml:space="preserve">
          <source>Warn if an empty body occurs in an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; or &lt;code&gt;do
while&lt;/code&gt; statement. This warning is also enabled by</source>
          <target state="translated">Предупреждать, если в операторе &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; или &lt;code&gt;do while&lt;/code&gt; встречается пустое тело . Это предупреждение также активируется</target>
        </trans-unit>
        <trans-unit id="383fdc3973b7b5cc3531ea392827d8edfbd6eb85" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field with side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;). This warning is enabled by default.</source>
          <target state="translated">Предупреждать, если инициализированное поле с побочными эффектами отменяется при использовании назначенных инициализаторов (см. &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Назначенные инициализаторы&lt;/a&gt; ). Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fdf68e08c13104db975e1e1b5bfffcc9f671b2dc" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field without side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;).</source>
          <target state="translated">Предупреждать, если инициализированное поле без побочных эффектов отменяется при использовании назначенных инициализаторов (см. &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Назначенные инициализаторы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d80a9ebeceb31bde1433b7b0306e206a1d5169eb" translate="yes" xml:space="preserve">
          <source>Warn if an old-style (C-style) cast to a non-void type is used within a C++ program. The new-style casts (&lt;code&gt;dynamic_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, &lt;code&gt;reinterpret_cast&lt;/code&gt;, and &lt;code&gt;const_cast&lt;/code&gt;) are less vulnerable to unintended effects and much easier to search for.</source>
          <target state="translated">Предупреждать, если в программе на C ++ используется приведение старого стиля (стиля C) к непустому типу. Приведения нового стиля ( &lt;code&gt;dynamic_cast&lt;/code&gt; , &lt;code&gt;static_cast&lt;/code&gt; , &lt;code&gt;reinterpret_cast&lt;/code&gt; и &lt;code&gt;const_cast&lt;/code&gt; ) менее уязвимы для непреднамеренных эффектов и их намного проще искать.</target>
        </trans-unit>
        <trans-unit id="c7f9169958964ae3bf708d5e9fc733f1b6f3d079" translate="yes" xml:space="preserve">
          <source>Warn if an old-style function definition is used. A warning is given even if there is a previous prototype.</source>
          <target state="translated">Предупредить,если используется старое определение функции.Предупреждение выдается,даже если есть предыдущий прототип.</target>
        </trans-unit>
        <trans-unit id="bcf8277c15949fc4cfed473cccfc5dd0c50d837b" translate="yes" xml:space="preserve">
          <source>Warn if an old-style function definition is used. A warning is given even if there is a previous prototype. A definition using &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6e0c7f139a454bc8182dc0ec55a473f639305f" translate="yes" xml:space="preserve">
          <source>Warn if an undefined identifier is evaluated in an &lt;code&gt;#if&lt;/code&gt; directive. Such identifiers are replaced with zero.</source>
          <target state="translated">Предупреждать, если неопределенный идентификатор оценивается в директиве &lt;code&gt;#if&lt;/code&gt; . Такие идентификаторы заменяются нулем.</target>
        </trans-unit>
        <trans-unit id="ac1c57ed34616373c808e98ba1a7016be9451740" translate="yes" xml:space="preserve">
          <source>Warn if any functions that return structures or unions are defined or called. (In languages where you can return an array, this also elicits a warning.)</source>
          <target state="translated">Предупреждать о том,что любые функции,возвращающие структуры или союзы,определены или вызваны.(В языках,где можно вернуть массив,это также вызывает предупреждение).</target>
        </trans-unit>
        <trans-unit id="51dd1d087c6f2f3e06e53605399888ad9deb557f" translate="yes" xml:space="preserve">
          <source>Warn if any trigraphs are encountered that might change the meaning of the program. Trigraphs within comments are not warned about, except those that would form escaped newlines.</source>
          <target state="translated">Предупреждайте,если встречаются триграфы,которые могут изменить смысл программы.Триграфы в комментариях не предупреждаются,за исключением тех,которые могли бы образовывать ускользающие строки.</target>
        </trans-unit>
        <trans-unit id="4ffcebae22b64bc0188075323e253a892fb2c53e" translate="yes" xml:space="preserve">
          <source>Warn if anything is declared more than once in the same scope, even in cases where multiple declaration is valid and changes nothing.</source>
          <target state="translated">Предупреждать,если что-либо декларируется несколько раз в одной и той же области,даже в тех случаях,когда многократное декларирование является действительным и ничего не меняет.</target>
        </trans-unit>
        <trans-unit id="e116ff785f520c78cab89ec80c259fd9b971e9a1" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles are missing when using the</source>
          <target state="translated">Предупреждать,если профили обратной связи отсутствуют при использовании параметра</target>
        </trans-unit>
        <trans-unit id="159621fc69892b60a8932abc53e5e7077fd3432a" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles do not match when using the</source>
          <target state="translated">Предупреждать,если профили обратной связи не совпадают при использовании параметра</target>
        </trans-unit>
        <trans-unit id="4484a988d285daa67ba50d8d0068eac8b9c3b671" translate="yes" xml:space="preserve">
          <source>Warn if floating-point values are used in equality comparisons.</source>
          <target state="translated">Предупредить,если при сравнении равенства используются значения с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="5905365a7243693b281255e7cd734a616d419731" translate="yes" xml:space="preserve">
          <source>Warn if in a loop with constant number of iterations the compiler detects undefined behavior in some statement during one or more of the iterations.</source>
          <target state="translated">Предупреждать,если в цикле с постоянным количеством итераций компилятор обнаруживает неопределенное поведение в том или ином операторе во время одной или нескольких итераций.</target>
        </trans-unit>
        <trans-unit id="30ffd0486ea9b42613bc7458b80c284dea250c07" translate="yes" xml:space="preserve">
          <source>Warn if left shifting a negative value. This warning is enabled by</source>
          <target state="translated">Предупреждайте,если левое смещение отрицательного значения.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="59ffb10f60449caf44bc018fb1547abe48a875a4" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods of different types for the same selector are found during compilation. The check is performed on the list of methods in the final stage of compilation. Additionally, a check is performed for each selector appearing in a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, and a corresponding method for that selector has been found during compilation. Because these checks scan the method table only at the end of compilation, these warnings are not produced if the final stage of compilation is not reached, for example because an error is found during compilation, or because the</source>
          <target state="translated">Предупреждать, если во время компиляции обнаружено несколько методов разных типов для одного и того же селектора. Проверка выполняется по списку методов на завершающей стадии компиляции. Кроме того, выполняется проверка каждого селектора, появляющегося в &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; , и во время компиляции был найден соответствующий метод для этого селектора. Поскольку эти проверки сканируют таблицу методов только в конце компиляции, эти предупреждения не выдаются, если не достигнут последний этап компиляции, например, из-за того, что во время компиляции обнаружена ошибка или</target>
        </trans-unit>
        <trans-unit id="cd90c2f7bb5d921c657a205bebfbd186d1fe38a6" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;Class&lt;/code&gt;. When this flag is off (which is the default behavior), the compiler omits such warnings if any differences found are confined to types that share the same size and alignment.</source>
          <target state="translated">Предупреждать, если для данного селектора найдено несколько методов с разными аргументами и / или возвращаемыми типами при попытке отправить сообщение с использованием этого селектора получателю типа &lt;code&gt;id&lt;/code&gt; или &lt;code&gt;Class&lt;/code&gt; . Когда этот флаг выключен (что является поведением по умолчанию), компилятор пропускает такие предупреждения, если любые обнаруженные различия ограничиваются типами, которые имеют одинаковый размер и выравнивание.</target>
        </trans-unit>
        <trans-unit id="b4a4ef5836fcd4eb9eae356fd7d365383ac64fa2" translate="yes" xml:space="preserve">
          <source>Warn if padding is included in a structure, either to align an element of the structure or to align the whole structure. Sometimes when this happens it is possible to rearrange the fields of the structure to reduce the padding and so make the structure smaller.</source>
          <target state="translated">Предупреждение,если накладка включена в конструкцию,либо для выравнивания элемента конструкции,либо для выравнивания всей конструкции.Иногда,когда это происходит,можно переставить поля конструкции,чтобы уменьшить набивку и таким образом уменьшить конструкцию.</target>
        </trans-unit>
        <trans-unit id="cd9ef45fbb8d72f1831fd326b4e220df7e2faf4b" translate="yes" xml:space="preserve">
          <source>Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence people often get confused about.</source>
          <target state="translated">Предупреждайте,если скобки опущены в определенных контекстах,например,когда есть задание в контексте,где ожидается значение истины,или когда вложены операторы,приоритет которых часто путают в людях.</target>
        </trans-unit>
        <trans-unit id="3dceb1e23a828c2f0ba0a906a334b86bd9449ace" translate="yes" xml:space="preserve">
          <source>Warn if shift count &amp;gt;= width of type. This warning is enabled by default.</source>
          <target state="translated">Предупреждать, если количество сдвигов&amp;gt; = ширина типа. Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="782b64d027fe58cf65d8d3d5a2401f820f146ca7" translate="yes" xml:space="preserve">
          <source>Warn if shift count is negative. This warning is enabled by default.</source>
          <target state="translated">Предупреждаю,если счетчик смен отрицательный.Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9c75b9200e1a12aae1dc4d040bec33d9a26d867e" translate="yes" xml:space="preserve">
          <source>Warn if the C++17 feature making &lt;code&gt;noexcept&lt;/code&gt; part of a function type changes the mangled name of a symbol relative to C++14. Enabled by</source>
          <target state="translated">Предупреждать , если С ++ 17 функция делает &lt;code&gt;noexcept&lt;/code&gt; часть типа функции изменяет искаженное имя символа по отношению к C ++ 14. Включено</target>
        </trans-unit>
        <trans-unit id="46702f45847b2104b177e9b694f3c3f7e2226105" translate="yes" xml:space="preserve">
          <source>Warn if the ISR is misspelled, i.e. without __vector prefix. Enabled by default.</source>
          <target state="translated">Предупредить,если ISR написан неправильно,т.е.без префикса __vector.По умолчанию включено.</target>
        </trans-unit>
        <trans-unit id="33d88165f92bdb2b45ff7a297ce9db7215dfa02b" translate="yes" xml:space="preserve">
          <source>Warn if the compiler detects paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. This option is only active when</source>
          <target state="translated">Предупреждать,если компилятор обнаруживает пути,которые приводят к ошибочному или неопределенному поведению из-за разыменования нулевого указателя.Эта опция активна только в том случае,если</target>
        </trans-unit>
        <trans-unit id="201bd84a1d08c6c2787e78691ed2f3f92ff20d03" translate="yes" xml:space="preserve">
          <source>Warn if the loop cannot be optimized because the compiler cannot assume anything on the bounds of the loop indices. With</source>
          <target state="translated">Предупреждать,если цикл не может быть оптимизирован,так как компилятор не может ничего предположить на границах индексов цикла.С</target>
        </trans-unit>
        <trans-unit id="6ce9dcfeb56e93b36f3824efcafb3fac2f89db30" translate="yes" xml:space="preserve">
          <source>Warn if the return type of a function has a type qualifier such as &lt;code&gt;const&lt;/code&gt;. For ISO C such a type qualifier has no effect, since the value returned by a function is not an lvalue. For C++, the warning is only emitted for scalar types or &lt;code&gt;void&lt;/code&gt;. ISO C prohibits qualified &lt;code&gt;void&lt;/code&gt; return types on function definitions, so such return types always receive a warning even without this option.</source>
          <target state="translated">Предупреждать, если тип возвращаемого значения функции имеет квалификатор типа, например &lt;code&gt;const&lt;/code&gt; . Для ISO C такой квалификатор типа не действует, поскольку значение, возвращаемое функцией, не является lvalue. Для C ++ предупреждение выдается только для скалярных типов или &lt;code&gt;void&lt;/code&gt; . ISO C запрещает квалифицированные возвращаемые типы &lt;code&gt;void&lt;/code&gt; в определениях функций, поэтому такие возвращаемые типы всегда получают предупреждение даже без этой опции.</target>
        </trans-unit>
        <trans-unit id="84e834ec069e09da87cddcf3972bf0a3064670e4" translate="yes" xml:space="preserve">
          <source>Warn if the size of a function frame exceeds &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack frame size is approximate and not conservative. The actual requirements may be somewhat greater than &lt;var&gt;byte-size&lt;/var&gt; even if you do not get a warning. In addition, any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is not included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">Предупредить, если размер фрейма функции превышает &lt;var&gt;byte-size&lt;/var&gt; . Вычисления, выполняемые для определения размера кадра стека, являются приблизительными и неконсервативными. Фактические требования могут быть несколько больше &lt;var&gt;byte-size&lt;/var&gt; даже если вы не получите предупреждения. Кроме того, любое пространство, выделенное с помощью &lt;code&gt;alloca&lt;/code&gt; , массивов переменной длины или связанных конструкций, не включается компилятором при определении того, выдавать ли предупреждение.</target>
        </trans-unit>
        <trans-unit id="5b03e969a133a7f61dfd42668c90fbd199dc871d" translate="yes" xml:space="preserve">
          <source>Warn if the stack usage of a function might exceed &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack usage is conservative. Any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">Предупреждать, если использование стека функцией может превышать &lt;var&gt;byte-size&lt;/var&gt; . Расчет, сделанный для определения использования стека, является консервативным. Любое пространство, выделенное с помощью &lt;code&gt;alloca&lt;/code&gt; , массивов переменной длины или связанных конструкций, включается компилятором при определении, выдавать ли предупреждение.</target>
        </trans-unit>
        <trans-unit id="949e7c4b1e5fd9dd73b3df3e4dd44a3a50fb46cc" translate="yes" xml:space="preserve">
          <source>Warn if the type of &lt;code&gt;main&lt;/code&gt; is suspicious. &lt;code&gt;main&lt;/code&gt; should be a function with external linkage, returning int, taking either zero arguments, two, or three arguments of appropriate types. This warning is enabled by default in C++ and is enabled by either</source>
          <target state="translated">Предупредить, если тип &lt;code&gt;main&lt;/code&gt; подозрительного. &lt;code&gt;main&lt;/code&gt; должна быть функцией с внешней связью, возвращающей int, принимающей либо ноль аргументов, либо два, либо три аргумента соответствующих типов. Это предупреждение включено по умолчанию в C ++ и включается либо</target>
        </trans-unit>
        <trans-unit id="6da28b5dec8555c7e8c577e4ad18fb400e3b7e57" translate="yes" xml:space="preserve">
          <source>Warn if the vectorizer cost model overrides the OpenMP simd directive set by user. The</source>
          <target state="translated">Предупреждать,если модель стоимости векторизатора переопределяет установленную пользователем директиву OpenMP simd.</target>
        </trans-unit>
        <trans-unit id="cd147a815b47d8a61a481259e6bec92f6328c4b1" translate="yes" xml:space="preserve">
          <source>Warn if variadic macros are used in ISO C90 mode, or if the GNU alternate syntax is used in ISO C99 mode. This is enabled by either</source>
          <target state="translated">Предупреждать,если в режиме ISO C90 используются вариадические макросы,или если в режиме ISO C99 используется альтернативный синтаксис GNU.Это включается либо</target>
        </trans-unit>
        <trans-unit id="55d977b102dea3867bcd6836e9a2eac79a9f6018" translate="yes" xml:space="preserve">
          <source>Warn if vector operation is not implemented via SIMD capabilities of the architecture. Mainly useful for the performance tuning. Vector operation can be implemented &lt;code&gt;piecewise&lt;/code&gt;, which means that the scalar operation is performed on every vector element; &lt;code&gt;in parallel&lt;/code&gt;, which means that the vector operation is implemented using scalars of wider type, which normally is more performance efficient; and &lt;code&gt;as a single scalar&lt;/code&gt;, which means that vector fits into a scalar type.</source>
          <target state="translated">Предупреждать, если векторные операции не реализованы через SIMD-возможности архитектуры. В основном полезно для настройки производительности. Операция с вектором может быть реализована &lt;code&gt;piecewise&lt;/code&gt; , что означает, что скалярная операция выполняется для каждого элемента вектора; &lt;code&gt;in parallel&lt;/code&gt; , что означает, что векторная операция реализуется с использованием скаляров более широкого типа, что обычно более эффективно по производительности; и &lt;code&gt;as a single scalar&lt;/code&gt; , что означает, что вектор соответствует скалярному типу.</target>
        </trans-unit>
        <trans-unit id="d552f4c46cc5d3bd7e299e5496e695efcda3d372" translate="yes" xml:space="preserve">
          <source>Warn on uses of the &lt;code&gt;register&lt;/code&gt; storage class specifier, except when it is part of the GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; extension. The use of the &lt;code&gt;register&lt;/code&gt; keyword as storage class specifier has been deprecated in C++11 and removed in C++17. Enabled by default with</source>
          <target state="translated">Предупреждать об использовании спецификатора класса хранения &lt;code&gt;register&lt;/code&gt; , кроме случаев, когда он является частью расширения GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; . Использование ключевого слова &lt;code&gt;register&lt;/code&gt; в качестве спецификатора класса хранения объявлено устаревшим в C ++ 11 и удалено в C ++ 17. Включено по умолчанию с</target>
        </trans-unit>
        <trans-unit id="77c0caa2b84a54b5bcf764add54f563ae56b7071" translate="yes" xml:space="preserve">
          <source>Warn that the implicit declaration of a copy constructor or copy assignment operator is deprecated if the class has a user-provided copy constructor or copy assignment operator, in C++11 and up. This warning is enabled by</source>
          <target state="translated">Предупредить,что неявное объявление конструктора копирования или оператора присваивания копий устарело,если класс имеет предоставленный пользователем конструктор копирования или оператор присваивания копий,в языке C++11 и выше.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="4d2e76892f19022181f5882885c8f72e1722da44" translate="yes" xml:space="preserve">
          <source>Warn upon questionable usage of the macros used to handle variable arguments like &lt;code&gt;va_start&lt;/code&gt;. This is default. To inhibit the warning messages, use</source>
          <target state="translated">Предупреждать о сомнительном использовании макросов, используемых для обработки переменных аргументов, таких как &lt;code&gt;va_start&lt;/code&gt; . Это по умолчанию. Чтобы подавить предупреждающие сообщения, используйте</target>
        </trans-unit>
        <trans-unit id="3abec5289cdc959e5a13fe23b53843308a01da72" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; and &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; built-in functions are used. These functions changed semantics in GCC 4.4.</source>
          <target state="translated">Предупреждать, когда &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; встроенные функции __sync_fetch_and_nand и &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; . Эти функции изменили семантику в GCC 4.4.</target>
        </trans-unit>
        <trans-unit id="2aa9b92f65cbea3024eccc7e04605b70f951ef46" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;delete&lt;/code&gt; is used to destroy an instance of a class that has virtual functions and non-virtual destructor. It is unsafe to delete an instance of a derived class through a pointer to a base class if the base class does not have a virtual destructor. This warning is enabled by</source>
          <target state="translated">Предупреждать, когда &lt;code&gt;delete&lt;/code&gt; используется для уничтожения экземпляра класса, который имеет виртуальные функции и не виртуальный деструктор. Небезопасно удалять экземпляр производного класса через указатель на базовый класс, если базовый класс не имеет виртуального деструктора. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="f21bdb487f01146075a954516a5aced86463b3d2" translate="yes" xml:space="preserve">
          <source>Warn when G++ it generates code that is probably not compatible with the vendor-neutral C++ ABI. Since G++ now defaults to updating the ABI with each major release, normally</source>
          <target state="translated">Предупреждайте,когда G++генерирует код,который,вероятно,не совместим с нейтрализующим производителя C++ABI.Так как G++теперь по умолчанию обновляет ABI с каждым основным выпуском,то обычно</target>
        </trans-unit>
        <trans-unit id="35e0de5085f6b803ca5c49ba47e5ebe4c1616823" translate="yes" xml:space="preserve">
          <source>Warn when a &lt;code&gt;#pragma&lt;/code&gt; directive is encountered that is not understood by GCC. If this command-line option is used, warnings are even issued for unknown pragmas in system header files. This is not the case if the warnings are only enabled by the</source>
          <target state="translated">Предупреждать при обнаружении директивы &lt;code&gt;#pragma&lt;/code&gt; , не понимаемой GCC. Если используется этот параметр командной строки, предупреждения выдаются даже для неизвестных прагм в файлах системных заголовков. Это не тот случай, если предупреждения включены только</target>
        </trans-unit>
        <trans-unit id="62d4dab62f762a61b2f522842ea9ed134dd06936" translate="yes" xml:space="preserve">
          <source>Warn when a class has virtual functions and an accessible non-virtual destructor itself or in an accessible polymorphic base class, in which case it is possible but unsafe to delete an instance of a derived class through a pointer to the class itself or base class. This warning is automatically enabled if</source>
          <target state="translated">Предупреждение при наличии в классе виртуальных функций и доступного невиртуального деструктора как такового,так и в доступном полиморфном базовом классе,в этом случае возможно,но небезопасно удалить экземпляр производного класса по указателю на сам класс или базовый класс.Данное предупреждение автоматически включается,если</target>
        </trans-unit>
        <trans-unit id="2cb7e95f48120a523e19a1fdc36b0b8e1ca72f8b" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with a virtual direct base class. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use virtual inheritance.</source>
          <target state="translated">Предупреждать,когда класс определен с помощью виртуального прямого базового класса.Некоторые правила кодирования запрещают множественное наследование,и это может быть использовано для принудительного применения данного правила.Предупреждение неактивно внутри системного заголовочного файла,такого как STL,поэтому можно использовать STL.Можно также определить классы,которые косвенно используют виртуальное наследование.</target>
        </trans-unit>
        <trans-unit id="856d4cae226810333db6e35bc2ec148c4f408659" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with multiple direct base classes. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use multiple inheritance.</source>
          <target state="translated">Предупреждение,когда класс определен с несколькими прямыми базовыми классами.Некоторые правила кодирования запрещают множественное наследование,и это может быть использовано для принудительного применения данного правила.Предупреждение неактивно внутри системного заголовочного файла,такого как STL,поэтому можно использовать STL.Можно также определить классы,которые косвенно используют множественное наследование.</target>
        </trans-unit>
        <trans-unit id="62d55cbfe764766f5f6f7218d2c7a740a50c90ce" translate="yes" xml:space="preserve">
          <source>Warn when a class seems unusable because all the constructors or destructors in that class are private, and it has neither friends nor public static member functions. Also warn if there are no non-private methods, and there&amp;rsquo;s at least one private member function that isn&amp;rsquo;t a constructor or destructor.</source>
          <target state="translated">Предупреждать, когда класс кажется непригодным для использования, потому что все конструкторы или деструкторы в этом классе являются частными и у него нет ни друзей, ни общедоступных статических функций-членов. Также предупредите, если нет неприватных методов и есть хотя бы одна закрытая функция-член, которая не является конструктором или деструктором.</target>
        </trans-unit>
        <trans-unit id="3da6bed540b8c798c01ac10e6f991d33a93d7840" translate="yes" xml:space="preserve">
          <source>Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned. In C++, this warning is also enabled by</source>
          <target state="translated">Предупреждать,когда сравнение подписанного и неподписанного значений может привести к неверному результату,когда подписанное значение конвертируется в неподписанное.В языке Си++это предупреждение также включается по команде</target>
        </trans-unit>
        <trans-unit id="d0d230a7b94f00a257ce101a92be2d7094f8073f" translate="yes" xml:space="preserve">
          <source>Warn when a declaration does not specify a type. This warning is enabled by</source>
          <target state="translated">Предупреждать,если в декларации не указан тип.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="65d83d710bdf5c622a92b858d79d70755ab8010e" translate="yes" xml:space="preserve">
          <source>Warn when a declaration is found after a statement in a block. This construct, known from C++, was introduced with ISO C99 and is by default allowed in GCC. It is not supported by ISO C90. See &lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;Mixed Declarations&lt;/a&gt;.</source>
          <target state="translated">Предупреждать, если объявление находится после оператора в блоке. Эта конструкция, известная из C ++, была введена в ISO C99 и по умолчанию разрешена в GCC. Он не поддерживается ISO C90. См. &lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;Смешанные декларации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a51fcbd164dc3089b47299b1d3b6f2732c7c6fcc" translate="yes" xml:space="preserve">
          <source>Warn when a declaration of a function is missing one or more attributes that a related function is declared with and whose absence may adversely affect the correctness or efficiency of generated code. For example, the warning is issued for declarations of aliases that use attributes to specify less restrictive requirements than those of their targets. This typically represents a potential optimization opportunity. By contrast, the</source>
          <target state="translated">Предупреждать,когда в объявлении функции отсутствует один или несколько атрибутов,с которыми объявлена связанная функция,и отсутствие которых может отрицательно сказаться на корректности или эффективности генерируемого кода.Например,предупреждение выдается для объявлений псевдонимов,в которых атрибуты используются для указания менее ограничительных требований,чем для их целей.Как правило,это представляет собой потенциальную возможность оптимизации.В отличие от этого</target>
        </trans-unit>
        <trans-unit id="4f18983de88b8950abf6205674919e5d25d36a1f" translate="yes" xml:space="preserve">
          <source>Warn when a function call is cast to a non-matching type. For example, warn if a call to a function returning an integer type is cast to a pointer type.</source>
          <target state="translated">Предупреждать,когда вызов функции приводится к несоответствующему типу.Например,предупреждать,если вызов функции,возвращающей целочисленный тип,приведен к типу указателя.</target>
        </trans-unit>
        <trans-unit id="1fee5efa47b570695ab661666c6e4fee9e9b04a8" translate="yes" xml:space="preserve">
          <source>Warn when a function declaration hides virtual functions from a base class. For example, in:</source>
          <target state="translated">Предупреждать,когда объявление функции скрывает виртуальные функции от базового класса.Например,in:</target>
        </trans-unit>
        <trans-unit id="e0dab17ca245164b1ca8348967e2bf698b2a4654" translate="yes" xml:space="preserve">
          <source>Warn when a function pointer is cast to an incompatible function pointer. In a cast involving function types with a variable argument list only the types of initial arguments that are provided are considered. Any parameter of pointer-type matches any other pointer-type. Any benign differences in integral types are ignored, like &lt;code&gt;int&lt;/code&gt; vs. &lt;code&gt;long&lt;/code&gt; on ILP32 targets. Likewise type qualifiers are ignored. The function type &lt;code&gt;void (*) (void)&lt;/code&gt; is special and matches everything, which can be used to suppress this warning. In a cast involving pointer to member types this warning warns whenever the type cast is changing the pointer to member type. This warning is enabled by</source>
          <target state="translated">Предупреждать, когда указатель функции приводится к несовместимому указателю функции. В приведении типов функций со списком переменных аргументов учитываются только те типы исходных аргументов, которые предоставлены. Любой параметр типа указателя соответствует любому другому типу указателя. Любые незначительные различия в целочисленных типах игнорируются, например, &lt;code&gt;int&lt;/code&gt; и &lt;code&gt;long&lt;/code&gt; в целях ILP32. Точно так же игнорируются квалификаторы типа. Тип функции &lt;code&gt;void (*) (void)&lt;/code&gt; является особенным и соответствует всему, что можно использовать для подавления этого предупреждения. В приведении типов, включающих указатель на типы членов, это предупреждение предупреждает всякий раз, когда приведение типа изменяет указатель на тип члена. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="1c95c86068b8b8d1d8a72bc94ef016e54d5ce483" translate="yes" xml:space="preserve">
          <source>Warn when a literal &amp;lsquo;</source>
          <target state="translated">Предупреждать, когда буквальный</target>
        </trans-unit>
        <trans-unit id="fc5d5783ac1277dfc41a8a050b298452017de063" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter whose type is compatible with that of the shadowing variable. In C++, type compatibility here means the type of the shadowing variable can be converted to that of the shadowed variable. The creation of this flag (in addition to</source>
          <target state="translated">Предупреждать,когда локальная переменная отбрасывает тень на другую локальную переменную или параметр,тип которого совместим с типом переменной отбрасывания.В языке C++совместимость типов здесь означает,что тип переменной shadowing может быть приведен к типу переменной shadowed.Создание этого флага (в дополнение к</target>
        </trans-unit>
        <trans-unit id="94a65f8d50b5cd46e5a81aecc00176e626e7d2a5" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ad15a27db9c39d53d6f814ef18cd0f426f15bd" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter. This warning is enabled by</source>
          <target state="translated">Предупреждать,когда локальная переменная отбрасывает тень на другую локальную переменную или параметр.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="7332bfdf0522cbf64f5e187ed28df9e9bbf190d7" translate="yes" xml:space="preserve">
          <source>Warn when a namespace definition is opened. Some coding rules disallow namespaces, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also use using directives and qualified names.</source>
          <target state="translated">Предупреждать при открытии определения пространства имен.Некоторые правила кодирования запрещают пространства имен,и это может быть использовано для обеспечения соблюдения этого правила.Предупреждение неактивно внутри системного заголовочного файла,такого как STL,поэтому можно использовать STL.Можно также использовать директивы и квалифицированные имена.</target>
        </trans-unit>
        <trans-unit id="0c68af853608801bfccea4375c872dd95f8c2c74" translate="yes" xml:space="preserve">
          <source>Warn when a noexcept-expression evaluates to false because of a call to a function that does not have a non-throwing exception specification (i.e. &lt;code&gt;throw()&lt;/code&gt; or &lt;code&gt;noexcept&lt;/code&gt;) but is known by the compiler to never throw an exception.</source>
          <target state="translated">Предупреждать, когда выражение noexcept принимает значение false из-за вызова функции, не имеющей спецификации исключения, не вызывающей исключения (например, &lt;code&gt;throw()&lt;/code&gt; или &lt;code&gt;noexcept&lt;/code&gt; ), но известно компилятору, что она никогда не генерирует исключение.</target>
        </trans-unit>
        <trans-unit id="64beb2070ebf4a8be0aefd1a955c78bef9d98677" translate="yes" xml:space="preserve">
          <source>Warn when a primary template declaration is encountered. Some coding rules disallow templates, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also instantiate or specialize templates.</source>
          <target state="translated">Предупреждать,когда встречается первичное шаблонное объявление.Некоторые правила кодирования запрещают шаблоны,и это может быть использовано для обеспечения соблюдения этого правила.Предупреждение неактивно внутри системного заголовочного файла,такого как STL,поэтому можно использовать STL.Можно также инстанцировать или специализировать шаблоны.</target>
        </trans-unit>
        <trans-unit id="ecfd63f7bf76274a278010015f443553fb311275" translate="yes" xml:space="preserve">
          <source>Warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore. As a conforming extension, GCC treats such suffixes as separate preprocessing tokens in order to maintain backwards compatibility with code that uses formatting macros from &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">Предупреждать, когда за строковым или символьным литералом следует суффикс ud, который не начинается с символа подчеркивания. В качестве соответствующего расширения GCC обрабатывает такие суффиксы как отдельные токены предварительной обработки, чтобы поддерживать обратную совместимость с кодом, который использует макросы форматирования из &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="af55e43f2240ead9470434a0686aeb1f0a48afd9" translate="yes" xml:space="preserve">
          <source>Warn when a switch case falls through. For example:</source>
          <target state="translated">Предупреждать,когда корпус переключателя выпадает из строя.Например:</target>
        </trans-unit>
        <trans-unit id="fae5e5411e11c5c48526329b8f085ab67410eafc" translate="yes" xml:space="preserve">
          <source>Warn when a type with an ABI tag is used in a context that does not have that ABI tag. See &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C++ Attributes&lt;/a&gt; for more information about ABI tags.</source>
          <target state="translated">Предупреждать, когда тип с тегом ABI используется в контексте, не имеющем этого тега ABI. См. &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;Атрибуты C ++&lt;/a&gt; для получения дополнительной информации о тегах ABI.</target>
        </trans-unit>
        <trans-unit id="b81088e3c7de4ba5e43b90938614126c8743c79a" translate="yes" xml:space="preserve">
          <source>Warn when a typedef locally defined in a function is not used. This warning is enabled by</source>
          <target state="translated">Предупреждать,если в функции не используется локально заданный шрифт.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="5ae378a748c0460a36b0f283509a63bb9a77b535" translate="yes" xml:space="preserve">
          <source>Warn when a value of enumerated type is implicitly converted to a different enumerated type. This warning is enabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f92b37eeb1fc74d56bfb3de4e40a33e9756c1f8" translate="yes" xml:space="preserve">
          <source>Warn when an attribute is ignored. This is different from the</source>
          <target state="translated">Предупреждать,когда атрибут игнорируется.Это отличается от</target>
        </trans-unit>
        <trans-unit id="69d8172c43b83e36a9fc251e2742504cc5f07f18" translate="yes" xml:space="preserve">
          <source>Warn when an expression is casted to its own type.</source>
          <target state="translated">Предупреждать,когда выражение кастится к своему типу.</target>
        </trans-unit>
        <trans-unit id="68276b3f14c999ac5fd8362dd7f4c1eb0d25507e" translate="yes" xml:space="preserve">
          <source>Warn when an if-else has identical branches. This warning detects cases like</source>
          <target state="translated">Предупреждайте,если у &quot;иф-альса&quot; одинаковые ветви.Это предупреждение обнаруживает такие случаи,как</target>
        </trans-unit>
        <trans-unit id="4eaddac0ef918127a66832ad98be3ebdfc801bcd" translate="yes" xml:space="preserve">
          <source>Warn when an object referenced by a &lt;code&gt;restrict&lt;/code&gt;-qualified parameter (or, in C++, a &lt;code&gt;__restrict&lt;/code&gt;-qualified parameter) is aliased by another argument, or when copies between such objects overlap. For example, the call to the &lt;code&gt;strcpy&lt;/code&gt; function below attempts to truncate the string by replacing its initial characters with the last four. However, because the call writes the terminating NUL into &lt;code&gt;a[4]&lt;/code&gt;, the copies overlap and the call is diagnosed.</source>
          <target state="translated">Предупреждать, когда объект, на который ссылается параметр &lt;code&gt;restrict&lt;/code&gt; -qualified (или, в C ++, параметр &lt;code&gt;__restrict&lt;/code&gt; -qualified), имеет псевдоним другого аргумента или когда копии между такими объектами перекрываются. Например, приведенный ниже вызов функции &lt;code&gt;strcpy&lt;/code&gt; пытается усечь строку, заменив ее начальные символы последними четырьмя. Однако, поскольку вызов записывает завершающий NUL в &lt;code&gt;a[4]&lt;/code&gt; , копии перекрываются, и вызов диагностируется.</target>
        </trans-unit>
        <trans-unit id="48e014515a7db6fc79ef0eeec4d6a1ef40fdd1b6" translate="yes" xml:space="preserve">
          <source>Warn when comparing an argument marked with the &lt;code&gt;nonnull&lt;/code&gt; function attribute against null inside the function.</source>
          <target state="translated">Предупреждать при сравнении аргумента, помеченного атрибутом функции, &lt;code&gt;nonnull&lt;/code&gt; от NULL, с нулевым значением внутри функции.</target>
        </trans-unit>
        <trans-unit id="448f3542d0488bfdc3c401daf34114424d62966e" translate="yes" xml:space="preserve">
          <source>Warn when deleting a pointer to incomplete type, which may cause undefined behavior at runtime. This warning is enabled by default.</source>
          <target state="translated">Предупреждение при удалении указателя на неполный тип,что может привести к неопределенному поведению во время выполнения.Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4aead77201e88b8231585b494878f47ece446b42" translate="yes" xml:space="preserve">
          <source>Warn when macros &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt; or &lt;code&gt;__TIMESTAMP__&lt;/code&gt; are encountered as they might prevent bit-wise-identical reproducible compilations.</source>
          <target state="translated">Предупреждать при &lt;code&gt;__TIME__&lt;/code&gt; макросов __TIME__ , &lt;code&gt;__DATE__&lt;/code&gt; или &lt;code&gt;__TIMESTAMP__&lt;/code&gt; , поскольку они могут помешать побитно-идентичным воспроизводимым компиляциям.</target>
        </trans-unit>
        <trans-unit id="f416313a5d687fda4c349efcccdbcd43185983e0" translate="yes" xml:space="preserve">
          <source>Warn when overload resolution chooses a promotion from unsigned or enumerated type to a signed type, over a conversion to an unsigned type of the same size. Previous versions of G++ tried to preserve unsignedness, but the standard mandates the current behavior.</source>
          <target state="translated">Предупреждать,когда разрешение перегрузки выбирает продвижение из неподписанного или перечисленного типа в подписанный,по преобразованию в неподписанный тип того же размера.Предыдущие версии G++пытались сохранить беззнаковое поведение,но стандарт предписывал текущее поведение.</target>
        </trans-unit>
        <trans-unit id="6b26cc3f03f85ab2638c4cf2001a077d93732070" translate="yes" xml:space="preserve">
          <source>Warn when the &amp;lsquo;</source>
          <target state="translated">Предупреждать, когда '</target>
        </trans-unit>
        <trans-unit id="8090e980ff3867e87fe893e55e71d464e21173ec" translate="yes" xml:space="preserve">
          <source>Warn when the &lt;code&gt;sizeof&lt;/code&gt; operator is applied to a parameter that is declared as an array in a function definition. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">Предупреждать, когда оператор &lt;code&gt;sizeof&lt;/code&gt; применяется к параметру, который объявлен как массив в определении функции. Это предупреждение включено по умолчанию для программ C и C ++.</target>
        </trans-unit>
        <trans-unit id="9e36c088ae2b71459782ca704065537e9a26901f" translate="yes" xml:space="preserve">
          <source>Warn when the address of packed member of struct or union is taken, which usually results in an unaligned pointer value. This is enabled by default.</source>
          <target state="translated">Предупреждают,когда берется адрес упакованного члена структуры или союза,что обычно приводит к выравниванию значения указателя.По умолчанию это включено.</target>
        </trans-unit>
        <trans-unit id="99f87649fa1908434c721b9cad02a2282152635b" translate="yes" xml:space="preserve">
          <source>Warn when the destination of a call to a raw memory function such as &lt;code&gt;memset&lt;/code&gt; or &lt;code&gt;memcpy&lt;/code&gt; is an object of class type, and when writing into such an object might bypass the class non-trivial or deleted constructor or copy assignment, violate const-correctness or encapsulation, or corrupt virtual table pointers. Modifying the representation of such objects may violate invariants maintained by member functions of the class. For example, the call to &lt;code&gt;memset&lt;/code&gt; below is undefined because it modifies a non-trivial class object and is, therefore, diagnosed. The safe way to either initialize or clear the storage of objects of such types is by using the appropriate constructor or assignment operator, if one is available.</source>
          <target state="translated">Предупреждать, когда адресатом вызова необработанной функции памяти, такой как &lt;code&gt;memset&lt;/code&gt; или &lt;code&gt;memcpy&lt;/code&gt; , является объект типа класса, и при записи в такой объект может обойти нетривиальный или удаленный конструктор класса или присвоение копии, нарушить константную корректность или инкапсуляция или повреждение указателей виртуальных таблиц. Изменение представления таких объектов может нарушить инварианты, поддерживаемые функциями-членами класса. Например, вызов &lt;code&gt;memset&lt;/code&gt; ниже не определен, поскольку он изменяет нетривиальный объект класса и, следовательно, диагностируется. Безопасный способ инициализировать или очистить хранилище объектов таких типов - использовать соответствующий конструктор или оператор присваивания, если он доступен.</target>
        </trans-unit>
        <trans-unit id="40608df8d0fb171d8c9fd495ba5d5a7b32bd842d" translate="yes" xml:space="preserve">
          <source>Warn when the indentation of the code does not reflect the block structure. Specifically, a warning is issued for &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt; clauses with a guarded statement that does not use braces, followed by an unguarded statement with the same indentation.</source>
          <target state="translated">Предупреждаем, когда отступ в коде не отражает структуру блока. В частности, предупреждение выдается для предложений &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; и &lt;code&gt;for&lt;/code&gt; предложений с защищенным оператором, не использующим фигурные скобки, за которым следует неохраняемый оператор с тем же отступом.</target>
        </trans-unit>
        <trans-unit id="ccf62a55eeac02e2a52c16724b5155a1eb1a630e" translate="yes" xml:space="preserve">
          <source>Warn when the order of member initializers given in the code does not match the order in which they must be executed. For instance:</source>
          <target state="translated">Предупреждать,если порядок инициализаторов членов,указанный в коде,не совпадает с порядком,в котором они должны быть выполнены.Например:</target>
        </trans-unit>
        <trans-unit id="761311d3e33c39156d8e3725fcf020a8f1821794" translate="yes" xml:space="preserve">
          <source>Warn when the stack frame of a function exceeds &lt;var&gt;n&lt;/var&gt; bytes.</source>
          <target state="translated">Предупреждать, когда размер стека функции превышает &lt;var&gt;n&lt;/var&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="837d376bd42b01ca86e7606408854284b9f96c39" translate="yes" xml:space="preserve">
          <source>Warn whenever &amp;lsquo;</source>
          <target state="translated">Предупреждать всякий раз</target>
        </trans-unit>
        <trans-unit id="0c2135b897d3d5641cf8e18388c032eb11d6e43a" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement contains statements between the controlling expression and the first case label, which will never be executed. For example:</source>
          <target state="translated">Предупреждать всякий раз, когда оператор &lt;code&gt;switch&lt;/code&gt; содержит операторы между управляющим выражением и первой меткой case, которые никогда не будут выполнены. Например:</target>
        </trans-unit>
        <trans-unit id="3eb686177c30ed2e6e5f5f2664f95e4bb53041fa" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement does not have a &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="translated">Предупреждать всякий раз, когда в инструкции &lt;code&gt;switch&lt;/code&gt; нет регистра по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee15f4deaad963ee59e6e25cbd36a97c1a0b6f8" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of boolean type and the case values are outside the range of a boolean type. It is possible to suppress this warning by casting the controlling expression to a type other than &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">Предупреждать всякий раз, когда оператор &lt;code&gt;switch&lt;/code&gt; имеет индекс логического типа, а значения case выходят за пределы диапазона логического типа. Это предупреждение можно подавить, приведя управляющее выражение к типу, отличному от &lt;code&gt;bool&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="d226ed0209ee1c2fb6432b4c47bf17b27b050c76" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. (The presence of a &lt;code&gt;default&lt;/code&gt; label prevents this warning.) &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used (even if there is a &lt;code&gt;default&lt;/code&gt; label). This warning is enabled by</source>
          <target state="translated">Предупреждать всякий раз, когда оператор &lt;code&gt;switch&lt;/code&gt; имеет индекс перечислимого типа и не имеет &lt;code&gt;case&lt;/code&gt; для одного или нескольких именованных кодов этого перечисления. (Наличие метки по &lt;code&gt;default&lt;/code&gt; предотвращает появление этого предупреждения.) Метки &lt;code&gt;case&lt;/code&gt; за пределами диапазона перечисления также вызывают предупреждения при использовании этой опции (даже если есть метка по &lt;code&gt;default&lt;/code&gt; ). Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="de11d7b668ccdb23ca7bd8a246e58548a37f3260" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used. The only difference between</source>
          <target state="translated">Предупреждать всякий раз, когда оператор &lt;code&gt;switch&lt;/code&gt; имеет индекс перечислимого типа и не имеет &lt;code&gt;case&lt;/code&gt; для одного или нескольких именованных кодов этого перечисления. метки &lt;code&gt;case&lt;/code&gt; вне диапазона перечисления также вызывают предупреждения при использовании этой опции. Единственная разница между</target>
        </trans-unit>
        <trans-unit id="2d59fb66fde78bda0a4dd35cce84a5db357b0d28" translate="yes" xml:space="preserve">
          <source>Warn whenever a comment-start sequence &amp;lsquo;</source>
          <target state="translated">Предупреждать всякий раз, когда последовательность начала комментария '</target>
        </trans-unit>
        <trans-unit id="017d9dfe987bf5077b04f6ad0db50c54e128c51c" translate="yes" xml:space="preserve">
          <source>Warn whenever a constant static variable is unused aside from its declaration.</source>
          <target state="translated">Предупреждать всякий раз,когда не используется постоянная статическая переменная,кроме ее объявления.</target>
        </trans-unit>
        <trans-unit id="44c2f3d6fa32cff8b5706f1e4a38180d5b65ee57" translate="yes" xml:space="preserve">
          <source>Warn whenever a function is defined with a return type that defaults to &lt;code&gt;int&lt;/code&gt;. Also warn about any &lt;code&gt;return&lt;/code&gt; statement with no return value in a function whose return type is not &lt;code&gt;void&lt;/code&gt; (falling off the end of the function body is considered returning without a value).</source>
          <target state="translated">Предупреждать всякий раз, когда функция определяется с возвращаемым типом, который по умолчанию имеет значение &lt;code&gt;int&lt;/code&gt; . Также предупреждайте о любом операторе &lt;code&gt;return&lt;/code&gt; без возвращаемого значения в функции, тип возвращаемого значения которой не является &lt;code&gt;void&lt;/code&gt; (падение с конца тела функции считается возвратом без значения).</target>
        </trans-unit>
        <trans-unit id="89fb51e22730b538a06b8e80540c16d1c3734cc8" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is assigned to, but otherwise unused (aside from its declaration).</source>
          <target state="translated">Предупреждать всякий раз,когда назначается параметр функции,но в противном случае не используется (кроме его объявления).</target>
        </trans-unit>
        <trans-unit id="7522f02e51d59309d9911182c3c068a365219bc7" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is unused aside from its declaration.</source>
          <target state="translated">Предупреждать всякий раз,когда параметр функции не используется помимо его объявления.</target>
        </trans-unit>
        <trans-unit id="c0a7eb9ab9f17ff83adfaf6aff2a67a4af1e6664" translate="yes" xml:space="preserve">
          <source>Warn whenever a label is declared but not used. This warning is enabled by</source>
          <target state="translated">Предупреждать всякий раз,когда этикетка объявлена,но не используется.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="2d58d8f5ceb022d5ba0d30591a67aed1db06f84d" translate="yes" xml:space="preserve">
          <source>Warn whenever a local or static variable is unused aside from its declaration. This option implies</source>
          <target state="translated">Предупреждать всякий раз,когда локальная или статическая переменная не используется помимо ее объявления.Эта опция подразумевает</target>
        </trans-unit>
        <trans-unit id="6e4150091f2d91d35b21758f7af8935b067c74b6" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable is assigned to, but otherwise unused (aside from its declaration). This warning is enabled by</source>
          <target state="translated">Предупреждать всякий раз,когда локальная переменная присваивается,но в противном случае не используется (кроме ее объявления).Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="40895acf40c91c4bfe26a1e2bb719c6261038bee" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable or type declaration shadows another variable, parameter, type, class member (in C++), or instance variable (in Objective-C) or whenever a built-in function is shadowed. Note that in C++, the compiler warns if a local variable shadows an explicit typedef, but not if it shadows a struct/class/enum. If this warning is enabled, it includes also all instances of local shadowing. This means that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ce592a35665d53c155cc3462735224db9a9571" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable or type declaration shadows another variable, parameter, type, class member (in C++), or instance variable (in Objective-C) or whenever a built-in function is shadowed. Note that in C++, the compiler warns if a local variable shadows an explicit typedef, but not if it shadows a struct/class/enum. Same as</source>
          <target state="translated">Предупреждать всякий раз,когда локальная переменная или объявление типа затеняет другую переменную,параметр,тип,член класса (в C++)или переменную экземпляра (в Objective-C),или когда затеняется встроенная функция.Обратите внимание,что в языке Си++компилятор предупреждает,если локальная переменная оттеняет явный тип,но не оттеняет структуру/класс/значение.То же самое,что и</target>
        </trans-unit>
        <trans-unit id="05ffb9a97b76e12ea54aaaeb8badea77adb678ae" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast so as to remove a type qualifier from the target type. For example, warn if a &lt;code&gt;const char *&lt;/code&gt; is cast to an ordinary &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">Предупреждать всякий раз при приведении указателя, чтобы удалить квалификатор типа из целевого типа. Например, предупредить, если &lt;code&gt;const char *&lt;/code&gt; приведен к обычному &lt;code&gt;char *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c63ef9e66f9b18bee95bf1723987dfd5d11a58f" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; on machines where integers can only be accessed at two- or four-byte boundaries.</source>
          <target state="translated">Предупреждать всякий раз, когда указатель приводится так, что требуемое выравнивание цели увеличивается. Например, предупреждать, если &lt;code&gt;char *&lt;/code&gt; приведен к &lt;code&gt;int *&lt;/code&gt; на машинах, где целые числа доступны только на двух- или четырехбайтовых границах.</target>
        </trans-unit>
        <trans-unit id="ef7fc95a5c54b16b21f690678e6321f329b8c724" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; regardless of the target machine.</source>
          <target state="translated">Предупреждать всякий раз, когда указатель приводится так, что требуемое выравнивание цели увеличивается. Например, предупреждать, если &lt;code&gt;char *&lt;/code&gt; приводится к &lt;code&gt;int *&lt;/code&gt; независимо от целевой машины.</target>
        </trans-unit>
        <trans-unit id="f17199fabf0d6edb5e8d9320d9584ee47f24d757" translate="yes" xml:space="preserve">
          <source>Warn whenever a statement computes a result that is explicitly not used. To suppress this warning cast the unused expression to &lt;code&gt;void&lt;/code&gt;. This includes an expression-statement or the left-hand side of a comma expression that contains no side effects. For example, an expression such as &lt;code&gt;x[i,j]&lt;/code&gt; causes a warning, while &lt;code&gt;x[(void)i,j]&lt;/code&gt; does not.</source>
          <target state="translated">Предупреждать всякий раз, когда инструкция вычисляет результат, который явно не используется. Чтобы подавить это предупреждение, &lt;code&gt;void&lt;/code&gt; неиспользуемое выражение . Это включает выражение-выражение или левую часть выражения запятой, которое не содержит побочных эффектов. Например, выражение, такое как &lt;code&gt;x[i,j]&lt;/code&gt; вызывает предупреждение, а &lt;code&gt;x[(void)i,j]&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="e9ed26895683fb69327818c06ae2df9969d8a9f1" translate="yes" xml:space="preserve">
          <source>Warn whenever a static function is declared but not defined or a non-inline static function is unused. This warning is enabled by</source>
          <target state="translated">Предупреждать всякий раз,когда статическая функция объявлена,но не определена,или когда нестрочная статическая функция не используется.Это предупреждение включается при помощи</target>
        </trans-unit>
        <trans-unit id="682ef1b46b2728b71e94a89b2010ca06ceb12456" translate="yes" xml:space="preserve">
          <source>Warn whenever an Objective-C assignment is being intercepted by the garbage collector.</source>
          <target state="translated">Предупреждать всякий раз,когда задание Объекта-С перехватывается сборщиком мусора.</target>
        </trans-unit>
        <trans-unit id="5f84fae543b9699e7c995142a54b65f353ecae8d" translate="yes" xml:space="preserve">
          <source>Warn whenever an object is defined whose size exceeds &lt;var&gt;byte-size&lt;/var&gt;.</source>
          <target state="translated">Предупреждать всякий раз, когда определяется объект, размер которого превышает размер &lt;var&gt;byte-size&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ea0ef30fd9bda293d78af05a20b81fc75c62d811" translate="yes" xml:space="preserve">
          <source>Warning Options</source>
          <target state="translated">Предупреждающие опции</target>
        </trans-unit>
        <trans-unit id="986ddebcadb3fa23d23a5b826b014fe8f130debb" translate="yes" xml:space="preserve">
          <source>Warning about assigning a signed value to an unsigned variable.</source>
          <target state="translated">Предупреждение о присвоении беззнакового значения беззнаковой переменной.</target>
        </trans-unit>
        <trans-unit id="e9e66e7d69e59ab3855b10526f1e61fff27e7187" translate="yes" xml:space="preserve">
          <source>Warning about using an expression whose type is signed as a shift count.</source>
          <target state="translated">Предупреждение об использовании выражения,тип которого обозначен как счетчик сдвигов.</target>
        </trans-unit>
        <trans-unit id="418dee8a9f5c36e0b14dc254214604e6561b0bc6" translate="yes" xml:space="preserve">
          <source>Warning when a non-void function value is ignored.</source>
          <target state="translated">Предупреждение,когда игнорируется значение неотвратимой функции.</target>
        </trans-unit>
        <trans-unit id="c63c46949dc10de80e839dce6410c17945e22373" translate="yes" xml:space="preserve">
          <source>Warnings about conversion from arithmetic on a small type back to that type are only given with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6016747760c907aec70fe12b355cb7c681c5c0db" translate="yes" xml:space="preserve">
          <source>Warnings are diagnostic messages that report constructions that are not inherently erroneous but that are risky or suggest there may have been an error.</source>
          <target state="translated">Предупреждения-это диагностические сообщения,которые сообщают о конструкциях,которые по своей природе не являются ошибочными,но рискованными или предполагают,что могла быть ошибка.</target>
        </trans-unit>
        <trans-unit id="0dd982bec66fde4c74400108fddfd5cb384244af" translate="yes" xml:space="preserve">
          <source>Warnings may indicate danger points where you should check to make sure that your program really does what you intend; or the use of obsolete features; or the use of nonstandard features of GNU C or C++. Many warnings are issued only if you ask for them, with one of the</source>
          <target state="translated">Предупреждения могут указывать на опасные моменты,в которых вам следует проверить,действительно ли ваша программа делает то,что вы задумали;или на применение устаревших возможностей;или на применение нестандартных возможностей GNU C или C++.Многие предупреждения выдаются только в том случае,если вы их запрашиваете,с одним из следующих пунктов</target>
        </trans-unit>
        <trans-unit id="774110e2ee23eade4be0249d185f9d3f531f461a" translate="yes" xml:space="preserve">
          <source>Weak pointers are supported through a new type character specifier represented by the &amp;lsquo;</source>
          <target state="translated">Слабые указатели поддерживаются с помощью спецификатора символа нового типа, представленного символом '</target>
        </trans-unit>
        <trans-unit id="833f5330898dc442fd023004015464621900910e" translate="yes" xml:space="preserve">
          <source>What constitutes an access to a volatile object.</source>
          <target state="translated">Что представляет собой доступ к взрывоопасному объекту.</target>
        </trans-unit>
        <trans-unit id="29d1640b5550a77154368675da8078c8ec35026f" translate="yes" xml:space="preserve">
          <source>What constitutes an access to an object that has volatile-qualified type (C90 6.5.3, C99 and C11 6.7.3).</source>
          <target state="translated">Что представляет собой доступ к объекту,который имеет взрывоопасный тип (С90 6.5.3,С99 и С11 6.7.3).</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="5a3c28f0078d3bccad681756e58285b312c781d5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setjmp&lt;/code&gt; is called on a &lt;code&gt;jmp_buf&lt;/code&gt; to record a rewind location, it records the stack frame. The stack frame becomes invalid when the function containing the &lt;code&gt;setjmp&lt;/code&gt; call returns. Attempting to rewind to it via &lt;code&gt;longjmp&lt;/code&gt; would reference a stack frame that no longer exists, and likely lead to a crash (or worse).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd64c930e8a03f6f18128acc45ad378c8a80720f" translate="yes" xml:space="preserve">
          <source>When FDO profile information is available,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ab9ffb5b7365deaf1034842a4b9d0c5073a1f3" translate="yes" xml:space="preserve">
          <source>When G++ and another C++ compiler conform to the same C++ ABI, but the implementations of the Standard C++ Library that they normally use do not follow the same ABI for the Standard C++ Library, object files built with those compilers can be used in the same program only if they use the same C++ library. This requires specifying the location of the C++ library header files when invoking the compiler whose usual library is not being used. The location of GCC&amp;rsquo;s C++ header files depends on how the GCC build was configured, but can be seen by using the G++</source>
          <target state="translated">Когда G ++ и другой компилятор C ++ соответствуют одному и тому же ABI C ++, но реализации стандартной библиотеки C ++, которые они обычно используют, не соответствуют одному и тому же ABI для стандартной библиотеки C ++, объектные файлы, созданные с помощью этих компиляторов, могут использоваться в одной программе. только если они используют одну и ту же библиотеку C ++. Для этого необходимо указать расположение файлов заголовков библиотеки C ++ при вызове компилятора, обычная библиотека которого не используется. Расположение файлов заголовков C ++ GCC зависит от того, как была настроена сборка GCC, но это можно увидеть с помощью G ++</target>
        </trans-unit>
        <trans-unit id="25b318e1653c6b6dda339c34d9872ce5b96093ce" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the index of an array access known, it adds a bonus of</source>
          <target state="translated">Когда IPA-CP определяет,что кандидат на клонирование сделает известным индекс доступа к массиву,он добавляет бонус в размере</target>
        </trans-unit>
        <trans-unit id="3fbfba2a71ffaa54417e4d873e33ec3bbc19a7e4" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the number of iterations of a loop known, it adds a bonus of</source>
          <target state="translated">Когда IPA-CP определяет,что кандидат на клонирование сделает известным количество итераций петли,он добавляет бонус в размере</target>
        </trans-unit>
        <trans-unit id="0b074b049fd7c7f48c6da34e1272635cac52856d" translate="yes" xml:space="preserve">
          <source>When a base class is virtual, only one subobject of the base class belongs to each full object. Also, the constructors and destructors are invoked only once, and called from the most-derived class. However, such objects behave unspecified when being assigned. For example:</source>
          <target state="translated">Когда базовый класс является виртуальным,каждому полному объекту принадлежит только один подобъект базового класса.Кроме того,конструкторы и деструкторы вызываются только один раз и вызываются из самого полученного класса.Однако при назначении такие объекты ведут себя неуточненно.Например:</target>
        </trans-unit>
        <trans-unit id="67be4830f6cdd00004022ad6db1aaae5471c2589" translate="yes" xml:space="preserve">
          <source>When a class has static data members, it is not enough to &lt;em&gt;declare&lt;/em&gt; the static member; you must also &lt;em&gt;define&lt;/em&gt; it. For example:</source>
          <target state="translated">Когда класс имеет статические члены данных, недостаточно &lt;em&gt;объявить&lt;/em&gt; статический член; вы также должны &lt;em&gt;определить&lt;/em&gt; это. Например:</target>
        </trans-unit>
        <trans-unit id="d927dabaa85a2fec9fca96ddc5e395f531b27e67" translate="yes" xml:space="preserve">
          <source>When a division strategy has not been specified the default strategy is selected based on the current target. For SH2A the default strategy is to use the &lt;code&gt;divs&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions instead of library function calls.</source>
          <target state="translated">Если стратегия разделения не указана, стратегия по умолчанию выбирается на основе текущей цели. Для SH2A стратегия по умолчанию использовать &lt;code&gt;divs&lt;/code&gt; и &lt;code&gt;divu&lt;/code&gt; инструкции вместо вызовов функций библиотеки.</target>
        </trans-unit>
        <trans-unit id="0a75adb840378c14dc9a655e4aba002e527f73a2" translate="yes" xml:space="preserve">
          <source>When a file is compiled with</source>
          <target state="translated">Когда файл компилируется с</target>
        </trans-unit>
        <trans-unit id="0cd90cdfd69b208961a20a866e993339b4b5f840" translate="yes" xml:space="preserve">
          <source>When a function is both inline and &lt;code&gt;static&lt;/code&gt;, if all calls to the function are integrated into the caller, and the function&amp;rsquo;s address is never used, then the function&amp;rsquo;s own assembler code is never referenced. In this case, GCC does not actually output assembler code for the function, unless you specify the option</source>
          <target state="translated">Когда функция является как встроенной, так и &lt;code&gt;static&lt;/code&gt; , если все вызовы функции интегрированы в вызывающий объект, а адрес функции никогда не используется, то на собственный ассемблерный код функции никогда не ссылаются. В этом случае GCC фактически не выводит ассемблерный код для функции, если вы не укажете параметр</target>
        </trans-unit>
        <trans-unit id="678a6d73dd419ef65f8fe5fe05b5c39fad57f23c" translate="yes" xml:space="preserve">
          <source>When a list constructor stores the &lt;code&gt;begin&lt;/code&gt; pointer from the &lt;code&gt;initializer_list&lt;/code&gt; argument, this doesn&amp;rsquo;t extend the lifetime of the array, so if a class variable is constructed from a temporary &lt;code&gt;initializer_list&lt;/code&gt;, the pointer is left dangling by the end of the variable declaration statement.</source>
          <target state="translated">Когда конструктор списка сохраняет указатель &lt;code&gt;begin&lt;/code&gt; из аргумента &lt;code&gt;initializer_list&lt;/code&gt; , это не продлевает время существования массива, поэтому, если переменная класса создается из временного &lt;code&gt;initializer_list&lt;/code&gt; , указатель остается висящим к концу оператора объявления переменной.</target>
        </trans-unit>
        <trans-unit id="00f542136163060bf7630e6166417f9110c29edb" translate="yes" xml:space="preserve">
          <source>When a lock acquire fails, it is required for good performance to abort the transaction quickly. This can be done with a &lt;code&gt;_mm_pause&lt;/code&gt;.</source>
          <target state="translated">При сбое запроса блокировки для хорошей производительности требуется быстрое прерывание транзакции. Это можно сделать с помощью &lt;code&gt;_mm_pause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f7415b6c4bfc3b8582a73345fc35229f98c2491" translate="yes" xml:space="preserve">
          <source>When a type involving an ABI tag is used as the type of a variable or return type of a function where that tag is not already present in the signature of the function, the tag is automatically applied to the variable or function.</source>
          <target state="translated">Когда тип,включающий ABI-тег,используется в качестве типа переменной или возвращаемого типа функции,где этот тег еще не присутствует в сигнатуре функции,тег автоматически применяется к переменной или функции.</target>
        </trans-unit>
        <trans-unit id="6dad89b8cb0d35ea0fd46b863a5983c0e559d839" translate="yes" xml:space="preserve">
          <source>When added to an interrupt handler with the M32C port, causes the prologue and epilogue to use bank switching to preserve the registers rather than saving them on the stack.</source>
          <target state="translated">При добавлении в обработчик прерываний с портом M32C,заставляет пролог и эпилог использовать банковское переключение для сохранения регистров,а не для их сохранения в стеке.</target>
        </trans-unit>
        <trans-unit id="f8717fcf897c9e046dd756abc024e5f7d502ccd8" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;initializer_list&lt;/code&gt; variable is assigned from a brace-enclosed initializer list, the temporary array created for the right side of the assignment only lives until the end of the full-expression, so at the next statement the &lt;code&gt;initializer_list&lt;/code&gt; variable has a dangling pointer.</source>
          <target state="translated">Когда переменная &lt;code&gt;initializer_list&lt;/code&gt; назначается из заключенного в фигурные скобки списка инициализаторов, временный массив, созданный для правой стороны присваивания, живет только до конца полного выражения, поэтому в следующем операторе переменная &lt;code&gt;initializer_list&lt;/code&gt; имеет висящий указатель.</target>
        </trans-unit>
        <trans-unit id="f82873b6d13dce7be3f4357951354ec118469799" translate="yes" xml:space="preserve">
          <source>When an error message refers to a specialization of a function template, the compiler normally prints the signature of the template followed by the template arguments and any typedefs or typenames in the signature (e.g. &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; rather than &lt;code&gt;void f(int)&lt;/code&gt;) so that it&amp;rsquo;s clear which template is involved. When an error message refers to a specialization of a class template, the compiler omits any template arguments that match the default template arguments for that template. If either of these behaviors make it harder to understand the error message rather than easier, you can use</source>
          <target state="translated">Когда сообщение об ошибке относится к специализации шаблона функции, компилятор обычно печатает подпись шаблона, за которой следуют аргументы шаблона и любые определения типов или имена типов в подписи (например, &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; а не &lt;code&gt;void f(int)&lt;/code&gt; ), чтобы было понятно, какой шаблон задействован. Когда сообщение об ошибке относится к специализации шаблона класса, компилятор пропускает любые аргументы шаблона, которые соответствуют аргументам шаблона по умолчанию для этого шаблона. Если какое-либо из этих действий затрудняет понимание сообщения об ошибке, а не упрощает, вы можете использовать</target>
        </trans-unit>
        <trans-unit id="4a0782c5484322bfadd7fe79666979332dd01a38" translate="yes" xml:space="preserve">
          <source>When an executable is run in a massive parallel environment, it is recommended to save profile to different folders. That can be done with variables in &lt;var&gt;path&lt;/var&gt; that are exported during run-time:</source>
          <target state="translated">Когда исполняемый файл запускается в массивной параллельной среде, рекомендуется сохранять профиль в разные папки. Это можно сделать с помощью переменных в &lt;var&gt;path&lt;/var&gt; , которые экспортируются во время выполнения:</target>
        </trans-unit>
        <trans-unit id="d2c4f8c7d6b26eab60b9d9e100920ff031a8aaf4" translate="yes" xml:space="preserve">
          <source>When an inline function is not &lt;code&gt;static&lt;/code&gt;, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-&lt;code&gt;static&lt;/code&gt; inline function is always compiled on its own in the usual fashion.</source>
          <target state="translated">Когда встроенная функция не является &lt;code&gt;static&lt;/code&gt; , компилятор должен предположить, что могут быть вызовы из других исходных файлов; поскольку глобальный символ может быть определен только один раз в любой программе, функция не должна быть определена в других исходных файлах, поэтому вызовы в них не могут быть интегрированы. Поэтому &lt;code&gt;static&lt;/code&gt; встроенная функция всегда компилируется сама по себе обычным способом.</target>
        </trans-unit>
        <trans-unit id="b338539fbe33495121e46c5661e5bc16f008a3e0" translate="yes" xml:space="preserve">
          <source>When an insn has two alternative constraint-patterns.</source>
          <target state="translated">Когда у Insn есть два альтернативных способа ограничения.</target>
        </trans-unit>
        <trans-unit id="4cbff59218859bab09c21980b2597e3d4c6294f2" translate="yes" xml:space="preserve">
          <source>When an unrecognized warning option is requested (e.g.,</source>
          <target state="translated">Когда запрашивается нераспознанная опция предупреждения (например</target>
        </trans-unit>
        <trans-unit id="537d39cd77a447e897b80dd75224237bdc4e0719" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of 4-operand &lt;code&gt;madd.s&lt;/code&gt;, &lt;code&gt;madd.d&lt;/code&gt; and related instructions. Enabled by default.</source>
          <target state="translated">Если возможно, включите (отключите) генерацию 4-операндов &lt;code&gt;madd.s&lt;/code&gt; , &lt;code&gt;madd.d&lt;/code&gt; и связанных инструкций. Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4c26cdde33cc06bf31aab1a7bf63c69c29f00704" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of &lt;code&gt;lwxc1&lt;/code&gt;, &lt;code&gt;swxc1&lt;/code&gt;, &lt;code&gt;ldxc1&lt;/code&gt;, &lt;code&gt;sdxc1&lt;/code&gt; instructions. Enabled by default.</source>
          <target state="translated">Если применимо, включите (отключите) создание &lt;code&gt;lwxc1&lt;/code&gt; , &lt;code&gt;swxc1&lt;/code&gt; , &lt;code&gt;ldxc1&lt;/code&gt; , &lt;code&gt;sdxc1&lt;/code&gt; . Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7184e15e5684528f54729686834cdf00887683be" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks defined non-inlined member functions and static data members as exports. Static consts initialized in-class are not marked unless they are also defined out-of-class.</source>
          <target state="translated">При применении к классам C++,метки атрибутов определяли в качестве экспортируемых необлицованные функции-члены и статические члены данных.Статические консоли,инициализированные в классе,не отмечаются,если только они также не определены вне класса.</target>
        </trans-unit>
        <trans-unit id="7d9feaafaf97b8f7fe46d8b6b598964809d89431" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks non-inlined member functions and static data members as imports. However, the attribute is ignored for virtual methods to allow creation of vtables using thunks.</source>
          <target state="translated">При применении к классам C++атрибут отмечает в качестве импорта необлицованные функции-члены и статические члены данных.Однако,атрибут игнорируется для виртуальных методов,чтобы позволить создание таблиц с использованием thunks.</target>
        </trans-unit>
        <trans-unit id="bbf180b63c03eb34a3aba311a968f02d5135ed3e" translate="yes" xml:space="preserve">
          <source>When applied to a member function of a C++ class template, the attribute also means that the function is instantiated if the class itself is instantiated.</source>
          <target state="translated">При применении к функции-члену шаблона класса C++атрибут также означает,что функция инстанцируется,если инстанцируется сам класс.</target>
        </trans-unit>
        <trans-unit id="cabddb6e825602d843a117fb734ca3aff3112d1a" translate="yes" xml:space="preserve">
          <source>When applied to a static data member of a C++ class template, the attribute also means that the member is instantiated if the class itself is instantiated.</source>
          <target state="translated">При применении к статическому члену данных шаблона класса C++атрибут также означает,что этот член инстанцируется,если сам класс инстанцируется.</target>
        </trans-unit>
        <trans-unit id="59f0e6f1d8d71dac3701cee27ca42c33aae99e5f" translate="yes" xml:space="preserve">
          <source>When attached to a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, this attribute sets the storage order, aka endianness, of the scalar fields of the type, as well as the array fields whose component is scalar. The supported endiannesses are &lt;code&gt;big-endian&lt;/code&gt; and &lt;code&gt;little-endian&lt;/code&gt;. The attribute has no effects on fields which are themselves a &lt;code&gt;union&lt;/code&gt;, a &lt;code&gt;struct&lt;/code&gt; or an array whose component is a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, and it is possible for these fields to have a different scalar storage order than the enclosing type.</source>
          <target state="translated">При присоединении к &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; этот атрибут устанавливает порядок хранения, также называемый порядком следования байтов, скалярных полей типа, а также полей массива, компонент которых является скалярным. Поддерживаемые endiannesses являются &lt;code&gt;big-endian&lt;/code&gt; и &lt;code&gt;little-endian&lt;/code&gt; . Атрибут не влияет на поля, которые сами являются &lt;code&gt;union&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; или массивом, компонентом которого является &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; , и эти поля могут иметь другой скалярный порядок хранения, чем включающий тип.</target>
        </trans-unit>
        <trans-unit id="5370f9b64efe5c0ffe3fe15dfade832ac9be14df" translate="yes" xml:space="preserve">
          <source>When attached to a type (including a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;), this attribute means that variables of that type are meant to appear possibly unused. GCC does not produce a warning for any variables of that type, even if the variable appears to do nothing. This is often the case with lock or thread classes, which are usually defined and then not referenced, but contain constructors and destructors that have nontrivial bookkeeping functions.</source>
          <target state="translated">При присоединении к типу (включая &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; ) этот атрибут означает, что переменные этого типа могут казаться неиспользуемыми. GCC не выдает предупреждения ни для каких переменных этого типа, даже если переменная ничего не делает. Это часто случается с классами блокировки или потоков, которые обычно определяются, а затем не упоминаются, но содержат конструкторы и деструкторы, которые имеют нетривиальные бухгалтерские функции.</target>
        </trans-unit>
        <trans-unit id="607b6b9a753f4dcb8aa6e646687045411231d9db" translate="yes" xml:space="preserve">
          <source>When attached to an &lt;code&gt;enum&lt;/code&gt; definition, the &lt;code&gt;packed&lt;/code&gt; attribute indicates that the smallest integral type should be used. Specifying the</source>
          <target state="translated">Когда он прикреплен к определению &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;packed&lt;/code&gt; атрибут указывает, что следует использовать наименьший интегральный тип. Указание</target>
        </trans-unit>
        <trans-unit id="3212c36750452527c536dd1eddfa9228aa24bc41" translate="yes" xml:space="preserve">
          <source>When branch is predicted to be taken with probability lower than this threshold (in percent), then it is considered well predictable.</source>
          <target state="translated">Когда предсказывается,что ветка будет взята с вероятностью ниже этого порога (в процентах),то это считается хорошо предсказуемым.</target>
        </trans-unit>
        <trans-unit id="f92818ac1f6c1cf9820bd7ad2460f0b770895e75" translate="yes" xml:space="preserve">
          <source>When branch probabilities are given, include those of unconditional branches. Unconditional branches are normally not interesting.</source>
          <target state="translated">Когда приводятся вероятности ветвей,включайте вероятности безусловных ветвей.Безусловные ветви обычно не интересны.</target>
        </trans-unit>
        <trans-unit id="0ae42b215512052c2cadc23355c16f5c5dd443cf" translate="yes" xml:space="preserve">
          <source>When calling routines that are not aware of the reservation, be cautious if those routines call back into code which uses them. As an example, if you call the system library version of &lt;code&gt;qsort&lt;/code&gt;, it may clobber your registers during execution, but (if you have selected appropriate registers) it will restore them before returning. However it will &lt;em&gt;not&lt;/em&gt; restore them before calling &lt;code&gt;qsort&lt;/code&gt;&amp;rsquo;s comparison function. As a result, global values will not reliably be available to the comparison function unless the &lt;code&gt;qsort&lt;/code&gt; function itself is rebuilt.</source>
          <target state="translated">При вызове подпрограмм, которые не знают о резервировании, будьте осторожны, если эти подпрограммы обращаются к коду, который их использует. Например, если вы вызываете версию &lt;code&gt;qsort&lt;/code&gt; из системной библиотеки , она может сбивать ваши регистры во время выполнения, но (если вы выбрали соответствующие регистры) восстановит их перед возвратом. Однако он &lt;em&gt;не&lt;/em&gt; восстановит их до вызова &lt;code&gt;qsort&lt;/code&gt; сравнения qsort . В результате глобальные значения не будут надежно доступны для функции сравнения, если сама функция &lt;code&gt;qsort&lt;/code&gt; не будет перестроена.</target>
        </trans-unit>
        <trans-unit id="6ce64a23abaaddcfa5831e43098fffe47be4e539" translate="yes" xml:space="preserve">
          <source>When casting from pointer to integer and back again, the resulting pointer must reference the same object as the original pointer, otherwise the behavior is undefined. That is, one may not use integer arithmetic to avoid the undefined behavior of pointer arithmetic as proscribed in C99 and C11 6.5.6/8.</source>
          <target state="translated">При приведении от указателя к целому и обратно результирующий указатель должен ссылаться на тот же объект,что и исходный указатель,иначе поведение будет неопределенным.То есть нельзя использовать целочисленную арифметику,чтобы избежать неопределённого поведения арифметики с указателями,как это запрещено в C99 и C11 6.5.6/8.</target>
        </trans-unit>
        <trans-unit id="4a6770a95cb182eb94130a66a137214e2a89e539" translate="yes" xml:space="preserve">
          <source>When code compiled with</source>
          <target state="translated">При компиляции кода с</target>
        </trans-unit>
        <trans-unit id="2694a5fd19642dc29f67abfd4afa306ec8d78457" translate="yes" xml:space="preserve">
          <source>When compiling C++, warn about the deprecated conversion from string literals to &lt;code&gt;char *&lt;/code&gt;. This warning is enabled by default for C++ programs.</source>
          <target state="translated">При компиляции C ++ предупредите об устаревшем преобразовании строковых литералов в &lt;code&gt;char *&lt;/code&gt; . Это предупреждение включено по умолчанию для программ на C ++.</target>
        </trans-unit>
        <trans-unit id="b58e8f8f470141f0b7d65fa2b304a55713649c15" translate="yes" xml:space="preserve">
          <source>When compiling C, give string constants the type &lt;code&gt;const
char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; so that copying the address of one into a non-&lt;code&gt;const&lt;/code&gt;&lt;code&gt;char *&lt;/code&gt; pointer produces a warning. These warnings help you find at compile time code that can try to write into a string constant, but only if you have been very careful about using &lt;code&gt;const&lt;/code&gt; in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not make</source>
          <target state="translated">При компиляции C присвойте строковым константам тип &lt;code&gt;const char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; чтобы при копировании адреса одной в указатель, не являющийся &lt;code&gt;const&lt;/code&gt; &lt;code&gt;char *&lt;/code&gt; , вызывалось предупреждение. Эти предупреждения помогут вам найти время компиляции кода , который может попытаться записать в строковую константу, но только если вы были очень осторожны при использовании &lt;code&gt;const&lt;/code&gt; в объявлениях и прототипах. В остальном это просто неприятность. Вот почему мы не сделали</target>
        </trans-unit>
        <trans-unit id="cd87062968fd1ca6c15b5a9b85fba86d8a5ccfc2" translate="yes" xml:space="preserve">
          <source>When compiling code for single processor systems, it is generally safe to use &lt;code&gt;synci&lt;/code&gt;. However, on many multi-core (SMP) systems, it does not invalidate the instruction caches on all cores and may lead to undefined behavior.</source>
          <target state="translated">При компиляции кода для однопроцессорных систем обычно безопасно использовать &lt;code&gt;synci&lt;/code&gt; . Однако во многих многоядерных (SMP) системах это не делает недействительными кеши инструкций на всех ядрах и может привести к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="7c10c0020a810534faa4083bee532dbff326c982" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed MIPS16 and non-MIPS16 code, the preprocessor symbol &lt;code&gt;__mips16&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed MIPS16 and non-MIPS16 code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">При компиляции файлов, содержащих смешанный код MIPS16 и не-MIPS16, символ препроцессора &lt;code&gt;__mips16&lt;/code&gt; отражает настройку в командной строке, а не в отдельных функциях. Смешанный код MIPS16 и не-MIPS16 может плохо взаимодействовать с некоторыми расширениями GCC, такими как &lt;code&gt;__builtin_apply&lt;/code&gt; (см. &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Создание вызовов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="60deff215e04b72131ce496d836442fb3376a9ed" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed microMIPS and non-microMIPS code, the preprocessor symbol &lt;code&gt;__mips_micromips&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed microMIPS and non-microMIPS code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">При компиляции файлов, содержащих смешанный код microMIPS и не microMIPS, символ препроцессора &lt;code&gt;__mips_micromips&lt;/code&gt; отражает настройку в командной строке, а не в отдельных функциях. Смешанный код microMIPS и не-microMIPS может плохо взаимодействовать с некоторыми расширениями GCC, такими как &lt;code&gt;__builtin_apply&lt;/code&gt; (см. &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Создание вызовов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b21353af5c286cba09d175d058607a98bab9646" translate="yes" xml:space="preserve">
          <source>When compiling files residing in directory</source>
          <target state="translated">При компиляции файлов,находящихся в каталоге</target>
        </trans-unit>
        <trans-unit id="fb1c662fe80e2a5daa84889e9b20929141a1f39e" translate="yes" xml:space="preserve">
          <source>When compiling for Nios II, the following options are allowed:</source>
          <target state="translated">При компиляции для Nios II допускаются следующие варианты:</target>
        </trans-unit>
        <trans-unit id="47a745ce02eda6e5b8af0283813b8d27ac893e5a" translate="yes" xml:space="preserve">
          <source>When compiling for the NeXT runtime, the compiler ordinarily replaces calls to &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; (when the name of the class is known at compile time) with static class references that get initialized at load time, which improves run-time performance. Specifying the</source>
          <target state="translated">При компиляции для среды выполнения NeXT компилятор обычно заменяет вызовы &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; (когда имя класса известно во время компиляции) статическими ссылками на классы, которые инициализируются во время загрузки, что улучшает производительность во время выполнения. Указание</target>
        </trans-unit>
        <trans-unit id="7acd9f9e9a72745fc09c352c58646de2d43a5f5e" translate="yes" xml:space="preserve">
          <source>When compiling functions that return &lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt;, PCC converts it to a double. GCC actually returns a &lt;code&gt;float&lt;/code&gt;. If you are concerned with PCC compatibility, you should declare your functions to return &lt;code&gt;double&lt;/code&gt;; you might as well say what you mean.</source>
          <target state="translated">При компиляции функций, возвращающих &lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt; , PCC преобразует его в double. GCC фактически возвращает число с &lt;code&gt;float&lt;/code&gt; . Если вас беспокоит совместимость с PCC, вы должны объявить, что ваши функции возвращают &lt;code&gt;double&lt;/code&gt; ; с таким же успехом вы можете сказать то, что имеете в виду.</target>
        </trans-unit>
        <trans-unit id="d5db0043541449725fbfb6c49474d3dea04ea8f6" translate="yes" xml:space="preserve">
          <source>When compiling functions that return structures or unions, GCC output code normally uses a method different from that used on most versions of Unix. As a result, code compiled with GCC cannot call a structure-returning function compiled with PCC, and vice versa.</source>
          <target state="translated">При компиляции функций,возвращающих структуры или объединения,выходной код GCC обычно использует метод,отличный от используемого в большинстве версий Unix.В результате,код,скомпилированный с помощью GCC,не может вызвать функцию возврата структуры,скомпилированную с помощью PCC,и наоборот.</target>
        </trans-unit>
        <trans-unit id="42802196182be1a26f30e794627d93f753ad7250" translate="yes" xml:space="preserve">
          <source>When compiling using the AAPCS ABI (or a variant of it) then valid values for the argument are &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; and &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;. In order to use a variant other than &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; then the compiler must be permitted to use the appropriate co-processor registers (i.e., the VFP registers must be available in order to use &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;). For example,</source>
          <target state="translated">При компиляции с использованием AAPCS ABI (или его варианта) допустимые значения для аргумента - &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; и &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; . Чтобы использовать вариант, отличный от &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; компилятору должно быть разрешено использовать соответствующие регистры сопроцессора (т. &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; VFP должны быть доступны для использования &amp;laquo;aapcs-vfp&amp;raquo; ). Например,</target>
        </trans-unit>
        <trans-unit id="47786f698591599dbf04987dfe010be22ff77e3c" translate="yes" xml:space="preserve">
          <source>When compiling with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f269c2c80bc0b6cd00bdccd1a4ad395d3f1e317" translate="yes" xml:space="preserve">
          <source>When compiling, this option enables</source>
          <target state="translated">При компиляции,эта опция включает</target>
        </trans-unit>
        <trans-unit id="315f128e4ce30c782f28bfb565507bc8d99b6552" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps (see</source>
          <target state="translated">При отладке дампа (см.</target>
        </trans-unit>
        <trans-unit id="dce8f6e7dddb2ada38853381a56083f98e91e173" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different compiler binaries and/or different text / bss / data / heap / stack / dso start locations.</source>
          <target state="translated">При отладке дампа подавляйте вывод адресов.Это делает более целесообразным использование diff при отладке дампов для вызовов компилятора с различными двоичными файлами компилятора и/или различными текстовыми/bss/data/heap/stack/dso стартовыми точками.</target>
        </trans-unit>
        <trans-unit id="5cb94325a71b749cb8e5d8b4041d1d7a131d0f11" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress instruction numbers and address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different options, in particular with and without</source>
          <target state="translated">При отладке дампа подавляйте номера команд и вывод адресов.Это делает более целесообразным использование diff при отладке дампов для вызовов компилятора с различными опциями,в частности,с и без</target>
        </trans-unit>
        <trans-unit id="6a3f0b550d9291ec66729667f3f7ca83fd2f4d8b" translate="yes" xml:space="preserve">
          <source>When dumping RTL, print the RTL in slim (condensed) form instead of the default LISP-like representation.</source>
          <target state="translated">При демпинге RTL,распечатайте RTL в тонком (конденсированном)виде вместо LISP-подобного представления по умолчанию.</target>
        </trans-unit>
        <trans-unit id="74301d6d6862291588f10bf29b45b4967ce13d2f" translate="yes" xml:space="preserve">
          <source>When dumping front-end intermediate representations, inhibit dumping of members of a scope or body of a function merely because that scope has been reached. Only dump such items when they are directly reachable by some other path.</source>
          <target state="translated">При сбросе фронтальных промежуточных представлений препятствуйте сбросу членов области видимости или тела функции только потому,что эта область видимости была достигнута.Выдавать такие элементы только тогда,когда они непосредственно доступны по какому-либо другому пути.</target>
        </trans-unit>
        <trans-unit id="f945883699fc9792ba3afeb26f744a7773586ecc" translate="yes" xml:space="preserve">
          <source>When dumping pretty-printed trees, this option inhibits dumping the bodies of control structures.</source>
          <target state="translated">При сбросе красиво напечатанных деревьев эта опция препятствует сбросу тел структур управления.</target>
        </trans-unit>
        <trans-unit id="6fc1555729570caee324aa057f7026754c896f3e" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural bitwise constant propagation. This flag is enabled by default at</source>
          <target state="translated">Если включено,выполняйте межпроцедурное битовое распространение константы.Этот флаг включен по умолчанию при</target>
        </trans-unit>
        <trans-unit id="bf82f180e269afc159377aa835c2b162d457aecd" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural propagation of value ranges. This flag is enabled by default at</source>
          <target state="translated">Если включено,выполните межпроцедурное распространение диапазонов значений.Этот флаг включен по умолчанию при</target>
        </trans-unit>
        <trans-unit id="5a6db9d98413978e8951a290a39c293b6dbce38a" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain CSYNC or SSYNC instructions too soon after conditional branches. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; is defined.</source>
          <target state="translated">Если этот параметр включен, компилятор гарантирует, что сгенерированный код не содержит инструкций CSYNC или SSYNC слишком быстро после условных переходов. Если используется эта опция, определяется &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cabeafae5f5d65fb548beb5767960c04d9a35b8" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain speculative loads after jump instructions. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; is defined.</source>
          <target state="translated">Если этот параметр включен, компилятор гарантирует, что сгенерированный код не содержит спекулятивных нагрузок после инструкций перехода. Если используется эта опция, определяется &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="177174ed256fb1fc5ac1ff6e0a69365e95922527" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler is free to take advantage of the knowledge that the entire program fits into the low 64k of memory.</source>
          <target state="translated">При включении компилятор может свободно воспользоваться знанием того,что вся программа помещается в низкий уровень 64k памяти.</target>
        </trans-unit>
        <trans-unit id="f1158beec156e6a8ecff5cd217a56a66d53e95d9" translate="yes" xml:space="preserve">
          <source>When enabled, this option states that a range reduction step is not needed when performing complex division. Also, there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case. The default is</source>
          <target state="translated">Если этот параметр включен, то при выполнении сложного деления шаг уменьшения диапазона не требуется. Кроме того, не проверяется, равен ли результат сложного умножения или деления &lt;code&gt;NaN + I*NaN&lt;/code&gt; , с попыткой спасти ситуацию в этом случае. По умолчанию</target>
        </trans-unit>
        <trans-unit id="5c41cf550423b99323059ab9102f75c243821bb0" translate="yes" xml:space="preserve">
          <source>When estimated performance improvement of caller + callee runtime exceeds this threshold (in percent), the function can be inlined regardless of the limit on</source>
          <target state="translated">Когда предполагаемое улучшение производительности вызывающего+вызываемого абонента превышает этот порог (в процентах),функция может быть включена независимо от лимита на</target>
        </trans-unit>
        <trans-unit id="0546498041d4ec0ccfc5ce36934cf27647842a41" translate="yes" xml:space="preserve">
          <source>When generating PIC code, do or don&amp;rsquo;t allow the use of PLTs. Ignored for non-PIC. The default is</source>
          <target state="translated">При генерации кода PIC разрешать или запрещать использование PLT. Игнорируется для не-PIC. По умолчанию</target>
        </trans-unit>
        <trans-unit id="511bcbbf68adbe04ec79792863471cde6b014863" translate="yes" xml:space="preserve">
          <source>When generating a function that returns a pointer, return the pointer in both &lt;code&gt;a0&lt;/code&gt; and &lt;code&gt;d0&lt;/code&gt;. Otherwise, the pointer is returned only in &lt;code&gt;a0&lt;/code&gt;, and attempts to call such functions without a prototype result in errors. Note that this option is on by default; use</source>
          <target state="translated">При создании функции, возвращающей указатель, возвращайте указатель как в &lt;code&gt;a0&lt;/code&gt; ,так и в &lt;code&gt;d0&lt;/code&gt; . В противном случае указатель возвращается только в &lt;code&gt;a0&lt;/code&gt; , и попытки вызвать такие функции без прототипа приводят к ошибкам. Обратите внимание, что этот параметр включен по умолчанию; использование</target>
        </trans-unit>
        <trans-unit id="dd2029500976920c4504065ca16226229e4f7c22" translate="yes" xml:space="preserve">
          <source>When generating assembler output use a syntax that is compatible with Renesas&amp;rsquo;s AS100 assembler. This syntax can also be handled by the GAS assembler, but it has some restrictions so it is not generated by default.</source>
          <target state="translated">При создании вывода на ассемблере используйте синтаксис, совместимый с ассемблером Renesas AS100. Этот синтаксис также может обрабатываться ассемблером GAS, но у него есть некоторые ограничения, поэтому он не генерируется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="34010eecdc80bda1996b3453a5842eca5948c6ad" translate="yes" xml:space="preserve">
          <source>When generating code for shared libraries,</source>
          <target state="translated">При генерации кода для разделяемых библиотек,</target>
        </trans-unit>
        <trans-unit id="ee57ba558572772d8e7d0fd148c855146cc649ba" translate="yes" xml:space="preserve">
          <source>When generating code for the x86-64 architecture with SSE extensions disabled,</source>
          <target state="translated">При генерации кода для архитектуры x86-64 с отключенными SSE расширениями,</target>
        </trans-unit>
        <trans-unit id="8c85713507dce4f24637fdca8c9dd42ecd242b3b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code for ColdFire, generate code that works if the GOT has more than 8192 entries. This code is larger and slower than code generated without this option. On M680x0 processors, this option is not needed;</source>
          <target state="translated">При генерации позиционно-независимого кода для ColdFire,генерируйте код,который работает,если GOT имеет более 8192 записей.Этот код больше и медленнее,чем код,генерируемый без этой опции.На процессорах M680x0 эта опция не требуется;</target>
        </trans-unit>
        <trans-unit id="ddb821edf6cd4d8eabb391980c4305801a4dd35b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code, emit function calls using the Global Offset Table instead of the Procedure Linkage Table.</source>
          <target state="translated">При генерации позиционно-независимого кода,излучайте вызовы функций с использованием Глобальной таблицы смещений вместо Таблицы связи процедур.</target>
        </trans-unit>
        <trans-unit id="58318867846389e3f00483e730d9cdc45f04b844" translate="yes" xml:space="preserve">
          <source>When implementing patterns for these built-in functions, the memory order parameter can be ignored as long as the pattern implements the most restrictive &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; memory order. Any of the other memory orders execute correctly with this memory order but they may not execute as efficiently as they could with a more appropriate implementation of the relaxed requirements.</source>
          <target state="translated">При реализации шаблонов для этих встроенных функций параметр порядка памяти можно игнорировать, пока шаблон реализует наиболее строгий &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; памяти __ATOMIC_SEQ_CST . Любой из других порядков памяти выполняется правильно с этим порядком памяти, но они могут выполняться не так эффективно, как могли бы при более подходящей реализации ослабленных требований.</target>
        </trans-unit>
        <trans-unit id="e9af953ed4f40761c964f415712e4b881671dfb2" translate="yes" xml:space="preserve">
          <source>When linking a big-endian image select between BE8 and BE32 formats. The option has no effect for little-endian images and is ignored. The default is dependent on the selected target architecture. For ARMv6 and later architectures the default is BE8, for older architectures the default is BE32. BE32 format has been deprecated by ARM.</source>
          <target state="translated">При привязке изображения с большой диагональю выберите между форматами BE8 и BE32.Опция не имеет эффекта для биг-ендианских растров и игнорируется.Значение по умолчанию зависит от выбранной целевой архитектуры.Для архитектур ARMv6 и более поздних версий по умолчанию используется BE8,для более старых архитектур-BE32.Формат BE32 был устарел от ARM.</target>
        </trans-unit>
        <trans-unit id="920068058745daad77bac4500e9d9b0ac2200c05" translate="yes" xml:space="preserve">
          <source>When making copies of thread-local variables in a transaction, this parameter specifies the size in bytes after which variables are saved with the logging functions as opposed to save/restore code sequence pairs. This option only applies when using</source>
          <target state="translated">При копировании потоколокальных переменных в транзакции данный параметр задает размер в байтах,после чего переменные сохраняются функциями протоколирования,а не парами сохранения/восстановления последовательности кода.Данный параметр применяется только при использовании</target>
        </trans-unit>
        <trans-unit id="20fd5eb54a80ab92bcf13e1600542aa28ff5d13b" translate="yes" xml:space="preserve">
          <source>When mangling a function type with function-cv-qualifiers, the un-qualified function type was incorrectly treated as a substitution candidate.</source>
          <target state="translated">При использовании функционального типа с функциями-cv-квалификаторами,неквалифицированный тип функции ошибочно рассматривался как кандидат на замену.</target>
        </trans-unit>
        <trans-unit id="6e16f38a870c014c4bf05a4ba66aff0d8f015c53" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are three output operands, use &amp;lsquo;</source>
          <target state="translated">Если &lt;var&gt;asmSymbolicName&lt;/var&gt; не используется, используйте позицию (отсчитывающуюся от нуля) операнда в списке операндов в шаблоне ассемблера. Например, если есть три выходных операнда, используйте '</target>
        </trans-unit>
        <trans-unit id="f7f108470bcf6e6b304f3263a3362bac9bf0990f" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are two output operands and three inputs, use &amp;lsquo;</source>
          <target state="translated">Если &lt;var&gt;asmSymbolicName&lt;/var&gt; не используется, используйте позицию (отсчитывающуюся от нуля) операнда в списке операндов в шаблоне ассемблера. Например, если есть два выходных операнда и три входа, используйте '</target>
        </trans-unit>
        <trans-unit id="9ab94547949a5e4c3215ae42df94303adb7916f4" translate="yes" xml:space="preserve">
          <source>When optimizing for size (using</source>
          <target state="translated">При оптимизации размера (используя</target>
        </trans-unit>
        <trans-unit id="97bc78492cc0f58dc12735620055de6a1daa4843" translate="yes" xml:space="preserve">
          <source>When passed this option, GCC produces a dynamic library instead of an executable when linking, using the Darwin</source>
          <target state="translated">При передаче этой опции GCC создает динамическую библиотеку вместо исполняемого файла при линковке,используя Darwin</target>
        </trans-unit>
        <trans-unit id="f2411855bc2157c02295a4d406d5bb74f6ed2885" translate="yes" xml:space="preserve">
          <source>When performing a stack backtrace, code can inspect the value of &lt;code&gt;pc&lt;/code&gt; stored at &lt;code&gt;fp + 0&lt;/code&gt;. If the trace function then looks at location &lt;code&gt;pc - 12&lt;/code&gt; and the top 8 bits are set, then we know that there is a function name embedded immediately preceding this location and has length &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt;.</source>
          <target state="translated">При выполнении трассировки стека код может проверять значение &lt;code&gt;pc&lt;/code&gt; , хранящееся в &lt;code&gt;fp + 0&lt;/code&gt; . Если функция трассировки затем смотрит на местоположение &lt;code&gt;pc - 12&lt;/code&gt; и установлены верхние 8 бит, то мы знаем, что имя функции встроено непосредственно перед этим местоположением и имеет длину &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f597a9e8b63ff1121b0842bcdb388264d1b3c5ff" translate="yes" xml:space="preserve">
          <source>When performing branch target register load optimization, don&amp;rsquo;t reuse branch target registers within any basic block.</source>
          <target state="translated">При выполнении оптимизации загрузки целевого регистра перехода не используйте повторно целевые регистры перехода в любом базовом блоке.</target>
        </trans-unit>
        <trans-unit id="9c01537a52102dd8946fc5982208fe491740f320" translate="yes" xml:space="preserve">
          <source>When pipelining loops during selective scheduling, also pipeline outer loops. This option has no effect unless</source>
          <target state="translated">При селективной прокладке трубопроводных контуров во время селективного планирования,необходимо также прокладывать внешние контуры трубопровода.Этот вариант не имеет эффекта,если только</target>
        </trans-unit>
        <trans-unit id="1280e31b08d3497c525b6d236dd8d4d87c36c837" translate="yes" xml:space="preserve">
          <source>When preprocessing files residing in directory</source>
          <target state="translated">При препроцессировании файлов,находящихся в каталоге</target>
        </trans-unit>
        <trans-unit id="18019b7cb63563a2a1382c41adbfffdfc589112f" translate="yes" xml:space="preserve">
          <source>When preprocessing, do not shorten system header paths with canonicalization.</source>
          <target state="translated">При препроцессировании не укорачивайте системные пути заголовков с каноническим исполнением.</target>
        </trans-unit>
        <trans-unit id="2727468a8d8ea18794592843d12955ca0144b622" translate="yes" xml:space="preserve">
          <source>When preprocessing, handle directives, but do not expand macros.</source>
          <target state="translated">При препроцессировании обрабатывайте директивы,но не расширяйте макросы.</target>
        </trans-unit>
        <trans-unit id="bb09a7ade548f20e19021a30661ff4362be9b030" translate="yes" xml:space="preserve">
          <source>When printing percentages, 0% and 100% are only printed when the values are &lt;em&gt;exactly&lt;/em&gt; 0% and 100% respectively. Other values which would conventionally be rounded to 0% or 100% are instead printed as the nearest non-boundary value.</source>
          <target state="translated">При печати в процентах, 0% и 100% печатаются только тогда , когда значения &lt;em&gt;ровно&lt;/em&gt; 0% и 100% соответственно. Другие значения, которые обычно округляются до 0% или 100%, вместо этого печатаются как ближайшее не граничное значение.</target>
        </trans-unit>
        <trans-unit id="814abd66e9c273530f2d56ad0a0cd6cc246294fd" translate="yes" xml:space="preserve">
          <source>When producing the final binary, GCC only applies link-time optimizations to those files that contain bytecode. Therefore, you can mix and match object files and libraries with GIMPLE bytecodes and final object code. GCC automatically selects which files to optimize in LTO mode and which files to link without further processing.</source>
          <target state="translated">При создании финального двоичного файла GCC применяет оптимизацию во времени компоновки только к тем файлам,которые содержат байткод.Таким образом,вы можете смешивать и сопоставлять объектные файлы и библиотеки с байткодами GIMPLE и конечным объектным кодом.GCC автоматически выбирает,какие файлы оптимизировать в режиме LTO,а какие компоновать без дальнейшей обработки.</target>
        </trans-unit>
        <trans-unit id="b96765bcbef2cdc563af58e2e7b14e500edcf025" translate="yes" xml:space="preserve">
          <source>When profile feedback is available (see</source>
          <target state="translated">Когда доступен отзыв профиля (см.</target>
        </trans-unit>
        <trans-unit id="21ec7c5b40c9ae6af5acdf4a048ad5c0d3bce4e5" translate="yes" xml:space="preserve">
          <source>When profile feedback is available, via</source>
          <target state="translated">Когда отзыв профиля доступен,через</target>
        </trans-unit>
        <trans-unit id="2f272057236473f0d19fb086d6183a38dfbd5bad" translate="yes" xml:space="preserve">
          <source>When reading data from memory in sizes shorter than 64 bits, use (do not use) zero-extending load instructions by default, rather than sign-extending ones.</source>
          <target state="translated">При чтении данных из памяти размером меньше 64 бит используйте (не используйте)по умолчанию не знаково-расширяющие инструкции загрузки,а нулевые.</target>
        </trans-unit>
        <trans-unit id="f96511339203319c533d1e5bb317204cec489683" translate="yes" xml:space="preserve">
          <source>When scheduling after register allocation, use superblock scheduling. This allows motion across basic block boundaries, resulting in faster schedules. This option is experimental, as not all machine descriptions used by GCC model the CPU closely enough to avoid unreliable results from the algorithm.</source>
          <target state="translated">При составлении расписания после распределения регистров используйте планирование суперблоков.Это позволяет перемещаться через границы основных блоков,что приводит к более быстрому составлению расписаний.Эта опция является экспериментальной,так как не все описания машин,используемые GCC моделью CPU достаточно близко,чтобы избежать ненадежных результатов от алгоритма.</target>
        </trans-unit>
        <trans-unit id="711283accf977e698dde3a25dc400a61116947e3" translate="yes" xml:space="preserve">
          <source>When selecting a register, choose one that is normally saved and restored by function calls on your machine. This ensures that code which is unaware of this reservation (such as library routines) will restore it before returning.</source>
          <target state="translated">При выборе регистра выберите тот,который обычно сохраняется и восстанавливается по вызовам функций на вашем аппарате.Это гарантирует,что код,который не знает об этом резервировании (например,библиотечные процедуры),восстановит его перед возвращением.</target>
        </trans-unit>
        <trans-unit id="935d1b181ddc0bd3e6f68299a5752f8a09580e76" translate="yes" xml:space="preserve">
          <source>When selecting this option, be aware that the standard library headers do not obey all of these guidelines; use &amp;lsquo;</source>
          <target state="translated">Выбирая эту опцию, помните, что заголовки стандартной библиотеки не подчиняются всем этим рекомендациям; использовать '</target>
        </trans-unit>
        <trans-unit id="30da98647c378a61b9ead522311838c64d97cf26" translate="yes" xml:space="preserve">
          <source>When supplied with a 128-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a quad-precision ieee floating point value. The sign bit of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 15 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 112 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="translated">При наличии 128-битного первого аргумента встроенная функция &lt;code&gt;scalar_insert_exp&lt;/code&gt; возвращает значение с плавающей запятой ieee с четырехкратной точностью. Знаковый бит результата копируется из старшего разряда &lt;code&gt;significand&lt;/code&gt; аргумента. Мантиссы и экспоненты компоненты результата состоят из наименее значимых 15 битых &lt;code&gt;exponent&lt;/code&gt; аргумента и наименее значимых бит 112 в &lt;code&gt;significand&lt;/code&gt; аргумента соответственно.</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">Когда</target>
        </trans-unit>
        <trans-unit id="82085de4f0e784cd78a6493470847db57c3b16cf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;g++&lt;/code&gt; program is used to link a C++ program, it normally automatically links against</source>
          <target state="translated">Когда программа &lt;code&gt;g++&lt;/code&gt; используется для связывания программы на C ++, она обычно автоматически связывается с</target>
        </trans-unit>
        <trans-unit id="9d1f5e646a4aa7fceb07c0207db652e826f24dbb" translate="yes" xml:space="preserve">
          <source>When the address-of operator is applied to a thread-local variable, it is evaluated at run time and returns the address of the current thread&amp;rsquo;s instance of that variable. An address so obtained may be used by any thread. When a thread terminates, any pointers to thread-local variables in that thread become invalid.</source>
          <target state="translated">Когда оператор адресации применяется к локальной переменной потока, она оценивается во время выполнения и возвращает адрес экземпляра этой переменной текущего потока. Полученный таким образом адрес может использоваться любым потоком. Когда поток завершается, любые указатели на локальные переменные потока в этом потоке становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="0b679da0a8fd732962aaaa73513d25a32daf4775" translate="yes" xml:space="preserve">
          <source>When the compiled program exits it saves this data to a file called</source>
          <target state="translated">Когда скомпилированная программа выходит из программы,она сохраняет эти данные в файл с именем</target>
        </trans-unit>
        <trans-unit id="ba14367decd6810d3de98e37ab796a274e5fcb83" translate="yes" xml:space="preserve">
          <source>When the compiler creates the statically allocated constant string object, the &lt;code&gt;c_string&lt;/code&gt; field will be filled by the compiler with the string; the &lt;code&gt;length&lt;/code&gt; field will be filled by the compiler with the string length; the &lt;code&gt;isa&lt;/code&gt; pointer will be filled with &lt;code&gt;NULL&lt;/code&gt; by the compiler, and it will later be fixed up automatically at runtime by the GNU Objective-C runtime library to point to the class which was set by the</source>
          <target state="translated">Когда компилятор создает статически выделенный строковый объект- &lt;code&gt;c_string&lt;/code&gt; поле c_string будет заполнено компилятором строкой; &lt;code&gt;length&lt;/code&gt; поле будет заполнено компилятором с длиной строки; &lt;code&gt;isa&lt;/code&gt; указатель будет заполнен &lt;code&gt;NULL&lt;/code&gt; компилятором, и он будет позже фиксируется автоматически во время выполнения в Objective-C библиотеки времени выполнения GNU в точке к классу , который был задан</target>
        </trans-unit>
        <trans-unit id="75d541d9bedf275908dc64ccacf78982bc497338" translate="yes" xml:space="preserve">
          <source>When the compiler fixes up the operands to satisfy the constraints, it needs to know which operands are read by the instruction and which are written by it. &amp;lsquo;</source>
          <target state="translated">Когда компилятор исправляет операнды для удовлетворения ограничений, ему необходимо знать, какие операнды считываются инструкцией, а какие записываются ею. '</target>
        </trans-unit>
        <trans-unit id="fe9038c60a954d7fa872648aae2a7292450a7e26" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the input operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">Когда компилятор выбирает регистры для использования для представления входных операндов, он не использует ни один из затираемых регистров (см. &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers и Scratch Registers&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc0664d7c952e60ae422d980b70454766a66b5fe" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the output operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">Когда компилятор выбирает регистры для использования для представления выходных операндов, он не использует ни один из затираемых регистров (см. &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers и Scratch Registers&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9af3756142eed3c562da1e3a657ce9b62976062a" translate="yes" xml:space="preserve">
          <source>When the compiler selects which registers to use to represent input and output operands, it does not use any of the clobbered registers. As a result, clobbered registers are available for any use in the assembler code.</source>
          <target state="translated">Когда компилятор выбирает,какие регистры использовать для представления операндов ввода и вывода,он не использует ни один из забитых регистров.В результате,забитые регистры доступны для любого использования в ассемблерном коде.</target>
        </trans-unit>
        <trans-unit id="c3d75a61bee977e603b0ea8873c523597d8f39fa" translate="yes" xml:space="preserve">
          <source>When the garbage collector is used, the objects are allocated using the so-called typed memory allocation mechanism available in the Boehm-Demers-Weiser collector. This mode requires precise information on where pointers are located inside objects. This information is computed once per class, immediately after the class has been initialized.</source>
          <target state="translated">При использовании сборщика мусора объекты выделяются с помощью так называемого механизма типизированного выделения памяти,доступного в коллекторе Boehm-Demers-Weiser.Этот режим требует точной информации о том,где находятся указатели внутри объектов.Эта информация вычисляется один раз для каждого класса,сразу после инициализации класса.</target>
        </trans-unit>
        <trans-unit id="ce04df43b58d0607f55d930a3e25d2b0c0d86fd3" translate="yes" xml:space="preserve">
          <source>When the instructions are enabled GCC defines the C preprocessor symbol &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt;, otherwise it defines the symbol &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt;.</source>
          <target state="translated">Когда инструкции включены, GCC определяет символ препроцессора C &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt; , в противном случае он определяет символ &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="237034d602a7895e4b871df52b8d8208437c1b5e" translate="yes" xml:space="preserve">
          <source>When the option</source>
          <target state="translated">Когда вариант</target>
        </trans-unit>
        <trans-unit id="f59a2028d7f7059c14cfbb4f7cac2e937416cda2" translate="yes" xml:space="preserve">
          <source>When the value of a decimal floating type cannot be represented in the integer type to which it is being converted, the result is undefined rather than the result value specified by the draft technical report.</source>
          <target state="translated">Когда значение десятичного плавающего типа не может быть представлено в целочисленном типе,к которому оно приводится,результат является неопределенным,а не результатом,указанным в проекте технического отчета.</target>
        </trans-unit>
        <trans-unit id="43dfcc6f2fffee0a3a2515bfa1a37e71e51242de" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 1.</source>
          <target state="translated">Когда этот флаг установлен, макросам &lt;code&gt;__pic__&lt;/code&gt; и &lt;code&gt;__PIC__&lt;/code&gt; присваивается значение 1.</target>
        </trans-unit>
        <trans-unit id="44c57deb401735025dc176c7c63debf58618c2fc" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 2.</source>
          <target state="translated">Когда этот флаг установлен, макросам &lt;code&gt;__pic__&lt;/code&gt; и &lt;code&gt;__PIC__&lt;/code&gt; присвоено значение 2.</target>
        </trans-unit>
        <trans-unit id="4a1317c4b8d2af979d94b62164c9d7ecd9184a36" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC inserts &lt;code&gt;MEMW&lt;/code&gt; instructions before &lt;code&gt;volatile&lt;/code&gt; memory references to guarantee sequential consistency. The default is</source>
          <target state="translated">Когда этот параметр включен, GCC вставляет инструкции &lt;code&gt;MEMW&lt;/code&gt; перед ссылками на &lt;code&gt;volatile&lt;/code&gt; память, чтобы гарантировать последовательную согласованность. По умолчанию</target>
        </trans-unit>
        <trans-unit id="4f8fad713a34ff4dd67014e2a8d65e863876b686" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to automatically align instructions to reduce branch penalties at the expense of some code density. The assembler attempts to widen density instructions to align branch targets and the instructions following call instructions. If there are not enough preceding safe density instructions to align a target, no widening is performed. The default is</source>
          <target state="translated">Когда эта опция включена,GCC инструктирует ассемблера автоматически выравнивать инструкции для уменьшения штрафов за ветки за счет некоторой плотности кода.Ассемблер пытается расширить инструкции по выравниванию плотности ветвей,а также инструкции,следующие за инструкциями по вызову.Если предшествующих инструкций по безопасному выравниванию плотности недостаточно для выравнивания цели,то расширение не выполняется.По умолчанию</target>
        </trans-unit>
        <trans-unit id="6aace4cd615149f89dea8fcd082fb55d9878fa43" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to translate direct calls to indirect calls unless it can determine that the target of a direct call is in the range allowed by the call instruction. This translation typically occurs for calls to functions in other source files. Specifically, the assembler translates a direct &lt;code&gt;CALL&lt;/code&gt; instruction into an &lt;code&gt;L32R&lt;/code&gt; followed by a &lt;code&gt;CALLX&lt;/code&gt; instruction. The default is</source>
          <target state="translated">Когда эта опция включена, GCC инструктирует ассемблер переводить прямые вызовы в косвенные вызовы, если он не может определить, что цель прямого вызова находится в диапазоне, разрешенном инструкцией вызова. Этот перевод обычно происходит для вызовов функций в других исходных файлах. В частности, ассемблер переводит прямую инструкцию &lt;code&gt;CALL&lt;/code&gt; в &lt;code&gt;L32R&lt;/code&gt; , за которой &lt;code&gt;CALLX&lt;/code&gt; инструкция CALLX . По умолчанию</target>
        </trans-unit>
        <trans-unit id="932f419fffb4962ea09a2d68b7d48f6dd70fbe9a" translate="yes" xml:space="preserve">
          <source>When this option is not used, GCC optimizes for the processor specified by</source>
          <target state="translated">Когда эта опция не используется,GCC оптимизирует для процессора,указанного в параметре</target>
        </trans-unit>
        <trans-unit id="d8e1351858aa322f0a55264f24813443d8991eb4" translate="yes" xml:space="preserve">
          <source>When this option is passed to the compiler driver, it causes the &lt;em&gt;first&lt;/em&gt; compilation to be skipped, which makes it useful for little other than debugging the compiler proper.</source>
          <target state="translated">Когда этот параметр передается драйверу компилятора, он приводит к пропуску &lt;em&gt;первой&lt;/em&gt; компиляции, что делает ее полезной практически для всех, кроме собственно отладки компилятора.</target>
        </trans-unit>
        <trans-unit id="9e23f54eaa8f9101922e305be1e7015dd6fc78fe" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">Когда эта версия ABI включена, определяется символ препроцессора C &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a3a63e7e68adaacd52d22d0fef6ef4e247546c7" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">Когда эта версия ABI включена, определяется символ препроцессора C &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffcbc5063df93d534e3fd1a9be3948f3d608cc53" translate="yes" xml:space="preserve">
          <source>When trying to fill delay slots, the maximum number of instructions to consider when searching for a block with valid live register information. Increasing this arbitrarily chosen value means more aggressive optimization, increasing the compilation time. This parameter should be removed when the delay slot code is rewritten to maintain the control-flow graph.</source>
          <target state="translated">При попытке заполнить слоты задержки,максимальное количество инструкций,которые необходимо учитывать при поиске блока с достоверной информацией о живом регистре.Увеличение этого произвольно выбранного значения означает более агрессивную оптимизацию,увеличение времени компиляции.Этот параметр следует удалять,когда код слота задержки переписывается для поддержания графа управляющего потока.</target>
        </trans-unit>
        <trans-unit id="ca1100086e04f30d15e50b0b6ef7fef7de69d02a" translate="yes" xml:space="preserve">
          <source>When used as part of the register variable extension, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">При использовании как части расширения регистровой переменной см. &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Явные регистровые переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="106a6c1a466d5af73cd467f48ab954141e8dae1a" translate="yes" xml:space="preserve">
          <source>When used as the pattern of a pack expansion within a template definition, expands to a template argument pack containing integers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt;. This is provided for efficient implementation of &lt;code&gt;std::make_integer_sequence&lt;/code&gt;.</source>
          <target state="translated">При использовании в качестве шаблона расширения пакета в определении шаблона расширяется до пакета аргументов шаблона, содержащего целые числа от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;length-1&lt;/code&gt; . Это предусмотрено для эффективной реализации &lt;code&gt;std::make_integer_sequence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="780fee7b38bbbc14d6460730fc730c12ac99a32c" translate="yes" xml:space="preserve">
          <source>When used from GCC without</source>
          <target state="translated">При использовании из GCC без</target>
        </trans-unit>
        <trans-unit id="0e9e8833e240e4ed56f0fb1a36eb014753411cc2" translate="yes" xml:space="preserve">
          <source>When used in combination with</source>
          <target state="translated">При использовании в сочетании с</target>
        </trans-unit>
        <trans-unit id="4ec2dc1132b93e0ccc417d346f716fa8317dce1d" translate="yes" xml:space="preserve">
          <source>When used in combination with the</source>
          <target state="translated">При использовании в сочетании с</target>
        </trans-unit>
        <trans-unit id="7e7b12188944613e3ecc2fd00ed8b819fb8ad2ca" translate="yes" xml:space="preserve">
          <source>When used in conjunction with</source>
          <target state="translated">При использовании в сочетании с</target>
        </trans-unit>
        <trans-unit id="49cb60ae0da0fc7302708101bdf54d1b69871514" translate="yes" xml:space="preserve">
          <source>When used on a struct, or struct member, the &lt;code&gt;aligned&lt;/code&gt; attribute can only increase the alignment; in order to decrease it, the &lt;code&gt;packed&lt;/code&gt; attribute must be specified as well. When used as part of a typedef, the &lt;code&gt;aligned&lt;/code&gt; attribute can both increase and decrease alignment, and specifying the &lt;code&gt;packed&lt;/code&gt; attribute generates a warning.</source>
          <target state="translated">При использовании в структуре или члене структуры, &lt;code&gt;aligned&lt;/code&gt; атрибут может только увеличить выравнивание; для его уменьшения необходимо указать также и &lt;code&gt;packed&lt;/code&gt; атрибут. При использовании как часть typedef атрибут &lt;code&gt;aligned&lt;/code&gt; может как увеличивать, так и уменьшать выравнивание, а указание атрибута &lt;code&gt;packed&lt;/code&gt; генерирует предупреждение.</target>
        </trans-unit>
        <trans-unit id="9e5e1c3d3ae3ca589eb9e745a2edd3f0de6b0b04" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt;, code is generated to load the stack pointer from the USP register in the function prologue.</source>
          <target state="translated">При использовании вместе с &lt;code&gt;interrupt_handler&lt;/code&gt; , &lt;code&gt;exception_handler&lt;/code&gt; или &lt;code&gt;nmi_handler&lt;/code&gt; создается код для загрузки указателя стека из регистра USP в прологе функции.</target>
        </trans-unit>
        <trans-unit id="0fa555d9978b74bbd46ce823e883fc5dc96ece10" translate="yes" xml:space="preserve">
          <source>When used together,</source>
          <target state="translated">При совместном использовании,</target>
        </trans-unit>
        <trans-unit id="dd9e3fff8e9f3de600aeb120c0ac434ae6e8fd7f" translate="yes" xml:space="preserve">
          <source>When used with</source>
          <target state="translated">При использовании с</target>
        </trans-unit>
        <trans-unit id="92cecb0d71e3d06f0f2ee726aec0670791ccea60" translate="yes" xml:space="preserve">
          <source>When used with GNU ld version 2.8 or later on an ELF system such as GNU/Linux or Solaris 2, or on Microsoft Windows, duplicate copies of these constructs will be discarded at link time. This is known as COMDAT support.</source>
          <target state="translated">При использовании с GNU ld версии 2.8 или более поздней в системе ELF,такой как GNU/Linux или Solaris 2,или в Microsoft Windows дубликаты этих конструкций будут отбрасываться во время компоновки.Это известно как поддержка COMDAT.</target>
        </trans-unit>
        <trans-unit id="3e4af787046ae7ade38ea86db68f50943f9b708f" translate="yes" xml:space="preserve">
          <source>When used with the driver options</source>
          <target state="translated">При использовании с опциями драйвера</target>
        </trans-unit>
        <trans-unit id="c37b9bb49622ff1b2c39fa2ca14e91b87c1c3e6e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;__vector&lt;/code&gt; instead of &lt;code&gt;vector&lt;/code&gt;; for example,</source>
          <target state="translated">При использовании &lt;code&gt;__vector&lt;/code&gt; вместо &lt;code&gt;vector&lt;/code&gt; ; например,</target>
        </trans-unit>
        <trans-unit id="6b2bcfc1c3c9cde870c3782ea70e6faf69a223bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;gcov&lt;/code&gt;, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">При использовании &lt;code&gt;gcov&lt;/code&gt; вы должны сначала скомпилировать свою программу со специальной опцией GCC '</target>
        </trans-unit>
        <trans-unit id="813ae21e068ea720242cb9123e52a1c2bfc86b90" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vector&lt;/code&gt; in keyword-and-predefine mode; for example,</source>
          <target state="translated">При использовании &lt;code&gt;vector&lt;/code&gt; в режиме ключевых слов и предопределения; например,</target>
        </trans-unit>
        <trans-unit id="ff0142771a5792099b24be57745c687b91541e72" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;wa&lt;/code&gt;, you should use the &lt;code&gt;%x&lt;/code&gt; output modifier, so that the correct register number is printed. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5643f8856029d91e0b316af45e590b017e03b023" translate="yes" xml:space="preserve">
          <source>When using &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt;, gcov uses the full pathname of the source files to create an output filename. This can lead to long filenames that can overflow filesystem limits. This option creates names of the form</source>
          <target state="translated">При использовании &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt; gcov использует полный путь к исходным файлам для создания имени файла вывода. Это может привести к длинным именам файлов, которые могут выйти за рамки ограничений файловой системы. Эта опция создает имена формы</target>
        </trans-unit>
        <trans-unit id="86e384abcdbbd0ac6dda953fb252a5fa852b9cab" translate="yes" xml:space="preserve">
          <source>When using DWARF Version 4 or higher, type DIEs can be put into their own &lt;code&gt;.debug_types&lt;/code&gt; section instead of making them part of the &lt;code&gt;.debug_info&lt;/code&gt; section. It is more efficient to put them in a separate comdat section since the linker can then remove duplicates. But not all DWARF consumers support &lt;code&gt;.debug_types&lt;/code&gt; sections yet and on some objects &lt;code&gt;.debug_types&lt;/code&gt; produces larger instead of smaller debugging information.</source>
          <target state="translated">При использовании DWARF версии 4 или выше, типы DIE можно поместить в &lt;code&gt;.debug_types&lt;/code&gt; раздел .debug_types вместо того, чтобы делать их частью раздела &lt;code&gt;.debug_info&lt;/code&gt; . Более эффективно поместить их в отдельный раздел comdat, так как компоновщик может удалить дубликаты. Но не все потребители &lt;code&gt;.debug_types&lt;/code&gt; пока поддерживают разделы .debug_types, а для некоторых объектов &lt;code&gt;.debug_types&lt;/code&gt; дает больше, а не меньшую отладочную информацию.</target>
        </trans-unit>
        <trans-unit id="7fb27cfc2abe0d594f6b16d8710a96a8aeba9d2c" translate="yes" xml:space="preserve">
          <source>When using a reference to volatile, G++ does not treat equivalent expressions as accesses to volatiles, but instead issues a warning that no volatile is accessed. The rationale for this is that otherwise it becomes difficult to determine where volatile access occur, and not possible to ignore the return value from functions returning volatile references. Again, if you wish to force a read, cast the reference to an rvalue.</source>
          <target state="translated">При использовании ссылки на volatile,G++не рассматривает эквивалентные выражения как доступ к волатилям,а выдает предупреждение об отсутствии доступа к волатилям.Это объясняется тем,что в противном случае становится сложно определить,где происходит обращение к волатильности,и невозможно игнорировать возвращаемое значение из функций,возвращающих волатильные ссылки.Опять же,если вы хотите принудительно прочитать,бросьте ссылку на значение rvalue.</target>
        </trans-unit>
        <trans-unit id="ffb95a64a466d2bd4851566c5320aa64fa40418e" translate="yes" xml:space="preserve">
          <source>When using a type that occupies multiple registers, such as &lt;code&gt;long
long&lt;/code&gt; on a 32-bit system, split the registers apart and allocate them independently. This normally generates better code for those types, but may make debugging more difficult.</source>
          <target state="translated">При использовании типа, который занимает несколько регистров, например &lt;code&gt;long long&lt;/code&gt; в 32-разрядной системе, разделите регистры на части и распределите их независимо. Обычно это создает лучший код для этих типов, но может затруднить отладку.</target>
        </trans-unit>
        <trans-unit id="f38f792e072335436a4ef70d8d149701336de24f" translate="yes" xml:space="preserve">
          <source>When using any of the register constraints (&lt;code&gt;wa&lt;/code&gt;, &lt;code&gt;wd&lt;/code&gt;, &lt;code&gt;wf&lt;/code&gt;, &lt;code&gt;wg&lt;/code&gt;, &lt;code&gt;wh&lt;/code&gt;, &lt;code&gt;wi&lt;/code&gt;, &lt;code&gt;wj&lt;/code&gt;, &lt;code&gt;wk&lt;/code&gt;, &lt;code&gt;wl&lt;/code&gt;, &lt;code&gt;wm&lt;/code&gt;, &lt;code&gt;wo&lt;/code&gt;, &lt;code&gt;wp&lt;/code&gt;, &lt;code&gt;wq&lt;/code&gt;, &lt;code&gt;ws&lt;/code&gt;, &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;wu&lt;/code&gt;, &lt;code&gt;wv&lt;/code&gt;, &lt;code&gt;ww&lt;/code&gt;, or &lt;code&gt;wy&lt;/code&gt;) that take VSX registers, you must use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; in the template so that the correct register is used. Otherwise the register number output in the assembly file will be incorrect if an Altivec register is an operand of a VSX instruction that expects VSX register numbering.</source>
          <target state="translated">При использовании любых ограничений регистров ( &lt;code&gt;wa&lt;/code&gt; , &lt;code&gt;wd&lt;/code&gt; , &lt;code&gt;wf&lt;/code&gt; , &lt;code&gt;wg&lt;/code&gt; , &lt;code&gt;wh&lt;/code&gt; , &lt;code&gt;wi&lt;/code&gt; , &lt;code&gt;wj&lt;/code&gt; , &lt;code&gt;wk&lt;/code&gt; , &lt;code&gt;wl&lt;/code&gt; , &lt;code&gt;wm&lt;/code&gt; , &lt;code&gt;wo&lt;/code&gt; , &lt;code&gt;wp&lt;/code&gt; , &lt;code&gt;wq&lt;/code&gt; , &lt;code&gt;ws&lt;/code&gt; , &lt;code&gt;wt&lt;/code&gt; , &lt;code&gt;wu&lt;/code&gt; , &lt;code&gt;wv&lt;/code&gt; , &lt;code&gt;ww&lt;/code&gt; или &lt;code&gt;wy&lt;/code&gt; ), которые принимают VSX регистры, вы должны использовать &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; в шаблоне, чтобы использовался правильный регистр. В противном случае вывод номера регистра в файле сборки будет неправильным, если регистр Altivec является операндом инструкции VSX, которая ожидает нумерацию регистров VSX.</target>
        </trans-unit>
        <trans-unit id="c184ccdd41991ac034a44b8741c7f1fabbb85a41" translate="yes" xml:space="preserve">
          <source>When using precompiled headers (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;), this flag causes the dependency-output flags to also list the files from the precompiled header&amp;rsquo;s dependencies. If not specified, only the precompiled header are listed and not the files that were used to create it, because those files are not consulted when a precompiled header is used.</source>
          <target state="translated">При использовании предварительно скомпилированных заголовков (см. &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Предварительно скомпилированные заголовки&lt;/a&gt; ) этот флаг заставляет флаги вывода зависимостей также перечислять файлы из зависимостей предварительно скомпилированного заголовка. Если не указано иное, отображается только предварительно скомпилированный заголовок, а не файлы, которые использовались для его создания, потому что при использовании предварительно скомпилированного заголовка к этим файлам не обращаются.</target>
        </trans-unit>
        <trans-unit id="4d73200be5ca0030ca174cac8ec7eb66631895c5" translate="yes" xml:space="preserve">
          <source>When using the GNU linker, it is usually more convenient to pass arguments to linker options using the</source>
          <target state="translated">При использовании компоновщика GNU обычно удобнее передавать аргументы в опции компоновщика,используя команду</target>
        </trans-unit>
        <trans-unit id="067cd2444323b04ef76bdc13d65b55530611c791" translate="yes" xml:space="preserve">
          <source>When vectorizing for SVE, consider using &amp;ldquo;unpacked&amp;rdquo; vectors for smaller elements and use the cost model to pick the cheapest approach. Also use the cost model to choose between SVE and Advanced SIMD vectorization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d62f57e8744ee5ede23dc9a1e4cfca2395afa4" translate="yes" xml:space="preserve">
          <source>When you are using the &lt;code&gt;goto&lt;/code&gt; form of &lt;code&gt;asm&lt;/code&gt;, this section contains the list of all C labels to which the code in the &lt;var&gt;AssemblerTemplate&lt;/var&gt; may jump. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">Когда вы используете форму &lt;code&gt;goto&lt;/code&gt; для &lt;code&gt;asm&lt;/code&gt; , этот раздел содержит список всех меток C, на которые может перейти код в &lt;var&gt;AssemblerTemplate&lt;/var&gt; . См. &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1da9d83d815287fc18f851fe43c98fefdf50af5" translate="yes" xml:space="preserve">
          <source>When you compile C++ programs, you may specify many of the same command-line options that you use for compiling programs in any language; or command-line options meaningful for C and related languages; or options that are meaningful only for C++ programs. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;, for explanations of options for languages related to C. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;, for explanations of options that are meaningful only for C++ programs.</source>
          <target state="translated">При компиляции программ на C ++ вы можете указать многие из тех же параметров командной строки, которые вы используете для компиляции программ на любом языке; или параметры командной строки, значимые для C и родственных языков; или параметры, имеющие значение только для программ на C ++. См. В разделе &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Параметры, управляющие диалектом C&lt;/a&gt; , объяснения параметров для языков, связанных с C. См. &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Параметры, управляющие диалектом C ++&lt;/a&gt; , для объяснения параметров, имеющих значение только для программ на C ++.</target>
        </trans-unit>
        <trans-unit id="628daae8697f91bc17f481bc0199bf74cc7f3f93" translate="yes" xml:space="preserve">
          <source>When you invoke GCC, it normally does preprocessing, compilation, assembly and linking. The &amp;ldquo;overall options&amp;rdquo; allow you to stop this process at an intermediate stage. For example, the</source>
          <target state="translated">Когда вы вызываете GCC, он обычно выполняет предварительную обработку, компиляцию, сборку и компоновку. &amp;laquo;Общие параметры&amp;raquo; позволяют остановить этот процесс на промежуточном этапе. Например,</target>
        </trans-unit>
        <trans-unit id="13f12c6ad07dc26768d388eda6cec8315eff87bf" translate="yes" xml:space="preserve">
          <source>When you need to pass options to the assembler via</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4bcf9de739295968f25374fa0b9b82393e8d47" translate="yes" xml:space="preserve">
          <source>When you use</source>
          <target state="translated">При использовании</target>
        </trans-unit>
        <trans-unit id="8bb9a5cb938f4f893dfe56300e7991ff5d9ac371" translate="yes" xml:space="preserve">
          <source>When you use &lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;, the only automatic variables guaranteed to remain valid are those declared &lt;code&gt;volatile&lt;/code&gt;. This is a consequence of automatic register allocation. Consider this function:</source>
          <target state="translated">Когда вы используете &lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; и &lt;code&gt;longjmp&lt;/code&gt; , единственные автоматические переменные, которые гарантированно остаются действительными, - это те, которые объявлены &lt;code&gt;volatile&lt;/code&gt; . Это следствие автоматического распределения регистров. Рассмотрим эту функцию:</target>
        </trans-unit>
        <trans-unit id="4f5a87979f362a282d672c1cd391334d27dc161a" translate="yes" xml:space="preserve">
          <source>When you use the</source>
          <target state="translated">Когда вы используете</target>
        </trans-unit>
        <trans-unit id="cef8b3831d50a66f25ff90c61c375348a6eba6bf" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should use the general-purpose constraint letters in &lt;code&gt;asm&lt;/code&gt; arguments, since they will convey meaning more readily to people reading your code. Failing that, use the constraint letters that usually have very similar meanings across architectures. The most commonly used constraints are &amp;lsquo;</source>
          <target state="translated">По возможности следует использовать в аргументах &lt;code&gt;asm&lt;/code&gt; ограничительные буквы общего назначения , так как они легче передают смысл людям, читающим ваш код. В противном случае используйте буквы ограничений, которые обычно имеют очень похожее значение для разных архитектур. Наиболее часто используемые ограничения:</target>
        </trans-unit>
        <trans-unit id="3a4007ba3fafc819a7924ea3b2d8632c8709039c" translate="yes" xml:space="preserve">
          <source>Whenever you leave out the alignment factor in an &lt;code&gt;aligned&lt;/code&gt; attribute specification, the compiler automatically sets the alignment for the type to the largest alignment that is ever used for any data type on the target machine you are compiling for. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables that have types that you have aligned this way.</source>
          <target state="translated">Каждый раз, когда вы пропускаете коэффициент &lt;code&gt;aligned&lt;/code&gt; спецификации выровненного атрибута, компилятор автоматически устанавливает выравнивание для типа на самое большое выравнивание, которое когда-либо использовалось для любого типа данных на целевой машине, для которой вы компилируете. Выполнение этого часто может сделать операции копирования более эффективными, потому что компилятор может использовать любые инструкции, копирующие самые большие фрагменты памяти, при выполнении копий в или из переменных, типы которых вы выровнены таким образом.</target>
        </trans-unit>
        <trans-unit id="08306a1126e7ec7f2d356c52bfc279fbbf71d360" translate="yes" xml:space="preserve">
          <source>Where &lt;var&gt;op&lt;/var&gt; is the name of the instruction. Refer to the ISA manual for the complete list of instructions.</source>
          <target state="translated">Где &lt;var&gt;op&lt;/var&gt; - название инструкции. См. Полный список инструкций в руководстве ISA.</target>
        </trans-unit>
        <trans-unit id="a66402f17809117f1d29c4b80df406d4e2f11bba" translate="yes" xml:space="preserve">
          <source>Where G++ puts inlines, vtables and such.</source>
          <target state="translated">Где G++ставит в строки,конюшни и тому подобное.</target>
        </trans-unit>
        <trans-unit id="f97bcbccf23129ffc3f54b71abd0f18cfe88a7d0" translate="yes" xml:space="preserve">
          <source>Where none of</source>
          <target state="translated">Где никто из</target>
        </trans-unit>
        <trans-unit id="18ba47ae48773e2f3f0699ad79e05aa7bd3185d2" translate="yes" xml:space="preserve">
          <source>Where the standard specified with</source>
          <target state="translated">Если стандарт указан с</target>
        </trans-unit>
        <trans-unit id="7c95dc097ed9e81e390e81810c6f3d829c025cc5" translate="yes" xml:space="preserve">
          <source>Where the unused arguments lie between used arguments that are specified with &amp;lsquo;</source>
          <target state="translated">Если неиспользуемые аргументы находятся между использованными аргументами, которые указаны с помощью '</target>
        </trans-unit>
        <trans-unit id="b3e4d8bab3e588a9e2b728940ccf589c5438a70e" translate="yes" xml:space="preserve">
          <source>Where the value in &lt;var&gt;dest&lt;/var&gt; will be the result returned from the built-in.</source>
          <target state="translated">Где значение в &lt;var&gt;dest&lt;/var&gt; будет результатом, возвращаемым встроенным.</target>
        </trans-unit>
        <trans-unit id="e57ba6952af402ae437a5e3309d0cfb54d03b1f3" translate="yes" xml:space="preserve">
          <source>Where to find header files and libraries. Where to find the compiler executable files.</source>
          <target state="translated">Где найти заголовочные файлы и библиотеки.Где найти исполняемые файлы компилятора.</target>
        </trans-unit>
        <trans-unit id="3c00f7db25c9cf9b37e3952008b0e2f58aade5fa" translate="yes" xml:space="preserve">
          <source>Whether a &amp;ldquo;plain&amp;rdquo; &lt;code&gt;int&lt;/code&gt; bit-field is treated as a &lt;code&gt;signed int&lt;/code&gt; bit-field or as an &lt;code&gt;unsigned int&lt;/code&gt; bit-field (C90 6.5.2, C90 6.5.2.1, C99 and C11 6.7.2, C99 and C11 6.7.2.1).</source>
          <target state="translated">Является ли &amp;laquo;простой&amp;raquo; &lt;code&gt;int&lt;/code&gt; битовое поле рассматривается как &lt;code&gt;signed int&lt;/code&gt; битовое поле или как &lt;code&gt;unsigned int&lt;/code&gt; битового поля (C90 6.5.2, C90 6.5.2.1, C99 и C11 6.7.2, C99 и C11 6.7.2.1 ).</target>
        </trans-unit>
        <trans-unit id="7531059d0a25c98e7ca278e75f82acc76daa9a55" translate="yes" xml:space="preserve">
          <source>Whether a bit-field can straddle a storage-unit boundary (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">Может ли битовое поле пересекать границу раздела хранилища (C90 6.5.2.1,C99 и C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="fe2aebfc599d584921175261d958d43ef0f0aec0" translate="yes" xml:space="preserve">
          <source>Whether a function in a binary built by one set of tools can call a function in a binary built by a different set of tools is a subset of interoperability.</source>
          <target state="translated">Может ли функция в двоичном файле,собранная одним набором инструментов,вызывать функцию в двоичном файле,собранном другим набором инструментов,является подмножеством функциональной совместимости.</target>
        </trans-unit>
        <trans-unit id="c06b8898733d76cc9dce4e56a21efa3845ac1918" translate="yes" xml:space="preserve">
          <source>Whether an argument of class type with a non-trivial copy constructor or destructor can be passed to ... (C++0x 5.2.2).</source>
          <target state="translated">Может ли аргумент типа класса с нетривиальным конструктором копирования или деструктором быть передан в ...(C++0x 5.2.2).</target>
        </trans-unit>
        <trans-unit id="f086235b38a936fb8979e808d23b4c24d86f5d9b" translate="yes" xml:space="preserve">
          <source>Whether and how floating expressions are contracted when not disallowed by the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 6.5).</source>
          <target state="translated">&lt;code&gt;FP_CONTRACT&lt;/code&gt; ли и как плавающие выражения, если они не запрещены прагмой FP_CONTRACT (C99 и C11 6.5).</target>
        </trans-unit>
        <trans-unit id="f8840ea94992b3ba6df4412ec15b47848948aba5" translate="yes" xml:space="preserve">
          <source>Whether any extended alignments are supported and the contexts in which they are supported (C11 6.2.8).</source>
          <target state="translated">Поддерживаются ли расширенные выравнивания и контексты,в которых они поддерживаются (C11 6.2.8).</target>
        </trans-unit>
        <trans-unit id="5e7ac927cf9e33f4c488cef419402e9a193f27f2" translate="yes" xml:space="preserve">
          <source>Whether atomic types are permitted for bit-fields (C11 6.7.2.1).</source>
          <target state="translated">Разрешены ли атомные типы для битовых полей (С11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="1b73e138d1b7cf4eb52da0986b7749369200c235" translate="yes" xml:space="preserve">
          <source>Whether case distinctions are significant in an identifier with external linkage (C90 6.1.2).</source>
          <target state="translated">Значимы ли различия в регистре в идентификаторе с внешней связью (C90 6.1.2).</target>
        </trans-unit>
        <trans-unit id="f11ebb9d3de47abc2e0ca0f87e800f9634ac636f" translate="yes" xml:space="preserve">
          <source>Whether codegen errors should be ICEs when</source>
          <target state="translated">Должны ли кодовые ошибки быть ICE,когда</target>
        </trans-unit>
        <trans-unit id="354a46344b75f29340cafb16fbb91450a8587db2" translate="yes" xml:space="preserve">
          <source>Whether differently-prefixed wide string literal tokens can be concatenated and, if so, the treatment of the resulting multibyte character sequence (C11 6.4.5).</source>
          <target state="translated">Могут ли быть сконцентрированы по-разному исправленные маркеры широкострочных литералов,и если да,то обработка получившейся многобайтовой последовательности символов (C11 6.4.5).</target>
        </trans-unit>
        <trans-unit id="3b5528cb4a8a2228a3304685d15fcf34a763a7fb" translate="yes" xml:space="preserve">
          <source>Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character in translation phase 3 (C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">Сохраняется ли каждая непустая последовательность пробельных символов,кроме новой строки,или заменяется одним пробелом на третьем этапе перевода (C90,C99 и C11 5.1.1.2).</target>
        </trans-unit>
        <trans-unit id="599547a438479475d1d2cda798d15d3f35866c27" translate="yes" xml:space="preserve">
          <source>Whether signed integer types are represented using sign and magnitude, two&amp;rsquo;s complement, or one&amp;rsquo;s complement, and whether the extraordinary value is a trap representation or an ordinary value (C99 and C11 6.2.6.2).</source>
          <target state="translated">Представляются ли целочисленные типы со знаком с использованием знака и величины, дополнения до двух или дополнения до одного, и является ли исключительное значение представлением прерывания или обычным значением (C99 и C11 6.2.6.2).</target>
        </trans-unit>
        <trans-unit id="40b6d1461dda1b8f55b388b60612f0a1c5dc15ae" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;inexact&amp;rdquo; floating-point exception can be raised when the rounded result actually does equal the mathematical result in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">Может ли быть вызвано &amp;laquo;неточное&amp;raquo; исключение с плавающей запятой, когда округленный результат действительно равен математическому результату в реализации, соответствующей IEC 60559 (C99 F.9).</target>
        </trans-unit>
        <trans-unit id="c1f63f009e459571f2431bd617b7dca64a11adca" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;underflow&amp;rdquo; (and &amp;ldquo;inexact&amp;rdquo;) floating-point exception can be raised when a result is tiny but not inexact in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">Может ли быть вызвано исключение с плавающей запятой &amp;laquo;недополнение&amp;raquo; (и &amp;laquo;неточность&amp;raquo;), если результат мал, но не неточен в реализации, соответствующей IEC 60559 (C99 F.9).</target>
        </trans-unit>
        <trans-unit id="945b6d4fa9a5ecbaf6bafbdb8d0d89ae5b700edc" translate="yes" xml:space="preserve">
          <source>Whether the &amp;lsquo;</source>
          <target state="translated">Будь то</target>
        </trans-unit>
        <trans-unit id="bba97b060da98c792876d4d0754d818ca89f0204" translate="yes" xml:space="preserve">
          <source>Whether the compiler should use the &amp;ldquo;canonical&amp;rdquo; type system. Should always be 1, which uses a more efficient internal mechanism for comparing types in C++ and Objective-C++. However, if bugs in the canonical type system are causing compilation failures, set this value to 0 to disable canonical types.</source>
          <target state="translated">Следует ли компилятору использовать &amp;laquo;каноническую&amp;raquo; систему типов. Всегда должно быть 1, что позволяет использовать более эффективный внутренний механизм сравнения типов в C ++ и Objective-C ++. Однако, если ошибки в системе канонических типов вызывают сбои компиляции, установите для этого значения 0, чтобы отключить канонические типы.</target>
        </trans-unit>
        <trans-unit id="9bf07719435931f48daf3148b7f591b08eee6622" translate="yes" xml:space="preserve">
          <source>Whether the loop array prefetch pass should issue software prefetch hints for strides that are non-constant. In some cases this may be beneficial, though the fact the stride is non-constant may make it hard to predict when there is clear benefit to issuing these hints.</source>
          <target state="translated">Должна ли передача предварительной выборки массива в цикле выдавать программные подсказки предварительной выборки для неконстантных шагов.В некоторых случаях это может быть полезно,хотя тот факт,что шаг не постоянен,может затруднить предсказание,когда есть явная выгода от выдачи этих подсказок.</target>
        </trans-unit>
        <trans-unit id="3783705a05be7fc566fd28d14a20893e46a49fb1" translate="yes" xml:space="preserve">
          <source>Whether the value of a character constant in a constant expression that controls conditional inclusion matches the value of the same character constant in the execution character set (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">Совпадает ли значение символьной константы в константном выражении,которое управляет условным включением,со значением той же символьной константы в наборе символов исполнения (C90 6.8.1,C99 и C11 6.10.1).</target>
        </trans-unit>
        <trans-unit id="c36d4d5da07291b1b8267749102489e31d3d638e" translate="yes" xml:space="preserve">
          <source>Whether the value of a single-character character constant in a constant expression that controls conditional inclusion may have a negative value (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">Может ли значение односимвольной символьной константы в константном выражении,которое контролирует условное включение,иметь отрицательное значение (С90 6.8.1,С99 и С11 6.10.1).</target>
        </trans-unit>
        <trans-unit id="9cb3bdf69d2ad24cba5875ebe4f0cafed80a2719" translate="yes" xml:space="preserve">
          <source>Which additional multibyte characters may appear in identifiers and their correspondence to universal character names (C99 and C11 6.4.2).</source>
          <target state="translated">Какие дополнительные многобайтовые символы могут появляться в идентификаторах и их соответствие универсальным символьным именам (С99 и С11 6.4.2).</target>
        </trans-unit>
        <trans-unit id="d42124c28b1baab39d06e79c2e6fbc80bcb8c3b0" translate="yes" xml:space="preserve">
          <source>Which of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; has the same range, representation, and behavior as &amp;ldquo;plain&amp;rdquo; &lt;code&gt;char&lt;/code&gt; (C90 6.1.2.5, C90 6.2.1.1, C99 and C11 6.2.5, C99 and C11 6.3.1.1).</source>
          <target state="translated">Какой из &lt;code&gt;signed char&lt;/code&gt; или &lt;code&gt;unsigned char&lt;/code&gt; имеет тот же диапазон, представление и поведение, что и &amp;laquo;простой&amp;raquo; &lt;code&gt;char&lt;/code&gt; (C90 6.1.2.5, C90 6.2.1.1, C99 и C11 6.2.5, C99 и C11 6.3.1.1).</target>
        </trans-unit>
        <trans-unit id="a3f8e01950ee5a5eeec136d809212bfccead4676" translate="yes" xml:space="preserve">
          <source>Which problems in your code get warnings, and which get errors.</source>
          <target state="translated">Какие проблемы в вашем коде получают предупреждения,а какие-ошибки.</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="78cfea135064bce5a81b5bd15458f3f64f56702d" translate="yes" xml:space="preserve">
          <source>While it is possible to leave the function undefined and thus invoke a link failure (to define the function with a message in &lt;code&gt;.gnu.warning*&lt;/code&gt; section), when using these attributes the problem is diagnosed earlier and with exact location of the call even in presence of inline functions or when not emitting debugging information.</source>
          <target state="translated">Хотя можно оставить функцию неопределенной и, таким образом, вызвать сбой связи (чтобы определить функцию с сообщением в разделе &lt;code&gt;.gnu.warning*&lt;/code&gt; ), при использовании этих атрибутов проблема диагностируется раньше и с точным местоположением вызова даже в наличие встроенных функций или отсутствие отладочной информации.</target>
        </trans-unit>
        <trans-unit id="652d59cea2004903b4f313a4a1b258897728e71e" translate="yes" xml:space="preserve">
          <source>While the compiler is aware of changes to entries listed in the output operands, the inline &lt;code&gt;asm&lt;/code&gt; code may modify more than just the outputs. For example, calculations may require additional registers, or the processor may overwrite a register as a side effect of a particular assembler instruction. In order to inform the compiler of these changes, list them in the clobber list. Clobber list items are either register names or the special clobbers (listed below). Each clobber list item is a string constant enclosed in double quotes and separated by commas.</source>
          <target state="translated">Хотя компилятор знает об изменениях записей, перечисленных в выходных операндах, встроенный &lt;code&gt;asm&lt;/code&gt; - код может изменять не только выходные данные. Например, для вычислений могут потребоваться дополнительные регистры, или процессор может перезаписать регистр как побочный эффект конкретной инструкции ассемблера. Чтобы сообщить компилятору об этих изменениях, внесите их в список clobber. Пункты списка Clobber - это либо имена регистров, либо специальные clobbers (перечисленные ниже). Каждый элемент списка clobber представляет собой строковую константу, заключенную в двойные кавычки и разделенные запятыми.</target>
        </trans-unit>
        <trans-unit id="e21fa2c7a90a60eea68201dc97480d9a5390c69c" translate="yes" xml:space="preserve">
          <source>While the uses of &lt;code&gt;asm&lt;/code&gt; are many and varied, it may help to think of an &lt;code&gt;asm&lt;/code&gt; statement as a series of low-level instructions that convert input parameters to output parameters. So a simple (if not particularly useful) example for i386 using &lt;code&gt;asm&lt;/code&gt; might look like this:</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;asm&lt;/code&gt; используется много и разнообразно, можно подумать об операторе &lt;code&gt;asm&lt;/code&gt; как о серии низкоуровневых инструкций, которые преобразуют входные параметры в выходные параметры. Итак, простой (если не особо полезный) пример для i386 с использованием &lt;code&gt;asm&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="39d000e8aa5910f6d9ef12595235838dbefbbb8c" translate="yes" xml:space="preserve">
          <source>While transforming the program out of the SSA representation, attempt to reduce copying by coalescing versions of different user-defined variables, instead of just compiler temporaries. This may severely limit the ability to debug an optimized program compiled with</source>
          <target state="translated">При преобразовании программы из представления SSA попытайтесь сократить копирование путем объединения версий различных пользовательских переменных,а не только временных файлов компилятора.Это может серьезно ограничить возможность отладки оптимизированной программы,скомпилированной с помощью</target>
        </trans-unit>
        <trans-unit id="91e29563eb1f68f27cd54dba1d78ec9cc5f02f0e" translate="yes" xml:space="preserve">
          <source>Whitespace characters are ignored and can be inserted at any position except the first. This enables each alternative for different operands to be visually aligned in the machine description even if they have different number of constraints and modifiers.</source>
          <target state="translated">Пробельные символы игнорируются и могут быть вставлены в любую позицию,кроме первой.Это позволяет визуально выровнять каждую альтернативу для различных операндов в описании машины,даже если они имеют разное количество ограничений и модификаторов.</target>
        </trans-unit>
        <trans-unit id="39ae8a30b75fbc11a781450228d73f4f7d67eae3" translate="yes" xml:space="preserve">
          <source>Will produce a &lt;code&gt;.symver foo_v1, foo@VERS_1&lt;/code&gt; directive in the assembler output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45faa4599697b06106508c630a671752d1b455fb" translate="yes" xml:space="preserve">
          <source>Wint-to-pointer-cast</source>
          <target state="translated">Wint-to-pointer-cast</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="51349bc0c9c137d79df06bd38d1ae337509f6d51" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-fprofile-use&lt;/code&gt; all portions of programs not executed during train run are optimized agressively for size rather than speed. In some cases it is not practical to train all possible hot paths in the program. (For example, program may contain functions specific for a given hardware and trianing may not cover all hardware configurations program is run on.) With &lt;code&gt;-fprofile-partial-training&lt;/code&gt; profile feedback will be ignored for all functions not executed during the train run leading them to be optimized as if they were compiled without profile feedback. This leads to better performance when train run is not representative but also leads to significantly bigger code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db41302cf4b363b4a1378448e9a36c920e1a7fca" translate="yes" xml:space="preserve">
          <source>With both</source>
          <target state="translated">С обоими</target>
        </trans-unit>
        <trans-unit id="a29e68e9d153083133283a2db9d7b73482a032a4" translate="yes" xml:space="preserve">
          <source>With extended &lt;code&gt;asm&lt;/code&gt; you can read and write C variables from assembler and perform jumps from assembler code to C labels. Extended &lt;code&gt;asm&lt;/code&gt; syntax uses colons (&amp;lsquo;</source>
          <target state="translated">С расширенным &lt;code&gt;asm&lt;/code&gt; вы можете читать и записывать переменные C из ассемблера и выполнять переходы от кода ассемблера к меткам C. Расширенный синтаксис &lt;code&gt;asm&lt;/code&gt; использует двоеточия ('</target>
        </trans-unit>
        <trans-unit id="b2027ec70d531c569c806c46a0ed0d35bbfbe374" translate="yes" xml:space="preserve">
          <source>With no modifiers, this is what the output from the operands would be for the &amp;lsquo;</source>
          <target state="translated">Без модификаторов это то, что будет вывод операндов для '</target>
        </trans-unit>
        <trans-unit id="d8a4b9d08d97e45adb4da87468c9bc15fb87e195" translate="yes" xml:space="preserve">
          <source>With the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd37ca8139ba8f0077df8728d69e1509b46cb93" translate="yes" xml:space="preserve">
          <source>With the GNU C++ front end, for x86 targets, you may specify multiple versions of a function, where each function is specialized for a specific target feature. At runtime, the appropriate version of the function is automatically executed depending on the characteristics of the execution platform. Here is an example.</source>
          <target state="translated">В GNU C++front end,для x86 targets,вы можете указать несколько версий функции,где каждая функция специализируется на конкретной целевой функции.Во время выполнения автоматически выполняется соответствующая версия функции в зависимости от характеристик платформы выполнения.Приведем пример.</target>
        </trans-unit>
        <trans-unit id="872450a8fc748ddfde2cdc81d3d1bdedfaa16509" translate="yes" xml:space="preserve">
          <source>With the GNU runtime, exceptions are always implemented as &amp;ldquo;native&amp;rdquo; exceptions and it is recommended that the</source>
          <target state="translated">В среде исполнения GNU исключения всегда реализуются как &amp;laquo;собственные&amp;raquo; исключения, и рекомендуется, чтобы</target>
        </trans-unit>
        <trans-unit id="ede352de48f14dbfe64db09513e522c73f079435" translate="yes" xml:space="preserve">
          <source>With the NeXT runtime, although currently designed to be binary compatible with &lt;code&gt;NS_HANDLER&lt;/code&gt;-style idioms provided by the &lt;code&gt;NSException&lt;/code&gt; class, the new exceptions can only be used on Mac OS X 10.3 (Panther) and later systems, due to additional functionality needed in the NeXT Objective-C runtime.</source>
          <target state="translated">Со средой выполнения NeXT, хотя в настоящее время она предназначена для двоичной совместимости с &lt;code&gt;NS_HANDLER&lt;/code&gt; стиля NS_HANDLER, предоставляемыми классом &lt;code&gt;NSException&lt;/code&gt; , новые исключения могут использоваться только в Mac OS X 10.3 (Panther) и более поздних системах из-за дополнительных функций, необходимых в NeXT. Среда выполнения Objective-C.</target>
        </trans-unit>
        <trans-unit id="dab61d2e9aaa3623f28b2c32d76967b2c680ed03" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one &lt;var&gt;storage-class-specifier&lt;/var&gt; shall appear in a given &lt;var&gt;decl-specifier-seq&lt;/var&gt;. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers. [&amp;hellip;]</source>
          <target state="translated">За исключением &lt;code&gt;__thread&lt;/code&gt; , не более одного &lt;var&gt;storage-class-specifier&lt;/var&gt; должен появиться в данном &lt;var&gt;decl-specifier-seq&lt;/var&gt; . Спецификатор &lt;code&gt;__thread&lt;/code&gt; может использоваться отдельно или сразу после спецификаторов &lt;code&gt;extern&lt;/code&gt; или &lt;code&gt;static&lt;/code&gt; . [...]</target>
        </trans-unit>
        <trans-unit id="292a47839ebc29dbb70ec7b25cc162b60e68673e" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one storage-class specifier may be given [&amp;hellip;]. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">За исключением &lt;code&gt;__thread&lt;/code&gt; , может быть задано не более одного спецификатора класса хранения [&amp;hellip;]. Спецификатор &lt;code&gt;__thread&lt;/code&gt; может использоваться отдельно или сразу после &lt;code&gt;extern&lt;/code&gt; или &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a3f5b76de67732f25dfbe9b7ab3c5b977a603b2" translate="yes" xml:space="preserve">
          <source>With the exception of built-ins that have library equivalents such as the standard C library functions discussed below, or that expand to library calls, GCC built-in functions are always expanded inline and thus do not have corresponding entry points and their address cannot be obtained. Attempting to use them in an expression other than a function call results in a compile-time error.</source>
          <target state="translated">За исключением встраиваемых функций,которые имеют библиотечные эквиваленты,такие как стандартные библиотечные функции C,рассмотренные ниже,или которые расширяются до вызовов библиотек,встроенные функции GCC всегда расширяются встроенными функциями,и поэтому не имеют соответствующих точек входа,и их адрес не может быть получен.Попытка использовать их в выражении,отличном от вызова функции,приводит к ошибке во время компиляции.</target>
        </trans-unit>
        <trans-unit id="e736ee71288d11d1b230f0b89bdd35b5282b45ac" translate="yes" xml:space="preserve">
          <source>With the latter choice the options</source>
          <target state="translated">С последним выбором вариантов</target>
        </trans-unit>
        <trans-unit id="a6637ce41dda1dbfc19245d823fa7fce4d91f90f" translate="yes" xml:space="preserve">
          <source>With the linker plugin enabled, the linker extracts the needed GIMPLE files from</source>
          <target state="translated">При включенном плагине компоновщика,компоновщик извлекает нужные файлы GIMPLE из</target>
        </trans-unit>
        <trans-unit id="8b0e7753b83f2f64fc1212f98878b05c847daa5e" translate="yes" xml:space="preserve">
          <source>With the specification of an output file, the output is appended to the named file, and it looks like this:</source>
          <target state="translated">При спецификации выходного файла выходной файл добавляется к именованному файлу,и он выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="51ee435d4a40a1b09c0e1be2e1a80aec4607b86e" translate="yes" xml:space="preserve">
          <source>With this interface, &lt;code&gt;wait&lt;/code&gt;&amp;rsquo;s implementation might look like this:</source>
          <target state="translated">В этом интерфейсе реализация &lt;code&gt;wait&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="901e3b5288c53d25410e3fbe70a050954297b494" translate="yes" xml:space="preserve">
          <source>With this option, the compiler creates multiple copies of some local variables when unrolling a loop, which can result in superior code.</source>
          <target state="translated">С помощью этой опции компилятор при разворачивании цикла создает несколько копий некоторых локальных переменных,что может привести к улучшению кода.</target>
        </trans-unit>
        <trans-unit id="ce8a418995461de4210630163f948f5da9423e89" translate="yes" xml:space="preserve">
          <source>With this option, the compiler turns the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call into a diagnostics message call instead. When reaching the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call, the behavior is undefined.</source>
          <target state="translated">С помощью этой опции компилятор вместо этого превращает вызов &lt;code&gt;__builtin_unreachable&lt;/code&gt; в вызов диагностического сообщения. При достижении вызова &lt;code&gt;__builtin_unreachable&lt;/code&gt; поведение не определено.</target>
        </trans-unit>
        <trans-unit id="756db1c4a886455bb3e77429e2aacb2477c5e4e1" translate="yes" xml:space="preserve">
          <source>With this pragma, the programmer asserts that there are no loop-carried dependencies which would prevent consecutive iterations of the following loop from executing concurrently with SIMD (single instruction multiple data) instructions.</source>
          <target state="translated">С помощью этой прагмы программист утверждает,что не существует зацикленных зависимостей,которые препятствовали бы одновременному выполнению последовательных итераций следующего цикла с инструкциями SIMD (одна инструкция-несколько данных).</target>
        </trans-unit>
        <trans-unit id="a8d9a31f26b7d1b3f16e1e66c83efb3ffbd755c5" translate="yes" xml:space="preserve">
          <source>Within either execution environment, a &lt;em&gt;thread&lt;/em&gt; is a flow of control within a program. It is implementation defined whether or not there may be more than one thread associated with a program. It is implementation defined how threads beyond the first are created, the name and type of the function called at thread startup, and how threads may be terminated. However, objects with thread storage duration shall be initialized before thread startup.</source>
          <target state="translated">В любой среде выполнения &lt;em&gt;поток&lt;/em&gt; - это поток управления в программе. Реализация определяется, может ли с программой быть связано более одного потока. Реализация определяет, как создаются потоки, помимо первого, имя и тип функции, вызываемой при запуске потока, и как потоки могут быть завершены. Однако объекты с длительностью хранения потока должны быть инициализированы перед запуском потока.</target>
        </trans-unit>
        <trans-unit id="0e894809a49c1ed8c2eb1cfd50b560eb03dca15f" translate="yes" xml:space="preserve">
          <source>Within the body of &lt;code&gt;T::fn&lt;/code&gt;, &lt;var&gt;this&lt;/var&gt; has the effective definition &lt;code&gt;T *__restrict__ const this&lt;/code&gt;. Notice that the interpretation of a &lt;code&gt;__restrict__&lt;/code&gt; member function qualifier is different to that of &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt; qualifier, in that it is applied to the pointer rather than the object. This is consistent with other compilers that implement restricted pointers.</source>
          <target state="translated">В теле &lt;code&gt;T::fn&lt;/code&gt; , &lt;var&gt;this&lt;/var&gt; имеет эффективное определение &lt;code&gt;T *__restrict__ const this&lt;/code&gt; . Обратите внимание, что интерпретация квалификатора функции-члена &lt;code&gt;__restrict__&lt;/code&gt; отличается от интерпретации квалификатора &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;volatile&lt;/code&gt; тем , что он применяется к указателю, а не к объекту. Это согласуется с другими компиляторами, реализующими ограниченные указатели.</target>
        </trans-unit>
        <trans-unit id="06d91320f48b09da02ef917261dcfd59521156ff" translate="yes" xml:space="preserve">
          <source>Without a value specified, pack all structure members together without holes. When a value is specified (which must be a small power of two), pack structure members according to this value, representing the maximum alignment (that is, objects with default alignment requirements larger than this are output potentially unaligned at the next fitting location.</source>
          <target state="translated">Без указания значения упакуйте все элементы конструкции вместе без отверстий.Когда указано значение (которое должно быть небольшим из двух),члены структуры упаковываются в соответствии с этим значением,представляющим собой максимальное выравнивание (т.е.объекты с требованиями по умолчанию по выравниванию,превышающими это значение,выводятся потенциально не выровненными в следующем подходящем месте.</target>
        </trans-unit>
        <trans-unit id="4610e8cd3674760f9e34246c3335f6375dea470e" translate="yes" xml:space="preserve">
          <source>Without any optimization option, the compiler&amp;rsquo;s goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you expect from the source code.</source>
          <target state="translated">Без какой-либо опции оптимизации цель компилятора - снизить стоимость компиляции и добиться от отладки ожидаемых результатов. Операторы независимы: если вы останавливаете программу с точкой останова между операторами, вы можете затем присвоить новое значение любой переменной или изменить счетчик программы на любой другой оператор в функции и получить именно те результаты, которые вы ожидаете от исходного кода.</target>
        </trans-unit>
        <trans-unit id="d8d4a33aae2a07ecc8c812bfec17c5e5d451e08a" translate="yes" xml:space="preserve">
          <source>Without the specification of an output file, the output looks like this:</source>
          <target state="translated">Без спецификации выходного файла вывод выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5f36069c670576f1745c3bcd64036649a26fba3f" translate="yes" xml:space="preserve">
          <source>Without this option, &amp;lsquo;</source>
          <target state="translated">Без этой опции '</target>
        </trans-unit>
        <trans-unit id="810b49b99b225fdb366e04ce850176fc78b9dace" translate="yes" xml:space="preserve">
          <source>Without this option, the &lt;code&gt;X&lt;/code&gt; register may be used in the same way as &lt;code&gt;Y&lt;/code&gt; or &lt;code&gt;Z&lt;/code&gt; which then is emulated by additional instructions. For example, loading a value with &lt;code&gt;X+const&lt;/code&gt; addressing with a small non-negative &lt;code&gt;const &amp;lt; 64&lt;/code&gt; to a register &lt;var&gt;Rn&lt;/var&gt; is performed as</source>
          <target state="translated">Без этой опции регистр &lt;code&gt;X&lt;/code&gt; может использоваться так же, как &lt;code&gt;Y&lt;/code&gt; или &lt;code&gt;Z&lt;/code&gt; , который затем эмулируется дополнительными инструкциями. Например, загрузка значения с адресацией &lt;code&gt;X+const&lt;/code&gt; с небольшим неотрицательным &lt;code&gt;const &amp;lt; 64&lt;/code&gt; в регистр &lt;var&gt;Rn&lt;/var&gt; выполняется как</target>
        </trans-unit>
        <trans-unit id="4c7069fd8666957ba9eac9efad054fa1d2f74644" translate="yes" xml:space="preserve">
          <source>Work around a bug in the &lt;code&gt;muls&lt;/code&gt; and &lt;code&gt;mulu&lt;/code&gt; instructions for CPU models where it applies. This option is active by default.</source>
          <target state="translated">Работа вокруг ошибки в &lt;code&gt;muls&lt;/code&gt; и &lt;code&gt;mulu&lt;/code&gt; инструкции для моделей процессоров , где она применяется. Эта опция активна по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9517982144bf04b0b47a4d85a09581d177ba1cbb" translate="yes" xml:space="preserve">
          <source>Work around a hardware bug that causes the SPU to stall indefinitely. By default, GCC inserts the &lt;code&gt;hbrp&lt;/code&gt; instruction to make sure this stall won&amp;rsquo;t happen.</source>
          <target state="translated">Обходите аппаратную ошибку, из-за которой SPU зависает на неопределенное время. По умолчанию GCC вставляет инструкцию &lt;code&gt;hbrp&lt;/code&gt; , чтобы этого не произошло.</target>
        </trans-unit>
        <trans-unit id="8c4b8e3f13ae11240c809eb84fd3edb5d1bba62a" translate="yes" xml:space="preserve">
          <source>Work around certain R10000 errata:</source>
          <target state="translated">Поработайте с определенными ошибками R10000:</target>
        </trans-unit>
        <trans-unit id="9074be04c7616416ed213f212eeb7c6c7c183d4c" translate="yes" xml:space="preserve">
          <source>Work around certain R4000 CPU errata:</source>
          <target state="translated">Работайте с определенными ошибками процессора R4000:</target>
        </trans-unit>
        <trans-unit id="fd709a4ced203846b02db64672dd131b123d5504" translate="yes" xml:space="preserve">
          <source>Work around certain R4400 CPU errata:</source>
          <target state="translated">Работайте с определенными ошибками процессора R4400:</target>
        </trans-unit>
        <trans-unit id="9c76802dfaf86b35388bb6eac2a9a428f20a7a39" translate="yes" xml:space="preserve">
          <source>Work around certain SB-1 CPU core errata. (This flag currently works around the SB-1 revision 2 &amp;ldquo;F1&amp;rdquo; and &amp;ldquo;F2&amp;rdquo; floating-point errata.)</source>
          <target state="translated">Устраните определенные ошибки ядра ЦП SB-1. (Этот флаг в настоящее время работает с ошибками с плавающей запятой SB-1 версии 2 &amp;laquo;F1&amp;raquo; и &amp;laquo;F2&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="f1322c2c26c7f8a2ae0c4abcf920ab6e36d8883e" translate="yes" xml:space="preserve">
          <source>Work around certain VR4120 errata:</source>
          <target state="translated">Поработайте с определенными ошибками VR4120:</target>
        </trans-unit>
        <trans-unit id="70f65ee28d3f60e1570e5c0565d3bacdc0372408" translate="yes" xml:space="preserve">
          <source>Work around the 24K E48 (lost data on stores during refill) errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">Работайте с ошибками 24K E48 (потеря данных в хранилищах при пополнении).Обходные пути реализуются ассемблером,а не GCC.</target>
        </trans-unit>
        <trans-unit id="eecdf3e0ad9c1e4373885008c446ef1d15e0de5a" translate="yes" xml:space="preserve">
          <source>Work around the RM7000 &lt;code&gt;dmult&lt;/code&gt;/&lt;code&gt;dmultu&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">Исправьте &lt;code&gt;dmult&lt;/code&gt; RM7000 dmult / &lt;code&gt;dmultu&lt;/code&gt; . Обходные пути реализуются ассемблером, а не GCC.</target>
        </trans-unit>
        <trans-unit id="f514e8f6d3c8232406871016402b0b519b9f1bff" translate="yes" xml:space="preserve">
          <source>Work around the VR4130 &lt;code&gt;mflo&lt;/code&gt;/&lt;code&gt;mfhi&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC, although GCC avoids using &lt;code&gt;mflo&lt;/code&gt; and &lt;code&gt;mfhi&lt;/code&gt; if the VR4130 &lt;code&gt;macc&lt;/code&gt;, &lt;code&gt;macchi&lt;/code&gt;, &lt;code&gt;dmacc&lt;/code&gt; and &lt;code&gt;dmacchi&lt;/code&gt; instructions are available instead.</source>
          <target state="translated">Исправьте &lt;code&gt;mflo&lt;/code&gt; VR4130 mflo / &lt;code&gt;mfhi&lt;/code&gt; . Обходные пути реализуются ассемблером, а не GCC, хотя GCC избегает использования &lt;code&gt;mflo&lt;/code&gt; и &lt;code&gt;mfhi&lt;/code&gt; , если вместо них доступны инструкции VR4130 &lt;code&gt;macc&lt;/code&gt; , &lt;code&gt;macchi&lt;/code&gt; , &lt;code&gt;dmacc&lt;/code&gt; и &lt;code&gt;dmacchi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a937c64e2a5b7eba62b666d7ca837eb48731984" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into Y.</source>
          <target state="translated">Запишите &lt;var&gt;src1&lt;/var&gt; в Y.</target>
        </trans-unit>
        <trans-unit id="b99c5ddd130a32b9357572f70d99408237dc24f1" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into the least significant half of X and &lt;var&gt;src2&lt;/var&gt; into the most significant half of X.</source>
          <target state="translated">Запишите &lt;var&gt;src1&lt;/var&gt; в младшую половину X и &lt;var&gt;src2&lt;/var&gt; в старшую половину X.</target>
        </trans-unit>
        <trans-unit id="282a09ed773c8ef9852a2c6377ed12597d3a9c69" translate="yes" xml:space="preserve">
          <source>Write a SRCFILE.opt-record.json.gz file detailing what optimizations were performed, for those optimizations that support</source>
          <target state="translated">Напишите файл SRCFILE.opt-record.json.gz,в котором подробно описано,какие оптимизации были выполнены,для тех оптимизаций,которые поддерживаются</target>
        </trans-unit>
        <trans-unit id="40d1ca8852e0dec6c7d4fad7e6bc0514fe5d1c54" translate="yes" xml:space="preserve">
          <source>Write branch frequencies as the number of branches taken, rather than the percentage of branches taken.</source>
          <target state="translated">Частоты ветвей записывайте как количество взятых ветвей,а не как процент взятых ветвей.</target>
        </trans-unit>
        <trans-unit id="1423ee2af8243360b137ebe26d7ad382ca0b3b1e" translate="yes" xml:space="preserve">
          <source>Write branch frequencies to the output file, and write branch summary info to the standard output. This option allows you to see how often each branch in your program was taken. Unconditional branches will not be shown, unless the</source>
          <target state="translated">Запишите частоты ветвей в выходной файл и запишите сводную информацию о ветвях в стандартный выходной файл.Эта опция позволяет вам увидеть,как часто каждая ветвь в вашей программе была взята.Необусловленные ветви не будут показаны,если только</target>
        </trans-unit>
        <trans-unit id="1fecc6871d15f561a1a398ebd76fa3a7a1663e9e" translate="yes" xml:space="preserve">
          <source>Write counts in human readable format (like 24.6k).</source>
          <target state="translated">Пишите в формате,удобном для чтения человеком (например,24.6k).</target>
        </trans-unit>
        <trans-unit id="e00e26a5662df1b01236462f99618d8089824cf9" translate="yes" xml:space="preserve">
          <source>Write individual execution counts for every basic block. Normally gcov outputs execution counts only for the main blocks of a line. With this option you can determine if blocks within a single line are not being executed.</source>
          <target state="translated">Запишите индивидуальные подсчеты выполнения для каждого базового блока.Обычно gcov выводит счетчик выполнения только для основных блоков строки.С помощью этой опции можно определить,не выполняются ли блоки внутри одной строки.</target>
        </trans-unit>
        <trans-unit id="27b79e5dd909fed4a63697002ecabe6d4fcefd2b" translate="yes" xml:space="preserve">
          <source>Write the name of each function into the text section, directly preceding the function prologue. The generated code is similar to this:</source>
          <target state="translated">Запишите название каждой функции в текстовую секцию,непосредственно предшествующую прологу функции.Сгенерированный код аналогичен этому:</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="2c144edd2dd673b9ae13db81c4f7c41356844426" translate="yes" xml:space="preserve">
          <source>XER[CA]</source>
          <target state="translated">XER[CA]</target>
        </trans-unit>
        <trans-unit id="edd05eca97855bc49145e43cb3ab5438e61cd98b" translate="yes" xml:space="preserve">
          <source>XOP instructions.</source>
          <target state="translated">XOP инструкции.</target>
        </trans-unit>
        <trans-unit id="e69dd5b634eb9535ab5de7682e5d1e10df284ccf" translate="yes" xml:space="preserve">
          <source>Xstormy16&amp;mdash;</source>
          <target state="translated">Xstormy16&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8341de0a85a327eb2d7c97b77086eb0bff937ecb" translate="yes" xml:space="preserve">
          <source>Xtensa&amp;mdash;</source>
          <target state="translated">Xtensa&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="cbfadbe232364f5b4cd1f9250a9cda7fadbb0042" translate="yes" xml:space="preserve">
          <source>You can additionally specify a string parameter: &amp;lsquo;</source>
          <target state="translated">Вы можете дополнительно указать строковый параметр: '</target>
        </trans-unit>
        <trans-unit id="37f047474bb2991bbc870836a4b1dc7ea6a7e179" translate="yes" xml:space="preserve">
          <source>You can also construct an array, though this is dangerous in C++, as explained below. If all the elements of the compound literal are (made up of) simple constant expressions suitable for use in initializers of objects of static storage duration, then the compound literal can be coerced to a pointer to its first element and used in such an initializer, as shown here:</source>
          <target state="translated">Вы также можете построить массив,хотя это опасно в C++,как поясняется ниже.Если все элементы составного литерала представляют собой (состоящие из)простых константных выражений,пригодных для использования в инициализаторах объектов статической длительности хранения,то составной литерал может быть принудительно приведен к указателю на его первый элемент и использован в таком инициализаторе,как показано здесь:</target>
        </trans-unit>
        <trans-unit id="7e3923b44bbc7d66662628b3637d89fe21e428bc" translate="yes" xml:space="preserve">
          <source>You can also include type attributes in a &lt;code&gt;typedef&lt;/code&gt; declaration. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes.</source>
          <target state="translated">Вы также можете включить атрибуты типа в объявление &lt;code&gt;typedef&lt;/code&gt; . См. В разделе &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; подробную информацию о точном синтаксисе использования атрибутов.</target>
        </trans-unit>
        <trans-unit id="c36aaae0a5a83266e8e76c432773d2ebb3588799" translate="yes" xml:space="preserve">
          <source>You can also override the ARM and Thumb mode for each function by using the &lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; and &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">Вы также можете переопределить режимы ARM и Thumb для каждой функции, используя атрибуты функции &lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; и &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; (см. &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;Атрибуты функций ARM&lt;/a&gt; ) или прагмы (см. &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Прагмы опций, специфичных для функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="70f9f23d58cf9ce6f889493d1bc7a0c90625f3a7" translate="yes" xml:space="preserve">
          <source>You can also record the return value of that function call, and later return that value, without knowing what data type the function tried to return (as long as your caller expects that data type).</source>
          <target state="translated">Вы также можете записать возвращаемое значение этого вызова функции,а затем вернуть это значение,не зная,какой тип данных пыталась вернуть функция (до тех пор,пока ваш вызывающий абонент ожидает этот тип данных).</target>
        </trans-unit>
        <trans-unit id="1165641e4d4b9af84b909635ee9d9e9c442957c3" translate="yes" xml:space="preserve">
          <source>You can also set the fpu name at function level by using the &lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">Вы также можете установить имя fpu на уровне функции с помощью &lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; атрибутов функции (см. &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;Атрибуты функций ARM&lt;/a&gt; ) или прагм (см. &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Прагмы опций, специфичных для функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7268dd0eaeb17935e5094a8029ba22d93c31a1ac" translate="yes" xml:space="preserve">
          <source>You can also specify</source>
          <target state="translated">Вы также можете указать</target>
        </trans-unit>
        <trans-unit id="08bf03c9c6ff7624c857011e74954c5c6f9f4300" translate="yes" xml:space="preserve">
          <source>You can also specify the alignment of structure fields. For example, to create a double-word aligned &lt;code&gt;int&lt;/code&gt; pair, you could write:</source>
          <target state="translated">Вы также можете указать выравнивание полей структуры. Например, чтобы создать пару &lt;code&gt;int&lt;/code&gt; , выровненную по двойному слову , вы можете написать:</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">Вы также можете использовать</target>
        </trans-unit>
        <trans-unit id="786f949c0e9eda9e16d05bfc56918d7d5e4bbdd4" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; to explicitly assign a probability value to individual expressions. If the built-in is used in a loop construct, the provided probability will influence the expected number of iterations made by loop optimizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282b6d022cb9c27fb3bb9103220d6eb51129f71a" translate="yes" xml:space="preserve">
          <source>You can also use attributes to control memory placement, code generation options or call/return conventions within the function being annotated. Many of these attributes are target-specific. For example, many targets support attributes for defining interrupt handler functions, which typically must follow special register usage and return conventions. Such attributes are described in the subsection for each target. However, a considerable number of attributes are supported by most, if not all targets. Those are described in the &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt; section.</source>
          <target state="translated">Вы также можете использовать атрибуты для управления размещением в памяти, параметрами генерации кода или соглашениями о вызове / возврате в аннотируемой функции. Многие из этих атрибутов являются целевыми. Например, многие цели поддерживают атрибуты для определения функций обработчика прерываний, которые обычно должны следовать специальным соглашениям об использовании регистров и возврате. Такие атрибуты описаны в подразделе для каждой цели. Однако значительное количество атрибутов поддерживается большинством, если не всеми целями. Они описаны в разделе &amp;laquo; &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функций&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="972bfbc14b560aee91d8b7d5cfbc635d959441aa" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;asm&lt;/code&gt; keyword to override the assembler name for a C symbol, or to place a C variable in a specific register.</source>
          <target state="translated">Вы также можете использовать ключевое слово &lt;code&gt;asm&lt;/code&gt; , чтобы переопределить имя ассемблера для символа C или поместить переменную C в определенный регистр.</target>
        </trans-unit>
        <trans-unit id="354710c3fd8ed8d70c6d2f210156da0243dc4ade" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;nocf_check&lt;/code&gt; attribute to identify which functions and calls should be skipped from instrumentation (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">Вы также можете использовать атрибут &lt;code&gt;nocf_check&lt;/code&gt; , чтобы определить, какие функции и вызовы следует пропускать из инструментария (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1c6ca2bbbe80bcabecefea25be4aa8fafd6e4d0" translate="yes" xml:space="preserve">
          <source>You can also use the union cast as a function argument:</source>
          <target state="translated">Вы также можете использовать кастинг союза в качестве аргумента функции:</target>
        </trans-unit>
        <trans-unit id="66b750e5491b307807c28732748047266dbd8e2a" translate="yes" xml:space="preserve">
          <source>You can also use variable-length arrays as arguments to functions:</source>
          <target state="translated">Вы также можете использовать массивы переменной длины в качестве аргументов к функциям:</target>
        </trans-unit>
        <trans-unit id="3ed04a1e1ec2d18dcef36c3f37e8523ec33398b1" translate="yes" xml:space="preserve">
          <source>You can also write a series of &amp;lsquo;</source>
          <target state="translated">Вы также можете написать серию &quot;</target>
        </trans-unit>
        <trans-unit id="9a5d42d9b4feab1feb11ac3d7558132f70441d15" translate="yes" xml:space="preserve">
          <source>You can combine this technique of naming elements with ordinary C initialization of successive elements. Each initializer element that does not have a designator applies to the next consecutive element of the array or structure. For example,</source>
          <target state="translated">Вы можете комбинировать эту технику именования элементов с обычной инициализацией последовательных элементов на языке C.Каждый элемент инициализатора,не имеющий обозначения,относится к следующему последующему элементу массива или структуры.Например,</target>
        </trans-unit>
        <trans-unit id="dafe9f6d4d43d75c6afd7b0ee12396460454db2d" translate="yes" xml:space="preserve">
          <source>You can compile C or C++ programs.</source>
          <target state="translated">Вы можете скомпилировать программы на C или C++.</target>
        </trans-unit>
        <trans-unit id="54a148541552bb61abf1cc1bf716d6d5d34812ff" translate="yes" xml:space="preserve">
          <source>You can declare variables and use them in function calls and returns, as well as in assignments and some casts. You can specify a vector type as a return type for a function. Vector types can also be used as function arguments. It is possible to cast from one vector type to another, provided they are of the same size (in fact, you can also cast vectors to and from other datatypes of the same size).</source>
          <target state="translated">Вы можете объявлять переменные и использовать их в вызовах и возвратах функций,а также в присваиваниях и некоторых кастах.В качестве типа возврата для функции можно указать тип вектора.Векторные типы также могут быть использованы в качестве аргументов функции.Возможно приведение от одного векторного типа к другому при условии,что они имеют одинаковый размер (фактически,можно также приводить векторы к и от других типов данных того же размера).</target>
        </trans-unit>
        <trans-unit id="1ab5d021681ed2c7cdd4c44a866c9249ac2dea29" translate="yes" xml:space="preserve">
          <source>You can define a global register variable and associate it with a specified register like this:</source>
          <target state="translated">Вы можете определить глобальную регистровую переменную и связать ее с указанным регистром вот так:</target>
        </trans-unit>
        <trans-unit id="77ca46933320ecebc543d5687d368957991075a9" translate="yes" xml:space="preserve">
          <source>You can define a local register variable and associate it with a specified register like this:</source>
          <target state="translated">Вы можете определить локальную регистровую переменную и связать ее с указанным регистром вот так:</target>
        </trans-unit>
        <trans-unit id="ca45e2aac1a5f53872ccff8b57eb4700a2d304e0" translate="yes" xml:space="preserve">
          <source>You can define an &lt;code&gt;enum&lt;/code&gt; tag without specifying its possible values. This results in an incomplete type, much like what you get if you write &lt;code&gt;struct foo&lt;/code&gt; without describing the elements. A later declaration that does specify the possible values completes the type.</source>
          <target state="translated">Вы можете определить тег &lt;code&gt;enum&lt;/code&gt; без указания его возможных значений. Это приводит к неполному типу, очень похожему на то, что вы получите, если напишете &lt;code&gt;struct foo&lt;/code&gt; без описания элементов. Более позднее объявление, в котором указаны возможные значения, завершает тип.</target>
        </trans-unit>
        <trans-unit id="fb2a1d08a5c520db79d7874dd1dd146adad124cb" translate="yes" xml:space="preserve">
          <source>You can easily find more examples by running the &amp;ldquo;strings&amp;rdquo; program on an Objective-C object file compiled by GCC. You&amp;rsquo;ll see a lot of strings that look very much like &lt;code&gt;i8@0:4&lt;/code&gt;. They are signatures of Objective-C methods.</source>
          <target state="translated">Вы можете легко найти больше примеров, запустив программу &amp;laquo;строк&amp;raquo; ​​в объектном файле Objective-C, скомпилированном GCC. Вы увидите множество строк, очень похожих на &lt;code&gt;i8@0:4&lt;/code&gt; . Они являются сигнатурами методов Objective-C.</target>
        </trans-unit>
        <trans-unit id="c91ff1d5bc0072fabb3f73c5cf99e1426b54e8b7" translate="yes" xml:space="preserve">
          <source>You can extract a function pointer to the method denoted by a &amp;lsquo;</source>
          <target state="translated">Вы можете извлечь указатель функции на метод, обозначенный символом '</target>
        </trans-unit>
        <trans-unit id="8a467dff38136e5694516c0b9fa42d9b5384c2d1" translate="yes" xml:space="preserve">
          <source>You can get the address of a label defined in the current function (or a containing function) with the unary operator &amp;lsquo;</source>
          <target state="translated">Вы можете получить адрес метки, определенной в текущей функции (или содержащей функцию), с помощью унарного оператора '</target>
        </trans-unit>
        <trans-unit id="66a39a597ab8644152ae7afe5488f241a221884a" translate="yes" xml:space="preserve">
          <source>You can locally override stack limit checking by using the &lt;code&gt;no_stack_limit&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">Вы можете локально переопределить проверку предела стека, используя &lt;code&gt;no_stack_limit&lt;/code&gt; функции no_stack_limit (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="017844d9ef74d08a2197a10acca046c6aa9a28bc" translate="yes" xml:space="preserve">
          <source>You can make</source>
          <target state="translated">Вы можете сделать</target>
        </trans-unit>
        <trans-unit id="f287c383d16164fdc862549b5e329c619384b24c" translate="yes" xml:space="preserve">
          <source>You can mix options and other arguments. For the most part, the order you use doesn&amp;rsquo;t matter. Order does matter when you use several options of the same kind; for example, if you specify</source>
          <target state="translated">Вы можете смешивать варианты и другие аргументы. По большей части порядок, который вы используете, не имеет значения. Порядок имеет значение, когда вы используете несколько вариантов одного и того же типа; например, если вы укажете</target>
        </trans-unit>
        <trans-unit id="a60d360fa80936234f5b0e4eae813689b9ce29d9" translate="yes" xml:space="preserve">
          <source>You can partially avoid this problem by using the</source>
          <target state="translated">Вы можете частично избежать этой проблемы,используя</target>
        </trans-unit>
        <trans-unit id="dd9e0967154278910b1a4d13c152f96dcaf35354" translate="yes" xml:space="preserve">
          <source>You can pass options to the assembler.</source>
          <target state="translated">Вы можете передать опции сборщику.</target>
        </trans-unit>
        <trans-unit id="394017d54ef624457656b3872471fba70d98d59b" translate="yes" xml:space="preserve">
          <source>You can provide an argument to the interrupt attribute which specifies a name or number. If the argument is a number it indicates the slot in the interrupt vector table (0 - 31) to which this handler should be assigned. If the argument is a name it is treated as a symbolic name for the vector slot. These names should match up with appropriate entries in the linker script. By default the names &lt;code&gt;watchdog&lt;/code&gt; for vector 26, &lt;code&gt;nmi&lt;/code&gt; for vector 30 and &lt;code&gt;reset&lt;/code&gt; for vector 31 are recognized.</source>
          <target state="translated">Вы можете предоставить аргумент для атрибута прерывания, который указывает имя или номер. Если аргумент является числом, он указывает слот в таблице векторов прерываний (0&amp;ndash;31), которому должен быть назначен этот обработчик. Если аргументом является имя, оно рассматривается как символическое имя для векторного слота. Эти имена должны совпадать с соответствующими записями в сценарии компоновщика. По умолчанию распознаются &lt;code&gt;watchdog&lt;/code&gt; имен для вектора 26, &lt;code&gt;nmi&lt;/code&gt; для вектора 30 и &lt;code&gt;reset&lt;/code&gt; для вектора 31.</target>
        </trans-unit>
        <trans-unit id="21a34f7c6e1539af9716888a85e0e6ebdfedbecf" translate="yes" xml:space="preserve">
          <source>You can request many specific warnings with options beginning with &amp;lsquo;</source>
          <target state="translated">Вы можете запросить множество конкретных предупреждений с параметрами, начинающимися с '</target>
        </trans-unit>
        <trans-unit id="7fbbe3966a5814f26c4830b1276b72ab5f2dc01c" translate="yes" xml:space="preserve">
          <source>You can specify a range of consecutive values in a single &lt;code&gt;case&lt;/code&gt; label, like this:</source>
          <target state="translated">Вы можете указать диапазон последовательных значений в метке с одним &lt;code&gt;case&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="97b79ea591cef9266e325e711531c14dffd1c998" translate="yes" xml:space="preserve">
          <source>You can specify any number or combination of these options on the command line to search for header files in several directories. The lookup order is as follows:</source>
          <target state="translated">Вы можете указать любое количество или комбинацию этих опций в командной строке для поиска заголовочных файлов в нескольких каталогах.Порядок поиска следующий:</target>
        </trans-unit>
        <trans-unit id="0856d34db6c364c78838eb5dc1f8a6703a890626" translate="yes" xml:space="preserve">
          <source>You can specify that an individual function is called with this calling sequence with the function attribute &lt;code&gt;stdcall&lt;/code&gt;. You can also override the</source>
          <target state="translated">Вы можете указать, что отдельная функция вызывается с этой последовательностью вызовов, с помощью атрибута функции &lt;code&gt;stdcall&lt;/code&gt; . Вы также можете переопределить</target>
        </trans-unit>
        <trans-unit id="e32757ea6fc6362ed46b9b724d574c0143bee986" translate="yes" xml:space="preserve">
          <source>You can specify the input language explicitly with the</source>
          <target state="translated">Вы можете явно указать язык ввода с помощью команды</target>
        </trans-unit>
        <trans-unit id="5a6c68a45d3cab174002900881189fc68df355b1" translate="yes" xml:space="preserve">
          <source>You can specify the kind of interrupt to be handled by adding an optional parameter to the interrupt attribute like this:</source>
          <target state="translated">Вы можете указать тип обрабатываемого прерывания,добавив дополнительный параметр к атрибуту прерывания,например,такой:</target>
        </trans-unit>
        <trans-unit id="eee1f7bf9410ab86d8dd30e2bec2be1b2b043010" translate="yes" xml:space="preserve">
          <source>You can specify the name to be used in the assembler code for a C function or variable by writing the &lt;code&gt;asm&lt;/code&gt; (or &lt;code&gt;__asm__&lt;/code&gt;) keyword after the declarator. It is up to you to make sure that the assembler names you choose do not conflict with any other assembler symbols, or reference registers.</source>
          <target state="translated">Вы можете указать имя, которое будет использоваться в коде ассемблера для функции или переменной C, написав ключевое слово &lt;code&gt;asm&lt;/code&gt; (или &lt;code&gt;__asm__&lt;/code&gt; ) после декларатора. Вы должны убедиться, что выбранные вами имена ассемблера не конфликтуют с другими символами ассемблера или ссылочными регистрами.</target>
        </trans-unit>
        <trans-unit id="30703f7905f24c8604a78167a64a5e3a31da9d67" translate="yes" xml:space="preserve">
          <source>You can switch the warning off for all characters by writing</source>
          <target state="translated">Вы можете отключить предупреждение для всех символов,написав</target>
        </trans-unit>
        <trans-unit id="95dff15ddf46fdf8429aae6e46c8c16ce4977196" translate="yes" xml:space="preserve">
          <source>You can tell GCC to use a compatible convention for all structure and union returning with the option</source>
          <target state="translated">Вы можете сказать GCC использовать совместимое соглашение для всех структур и союзов возвращения с вариантом</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">Вы можете использовать</target>
        </trans-unit>
        <trans-unit id="4f81d4b126c2797fc5e8e7dc1694c11a9c296047" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllexport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;__declspec(dllexport)&lt;/code&gt; как синоним для &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; для совместимости с другими компиляторами.</target>
        </trans-unit>
        <trans-unit id="50005d4562495b37fc24571844dc1743ca746f4c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllimport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;__declspec(dllimport)&lt;/code&gt; в качестве синонима &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; для совместимости с другими компиляторами.</target>
        </trans-unit>
        <trans-unit id="86cd667b81efa67cbffa6feec930a1fbdb8eae9f" translate="yes" xml:space="preserve">
          <source>You can use a single C++ header file for both declarations and definitions.</source>
          <target state="translated">Вы можете использовать один C++заголовочный файл как для деклараций,так и для определений.</target>
        </trans-unit>
        <trans-unit id="9d208552bb3a27bb1eed945c45c53009e9054861" translate="yes" xml:space="preserve">
          <source>You can use any combination of these attributes, as shown below:</source>
          <target state="translated">Вы можете использовать любую комбинацию этих атрибутов,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="db76755964be4e6b6be71f9e85d1a8d93663640f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;copy&lt;/code&gt; attribute to apply the same set of attributes to a declaration as that on another declaration without explicitly enumerating the attributes. This attribute can be applied to declarations of functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;), or types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="translated">Вы можете использовать атрибут &lt;code&gt;copy&lt;/code&gt; чтобы применить тот же набор атрибутов к объявлению, что и к другому объявлению, без явного перечисления атрибутов. Этот атрибут может применяться к объявлениям функций (см. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функций&lt;/a&gt; ), переменных (см. &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Общие атрибуты переменных&lt;/a&gt; ) или типов (см. &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Общие атрибуты типов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="89b5b15d997a3489b69c6b152372fee0f86bbdac" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_choose_expr&lt;/code&gt; to evaluate code depending on the value of a constant expression. This built-in function returns &lt;var&gt;exp1&lt;/var&gt; if &lt;var&gt;const_exp&lt;/var&gt;, which is an integer constant expression, is nonzero. Otherwise it returns &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">Вы можете использовать встроенную функцию &lt;code&gt;__builtin_choose_expr&lt;/code&gt; для оценки кода в зависимости от значения константного выражения. Эта встроенная функция возвращает &lt;var&gt;exp1&lt;/var&gt; , если &lt;var&gt;const_exp&lt;/var&gt; , которое является целочисленным константным выражением, не равно нулю. В противном случае возвращается &lt;var&gt;exp2&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd9fec295629e67098066cf6cb3c9ec92e5bb68" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_constant_p&lt;/code&gt; to determine if a value is known to be constant at compile time and hence that GCC can perform constant-folding on expressions involving that value. The argument of the function is the value to test. The function returns the integer 1 if the argument is known to be a compile-time constant and 0 if it is not known to be a compile-time constant. A return of 0 does not indicate that the value is &lt;em&gt;not&lt;/em&gt; a constant, but merely that GCC cannot prove it is a constant with the specified value of the</source>
          <target state="translated">Вы можете использовать встроенную функцию &lt;code&gt;__builtin_constant_p&lt;/code&gt; , чтобы определить, является ли значение постоянным во время компиляции и, следовательно, GCC может выполнять свертывание констант для выражений, включающих это значение. Аргумент функции - это проверяемое значение. Функция возвращает целое число 1, если известно, что аргумент является константой времени компиляции, и 0, если известно, что он не является константой времени компиляции. Возврат 0 не означает, что значение &lt;em&gt;не&lt;/em&gt; является константой, а просто то, что GCC не может доказать, что это константа с указанным значением</target>
        </trans-unit>
        <trans-unit id="9782a2381707d838ed59767d72501592b95036b5" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; to determine whether two types are the same.</source>
          <target state="translated">Вы можете использовать встроенную функцию &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; , чтобы определить, являются ли два типа одинаковыми.</target>
        </trans-unit>
        <trans-unit id="43fa60b9360490e7ba0b03452edb689c2650070f" translate="yes" xml:space="preserve">
          <source>You can use the following attributes to modify the behavior of an interrupt handler:</source>
          <target state="translated">Вы можете использовать следующие атрибуты для изменения поведения обработчика прерываний:</target>
        </trans-unit>
        <trans-unit id="02c72ec7b7bacac9ecd4a1fee983fedeb76ad118" translate="yes" xml:space="preserve">
          <source>You can use the function &lt;code&gt;alloca&lt;/code&gt; to get an effect much like variable-length arrays. The function &lt;code&gt;alloca&lt;/code&gt; is available in many other C implementations (but not in all). On the other hand, variable-length arrays are more elegant.</source>
          <target state="translated">Вы можете использовать функцию &lt;code&gt;alloca&lt;/code&gt; , чтобы получить эффект, похожий на массивы переменной длины. Функция &lt;code&gt;alloca&lt;/code&gt; доступна во многих других реализациях C (но не во всех). С другой стороны, массивы переменной длины более элегантны.</target>
        </trans-unit>
        <trans-unit id="50e67953531648188b117541d8b8b4fa30e96296" translate="yes" xml:space="preserve">
          <source>You can use the function attribute &lt;code&gt;no_instrument_function&lt;/code&gt; to suppress profiling of individual functions when compiling with these options. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">Вы можете использовать атрибут функции &lt;code&gt;no_instrument_function&lt;/code&gt; , чтобы подавить профилирование отдельных функций при компиляции с этими параметрами. См. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0525436fc5cc0248b7f78e573bd26eb006c5427" translate="yes" xml:space="preserve">
          <source>You can use the sequence &amp;lsquo;</source>
          <target state="translated">Вы можете использовать последовательность '</target>
        </trans-unit>
        <trans-unit id="25c48302e37cab0b76739d2efc98f5300353b6c4" translate="yes" xml:space="preserve">
          <source>You can use these attributes on Microsoft Windows targets. &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; for additional Windows compatibility attributes available on all x86 targets.</source>
          <target state="translated">Вы можете использовать эти атрибуты в целях Microsoft Windows. &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;Атрибуты переменных x86&lt;/a&gt; для дополнительных атрибутов совместимости Windows, доступных для всех целей x86.</target>
        </trans-unit>
        <trans-unit id="349076840f0960c3892315d6f39c00e2e8d77252" translate="yes" xml:space="preserve">
          <source>You can use these types in arithmetic like any other integer types. Addition, subtraction, and bitwise boolean operations on these types are open-coded on all types of machines. Multiplication is open-coded if the machine supports a fullword-to-doubleword widening multiply instruction. Division and shifts are open-coded only on machines that provide special support. The operations that are not open-coded use special library routines that come with GCC.</source>
          <target state="translated">Вы можете использовать эти типы в арифметике,как и любые другие целочисленные типы.Добавление,вычитание и битовые логические операции над этими типами открыты для всех типов машин.Умножение является открытым кодом,если машина поддерживает инструкцию умножения с расширением от одного до двух слов.Деление и сдвиги открыты только на машинах,которые обеспечивают специальную поддержку.Операции,которые не имеют открытого кода,используют специальные библиотечные подпрограммы,которые поставляются с GCC.</target>
        </trans-unit>
        <trans-unit id="5aa1044e05ab82d1a453a9feb88c6b31c8d70c35" translate="yes" xml:space="preserve">
          <source>You can use this pragma to control how many times a loop should be unrolled. It must be placed immediately before a &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt; loop or a &lt;code&gt;#pragma GCC ivdep&lt;/code&gt;, and applies only to the loop that follows. &lt;var&gt;n&lt;/var&gt; is an integer constant expression specifying the unrolling factor. The values of &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;1&lt;/em&gt; block any unrolling of the loop.</source>
          <target state="translated">Вы можете использовать эту прагму, чтобы контролировать, сколько раз цикл должен быть развернут. Он должен быть размещен непосредственно перед циклом &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; или &lt;code&gt;do&lt;/code&gt; или &lt;code&gt;#pragma GCC ivdep&lt;/code&gt; и применяется только к следующему циклу. &lt;var&gt;n&lt;/var&gt; - целочисленное постоянное выражение, определяющее коэффициент развертки. Значения &lt;em&gt;0&lt;/em&gt; и &lt;em&gt;1&lt;/em&gt; блокируют любое развертывание цикла.</target>
        </trans-unit>
        <trans-unit id="d29715d375c9f43b63580c5f152e79229b459a6b" translate="yes" xml:space="preserve">
          <source>You can write any number of such parameter forward declarations in the parameter list. They can be separated by commas or semicolons, but the last one must end with a semicolon, which is followed by the &amp;ldquo;real&amp;rdquo; parameter declarations. Each forward declaration must match a &amp;ldquo;real&amp;rdquo; declaration in parameter name and data type. ISO C99 does not support parameter forward declarations.</source>
          <target state="translated">Вы можете записать любое количество таких предварительных объявлений параметров в список параметров. Их можно разделять запятыми или точками с запятой, но последняя должна заканчиваться точкой с запятой, за которой следуют &amp;laquo;настоящие&amp;raquo; объявления параметров. Каждое предварительное объявление должно соответствовать &amp;laquo;реальному&amp;raquo; объявлению в имени параметра и типе данных. ISO C99 не поддерживает предварительное объявление параметров.</target>
        </trans-unit>
        <trans-unit id="4d285fcb57d29c445f5c75a81399654db437434b" translate="yes" xml:space="preserve">
          <source>You cannot allocate variables or storage using the type while it is incomplete. However, you can work with pointers to that type.</source>
          <target state="translated">Нельзя выделять переменные или хранилище по типу,пока он неполный.Однако,вы можете работать с указателями на этот тип.</target>
        </trans-unit>
        <trans-unit id="53335da409471fbe7935a617fd9f6ebf473abc26" translate="yes" xml:space="preserve">
          <source>You cannot operate between vectors of different lengths or different signedness without a cast.</source>
          <target state="translated">Нельзя работать между векторами разной длины или разной подписью без гипса.</target>
        </trans-unit>
        <trans-unit id="13abf1800307e25590d2602f0489f433955f9bc6" translate="yes" xml:space="preserve">
          <source>You have freedom to copy and modify this GNU Manual, like GNU software. Copies published by the Free Software Foundation raise funds for GNU development.</source>
          <target state="translated">У вас есть свобода копировать и изменять это Руководство GNU,как программы GNU.Копии,опубликованные Фондом свободного программного обеспечения,собирают средства на разработку GNU.</target>
        </trans-unit>
        <trans-unit id="35918096a4cd3290ec21ef1581f71b03f35bc6de" translate="yes" xml:space="preserve">
          <source>You have the following options for dealing with template instantiations:</source>
          <target state="translated">У вас есть следующие опции для работы с инстанциями шаблонов:</target>
        </trans-unit>
        <trans-unit id="83ae29ebda55f943f2de3641f83fdea66157c750" translate="yes" xml:space="preserve">
          <source>You have to expect a certain amount of disagreement between the executable and your source code, when you use optimization.</source>
          <target state="translated">При использовании оптимизации следует ожидать некоторого расхождения между исполняемым файлом и вашим исходным кодом.</target>
        </trans-unit>
        <trans-unit id="c18143538d54c0195224945ef42bc5ea23853737" translate="yes" xml:space="preserve">
          <source>You may also specify whether a member function&amp;rsquo;s &lt;var&gt;this&lt;/var&gt; pointer is unaliased by using &lt;code&gt;__restrict__&lt;/code&gt; as a member function qualifier.</source>
          <target state="translated">Вы можете также указать , является ли функция - член в &lt;var&gt;this&lt;/var&gt; является unaliased с помощью указателя &lt;code&gt;__restrict__&lt;/code&gt; в качестве функции члена классификатором.</target>
        </trans-unit>
        <trans-unit id="3c9c1785a9b73c6c0c84000e89963aae3de9c571" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;__builtin_constant_p&lt;/code&gt; in initializers for static data. For instance, you can write</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;__builtin_constant_p&lt;/code&gt; в инициализаторах для статических данных. Например, вы можете написать</target>
        </trans-unit>
        <trans-unit id="77816405062bcfbd54b0c2d088c0cfe9f5a2c604" translate="yes" xml:space="preserve">
          <source>You may mark a method as having a visibility explicitly to negate the effect of the switch for that method. For example, if you do want to compare pointers to a particular inline method, you might mark it as having default visibility. Marking the enclosing class with explicit visibility has no effect.</source>
          <target state="translated">Вы можете пометить метод как метод,имеющий видимость явно для того,чтобы отрицать эффект коммутатора для этого метода.Например,если вы хотите сравнить указатели с определенным методом,вы можете пометить его как метод,имеющий видимость по умолчанию.Пометка класса-вкладыша с явной видимостью не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="e445da5feb655d87cca8dbc770cb3f7e24dc970f" translate="yes" xml:space="preserve">
          <source>You may need to experiment to determine the best settings for your application.</source>
          <target state="translated">Возможно,вам понадобится поэкспериментировать,чтобы определить наилучшие настройки для вашего приложения.</target>
        </trans-unit>
        <trans-unit id="bad95174418ab8218d171a6375d9166859a034cf" translate="yes" xml:space="preserve">
          <source>You may need to specify</source>
          <target state="translated">Возможно,вам понадобится указать</target>
        </trans-unit>
        <trans-unit id="48a08602699410d27da97f57d05daf9841a17a43" translate="yes" xml:space="preserve">
          <source>You may not use this mechanism to jump to code in a different function. If you do that, totally unpredictable things happen. The best way to avoid this is to store the label address only in automatic variables and never pass it as an argument.</source>
          <target state="translated">Этот механизм нельзя использовать для перехода к коду в другой функции.Если вы это сделаете,то произойдут совершенно непредсказуемые вещи.Лучший способ избежать этого-хранить адрес метки только в автоматических переменных и никогда не передавать его в качестве аргумента.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
