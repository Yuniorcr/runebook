<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="e9932d75815f4a1da8b9c3167803247d114d4d3e" translate="yes" xml:space="preserve">
          <source>Some AVR devices (AT90S8515, ATmega103) must not skip 32-bit instructions because of a hardware erratum. Skip instructions are &lt;code&gt;SBRS&lt;/code&gt;, &lt;code&gt;SBRC&lt;/code&gt;, &lt;code&gt;SBIS&lt;/code&gt;, &lt;code&gt;SBIC&lt;/code&gt; and &lt;code&gt;CPSE&lt;/code&gt;. The second macro is only defined if &lt;code&gt;__AVR_HAVE_JMP_CALL__&lt;/code&gt; is also set.</source>
          <target state="translated">Некоторые устройства AVR (AT90S8515, ATmega103) не должны пропускать 32-битные инструкции из-за аппаратной ошибки. Пропустить инструкции &lt;code&gt;SBRS&lt;/code&gt; , &lt;code&gt;SBRC&lt;/code&gt; , &lt;code&gt;SBIS&lt;/code&gt; , &lt;code&gt;SBIC&lt;/code&gt; и &lt;code&gt;CPSE&lt;/code&gt; . Второй макрос определяется, только если также установлено &lt;code&gt;__AVR_HAVE_JMP_CALL__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8587f1a252be44a26b4bf83b41b8cacfabe3c53" translate="yes" xml:space="preserve">
          <source>Some AVR devices support memories larger than the 64 KiB range that can be accessed with 16-bit pointers. To access memory locations outside this 64 KiB range, the content of a &lt;code&gt;RAMP&lt;/code&gt; register is used as high part of the address: The &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; address register is concatenated with the &lt;code&gt;RAMPX&lt;/code&gt;, &lt;code&gt;RAMPY&lt;/code&gt;, &lt;code&gt;RAMPZ&lt;/code&gt; special function register, respectively, to get a wide address. Similarly, &lt;code&gt;RAMPD&lt;/code&gt; is used together with direct addressing.</source>
          <target state="translated">Некоторые устройства AVR поддерживают память размером более 64 КиБ, к которой можно получить доступ с помощью 16-битных указателей. Для доступа к ячейкам памяти за пределами этого диапазона 64 КиБ содержимое регистра &lt;code&gt;RAMP&lt;/code&gt; используется как старшая часть адреса: регистр адреса &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; объединяется с &lt;code&gt;RAMPZ&lt;/code&gt; специальной функции &lt;code&gt;RAMPX&lt;/code&gt; , &lt;code&gt;RAMPY&lt;/code&gt; , RAMPZ соответственно, чтобы получить широкий адрес. Аналогичным образом &lt;code&gt;RAMPD&lt;/code&gt; используется вместе с прямой адресацией.</target>
        </trans-unit>
        <trans-unit id="b652248718bfad5072f0c61fa63785c614519d9b" translate="yes" xml:space="preserve">
          <source>Some Cortex-M3 cores can cause data corruption when &lt;code&gt;ldrd&lt;/code&gt; instructions with overlapping destination and base registers are used. This option avoids generating these instructions. This option is enabled by default when</source>
          <target state="translated">Некоторые ядра Cortex-M3 могут вызвать повреждение данных при &lt;code&gt;ldrd&lt;/code&gt; инструкций ldrd с перекрывающимися целевым и базовым регистрами. Эта опция позволяет избежать генерации этих инструкций. Эта опция включена по умолчанию, когда</target>
        </trans-unit>
        <trans-unit id="de0fd695fef81a6e3c397b49019c4e2e00e1f0cc" translate="yes" xml:space="preserve">
          <source>Some GCC compilation options cause the compiler to generate code that does not conform to the platform&amp;rsquo;s default ABI. Other options cause different program behavior for implementation-defined features that are not covered by an ABI. These options are provided for consistency with other compilers that do not follow the platform&amp;rsquo;s default ABI or the usual behavior of implementation-defined features for the platform. Be very careful about using such options.</source>
          <target state="translated">Некоторые параметры компиляции GCC заставляют компилятор генерировать код, который не соответствует ABI платформы по умолчанию. Другие параметры вызывают другое поведение программы для функций, определяемых реализацией, которые не охватываются ABI. Эти параметры предоставляются для согласованности с другими компиляторами, которые не следуют ABI платформы по умолчанию или обычному поведению функций, определенных реализацией для платформы. Будьте очень осторожны при использовании таких опций.</target>
        </trans-unit>
        <trans-unit id="0325ca2d082f6bb9f5d1e5e855cb8121b2560adb" translate="yes" xml:space="preserve">
          <source>Some ISO C testsuites report failure when the compiler does not produce an error message for a certain program.</source>
          <target state="translated">Некоторые тестирующие комплекты ISO C сообщают о сбоях,когда компилятор не выдает сообщение об ошибке для определенной программы.</target>
        </trans-unit>
        <trans-unit id="84f1bb1b30ec55b3fd5d6eb1c7f6faa03400485d" translate="yes" xml:space="preserve">
          <source>Some additional environment variables affect the behavior of the preprocessor.</source>
          <target state="translated">Некоторые дополнительные переменные окружения влияют на поведение препроцессора.</target>
        </trans-unit>
        <trans-unit id="5045e735a2d8c7129e122a97ea30410aa9319aed" translate="yes" xml:space="preserve">
          <source>Some assemblers only support this flag when &lt;var&gt;n&lt;/var&gt; is a power of two; in that case, it is rounded up.</source>
          <target state="translated">Некоторые ассемблеры поддерживают этот флаг, только когда &lt;var&gt;n&lt;/var&gt; является степенью двойки; в этом случае оно округляется в большую сторону.</target>
        </trans-unit>
        <trans-unit id="2ceba313d16765bb5b6ec17c1ebb8d3d9c14df42" translate="yes" xml:space="preserve">
          <source>Some attributes only make sense for C++ programs.</source>
          <target state="translated">Некоторые атрибуты имеют смысл только для программ на Си++.</target>
        </trans-unit>
        <trans-unit id="81c2a3663ddcd2a93314c07f339088b18a9513ff" translate="yes" xml:space="preserve">
          <source>Some cases of unnamed fields in structures and unions are only accepted with this option. See &lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;Unnamed struct/union fields within structs/unions&lt;/a&gt;, for details.</source>
          <target state="translated">Некоторые случаи безымянных полей в структурах и объединениях принимаются только с этой опцией. См. Подробности в разделе &amp;laquo; &lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;Неназванные поля структуры / объединения в структурах / объединениях&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15750fff39388c96e233f1fff7614239f8996f69" translate="yes" xml:space="preserve">
          <source>Some characters in ISO 10646 have distinct meanings but look identical in some fonts or display methodologies, especially once formatting has been applied. For instance &lt;code&gt;\u207F&lt;/code&gt;, &amp;ldquo;SUPERSCRIPT LATIN SMALL LETTER N&amp;rdquo;, displays just like a regular &lt;code&gt;n&lt;/code&gt; that has been placed in a superscript. ISO 10646 defines the &lt;em&gt;NFKC&lt;/em&gt; normalization scheme to convert all these into a standard form as well, and GCC warns if your code is not in NFKC if you use</source>
          <target state="translated">Некоторые символы в ISO 10646 имеют разные значения, но выглядят одинаково в некоторых шрифтах или методах отображения, особенно после применения форматирования. Например, &lt;code&gt;\u207F&lt;/code&gt; , &amp;laquo;SUPERSCRIPT LATIN SMART LETTER N&amp;raquo; отображается так же, как обычное &lt;code&gt;n&lt;/code&gt; , помещенное в верхний индекс. ISO 10646 определяет &lt;em&gt;схему&lt;/em&gt; нормализации &lt;em&gt;NFKC&lt;/em&gt; для преобразования всего этого в стандартную форму, а GCC предупреждает, если ваш код не находится в NFKC, если вы используете</target>
        </trans-unit>
        <trans-unit id="5d2e5736cfa0533f11cc548a18ee8de7127f23cf" translate="yes" xml:space="preserve">
          <source>Some checkers are disabled by default (even with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06da659fa22deee4cc3d56729c6b4abce7edba00" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are documented in the corresponding document for the C language. See &lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;C Implementation&lt;/a&gt;. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="translated">Некоторые варианты зависят от определяемого извне ABI для платформы (включая стандартные кодировки символов), которому следует GCC; они перечислены ниже как &amp;laquo;определенные ABI&amp;raquo;. См. Раздел &amp;laquo; &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Двоичная совместимость&amp;raquo;&lt;/a&gt; и &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt; . Некоторые варианты задокументированы в руководстве препроцессора. См. Описание &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;поведения, определенного реализацией&lt;/a&gt; в Препроцессоре C. Некоторые варианты описаны в соответствующем документе для языка C. См &lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;Реализация C&lt;/a&gt; . Некоторые варианты выбора выполняются библиотекой и операционной системой (или другой средой при компиляции для автономной среды); обратитесь к их документации за подробностями.</target>
        </trans-unit>
        <trans-unit id="258878cc764e88fa980c6c9ddf4a6f80e9d5cd8f" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="translated">Некоторые варианты зависят от определяемого извне ABI для платформы (включая стандартные кодировки символов), которому следует GCC; они перечислены ниже как &amp;laquo;определенные ABI&amp;raquo;. См. Раздел &amp;laquo; &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Двоичная совместимость&amp;raquo;&lt;/a&gt; и &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt; . Некоторые варианты задокументированы в руководстве препроцессора. См. Описание &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;поведения, определенного реализацией&lt;/a&gt; в Препроцессоре C. Некоторые варианты выбора выполняются библиотекой и операционной системой (или другой средой при компиляции для автономной среды); обратитесь к их документации за подробностями.</target>
        </trans-unit>
        <trans-unit id="15506c8b8d5d6b275040aeee640a2a5a3f7d4d37" translate="yes" xml:space="preserve">
          <source>Some common examples of pure functions are &lt;code&gt;strlen&lt;/code&gt; or &lt;code&gt;memcmp&lt;/code&gt;. Interesting non-pure functions are functions with infinite loops or those depending on volatile memory or other system resource, that may change between consecutive calls (such as the standard C &lt;code&gt;feof&lt;/code&gt; function in a multithreading environment).</source>
          <target state="translated">Некоторые распространенные примеры чистых функций - это &lt;code&gt;strlen&lt;/code&gt; или &lt;code&gt;memcmp&lt;/code&gt; . Интересные &amp;laquo;нечистые&amp;raquo; функции - это функции с бесконечными циклами или функции, зависящие от энергозависимой памяти или другого системного ресурса, которые могут меняться между последовательными вызовами (например, стандартная функция C &lt;code&gt;feof&lt;/code&gt; в многопоточной среде).</target>
        </trans-unit>
        <trans-unit id="12ce1dfd34507685834493a64bea0bb0f207ab99" translate="yes" xml:space="preserve">
          <source>Some computer manufacturers have published Application Binary Interface standards which specify that plain bit-fields should be unsigned. It is a mistake, however, to say anything about this issue in an ABI. This is because the handling of plain bit-fields distinguishes two dialects of C. Both dialects are meaningful on every type of machine. Whether a particular object file was compiled using signed bit-fields or unsigned is of no concern to other object files, even if they access the same bit-fields in the same data structures.</source>
          <target state="translated">Некоторые производители компьютеров опубликовали стандарты двоичного интерфейса приложений,в которых указано,что простые битовые поля должны быть неподписанными.Однако,говорить что-либо об этом в ABI-это ошибка.Это происходит потому,что работа с обычными битовыми полями различает два диалекта C.Оба диалекта имеют смысл на каждом типе машин.Был ли конкретный объектный файл скомпилирован с использованием подписанных битовых полей или без них,не имеет значения для других объектных файлов,даже если они обращаются к одним и тем же битовым полям в одних и тех же структурах данных.</target>
        </trans-unit>
        <trans-unit id="71e1ac9ab0109c68aee90fe9c98e8024ac2ba20a" translate="yes" xml:space="preserve">
          <source>Some configurations of the compiler also support additional target-specific options, usually for compatibility with other compilers on the same platform.</source>
          <target state="translated">Некоторые конфигурации компилятора также поддерживают дополнительные целевые опции,обычно для совместимости с другими компиляторами на той же платформе.</target>
        </trans-unit>
        <trans-unit id="efc299e6d6d519531f7a42935a2ff0371856c97e" translate="yes" xml:space="preserve">
          <source>Some developers use Local Register Variables in an attempt to improve gcc&amp;rsquo;s allocation of registers, especially in large functions. In this case the register name is essentially a hint to the register allocator. While in some instances this can generate better code, improvements are subject to the whims of the allocator/optimizers. Since there are no guarantees that your improvements won&amp;rsquo;t be lost, this usage of Local Register Variables is discouraged.</source>
          <target state="translated">Некоторые разработчики используют переменные локальных регистров в попытке улучшить распределение регистров в gcc, особенно в больших функциях. В этом случае имя регистра является подсказкой для распределителя регистров. Хотя в некоторых случаях это может привести к созданию лучшего кода, улучшения зависят от капризов распределителя / оптимизаторов. Поскольку нет никаких гарантий, что ваши улучшения не будут потеряны, такое использование переменных локального регистра не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="cd13c19c4da21f1c5afd2756424c80ed7c852869" translate="yes" xml:space="preserve">
          <source>Some devices support reading from flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions. The flash memory is seen in the data address space at an offset of &lt;code&gt;__AVR_PM_BASE_ADDRESS__&lt;/code&gt;. If this macro is not defined, this feature is not available. If defined, the address space is linear and there is no need to put &lt;code&gt;.rodata&lt;/code&gt; into RAM. This is handled by the default linker description file, and is currently available for &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt;. Even more convenient, there is no need to use address spaces like &lt;code&gt;__flash&lt;/code&gt; or features like attribute &lt;code&gt;progmem&lt;/code&gt; and &lt;code&gt;pgm_read_*&lt;/code&gt;.</source>
          <target state="translated">Некоторые устройства поддерживают чтение из флэш-памяти с помощью инструкций &lt;code&gt;LD*&lt;/code&gt; . Флэш-память видна в адресном пространстве данных со смещением &lt;code&gt;__AVR_PM_BASE_ADDRESS__&lt;/code&gt; . Если этот макрос не определен, эта функция недоступна. Если определено, адресное пространство является линейным, и нет необходимости помещать &lt;code&gt;.rodata&lt;/code&gt; в ОЗУ. Это обрабатывается файлом описания компоновщика по умолчанию, и в настоящее время он доступен для &lt;code&gt;avrtiny&lt;/code&gt; и &lt;code&gt;avrxmega3&lt;/code&gt; . Еще более удобно, что нет необходимости использовать адресные пространства, такие как &lt;code&gt;__flash&lt;/code&gt; , или такие функции, как attribute &lt;code&gt;progmem&lt;/code&gt; и &lt;code&gt;pgm_read_*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12cca45385c65440f1fac5331dbdc800f8010a0a" translate="yes" xml:space="preserve">
          <source>Some features that are in ISO C99 but not C90 or C++ are also, as extensions, accepted by GCC in C90 mode and in C++.</source>
          <target state="translated">Некоторые функции,которые есть в ISO C99,но не в C90 или C++,также,в качестве расширений,принимаются GCC в режиме C90 и в C++.</target>
        </trans-unit>
        <trans-unit id="768fab3712868916420b11c9d81a46a5d1e9bab0" translate="yes" xml:space="preserve">
          <source>Some file formats do not support arbitrary sections so the &lt;code&gt;section&lt;/code&gt; attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</source>
          <target state="translated">Некоторые форматы файлов не поддерживают произвольные разделы, поэтому атрибут &lt;code&gt;section&lt;/code&gt; доступен не на всех платформах. Если вам нужно сопоставить все содержимое модуля с конкретным разделом, рассмотрите возможность использования средств компоновщика.</target>
        </trans-unit>
        <trans-unit id="63737560dbee375bb4595f35dcce3b604d447957" translate="yes" xml:space="preserve">
          <source>Some function attributes take one or more arguments that refer to the function&amp;rsquo;s parameters by their positions within the function parameter list. Such attribute arguments are referred to as &lt;em&gt;positional arguments&lt;/em&gt;. Unless specified otherwise, positional arguments that specify properties of parameters with pointer types can also specify the same properties of the implicit C++ &lt;code&gt;this&lt;/code&gt; argument in non-static member functions, and of parameters of reference to a pointer type. For ordinary functions, position one refers to the first parameter on the list. In C++ non-static member functions, position one refers to the implicit &lt;code&gt;this&lt;/code&gt; pointer. The same restrictions and effects apply to function attributes used with ordinary functions or C++ member functions.</source>
          <target state="translated">Некоторые атрибуты функции принимают один или несколько аргументов, которые ссылаются на параметры функции по их позициям в списке параметров функции. Такие аргументы атрибута называются &lt;em&gt;позиционными аргументами&lt;/em&gt; . Если не указано иное, позиционные аргументы, которые определяют свойства параметров с типами указателей, также могут указывать те же свойства неявного аргумента C ++ &lt;code&gt;this&lt;/code&gt; в нестатических функциях-членах и параметров ссылки на тип указателя. Для обычных функций первая позиция относится к первому параметру в списке. В нестатических функциях-членах C ++ первая позиция относится к неявному указателю &lt;code&gt;this&lt;/code&gt; . Те же ограничения и эффекты применяются к атрибутам функций, используемым с обычными функциями или функциями-членами C ++.</target>
        </trans-unit>
        <trans-unit id="fb33f99a987006c02f399310559443d2a427b3a7" translate="yes" xml:space="preserve">
          <source>Some lines of information at the start have &lt;var&gt;line_number&lt;/var&gt; of zero. These preamble lines are of the form</source>
          <target state="translated">Некоторые строки информации в начале имеют &lt;var&gt;line_number&lt;/var&gt; . Эти строки преамбулы имеют форму</target>
        </trans-unit>
        <trans-unit id="9e5021e481328ac057640ef2a536800d9166dbbe" translate="yes" xml:space="preserve">
          <source>Some linkers are capable of detecting out-of-range calls and generating glue code on the fly. On these systems, long calls are unnecessary and generate slower code. As of this writing, the AIX linker can do this, as can the GNU linker for PowerPC/64. It is planned to add this feature to the GNU linker for 32-bit PowerPC systems as well.</source>
          <target state="translated">Некоторые компоновщики способны обнаруживать внедиапазонные звонки и генерировать клеевой код на лету.На таких системах длинные вызовы не нужны и генерируют более медленный код.На момент написания этой статьи линкер AIX может сделать это,как и линкер GNU для PowerPC/64.Планируется добавить эту возможность и в линкер GNU для 32-битных систем PowerPC.</target>
        </trans-unit>
        <trans-unit id="e7ded2d98e8ad6e738cfb416e0e144f7c6488a8f" translate="yes" xml:space="preserve">
          <source>Some machines never actually require alignment; they allow references to any data type even at an odd address. For these machines, &lt;code&gt;__alignof__&lt;/code&gt; reports the smallest alignment that GCC gives the data type, usually as mandated by the target ABI.</source>
          <target state="translated">Некоторые машины фактически никогда не требуют юстировки; они позволяют ссылаться на любой тип данных даже по нечетному адресу. Для этих машин &lt;code&gt;__alignof__&lt;/code&gt; сообщает о наименьшем выравнивании, которое GCC дает типу данных, обычно в соответствии с требованиями целевого ABI.</target>
        </trans-unit>
        <trans-unit id="e609cdc1429a6fcb8d2a4566b95c795a179f9f38" translate="yes" xml:space="preserve">
          <source>Some more examples of the use of &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">Еще несколько примеров использования &lt;code&gt;typeof&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="97a9b6bbb4ff568061400bba291a0fa95f27baca" translate="yes" xml:space="preserve">
          <source>Some object formats, like ELF, allow interposing of symbols by the dynamic linker. This means that for symbols exported from the DSO, the compiler cannot perform interprocedural propagation, inlining and other optimizations in anticipation that the function or variable in question may change. While this feature is useful, for example, to rewrite memory allocation functions by a debugging implementation, it is expensive in the terms of code quality. With</source>
          <target state="translated">Некоторые форматы объектов,такие как ELF,позволяют динамический компоновщик связывать символы.Это означает,что для символов,экспортируемых из DSO,компилятор не может выполнять межпроцедурное распространение,встраивание и другие оптимизации в ожидании,что данная функция или переменная может измениться.Хотя эта возможность полезна,например,для перезаписи функций выделения памяти отладочной реализацией,она дорого стоит с точки зрения качества кода.С .</target>
        </trans-unit>
        <trans-unit id="53b2cdebe3092f05376eba4dc6edb1163b208474" translate="yes" xml:space="preserve">
          <source>Some of these problems are due to bugs in other software, some are missing features that are too much work to add, and some are places where people&amp;rsquo;s opinions differ as to what is best.</source>
          <target state="translated">Некоторые из этих проблем связаны с ошибками в другом программном обеспечении, в некоторых отсутствуют функции, для добавления которых требуется слишком много работы, а в некоторых люди расходятся во мнениях относительно того, что лучше.</target>
        </trans-unit>
        <trans-unit id="e5a8bcdbd9732dbb47db6e251241faa598f69eaa" translate="yes" xml:space="preserve">
          <source>Some operands need to be in particular places on the stack. All output operands fall in this category&amp;mdash;GCC has no other way to know which registers the outputs appear in unless you indicate this in the constraints.</source>
          <target state="translated">Некоторые операнды должны находиться в определенных местах в стеке. Все выходные операнды попадают в эту категорию - GCC не имеет другого способа узнать, в каких регистрах появляются выходные данные, если вы не укажете это в ограничениях.</target>
        </trans-unit>
        <trans-unit id="7bc3611475871be65cea3ae1eb8a4118c1e3da02" translate="yes" xml:space="preserve">
          <source>Some options for compiling C programs, such as</source>
          <target state="translated">Некоторые варианты компиляции программ на C,такие как</target>
        </trans-unit>
        <trans-unit id="9aab2dd921eb504a0a6bf04d60fa17f07ef07e59" translate="yes" xml:space="preserve">
          <source>Some options take one or more arguments typically separated either by a space or by the equals sign (&amp;lsquo;</source>
          <target state="translated">Некоторые параметры принимают один или несколько аргументов, обычно разделенных либо пробелом, либо знаком равенства ('</target>
        </trans-unit>
        <trans-unit id="b09c01fb6d97b0be636c36b27746781fe632f575" translate="yes" xml:space="preserve">
          <source>Some options, such as</source>
          <target state="translated">Некоторые варианты,такие как</target>
        </trans-unit>
        <trans-unit id="8b764d6df82f9df721fda3ecd882ae472b0abef6" translate="yes" xml:space="preserve">
          <source>Some other command-line options starting with</source>
          <target state="translated">Некоторые другие опции командной строки,начиная с</target>
        </trans-unit>
        <trans-unit id="2b1de7c862240cc77fd4597210b6bd463edb0754" translate="yes" xml:space="preserve">
          <source>Some spurious warnings can be avoided if you declare all the functions you use that never return as &lt;code&gt;noreturn&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">Некоторых ложных предупреждений можно избежать, если объявить все используемые вами функции, которые никогда не возвращаются как &lt;code&gt;noreturn&lt;/code&gt; . См. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b7a7ebb3620b1d731c5783bb7dadf2877e0be61" translate="yes" xml:space="preserve">
          <source>Some targets have a special register that holds the &amp;ldquo;flags&amp;rdquo; for the result of an operation or comparison. Normally, the contents of that register are either unmodifed by the asm, or the &lt;code&gt;asm&lt;/code&gt; statement is considered to clobber the contents.</source>
          <target state="translated">Некоторые цели имеют специальный регистр, в котором хранятся &amp;laquo;флаги&amp;raquo; для результата операции или сравнения. Обычно содержимое этого регистра либо не изменяется с помощью asm, либо считается , что оператор &lt;code&gt;asm&lt;/code&gt; затирает содержимое.</target>
        </trans-unit>
        <trans-unit id="ece7407fc707518ca6db13a249080d20314edfb1" translate="yes" xml:space="preserve">
          <source>Some targets require that GCC track the size of each instruction used in order to generate correct code. Because the final length of the code produced by an &lt;code&gt;asm&lt;/code&gt; statement is only known by the assembler, GCC must make an estimate as to how big it will be. It does this by counting the number of instructions in the pattern of the &lt;code&gt;asm&lt;/code&gt; and multiplying that by the length of the longest instruction supported by that processor. (When working out the number of instructions, it assumes that any occurrence of a newline or of whatever statement separator character is supported by the assembler &amp;mdash; typically &amp;lsquo;</source>
          <target state="translated">Некоторые цели требуют, чтобы GCC отслеживал размер каждой инструкции, используемой для генерации правильного кода. Поскольку окончательная длина кода, созданного оператором &lt;code&gt;asm&lt;/code&gt; , известна только ассемблеру, GCC должен оценить, насколько он будет большим. Для этого он подсчитывает количество инструкций в шаблоне &lt;code&gt;asm&lt;/code&gt; и умножает его на длину самой длинной инструкции, поддерживаемой этим процессором. (При вычислении количества инструкций предполагается, что любое вхождение символа новой строки или любого символа разделителя операторов поддерживается ассемблером - обычно '</target>
        </trans-unit>
        <trans-unit id="d9a576a0cb85284fa181b1af5cb015b4bd820399" translate="yes" xml:space="preserve">
          <source>Some targets, e.g. x86 and PowerPC, support the &lt;code&gt;#pragma ms_struct&lt;/code&gt; directive which lays out structures and unions subsequently defined as the documented &lt;code&gt;__attribute__ ((ms_struct))&lt;/code&gt;.</source>
          <target state="translated">Некоторые цели, например x86 и PowerPC, поддерживают директиву &lt;code&gt;#pragma ms_struct&lt;/code&gt; , которая определяет структуры и объединения, впоследствии определенные как задокументированный &lt;code&gt;__attribute__ ((ms_struct))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32c528c0b130160ed58ee14f8bbba2d7a132054b" translate="yes" xml:space="preserve">
          <source>Some users try to use</source>
          <target state="translated">Некоторые пользователи пытаются использовать</target>
        </trans-unit>
        <trans-unit id="c714f3fa36461f2e5681ce26cd399297f4a56453" translate="yes" xml:space="preserve">
          <source>Some users try to use &lt;code&gt;__STDC__&lt;/code&gt; to check for the availability of certain library facilities. This is actually incorrect usage in an ISO C program, because the ISO C standard says that a conforming freestanding implementation should define &lt;code&gt;__STDC__&lt;/code&gt; even though it does not have the library facilities. &amp;lsquo;</source>
          <target state="translated">Некоторые пользователи пытаются использовать &lt;code&gt;__STDC__&lt;/code&gt; для проверки доступности определенных библиотечных средств. На самом деле это неправильное использование в программе ISO C, потому что стандарт ISO C говорит, что соответствующая автономная реализация должна определять &lt;code&gt;__STDC__&lt;/code&gt; , даже если у нее нет средств библиотеки. '</target>
        </trans-unit>
        <trans-unit id="6c0811681aff3d220c177a6ae42df51a4668d70d" translate="yes" xml:space="preserve">
          <source>Sometimes a single instruction has multiple alternative sets of possible operands. For example, on the 68000, a logical-or instruction can combine register or an immediate value into memory, or it can combine any kind of operand into a register; but it cannot combine one memory location into another.</source>
          <target state="translated">Иногда одна инструкция имеет несколько альтернативных наборов возможных операндов.Например,в команде 68000 логика или инструкция может комбинировать регистр или непосредственное значение в память,или она может комбинировать любой вид операнда в регистр;но она не может комбинировать одну область памяти в другую.</target>
        </trans-unit>
        <trans-unit id="bcdf40850f5e7d0e40bbaa8bc961e1b76a034440" translate="yes" xml:space="preserve">
          <source>Sometimes it is desirable to write code using a mix of generic vector operations (for clarity) and machine-specific vector intrinsics (to access vector instructions that are not exposed via generic built-ins). On x86, intrinsic functions for integer vectors typically use the same vector type &lt;code&gt;__m128i&lt;/code&gt; irrespective of how they interpret the vector, making it necessary to cast their arguments and return values from/to other vector types. In C, you can make use of a &lt;code&gt;union&lt;/code&gt; type:</source>
          <target state="translated">Иногда желательно написать код, используя сочетание общих векторных операций (для ясности) и машинно-зависимых векторных встроенных функций (для доступа к векторным инструкциям, которые не отображаются через общие встроенные модули). В x86 встроенные функции для целочисленных векторов обычно используют один и тот же векторный тип &lt;code&gt;__m128i&lt;/code&gt; независимо от того, как они интерпретируют вектор, что делает необходимым приводить свои аргументы и возвращать значения из / в другие векторные типы. В C вы можете использовать тип &lt;code&gt;union&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e7b9f7e78924f4429d79b3875d59ae1541b656fb" translate="yes" xml:space="preserve">
          <source>Sometimes people say that defining &lt;code&gt;__STDC__&lt;/code&gt; in a compiler that does not completely conform to the ISO C standard somehow violates the standard. This is illogical. The standard is a standard for compilers that claim to support ISO C, such as &amp;lsquo;</source>
          <target state="translated">Иногда люди говорят, что определение &lt;code&gt;__STDC__&lt;/code&gt; в компиляторе, который не полностью соответствует стандарту ISO C, каким-то образом нарушает стандарт. Это нелогично. Стандарт - это стандарт для компиляторов, которые заявляют о поддержке ISO C, например '</target>
        </trans-unit>
        <trans-unit id="c41073d5b9e69b8696bff1b0838e6f995522031e" translate="yes" xml:space="preserve">
          <source>Sort the symbols according to size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f71bf34c2cf4ef01fa642de620de6d3ffbf6ba33" translate="yes" xml:space="preserve">
          <source>Sort the symbols alphabetically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8110c50df0a3ae32bff485105c38a69468d7fdd2" translate="yes" xml:space="preserve">
          <source>Special constraints for some particular machines.</source>
          <target state="translated">Особые ограничения для некоторых конкретных машин.</target>
        </trans-unit>
        <trans-unit id="2ba4930cab85f2e9501af3573b08b92708f7a0ae" translate="yes" xml:space="preserve">
          <source>Special format strings</source>
          <target state="translated">Специальные строки формата</target>
        </trans-unit>
        <trans-unit id="2a9d5504a562859df5546c189640d36f2ebdc1bd" translate="yes" xml:space="preserve">
          <source>Special syntax for implementing &lt;code&gt;offsetof&lt;/code&gt;.</source>
          <target state="translated">Специальный синтаксис для реализации &lt;code&gt;offsetof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="253477bfce70caeee68c5d46f4cbdd5958d04b09" translate="yes" xml:space="preserve">
          <source>Specifier</source>
          <target state="translated">Specifier</target>
        </trans-unit>
        <trans-unit id="fae65de83d82c109b91ff281d719a67482b13328" translate="yes" xml:space="preserve">
          <source>Specifies a C lvalue expression to hold the output, typically a variable name. The enclosing parentheses are a required part of the syntax.</source>
          <target state="translated">Указание выражения значения C lue для удержания вывода,обычно это имя переменной.Прилагаемые скобки являются необходимой частью синтаксиса.</target>
        </trans-unit>
        <trans-unit id="05513a361baed0fc6bc2b4e7e1181bfda41a5c6c" translate="yes" xml:space="preserve">
          <source>Specifies a symbolic name for the operand. Reference the name in the assembler template by enclosing it in square brackets (i.e. &amp;lsquo;</source>
          <target state="translated">Задает символическое имя для операнда. Укажите имя в шаблоне ассемблера, заключив его в квадратные скобки (т.е.</target>
        </trans-unit>
        <trans-unit id="c765ec9a6362d918fb2bf1565e87927ec8cd6358" translate="yes" xml:space="preserve">
          <source>Specifies general-purposes registers that the processor automatically saves/restores on interrupt entry and exit. &lt;var&gt;register-range&lt;/var&gt; is specified as two registers separated by a dash. The register range always starts with &lt;code&gt;r0&lt;/code&gt;, the upper limit is &lt;code&gt;fp&lt;/code&gt; register. &lt;var&gt;blink&lt;/var&gt; and &lt;var&gt;lp_count&lt;/var&gt; are optional. This option is only valid for ARC EM and ARC HS cores.</source>
          <target state="translated">Задает регистры общего назначения, которые процессор автоматически сохраняет / восстанавливает при входе и выходе из прерывания. &lt;var&gt;register-range&lt;/var&gt; определяется как два регистра, разделенных тире. Диапазон регистров всегда начинается с &lt;code&gt;r0&lt;/code&gt; , верхний предел - регистр &lt;code&gt;fp&lt;/code&gt; . &lt;var&gt;blink&lt;/var&gt; и &lt;var&gt;lp_count&lt;/var&gt; не являются обязательными. Эта опция действительна только для ядер ARC EM и ARC HS.</target>
        </trans-unit>
        <trans-unit id="f3854791e88bad573a0be4f46ed869cefa1b475c" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large function caused by inlining in percents. For example, parameter value 100 limits large function growth to 2.0 times the original size.</source>
          <target state="translated">Определяет максимальный рост большой функции,вызванный вливанием в процентах.Например,значение параметра 100 ограничивает рост большой функции в 2,0 раза по сравнению с исходным размером.</target>
        </trans-unit>
        <trans-unit id="dfe06371f415167055f13157f6cd31af5c5dbd88" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large stack frames caused by inlining in percents. For example, parameter value 1000 limits large stack frame growth to 11 times the original size.</source>
          <target state="translated">Определяет максимальный рост крупногабаритных штабельных рам за счет встраивания в процентах.Например,значение параметра 1000 ограничивает рост больших стековых кадров до 11 раз по сравнению с исходным размером.</target>
        </trans-unit>
        <trans-unit id="94731e3c8ea6ab127a428ca6dbbe480337db1263" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by inlining. For example, parameter value 20 limits unit growth to 1.2 times the original size. Cold functions (either marked cold via an attribute or by profile feedback) are not accounted into the unit size.</source>
          <target state="translated">Определяет максимальный общий рост агрегата компоновки,вызванный вкраплением.Например,значение параметра 20 ограничивает рост единицы в 1,2 раза по сравнению с исходным размером.Функции охлаждения (либо обозначенные холодным через атрибут,либо через обратную связь по профилю)не учитываются в типоразмере агрегата.</target>
        </trans-unit>
        <trans-unit id="f6a6169df4d1b9f4ae3a854ae149c4bc3eb831c7" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by interprocedural constant propagation. For example, parameter value 10 limits unit growth to 1.1 times the original size.</source>
          <target state="translated">Определяет максимальный общий рост единицы компиляции,вызванный межпроцедурным постоянным распространением.Например,значение параметра 10 ограничивает рост единицы в 1.1 раза больше исходного размера.</target>
        </trans-unit>
        <trans-unit id="c09858fd018d531b5e4ff4ecd665a6f14de1bdc3" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the MDUC registers. This is only necessary if normal code might use the MDUC registers, for example because it performs multiplication and division operations. The default is to ignore the MDUC registers as this makes the interrupt handlers faster. The target option -mg13 needs to be passed for this to work as this feature is only available on the G13 target (S2 core). The MDUC registers will only be saved if the interrupt handler performs a multiplication or division operation or it calls another function.</source>
          <target state="translated">Указывает,что функции обработчика прерываний должны сохранять MDUC-регистры.Это необходимо только в том случае,если обычный код может использовать MDUC регистры,например,потому,что он выполняет операции умножения и деления.По умолчанию MDUC регистры игнорируются,так как это делает обработчики прерываний более быстрыми.Целевая опция -mg13 должна быть передана,чтобы это работало,так как эта возможность доступна только на цели G13 (ядро S2).Регистры MDUC будут сохранены только в том случае,если обработчик прерывания выполняет операцию умножения или деления или вызывает другую функцию.</target>
        </trans-unit>
        <trans-unit id="e16a3667d78dbf88b960c5650973c17d00b701b4" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the accumulator register. This is only necessary if normal code might use the accumulator register, for example because it performs 64-bit multiplications. The default is to ignore the accumulator as this makes the interrupt handlers faster.</source>
          <target state="translated">Указывает,что функции обработчика прерываний должны сохранять регистр аккумулятора.Это необходимо только в том случае,если обычный код может использовать регистр аккумулятора,например,потому что он выполняет 64-битные умножения.По умолчанию игнорируется аккумулятор,так как это делает обработчики прерываний более быстрыми.</target>
        </trans-unit>
        <trans-unit id="b7effad23ab12e24339284e6f0eafe7d16434faa" translate="yes" xml:space="preserve">
          <source>Specifies that the PRU CTABLE entry given by &lt;var&gt;index&lt;/var&gt; has the value &lt;var&gt;constant_address&lt;/var&gt;. This enables GCC to emit LBCO/SBCO instructions when the load/store address is known and can be addressed with some CTABLE entry. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd671f6f6086870972e15aa7905ec8f7db267ac7" translate="yes" xml:space="preserve">
          <source>Specifies that the cache cannot be flushed by using a trap.</source>
          <target state="translated">Указывает,что кэш не может быть очищен с помощью ловушки.</target>
        </trans-unit>
        <trans-unit id="47947b45b4744585e55d8f763014a0ae39516e00" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime library to be linked in which supports, for example, file I/O. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="translated">Указывает,что программа будет запущена на симуляторе.Это приводит к компоновке альтернативной библиотеки времени выполнения,в которой поддерживается,например,файловый ввод/вывод.Вы не должны использовать эту опцию при генерации программ,которые будут выполняться на реальном оборудовании;вы должны предоставить свою собственную библиотеку времени выполнения для любых функций ввода/вывода,которые необходимы.</target>
        </trans-unit>
        <trans-unit id="92a7b7c9a6c346e8818d5fec33b1b2c04de8591c" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime startup and library to be linked. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="translated">Указывает,что программа будет запущена на симуляторе.Это приводит к компоновке альтернативного запуска и библиотеки.Вы не должны использовать эту опцию при генерации программ,которые будут выполняться на реальном оборудовании;вы должны предоставить свою собственную библиотеку времени выполнения для любых функций ввода/вывода,которые необходимы.</target>
        </trans-unit>
        <trans-unit id="cc31c50b75b75e6cf86f872d21ade4b77825de9f" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes the simulator BSP provided by libgloss to be linked in. This option has effect only for &amp;lsquo;</source>
          <target state="translated">Указывает, что программа будет запускаться на симуляторе. Это приводит к подключению симулятора BSP, предоставленного libgloss. Этот параметр действует только для '</target>
        </trans-unit>
        <trans-unit id="4b908ebdba88cf2c2a293fda93618017153fd58b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">Задает тип ABI, который будет использоваться для векторизации встроенных функций с использованием внешней библиотеки. Поддерживаемые значения для &lt;var&gt;type&lt;/var&gt; : '</target>
        </trans-unit>
        <trans-unit id="df8e8fddb7d07761c1b84aad23b4814d921c564b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. The only type supported at present is &amp;lsquo;</source>
          <target state="translated">Задает тип ABI, который будет использоваться для векторизации встроенных функций с использованием внешней библиотеки. В настоящее время поддерживается только тип '</target>
        </trans-unit>
        <trans-unit id="3e1277fdc0689b726ff15cccd084ddbac36979fe" translate="yes" xml:space="preserve">
          <source>Specifies the ISA to use. Accepted values are &amp;lsquo;</source>
          <target state="translated">Задает используемый ISA. Допустимые значения: '</target>
        </trans-unit>
        <trans-unit id="5ca955df8b960b04d79d7dd74115e500bda85663" translate="yes" xml:space="preserve">
          <source>Specifies the RL78 core to target. The default is the G14 core, also known as an S3 core or just RL78. The G13 or S2 core does not have multiply or divide instructions, instead it uses a hardware peripheral for these operations. The G10 or S1 core does not have register banks, so it uses a different calling convention.</source>
          <target state="translated">Указание ядра RL78 на цель.По умолчанию используется ядро G14,также известное как ядро S3 или просто RL78.Ядро G13 или S2 не имеет инструкций по умножению или разделению,вместо этого оно использует аппаратную периферию для этих операций.Ядро G10 или S1 не имеет банков регистрации,поэтому оно использует другое соглашение по вызову.</target>
        </trans-unit>
        <trans-unit id="f635669de18bf56a687958d1a8c71186afb495b2" translate="yes" xml:space="preserve">
          <source>Specifies the TLS dialect to use for this function. The behavior and permissible arguments are the same as for the command-line option</source>
          <target state="translated">Указание диалекта TLS,который будет использоваться для этой функции.Поведение и допустимые аргументы такие же,как и для опции командной строки</target>
        </trans-unit>
        <trans-unit id="c52b2c30fecaf2eb67f980f2baf7835c6acbf2e9" translate="yes" xml:space="preserve">
          <source>Specifies the architecture version and architectural extensions to use for this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">Указание версии архитектуры и архитектурных расширений,которые будут использоваться для этой функции.Поведение и допустимые аргументы такие же,как и для функции</target>
        </trans-unit>
        <trans-unit id="dbbb7ebc147f28ae0dcd4250f31f3d8fd9cac55e" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function and also whose architectural features to use. The behavior and valid arguments are the same as for the</source>
          <target state="translated">Определяет ядро,для которого следует настроить выполнение этой функции,а также архитектурные особенности,которые следует использовать.Поведение и допустимые аргументы такие же,как и для функции</target>
        </trans-unit>
        <trans-unit id="fe58a5c95595be8f2a1ff92d9451c73415b5a99d" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">Определяет ядро,для которого следует настроить выполнение этой функции.Поведение и допустимые аргументы такие же,как и для функции</target>
        </trans-unit>
        <trans-unit id="28873c2fbf7d823a74544bebc8a6344119496c82" translate="yes" xml:space="preserve">
          <source>Specifies the fpu for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">Определяет,для какого fpu настраивать выполнение этой функции.Поведение и допустимые аргументы такие же,как и для функции</target>
        </trans-unit>
        <trans-unit id="cce88289fcb8b24761c893dbf247fdd528b95133" translate="yes" xml:space="preserve">
          <source>Specifies the function to call to flush the I and D caches, or to not call any such function. If called, the function must take the same arguments as the common &lt;code&gt;_flush_func&lt;/code&gt;, that is, the address of the memory range for which the cache is being flushed, the size of the memory range, and the number 3 (to flush both caches). The default depends on the target GCC was configured for, but commonly is either &lt;code&gt;_flush_func&lt;/code&gt; or &lt;code&gt;__cpu_flush&lt;/code&gt;.</source>
          <target state="translated">Задает функцию, вызываемую для очистки кешей I и D или для отказа от вызова любой такой функции. При вызове функция должна принимать те же аргументы, что и обычный &lt;code&gt;_flush_func&lt;/code&gt; , то есть адрес диапазона памяти, для которого очищается кеш, размер диапазона памяти и число 3 (для очистки обоих кешей). Значение по умолчанию зависит от того, для чего был настроен целевой GCC, но обычно это либо &lt;code&gt;_flush_func&lt;/code&gt; , либо &lt;code&gt;__cpu_flush&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7671feaad590d7ec398f51bb4af652d4dc88ce38" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library but is no more space- or time-efficient than omitting this option.</source>
          <target state="translated">Указание идентификационного номера компилируемой общей библиотеки,основанной на ID.Указание значения 0 генерирует более компактный код;указание других значений заставляет выделить это число для текущей библиотеки,но не более эффективно с точки зрения пробела или времени,чем пропустить эту опцию.</target>
        </trans-unit>
        <trans-unit id="99738458ed498047e95197f3c00800b279d2d584" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library, but is no more space- or time-efficient than omitting this option.</source>
          <target state="translated">Указание идентификационного номера компилируемой общей библиотеки,основанной на ID.Указание значения 0 генерирует более компактный код;указание других значений заставляет выделить это число для текущей библиотеки,но не более эффективно с точки зрения пробела или времени,чем пропустить эту опцию.</target>
        </trans-unit>
        <trans-unit id="c1e382c74800682d2e9f3b74a1844826dd2ecb62" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of instructions an out-of-line copy of a self-recursive inline function can grow into by performing recursive inlining.</source>
          <target state="translated">Определяет максимальное количество инструкций,в которое может вырасти внестрочная копия саморекурсивной встроенной функции путем выполнения рекурсивных вставок.</target>
        </trans-unit>
        <trans-unit id="a5e540e476e706af7ae2a630f97b45afd6de5bb3" translate="yes" xml:space="preserve">
          <source>Specifies the maximum recursion depth used for recursive inlining.</source>
          <target state="translated">Определяет максимальную глубину рекурсии,используемую для рекурсивной встраивания.</target>
        </trans-unit>
        <trans-unit id="842831f7e4e5d29f3e7d0beec2854a0216bc6e42" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size in bytes of global and static variables which can be placed into the small data area. Using the small data area can lead to smaller and faster code, but the size of area is limited and it is up to the programmer to ensure that the area does not overflow. Also when the small data area is used one of the RX&amp;rsquo;s registers (usually &lt;code&gt;r13&lt;/code&gt;) is reserved for use pointing to this area, so it is no longer available for use by the compiler. This could result in slower and/or larger code if variables are pushed onto the stack instead of being held in this register.</source>
          <target state="translated">Задает максимальный размер в байтах глобальных и статических переменных, которые могут быть помещены в небольшую область данных. Использование небольшой области данных может привести к меньшему и более быстрому коду, но размер области ограничен, и программист должен гарантировать, что область не переполнится. Также, когда используется небольшая область данных, один из регистров RX (обычно &lt;code&gt;r13&lt;/code&gt; ) зарезервирован для использования, указывающего на эту область, поэтому он больше не доступен для использования компилятором. Это может привести к более медленному и / или большему коду, если переменные помещаются в стек, а не хранятся в этом регистре.</target>
        </trans-unit>
        <trans-unit id="7412a6cb9b0e0f8b6e7f0d0e77fd2140ccfb86a1" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size, in bytes, of a constant that can be used as an operand in a RX instruction. Although the RX instruction set does allow constants of up to 4 bytes in length to be used in instructions, a longer value equates to a longer instruction. Thus in some circumstances it can be beneficial to restrict the size of constants that are used in instructions. Constants that are too big are instead placed into a constant pool and referenced via register indirection.</source>
          <target state="translated">Указывает максимальный размер в байтах константы,которая может быть использована в качестве операнда в команде RX.Хотя набор команд RX позволяет использовать в командах константы длиной до 4 байт,более длинное значение равно более длинной команде.Таким образом,в некоторых обстоятельствах может быть полезно ограничить размер констант,используемых в инструкциях.Слишком большие константы помещаются в пул констант и на них ссылаются по идирекции регистра.</target>
        </trans-unit>
        <trans-unit id="f498cab10962b0798c0931ba2f63475387ade694" translate="yes" xml:space="preserve">
          <source>Specifies the name of the operating system function to call to flush the cache. The default is &amp;lsquo;</source>
          <target state="translated">Задает имя функции операционной системы, которую нужно вызвать для очистки кеша. По умолчанию '</target>
        </trans-unit>
        <trans-unit id="4cb9f9dd93932f78051a635c26202d7d8e5535cd" translate="yes" xml:space="preserve">
          <source>Specifies the name of the target Blackfin processor. Currently, &lt;var&gt;cpu&lt;/var&gt; can be one of &amp;lsquo;</source>
          <target state="translated">Задает имя целевого процессора Blackfin. В настоящее время &lt;var&gt;cpu&lt;/var&gt; может быть одним из '</target>
        </trans-unit>
        <trans-unit id="c0803aab785a2e20aedd243e17212d6d9ce8548e" translate="yes" xml:space="preserve">
          <source>Specifies the number of memory-based pseudo-registers GCC uses during code generation. These pseudo-registers are used like real registers, so there is a tradeoff between GCC&amp;rsquo;s ability to fit the code into available registers, and the performance penalty of using memory instead of registers. Note that all modules in a program must be compiled with the same value for this option. Because of that, you must not use this option with GCC&amp;rsquo;s default runtime libraries.</source>
          <target state="translated">Задает количество псевдорегистров в памяти, используемых GCC во время генерации кода. Эти псевдорегистры используются как настоящие регистры, поэтому существует компромисс между способностью GCC уместить код в доступные регистры и снижением производительности за счет использования памяти вместо регистров. Обратите внимание, что все модули в программе должны быть скомпилированы с одинаковым значением для этой опции. По этой причине вы не должны использовать эту опцию с библиотеками времени выполнения GCC по умолчанию.</target>
        </trans-unit>
        <trans-unit id="22f3ed905850cb42bd6d50bb52af7907bc7a581e" translate="yes" xml:space="preserve">
          <source>Specifies the number of registers replicated in second register bank on entry to fast interrupt. Fast interrupts are interrupts with the highest priority level P0. These interrupts save only PC and STATUS32 registers to avoid memory transactions during interrupt entry and exit sequences. Use this option when you are using fast interrupts in an ARC V2 family processor. Permitted values are 4, 8, 16, and 32.</source>
          <target state="translated">Указывает количество регистров,реплицированных во втором банке регистров при записи на быстрое прерывание.Быстрые прерывания-это прерывания с наивысшим уровнем приоритета P0.Эти прерывания сохраняют только регистры ПК и STATUS32,чтобы избежать операций с памятью во время последовательностей входа и выхода из прерывания.Используйте эту опцию при использовании быстрых прерываний в процессорах семейства ARC V2.Допустимые значения:4,8,16 и 32.</target>
        </trans-unit>
        <trans-unit id="affdb413ade6c559688aa8325514465c16425b76" translate="yes" xml:space="preserve">
          <source>Specifies the trap number to use to flush the cache. The default is 12. Valid numbers are between 0 and 15 inclusive.</source>
          <target state="translated">Указание номера ловушки,которая будет использоваться для промывки кэша.По умолчанию 12.Допустимые номера-от 0 до 15 включительно.</target>
        </trans-unit>
        <trans-unit id="c90e51847549c6d7bfb26f9d83f651beb9507ea1" translate="yes" xml:space="preserve">
          <source>Specifies the type of hardware multiplication and division support to be used. The simplest is &lt;code&gt;none&lt;/code&gt;, which uses software for both multiplication and division. This is the default. The &lt;code&gt;g13&lt;/code&gt; value is for the hardware multiply/divide peripheral found on the RL78/G13 (S2 core) targets. The &lt;code&gt;g14&lt;/code&gt; value selects the use of the multiplication and division instructions supported by the RL78/G14 (S3 core) parts. The value &lt;code&gt;rl78&lt;/code&gt; is an alias for &lt;code&gt;g14&lt;/code&gt; and the value &lt;code&gt;mg10&lt;/code&gt; is an alias for &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">Указывает тип используемой аппаратной поддержки умножения и деления. Самым простым является &lt;code&gt;none&lt;/code&gt; , в котором используются программы как для умножения, так и для деления. Это значение по умолчанию. Значение &lt;code&gt;g13&lt;/code&gt; предназначено для аппаратного периферийного устройства умножения / деления на целевых объектах RL78 / G13 (ядро S2). Значение &lt;code&gt;g14&lt;/code&gt; выбирает использование команд умножения и деления, поддерживаемых частями RL78 / G14 (ядро S3). Значение &lt;code&gt;rl78&lt;/code&gt; является псевдонимом для &lt;code&gt;g14&lt;/code&gt; , а значение &lt;code&gt;mg10&lt;/code&gt; - псевдонимом для &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f81d16d95cc0305e73b474da06956f8e11e96d3" translate="yes" xml:space="preserve">
          <source>Specifies whether FP exceptions are enabled. This affects how FP instructions are scheduled for some processors. The default is that FP exceptions are enabled.</source>
          <target state="translated">Указывает,включены ли исключения FP.Это влияет на то,как запланированы инструкции FP для некоторых процессоров.По умолчанию включено исключение FP.</target>
        </trans-unit>
        <trans-unit id="72b43446cb2dd4e94fe26ad69b18b9bf05535ef3" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are available to the register allocator. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">Определяет, какие регистры сопроцессора доступны распределителю регистров. &lt;var&gt;registers&lt;/var&gt; могут быть одним регистром, диапазоном регистров, разделенным многоточием, или их списком, разделенным запятыми. Пример:</target>
        </trans-unit>
        <trans-unit id="0598db288f6f533223b56d068b56fd87125317c1" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are to be saved and restored by any function using them. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">Определяет, какие регистры сопроцессора должны быть сохранены и восстановлены любой функцией, использующей их. &lt;var&gt;registers&lt;/var&gt; могут быть одним регистром, диапазоном регистров, разделенным многоточием, или их списком, разделенным запятыми. Пример:</target>
        </trans-unit>
        <trans-unit id="c1b3620228a9a55d3a61b6172646e0fda8c7d9e2" translate="yes" xml:space="preserve">
          <source>Specifies which floating-point ABI to use. Permissible values are: &amp;lsquo;</source>
          <target state="translated">Указывает, какой ABI с плавающей запятой использовать. Допустимые значения: '</target>
        </trans-unit>
        <trans-unit id="a477d8dab7ef5cc90c58a41d06ca3494aeba078f" translate="yes" xml:space="preserve">
          <source>Specify</source>
          <target state="translated">Specify</target>
        </trans-unit>
        <trans-unit id="b7d7c4da380841e46021fb0ca037b1a5efba92c6" translate="yes" xml:space="preserve">
          <source>Specify &lt;var&gt;prefix&lt;/var&gt; as the prefix for subsequent</source>
          <target state="translated">Укажите &lt;var&gt;prefix&lt;/var&gt; в качестве префикса для последующих</target>
        </trans-unit>
        <trans-unit id="a1b75d36373bf0a158266aad4b0685acf54bdd9f" translate="yes" xml:space="preserve">
          <source>Specify Atmel AVR instruction set architectures (ISA) or MCU type.</source>
          <target state="translated">Укажите архитектуру набора команд Atmel AVR (ISA)или тип микроконтроллера.</target>
        </trans-unit>
        <trans-unit id="d5ced711925ce2b86f2945855d11a9f765bdf3b8" translate="yes" xml:space="preserve">
          <source>Specify a register to hold the constant -1, which makes loading small negative constants and certain bitmasks faster. Allowable values for &lt;var&gt;reg&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">Укажите регистр для хранения константы -1, что ускоряет загрузку небольших отрицательных констант и определенных битовых масок. Допустимые значения для &lt;var&gt;reg&lt;/var&gt; : '</target>
        </trans-unit>
        <trans-unit id="ee4e72d685bf13ccdca2b955146686e94f4dd820" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 12, 24, 32, 48. This option requires binutils 2.26 or newer.</source>
          <target state="translated">Укажите размер битов немедленного смещения TLS.Действительные значения:12,24,32,48.Эта опция требует бинутилей 2.26 или более новых.</target>
        </trans-unit>
        <trans-unit id="0ee5fd4c06f208dc72a94346beb5b066cc520b6c" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 14, 22, and 64.</source>
          <target state="translated">Укажите размер битов немедленного смещения TLS.Действительные значения:14,22 и 64.</target>
        </trans-unit>
        <trans-unit id="e3d343f19f5a896581a51d8a250efd477d791df5" translate="yes" xml:space="preserve">
          <source>Specify both</source>
          <target state="translated">Укажите оба</target>
        </trans-unit>
        <trans-unit id="790583d2504db1e70b776b6337942849b2d5671c" translate="yes" xml:space="preserve">
          <source>Specify default compute dimensions for parallel offload regions that do not explicitly specify. The &lt;var&gt;geom&lt;/var&gt; value is a triple of &amp;rsquo;:&amp;rsquo;-separated sizes, in order &amp;rsquo;gang&amp;rsquo;, &amp;rsquo;worker&amp;rsquo; and, &amp;rsquo;vector&amp;rsquo;. A size can be omitted, to use a target-specific default value.</source>
          <target state="translated">Укажите размеры вычислений по умолчанию для параллельных областей разгрузки, которые не указываются явно. Значение &lt;var&gt;geom&lt;/var&gt; - это тройка разделенных ':' размеров в порядке &quot;группа&quot;, &quot;рабочий&quot; и &quot;вектор&quot;. Размер можно не указывать, чтобы использовать значение по умолчанию для конкретной цели.</target>
        </trans-unit>
        <trans-unit id="d0c09fd54e93619fc886af47d25ab910da3f1f1d" translate="yes" xml:space="preserve">
          <source>Specify desired number of partitions produced during WHOPR compilation. The number of partitions should exceed the number of CPUs used for compilation.</source>
          <target state="translated">Укажите желаемое количество разделов,произведенных во время компиляции WHOPR.Количество разделов должно превышать количество процессоров,используемых при компиляции.</target>
        </trans-unit>
        <trans-unit id="ddd74922c1fffe0660ee607e7c8c05e6b9c36231" translate="yes" xml:space="preserve">
          <source>Specify either the directory containing the gcov data files, or the object path name. The</source>
          <target state="translated">Укажите либо каталог,содержащий файлы данных gcov,либо имя пути к объекту..</target>
        </trans-unit>
        <trans-unit id="a8bb63ac54bf2ea3fd989f2a3dede75fee9c409d" translate="yes" xml:space="preserve">
          <source>Specify explicitly the &lt;var&gt;language&lt;/var&gt; for the following input files (rather than letting the compiler choose a default based on the file name suffix). This option applies to all following input files until the next</source>
          <target state="translated">Явно укажите &lt;var&gt;language&lt;/var&gt; для следующих входных файлов (вместо того, чтобы позволять компилятору выбирать язык по умолчанию на основе суффикса имени файла). Этот параметр применяется ко всем последующим входным файлам до следующего</target>
        </trans-unit>
        <trans-unit id="1dece3d1baf820f578333563e62b95b8ee062ffd" translate="yes" xml:space="preserve">
          <source>Specify growth that the early inliner can make. In effect it increases the amount of inlining for code having a large abstraction penalty.</source>
          <target state="translated">Укажите рост,который может произвести ранний лайнер.По сути,это увеличивает количество вкраплений для кода с большим штрафом за абстракцию.</target>
        </trans-unit>
        <trans-unit id="8b0123ff59c8271225f538f6c8fc4517d3e5946e" translate="yes" xml:space="preserve">
          <source>Specify how many &lt;var&gt;bytes&lt;/var&gt; of stack space will be requested for each GPU thread (wave-front). Beware that there may be many threads and limited memory available. The size of the stack allocation may also have an impact on run-time performance. The default is 32KB when using OpenACC or OpenMP, and 1MB otherwise.</source>
          <target state="translated">Укажите, сколько &lt;var&gt;bytes&lt;/var&gt; пространства стека будет запрошено для каждого потока графического процессора (волновой фронт). Помните, что может быть много потоков и ограниченная память. Размер выделения стека также может влиять на производительность во время выполнения. Значение по умолчанию - 32 КБ при использовании OpenACC или OpenMP и 1 МБ в противном случае.</target>
        </trans-unit>
        <trans-unit id="6b4cd64add8e5ab4a64ac446bfe3679786b4245a" translate="yes" xml:space="preserve">
          <source>Specify how to print paths of control-flow events for diagnostics that have such a path associated with them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9c99e300af9c8b6bed1288c468edd9f4ff0049" translate="yes" xml:space="preserve">
          <source>Specify integer and floating-point calling convention. &lt;var&gt;ABI-string&lt;/var&gt; contains two parts: the size of integer types and the registers used for floating-point types. For example &amp;lsquo;</source>
          <target state="translated">Укажите соглашение о вызовах целых чисел и чисел с плавающей запятой. &lt;var&gt;ABI-string&lt;/var&gt; состоит из двух частей: размера целочисленных типов и регистров, используемых для типов с плавающей запятой. Например '</target>
        </trans-unit>
        <trans-unit id="d83c8944a923ba0afcb420deeb5f2d35c92d90c2" translate="yes" xml:space="preserve">
          <source>Specify that intrinsic library functions are being compiled, passing all values in registers, no matter the size.</source>
          <target state="translated">Укажите,что компилируются внутренние библиотечные функции,передавая все значения в регистрах,независимо от их размера.</target>
        </trans-unit>
        <trans-unit id="ece1c6c2bc5985e3475fb38d94d339c81045f6ff" translate="yes" xml:space="preserve">
          <source>Specify that the assembler should encode SSE instructions with VEX prefix. The option</source>
          <target state="translated">Укажите,что ассемблер должен кодировать инструкции SSE с префиксом VEX.Опция</target>
        </trans-unit>
        <trans-unit id="b6e1f7a9d2a1718382e7b4d035866fa5b223eb27" translate="yes" xml:space="preserve">
          <source>Specify that the program entry point is &lt;var&gt;entry&lt;/var&gt;. The argument is interpreted by the linker; the GNU linker accepts either a symbol name or an address.</source>
          <target state="translated">Укажите, что точкой &lt;var&gt;entry&lt;/var&gt; в программу является вход . Аргумент интерпретируется компоновщиком; компоновщик GNU принимает имя символа или адрес.</target>
        </trans-unit>
        <trans-unit id="109f76cb76b9bdcac0640d708d9f5aa531701516" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850.</source>
          <target state="translated">Укажите,что целевым процессором является V850.</target>
        </trans-unit>
        <trans-unit id="e795d47484c6aa284871594487a90d959a680146" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E. The preprocessor constant &lt;code&gt;__v850e__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">Укажите, что целевой процессор - V850E. Константа препроцессора &lt;code&gt;__v850e__&lt;/code&gt; определяется, если используется эта опция.</target>
        </trans-unit>
        <trans-unit id="8b95c4ac2d723888f85d1eb5d22f7c525dcae0da" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E1. The preprocessor constants &lt;code&gt;__v850e1__&lt;/code&gt; and &lt;code&gt;__v850e__&lt;/code&gt; are defined if this option is used.</source>
          <target state="translated">Укажите, что целевой процессор - V850E1. Константы препроцессора &lt;code&gt;__v850e1__&lt;/code&gt; и &lt;code&gt;__v850e__&lt;/code&gt; определены, если используется эта опция.</target>
        </trans-unit>
        <trans-unit id="978d09824c615036a75f151e3f181a0c030be29d" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2. The preprocessor constant &lt;code&gt;__v850e2__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">Укажите, что целевой процессор - V850E2. Константа препроцессора &lt;code&gt;__v850e2__&lt;/code&gt; определяется, если используется эта опция.</target>
        </trans-unit>
        <trans-unit id="ed32c1d3fe9b0d91dac78559f89b829020d693b3" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2V3. The preprocessor constant &lt;code&gt;__v850e2v3__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">Укажите, что целевой процессор - V850E2V3. Константа препроцессора &lt;code&gt;__v850e2v3__&lt;/code&gt; определяется, если используется эта опция.</target>
        </trans-unit>
        <trans-unit id="45dfef0c4ebf051e18bbb6d800fab624cbb970fb" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. The preprocessor constant &lt;code&gt;__v850e3v5__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">Укажите, что целевой процессор - V850E3V5. Константа препроцессора &lt;code&gt;__v850e3v5__&lt;/code&gt; определяется, если используется эта опция.</target>
        </trans-unit>
        <trans-unit id="c53303aa9a3d3e7e971e5fac1f2e4c19510c6915" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. This is an alias for the</source>
          <target state="translated">Укажите,что целевым процессором является V850E3V5.Это псевдоним для</target>
        </trans-unit>
        <trans-unit id="f54503d1104c416ab9f70cb3eb9892d2467505fc" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850ES. This is an alias for the</source>
          <target state="translated">Укажите,что целевым процессором является V850ES.Это псевдоним для</target>
        </trans-unit>
        <trans-unit id="ffbfc8af222c9971b65ff46dc8c44a1dab74c77d" translate="yes" xml:space="preserve">
          <source>Specify the ABI variant to output code for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a7ba111bd81efdcb44d105c109fea8a9201317" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target architecture. Valid values for &lt;var&gt;arch&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="translated">Укажите целевую архитектуру C-SKY. Допустимые значения для &lt;var&gt;arch&lt;/var&gt; : '</target>
        </trans-unit>
        <trans-unit id="11e0bbd00da02b87a4bf01c5c95da5cd4e1c7d2f" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target processor. Valid values for &lt;var&gt;cpu&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="translated">Укажите целевой процессор C-SKY. Допустимые значения для &lt;var&gt;cpu&lt;/var&gt; : '</target>
        </trans-unit>
        <trans-unit id="fbd43e450dfe7c7020abde276dbd9a11edafebb9" translate="yes" xml:space="preserve">
          <source>Specify the PRU MCU variant to use. Check Newlib for the exact list of supported MCUs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc89fadc7861eb9269a2f0ab8fd00ec9f83fdfcb" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5 as the target architecture.</source>
          <target state="translated">Укажите SCORE5 в качестве целевой архитектуры.</target>
        </trans-unit>
        <trans-unit id="80ac17f93e6b558b7b64a2653f4a0db05f2f20e9" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5U of the target architecture.</source>
          <target state="translated">Укажите SCORE5U целевой архитектуры.</target>
        </trans-unit>
        <trans-unit id="e2e0fec7f878028d3e3295fde4a330a4137fef1a" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7 as the target architecture. This is the default.</source>
          <target state="translated">Укажите SCORE7 в качестве целевой архитектуры.Это умолчание.</target>
        </trans-unit>
        <trans-unit id="3faa14b10ee7726e8a0c19877d4b1bbbf4106dd0" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7D as the target architecture.</source>
          <target state="translated">Укажите SCORE7D в качестве целевой архитектуры.</target>
        </trans-unit>
        <trans-unit id="7c8f7f5802b742a1c6e69d2f1fd902f62c599e4f" translate="yes" xml:space="preserve">
          <source>Specify the access model for the thread local storage pointer. The valid models are &amp;lsquo;</source>
          <target state="translated">Укажите модель доступа для указателя локального хранилища потока. Допустимые модели:</target>
        </trans-unit>
        <trans-unit id="4fe4d9d926d51c315bc40fdf7c449529e2dcee8d" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for in compiling the function.</source>
          <target state="translated">Укажите архитектуру для генерации кода при компиляции функции.</target>
        </trans-unit>
        <trans-unit id="13ac0518f9e486f66b03f2a62260517f22563228" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for when compiling the function. If you select the &lt;code&gt;target(&quot;cpu=power7&quot;)&lt;/code&gt; attribute when generating 32-bit code, VSX and AltiVec instructions are not generated unless you use the</source>
          <target state="translated">Укажите архитектуру для генерации кода при компиляции функции. Если вы выбираете атрибут &lt;code&gt;target(&quot;cpu=power7&quot;)&lt;/code&gt; при генерации 32-битного кода, инструкции VSX и AltiVec не создаются, если вы не используете</target>
        </trans-unit>
        <trans-unit id="815118b1ba2fa776327569310aabc51b60f85457" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for in compiling the function.</source>
          <target state="translated">Укажите архитектуру для настройки при компиляции функции.</target>
        </trans-unit>
        <trans-unit id="c736ab6b1828855a9d2fe005636f63dbc18a00fc" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for when compiling the function. If you do not specify the &lt;code&gt;target(&quot;tune=&lt;var&gt;TUNE&lt;/var&gt;&quot;)&lt;/code&gt; attribute and you do specify the &lt;code&gt;target(&quot;cpu=&lt;var&gt;CPU&lt;/var&gt;&quot;)&lt;/code&gt; attribute, compilation tunes for the &lt;var&gt;CPU&lt;/var&gt; architecture, and not the default tuning specified on the command line.</source>
          <target state="translated">Укажите архитектуру для настройки при компиляции функции. Если вы не укажете атрибут &lt;code&gt;target(&quot;tune=&lt;var&gt;TUNE&lt;/var&gt;&quot;)&lt;/code&gt; , но укажете атрибут &lt;code&gt;target(&quot;cpu=&lt;var&gt;CPU&lt;/var&gt;&quot;)&lt;/code&gt; , компиляция настроится на архитектуру &lt;var&gt;CPU&lt;/var&gt; , а не на настройку по умолчанию, указанную в командной строке.</target>
        </trans-unit>
        <trans-unit id="cb717a175d86a7113193ef8b41cb494223988553" translate="yes" xml:space="preserve">
          <source>Specify the dialect to use for accessing thread local storage. Two &lt;var&gt;dialect&lt;/var&gt;s are supported&amp;mdash;&amp;lsquo;</source>
          <target state="translated">Укажите диалект, который будет использоваться для доступа к локальному хранилищу потока. Поддерживаются два &lt;var&gt;dialect&lt;/var&gt; - '</target>
        </trans-unit>
        <trans-unit id="b0bb1382b2b688a4ca78557929489507a5c35134" translate="yes" xml:space="preserve">
          <source>Specify the format of the &lt;code&gt;__fp16&lt;/code&gt; half-precision floating-point type. Permissible names are &amp;lsquo;</source>
          <target state="translated">Укажите формат типа &lt;code&gt;__fp16&lt;/code&gt; с плавающей запятой половинной точности. Допустимые имена:</target>
        </trans-unit>
        <trans-unit id="54ccdaa4f82b5c59817de75dfddfa096068b5632" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture and, optionally, one or more feature modifiers. This option has the form</source>
          <target state="translated">Укажите имя целевой архитектуры и,опционально,один или несколько модификаторов функций.Этот вариант имеет форму</target>
        </trans-unit>
        <trans-unit id="db2ae06942e745baa6c648898511743a3997f671" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture.</source>
          <target state="translated">Укажите имя целевой архитектуры.</target>
        </trans-unit>
        <trans-unit id="5bd735b6bf455d85d0ce6fea68c71abb062c337b" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor for which GCC should tune the performance of the code. Permissible values for this option are: &amp;lsquo;</source>
          <target state="translated">Укажите имя целевого процессора, для которого GCC должен настроить производительность кода. Допустимые значения для этой опции: '</target>
        </trans-unit>
        <trans-unit id="4403ce6e54a70cfa6d14c2a2335877fa18af0100" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor, optionally suffixed by one or more feature modifiers. This option has the form</source>
          <target state="translated">Укажите имя целевого процессора,опционально дополненное одним или несколькими модификаторами функций.Эта опция имеет форму</target>
        </trans-unit>
        <trans-unit id="4092610bf9412a688b5dccb4c11f819e1c6c07fc" translate="yes" xml:space="preserve">
          <source>Specify the number of bits in an SVE vector register. This option only has an effect when SVE is enabled.</source>
          <target state="translated">Укажите количество бит в векторном регистре SVE.Эта опция действует только при включенном SVE.</target>
        </trans-unit>
        <trans-unit id="e688b24a3a041ea4cb98f3c1a8d73b1e4471b5fc" translate="yes" xml:space="preserve">
          <source>Specify the number of registers to reserve for fast interrupt handler functions. The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 1 means that register &lt;code&gt;r13&lt;/code&gt; is reserved for the exclusive use of fast interrupt handlers. A value of 2 reserves &lt;code&gt;r13&lt;/code&gt; and &lt;code&gt;r12&lt;/code&gt;. A value of 3 reserves &lt;code&gt;r13&lt;/code&gt;, &lt;code&gt;r12&lt;/code&gt; and &lt;code&gt;r11&lt;/code&gt;, and a value of 4 reserves &lt;code&gt;r13&lt;/code&gt; through &lt;code&gt;r10&lt;/code&gt;. A value of 0, the default, does not reserve any registers.</source>
          <target state="translated">Укажите количество регистров, которые нужно зарезервировать для функций быстрого обработчика прерываний. Значение &lt;var&gt;N&lt;/var&gt; может находиться в &lt;code&gt;r13&lt;/code&gt; от 0 до 4. Значение 1 означает, что регистр r13 зарезервирован для исключительного использования обработчиков быстрых прерываний. Значение 2 резервирует &lt;code&gt;r13&lt;/code&gt; и &lt;code&gt;r12&lt;/code&gt; . Значение 3 резервов &lt;code&gt;r13&lt;/code&gt; , &lt;code&gt;r12&lt;/code&gt; и &lt;code&gt;r11&lt;/code&gt; , а значение 4 резервов &lt;code&gt;r13&lt;/code&gt; через &lt;code&gt;r10&lt;/code&gt; . Значение 0 по умолчанию не резервирует регистры.</target>
        </trans-unit>
        <trans-unit id="96cf955f0da2fdbcd4bc1c6671a0522d71316b38" translate="yes" xml:space="preserve">
          <source>Specify the partitioning algorithm used by the link-time optimizer. The value is either &amp;lsquo;</source>
          <target state="translated">Укажите алгоритм разделения, используемый оптимизатором времени компоновки. Значение либо '</target>
        </trans-unit>
        <trans-unit id="5f46dcee93a04ae249c6b3def708b00260f2a519" translate="yes" xml:space="preserve">
          <source>Specify the register to be used for PIC addressing. For standard PIC base case, the default is any suitable register determined by compiler. For single PIC base case, the default is &amp;lsquo;</source>
          <target state="translated">Укажите регистр, который будет использоваться для адресации PIC. Для стандартного базового случая PIC по умолчанию используется любой подходящий регистр, определенный компилятором. Для одного базового случая PIC значение по умолчанию - '</target>
        </trans-unit>
        <trans-unit id="9157006b777e209a57da158df2f68846623d8678" translate="yes" xml:space="preserve">
          <source>Specify the size of each cache block, which must be a power of 2 between 4 and 512.</source>
          <target state="translated">Укажите размер каждого блока кэша,который должен быть мощностью 2 от 4 до 512.</target>
        </trans-unit>
        <trans-unit id="edab8f619041277bee138aa740d3f8bdb844feca" translate="yes" xml:space="preserve">
          <source>Specify the size of each interrupt vector, which must be 4 or 16.</source>
          <target state="translated">Укажите размер каждого вектора прерывания,который должен быть 4 или 16.</target>
        </trans-unit>
        <trans-unit id="dde0e6e48055b68c9dfa72618fe117ee2653e7c8" translate="yes" xml:space="preserve">
          <source>Specify the size of the operating system provided stack guard as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="translated">Указывает размер операционной системы при условии стека охраной как 2 увеличен до &lt;var&gt;num&lt;/var&gt; байт. Более высокие значения могут уменьшить количество явных проверок, но значение, превышающее значение, обеспечиваемое защитой операционной системы, сделает код уязвимым для атак в стиле конфликта стека.</target>
        </trans-unit>
        <trans-unit id="4bee625f3585900ec98450bcf9d2c818f2c00803" translate="yes" xml:space="preserve">
          <source>Specify the struct-like types for which the compiler generates debug information. The intent is to reduce duplicate struct debug information between different object files within the same program.</source>
          <target state="translated">Укажите структуроподобные типы,для которых компилятор генерирует отладочную информацию.Цель-уменьшить дублирование структуроподобной отладочной информации между различными объектными файлами внутри одной и той же программы.</target>
        </trans-unit>
        <trans-unit id="4e0fd0bd7b4133166f8983f5ca490beae5286735" translate="yes" xml:space="preserve">
          <source>Specify the width of the &lt;code&gt;lp_count&lt;/code&gt; register. Valid values for &lt;var&gt;width&lt;/var&gt; are 8, 16, 20, 24, 28 and 32 bits. The default width is fixed to 32 bits. If the width is less than 32, the compiler does not attempt to transform loops in your program to use the zero-delay loop mechanism unless it is known that the &lt;code&gt;lp_count&lt;/code&gt; register can hold the required loop-counter value. Depending on the width specified, the compiler and run-time library might continue to use the loop mechanism for various needs. This option defines macro &lt;code&gt;__ARC_LPC_WIDTH__&lt;/code&gt; with the value of &lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">Укажите ширину регистра &lt;code&gt;lp_count&lt;/code&gt; . Допустимые значения &lt;var&gt;width&lt;/var&gt; : 8, 16, 20, 24, 28 и 32 бита. Ширина по умолчанию составляет 32 бита. Если ширина меньше 32, компилятор не пытается преобразовать циклы в вашей программе для использования механизма цикла с нулевой задержкой, если не известно, что регистр &lt;code&gt;lp_count&lt;/code&gt; может содержать требуемое значение счетчика циклов. В зависимости от указанной ширины компилятор и библиотека времени выполнения могут продолжать использовать механизм цикла для различных нужд. Эта опция определяет макрос &lt;code&gt;__ARC_LPC_WIDTH__&lt;/code&gt; со значением &lt;var&gt;width&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ef84b64c518f868fe3c1456dcd8b940ed2f5f518" translate="yes" xml:space="preserve">
          <source>Specify thread pointer register number.</source>
          <target state="translated">Укажите номер регистра указателя потока.</target>
        </trans-unit>
        <trans-unit id="0795a2fa90067cc8a239666f6041471cc59a29ac" translate="yes" xml:space="preserve">
          <source>Specify whether GCC may generate code that reads from executable sections. There are three possible settings:</source>
          <target state="translated">Укажите,может ли GCC генерировать код,который читается из исполняемых секций.Есть три возможных параметра:</target>
        </trans-unit>
        <trans-unit id="d19282618f9569137fcb9b5340c3ea42b2a33ba2" translate="yes" xml:space="preserve">
          <source>Specify whether GCC should insert cache barriers to avoid the side effects of speculation on R10K processors.</source>
          <target state="translated">Укажите,должен ли GCC вставлять барьеры кэширования,чтобы избежать побочных эффектов спекуляции на процессорах R10K.</target>
        </trans-unit>
        <trans-unit id="1440f232d0fc9c6f8894e1bd99ffd6ec679cd656" translate="yes" xml:space="preserve">
          <source>Specify which floating-point unit to use. You must specify the &lt;code&gt;target(&quot;fpmath=sse,387&quot;)&lt;/code&gt; option as &lt;code&gt;target(&quot;fpmath=sse+387&quot;)&lt;/code&gt; because the comma would separate different options.</source>
          <target state="translated">Укажите, какой модуль с плавающей запятой использовать. Вы должны указать параметр &lt;code&gt;target(&quot;fpmath=sse,387&quot;)&lt;/code&gt; как &lt;code&gt;target(&quot;fpmath=sse+387&quot;)&lt;/code&gt; потому что запятая разделяет разные параметры.</target>
        </trans-unit>
        <trans-unit id="f360040b863c4a298bd666b8b6b30d2471ac8011" translate="yes" xml:space="preserve">
          <source>Specifying</source>
          <target state="translated">Specifying</target>
        </trans-unit>
        <trans-unit id="99167fd0d0a95abb4e35db3c3f342b56f873f72a" translate="yes" xml:space="preserve">
          <source>Specifying &amp;lsquo;</source>
          <target state="translated">Указание '</target>
        </trans-unit>
        <trans-unit id="d1885b005623a5f02d47b85a83ced0900c30f8b7" translate="yes" xml:space="preserve">
          <source>Specifying a combination that is not valid for the current architecture causes GCC to synthesize the instructions using a narrower mode. For example, if you specify a variable of type &lt;code&gt;V4SI&lt;/code&gt; and your architecture does not allow for this specific SIMD type, GCC produces code that uses 4 &lt;code&gt;SIs&lt;/code&gt;.</source>
          <target state="translated">Указание комбинации, недопустимой для текущей архитектуры, заставляет GCC синтезировать инструкции в более узком режиме. Например, если вы указываете переменную типа &lt;code&gt;V4SI&lt;/code&gt; , а ваша архитектура не позволяет использовать этот конкретный тип SIMD, GCC создает код, который использует 4 &lt;code&gt;SIs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e7e05645dcca05e87ea389d828aa6bfe5f9fa1f" translate="yes" xml:space="preserve">
          <source>Specifying a larger number can produce faster, more efficient code, but can also increase the size of the program. Different values are potentially incompatible. Code compiled with one value cannot necessarily expect to work with code or libraries compiled with another value, if they exchange information using structures or unions.</source>
          <target state="translated">Указание большего числа может производить более быстрый и эффективный код,но также может увеличить размер программы.Различные значения потенциально несовместимы.Код,скомпилированный с одним значением,не обязательно должен работать с кодом или библиотеками,скомпилированными с другим значением,если они обмениваются информацией,используя структуры или объединения.</target>
        </trans-unit>
        <trans-unit id="03c6ae3356882b0eeb6636e77ccaa0aba81823b0" translate="yes" xml:space="preserve">
          <source>Specifying attributes of types.</source>
          <target state="translated">Указание атрибутов типов.</target>
        </trans-unit>
        <trans-unit id="9e1c53b45f7e03f5a8d931294deb320e271bf08b" translate="yes" xml:space="preserve">
          <source>Specifying attributes of variables.</source>
          <target state="translated">Указание атрибутов переменных.</target>
        </trans-unit>
        <trans-unit id="5db2ee21c24dcdf45bcae194cf2ecad708afe6a7" translate="yes" xml:space="preserve">
          <source>Specifying attributes on enumerators.</source>
          <target state="translated">Указание атрибутов на счетчиках.</target>
        </trans-unit>
        <trans-unit id="ae68580bc0d24f5d44a4b1108b3374a4cbf533b1" translate="yes" xml:space="preserve">
          <source>Specifying attributes on labels.</source>
          <target state="translated">Указание атрибутов на этикетках.</target>
        </trans-unit>
        <trans-unit id="6f4d8f85b31cb45df6efc5370ca55a06e5b2185a" translate="yes" xml:space="preserve">
          <source>Specifying attributes on statements.</source>
          <target state="translated">Указание атрибутов на утверждениях.</target>
        </trans-unit>
        <trans-unit id="c4fb77efc8cd285dcec19a190e5fd370517a59b0" translate="yes" xml:space="preserve">
          <source>Specifying conventions for function calls, data layout and register usage.</source>
          <target state="translated">Указание соглашений по вызовам функций,расположению данных и использованию регистров.</target>
        </trans-unit>
        <trans-unit id="8a322c1f2da20dac777d0e24ef37843a3925d344" translate="yes" xml:space="preserve">
          <source>Specifying libraries and so on.</source>
          <target state="translated">Указание библиотек и так далее.</target>
        </trans-unit>
        <trans-unit id="35c808a95c8bd97d1d48f311fe3d1ff9cbb26d16" translate="yes" xml:space="preserve">
          <source>Specifying target attributes on individual functions or performing link-time optimization across translation units compiled with different target options can affect function inlining rules:</source>
          <target state="translated">Указание целевых атрибутов на отдельных функциях или выполнение линк-оптимизации в единицах трансляции,скомпилированных с различными целевыми опциями,может повлиять на правила встраивания функций:</target>
        </trans-unit>
        <trans-unit id="4ee9cc1aa83bf2a8aaa7d549089eae697b9df2fe" translate="yes" xml:space="preserve">
          <source>Specifying the</source>
          <target state="translated">Указание</target>
        </trans-unit>
        <trans-unit id="be769970f9d0ab94f326ad5f60920cc958cef495" translate="yes" xml:space="preserve">
          <source>Specifying the assembler name to use for a C symbol.</source>
          <target state="translated">Указание имени ассемблера для символа C.</target>
        </trans-unit>
        <trans-unit id="b768e2f08c0d665e3b9b9a2f57c49ac37e0b4986" translate="yes" xml:space="preserve">
          <source>Speculation Barrier Instruction.</source>
          <target state="translated">Инструкция по барьеру спекуляции.</target>
        </trans-unit>
        <trans-unit id="e39eb4a0ece25ea3aad502401ffe4e7271da49e1" translate="yes" xml:space="preserve">
          <source>Speculatively hoist loads from both branches of an if-then-else if the loads are from adjacent locations in the same structure and the target architecture has a conditional move instruction. This flag is enabled by default at</source>
          <target state="translated">Спекулятивно поднимать грузы из обеих ветвей if-then-else,если грузы поступают из соседних мест в одной конструкции,а целевая архитектура имеет условную инструкцию перемещения.Этот флаг включен по умолчанию при</target>
        </trans-unit>
        <trans-unit id="e6c7808e8703d45ea319f5ac9cfea72c1d3b2c26" translate="yes" xml:space="preserve">
          <source>Split 32-byte AVX unaligned load and store.</source>
          <target state="translated">Разделение 32-байтового AVX без выравнивания нагрузки и хранения.</target>
        </trans-unit>
        <trans-unit id="a66f8bdb0cdd7c740f8bab1b871317c083f59cec" translate="yes" xml:space="preserve">
          <source>Split a loop into two if it contains a condition that&amp;rsquo;s always true for one side of the iteration space and false for the other.</source>
          <target state="translated">Разделите цикл на два, если он содержит условие, которое всегда истинно для одной стороны пространства итераций и ложно для другой.</target>
        </trans-unit>
        <trans-unit id="7e793f0b9e2c47f7ff51cea5a83ac494564f9b01" translate="yes" xml:space="preserve">
          <source>Split paths leading to loop backedges. This can improve dead code elimination and common subexpression elimination. This is enabled by default at</source>
          <target state="translated">Разделенные пути,ведущие к петлям.Это может улучшить устранение мертвого кода и общего подвыражения.По умолчанию это включено при</target>
        </trans-unit>
        <trans-unit id="c19cf5ca00368b6bf60823f07c7f7db52961a1db" translate="yes" xml:space="preserve">
          <source>Split the include path. This option has been deprecated. Please use</source>
          <target state="translated">Разделите путь включения.Эта опция была устарела.Пожалуйста,используйте</target>
        </trans-unit>
        <trans-unit id="03d6628c91b12235f628c3f0849b814233af5af3" translate="yes" xml:space="preserve">
          <source>Split vector moves into single word moves before reload. In theory this can give better register allocation, but so far the reverse seems to be generally the case.</source>
          <target state="translated">Разделенный вектор перемещается на ходы по одному слову перед перезагрузкой.Теоретически это может дать лучшее распределение регистров,но до сих пор,похоже,что в целом все наоборот.</target>
        </trans-unit>
        <trans-unit id="9b6e2276ec4ca5446d91dd4b3bca6fc9336a2104" translate="yes" xml:space="preserve">
          <source>Stack clash protection involves probing stack space as it is allocated. This param controls the maximum distance between probes into the stack as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="translated">Защита от конфликтов стека включает зондирование пространства стека по мере его выделения. Эти пары контролируют максимальное расстояние между зондами в стек как 2 увеличен до &lt;var&gt;num&lt;/var&gt; байт. Более высокие значения могут уменьшить количество явных проверок, но значение, превышающее значение, обеспечиваемое операционной системой, оставит код уязвимым для атак в стиле конфликта стека.</target>
        </trans-unit>
        <trans-unit id="42423254dd8ef2b598b3ee0e697e74e7db04abbc" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SP).</source>
          <target state="translated">Регистр указателей стека (SP).</target>
        </trans-unit>
        <trans-unit id="1d47e20f0d3ac51ec48cf366af32c77c2669b54f" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SPH:SPL)</source>
          <target state="translated">Регистр указателей стека (SPH:SPL)</target>
        </trans-unit>
        <trans-unit id="d8ceeae642420027f1322393a2a3a2e2bcca2060" translate="yes" xml:space="preserve">
          <source>Stack register $sp.</source>
          <target state="translated">Стек регистрации $sp.</target>
        </trans-unit>
        <trans-unit id="19b7dc1683e0d583c27f00412d344ea74bdf5a0a" translate="yes" xml:space="preserve">
          <source>Stack variables are not affected by linker restrictions; GCC can properly align them on any target.</source>
          <target state="translated">Переменные стека не подвержены влиянию линкерных ограничений;GCC может правильно выровнять их по любой цели.</target>
        </trans-unit>
        <trans-unit id="ac5a8f549a994c1b8e4dd80d24db9f3996eea422" translate="yes" xml:space="preserve">
          <source>Standard 80387 floating point constant.</source>
          <target state="translated">Стандартная 80387 константа с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="257c765fd4761dbfb8a7c22158ae9ccc2a9c0d89" translate="yes" xml:space="preserve">
          <source>Standard C requires that pointer types used with &lt;code&gt;va_arg&lt;/code&gt; in functions with variable argument lists either must be compatible with that of the actual argument, or that one type must be a pointer to &lt;code&gt;void&lt;/code&gt; and the other a pointer to a character type. GNU C implements the POSIX XSI extension that additionally permits the use of &lt;code&gt;va_arg&lt;/code&gt; with a pointer type to receive arguments of any other pointer type.</source>
          <target state="translated">Стандарт C требует, чтобы типы указателей, используемые с &lt;code&gt;va_arg&lt;/code&gt; в функциях со списками переменных аргументов, либо были совместимы с типом фактического аргумента, либо один тип должен быть указателем на &lt;code&gt;void&lt;/code&gt; , а другой - указателем на тип символа. GNU C реализует расширение POSIX XSI, которое дополнительно разрешает использование &lt;code&gt;va_arg&lt;/code&gt; с типом указателя для получения аргументов любого другого типа указателя.</target>
        </trans-unit>
        <trans-unit id="6f7654adc68a64f36e03bf390845ec45238411d8" translate="yes" xml:space="preserve">
          <source>Standard C90 requires the elements of an initializer to appear in a fixed order, the same as the order of the elements in the array or structure being initialized.</source>
          <target state="translated">Стандарт C90 требует,чтобы элементы инициализатора отображались в фиксированном порядке,таком же,как и порядок элементов в инициализируемом массиве или структуре.</target>
        </trans-unit>
        <trans-unit id="b23b0b38a39d349a3165d9fefce6588293b09611" translate="yes" xml:space="preserve">
          <source>Standard system directories are scanned.</source>
          <target state="translated">Сканируются стандартные системные каталоги.</target>
        </trans-unit>
        <trans-unit id="7f3657857ae8fa83a5a6acb61ee0490999a1f0da" translate="yes" xml:space="preserve">
          <source>Start a RTM (Restricted Transactional Memory) transaction. Returns &lt;code&gt;_XBEGIN_STARTED&lt;/code&gt; when the transaction started successfully (note this is not 0, so the constant has to be explicitly tested).</source>
          <target state="translated">Запустите транзакцию RTM (ограниченная транзакционная память). Возвращает &lt;code&gt;_XBEGIN_STARTED&lt;/code&gt; , когда транзакция началась успешно (обратите внимание, что это не 0, поэтому константа должна быть явно протестирована).</target>
        </trans-unit>
        <trans-unit id="d321cb5e91b977aa5f4a76bb28fcd908795d2d2b" translate="yes" xml:space="preserve">
          <source>Start lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; or stronger.</source>
          <target state="translated">Начать снятие блокировки с переменной блокировки. Порядок памяти должен быть &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; или выше.</target>
        </trans-unit>
        <trans-unit id="d710b21a9b9bf4c6c45243e4c0bf0c7460f48764" translate="yes" xml:space="preserve">
          <source>Starting with GCC 3.2, GCC binary conventions for C++ are based on a written, vendor-neutral C++ ABI that was designed to be specific to 64-bit Itanium but also includes generic specifications that apply to any platform. This C++ ABI is also implemented by other compiler vendors on some platforms, notably GNU/Linux and BSD systems. We have tried hard to provide a stable ABI that will be compatible with future GCC releases, but it is possible that we will encounter problems that make this difficult. Such problems could include different interpretations of the C++ ABI by different vendors, bugs in the ABI, or bugs in the implementation of the ABI in different compilers. GCC&amp;rsquo;s</source>
          <target state="translated">Начиная с GCC 3.2, бинарные соглашения GCC для C ++ основаны на написанном, независимом от поставщика ABI C ++, который был разработан специально для 64-разрядного Itanium, но также включает общие спецификации, применимые к любой платформе. Этот C ++ ABI также реализован другими поставщиками компиляторов на некоторых платформах, особенно в системах GNU / Linux и BSD. Мы очень старались предоставить стабильный ABI, который будет совместим с будущими выпусками GCC, но возможно, что мы столкнемся с проблемами, которые усложнят это. Такие проблемы могут включать различные интерпретации C ++ ABI разными поставщиками, ошибки в ABI или ошибки в реализации ABI в разных компиляторах. ССЗ</target>
        </trans-unit>
        <trans-unit id="e0603cbbfdea44aa94fc492612a783b691bd4ebd" translate="yes" xml:space="preserve">
          <source>Starting with GCC 4.7.0, the traditional GNU runtime API is no longer available.</source>
          <target state="translated">Начиная с версии GCC 4.7.0,традиционный API исполнения GNU больше не доступен.</target>
        </trans-unit>
        <trans-unit id="0d99177a777348b93d27364c0bfe456087ad31a7" translate="yes" xml:space="preserve">
          <source>Statement Attributes</source>
          <target state="translated">Атрибуты выписки</target>
        </trans-unit>
        <trans-unit id="9a5ff5b401235fc57fb6c95d79c8c8b7116e1c37" translate="yes" xml:space="preserve">
          <source>States an expression as an assumption, and if possible, verifies that the assumption is valid. For example, &lt;code&gt;assume(n &amp;gt; 0)&lt;/code&gt;.</source>
          <target state="translated">Утверждает выражение как предположение и, если возможно, проверяет его правильность. Например, &lt;code&gt;assume(n &amp;gt; 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c22f2edc68615de37762f51b4fa28235f463b8f3" translate="yes" xml:space="preserve">
          <source>Static Analyzer Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f44280770a4ee1097a4edddc52f0cd05d85a900" translate="yes" xml:space="preserve">
          <source>Static libraries are archives of object files, and have file names like</source>
          <target state="translated">Статические библиотеки являются архивами объектных файлов и имеют имена файлов типа</target>
        </trans-unit>
        <trans-unit id="c46e734f5fd8510b9e062efd2082eeb14db6af81" translate="yes" xml:space="preserve">
          <source>Static member declarations are not definitions</source>
          <target state="translated">Статические декларации членов не являются определениями</target>
        </trans-unit>
        <trans-unit id="d94ff9dc4d646834a0535298621e393784d6f1d3" translate="yes" xml:space="preserve">
          <source>Stop after the preprocessing stage; do not run the compiler proper. The output is in the form of preprocessed source code, which is sent to the standard output.</source>
          <target state="translated">Остановитесь после препроцессирования;не запускайте компилятор собственноручно.Вывод выполнен в виде препроцессированного исходного кода,который посылается в стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="2daee47861dfd3c59bf8ff060a32e292f65fec05" translate="yes" xml:space="preserve">
          <source>Stop after the stage of compilation proper; do not assemble. The output is in the form of an assembler code file for each non-assembler input file specified.</source>
          <target state="translated">Остановитесь после собственно этапа компиляции;не ассемблируйте.Выводится в виде файла ассемблерного кода для каждого указанного не ассемблерного входного файла.</target>
        </trans-unit>
        <trans-unit id="8347e9bfc02ac3a60787813c10d80e9ff680d75e" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the best edge has probability lower than this threshold.</source>
          <target state="translated">Остановить рост вперед,если лучший край имеет вероятность ниже этого порога.</target>
        </trans-unit>
        <trans-unit id="93e3b1851a75fdb25f8f9ca9807e49174553cf12" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the probability of best edge is less than this threshold (in percent). Used when profile feedback is available.</source>
          <target state="translated">Остановить рост вперед,если вероятность наилучшего края меньше этого порога (в процентах).Используется при наличии обратной связи по профилю.</target>
        </trans-unit>
        <trans-unit id="5b2c101566fb4988550c86b87f1d88d336f66263" translate="yes" xml:space="preserve">
          <source>Stop reverse growth when the reverse probability of best edge is less than this threshold (in percent).</source>
          <target state="translated">Остановить обратный рост,когда обратная вероятность лучшего края меньше этого порога (в процентах).</target>
        </trans-unit>
        <trans-unit id="5b4aff278c0fdce3e7f55f32e7c895daaa47f804" translate="yes" xml:space="preserve">
          <source>Stop tail duplication once code growth has reached given percentage. This is a rather artificial limit, as most of the duplicates are eliminated later in cross jumping, so it may be set to much higher values than is the desired code growth.</source>
          <target state="translated">Остановить дублирование хвоста,как только рост кода достигнет заданного процента.Это довольно искусственный лимит,так как большинство дубликатов устраняется позже при перекрестном прыжке,поэтому его можно установить на гораздо более высокие значения,чем желаемый рост кода.</target>
        </trans-unit>
        <trans-unit id="e5524f873f830633dc8a23de8cf2d30b3d74c34d" translate="yes" xml:space="preserve">
          <source>Store (do not store) the address of the caller&amp;rsquo;s frame as backchain pointer into the callee&amp;rsquo;s stack frame. A backchain may be needed to allow debugging using tools that do not understand DWARF call frame information. When</source>
          <target state="translated">Сохранять (не сохранять) адрес кадра вызывающего абонента в качестве указателя обратной цепи в кадре стека вызываемого объекта. Может потребоваться обратная цепочка, чтобы разрешить отладку с использованием инструментов, которые не понимают информацию о кадре вызова DWARF. когда</target>
        </trans-unit>
        <trans-unit id="b16037d0dfeba50e99ce7619111826617ed26b77" translate="yes" xml:space="preserve">
          <source>Store data (but not code) in the big-endian format. The default is</source>
          <target state="translated">Хранить данные (но не код)в формате big-endian.По умолчанию</target>
        </trans-unit>
        <trans-unit id="d1b3895de4641414ac79dc4d41b3d54519e0dbbf" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently. If the</source>
          <target state="translated">Постоянно храните обычные &amp;laquo;временные&amp;raquo; промежуточные файлы. Если</target>
        </trans-unit>
        <trans-unit id="825a3542481737ba30d5e3c1a289571cd11217e5" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently; place them in the current directory and name them based on the source file. Thus, compiling</source>
          <target state="translated">Постоянно храните обычные &amp;laquo;временные&amp;raquo; промежуточные файлы; поместите их в текущий каталог и назовите их на основе исходного файла. Таким образом, составив</target>
        </trans-unit>
        <trans-unit id="6a52a11a90147dcb5f7e83906aec646860b00234" translate="yes" xml:space="preserve">
          <source>Storing into the pointer can be done likewise with the same union.</source>
          <target state="translated">Хранение в указателе может быть сделано так же с тем же самым союзом.</target>
        </trans-unit>
        <trans-unit id="7e43c92861ad3e02cc7239ce0887aa080085a685" translate="yes" xml:space="preserve">
          <source>Storing the new address in &lt;code&gt;*&lt;var&gt;ra-address&lt;/var&gt;&lt;/code&gt;, if &lt;var&gt;ra-address&lt;/var&gt; is nonnull.</source>
          <target state="translated">Сохранение нового адреса в &lt;code&gt;*&lt;var&gt;ra-address&lt;/var&gt;&lt;/code&gt; , если &lt;var&gt;ra-address&lt;/var&gt; равен нулю.</target>
        </trans-unit>
        <trans-unit id="d51f83d4384be85e0661264f111bae505e048852" translate="yes" xml:space="preserve">
          <source>Stream extra information needed for aggressive devirtualization when running the link-time optimizer in local transformation mode. This option enables more devirtualization but significantly increases the size of streamed data. For this reason it is disabled by default.</source>
          <target state="translated">Потоковая дополнительная информация,необходимая для агрессивной девиртуализации при запуске оптимизатора времени соединения в режиме локального преобразования.Эта опция обеспечивает большую девиртуализацию,но значительно увеличивает размер потоковых данных.По этой причине по умолчанию она отключена.</target>
        </trans-unit>
        <trans-unit id="474bfcc8400d6e8dacea61eec4b30865208de5b9" translate="yes" xml:space="preserve">
          <source>Structure members are stored sequentially in the order in which they are declared: the first member has the lowest memory address and the last member the highest.</source>
          <target state="translated">Члены структуры хранятся последовательно в порядке,в котором они объявлены:первый член имеет самый низкий адрес памяти,а последний член-самый высокий.</target>
        </trans-unit>
        <trans-unit id="c3de1ed2a463e2a1c2ff86baf892b9da62d4e4d8" translate="yes" xml:space="preserve">
          <source>Structure of the JSON is following:</source>
          <target state="translated">Структура JSON следующая:</target>
        </trans-unit>
        <trans-unit id="4a4ea855e21caf3a76611861328cfb1249cb6b2a" translate="yes" xml:space="preserve">
          <source>Structures with no members.</source>
          <target state="translated">Структуры без членов.</target>
        </trans-unit>
        <trans-unit id="9075bc2ab7ab689b643437d474f305a0857530db" translate="yes" xml:space="preserve">
          <source>Stubs are generated automatically by the linker if the following two conditions are met:</source>
          <target state="translated">Шлейфы автоматически генерируются компоновщиком при выполнении следующих двух условий:</target>
        </trans-unit>
        <trans-unit id="9013b380508240de43628bfd190a9b994da8e678" translate="yes" xml:space="preserve">
          <source>Substitute a file name that has suffix &lt;var&gt;suffix&lt;/var&gt; and is chosen once per compilation, and mark the argument in the same way as &amp;lsquo;</source>
          <target state="translated">Подставьте имя файла с суффиксом &lt;var&gt;suffix&lt;/var&gt; выбираемое один раз для компиляции, и отметьте аргумент таким же образом, как '</target>
        </trans-unit>
        <trans-unit id="5a84f064e80a6c0f3317c7855f9c6ac2c41131d2" translate="yes" xml:space="preserve">
          <source>Substitute any of</source>
          <target state="translated">Заменить любой из</target>
        </trans-unit>
        <trans-unit id="998b2b0ec7c7cc0618199202723cd62e2208d036" translate="yes" xml:space="preserve">
          <source>Substitute one &amp;lsquo;</source>
          <target state="translated">Заменить один</target>
        </trans-unit>
        <trans-unit id="2d0f6708feea91da92348701c1acca054bd497b6" translate="yes" xml:space="preserve">
          <source>Substitute the basename of the input file being processed. This is the substring up to (and not including) the last period and not including the directory.</source>
          <target state="translated">Замените базовое имя обрабатываемого входного файла.Это подстрока до (и не включая)последнего периода и не включая каталог.</target>
        </trans-unit>
        <trans-unit id="1de1b430997906cd235f8cdbc3a04979f0ce1846" translate="yes" xml:space="preserve">
          <source>Substitute the contents of spec string &lt;var&gt;name&lt;/var&gt; at this point.</source>
          <target state="translated">Подставьте в этот момент содержимое строки спецификации &lt;var&gt;name&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fd2fde2ae73c8516cb1a3cac098e2359e8a7c33a" translate="yes" xml:space="preserve">
          <source>Substitute the name of the input file being processed.</source>
          <target state="translated">Замените имя обрабатываемого входного файла.</target>
        </trans-unit>
        <trans-unit id="ae8eaa414e533e6922c45c08150cca1cb19b9be1" translate="yes" xml:space="preserve">
          <source>Substitute the variable part of a matched option. See below. Note that each comma in the substituted string is replaced by a single space.</source>
          <target state="translated">Замените переменную часть соответствующей опции.См.ниже.Обратите внимание,что каждая запятая в подставленной строке заменяется одним пробелом.</target>
        </trans-unit>
        <trans-unit id="43dec03cdd027bda7c71fa5dcb7ea1dab00d8963" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if either &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-P&lt;/code&gt; is given to GCC. This may be combined with &amp;lsquo;</source>
          <target state="translated">Заменяет &lt;code&gt;X&lt;/code&gt; , если GCC задано &lt;code&gt;-S&lt;/code&gt; или &lt;code&gt;-P&lt;/code&gt; . Это может быть объединено с '</target>
        </trans-unit>
        <trans-unit id="e6be527872250ba01c3017e89b857046ca96045c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if one or more switches whose names start with &lt;code&gt;-S&lt;/code&gt; are specified to GCC. Normally &lt;code&gt;X&lt;/code&gt; is substituted only once, no matter how many such switches appeared. However, if &lt;code&gt;%*&lt;/code&gt; appears somewhere in &lt;code&gt;X&lt;/code&gt;, then &lt;code&gt;X&lt;/code&gt; is substituted once for each matching switch, with the &lt;code&gt;%*&lt;/code&gt; replaced by the part of that switch matching the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Заменяет &lt;code&gt;X&lt;/code&gt; , если в GCC указан один или несколько ключей, имена которых начинаются с &lt;code&gt;-S&lt;/code&gt; . Обычно &lt;code&gt;X&lt;/code&gt; заменяется только один раз, сколько бы таких переключателей не появлялось. Однако, если &lt;code&gt;%*&lt;/code&gt; появляется где-то в &lt;code&gt;X&lt;/code&gt; , то &lt;code&gt;X&lt;/code&gt; заменяется один раз для каждого соответствующего переключателя, причем &lt;code&gt;%*&lt;/code&gt; заменяется частью этого переключателя, совпадающей с &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="786d7f6a8f7f27970f79f53feb14051559d33597" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if &lt;em&gt;not&lt;/em&gt; processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">Заменители &lt;code&gt;X&lt;/code&gt; , если &lt;em&gt;не&lt;/em&gt; обрабатывает файл с суффиксом &lt;code&gt;S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="864ccc2fa9d07c116ad04b8eeaefd7787e81b65c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if not processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">Заменители &lt;code&gt;X&lt;/code&gt; , если не обрабатывает файл для языка &lt;code&gt;S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64dfa62f2736f224c236543aa31324e1526b2435" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">Заменители &lt;code&gt;X&lt;/code&gt; , если обработка файла для языка &lt;code&gt;S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6dded313927000e1a3934ea810bce16c0a202a3" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">Заменители &lt;code&gt;X&lt;/code&gt; , если обработка файла с суффиксом &lt;code&gt;S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0531e0f44345fcee0b59ff85181d8e187cb0d34" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if the</source>
          <target state="translated">Заменяет &lt;code&gt;X&lt;/code&gt; , если</target>
        </trans-unit>
        <trans-unit id="381da79492b4d41df2595656917a76e838b4035d" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;var&gt;.SUFFIX&lt;/var&gt; for the suffixes of a matched switch&amp;rsquo;s args when it is subsequently output with &amp;lsquo;</source>
          <target state="translated">Заменители &lt;var&gt;.SUFFIX&lt;/var&gt; для суффиксов арга подобранного коммутатора , когда он впоследствии выводится с '</target>
        </trans-unit>
        <trans-unit id="330d507dbe426595b8910e78b9c215b447059d1c" translate="yes" xml:space="preserve">
          <source>Substitutes all the switches specified to GCC whose names start with &lt;code&gt;-S&lt;/code&gt;, but which also take an argument. This is used for switches like</source>
          <target state="translated">Подставляет все переключатели, указанные в GCC, имена которых начинаются с &lt;code&gt;-S&lt;/code&gt; , но также принимают аргумент. Это используется для таких переключателей, как</target>
        </trans-unit>
        <trans-unit id="83c0a4e01bdd2a1adfb064f09d23d09f40d1cc63" translate="yes" xml:space="preserve">
          <source>Substitutes the &lt;code&gt;-S&lt;/code&gt; switch, if that switch is given to GCC. If that switch is not specified, this substitutes nothing. Note that the leading dash is omitted when specifying this option, and it is automatically inserted if the substitution is performed. Thus the spec string &amp;lsquo;</source>
          <target state="translated">Заменяет &lt;code&gt;-S&lt;/code&gt; выключатель, если переключатель дается НКУ. Если этот переключатель не указан, это ничего не заменяет. Обратите внимание, что при указании этой опции ведущее тире опускается и автоматически вставляется, если выполняется подстановка. Таким образом, строка спецификации '</target>
        </trans-unit>
        <trans-unit id="3c13db3d4f7d55a97362e7f68ba24cf3424c2837" translate="yes" xml:space="preserve">
          <source>Substitutes the last file name generated with &amp;lsquo;</source>
          <target state="translated">Заменяет последнее созданное имя файла на '</target>
        </trans-unit>
        <trans-unit id="4b4f52841be7dd8b1c205fb48bea71f8dc73cc8b" translate="yes" xml:space="preserve">
          <source>Substitutes the name of the &lt;code&gt;HOST_BIT_BUCKET&lt;/code&gt;, if any, and if it is writable, and if</source>
          <target state="translated">&lt;code&gt;HOST_BIT_BUCKET&lt;/code&gt; имя HOST_BIT_BUCKET , если есть, и если он доступен для записи, и если</target>
        </trans-unit>
        <trans-unit id="510d92a70f7a6df088d50db8add12d77997610de" translate="yes" xml:space="preserve">
          <source>Substitutes the names of all the output files, with spaces automatically placed around them. You should write spaces around the &amp;lsquo;</source>
          <target state="translated">Заменяет имена всех выходных файлов с автоматически помещенными вокруг них пробелами. Вы должны написать пробелы вокруг '</target>
        </trans-unit>
        <trans-unit id="37e406a2f9f9f2524ce85dd8f1df47e0fcb53fb6" translate="yes" xml:space="preserve">
          <source>Substitutes the standard macro predefinitions for the current target machine. Use this when running &lt;code&gt;cpp&lt;/code&gt;.</source>
          <target state="translated">Заменяет стандартные предопределения макросов для текущей целевой машины. Используйте это при запуске &lt;code&gt;cpp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="601b96766181d9e1c5aa982978f52e20aab04d35" translate="yes" xml:space="preserve">
          <source>Substitutes the suffix for object files. Note that this is handled specially when it immediately follows &amp;lsquo;</source>
          <target state="translated">Заменяет суффикс объектных файлов. Обратите внимание, что это обрабатывается специально, когда сразу следует за '</target>
        </trans-unit>
        <trans-unit id="ebb148237b08e3751f6fc1e4dce1cbcd763ff06d" translate="yes" xml:space="preserve">
          <source>Subtraction, multiplication, division, and the logical operations operate in a similar manner. Likewise, the result of using the unary minus or complement operators on a vector type is a vector whose elements are the negative or complemented values of the corresponding elements in the operand.</source>
          <target state="translated">Вычитание,умножение,деление и логические операции действуют аналогичным образом.Аналогично,результатом использования операторов одинарного минуса или дополнения на векторном типе является вектор,элементы которого являются отрицательными или дополненными значениями соответствующих элементов в операнде.</target>
        </trans-unit>
        <trans-unit id="9ed92f9622e5eda43509c60bb3049fa12fe5ec7f" translate="yes" xml:space="preserve">
          <source>Such a feature would work only occasionally&amp;mdash;only for calls that appear in the same file as the called function, following the definition. The only way to check all calls reliably is to add a prototype for the function. But adding a prototype eliminates the motivation for this feature. So the feature is not worthwhile.</source>
          <target state="translated">Такая функция будет работать только изредка - только для вызовов, которые появляются в том же файле, что и вызываемая функция, после определения. Единственный способ надежно проверить все вызовы - добавить прототип функции. Но добавление прототипа устраняет мотивацию для этой функции. Так что особенность не стоит.</target>
        </trans-unit>
        <trans-unit id="5af0feab651599b508e437900c6cfc81abd2fe41" translate="yes" xml:space="preserve">
          <source>Such accesses are supported, subject to the same requirements for synchronization for concurrent accesses as for concurrent accesses to any object.</source>
          <target state="translated">Такие обращения поддерживаются,при условии соблюдения тех же требований к синхронизации для параллельных обращений,что и для параллельных обращений к любому объекту.</target>
        </trans-unit>
        <trans-unit id="4cfbaa1bf62e72b4bca886bc067e3bd96ad98df4" translate="yes" xml:space="preserve">
          <source>Such an array of label values serves a purpose much like that of the &lt;code&gt;switch&lt;/code&gt; statement. The &lt;code&gt;switch&lt;/code&gt; statement is cleaner, so use that rather than an array unless the problem does not fit a &lt;code&gt;switch&lt;/code&gt; statement very well.</source>
          <target state="translated">Такой массив значений меток служит цели, во многом аналогичной цели оператора &lt;code&gt;switch&lt;/code&gt; . Оператор &lt;code&gt;switch&lt;/code&gt; более понятен, поэтому используйте его, а не массив, если проблема не подходит для оператора &lt;code&gt;switch&lt;/code&gt; очень хорошо.</target>
        </trans-unit>
        <trans-unit id="4348530a5b230f9786021cf2cdbed2168537bbe7" translate="yes" xml:space="preserve">
          <source>Such an object is normally accessed by pointers and used for accessing hardware. In most expressions, it is intuitively obvious what is a read and what is a write. For example</source>
          <target state="translated">Доступ к такому объекту обычно осуществляется с помощью указателей и используется для доступа к оборудованию.В большинстве выражений интуитивно понятно,что такое чтение,а что-запись.Например</target>
        </trans-unit>
        <trans-unit id="7e9903330f56016812404c897216c2074bedf62f" translate="yes" xml:space="preserve">
          <source>Such argument passing is supported, using the same pass-by-invisible-reference approach used for normal function arguments of such types.</source>
          <target state="translated">Такая передача аргументов поддерживается,используя тот же подход pass-by-invisible-reference,который используется для обычных аргументов функций таких типов.</target>
        </trans-unit>
        <trans-unit id="fdaf5b5f6a3d1715a900b4b2779de302364392a5" translate="yes" xml:space="preserve">
          <source>Such assignments must be very common; warning about them would cause more annoyance than good.</source>
          <target state="translated">Такие задания должны быть очень распространены;предупреждение о них вызовет больше раздражения,чем пользы.</target>
        </trans-unit>
        <trans-unit id="fc536d9f079301ea3cff9bd45f17bf843dbe50ad" translate="yes" xml:space="preserve">
          <source>Such built-in functions are provided for &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;mempcpy&lt;/code&gt;, &lt;code&gt;memmove&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;stpcpy&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt; and &lt;code&gt;strncat&lt;/code&gt;.</source>
          <target state="translated">Такие встроенные функции предоставляются для &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;mempcpy&lt;/code&gt; , &lt;code&gt;memmove&lt;/code&gt; , &lt;code&gt;memset&lt;/code&gt; , &lt;code&gt;strcpy&lt;/code&gt; , &lt;code&gt;stpcpy&lt;/code&gt; , &lt;code&gt;strncpy&lt;/code&gt; , &lt;code&gt;strcat&lt;/code&gt; и &lt;code&gt;strncat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a73b44a4d02b7ee2f589148448bb9f1b269841d" translate="yes" xml:space="preserve">
          <source>Such code is suitable for level 0 PA systems and kernels.</source>
          <target state="translated">Такой код подходит для систем и ядер уровня 0 PA.</target>
        </trans-unit>
        <trans-unit id="221482fe63639c70a1d813f43faebcec11cd2c30" translate="yes" xml:space="preserve">
          <source>Such expressions are rvalues, and GCC implements this as a read of the volatile object being pointed to.</source>
          <target state="translated">Такие выражения являются значениями,и GCC реализует это как чтение указываемого волатильного объекта.</target>
        </trans-unit>
        <trans-unit id="44cf0f4f846947a1f248438be1e959f7db481213" translate="yes" xml:space="preserve">
          <source>Such tokens may not be concatenated.</source>
          <target state="translated">Такие жетоны не могут быть соединены.</target>
        </trans-unit>
        <trans-unit id="2bba52ae9199f8bd23584e0938f470a93242074f" translate="yes" xml:space="preserve">
          <source>Support &lt;em&gt;IBM RS/6000 SP&lt;/em&gt;&lt;em&gt;Parallel Environment&lt;/em&gt; (PE). Link an application written to use message passing with special startup code to enable the application to run. The system must have PE installed in the standard location (</source>
          <target state="translated">Поддержка &lt;em&gt;параллельной среды &lt;/em&gt;&lt;em&gt;IBM RS / 6000 SP&lt;/em&gt; (PE). Свяжите приложение, написанное для использования передачи сообщений, со специальным кодом запуска, чтобы приложение могло работать. В системе должен быть установлен PE в стандартном месте (&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="075bd5530c2b703c7849a9e331065651957bda71" translate="yes" xml:space="preserve">
          <source>Support ISO C trigraphs. These are three-character sequences, all starting with &amp;lsquo;</source>
          <target state="translated">Поддержка триграфов ISO C. Это трехсимвольные последовательности, начинающиеся с '</target>
        </trans-unit>
        <trans-unit id="8219e8938cf7630391bdb51b3542081a049cff2c" translate="yes" xml:space="preserve">
          <source>Support all ISO C90 programs (certain GNU extensions that conflict with ISO C90 are disabled). Same as</source>
          <target state="translated">Поддержка всех программ ISO C90 (некоторые расширения GNU,которые конфликтуют с ISO C90,отключены).То же самое,что и</target>
        </trans-unit>
        <trans-unit id="54fea23628caa918a67b27ac084d811f983c065d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;resolveClassMethod:&lt;/code&gt; was added to the GNU Objective-C runtime in GCC version 4.6.</source>
          <target state="translated">Поддержка &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; и &lt;code&gt;resolveClassMethod:&lt;/code&gt; была добавлена ​​в среду выполнения GNU Objective-C в GCC версии 4.6.</target>
        </trans-unit>
        <trans-unit id="dd68cf9e9a0ec7bc0fc781d9f962022790ff0418" translate="yes" xml:space="preserve">
          <source>Support for decimal floating types includes the arithmetic operators add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="translated">Поддержка десятичных плавающих типов включает арифметические операторы сложение, вычитание, умножение, деление; унарные арифметические операторы; реляционные операторы; операторы равенства; и преобразования в и из целочисленных и других типов с плавающей запятой. Используйте суффикс '</target>
        </trans-unit>
        <trans-unit id="81ca39c921120d2adfd04ac948aaa079d0c3ae01" translate="yes" xml:space="preserve">
          <source>Support for fixed-point types includes:</source>
          <target state="translated">Поддержка для типов с фиксированной точкой включает в себя:</target>
        </trans-unit>
        <trans-unit id="5e968c4a4e334d0a74a0d1d72a11bad05634a930" translate="yes" xml:space="preserve">
          <source>Support for garbage collection with the GNU runtime has been added by using a powerful conservative garbage collector, known as the Boehm-Demers-Weiser conservative garbage collector.</source>
          <target state="translated">Поддержка сбора мусора во время выполнения GNU была добавлена с помощью мощного консервативного сборщика мусора,известного как консервативный сборщик мусора Boehm-Demers-Weiser.</target>
        </trans-unit>
        <trans-unit id="03b50bd9ac9ebf90f9a5662b1d0f6ab814a76b5a" translate="yes" xml:space="preserve">
          <source>Support for streams has been removed and the string to be printed will always be sent to stdout via the &lt;code&gt;write&lt;/code&gt; syscall. The string is not buffered before it is sent to write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0504a68e0c39cc0a79b57df0e39cf16b54d9e942" translate="yes" xml:space="preserve">
          <source>Support for these additional types includes the arithmetic operators: add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="translated">Поддержка этих дополнительных типов включает арифметические операторы: сложение, вычитание, умножение, деление; унарные арифметические операторы; реляционные операторы; операторы равенства; и преобразования в и из целочисленных и других типов с плавающей запятой. Используйте суффикс '</target>
        </trans-unit>
        <trans-unit id="43f86c51be480704f6fd0e7ee0fe1bad4e5dee50" translate="yes" xml:space="preserve">
          <source>Support thread-safe exception handling on MinGW. Programs that rely on thread-safe exception handling must compile and link all code with the</source>
          <target state="translated">Обработка исключений,безопасных для резьбы,на MinGW.Программы,которые полагаются на потокобезопасную обработку исключений,должны скомпилировать и связать весь код с помощью команды</target>
        </trans-unit>
        <trans-unit id="b789d7421ca6bd2ef122f7c0fe30f55f0075ed29" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu&lt;/var&gt; are</source>
          <target state="translated">Поддерживаемые значения для &lt;var&gt;cpu&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="4bb84e33320d5d24d55a608a57ed95d8069c1f60" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu_type&lt;/var&gt; are</source>
          <target state="translated">Поддерживаемые значения для &lt;var&gt;cpu_type&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="e586e3e5b6ddb947a96ee95bbf9931e047b7a75c" translate="yes" xml:space="preserve">
          <source>Suppose for example you have a &lt;code&gt;FileStream&lt;/code&gt; class that declares &lt;code&gt;Stdin&lt;/code&gt;, &lt;code&gt;Stdout&lt;/code&gt; and &lt;code&gt;Stderr&lt;/code&gt; as global variables, like below:</source>
          <target state="translated">Предположим, например, что у вас есть класс &lt;code&gt;FileStream&lt;/code&gt; , который объявляет &lt;code&gt;Stdin&lt;/code&gt; , &lt;code&gt;Stdout&lt;/code&gt; и &lt;code&gt;Stderr&lt;/code&gt; как глобальные переменные, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="e59b9335cfc4b19ac5e0c2f6fad649ab56af701c" translate="yes" xml:space="preserve">
          <source>Suppose the type &lt;code&gt;uid_t&lt;/code&gt; happens to be &lt;code&gt;short&lt;/code&gt;. ISO C does not allow this example, because subword arguments in old-style non-prototype definitions are promoted. Therefore in this example the function definition&amp;rsquo;s argument is really an &lt;code&gt;int&lt;/code&gt;, which does not match the prototype argument type of &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">Предположим , что тип &lt;code&gt;uid_t&lt;/code&gt; случается быть &lt;code&gt;short&lt;/code&gt; . ISO C не допускает этот пример, потому что аргументы подслов в определениях старого стиля, не являющиеся прототипами, продвигаются. Поэтому в этом примере аргумент определения функции действительно является &lt;code&gt;int&lt;/code&gt; , что не соответствует типу аргумента прототипа &lt;code&gt;short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48ba8dd72d18863780aea11859486731c35e5eea" translate="yes" xml:space="preserve">
          <source>Suppress the generation of link options to search libdld.sl when the</source>
          <target state="translated">Подавление генерации опций ссылок для поиска libdld.sl,когда</target>
        </trans-unit>
        <trans-unit id="d35c9ca6cfae417ba88541dbae7bd0b48fb96152" translate="yes" xml:space="preserve">
          <source>Suppress warning messages emitted by &lt;code&gt;#warning&lt;/code&gt; directives.</source>
          <target state="translated">Подавлять предупреждающие сообщения, &lt;code&gt;#warning&lt;/code&gt; директивами #warning .</target>
        </trans-unit>
        <trans-unit id="7f779f6a3dd8fc46f68f940fe5b38cc8f0332cb0" translate="yes" xml:space="preserve">
          <source>Suppress warnings about inheriting from a virtual base with a non-trivial C++11 move assignment operator. This is dangerous because if the virtual base is reachable along more than one path, it is moved multiple times, which can mean both objects end up in the moved-from state. If the move assignment operator is written to avoid moving from a moved-from object, this warning can be disabled.</source>
          <target state="translated">Подавление предупреждений о наследовании из виртуальной базы с нетривиальным оператором присваивания перемещений C++11.Это опасно,так как если виртуальная база доступна по нескольким путям,то она перемещается несколько раз,что может означать,что оба объекта окажутся в состоянии перемещения.Если оператор присваивания перемещений написан для того,чтобы избежать перемещения из сдвинутого объекта,то данное предупреждение может быть отключено.</target>
        </trans-unit>
        <trans-unit id="48a42269132ea484d01ac088e414c9e42de642c6" translate="yes" xml:space="preserve">
          <source>Suppress warnings about use of C++11 inheriting constructors when the base class inherited from has a C variadic constructor; the warning is on by default because the ellipsis is not inherited.</source>
          <target state="translated">Подавить предупреждения об использовании наследующих конструкторов C++11,когда базовый класс,от которого наследуется C variadic,имеет конструктор C;предупреждение включено по умолчанию,так как эллипсис не наследуется.</target>
        </trans-unit>
        <trans-unit id="cb3aae6f5324c78295db9baccb5bafa853510ca1" translate="yes" xml:space="preserve">
          <source>Suppress warnings from applying the &lt;code&gt;offsetof&lt;/code&gt; macro to a non-POD type. According to the 2014 ISO C++ standard, applying &lt;code&gt;offsetof&lt;/code&gt; to a non-standard-layout type is undefined. In existing C++ implementations, however, &lt;code&gt;offsetof&lt;/code&gt; typically gives meaningful results. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it.</source>
          <target state="translated">Подавить предупреждения о применении макроса &lt;code&gt;offsetof&lt;/code&gt; к типу, отличному от POD. Согласно стандарту ISO C ++ 2014 года, применение &lt;code&gt;offsetof&lt;/code&gt; к нестандартному типу макета не определено. Однако в существующих реализациях C ++ &lt;code&gt;offsetof&lt;/code&gt; обычно дает значимые результаты. Этот флаг предназначен для пользователей, которые знают, что они пишут непереносимый код, и которые сознательно решили игнорировать предупреждение об этом.</target>
        </trans-unit>
        <trans-unit id="ba83304e4c99868bbbe79f9fdcf9011c9415eab0" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts from a pointer to an integer type of a different size.</source>
          <target state="translated">Подавление предупреждений от каст от указателя до целочисленного типа различного размера.</target>
        </trans-unit>
        <trans-unit id="ef9b18daa97b7e3ff555e42290cbf027c56dba77" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts to pointer type of an integer of a different size. In C++, casting to a pointer type of smaller size is an error.</source>
          <target state="translated">Подавление предупреждений от каст до типа указателя на целое число разного размера.В Си++приведение к типу указателя меньшего размера является ошибкой.</target>
        </trans-unit>
        <trans-unit id="d5c7bd9509193e71d10cdb667e9063dd06de3280" translate="yes" xml:space="preserve">
          <source>Suppress warnings when a positional initializer is used to initialize a structure that has been marked with the &lt;code&gt;designated_init&lt;/code&gt; attribute.</source>
          <target state="translated">Подавить предупреждения , когда позиционная инициализатор используется для инициализации структуры , которая была отмечена с &lt;code&gt;designated_init&lt;/code&gt; атрибутом.</target>
        </trans-unit>
        <trans-unit id="b5db30b4023b1a002e3bf61c91080c305981c620" translate="yes" xml:space="preserve">
          <source>Switch ARM/Thumb modes on alternating functions. This option is provided for regression testing of mixed Thumb/ARM code generation, and is not intended for ordinary use in compiling code.</source>
          <target state="translated">Переключение режимов ARM/Thumb на альтернативные функции.Данная опция предусмотрена для регрессионного тестирования смешанного Thumb/ARM кода,и не предназначена для обычного использования при компиляции кода.</target>
        </trans-unit>
        <trans-unit id="d7301da94a751f6929a8a4eed4be94e8d5777d3a" translate="yes" xml:space="preserve">
          <source>Switch initialization conversion refuses to create arrays that are bigger than</source>
          <target state="translated">Преобразование инициализации коммутатора отказывается от создания массивов размером больше,чем</target>
        </trans-unit>
        <trans-unit id="aaf2d10ad0dec99d41b3214114d91b1b2422b89f" translate="yes" xml:space="preserve">
          <source>Switch to code generation variant that allows to execute all threads in each warp, while maintaining memory state and side effects as if only one thread in each warp was active outside of OpenMP SIMD regions. All atomic operations and calls to runtime (malloc, free, vprintf) are conditionally executed (iff current lane index equals the master lane index), and the register being assigned is copied via a shuffle instruction from the master lane. Outside of SIMD regions lane 0 is the master; inside, each thread sees itself as the master. Shared memory array &lt;code&gt;int __nvptx_uni[]&lt;/code&gt; stores all-zeros or all-ones bitmasks for each warp, indicating current mode (0 outside of SIMD regions). Each thread can bitwise-and the bitmask at position &lt;code&gt;tid.y&lt;/code&gt; with current lane index to compute the master lane index.</source>
          <target state="translated">Переключитесь на вариант генерации кода, который позволяет выполнять все потоки в каждой основе, сохраняя при этом состояние памяти и побочные эффекты, как если бы только один поток в каждой основе был активен вне областей OpenMP SIMD. Все атомарные операции и вызовы среды выполнения (malloc, free, vprintf) выполняются условно (если текущий индекс полосы равен индексу главной полосы), а назначаемый регистр копируется с помощью инструкции перемешивания из главной полосы. За пределами SIMD-регионов полоса 0 является ведущей; внутри каждый поток считает себя мастером. В массиве разделяемой памяти &lt;code&gt;int __nvptx_uni[]&lt;/code&gt; хранятся битовые маски всех нулей или единиц для каждой деформации, указывающие текущий режим (0 за пределами областей SIMD). Каждый поток может быть побитовым и битовой маской в ​​позиции &lt;code&gt;tid.y&lt;/code&gt; с текущим индексом полосы для вычисления индекса главной полосы.</target>
        </trans-unit>
        <trans-unit id="df31493a786b81749ab4d7d1c6bbb6b81f2ef537" translate="yes" xml:space="preserve">
          <source>Symbolic constant for call/jump instruction.</source>
          <target state="translated">Символическая константа для команды вызова/прыжка.</target>
        </trans-unit>
        <trans-unit id="d02b75640f5617b344a6fd481b4fcf74a33c7dab" translate="yes" xml:space="preserve">
          <source>Synonyms for</source>
          <target state="translated">Синонимы для</target>
        </trans-unit>
        <trans-unit id="a7f02fe7170bb60802488281e7b6535e4525bc7a" translate="yes" xml:space="preserve">
          <source>Syntax without an explicit &lt;var&gt;opts&lt;/var&gt; parameter is deprecated. It is equivalent to specifying an &lt;var&gt;opts&lt;/var&gt; list of:</source>
          <target state="translated">Синтаксис без явного параметра &lt;var&gt;opts&lt;/var&gt; считается устаревшим. Это эквивалентно указанию списка &lt;var&gt;opts&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="fb5461d0f57b9c531d984331d59cfb9c2b43a2f9" translate="yes" xml:space="preserve">
          <source>System V Release 4 small data area reference</source>
          <target state="translated">Система V Релиз 4 ссылка на небольшую область данных</target>
        </trans-unit>
        <trans-unit id="e4a39789bd7be8b8dfec91a966c5aa35d6a313b6" translate="yes" xml:space="preserve">
          <source>TI ABI specifies that function (code) pointers are 16-bit, whereas GNU supports only 32-bit data and code pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2218a74f01f0ccb4e48f5247664f57112a4f0aaf" translate="yes" xml:space="preserve">
          <source>TI C6X family&amp;mdash;</source>
          <target state="translated">Семейство TI C6X&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="c941de06f499163c146e2988a363757665dd2da4" translate="yes" xml:space="preserve">
          <source>TILE-Gx&amp;mdash;</source>
          <target state="translated">TILE-Gx&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="94413aebaec1d35ed29622efe6a91644c6c91dd4" translate="yes" xml:space="preserve">
          <source>TILEPro&amp;mdash;</source>
          <target state="translated">TILEPro&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">Содержание</target>
        </trans-unit>
        <trans-unit id="ecd7eecc4f728ae74383a27923d7203db8bfeb4c" translate="yes" xml:space="preserve">
          <source>Take advantage of linker relaxations to reduce the number of instructions required to materialize symbol addresses. The default is to take advantage of linker relaxations.</source>
          <target state="translated">Воспользуйтесь преимуществами релаксации компоновщика,чтобы уменьшить количество инструкций,необходимых для материализации адресов символов.По умолчанию используются релаксации компоновщика.</target>
        </trans-unit>
        <trans-unit id="01d35405dd4f6f085c687c5306bb4a6e617f2e88" translate="yes" xml:space="preserve">
          <source>Taking the address of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted.</source>
          <target state="translated">Допускается получение адреса &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; с обратным скалярным порядком хранения.</target>
        </trans-unit>
        <trans-unit id="9ff36b684e3489808b01be7efb64c6849f9ba0f5" translate="yes" xml:space="preserve">
          <source>Taking the address of a label may generate errors from the HP-UX PA assembler. GAS for the PA does not have this problem.</source>
          <target state="translated">Взятие адреса метки может привести к ошибкам в работе ассемблера HP-UX PA.GAS для PA не имеет этой проблемы.</target>
        </trans-unit>
        <trans-unit id="8c7129ffec0f9a33a9ffe8b44de153b8593725b3" translate="yes" xml:space="preserve">
          <source>Taking the address of a scalar field of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is not permitted and yields an error.</source>
          <target state="translated">Взятие адреса скалярного поля &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; с обратным скалярным порядком хранения не допускается и приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="9f5bfaf20daa2c55100557696546e467c263a569" translate="yes" xml:space="preserve">
          <source>Taking the address of an array field, whose component is scalar, of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted but yields a warning, unless</source>
          <target state="translated">Принятие адреса поля массива, компонент которого является скалярным, из &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; с обратным скалярным порядком хранения разрешен, но дает предупреждение, если только</target>
        </trans-unit>
        <trans-unit id="eb41297adae8dd10c30aff884697e8695add6957" translate="yes" xml:space="preserve">
          <source>Taking this into account, it is important to note the following:</source>
          <target state="translated">Учитывая это,важно отметить следующее:</target>
        </trans-unit>
        <trans-unit id="c69e706d0180e6de86eaea828036822f65c39e90" translate="yes" xml:space="preserve">
          <source>Target architectures are encouraged to provide their own patterns for each of the atomic built-in functions. If no target is provided, the original non-memory model set of &amp;lsquo;</source>
          <target state="translated">Целевым архитектурам рекомендуется предоставлять свои собственные шаблоны для каждой атомарной встроенной функции. Если цель не указана, исходный набор модели без памяти '</target>
        </trans-unit>
        <trans-unit id="f7c745960637a96625efff80e3b7b6cb80a28125" translate="yes" xml:space="preserve">
          <source>Target has split instruction and data space. Implies -m45.</source>
          <target state="translated">Цель имеет разделенное пространство инструкций и данных.Подразумевается -m45.</target>
        </trans-unit>
        <trans-unit id="70857ff656af8497b29b5cea7cede66fd2b8d04e" translate="yes" xml:space="preserve">
          <source>Target-specific attributes that affect the identity of a type, such as ia32 calling conventions on a function type (stdcall, regparm, etc.), did not affect the mangled name, leading to name collisions when function pointers were used as template arguments.</source>
          <target state="translated">Специфические атрибуты,которые влияют на идентичность типа,такие как ia32,вызывающие соглашения о типе функции (stdcall,regparm и т.д.),не влияли на искаженное имя,что приводило к столкновению имен,когда указатели функции использовались в качестве шаблонных аргументов.</target>
        </trans-unit>
        <trans-unit id="55ac9adb172fe07da9b52a8103d4a87829fbaae5" translate="yes" xml:space="preserve">
          <source>Target-specific options, such as compiling for a specific processor variant.</source>
          <target state="translated">Специальные опции,такие как компиляция для конкретного варианта процессора.</target>
        </trans-unit>
        <trans-unit id="82a660e45a245ce196b4fdfa2d1b2b50ce849614" translate="yes" xml:space="preserve">
          <source>Tell the MIPS assembler to not run its preprocessor over user assembler files (with a &amp;lsquo;</source>
          <target state="translated">Сообщите ассемблеру MIPS, чтобы он не запускал свой препроцессор над пользовательскими файлами ассемблера (с помощью символа '</target>
        </trans-unit>
        <trans-unit id="68c3b5335b5c0cc22332ebfdb31ac1bb53445273" translate="yes" xml:space="preserve">
          <source>Tells the compiler that any variable marked with the &lt;code&gt;io&lt;/code&gt; attribute is to be considered volatile.</source>
          <target state="translated">Сообщает компилятору, что любая переменная, отмеченная атрибутом &lt;code&gt;io&lt;/code&gt; , должна считаться изменчивой.</target>
        </trans-unit>
        <trans-unit id="6c80eca69977e6b469c44eecba1a817d3b44f7d0" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 24-bit addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="translated">Сказывает компилятору выполнить вызов функции,сначала загрузив адрес функции в регистр,а затем выполнив вызов подпрограмм на этом регистре.Этот переключатель необходим,если целевая функция находится за пределами 24-битного диапазона адресации в смещённой версии команды вызова подпрограммы.</target>
        </trans-unit>
        <trans-unit id="f7974b9f9368d29b382ac1425edcaf88973b1540" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 64-megabyte addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="translated">Сказывает компилятору выполнить вызов функции,сначала загрузив адрес функции в регистр,а затем выполнив вызов подпрограмм на этом регистре.Этот ключ необходим,если целевая функция находится за пределами 64-мегабайтного диапазона адресации в смещенной версии команды вызова подпрограммы.</target>
        </trans-unit>
        <trans-unit id="4035c3eab8e73aa47237d7e7a48fe4ab59208c8f" translate="yes" xml:space="preserve">
          <source>Template Instantiations</source>
          <target state="translated">Образцы шаблонов</target>
        </trans-unit>
        <trans-unit id="eb2cd45b5c86db640ab845c9538624992d63586f" translate="yes" xml:space="preserve">
          <source>Temporaries may vanish before you expect</source>
          <target state="translated">Времена могут исчезнуть раньше,чем вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="9f5670dc2252e3e0202f196c05a183f0e891e7ce" translate="yes" xml:space="preserve">
          <source>Temporary assist register $ta (i.e. $r15).</source>
          <target state="translated">Временный персонал регистрирует $ta (т.е.$r15).</target>
        </trans-unit>
        <trans-unit id="f01689c0a988a52e1980b89817f9a193bf32f058" translate="yes" xml:space="preserve">
          <source>Temporary register r0</source>
          <target state="translated">Временный регистр r0</target>
        </trans-unit>
        <trans-unit id="eb69100c455a5efc5c637f0862041f54fcc63021" translate="yes" xml:space="preserve">
          <source>That code overwrites the variable &lt;code&gt;Index&lt;/code&gt; (&amp;lsquo;</source>
          <target state="translated">Этот код перезаписывает переменную &lt;code&gt;Index&lt;/code&gt; ('</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="3d372c7173ccc49ed5f8266482156df6e30a1a0e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bool&amp;rdquo; version returns &lt;code&gt;true&lt;/code&gt; if the comparison is successful and &lt;var&gt;newval&lt;/var&gt; is written. The &amp;ldquo;val&amp;rdquo; version returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; before the operation.</source>
          <target state="translated">Версия &amp;laquo;bool&amp;raquo; возвращает &lt;code&gt;true&lt;/code&gt; , если сравнение &lt;var&gt;newval&lt;/var&gt; успешно и записано newval . Версия &amp;laquo;val&amp;raquo; возвращает содержимое &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; перед операцией.</target>
        </trans-unit>
        <trans-unit id="09bc8f2a14ab55c654c682384317bfec0642af39" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;signature&amp;rdquo; is a null-terminated string, composed of the following:</source>
          <target state="translated">&amp;laquo;Подпись&amp;raquo; - это строка с нулевым символом в конце, состоящая из следующего:</target>
        </trans-unit>
        <trans-unit id="4c06e97499a27f0f80d31e89637ece588d8ec278" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;user time&amp;rdquo; and the &amp;ldquo;system time&amp;rdquo; are moved before the program name, and the options passed to the program are displayed, so that one can later tell what file was being compiled, and with which options.</source>
          <target state="translated">&amp;laquo;Время пользователя&amp;raquo; и &amp;laquo;системное время&amp;raquo; перемещаются перед именем программы, и отображаются параметры, переданные программе, так что впоследствии можно будет узнать, какой файл компилировался и с какими параметрами.</target>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="9820649111d032078a2e341b12a064c77a65bbc2" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R10&lt;/code&gt; register.</source>
          <target state="translated">16-битный регистр &lt;code&gt;R10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cd88b0aaf75b51696b24c3768a2b1a20915edac" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R8&lt;/code&gt; register.</source>
          <target state="translated">16-битный регистр &lt;code&gt;R8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1272239002f51f4809e26667c1b13c1b964633d" translate="yes" xml:space="preserve">
          <source>The 1998 ISO C++ standard plus the 2003 technical corrigendum and some additional defect reports. Same as</source>
          <target state="translated">Стандарт ИСО С++1998 года,а также техническое исправление 2003 года и некоторые дополнительные отчеты о дефектах.То же самое,что и</target>
        </trans-unit>
        <trans-unit id="cfd06b261fe64d273c59c563a73adcb4a19fda6b" translate="yes" xml:space="preserve">
          <source>The 2011 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">Стандарт ISO C ++ 2011 года плюс поправки. Имя '</target>
        </trans-unit>
        <trans-unit id="e0824fd4223b0cb3aeed48d8b77f3a1b17acde06" translate="yes" xml:space="preserve">
          <source>The 2014 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">Стандарт ISO C ++ 2014 г. плюс поправки. Имя '</target>
        </trans-unit>
        <trans-unit id="d75bfd00cf21586d8e597fcc9ed0b86883eb1dfa" translate="yes" xml:space="preserve">
          <source>The 2017 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">Стандарт ISO C ++ 2017 плюс поправки. Имя '</target>
        </trans-unit>
        <trans-unit id="9e4484fd6590cd7f36b6fdf94168a5387d0e46c3" translate="yes" xml:space="preserve">
          <source>The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in this structure:</source>
          <target state="translated">GCC серий 4.1, 4.2 и 4.3 игнорирует &lt;code&gt;packed&lt;/code&gt; атрибут в битовых полях типа &lt;code&gt;char&lt;/code&gt; . Это было исправлено в GCC 4.4, но изменение может привести к различиям в структуре структуры. GCC сообщает вам, когда смещение такого поля изменилось в GCC 4.4. Например, в этой структуре больше нет 4-битного заполнения между полями &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8937102670278bcd3018a5a5c9e549b76146be93" translate="yes" xml:space="preserve">
          <source>The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This was fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in this structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909967fe10a21a246a86aeb337d0842e478f43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;cc&quot;&lt;/code&gt; clobber indicates that the assembler code modifies the flags register. On some machines, GCC represents the condition codes as a specific hardware register; &lt;code&gt;&quot;cc&quot;&lt;/code&gt; serves to name this register. On other machines, condition code handling is different, and specifying &lt;code&gt;&quot;cc&quot;&lt;/code&gt; has no effect. But it is valid no matter what the target.</source>
          <target state="translated">&lt;code&gt;&quot;cc&quot;&lt;/code&gt; колошматить указывает на то, что ассемблерный код модифицирует регистр флагов. На некоторых машинах GCC представляет коды условий в виде специального аппаратного регистра; &lt;code&gt;&quot;cc&quot;&lt;/code&gt; служит для обозначения этого регистра. На других машинах обработка кода условия отличается, и указание &lt;code&gt;&quot;cc&quot;&lt;/code&gt; имеет никакого эффекта. Но это действительно независимо от цели.</target>
        </trans-unit>
        <trans-unit id="f2534a799a74c45e086749f66cd7d314d0f206ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the &lt;code&gt;asm&lt;/code&gt;. Further, the compiler does not assume that any values read from memory before an &lt;code&gt;asm&lt;/code&gt; remain unchanged after that &lt;code&gt;asm&lt;/code&gt;; it reloads them as needed. Using the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber effectively forms a read/write memory barrier for the compiler.</source>
          <target state="translated">&lt;code&gt;&quot;memory&quot;&lt;/code&gt; колошматить сообщает компилятору , что код выполняет память сборки считывает или записывает на другие , чем те , которые перечислены в входных и выходных операндов элементов (например, доступ к памяти , на который указывает один из входных параметров). Чтобы гарантировать, что память содержит правильные значения, GCC может потребоваться сбросить определенные значения регистров в память перед выполнением &lt;code&gt;asm&lt;/code&gt; . Кроме того, компилятор не предполагает, что какие-либо значения, считанные из памяти перед &lt;code&gt;asm&lt;/code&gt; , останутся неизменными после этого &lt;code&gt;asm&lt;/code&gt; ; он перезагружает их по мере необходимости. Использование затирающего устройства &lt;code&gt;&quot;memory&quot;&lt;/code&gt; эффективно формирует барьер памяти для чтения / записи для компилятора.</target>
        </trans-unit>
        <trans-unit id="287b2b66c9a7de19b9dd84de221d8d45c3b97aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#pragma GCC target&lt;/code&gt; pragma is presently implemented for x86, ARM, AArch64, PowerPC, S/390, and Nios II targets only.</source>
          <target state="translated">&lt;code&gt;#pragma GCC target&lt;/code&gt; прагма в настоящее время реализована для x86, ARM, AArch64, PowerPC, S / 390, а также цели Nios II только.</target>
        </trans-unit>
        <trans-unit id="3ccfce523413ade3933dc06559f7495350ab0dd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; expressions for the same label might have different values if the containing function is inlined or cloned. If a program relies on them being always the same, &lt;code&gt;__attribute__((__noinline__,__noclone__))&lt;/code&gt; should be used to prevent inlining and cloning. If &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; is used in a static variable initializer, inlining and cloning is forbidden.</source>
          <target state="translated">В &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; выражения для одной метки могут иметь разные значения , если функция Содержащий встраиваемыми или клонированные. Если программа полагается на то, что они всегда одинаковы, следует использовать &lt;code&gt;__attribute__((__noinline__,__noclone__))&lt;/code&gt; для предотвращения встраивания и клонирования. Если &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; используется в инициализаторе статической переменной, встраивание и клонирование запрещено.</target>
        </trans-unit>
        <trans-unit id="33e1502637058c6ab49c207cf28a3e3142aca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; implementation in the GNU runtime guarantees you the following things:</source>
          <target state="translated">Реализация &lt;code&gt;+load&lt;/code&gt; в среде выполнения GNU гарантирует вам следующее:</target>
        </trans-unit>
        <trans-unit id="91dd9757303b9f56bf3b6cb9119e24fe8a8727f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; is a method that is not overridden by categories. If a class and a category of it both implement &lt;code&gt;+load&lt;/code&gt;, both methods are invoked. This allows some additional initializations to be performed in a category.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; представляет собой метод , который не переопределен по категориям. Если и класс, и его категория реализуют &lt;code&gt;+load&lt;/code&gt; , вызываются оба метода. Это позволяет выполнять некоторые дополнительные инициализации в категории.</target>
        </trans-unit>
        <trans-unit id="772d2fc6151afb4fb1792207ec49f4a45839a16b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; method is also invoked when a bundle is dynamically loaded into your running program. This happens automatically without any intervening operation from you. When you write bundles and you need to write &lt;code&gt;+load&lt;/code&gt; you can safely create and send messages to objects whose classes already exist in the running program. The same restrictions as above apply to classes defined in bundle.</source>
          <target state="translated">Метод &lt;code&gt;+load&lt;/code&gt; также вызывается, когда пакет динамически загружается в вашу запущенную программу. Это происходит автоматически, без каких-либо действий с вашей стороны. Когда вы пишете пакеты и вам нужно написать &lt;code&gt;+load&lt;/code&gt; , вы можете безопасно создавать и отправлять сообщения объектам, классы которых уже существуют в запущенной программе. Те же ограничения, что и выше, применяются к классам, определенным в bundle.</target>
        </trans-unit>
        <trans-unit id="dc6d2c3cb15d85f1417842f0fbdf998d14486ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods thusly generated only operate on instance variables declared in the current Objective-C class, and not those inherited from superclasses. It is the responsibility of the Objective-C runtime to invoke all such methods in an object&amp;rsquo;s inheritance hierarchy. The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; methods are invoked by the runtime immediately after a new object instance is allocated; the &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods are invoked immediately before the runtime deallocates an object instance.</source>
          <target state="translated">Таким образом сгенерированные методы &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; и &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; работают только с переменными экземпляра, объявленными в текущем классе Objective-C, а не с теми, которые унаследованы от суперклассов. Среда выполнения Objective-C отвечает за вызов всех таких методов в иерархии наследования объекта. В &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; методы вызываются средой выполнения сразу после того, как новый экземпляр объекта выделяется; &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; методы вызываются непосредственно перед среда выполнения освобождает экземпляр объекта.</target>
        </trans-unit>
        <trans-unit id="e7108ce8eed259a604477fdf012b421d600214df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@finally&lt;/code&gt; clause, if present, will be executed upon exit from the immediately preceding &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section. This will happen regardless of whether any exceptions are thrown, caught or rethrown inside the &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section, analogously to the behavior of the &lt;code&gt;finally&lt;/code&gt; clause in Java.</source>
          <target state="translated">Предложение &lt;code&gt;@finally&lt;/code&gt; , если оно присутствует, будет выполнено при выходе из непосредственно предшествующего &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; . Это произойдет независимо от того, генерируются ли какие-либо исключения, перехватываются или повторно генерируются внутри &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; , аналогично поведению предложения &lt;code&gt;finally&lt;/code&gt; в Java.</target>
        </trans-unit>
        <trans-unit id="478f5300c419fd9f1ddbebddc4f1aa8b783e2f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@throw&lt;/code&gt; statement may appear anywhere in an Objective-C or Objective-C++ program; when used inside of a &lt;code&gt;@catch&lt;/code&gt; block, the &lt;code&gt;@throw&lt;/code&gt; may appear without an argument (as shown above), in which case the object caught by the &lt;code&gt;@catch&lt;/code&gt; will be rethrown.</source>
          <target state="translated">Оператор &lt;code&gt;@throw&lt;/code&gt; может появляться где угодно в программе Objective-C или Objective-C ++; при использовании внутри блока &lt;code&gt;@catch&lt;/code&gt; &lt;code&gt;@throw&lt;/code&gt; может появляться без аргумента (как показано выше), и в этом случае объект, пойманный &lt;code&gt;@catch&lt;/code&gt; , будет повторно брошен.</target>
        </trans-unit>
        <trans-unit id="e66bfb70bc3d8564c8867b596c9daf7ef51239bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;A&lt;/code&gt; register.</source>
          <target state="translated">Регистр. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7abbdb5d09af41601d4b6214589f91ad242a72c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AX&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;AX&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="e8869263f41399bf1548d77cd0b06fdeab5b6090" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; регистре.</target>
        </trans-unit>
        <trans-unit id="00b8662f23339aa40fc33f83b8bce9ef615fd089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BC&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;BC&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="fafb503a49e3e2b7cffac8865ce407955e8ba5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; регистром.</target>
        </trans-unit>
        <trans-unit id="c945285a14de09364b5e9d34fc7e6e4e9171bb55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;D&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; регистра.</target>
        </trans-unit>
        <trans-unit id="f334445b19ebbcdfd81f6a6a62d0c7c6a38f5f11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DE&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;DE&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="84d9046824f2223a9b4a7038c1fdd6a7981413ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;E&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="5f8a2094444afcd8a79b22ed65059e8f2a29f862" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;H&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;H&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="2d1c2a880567113429c4b1cc1d7e5ee3f5c01334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HL&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;HL&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="eb2a84b1e54ac92e546337e928dcc83ba5c11f03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;L&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="d88299e2896aeb367bb70fd25b9a5db675642c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable specifies character classification. GCC uses it to determine the character boundaries in a string; this is needed for some multibyte encodings that contain quote and escape characters that are otherwise interpreted as a string end or escape.</source>
          <target state="translated">В &lt;code&gt;LC_CTYPE&lt;/code&gt; характер переменной окружения определяет , классификация. GCC использует его для определения границ символов в строке; это необходимо для некоторых многобайтовых кодировок, содержащих кавычки и escape-символы, которые иначе интерпретируются как конец строки или escape.</target>
        </trans-unit>
        <trans-unit id="fd95cbfac63c17d00419fc1cfbc5f410bf724a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_MESSAGES&lt;/code&gt; environment variable specifies the language to use in diagnostic messages.</source>
          <target state="translated">&lt;code&gt;LC_MESSAGES&lt;/code&gt; переменной среды определяет язык для использования в диагностических сообщениях.</target>
        </trans-unit>
        <trans-unit id="59d7ad50b2abf1611438129375bb15e01da761cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_main&lt;/code&gt; attribute can be used when there &lt;em&gt;is guarantee&lt;/em&gt; that interrupts are disabled at the time when the function is entered. This saves resources when the stack pointer has to be changed to set up a frame for local variables.</source>
          <target state="translated">&lt;code&gt;OS_main&lt;/code&gt; атрибут может быть использован , когда есть &lt;em&gt;гарантия&lt;/em&gt; , что прерывания отключены в то время , когда функция ввода. Это экономит ресурсы, когда нужно изменить указатель стека, чтобы настроить фрейм для локальных переменных.</target>
        </trans-unit>
        <trans-unit id="20f1e35a5360b1f14267221fb24f61e47178d10d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_task&lt;/code&gt; attribute can be used when there is &lt;em&gt;no guarantee&lt;/em&gt; that interrupts are disabled at that time when the function is entered like for, e.g. task functions in a multi-threading operating system. In that case, changing the stack pointer register is guarded by save/clear/restore of the global interrupt enable flag.</source>
          <target state="translated">&lt;code&gt;OS_task&lt;/code&gt; атрибут может быть использован , когда нет &lt;em&gt;никакой гарантии&lt;/em&gt; , что прерывания отключены в то время , когда функция вводятся как для, например , функции задач в многопоточной операционной системе. В этом случае изменение регистра указателя стека охраняется сохранением / очисткой / восстановлением глобального флага разрешения прерывания.</target>
        </trans-unit>
        <trans-unit id="973b834abbbf1594a420dbfab9c679298adbbcc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PSW&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;PSW&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="03b6c46fda7548d67fe293013e4597e13b6cc3ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SP&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;SP&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="77c3ff8f2bcfaf9382aab427535123ecf6e87b0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="f7925d7fc0ef32aa9ba1ce9e18d90f31a2b1041d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Float128&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported or where &lt;code&gt;long double&lt;/code&gt; has the IEEE binary128 format. The &lt;code&gt;_Float64x&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported. The &lt;code&gt;_Float32&lt;/code&gt; type is supported on all systems supporting IEEE binary32; the &lt;code&gt;_Float64&lt;/code&gt; and &lt;code&gt;_Float32x&lt;/code&gt; types are supported on all systems supporting IEEE binary64. The &lt;code&gt;_Float16&lt;/code&gt; type is supported on AArch64 systems by default, and on ARM systems when the IEEE format for 16-bit floating-point types is selected with</source>
          <target state="translated">Тип &lt;code&gt;_Float128&lt;/code&gt; поддерживается во всех системах, где поддерживается &lt;code&gt;__float128&lt;/code&gt; или где &lt;code&gt;long double&lt;/code&gt; имеет формат IEEE binary128. Тип &lt;code&gt;_Float64x&lt;/code&gt; поддерживается во всех системах, где поддерживается &lt;code&gt;__float128&lt;/code&gt; . Тип &lt;code&gt;_Float32&lt;/code&gt; поддерживается во всех системах, поддерживающих IEEE binary32; в &lt;code&gt;_Float64&lt;/code&gt; и &lt;code&gt;_Float32x&lt;/code&gt; типы поддерживаются на всех системах , поддерживающих IEEE binary64. Тип &lt;code&gt;_Float16&lt;/code&gt; поддерживается в системах AArch64 по умолчанию и в системах ARM, когда формат IEEE для 16-битных типов с плавающей запятой выбран с помощью</target>
        </trans-unit>
        <trans-unit id="85103cf2482f16ae09dc93810b2ec0258970e808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_HTM_FIRST_USER_ABORT_CODE&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; specifies the first abort code which can be used for &lt;code&gt;__builtin_tabort&lt;/code&gt;. Values below this threshold are reserved for machine use.</source>
          <target state="translated">&lt;code&gt;_HTM_FIRST_USER_ABORT_CODE&lt;/code&gt; определено в &lt;code&gt;htmintrin.h&lt;/code&gt; определяет первый код отмены , который может быть использован для &lt;code&gt;__builtin_tabort&lt;/code&gt; . Значения ниже этого порога зарезервированы для машинного использования.</target>
        </trans-unit>
        <trans-unit id="392542e4dc2c75d48ed6b1e9e4e666156b2ab35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses.</source>
          <target state="translated">За ключевым словом &lt;code&gt;__attribute__&lt;/code&gt; следует спецификация атрибута, заключенная в двойные круглые скобки.</target>
        </trans-unit>
        <trans-unit id="0f8acb405a5cf121cc5773d2c4339fe65a77bcf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The object is aligned on the default stack alignment boundary for the target determined by the &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; macro. The &lt;code&gt;__builtin_alloca&lt;/code&gt; function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends just before the calling function returns to its caller. This is so even when &lt;code&gt;__builtin_alloca&lt;/code&gt; is called within a nested block.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_alloca&lt;/code&gt; должна вызываться в области блока. Функция выделяет объект &lt;var&gt;size&lt;/var&gt; байтах в стеке вызывающей функции. Объект выравнивается по границе выравнивания стека по умолчанию для цели, определенной &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; . Функция &lt;code&gt;__builtin_alloca&lt;/code&gt; возвращает указатель на первый байт выделенного объекта. Время жизни выделенного объекта заканчивается непосредственно перед тем, как вызывающая функция вернется к вызывающей стороне. Это так даже тогда, когда &lt;code&gt;__builtin_alloca&lt;/code&gt; вызывается внутри вложенного блока.</target>
        </trans-unit>
        <trans-unit id="699047c637b673c64e86fa3b74734bf759b728ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The allocated object is aligned on the boundary specified by the argument &lt;var&gt;alignment&lt;/var&gt; whose unit is given in bits (not bytes). The &lt;var&gt;size&lt;/var&gt; argument must be positive and not exceed the stack size limit. The &lt;var&gt;alignment&lt;/var&gt; argument must be a constant integer expression that evaluates to a power of 2 greater than or equal to &lt;code&gt;CHAR_BIT&lt;/code&gt; and less than some unspecified maximum. Invocations with other values are rejected with an error indicating the valid bounds. The function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends at the end of the block in which the function was called. The allocated storage is released no later than just before the calling function returns to its caller, but may be released at the end of the block in which the function was called.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; должна вызываться в области блока. Функция выделяет объект &lt;var&gt;size&lt;/var&gt; байтах в стеке вызывающей функции. Выделенный объект выравнивается по границе, заданной &lt;var&gt;alignment&lt;/var&gt; аргумента , единица которого задается в битах (а не в байтах). &lt;var&gt;size&lt;/var&gt; аргумент должен быть положительным и не превышать предельный размер стека. &lt;var&gt;alignment&lt;/var&gt; аргумент должен быть целочисленным выражением константы , которая вычисляется в силу-больше или равно к &lt;code&gt;CHAR_BIT&lt;/code&gt; и меньше некоторого неустановленного максимума. Вызовы с другими значениями отклоняются с ошибкой, указывающей допустимые границы. Функция возвращает указатель на первый байт выделенного объекта. Время жизни выделенного объекта заканчивается в конце блока, в котором была вызвана функция. Выделенная память освобождается не позднее, чем непосредственно перед тем, как вызывающая функция вернется к своему вызывающему, но может быть освобождена в конце блока, в котором функция была вызвана.</target>
        </trans-unit>
        <trans-unit id="d14b3efa7fa2847225bae57a72e4dc716953742d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; and &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; require an environment supporting ISA 3.0 or later. For these two functions, the &lt;code&gt;range&lt;/code&gt; argument is encoded as 4 bytes, organized as &lt;code&gt;hi_1:lo_1:hi_2:lo_2&lt;/code&gt;. The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument is within the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive. The &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; function returns non-zero if and only if its &lt;code&gt;u&lt;/code&gt; argument is within either the range bounded between &lt;code&gt;lo_1&lt;/code&gt; and &lt;code&gt;hi_1&lt;/code&gt; inclusive or the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive.</source>
          <target state="translated">Для &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; и &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; требуется среда, поддерживающая ISA 3.0 или новее. Для этих двух функций аргумент &lt;code&gt;range&lt;/code&gt; закодирован как 4 байта, организованных как &lt;code&gt;hi_1:lo_1:hi_2:lo_2&lt;/code&gt; . Функция &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; возвращает ненулевое значение тогда и только тогда, когда ее аргумент &lt;code&gt;u&lt;/code&gt; находится в диапазоне, ограниченном от &lt;code&gt;lo_2&lt;/code&gt; до &lt;code&gt;hi_2&lt;/code&gt; включительно. Функция &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; возвращает ненулевое значение тогда и только тогда, когда ее аргумент &lt;code&gt;u&lt;/code&gt; находится в пределах диапазона, ограниченного между &lt;code&gt;lo_1&lt;/code&gt; и &lt;code&gt;hi_1&lt;/code&gt; .включительно или диапазон, ограниченный от &lt;code&gt;lo_2&lt;/code&gt; до &lt;code&gt;hi_2&lt;/code&gt; включительно.</target>
        </trans-unit>
        <trans-unit id="e9c90a92a294d6da36a67b6812f4d7f784a68c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_set&lt;/code&gt; function requires a 64-bit environment supporting ISA 3.0 or later. This function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument exactly equals one of the eight bytes contained within its 64-bit &lt;code&gt;set&lt;/code&gt; argument.</source>
          <target state="translated">Для функции &lt;code&gt;__builtin_byte_in_set&lt;/code&gt; требуется 64-разрядная среда, поддерживающая ISA 3.0 или новее. Эта функция возвращает ненулевое значение тогда и только тогда, когда ее аргумент &lt;code&gt;u&lt;/code&gt; точно равен одному из восьми байтов, содержащихся в ее 64-битном аргументе &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb729367b3d36e784ee118ae00a98821f8cbe5c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cmpb&lt;/code&gt; function performs a byte-wise compare on the contents of its two arguments, returning the result of the byte-wise comparison as the returned value. For each byte comparison, the corresponding byte of the return value holds 0xff if the input bytes are equal and 0 if the input bytes are not equal. If either of the arguments to this built-in function is wider than 32 bits, the function call expands into the form that expects &lt;code&gt;unsigned long long int&lt;/code&gt; arguments which is only available on 64-bit targets.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_cmpb&lt;/code&gt; выполняет побайтовое сравнение содержимого двух своих аргументов, возвращая результат побайтного сравнения в качестве возвращаемого значения. Для каждого сравнения байтов соответствующий байт возвращаемого значения содержит 0xff, если входные байты равны, и 0, если входные байты не равны. Если любой из аргументов этой встроенной функции превышает 32 бита, вызов функции разворачивается в форму, которая ожидает аргументы типа &lt;code&gt;unsigned long long int&lt;/code&gt; , которые доступны только для 64-битных целей.</target>
        </trans-unit>
        <trans-unit id="26cf6e5166e71a9dc3d72ae3910f453428861ff1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_is&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="translated">Для функции &lt;code&gt;__builtin_cpu_is&lt;/code&gt; требуется GLIBC 2.23 или новее, которая экспортирует биты возможностей оборудования. GCC определяет макрос &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; , если встроенная функция &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; полностью поддерживается.</target>
        </trans-unit>
        <trans-unit id="225ecb4eafc9e778fee170a226e93b379e52b096" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="translated">Для функции &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; требуется GLIBC 2.23 или новее, которая экспортирует биты возможностей оборудования. GCC определяет макрос &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; , если встроенная функция &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; полностью поддерживается.</target>
        </trans-unit>
        <trans-unit id="9d549e750824586a0354c272406d5e4e5816a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_darn&lt;/code&gt; and &lt;code&gt;__builtin_darn_raw&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;__builtin_darn&lt;/code&gt; function provides a 64-bit conditioned random number. The &lt;code&gt;__builtin_darn_raw&lt;/code&gt; function provides a 64-bit raw random number. The &lt;code&gt;__builtin_darn_32&lt;/code&gt; function provides a 32-bit conditioned random number.</source>
          <target state="translated">Для функций &lt;code&gt;__builtin_darn&lt;/code&gt; и &lt;code&gt;__builtin_darn_raw&lt;/code&gt; требуется 64-разрядная среда, поддерживающая ISA 3.0 или новее. Функция &lt;code&gt;__builtin_darn&lt;/code&gt; предоставляет 64-битное условное случайное число. Функция &lt;code&gt;__builtin_darn_raw&lt;/code&gt; предоставляет 64-битное необработанное случайное число. Функция &lt;code&gt;__builtin_darn_32&lt;/code&gt; предоставляет 32-битное условное случайное число.</target>
        </trans-unit>
        <trans-unit id="fc4f02a6f5765f9e617ea8ee9a4170e4b962d403" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_eq&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument equals its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_eq_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_eq_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_dfp_dtstsfi_eq&lt;/code&gt; возвращает ненулевое значение тогда и только тогда, когда количество значащих цифр ее аргумента &lt;code&gt;value&lt;/code&gt; равно его аргументу &lt;code&gt;comparison&lt;/code&gt; . Функции &lt;code&gt;__builtin_dfp_dtstsfi_eq_dd&lt;/code&gt; и &lt;code&gt;__builtin_dfp_dtstsfi_eq_td&lt;/code&gt; ведут себя аналогичным образом, но требуют, чтобы тип аргумента &lt;code&gt;value&lt;/code&gt; был &lt;code&gt;__Decimal64&lt;/code&gt; и &lt;code&gt;__Decimal128&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="57591fb5134dd8d315ee0a2d1522ee30d9827c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_gt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is greater than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_gt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_gt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_dfp_dtstsfi_gt&lt;/code&gt; возвращает ненулевое значение тогда и только тогда, когда количество значащих цифр в аргументе &lt;code&gt;value&lt;/code&gt; больше, чем в аргументе &lt;code&gt;comparison&lt;/code&gt; . Функции &lt;code&gt;__builtin_dfp_dtstsfi_gt_dd&lt;/code&gt; и &lt;code&gt;__builtin_dfp_dtstsfi_gt_td&lt;/code&gt; ведут себя аналогично, но требуют, чтобы тип аргумента &lt;code&gt;value&lt;/code&gt; был &lt;code&gt;__Decimal64&lt;/code&gt; и &lt;code&gt;__Decimal128&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="b01dbf5e64c194eb164595e23ee9b740573ded8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_lt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is less than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_lt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_lt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_dfp_dtstsfi_lt&lt;/code&gt; возвращает ненулевое значение тогда и только тогда, когда количество значащих цифр в аргументе &lt;code&gt;value&lt;/code&gt; меньше, чем в аргументе &lt;code&gt;comparison&lt;/code&gt; . Функции &lt;code&gt;__builtin_dfp_dtstsfi_lt_dd&lt;/code&gt; и &lt;code&gt;__builtin_dfp_dtstsfi_lt_td&lt;/code&gt; ведут себя аналогично, но требуют, чтобы тип аргумента &lt;code&gt;value&lt;/code&gt; был &lt;code&gt;__Decimal64&lt;/code&gt; и &lt;code&gt;__Decimal128&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="b4420e5d860b7c4bb7ba6d7a8d1a6213bfe7043a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_ov&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;value&lt;/code&gt; argument has an undefined number of significant digits, such as when &lt;code&gt;value&lt;/code&gt; is an encoding of &lt;code&gt;NaN&lt;/code&gt;. The &lt;code&gt;__builtin_dfp_dtstsfi_ov_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_ov_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_dfp_dtstsfi_ov&lt;/code&gt; возвращает ненулевое значение тогда и только тогда, когда ее аргумент &lt;code&gt;value&lt;/code&gt; имеет неопределенное количество значащих цифр, например, когда &lt;code&gt;value&lt;/code&gt; является кодировкой &lt;code&gt;NaN&lt;/code&gt; . Функции &lt;code&gt;__builtin_dfp_dtstsfi_ov_dd&lt;/code&gt; и &lt;code&gt;__builtin_dfp_dtstsfi_ov_td&lt;/code&gt; ведут себя аналогично, но требуют, чтобы тип аргумента &lt;code&gt;value&lt;/code&gt; был &lt;code&gt;__Decimal64&lt;/code&gt; и &lt;code&gt;__Decimal128&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="a0bfeb225a5faf6d6577d095e4bb9f94249f0a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function evaluates to an integer constant expression equal to &lt;code&gt;true&lt;/code&gt; if the symbol or type referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument has been declared with the &lt;var&gt;attribute&lt;/var&gt; referenced by the second argument. For an &lt;var&gt;type-or-expression&lt;/var&gt; argument that does not reference a symbol, since attributes do not apply to expressions the built-in consider the type of the argument. Neither argument is evaluated. The &lt;var&gt;type-or-expression&lt;/var&gt; argument is subject to the same restrictions as the argument to &lt;code&gt;typeof&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;). The &lt;var&gt;attribute&lt;/var&gt; argument is an attribute name optionally followed by a comma-separated list of arguments enclosed in parentheses. Both forms of attribute names&amp;mdash;with and without double leading and trailing underscores&amp;mdash;are recognized. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details. When no attribute arguments are specified for an attribute that expects one or more arguments the function returns &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;type-or-expression&lt;/var&gt; has been declared with the attribute regardless of the attribute argument values. Arguments provided for an attribute that expects some are validated and matched up to the provided number. The function returns &lt;code&gt;true&lt;/code&gt; if all provided arguments match. For example, the first call to the function below evaluates to &lt;code&gt;true&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared with the &lt;code&gt;aligned&lt;/code&gt; attribute but the second call evaluates to &lt;code&gt;false&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared &lt;code&gt;aligned (8)&lt;/code&gt; and not &lt;code&gt;aligned (4)&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_has_attribute&lt;/code&gt; оценивает целочисленное постоянное выражение, равное &lt;code&gt;true&lt;/code&gt; , если символ или тип, на которые ссылается аргумент &lt;var&gt;type-or-expression&lt;/var&gt; , был объявлен с &lt;var&gt;attribute&lt;/var&gt; ссылается второй аргумент. Для аргумента &lt;var&gt;type-or-expression&lt;/var&gt; , который не ссылается на символ, поскольку атрибуты не применяются к выражениям, встроенная функция учитывает тип аргумента. Ни один из аргументов не оценивается. &lt;var&gt;type-or-expression&lt;/var&gt; аргумент распространяются те же ограничения в качестве аргумента &lt;code&gt;typeof&lt;/code&gt; (см &lt;a href=&quot;typeof#Typeof&quot;&gt;TypeOf&lt;/a&gt; ). &lt;var&gt;attribute&lt;/var&gt; Аргумент - это имя атрибута, за которым может следовать список аргументов, разделенных запятыми, заключенный в круглые скобки. Обе формы имен атрибутов - с двойным начальным и конечным подчеркиванием и без них - распознаются. Подробнее см. &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Синтаксис атрибутов&lt;/a&gt; . Если аргументы атрибута не указаны для атрибута, который ожидает один или несколько аргументов, функция возвращает &lt;code&gt;true&lt;/code&gt; если &lt;var&gt;type-or-expression&lt;/var&gt; были объявлены с атрибутом независимо от значений аргументов атрибута. Аргументы, предоставленные для атрибута, который ожидает некоторые из них, проверяются и сопоставляются с предоставленным числом. Функция возвращает &lt;code&gt;true&lt;/code&gt; если все предоставленные аргументы совпадают. Например, первый вызов функции ниже оценивается как &lt;code&gt;true&lt;/code&gt; поскольку &lt;code&gt;x&lt;/code&gt; объявлен с атрибутом &lt;code&gt;aligned&lt;/code&gt; но второй вызов оценивается как &lt;code&gt;false&lt;/code&gt; , потому что &lt;code&gt;x&lt;/code&gt; объявлен &lt;code&gt;aligned (8)&lt;/code&gt; а не &lt;code&gt;aligned (4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cbfc7ec73fa262c76440a5134fc2d0584d6a4cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_is_constant_evaluated&lt;/code&gt; function is available only in C++. The built-in is intended to be used by implementations of the &lt;code&gt;std::is_constant_evaluated&lt;/code&gt; C++ function. Programs should make use of the latter function rather than invoking the built-in directly.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_is_constant_evaluated&lt;/code&gt; доступна только в C ++. Встроенная функция предназначена для использования в реализациях функции &lt;code&gt;std::is_constant_evaluated&lt;/code&gt; C ++. Программы должны использовать последнюю функцию, а не напрямую вызывать встроенную.</target>
        </trans-unit>
        <trans-unit id="8c4494406f2455746a4c649b18a2c01e01f2fd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_mffsl&lt;/code&gt; uses the ISA 3.0 &lt;code&gt;mffsl&lt;/code&gt; instruction to read the FPSCR. The instruction is a lower latency version of the &lt;code&gt;mffs&lt;/code&gt; instruction. If the &lt;code&gt;mffsl&lt;/code&gt; instruction is not available, then the builtin uses the older &lt;code&gt;mffs&lt;/code&gt; instruction to read the FPSCR.</source>
          <target state="translated">&lt;code&gt;__builtin_mffsl&lt;/code&gt; использует ISA 3,0 &lt;code&gt;mffsl&lt;/code&gt; инструкцию читать FPSCR. Эта инструкция представляет собой версию инструкции &lt;code&gt;mffs&lt;/code&gt; с меньшей задержкой . Если инструкция &lt;code&gt;mffsl&lt;/code&gt; недоступна, то встроенная программа использует старую инструкцию &lt;code&gt;mffs&lt;/code&gt; для чтения FPSCR.</target>
        </trans-unit>
        <trans-unit id="1c6f10224f071b484a2f23cb973dde539bd04b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_ibm128&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;__ibm128&lt;/code&gt; value that combines the two arguments.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_pack_ibm128&lt;/code&gt; принимает два аргумента типа &lt;code&gt;double&lt;/code&gt; и возвращает значение &lt;code&gt;__ibm128&lt;/code&gt; , которое объединяет эти два аргумента.</target>
        </trans-unit>
        <trans-unit id="ce45c9f46fdb649818045c7651274a51c7c9b814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;long double&lt;/code&gt; value that combines the two arguments. The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; принимает два аргумента типа &lt;code&gt;double&lt;/code&gt; и возвращает &lt;code&gt;long double&lt;/code&gt; значение типа double , объединяющее эти два аргумента. Функция &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; доступна, только если &lt;code&gt;long double&lt;/code&gt; использует расширенное двойное представление IBM.</target>
        </trans-unit>
        <trans-unit id="8465d06a8e70b59990aa3c2108eef59db7b2906e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; and &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; functions generate instructions to read the Time Base Register. The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; function may generate multiple instructions and always returns the 64 bits of the Time Base Register. The &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; function always generates one instruction and returns the Time Base Register value as an unsigned long, throwing away the most significant word on 32-bit environments. The &lt;code&gt;__builtin_mffs&lt;/code&gt; return the value of the FPSCR register. Note, ISA 3.0 supports the &lt;code&gt;__builtin_mffsl()&lt;/code&gt; which permits software to read the control and non-sticky status bits in the FSPCR without the higher latency associated with accessing the sticky status bits. The &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; and &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; take the bit to change as an argument. The valid bit range is between 0 and 31. The builtins map to the &lt;code&gt;mtfsb0&lt;/code&gt; and &lt;code&gt;mtfsb1&lt;/code&gt; instructions which take the argument and add 32. Hence these instructions only modify the FPSCR[32:63] bits by changing the specified bit to a zero or one respectively. The &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; builtin allows changing both of the floating point rounding mode bits. The argument is a 2-bit value. The argument can either be a &lt;code&gt;const int&lt;/code&gt; or stored in a variable. The builtin uses the ISA 3.0 instruction &lt;code&gt;mffscrn&lt;/code&gt; if available, otherwise it reads the FPSCR, masks the current rounding mode bits out and OR&amp;rsquo;s in the new value.</source>
          <target state="translated">Функции &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; и &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; генерируют инструкции для чтения регистра временной базы. Функция &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; может генерировать несколько инструкций и всегда возвращает 64 бита регистра временной базы. Функция &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; всегда генерирует одну инструкцию и возвращает значение регистра временной базы в виде длинного числа без знака, отбрасывая старшее слово в 32-битных средах. В &lt;code&gt;__builtin_mffs&lt;/code&gt; возвращает значение регистра FPSCR. Обратите внимание, ISA 3.0 поддерживает &lt;code&gt;__builtin_mffsl()&lt;/code&gt; который позволяет программному обеспечению считывать управляющие и незакрепляющие биты состояния в FSPCR без более высокой задержки, связанной с доступом к закрепленным битам состояния. &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; и &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; закусить изменения в качестве аргумента. Допустимый битовый диапазон - от 0 до 31. &lt;code&gt;mtfsb1&lt;/code&gt; команды сопоставляются с инструкциями &lt;code&gt;mtfsb0&lt;/code&gt; и mtfsb1, которые принимают аргумент и добавляют 32. Следовательно, эти инструкции изменяют только биты FPSCR [32:63], изменяя указанный бит на ноль или единицу. соответственно. &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; встроенный позволяет изменять оба с плавающей точкой округления битов режима. Аргумент - это 2-битное значение. Аргумент может быть либо &lt;code&gt;const int&lt;/code&gt; или хранится в переменной. &lt;code&gt;mffscrn&lt;/code&gt; команда использует команду mffscrn ISA 3.0, если она доступна, в противном случае она считывает FPSCR, маскирует текущие биты режима округления и ИЛИ в новом значении.</target>
        </trans-unit>
        <trans-unit id="f74488ec411590dcc75315f19183a037dc14b9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; and &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; functions generate instructions to read the Time Base Register. The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; function may generate multiple instructions and always returns the 64 bits of the Time Base Register. The &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; function always generates one instruction and returns the Time Base Register value as an unsigned long, throwing away the most significant word on 32-bit environments. The &lt;code&gt;__builtin_mffs&lt;/code&gt; return the value of the FPSCR register. Note, ISA 3.0 supports the &lt;code&gt;__builtin_mffsl()&lt;/code&gt; which permits software to read the control and non-sticky status bits in the FSPCR without the higher latency associated with accessing the sticky status bits. The &lt;code&gt;__builtin_mtfsf&lt;/code&gt; takes a constant 8-bit integer field mask and a double precision floating point argument and generates the &lt;code&gt;mtfsf&lt;/code&gt; (extended mnemonic) instruction to write new values to selected fields of the FPSCR. The &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; and &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; take the bit to change as an argument. The valid bit range is between 0 and 31. The builtins map to the &lt;code&gt;mtfsb0&lt;/code&gt; and &lt;code&gt;mtfsb1&lt;/code&gt; instructions which take the argument and add 32. Hence these instructions only modify the FPSCR[32:63] bits by changing the specified bit to a zero or one respectively. The &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; builtin allows changing both of the floating point rounding mode bits. The argument is a 2-bit value. The argument can either be a &lt;code&gt;const int&lt;/code&gt; or stored in a variable. The builtin uses the ISA 3.0 instruction &lt;code&gt;mffscrn&lt;/code&gt; if available, otherwise it reads the FPSCR, masks the current rounding mode bits out and OR&amp;rsquo;s in the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198788e1a597fcc05831a074890ff7147c3e1998" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_recipdiv&lt;/code&gt;, and &lt;code&gt;__builtin_recipdivf&lt;/code&gt; functions generate multiple instructions to implement division using the reciprocal estimate instructions.</source>
          <target state="translated">Функции &lt;code&gt;__builtin_recipdiv&lt;/code&gt; и &lt;code&gt;__builtin_recipdivf&lt;/code&gt; генерируют несколько инструкций для реализации деления с использованием инструкций обратной оценки.</target>
        </trans-unit>
        <trans-unit id="eca84e06c376750982f7cbde8f6e8edd81f796b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_ibm128&lt;/code&gt; function takes a &lt;code&gt;__ibm128&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;__ibm128&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_unpack_ibm128&lt;/code&gt; принимает аргумент &lt;code&gt;__ibm128&lt;/code&gt; и константу времени компиляции, равную 0 или 1. Если константа равна 0, возвращается первое &lt;code&gt;double&lt;/code&gt; в &lt;code&gt;__ibm128&lt;/code&gt; , в противном случае возвращается второе &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48855b25f6a50b8b8736a064f19a8b37e730a064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function takes a &lt;code&gt;long double&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;long double&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned. The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="translated">Функция &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; принимает аргумент &lt;code&gt;long double&lt;/code&gt; и константу времени компиляции 0 или 1. Если константа равна 0, возвращается первое &lt;code&gt;double&lt;/code&gt; в пределах &lt;code&gt;long double&lt;/code&gt; , в противном случае возвращается второе &lt;code&gt;double&lt;/code&gt; . Функция &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; доступна, только если &lt;code&gt;long double&lt;/code&gt; использует расширенное двойное представление IBM.</target>
        </trans-unit>
        <trans-unit id="cf7f4f10325e1d8819fa9c82ff898e127032c07d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__flash&lt;/code&gt; qualifier locates data in the &lt;code&gt;.progmem.data&lt;/code&gt; section. Data is read using the &lt;code&gt;LPM&lt;/code&gt; instruction. Pointers to this address space are 16 bits wide.</source>
          <target state="translated">&lt;code&gt;__flash&lt;/code&gt; классификатор размещает данные в &lt;code&gt;.progmem.data&lt;/code&gt; разделе. Данные считываются с помощью инструкции &lt;code&gt;LPM&lt;/code&gt; . Указатели на это адресное пространство имеют ширину 16 бит.</target>
        </trans-unit>
        <trans-unit id="097ea3d6342e0a23a9235845e85db17d4022ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__fp16&lt;/code&gt; type may only be used as an argument to intrinsics defined in &lt;code&gt;&amp;lt;arm_fp16.h&amp;gt;&lt;/code&gt;, or as a storage format. For purposes of arithmetic and other operations, &lt;code&gt;__fp16&lt;/code&gt; values in C or C++ expressions are automatically promoted to &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;__fp16&lt;/code&gt; может использоваться только как аргумент для встроенных &lt;code&gt;&amp;lt;arm_fp16.h&amp;gt;&lt;/code&gt; , определенных в &amp;lt;arm_fp16.h&amp;gt; , или как формат хранения. Для арифметических и других операций значения &lt;code&gt;__fp16&lt;/code&gt; в выражениях C или C ++ автоматически переводятся в положение с &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec03917f805a8e50fbb98586530e665bfe69da73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier can be applied only to the names of objects and to anonymous unions.</source>
          <target state="translated">Спецификатор &lt;code&gt;__thread&lt;/code&gt; может применяться только к именам объектов и к анонимным объединениям.</target>
        </trans-unit>
        <trans-unit id="f3af60ab1131c66623c0fb9cd375a6e888cff899" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be applied to any global, file-scoped static, function-scoped static, or static data member of a class. It may not be applied to block-scoped automatic or non-static data member.</source>
          <target state="translated">Спецификатор &lt;code&gt;__thread&lt;/code&gt; может применяться к любому глобальному, статическому элементу данных в области файлов, статическому элементу данных в области функции или статическому члену данных класса. Его нельзя применять к автоматическим или нестатическим элементам данных с блочной областью видимости.</target>
        </trans-unit>
        <trans-unit id="d8177fe879ae4fe2cff503c3513d84606c176b85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, with the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers, but with no other storage class specifier. When used with &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;__thread&lt;/code&gt; must appear immediately after the other storage class specifier.</source>
          <target state="translated">Спецификатор &lt;code&gt;__thread&lt;/code&gt; может использоваться отдельно со спецификаторами &lt;code&gt;extern&lt;/code&gt; или &lt;code&gt;static&lt;/code&gt; , но без другого спецификатора класса хранения. При использовании &lt;code&gt;extern&lt;/code&gt; или &lt;code&gt;static&lt;/code&gt; , &lt;code&gt;__thread&lt;/code&gt; должен появиться сразу после другого класса хранения спецификатора.</target>
        </trans-unit>
        <trans-unit id="63dae9f24b29dc710773ce4dac88b4e87c3c52d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier shall be used only with variables.</source>
          <target state="translated">Спецификатор &lt;code&gt;__thread&lt;/code&gt; должен использоваться только с переменными.</target>
        </trans-unit>
        <trans-unit id="adf603edfc142efac4a9a3b77d51d44293820a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__trampolines_start&lt;/code&gt; symbol is defined in the linker script.</source>
          <target state="translated">Символ &lt;code&gt;__trampolines_start&lt;/code&gt; определен в скрипте компоновщика.</target>
        </trans-unit>
        <trans-unit id="375e8541e5237f24ef902439af8b3c21cd835020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; registers. This class is used for instructions that return double word results in the &lt;code&gt;ax:dx&lt;/code&gt; register pair. Single word values will be allocated either in &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. For example on i386 the following implements &lt;code&gt;rdtsc&lt;/code&gt;:</source>
          <target state="translated">В &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; регистров. Этот класс используется для инструкций, которые возвращают результаты двойного слова в паре регистров &lt;code&gt;ax:dx&lt;/code&gt; . Значения одного слова будут размещены в &lt;code&gt;ax&lt;/code&gt; или &lt;code&gt;dx&lt;/code&gt; . Например, на i386 &lt;code&gt;rdtsc&lt;/code&gt; реализуется следующим образом :</target>
        </trans-unit>
        <trans-unit id="a0d40f91f92592e29ec24cddc648e15fc94fdbdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; register.</source>
          <target state="translated">Регистр. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf9b97f6ebb578cc8aa854722849a8e5b4602c9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abi_tag&lt;/code&gt; attribute can be applied to a function, variable, or class declaration. It modifies the mangled name of the entity to incorporate the tag name, in order to distinguish the function or class from an earlier version with a different ABI; perhaps the class has changed size, or the function has a different return type that is not encoded in the mangled name.</source>
          <target state="translated">&lt;code&gt;abi_tag&lt;/code&gt; атрибут может быть применен к функции, переменной или объявления класса. Он изменяет искаженное имя объекта, чтобы включить имя тега, чтобы отличить функцию или класс от более ранней версии с другим ABI; возможно, класс изменил размер или функция имеет другой тип возвращаемого значения, который не закодирован в искаженном имени.</target>
        </trans-unit>
        <trans-unit id="7fe3aef8751a598cb1fd1f579f51dc2e77fc03d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;access&lt;/code&gt; attribute enables the detection of invalid or unsafe accesses by functions to which they apply or their callers, as well as write-only accesses to objects that are never read from. Such accesses may be diagnosed by warnings such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3485b263c83290ae97682123760b0adc0b05426c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;access&lt;/code&gt; attribute specifies that a function to whose by-reference arguments the attribute applies accesses the referenced object according to &lt;var&gt;access-mode&lt;/var&gt;. The &lt;var&gt;access-mode&lt;/var&gt; argument is required and must be one of three names: &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;read_write&lt;/code&gt;, or &lt;code&gt;write_only&lt;/code&gt;. The remaining two are positional arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecdfed9d96d6be598a27e07d494142206025586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; attribute causes the declaration to be emitted as an alias for another symbol, which must be specified. For instance,</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; атрибут приводит к тому , декларации, издаваемая в качестве псевдонима для другого символа, который должен быть указан. Например,</target>
        </trans-unit>
        <trans-unit id="7e61edae77066dd3dc159fcdac928cd068378010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; attribute causes the declaration to be emitted as an alias for another symbol, which must have been previously declared with the same type, and for variables, also the same size and alignment. Declaring an alias with a different type than the target is undefined and may be diagnosed. As an example, the following declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2be5f23f4d95994e296cf8157df7b27aa96115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; variable attribute causes the declaration to be emitted as an alias for another symbol known as an &lt;em&gt;alias target&lt;/em&gt;. Except for top-level qualifiers the alias target must have the same type as the alias. For instance, the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf61029ae4ce438827c598f61cf786192d3f583" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; атрибут может также использоваться для функций (см &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общих атрибутов функции&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="116110dd4cf7976fa8985541dcc415370c4044c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for variables and fields (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; атрибут может также использоваться для переменных и полей (см &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;атрибутов переменных&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="5b5ae34d39ede17878fd463e5860c5561589d603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment (in bytes) for variables of the specified type. When specified, &lt;var&gt;alignment&lt;/var&gt; must be a power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes. For example, the declarations:</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; атрибут определяет минимальное выравнивание (в байтах) для переменных указанного типа. Если указано, &lt;var&gt;alignment&lt;/var&gt; должно быть степенью 2. Отсутствие аргумента &lt;var&gt;alignment&lt;/var&gt; подразумевает максимальное выравнивание для цели, которое часто, но не всегда, составляет 8 или 16 байтов. Например, объявления:</target>
        </trans-unit>
        <trans-unit id="84a176d406c41abb708c1f3ca71eadfaf0924f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the first instruction of the function, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the ideal alignment for the target. The &lt;code&gt;__alignof__&lt;/code&gt; operator can be used to determine what that is (see &lt;a href=&quot;alignment#Alignment&quot;&gt;Alignment&lt;/a&gt;). The attribute has no effect when a definition for the function is not provided in the same translation unit.</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; атрибут определяет минимальное выравнивание для первой инструкции функции, измеренной в байтах. Если указано, &lt;var&gt;alignment&lt;/var&gt; должно быть целочисленной постоянной степенью 2. Отсутствие аргумента &lt;var&gt;alignment&lt;/var&gt; подразумевает идеальное выравнивание для цели. Оператор &lt;code&gt;__alignof__&lt;/code&gt; может использоваться, чтобы определить, что это такое (см. &lt;a href=&quot;alignment#Alignment&quot;&gt;Выравнивание&lt;/a&gt; ). Атрибут не действует, если определение функции не предоставлено в той же единице перевода.</target>
        </trans-unit>
        <trans-unit id="8ba9bd3f254f0cc2bc69cd8b105c1d09efd2f77c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the variable or structure field, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes.</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; атрибут определяет минимальное выравнивание для поля переменного или структур, которая измеряется в байтах. Если указано, &lt;var&gt;alignment&lt;/var&gt; должно быть целочисленной постоянной степенью 2. Указание отсутствия аргумента &lt;var&gt;alignment&lt;/var&gt; подразумевает максимальное выравнивание для цели, которое часто, но не всегда, составляет 8 или 16 байтов.</target>
        </trans-unit>
        <trans-unit id="f46b2b0bb9e3e850ca63944ddf914702b4818ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_align&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer is aligned on a boundary given by the function argument at &lt;var&gt;position&lt;/var&gt;. Meaningful alignments are powers of 2 greater than one. GCC uses this information to improve pointer alignment analysis.</source>
          <target state="translated">&lt;code&gt;alloc_align&lt;/code&gt; атрибут может быть применен к функции , которая возвращает указатель и принимает по меньшей мере , один аргумент целого числа или пронумерованный типа. Он указывает, что возвращенный указатель выровнен по границе, заданной аргументом функции в &lt;var&gt;position&lt;/var&gt; . Значимое выравнивание - это степень двойки больше единицы. GCC использует эту информацию для улучшения анализа выравнивания указателя.</target>
        </trans-unit>
        <trans-unit id="8797cd128649602028c5dfdc7369a0575f411979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer points to memory whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alloc_size&lt;/code&gt; атрибут может быть применен к функции , которая возвращает указатель и принимает по меньшей мере , один аргумент целого числа или пронумерованный типа. Он указывает на то, что возвращенный указатель указывает на память, размер которой задается аргументом функции в &lt;var&gt;position-1&lt;/var&gt; или произведением аргументов в &lt;var&gt;position-1&lt;/var&gt; и &lt;var&gt;position-2&lt;/var&gt; . Значимые размеры - это положительные значения меньше &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; . GCC использует эту информацию для улучшения результатов &lt;code&gt;__builtin_object_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f06aab07630994254a1a8fb1c75da104d280fc4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; type attribute may be applied to the definition of a type of a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alloc_size&lt;/code&gt; атрибут типа может быть применен к определению типа функции , которая возвращает указатель и принимает по меньшей мере , один аргумент целочисленного типа. Он указывает на то, что возвращаемый указатель указывает на объект, размер которого задается аргументом функции в &lt;var&gt;position-1&lt;/var&gt; или произведением аргументов в &lt;var&gt;position-1&lt;/var&gt; и &lt;var&gt;position-2&lt;/var&gt; . Значимые размеры - это положительные значения меньше &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; . При обнаружении другие размеры не отображаются. GCC использует эту информацию для улучшения результатов &lt;code&gt;__builtin_object_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="065a219ddaff6d679a0be49eb2bd7f719e312c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; variable attribute may be applied to the declaration of a pointer to a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alloc_size&lt;/code&gt; атрибут переменный может быть применен к объявлению указателя на функцию , которая возвращает указатель и принимает по меньшей мере , один аргумент целочисленного типа. Он указывает на то, что возвращаемый указатель указывает на объект, размер которого задается аргументом функции в &lt;var&gt;position-1&lt;/var&gt; или произведением аргументов в &lt;var&gt;position-1&lt;/var&gt; и &lt;var&gt;position-2&lt;/var&gt; . Значимые размеры - это положительные значения меньше &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; . При обнаружении другие размеры не отображаются. GCC использует эту информацию для улучшения результатов &lt;code&gt;__builtin_object_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbdc1421fb579e3bcb9c9ed2bb5181ffe0b47ee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword allows you to embed assembler instructions within C code. GCC provides two forms of inline &lt;code&gt;asm&lt;/code&gt; statements. A &lt;em&gt;basic &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement is one with no operands (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;), while an &lt;em&gt;extended &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) includes one or more operands. The extended form is preferred for mixing C and assembly language within a function, but to include assembly language at top level you must use basic &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; ключевых слов позволяет вставлять инструкции ассемблера внутри кода C. GCC предоставляет две формы встроенных операторов &lt;code&gt;asm&lt;/code&gt; . &lt;em&gt;Основной &lt;code&gt;asm&lt;/code&gt; &lt;/em&gt; утверждение один без каких - либо операндов (см &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt; ), в то время как &lt;em&gt;расширенное &lt;code&gt;asm&lt;/code&gt; &lt;/em&gt; заявление (см &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt; ) включает в себя один или несколько операндов. Расширенная форма предпочтительна для смешивания C и языка ассемблера в функции, но для включения языка ассемблера на верхнем уровне вы должны использовать базовый &lt;code&gt;asm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c83f20d0e6ffe18a83c8f1ea64e1025e8b4e3b79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword is a GNU extension. When writing code that can be compiled with</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; ключевое слово является расширением GNU. При написании кода, который можно скомпилировать с</target>
        </trans-unit>
        <trans-unit id="5154cd3afb55ec67fd254011d045e0b4c9d93a08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; statement allows you to include assembly instructions directly within C code. This may help you to maximize performance in time-sensitive code or to access assembly instructions that are not readily available to C programs.</source>
          <target state="translated">Оператор &lt;code&gt;asm&lt;/code&gt; позволяет включать инструкции сборки непосредственно в код C. Это может помочь вам максимизировать производительность в чувствительном ко времени коде или получить доступ к инструкциям сборки, которые не всегда доступны для программ C.</target>
        </trans-unit>
        <trans-unit id="889a71d5c542b05221a1fea4fb081bfa156749e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assume_aligned&lt;/code&gt; attribute may be applied to a function that returns a pointer. It indicates that the returned pointer is aligned on a boundary given by &lt;var&gt;alignment&lt;/var&gt;. If the attribute has two arguments, the second argument is misalignment &lt;var&gt;offset&lt;/var&gt;. Meaningful values of &lt;var&gt;alignment&lt;/var&gt; are powers of 2 greater than one. Meaningful values of &lt;var&gt;offset&lt;/var&gt; are greater than zero and less than &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;assume_aligned&lt;/code&gt; атрибут может быть применен к функции , которая возвращает указатель. Он указывает, что возвращенный указатель выровнен по границе, заданной &lt;var&gt;alignment&lt;/var&gt; . Если атрибут имеет два аргумента, второй аргумент - смещение &lt;var&gt;offset&lt;/var&gt; . Значимые значения &lt;var&gt;alignment&lt;/var&gt; - это степени двойки больше единицы. Значимые значения &lt;var&gt;offset&lt;/var&gt; больше нуля и меньше &lt;var&gt;alignment&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="e7eb78f1e02d22076254e95ec303c8093068484f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aux&lt;/code&gt; attribute is used to directly access the ARC&amp;rsquo;s auxiliary register space from C. The auxilirary register number is given via attribute argument.</source>
          <target state="translated">&lt;code&gt;aux&lt;/code&gt; атрибут используются для прямого доступа вспомогательного регистра пространство АРК от C. auxilirary номер регистра даются с помощью атрибута аргумента.</target>
        </trans-unit>
        <trans-unit id="b63bd6b23aa2da11430c3217df7f40955b5b703f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;b&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="0166d882668eb629f4c81b26d5f43ba89f13484a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;c&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; регистром.</target>
        </trans-unit>
        <trans-unit id="07fada73a7cf214a1328d2a6e8cd842b7cf5c1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cf_check&lt;/code&gt; attribute on a function is used to inform the compiler that ENDBR instruction should be placed at the function entry when</source>
          <target state="translated">&lt;code&gt;cf_check&lt;/code&gt; атрибут функции используется для информирования компилятора , что инструкция ENDBR должна быть размещена на входе функции , когда</target>
        </trans-unit>
        <trans-unit id="ca2675a5f39c8ca20fe391d93c61cca5056e32cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cleanup&lt;/code&gt; attribute runs a function when the variable goes out of scope. This attribute can only be applied to auto function scope variables; it may not be applied to parameters or variables with static storage duration. The function must take one parameter, a pointer to a type compatible with the variable. The return value of the function (if any) is ignored.</source>
          <target state="translated">&lt;code&gt;cleanup&lt;/code&gt; атрибут запускает функцию , когда переменная выходит из области видимости. Этот атрибут может применяться только к переменным области автоматической функции; его нельзя применять к параметрам или переменным со статической продолжительностью хранения. Функция должна принимать один параметр, указатель на тип, совместимый с переменной. Возвращаемое значение функции (если есть) игнорируется.</target>
        </trans-unit>
        <trans-unit id="85d44203c9f2ae9c43811502121d3c877febd137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on functions is used to inform the compiler that the function is unlikely to be executed. The function is optimized for size rather than speed and on many targets it is placed into a special subsection of the text section so all cold functions appear close together, improving code locality of non-cold parts of program. The paths leading to calls of cold functions within code are marked as unlikely by the branch prediction mechanism. It is thus useful to mark functions used to handle unlikely conditions, such as &lt;code&gt;perror&lt;/code&gt;, as cold to improve optimization of hot functions that do call marked functions in rare occasions.</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; атрибут функций используются для информирования компилятора , что функция вряд ли будет выполнено. Функция оптимизирована по размеру, а не по скорости, и для многих целей она помещена в специальный подраздел текстового раздела, поэтому все холодные функции отображаются близко друг к другу, улучшая локальность кода не холодных частей программы. Пути, ведущие к вызовам холодных функций в коде, помечаются механизмом прогнозирования переходов как маловероятные. Таким образом, полезно помечать функции, используемые для обработки маловероятных условий, таких как &lt;code&gt;perror&lt;/code&gt; , как холодные, чтобы улучшить оптимизацию горячих функций, которые в редких случаях вызывают помеченные функции.</target>
        </trans-unit>
        <trans-unit id="baaebf592a1c26312204d234ba4d0961fa9cfdc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on labels is used to inform the compiler that the path following the label is unlikely to be executed. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; атрибут на этикетках используются для информирования компилятора , что путь после этикетки вряд ли будет выполнено. Этот атрибут используется в случаях, когда &lt;code&gt;__builtin_expect&lt;/code&gt; не может использоваться, например, с вычисленным goto или &lt;code&gt;asm goto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84aae041fbfd493303c7dc6f97608b2aa0f0cfea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;common&lt;/code&gt; attribute requests GCC to place a variable in &amp;ldquo;common&amp;rdquo; storage. The &lt;code&gt;nocommon&lt;/code&gt; attribute requests the opposite&amp;mdash;to allocate space for it directly.</source>
          <target state="translated">&lt;code&gt;common&lt;/code&gt; атрибут просит GCC поместить переменную в &amp;laquo;общем&amp;raquo; хранения. &lt;code&gt;nocommon&lt;/code&gt; атрибут просит противоположные выделить место для него непосредственно.</target>
        </trans-unit>
        <trans-unit id="09440712407e39d94a0cdcf960e85948cfc3c350" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute imposes greater restrictions on a function&amp;rsquo;s definition than the similar &lt;code&gt;pure&lt;/code&gt; attribute. Declaring the same function with both the &lt;code&gt;const&lt;/code&gt; and the &lt;code&gt;pure&lt;/code&gt; attribute is diagnosed. Because a const function cannot have any observable side effects it does not make sense for it to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; атрибут накладывает большие ограничения на определение некоторой функции, чем аналогичный &lt;code&gt;pure&lt;/code&gt; атрибут. Диагностируется объявление одной и той же функции как с атрибутом &lt;code&gt;const&lt;/code&gt; ,так и с атрибутом &lt;code&gt;pure&lt;/code&gt; . Поскольку константная функция не может иметь никаких наблюдаемых побочных эффектов, для нее нет смысла возвращать &lt;code&gt;void&lt;/code&gt; . Объявление такой функции диагностируется.</target>
        </trans-unit>
        <trans-unit id="db8d892c81dcdfdd626d5be4bd09dab512df4f9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute prohibits a function from reading objects that affect its return value between successive invocations. However, functions declared with the attribute can safely read objects that do not change their return value, such as non-volatile constants.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; атрибут запрещает функцию от чтения объектов , которые влияют на ее возвращаемое значение между последовательными вызовами. Однако функции, объявленные с этим атрибутом, могут безопасно читать объекты, которые не изменяют свое возвращаемое значение, например, энергонезависимые константы.</target>
        </trans-unit>
        <trans-unit id="99106b80230d2cf73a73b452a0a31c02c4de491f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constructor&lt;/code&gt; attribute causes the function to be called automatically before execution enters &lt;code&gt;main ()&lt;/code&gt;. Similarly, the &lt;code&gt;destructor&lt;/code&gt; attribute causes the function to be called automatically after &lt;code&gt;main ()&lt;/code&gt; completes or &lt;code&gt;exit ()&lt;/code&gt; is called. Functions with these attributes are useful for initializing data that is used implicitly during the execution of the program.</source>
          <target state="translated">&lt;code&gt;constructor&lt;/code&gt; атрибута вызывает функцию , которая будет вызвана автоматически до исполнения входит &lt;code&gt;main ()&lt;/code&gt; . Точно так же атрибут &lt;code&gt;destructor&lt;/code&gt; вызывает автоматический вызов функции после завершения &lt;code&gt;main ()&lt;/code&gt; или &lt;code&gt;exit ()&lt;/code&gt; . Функции с этими атрибутами полезны для инициализации данных, которые неявно используются во время выполнения программы.</target>
        </trans-unit>
        <trans-unit id="7f891d087177f42fcc2b6b6abd03f036315d60bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;function&lt;/var&gt; has been declared to the declaration of the function to which the attribute is applied. The attribute is designed for libraries that define aliases or function resolvers that are expected to specify the same set of attributes as their targets. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with functions, variables, or types. However, the kind of symbol to which the attribute is applied (either function or variable) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; and &lt;code&gt;target_clones&lt;/code&gt; attribute are also not copied. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1214564b5cbc84df3e7da6094de27b7006df5a48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;function&lt;/var&gt; has been declared to the declaration of the function to which the attribute is applied. The attribute is designed for libraries that define aliases or function resolvers that are expected to specify the same set of attributes as their targets. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with functions, variables, or types. However, the kind of symbol to which the attribute is applied (either function or variable) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; атрибут применяется набор атрибутов , с которым &lt;var&gt;function&lt;/var&gt; была объявлена в декларации функции , к которой применяется атрибут. Атрибут разработан для библиотек, которые определяют псевдонимы или преобразователи функций, которые должны указывать тот же набор атрибутов, что и их цели. &lt;code&gt;copy&lt;/code&gt; атрибут может использоваться с функциями, переменных или типов. Однако тип символа, к которому применяется атрибут (функция или переменная), должен соответствовать типу символа, на который ссылается аргумент. &lt;code&gt;copy&lt;/code&gt; атрибут копирует только синтаксические и семантические признаки , но не атрибуты, определяющей связь или видимость символа, такие как &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;visibility&lt;/code&gt; , или &lt;code&gt;weak&lt;/code&gt; . &lt;code&gt;deprecated&lt;/code&gt; атрибут также не копируется. См. &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Атрибуты общего типа&lt;/a&gt; . См. &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Общие атрибуты переменных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="592273a5e05d6744ed0bd5dc37c91bbe97b23cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;variable&lt;/var&gt; has been declared to the declaration of the variable to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with variables, functions or types. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; атрибут применяется набор атрибутов , с которым &lt;var&gt;variable&lt;/var&gt; была объявлена в объявлении переменной , к которой применяется атрибут. Атрибут разработан для библиотек, которые определяют псевдонимы, которые, как ожидается, будут указывать тот же набор атрибутов, что и символы с псевдонимами. &lt;code&gt;copy&lt;/code&gt; атрибут может использоваться с переменными, функциями или типов. Однако тип символа, к которому применяется атрибут (переменная или функция), должен соответствовать типу символа, на который ссылается аргумент. В &lt;code&gt;copy&lt;/code&gt; атрибуты копируют только синтаксические и семантические атрибуты , но не атрибуты , которые влияют на связь или видимость символа, такие как &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;visibility&lt;/code&gt; , или &lt;code&gt;weak&lt;/code&gt; , &lt;code&gt;deprecated&lt;/code&gt; атрибут также не копируется. См. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функций&lt;/a&gt; . См. &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Атрибуты общего типа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a505e2a0a73ab045449836d4a18bec5c0bc8127e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which the type of the &lt;var&gt;expression&lt;/var&gt; has been declared to the declaration of the type to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with types, variables, or functions. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; атрибут применяется набор атрибутов , с которыми тип &lt;var&gt;expression&lt;/var&gt; был объявлен в декларации типа , к которому применяется атрибут. Атрибут разработан для библиотек, которые определяют псевдонимы, которые, как ожидается, будут указывать тот же набор атрибутов, что и символы с псевдонимами. &lt;code&gt;copy&lt;/code&gt; атрибут может использоваться с типами, переменными или функциями. Однако тип символа, к которому применяется атрибут (переменная или функция), должен соответствовать типу символа, на который ссылается аргумент. В &lt;code&gt;copy&lt;/code&gt; атрибуты копируют только синтаксические и семантические атрибуты , но не атрибуты , которые влияют на связь или видимость символа, такие как &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;visibility&lt;/code&gt; , или &lt;code&gt;weak&lt;/code&gt; . &lt;code&gt;deprecated&lt;/code&gt; атрибут также не копируется. См. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общие атрибуты функций&lt;/a&gt; . См. &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Общие атрибуты переменных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a4a7841fe7fe34c4f48a65b187a7fb8df9b582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;d&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; регистра.</target>
        </trans-unit>
        <trans-unit id="024895282c898bc3d4211d4724e2af4880224cde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and types (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; атрибут может также использоваться для функций и типов (см &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Общих функций Атрибуты&lt;/a&gt; см &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Атрибуты Common Type&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="162fc2b6ed9e6c2908900a7eb89f4726020462d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and variables (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; атрибут может также использоваться для функций и переменных (см &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;атрибутов функции&lt;/a&gt; см &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;атрибутов переменных&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="b2cfdb164eda8f42cf6433c514a0ea224366c785" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for variables and types (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;, see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; атрибут может также использоваться для переменных и типов (см &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;атрибутов переменных&lt;/a&gt; см &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты Тип&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="cad1e87fce264d36291150600cb66c57e91c1432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the enumerator is used anywhere in the source file. This is useful when identifying enumerators that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated enumerator, to enable users to easily find further information about why the enumerator is deprecated, or what they should do instead. Note that the warnings only occurs for uses.</source>
          <target state="translated">Использование &lt;code&gt;deprecated&lt;/code&gt; атрибута приводит к предупреждению, если перечислитель используется в любом месте исходного файла. Это полезно при определении счетчиков, которые, как ожидается, будут удалены в будущей версии программы. Предупреждение также включает местоположение объявления устаревшего перечислителя, чтобы пользователи могли легко найти дополнительную информацию о том, почему перечислитель устарел или что им следует делать вместо этого. Обратите внимание, что предупреждения появляются только при использовании.</target>
        </trans-unit>
        <trans-unit id="20e0cb154d9e21da1f2de2ead88f358575c22b29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the function is used anywhere in the source file. This is useful when identifying functions that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated function, to enable users to easily find further information about why the function is deprecated, or what they should do instead. Note that the warnings only occurs for uses:</source>
          <target state="translated">Использование &lt;code&gt;deprecated&lt;/code&gt; атрибута приводит к предупреждению, если функция используется в любом месте исходного файла. Это полезно при идентификации функций, которые, как ожидается, будут удалены в будущей версии программы. Предупреждение также включает местоположение объявления устаревшей функции, чтобы пользователи могли легко найти дополнительную информацию о том, почему функция устарела или что им следует делать вместо нее. Обратите внимание, что предупреждения появляются только при использовании:</target>
        </trans-unit>
        <trans-unit id="7280557c8bb44f2fb4dbaff815426552ad4804e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the type is used anywhere in the source file. This is useful when identifying types that are expected to be removed in a future version of a program. If possible, the warning also includes the location of the declaration of the deprecated type, to enable users to easily find further information about why the type is deprecated, or what they should do instead. Note that the warnings only occur for uses and then only if the type is being applied to an identifier that itself is not being declared as deprecated.</source>
          <target state="translated">Использование &lt;code&gt;deprecated&lt;/code&gt; атрибута приводит к предупреждению, если тип используется в любом месте исходного файла. Это полезно при идентификации типов, которые, как ожидается, будут удалены в будущей версии программы. Если возможно, предупреждение также включает местоположение объявления устаревшего типа, чтобы пользователи могли легко найти дополнительную информацию о том, почему этот тип является устаревшим или что им следует делать вместо этого. Обратите внимание, что предупреждения возникают только при использовании и только в том случае, если тип применяется к идентификатору, который сам не объявляется устаревшим.</target>
        </trans-unit>
        <trans-unit id="597712de9335903c130e7df57d7a0ba95b08639b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the variable is used anywhere in the source file. This is useful when identifying variables that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated variable, to enable users to easily find further information about why the variable is deprecated, or what they should do instead. Note that the warning only occurs for uses:</source>
          <target state="translated">Использование &lt;code&gt;deprecated&lt;/code&gt; атрибута приводит к предупреждению, если переменная используется в любом месте исходного файла. Это полезно при идентификации переменных, которые, как ожидается, будут удалены в будущей версии программы. Предупреждение также включает местоположение объявления устаревшей переменной, чтобы пользователи могли легко найти дополнительную информацию о том, почему переменная устарела или что им следует делать вместо этого. Обратите внимание, что предупреждение появляется только при использовании:</target>
        </trans-unit>
        <trans-unit id="344b31eee254fd7731082259002ff33f9b48b98f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;di&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;di&lt;/code&gt; - регистр.</target>
        </trans-unit>
        <trans-unit id="1650914162ce3f6c59a952f96564a05c9635bff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dllimport&lt;/code&gt; and &lt;code&gt;dllexport&lt;/code&gt; attributes are described in &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windows Function Attributes&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;dllimport&lt;/code&gt; и &lt;code&gt;dllexport&lt;/code&gt; атрибуты описаны в &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;функциональных атрибутов Microsoft Windows&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="602269999e7f262d03410dcdc10e151a9ba7ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;either&lt;/code&gt; attribute is special. It tells the linker to place the object into the corresponding &lt;code&gt;lower&lt;/code&gt; section if there is room for it. If there is insufficient room then the object is placed into the corresponding &lt;code&gt;upper&lt;/code&gt; section instead. Note that the placement algorithm is not very sophisticated. It does not attempt to find an optimal packing of the &lt;code&gt;lower&lt;/code&gt; sections. It just makes one pass over the objects and does the best that it can. Using the</source>
          <target state="translated">&lt;code&gt;either&lt;/code&gt; атрибут является особенным. Он сообщает компоновщику, что нужно поместить объект в соответствующую &lt;code&gt;lower&lt;/code&gt; секцию, если для него есть место. Если места недостаточно, то вместо этого объект помещается в соответствующую &lt;code&gt;upper&lt;/code&gt; секцию. Обратите внимание, что алгоритм размещения не очень сложен. Он не пытается найти оптимальную упаковку &lt;code&gt;lower&lt;/code&gt; секций. Он просто делает один проход над объектами и делает все возможное. Используя</target>
        </trans-unit>
        <trans-unit id="127ffb86a9524294853f3ef1fc5800cb8a1c3768" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fallthrough&lt;/code&gt; attribute with a null statement serves as a fallthrough statement. It hints to the compiler that a statement that falls through to another case label, or user-defined label in a switch statement is intentional and thus the</source>
          <target state="translated">&lt;code&gt;fallthrough&lt;/code&gt; атрибут с нулевым утверждением служит проваливаются заявлением. Он намекает компилятору, что оператор, который попадает в другую метку case или определяемую пользователем метку в операторе switch, является преднамеренным и, следовательно,</target>
        </trans-unit>
        <trans-unit id="6830b1617bcd576d4ef6cff9b6f00ee4b5966d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fixincludes&lt;/code&gt; script interacts badly with automounters; if the directory of system header files is automounted, it tends to be unmounted while &lt;code&gt;fixincludes&lt;/code&gt; is running. This would seem to be a bug in the automounter. We don&amp;rsquo;t know any good way to work around it.</source>
          <target state="translated">В &lt;code&gt;fixincludes&lt;/code&gt; скрипт взаимодействует плохо с; автоматического монтирования если каталог файлов системных заголовков &lt;code&gt;fixincludes&lt;/code&gt; автоматически, он обычно отключается во время работы fixincludes . Казалось бы, это ошибка автомонтирования. Мы не знаем, как это обойти.</target>
        </trans-unit>
        <trans-unit id="c63425a2cbc7b99cbe7ca99c3dbf9d57e95519bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute allows you to identify your own functions that take format strings as arguments, so that GCC can check the calls to these functions for errors. The compiler always (unless</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; атрибут позволяет определить свои собственные функции , которые принимают строки формата как аргументы, так что GCC может проверить вызовы этих функций на наличии ошибок. Компилятор всегда (если</target>
        </trans-unit>
        <trans-unit id="8186a0d48987dddde9af17dcccbd13ea17379b53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute specifies that a function takes &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style arguments that should be type-checked against a format string. For example, the declaration:</source>
          <target state="translated">В &lt;code&gt;format&lt;/code&gt; атрибут указывает , что функция принимает &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; , &lt;code&gt;strftime&lt;/code&gt; или &lt;code&gt;strfmon&lt;/code&gt; аргументы стиля , которые должны быть типа сверен строки формата. Например, объявление:</target>
        </trans-unit>
        <trans-unit id="85cee214b83f923e35c9402c26181e376eaa3ea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute allows you to identify your own functions that modify format strings, so that GCC can check the calls to &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; type function whose operands are a call to one of your own function. The compiler always treats &lt;code&gt;gettext&lt;/code&gt;, &lt;code&gt;dgettext&lt;/code&gt;, and &lt;code&gt;dcgettext&lt;/code&gt; in this manner except when strict ISO C support is requested by</source>
          <target state="translated">&lt;code&gt;format_arg&lt;/code&gt; атрибут позволяет определить свои собственные функции , что строки Задаваемого формата, так что GCC может проверить вызовы &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; , &lt;code&gt;strftime&lt;/code&gt; или &lt;code&gt;strfmon&lt;/code&gt; функции типа , чьи операнды вызов одному из вашей собственной функции. Компилятор всегда обрабатывает &lt;code&gt;gettext&lt;/code&gt; , &lt;code&gt;dgettext&lt;/code&gt; и &lt;code&gt;dcgettext&lt;/code&gt; таким образом, за исключением случаев, когда строгая поддержка ISO C запрашивается</target>
        </trans-unit>
        <trans-unit id="3daa7d7140f7871d6b8af467ff44e71c895472e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute specifies that a function takes one or more format strings for a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function and modifies it (for example, to translate it into another language), so the result can be passed to a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function (with the remaining arguments to the format function the same as they would have been for the unmodified string). Multiple &lt;code&gt;format_arg&lt;/code&gt; attributes may be applied to the same function, each designating a distinct parameter as a format string. For example, the declaration:</source>
          <target state="translated">В &lt;code&gt;format_arg&lt;/code&gt; указывает атрибут , что функция принимает один или несколько строк формата для &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; , &lt;code&gt;strftime&lt;/code&gt; или &lt;code&gt;strfmon&lt;/code&gt; функции и модифицирует его (например, чтобы перевести его на другой язык), так что результат может быть передан в &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; , &lt;code&gt;strfmon&lt;/code&gt; стиля &lt;code&gt;strftime&lt;/code&gt; или strfmon (с остальными аргументами функции форматирования, такими же, как они были бы для неизмененной строки). К &lt;code&gt;format_arg&lt;/code&gt; и той же функции можно применить несколько атрибутов format_arg , каждый из которых обозначает отдельный параметр как строку формата. Например, объявление:</target>
        </trans-unit>
        <trans-unit id="cca4e3fc744cfd6bb4409a911b1eaa70a4a7b0f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gcc&lt;/code&gt; program accepts options and file names as operands. Many options have multi-letter names; therefore multiple single-letter options may &lt;em&gt;not&lt;/em&gt; be grouped:</source>
          <target state="translated">Программа &lt;code&gt;gcc&lt;/code&gt; принимает параметры и имена файлов в качестве операндов. Многие варианты имеют названия из нескольких букв; поэтому несколько однобуквенных вариантов &lt;em&gt;не&lt;/em&gt; могут быть сгруппированы:</target>
        </trans-unit>
        <trans-unit id="13501a1cf6115328de048bf9d04f10c4c82f956e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getenv&lt;/code&gt; spec function takes two arguments: an environment variable name and a string. If the environment variable is not defined, a fatal error is issued. Otherwise, the return value is the value of the environment variable concatenated with the string. For example, if &lt;code&gt;TOPDIR&lt;/code&gt; is defined as</source>
          <target state="translated">Функция &lt;code&gt;getenv&lt;/code&gt; spec принимает два аргумента: имя переменной среды и строку. Если переменная среды не определена, выдается неустранимая ошибка. В противном случае возвращаемое значение - это значение переменной среды, объединенное со строкой. Например, если &lt;code&gt;TOPDIR&lt;/code&gt; определен как</target>
        </trans-unit>
        <trans-unit id="7e47220a0b9fe1eafb603003bb97378e81c55693" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a function is used to inform the compiler that the function is a hot spot of the compiled program. The function is optimized more aggressively and on many targets it is placed into a special subsection of the text section so all hot functions appear close together, improving locality.</source>
          <target state="translated">&lt;code&gt;hot&lt;/code&gt; атрибут функции используется для информирования компилятора , что функция является горячей точкой скомпилированной программы. Функция оптимизирована более агрессивно, и для многих целей она помещена в специальный подраздел текстового раздела, поэтому все горячие функции отображаются близко друг к другу, улучшая локальность.</target>
        </trans-unit>
        <trans-unit id="bdc71e7bb730a8ac55c634493d73dbda68f4ce5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a label is used to inform the compiler that the path following the label is more likely than paths that are not so annotated. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hot&lt;/code&gt; атрибут на этикетке используется для информирования компилятора , что путь после этикетки, более вероятно , чем пути , которые не так аннотаций. Этот атрибут используется в случаях, когда &lt;code&gt;__builtin_expect&lt;/code&gt; не может использоваться, например, с вычисленным goto или &lt;code&gt;asm goto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f61dd8421805c3f1f1761646164b13228bc83b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists-else&lt;/code&gt; spec function is similar to the &lt;code&gt;if-exists&lt;/code&gt; spec function, except that it takes two arguments. The first argument is an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists-else&lt;/code&gt; returns the pathname. If it does not exist, it returns the second argument. This way, &lt;code&gt;if-exists-else&lt;/code&gt; can be used to select one file or another, based on the existence of the first. Here is a small example of its usage:</source>
          <target state="translated">Спецификация &lt;code&gt;if-exists-else&lt;/code&gt; похожа на спецификацию &lt;code&gt;if-exists&lt;/code&gt; , за исключением того, что она принимает два аргумента. Первый аргумент - это абсолютный путь к файлу. Если файл существует, &lt;code&gt;if-exists-else&lt;/code&gt; возвращает путь. Если его не существует, он возвращает второй аргумент. Таким образом, &lt;code&gt;if-exists-else&lt;/code&gt; можно использовать для выбора того или иного файла в зависимости от наличия первого. Вот небольшой пример его использования:</target>
        </trans-unit>
        <trans-unit id="ca2fcf31ed2dc4dabd85a0634ae9ce4991a720f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists&lt;/code&gt; spec function takes one argument, an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists&lt;/code&gt; returns the pathname. Here is a small example of its usage:</source>
          <target state="translated">Спецификационная функция &lt;code&gt;if-exists&lt;/code&gt; принимает один аргумент - абсолютный путь к файлу. Если файл существует, функция &lt;code&gt;if-exists&lt;/code&gt; возвращает путь. Вот небольшой пример его использования:</target>
        </trans-unit>
        <trans-unit id="2f39b443650f9aa0609294fd86fb2e3c92efa3ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ifunc&lt;/code&gt; attribute is used to mark a function as an indirect function using the STT_GNU_IFUNC symbol type extension to the ELF standard. This allows the resolution of the symbol value to be determined dynamically at load time, and an optimized version of the routine to be selected for the particular processor or other system characteristics determined then. To use this attribute, first define the implementation functions available, and a resolver function that returns a pointer to the selected implementation function. The implementation functions&amp;rsquo; declarations must match the API of the function being implemented. The resolver should be declared to be a function taking no arguments and returning a pointer to a function of the same type as the implementation. For example:</source>
          <target state="translated">&lt;code&gt;ifunc&lt;/code&gt; атрибут используется для обозначения функции в качестве косвенного функции , используя расширение типа символ STT_GNU_IFUNC к стандарту ELF. Это позволяет динамически определять разрешение значения символа во время загрузки и выбирать оптимизированную версию процедуры для конкретного процессора или других характеристик системы, определяемых затем. Чтобы использовать этот атрибут, сначала определите доступные функции реализации и функцию преобразователя, которая возвращает указатель на выбранную функцию реализации. Объявления функций реализации должны соответствовать API реализуемой функции. Сопоставитель следует объявить как функцию, не принимающую аргументов и возвращающую указатель на функцию того же типа, что и реализация. Например:</target>
        </trans-unit>
        <trans-unit id="c93b19f3af6a498a18dbae7f15fda07496789c8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indirect_return&lt;/code&gt; attribute can be applied to a function, as well as variable or type of function pointer to inform the compiler that the function may return via indirect branch.</source>
          <target state="translated">&lt;code&gt;indirect_return&lt;/code&gt; атрибут может быть применен к функции, а также переменной или типа указателя на функцию , чтобы сообщить компилятору , что функция может возвращать через непрямой ветви.</target>
        </trans-unit>
        <trans-unit id="f9d323a0cf85010c427cc0692ec1f74e288bfb70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; type specifies the &lt;em&gt;base type&lt;/em&gt;, while the attribute specifies the vector size for the variable, measured in bytes. For example, the declaration above causes the compiler to set the mode for the &lt;code&gt;v4si&lt;/code&gt; type to be 16 bytes wide and divided into &lt;code&gt;int&lt;/code&gt; sized units. For a 32-bit &lt;code&gt;int&lt;/code&gt; this means a vector of 4 units of 4 bytes, and the corresponding mode of &lt;code&gt;foo&lt;/code&gt; is V4SI.</source>
          <target state="translated">Тип &lt;code&gt;int&lt;/code&gt; указывает &lt;em&gt;базовый тип&lt;/em&gt; , а атрибут определяет размер вектора для переменной, измеряемый в байтах. Например, приведенное выше объявление заставляет компилятор установить режим для типа &lt;code&gt;v4si&lt;/code&gt; шириной 16 байт и разделением на блоки размером &lt;code&gt;int&lt;/code&gt; . Для 32-битного &lt;code&gt;int&lt;/code&gt; это означает вектор из 4 единиц по 4 байта, и соответствующий режим &lt;code&gt;foo&lt;/code&gt; - V4SI.</target>
        </trans-unit>
        <trans-unit id="2ad85eea7d52841e376253f17a96317ee40b42d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; register. Use this register to store values that are no bigger than a word.</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; регистр. Используйте этот регистр для хранения значений размером не больше слова.</target>
        </trans-unit>
        <trans-unit id="d59f696ee7163d6ae5bf39bf73c4a8eee9fb142c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override both the</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; атрибут указывает на то, что функция может быть далеко от места вызова и требуют другого (более дорогой) , призывающую последовательность. &lt;code&gt;shortcall&lt;/code&gt; атрибут указывает на то, что функция всегда достаточно близко для короткой последовательности вызова будет использоваться. Эти атрибуты имеют приоритет над обоими</target>
        </trans-unit>
        <trans-unit id="fcca42c392befdcaa88d2e6501ea9388ada93b12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override the</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; атрибут указывает на то, что функция может быть далеко от места вызова и требуют другого (более дорогой) , призывающую последовательность. &lt;code&gt;shortcall&lt;/code&gt; атрибут указывает на то, что функция всегда достаточно близко для короткой последовательности вызова будет использоваться. Эти атрибуты имеют приоритет над</target>
        </trans-unit>
        <trans-unit id="dc876d3a5eef5293c3403c1a8361253a45afc935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movf&lt;/code&gt; functions are similar but use &lt;code&gt;movf.ps&lt;/code&gt; instead of &lt;code&gt;movt.ps&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;movf&lt;/code&gt; функции аналогичны , но использование &lt;code&gt;movf.ps&lt;/code&gt; вместо &lt;code&gt;movt.ps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7edfc9a06b3d4812f5bd4584647b1d884b0e5206" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movt&lt;/code&gt; functions return the value &lt;var&gt;x&lt;/var&gt; computed by:</source>
          <target state="translated">Функции &lt;code&gt;movt&lt;/code&gt; возвращают значение &lt;var&gt;x&lt;/var&gt; , вычисленное с помощью:</target>
        </trans-unit>
        <trans-unit id="2610b35bdca1d94154ca3ae8683caf9dc99891a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mutationsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is used to keep track of mutations. It should point to a number; before working on each object, the fast enumeration loop will check that this number has not changed. If it has, a mutation has happened and the fast enumeration will abort. So, &lt;code&gt;mutationsPtr&lt;/code&gt; could be set to point to some sort of version number of your collection, which is increased by one every time there is a change (for example when an object is added or removed). Or, if you are content with less strict mutation checks, it could point to the number of objects in your collection or some other value that can be checked to perform an approximate check that the collection has not been mutated.</source>
          <target state="translated">&lt;code&gt;mutationsPtr&lt;/code&gt; поле &lt;code&gt;NSFastEnumerationState&lt;/code&gt; используется для отслеживания мутаций. Он должен указывать на число; перед работой с каждым объектом цикл быстрого перебора проверяет, не изменилось ли это число. Если это так, значит, произошла мутация, и быстрое перечисление будет прервано. Итак, &lt;code&gt;mutationsPtr&lt;/code&gt; можно настроить так, чтобы он указывал на какой-то номер версии вашей коллекции, который увеличивается на единицу каждый раз, когда происходит изменение (например, когда объект добавляется или удаляется). Или, если вас устраивают менее строгие проверки на мутации, это может указывать на количество объектов в вашей коллекции или какое-либо другое значение, которое можно проверить для выполнения приблизительной проверки того, что коллекция не была изменена.</target>
        </trans-unit>
        <trans-unit id="eba0a2fef84c6754af39561a4cc5765385e357d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_profile_instrument_function&lt;/code&gt; attribute on functions is used to inform the compiler that it should not process any profile feedback based optimization code instrumentation.</source>
          <target state="translated">&lt;code&gt;no_profile_instrument_function&lt;/code&gt; атрибут функций используется для информирования компилятора , что он не должен обработать любой профиль на основе обратной связи оптимизации кода приборов.</target>
        </trans-unit>
        <trans-unit id="0918428dc764c04c359b85f748a679bc412726a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize&lt;/code&gt; attribute on functions is used to inform the compiler that it should not do sanitization of all options mentioned in &lt;var&gt;sanitize_option&lt;/var&gt;. A list of values acceptable by</source>
          <target state="translated">&lt;code&gt;no_sanitize&lt;/code&gt; атрибут функций используется для информирования компилятора , что он не должен делать дезинфекцию всех указанных в настройках &lt;var&gt;sanitize_option&lt;/var&gt; . Список значений, приемлемых для</target>
        </trans-unit>
        <trans-unit id="9e7127aec5521f1afa980b41ce3dbea36752798e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize&lt;/code&gt; attribute on functions is used to inform the compiler that it should not do sanitization of any option mentioned in &lt;var&gt;sanitize_option&lt;/var&gt;. A list of values acceptable by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598d3a3720c7288dc59d302cd06d4d62ac827b23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_address&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="translated">&lt;code&gt;no_sanitize_address&lt;/code&gt; атрибут функций используются для информирования компилятора , что он не должен доступов инструмента памяти в функции при компиляции с</target>
        </trans-unit>
        <trans-unit id="b0f00909d80fd99a1bd86005010002c8eae19649" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_thread&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="translated">&lt;code&gt;no_sanitize_thread&lt;/code&gt; атрибут функций используются для информирования компилятора , что он не должен доступов инструмента памяти в функции при компиляции с</target>
        </trans-unit>
        <trans-unit id="7a12b0e3b686d055271b195be15ed20337782164" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_undefined&lt;/code&gt; attribute on functions is used to inform the compiler that it should not check for undefined behavior in the function when compiling with the</source>
          <target state="translated">&lt;code&gt;no_sanitize_undefined&lt;/code&gt; атрибут функций используются для информирования компилятора , что он не должен проверять неопределенное поведение в функции при компиляции с</target>
        </trans-unit>
        <trans-unit id="fc8d4f077478dc90f16e53c6d13ee06401059297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute is applied to an object&amp;rsquo;s type. In case of assignment of a function address or a function pointer to another pointer, the attribute is not carried over from the right-hand object&amp;rsquo;s type; the type of left-hand object stays unchanged. The compiler checks for &lt;code&gt;nocf_check&lt;/code&gt; attribute mismatch and reports a warning in case of mismatch.</source>
          <target state="translated">&lt;code&gt;nocf_check&lt;/code&gt; атрибут применяется к типу объекта. В случае присвоения адреса функции или указателя функции другому указателю атрибут не переносится из типа правого объекта; тип левого объекта остается неизменным. Компилятор проверяет &lt;code&gt;nocf_check&lt;/code&gt; атрибута nocf_check и выдает предупреждение в случае несоответствия.</target>
        </trans-unit>
        <trans-unit id="037064bc2bccfb10212ace859111994bc55ff79f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a function is used to inform the compiler that the function&amp;rsquo;s prologue should not be instrumented when compiled with the</source>
          <target state="translated">&lt;code&gt;nocf_check&lt;/code&gt; атрибут функции используется для информирования компилятора , что пролог функции не должен быть инструментальными при компиляции с</target>
        </trans-unit>
        <trans-unit id="59968503e9385085cb3eaa290a16cdafff616101" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a type of pointer to function is used to inform the compiler that a call through the pointer should not be instrumented when compiled with the</source>
          <target state="translated">&lt;code&gt;nocf_check&lt;/code&gt; атрибут типа указателя на функцию используется для информирования компилятора , что вызов через указатель не должен быть инструментальными при компиляции с</target>
        </trans-unit>
        <trans-unit id="814b4e15c6c880738e37bebfa650ba3630bcdb26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonnull&lt;/code&gt; attribute may be applied to a function that takes at least one argument of a pointer type. It indicates that the referenced arguments must be non-null pointers. For instance, the declaration:</source>
          <target state="translated">&lt;code&gt;nonnull&lt;/code&gt; атрибут может быть применена к функции , которая принимает по меньшей мере , один аргумент типа указателя. Он указывает, что указанные аргументы должны быть ненулевыми указателями. Например, объявление:</target>
        </trans-unit>
        <trans-unit id="390c2fb36f2ab88e24c7fbba27c3b067ccacf7b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonstring&lt;/code&gt; variable attribute specifies that an object or member declaration with type array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, or &lt;code&gt;unsigned char&lt;/code&gt;, or pointer to such a type is intended to store character arrays that do not necessarily contain a terminating &lt;code&gt;NUL&lt;/code&gt;. This is useful in detecting uses of such arrays or pointers with functions that expect &lt;code&gt;NUL&lt;/code&gt;-terminated strings, and to avoid warnings when such an array or pointer is used as an argument to a bounded string manipulation function such as &lt;code&gt;strncpy&lt;/code&gt;. For example, without the attribute, GCC will issue a warning for the &lt;code&gt;strncpy&lt;/code&gt; call below because it may truncate the copy without appending the terminating &lt;code&gt;NUL&lt;/code&gt; character. Using the attribute makes it possible to suppress the warning. However, when the array is declared with the attribute the call to &lt;code&gt;strlen&lt;/code&gt; is diagnosed because when the array doesn&amp;rsquo;t contain a &lt;code&gt;NUL&lt;/code&gt;-terminated string the call is undefined. To copy, compare, of search non-string character arrays use the &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, and other functions that operate on arrays of bytes. In addition, calling &lt;code&gt;strnlen&lt;/code&gt; and &lt;code&gt;strndup&lt;/code&gt; with such arrays is safe provided a suitable bound is specified, and not diagnosed.</source>
          <target state="translated">В &lt;code&gt;nonstring&lt;/code&gt; указует переменные атрибуты, объект или элемент декларация с типом массивом &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; , или &lt;code&gt;unsigned char&lt;/code&gt; или указателем такого типа предназначена для хранения символьных массивов , которые не обязательно содержат завершающий &lt;code&gt;NUL&lt;/code&gt; . Это полезно для обнаружения использования таких массивов или указателей с функциями, которые ожидают &lt;code&gt;NUL&lt;/code&gt; - завершенные строки, и для предотвращения предупреждений, когда такой массив или указатель используется в качестве аргумента для функции обработки ограниченной строки, такой как &lt;code&gt;strncpy&lt;/code&gt; . Например, без атрибута GCC выдаст предупреждение для &lt;code&gt;strncpy&lt;/code&gt; вызовите ниже, потому что он может обрезать копию без добавления завершающего символа &lt;code&gt;NUL&lt;/code&gt; . Использование атрибута позволяет подавить предупреждение. Однако, когда массив объявлен с атрибутом, вызов &lt;code&gt;strlen&lt;/code&gt; диагностируется, потому что, когда массив не содержит строку с окончанием &lt;code&gt;NUL&lt;/code&gt; , вызов не определен. Для копирования, сравнения и поиска массивов &lt;code&gt;memcmp&lt;/code&gt; символов используйте &lt;code&gt;memcpy&lt;/code&gt; , memcmp , &lt;code&gt;memchr&lt;/code&gt; и другие функции, которые работают с массивами байтов. Кроме того, вызов &lt;code&gt;strnlen&lt;/code&gt; и &lt;code&gt;strndup&lt;/code&gt; с такими массивами безопасен при условии, что подходящая граница указана, а не диагностирована.</target>
        </trans-unit>
        <trans-unit id="bfce49165a44d874594bfffebd1dbb2dbd0c7094" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute is the counterpart to option</source>
          <target state="translated">&lt;code&gt;noplt&lt;/code&gt; атрибут является аналогом опции</target>
        </trans-unit>
        <trans-unit id="0300bf5cb9eee09bcd3c5b59946b4122f915396c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute on function &lt;code&gt;foo&lt;/code&gt; tells the compiler to assume that the function &lt;code&gt;foo&lt;/code&gt; is externally defined and that the call to &lt;code&gt;foo&lt;/code&gt; must avoid the PLT in position-independent code.</source>
          <target state="translated">&lt;code&gt;noplt&lt;/code&gt; атрибут функции &lt;code&gt;foo&lt;/code&gt; указывает компилятору считать , что функция &lt;code&gt;foo&lt;/code&gt; внешне определена и что вызов &lt;code&gt;foo&lt;/code&gt; должны избегать PLT в позиционно-независимый код.</target>
        </trans-unit>
        <trans-unit id="3e2a9d3dba3dc91ebe5e03bbafab67f8838787f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword does not affect the exceptional path when that applies: a &lt;code&gt;noreturn&lt;/code&gt;-marked function may still return to the caller by throwing an exception or calling &lt;code&gt;longjmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; ключевого слово не влияет на исключительном пути , когда это применимо: а &lt;code&gt;noreturn&lt;/code&gt; звёздочки функция все еще может вернуться к абоненту, бросая исключение или вызов &lt;code&gt;longjmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ede64b6031c14f35d5f8cb3935b7f6f8ada1843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword tells the compiler to assume that &lt;code&gt;fatal&lt;/code&gt; cannot return. It can then optimize without regard to what would happen if &lt;code&gt;fatal&lt;/code&gt; ever did return. This makes slightly better code. More importantly, it helps avoid spurious warnings of uninitialized variables.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; ключевое слово указывает компилятору предположить , что &lt;code&gt;fatal&lt;/code&gt; не может вернуться. Затем он может оптимизировать безотносительно к тому, что произойдет, если &lt;code&gt;fatal&lt;/code&gt; когда-нибудь вернется. Это немного улучшает код. Что еще более важно, это помогает избежать ложных предупреждений о неинициализированных переменных.</target>
        </trans-unit>
        <trans-unit id="322a4c52099d05e4a78d3c92d5bcf0059fa4fd77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nothrow&lt;/code&gt; attribute is used to inform the compiler that a function cannot throw an exception. For example, most functions in the standard C library can be guaranteed not to throw an exception with the notable exceptions of &lt;code&gt;qsort&lt;/code&gt; and &lt;code&gt;bsearch&lt;/code&gt; that take function pointer arguments.</source>
          <target state="translated">&lt;code&gt;nothrow&lt;/code&gt; атрибут используется для информирования компилятора , что функция не может выбросить исключение. Например, можно гарантировать, что большинство функций в стандартной библиотеке C не &lt;code&gt;bsearch&lt;/code&gt; исключения, за исключением заметных исключений &lt;code&gt;qsort&lt;/code&gt; и bsearch, которые принимают аргументы указателя функции.</target>
        </trans-unit>
        <trans-unit id="207d7791a2ec8b451439c9235cbe7bcf5c27be6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optimize&lt;/code&gt; attribute is used to specify that a function is to be compiled with different optimization options than specified on the command line. Valid arguments are constant non-negative integers and strings. Each numeric argument specifies an optimization &lt;var&gt;level&lt;/var&gt;. Each &lt;var&gt;string&lt;/var&gt; argument consists of one or more comma-separated substrings. Each substring that begins with the letter &lt;code&gt;O&lt;/code&gt; refers to an optimization option such as</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; атрибут используется для указания того, что функция должна быть составлена с различными вариантами оптимизации , чем указано в командной строке. Допустимые аргументы - это постоянные неотрицательные целые числа и строки. Каждый числовой аргумент указывает &lt;var&gt;level&lt;/var&gt; оптимизации . Каждый &lt;var&gt;string&lt;/var&gt; аргумент состоит из одной или нескольких подстрок, разделенных запятыми. Каждая подстрока, начинающаяся с буквы &lt;code&gt;O&lt;/code&gt; , относится к варианту оптимизации, например</target>
        </trans-unit>
        <trans-unit id="826d9e0c3c8b85ab7196ae31fb079d73a80bdae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; attribute specifies that a structure member should have the smallest possible alignment&amp;mdash;one bit for a bit-field and one byte otherwise, unless a larger value is specified with the &lt;code&gt;aligned&lt;/code&gt; attribute. The attribute does not apply to non-member objects.</source>
          <target state="translated">В &lt;code&gt;packed&lt;/code&gt; атрибут указывает , что структура состоит должна иметь наименьшее возможное выравнивание-один бит для битового поля и один байт в противном случае, если большее значение не задано с &lt;code&gt;aligned&lt;/code&gt; атрибута. Атрибут не применяется к объектам, не являющимся членами.</target>
        </trans-unit>
        <trans-unit id="39beb9f00633eee839c4a2a5158a15d6e464e28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pass-through-libs&lt;/code&gt; spec function takes any number of arguments. It finds any</source>
          <target state="translated">Функция спецификации &lt;code&gt;pass-through-libs&lt;/code&gt; принимает любое количество аргументов. Находит любые</target>
        </trans-unit>
        <trans-unit id="89c9a7db255ec3b8e7cca6652c90ae20f65b9a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;patchable_function_entry&lt;/code&gt; function attribute can be used to change the number of NOPs to any desired value. The two-value syntax is the same as for the command-line switch</source>
          <target state="translated">&lt;code&gt;patchable_function_entry&lt;/code&gt; атрибут функции может быть использован для изменения количества NOP , до любого желаемого значения. Синтаксис с двумя значениями такой же, как и для переключателя командной строки.</target>
        </trans-unit>
        <trans-unit id="e838ae744489fc704636367520fe3b637d47e7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcs&lt;/code&gt; attribute can be used to control the calling convention used for a function on ARM. The attribute takes an argument that specifies the calling convention to use.</source>
          <target state="translated">&lt;code&gt;pcs&lt;/code&gt; атрибут может быть использован для управления соглашением о вызовах , используемое для функции на ARM. Атрибут принимает аргумент, определяющий используемое соглашение о вызовах.</target>
        </trans-unit>
        <trans-unit id="bbf4d6b72a577c7b95004980e1bce0048594d8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print-asm-header&lt;/code&gt; function takes no arguments and simply prints a banner like:</source>
          <target state="translated">Функция &lt;code&gt;print-asm-header&lt;/code&gt; не принимает аргументов и просто печатает баннер, например:</target>
        </trans-unit>
        <trans-unit id="cb4fc17c6269a43f696bb9bef92ec98733094225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute imposes similar but looser restrictions on a function&amp;rsquo;s definition than the &lt;code&gt;const&lt;/code&gt; attribute: &lt;code&gt;pure&lt;/code&gt; allows the function to read any non-volatile memory, even if it changes in between successive invocations of the function. Declaring the same function with both the &lt;code&gt;pure&lt;/code&gt; and the &lt;code&gt;const&lt;/code&gt; attribute is diagnosed. Because a pure function cannot have any observable side effects it does not make sense for such a function to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; атрибут накладывает подобные , но более свободные ограничения на определении функции , в чем &lt;code&gt;const&lt;/code&gt; атрибут: &lt;code&gt;pure&lt;/code&gt; позволяет функции , чтобы прочитать любую энергонезависимую память, даже если он изменяется между последовательными вызовами функции. Диагностируется объявление одной и той же функции с атрибутом &lt;code&gt;pure&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; . Поскольку чистая функция не может иметь никаких наблюдаемых побочных эффектов, для такой функции не имеет смысла возвращать &lt;code&gt;void&lt;/code&gt; . Объявление такой функции диагностируется.</target>
        </trans-unit>
        <trans-unit id="323eb04f8039811b3bb58c82bccb097f2a6f7bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute prohibits a function from modifying the state of the program that is observable by means other than inspecting the function&amp;rsquo;s return value. However, functions declared with the &lt;code&gt;pure&lt;/code&gt; attribute can safely read any non-volatile objects, and modify the value of objects in a way that does not affect their return value or the observable state of the program.</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; атрибут запрещает функцию от изменения состояния программы , который различает кроме проверки возвращаемого значения функции средства. Однако функции, объявленные с атрибутом &lt;code&gt;pure&lt;/code&gt; , могут безопасно читать любые энергонезависимые объекты и изменять значение объектов таким образом, чтобы это не влияло на их возвращаемое значение или наблюдаемое состояние программы.</target>
        </trans-unit>
        <trans-unit id="24119821985c46d89b11400454926b0593b3b50d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_only&lt;/code&gt; access mode specifies that the pointer to which it applies is used to read the referenced object but not write to it. Unless the argument specifying the size of the access denoted by &lt;var&gt;size-index&lt;/var&gt; is zero, the referenced object must be initialized. The mode implies a stronger guarantee than the &lt;code&gt;const&lt;/code&gt; qualifier which, when cast away from a pointer, does not prevent the pointed-to object from being modified. Examples of the use of the &lt;code&gt;read_only&lt;/code&gt; access mode is the argument to the &lt;code&gt;puts&lt;/code&gt; function, or the second and third arguments to the &lt;code&gt;memcpy&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a3f3d3b23da8341683a81df31a980b08cf319c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_write&lt;/code&gt; access mode applies to arguments of pointer types without the &lt;code&gt;const&lt;/code&gt; qualifier. It specifies that the pointer to which it applies is used to both read and write the referenced object. Unless the argument specifying the size of the access denoted by &lt;var&gt;size-index&lt;/var&gt; is zero, the object referenced by the pointer must be initialized. An example of the use of the &lt;code&gt;read_write&lt;/code&gt; access mode is the first argument to the &lt;code&gt;strcat&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1720331b79d485f642342587a0a4961224f570c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; specifier affects code generation only in these ways:</source>
          <target state="translated">Спецификатор &lt;code&gt;register&lt;/code&gt; влияет на генерацию кода только следующими способами:</target>
        </trans-unit>
        <trans-unit id="a5258162416b278a0bfac9c4c7558d341c9154f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove-outfile&lt;/code&gt; spec function takes one argument. It looks for the first argument in the outfiles array and removes it. Here is a small example its usage:</source>
          <target state="translated">Функция спецификации &lt;code&gt;remove-outfile&lt;/code&gt; принимает один аргумент. Он ищет первый аргумент в массиве outfiles и удаляет его. Вот небольшой пример его использования:</target>
        </trans-unit>
        <trans-unit id="55bb4e8d3fe19956428bf774ea204bd862418b82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replace-outfile&lt;/code&gt; spec function takes two arguments. It looks for the first argument in the outfiles array and replaces it with the second argument. Here is a small example of its usage:</source>
          <target state="translated">Функция &lt;code&gt;replace-outfile&lt;/code&gt; spec принимает два аргумента. Он ищет первый аргумент в массиве Outfiles и заменяет его вторым аргументом. Вот небольшой пример его использования:</target>
        </trans-unit>
        <trans-unit id="9408f2030b23dd54137985158e8c003e073220be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_nonnull&lt;/code&gt; attribute specifies that the function return value should be a non-null pointer. For instance, the declaration:</source>
          <target state="translated">В &lt;code&gt;returns_nonnull&lt;/code&gt; атрибут указывает , что функция возвращает значение должно быть указателем ненулевым. Например, объявление:</target>
        </trans-unit>
        <trans-unit id="3e04bc9de35eb5e502accce1b00b75bbadd857dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_twice&lt;/code&gt; attribute tells the compiler that a function may return more than one time. The compiler ensures that all registers are dead before calling such a function and emits a warning about the variables that may be clobbered after the second return from the function. Examples of such functions are &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;vfork&lt;/code&gt;. The &lt;code&gt;longjmp&lt;/code&gt;-like counterpart of such function, if any, might need to be marked with the &lt;code&gt;noreturn&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;returns_twice&lt;/code&gt; атрибут указывает компилятору , что функция может возвращать более чем один раз. Компилятор гарантирует, что все регистры не работают, перед вызовом такой функции и выдает предупреждение о переменных, которые могут быть сбиты после второго возврата из функции. Примеры таких функций - &lt;code&gt;setjmp&lt;/code&gt; и &lt;code&gt;vfork&lt;/code&gt; . &lt;code&gt;longjmp&lt;/code&gt; -как аналог такой функции, если таковые имеются, возможно , придется быть помечена &lt;code&gt;noreturn&lt;/code&gt; атрибута.</target>
        </trans-unit>
        <trans-unit id="d109540c91de909173d68023125715d31c5696c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rtd&lt;/code&gt; instruction is supported by the 68010, 68020, 68030, 68040, 68060 and CPU32 processors, but not by the 68000 or 5200.</source>
          <target state="translated">&lt;code&gt;rtd&lt;/code&gt; инструкция поддерживается процессорами 68010, 68020, 68030, 68040, 68060 и CPU32, но не 68000 или 5200.</target>
        </trans-unit>
        <trans-unit id="d6a97b87fbba98b99c49488ce8d99f3965e9820d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_cmp_exp_gt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_lt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_eq&lt;/code&gt;, and &lt;code&gt;scalar_cmp_exp_unordered&lt;/code&gt; built-in functions return a non-zero value if &lt;code&gt;arg1&lt;/code&gt; is greater than, less than, equal to, or not comparable to &lt;code&gt;arg2&lt;/code&gt; respectively. The arguments are not comparable if one or the other equals NaN (not a number).</source>
          <target state="translated">&lt;code&gt;scalar_cmp_exp_gt&lt;/code&gt; , &lt;code&gt;scalar_cmp_exp_lt&lt;/code&gt; , &lt;code&gt;scalar_cmp_exp_eq&lt;/code&gt; и &lt;code&gt;scalar_cmp_exp_unordered&lt;/code&gt; встроенные функции возвращают ненулевое значение , если &lt;code&gt;arg1&lt;/code&gt; больше, меньше, равной или не сопоставимы с &lt;code&gt;arg2&lt;/code&gt; , соответственно. Аргументы несопоставимы, если один или другой равен NaN (не числу).</target>
        </trans-unit>
        <trans-unit id="8ed56e8dd6f8e41dde6e37a24332591f1ce27f7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; built-in functions return the significand and the biased exponent value respectively of their &lt;code&gt;source&lt;/code&gt; arguments. When supplied with a 64-bit &lt;code&gt;source&lt;/code&gt; argument, the result returned by &lt;code&gt;scalar_extract_sig&lt;/code&gt; has the &lt;code&gt;0x0010000000000000&lt;/code&gt; bit set if the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is in normalized form. Otherwise, this bit is set to 0. When supplied with a 128-bit &lt;code&gt;source&lt;/code&gt; argument, the &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; bit of the result is treated similarly. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;scalar_extract_sig&lt;/code&gt; function. Use the &lt;code&gt;scalar_test_neg&lt;/code&gt; function to test the sign of its &lt;code&gt;double&lt;/code&gt; argument.</source>
          <target state="translated">Для &lt;code&gt;scalar_extract_exp&lt;/code&gt; и &lt;code&gt;scalar_extract_sig&lt;/code&gt; требуется 64-разрядная среда, поддерживающая ISA 3.0 или новее. &lt;code&gt;scalar_extract_exp&lt;/code&gt; и &lt;code&gt;scalar_extract_sig&lt;/code&gt; встроенные функции возвращают мантиссу и предвзятое значение показателя степени соответственно их &lt;code&gt;source&lt;/code&gt; аргументов. При предоставлении с 64-битным &lt;code&gt;source&lt;/code&gt; аргументом результат, возвращаемый &lt;code&gt;scalar_extract_sig&lt;/code&gt; имеет установленный бит &lt;code&gt;0x0010000000000000&lt;/code&gt; , если &lt;code&gt;source&lt;/code&gt; аргумент функции находится в нормализованной форме. В противном случае этот бит устанавливается в 0. При использовании 128-битного аргумента &lt;code&gt;source&lt;/code&gt; &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; бит результата обрабатывается аналогично. Обратите внимание, что знак &lt;code&gt;scalar_extract_sig&lt;/code&gt; не представлен в результате, возвращаемом функцией scalar_extract_sig . Используйте функцию &lt;code&gt;scalar_test_neg&lt;/code&gt; , чтобы проверить знак &lt;code&gt;double&lt;/code&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="1f38aa375929331668f316b9a82c74ab6cc36489" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; built-in functions return the significand and the biased exponent value respectively of their &lt;code&gt;source&lt;/code&gt; arguments. When supplied with a 64-bit &lt;code&gt;source&lt;/code&gt; argument, the result returned by &lt;code&gt;scalar_extract_sig&lt;/code&gt; has the &lt;code&gt;0x0010000000000000&lt;/code&gt; bit set if the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is in normalized form. Otherwise, this bit is set to 0. When supplied with a 128-bit &lt;code&gt;source&lt;/code&gt; argument, the &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; bit of the result is treated similarly. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;scalar_extract_sig&lt;/code&gt; function. Use the &lt;code&gt;scalar_test_neg&lt;/code&gt; function to test the sign of its &lt;code&gt;double&lt;/code&gt; argument. The &lt;code&gt;vec_msum&lt;/code&gt; functions perform a vector multiply-sum, returning the result of arg1*arg2+arg3. ISA 3.0 adds support for vec_msum returning a vector int128 result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a572c2c2b0d3df765ec4322dbf92c35c2e4cbc19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_insert_exp&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. When supplied with a 64-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a double-precision floating point value that is constructed by assembling the values of its &lt;code&gt;significand&lt;/code&gt; and &lt;code&gt;exponent&lt;/code&gt; arguments. The sign of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 11 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 52 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="translated">Функции &lt;code&gt;scalar_insert_exp&lt;/code&gt; требуют 64-битной среды, поддерживающей ISA 3.0 или новее. При наличии 64-битного первого аргумента встроенная функция &lt;code&gt;scalar_insert_exp&lt;/code&gt; возвращает значение с плавающей запятой двойной точности, которое создается путем объединения значений его аргументов &lt;code&gt;significand&lt;/code&gt; и &lt;code&gt;exponent&lt;/code&gt; . Знак результата копируется из самого старшего &lt;code&gt;significand&lt;/code&gt; аргумента значимости . Компоненты мантиссы и экспоненты результата состоят из 11 младших битов аргумента &lt;code&gt;exponent&lt;/code&gt; и 52 младших битов &lt;code&gt;significand&lt;/code&gt; аргумента соответственно.</target>
        </trans-unit>
        <trans-unit id="30e5f673754badb55457e9f6e18bad2fb7c8867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_data_class&lt;/code&gt; built-in function returns 1 if any of the condition tests enabled by the value of the &lt;code&gt;condition&lt;/code&gt; variable are true, and 0 otherwise. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="translated">&lt;code&gt;scalar_test_data_class&lt;/code&gt; встроенной функция возвращает 1 , если любой из тестов состояния обеспечиваемых значения &lt;code&gt;condition&lt;/code&gt; переменного истинен, и 0 в противном случае. &lt;code&gt;condition&lt;/code&gt; аргумент должен быть константа времени компиляции целого числом со значением , не превышающим 127. &lt;code&gt;condition&lt;/code&gt; аргумента кодируются как битовая маска с каждым битом , позволяющего тестированием различных условий, как и характеризуются следующим:</target>
        </trans-unit>
        <trans-unit id="8baf3f4610726735a8a214eff212593a1cbf0b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_neg&lt;/code&gt; built-in function returns 1 if its &lt;code&gt;source&lt;/code&gt; argument holds a negative value, 0 otherwise.</source>
          <target state="translated">&lt;code&gt;scalar_test_neg&lt;/code&gt; встроенная функция возвращает 1 , если его &lt;code&gt;source&lt;/code&gt; аргумент имеет отрицательное значение, 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="312b5b4b73e9b711ee72f43d70d664005613348e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute causes an initialized global variable to have link-once semantics. When multiple definitions of the variable are encountered by the linker, the first is selected and the remainder are discarded. Following usage by the Microsoft compiler, the linker is told &lt;em&gt;not&lt;/em&gt; to warn about size or content differences of the multiple definitions.</source>
          <target state="translated">&lt;code&gt;selectany&lt;/code&gt; атрибут вызывает инициализацию глобальные переменный , чтобы иметь ссылку однократной семантики. Когда компоновщик обнаруживает несколько определений переменной, выбирается первое, а остальные отбрасываются. После использования компилятором Microsoft компоновщику предлагается &lt;em&gt;не&lt;/em&gt; предупреждать о различиях в размере или содержимом нескольких определений.</target>
        </trans-unit>
        <trans-unit id="7bbd5708df7b8ad51e26c82827c5a8837087e1d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute is only available on Microsoft Windows targets. You can use &lt;code&gt;__declspec (selectany)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((selectany))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">&lt;code&gt;selectany&lt;/code&gt; атрибут доступен только на цели Microsoft Windows. Вы можете использовать &lt;code&gt;__declspec (selectany)&lt;/code&gt; как синоним для &lt;code&gt;__attribute__ ((selectany))&lt;/code&gt; для совместимости с другими компиляторами.</target>
        </trans-unit>
        <trans-unit id="14873a7d123565ace388d75f6ab559389f994c52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; attribute is only available on Microsoft Windows.</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; атрибут доступен только в Microsoft Windows.</target>
        </trans-unit>
        <trans-unit id="9085a2da6609ed3bc0fa42e0bccb84c58724a810" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;si&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;si&lt;/code&gt; регистр.</target>
        </trans-unit>
        <trans-unit id="5a2831e5752e0e20c3cf70a499fe35cbe998dc8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;extra&lt;/code&gt; fields of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; structure allows your collection object to keep track of the state of the enumeration. In a simple array implementation, &lt;code&gt;state&lt;/code&gt; may keep track of the index of the last object that was returned, and &lt;code&gt;extra&lt;/code&gt; may be unused.</source>
          <target state="translated">В &lt;code&gt;state&lt;/code&gt; и &lt;code&gt;extra&lt;/code&gt; поля в &lt;code&gt;NSFastEnumerationState&lt;/code&gt; структуры позволяет ваш объект коллекции , чтобы следить за состоянием перечисления. В простой реализации массива &lt;code&gt;state&lt;/code&gt; может отслеживать индекс последнего возвращенного объекта, а &lt;code&gt;extra&lt;/code&gt; могут не использоваться.</target>
        </trans-unit>
        <trans-unit id="3c61038602bd0b5479d4058a6d4baafd6a0c2107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct __htm_tdb&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; describes the structure of the transaction diagnostic block as specified in the Principles of Operation manual chapter 5-91.</source>
          <target state="translated">Структура &lt;code&gt;struct __htm_tdb&lt;/code&gt; , определенная в &lt;code&gt;htmintrin.h&lt;/code&gt; , описывает структуру блока диагностики транзакции, как указано в главе 5-91 Руководства по Принципам работы.</target>
        </trans-unit>
        <trans-unit id="1669605966a6a01f0ff15b0d1cc0c388abd2971a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; attribute can be used for instance to have a function compiled with a different ISA (instruction set architecture) than the default. &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; атрибут может быть использован, например , иметь функцию , скомпилированную с другим ISA (набор инструкций архитектуры) , чем по умолчанию. '</target>
        </trans-unit>
        <trans-unit id="9c500ff15f72b79070a64c0e0436e7dcdc9aaf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_clones&lt;/code&gt; attribute is used to specify that a function be cloned into multiple versions compiled with different target options than specified on the command line. The supported options and restrictions are the same as for &lt;code&gt;target&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;target_clones&lt;/code&gt; атрибут используется для указания того, что функция клонировать в нескольких версиях , собранных с различными вариантами целевых , чем указано в командной строке. Поддерживаемые параметры и ограничения такие же, как и для &lt;code&gt;target&lt;/code&gt; атрибута.</target>
        </trans-unit>
        <trans-unit id="ccf91998c7f416dcbd90db0b120c7a4f8d3b089f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tls_model&lt;/code&gt; attribute sets thread-local storage model (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;) of a particular &lt;code&gt;__thread&lt;/code&gt; variable, overriding</source>
          <target state="translated">&lt;code&gt;tls_model&lt;/code&gt; наборы нитей локальная модель хранения атрибутов (см &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt; ) конкретной &lt;code&gt;__thread&lt;/code&gt; переменной, отменяя</target>
        </trans-unit>
        <trans-unit id="2f43feeb5f6870d9594f888564bad52895276f45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_absd&lt;/code&gt;, &lt;code&gt;vec_absdb&lt;/code&gt;, &lt;code&gt;vec_absdh&lt;/code&gt;, and &lt;code&gt;vec_absdw&lt;/code&gt; built-in functions each computes the absolute differences of the pairs of vector elements supplied in its two vector arguments, placing the absolute differences into the corresponding elements of the vector result.</source>
          <target state="translated">&lt;code&gt;vec_absd&lt;/code&gt; , &lt;code&gt;vec_absdb&lt;/code&gt; , &lt;code&gt;vec_absdh&lt;/code&gt; и &lt;code&gt;vec_absdw&lt;/code&gt; встроенные функции каждый вычисляет абсолютные разности пар векторных элементов , поставляемых в его двух векторных аргументов, размещение абсолютных различий в соответствующие элементы вектора результата.</target>
        </trans-unit>
        <trans-unit id="cc17321076f6146e9d0eff176ccfd2642bdf04e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_all_nez&lt;/code&gt;, &lt;code&gt;vec_any_eqz&lt;/code&gt;, and &lt;code&gt;vec_cmpnez&lt;/code&gt; perform pairwise comparisons between the elements at the same positions within their two vector arguments. The &lt;code&gt;vec_all_nez&lt;/code&gt; function returns a non-zero value if and only if all pairwise comparisons are not equal and no element of either vector argument contains a zero. The &lt;code&gt;vec_any_eqz&lt;/code&gt; function returns a non-zero value if and only if at least one pairwise comparison is equal or if at least one element of either vector argument contains a zero. The &lt;code&gt;vec_cmpnez&lt;/code&gt; function returns a vector of the same type as its two arguments, within which each element consists of all ones to denote that either the corresponding elements of the incoming arguments are not equal or that at least one of the corresponding elements contains zero. Otherwise, the element of the returned vector contains all zeros.</source>
          <target state="translated">В &lt;code&gt;vec_all_nez&lt;/code&gt; , &lt;code&gt;vec_any_eqz&lt;/code&gt; и &lt;code&gt;vec_cmpnez&lt;/code&gt; выполнения парных сравнений между в одних и тех же положениях в пределах своих двух векторных аргументов элементов. Функция &lt;code&gt;vec_all_nez&lt;/code&gt; возвращает ненулевое значение тогда и только тогда, когда все попарные сравнения не равны и ни один элемент любого аргумента вектора не содержит ноль. Функция &lt;code&gt;vec_any_eqz&lt;/code&gt; возвращает ненулевое значение тогда и только тогда, когда хотя бы одно попарное сравнение равно или если хотя бы один элемент любого аргумента вектора содержит ноль. &lt;code&gt;vec_cmpnez&lt;/code&gt; Функция возвращает вектор того же типа, что и два ее аргумента, в котором каждый элемент состоит из всех единиц, чтобы обозначить, что либо соответствующие элементы входящих аргументов не равны, либо хотя бы один из соответствующих элементов содержит ноль. В противном случае элемент возвращенного вектора содержит все нули.</target>
        </trans-unit>
        <trans-unit id="a9ea2035fded0002d7bb2f5901563d260d2323cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_cntlz_lsbb&lt;/code&gt; function returns the count of the number of consecutive leading byte elements (starting from position 0 within the supplied vector argument) for which the least-significant bit equals zero. The &lt;code&gt;vec_cnttz_lsbb&lt;/code&gt; function returns the count of the number of consecutive trailing byte elements (starting from position 15 and counting backwards within the supplied vector argument) for which the least-significant bit equals zero.</source>
          <target state="translated">Функция &lt;code&gt;vec_cntlz_lsbb&lt;/code&gt; возвращает количество последовательных ведущих байтовых элементов (начиная с позиции 0 в предоставленном векторном аргументе), для которых младший бит равен нулю. Функция &lt;code&gt;vec_cnttz_lsbb&lt;/code&gt; возвращает количество последовательных элементов завершающего байта (начиная с позиции 15 и считая в обратном порядке в пределах предоставленного аргумента вектора), для которых младший бит равен нулю.</target>
        </trans-unit>
        <trans-unit id="01b02bbdd65d95e68fbfa45f0222f7cae6e029b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_extract_sig&lt;/code&gt; and &lt;code&gt;vec_extract_exp&lt;/code&gt; built-in functions return vectors representing the significands and biased exponent values of their &lt;code&gt;source&lt;/code&gt; arguments respectively. Within the result vector returned by &lt;code&gt;vec_extract_sig&lt;/code&gt;, the &lt;code&gt;0x800000&lt;/code&gt; bit of each vector element returned when the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;float&lt;/code&gt; is set to 1 if the corresponding floating point value is in normalized form. Otherwise, this bit is set to 0. When the &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;double&lt;/code&gt;, the &lt;code&gt;0x10000000000000&lt;/code&gt; bit within each of the result vector&amp;rsquo;s elements is set according to the same rules. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;vec_extract_sig&lt;/code&gt; function. To extract the sign bits, use the &lt;code&gt;vec_cpsgn&lt;/code&gt; function, which returns a new vector within which all of the sign bits of its second argument vector are overwritten with the sign bits copied from the coresponding elements of its first argument vector, and all other (non-sign) bits of the second argument vector are copied unchanged into the result vector.</source>
          <target state="translated">&lt;code&gt;vec_extract_sig&lt;/code&gt; и &lt;code&gt;vec_extract_exp&lt;/code&gt; встроенные функции возвращают векторы , представляющие significands и смещенных значения экспонентов своих &lt;code&gt;source&lt;/code&gt; аргументов соответственно. В результирующем векторе, возвращаемом &lt;code&gt;vec_extract_sig&lt;/code&gt; , бит &lt;code&gt;0x800000&lt;/code&gt; каждого элемента вектора, возвращаемого, когда &lt;code&gt;source&lt;/code&gt; аргумент функции имеет тип &lt;code&gt;float&lt;/code&gt; , устанавливается в 1, если соответствующее значение с плавающей запятой находится в нормализованной форме. В противном случае этот бит устанавливается в 0. Если &lt;code&gt;source&lt;/code&gt; аргумент имеет тип &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;0x10000000000000&lt;/code&gt; бит в каждом элементе результирующего вектора устанавливается по тем же правилам. Обратите внимание, что знак &lt;code&gt;vec_extract_sig&lt;/code&gt; не представлен в результате, возвращаемом функцией vec_extract_sig . Чтобы извлечь знаковые биты, используйте функцию &lt;code&gt;vec_cpsgn&lt;/code&gt; , которая возвращает новый вектор, в котором все знаковые биты его второго вектора аргумента перезаписываются знаковыми битами, скопированными из соответствующих элементов его первого вектора аргумента, а все остальные (не -sign) биты второго вектора аргумента без изменений копируются в вектор результата.</target>
        </trans-unit>
        <trans-unit id="5a829a08652f6801fcbd433b37bbf07c5d838fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_insert_exp&lt;/code&gt; built-in functions return a vector of single- or double-precision floating point values constructed by assembling the values of their &lt;code&gt;significands&lt;/code&gt; and &lt;code&gt;exponents&lt;/code&gt; arguments into the corresponding elements of the returned vector. The sign of each element of the result is copied from the most significant bit of the corresponding entry within the &lt;code&gt;significands&lt;/code&gt; argument. Note that the relevant bits of the &lt;code&gt;significands&lt;/code&gt; argument are the same, for both integer and floating point types. The significand and exponent components of each element of the result are composed of the least significant bits of the corresponding &lt;code&gt;significands&lt;/code&gt; element and the least significant bits of the corresponding &lt;code&gt;exponents&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;vec_insert_exp&lt;/code&gt; встроенные функции возвращают вектор одно- или двойной точности значений с плавающей точкой , построенных по сборке значения их &lt;code&gt;significands&lt;/code&gt; и &lt;code&gt;exponents&lt;/code&gt; аргументов в соответствующие элементы возвращенного вектора. Знак каждого элемента результата копируется из наиболее значимого бита соответствующей записи в пределах &lt;code&gt;significands&lt;/code&gt; аргумента. Следует отметить , что соответствующие биты &lt;code&gt;significands&lt;/code&gt; аргумента являются такими же, как для целого числа и типов с плавающей точкой. Компоненты мантиссы и экспоненты каждого элемента результата состоят из младших значащих битов соответствующих &lt;code&gt;significands&lt;/code&gt; элемент и младшие значащие биты соответствующего элемента &lt;code&gt;exponents&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a91af05019f6d272dc741d0e069fe70406b3512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_revb&lt;/code&gt; built-in function reverses the bytes on an element by element basis. A vector of &lt;code&gt;vector unsigned char&lt;/code&gt; or &lt;code&gt;vector signed char&lt;/code&gt; reverses the bytes in the whole word.</source>
          <target state="translated">&lt;code&gt;vec_revb&lt;/code&gt; встроенная функция изменяет байты на поэлементно основе. Вектор типа &lt;code&gt;vector unsigned char&lt;/code&gt; или &lt;code&gt;vector signed char&lt;/code&gt; переворачивает байты во всем слове.</target>
        </trans-unit>
        <trans-unit id="9de89009a6ac207492ea21a351e324b964d19bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_rsqrt&lt;/code&gt;, &lt;code&gt;__builtin_rsqrt&lt;/code&gt;, and &lt;code&gt;__builtin_rsqrtf&lt;/code&gt; functions generate multiple instructions to implement the reciprocal sqrt functionality using reciprocal sqrt estimate instructions.</source>
          <target state="translated">Функции &lt;code&gt;vec_rsqrt&lt;/code&gt; , &lt;code&gt;__builtin_rsqrt&lt;/code&gt; и &lt;code&gt;__builtin_rsqrtf&lt;/code&gt; генерируют несколько инструкций для реализации обратной функциональности sqrt с использованием инструкций обратной оценки sqrt.</target>
        </trans-unit>
        <trans-unit id="246e48e9c9edd5f446bb04be8d23c0491da1918c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_slv&lt;/code&gt; and &lt;code&gt;vec_srv&lt;/code&gt; functions operate on all of the bytes of their &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;shift_distance&lt;/code&gt; arguments in parallel. The behavior of the &lt;code&gt;vec_slv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;slv_array&lt;/code&gt; within which elements 0 through 15 are the same as the entries in the &lt;code&gt;src&lt;/code&gt; array and element 16 equals 0. The result returned from the &lt;code&gt;vec_slv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(slv_array + i)) &amp;lt;&amp;lt; (0x07 &amp;amp;
shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type. The behavior of the &lt;code&gt;vec_srv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;srv_array&lt;/code&gt; within which element 0 equals zero and elements 1 through 16 equal the elements 0 through 15 of the &lt;code&gt;src&lt;/code&gt; array. The result returned from the &lt;code&gt;vec_srv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(srv_array + i)) &amp;gt;&amp;gt;
(0x07 &amp;amp; shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">Функции &lt;code&gt;vec_slv&lt;/code&gt; и &lt;code&gt;vec_srv&lt;/code&gt; работают со всеми байтами своих аргументов &lt;code&gt;src&lt;/code&gt; и &lt;code&gt;shift_distance&lt;/code&gt; параллельно. Поведение &lt;code&gt;vec_slv&lt;/code&gt; такое, как если бы существовал временный массив из 17 беззнаковых символов &lt;code&gt;slv_array&lt;/code&gt; , внутри которого элементы с 0 по 15 совпадают с записями в массиве &lt;code&gt;src&lt;/code&gt; , а элемент 16 равен 0. Результатом, возвращаемым функцией &lt;code&gt;vec_slv&lt;/code&gt; , является &lt;code&gt;__vector&lt;/code&gt; из 16 беззнаковых символов, внутри которых элемент &lt;code&gt;i&lt;/code&gt; вычисляется с использованием выражения C &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(slv_array + i)) &amp;lt;&amp;lt; (0x07 &amp;amp; shift_distance[i]))&lt;/code&gt; , с этим результирующим значением, приведенным к &lt;code&gt;unsigned char&lt;/code&gt; типу char . Поведение &lt;code&gt;vec_srv&lt;/code&gt; такое, как если бы существовал временный массив из 17 беззнаковых символов &lt;code&gt;srv_array&lt;/code&gt; , внутри которого элемент 0 равен нулю, а элементы с 1 по 16 равны элементам от 0 до 15 массива &lt;code&gt;src&lt;/code&gt; . Результатом, возвращаемым функцией &lt;code&gt;vec_srv&lt;/code&gt; , является &lt;code&gt;__vector&lt;/code&gt; из 16 символов без знака, в котором элемент &lt;code&gt;i&lt;/code&gt; вычисляется с использованием выражения C &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(srv_array + i)) &amp;gt;&amp;gt; (0x07 &amp;amp; shift_distance[i]))&lt;/code&gt; с этим результирующим значением, приведенным к &lt;code&gt;unsigned char&lt;/code&gt; типу char .</target>
        </trans-unit>
        <trans-unit id="6a1b591d1d5bc9da82b7b03dcf8d2e3d88da8bb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_test_data_class&lt;/code&gt; built-in function returns a vector representing the results of testing the &lt;code&gt;source&lt;/code&gt; vector for the condition selected by the &lt;code&gt;condition&lt;/code&gt; argument. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="translated">&lt;code&gt;vec_test_data_class&lt;/code&gt; встроенной функция возвращает вектор , представляющий результаты тестирования &lt;code&gt;source&lt;/code&gt; вектора для состояния выбранного &lt;code&gt;condition&lt;/code&gt; аргумента. &lt;code&gt;condition&lt;/code&gt; аргумент должен быть константа времени компиляции целого числом со значением , не превышающим 127. &lt;code&gt;condition&lt;/code&gt; аргумента кодируются как битовая маска с каждым битом , позволяющего тестированием различных условий, как и характеризуются следующим:</target>
        </trans-unit>
        <trans-unit id="991ae395a453d861dfb8c7b24fc2cbc3ce4b3da0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;vec_xl_len&lt;/code&gt; function loads a variable length vector from memory. The &lt;code&gt;vec_xst_len&lt;/code&gt; function stores a variable length vector to memory. With both the &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions, the &lt;code&gt;addr&lt;/code&gt; argument represents the memory address to or from which data will be transferred, and the &lt;code&gt;len&lt;/code&gt; argument represents the number of bytes to be transferred, as computed by the C expression &lt;code&gt;min((len &amp;amp; 0xff), 16)&lt;/code&gt;. If this expression&amp;rsquo;s value is not a multiple of the vector element&amp;rsquo;s size, the behavior of this function is undefined. In the case that the underlying computer is configured to run in big-endian mode, the data transfer moves bytes 0 to &lt;code&gt;(len - 1)&lt;/code&gt; of the corresponding vector. In little-endian mode, the data transfer moves bytes &lt;code&gt;(16 - len)&lt;/code&gt; to &lt;code&gt;15&lt;/code&gt; of the corresponding vector. For the load function, any bytes of the result vector that are not loaded from memory are set to zero. The value of the &lt;code&gt;addr&lt;/code&gt; argument need not be aligned on a multiple of the vector&amp;rsquo;s element size.</source>
          <target state="translated">Для &lt;code&gt;vec_xl_len&lt;/code&gt; и &lt;code&gt;vec_xst_len&lt;/code&gt; требуется 64-битная среда, поддерживающая ISA 3.0 или новее. Функция &lt;code&gt;vec_xl_len&lt;/code&gt; загружает вектор переменной длины из памяти. Функция &lt;code&gt;vec_xst_len&lt;/code&gt; сохраняет в памяти вектор переменной длины. С обеих &lt;code&gt;vec_xl_len&lt;/code&gt; и &lt;code&gt;vec_xst_len&lt;/code&gt; функций, то &lt;code&gt;addr&lt;/code&gt; аргумент представляет адрес памяти в или из которого будут переданы данные, а &lt;code&gt;len&lt;/code&gt; аргумент представляет собой число байтов , которые будут переданы, как вычислено выражением С &lt;code&gt;min((len &amp;amp; 0xff), 16)&lt;/code&gt; , Если значение этого выражения не кратно размеру элемента вектора, поведение этой функции не определено. В случае, если базовый компьютер настроен для работы в режиме прямого байта, передача данных перемещает байты 0 в &lt;code&gt;(len - 1)&lt;/code&gt; соответствующего вектора. В режиме little-endian при передаче данных байты &lt;code&gt;(16 - len)&lt;/code&gt; перемещаются в &lt;code&gt;15&lt;/code&gt; соответствующего вектора. Для функции загрузки любые байты результирующего вектора, которые не загружаются из памяти, устанавливаются в ноль. Значение аргумента &lt;code&gt;addr&lt;/code&gt; не обязательно должно быть выровнено по кратному размеру элемента вектора.</target>
        </trans-unit>
        <trans-unit id="32f436c7a33759092d0385b9b27659581036ece3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xlx&lt;/code&gt; and &lt;code&gt;vec_xrx&lt;/code&gt; functions extract the single element selected by the &lt;code&gt;index&lt;/code&gt; argument from the vector represented by the &lt;code&gt;data&lt;/code&gt; argument. The &lt;code&gt;index&lt;/code&gt; argument always specifies a byte offset, regardless of the size of the vector element. With &lt;code&gt;vec_xlx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; is the offset of the first byte of the element to be extracted. With &lt;code&gt;vec_xrx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; represents the last byte of the element to be extracted, measured from the right end of the vector. In other words, the last byte of the element to be extracted is found at position &lt;code&gt;(15 - index)&lt;/code&gt;. There is no requirement that &lt;code&gt;index&lt;/code&gt; be a multiple of the vector element size. However, if the size of the vector element added to &lt;code&gt;index&lt;/code&gt; is greater than 15, the content of the returned value is undefined.</source>
          <target state="translated">Функции &lt;code&gt;vec_xlx&lt;/code&gt; и &lt;code&gt;vec_xrx&lt;/code&gt; извлекают единственный элемент, выбранный аргументом &lt;code&gt;index&lt;/code&gt; из вектора, представленного аргументом &lt;code&gt;data&lt;/code&gt; . &lt;code&gt;index&lt;/code&gt; Аргумент всегда указывает смещение байта, независимо от размера элемента вектора. С &lt;code&gt;vec_xlx&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; является смещение первого байта элемента, подлежащего извлеченного. С &lt;code&gt;vec_xrx&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; представляет собой последние байты элемента, подлежащие извлеченным, измеренный от правого конца вектора. Другими словами, последний байт извлекаемого элемента находится в позиции &lt;code&gt;(15 - index)&lt;/code&gt; . Нет требования, чтобы &lt;code&gt;index&lt;/code&gt; быть кратным размеру элемента вектора. Однако, если размер элемента вектора, добавляемого в &lt;code&gt;index&lt;/code&gt; , больше 15, содержимое возвращаемого значения не определено.</target>
        </trans-unit>
        <trans-unit id="1ebaac2fb10fbefef121de501464e717714b8367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vector_size&lt;/code&gt; attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct. Only sizes that are positive power-of-two multiples of the base type size are currently allowed.</source>
          <target state="translated">&lt;code&gt;vector_size&lt;/code&gt; атрибут применим только к целочисленным и плавающим скалярам, хотя массивы, указатели и значение функции возврата допускаются в сочетании с этой конструкцией. В настоящее время разрешены только размеры, которые кратны размеру основного шрифта, кратному степени двух.</target>
        </trans-unit>
        <trans-unit id="837b5049d27cb5d3caabb0997e45a1cbb234446d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vliw&lt;/code&gt; attribute tells the compiler to emit instructions in VLIW mode instead of core mode. Note that this attribute is not allowed unless a VLIW coprocessor has been configured and enabled through command-line options.</source>
          <target state="translated">&lt;code&gt;vliw&lt;/code&gt; атрибут указывает компилятору инструкции излучающие в режиме VLIW вместо основного режима. Обратите внимание, что этот атрибут не разрешен, если сопроцессор VLIW не настроен и не включен с помощью параметров командной строки.</target>
        </trans-unit>
        <trans-unit id="42d2812dccb310da3b37a59c6a8e7a142b29dac3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warn_unused_result&lt;/code&gt; attribute causes a warning to be emitted if a caller of the function with this attribute does not use its return value. This is useful for functions where not checking the result is either a security problem or always a bug, such as &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;warn_unused_result&lt;/code&gt; атрибут вызывает предупреждение испускается , если вызывающие функции с этим атрибутом не использует возвращаемое значение. Это полезно для функций, в которых отсутствие проверки результата является либо проблемой безопасности, либо всегда ошибкой, например &lt;code&gt;realloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d86cabe39f6b2eca4b3f76217c522746181a80f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute causes a declaration of an external symbol to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. The overriding symbol must have the same type as the weak symbol. In addition, if it designates a variable it must also have the same size and alignment as the weak symbol. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64e3cfe5255e69eafb7d485c8c088e61fa4d8a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute causes the declaration to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</source>
          <target state="translated">&lt;code&gt;weak&lt;/code&gt; атрибут вызывает заявление, излучаемый как слабый символ , а не глобальный. Это в первую очередь полезно при определении библиотечных функций, которые можно переопределить в пользовательском коде, хотя его также можно использовать с объявлениями, не являющимися функциями. Слабые символы поддерживаются для целей ELF, а также для целей a.out при использовании ассемблера и компоновщика GNU.</target>
        </trans-unit>
        <trans-unit id="4250f8084c2d37890c56691349397dd644e93eba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;weak&lt;/code&gt; атрибут описывается в &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;общих атрибутов функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd7b693a88b68899809d3dfabebee19f1a4688b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weakref&lt;/code&gt; attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an &lt;code&gt;alias&lt;/code&gt; attribute naming the target symbol. Alternatively, &lt;var&gt;target&lt;/var&gt; may be given as an argument to &lt;code&gt;weakref&lt;/code&gt; itself, naming the target definition of the alias. The &lt;var&gt;target&lt;/var&gt; must have the same type as the declaration. In addition, if it designates a variable it must also have the same size and alignment as the declaration. In either form of the declaration &lt;code&gt;weakref&lt;/code&gt; implicitly marks the declared symbol as &lt;code&gt;weak&lt;/code&gt;. Without a &lt;var&gt;target&lt;/var&gt; given as an argument to &lt;code&gt;weakref&lt;/code&gt; or to &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt; is equivalent to &lt;code&gt;weak&lt;/code&gt; (in that case the declaration may be &lt;code&gt;extern&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362aefd1f311374abf7ac9d8d10e9633ea762db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weakref&lt;/code&gt; attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an &lt;code&gt;alias&lt;/code&gt; attribute naming the target symbol. Optionally, the &lt;var&gt;target&lt;/var&gt; may be given as an argument to &lt;code&gt;weakref&lt;/code&gt; itself. In either case, &lt;code&gt;weakref&lt;/code&gt; implicitly marks the declaration as &lt;code&gt;weak&lt;/code&gt;. Without a &lt;var&gt;target&lt;/var&gt;, given as an argument to &lt;code&gt;weakref&lt;/code&gt; or to &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt; is equivalent to &lt;code&gt;weak&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;weakref&lt;/code&gt; метки атрибутов декларацию в качестве слабой ссылки. Без аргументов он должен сопровождаться атрибутом &lt;code&gt;alias&lt;/code&gt; указывающим целевой символ. Необязательно, &lt;var&gt;target&lt;/var&gt; может быть указана в качестве аргумента самому &lt;code&gt;weakref&lt;/code&gt; . В любом случае &lt;code&gt;weakref&lt;/code&gt; неявно отмечает объявление как &lt;code&gt;weak&lt;/code&gt; . Без &lt;var&gt;target&lt;/var&gt; , заданной в качестве аргумента для &lt;code&gt;weakref&lt;/code&gt; или &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;weakref&lt;/code&gt; эквивалентен &lt;code&gt;weak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31c2b38693187358ef61afd2bbcd821fce4cea47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write_only&lt;/code&gt; access mode applies to arguments of pointer types without the &lt;code&gt;const&lt;/code&gt; qualifier. It specifies that the pointer to which it applies is used to write to the referenced object but not read from it. The object referenced by the pointer need not be initialized. An example of the use of the &lt;code&gt;write_only&lt;/code&gt; access mode is the first argument to the &lt;code&gt;strcpy&lt;/code&gt; function, or the first two arguments to the &lt;code&gt;fgets&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5580c84e305bbd75698ac25971a0df43ef6cc5f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;call_exp&lt;/var&gt; expression must be a function call, and the &lt;var&gt;pointer_exp&lt;/var&gt; expression must be a pointer. The &lt;var&gt;pointer_exp&lt;/var&gt; is passed to the function call in the target&amp;rsquo;s static chain location. The result of builtin is the result of the function call.</source>
          <target state="translated">&lt;var&gt;call_exp&lt;/var&gt; выражение должно быть вызовом функции, а &lt;var&gt;pointer_exp&lt;/var&gt; выражение должно быть указателем. &lt;var&gt;pointer_exp&lt;/var&gt; передается при вызове функции в статическом месте цепи мишени. Результат встроенной функции - это результат вызова функции.</target>
        </trans-unit>
        <trans-unit id="47808f5c44d74211446dd3107371068aa638bc2f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;information&lt;/var&gt; is human readable, but designed to be simple enough for machine parsing too.</source>
          <target state="translated">&lt;var&gt;information&lt;/var&gt; является читаемым человеком, но разработана , чтобы быть достаточно простой для разбора машины тоже.</target>
        </trans-unit>
        <trans-unit id="2e82b6b86f048807c7ae6131df8cf24c8fb6345a" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument must be a constant integer.</source>
          <target state="translated">&lt;var&gt;level&lt;/var&gt; аргумент должен быть постоянным целым числом.</target>
        </trans-unit>
        <trans-unit id="2457707eff68e08cd199be4e3c699bc3aefc86a0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument should be one of the following:</source>
          <target state="translated">&lt;var&gt;level&lt;/var&gt; аргумент должен быть один из следующих:</target>
        </trans-unit>
        <trans-unit id="9e08ee76b1da2a0a7eab6aae9dc5ab5a92291dc1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; can be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07133152e9a0d85287182cf9221be477141dff40" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;oldname&lt;/var&gt; used by &lt;code&gt;#pragma redefine_extname&lt;/code&gt; is always the C-language name.</source>
          <target state="translated">&lt;var&gt;oldname&lt;/var&gt; используется &lt;code&gt;#pragma redefine_extname&lt;/code&gt; всегда название C-язык.</target>
        </trans-unit>
        <trans-unit id="f9388ad5137ed5dfa5588bcfa11755abc3ce7181" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;options&lt;/var&gt; can be divided into three groups:</source>
          <target state="translated">Эти &lt;var&gt;options&lt;/var&gt; можно разделить на три группы:</target>
        </trans-unit>
        <trans-unit id="c19aabaea762edf72b5cc0612746c317d8ff2de8" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;os&lt;/var&gt; argument is the object size &lt;var&gt;s&lt;/var&gt; points to, like in the other built-in functions. There is a small difference in the behavior though, if &lt;var&gt;os&lt;/var&gt; is &lt;code&gt;(size_t) -1&lt;/code&gt;, the built-in functions are optimized into the non-checking functions only if &lt;var&gt;flag&lt;/var&gt; is 0, otherwise the checking function is called with &lt;var&gt;os&lt;/var&gt; argument set to &lt;code&gt;(size_t) -1&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;os&lt;/var&gt; аргумент размер объекта &lt;var&gt;s&lt;/var&gt; указывает на, как в других встроенных функций. Однако есть небольшая разница в поведении: если &lt;var&gt;os&lt;/var&gt; равен &lt;code&gt;(size_t) -1&lt;/code&gt; , встроенные функции оптимизируются в функции без проверки, только если &lt;var&gt;flag&lt;/var&gt; равен 0, в противном случае функция проверки вызывается с аргументом &lt;var&gt;os&lt;/var&gt; , установленным в &lt;code&gt;(size_t) -1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99051c6bb8529049d31b5150a695460a96f0eb50" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; can either be a number (decimal, octal or hex) or an arbitrary string (in which case it&amp;rsquo;s converted to a number by computing CRC32).</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; может быть либо число (десятичное, восьмеричное или шестнадцатеричное) или произвольную строку (в этом случае он преобразуется в число с помощью вычисления CRC32).</target>
        </trans-unit>
        <trans-unit id="e2a9a665b951d617734d12093bb7933ae309b7f0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; should be different for every file you compile.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; должна быть различной для каждого файла , который вы компиляция.</target>
        </trans-unit>
        <trans-unit id="e5cf6b74b693d7f4748254b48ea16e3b5621f730" translate="yes" xml:space="preserve">
          <source>The ABI tags apply to a name, so all instantiations and specializations of a template have the same tags. The attribute will be ignored if applied to an explicit specialization or instantiation.</source>
          <target state="translated">Тэги ABI применяются к имени,поэтому все инстанцинации и специализации шаблона имеют одинаковые теги.Атрибут будет проигнорирован,если применен к явной специализации или инстанцированию.</target>
        </trans-unit>
        <trans-unit id="d6e578589905c0491635616be2b8a8085308fc15" translate="yes" xml:space="preserve">
          <source>The AIX calling convention was extended but not initially documented to handle an obscure K&amp;amp;R C case of calling a function that takes the address of its arguments with fewer arguments than declared. IBM XL compilers access floating-point arguments that do not fit in the RSA from the stack when a subroutine is compiled without optimization. Because always storing floating-point arguments on the stack is inefficient and rarely needed, this option is not enabled by default and only is necessary when calling subroutines compiled by IBM XL compilers without optimization.</source>
          <target state="translated">Соглашение о вызовах AIX было расширено, но изначально не задокументировано для обработки неясного случая K&amp;amp;R C вызова функции, которая принимает адрес своих аргументов с меньшим количеством аргументов, чем объявлено. Компиляторы IBM XL получают доступ к аргументам с плавающей запятой, которые не подходят для RSA, из стека, когда подпрограмма компилируется без оптимизации. Поскольку постоянное хранение аргументов с плавающей запятой в стеке неэффективно и редко требуется, эта опция не включена по умолчанию и необходима только при вызове подпрограмм, скомпилированных компиляторами IBM XL без оптимизации.</target>
        </trans-unit>
        <trans-unit id="0286e5ab4aaa67941386b2ad2370f9a09da6cea5" translate="yes" xml:space="preserve">
          <source>The ARM attribute &lt;code&gt;Tag_CPU_unaligned_access&lt;/code&gt; is set in the generated object file to either true or false, depending upon the setting of this option. If unaligned access is enabled then the preprocessor symbol &lt;code&gt;__ARM_FEATURE_UNALIGNED&lt;/code&gt; is also defined.</source>
          <target state="translated">Атрибут ARM &lt;code&gt;Tag_CPU_unaligned_access&lt;/code&gt; устанавливается в сгенерированном объектном файле в значение true или false, в зависимости от настройки этой опции. Если разрешен невыровненный доступ, то также определяется символ препроцессора &lt;code&gt;__ARM_FEATURE_UNALIGNED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38b655dda41c627fb0c53750526171175cc9f72b" translate="yes" xml:space="preserve">
          <source>The ARM target defines pragmas for controlling the default addition of &lt;code&gt;long_call&lt;/code&gt; and &lt;code&gt;short_call&lt;/code&gt; attributes to functions. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for information about the effects of these attributes.</source>
          <target state="translated">Цель ARM определяет прагмы для управления добавлением &lt;code&gt;long_call&lt;/code&gt; и &lt;code&gt;short_call&lt;/code&gt; по умолчанию к функциям. См. &amp;laquo; &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&amp;raquo;&lt;/a&gt; для получения информации о влиянии этих атрибутов.</target>
        </trans-unit>
        <trans-unit id="180b9a433ddcfbb50e74358632373510b9ae0866" translate="yes" xml:space="preserve">
          <source>The ARM target provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; values as an extension to VFP and NEON (Advanced SIMD), and from ARMv8-A provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; values. GCC generates code using these hardware instructions if you compile with options to select an FPU that provides them; for example,</source>
          <target state="translated">Цель ARM обеспечивает аппаратную поддержку преобразований между значениями &lt;code&gt;__fp16&lt;/code&gt; и &lt;code&gt;float&lt;/code&gt; в качестве расширения для VFP и NEON (Advanced SIMD), а из ARMv8-A обеспечивает аппаратную поддержку преобразований между значениями &lt;code&gt;__fp16&lt;/code&gt; и &lt;code&gt;double&lt;/code&gt; . GCC генерирует код, используя эти аппаратные инструкции, если вы компилируете с опциями для выбора FPU, который их предоставляет; например,</target>
        </trans-unit>
        <trans-unit id="74677651175ff4a21af34df2adc4b16af0c62864" translate="yes" xml:space="preserve">
          <source>The ARM-state integer division instructions.</source>
          <target state="translated">Инструкции по целочисленному делению ARM-состояния.</target>
        </trans-unit>
        <trans-unit id="25504eb2b5db6b1309f7e3ea71e7847bbe69ef9e" translate="yes" xml:space="preserve">
          <source>The ARMv8-A Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Усовершенствованная SIMD-система ARMv8-A и инструкции с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="7f8a18de7f60ebb2b7344b3e4891cc4342f1a12d" translate="yes" xml:space="preserve">
          <source>The ARMv8.1-A Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Усовершенствованные SIMD-инструкции ARMv8.1-A и инструкции с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="33734522bf6eef68d24bf96c977fe3c147340232" translate="yes" xml:space="preserve">
          <source>The ARMv8.3-A Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="translated">Усовершенствованные SIMD-инструкции ARMv8.3-A и инструкции с плавающей запятой,а также расширение Dot Product.</target>
        </trans-unit>
        <trans-unit id="2e1c8ef545821a2ae5bcfc55a26fd3b81629816e" translate="yes" xml:space="preserve">
          <source>The AT&amp;amp;T C++ translator, Cfront, solved the template instantiation problem by creating the notion of a template repository, an automatically maintained place where template instances are stored. A more modern version of the repository works as follows: As individual object files are built, the compiler places any template definitions and instantiations encountered in the repository. At link time, the link wrapper adds in the objects in the repository and compiles any needed instances that were not previously emitted. The advantages of this model are more optimal compilation speed and the ability to use the system linker; to implement the Borland model a compiler vendor also needs to replace the linker. The disadvantages are vastly increased complexity, and thus potential for error; for some code this can be just as transparent, but in practice it can been very difficult to build multiple programs in one directory and one program in multiple directories. Code written for this model tends to separate definitions of non-inline member templates into a separate file, which should be compiled separately.</source>
          <target state="translated">Переводчик C ++ компании AT&amp;amp;T, Cfront, решил проблему создания экземпляров шаблонов, создав понятие репозитория шаблонов, автоматически поддерживаемого места, где хранятся экземпляры шаблонов. Более современная версия репозитория работает следующим образом: по мере создания отдельных объектных файлов компилятор помещает в репозиторий любые определения шаблонов и экземпляры, встречающиеся в нем. Во время связывания оболочка ссылки добавляет объекты в репозиторий и компилирует все необходимые экземпляры, которые ранее не были отправлены. Преимущества этой модели - более оптимальная скорость компиляции и возможность использования системного компоновщика; для реализации модели Borland поставщик компилятора также должен заменить компоновщик. Недостатки - значительно увеличенная сложность и, следовательно, возможность ошибки; для некоторого кода это может быть таким же прозрачным,но на практике может быть очень сложно построить несколько программ в одном каталоге и одну программу в нескольких каталогах. Код, написанный для этой модели, имеет тенденцию выделять определения не встроенных шаблонов элементов в отдельный файл, который следует компилировать отдельно.</target>
        </trans-unit>
        <trans-unit id="b2f96e374cb7c3be8b863693d2e8387693d91334" translate="yes" xml:space="preserve">
          <source>The AVR hardware globally disables interrupts when an interrupt is executed. Interrupt handler functions defined with the &lt;code&gt;signal&lt;/code&gt; attribute do not re-enable interrupts. It is save to enable interrupts in a &lt;code&gt;signal&lt;/code&gt; handler. This &amp;ldquo;save&amp;rdquo; only applies to the code generated by the compiler and not to the IRQ layout of the application which is responsibility of the application.</source>
          <target state="translated">Аппаратное обеспечение AVR глобально отключает прерывания, когда прерывание выполняется. Функции обработчика прерываний, определенные с помощью атрибута &lt;code&gt;signal&lt;/code&gt; , не активируют прерывания повторно. Сохраняется разрешение прерывания в обработчике &lt;code&gt;signal&lt;/code&gt; . Это &amp;laquo;сохранение&amp;raquo; применяется только к коду, сгенерированному компилятором, а не к макету IRQ приложения, за которое отвечает приложение.</target>
        </trans-unit>
        <trans-unit id="819e5dd1ebff38014ce3cc47fe71028f5e880298" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions, with the half-precision floating-point conversion operations.</source>
          <target state="translated">Усовершенствованный SIMD (Neon)v1 и инструкции VFPv3 с плавающей запятой,содержащие операции преобразования с плавающей запятой с половинной точностью.</target>
        </trans-unit>
        <trans-unit id="04a974f086b15b184d16af3fa03c2b5403d55b20" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Advanced SIMD (Neon) v1 и инструкции с плавающей запятой VFPv3. Расширение '</target>
        </trans-unit>
        <trans-unit id="3b1828fb03b38714492461b5c83b7a35d9811c07" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extensions &amp;lsquo;</source>
          <target state="translated">Advanced SIMD (Neon) v1 и инструкции с плавающей запятой VFPv3. Расширения</target>
        </trans-unit>
        <trans-unit id="25f15c2fd3a5e4f09bf2de0e8dd88934f187e30c" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions.</source>
          <target state="translated">Усовершенствованный SIMD (Neon)v2 и инструкции VFPv4 с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="8fb627100c24fb77ea39c11992a8aa490fe9b6bf" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Advanced SIMD (Neon) v2 и инструкции с плавающей запятой VFPv4. Расширение '</target>
        </trans-unit>
        <trans-unit id="a0b4e865040163440dd355cb51993ec44628f3a4" translate="yes" xml:space="preserve">
          <source>The Alpha architecture implements floating-point hardware optimized for maximum performance. It is mostly compliant with the IEEE floating-point standard. However, for full compliance, software assistance is required. This option generates code fully IEEE-compliant code &lt;em&gt;except&lt;/em&gt; that the &lt;var&gt;inexact-flag&lt;/var&gt; is not maintained (see below). If this option is turned on, the preprocessor macro &lt;code&gt;_IEEE_FP&lt;/code&gt; is defined during compilation. The resulting code is less efficient but is able to correctly support denormalized numbers and exceptional IEEE values such as not-a-number and plus/minus infinity. Other Alpha compilers call this option</source>
          <target state="translated">В архитектуре Alpha реализовано оборудование с плавающей запятой, оптимизированное для максимальной производительности. Он в основном соответствует стандарту с плавающей запятой IEEE. Однако для полного соответствия требуется помощь программного обеспечения. Эта опция генерирует код, полностью совместимый с IEEE, &lt;em&gt;за исключением того,&lt;/em&gt; что не поддерживается &lt;var&gt;inexact-flag&lt;/var&gt; (см. Ниже). Если эта опция &lt;code&gt;_IEEE_FP&lt;/code&gt; макрос препроцессора _IEEE_FP определяется во время компиляции. Получающийся в результате код менее эффективен, но способен правильно поддерживать денормализованные числа и исключительные значения IEEE, такие как не-число и плюс / минус бесконечность. Другие компиляторы Alpha называют эту опцию</target>
        </trans-unit>
        <trans-unit id="a224b29d0d210a4ad06df789e64da22f568f6054" translate="yes" xml:space="preserve">
          <source>The AltiVec built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.06 or later. These are normally enabled by adding</source>
          <target state="translated">Встроенные функции AltiVec,описанные в этом разделе,доступны в семействе процессоров PowerPC,начиная с ISA 2.06 или более поздней версии.Обычно они включаются путем добавления</target>
        </trans-unit>
        <trans-unit id="224e64a8094f6a857fb86e36e422aa4067f4740c" translate="yes" xml:space="preserve">
          <source>The C and C++ language specifications differ when an object is accessed in a void context:</source>
          <target state="translated">Спецификации языка Си и Си++различаются при доступе к объекту в пустом контексте:</target>
        </trans-unit>
        <trans-unit id="0ef06715d23eab6e0953d0e3dffa82f688ece5af" translate="yes" xml:space="preserve">
          <source>The C and C++ standards define the order in which expressions in a C/C++ program are evaluated in terms of &lt;em&gt;sequence points&lt;/em&gt;, which represent a partial ordering between the execution of parts of the program: those executed before the sequence point, and those executed after it. These occur after the evaluation of a full expression (one which is not part of a larger expression), after the evaluation of the first operand of a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;? :&lt;/code&gt; or &lt;code&gt;,&lt;/code&gt; (comma) operator, before a function is called (but after the evaluation of its arguments and the expression denoting the called function), and in certain other places. Other than as expressed by the sequence point rules, the order of evaluation of subexpressions of an expression is not specified. All these rules describe only a partial order rather than a total order, since, for example, if two functions are called within one expression with no sequence point between them, the order in which the functions are called is not specified. However, the standards committee have ruled that function calls do not overlap.</source>
          <target state="translated">Стандарты C и C ++ определяют порядок, в котором выражения в программе C / C ++ оцениваются с точки зрения &lt;em&gt;точек последовательности&lt;/em&gt; , которые представляют собой частичный порядок между выполнением частей программы: те, которые выполняются до точки последовательности, и те, которые выполняются после Это. Это происходит после оценки полного выражения (того, которое не является частью большего выражения), после оценки первого операнда &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;? :&lt;/code&gt; или &lt;code&gt;,&lt;/code&gt; (запятая) перед вызовом функции (но после оценки ее аргументов и выражения, обозначающего вызываемую функцию) и в некоторых других местах. За исключением случаев, указанных в правилах точки последовательности, порядок оценки подвыражений выражения не указывается. Все эти правила описывают только частичный порядок, а не общий порядок, поскольку, например, если две функции вызываются в одном выражении без точки последовательности между ними, порядок, в котором функции вызываются, не указывается. Однако комитет по стандартам постановил, что вызовы функций не перекрываются.</target>
        </trans-unit>
        <trans-unit id="ef19b8344a45aab20d25a471f2eb0b887d44fb1e" translate="yes" xml:space="preserve">
          <source>The C++ ABI requires multiple entry points for constructors and destructors: one for a base subobject, one for a complete object, and one for a virtual destructor that calls operator delete afterwards. For a hierarchy with virtual bases, the base and complete variants are clones, which means two copies of the function. With this option, the base and complete variants are changed to be thunks that call a common implementation.</source>
          <target state="translated">Для C++ABI требуется несколько точек входа для конструкторов и деструкторов:одна для базового подобъекта,одна для полного объекта и одна для виртуального деструктора,вызывающего после этого оператор delete.Для иерархии с виртуальными базами базовый и полный варианты являются клонами,что означает две копии функции.С помощью этой опции базовый и полный варианты изменяются на клоны,вызывающие общую реализацию.</target>
        </trans-unit>
        <trans-unit id="e88e1274e3c31338e664afbec99b09eac3f5a529" translate="yes" xml:space="preserve">
          <source>The C++ front end implements syntactic extensions that allow compile-time determination of various characteristics of a type (or of a pair of types).</source>
          <target state="translated">Во фронтальной части C++реализованы синтаксические расширения,позволяющие скомпилировать время определения различных характеристик типа (или пары типов).</target>
        </trans-unit>
        <trans-unit id="ec04375b745b1f1c4ce1f6fa5f903e079a94852c" translate="yes" xml:space="preserve">
          <source>The C++ language was further revised in 2017 and ISO/IEC 14882:2017 was published. This is referred to as C++17, and before publication was often referred to as C++1z. GCC supports all the changes in the new specification. For further details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&lt;/a&gt;. Use the option</source>
          <target state="translated">В 2017 году язык C ++ был дополнительно переработан, и был опубликован ISO / IEC 14882: 2017. Это называется C ++ 17, а до публикации часто упоминалось как C ++ 1z. GCC поддерживает все изменения в новой спецификации. Для получения дополнительных сведений см. &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&quot;&gt;Https://gcc.gnu.org/projects/cxx-status.html#cxx1z&lt;/a&gt; . Воспользуйтесь опцией</target>
        </trans-unit>
        <trans-unit id="bcdb3a64fa68982d2e2c4cbdd5d9be1a69decab7" translate="yes" xml:space="preserve">
          <source>The C++ library used with a C++ compiler includes the Standard C++ Library, with functionality defined in the C++ Standard, plus language runtime support. The runtime support is included in a C++ ABI, but there is no formal ABI for the Standard C++ Library. Two implementations of that library are interoperable if one follows the de-facto ABI of the other and if they are both built with the same compiler, or with compilers that conform to the same ABI for C++ compiler and runtime support.</source>
          <target state="translated">Библиотека C++,используемая с компилятором C++,включает в себя Стандартную библиотеку C++,с функциональностью,определенной в Стандарте C++,плюс поддержкой языка выполнения.Поддержка среды исполнения включена в C++ABI,но для Стандартной библиотеки C++нет формального ABI.Две реализации этой библиотеки являются взаимозаменяемыми,если одна следует за де-факто ABI другой и если обе они собраны одним компилятором,или с компиляторами,которые соответствуют одному ABI для компилятора C++и поддержкой времени исполнения.</target>
        </trans-unit>
        <trans-unit id="b030a2dbb3c8b3c3ceafa77d7dbaf4d97c312843" translate="yes" xml:space="preserve">
          <source>The C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type. Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases. This option also causes G++ to call trivial member functions which otherwise would be expanded inline.</source>
          <target state="translated">Стандарт C++позволяет в реализации пропустить создание временного объекта,который используется только для инициализации другого объекта того же типа.Указание этой опции отключает эту оптимизацию и заставляет G++вызывать конструктор копирования во всех случаях.Эта опция также заставляет G++вызывать тривиальные функции-члены,которые в противном случае были бы расширены inline.</target>
        </trans-unit>
        <trans-unit id="c549c47d787f5172f4a63d73dccb4d86a5de3eaa" translate="yes" xml:space="preserve">
          <source>The C++ standard differs from the C standard in its treatment of volatile objects. It fails to specify what constitutes a volatile access, except to say that C++ should behave in a similar manner to C with respect to volatiles, where possible. However, the different lvalueness of expressions between C and C++ complicate the behavior. G++ behaves the same as GCC for volatile access, See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Volatiles&lt;/a&gt;, for a description of GCC&amp;rsquo;s behavior.</source>
          <target state="translated">Стандарт C ++ отличается от стандарта C обработкой изменчивых объектов. В нем не указывается, что представляет собой изменчивый доступ, за исключением того, что сказано, что C ++ должен вести себя аналогично C в отношении изменчивых элементов, где это возможно. Однако различная ценность выражений между C и C ++ усложняет поведение. G ++ ведет себя так же, как GCC для изменчивого доступа, см. &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Volatiles&lt;/a&gt; , где описано поведение GCC.</target>
        </trans-unit>
        <trans-unit id="949a50a0730c5f7ad89696edd9c2072338129167" translate="yes" xml:space="preserve">
          <source>The C++ standard just uses the term &amp;ldquo;dependent&amp;rdquo; for names that depend on the type or value of template parameters. This shorter term will also be used in the rest of this section.</source>
          <target state="translated">Стандарт C ++ просто использует термин &amp;laquo;зависимые&amp;raquo; для имен, которые зависят от типа или значения параметров шаблона. Этот более короткий термин также будет использоваться в оставшейся части этого раздела.</target>
        </trans-unit>
        <trans-unit id="7681d0e5c1533a0361ba254a5958bd845de12e17" translate="yes" xml:space="preserve">
          <source>The C++ standard prescribes that all names that are not dependent on template parameters are bound to their present definitions when parsing a template function or class.&lt;a href=&quot;#FOOT5&quot; id=&quot;DOCF5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; Only names that are dependent are looked up at the point of instantiation. For example, consider</source>
          <target state="translated">Стандарт C ++ предписывает, чтобы все имена, не зависящие от параметров шаблона, были привязаны к своим текущим определениям при синтаксическом анализе функции или класса шаблона. &lt;a href=&quot;#FOOT5&quot; id=&quot;DOCF5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5 При&lt;/sup&gt;&lt;/a&gt; создании экземпляра ищутся только зависимые имена. Например, рассмотрим</target>
        </trans-unit>
        <trans-unit id="253e6af722c0841d38d6e4f298c9a3cde3c002be" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that &amp;lsquo;</source>
          <target state="translated">Стандарт C ++ определяет, что '</target>
        </trans-unit>
        <trans-unit id="7e51d56fadfe74149ae162a54ac1fe3c8b16dbb0" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that such expressions do not undergo lvalue to rvalue conversion, and that the type of the dereferenced object may be incomplete. The C++ standard does not specify explicitly that it is lvalue to rvalue conversion that is responsible for causing an access. There is reason to believe that it is, because otherwise certain simple expressions become undefined. However, because it would surprise most programmers, G++ treats dereferencing a pointer to volatile object of complete type as GCC would do for an equivalent type in C. When the object has incomplete type, G++ issues a warning; if you wish to force an error, you must force a conversion to rvalue with, for instance, a static cast.</source>
          <target state="translated">В стандарте языка Си++указано,что такие выражения не подвергаются приведению lvalue to rvalue,и что тип разыменованного объекта может быть неполным.В стандарте Си++явно не указано,что именно преобразование lvalue to rvalue является причиной доступа.Есть основания полагать,что это так,так как в противном случае некоторые простые выражения становятся неопределенными.Однако,так как это удивило бы большинство программистов,G++рассматривает разыменование указателя на летучий объект полного типа,как это сделал бы GCC для эквивалентного типа в Си.Когда объект имеет неполный тип,G++выдает предупреждение;если вы хотите вызвать ошибку,то вы должны вызвать приведение к значению,например,статическим приведением.</target>
        </trans-unit>
        <trans-unit id="73a31b9577ac049499e169205951815b4d802407" translate="yes" xml:space="preserve">
          <source>The C++11 and OpenMP standards allow &lt;code&gt;thread_local&lt;/code&gt; and &lt;code&gt;threadprivate&lt;/code&gt; variables to have dynamic (runtime) initialization. To support this, any use of such a variable goes through a wrapper function that performs any necessary initialization. When the use and definition of the variable are in the same translation unit, this overhead can be optimized away, but when the use is in a different translation unit there is significant overhead even if the variable doesn&amp;rsquo;t actually need dynamic initialization. If the programmer can be sure that no use of the variable in a non-defining TU needs to trigger dynamic initialization (either because the variable is statically initialized, or a use of the variable in the defining TU will be executed before any uses in another TU), they can avoid this overhead with the</source>
          <target state="translated">Стандарты C ++ 11 и OpenMP позволяют использовать &lt;code&gt;thread_local&lt;/code&gt; и &lt;code&gt;threadprivate&lt;/code&gt; .переменные для динамической инициализации (во время выполнения). Для поддержки этого любое использование такой переменной проходит через функцию-оболочку, которая выполняет любую необходимую инициализацию. Когда использование и определение переменной находятся в одной и той же единице трансляции, эти накладные расходы можно оптимизировать, но когда использование находится в другой единице трансляции, возникают значительные накладные расходы, даже если переменная фактически не требует динамической инициализации. Если программист может быть уверен, что использование переменной в не определяющей TU не должно запускать динамическую инициализацию (либо потому, что переменная инициализирована статически, либо использование переменной в определяющей TU будет выполнено до любого использования в другом TU), они могут избежать этих накладных расходов с помощью</target>
        </trans-unit>
        <trans-unit id="da8ab7209d2ba607c1022648449bd576dc30ecb4" translate="yes" xml:space="preserve">
          <source>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this option will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463aa5596934552e20b1c86daa9eff2befcfafd9" translate="yes" xml:space="preserve">
          <source>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this warning will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++.</source>
          <target state="translated">Стандарт C++17 будет определять порядок оценки операндов в большем количестве случаев:в частности,он требует,чтобы правая сторона задания оценивалась перед левой,так что вышеприведенные примеры больше не являются неопределенными.Но это предупреждение всё равно будет предупреждать о них,чтобы помочь людям избежать написания кода,который неопределён в Си и более ранних ревизиях Си++.</target>
        </trans-unit>
        <trans-unit id="3f8518a5ffcdc724e580f436c8e8861c47a79dbf" translate="yes" xml:space="preserve">
          <source>The CC register.</source>
          <target state="translated">Реестр СС.</target>
        </trans-unit>
        <trans-unit id="aac83138ffc7dedbba141af64e9e3833a7581060" translate="yes" xml:space="preserve">
          <source>The Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="translated">Инструкции по циклической проверке избыточности (CRC).</target>
        </trans-unit>
        <trans-unit id="26d3b88b25735a58406b058569b742cd7ef6e371" translate="yes" xml:space="preserve">
          <source>The DSP instructions.</source>
          <target state="translated">Инструкции DSP.</target>
        </trans-unit>
        <trans-unit id="8a394fdb5f659a018583a4b282fa046a537ed960" translate="yes" xml:space="preserve">
          <source>The Darwin tools vary in their behavior when presented with an ISA mismatch. The assembler,</source>
          <target state="translated">Инструменты Дарвина варьируются в своем поведении при представлении несовпадения ISA.Ассемблер,</target>
        </trans-unit>
        <trans-unit id="c474ab61fc35bcc3be354a3a5837d9c0d40e8830" translate="yes" xml:space="preserve">
          <source>The GCC port for AArch64 only supports the IEEE 754-2008 format, and does not require use of the</source>
          <target state="translated">Порт GCC для AArch64 поддерживает только IEEE 754-2008 формат,и не требует использования</target>
        </trans-unit>
        <trans-unit id="0079c12261c57d6bab6a15c723b1304a15531596" translate="yes" xml:space="preserve">
          <source>The GNU C compiler supports both dialects; you can specify the signed dialect with</source>
          <target state="translated">Компилятор Си GNU поддерживает оба диалекта;вы можете указать подписанный диалект с помощью команды</target>
        </trans-unit>
        <trans-unit id="9a9482fb99a743f48dbd7859a7e8e12b5401b580" translate="yes" xml:space="preserve">
          <source>The GNU C preprocessor recognizes several pragmas in addition to the compiler pragmas documented here. Refer to the CPP manual for more information.</source>
          <target state="translated">Препроцессор GNU C распознает несколько прагм в дополнение к задокументированным здесь прагмам компилятора.Дополнительные сведения см.в руководстве по CPP.</target>
        </trans-unit>
        <trans-unit id="0227d0ba5f10912bdc54f8efb32ad7ab5a1942f8" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a hook, called &lt;code&gt;__objc_msg_forward2&lt;/code&gt;, which is called by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; when it cannot find a method implementation in the runtime tables and after calling &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;+resolveClassMethod:&lt;/code&gt; has been attempted and did not succeed in dynamically registering the method.</source>
          <target state="translated">Среда выполнения GNU Objective-C предоставляет перехватчик, называемый &lt;code&gt;__objc_msg_forward2&lt;/code&gt; , который вызывается &lt;code&gt;objc_msg_lookup()&lt;/code&gt; когда он не может найти реализацию метода в таблицах времени выполнения и после вызова &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; и &lt;code&gt;+resolveClassMethod:&lt;/code&gt; была предпринята попытка и не удалось выполнить динамически регистрация метода.</target>
        </trans-unit>
        <trans-unit id="c32c2c0d5cf1c06ca2fc7f8fc5108f046c90f6d6" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a way that allows you to execute code before the execution of the program enters the &lt;code&gt;main&lt;/code&gt; function. The code is executed on a per-class and a per-category basis, through a special class method &lt;code&gt;+load&lt;/code&gt;.</source>
          <target state="translated">Среда выполнения GNU Objective-C предоставляет способ, позволяющий выполнять код до того, как выполнение программы перейдет в &lt;code&gt;main&lt;/code&gt; функцию. Код выполняется для каждого класса и для каждой категории с помощью специального метода класса &lt;code&gt;+load&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6204b4438d0b4bf08e65cf328298ab3f8520d1f5" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API that allows you to interact with the Objective-C runtime system, querying the live runtime structures and even manipulating them. This allows you for example to inspect and navigate classes, methods and protocols; to define new classes or new methods, and even to modify existing classes or protocols.</source>
          <target state="translated">В среде исполнения GNU Objective-C предоставляется API,которое позволяет вам взаимодействовать с системой времени исполнения Objective-C,опрашивая структуры времени исполнения в реальном времени и даже манипулируя ими.Это позволяет,например,осматривать и перемещаться по классам,методам и протоколам;определять новые классы или новые методы и даже изменять существующие классы или протоколы.</target>
        </trans-unit>
        <trans-unit id="4882007657bbd3b9904317ecd7c9122b201adae0" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API which is similar to the one provided by the &amp;ldquo;Objective-C 2.0&amp;rdquo; Apple/NeXT Objective-C runtime. The API is documented in the public header files of the GNU Objective-C runtime:</source>
          <target state="translated">Среда выполнения GNU Objective-C предоставляет API, аналогичный API, предоставляемому средой выполнения Apple / NeXT Objective-C &amp;laquo;Objective-C 2.0&amp;raquo;. API задокументирован в общедоступных файлах заголовков среды выполнения GNU Objective-C:</target>
        </trans-unit>
        <trans-unit id="bda523f70e2cc81aec3a5420312f2dc14631e90d" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime used to provide a different API, which we call the &amp;ldquo;traditional&amp;rdquo; GNU Objective-C runtime API. Functions belonging to this API are easy to recognize because they use a different naming convention, such as &lt;code&gt;class_get_super_class()&lt;/code&gt; (traditional API) instead of &lt;code&gt;class_getSuperclass()&lt;/code&gt; (modern API). Software using this API includes the file</source>
          <target state="translated">Среда выполнения GNU Objective-C использовалась для предоставления другого API, который мы называем &amp;laquo;традиционным&amp;raquo; API среды выполнения GNU Objective-C. Функции, принадлежащие этому API, легко распознать, потому что они используют другое соглашение об именах, например &lt;code&gt;class_get_super_class()&lt;/code&gt; (традиционный API) вместо &lt;code&gt;class_getSuperclass()&lt;/code&gt; (современный API). Программное обеспечение, использующее этот API, включает файл</target>
        </trans-unit>
        <trans-unit id="a580b32a37e3e1afb84412437056129293c1db6e" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux</source>
          <target state="translated">Проект GNU и GNU/Linux</target>
        </trans-unit>
        <trans-unit id="fbf08e863571f4a8147fed0d98f89d3a6cc1c1c5" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux.</source>
          <target state="translated">Проект GNU и GNU/Linux.</target>
        </trans-unit>
        <trans-unit id="565581be4558eda62440473a382dca36e2293950" translate="yes" xml:space="preserve">
          <source>The GNU compiler can produce two kinds of diagnostics: errors and warnings. Each kind has a different purpose:</source>
          <target state="translated">Компилятор GNU может выдавать два вида диагностики:ошибки и предупреждения.Каждый вид имеет свое назначение:</target>
        </trans-unit>
        <trans-unit id="0ef6aa50a29b9e95c494d3259dc5f4a2758d594d" translate="yes" xml:space="preserve">
          <source>The GNU compiler provides these extensions to the C++ language (and you can also use most of the C language extensions in your C++ programs). If you want to write code that checks whether these features are available, you can test for the GNU compiler the same way as for C programs: check for a predefined macro &lt;code&gt;__GNUC__&lt;/code&gt;. You can also use &lt;code&gt;__GNUG__&lt;/code&gt; to test specifically for GNU C++ (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Predefined Macros&lt;/a&gt; in The GNU C Preprocessor).</source>
          <target state="translated">Компилятор GNU предоставляет эти расширения для языка C ++ (и вы также можете использовать большинство расширений языка C в своих программах на C ++). Если вы хотите написать код, который проверяет, доступны ли эти функции, вы можете протестировать компилятор GNU так же, как и программы на C: проверьте наличие предопределенного макроса &lt;code&gt;__GNUC__&lt;/code&gt; . Вы также можете использовать &lt;code&gt;__GNUG__&lt;/code&gt; для тестирования специально для GNU C ++ (см. &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Предопределенные макросы&lt;/a&gt; в Препроцессоре GNU C).</target>
        </trans-unit>
        <trans-unit id="fdd4d4c02d395886b71e823798e0aedf04f540c0" translate="yes" xml:space="preserve">
          <source>The GNU linker (beginning with version 2.16) has the necessary support for this option. If your linker does not support this option, the header file aspect of</source>
          <target state="translated">Линкер GNU (начиная с версии 2.16)имеет необходимую поддержку этого варианта.Если ваш компоновщик не поддерживает этот параметр,то аспект заголовочного файла в</target>
        </trans-unit>
        <trans-unit id="649e8f725ce325928e9d3758e5501f5eb08d8098" translate="yes" xml:space="preserve">
          <source>The HP-UX implementation of setlocale in libc has a dependency on libdld.sl. There isn&amp;rsquo;t an archive version of libdld.sl. Thus, when the</source>
          <target state="translated">Реализация setlocale в libc для HP-UX зависит от libdld.sl. Не существует архивной версии libdld.sl. Таким образом, когда</target>
        </trans-unit>
        <trans-unit id="e6712fd16e48687aa09a28dcd06ca5cfec22cf46" translate="yes" xml:space="preserve">
          <source>The HTM builtins (with the exception of &lt;code&gt;__builtin_tbegin&lt;/code&gt;) return the full 4-bit condition register value set by their associated hardware instruction. The header file &lt;code&gt;htmintrin.h&lt;/code&gt; defines some macros that can be used to decipher the return value. The &lt;code&gt;__builtin_tbegin&lt;/code&gt; builtin returns a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; value depending on whether a transaction was successfully started or not. The arguments of the builtins match exactly the type and order of the associated hardware instruction&amp;rsquo;s operands, except for the &lt;code&gt;__builtin_tcheck&lt;/code&gt; builtin, which does not take any input arguments. Refer to the ISA manual for a description of each instruction&amp;rsquo;s operands.</source>
          <target state="translated">Встроенные функции HTM (за исключением &lt;code&gt;__builtin_tbegin&lt;/code&gt; ) возвращают полное 4-битное значение регистра условий, установленное соответствующей аппаратной инструкцией. Заголовочный файл &lt;code&gt;htmintrin.h&lt;/code&gt; определяет некоторые макросы, которые можно использовать для расшифровки возвращаемого значения. &lt;code&gt;__builtin_tbegin&lt;/code&gt; встроенной возвращает простое &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; значение в зависимости от того, была ли успешно запущена операция или нет. Аргументы встроенных команд точно соответствуют типу и порядку операндов связанных аппаратных инструкций, за исключением встроенной функции &lt;code&gt;__builtin_tcheck&lt;/code&gt; , которая не принимает никаких входных аргументов. Обратитесь к руководству ISA за описанием операндов каждой инструкции.</target>
        </trans-unit>
        <trans-unit id="87dbb117c6f13df65961818e4b7b41562cf362b8" translate="yes" xml:space="preserve">
          <source>The IA-64 back end supports the following variable attribute:</source>
          <target state="translated">Задняя часть IA-64 поддерживает следующий атрибут переменной:</target>
        </trans-unit>
        <trans-unit id="03f6d255f23aeee8dc7ee63e3c04d489d6fd6b28" translate="yes" xml:space="preserve">
          <source>The ISA and hardware multiply supported for the different MCUs is hard-coded into GCC. However, an external &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f39a7601ef937b791997651319caebaf1d1db8" translate="yes" xml:space="preserve">
          <source>The ISO C standard defines (in clause 4) two classes of conforming implementation. A &lt;em&gt;conforming hosted implementation&lt;/em&gt; supports the whole standard including all the library facilities; a &lt;em&gt;conforming freestanding implementation&lt;/em&gt; is only required to provide certain library facilities: those in &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;; since AMD1, also those in &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;; since C99, also those in &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;; and since C11, also those in &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;. In addition, complex types, added in C99, are not required for freestanding implementations.</source>
          <target state="translated">Стандарт ISO C определяет (в разделе 4) два класса соответствующей реализации. В &lt;em&gt;соответствии прошла реализация&lt;/em&gt; поддерживает весь стандарт , включая все библиотеки объектов; , &lt;em&gt;удовлетворяющих требованиям автономных реализации&lt;/em&gt; требуется только предоставить определенные библиотечные объекты: те , в &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; ; начиная с AMD1, а также те, что находятся в &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; ; начиная с C99, а также те, что находятся в &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; ; а с C11 также те, что находятся в &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt; , Кроме того, сложные типы, добавленные в C99, не требуются для автономных реализаций.</target>
        </trans-unit>
        <trans-unit id="4df8e4ece265376ae0055a7b2b932c764c91156b" translate="yes" xml:space="preserve">
          <source>The ISO C standard leaves it up to the implementation whether a bit-field declared plain &lt;code&gt;int&lt;/code&gt; is signed or not. This in effect creates two alternative dialects of C.</source>
          <target state="translated">Стандарт ISO C оставляет на усмотрение реализации, подписано ли битовое поле, объявленное как простой &lt;code&gt;int&lt;/code&gt; , или нет. По сути, это создает два альтернативных диалекта C.</target>
        </trans-unit>
        <trans-unit id="bced80c01ede6829408bc604cd122f3ce07d3569" translate="yes" xml:space="preserve">
          <source>The ISO C++14 library also defines the &amp;lsquo;</source>
          <target state="translated">Библиотека ISO C ++ 14 также определяет '</target>
        </trans-unit>
        <trans-unit id="de0f27c3596685d686fd3d285d5ba869620aa947" translate="yes" xml:space="preserve">
          <source>The ISO C90 functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, &lt;code&gt;fputs&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, &lt;code&gt;isxdigit&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;, &lt;code&gt;toupper&lt;/code&gt;, &lt;code&gt;labs&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;putchar&lt;/code&gt;, &lt;code&gt;puts&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sscanf&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt;, &lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncmp&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, &lt;code&gt;strrchr&lt;/code&gt;, &lt;code&gt;strspn&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;vfprintf&lt;/code&gt;, &lt;code&gt;vprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; are all recognized as built-in functions unless</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ca06952bac1aee629481893fc1242a0df75d20" translate="yes" xml:space="preserve">
          <source>The ISO C90 functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, &lt;code&gt;fputs&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, &lt;code&gt;isxdigit&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;, &lt;code&gt;toupper&lt;/code&gt;, &lt;code&gt;labs&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;putchar&lt;/code&gt;, &lt;code&gt;puts&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sscanf&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt;, &lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncmp&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, &lt;code&gt;strrchr&lt;/code&gt;, &lt;code&gt;strspn&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;vfprintf&lt;/code&gt;, &lt;code&gt;vprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; are all recognized as built-in functions unless</source>
          <target state="translated">Функции ISO C90 &lt;code&gt;abort&lt;/code&gt; , &lt;code&gt;abs&lt;/code&gt; , &lt;code&gt;acos&lt;/code&gt; , &lt;code&gt;asin&lt;/code&gt; , &lt;code&gt;atan2&lt;/code&gt; , &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;calloc&lt;/code&gt; , &lt;code&gt;ceil&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; , &lt;code&gt;exit&lt;/code&gt; , &lt;code&gt;exp&lt;/code&gt; , &lt;code&gt;fabs&lt;/code&gt; , &lt;code&gt;floor&lt;/code&gt; , &lt;code&gt;fmod&lt;/code&gt; , &lt;code&gt;fprintf&lt;/code&gt; , &lt;code&gt;fputs&lt;/code&gt; , &lt;code&gt;frexp&lt;/code&gt; , &lt;code&gt;fscanf&lt;/code&gt; , &lt;code&gt;isalnum&lt;/code&gt; , &lt;code&gt;isalpha&lt;/code&gt; , &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; , &lt;code&gt;isgraph&lt;/code&gt; , &lt;code&gt;islower&lt;/code&gt; , &lt;code&gt;isprint&lt;/code&gt; , &lt;code&gt;ispunct&lt;/code&gt; , &lt;code&gt;isspace&lt;/code&gt; , &lt;code&gt;isupper&lt;/code&gt; , &lt;code&gt;isxdigit&lt;/code&gt; , &lt;code&gt;tolower&lt;/code&gt; , &lt;code&gt;toupper&lt;/code&gt; , &lt;code&gt;labs&lt;/code&gt; , &lt;code&gt;ldexp&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; , &lt;code&gt;memchr&lt;/code&gt; , &lt;code&gt;memcmp&lt;/code&gt; , &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;memset&lt;/code&gt; , &lt;code&gt;modf&lt;/code&gt; , &lt;code&gt;pow&lt;/code&gt; , &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;putchar&lt;/code&gt; , &lt;code&gt;puts&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; , &lt;code&gt;sinh&lt;/code&gt; , &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;snprintf&lt;/code&gt; , &lt;code&gt;sprintf&lt;/code&gt; , &lt;code&gt;sqrt&lt;/code&gt; , &lt;code&gt;sscanf&lt;/code&gt; , &lt;code&gt;strcat&lt;/code&gt; , &lt;code&gt;strchr&lt;/code&gt; , &lt;code&gt;strcmp&lt;/code&gt; , &lt;code&gt;strcpy&lt;/code&gt; , &lt;code&gt;strcspn&lt;/code&gt; , &lt;code&gt;strlen&lt;/code&gt; , &lt;code&gt;strncat&lt;/code&gt; , &lt;code&gt;strncmp&lt;/code&gt; , &lt;code&gt;strncpy&lt;/code&gt; , &lt;code&gt;strpbrk&lt;/code&gt; , &lt;code&gt;strrchr&lt;/code&gt; , &lt;code&gt;strspn&lt;/code&gt; , &lt;code&gt;strstr&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;vfprintf&lt;/code&gt; , &lt;code&gt;vprintf&lt;/code&gt; все встроенные функции as не распознаны и vprintf, если не распознаны и vprintf в &lt;code&gt;vsprintf&lt;/code&gt; все функции</target>
        </trans-unit>
        <trans-unit id="ae47f0c159fa493b3beadffa3ea4146c32c1e50a" translate="yes" xml:space="preserve">
          <source>The ISO C94 functions &lt;code&gt;iswalnum&lt;/code&gt;, &lt;code&gt;iswalpha&lt;/code&gt;, &lt;code&gt;iswcntrl&lt;/code&gt;, &lt;code&gt;iswdigit&lt;/code&gt;, &lt;code&gt;iswgraph&lt;/code&gt;, &lt;code&gt;iswlower&lt;/code&gt;, &lt;code&gt;iswprint&lt;/code&gt;, &lt;code&gt;iswpunct&lt;/code&gt;, &lt;code&gt;iswspace&lt;/code&gt;, &lt;code&gt;iswupper&lt;/code&gt;, &lt;code&gt;iswxdigit&lt;/code&gt;, &lt;code&gt;towlower&lt;/code&gt; and &lt;code&gt;towupper&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="translated">Функции ISO C94 &lt;code&gt;iswalnum&lt;/code&gt; , &lt;code&gt;iswalpha&lt;/code&gt; , &lt;code&gt;iswcntrl&lt;/code&gt; , &lt;code&gt;iswdigit&lt;/code&gt; , &lt;code&gt;iswgraph&lt;/code&gt; , &lt;code&gt;iswlower&lt;/code&gt; , &lt;code&gt;iswprint&lt;/code&gt; , &lt;code&gt;iswpunct&lt;/code&gt; , &lt;code&gt;iswspace&lt;/code&gt; , &lt;code&gt;iswupper&lt;/code&gt; , &lt;code&gt;iswxdigit&lt;/code&gt; , &lt;code&gt;towlower&lt;/code&gt; и &lt;code&gt;towupper&lt;/code&gt; обрабатываются как встроенные функции, за исключением строгого режима ISO C90 (</target>
        </trans-unit>
        <trans-unit id="6cca21d213324c7eb2448728bd34ae61f7e19024" translate="yes" xml:space="preserve">
          <source>The ISO C99 functions &lt;code&gt;_Exit&lt;/code&gt;, &lt;code&gt;acoshf&lt;/code&gt;, &lt;code&gt;acoshl&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt;, &lt;code&gt;asinhf&lt;/code&gt;, &lt;code&gt;asinhl&lt;/code&gt;, &lt;code&gt;asinh&lt;/code&gt;, &lt;code&gt;atanhf&lt;/code&gt;, &lt;code&gt;atanhl&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt;, &lt;code&gt;cabsf&lt;/code&gt;, &lt;code&gt;cabsl&lt;/code&gt;, &lt;code&gt;cabs&lt;/code&gt;, &lt;code&gt;cacosf&lt;/code&gt;, &lt;code&gt;cacoshf&lt;/code&gt;, &lt;code&gt;cacoshl&lt;/code&gt;, &lt;code&gt;cacosh&lt;/code&gt;, &lt;code&gt;cacosl&lt;/code&gt;, &lt;code&gt;cacos&lt;/code&gt;, &lt;code&gt;cargf&lt;/code&gt;, &lt;code&gt;cargl&lt;/code&gt;, &lt;code&gt;carg&lt;/code&gt;, &lt;code&gt;casinf&lt;/code&gt;, &lt;code&gt;casinhf&lt;/code&gt;, &lt;code&gt;casinhl&lt;/code&gt;, &lt;code&gt;casinh&lt;/code&gt;, &lt;code&gt;casinl&lt;/code&gt;, &lt;code&gt;casin&lt;/code&gt;, &lt;code&gt;catanf&lt;/code&gt;, &lt;code&gt;catanhf&lt;/code&gt;, &lt;code&gt;catanhl&lt;/code&gt;, &lt;code&gt;catanh&lt;/code&gt;, &lt;code&gt;catanl&lt;/code&gt;, &lt;code&gt;catan&lt;/code&gt;, &lt;code&gt;cbrtf&lt;/code&gt;, &lt;code&gt;cbrtl&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt;, &lt;code&gt;ccosf&lt;/code&gt;, &lt;code&gt;ccoshf&lt;/code&gt;, &lt;code&gt;ccoshl&lt;/code&gt;, &lt;code&gt;ccosh&lt;/code&gt;, &lt;code&gt;ccosl&lt;/code&gt;, &lt;code&gt;ccos&lt;/code&gt;, &lt;code&gt;cexpf&lt;/code&gt;, &lt;code&gt;cexpl&lt;/code&gt;, &lt;code&gt;cexp&lt;/code&gt;, &lt;code&gt;cimagf&lt;/code&gt;, &lt;code&gt;cimagl&lt;/code&gt;, &lt;code&gt;cimag&lt;/code&gt;, &lt;code&gt;clogf&lt;/code&gt;, &lt;code&gt;clogl&lt;/code&gt;, &lt;code&gt;clog&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, &lt;code&gt;conjl&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt;, &lt;code&gt;copysignf&lt;/code&gt;, &lt;code&gt;copysignl&lt;/code&gt;, &lt;code&gt;copysign&lt;/code&gt;, &lt;code&gt;cpowf&lt;/code&gt;, &lt;code&gt;cpowl&lt;/code&gt;, &lt;code&gt;cpow&lt;/code&gt;, &lt;code&gt;cprojf&lt;/code&gt;, &lt;code&gt;cprojl&lt;/code&gt;, &lt;code&gt;cproj&lt;/code&gt;, &lt;code&gt;crealf&lt;/code&gt;, &lt;code&gt;creall&lt;/code&gt;, &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;csinf&lt;/code&gt;, &lt;code&gt;csinhf&lt;/code&gt;, &lt;code&gt;csinhl&lt;/code&gt;, &lt;code&gt;csinh&lt;/code&gt;, &lt;code&gt;csinl&lt;/code&gt;, &lt;code&gt;csin&lt;/code&gt;, &lt;code&gt;csqrtf&lt;/code&gt;, &lt;code&gt;csqrtl&lt;/code&gt;, &lt;code&gt;csqrt&lt;/code&gt;, &lt;code&gt;ctanf&lt;/code&gt;, &lt;code&gt;ctanhf&lt;/code&gt;, &lt;code&gt;ctanhl&lt;/code&gt;, &lt;code&gt;ctanh&lt;/code&gt;, &lt;code&gt;ctanl&lt;/code&gt;, &lt;code&gt;ctan&lt;/code&gt;, &lt;code&gt;erfcf&lt;/code&gt;, &lt;code&gt;erfcl&lt;/code&gt;, &lt;code&gt;erfc&lt;/code&gt;, &lt;code&gt;erff&lt;/code&gt;, &lt;code&gt;erfl&lt;/code&gt;, &lt;code&gt;erf&lt;/code&gt;, &lt;code&gt;exp2f&lt;/code&gt;, &lt;code&gt;exp2l&lt;/code&gt;, &lt;code&gt;exp2&lt;/code&gt;, &lt;code&gt;expm1f&lt;/code&gt;, &lt;code&gt;expm1l&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;, &lt;code&gt;fdimf&lt;/code&gt;, &lt;code&gt;fdiml&lt;/code&gt;, &lt;code&gt;fdim&lt;/code&gt;, &lt;code&gt;fmaf&lt;/code&gt;, &lt;code&gt;fmal&lt;/code&gt;, &lt;code&gt;fmaxf&lt;/code&gt;, &lt;code&gt;fmaxl&lt;/code&gt;, &lt;code&gt;fmax&lt;/code&gt;, &lt;code&gt;fma&lt;/code&gt;, &lt;code&gt;fminf&lt;/code&gt;, &lt;code&gt;fminl&lt;/code&gt;, &lt;code&gt;fmin&lt;/code&gt;, &lt;code&gt;hypotf&lt;/code&gt;, &lt;code&gt;hypotl&lt;/code&gt;, &lt;code&gt;hypot&lt;/code&gt;, &lt;code&gt;ilogbf&lt;/code&gt;, &lt;code&gt;ilogbl&lt;/code&gt;, &lt;code&gt;ilogb&lt;/code&gt;, &lt;code&gt;imaxabs&lt;/code&gt;, &lt;code&gt;isblank&lt;/code&gt;, &lt;code&gt;iswblank&lt;/code&gt;, &lt;code&gt;lgammaf&lt;/code&gt;, &lt;code&gt;lgammal&lt;/code&gt;, &lt;code&gt;lgamma&lt;/code&gt;, &lt;code&gt;llabs&lt;/code&gt;, &lt;code&gt;llrintf&lt;/code&gt;, &lt;code&gt;llrintl&lt;/code&gt;, &lt;code&gt;llrint&lt;/code&gt;, &lt;code&gt;llroundf&lt;/code&gt;, &lt;code&gt;llroundl&lt;/code&gt;, &lt;code&gt;llround&lt;/code&gt;, &lt;code&gt;log1pf&lt;/code&gt;, &lt;code&gt;log1pl&lt;/code&gt;, &lt;code&gt;log1p&lt;/code&gt;, &lt;code&gt;log2f&lt;/code&gt;, &lt;code&gt;log2l&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;logbf&lt;/code&gt;, &lt;code&gt;logbl&lt;/code&gt;, &lt;code&gt;logb&lt;/code&gt;, &lt;code&gt;lrintf&lt;/code&gt;, &lt;code&gt;lrintl&lt;/code&gt;, &lt;code&gt;lrint&lt;/code&gt;, &lt;code&gt;lroundf&lt;/code&gt;, &lt;code&gt;lroundl&lt;/code&gt;, &lt;code&gt;lround&lt;/code&gt;, &lt;code&gt;nearbyintf&lt;/code&gt;, &lt;code&gt;nearbyintl&lt;/code&gt;, &lt;code&gt;nearbyint&lt;/code&gt;, &lt;code&gt;nextafterf&lt;/code&gt;, &lt;code&gt;nextafterl&lt;/code&gt;, &lt;code&gt;nextafter&lt;/code&gt;, &lt;code&gt;nexttowardf&lt;/code&gt;, &lt;code&gt;nexttowardl&lt;/code&gt;, &lt;code&gt;nexttoward&lt;/code&gt;, &lt;code&gt;remainderf&lt;/code&gt;, &lt;code&gt;remainderl&lt;/code&gt;, &lt;code&gt;remainder&lt;/code&gt;, &lt;code&gt;remquof&lt;/code&gt;, &lt;code&gt;remquol&lt;/code&gt;, &lt;code&gt;remquo&lt;/code&gt;, &lt;code&gt;rintf&lt;/code&gt;, &lt;code&gt;rintl&lt;/code&gt;, &lt;code&gt;rint&lt;/code&gt;, &lt;code&gt;roundf&lt;/code&gt;, &lt;code&gt;roundl&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;scalblnf&lt;/code&gt;, &lt;code&gt;scalblnl&lt;/code&gt;, &lt;code&gt;scalbln&lt;/code&gt;, &lt;code&gt;scalbnf&lt;/code&gt;, &lt;code&gt;scalbnl&lt;/code&gt;, &lt;code&gt;scalbn&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;tgammaf&lt;/code&gt;, &lt;code&gt;tgammal&lt;/code&gt;, &lt;code&gt;tgamma&lt;/code&gt;, &lt;code&gt;truncf&lt;/code&gt;, &lt;code&gt;truncl&lt;/code&gt;, &lt;code&gt;trunc&lt;/code&gt;, &lt;code&gt;vfscanf&lt;/code&gt;, &lt;code&gt;vscanf&lt;/code&gt;, &lt;code&gt;vsnprintf&lt;/code&gt; and &lt;code&gt;vsscanf&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="translated">Функции ISO C99 &lt;code&gt;_Exit&lt;/code&gt; , &lt;code&gt;acoshf&lt;/code&gt; , &lt;code&gt;acoshl&lt;/code&gt; , &lt;code&gt;acosh&lt;/code&gt; , &lt;code&gt;asinhf&lt;/code&gt; , &lt;code&gt;asinhl&lt;/code&gt; , &lt;code&gt;asinh&lt;/code&gt; , &lt;code&gt;atanhf&lt;/code&gt; , &lt;code&gt;atanhl&lt;/code&gt; , &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;cabsf&lt;/code&gt; , &lt;code&gt;cabsl&lt;/code&gt; , &lt;code&gt;cabs&lt;/code&gt; , &lt;code&gt;cacosf&lt;/code&gt; , &lt;code&gt;cacoshf&lt;/code&gt; , &lt;code&gt;cacoshl&lt;/code&gt; , &lt;code&gt;cacosh&lt;/code&gt; , &lt;code&gt;cacosl&lt;/code&gt; , &lt;code&gt;cacos&lt;/code&gt; , &lt;code&gt;cargf&lt;/code&gt; , &lt;code&gt;cargl&lt;/code&gt; , &lt;code&gt;carg&lt;/code&gt; , &lt;code&gt;casinf&lt;/code&gt; , &lt;code&gt;casinhf&lt;/code&gt; , &lt;code&gt;casinhl&lt;/code&gt; , &lt;code&gt;casinh&lt;/code&gt; , &lt;code&gt;casinl&lt;/code&gt; , &lt;code&gt;casin&lt;/code&gt; , &lt;code&gt;catanf&lt;/code&gt; , &lt;code&gt;catanhf&lt;/code&gt; , &lt;code&gt;catanhl&lt;/code&gt; , &lt;code&gt;catanh&lt;/code&gt; , &lt;code&gt;catanl&lt;/code&gt; , &lt;code&gt;catan&lt;/code&gt; , &lt;code&gt;cbrtf&lt;/code&gt; , &lt;code&gt;cbrtl&lt;/code&gt; , &lt;code&gt;cbrt&lt;/code&gt; , &lt;code&gt;ccosf&lt;/code&gt; , &lt;code&gt;ccoshf&lt;/code&gt; , &lt;code&gt;ccoshl&lt;/code&gt; , &lt;code&gt;ccosh&lt;/code&gt; , &lt;code&gt;ccosl&lt;/code&gt; , &lt;code&gt;ccos&lt;/code&gt; , &lt;code&gt;cexpf&lt;/code&gt; , &lt;code&gt;cexpl&lt;/code&gt; , &lt;code&gt;cexp&lt;/code&gt; , &lt;code&gt;cimagf&lt;/code&gt; , &lt;code&gt;cimagl&lt;/code&gt; , &lt;code&gt;cimag&lt;/code&gt; , &lt;code&gt;clogf&lt;/code&gt; , &lt;code&gt;clogl&lt;/code&gt; , &lt;code&gt;clog&lt;/code&gt; , &lt;code&gt;conjf&lt;/code&gt; , &lt;code&gt;conjl&lt;/code&gt; , &lt;code&gt;conj&lt;/code&gt; , &lt;code&gt;copysignf&lt;/code&gt; , &lt;code&gt;copysignl&lt;/code&gt; , &lt;code&gt;copysign&lt;/code&gt; , &lt;code&gt;cpowf&lt;/code&gt; , &lt;code&gt;cpowl&lt;/code&gt; , &lt;code&gt;cpow&lt;/code&gt; , &lt;code&gt;cprojf&lt;/code&gt; , &lt;code&gt;cprojl&lt;/code&gt; , &lt;code&gt;cproj&lt;/code&gt; , &lt;code&gt;crealf&lt;/code&gt; , &lt;code&gt;creall&lt;/code&gt; , &lt;code&gt;creal&lt;/code&gt; , &lt;code&gt;csinf&lt;/code&gt; , &lt;code&gt;csinhf&lt;/code&gt; , &lt;code&gt;csinhl&lt;/code&gt; , &lt;code&gt;csinh&lt;/code&gt; , &lt;code&gt;csinl&lt;/code&gt; , &lt;code&gt;csin&lt;/code&gt; , &lt;code&gt;csqrtf&lt;/code&gt; , &lt;code&gt;csqrtl&lt;/code&gt; , &lt;code&gt;csqrt&lt;/code&gt; , &lt;code&gt;ctanf&lt;/code&gt; , &lt;code&gt;ctanhf&lt;/code&gt; , &lt;code&gt;ctanhl&lt;/code&gt; , &lt;code&gt;ctanh&lt;/code&gt; , &lt;code&gt;ctanl&lt;/code&gt; , &lt;code&gt;ctan&lt;/code&gt; , &lt;code&gt;erfcf&lt;/code&gt; , &lt;code&gt;erfcl&lt;/code&gt; , &lt;code&gt;erfc&lt;/code&gt; , &lt;code&gt;erff&lt;/code&gt; , &lt;code&gt;erfl&lt;/code&gt; , &lt;code&gt;erf&lt;/code&gt; , &lt;code&gt;exp2f&lt;/code&gt; , &lt;code&gt;exp2l&lt;/code&gt; , &lt;code&gt;exp2&lt;/code&gt; , &lt;code&gt;expm1f&lt;/code&gt; , &lt;code&gt;expm1l&lt;/code&gt; , &lt;code&gt;expm1&lt;/code&gt; , &lt;code&gt;fdimf&lt;/code&gt; , &lt;code&gt;fdiml&lt;/code&gt; , &lt;code&gt;fdim&lt;/code&gt; , &lt;code&gt;fmaf&lt;/code&gt; , &lt;code&gt;fmal&lt;/code&gt; , &lt;code&gt;fmaxf&lt;/code&gt; , &lt;code&gt;fmaxl&lt;/code&gt; , &lt;code&gt;fmax&lt;/code&gt; , &lt;code&gt;fma&lt;/code&gt; , &lt;code&gt;fminf&lt;/code&gt; , &lt;code&gt;fminl&lt;/code&gt; , &lt;code&gt;fmin&lt;/code&gt; , &lt;code&gt;hypotf&lt;/code&gt; , &lt;code&gt;hypotl&lt;/code&gt; , &lt;code&gt;hypot&lt;/code&gt; , &lt;code&gt;ilogbf&lt;/code&gt; , &lt;code&gt;ilogbl&lt;/code&gt; , &lt;code&gt;ilogb&lt;/code&gt; , &lt;code&gt;imaxabs&lt;/code&gt; , &lt;code&gt;isblank&lt;/code&gt; , &lt;code&gt;iswblank&lt;/code&gt; , &lt;code&gt;lgammaf&lt;/code&gt; , &lt;code&gt;lgammal&lt;/code&gt; , &lt;code&gt;lgamma&lt;/code&gt; , &lt;code&gt;llabs&lt;/code&gt; , &lt;code&gt;llrintf&lt;/code&gt; , &lt;code&gt;llrintl&lt;/code&gt; , &lt;code&gt;llrint&lt;/code&gt; , &lt;code&gt;llroundf&lt;/code&gt; , &lt;code&gt;llroundl&lt;/code&gt; , &lt;code&gt;llround&lt;/code&gt; , &lt;code&gt;log1pf&lt;/code&gt; , &lt;code&gt;log1pl&lt;/code&gt; , &lt;code&gt;log1p&lt;/code&gt; , &lt;code&gt;log2f&lt;/code&gt; , &lt;code&gt;log2l&lt;/code&gt; , &lt;code&gt;log2&lt;/code&gt; , &lt;code&gt;logbf&lt;/code&gt; , &lt;code&gt;logbl&lt;/code&gt; , &lt;code&gt;logb&lt;/code&gt; , &lt;code&gt;lrintf&lt;/code&gt; , &lt;code&gt;lrintl&lt;/code&gt; , &lt;code&gt;lrint&lt;/code&gt; , &lt;code&gt;lroundf&lt;/code&gt; , &lt;code&gt;lroundl&lt;/code&gt; , &lt;code&gt;lround&lt;/code&gt; , &lt;code&gt;nearbyintf&lt;/code&gt; , &lt;code&gt;nearbyintl&lt;/code&gt; , &lt;code&gt;nearbyint&lt;/code&gt; , &lt;code&gt;nextafterf&lt;/code&gt; , &lt;code&gt;nextafterl&lt;/code&gt; , &lt;code&gt;nextafter&lt;/code&gt; , &lt;code&gt;nexttowardf&lt;/code&gt; , &lt;code&gt;nexttowardl&lt;/code&gt; , &lt;code&gt;nexttoward&lt;/code&gt; , &lt;code&gt;remainderf&lt;/code&gt; , &lt;code&gt;remainderl&lt;/code&gt; , &lt;code&gt;remainder&lt;/code&gt; , &lt;code&gt;remquof&lt;/code&gt; , &lt;code&gt;remquol&lt;/code&gt; , &lt;code&gt;remquo&lt;/code&gt; , &lt;code&gt;rintf&lt;/code&gt; , &lt;code&gt;rintl&lt;/code&gt; , &lt;code&gt;rint&lt;/code&gt; , &lt;code&gt;roundf&lt;/code&gt; , &lt;code&gt;roundl&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; , &lt;code&gt;scalblnf&lt;/code&gt; , &lt;code&gt;scalblnl&lt;/code&gt; , &lt;code&gt;scalbln&lt;/code&gt; , &lt;code&gt;scalbnf&lt;/code&gt; , &lt;code&gt;scalbnl&lt;/code&gt; , &lt;code&gt;scalbn&lt;/code&gt; , &lt;code&gt;snprintf&lt;/code&gt; , &lt;code&gt;tgammaf&lt;/code&gt; , &lt;code&gt;tgammal&lt;/code&gt; , &lt;code&gt;tgamma&lt;/code&gt; , &lt;code&gt;truncf&lt;/code&gt; , &lt;code&gt;truncl&lt;/code&gt; , &lt;code&gt;trunc&lt;/code&gt; , &lt;code&gt;vfscanf&lt;/code&gt; , &lt;code&gt;vscanf&lt;/code&gt; , &lt;code&gt;vsnprintf&lt;/code&gt; и &lt;code&gt;vsscanf&lt;/code&gt; обрабатываются как встроенные функции, за исключением строгого режима ISO C90 (</target>
        </trans-unit>
        <trans-unit id="2784e50b776c95c529ea8bb486ce2750890944bf" translate="yes" xml:space="preserve">
          <source>The ISO type of an integer constant has a different width or signedness from its traditional type. This warning is only issued if the base of the constant is ten. I.e. hexadecimal or octal values, which typically represent bit patterns, are not warned about.</source>
          <target state="translated">ISO-тип целочисленной константы имеет ширину или знак,отличные от ее традиционного типа.Предупреждение выдается только в том случае,если база константы равна десяти.Т.е.шестнадцатеричные или восьмеричные значения,которые обычно представляют битовые закономерности,не предупреждаются.</target>
        </trans-unit>
        <trans-unit id="82a12be836835137fbdc59e2c7d2766dbca00a8c" translate="yes" xml:space="preserve">
          <source>The JSON is emitted as one line, without formatting; the examples below have been formatted for clarity.</source>
          <target state="translated">JSON испускается в виде одной строки без форматирования;примеры ниже отформатированы для наглядности.</target>
        </trans-unit>
        <trans-unit id="a08b3636d7c444216df0829b96c5cf7186a63397" translate="yes" xml:space="preserve">
          <source>The M-Profile Vector Extension (MVE) integer and single precision floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121628a4764ae0bea2f22e038677fd81cecafe48" translate="yes" xml:space="preserve">
          <source>The M-Profile Vector Extension (MVE) integer instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a22ef3a7780246abe5b933d687f802ceaac7fd9" translate="yes" xml:space="preserve">
          <source>The MIPS DSP Application-Specific Extension (ASE) includes new instructions that are designed to improve the performance of DSP and media applications. It provides instructions that operate on packed 8-bit/16-bit integer data, Q7, Q15 and Q31 fractional data.</source>
          <target state="translated">Расширение MIPS DSP Application-Specific Extension (ASE)включает в себя новые инструкции,предназначенные для повышения производительности DSP и мультимедийных приложений.Оно предоставляет инструкции,которые работают с упакованными 8-битными/16-битными целочисленными данными,Q7,Q15 и Q31 дробными данными.</target>
        </trans-unit>
        <trans-unit id="f5ed4155655f597ba1ea8fb1a082975a691dee38" translate="yes" xml:space="preserve">
          <source>The MIPS-3D Application-Specific Extension (ASE) includes additional paired-single instructions that are designed to improve the performance of 3D graphics operations. Support for these instructions is controlled by the</source>
          <target state="translated">Расширение MIPS-3D Application-Specific Extension (ASE)включает в себя дополнительные парные одиночные инструкции,предназначенные для повышения производительности операций с 3D-графикой.Поддержка этих инструкций контролируется</target>
        </trans-unit>
        <trans-unit id="2568887586875d72638add2c316850a652079522" translate="yes" xml:space="preserve">
          <source>The MIPS64 architecture includes a number of instructions that operate on pairs of single-precision floating-point values. Each pair is packed into a 64-bit floating-point register, with one element being designated the &amp;ldquo;upper half&amp;rdquo; and the other being designated the &amp;ldquo;lower half&amp;rdquo;.</source>
          <target state="translated">Архитектура MIPS64 включает ряд инструкций, которые работают с парами значений с плавающей запятой одинарной точности. Каждая пара упакована в 64-битный регистр с плавающей запятой, причем один элемент обозначен как &amp;laquo;верхняя половина&amp;raquo;, а другой - &amp;laquo;нижняя половина&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="19791c6fc0c7878cc7c0d81440fdc8b3deac6cc4" translate="yes" xml:space="preserve">
          <source>The MSP430 hardware ensures that interrupts are disabled on entry to &lt;code&gt;interrupt&lt;/code&gt; functions, and restores the previous interrupt state on exit. The &lt;code&gt;critical&lt;/code&gt; attribute is therefore redundant on &lt;code&gt;interrupt&lt;/code&gt; functions.</source>
          <target state="translated">Аппаратное обеспечение MSP430 обеспечивает отключение прерываний при входе в функции &lt;code&gt;interrupt&lt;/code&gt; и восстанавливает предыдущее состояние прерывания при выходе. Поэтому &lt;code&gt;critical&lt;/code&gt; атрибут является избыточным для функций &lt;code&gt;interrupt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="324add0fab22223316ad270b660243d491e201b4" translate="yes" xml:space="preserve">
          <source>The MeP target has a number of addressing modes and busses. The &lt;code&gt;near&lt;/code&gt; space spans the standard memory space&amp;rsquo;s first 16 megabytes (24 bits). The &lt;code&gt;far&lt;/code&gt; space spans the entire 32-bit memory space. The &lt;code&gt;based&lt;/code&gt; space is a 128-byte region in the memory space that is addressed relative to the &lt;code&gt;$tp&lt;/code&gt; register. The &lt;code&gt;tiny&lt;/code&gt; space is a 65536-byte region relative to the &lt;code&gt;$gp&lt;/code&gt; register. In addition to these memory regions, the MeP target has a separate 16-bit control bus which is specified with &lt;code&gt;cb&lt;/code&gt; attributes.</source>
          <target state="translated">Мишень MeP имеет несколько режимов адресации и шин. &lt;code&gt;near&lt;/code&gt; пространство охватывает первые 16 мегабайт стандартного пространства памяти в (24 бита). В &lt;code&gt;far&lt;/code&gt; космосе охватывает все 32-битное пространство памяти. &lt;code&gt;based&lt;/code&gt; пространство представляет собой область 128 байт в области памяти, адресованной по отношению к &lt;code&gt;$tp&lt;/code&gt; регистра. &lt;code&gt;tiny&lt;/code&gt; пространство является 65536 байт области по сравнению с &lt;code&gt;$gp&lt;/code&gt; регистра. В дополнение к этим областям памяти цель MeP имеет отдельную 16-битную шину управления, которая указывается с помощью атрибутов &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d8a7015c96baf068daea7c993c23e530f568f5f" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model for embedded systems: 64-bit addresses, the text and data segments must be less than 2GB in size, both starting anywhere in memory (determined at link time). The global register %g4 points to the base of the data segment. Programs are statically linked and PIC is not supported.</source>
          <target state="translated">Модель кода Medium/Anywhere для встраиваемых систем:64-битные адреса,текстовый сегмент и сегмент данных должны быть размером менее 2 Гб,оба начинаются в любом месте памяти (определяемом во время соединения).Глобальный регистр %g4 указывает на базу сегмента данных.Программы статически связаны и PIC не поддерживается.</target>
        </trans-unit>
        <trans-unit id="cc31a18cddf7a0f78efe693458fe2d9afe6d7019" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model: 64-bit addresses, programs may be linked anywhere in memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="translated">Модель кода Medium/Anywhere:64-битные адреса,программы могут быть связаны где угодно в памяти,размер текстового сегмента и сегмента данных должен быть менее 2 Гб,а размер сегмента данных должен находиться в пределах 2 Гб от текстового сегмента.</target>
        </trans-unit>
        <trans-unit id="7e3c5ad40e25357a2525dfa3cd571c1d3bd7d34a" translate="yes" xml:space="preserve">
          <source>The Medium/Low code model: 64-bit addresses, programs must be linked in the low 32 bits of memory. Programs can be statically or dynamically linked.</source>
          <target state="translated">Средне-низкая кодовая модель:64-битные адреса,программы должны компоноваться в младших 32 битах памяти.Программы могут быть связаны статически или динамически.</target>
        </trans-unit>
        <trans-unit id="3b39ba546b4adedbbf99b1b31d01ec7fac76520a" translate="yes" xml:space="preserve">
          <source>The Medium/Middle code model: 64-bit addresses, programs must be linked in the low 44 bits of memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="translated">Модель среднего/среднего кода:64-битные адреса,программы должны быть связаны в младших 44 битах памяти,текстовые сегменты и сегменты данных должны быть размером менее 2 ГБ,а сегмент данных должен находиться в пределах 2 ГБ от текстового сегмента.</target>
        </trans-unit>
        <trans-unit id="da2b29936b818cfc1e5a3a58f7738a9fa0c881c1" translate="yes" xml:space="preserve">
          <source>The Microsoft structure layout algorithm is fairly simple with the exception of the bit-field packing. The padding and alignment of members of structures and whether a bit-field can straddle a storage-unit boundary are determine by these rules:</source>
          <target state="translated">Алгоритм компоновки структуры Microsoft достаточно прост,за исключением упаковки битовых полей.Эти правила определяют насыщенность и выравнивание членов структур,а также то,может ли битовое поле пересекать границу раздела хранилища:</target>
        </trans-unit>
        <trans-unit id="aeff520b5677f801f6da4eeb7f1e51a9a569cd01" translate="yes" xml:space="preserve">
          <source>The NOP instructions are inserted at&amp;mdash;and maybe before, depending on &lt;var&gt;M&lt;/var&gt;&amp;mdash;the function entry address, even before the prologue.</source>
          <target state="translated">Инструкции NOP вставляются - и, возможно, до, в зависимости от &lt;var&gt;M&lt;/var&gt; - адреса входа функции, даже до пролога.</target>
        </trans-unit>
        <trans-unit id="ff55b141ae724be4a1c090f09197c4cc8d0b49e5" translate="yes" xml:space="preserve">
          <source>The Objective-C 2.0 language extensions and features are automatically enabled; they include properties (via the &lt;code&gt;@property&lt;/code&gt;, &lt;code&gt;@synthesize&lt;/code&gt; and &lt;code&gt;@dynamic keywords&lt;/code&gt;), fast enumeration (not available in Objective-C++), attributes for methods (such as &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;sentinel&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;), the &lt;code&gt;unused&lt;/code&gt; attribute for method arguments, the &lt;code&gt;@package&lt;/code&gt; keyword for instance variables and the &lt;code&gt;@optional&lt;/code&gt; and &lt;code&gt;@required&lt;/code&gt; keywords in protocols. You can disable all these Objective-C 2.0 language extensions with the option</source>
          <target state="translated">Расширения и функции языка Objective-C 2.0 включаются автоматически; они включают свойства (через &lt;code&gt;@dynamic keywords&lt;/code&gt; &lt;code&gt;@property&lt;/code&gt; , &lt;code&gt;@synthesize&lt;/code&gt; и @dynamic ), быстрое перечисление (недоступно в Objective-C ++), атрибуты для методов (такие как &lt;code&gt;deprecated&lt;/code&gt; , &lt;code&gt;noreturn&lt;/code&gt; , &lt;code&gt;sentinel&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; ), &lt;code&gt;unused&lt;/code&gt; атрибут для аргументов метода, &lt;code&gt;@package&lt;/code&gt; ключевое слово для переменных экземпляра и &lt;code&gt;@optional&lt;/code&gt; и &lt;code&gt;@required&lt;/code&gt; ключевых слов в протоколах. Вы можете отключить все эти языковые расширения Objective-C 2.0 с помощью параметра</target>
        </trans-unit>
        <trans-unit id="c6923a9108193e35102064afa9eda743cb37bdd9" translate="yes" xml:space="preserve">
          <source>The Objective-C compiler generates type encodings for all the types. These type encodings are used at runtime to find out information about selectors and methods and about objects and classes.</source>
          <target state="translated">Компилятор Objective-C генерирует кодировки типов для всех типов.Эти кодировки типов используются во время исполнения для получения информации о селекторах и методах,а также об объектах и классах.</target>
        </trans-unit>
        <trans-unit id="e464bd6510d0d75994dbae5961cb9df5baed7b28" translate="yes" xml:space="preserve">
          <source>The Objective-C exception and synchronization syntax (that is, the keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;) is supported by GCC and is enabled with the option</source>
          <target state="translated">Синтаксис исключения и синхронизации Objective-C (то есть ключевые слова &lt;code&gt;@try&lt;/code&gt; , &lt;code&gt;@throw&lt;/code&gt; , &lt;code&gt;@catch&lt;/code&gt; , &lt;code&gt;@finally&lt;/code&gt; и &lt;code&gt;@synchronized&lt;/code&gt; ) поддерживается GCC и включается с помощью параметра</target>
        </trans-unit>
        <trans-unit id="504b920d3ddaa29eaf4f4d2837867a09bb928c21" translate="yes" xml:space="preserve">
          <source>The One Definition Rule is relaxed for types without explicit visibility specifications that are defined in more than one shared object: those declarations are permitted if they are permitted when this option is not used.</source>
          <target state="translated">Правило одного определения ослаблено для типов без явных спецификаций видимости,которые определены в более чем одном общем объекте:эти декларации разрешены,если они разрешены,когда эта опция не используется.</target>
        </trans-unit>
        <trans-unit id="2d22810fdfaa073bc94d2050ac8533154c085f11" translate="yes" xml:space="preserve">
          <source>The RL78 back end supports the &lt;code&gt;saddr&lt;/code&gt; variable attribute. This specifies placement of the corresponding variable in the SADDR area, which can be accessed more efficiently than the default memory region.</source>
          <target state="translated">Серверная часть RL78 поддерживает &lt;code&gt;saddr&lt;/code&gt; переменной saddr . Это определяет размещение соответствующей переменной в области SADDR, к которой можно получить доступ более эффективно, чем к области памяти по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1c75a1f23dddf5a55d85a877757468d10500aab3" translate="yes" xml:space="preserve">
          <source>The RS/6000 and PowerPC targets define one pragma for controlling whether or not the &lt;code&gt;longcall&lt;/code&gt; attribute is added to function declarations by default. This pragma overrides the</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; объекты RS / 6000 и PowerPC определяют одну директиву для управления добавлением атрибута longcall к объявлениям функций по умолчанию. Эта прагма отменяет</target>
        </trans-unit>
        <trans-unit id="549fc0bcd99c9fa57f4b149326299d99007e47ae" translate="yes" xml:space="preserve">
          <source>The SCOUNT and POS bits of the DSP control register are global. The WRDSP, EXTPDP, EXTPDPV and MTHLIP instructions modify the SCOUNT and POS bits. During optimization, the compiler does not delete these instructions and it does not delete calls to functions containing these instructions.</source>
          <target state="translated">Биты SCOUNT и POS регистра управления DSP являются глобальными.Инструкции WRDSP,EXTPDP,EXTPDPV и MTHLIP изменяют биты SCOUNT и POS.Во время оптимизации компилятор не удаляет эти инструкции и не удаляет вызовы функций,содержащих эти инструкции.</target>
        </trans-unit>
        <trans-unit id="feed8b7325d666bcdf4c1efd5aa692caea9e4e2d" translate="yes" xml:space="preserve">
          <source>The SPU supports the &lt;code&gt;spu_vector&lt;/code&gt; attribute for variables. For documentation of this attribute please see the documentation in &lt;a href=&quot;type-attributes#SPU-Type-Attributes&quot;&gt;SPU Type Attributes&lt;/a&gt;.</source>
          <target state="translated">SPU поддерживает атрибут &lt;code&gt;spu_vector&lt;/code&gt; для переменных. Для документации по этому атрибуту см. Документацию в разделе &lt;a href=&quot;type-attributes#SPU-Type-Attributes&quot;&gt;Атрибуты типа SPU&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e00194fefd3abe9f6e9c4ed0e24c5f1cdb3e71d6" translate="yes" xml:space="preserve">
          <source>The Solaris target supports &lt;code&gt;#pragma redefine_extname&lt;/code&gt; (see &lt;a href=&quot;symbol_002drenaming-pragmas#Symbol_002dRenaming-Pragmas&quot;&gt;Symbol-Renaming Pragmas&lt;/a&gt;). It also supports additional &lt;code&gt;#pragma&lt;/code&gt; directives for compatibility with the system compiler.</source>
          <target state="translated">Целевой объект Solaris поддерживает &lt;code&gt;#pragma redefine_extname&lt;/code&gt; (см. &lt;a href=&quot;symbol_002drenaming-pragmas#Symbol_002dRenaming-Pragmas&quot;&gt;Прагмы переименования символов&lt;/a&gt; ). Он также поддерживает дополнительные директивы &lt;code&gt;#pragma&lt;/code&gt; для совместимости с системным компилятором.</target>
        </trans-unit>
        <trans-unit id="b577e7bfa4d5d277a90aa967bc9fa309870fa29b" translate="yes" xml:space="preserve">
          <source>The V850 back end supports these function attributes:</source>
          <target state="translated">Задняя часть V850 поддерживает эти атрибуты функции:</target>
        </trans-unit>
        <trans-unit id="87ba99adc7a79652db01be899ada60245b8a9d21" translate="yes" xml:space="preserve">
          <source>The VFPv2 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Инструкции с плавающей запятой VFPv2. Расширение '</target>
        </trans-unit>
        <trans-unit id="259f6621f353addf35de203c6cc21ec70166871f" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">Инструкции VFPv3 с плавающей запятой,содержащие 16 регистров двойной точности и операции преобразования с плавающей запятой половинной точности.</target>
        </trans-unit>
        <trans-unit id="69bbc2d35ac5910370025649743d2c9e7aba8bec" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers. The extension +vfpv3-d16 can be used as an alias for this extension.</source>
          <target state="translated">Инструкции VFPv3 с плавающей запятой с 16 регистрами двойной точности.В качестве псевдонима для этого расширения можно использовать расширение +vfpv3-d16.</target>
        </trans-unit>
        <trans-unit id="7d392f4c1ad45a7ce6a0755dbe2047b64e45ba0e" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">Инструкции VFPv3 с плавающей запятой,с 16 регистрами двойной точности и операциями преобразования с плавающей запятой половинной точности.</target>
        </trans-unit>
        <trans-unit id="9ea0bf30af6241dd74e66058037f24ca2aa3b024" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers.</source>
          <target state="translated">Инструкции VFPv3 с плавающей запятой,с 16 регистрами двойной точности.</target>
        </trans-unit>
        <trans-unit id="8c44d40609c70bac64a3214e9aba6ea5f2799b31" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="translated">Инструкции с плавающей запятой VFPv3 с 16 регистрами двойной точности. Расширение '</target>
        </trans-unit>
        <trans-unit id="69ba42177cf602fb7a0ed600eac827a8de6a449b" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">Инструкции VFPv3 с плавающей запятой,с 32 регистрами двойной точности и операциями преобразования с плавающей запятой половинной точности.</target>
        </trans-unit>
        <trans-unit id="193d13643a69320727d206517bd62145a8c8f03c" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers.</source>
          <target state="translated">Инструкции VFPv3 с плавающей запятой,с 32 регистрами двойной точности.</target>
        </trans-unit>
        <trans-unit id="a0936e97cd9c57c2c85efdbe6388f42baca5f03d" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers.</source>
          <target state="translated">Инструкции VFPv4 с плавающей запятой,с 16 регистрами двойной точности.</target>
        </trans-unit>
        <trans-unit id="103d1acc3dfe417798e6bd838ba4fc9709451552" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="translated">Инструкции с плавающей запятой VFPv4 с 16 регистрами двойной точности. Расширение '</target>
        </trans-unit>
        <trans-unit id="06ddcf864547f4dbeda808689e788fca6e819171" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 32 double-precision registers.</source>
          <target state="translated">Инструкции VFPv4 с плавающей запятой,с 32 регистрами двойной точности.</target>
        </trans-unit>
        <trans-unit id="9285ccf7646c59c98d31930bdd84e56c45d5fd26" translate="yes" xml:space="preserve">
          <source>The VR4130 pipeline is two-way superscalar, but can only issue two instructions together if the first one is 8-byte aligned. When this option is enabled, GCC aligns pairs of instructions that it thinks should execute in parallel.</source>
          <target state="translated">Трубопровод VR4130 является двусторонним суперскаляром,но может выдавать только две инструкции вместе,если первая из них выровнена на 8 байт.Когда эта опция включена,GCC выравнивает пары инструкций,которые,по его мнению,должны выполняться параллельно.</target>
        </trans-unit>
        <trans-unit id="cb154aff394215a4189b3dafa08992907beaeea3" translate="yes" xml:space="preserve">
          <source>The VSX instruction set (</source>
          <target state="translated">Набор команд VSX (</target>
        </trans-unit>
        <trans-unit id="5a0171ba1b31d3315fbbfaace918d589c6b61613" translate="yes" xml:space="preserve">
          <source>The abbreviation &lt;em&gt;GCC&lt;/em&gt; has multiple meanings in common use. The current official meaning is &amp;ldquo;GNU Compiler Collection&amp;rdquo;, which refers generically to the complete suite of tools. The name historically stood for &amp;ldquo;GNU C Compiler&amp;rdquo;, and this usage is still common when the emphasis is on compiling C programs. Finally, the name is also used when speaking of the &lt;em&gt;language-independent&lt;/em&gt; component of GCC: code shared among the compilers for all supported languages.</source>
          <target state="translated">Аббревиатура &lt;em&gt;GCC&lt;/em&gt; имеет несколько общих значений. Текущее официальное значение - &amp;laquo;Коллекция компиляторов GNU&amp;raquo;, что в общем относится к полному набору инструментов. Исторически это название расшифровывалось как &amp;laquo;GNU C Compiler&amp;raquo;, и это использование все еще широко распространено, когда упор делается на компиляцию программ на C. Наконец, это имя также используется, когда речь идет о &lt;em&gt;независимом&lt;/em&gt; от &lt;em&gt;языка&lt;/em&gt; компоненте GCC: код, совместно используемый компиляторами для всех поддерживаемых языков.</target>
        </trans-unit>
        <trans-unit id="3a9d23d169ba3b72eeef6725cec43a13a50013c2" translate="yes" xml:space="preserve">
          <source>The above generates bytecode for</source>
          <target state="translated">Вышеуказанное генерирует байткод для</target>
        </trans-unit>
        <trans-unit id="34a36dd9deec63b753f5d433c0dd87cbce7edcf4" translate="yes" xml:space="preserve">
          <source>The above lines are equivalent to the following:</source>
          <target state="translated">Вышеуказанные строки эквивалентны следующим:</target>
        </trans-unit>
        <trans-unit id="a39976e643ac6d1dc6fe3e4366ed3a13dea2466b" translate="yes" xml:space="preserve">
          <source>The above target attributes can be specified as follows:</source>
          <target state="translated">Вышеуказанные целевые атрибуты могут быть указаны следующим образом:</target>
        </trans-unit>
        <trans-unit id="ed1f637f7dae694f5c4cfc72955bdf63e2cee6a2" translate="yes" xml:space="preserve">
          <source>The accuracy is unknown.</source>
          <target state="translated">Точность неизвестна.</target>
        </trans-unit>
        <trans-unit id="120b6f184277986efda6f906c93a195e4dc7e853" translate="yes" xml:space="preserve">
          <source>The accuracy of the floating-point operations and of the library functions in &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; that return floating-point results (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="translated">Точность операций с плавающей запятой и библиотечных функций в &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; , которые возвращают результаты с плавающей запятой (C90, C99 и C11 5.2.4.2.2).</target>
        </trans-unit>
        <trans-unit id="80f0b076d52d6244bc6636b163e80827a773f50c" translate="yes" xml:space="preserve">
          <source>The actual register chosen to hold the constant data base address depends upon whether the</source>
          <target state="translated">Реальный регистр,выбранный для хранения постоянного адреса базы данных,зависит от того,является ли</target>
        </trans-unit>
        <trans-unit id="a30a65f7051569a9a9c6241a0c50efdd3d1de863" translate="yes" xml:space="preserve">
          <source>The added &lt;var&gt;flag&lt;/var&gt; argument is passed unchanged to &lt;code&gt;__sprintf_chk&lt;/code&gt; etc. functions and can contain implementation specific flags on what additional security measures the checking function might take, such as handling &lt;code&gt;%n&lt;/code&gt; differently.</source>
          <target state="translated">Аргумент добавленного &lt;var&gt;flag&lt;/var&gt; передается без изменений &lt;code&gt;__sprintf_chk&lt;/code&gt; и т. Д. И может содержать специфические для реализации флаги о том, какие дополнительные меры безопасности может предпринять функция проверки, например, по- разному обрабатывать &lt;code&gt;%n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e6f66f554f454fd60e4196cbe8c25320dedb4b7" translate="yes" xml:space="preserve">
          <source>The added comments include:</source>
          <target state="translated">Добавленные комментарии включают в себя:</target>
        </trans-unit>
        <trans-unit id="5c6f1012ead9ec76811fd2e9243c4b72f326472d" translate="yes" xml:space="preserve">
          <source>The additional block information is of the form</source>
          <target state="translated">Дополнительная блочная информация имеет форму</target>
        </trans-unit>
        <trans-unit id="79eafbe5ef62b1bf562656c8ccc8660f517c4542" translate="yes" xml:space="preserve">
          <source>The address as returned by &lt;code&gt;__builtin_return_address&lt;/code&gt; may have to be fed through this function to get the actual encoded address. For example, on the 31-bit S/390 platform the highest bit has to be masked out, or on SPARC platforms an offset has to be added for the true next instruction to be executed.</source>
          <target state="translated">Адрес, возвращаемый &lt;code&gt;__builtin_return_address&lt;/code&gt; , может потребоваться передать через эту функцию, чтобы получить фактический закодированный адрес. Например, на 31-битной платформе S / 390 старший бит должен быть замаскирован, или на платформах SPARC необходимо добавить смещение для выполнения истинной следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="9133fefd38b502d139962641eb1473acc29ca6ef" translate="yes" xml:space="preserve">
          <source>The addressability of a particular object can be set with the &lt;code&gt;model&lt;/code&gt; attribute.</source>
          <target state="translated">Адресуемость конкретного объекта может быть установлена ​​с помощью атрибута &lt;code&gt;model&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b38ea0caa823f37a2f086f0d1bc57b4b47d283c" translate="yes" xml:space="preserve">
          <source>The alignment of non-bit-field members of structures (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">Выравнивание членов структур,не являющихся подразделениями на местах (C90 6.5.2.1,C99 и C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="322481284c6908feb9887b9dd7bb912960123985" translate="yes" xml:space="preserve">
          <source>The alternate keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__extension__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; continue to work despite</source>
          <target state="translated">Альтернативные ключевые слова &lt;code&gt;__asm__&lt;/code&gt; , &lt;code&gt;__extension__&lt;/code&gt; , &lt;code&gt;__inline__&lt;/code&gt; и &lt;code&gt;__typeof__&lt;/code&gt; продолжают работать, несмотря на</target>
        </trans-unit>
        <trans-unit id="8e728c9fa7b9e6ce4962fad39896909da2bde1ee" translate="yes" xml:space="preserve">
          <source>The analogous feature in Fortran is called an assigned goto, but that name seems inappropriate in C, where one can do more than simply store label addresses in label variables.</source>
          <target state="translated">Аналогичная функция в Fortran называется назначенным goto,но это имя кажется неуместным в C,где можно сделать больше,чем просто хранить адреса этикеток в переменных этикетки.</target>
        </trans-unit>
        <trans-unit id="14c11777761d5f46c1a9fb516ac0c2ee4a9cb68d" translate="yes" xml:space="preserve">
          <source>The application binary interface implemented by a C or C++ compiler affects code generation and runtime support for:</source>
          <target state="translated">Двоичный интерфейс приложения,реализованный компилятором C или C++,влияет на поддержку генерации и выполнения кода:</target>
        </trans-unit>
        <trans-unit id="29b549ce42574a44cc4510011757b7ba9fd1935c" translate="yes" xml:space="preserve">
          <source>The approximate maximum amount of memory that can be allocated in order to perform the global common subexpression elimination optimization. If more memory than specified is required, the optimization is not done.</source>
          <target state="translated">Ориентировочный максимальный объем памяти,который может быть выделен для выполнения глобальной оптимизации по устранению общих подвыражений.Если требуется больше памяти,чем указано,оптимизация не производится.</target>
        </trans-unit>
        <trans-unit id="01165ed876927994264f7a9cab383ccc4af10540" translate="yes" xml:space="preserve">
          <source>The argument can be a list of strings of arbitrary length. The strings are sorted on output, so the order of the list is unimportant.</source>
          <target state="translated">Аргументом может быть список строк произвольной длины.Строки сортируются на выходе,поэтому порядок следования списка не имеет значения.</target>
        </trans-unit>
        <trans-unit id="59d49582cbfaa16c6712e0f374a5a6c15a857459" translate="yes" xml:space="preserve">
          <source>The argument to</source>
          <target state="translated">Аргумент в пользу</target>
        </trans-unit>
        <trans-unit id="d44a319a963da0f3902d413f244d251258e282dd" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are at least two pointers to functions, followed by the arguments to the type-generic macro (which will be passed as arguments to the selected function). All the pointers to functions must be pointers to prototyped functions, none of which may have variable arguments, and all of which must have the same number of parameters; the number of parameters of the first function determines how many arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are interpreted as function pointers, and how many as the arguments to the called function.</source>
          <target state="translated">Аргументы &lt;code&gt;__builtin_tgmath&lt;/code&gt; - это по крайней мере два указателя на функции, за которыми следуют аргументы макроса универсального типа (который будет передан в качестве аргументов выбранной функции). Все указатели на функции должны быть указателями на прототипы функций, ни одна из которых не может иметь переменных аргументов, и все они должны иметь одинаковое количество параметров; количество параметров первой функции определяет, сколько аргументов &lt;code&gt;__builtin_tgmath&lt;/code&gt; интерпретируется как указатели на функции, а сколько - как аргументы вызываемой функции.</target>
        </trans-unit>
        <trans-unit id="966ac956bf197ec8f0ba6771423c919858f24a7d" translate="yes" xml:space="preserve">
          <source>The arguments to the built-in functions can be divided into three groups: register numbers, compile-time constants and run-time values. In order to make this classification clear at a glance, the arguments and return values are given the following pseudo types:</source>
          <target state="translated">Аргументы к встроенным функциям можно разделить на три группы:номера регистров,константы времени компиляции и значения времени исполнения.Для того,чтобы сделать эту классификацию понятной с первого взгляда,аргументы и возвращаемые значения имеют следующие псевдотипы:</target>
        </trans-unit>
        <trans-unit id="c829863ade5431c1682f5d64360267aae12a2fb8" translate="yes" xml:space="preserve">
          <source>The attribute can also be applied to an inline namespace, but does not affect the mangled name of the namespace; in this case it is only used for</source>
          <target state="translated">Атрибут также может быть применен к внутристрочному пространству имён,но не влияет на искажённое имя пространства имён;в этом случае он используется только для</target>
        </trans-unit>
        <trans-unit id="ed02eb26a29f10b556adacd30701241deccd245e" translate="yes" xml:space="preserve">
          <source>The attribute cannot be used to decrease the alignment of a function previously declared with a more restrictive alignment; only to increase it. Attempts to do otherwise are diagnosed. Some targets specify a minimum default alignment for functions that is greater than 1. On such targets, specifying a less restrictive alignment is silently ignored. Using the attribute overrides the effect of the</source>
          <target state="translated">Атрибут не может быть использован для уменьшения выравнивания функции,ранее объявленной с более ограничительным выравниванием,а только для его увеличения.Попытки сделать по-другому диагностируются.Некоторые цели указывают минимальное выравнивание по умолчанию для функций больше 1.На таких целях указание менее ограничительного выравнивания молча игнорируется.Использование атрибута переопределяет эффект от</target>
        </trans-unit>
        <trans-unit id="ae26e49e643c3950ed6f72c5632f4fffd355af07" translate="yes" xml:space="preserve">
          <source>The attribute has no effect on functions defined within the current compilation unit. This is to allow easy merging of multiple compilation units into one, for example, by using the link-time optimization. For this reason the attribute is not allowed on types to annotate indirect calls.</source>
          <target state="translated">Атрибут не влияет на функции,определенные в текущем модуле компиляции.Это позволяет легко объединить несколько модулей компиляции в один,например,с помощью оптимизации времени соединения.По этой причине атрибут не допускается на типы для аннотирования косвенных вызовов.</target>
        </trans-unit>
        <trans-unit id="87e6916763209960cf7a9bdaddf003a5218d3bef" translate="yes" xml:space="preserve">
          <source>The attribute is automatically set with a position of 0 for the built-in functions &lt;code&gt;execl&lt;/code&gt; and &lt;code&gt;execlp&lt;/code&gt;. The built-in function &lt;code&gt;execle&lt;/code&gt; has the attribute set with a position of 1.</source>
          <target state="translated">&lt;code&gt;execl&lt;/code&gt; автоматически присваивается позиция 0 для встроенных функций execl и &lt;code&gt;execlp&lt;/code&gt; . У встроенной функции &lt;code&gt;execle&lt;/code&gt; атрибут установлен с позицией 1.</target>
        </trans-unit>
        <trans-unit id="fe2a754094a48aee11cc854617f21a28a6c915b2" translate="yes" xml:space="preserve">
          <source>The attribute is ignored for undefined symbols.</source>
          <target state="translated">Атрибут игнорируется для неопределенных символов.</target>
        </trans-unit>
        <trans-unit id="c20b877bf7007b2fcc50da9d21f8618882a3644d" translate="yes" xml:space="preserve">
          <source>The attribute is intended for library functions to improve dataflow analysis. The compiler takes the hint that any data not escaping the current compilation unit cannot be used or modified by the leaf function. For example, the &lt;code&gt;sin&lt;/code&gt; function is a leaf function, but &lt;code&gt;qsort&lt;/code&gt; is not.</source>
          <target state="translated">Атрибут предназначен для библиотечных функций для улучшения анализа потока данных. Компилятор получает подсказку, что любые данные, не экранирующие текущую единицу компиляции, не могут быть использованы или изменены конечной функцией. Например, функция &lt;code&gt;sin&lt;/code&gt; является листовой функцией, а &lt;code&gt;qsort&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="cdb101c8aa868b197540d1e1e07e514397c2827e" translate="yes" xml:space="preserve">
          <source>The attribute parameters configure what values are passed into the kernel function by the GPU drivers, via the initial register state. Some values are used by the compiler, and therefore forced on. Enabling other options may break assumptions in the compiler and/or run-time libraries.</source>
          <target state="translated">Параметры атрибута настраивают,какие значения передаются в функцию кернела драйверами GPU,через начальное состояние регистра.Некоторые значения используются компилятором,и поэтому принудительно включаются.Включение других параметров может нарушить допущения в компиляторе и/или библиотеках времени исполнения.</target>
        </trans-unit>
        <trans-unit id="f37e3b5bceea5d68174fbdb23337f013d5dc061b" translate="yes" xml:space="preserve">
          <source>The attributes work in conjunction with a linker script that has been augmented to specify where to place sections with a &lt;code&gt;.lower&lt;/code&gt; and a &lt;code&gt;.upper&lt;/code&gt; prefix. So, for example, as well as placing the &lt;code&gt;.data&lt;/code&gt; section, the script also specifies the placement of a &lt;code&gt;.lower.data&lt;/code&gt; and a &lt;code&gt;.upper.data&lt;/code&gt; section. The intention is that &lt;code&gt;lower&lt;/code&gt; sections are placed into a small but easier to access memory region and the upper sections are placed into a larger, but slower to access, region.</source>
          <target state="translated">Атрибуты работают вместе со сценарием компоновщика, который был расширен, чтобы указать, где размещать разделы с &lt;code&gt;.lower&lt;/code&gt; и &lt;code&gt;.upper&lt;/code&gt; . Так, например, &lt;code&gt;.lower.data&lt;/code&gt; размещения раздела &lt;code&gt;.data&lt;/code&gt; , сценарий также определяет размещение раздела .lower.data и &lt;code&gt;.upper.data&lt;/code&gt; . Предполагается, что &lt;code&gt;lower&lt;/code&gt; секции помещаются в небольшую, но более доступную область памяти, а верхние секции помещаются в большую, но более медленную для доступа область.</target>
        </trans-unit>
        <trans-unit id="10feff4fc0898bcb9645a7662553ea298f34abd3" translate="yes" xml:space="preserve">
          <source>The authoritative manual on Objective-C 2.0 is available from Apple:</source>
          <target state="translated">Авторитетное руководство по Objective-C 2.0 доступно в компании Apple:</target>
        </trans-unit>
        <trans-unit id="f6ef9f24ededd45d5c51229d5801270991d5579a" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.05 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">Основные встроенные функции,описанные в этом разделе,доступны в семействе процессоров PowerPC,начиная с ISA 2.05 или более поздней версии.Если конкретные опции явно не отключены в командной строке,указание опции</target>
        </trans-unit>
        <trans-unit id="edbf04361cb171c9ec574af51f9f9931b1811352" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.07 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">Основные встроенные функции,описанные в этом разделе,доступны в семействе процессоров PowerPC,начиная с ISA 2.07 или более поздней версии.Если только конкретные опции явно не отключены в командной строке,указание опции</target>
        </trans-unit>
        <trans-unit id="70f8648696a80bbf371453c7d66873b6ed3c1e9f" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 3.0 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">Основные встроенные функции,описанные в этом разделе,доступны в семействе процессоров PowerPC,начиная с ISA 3.0 или более поздней версии.Если только конкретные опции явно не отключены в командной строке,указание опции</target>
        </trans-unit>
        <trans-unit id="b5753c392332963f289e128617ea50b9de09b52f" translate="yes" xml:space="preserve">
          <source>The behavior of most of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="translated">Поведение большинства из этих пунктов зависит от реализации библиотеки Си и не определяется самим GCC.</target>
        </trans-unit>
        <trans-unit id="12799856c643d4a305ab2b4319a6be1f011a91bc" translate="yes" xml:space="preserve">
          <source>The behavior of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="translated">Поведение этих точек зависит от реализации библиотеки Си и не определяется самим GCC.</target>
        </trans-unit>
        <trans-unit id="98ca99f07d3faae58eb40bce10f1e4e864f854e3" translate="yes" xml:space="preserve">
          <source>The behavior of this switch is not quite the same as marking the methods as hidden directly, because it does not affect static variables local to the function or cause the compiler to deduce that the function is defined in only one shared object.</source>
          <target state="translated">Поведение этого ключа не совсем то же самое,что пометить методы как скрытые напрямую,так как он не влияет на статические переменные,локальные для функции,и не заставляет компилятор делать вывод,что функция определена только в одном общем объекте.</target>
        </trans-unit>
        <trans-unit id="7d6b7cdf4a6f4c034253043f3e78682296fde54a" translate="yes" xml:space="preserve">
          <source>The behavior on each recognized non-&lt;code&gt;STDC #pragma&lt;/code&gt; directive (C90 6.8.6, C99 and C11 6.10.6).</source>
          <target state="translated">Поведение каждой распознанной директивы &lt;code&gt;STDC #pragma&lt;/code&gt; (C90 6.8.6, C99 и C11 6.10.6).</target>
        </trans-unit>
        <trans-unit id="78838b89d1e6169626813ca34b5663bfb106ff9a" translate="yes" xml:space="preserve">
          <source>The best solution to such a problem is to put the text into an actual C comment delimited by &amp;lsquo;</source>
          <target state="translated">Лучшее решение такой проблемы - поместить текст в настоящий комментарий C, разделенный символом '</target>
        </trans-unit>
        <trans-unit id="cbc968ad31a477faa2208668bddbf016d38a55ba" translate="yes" xml:space="preserve">
          <source>The built-in compare types&amp;ndash;eq, ne, gtu, ltu, geu, and leu.</source>
          <target state="translated">Встроенные типы сравнения: eq, ne, gtu, ltu, geu и leu.</target>
        </trans-unit>
        <trans-unit id="ce0a88d34ad669c64ab3760c61374b2e37e4cc3c" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_complex&lt;/code&gt; is provided for use in implementing the ISO C11 macros &lt;code&gt;CMPLXF&lt;/code&gt;, &lt;code&gt;CMPLX&lt;/code&gt; and &lt;code&gt;CMPLXL&lt;/code&gt;. &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt; must have the same type, a real binary floating-point type, and the result has the corresponding complex type with real and imaginary parts &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt;. Unlike &amp;lsquo;</source>
          <target state="translated">Встроенная функция &lt;code&gt;__builtin_complex&lt;/code&gt; предназначена для использования при реализации макросов ISO C11 &lt;code&gt;CMPLXF&lt;/code&gt; , &lt;code&gt;CMPLX&lt;/code&gt; и &lt;code&gt;CMPLXL&lt;/code&gt; . &lt;var&gt;real&lt;/var&gt; и &lt;var&gt;imag&lt;/var&gt; должны иметь тот же тип, типа с плавающей запятой в режиме реальных двоичной, и результат имеет соответствующий сложный тип с действительными и мнимыми частями &lt;var&gt;real&lt;/var&gt; и &lt;var&gt;imag&lt;/var&gt; . В отличие '</target>
        </trans-unit>
        <trans-unit id="4172235cf37ce3bd8136a03cb1f1f52ca1bd1d30" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_tgmath&lt;/code&gt;, available only for C and Objective-C, calls a function determined according to the rules of &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros. It is intended to be used in implementations of that header, so that expansions of macros from that header only expand each of their arguments once, to avoid problems when calls to such macros are nested inside the arguments of other calls to such macros; in addition, it results in better diagnostics for invalid calls to &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros than implementations using other GNU C language features. For example, the &lt;code&gt;pow&lt;/code&gt; type-generic macro might be defined as:</source>
          <target state="translated">Встроенная функция &lt;code&gt;__builtin_tgmath&lt;/code&gt; , доступная только для C и Objective-C, вызывает функцию, определенную в соответствии с правилами макросов &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; . Он предназначен для использования в реализациях этого заголовка, так что раскрытия макросов из этого заголовка только расширяют каждый из их аргументов один раз, чтобы избежать проблем, когда вызовы таких макросов вложены в аргументы других вызовов таких макросов; кроме того, это приводит к лучшей диагностике недопустимых вызовов макросов &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; , чем реализации, использующие другие возможности языка GNU C. Например, универсальный макрос типа &lt;code&gt;pow&lt;/code&gt; может быть определен как:</target>
        </trans-unit>
        <trans-unit id="a4ab6bdc7a525221a10db36f04ba0ea776ca5cba" translate="yes" xml:space="preserve">
          <source>The built-in function can be used where a variable appears to be used in a safe way, but the CPU, due to speculative execution may temporarily ignore the bounds checks. Consider, for example, the following function:</source>
          <target state="translated">Встроенная функция может быть использована там,где переменная,как представляется,используется безопасным способом,но процессор,из-за спекулятивного исполнения,может временно игнорировать проверки границ.Рассмотрим,например,следующую функцию:</target>
        </trans-unit>
        <trans-unit id="a003f5f8fd45a849966ac7beaa6dcf85e370f177" translate="yes" xml:space="preserve">
          <source>The built-in function will either cause execution to stall until the conditional branch has been fully resolved, or it may permit speculative execution to continue, but using 0 instead of &lt;code&gt;untrusted_value&lt;/code&gt; if that exceeds the limit.</source>
          <target state="translated">Встроенная функция либо приведет к остановке выполнения до тех пор, пока условная ветвь не будет полностью разрешена, либо она может разрешить спекулятивное выполнение для продолжения, но с использованием 0 вместо &lt;code&gt;untrusted_value&lt;/code&gt; , если это превышает предел.</target>
        </trans-unit>
        <trans-unit id="23fbf2c81175bf34ed4b14a9d7849c7a6ed67337" translate="yes" xml:space="preserve">
          <source>The built-in functions are optimized into the normal string functions like &lt;code&gt;memcpy&lt;/code&gt; if the last argument is &lt;code&gt;(size_t) -1&lt;/code&gt; or if it is known at compile time that the destination object will not be overflowed. If the compiler can determine at compile time that the object will always be overflowed, it issues a warning.</source>
          <target state="translated">Встроенные функции оптимизируются в обычные строковые функции, такие как &lt;code&gt;memcpy&lt;/code&gt; , если последний аргумент равен &lt;code&gt;(size_t) -1&lt;/code&gt; или если во время компиляции известно, что целевой объект не будет переполнен. Если компилятор может определить во время компиляции, что объект всегда будет переполнен, он выдает предупреждение.</target>
        </trans-unit>
        <trans-unit id="97b0909bb726639d57f4621d69b4f030cedbb5e2" translate="yes" xml:space="preserve">
          <source>The built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type of the third argument. If the cast result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. The value of the third argument is ignored, just the side effects in the third argument are evaluated, and no integral argument promotions are performed on the last argument. If the third argument is a bit-field, the type used for the result cast has the precision and signedness of the given bit-field, rather than precision and signedness of the underlying type.</source>
          <target state="translated">Встроенные функции переводят первые два операнда в знаковый тип бесконечной точности и выполняют сложение этих продвинутых операндов. Затем результат приводится к типу третьего аргумента. Если результат приведения равен результату с бесконечной точностью, встроенные функции возвращают &lt;code&gt;false&lt;/code&gt; , в противном случае они возвращают &lt;code&gt;true&lt;/code&gt; . Значение третьего аргумента игнорируется, оцениваются только побочные эффекты в третьем аргументе, и для последнего аргумента не выполняются никакие продвижение интегральных аргументов. Если третий аргумент является битовым полем, тип, используемый для приведения результата, имеет точность и знаковую точность данного битового поля, а не точность и знаковую точность базового типа.</target>
        </trans-unit>
        <trans-unit id="b3bbc4c3c1cb9c4fe70210b2dfdbc17fe5153882" translate="yes" xml:space="preserve">
          <source>The built-in functions supported are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334b3175e81dee6f1e168a0be44f3b7d957b1be7" translate="yes" xml:space="preserve">
          <source>The built-in macros&amp;rsquo; names follow the scheme &lt;code&gt;__AVR_&lt;var&gt;Device&lt;/var&gt;__&lt;/code&gt; where &lt;var&gt;Device&lt;/var&gt; is the device name as from the AVR user manual. The difference between &lt;var&gt;Device&lt;/var&gt; in the built-in macro and &lt;var&gt;device&lt;/var&gt; in</source>
          <target state="translated">Имена встроенных макросов соответствуют схеме &lt;code&gt;__AVR_&lt;var&gt;Device&lt;/var&gt;__&lt;/code&gt; где &lt;var&gt;Device&lt;/var&gt; - это имя устройства, указанное в руководстве пользователя AVR. Разница между &lt;var&gt;Device&lt;/var&gt; во встроенном макросе и &lt;var&gt;device&lt;/var&gt; в</target>
        </trans-unit>
        <trans-unit id="62f099d3393656bddb7d8b0dd222e5a223f8d688" translate="yes" xml:space="preserve">
          <source>The built-in versions of these functions use GCC&amp;rsquo;s normal mechanisms to save and restore registers using the stack on function entry and exit. The jump buffer argument &lt;var&gt;buf&lt;/var&gt; holds only the information needed to restore the stack frame, rather than the entire set of saved register values.</source>
          <target state="translated">Встроенные версии этих функций используют обычные механизмы GCC для сохранения и восстановления регистров с использованием стека при входе в функцию и выходе из нее. Аргумент буфера перехода &lt;var&gt;buf&lt;/var&gt; содержит только информацию, необходимую для восстановления кадра стека, а не весь набор сохраненных значений регистров.</target>
        </trans-unit>
        <trans-unit id="4488c1d75b7b81f78b64d60c26fdf9ed24d8f3bf" translate="yes" xml:space="preserve">
          <source>The call-clobbered integer registers.</source>
          <target state="translated">Целые позывные регистры.</target>
        </trans-unit>
        <trans-unit id="0b277cbf75c7f621fb1dabe16f1a3a2fa8a7f4cc" translate="yes" xml:space="preserve">
          <source>The caller copies function arguments passed by hidden reference. This option should be used with care as it is not compatible with the default 32-bit runtime. However, only aggregates larger than eight bytes are passed by hidden reference and the option provides better compatibility with OpenMP.</source>
          <target state="translated">Вызователь копирует аргументы функции,передаваемые по скрытой ссылке.Эту опцию следует использовать с осторожностью,так как она не совместима с 32-битным временем выполнения по умолчанию.Однако,только агрегаты размером больше восьми байт передаются по скрытой ссылке,а опция обеспечивает лучшую совместимость с OpenMP.</target>
        </trans-unit>
        <trans-unit id="b583bb229dda327522feb6b40a364f4908fd1bf3" translate="yes" xml:space="preserve">
          <source>The carry register.</source>
          <target state="translated">Книга учёта.</target>
        </trans-unit>
        <trans-unit id="c7287b1af6a41a31db6c4fc8adca45c0df1d456b" translate="yes" xml:space="preserve">
          <source>The change to the types of UTF-8 string and character literals introduces incompatibilities with ISO C++11 and later standards. For example, the following code is well-formed under ISO C++11, but is ill-formed when</source>
          <target state="translated">Изменение типов строковых и символьных литералов UTF-8 вводит несовместимость с ISO C++11 и более поздними стандартами.Например,следующий код хорошо сформирован по ISO C++11,но плохо сформирован,когда</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">Персонаж '</target>
        </trans-unit>
        <trans-unit id="519631b15cf0936ab9bd0c60033ca6acf8715c58" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are the same as for</source>
          <target state="translated">Выбор &lt;var&gt;cpu-type&lt;/var&gt; такой же, как и для</target>
        </trans-unit>
        <trans-unit id="682ea402eec35d575ae857912b781a6cde1e0d53" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are:</source>
          <target state="translated">Возможны следующие варианты &lt;var&gt;cpu-type&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="8623d02fccd10cdf135414efb4d8dedf3d5298b1" translate="yes" xml:space="preserve">
          <source>The code above would iterate over all objects in &lt;code&gt;array&lt;/code&gt;. For each of them, it assigns it to &lt;code&gt;object&lt;/code&gt;, then executes the &lt;code&gt;Do something with 'object'&lt;/code&gt; statements.</source>
          <target state="translated">Приведенный выше код будет перебирать все объекты в &lt;code&gt;array&lt;/code&gt; . Для каждого из них он назначает его &lt;code&gt;object&lt;/code&gt; , а затем выполняет инструкции &amp;laquo; &lt;code&gt;Do something with 'object'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990cbdb236536d3c2c7b3b4ad41a30dc08b70c1d" translate="yes" xml:space="preserve">
          <source>The colors are defined by the environment variable &lt;code&gt;GCC_COLORS&lt;/code&gt;. Its value is a colon-separated list of capabilities and Select Graphic Rendition (SGR) substrings. SGR commands are interpreted by the terminal or terminal emulator. (See the section in the documentation of your text terminal for permitted values and their meanings as character attributes.) These substring values are integers in decimal representation and can be concatenated with semicolons. Common values to concatenate include &amp;lsquo;</source>
          <target state="translated">Цвета определяются переменной окружения &lt;code&gt;GCC_COLORS&lt;/code&gt; . Его значение представляет собой список возможностей, разделенных двоеточиями, и подстроки Select Graphic Rendition (SGR). Команды SGR интерпретируются терминалом или эмулятором терминала. (См. Раздел документации вашего текстового терминала, чтобы узнать о допустимых значениях и их значениях в качестве атрибутов символов.) Эти значения подстроки являются целыми числами в десятичном представлении и могут быть объединены точками с запятой. Общие значения для объединения включают '</target>
        </trans-unit>
        <trans-unit id="34aa8249352c8e598246fe5c42924ea343806e93" translate="yes" xml:space="preserve">
          <source>The comment needs to be followed after optional whitespace and other comments by &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; keywords or by a user label that precedes some &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label.</source>
          <target state="translated">Комментарий должен следовать после необязательного пробела и других комментариев по &lt;code&gt;case&lt;/code&gt; или ключевым словам по &lt;code&gt;default&lt;/code&gt; или по пользовательской метке, которая предшествует некоторому &lt;code&gt;case&lt;/code&gt; или метке по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4f1f40d78278988845f6e6d5dd1df865371c25c" translate="yes" xml:space="preserve">
          <source>The comments are intended for humans rather than machines and hence the precise format of the comments is subject to change.</source>
          <target state="translated">Комментарии предназначены для людей,а не для машин,поэтому точный формат комментариев может быть изменен.</target>
        </trans-unit>
        <trans-unit id="92f39136333428ef92d0ab34cd6ec4175f20f2a6" translate="yes" xml:space="preserve">
          <source>The common src/dest memory addressing modes.</source>
          <target state="translated">Общие режимы адресации памяти src/dest.</target>
        </trans-unit>
        <trans-unit id="23d24a28b1d2dd308a7ff9954bb96ae5aaa048ba" translate="yes" xml:space="preserve">
          <source>The common subset of the ARMv7-A, ARMv7-R and ARMv7-M architectures.</source>
          <target state="translated">Общее подмножество архитектур ARMv7-A,ARMv7-R и ARMv7-M.</target>
        </trans-unit>
        <trans-unit id="17c10738c483ffe85f7448f4cbfe545afae5514b" translate="yes" xml:space="preserve">
          <source>The compiler assumes that &lt;code&gt;EIND&lt;/code&gt; never changes during the startup code or during the application. In particular, &lt;code&gt;EIND&lt;/code&gt; is not saved/restored in function or interrupt service routine prologue/epilogue.</source>
          <target state="translated">Компилятор предполагает, что &lt;code&gt;EIND&lt;/code&gt; никогда не изменяется во время запуска кода или во время работы приложения. В частности, &lt;code&gt;EIND&lt;/code&gt; не сохраняется / не восстанавливается в прологе / эпилоге подпрограммы обслуживания функций или прерываний.</target>
        </trans-unit>
        <trans-unit id="8983abbfe719941604e388ad4f86efe2a35d89a4" translate="yes" xml:space="preserve">
          <source>The compiler automatically sets the alignment for the declared variable or field to &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables or fields that you have aligned this way. Note that the value of &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; may change depending on command-line options.</source>
          <target state="translated">Компилятор автоматически устанавливает для объявленной переменной или поля &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; . Выполнение этого часто может сделать операции копирования более эффективными, поскольку компилятор может использовать любые инструкции, копирующие самые большие фрагменты памяти, при выполнении копий в или из переменных или полей, которые вы выровняли таким образом. Обратите внимание, что значение &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; может изменяться в зависимости от параметров командной строки.</target>
        </trans-unit>
        <trans-unit id="9e7e2956c5fa63410dcde9892cdb317e8b9bdabe" translate="yes" xml:space="preserve">
          <source>The compiler can accept several base standards, such as &amp;lsquo;</source>
          <target state="translated">Компилятор может принимать несколько базовых стандартов, например '</target>
        </trans-unit>
        <trans-unit id="ae77b7d999c147c822471a0c6078013beaa6bc78" translate="yes" xml:space="preserve">
          <source>The compiler checks to see if the path provided by</source>
          <target state="translated">Компилятор проверяет,не предоставляет ли путь</target>
        </trans-unit>
        <trans-unit id="e75bc3167776cc7681a2a3309af02b07eee5f4ff" translate="yes" xml:space="preserve">
          <source>The compiler contains estimates of the number of clock cycles for &amp;ldquo;typical&amp;rdquo; EV4 &amp;amp; EV5 hardware for the Level 1, 2 &amp;amp; 3 caches (also called Dcache, Scache, and Bcache), as well as to main memory. Note that L3 is only valid for EV5.</source>
          <target state="translated">Компилятор содержит оценки количества тактовых циклов для &amp;laquo;типичного&amp;raquo; оборудования EV4 и EV5 для кешей уровней 1, 2 и 3 (также называемых Dcache, Scache и Bcache), а также для основной памяти. Обратите внимание, что L3 действителен только для EV5.</target>
        </trans-unit>
        <trans-unit id="8338416b67f14201602d466304368b7f468175f5" translate="yes" xml:space="preserve">
          <source>The compiler copies the assembler instructions in a basic &lt;code&gt;asm&lt;/code&gt; verbatim to the assembly language output file, without processing dialects or any of the &amp;lsquo;</source>
          <target state="translated">Компилятор копирует инструкции ассемблера в базовом формате &lt;code&gt;asm&lt;/code&gt; дословно в выходной файл языка ассемблера, не обрабатывая диалекты или любой из символов '</target>
        </trans-unit>
        <trans-unit id="d28532eae1da814b4665d28f7dd4fbb9e0aec8b2" translate="yes" xml:space="preserve">
          <source>The compiler driver program runs one or more of the subprograms &lt;code&gt;cpp&lt;/code&gt;, &lt;code&gt;cc1&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;. It tries &lt;var&gt;prefix&lt;/var&gt; as a prefix for each program it tries to run, both with and without &amp;lsquo;</source>
          <target state="translated">Программа драйвера компилятора запускает одну или несколько подпрограмм &lt;code&gt;cpp&lt;/code&gt; , &lt;code&gt;cc1&lt;/code&gt; , &lt;code&gt;as&lt;/code&gt; и &lt;code&gt;ld&lt;/code&gt; . Он пробует &lt;var&gt;prefix&lt;/var&gt; в качестве префикса для каждой программы, которую пытается запустить, как с, так и без '</target>
        </trans-unit>
        <trans-unit id="9b9b15ff6acdc5c85d5777579b9105147bc703cb" translate="yes" xml:space="preserve">
          <source>The compiler emits such &lt;code&gt;gs&lt;/code&gt; modifiers for code labels in the following situations:</source>
          <target state="translated">Компилятор генерирует такие модификаторы &lt;code&gt;gs&lt;/code&gt; для меток кода в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="1aa76bdb9ae1bbf7aa774ff7d0e6d298e86f04a3" translate="yes" xml:space="preserve">
          <source>The compiler generates special code to access the variable &lt;code&gt;i&lt;/code&gt;. It may use runtime library support, or generate special machine instructions to access that address space.</source>
          <target state="translated">Компилятор генерирует специальный код для доступа к переменной &lt;code&gt;i&lt;/code&gt; . Он может использовать поддержку библиотеки времени выполнения или генерировать специальные машинные инструкции для доступа к этому адресному пространству.</target>
        </trans-unit>
        <trans-unit id="6d157d680a0dc51afbbd2163137f4b54277c4701" translate="yes" xml:space="preserve">
          <source>The compiler is configured to be used together with AVR-Libc. See the</source>
          <target state="translated">Компилятор настроен на использование вместе с AVR-Libc.См.раздел</target>
        </trans-unit>
        <trans-unit id="fdab34c680d8fa9373eabc63f94733d605cf2016" translate="yes" xml:space="preserve">
          <source>The compiler may generate calls to &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt;. These entries are usually resolved by entries in libc. These entry points should be supplied through some other mechanism when this option is specified.</source>
          <target state="translated">Компилятор может генерировать вызовы &lt;code&gt;memcmp&lt;/code&gt; , &lt;code&gt;memset&lt;/code&gt; , &lt;code&gt;memcpy&lt;/code&gt; и &lt;code&gt;memmove&lt;/code&gt; . Эти записи обычно разрешаются записями в libc. Эти точки входа должны быть предоставлены через какой-либо другой механизм, если указана эта опция.</target>
        </trans-unit>
        <trans-unit id="197f6accb1b57a2d3b7bbd9dc901a8f9853c9909" translate="yes" xml:space="preserve">
          <source>The compiler may move the addition back before the &lt;code&gt;volatile asm&lt;/code&gt; statement. To make it work as expected, add an artificial dependency to the &lt;code&gt;asm&lt;/code&gt; by referencing a variable in the subsequent code, for example:</source>
          <target state="translated">Компилятор может вернуть сложение перед &lt;code&gt;volatile asm&lt;/code&gt; оператором asm . Чтобы заставить его работать должным образом, добавьте искусственную зависимость к &lt;code&gt;asm&lt;/code&gt; ,указав переменную в последующем коде, например:</target>
        </trans-unit>
        <trans-unit id="2d9dc939c11511961a2efd9a38375989ea973bee" translate="yes" xml:space="preserve">
          <source>The compiler never sets &lt;code&gt;EIND&lt;/code&gt;.</source>
          <target state="translated">Компилятор никогда не устанавливает &lt;code&gt;EIND&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c65d66d80d8006703599470ce9ad6d678c7518" translate="yes" xml:space="preserve">
          <source>The compiler performs optimization based on the knowledge it has of the program. Compiling multiple files at once to a single output file mode allows the compiler to use information gained from all of the files when compiling each of them.</source>
          <target state="translated">Компилятор производит оптимизацию,основываясь на знании программы.Компиляция нескольких файлов одновременно в режиме одного выходного файла позволяет компилятору при компиляции каждого из них использовать информацию,полученную из всех файлов.</target>
        </trans-unit>
        <trans-unit id="059a79983e1d0cd8bbb8de563c5411cbd5695493" translate="yes" xml:space="preserve">
          <source>The compiler rearranges the member initializers for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; to match the declaration order of the members, emitting a warning to that effect. This warning is enabled by</source>
          <target state="translated">Компилятор перестраивает инициализаторы элементов для &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; , чтобы они соответствовали порядку объявления членов, выдавая соответствующее предупреждение. Это предупреждение включено</target>
        </trans-unit>
        <trans-unit id="6f7ea77386532c48049a0ac434d425f5c9cdb9e9" translate="yes" xml:space="preserve">
          <source>The compiler uses &lt;code&gt;EIND&lt;/code&gt; implicitly in &lt;code&gt;EICALL&lt;/code&gt;/&lt;code&gt;EIJMP&lt;/code&gt; instructions or might read &lt;code&gt;EIND&lt;/code&gt; directly in order to emulate an indirect call/jump by means of a &lt;code&gt;RET&lt;/code&gt; instruction.</source>
          <target state="translated">Компилятор неявно использует &lt;code&gt;EIND&lt;/code&gt; в &lt;code&gt;EICALL&lt;/code&gt; / &lt;code&gt;EIJMP&lt;/code&gt; или может читать &lt;code&gt;EIND&lt;/code&gt; напрямую, чтобы имитировать косвенный вызов / переход с помощью инструкции &lt;code&gt;RET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a697129b447131da9ef72d7d16ecc19d13cde06f" translate="yes" xml:space="preserve">
          <source>The compiler uses a variety of heuristics to determine whether or not to inline a function. For example, the compiler takes into account the size of the function being inlined and the amount of inlining that has already been done in the current function. Therefore, seemingly insignificant changes in the source program can cause the warnings produced by</source>
          <target state="translated">Компилятор использует различные эвристики,чтобы определить,следует ли встраивать функцию.Например,компилятор учитывает размер встраиваемой функции и количество встраиваний,которые уже были сделаны в текущей функции.Следовательно,кажущиеся незначительными изменения в исходной программе могут привести к появлению предупреждений от</target>
        </trans-unit>
        <trans-unit id="37e71b48c058bf8bd050867961b9167f5825927e" translate="yes" xml:space="preserve">
          <source>The compiler will attempt to use hardware instructions to implement these built-in functions where possible, like conditional jump on overflow after addition, conditional jump on carry etc.</source>
          <target state="translated">Компилятор попытается использовать аппаратные инструкции для реализации этих встроенных функций там,где это возможно,например,условный переход при переполнении после добавления,условный переход при переносе и т.д.</target>
        </trans-unit>
        <trans-unit id="1f76bb0a6a769fd6051ac5f386b3821fb4f8794e" translate="yes" xml:space="preserve">
          <source>The concatenated &lt;code&gt;hi&lt;/code&gt; and &lt;code&gt;lo&lt;/code&gt; registers. Use this register to store doubleword values.</source>
          <target state="translated">Объединенные регистры &lt;code&gt;hi&lt;/code&gt; и &lt;code&gt;lo&lt;/code&gt; . Используйте этот регистр для хранения значений двойного слова.</target>
        </trans-unit>
        <trans-unit id="99e27c97d9f5e63a4ed1ab3fd7f4a5a1d329e043" translate="yes" xml:space="preserve">
          <source>The conditional text &lt;code&gt;X&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="translated">Условный текст &lt;code&gt;X&lt;/code&gt; в '</target>
        </trans-unit>
        <trans-unit id="a43dc662cd7d08ba0c1419ce7462e0ce31ad7cad" translate="yes" xml:space="preserve">
          <source>The constant -1</source>
          <target state="translated">постоянная -1</target>
        </trans-unit>
        <trans-unit id="b06d0b57697105de48b17a361b846597d95ea06a" translate="yes" xml:space="preserve">
          <source>The constant 0.</source>
          <target state="translated">Константа 0.</target>
        </trans-unit>
        <trans-unit id="40c6bdbaee6c04b3fea04b89e43f4576ad393c2b" translate="yes" xml:space="preserve">
          <source>The constant 4096</source>
          <target state="translated">постоянная 4096</target>
        </trans-unit>
        <trans-unit id="2dcf3547f5273811228bed3353ffa4e638845233" translate="yes" xml:space="preserve">
          <source>The constant all-ones, for floating-point.</source>
          <target state="translated">Постоянные все-в-одном,для плавающей точки.</target>
        </trans-unit>
        <trans-unit id="d766b475adfc1a095915836fa6b0ad31150ade7f" translate="yes" xml:space="preserve">
          <source>The constant string objects are by default instances of the &lt;code&gt;NXConstantString&lt;/code&gt; class which is provided by the GNU Objective-C runtime. To get the definition of this class you must include the</source>
          <target state="translated">Постоянные строковые объекты по умолчанию являются экземплярами класса &lt;code&gt;NXConstantString&lt;/code&gt; , который предоставляется средой выполнения GNU Objective-C. Чтобы получить определение этого класса, вы должны включить</target>
        </trans-unit>
        <trans-unit id="66bea79ec7c08d8354c118573be3f32ece7da1fe" translate="yes" xml:space="preserve">
          <source>The constant zero</source>
          <target state="translated">Постоянный ноль</target>
        </trans-unit>
        <trans-unit id="0934955261fabaea67e58ba0c7b8bdff156718f6" translate="yes" xml:space="preserve">
          <source>The constant zero or one</source>
          <target state="translated">Постоянный ноль или один</target>
        </trans-unit>
        <trans-unit id="910f5457ff53fa25b37247787227a27d85f14892" translate="yes" xml:space="preserve">
          <source>The constraint matches if the specified part of a constant has a value different from its other parts.</source>
          <target state="translated">Ограничение совпадает,если указанная часть константы имеет значение,отличное от других ее частей.</target>
        </trans-unit>
        <trans-unit id="d2273d82451da8273035b5677a47ae31f7f347c8" translate="yes" xml:space="preserve">
          <source>The contents of &lt;var&gt;definition&lt;/var&gt; are tokenized and processed as if they appeared during translation phase three in a &amp;lsquo;</source>
          <target state="translated">Содержимое &lt;var&gt;definition&lt;/var&gt; токенизируется и обрабатывается так, как если бы оно появилось на третьей фазе трансляции в '</target>
        </trans-unit>
        <trans-unit id="3b752ddcb3035f47ee09a797efcd12407968ef21" translate="yes" xml:space="preserve">
          <source>The convenience of this extension is that &lt;code&gt;f1&lt;/code&gt; has the desired type, eliminating the need to consistently refer to &lt;code&gt;f2.f1&lt;/code&gt;.</source>
          <target state="translated">Удобство этого расширения в том, что &lt;code&gt;f1&lt;/code&gt; имеет желаемый тип, что избавляет от необходимости постоянно ссылаться на &lt;code&gt;f2.f1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eb402cf1ad5d2ebe2ca4cbf79d4710d25aab043" translate="yes" xml:space="preserve">
          <source>The correct solution of the above problem is to use the &lt;code&gt;+load&lt;/code&gt; method instead of &lt;code&gt;+initialize&lt;/code&gt;:</source>
          <target state="translated">Правильное решение вышеуказанной проблемы - использовать метод &lt;code&gt;+load&lt;/code&gt; вместо &lt;code&gt;+initialize&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="195548e33bab5979c07277ae9248599cd2872bd1" translate="yes" xml:space="preserve">
          <source>The count register, &lt;code&gt;ctr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5773d425eed0cc1da37ec24e48650c9ef1f3309" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions.</source>
          <target state="translated">Криптографические инструкции.</target>
        </trans-unit>
        <trans-unit id="3b148cbd7e0801501003f1c6b7a5b5ed93ac8a89" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="translated">Криптографические инструкции.Это также позволяет использовать усовершенствованные SIMD и инструкции с плавающей запятой,а также расширение Dot Product.</target>
        </trans-unit>
        <trans-unit id="bebf33834922696e2e3f146a7028c6f38f3d8ce5" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Криптографические инструкции.Это также позволяет использовать усовершенствованную SIMD-карту и инструкции с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="3b57febbf4c477f2667a31f8b5a1e7554fec41ce" translate="yes" xml:space="preserve">
          <source>The current</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c616918c11c60074662af2cce8d7bf0b00b006e" translate="yes" xml:space="preserve">
          <source>The current implementation of LTO makes no attempt to generate bytecode that is portable between different types of hosts. The bytecode files are versioned and there is a strict version check, so bytecode files generated in one version of GCC do not work with an older or newer version of GCC.</source>
          <target state="translated">Текущая реализация LTO не делает попыток генерации байткода,переносимого между различными типами хостов.Файлы байткода версируются,и существует строгая проверка версий,поэтому файлы байткода,сгенерированные в одной из версий GCC,не работают со старой или более новой версией GCC.</target>
        </trans-unit>
        <trans-unit id="3c2f64218f4b3df3bf76a18bea506a72c2b53fb3" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide character constant consisting of a single multibyte character that maps to a member of the extended execution character set into a corresponding wide character code (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">Текущая локаль,используемая для преобразования широкой символьной константы,состоящей из одного многобайтового символа,который сопоставляется с членом расширенного набора символов исполнения,в соответствующий широкий символьный код (С90 6.1.3.4,С99 и С11 6.4.4.4).</target>
        </trans-unit>
        <trans-unit id="a8b517f5ebe96bc26ba29bd9df7b451bc7264848" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide string literal into corresponding wide character codes (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="translated">Текущая локаль,используемая для преобразования широкополосного литерала в соответствующие широкосимвольные коды (C90 6.1.4,C99 и C11 6.4.5).</target>
        </trans-unit>
        <trans-unit id="cdee0986787f12266222c4757db3c96510d2856b" translate="yes" xml:space="preserve">
          <source>The data in the</source>
          <target state="translated">Данные в</target>
        </trans-unit>
        <trans-unit id="ad21981df5f9d5df0a92c3202b31e09f62748eca" translate="yes" xml:space="preserve">
          <source>The data segment must be within 512KB while the read-only data segment can be within 4GB addressing space. The text segment should be still within 16MB addressing space.</source>
          <target state="translated">Сегмент данных должен находиться в пределах 512 КБ,в то время как сегмент данных,доступный только для чтения,может находиться в пределах 4 ГБ адресного пространства.Текстовый сегмент должен находиться в пределах 16 МБ адресного пространства.</target>
        </trans-unit>
        <trans-unit id="308218254edaf858c826e3717d9728c20e8ea1e8" translate="yes" xml:space="preserve">
          <source>The decimal floating types are &lt;code&gt;_Decimal32&lt;/code&gt;, &lt;code&gt;_Decimal64&lt;/code&gt;, and &lt;code&gt;_Decimal128&lt;/code&gt;. They use a radix of ten, unlike the floating types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; whose radix is not specified by the C standard but is usually two.</source>
          <target state="translated">Десятичные типы с плавающей запятой: &lt;code&gt;_Decimal32&lt;/code&gt; , &lt;code&gt;_Decimal64&lt;/code&gt; и &lt;code&gt;_Decimal128&lt;/code&gt; . Они используют десятичную систему счисления, в отличие от плавающих типов &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;long double&lt;/code&gt; , основание системы счисления которых не определено стандартом C, но обычно равно двум.</target>
        </trans-unit>
        <trans-unit id="4ed195636dddaed157754b6f5efb512126f16823" translate="yes" xml:space="preserve">
          <source>The declaration of an identifier for a variable that has block scope that specifies &lt;code&gt;__thread&lt;/code&gt; shall also specify either &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">Объявление идентификатора для переменной, имеющей область действия блока, определяющую &lt;code&gt;__thread&lt;/code&gt; , также должно указывать либо &lt;code&gt;extern&lt;/code&gt; , либо &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="539622d22b3611e1a0d2bdec661bbb3d138ab211" translate="yes" xml:space="preserve">
          <source>The default</source>
          <target state="translated">По умолчанию</target>
        </trans-unit>
        <trans-unit id="2d93ba84906186c36a266b5450164ecc57295a2f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;GCC_COLORS&lt;/code&gt; is</source>
          <target state="translated">По умолчанию &lt;code&gt;GCC_COLORS&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="cd78088e10f5ca7d05051ca6c08ccd0393bc0395" translate="yes" xml:space="preserve">
          <source>The default choice depends on the target.</source>
          <target state="translated">Выбор по умолчанию зависит от цели.</target>
        </trans-unit>
        <trans-unit id="24583facb0777645f4006ae576dc03c661b296bf" translate="yes" xml:space="preserve">
          <source>The default depends on how the compiler has been configured. It can be any of the above &lt;var&gt;WHEN&lt;/var&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821efaa8e812e852d4a90373d231a1a43df2b45f" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the LP64 and ILP32 ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="translated">Значение по умолчанию зависит от конкретной целевой конфигурации.Обратите внимание,что ABI LP64 и ILP32 не поддерживают линковку;вы должны скомпилировать всю программу с одним и тем же ABI,и линковку с совместимым набором библиотек.</target>
        </trans-unit>
        <trans-unit id="073f483a59a39bdd6290fbf3294619a632dc2b8a" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the hard-float and soft-float ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="translated">Значение по умолчанию зависит от конкретной целевой конфигурации.Обратите внимание,что ABI с жестким и мягким диском не поддерживают компоновку;вы должны компилировать всю программу с одним ABI и компоновать ее с совместимым набором библиотек.</target>
        </trans-unit>
        <trans-unit id="83926f7ff8324784f23d17c03f2640efad441ea9" translate="yes" xml:space="preserve">
          <source>The default for</source>
          <target state="translated">По умолчанию для</target>
        </trans-unit>
        <trans-unit id="c9e7e18cf6d489e9159a83316e730a739e99cc90" translate="yes" xml:space="preserve">
          <source>The default for this argument is system dependent, users who want a specific calling convention should specify one explicitly. The valid calling conventions are: &amp;lsquo;</source>
          <target state="translated">Значение по умолчанию для этого аргумента зависит от системы, пользователи, которым требуется конкретное соглашение о вызовах, должны указать его явно. Допустимые соглашения о вызовах:</target>
        </trans-unit>
        <trans-unit id="92d2141e4257c252bb28809158d1f4e1362f7a44" translate="yes" xml:space="preserve">
          <source>The default for this option is &amp;lsquo;</source>
          <target state="translated">Значение по умолчанию для этой опции - '</target>
        </trans-unit>
        <trans-unit id="5842694f6173b42e85122f8c60c286aa7ddb9932" translate="yes" xml:space="preserve">
          <source>The default is</source>
          <target state="translated">По умолчанию</target>
        </trans-unit>
        <trans-unit id="f12e5a4f7dd6f8646e20a0f33147742e17617209" translate="yes" xml:space="preserve">
          <source>The default is &amp;lsquo;</source>
          <target state="translated">По умолчанию '</target>
        </trans-unit>
        <trans-unit id="5d068c3eaa8d9ce215b5361f4b44c855149b5984" translate="yes" xml:space="preserve">
          <source>The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when RAM &amp;gt;= 1GB. If &lt;code&gt;getrlimit&lt;/code&gt; is available, the notion of &amp;ldquo;RAM&amp;rdquo; is the smallest of actual RAM and &lt;code&gt;RLIMIT_DATA&lt;/code&gt; or &lt;code&gt;RLIMIT_AS&lt;/code&gt;. If GCC is not able to calculate RAM on a particular platform, the lower bound of 30% is used. Setting this parameter and</source>
          <target state="translated">Значение по умолчанию - 30% + 70% * (RAM / 1GB) с верхней границей 100%, когда RAM&amp;gt; = 1GB. Если доступен &lt;code&gt;getrlimit&lt;/code&gt; , понятие &amp;laquo;RAM&amp;raquo; является наименьшим из фактических RAM и &lt;code&gt;RLIMIT_DATA&lt;/code&gt; или &lt;code&gt;RLIMIT_AS&lt;/code&gt; . Если GCC не может вычислить оперативную память на определенной платформе, используется нижняя граница 30%. Установка этого параметра и</target>
        </trans-unit>
        <trans-unit id="cce96b424afaca2d610cda8bfb3dce73bc563484" translate="yes" xml:space="preserve">
          <source>The default is the smaller of RAM/8, RLIMIT_RSS, or a limit that tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but with a lower bound of 4096 (four megabytes) and an upper bound of 131072 (128 megabytes). If GCC is not able to calculate RAM on a particular platform, the lower bound is used. Setting this parameter very large effectively disables garbage collection. Setting this parameter and</source>
          <target state="translated">По умолчанию используется меньшее из значений RAM/8,RLIMIT_RSS,или лимит,который пытается гарантировать,что RLIMIT_DATA или RLIMIT_AS не превышены,но с нижней границей 4096 (четыре мегабайта)и верхней-131072 (128 мегабайт).Если GCC не может вычислить объем оперативной памяти на определенной платформе,используется нижняя граница.Установка этого параметра очень большого значения эффективно отключает сбор мусора.Установка этого параметра и</target>
        </trans-unit>
        <trans-unit id="cfa3b0a93016b2ef8689d14e510c93e9df2d4e56" translate="yes" xml:space="preserve">
          <source>The default is to allow these instructions, but it is not possible for GCC to reliably detect all circumstances where a string instruction might be used to access an I/O register, so their use cannot be disabled automatically. Instead it is reliant upon the programmer to use the</source>
          <target state="translated">По умолчанию эти инструкции разрешены,но GCC не может надежно обнаружить все обстоятельства,при которых строковая инструкция может быть использована для доступа к регистру ввода/вывода,поэтому их использование не может быть отключено автоматически.Вместо этого,программист должен использовать команду</target>
        </trans-unit>
        <trans-unit id="b3f67e8f5424b41ebf8e66523efa318016a862fb" translate="yes" xml:space="preserve">
          <source>The default is to not maintain the backchain.</source>
          <target state="translated">По умолчанию не поддерживается обратная цепь.</target>
        </trans-unit>
        <trans-unit id="a0a0e13c8768face52cb8f602f8efb80a446348b" translate="yes" xml:space="preserve">
          <source>The default is to not use the packed stack layout.</source>
          <target state="translated">По умолчанию не используется компоновка упакованного стека.</target>
        </trans-unit>
        <trans-unit id="edb857f688cb7de8ba1fbdc52989269bb35500d9" translate="yes" xml:space="preserve">
          <source>The default is usually</source>
          <target state="translated">По умолчанию обычно</target>
        </trans-unit>
        <trans-unit id="d74d1893ecb7357c9e0df6cf36fc2bbcbd00a365" translate="yes" xml:space="preserve">
          <source>The default linker script is arranged for code with &lt;code&gt;EIND = 0&lt;/code&gt;. If code is supposed to work for a setup with &lt;code&gt;EIND != 0&lt;/code&gt;, a custom linker script has to be used in order to place the sections whose name start with &lt;code&gt;.trampolines&lt;/code&gt; into the segment where &lt;code&gt;EIND&lt;/code&gt; points to.</source>
          <target state="translated">Сценарий компоновщика по умолчанию предназначен для кода с &lt;code&gt;EIND = 0&lt;/code&gt; . Если предполагается, что код работает для настройки с &lt;code&gt;EIND != 0&lt;/code&gt; , необходимо использовать собственный сценарий компоновщика, чтобы поместить разделы, имена которых начинаются с &lt;code&gt;.trampolines&lt;/code&gt; , в сегмент, на &lt;code&gt;EIND&lt;/code&gt; указывает EIND .</target>
        </trans-unit>
        <trans-unit id="27ca561e84dd9753757548b177e64c001dc72487" translate="yes" xml:space="preserve">
          <source>The default memory model for the processor and operating system.</source>
          <target state="translated">Модель памяти по умолчанию для процессора и операционной системы.</target>
        </trans-unit>
        <trans-unit id="1d2c3331e29b4e0f75190cbcac7d2cc2935baa6d" translate="yes" xml:space="preserve">
          <source>The default size of &lt;code&gt;int&lt;/code&gt;s, &lt;code&gt;long&lt;/code&gt;s and pointers depends on the ABI. All the supported ABIs use 32-bit &lt;code&gt;int&lt;/code&gt;s. The n64 ABI uses 64-bit &lt;code&gt;long&lt;/code&gt;s, as does the 64-bit EABI; the others use 32-bit &lt;code&gt;long&lt;/code&gt;s. Pointers are the same size as &lt;code&gt;long&lt;/code&gt;s, or the same size as integer registers, whichever is smaller.</source>
          <target state="translated">Размер по умолчанию для &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; и указателей зависит от ABI. Все поддерживаемые ABI используют 32-битные &lt;code&gt;int&lt;/code&gt; . ABI n64 использует 64-битные &lt;code&gt;long&lt;/code&gt; s, как и 64-битный EABI; остальные используют 32-битные &lt;code&gt;long&lt;/code&gt; s. Указатели того же размера, что и &lt;code&gt;long&lt;/code&gt; s, или того же размера, что и целочисленные регистры, в зависимости от того, что меньше.</target>
        </trans-unit>
        <trans-unit id="c7b0f9504e79ddd153856cb5f4d8eb1074e6f4cb" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma (C99 and C11 7.6.1).</source>
          <target state="translated">Состояние по умолчанию для &lt;code&gt;FENV_ACCESS&lt;/code&gt; (C99 и C11 7.6.1).</target>
        </trans-unit>
        <trans-unit id="177e9fccdcf6129808c994646c54fbba2a07d2f1" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 7.12.2).</source>
          <target state="translated">Состояние по умолчанию для &lt;code&gt;FP_CONTRACT&lt;/code&gt; (C99 и C11 7.12.2).</target>
        </trans-unit>
        <trans-unit id="2aba487b3647bdb911ee4d93a6d6e3bbfd1ab912" translate="yes" xml:space="preserve">
          <source>The default target is automatically quoted, as if it were given with</source>
          <target state="translated">Цели по умолчанию автоматически цитируются,как если бы они были даны с</target>
        </trans-unit>
        <trans-unit id="33b715cc53246030b15f24132e973369879e225c" translate="yes" xml:space="preserve">
          <source>The default value is zero, which disables this feature. Note, this feature is not enabled by default with higher optimization levels (</source>
          <target state="translated">Значение по умолчанию равно нулю,что отключает эту функцию.Обратите внимание,что при более высоких уровнях оптимизации эта функция по умолчанию не включена (</target>
        </trans-unit>
        <trans-unit id="bbd9601e22b31b48a224ffc4033c0ab4f7fbfa78" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is</source>
          <target state="translated">Значение по умолчанию &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="209814b876827ae56a611572209eb49a8bba5de1" translate="yes" xml:space="preserve">
          <source>The default value of this option is determined by the application binary interface for the target processor.</source>
          <target state="translated">Значение этого параметра по умолчанию определяется прикладным двоичным интерфейсом для целевого процессора.</target>
        </trans-unit>
        <trans-unit id="59182b861f448516d9a37ab74276ea6b6b33c147" translate="yes" xml:space="preserve">
          <source>The default value of this option is enabled, thus the only useful form of the option is</source>
          <target state="translated">Значение по умолчанию этой опции включено,таким образом,единственной полезной формой опции является</target>
        </trans-unit>
        <trans-unit id="1a823e9ffdad4eb9044013582624dc9752e06eea" translate="yes" xml:space="preserve">
          <source>The default warning level of the</source>
          <target state="translated">Уровень предупреждений по умолчанию</target>
        </trans-unit>
        <trans-unit id="c7308db0e02a6c747424ae6a4742ab7d5a6523ec" translate="yes" xml:space="preserve">
          <source>The default when in a standards compliant mode (</source>
          <target state="translated">По умолчанию в режиме,соответствующем стандартам (</target>
        </trans-unit>
        <trans-unit id="c45a650c66e86b129ff1159a971751cec60bc96d" translate="yes" xml:space="preserve">
          <source>The default without</source>
          <target state="translated">По умолчанию без</target>
        </trans-unit>
        <trans-unit id="ecb6ca065b9096c7acde0b3f9da92272ca10172c" translate="yes" xml:space="preserve">
          <source>The default x86-32 ABI assumes that the callee pops the stack for hidden pointer. However, on x86-32 Microsoft Windows targets, the compiler assumes that the caller pops the stack for hidden pointer.</source>
          <target state="translated">По умолчанию x86-32 ABI предполагает,что callee выскакивает стек для скрытого указателя.Однако в целях x86-32 Microsoft Windows компилятор предполагает,что вызывающий абонент открывает стек для скрытого указателя.</target>
        </trans-unit>
        <trans-unit id="a2e6fba24182b6c22f37f14e5bbdf01ab49ea815" translate="yes" xml:space="preserve">
          <source>The default, if no C language dialect options are given, is</source>
          <target state="translated">По умолчанию,если не заданы диалекты языка C,то по умолчанию</target>
        </trans-unit>
        <trans-unit id="94e40f79f518daef10239cd573498a0a9fbea872" translate="yes" xml:space="preserve">
          <source>The default, if no C++ language dialect options are given, is</source>
          <target state="translated">По умолчанию,если не задан диалект языка C++,то по умолчанию,если не задан диалект языка C++,это</target>
        </trans-unit>
        <trans-unit id="63d161b7c381e191c75f2893e8fc452452e1e3d3" translate="yes" xml:space="preserve">
          <source>The definition given in the Intel documentation allows only for the use of the types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt; or their unsigned counterparts. GCC allows any scalar type that is 1, 2, 4 or 8 bytes in size other than the C type &lt;code&gt;_Bool&lt;/code&gt; or the C++ type &lt;code&gt;bool&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">Определение, данное в документации Intel, допускает использование только типов &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; или их беззнаковых аналогов. GCC допускает любой скалярный тип размером 1, 2, 4 или 8 байтов, кроме типа C &lt;code&gt;_Bool&lt;/code&gt; или типа C ++ &lt;code&gt;bool&lt;/code&gt; . Операции с аргументами указателя выполняются так, как если бы операнды имели тип &lt;code&gt;uintptr_t&lt;/code&gt; . То есть они не масштабируются по размеру типа, на который указывает указатель.</target>
        </trans-unit>
        <trans-unit id="12d18656502db6e4e9c93de0479a82b56cb9d524" translate="yes" xml:space="preserve">
          <source>The definitions for &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; when respectively, the date and time of translation are not available (C90 6.8.8, C99 6.10.8, C11 6.10.8.1).</source>
          <target state="translated">Определения для &lt;code&gt;__DATE__&lt;/code&gt; и &lt;code&gt;__TIME__&lt;/code&gt; , когда соответственно дата и время перевода недоступны (C90 6.8.8, C99 6.10.8, C11 6.10.8.1).</target>
        </trans-unit>
        <trans-unit id="d50e31983578e620136495305e55ed145625f1a3" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the execution frequency of the entry block of a function that a basic block of this function needs to at least have in order to be considered hot. The default is 1000, which means that a basic block is considered hot in a function if it is executed more frequently than 1/1000 of the frequency of the entry block of the function. 0 means that it is never considered hot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cdf285dab576e728fe4c1726581875dabc3071" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the maximal execution count of a basic block in the entire program that a basic block needs to at least have in order to be considered hot. The default is 10000, which means that a basic block is considered hot if its execution count is greater than 1/10000 of the maximal execution count. 0 means that it is never considered hot. Used in non-LTO mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8711313846a248f0818ef2198a1524b06952be7" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the number of profiled runs of the entire program below which the execution count of a basic block must be in order for the basic block to be considered unlikely executed. The default is 20, which means that a basic block is considered unlikely executed if it is executed in fewer than 1/20, or 5%, of the runs of the program. 0 means that it is always considered unlikely executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09ae46c0bc04395fafa29f4371d3dd1f0905098" translate="yes" xml:space="preserve">
          <source>The depth of search in the dominator tree for expressions to hoist. This is used to avoid quadratic behavior in hoisting algorithm. The value of 0 does not limit on the search, but may slow down compilation of huge functions.</source>
          <target state="translated">Глубина поиска в дереве доминаторов для поднятия выражений.Это используется для того,чтобы избежать квадратичного поведения в алгоритме подъема.Значение 0 не ограничивает поиск,но может замедлить компиляцию огромных функций.</target>
        </trans-unit>
        <trans-unit id="14934208c61e859a6e7eb6b441a06008f55e391f" translate="yes" xml:space="preserve">
          <source>The device / architecture belongs to the XMEGA family of devices.</source>
          <target state="translated">Устройство/архитектура относится к семейству устройств XMEGA.</target>
        </trans-unit>
        <trans-unit id="0848b55d6ef92bf5b121f28a3f70167cf843e9f0" translate="yes" xml:space="preserve">
          <source>The device has Read-Modify-Write instructions (XCH, LAC, LAS and LAT).</source>
          <target state="translated">Устройство имеет инструкции по чтению-изменению-записи (XCH,LAC,LAS и LAT).</target>
        </trans-unit>
        <trans-unit id="c94be4f62c4adcfc5a43023ae724a73e574f4d44" translate="yes" xml:space="preserve">
          <source>The device has a hardware multiplier.</source>
          <target state="translated">Устройство имеет аппаратный мультипликатор.</target>
        </trans-unit>
        <trans-unit id="40eec38c7059a6f4d65d7d4102f16aec3f9f23ce" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;EIJMP&lt;/code&gt; and &lt;code&gt;EICALL&lt;/code&gt; instructions. This is the case for devices with more than 128 KiB of program memory. This also means that the program counter (PC) is 3 bytes wide.</source>
          <target state="translated">В устройстве есть инструкции &lt;code&gt;EIJMP&lt;/code&gt; и &lt;code&gt;EICALL&lt;/code&gt; . Это относится к устройствам с более чем 128 Кбайт программной памяти. Это также означает, что счетчик программ (ПК) имеет ширину 3 байта.</target>
        </trans-unit>
        <trans-unit id="7183cfd675e5fad71be960e9de6faa5f999d51c4" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;ELPM
R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="translated">Устройство имеет &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; и &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="124acdeb9487e33b6bf2adad9222c95480d5e077" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="translated">В устройстве есть инструкция &lt;code&gt;ELPM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ace169ce6eef96ce4c8d2efd5bee4eef88f9d4da" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;JMP&lt;/code&gt; and &lt;code&gt;CALL&lt;/code&gt; instructions. This is the case for devices with more than 8 KiB of program memory.</source>
          <target state="translated">Устройство имеет инструкции &lt;code&gt;JMP&lt;/code&gt; и &lt;code&gt;CALL&lt;/code&gt; . Это относится к устройствам с более чем 8 КиБ программной памяти.</target>
        </trans-unit>
        <trans-unit id="c648d34bf5dc6505ae5b97362b5aa073400b3ded" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="translated">Устройство имеет инструкции &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; и &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeb599358087e9ab1d870c33d3b39e9eeb6c15cf" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;MOVW&lt;/code&gt; instruction to perform 16-bit register-register moves.</source>
          <target state="translated">В устройстве есть инструкция &lt;code&gt;MOVW&lt;/code&gt; для выполнения 16-битных перемещений регистр-регистр.</target>
        </trans-unit>
        <trans-unit id="83a1356b9ac9ce24c84c12bd07e29feb04f94c12" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;RAMPD&lt;/code&gt;, &lt;code&gt;RAMPX&lt;/code&gt;, &lt;code&gt;RAMPY&lt;/code&gt;, &lt;code&gt;RAMPZ&lt;/code&gt; special function register, respectively.</source>
          <target state="translated">Устройство имеет &lt;code&gt;RAMPZ&lt;/code&gt; специальных функций &lt;code&gt;RAMPD&lt;/code&gt; , &lt;code&gt;RAMPX&lt;/code&gt; , &lt;code&gt;RAMPY&lt;/code&gt; , RAMPZ соответственно.</target>
        </trans-unit>
        <trans-unit id="7440edf5c9a0d8bde64b1ecefe74df7b62918795" translate="yes" xml:space="preserve">
          <source>The device has the SPH (high part of stack pointer) special function register or has an 8-bit stack pointer, respectively. The definition of these macros is affected by</source>
          <target state="translated">Устройство имеет регистр SPH (высокая часть указателя стека)специальной функции или 8-битный указатель стека,соответственно.На определение этих макросов влияет</target>
        </trans-unit>
        <trans-unit id="a15f34c198926a24e4b29d121787f367b6273a1a" translate="yes" xml:space="preserve">
          <source>The diff may or may not be colorized, following the same rules as for diagnostics (see</source>
          <target state="translated">Разница может быть окрашена или не окрашена,следуя тем же правилам,что и для диагностики (смотрите раздел</target>
        </trans-unit>
        <trans-unit id="bfb8bac86341e0faa063bc2c7464731f3754920b" translate="yes" xml:space="preserve">
          <source>The differences to the &lt;code&gt;naked&lt;/code&gt; function attribute are:</source>
          <target state="translated">Отличия от атрибута &lt;code&gt;naked&lt;/code&gt; функции:</target>
        </trans-unit>
        <trans-unit id="caa2f3d0586724648ad5dc95b2dd6a57770fcc55" translate="yes" xml:space="preserve">
          <source>The direction of rounding when a floating-point number is converted to a narrower floating-point number (C90 6.2.1.4, C99 and C11 6.3.1.5).</source>
          <target state="translated">Направление округления,когда число с плавающей точкой преобразуется в более узкое число с плавающей точкой (C90 6.2.1.4,C99 и C11 6.3.1.5).</target>
        </trans-unit>
        <trans-unit id="26fb3de478c5cf1596d7cf8a88ab611eedc18b11" translate="yes" xml:space="preserve">
          <source>The direction of rounding when an integer is converted to a floating-point number that cannot exactly represent the original value (C90 6.2.1.3, C99 and C11 6.3.1.4).</source>
          <target state="translated">Направление округления,когда целое число преобразуется в число с плавающей точкой,которое не может точно представлять исходное значение (C90 6.2.1.3,C99 и C11 6.3.1.4).</target>
        </trans-unit>
        <trans-unit id="9c2a89eb8a493cddb0e17d65209367b348e4e331" translate="yes" xml:space="preserve">
          <source>The earliest version of MacOS X that this executable will run on is &lt;var&gt;version&lt;/var&gt;. Typical values of &lt;var&gt;version&lt;/var&gt; include &lt;code&gt;10.1&lt;/code&gt;, &lt;code&gt;10.2&lt;/code&gt;, and &lt;code&gt;10.3.9&lt;/code&gt;.</source>
          <target state="translated">Самая ранняя версия MacOS X, на которой будет работать этот исполняемый файл, - это &lt;var&gt;version&lt;/var&gt; . Типичные значения &lt;var&gt;version&lt;/var&gt; включают &lt;code&gt;10.1&lt;/code&gt; , &lt;code&gt;10.2&lt;/code&gt; и &lt;code&gt;10.3.9&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dc00d4d1ee11aa29f8972e4481c89ebd51afb01" translate="yes" xml:space="preserve">
          <source>The easiest way of satisfying these restrictions is to compile and link every module with the same</source>
          <target state="translated">Самый простой способ удовлетворить эти ограничения-скомпилировать и связать каждый модуль с одним и тем же</target>
        </trans-unit>
        <trans-unit id="ee24dbb06c4125c8c59c873450e471ac0298f125" translate="yes" xml:space="preserve">
          <source>The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a link with relocatable output (i.e. &lt;code&gt;ld -r&lt;/code&gt;) on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ce96812102dd380fc896f02591a99db980d416" translate="yes" xml:space="preserve">
          <source>The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a link with relocatable output (ie: &lt;code&gt;ld -r&lt;/code&gt;) on them.</source>
          <target state="translated">Эффект эквивалентен перемещению всех ссылок на псевдоним в отдельную единицу перевода, переименованию псевдонима в символ с псевдонимом, объявлению его слабым, компиляции двух отдельных единиц перевода и выполнению ссылки с перемещаемым выводом (например, &lt;code&gt;ld -r&lt;/code&gt; ) на них.</target>
        </trans-unit>
        <trans-unit id="2fcdd3faf7319592c843ba96ea56c638eff89d9c" translate="yes" xml:space="preserve">
          <source>The effect of this is that GCC may, effectively, mark inline methods with &lt;code&gt;__attribute__ ((visibility (&quot;hidden&quot;)))&lt;/code&gt; so that they do not appear in the export table of a DSO and do not require a PLT indirection when used within the DSO. Enabling this option can have a dramatic effect on load and link times of a DSO as it massively reduces the size of the dynamic export table when the library makes heavy use of templates.</source>
          <target state="translated">В результате GCC может помечать встроенные методы с помощью &lt;code&gt;__attribute__ ((visibility (&quot;hidden&quot;)))&lt;/code&gt; чтобы они не отображались в таблице экспорта DSO и не требовали косвенного обращения к PLT при использовании внутри DSO. Включение этой опции может существенно повлиять на время загрузки и связывания DSO, поскольку значительно уменьшает размер динамической таблицы экспорта, когда библиотека интенсивно использует шаблоны.</target>
        </trans-unit>
        <trans-unit id="0339dc59fd2ec7a99f69b1c58fc9500261d6af02" translate="yes" xml:space="preserve">
          <source>The effectiveness of some warnings depends on optimizations also being enabled. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80b8b3ee96e1537d805054b77f62723800f759b" translate="yes" xml:space="preserve">
          <source>The elements of the input vectors are numbered in memory ordering of &lt;var&gt;vec0&lt;/var&gt; beginning at 0 and &lt;var&gt;vec1&lt;/var&gt; beginning at &lt;var&gt;N&lt;/var&gt;. The elements of &lt;var&gt;mask&lt;/var&gt; are considered modulo &lt;var&gt;N&lt;/var&gt; in the single-operand case and modulo &lt;em&gt;2*&lt;var&gt;N&lt;/var&gt;&lt;/em&gt; in the two-operand case.</source>
          <target state="translated">Элементы входных векторов пронумерованы в заказе памяти &lt;var&gt;vec0&lt;/var&gt; начиная с 0 и &lt;var&gt;vec1&lt;/var&gt; начала в &lt;var&gt;N&lt;/var&gt; . Элементы &lt;var&gt;mask&lt;/var&gt; рассматриваются по модулю &lt;var&gt;N&lt;/var&gt; в случае с одним операндом и по модулю &lt;em&gt;2 * &lt;var&gt;N&lt;/var&gt; &lt;/em&gt; в случае с двумя операндами.</target>
        </trans-unit>
        <trans-unit id="03329c8955d8e056ec3aa9ef42249119fe358d03" translate="yes" xml:space="preserve">
          <source>The encoding of any of &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, and &lt;code&gt;char32_t&lt;/code&gt; where the corresponding standard encoding macro (&lt;code&gt;__STDC_ISO_10646__&lt;/code&gt;, &lt;code&gt;__STDC_UTF_16__&lt;/code&gt;, or &lt;code&gt;__STDC_UTF_32__&lt;/code&gt;) is not defined (C11 6.10.8.2).</source>
          <target state="translated">Кодировка любого из &lt;code&gt;wchar_t&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; и &lt;code&gt;char32_t&lt;/code&gt; , где соответствующий стандартный макрос кодирования ( &lt;code&gt;__STDC_ISO_10646__&lt;/code&gt; , &lt;code&gt;__STDC_UTF_16__&lt;/code&gt; или &lt;code&gt;__STDC_UTF_32__&lt;/code&gt; ) не определен (C11 6.10.8.2).</target>
        </trans-unit>
        <trans-unit id="f0c42b29af2e3bb28afd21f635c0f39721670e06" translate="yes" xml:space="preserve">
          <source>The encoding of bit-fields has changed to allow bit-fields to be properly handled by the runtime functions that compute sizes and alignments of types that contain bit-fields. The previous encoding contained only the size of the bit-field. Using only this information it is not possible to reliably compute the size occupied by the bit-field. This is very important in the presence of the Boehm&amp;rsquo;s garbage collector because the objects are allocated using the typed memory facility available in this collector. The typed memory allocation requires information about where the pointers are located inside the object.</source>
          <target state="translated">Кодирование битовых полей было изменено, чтобы позволить битовым полям правильно обрабатывать функции времени выполнения, которые вычисляют размеры и выравнивания типов, содержащих битовые поля. Предыдущая кодировка содержала только размер битового поля. Используя только эту информацию, невозможно надежно вычислить размер, занимаемый битовым полем. Это очень важно при наличии сборщика мусора Боэма, потому что объекты выделяются с использованием средства типизированной памяти, доступной в этом сборщике. Для типизированного выделения памяти требуется информация о том, где внутри объекта расположены указатели.</target>
        </trans-unit>
        <trans-unit id="32de7cb2a746befc3519adabd406682f138c91dc" translate="yes" xml:space="preserve">
          <source>The encoding of the branch hint instruction limits the hint to be within 256 instructions of the branch it is affecting. By default, GCC makes sure it is within 125.</source>
          <target state="translated">Кодирование инструкции подсказки ветви ограничивает подсказку 256 инструкциями той ветви,на которую она влияет.По умолчанию GCC гарантирует,что она находится в пределах 125.</target>
        </trans-unit>
        <trans-unit id="86931df671f82bbbca9166c366a69eb90410e2f2" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt;, if defined, non-empty and nonzero, implicitly enables</source>
          <target state="translated">Переменная среды &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; , если определена, непустая и ненулевая, неявно включает</target>
        </trans-unit>
        <trans-unit id="f1abddc031f4887620e779e03fa9bce246eca769" translate="yes" xml:space="preserve">
          <source>The error is only generated if the pragma is present in the code after pre-processing has been completed. It does not matter however if the code containing the pragma is unreachable:</source>
          <target state="translated">Ошибка генерируется только в том случае,если прагма присутствует в коде после завершения препроцессирования.Однако не имеет значения,доступен ли код,содержащий прагму:</target>
        </trans-unit>
        <trans-unit id="62217b180fda693fac806123c3cedff899bcd7c2" translate="yes" xml:space="preserve">
          <source>The evaluation methods characterized by non-standard negative values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; (C99 and C11 5.2.4.2.2).</source>
          <target state="translated">Методы оценки, характеризующиеся нестандартными отрицательными значениями &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; (C99 и C11 5.2.4.2.2).</target>
        </trans-unit>
        <trans-unit id="e7ca0d5b7ee5cf7cc21b906f53631f0432c41aa1" translate="yes" xml:space="preserve">
          <source>The example above is correctly written as:</source>
          <target state="translated">Пример выше правильно написан как:</target>
        </trans-unit>
        <trans-unit id="2262d7979d1e6f669d9d267628d7f1a5e043c047" translate="yes" xml:space="preserve">
          <source>The execution counts are cumulative. If the example program were executed again without removing the</source>
          <target state="translated">Количество исполнений является кумулятивным.Если пример программы был выполнен заново без удаления параметра</target>
        </trans-unit>
        <trans-unit id="30cd9cacada80b254b465216587c60514745e9e0" translate="yes" xml:space="preserve">
          <source>The exported header file declaring the function the user calls would contain:</source>
          <target state="translated">Экспортированный заголовочный файл с объявлением функции,которую будут содержать вызовы пользователя:</target>
        </trans-unit>
        <trans-unit id="6a3b0d1b517a2735ccea32622e6c16bbe062c918" translate="yes" xml:space="preserve">
          <source>The extended version of &lt;code&gt;__builtin_expect&lt;/code&gt; is not supported.</source>
          <target state="translated">Расширенная версия &lt;code&gt;__builtin_expect&lt;/code&gt; не поддерживается.</target>
        </trans-unit>
        <trans-unit id="e5f79933f130a6010408a53873b5c18d791196b0" translate="yes" xml:space="preserve">
          <source>The extended version of the ARMv7-A architecture with support for virtualization.</source>
          <target state="translated">Расширенная версия архитектуры ARMv7-A с поддержкой виртуализации.</target>
        </trans-unit>
        <trans-unit id="f69903151111d03e37009b513bcf8f14816a93e4" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the &lt;code&gt;register&lt;/code&gt; storage-class specifier are effective (C90 6.5.1, C99 and C11 6.7.1).</source>
          <target state="translated">Степень, в которой предложения, сделанные с использованием спецификатора класса хранения &lt;code&gt;register&lt;/code&gt; , эффективны (C90 6.5.1, C99 и C11 6.7.1).</target>
        </trans-unit>
        <trans-unit id="99d4acdb059ef7e8275eb6991f7b3fdb57cb4d7e" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the inline function specifier are effective (C99 and C11 6.7.4).</source>
          <target state="translated">Степень эффективности предложений,сделанных с использованием встроенного спецификатора функции (C99 и C11 6.7.4).</target>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">Файл</target>
        </trans-unit>
        <trans-unit id="be1544009a06e2ed9b8c04313febbe4a5054a34c" translate="yes" xml:space="preserve">
          <source>The filename and replacement string escape backslash as &amp;ldquo;\\&quot;, tab as &amp;ldquo;\t&amp;rdquo;, newline as &amp;ldquo;\n&amp;rdquo;, double quotes as &amp;ldquo;\&quot;&amp;rdquo;, non-printable characters as octal (e.g. vertical tab as &amp;ldquo;\013&amp;rdquo;).</source>
          <target state="translated">Имя файла и строка замены экранируются обратной косой чертой как &amp;laquo;\\&amp;raquo;, табуляция как &amp;laquo;\ t&amp;raquo;, новая строка как &amp;laquo;\ n&amp;raquo;, двойные кавычки как &amp;laquo;\&amp;raquo; &amp;raquo;, непечатаемые символы как восьмеричные (например, вертикальная табуляция как&amp;laquo; \ 013 &amp;raquo; ).</target>
        </trans-unit>
        <trans-unit id="052b9a9ce595b22df1664059ccb4ac71ceb3b652" translate="yes" xml:space="preserve">
          <source>The files used by gcov.</source>
          <target state="translated">Файлы,используемые gcov.</target>
        </trans-unit>
        <trans-unit id="5f9146bf44aa8a552083fbcdde4f12b382de6ccc" translate="yes" xml:space="preserve">
          <source>The first argument is the address of the start of the current function, which may be looked up exactly in the symbol table.</source>
          <target state="translated">Первый аргумент-адрес начала текущей функции,который может быть найден точно в таблице символов.</target>
        </trans-unit>
        <trans-unit id="d40b2392c804eafb9e2a38b040dcc6ad4b8a38cb" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register, the second argument, &lt;var&gt;val&lt;/var&gt;, is a compile time constant to be written to the register. Generates:</source>
          <target state="translated">Первый аргумент, &lt;var&gt;auxv&lt;/var&gt; , - это адрес вспомогательного регистра, второй аргумент, &lt;var&gt;val&lt;/var&gt; , - постоянная времени компиляции, которая должна быть записана в регистр. Формирует:</target>
        </trans-unit>
        <trans-unit id="1bb8468783d812fcfe3a90c5c3005fc31c3a8b43" translate="yes" xml:space="preserve">
          <source>The first built-in function allows arbitrary integral types for operands and the result type must be pointer to some integral type other than enumerated or boolean type, the rest of the built-in functions have explicit integer types.</source>
          <target state="translated">Первая встроенная функция допускает произвольные интегральные типы для операндов,а результирующий тип должен быть указателем на некоторый интегральный тип,отличный от перечисленного или булевого типа,остальные встроенные функции имеют явные целочисленные типы.</target>
        </trans-unit>
        <trans-unit id="766dbe1354f0d010e9b9752b025269447d8bacdc" translate="yes" xml:space="preserve">
          <source>The first number on each line is the &amp;ldquo;user time&amp;rdquo;, that is time spent executing the program itself. The second number is &amp;ldquo;system time&amp;rdquo;, time spent executing operating system routines on behalf of the program. Both numbers are in seconds.</source>
          <target state="translated">Первое число в каждой строке - это &amp;laquo;время пользователя&amp;raquo;, то есть время, потраченное на выполнение самой программы. Второе число - &amp;laquo;системное время&amp;raquo;, время, затраченное на выполнение подпрограмм операционной системы от имени программы. Оба числа указаны в секундах.</target>
        </trans-unit>
        <trans-unit id="7705a0a1f8fdbe72b6eed476ebaac5e4596393cb" translate="yes" xml:space="preserve">
          <source>The first operand is the number of a register to be written, the second operand is a compile time constant to write into that register. Generates:</source>
          <target state="translated">Первый операнд-номер записываемого регистра,второй операнд-константа времени компиляции для записи в этот регистр.Генерирует:</target>
        </trans-unit>
        <trans-unit id="5403326826a0ff4e3670389f165daf4e08127b0b" translate="yes" xml:space="preserve">
          <source>The first step in using these extensions is to provide the necessary data types. This should be done using an appropriate &lt;code&gt;typedef&lt;/code&gt;:</source>
          <target state="translated">Первым шагом в использовании этих расширений является предоставление необходимых типов данных. Это должно быть сделано с использованием соответствующего &lt;code&gt;typedef&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0180fb5f9566434bbaf5187f78b901ca8a7ed3d8" translate="yes" xml:space="preserve">
          <source>The first two invocations to GCC save a bytecode representation of GIMPLE into special ELF sections inside</source>
          <target state="translated">Первые две ссылки на GCC сохраняют байткодовое представление GIMPLE в специальных секциях ELF внутри</target>
        </trans-unit>
        <trans-unit id="d7463018cc3efdf04fea2a1a9520f2dcaa8a917d" translate="yes" xml:space="preserve">
          <source>The fixed-point types are &lt;code&gt;short _Fract&lt;/code&gt;, &lt;code&gt;_Fract&lt;/code&gt;, &lt;code&gt;long _Fract&lt;/code&gt;, &lt;code&gt;long long _Fract&lt;/code&gt;, &lt;code&gt;unsigned short _Fract&lt;/code&gt;, &lt;code&gt;unsigned _Fract&lt;/code&gt;, &lt;code&gt;unsigned long _Fract&lt;/code&gt;, &lt;code&gt;unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat short _Fract&lt;/code&gt;, &lt;code&gt;_Sat _Fract&lt;/code&gt;, &lt;code&gt;_Sat long _Fract&lt;/code&gt;, &lt;code&gt;_Sat long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;short _Accum&lt;/code&gt;, &lt;code&gt;_Accum&lt;/code&gt;, &lt;code&gt;long _Accum&lt;/code&gt;, &lt;code&gt;long long _Accum&lt;/code&gt;, &lt;code&gt;unsigned short _Accum&lt;/code&gt;, &lt;code&gt;unsigned _Accum&lt;/code&gt;, &lt;code&gt;unsigned long _Accum&lt;/code&gt;, &lt;code&gt;unsigned long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat short _Accum&lt;/code&gt;, &lt;code&gt;_Sat _Accum&lt;/code&gt;, &lt;code&gt;_Sat long _Accum&lt;/code&gt;, &lt;code&gt;_Sat long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Accum&lt;/code&gt;.</source>
          <target state="translated">Типы с фиксированной точкой: &lt;code&gt;short _Fract&lt;/code&gt; , &lt;code&gt;_Fract&lt;/code&gt; , &lt;code&gt;long _Fract&lt;/code&gt; , &lt;code&gt;long long _Fract&lt;/code&gt; , &lt;code&gt;unsigned short _Fract&lt;/code&gt; , &lt;code&gt;unsigned _Fract&lt;/code&gt; , &lt;code&gt;unsigned long _Fract&lt;/code&gt; , &lt;code&gt;unsigned long long _Fract&lt;/code&gt; , &lt;code&gt;_Sat short _Fract&lt;/code&gt; , &lt;code&gt;_Sat _Fract&lt;/code&gt; , &lt;code&gt;_Sat long _Fract&lt;/code&gt; , &lt;code&gt;_Sat long long _Fract&lt;/code&gt; , &lt;code&gt;_Sat unsigned short _Fract&lt;/code&gt; , &lt;code&gt;_Sat unsigned _Fract&lt;/code&gt; , &lt;code&gt;_Sat unsigned long _Fract&lt;/code&gt; , &lt;code&gt;_Sat unsigned long long _Fract&lt;/code&gt; , &lt;code&gt;short _Accum&lt;/code&gt; , &lt;code&gt;_Accum&lt;/code&gt; , &lt;code&gt;long _Accum&lt;/code&gt; , &lt;code&gt;long long _Accum&lt;/code&gt; , &lt;code&gt;unsigned short _Accum&lt;/code&gt; , &lt;code&gt;unsigned _Accum&lt;/code&gt; , &lt;code&gt;unsigned long _Accum&lt;/code&gt; , &lt;code&gt;unsigned long long _Accum&lt;/code&gt; , &lt;code&gt;_Sat short _Accum&lt;/code&gt; , &lt;code&gt;_Sat _Accum&lt;/code&gt; , &lt;code&gt;_Sat long _Accum&lt;/code&gt; , &lt;code&gt;_Sat long long _Accum&lt;/code&gt; , &lt;code&gt;_Sat unsigned short _Accum&lt;/code&gt; , &lt;code&gt;_Sat unsigned _Accum&lt;/code&gt; , &lt;code&gt;_Sat unsigned long _Accum&lt;/code&gt; , &lt;code&gt;_Sat unsigned long long _Accum&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3caefb409c9894c159fb9e3de06457a892f7b065" translate="yes" xml:space="preserve">
          <source>The flag makes these changes to GCC&amp;rsquo;s linkage model:</source>
          <target state="translated">Флаг вносит следующие изменения в модель связывания GCC:</target>
        </trans-unit>
        <trans-unit id="e89357c25217d9e6ea0399e085ee6ac916e2228f" translate="yes" xml:space="preserve">
          <source>The flag output constraints are not supported in thumb1 mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398abcfd0bda984ca55650d923231a3e23d99caf" translate="yes" xml:space="preserve">
          <source>The flag output constraints for the ARM family are of the form &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467579e58b2ed3f9e1f5da092ecc00a08220e553" translate="yes" xml:space="preserve">
          <source>The flag output constraints for the x86 family are of the form &amp;lsquo;</source>
          <target state="translated">Ограничения вывода флагов для семейства x86 имеют форму '</target>
        </trans-unit>
        <trans-unit id="08b70c97084691cff3ef37f7ca63544f38157171" translate="yes" xml:space="preserve">
          <source>The flags register.</source>
          <target state="translated">Флаги зарегистрированы.</target>
        </trans-unit>
        <trans-unit id="bdec47de335eba5411aba4ed82b1290026a8b9df" translate="yes" xml:space="preserve">
          <source>The floating-point constant 0.0</source>
          <target state="translated">Константа с плавающей точкой 0.0</target>
        </trans-unit>
        <trans-unit id="ec2c9b05e5630a06e86a36a4fbe950b6561191c6" translate="yes" xml:space="preserve">
          <source>The following</source>
          <target state="translated">Нижеперечисленные</target>
        </trans-unit>
        <trans-unit id="3c5af523cdaaa4e1970de9cf32fc6b6194b0929d" translate="yes" xml:space="preserve">
          <source>The following CPU names can be detected:</source>
          <target state="translated">Можно обнаружить следующие имена процессоров:</target>
        </trans-unit>
        <trans-unit id="5f10647ac5c4280bde68061d0442176ac21bf7e2" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 (</source>
          <target state="translated">Следующие дополнительные встроенные функции также доступны для процессоров семейства PowerPC,начиная с ISA 3.0 (</target>
        </trans-unit>
        <trans-unit id="1929bf7289a9ecdc2dad5969b2604877133b0494" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later:</source>
          <target state="translated">Следующие дополнительные встроенные функции также доступны для процессоров семейства PowerPC,начиная с ISA 3.0 или более поздней версии:</target>
        </trans-unit>
        <trans-unit id="8b6e450e5b4547d8cc58a1ea785d39c551b41c7f" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 14882:1998 (aka C++98) that document the exact semantics of the language extension.</source>
          <target state="translated">Ниже приводится набор изменений в ISO/IEC 14882:1998 (также известный как C++98),документирующих точную семантику расширения языка.</target>
        </trans-unit>
        <trans-unit id="973ba60cc5ca780083859b39f3e2346700d51250" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 9899:1999 (aka C99) that document the exact semantics of the language extension.</source>
          <target state="translated">Ниже приводится набор изменений в ISO/IEC 9899:1999 (он же С99),которые документируют точную семантику расширения языка.</target>
        </trans-unit>
        <trans-unit id="ebfbe098b1dd5eca0cbfbb3ca87cce639c317631" translate="yes" xml:space="preserve">
          <source>The following attributes are available on Microsoft Windows and Symbian OS targets.</source>
          <target state="translated">Следующие атрибуты доступны для целей Microsoft Windows и Symbian OS.</target>
        </trans-unit>
        <trans-unit id="75d2d7b6e92a2c518243634b77f2438ea7a789b2" translate="yes" xml:space="preserve">
          <source>The following attributes are supported on most targets.</source>
          <target state="translated">Следующие атрибуты поддерживаются для большинства целей.</target>
        </trans-unit>
        <trans-unit id="f3abf3f6e4762f0945d50d1dadcf30c08d9bb36f" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions require</source>
          <target state="translated">Следующие основные встроенные функции требуют</target>
        </trans-unit>
        <trans-unit id="e3618b6444ab4403d286bb790c65250955a9b750" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions, which are also supported on x86 targets, require</source>
          <target state="translated">Следующие основные встроенные функции,которые также поддерживаются на x86-мишенях,требуют</target>
        </trans-unit>
        <trans-unit id="369096374260c4b128f072244e93419c1bf1630f" translate="yes" xml:space="preserve">
          <source>The following built-in function is always available.</source>
          <target state="translated">Следующая встроенная функция всегда доступна.</target>
        </trans-unit>
        <trans-unit id="d0dad43e81aa335fef875c6f114a13ef9920a9d7" translate="yes" xml:space="preserve">
          <source>The following built-in function is available when</source>
          <target state="translated">Следующая встроенная функция доступна,когда</target>
        </trans-unit>
        <trans-unit id="04398186d020848766aea5fdd0b1552e99124d98" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow checking if simple arithmetic operation would overflow.</source>
          <target state="translated">Следующие встроенные функции позволяют проверить,не переполнится ли простая арифметическая операция.</target>
        </trans-unit>
        <trans-unit id="3c890e563c5fad880f7759533a175fe222845037" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow performing simple arithmetic operations together with checking whether the operations overflowed.</source>
          <target state="translated">Следующие встроенные функции позволяют выполнять простые арифметические операции,а также проверять,не переполнились ли операции.</target>
        </trans-unit>
        <trans-unit id="036eb93cb5a048428c65535ab685e9ef099b6ed1" translate="yes" xml:space="preserve">
          <source>The following built-in functions approximately match the requirements for the C++11 memory model. They are all identified by being prefixed with &amp;lsquo;</source>
          <target state="translated">Следующие встроенные функции приблизительно соответствуют требованиям для модели памяти C ++ 11. Все они обозначаются префиксом '</target>
        </trans-unit>
        <trans-unit id="bdf24977f571452f19f365486502e966dab5d0e9" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">Следующие встроенные функции также доступны для процессоров семейства PowerPC,начиная с ISA 3.0 или более поздней версии (</target>
        </trans-unit>
        <trans-unit id="3d2195469599cbd3dc33d7718d1e125824d6001b" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available on all PowerPC processors:</source>
          <target state="translated">Следующие встроенные функции также доступны на всех процессорах PowerPC:</target>
        </trans-unit>
        <trans-unit id="813e5a763e7aaceeb023e2843416ac3c7a436f0e" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available and can be used to check the target platform type.</source>
          <target state="translated">Следующие встроенные функции всегда доступны и могут быть использованы для проверки типа целевой платформы.</target>
        </trans-unit>
        <trans-unit id="a3a8ba0cceaa78de81b273be464b1e1bbe129653" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available.</source>
          <target state="translated">Всегда доступны следующие встроенные функции.</target>
        </trans-unit>
        <trans-unit id="ecfceed60efae2019076e7ea0c389384453f2603" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate a Nios II Custom Instruction. The name of the function represents the types that the function takes and returns. The letter before the &lt;code&gt;n&lt;/code&gt; is the return type or void if absent. The &lt;code&gt;n&lt;/code&gt; represents the first parameter to all the custom instructions, the custom instruction number. The two letters after the &lt;code&gt;n&lt;/code&gt; represent the up to two parameters to the function.</source>
          <target state="translated">Всегда доступны следующие встроенные функции. Все они генерируют пользовательскую инструкцию Nios II. Имя функции представляет типы, которые функция принимает и возвращает. Буква перед &lt;code&gt;n&lt;/code&gt; является возвращаемым типом или недействительна, если отсутствует. &lt;code&gt;n&lt;/code&gt; представляет первый параметр для всех пользовательских инструкций, количества пользовательских команд. Две буквы после &lt;code&gt;n&lt;/code&gt; обозначают до двух параметров функции.</target>
        </trans-unit>
        <trans-unit id="1af31ca0a6a69044f40261c9e3766a7bcb45f606" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate the machine instruction that is part of the name.</source>
          <target state="translated">Всегда доступны следующие встроенные функции.Все они генерируют команду машины,которая является частью названия.</target>
        </trans-unit>
        <trans-unit id="f2ff9df600bfad81ae439ad951e20e63358dbf59" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always with</source>
          <target state="translated">Следующие встроенные функции всегда с</target>
        </trans-unit>
        <trans-unit id="458872e50bacb1837e94edbee1f56e422633f9ac" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available for eBPF targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04c80c36791193b7507cbe8aa1b633c63c489df" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">Следующие встроенные функции доступны для процессоров семейства PowerPC,начиная с ISA 3.0 или более поздней версии (</target>
        </trans-unit>
        <trans-unit id="f55e084e6b2bbe2c1d4a74d78f9b5a79a08af791" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on Linux 64-bit systems that use the ISA 3.0 instruction set (</source>
          <target state="translated">На 64-битных системах Linux,использующих набор инструкций ISA 3.0,доступны следующие встроенные функции (</target>
        </trans-unit>
        <trans-unit id="60ee9c1229ed14f7445701a16ac0e8900c850fff" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on systems that use the OSF/1 PALcode. Normally they invoke the &lt;code&gt;rduniq&lt;/code&gt; and &lt;code&gt;wruniq&lt;/code&gt; PAL calls, but when invoked with</source>
          <target state="translated">Следующие встроенные функции доступны в системах, использующих код OSF / 1 PAL. Обычно они вызывают &lt;code&gt;rduniq&lt;/code&gt; и &lt;code&gt;wruniq&lt;/code&gt; PAL, но когда вызываются с</target>
        </trans-unit>
        <trans-unit id="b74dd20c718ebc6e02b444b4df3b1293b7b777b2" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when</source>
          <target state="translated">Следующие встроенные функции доступны,когда</target>
        </trans-unit>
        <trans-unit id="776fae37ac2c3903c04468f14c58000c2d1da4aa" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when hardware decimal floating point (</source>
          <target state="translated">Следующие встроенные функции доступны при аппаратных десятичных вычислениях с плавающей запятой (</target>
        </trans-unit>
        <trans-unit id="8714301d00c50c02cc49a9653de9815ca07de516" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.1 instructions when</source>
          <target state="translated">Следующие встроенные функции изменяются для генерации новых инструкций SSE4.1,когда</target>
        </trans-unit>
        <trans-unit id="b44b1444a99a16bc850f8161bf3acb0269e3baa5" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.2 instructions when</source>
          <target state="translated">Следующие встроенные функции изменяются для генерации новых инструкций SSE4.2,когда</target>
        </trans-unit>
        <trans-unit id="eabb92d44c62afaf48fdd22b40e596e4fd090919" translate="yes" xml:space="preserve">
          <source>The following built-in functions are intended to be compatible with those described in the Intel Itanium Processor-specific Application Binary Interface, section 7.4. As such, they depart from normal GCC practice by not using the &amp;lsquo;</source>
          <target state="translated">Следующие встроенные функции предназначены для совместимости с функциями, описанными в двоичном интерфейсе приложения для процессора Intel Itanium, раздел 7.4. Таким образом, они отклоняются от обычной практики GCC, не используя '</target>
        </trans-unit>
        <trans-unit id="831ee0ed207b248768e0caf3e133139a3eef8c8d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available by</source>
          <target state="translated">Следующие встроенные функции доступны посредством</target>
        </trans-unit>
        <trans-unit id="919b7b433192dee8b53ccb79ce4649060e122b82" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available either with</source>
          <target state="translated">Следующие встроенные функции доступны либо с</target>
        </trans-unit>
        <trans-unit id="6ccb74ff52e53e43a5c01fd32034e69dc2ae153d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are provided for ARC targets. The built-ins generate the corresponding assembly instructions. In the examples given below, the generated code often requires an operand or result to be in a register. Where necessary further code will be generated to ensure this is true, but for brevity this is not described in each case.</source>
          <target state="translated">Для целей ARC предусмотрены следующие встроенные функции.Встроенные функции генерируют соответствующие инструкции по сборке.В приведенных ниже примерах сгенерированный код часто требует,чтобы операнд или результат находились в регистре.При необходимости будет сгенерирован дополнительный код,чтобы убедиться,что это правда,но для краткости это не описывается в каждом случае.</target>
        </trans-unit>
        <trans-unit id="75e740a11dbfb99edbd20d26c1a8e83fccd42794" translate="yes" xml:space="preserve">
          <source>The following built-in functions are supported on the SH1, SH2, SH3 and SH4 families of processors:</source>
          <target state="translated">На процессорах семейства SH1,SH2,SH3 и SH4 поддерживаются следующие встроенные функции:</target>
        </trans-unit>
        <trans-unit id="f89feba67398daada2fcc2ab442cabeeabf1732a" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP REV 2 instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">Следующие встроенные функции сопоставляются непосредственно с конкретной инструкцией MIPS DSP REV 2.Пожалуйста,ознакомьтесь со спецификацией архитектуры для получения подробной информации о том,что делает каждая инструкция.</target>
        </trans-unit>
        <trans-unit id="f21bc507e92bf45d2cc2ac3a1f9c044c10482e71" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">Следующие встроенные функции сопоставляются непосредственно с конкретной MIPS DSP инструкцией.Пожалуйста,обратитесь к спецификации архитектуры для получения подробной информации о том,что делает каждая инструкция.</target>
        </trans-unit>
        <trans-unit id="b9487d4f044e41716b6891b45e9753c6c90cda37" translate="yes" xml:space="preserve">
          <source>The following built-in spec functions are provided:</source>
          <target state="translated">Предоставляются следующие встроенные спецификации:</target>
        </trans-unit>
        <trans-unit id="2786d4ea3cbfa4ab2030f517cdaa8499a49060e7" translate="yes" xml:space="preserve">
          <source>The following built-in vector functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">Для процессоров семейства PowerPC,начиная с ISA 3.0 или более поздней версии,доступны следующие встроенные векторные функции (</target>
        </trans-unit>
        <trans-unit id="1a38882cce5b0e920f7bd6e773e987b24fc62b96" translate="yes" xml:space="preserve">
          <source>The following choices of &lt;var&gt;name&lt;/var&gt; are available on AArch64 targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd16ee07975a361776687491f1d62adb24d9f69" translate="yes" xml:space="preserve">
          <source>The following code initializes a variable &lt;code&gt;pfoo&lt;/code&gt; located in static storage with a 24-bit address:</source>
          <target state="translated">Следующий код инициализирует переменную &lt;code&gt;pfoo&lt;/code&gt; , расположенную в статическом хранилище, с 24-битным адресом:</target>
        </trans-unit>
        <trans-unit id="8780ef62a5e7e11e92254999b8a74301b194fac1" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a case where you need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier. It uses the x86 &lt;code&gt;rdtsc&lt;/code&gt; instruction, which reads the computer&amp;rsquo;s time-stamp counter. Without the &lt;code&gt;volatile&lt;/code&gt; qualifier, the optimizers might assume that the &lt;code&gt;asm&lt;/code&gt; block will always return the same value and therefore optimize away the second call.</source>
          <target state="translated">В следующем примере демонстрируется случай, когда вам нужно использовать квалификатор &lt;code&gt;volatile&lt;/code&gt; . Он использует инструкцию x86 &lt;code&gt;rdtsc&lt;/code&gt; , которая считывает счетчик меток времени компьютера. Без квалификатора &lt;code&gt;volatile&lt;/code&gt; оптимизаторы могут предположить, что блок &lt;code&gt;asm&lt;/code&gt; всегда будет возвращать одно и то же значение, и поэтому оптимизирует второй вызов.</target>
        </trans-unit>
        <trans-unit id="4b55ceed13d64aeb896ca2cdaff9ea36b6ca968e" translate="yes" xml:space="preserve">
          <source>The following example shows an &lt;code&gt;asm goto&lt;/code&gt; that uses a memory clobber.</source>
          <target state="translated">В следующем примере показан &lt;code&gt;asm goto&lt;/code&gt; , который использует затирание памяти.</target>
        </trans-unit>
        <trans-unit id="1ff7cf2e98d1cdb33c85dfebf8c45ca797099418" translate="yes" xml:space="preserve">
          <source>The following examples are all valid uses of these attributes on Epiphany targets:</source>
          <target state="translated">Следующие примеры-все обоснованное использование этих атрибутов на Богоявленских мишенях:</target>
        </trans-unit>
        <trans-unit id="133fac7dc52d4be5d02e2ee9f610bd07e27fcb98" translate="yes" xml:space="preserve">
          <source>The following extension options are common to the listed CPUs:</source>
          <target state="translated">Следующие опции расширения являются общими для перечисленных ЦПУ:</target>
        </trans-unit>
        <trans-unit id="585cd94a6c81e37ef942855a4e92760bf2aec5f9" translate="yes" xml:space="preserve">
          <source>The following features can be detected:</source>
          <target state="translated">Могут быть обнаружены следующие функции:</target>
        </trans-unit>
        <trans-unit id="4cbf90dbd434ca4f2150e22b1aa4b1a78b14c334" translate="yes" xml:space="preserve">
          <source>The following floating-point built-in functions are always available. All of them implement the function that is part of the name.</source>
          <target state="translated">Всегда доступны следующие встроенные функции с плавающей запятой.Все они реализуют функцию,которая является частью названия.</target>
        </trans-unit>
        <trans-unit id="e1be7f4828f104915bab6627d884213aaa11c9fc" translate="yes" xml:space="preserve">
          <source>The following functions require</source>
          <target state="translated">Для выполнения следующих функций необходимо</target>
        </trans-unit>
        <trans-unit id="31dedf0887f3cce8587f9fc85d3da325ab3058ce" translate="yes" xml:space="preserve">
          <source>The following functions require option</source>
          <target state="translated">Следующие функции требуют дополнительной опции</target>
        </trans-unit>
        <trans-unit id="f640e02367945c84624ea0fa79ae818fc5491bf9" translate="yes" xml:space="preserve">
          <source>The following high level HTM interface is made available by including &lt;code&gt;&amp;lt;htmxlintrin.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">Следующий высокоуровневый интерфейс HTM доступен при включении &lt;code&gt;&amp;lt;htmxlintrin.h&amp;gt;&lt;/code&gt; и использовании</target>
        </trans-unit>
        <trans-unit id="102c1a366ea24351d92a6971e3810fc18f2df2f4" translate="yes" xml:space="preserve">
          <source>The following i386 example uses the &lt;var&gt;asmSymbolicName&lt;/var&gt; syntax. It produces the same result as the code above, but some may consider it more readable or more maintainable since reordering index numbers is not necessary when adding or removing operands. The names &lt;code&gt;aIndex&lt;/code&gt; and &lt;code&gt;aMask&lt;/code&gt; are only used in this example to emphasize which names get used where. It is acceptable to reuse the names &lt;code&gt;Index&lt;/code&gt; and &lt;code&gt;Mask&lt;/code&gt;.</source>
          <target state="translated">В следующем примере i386 используется синтаксис &lt;var&gt;asmSymbolicName&lt;/var&gt; . Он дает тот же результат, что и приведенный выше код, но некоторые могут посчитать его более читаемым или более удобным в обслуживании, поскольку переупорядочивание номеров индексов не требуется при добавлении или удалении операндов. Имена &lt;code&gt;aIndex&lt;/code&gt; и &lt;code&gt;aMask&lt;/code&gt; используются в этом примере только для того, чтобы подчеркнуть, какие имена и где используются. Допускается повторное использование имен &lt;code&gt;Index&lt;/code&gt; и &lt;code&gt;Mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6e6249e0b2946138511bcb4a6acddccaf21d75a" translate="yes" xml:space="preserve">
          <source>The following interfaces are supported for the generic and specific AltiVec operations and the AltiVec predicates. In cases where there is a direct mapping between generic and specific operations, only the generic names are shown here, although the specific operations can also be used.</source>
          <target state="translated">Следующие интерфейсы поддерживаются для общих и специфических операций AltiVec и предикатов AltiVec.В случаях,когда существует прямое сопоставление между общими и специфическими операциями,здесь показываются только общие имена,хотя специфические операции также могут быть использованы.</target>
        </trans-unit>
        <trans-unit id="641482ab6aae43e810063e867385af29b325d058" translate="yes" xml:space="preserve">
          <source>The following is a complete list of all the SIMD built-ins provided for ARC, grouped by calling signature.</source>
          <target state="translated">Ниже приведен полный список всех SIMD-встроенных модулей,предоставленных для ARC,сгруппированных по позывным подписям.</target>
        </trans-unit>
        <trans-unit id="59aaf754b53dd8275d60f36863885f1f7f538958" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved for concepts.</source>
          <target state="translated">Следующие ключевые слова зарезервированы для понятий.</target>
        </trans-unit>
        <trans-unit id="1ea9055e3c282c50c68c6d2aeac0047e44355ae3" translate="yes" xml:space="preserve">
          <source>The following language-independent options do not enable specific warnings but control the kinds of diagnostics produced by GCC.</source>
          <target state="translated">Следующие опции,не зависящие от языка,не допускают конкретных предупреждений,но контролируют виды диагностики,производимой GCC.</target>
        </trans-unit>
        <trans-unit id="d9f20c0f07be1621f3a5ece2a524e2a15cb445a2" translate="yes" xml:space="preserve">
          <source>The following low level built-in functions are available with</source>
          <target state="translated">Следующие низкоуровневые встроенные функции доступны с</target>
        </trans-unit>
        <trans-unit id="b73379da25dc8349b928d96eecb55babb0495892" translate="yes" xml:space="preserve">
          <source>The following machine modes are available for use with MMX built-in functions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;): &lt;code&gt;V2SI&lt;/code&gt; for a vector of two 32-bit integers, &lt;code&gt;V4HI&lt;/code&gt; for a vector of four 16-bit integers, and &lt;code&gt;V8QI&lt;/code&gt; for a vector of eight 8-bit integers. Some of the built-in functions operate on MMX registers as a whole 64-bit entity, these use &lt;code&gt;V1DI&lt;/code&gt; as their mode.</source>
          <target state="translated">Следующие машинные режимы доступны для использования со встроенными функциями MMX (см. &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Векторные расширения&lt;/a&gt; ): &lt;code&gt;V2SI&lt;/code&gt; для вектора из двух 32-битных целых чисел, &lt;code&gt;V4HI&lt;/code&gt; для вектора из четырех 16-битных целых чисел и &lt;code&gt;V8QI&lt;/code&gt; для вектора из восьми 8 -битовые целые числа. Некоторые из встроенных функций работают с регистрами MMX как с целым 64-битным объектом, они используют &lt;code&gt;V1DI&lt;/code&gt; в качестве своего режима.</target>
        </trans-unit>
        <trans-unit id="7cf3a8e89705f68be72e746786d162672425cfef" translate="yes" xml:space="preserve">
          <source>The following multi-instruction functions are also available. In each case, &lt;var&gt;cond&lt;/var&gt; can be any of the 16 floating-point conditions: &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;un&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ueq&lt;/code&gt;, &lt;code&gt;olt&lt;/code&gt;, &lt;code&gt;ult&lt;/code&gt;, &lt;code&gt;ole&lt;/code&gt;, &lt;code&gt;ule&lt;/code&gt;, &lt;code&gt;sf&lt;/code&gt;, &lt;code&gt;ngle&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ngl&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;nge&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt; or &lt;code&gt;ngt&lt;/code&gt;.</source>
          <target state="translated">Также доступны следующие функции с несколькими инструкциями. В каждом случае &lt;var&gt;cond&lt;/var&gt; может быть любым из 16 условий с плавающей запятой: &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;un&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ueq&lt;/code&gt; , &lt;code&gt;olt&lt;/code&gt; , &lt;code&gt;ult&lt;/code&gt; , &lt;code&gt;ole&lt;/code&gt; , &lt;code&gt;ule&lt;/code&gt; , &lt;code&gt;sf&lt;/code&gt; , &lt;code&gt;ngle&lt;/code&gt; , &lt;code&gt;seq&lt;/code&gt; , &lt;code&gt;ngl&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;nge&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; или &lt;code&gt;ngt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d0ee4cac44eb1ea6ef3d346a27ca60807cc0101" translate="yes" xml:space="preserve">
          <source>The following option controls the dump verbosity:</source>
          <target state="translated">Следующая опция управляет многословием свалки:</target>
        </trans-unit>
        <trans-unit id="abb8267f4643a3a1e1226701a4af5aa70991f141" translate="yes" xml:space="preserve">
          <source>The following options are enabled:</source>
          <target state="translated">Включены следующие опции:</target>
        </trans-unit>
        <trans-unit id="81ad9c293f6f20ff40e11231422dcfe5f5c7994f" translate="yes" xml:space="preserve">
          <source>The following options are maintained for backward compatibility, but are now deprecated and will be removed in a future release:</source>
          <target state="translated">Следующие опции поддерживаются для обратной совместимости,но в настоящее время устарели и будут удалены в одном из будущих релизов:</target>
        </trans-unit>
        <trans-unit id="830e32827e2b8144f32b52b0121c8d7081e1b6a0" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the assembler, and also define preprocessor macro symbols.</source>
          <target state="translated">Следующие опции передаются ассемблеру,а также определяют макросимволы препроцессора.</target>
        </trans-unit>
        <trans-unit id="3893bff29544ccfaa517cc2326f9ca49c8a38aa9" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the linker:</source>
          <target state="translated">В линкер передаются следующие опции:</target>
        </trans-unit>
        <trans-unit id="3c36d7938f4b3037d603daaacf0e18dc02039404" translate="yes" xml:space="preserve">
          <source>The following options control compiler behavior regarding floating-point arithmetic. These options trade off between speed and correctness. All must be specifically enabled.</source>
          <target state="translated">Следующие опции управляют поведением компилятора относительно арифметики с плавающей точкой.Эти опции торгуют между скоростью и корректностью.Все они должны быть специально включены.</target>
        </trans-unit>
        <trans-unit id="86976c9ace4c113da10573eddefe715e4cb2f672" translate="yes" xml:space="preserve">
          <source>The following options control how the assembly code is annotated:</source>
          <target state="translated">Следующие опции управляют аннотацией ассемблерного кода:</target>
        </trans-unit>
        <trans-unit id="14f279a10a5e010786a9e225f2aacc08d5d8248b" translate="yes" xml:space="preserve">
          <source>The following options control optimizations that may improve performance, but are not enabled by any</source>
          <target state="translated">Следующие опции управляют оптимизациями,которые могут улучшить производительность,но не включены никакими из них</target>
        </trans-unit>
        <trans-unit id="55fd5087fff35ad2ed3317068955b447140094de" translate="yes" xml:space="preserve">
          <source>The following options control specific optimizations. They are either activated by</source>
          <target state="translated">Следующие опции управляют конкретными оптимизациями.Они либо активируются</target>
        </trans-unit>
        <trans-unit id="97f1dd31a84415d7a8f21c8572a9ef06924b80bb" translate="yes" xml:space="preserve">
          <source>The following options control the analyzer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75b9b815cb70c1acb6a0a4fa3f69dee634495bb" translate="yes" xml:space="preserve">
          <source>The following options control the architecture variant for which code is being compiled:</source>
          <target state="translated">Следующие опции управляют вариантом архитектуры,для которой компилируется код:</target>
        </trans-unit>
        <trans-unit id="99d7d28f2f9b185e45e491d2e2f8457796b4ee30" translate="yes" xml:space="preserve">
          <source>The following options control the dialect of C (or languages derived from C, such as C++, Objective-C and Objective-C++) that the compiler accepts:</source>
          <target state="translated">Следующие опции управляют диалектом C (или языками,производными от C,такими как C++,Objective-C и Objective-C++),который принимает компилятор:</target>
        </trans-unit>
        <trans-unit id="813aeaa760a029b92e3d877fed33fc8e7a96dc7f" translate="yes" xml:space="preserve">
          <source>The following options control the semantics of generated code:</source>
          <target state="translated">Следующие опции управляют семантикой генерируемого кода:</target>
        </trans-unit>
        <trans-unit id="d3598ddb012ba205521fc6ee02e575b5bc46a933" translate="yes" xml:space="preserve">
          <source>The following options control which kinds of messages should be emitted:</source>
          <target state="translated">Следующие опции управляют тем,какие типы сообщений должны излучаться:</target>
        </trans-unit>
        <trans-unit id="4d212367144c7ffb5256031004f3dbec4705f316" translate="yes" xml:space="preserve">
          <source>The following options fine tune code generation:</source>
          <target state="translated">Следующие опции тонкой настройки генерации кода:</target>
        </trans-unit>
        <trans-unit id="e686313bb7d2bb5ed9fc2b2f596d5d6ba9508b34" translate="yes" xml:space="preserve">
          <source>The following paired-single functions map directly to a particular MIPS instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">Следующие парные функции сопоставляются непосредственно с конкретной MIPS-инструкцией.Пожалуйста,ознакомьтесь со спецификацией архитектуры для получения подробной информации о том,что делает каждая инструкция.</target>
        </trans-unit>
        <trans-unit id="d31f26e42333950d2b2ffa071557eac8358219f6" translate="yes" xml:space="preserve">
          <source>The following pragmas are available for all architectures running the Darwin operating system. These are useful for compatibility with other Mac OS compilers.</source>
          <target state="translated">Следующие прагмы доступны для всех архитектур под управлением операционной системы Darwin.Они полезны для совместимости с другими компиляторами Mac OS.</target>
        </trans-unit>
        <trans-unit id="5efd4f1d1fe7f21c34100607d9ffdb85cb1ed570" translate="yes" xml:space="preserve">
          <source>The following set of built-in functions are available to gain access to the HTM specific special purpose registers.</source>
          <target state="translated">Следующий набор встроенных функций доступен для получения доступа к специальным регистрам назначения HTM.</target>
        </trans-unit>
        <trans-unit id="fe37409b5b6fb37c45d0db10dbe34cd37d4dfd29" translate="yes" xml:space="preserve">
          <source>The following statements are identical:</source>
          <target state="translated">Следующие утверждения идентичны:</target>
        </trans-unit>
        <trans-unit id="4c95f76a6048996b1dcedbb4002de26c05b62460" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and three &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile-time constant, identifying the 16-bit sub-register to be stored, the third argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the fourth argument must be an 8-bit compile time constant.</source>
          <target state="translated">Следующее принимает аргумент &lt;code&gt;__v8hi&lt;/code&gt; и три аргумента &lt;code&gt;int&lt;/code&gt; и не возвращает результата. Второй аргумент должен быть 3-битной константой времени компиляции, идентифицирующей 16-битный подрегистр, который будет сохранен, третий аргумент должен быть 3-битной константой времени компиляции, указывающей на регистры I0-I7, а четвертый аргумент должен быть 8-битной постоянной времени компиляции.</target>
        </trans-unit>
        <trans-unit id="5da4f813451b70864b4ac68a9c6bb25ff058833e" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="translated">Следующее принимает аргумент &lt;code&gt;__v8hi&lt;/code&gt; и два аргумента &lt;code&gt;int&lt;/code&gt; и возвращает результат &lt;code&gt;__v8hi&lt;/code&gt; . Второй аргумент должен быть 3-битной константой времени компиляции, указывающей на регистры I0-I7, а третий аргумент должен быть 8-битной константой времени компиляции.</target>
        </trans-unit>
        <trans-unit id="559f51894eceb199907d056ff4f4a6285c76d1d1" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="translated">Следующее принимает аргумент &lt;code&gt;__v8hi&lt;/code&gt; и два аргумента &lt;code&gt;int&lt;/code&gt; и не возвращает результата. Второй аргумент должен быть 3-битной константой времени компиляции, указывающей на регистры I0-I7, а третий аргумент должен быть 8-битной константой времени компиляции.</target>
        </trans-unit>
        <trans-unit id="19babaec618194855f5c8b00e66e42a23a7c9b80" translate="yes" xml:space="preserve">
          <source>The following take a single &lt;code&gt;__v8hi&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">Следующее принимает единственный аргумент &lt;code&gt;__v8hi&lt;/code&gt; и возвращает результат &lt;code&gt;__v8hi&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="24b4a9f9391a5e9fb5aa4cf91d4033a4a1ba3911" translate="yes" xml:space="preserve">
          <source>The following take an &lt;code&gt;int&lt;/code&gt; argument and return no result:</source>
          <target state="translated">Следующие команды принимают аргумент типа &lt;code&gt;int&lt;/code&gt; и не возвращают результата:</target>
        </trans-unit>
        <trans-unit id="1708876febe0e46c893dfd70681ac1b1b3aa8762" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; and one &lt;code&gt;int&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">Следующее принимает один &lt;code&gt;__v8hi&lt;/code&gt; и один аргумент &lt;code&gt;int&lt;/code&gt; и возвращает результат &lt;code&gt;__v8hi&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3ad9bd81f972d4f83266bbddb59970dde24eddc0" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 3-bit compile time constant indicating a register number I0-I7. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">Следующее принимает один аргумент &lt;code&gt;__v8hi&lt;/code&gt; и один аргумент &lt;code&gt;int&lt;/code&gt; , который должен быть 3-битной константой времени компиляции, указывающей номер регистра I0-I7. Они возвращают результат &lt;code&gt;__v8hi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc2a1ecceb07161357bd0a5bf4b1cca5ccc19add" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 6-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">Следующее принимает один аргумент &lt;code&gt;__v8hi&lt;/code&gt; и один аргумент &lt;code&gt;int&lt;/code&gt; , который должен быть 6-битной постоянной времени компиляции. Они возвращают результат &lt;code&gt;__v8hi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c720afe018ece35380697d65f42b49460f2c3700" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">Следующее принимает один аргумент &lt;code&gt;__v8hi&lt;/code&gt; и один аргумент &lt;code&gt;int&lt;/code&gt; , который должен быть 8-битной константой времени компиляции. Они возвращают результат &lt;code&gt;__v8hi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0015b52d89388ff44035be55e55280be0b4aaeb6" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;__v8hi&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">Следующее принимает два аргумента &lt;code&gt;__v8hi&lt;/code&gt; и возвращает результат &lt;code&gt;__v8hi&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="074063c3bbf2515afebb90aeb39ce860c2e31da4" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The first argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the second argument must be an 8-bit compile time constant.</source>
          <target state="translated">Следующее принимает два аргумента &lt;code&gt;int&lt;/code&gt; и возвращает результат &lt;code&gt;__v8hi&lt;/code&gt; . Первый аргумент должен быть 3-битной константой времени компиляции, указывающей регистры I0-I7, а второй аргумент должен быть 8-битной константой времени компиляции.</target>
        </trans-unit>
        <trans-unit id="e5b1b82914edb80d2ca00848561437d84a1f1eb2" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The first argument must a 3-bit compile time constant indicating one of the DR0-DR7 DMA setup channels:</source>
          <target state="translated">Следующее принимает два аргумента типа &lt;code&gt;int&lt;/code&gt; и не возвращает результата. Первый аргумент должен иметь 3-битную константу времени компиляции, указывающую один из каналов настройки DR0-DR7 DMA:</target>
        </trans-unit>
        <trans-unit id="14c057c170ec53d564774b373c4a36cf121034de" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result:</source>
          <target state="translated">Следующее принимает два аргумента типа &lt;code&gt;int&lt;/code&gt; и не возвращает результата:</target>
        </trans-unit>
        <trans-unit id="c73d90b3764a03700faea9b5a80499c3a3c6ee74" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments, the second of which which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">Следующее принимает два аргумента типа &lt;code&gt;int&lt;/code&gt; , второй из которых должен быть 8-битной константой времени компиляции. Они возвращают результат &lt;code&gt;__v8hi&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7604a9689ceddf3a88ac390cfb640c35daa9929f" translate="yes" xml:space="preserve">
          <source>The following target-specific function attributes are available for the AArch64 target. For the most part, these options mirror the behavior of similar command-line options (see &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 Options&lt;/a&gt;), but on a per-function basis.</source>
          <target state="translated">Для цели AArch64 доступны следующие атрибуты функций, специфичных для цели. По большей части эти параметры отражают поведение аналогичных параметров командной строки (см. &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;Параметры AArch64&lt;/a&gt; ), но для каждой функции.</target>
        </trans-unit>
        <trans-unit id="2a9dcb7afea2063b88c3f0d0bf8b210d678cf434" translate="yes" xml:space="preserve">
          <source>The following type attributes are supported on most targets.</source>
          <target state="translated">Следующие атрибуты типа поддерживаются для большинства целей.</target>
        </trans-unit>
        <trans-unit id="7ea3e81960cea1d06fa9fca33b75a29a1d4f2d4a" translate="yes" xml:space="preserve">
          <source>The following values of &lt;var&gt;insn&lt;/var&gt; are supported. Except as otherwise noted, floating-point operations are expected to be implemented with normal IEEE 754 semantics and correspond directly to the C operators or the equivalent GCC built-in functions (see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt;).</source>
          <target state="translated">Поддерживаются следующие значения &lt;var&gt;insn&lt;/var&gt; . Если не указано иное, ожидается, что операции с плавающей запятой будут реализованы с нормальной семантикой IEEE 754 и будут напрямую соответствовать операторам C или эквивалентным встроенным функциям GCC (см. &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Другие встроенные функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="da10b4f1472639ab267cde98b6118ed2bb143912" translate="yes" xml:space="preserve">
          <source>The formats are checked against the format features supported by GNU libc version 2.2. These include all ISO C90 and C99 features, as well as features from the Single Unix Specification and some BSD and GNU extensions. Other library implementations may not support all these features; GCC does not support warning about features that go beyond a particular library&amp;rsquo;s limitations. However, if</source>
          <target state="translated">Форматы проверяются на соответствие функциям формата, поддерживаемым GNU libc версии 2.2. К ним относятся все функции ISO C90 и C99, а также функции из спецификации Single Unix и некоторые расширения BSD и GNU. Другие реализации библиотеки могут не поддерживать все эти функции; GCC не поддерживает предупреждения о функциях, которые выходят за рамки ограничений конкретной библиотеки. Однако если</target>
        </trans-unit>
        <trans-unit id="3fd329b7b6e510f8c7f38ab04501976f2c6f4c71" translate="yes" xml:space="preserve">
          <source>The forwarding method implementation thus created is returned by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; and is executed as if it was a normal method implementation. When the forwarding method implementation is called, it is usually expected to pack all arguments into some sort of object (typically, an &lt;code&gt;NSInvocation&lt;/code&gt; in a &amp;ldquo;Foundation&amp;rdquo; library), and hand it over to the programmer (&lt;code&gt;forwardInvocation:&lt;/code&gt;) who is then allowed to manipulate the method invocation using a high-level API provided by the &amp;ldquo;Foundation&amp;rdquo; library. For example, the programmer may want to examine the method invocation arguments and name and potentially change them before forwarding the method invocation to one or more local objects (&lt;code&gt;performInvocation:&lt;/code&gt;) or even to remote objects (by using Distributed Objects or some other mechanism). When all this completes, the return value is passed back and must be returned correctly to the original caller.</source>
          <target state="translated">Созданная таким образом реализация метода пересылки возвращается &lt;code&gt;objc_msg_lookup()&lt;/code&gt; и выполняется, как если бы это была обычная реализация метода. Когда вызывается реализация метода пересылки, обычно ожидается, что все аргументы будут упакованы в какой-либо объект (обычно &lt;code&gt;NSInvocation&lt;/code&gt; в библиотеке &amp;laquo;Foundation&amp;raquo;) и &lt;code&gt;forwardInvocation:&lt;/code&gt; программисту ( forwardInvocation :), которому затем разрешено управлять вызовом метода с помощью высокоуровневого API, предоставляемого библиотекой &amp;laquo;Foundation&amp;raquo;. Например, программист может захотеть проверить аргументы и имя вызова метода и потенциально изменить их, прежде чем перенаправить вызов метода одному или нескольким локальным объектам ( &lt;code&gt;performInvocation:&lt;/code&gt; ) или даже удаленным объектам (с помощью распределенных объектов или какого-либо другого механизма). Когда все это завершается, возвращаемое значение передается обратно и должно быть правильно возвращено исходной вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="370cce3123cd6103545b49952aa7ecfe80d28686" translate="yes" xml:space="preserve">
          <source>The four non-arithmetic functions (load, store, exchange, and compare_exchange) all have a generic version as well. This generic version works on any data type. It uses the lock-free built-in function if the specific data type size makes that possible; otherwise, an external call is left to be resolved at run time. This external call is the same format with the addition of a &amp;lsquo;</source>
          <target state="translated">Все четыре неарифметических функции (загрузка, сохранение, обмен и compare_exchange) также имеют общую версию. Эта универсальная версия работает с любым типом данных. Он использует встроенную функцию lock-free, если это возможно из-за размера конкретного типа данных; в противном случае внешний вызов остается разрешенным во время выполнения. Этот внешний вызов имеет тот же формат с добавлением символа '</target>
        </trans-unit>
        <trans-unit id="bc7082dbfb46d172471e10794421761522292732" translate="yes" xml:space="preserve">
          <source>The frame is the area on the stack that holds local variables and saved registers. The frame address is normally the address of the first word pushed on to the stack by the function. However, the exact definition depends upon the processor and the calling convention. If the processor has a dedicated frame pointer register, and the function has a frame, then &lt;code&gt;__builtin_frame_address&lt;/code&gt; returns the value of the frame pointer register.</source>
          <target state="translated">Фрейм - это область в стеке, в которой хранятся локальные переменные и сохраненные регистры. Адрес кадра обычно является адресом первого слова, помещенного функцией в стек. Однако точное определение зависит от процессора и соглашения о вызовах. Если процессор имеет специальный регистр указателя кадра, а функция имеет кадр, то &lt;code&gt;__builtin_frame_address&lt;/code&gt; возвращает значение регистра указателя кадра.</target>
        </trans-unit>
        <trans-unit id="91be25b4a97f2d4dcdca61df07841207c68074ea" translate="yes" xml:space="preserve">
          <source>The front end also exposes a number of internal mechanism that can be used to simplify the writing of type traits. Note that some of these traits are likely to be removed in the future.</source>
          <target state="translated">Передняя часть также раскрывает ряд внутренних механизмов,которые могут быть использованы для упрощения записи типовых признаков.Обратите внимание,что некоторые из этих черт,вероятно,будут удалены в будущем.</target>
        </trans-unit>
        <trans-unit id="0002fd6e851a03368550f6c8393985028e5a22a9" translate="yes" xml:space="preserve">
          <source>The function may cause execution to pause until it is known that the code is no-longer being executed speculatively (in which case &lt;var&gt;val&lt;/var&gt; can be returned, as above); or</source>
          <target state="translated">Функция может вызвать приостановку выполнения до тех пор, пока не станет известно, что код больше не выполняется спекулятивно (в этом случае может быть возвращено значение &lt;var&gt;val&lt;/var&gt; , как указано выше); или</target>
        </trans-unit>
        <trans-unit id="c285a5c6cfe9015607ff4a0e2ac733ad987d0e25" translate="yes" xml:space="preserve">
          <source>The function may use target-dependent speculation tracking state to cause &lt;var&gt;failval&lt;/var&gt; to be returned when it is known that speculative execution has incorrectly predicted a conditional branch operation.</source>
          <target state="translated">Функция может использовать состояние отслеживания спекуляций, зависящее от цели, чтобы вызвать &lt;var&gt;failval&lt;/var&gt; , когда известно, что спекулятивное выполнение неправильно предсказало операцию условного перехода.</target>
        </trans-unit>
        <trans-unit id="1910cbf4d249572210143c348f1416c66e710621" translate="yes" xml:space="preserve">
          <source>The function parameter denoting the allocated alignment is specified by one constant integer argument whose number is the argument of the attribute. Argument numbering starts at one.</source>
          <target state="translated">Параметр функции,обозначающий выравнивание по распределению,задается одним постоянным целочисленным аргументом,число которого является аргументом атрибута.Нумерация аргументов начинается с единицы.</target>
        </trans-unit>
        <trans-unit id="3b052040572f76188271e0e3e0c80c35be66f2c8" translate="yes" xml:space="preserve">
          <source>The function parameter(s) denoting the allocated size are specified by one or two integer arguments supplied to the attribute. The allocated size is either the value of the single function argument specified or the product of the two function arguments specified. Argument numbering starts at one for ordinary functions, and at two for C++ non-static member functions.</source>
          <target state="translated">Параметр(ы)функции,обозначающий размер присваиваемого значения,задается одним или двумя целыми аргументами,передаваемыми в атрибут.Размер присваиваемого значения является либо значением одного из указанных аргументов функции,либо произведением двух указанных аргументов функции.Нумерация аргументов начинается с одного для обычных функций и с двух для нестатических функций C++.</target>
        </trans-unit>
        <trans-unit id="0ca979696b9a2800aa34523d4083bf5a14d799aa" translate="yes" xml:space="preserve">
          <source>The function saves the arg pointer register, structure value address, and all registers that might be used to pass arguments to a function into a block of memory allocated on the stack. Then it returns the address of that block.</source>
          <target state="translated">Функция сохраняет регистр указателя arg,адрес значения структуры и все регистры,которые могут быть использованы для передачи аргументов функции в блок памяти,выделенный на стеке.Затем она возвращает адрес этого блока.</target>
        </trans-unit>
        <trans-unit id="6872e4d72d8fbbd9743faadfaad51d5d8e08d8dc" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V I-type instructions.</source>
          <target state="translated">Функции,перечисленные ниже,отображаются непосредственно в инструкциях FR-V I-типа.</target>
        </trans-unit>
        <trans-unit id="c602f6bdf5c7225fe620c26f84e8de50c7071a07" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V M-type instructions.</source>
          <target state="translated">Функции,перечисленные ниже,отображаются непосредственно в инструкциях FR-V M-типа.</target>
        </trans-unit>
        <trans-unit id="d757b37f17b7bb17dc67a24428e9f56b268f5c5e" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to a particular MIPS-3D instruction. Please refer to the architecture specification for more details on what each instruction does.</source>
          <target state="translated">Функции,перечисленные ниже,сопоставляются непосредственно с конкретной инструкцией MIPS-3D.Пожалуйста,обратитесь к спецификации архитектуры для получения более подробной информации о том,что делает каждая инструкция.</target>
        </trans-unit>
        <trans-unit id="636b8102a37675bf78355f0f6bba2ff462438334" translate="yes" xml:space="preserve">
          <source>The functions supported are:</source>
          <target state="translated">Поддерживаются следующие функции:</target>
        </trans-unit>
        <trans-unit id="ad7023ac286f3db88bfb11b7cae18fc097b31af2" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension and the half-precision floating-point fmla extension.</source>
          <target state="translated">Инструкции по обработке данных с плавающей запятой с половинной точностью.Это также позволяет использовать расширенные инструкции SIMD и вычислений с плавающей запятой,а также расширение Dot Product и расширение fmla с плавающей запятой половинной точности.</target>
        </trans-unit>
        <trans-unit id="58f4f715483c2871dde2ce2ca0d2db8aca84c869" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Инструкции по обработке данных с плавающей запятой с половинной точностью.Это также позволяет использовать усовершенствованный SIMD и инструкции с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="11520bb64917989439d0bd1e50b448954652e968" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point fmla extension. This also enables the half-precision floating-point extension and Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Расширение с плавающей точкой fmla с половинной точностью.Это также позволяет использовать расширение с плавающей запятой с половинной точностью и Advanced SIMD и инструкции по работе с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="ddd47b9fa117c203d0b4afbba7a0a4bc59d68406" translate="yes" xml:space="preserve">
          <source>The hardware multiply routines disable interrupts whilst running and restore the previous interrupt state when they finish. This makes them safe to use inside interrupt handlers as well as in normal code.</source>
          <target state="translated">Аппаратные процедуры умножения отключают прерывания во время выполнения и восстанавливают предыдущее состояние прерывания по его завершению.Это делает их безопасными для использования как внутри обработчиков прерываний,так и в обычном коде.</target>
        </trans-unit>
        <trans-unit id="1700f28ed95fcc91e5f3613066db6eabb50e9b1f" translate="yes" xml:space="preserve">
          <source>The header files contain detailed documentation for each function in the GNU Objective-C runtime API.</source>
          <target state="translated">Заголовочные файлы содержат подробную документацию по каждой функции в API среды исполнения GNU Objective-C.</target>
        </trans-unit>
        <trans-unit id="bef3ae0649be61ff8ea14c16eb476e462ede9be4" translate="yes" xml:space="preserve">
          <source>The high part (bits 12 and upwards) of the pc-relative address of a symbol within 4GB of the instruction</source>
          <target state="translated">Высокая часть (биты 12 и вверх)pc-относительного адреса символа в пределах 4 ГБ инструкции</target>
        </trans-unit>
        <trans-unit id="ea0d4a97e0e09b3d462961a102c172f60bf94df3" translate="yes" xml:space="preserve">
          <source>The iWMMX GR registers.</source>
          <target state="translated">iWMMX GR регистрирует.</target>
        </trans-unit>
        <trans-unit id="2ad23a41b556be75b4554217ab7b7da89d6570d2" translate="yes" xml:space="preserve">
          <source>The iWMMX co-processor registers.</source>
          <target state="translated">Регистры сопроцессора iWMMX.</target>
        </trans-unit>
        <trans-unit id="b46a70e92f765a7f4dbecade6890d0ae606db8e1" translate="yes" xml:space="preserve">
          <source>The idea behind this is that sometimes it is convenient (for the programmer) to consider floating-point values as approximations to infinitely precise real numbers. If you are doing this, then you need to compute (by analyzing the code, or in some other way) the maximum or likely maximum error that the computation introduces, and allow for it when performing comparisons (and when producing output, but that&amp;rsquo;s a different problem). In particular, instead of testing for equality, you should check to see whether the two values have ranges that overlap; and this is done with the relational operators, so equality comparisons are probably mistaken.</source>
          <target state="translated">Идея заключается в том, что иногда (для программиста) удобно рассматривать значения с плавающей запятой как приближения к бесконечно точным действительным числам. Если вы делаете это, вам необходимо вычислить (путем анализа кода или каким-либо другим способом) максимальную или вероятную максимальную ошибку, которую вводит вычисление, и учесть ее при выполнении сравнений (и при создании вывода, но это другая проблема). В частности, вместо проверки на равенство вы должны проверить, имеют ли два значения перекрывающиеся диапазоны; и это делается с помощью операторов отношения, поэтому сравнения на равенство, вероятно, ошибочны.</target>
        </trans-unit>
        <trans-unit id="c0a98af2de248cc10c278826d9411559e39eee26" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;__func__&lt;/code&gt; is implicitly declared by the translator as if, immediately following the opening brace of each function definition, the declaration</source>
          <target state="translated">Идентификатор &lt;code&gt;__func__&lt;/code&gt; неявно объявляется переводчиком, как если бы сразу после открывающей скобки каждого определения функции объявление</target>
        </trans-unit>
        <trans-unit id="13fbfb86cc636b25b4f8dbf9788be6becd2407c7" translate="yes" xml:space="preserve">
          <source>The immediate value 0x01.</source>
          <target state="translated">Немедленное значение 0x01.</target>
        </trans-unit>
        <trans-unit id="52de78dd0ef761fa638ed2df23930f5359ca4c01" translate="yes" xml:space="preserve">
          <source>The immediate value 0x7ff.</source>
          <target state="translated">Немедленное значение 0x7ff.</target>
        </trans-unit>
        <trans-unit id="178295c2520a8328225a3e14f6430b205aa477b7" translate="yes" xml:space="preserve">
          <source>The immediate value 0xff.</source>
          <target state="translated">Немедленное значение 0xff.</target>
        </trans-unit>
        <trans-unit id="ba38c21b26ea7ac3618ca4682f483633c0168822" translate="yes" xml:space="preserve">
          <source>The immediate value 0xffff.</source>
          <target state="translated">Немедленное значение 0xff.</target>
        </trans-unit>
        <trans-unit id="f3edc2d2bcd9f411eb9c02f201cf5906b594ce1b" translate="yes" xml:space="preserve">
          <source>The immediate value that can be simply set high 20-bit.</source>
          <target state="translated">Непосредственное значение,которое можно просто установить высоким 20-битным.</target>
        </trans-unit>
        <trans-unit id="f3b3ce3b975ce4bb65c0a8ad20428b556134b6e5" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2 minus 1.</source>
          <target state="translated">Непосредственное значение с мощностью 2 минус 1.</target>
        </trans-unit>
        <trans-unit id="cdad57dc1c93e8c86249089910e5d64e47612ed8" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2.</source>
          <target state="translated">Непосредственное значение с мощностью 2.</target>
        </trans-unit>
        <trans-unit id="292bc2fc3bad9eb92ff6853193b506ffc6d78c40" translate="yes" xml:space="preserve">
          <source>The impacted functions are determined by the compiler&amp;rsquo;s interprocedural optimizations. For example, a caller is impacted when inlining a function into its caller, cloning a function and changing its caller to call this new clone, or extracting a function&amp;rsquo;s pureness/constness information to optimize its direct or indirect callers, etc.</source>
          <target state="translated">Затрагиваемые функции определяются межпроцедурной оптимизацией компилятора. Например, на вызывающего влияет встраивание функции в вызывающий объект, клонирование функции и изменение вызывающего объекта для вызова этого нового клона или извлечение информации о чистоте / постоянстве функции для оптимизации прямых или косвенных вызывающих объектов и т. Д.</target>
        </trans-unit>
        <trans-unit id="788e9c101326291dabb53f85af22d398e9b836ec" translate="yes" xml:space="preserve">
          <source>The implementation of messaging in the GNU Objective-C runtime is designed to be portable, and so is based on standard C.</source>
          <target state="translated">Реализация обмена сообщениями во время выполнения GNU Objective-C разработана так,чтобы быть переносимой,и поэтому основана на стандартной C.</target>
        </trans-unit>
        <trans-unit id="4de99bcf5ddd6a719a8ac7733daede651bd9f548" translate="yes" xml:space="preserve">
          <source>The important thing to keep in mind is that to enable link-time optimizations you need to use the GCC driver to perform the link step. GCC automatically performs link-time optimization if any of the objects involved were compiled with the</source>
          <target state="translated">Важно помнить,что для включения оптимизации времени соединения вам нужно использовать драйвер GCC для выполнения шага соединения.GCC автоматически выполняет линк-оптимизацию,если любой из задействованных объектов был скомпилирован с помощью параметра</target>
        </trans-unit>
        <trans-unit id="9a2b4fb08fe8eee4956db02cb6f8d3c3fb54b6e4" translate="yes" xml:space="preserve">
          <source>The index values must be constant expressions, even if the array being initialized is automatic.</source>
          <target state="translated">Значения индекса должны быть константными выражениями,даже если инициализируемый массив является автоматическим.</target>
        </trans-unit>
        <trans-unit id="20238db563baf6821f8bed87f8777e30be3fd316" translate="yes" xml:space="preserve">
          <source>The induction variable optimizations give up on loops that contain more induction variable uses.</source>
          <target state="translated">Оптимизация индукционных переменных позволяет отказаться от циклов,в которых используется больше индукционных переменных.</target>
        </trans-unit>
        <trans-unit id="99b9ae56dc4f69f455cd2846f1efc86548a4f0b0" translate="yes" xml:space="preserve">
          <source>The instructions generated by the following builtins are not considered as candidates for scheduling. They are not moved around by the compiler during scheduling, and thus can be expected to appear where they are put in the C code:</source>
          <target state="translated">Инструкции,генерируемые следующими сборками,не рассматриваются в качестве кандидатов для составления расписания.Они не перемещаются компилятором во время составления расписания,и поэтому можно ожидать,что они появятся в том месте,куда их поместили в C-коде:</target>
        </trans-unit>
        <trans-unit id="0143a1fa40596d46b920e516a49bccafb05c6756" translate="yes" xml:space="preserve">
          <source>The integer constant -1.</source>
          <target state="translated">Целочисленная константа -1.</target>
        </trans-unit>
        <trans-unit id="0304e4a19fa9d570fa64154ef073c85be9e9d234" translate="yes" xml:space="preserve">
          <source>The integer constant -2.</source>
          <target state="translated">Целочисленная константа -2.</target>
        </trans-unit>
        <trans-unit id="20219359f9654d4bb60ad841282922f1407f31ff" translate="yes" xml:space="preserve">
          <source>The integer constant 0.</source>
          <target state="translated">Целая константа 0.</target>
        </trans-unit>
        <trans-unit id="84b9a3c5e77c93a53f2664cad25c5af25a563160" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff.</source>
          <target state="translated">Целочисленная константа 0xffffff.</target>
        </trans-unit>
        <trans-unit id="0900ba8234ff692dd368ac2562960d9c24b87490" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff00000000.</source>
          <target state="translated">Целая константа 0xffffff00000000.</target>
        </trans-unit>
        <trans-unit id="1704120ef6a8406a0d73d119b3bae3d2fd6db0c7" translate="yes" xml:space="preserve">
          <source>The integer constant 1.</source>
          <target state="translated">Целая константа 1.</target>
        </trans-unit>
        <trans-unit id="f7733e70947e25f6ba4f15b855fbc6bb56230e77" translate="yes" xml:space="preserve">
          <source>The integer constant 2.</source>
          <target state="translated">Целая константа 2.</target>
        </trans-unit>
        <trans-unit id="2e4afdbd5f6f64969b9a9086ed5845106d1e1df4" translate="yes" xml:space="preserve">
          <source>The integer type compatible with each enumerated type (C90 6.5.2.2, C99 and C11 6.7.2.2).</source>
          <target state="translated">Целый тип,совместимый с каждым перечисленным типом (C90 6.5.2.2,C99 и C11 6.7.2.2).</target>
        </trans-unit>
        <trans-unit id="d4f4c82404325b1bedf2b678bda8824c1372dc16" translate="yes" xml:space="preserve">
          <source>The integer zero constant.</source>
          <target state="translated">Целочисленная нулевая константа.</target>
        </trans-unit>
        <trans-unit id="7f5eb05da6eb2941255dd1f24db7755004fe0fb6" translate="yes" xml:space="preserve">
          <source>The intended use can be e.g.</source>
          <target state="translated">Использование по назначению может быть,например</target>
        </trans-unit>
        <trans-unit id="eec03e559122067c46321a3d23e2fe242aaa628b" translate="yes" xml:space="preserve">
          <source>The intrinsic &lt;code&gt;void __tile_network_barrier (void)&lt;/code&gt; is used to guarantee that no network operations before it are reordered with those after it.</source>
          <target state="translated">Внутренний &lt;code&gt;void __tile_network_barrier (void)&lt;/code&gt; используется, чтобы гарантировать, что никакие сетевые операции до него не переупорядочиваются с операциями после него.</target>
        </trans-unit>
        <trans-unit id="2b326f68cedc113119b7cfc329617004f7ca5d0f" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction to which it corresponds, with suffixes added as appropriate to distinguish intrinsics that expand to the same machine instruction yet have different argument types. Refer to the architecture documentation for a description of the functionality of each instruction.</source>
          <target state="translated">Предоставляемые intrinsics перечислены ниже;каждая из них названа в честь инструкции машины,которой она соответствует,с добавлением суффиксов,подходящих для различения intrinsics,которые расширяются на ту же самую инструкцию машины,но имеют различные типы аргументов.Описание функциональности каждой инструкции см.в документации по архитектуре.</target>
        </trans-unit>
        <trans-unit id="3a0e26ddf5eff18eeea3fbd0b9d1cb136b8b4213" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction.</source>
          <target state="translated">Приведенные ниже intrinsics перечислены;каждая из них названа в соответствии с инструкцией по эксплуатации машины.</target>
        </trans-unit>
        <trans-unit id="3eef6d5321de2f795448068015c7c54f1ed1296f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;@compatibility_alias&lt;/code&gt; allows you to define a class name as equivalent to another class name. For example:</source>
          <target state="translated">Ключевое слово &lt;code&gt;@compatibility_alias&lt;/code&gt; позволяет вам определить имя класса как эквивалент другого имени класса. Например:</target>
        </trans-unit>
        <trans-unit id="dae34f2a2b2a52f07242474e58c01e8458c373a3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__alignof__&lt;/code&gt; determines the alignment requirement of a function, object, or a type, or the minimum alignment usually required by a type. Its syntax is just like &lt;code&gt;sizeof&lt;/code&gt; and C11 &lt;code&gt;_Alignof&lt;/code&gt;.</source>
          <target state="translated">Ключевое слово &lt;code&gt;__alignof__&lt;/code&gt; определяет требование выравнивания функции, объекта или типа или минимальное выравнивание, обычно требуемое типом. Его синтаксис такой же, как у &lt;code&gt;sizeof&lt;/code&gt; и C11 &lt;code&gt;_Alignof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e11754fcd951a085d6544dab003aaba8cd78a6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify special properties of variables, function parameters, or structure, union, and, in C++, class members. This &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses. Some attributes are currently defined generically for variables. Other attributes are defined for variables on particular target systems. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;). Other front ends might define more attributes (see &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;).</source>
          <target state="translated">Ключевое слово &lt;code&gt;__attribute__&lt;/code&gt; позволяет вам определять специальные свойства переменных, параметров функции или структуры, объединения и, в C ++, членов класса. За этим ключевым словом &lt;code&gt;__attribute__&lt;/code&gt; следует спецификация атрибута, заключенная в двойные круглые скобки. Некоторые атрибуты в настоящее время определены как общие для переменных. Другие атрибуты определены для переменных в конкретных целевых системах. Другие атрибуты доступны для функций (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функций&lt;/a&gt; ), меток (см. &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Атрибуты меток&lt;/a&gt; ), счетчиков (см. &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Атрибуты перечислителя&lt;/a&gt; ), операторов (см. &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Атрибуты&lt;/a&gt; операторов ) и типов (см. &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Атрибуты типа&lt;/a&gt; ). Другие внешние интерфейсы могут определять больше атрибутов (см.&lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Расширения языка C ++&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a4cf059503889f054506ae99e86330f0d94efc6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify various special properties of types. Some type attributes apply only to structure and union types, and in C++, also class types, while others can apply to any type defined via a &lt;code&gt;typedef&lt;/code&gt; declaration. Unless otherwise specified, the same restrictions and effects apply to attributes regardless of whether a type is a trivial structure or a C++ class with user-defined constructors, destructors, or a copy assignment.</source>
          <target state="translated">Ключевое слово &lt;code&gt;__attribute__&lt;/code&gt; позволяет указывать различные специальные свойства типов. Некоторые атрибуты типа применяются только к типам структуры и объединения, а в C ++ также к типам классов, тогда как другие могут применяться к любому типу, определенному через объявление &lt;code&gt;typedef&lt;/code&gt; . Если не указано иное, те же ограничения и эффекты применяются к атрибутам независимо от того, является ли тип тривиальной структурой или классом C ++ с определяемыми пользователем конструкторами, деструкторами или копированием.</target>
        </trans-unit>
        <trans-unit id="1572dc96be7f5e014878efc69fdfd49b0ae87eea" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__thread&lt;/code&gt; applied to a non-local object gives the object thread storage duration.</source>
          <target state="translated">Ключевое слово &lt;code&gt;__thread&lt;/code&gt; , примененное к нелокальному объекту, дает продолжительность хранения потока объекта.</target>
        </trans-unit>
        <trans-unit id="39b19603ff8ee793099ac42a05990562491ebaf2" translate="yes" xml:space="preserve">
          <source>The label declaration defines the label &lt;em&gt;name&lt;/em&gt;, but does not define the label itself. You must do this in the usual way, with &lt;code&gt;&lt;var&gt;label&lt;/var&gt;:&lt;/code&gt;, within the statements of the statement expression.</source>
          <target state="translated">Объявление метки определяет &lt;em&gt;имя&lt;/em&gt; метки , но не определяет саму метку. Вы должны сделать это обычным способом с &lt;code&gt;&lt;var&gt;label&lt;/var&gt;:&lt;/code&gt; внутри операторов выражения оператора.</target>
        </trans-unit>
        <trans-unit id="428f4e4c9e8e6a37b249e009bb97c82a44c2fb8f" translate="yes" xml:space="preserve">
          <source>The language-independent component of GCC includes the majority of the optimizers, as well as the &amp;ldquo;back ends&amp;rdquo; that generate machine code for various processors.</source>
          <target state="translated">Независимый от языка компонент GCC включает в себя большинство оптимизаторов, а также &amp;laquo;серверные части&amp;raquo;, которые генерируют машинный код для различных процессоров.</target>
        </trans-unit>
        <trans-unit id="005fac6b181ca927cb2a738c000f5da953afe1b7" translate="yes" xml:space="preserve">
          <source>The last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct. (If you use some other kind of statement last within the braces, the construct has type &lt;code&gt;void&lt;/code&gt;, and thus effectively no value.)</source>
          <target state="translated">Последним элементом составного оператора должно быть выражение, за которым следует точка с запятой; значение этого подвыражения служит значением всей конструкции. (Если последним в фигурных скобках вы используете какой-либо другой оператор, конструкция имеет тип &lt;code&gt;void&lt;/code&gt; и, следовательно, фактически не имеет значения.)</target>
        </trans-unit>
        <trans-unit id="206e1d46d7d3ee120b67ca48c1a3f104346b70ef" translate="yes" xml:space="preserve">
          <source>The length of an array is computed once when the storage is allocated and is remembered for the scope of the array in case you access it with &lt;code&gt;sizeof&lt;/code&gt;.</source>
          <target state="translated">Длина массива вычисляется один раз, когда выделяется хранилище, и запоминается для объема массива, если вы &lt;code&gt;sizeof&lt;/code&gt; к нему с помощью sizeof .</target>
        </trans-unit>
        <trans-unit id="ce058b55eed72e669ebdbd6e3aba9093499b97c5" translate="yes" xml:space="preserve">
          <source>The letters represent the following data types:</source>
          <target state="translated">Буквы представляют следующие типы данных:</target>
        </trans-unit>
        <trans-unit id="77263b459d57cfcd71f0acd14e32e54e7be714c9" translate="yes" xml:space="preserve">
          <source>The lifetime of a compiler generated temporary is well defined by the C++ standard. When a lifetime of a temporary ends, and if the temporary lives in memory, the optimizing compiler has the freedom to reuse its stack space with other temporaries or scoped local variables whose live range does not overlap with it. However some of the legacy code relies on the behavior of older compilers in which temporaries&amp;rsquo; stack space is not reused, the aggressive stack reuse can lead to runtime errors. This option is used to control the temporary stack reuse optimization.</source>
          <target state="translated">Время жизни временного файла, созданного компилятором, четко определено стандартом C ++. Когда время жизни временного заканчивается, и если временное находится в памяти, оптимизирующий компилятор может повторно использовать свое пространство стека с другими временными или ограниченными локальными переменными, динамический диапазон которых не перекрывается с ним. Однако часть унаследованного кода зависит от поведения старых компиляторов, в которых пространство стека временных библиотек не используется повторно, агрессивное повторное использование стека может привести к ошибкам времени выполнения. Эта опция используется для управления временной оптимизацией повторного использования стека.</target>
        </trans-unit>
        <trans-unit id="499ee472bf57c8d5ea52c4b866109362dfcc7841" translate="yes" xml:space="preserve">
          <source>The limit applies &lt;em&gt;after&lt;/em&gt; string constant concatenation, and does not count the trailing NUL. In C90, the limit was 509 characters; in C99, it was raised to 4095. C++98 does not specify a normative minimum maximum, so we do not diagnose overlength strings in C++.</source>
          <target state="translated">Предел применяется &lt;em&gt;после&lt;/em&gt; конкатенации строковых констант и не учитывает конечный NUL. В C90 ограничение составляло 509 символов; в C99 он был увеличен до 4095. C ++ 98 не определяет нормативный минимальный максимум, поэтому мы не диагностируем строки с избыточной длиной в C ++.</target>
        </trans-unit>
        <trans-unit id="e6c688d4fc373af85820537cf244755f93f3571e" translate="yes" xml:space="preserve">
          <source>The limit specifying large stack frames. While inlining the algorithm is trying to not grow past this limit too much.</source>
          <target state="translated">Ограничение,определяющее большие рамки стека.В то время как алгоритм подчёркивает,что он старается не переборщить с этим лимитом.</target>
        </trans-unit>
        <trans-unit id="85f90ab304447934cd7fe1bd66dac4bb5697c076" translate="yes" xml:space="preserve">
          <source>The limit specifying large translation unit. Growth caused by inlining of units larger than this limit is limited by</source>
          <target state="translated">Предел,определяющий большую единицу перевода.Рост,вызванный вкраплением единиц перевода,превышающих этот предел,ограничивается следующим</target>
        </trans-unit>
        <trans-unit id="24d66aaeb77b8d51a696a30383b9a88d8d0ffec4" translate="yes" xml:space="preserve">
          <source>The limit specifying really large functions. For functions larger than this limit after inlining, inlining is constrained by</source>
          <target state="translated">Ограничение,определяющее действительно большие функции.Для функций,превышающих этот предел после встраивания,встраивание ограничивается следующим</target>
        </trans-unit>
        <trans-unit id="c3e28be9ccc81004da7fffd01a2901be4871fc54" translate="yes" xml:space="preserve">
          <source>The link register, &lt;code&gt;lr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f2bb016c8b0766650946224b7ac36870093175" translate="yes" xml:space="preserve">
          <source>The linker searches a standard list of directories for the library. The directories searched include several standard system directories plus any that you specify with</source>
          <target state="translated">Линкер ищет стандартный список каталогов для библиотеки.Поиск в каталогах включает в себя несколько стандартных системных каталогов плюс любые каталоги,которые вы укажите с помощью</target>
        </trans-unit>
        <trans-unit id="78e4e4eb1e36ecbe1ce8c7bd81da2158dd82d6a9" translate="yes" xml:space="preserve">
          <source>The loader for SPU does not handle dynamic relocations. By default, GCC gives an error when it generates code that requires a dynamic relocation.</source>
          <target state="translated">Погрузчик для SPU не справляется с динамическими перемещениями.По умолчанию GCC выдает ошибку,когда генерирует код,требующий динамического перемещения.</target>
        </trans-unit>
        <trans-unit id="168977c575f70c81d88c067d5911fa44bdb4a1dc" translate="yes" xml:space="preserve">
          <source>The local label feature is useful for complex macros. If a macro contains nested loops, a &lt;code&gt;goto&lt;/code&gt; can be useful for breaking out of them. However, an ordinary label whose scope is the whole function cannot be used: if the macro can be expanded several times in one function, the label is multiply defined in that function. A local label avoids this problem. For example:</source>
          <target state="translated">Функция локальной метки полезна для сложных макросов. Если макрос содержит вложенные циклы, &lt;code&gt;goto&lt;/code&gt; может быть полезен для выхода из них. Однако обычная метка, область действия которой - вся функция, не может быть использована: если макрос может быть расширен несколько раз в одной функции, метка определяется в этой функции многократно. Местный лейбл позволяет избежать этой проблемы. Например:</target>
        </trans-unit>
        <trans-unit id="d40c92db025f666809a32030712abb46e10389b2" translate="yes" xml:space="preserve">
          <source>The location is expressed as a half-open range, expressed as a count of bytes, starting at byte 1 for the initial column. In the above example, bytes 3 through 20 of line 45 of &amp;ldquo;test.c&amp;rdquo; are to be replaced with the given string:</source>
          <target state="translated">Местоположение выражается как полуоткрытый диапазон, выраженный как количество байтов, начиная с байта 1 для начального столбца. В приведенном выше примере байты с 3 по 20 строки 45 файла &amp;laquo;test.c&amp;raquo; необходимо заменить данной строкой:</target>
        </trans-unit>
        <trans-unit id="068a4b98cf23f1dbecfe9f83dd38994bfe05765c" translate="yes" xml:space="preserve">
          <source>The locations within &lt;code&gt;#pragma&lt;/code&gt; directives where header name preprocessing tokens are recognized (C11 6.4, C11 6.4.7).</source>
          <target state="translated">Места в директивах &lt;code&gt;#pragma&lt;/code&gt; , где распознаются токены предварительной обработки имени заголовка (C11 6.4, C11 6.4.7).</target>
        </trans-unit>
        <trans-unit id="fc6965c74c684a5066713cd45514db9bb14c9963" translate="yes" xml:space="preserve">
          <source>The long long types are only implemented for 64-bit code generation.</source>
          <target state="translated">Типы long long реализованы только для генерации 64-битного кода.</target>
        </trans-unit>
        <trans-unit id="6b21e2c583138d02ccff65c0acb02831c06a2211" translate="yes" xml:space="preserve">
          <source>The low registers r0 - r15.</source>
          <target state="translated">Низкие регистры r0-r15.</target>
        </trans-unit>
        <trans-unit id="ed4899b603c3d7a32aa6ba260f62f9b063dd80a8" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__CET__&lt;/code&gt; is defined when</source>
          <target state="translated">Макрос &lt;code&gt;__CET__&lt;/code&gt; определяется, когда</target>
        </trans-unit>
        <trans-unit id="835cec1112f64c57bd44cb4fd1c6251993152130" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; is predefined when the</source>
          <target state="translated">Макрос &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; предопределен, когда</target>
        </trans-unit>
        <trans-unit id="4af0e1087a3dafe7b329598208d0e7bd6efe70c3" translate="yes" xml:space="preserve">
          <source>The main use case of the built-in is to determine whether a &lt;code&gt;constexpr&lt;/code&gt; function is being called in a &lt;code&gt;constexpr&lt;/code&gt; context. A call to the function evaluates to a core constant expression with the value &lt;code&gt;true&lt;/code&gt; if and only if it occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated as defined in the C++ standard. Manifestly constant-evaluated contexts include constant-expressions, the conditions of &lt;code&gt;constexpr if&lt;/code&gt; statements, constraint-expressions, and initializers of variables usable in constant expressions. For more details refer to the latest revision of the C++ standard.</source>
          <target state="translated">Основной вариант использования встроенной функции - определить, &lt;code&gt;constexpr&lt;/code&gt; ли функция &lt;code&gt;constexpr&lt;/code&gt; в контексте constexpr . Вызов функции оценивается в основное постоянное выражение со значением &lt;code&gt;true&lt;/code&gt; тогда и только тогда, когда он происходит в рамках оценки выражения или преобразования, которое явно оценивается константой, как определено в стандарте C ++. Контексты с &lt;code&gt;constexpr if&lt;/code&gt; вычисляемой константой включают константные выражения, условия constexpr if- операторов, ограничительные выражения и инициализаторы переменных, которые можно использовать в константных выражениях. Дополнительные сведения см. В последней версии стандарта C ++.</target>
        </trans-unit>
        <trans-unit id="44703f46619b4bb3387fbb3a9a4987ca25838ebf" translate="yes" xml:space="preserve">
          <source>The mangling was changed in</source>
          <target state="translated">Искажение было изменено в</target>
        </trans-unit>
        <trans-unit id="86f9d67774b219fd5194ad2624b61ab77f3088cf" translate="yes" xml:space="preserve">
          <source>The mapping between physical source file multibyte characters and the source character set in translation phase 1 (C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">Отображение между физическим исходным файлом многобайтовых символов и исходным набором символов на этапе перевода 1 (C90,C99 и C11 5.1.1.2).</target>
        </trans-unit>
        <trans-unit id="63322b3a774c9974339e8944410fb9a8c6f8ebf4" translate="yes" xml:space="preserve">
          <source>The mapping of members of the source character set (in character constants and string literals) to members of the execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4, C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">Отображение членов набора исходных символов (в символьных константах и строковых литералах)на члены набора символов исполнения (С90 6.1.3.4,С99 и С11 6.4.4.4,С90,С99 и С11 5.1.1.2).</target>
        </trans-unit>
        <trans-unit id="6bc3864d5e277c6ac4690c5e9d3fdbf817cb1a7c" translate="yes" xml:space="preserve">
          <source>The max number of reload pseudos which are considered during spilling a non-reload pseudo.</source>
          <target state="translated">Максимальное количество псевдо-перезагрузок,которое учитывается при проливе псевдо-незагрузок.</target>
        </trans-unit>
        <trans-unit id="4f47dce047d8beaa87edf8a1fdc1bf827620a7f2" translate="yes" xml:space="preserve">
          <source>The maximum alignment for SIMD vector mode types. &lt;var&gt;num&lt;/var&gt; may be 4 or 8. The default is 8. Note that this is an ABI change, even though many library function interfaces are unaffected if they don&amp;rsquo;t use SIMD vector modes in places that affect size and/or alignment of relevant types.</source>
          <target state="translated">Максимальное выравнивание для типов векторных режимов SIMD. &lt;var&gt;num&lt;/var&gt; может быть 4 или 8. По умолчанию - 8. Обратите внимание, что это изменение ABI, даже несмотря на то, что многие интерфейсы функций библиотеки не затронуты, если они не используют векторные режимы SIMD в местах, которые влияют на размер и / или выравнивание соответствующих типов.</target>
        </trans-unit>
        <trans-unit id="666ee1692153a86b3ec75a197326eda3a0d60489" translate="yes" xml:space="preserve">
          <source>The maximum amount of iterations of the pass over the function. This is used to limit compilation time in tree tail merging.</source>
          <target state="translated">Максимальное количество итераций прохождения над функцией.Это используется для ограничения времени компиляции при слиянии хвоста дерева.</target>
        </trans-unit>
        <trans-unit id="89ecfe4db21e974dbc1daddf5e580b9450304991" translate="yes" xml:space="preserve">
          <source>The maximum amount of similar bbs to compare a bb with. This is used to avoid quadratic behavior in tree tail merging.</source>
          <target state="translated">Максимальное количество похожих bb для сравнения с bb.Это используется,чтобы избежать квадратичного поведения при слиянии хвоста дерева.</target>
        </trans-unit>
        <trans-unit id="b6556ebb0621924348132da881ea97c1a248f5ac" translate="yes" xml:space="preserve">
          <source>The maximum code size expansion factor when copying basic blocks instead of jumping. The expansion is relative to a jump instruction.</source>
          <target state="translated">Максимальный коэффициент расширения размера кода при копировании основных блоков вместо прыжков.Расширение относительно инструкции по прыжку.</target>
        </trans-unit>
        <trans-unit id="fce841f0d7fbba4e3b6b48cb84aa6e927eb09594" translate="yes" xml:space="preserve">
          <source>The maximum code size growth ratio when expanding into a jump table (in percent). The parameter is used when optimizing for size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d12fa5294a85cba03b250f3a5bea21673f3bb2" translate="yes" xml:space="preserve">
          <source>The maximum code size growth ratio when expanding into a jump table (in percent). The parameter is used when optimizing for speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936a590636d845b92624c7728a4827fce9d92d06" translate="yes" xml:space="preserve">
          <source>The maximum conflict delay for an insn to be considered for speculative motion.</source>
          <target state="translated">Максимальная задержка конфликта для INSN должна быть рассмотрена для спекулятивного движения.</target>
        </trans-unit>
        <trans-unit id="fbb7200dcbf807a75160beecc432fa62ed3e9728" translate="yes" xml:space="preserve">
          <source>The maximum depth of a loop nest suitable for complete peeling.</source>
          <target state="translated">Максимальная глубина петлевого гнезда,пригодного для полного пилинга.</target>
        </trans-unit>
        <trans-unit id="26a797ef806eaaf765b7a781b669b0a1ee2786d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursive inlining for non-inline functions.</source>
          <target state="translated">Максимальная глубина рекурсивной вставки для нестрочных функций.</target>
        </trans-unit>
        <trans-unit id="20b08dcc7587be3ab6eef2848d7ad81b5a152655" translate="yes" xml:space="preserve">
          <source>The maximum length of a constant string for a builtin string cmp call eligible for inlining.</source>
          <target state="translated">Максимальная длина строки константы для вызова встроенной строки cmp,допустимой для встраивания.</target>
        </trans-unit>
        <trans-unit id="be0d3936975ebff6f26b92e20318105d1c7db49a" translate="yes" xml:space="preserve">
          <source>The maximum number of &amp;rsquo;after supernode&amp;rsquo; exploded nodes within the analyzer per supernode, before terminating analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e85e4670d6f7ac0961160fd225824b117f4e1d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;case&lt;/code&gt; values in a &lt;code&gt;switch&lt;/code&gt; statement (C90 6.6.4.2).</source>
          <target state="translated">Максимальное количество значений &lt;code&gt;case&lt;/code&gt; в операторе &lt;code&gt;switch&lt;/code&gt; (C90 6.6.4.2).</target>
        </trans-unit>
        <trans-unit id="0a2afaa6d3ae61c2d6492935df7934433f87eae8" translate="yes" xml:space="preserve">
          <source>The maximum number of SSA_NAME assignments to follow in determining a property of a variable such as its value. This limits the number of iterations or recursive calls GCC performs when optimizing certain statements or when determining their validity prior to issuing diagnostics.</source>
          <target state="translated">Максимальное количество присваиваний SSA_NAME для определения свойства переменной,такого как ее значение.Это ограничивает количество итераций или рекурсивных вызовов,выполняемых GCC при оптимизации определенных утверждений или при определении их действительности до выдачи диагностики.</target>
        </trans-unit>
        <trans-unit id="f915c9b0ddf0bbc0779c3cf7dd483c9574fb303a" translate="yes" xml:space="preserve">
          <source>The maximum number of artificial accesses that Scalar Replacement of Aggregates (SRA) will track, per one local variable, in order to facilitate copy propagation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfdd5d91556b4dd893a62b6a75874eee03cf513" translate="yes" xml:space="preserve">
          <source>The maximum number of assertions to add along the default edge of a switch statement during VRP.</source>
          <target state="translated">Максимальное количество утверждений для добавления по умолчанию по краю оператора переключения во время VRP.</target>
        </trans-unit>
        <trans-unit id="c6e6bc4dbd514d325e3c749eca0229393e1fb788" translate="yes" xml:space="preserve">
          <source>The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop. Larger values can exponentially increase compilation time.</source>
          <target state="translated">Максимальное количество попыток обратного хода,которое планировщик должен сделать при модульном планировании цикла.Большие значения могут экспоненциально увеличить время компиляции.</target>
        </trans-unit>
        <trans-unit id="018c7375a2caf17039c26fd694620cad7ebfaa5f" translate="yes" xml:space="preserve">
          <source>The maximum number of basic blocks on path that CSE considers.</source>
          <target state="translated">Максимальное количество основных блоков на пути,которое рассматривает CSE.</target>
        </trans-unit>
        <trans-unit id="c79967caf66fa10b13e953918175f64b9fd85351" translate="yes" xml:space="preserve">
          <source>The maximum number of best instructions in the ready list that are considered for renaming in the selective scheduler.</source>
          <target state="translated">Максимальное количество лучших инструкций в готовом списке,которые рассматриваются для переименования в селективном планировщике.</target>
        </trans-unit>
        <trans-unit id="79a02e3d5ce6c0b561178810954860635f75b277" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for interblock scheduling.</source>
          <target state="translated">Максимальное количество блоков в регионе для межблокового планирования.</target>
        </trans-unit>
        <trans-unit id="3225f5aa45adb6a455e07adb58dbc4331ca98962" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="translated">Максимальное количество блоков в регионе,которое должно учитываться для трубопроводов в селективном планировщике.</target>
        </trans-unit>
        <trans-unit id="d26d722dd2f733f712aeb0f605ec58066091d632" translate="yes" xml:space="preserve">
          <source>The maximum number of branches on the hot path through the peeled sequence.</source>
          <target state="translated">Максимальное количество ветвей на горячем пути через очищенную последовательность.</target>
        </trans-unit>
        <trans-unit id="d2fe875bfce475e08e430e98ccc72ad1afca879e" translate="yes" xml:space="preserve">
          <source>The maximum number of branches unswitched in a single loop.</source>
          <target state="translated">Максимальное количество ветвей,не отключенных в одном цикле.</target>
        </trans-unit>
        <trans-unit id="9965c595ccb073bed98dc2ae6e76b73f1d6e9fe2" translate="yes" xml:space="preserve">
          <source>The maximum number of conditional store pairs that can be sunk. Set to 0 if either vectorization (</source>
          <target state="translated">Максимальное количество пар условных магазинов,которые могут быть потоплены.Установите 0,если любая из векторизаций (</target>
        </trans-unit>
        <trans-unit id="126cc6769740c4d71bac9ace9af0b249f19d3967" translate="yes" xml:space="preserve">
          <source>The maximum number of declarators that may modify an arithmetic, structure or union type (C90 6.5.4).</source>
          <target state="translated">Максимальное число деклараторов,которые могут изменить арифметику,структуру или тип союза (С90 6.5.4).</target>
        </trans-unit>
        <trans-unit id="4d5793f890c15f6b518ebfeeddd6bdf92fc933a4" translate="yes" xml:space="preserve">
          <source>The maximum number of exploded nodes per program point within the analyzer, before terminating analysis of that point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046b54d8dec00a923499bbe98f2011a4caa2c4d1" translate="yes" xml:space="preserve">
          <source>The maximum number of incoming edges to consider for cross-jumping. The algorithm used by</source>
          <target state="translated">Максимальное количество входящих кроссов для перекрестных прыжков.Алгоритм,используемый</target>
        </trans-unit>
        <trans-unit id="23db9a7b1aa156bfdeb79b1a74ceb92745f99df4" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for interblock scheduling.</source>
          <target state="translated">Максимальное количество вставок в регионе для межблочного планирования.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
