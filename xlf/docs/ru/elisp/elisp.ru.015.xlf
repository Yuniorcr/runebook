<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="297514168ef2ea3e190861ad8aed9621b2bf0fde" translate="yes" xml:space="preserve">
          <source>The following functions replace characters within a specified region based on their character codes.</source>
          <target state="translated">Следующие функции заменяют символы в пределах указанного региона на основе их символьных кодов.</target>
        </trans-unit>
        <trans-unit id="8ef4900912dcb434358d1e1cc34146dd4ae71b7f" translate="yes" xml:space="preserve">
          <source>The following functions return a window which satisfies some criterion, without selecting it:</source>
          <target state="translated">Следующие функции возвращают окно,которое удовлетворяет определенному критерию,без его выбора:</target>
        </trans-unit>
        <trans-unit id="6c1b3a2ec1e9d599ce858d9c865cc30d35b9cfbd" translate="yes" xml:space="preserve">
          <source>The following functions return window positions in pixels, rather than character units. Though mostly useful on graphical displays, they can also be called on text terminals, where the screen area of each text character is taken to be one pixel.</source>
          <target state="translated">Следующие функции возвращают позиции окна в пикселях,а не в символьных единицах.Хотя в основном они полезны на графических дисплеях,их также можно вызывать на текстовых терминалах,где область экрана каждого текстового символа принимается за один пиксель.</target>
        </trans-unit>
        <trans-unit id="f2f37ec3b726c43a4c87205d55e42808f4009de8" translate="yes" xml:space="preserve">
          <source>The following functions return window positions in pixels, relative to the origin of the display screen rather than that of the frame:</source>
          <target state="translated">Следующие функции возвращают позиции окна в пикселях относительно начала экрана дисплея,а не рамки:</target>
        </trans-unit>
        <trans-unit id="155cd68525e1e78f8dc1877edd4a3b4cc3b3b32f" translate="yes" xml:space="preserve">
          <source>The following is a list of metadata entries that a completion function may return in response to a &lt;code&gt;metadata&lt;/code&gt; flag argument:</source>
          <target state="translated">Ниже приводится список записей метаданных, которые функция завершения может возвращать в ответ на аргумент флага &lt;code&gt;metadata&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4a1e6d11578135dd2c40c588ed3ccefbb4f97f26" translate="yes" xml:space="preserve">
          <source>The following is a list of properties that are meaningful for all image types (there are also properties which are meaningful only for certain image types, as documented in the following subsections):</source>
          <target state="translated">Ниже приведен список свойств,которые имеют значение для всех типов изображений (также есть свойства,которые имеют значение только для определенных типов изображений,как описано в следующих подразделах):</target>
        </trans-unit>
        <trans-unit id="4093aee444ad060f90230a5ef648f614d3a0ca58" translate="yes" xml:space="preserve">
          <source>The following is a list of some hook variables that let you provide functions to be called from within Emacs on suitable occasions.</source>
          <target state="translated">Ниже приведен список некоторых переменных перехвата,которые позволяют вызывать функции из Emacs в подходящих случаях.</target>
        </trans-unit>
        <trans-unit id="ccb2830cf31ad8ceb9e30c7ff4ee6d68c4873ecb" translate="yes" xml:space="preserve">
          <source>The following list of conventions is only partial. Each major mode should aim for consistency in general with other Emacs major modes, as this makes Emacs as a whole more coherent. It is impossible to list here all the possible points where this issue might come up; if the Emacs developers point out an area where your major mode deviates from the usual conventions, please make it compatible.</source>
          <target state="translated">Следующий список конвенций является неполным.Каждый основной режим должен быть направлен на согласованность в целом с другими основными режимами Emacs,так как это делает Emacs в целом более согласованным.Здесь невозможно перечислить все возможные моменты,в которых может возникнуть эта проблема;если разработчики Emacs укажут область,в которой ваш основной режим отличается от обычных конвенций,пожалуйста,сделайте его совместимым.</target>
        </trans-unit>
        <trans-unit id="2f4c46986c8a870fb9516c70d5b6f51ae0a91573" translate="yes" xml:space="preserve">
          <source>The following macro provides a convenient way to define pop-up menus and/or menu bar menus.</source>
          <target state="translated">Следующий макрос обеспечивает удобный способ определения всплывающих меню и/или меню панели меню.</target>
        </trans-unit>
        <trans-unit id="5ad57c1f83c65077036b934b7fd3727e3ea0f239" translate="yes" xml:space="preserve">
          <source>The following macros should be used in the body of a function defined by &lt;code&gt;define-inline&lt;/code&gt;.</source>
          <target state="translated">Следующие макросы следует использовать в теле функции, определенной с помощью &lt;code&gt;define-inline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61cd8af7f02eeb28f4ce378e89ac8b778f999f77" translate="yes" xml:space="preserve">
          <source>The following network options can be specified when you create a network process. Except for &lt;code&gt;:reuseaddr&lt;/code&gt;, you can also set or modify these options later, using &lt;code&gt;set-network-process-option&lt;/code&gt;.</source>
          <target state="translated">При создании сетевого процесса можно указать следующие параметры сети. За исключением &lt;code&gt;:reuseaddr&lt;/code&gt; , вы также можете установить или изменить эти параметры позже, используя &lt;code&gt;set-network-process-option&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2fc598c57ec7c3805d2638d2b8b8ee1d26d24c" translate="yes" xml:space="preserve">
          <source>The following option allows to automatically select the window under the mouse pointer. This accomplishes a policy similar to that of window managers that give focus to a frame (and thus trigger its subsequent selection) whenever the mouse pointer enters its window-system window (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">Следующая опция позволяет автоматически выбирать окно под курсором мыши. Это реализует политику, аналогичную политике оконных менеджеров, которые дают фокус кадру (и, таким образом, запускают его последующий выбор) всякий раз, когда указатель мыши входит в его окно оконной системы (см. &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Фокус ввода&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d7851e2664e5c756dae87ae16e5d4cb14feb40f7" translate="yes" xml:space="preserve">
          <source>The following option specifies how to deal with a frame containing just one window that should be either quit, or whose buffer should be buried.</source>
          <target state="translated">Следующая опция определяет,как работать с фреймом,содержащим только одно окно,которое должно либо выйти,либо чей буфер должен быть закопан.</target>
        </trans-unit>
        <trans-unit id="ada5ff929af79df9bfadbae1b79b7910e6c1c8cf" translate="yes" xml:space="preserve">
          <source>The following options affect some aspects of the startup sequence.</source>
          <target state="translated">Следующие варианты влияют на некоторые аспекты последовательности ввода в эксплуатацию.</target>
        </trans-unit>
        <trans-unit id="e1aec0ad769964195d8b0b82e98cb13200879f29" translate="yes" xml:space="preserve">
          <source>The following options provide additional control over the placement of side windows.</source>
          <target state="translated">Следующие опции обеспечивают дополнительный контроль над размещением боковых окон.</target>
        </trans-unit>
        <trans-unit id="0d184dd753268c287e714dc96de749f048d0308b" translate="yes" xml:space="preserve">
          <source>The following parameters are currently used by the window management code:</source>
          <target state="translated">Следующие параметры в настоящее время используются кодом управления окном:</target>
        </trans-unit>
        <trans-unit id="bbb0060fafb1b1a12e73884154b4dd11377c3b26" translate="yes" xml:space="preserve">
          <source>The following parameters are supported:</source>
          <target state="translated">Поддерживаются следующие параметры:</target>
        </trans-unit>
        <trans-unit id="4f59f6941bde6c4db5d1e3e41b34d7afbaba9370" translate="yes" xml:space="preserve">
          <source>The following piece of code demonstrates some important principles of working with iterators.</source>
          <target state="translated">Следующая часть кода демонстрирует некоторые важные принципы работы с итераторами.</target>
        </trans-unit>
        <trans-unit id="a4f0eab4462560047e86c6b11d762d5644d33c5b" translate="yes" xml:space="preserve">
          <source>The following predicates test whether a Lisp object is an atom, whether it is a cons cell or is a list, or whether it is the distinguished object &lt;code&gt;nil&lt;/code&gt;. (Many of these predicates can be defined in terms of the others, but they are used so often that it is worth having them.)</source>
          <target state="translated">Следующие предикаты проверяют, является ли объект Lisp атомом, является ли он cons-ячейкой или списком, или же это выделенный объект &lt;code&gt;nil&lt;/code&gt; . (Многие из этих предикатов можно определить в терминах других, но они используются настолько часто, что их стоит иметь.)</target>
        </trans-unit>
        <trans-unit id="826b4fe071d5c29efd8caca96b29fad3a0a2f2d1" translate="yes" xml:space="preserve">
          <source>The following properties have special meaning:</source>
          <target state="translated">Следующие свойства имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="ebef11ee154eef7f4eb1fc917c2aac083fcb211f" translate="yes" xml:space="preserve">
          <source>The following properties have special meanings:</source>
          <target state="translated">Следующие свойства имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="57c6bef4e378aea04508546ae08d21653ab1f737" translate="yes" xml:space="preserve">
          <source>The following regular expression constructs match the empty string&amp;mdash;that is, they don&amp;rsquo;t use up any characters&amp;mdash;but whether they match depends on the context. For all, the beginning and end of the accessible portion of the buffer are treated as if they were the actual beginning and end of the buffer.</source>
          <target state="translated">Следующие конструкции регулярных выражений соответствуют пустой строке, т. Е. Не используют никаких символов, но их соответствие зависит от контекста. Для всех начало и конец доступной части буфера обрабатываются так, как если бы они были фактическим началом и концом буфера.</target>
        </trans-unit>
        <trans-unit id="ab93757b1beab2aa1b514e6ad4b5403f0cf390d7" translate="yes" xml:space="preserve">
          <source>The following sample code shows a simple use of &lt;code&gt;abbrev-expand-function&lt;/code&gt;. It assumes that &lt;code&gt;foo-mode&lt;/code&gt; is a mode for editing certain files in which lines that start with &amp;lsquo;</source>
          <target state="translated">В следующем примере кода показано простое использование функции &lt;code&gt;abbrev-expand-function&lt;/code&gt; . Предполагается, что &lt;code&gt;foo-mode&lt;/code&gt; - это режим редактирования определенных файлов, в которых строки начинаются с '</target>
        </trans-unit>
        <trans-unit id="cd3bff5b4b8d36513361c4cb174579259d0a14c3" translate="yes" xml:space="preserve">
          <source>The following schematic shows the structure of a live window:</source>
          <target state="translated">Следующая схема показывает структуру живого окна:</target>
        </trans-unit>
        <trans-unit id="3812318991beb737b8ecfc0d3eb9bffa47526a30" translate="yes" xml:space="preserve">
          <source>The following sections describe how to create a package, and how to put it in a &lt;em&gt;package archive&lt;/em&gt; for others to download. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages&quot;&gt;Packages&lt;/a&gt; in</source>
          <target state="translated">В следующих разделах описывается, как создать пакет и как поместить его в &lt;em&gt;архив пакетов&lt;/em&gt; для загрузки другими пользователями. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages&quot;&gt;Пакеты&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="383d4b031e697c8a763f63ab5f2f0872562209fa" translate="yes" xml:space="preserve">
          <source>The following sections describe how to create a package, and how to put it in a &lt;em&gt;package archive&lt;/em&gt; for others to download. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages&quot;&gt;Packages&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f5eb5126f13e48e5d8a4cfa1f8a337e3e76816" translate="yes" xml:space="preserve">
          <source>The following subsections describe dynamic binding and lexical binding in greater detail, and how to enable lexical binding in Emacs Lisp programs.</source>
          <target state="translated">Следующие подразделы более подробно описывают динамическое связывание и лексическое связывание,а также то,как включить лексическое связывание в программах Emacs Lisp.</target>
        </trans-unit>
        <trans-unit id="f427796ad98b404b1017d94a966c0d6e0b800693" translate="yes" xml:space="preserve">
          <source>The following subsections describe these tasks and the</source>
          <target state="translated">Следующие подразделы описывают эти задачи и</target>
        </trans-unit>
        <trans-unit id="557e3858b495db8eb07b06d74c4bda7f399bc1fd" translate="yes" xml:space="preserve">
          <source>The following three functions are convenient subroutines for packages that define non-</source>
          <target state="translated">Следующие три функции являются удобными подпрограммами для пакетов,которые определяют non-</target>
        </trans-unit>
        <trans-unit id="536c73ef47f549795a27c13372e2ba64eb41c149" translate="yes" xml:space="preserve">
          <source>The following three functions are like &lt;code&gt;memq&lt;/code&gt;, &lt;code&gt;delq&lt;/code&gt; and &lt;code&gt;remq&lt;/code&gt;, but use &lt;code&gt;equal&lt;/code&gt; rather than &lt;code&gt;eq&lt;/code&gt; to compare elements. See &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicates&lt;/a&gt;.</source>
          <target state="translated">Следующие три функции похожи на &lt;code&gt;memq&lt;/code&gt; , &lt;code&gt;delq&lt;/code&gt; и &lt;code&gt;remq&lt;/code&gt; , но для сравнения элементов используются &lt;code&gt;equal&lt;/code&gt; а не &lt;code&gt;eq&lt;/code&gt; . См. &amp;laquo; &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Предикаты равенства&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="355f4e1293b1c2362148cc63e3a7bedf8f34b49f" translate="yes" xml:space="preserve">
          <source>The following three functions take as argument a live frame which defaults to the selected one.</source>
          <target state="translated">Следующие три функции принимают в качестве аргумента живой кадр,который по умолчанию является выбранным.</target>
        </trans-unit>
        <trans-unit id="1f17162ac41b5c364770f2de0d633eda6a4b0b6a" translate="yes" xml:space="preserve">
          <source>The following three variables are used in &lt;code&gt;mode-line-modes&lt;/code&gt;:</source>
          <target state="translated">Следующие три переменные используются в &lt;code&gt;mode-line-modes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="29c7181d047de2cd97f0970a6987cb63e7fbbb89" translate="yes" xml:space="preserve">
          <source>The following three variables, when non-&lt;code&gt;nil&lt;/code&gt;, cause the second method to be used in certain special cases. They have no effect on the treatment of files that don&amp;rsquo;t fall into the special cases.</source>
          <target state="translated">Следующие три переменные, если они не &lt;code&gt;nil&lt;/code&gt; , вызывают использование второго метода в определенных особых случаях. Они не влияют на обработку файлов, не относящихся к особым случаям.</target>
        </trans-unit>
        <trans-unit id="115768852bac8cdf35b7fa82a90cdf33ddc11555" translate="yes" xml:space="preserve">
          <source>The following two &lt;code&gt;%&lt;/code&gt;-constructs are still supported, but they are obsolete, since you can get the same results with the variables &lt;code&gt;mode-name&lt;/code&gt; and &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">Следующие две &lt;code&gt;%&lt;/code&gt; -конструкции по-прежнему поддерживаются, но они устарели, поскольку вы можете получить те же результаты с помощью переменных &lt;code&gt;mode-name&lt;/code&gt; &lt;code&gt;global-mode-string&lt;/code&gt; и глобальная-строка-режима .</target>
        </trans-unit>
        <trans-unit id="c8bf40b8538d6f6330c64f3c882e6c1bcb9062c8" translate="yes" xml:space="preserve">
          <source>The following two functions are meant for modes that want to provide help without relinquishing control, such as the electric modes. Their names begin with &amp;lsquo;</source>
          <target state="translated">Следующие две функции предназначены для режимов, в которых требуется помощь без отказа от управления, например для электрических режимов. Их имена начинаются с '</target>
        </trans-unit>
        <trans-unit id="1abd9368a3d734825a10efb49b4dabc426bea1a2" translate="yes" xml:space="preserve">
          <source>The following two functions are useful for combining a list of individual command-line argument strings into a single string, and taking a string apart into a list of individual command-line arguments. These functions are mainly intended for converting user input in the minibuffer, a Lisp string, into a list of string arguments to be passed to &lt;code&gt;make-process&lt;/code&gt;, &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, or for converting such lists of arguments into a single Lisp string to be presented in the minibuffer or echo area. Note that if a shell is involved (e.g., if using &lt;code&gt;call-process-shell-command&lt;/code&gt;), arguments should still be protected by &lt;code&gt;shell-quote-argument&lt;/code&gt;; &lt;code&gt;combine-and-quote-strings&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; intended to protect special characters from shell evaluation.</source>
          <target state="translated">Следующие две функции полезны для объединения списка отдельных строк аргументов командной строки в одну строку и разделения строки на список отдельных аргументов командной строки. Эти функции в основном предназначены для преобразования пользовательского ввода в минибуфер, строки Лиспа, в список строковых аргументов, передаваемых в &lt;code&gt;make-process&lt;/code&gt; , &lt;code&gt;call-process&lt;/code&gt; или &lt;code&gt;start-process&lt;/code&gt; , или для преобразования таких списков аргументов в единый Лисп. строка, которая будет представлена ​​в минибуфере или эхо-области. Обратите внимание, что если задействована оболочка (например, при использовании команды &lt;code&gt;call-process-shell-command&lt;/code&gt; ), аргументы все равно должны быть защищены &lt;code&gt;shell-quote-argument&lt;/code&gt; ; &lt;code&gt;combine-and-quote-strings&lt;/code&gt; это &lt;em&gt;не&lt;/em&gt; предназначен для защиты специальных символов от оценки оболочки.</target>
        </trans-unit>
        <trans-unit id="345ce9209913e7b713026911f4f5e94a02bd44b6" translate="yes" xml:space="preserve">
          <source>The following two functions are useful when a Lisp program needs to map buffer positions to byte offsets in a file visited by the buffer.</source>
          <target state="translated">Следующие две функции полезны,когда программе на языке Lisp необходимо сопоставить позиции буфера со смещениями байт в файле,посещаемом буфером.</target>
        </trans-unit>
        <trans-unit id="f6e12a6446862c2522d3f1a9ffd8ddf8904cc177" translate="yes" xml:space="preserve">
          <source>The following two functions can be used to return the total size of a window in units of pixels.</source>
          <target state="translated">Следующие две функции могут быть использованы для возврата общего размера окна в единицах пикселей.</target>
        </trans-unit>
        <trans-unit id="a48c7947820ecbb53fcfdd25e5c96ba5864b3d86" translate="yes" xml:space="preserve">
          <source>The following two functions can be useful when working with child and parent frames:</source>
          <target state="translated">Следующие две функции могут быть полезны при работе с дочерними и родительскими кадрами:</target>
        </trans-unit>
        <trans-unit id="2a83b06e67c6529bbdbddb0d5afbb5cf809d5bcc" translate="yes" xml:space="preserve">
          <source>The following two functions convert between directory names and directory file names. They do nothing special with environment variable substitutions such as &amp;lsquo;</source>
          <target state="translated">Следующие две функции преобразуют имена каталогов в имена файлов каталогов. Они не делают ничего особенного с заменами переменных среды, такими как '</target>
        </trans-unit>
        <trans-unit id="4fac544aa9936ae6c2b6929f4306babf281bddd4" translate="yes" xml:space="preserve">
          <source>The following two functions move point over a specified set of characters. For example, they are often used to skip whitespace. For related functions, see &lt;a href=&quot;motion-and-syntax#Motion-and-Syntax&quot;&gt;Motion and Syntax&lt;/a&gt;.</source>
          <target state="translated">Следующие две функции перемещают точку по указанному набору символов. Например, они часто используются для пропуска пробелов. Для связанных функций см. &lt;a href=&quot;motion-and-syntax#Motion-and-Syntax&quot;&gt;Движение и Синтаксис&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c338e0f1681bbeb0ada6c9b11a1251284be5bda" translate="yes" xml:space="preserve">
          <source>The following two functions return a mouse position list (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), specifying the position of a mouse event.</source>
          <target state="translated">Следующие две функции возвращают список положений мыши (см. &amp;laquo; &lt;a href=&quot;click-events#Click-Events&quot;&gt;События щелчка&amp;raquo;&lt;/a&gt; ), определяя положение события мыши.</target>
        </trans-unit>
        <trans-unit id="cc0b4c0c74f55c58b403e95e6a1acfb6ff12b20c" translate="yes" xml:space="preserve">
          <source>The following two functions return important information about a font.</source>
          <target state="translated">Следующие две функции возвращают важную информацию о шрифте.</target>
        </trans-unit>
        <trans-unit id="1e7e472e6478094296cd45e3d521f50016cac3a3" translate="yes" xml:space="preserve">
          <source>The following two options control whether minibuffer windows are resized automatically and how large they can get in the process.</source>
          <target state="translated">Следующие два варианта контролируют автоматическое изменение размера окон минибуфера и их размер.</target>
        </trans-unit>
        <trans-unit id="24fa8abe9618c4cb6b7db987de4f0d9cacb7fa8f" translate="yes" xml:space="preserve">
          <source>The following two regular expressions should &lt;em&gt;not&lt;/em&gt; assume the match always starts at the beginning of a line; they should not use &amp;lsquo;</source>
          <target state="translated">Следующие два регулярных выражения &lt;em&gt;не&lt;/em&gt; должны предполагать, что совпадение всегда начинается в начале строки; они не должны использовать '</target>
        </trans-unit>
        <trans-unit id="cc6bf9832061e83897200953f3dd12c79d5af846" translate="yes" xml:space="preserve">
          <source>The following two variables are obsoleted by &lt;code&gt;filter-buffer-substring-function&lt;/code&gt;, but are still supported for backward compatibility.</source>
          <target state="translated">Следующие две переменные устарели &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; , но все еще поддерживаются для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="4d489eae93ac203d9b2ffd3584656c2dde948029" translate="yes" xml:space="preserve">
          <source>The following values are respected:</source>
          <target state="translated">Соблюдаются следующие ценности:</target>
        </trans-unit>
        <trans-unit id="09aa9057414e7950dd19147648c16cf90861056f" translate="yes" xml:space="preserve">
          <source>The following variables affect how certain characters are displayed on the screen. Since they change the number of columns the characters occupy, they also affect the indentation functions. They also affect how the mode line is displayed; if you want to force redisplay of the mode line using the new values, call the function &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">Следующие переменные влияют на то, как определенные символы отображаются на экране. Поскольку они изменяют количество столбцов, которые занимают символы, они также влияют на функции отступа. Они также влияют на то, как отображается строка режима; если вы хотите принудительно повторно отобразить строку режима с использованием новых значений, вызовите функцию &lt;code&gt;force-mode-line-update&lt;/code&gt; (см. &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Формат строки режима&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="14dec20b7fbc6fcced5e5d29086ee55e867ebdd4" translate="yes" xml:space="preserve">
          <source>The following will create a linear gradient that goes from red at the start, to green 25% of the way, to blue at the end:</source>
          <target state="translated">Следующее создаст линейный градиент,который переходит от красного в начале,к зеленому 25% пути,к синему в конце:</target>
        </trans-unit>
        <trans-unit id="e95288a0f9a444d98e8a41cba18b24ae66da9ad1" translate="yes" xml:space="preserve">
          <source>The font must be an OpenType font that supports these OpenType features, provided Emacs is compiled with a library, such as &amp;lsquo;</source>
          <target state="translated">Шрифт должен быть шрифтом OpenType, который поддерживает эти функции OpenType, при условии, что Emacs скомпилирован с библиотекой, такой как '</target>
        </trans-unit>
        <trans-unit id="6556801bce4e544f06ab7ea9eb5f7746cb4afd5e" translate="yes" xml:space="preserve">
          <source>The font name (a string), in either XLFD, Fontconfig, or GTK+ format. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">Имя шрифта (строка) в формате XLFD, Fontconfig или GTK +. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Шрифты&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="2bc704bf2b2bbc2442021c0c06a953c0e26b4f52" translate="yes" xml:space="preserve">
          <source>The font name (a string), in either XLFD, Fontconfig, or GTK+ format. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0bd798857380a819581a44d67b89d6f115632d" translate="yes" xml:space="preserve">
          <source>The font name, a string.</source>
          <target state="translated">Имя шрифта,строка.</target>
        </trans-unit>
        <trans-unit id="a7248edb376ccd7b3b10bb9e3cb840736177f911" translate="yes" xml:space="preserve">
          <source>The font size&amp;mdash;either a non-negative integer that specifies the pixel size, or a floating-point number that specifies the point size.</source>
          <target state="translated">Размер шрифта - неотрицательное целое число, определяющее размер в пикселях, или число с плавающей запятой, определяющее размер точки.</target>
        </trans-unit>
        <trans-unit id="23f58ef9a79c9daa9a087fb25286120885af393b" translate="yes" xml:space="preserve">
          <source>The font used to display the face. Its value should be a font object or a fontset. See &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Low-Level Font&lt;/a&gt;, for information about font objects, font specs, and font entities. See &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;, for information about fontsets.</source>
          <target state="translated">Шрифт, используемый для отображения лица. Его значение должно быть объектом шрифта или набором шрифтов. См. &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Низкоуровневый шрифт&lt;/a&gt; для получения информации об объектах шрифтов, спецификациях шрифтов и объектах шрифтов. См. &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Наборы шрифтов&lt;/a&gt; для получения информации о наборах шрифтов.</target>
        </trans-unit>
        <trans-unit id="3e2495d3f6b500a7c3764a7896dc703df930eb34" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(+ &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; adds up the value of the expressions. The form &lt;code&gt;(- &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; negates or subtracts the value of the expressions.</source>
          <target state="translated">Форма &lt;code&gt;(+ &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; суммирует значения выражений. Форма &lt;code&gt;(- &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; отрицает или вычитает значение выражений.</target>
        </trans-unit>
        <trans-unit id="f9074ede26f7f654c16278889f1f4de2d0cebbf4" translate="yes" xml:space="preserve">
          <source>The form &lt;var&gt;num&lt;/var&gt; specifies a fraction of the default frame font height or width. The form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt;)&lt;/code&gt; specifies an absolute number of pixels. If &lt;var&gt;num&lt;/var&gt; is a symbol, &lt;var&gt;symbol&lt;/var&gt;, its buffer-local variable binding is used; that binding can be either a number or a cons cell of the forms shown above (including yet another cons cell whose &lt;code&gt;car&lt;/code&gt; is a symbol that has a buffer-local binding).</source>
          <target state="translated">Форма &lt;var&gt;num&lt;/var&gt; определяет долю высоты или ширины шрифта рамки по умолчанию. Форма &lt;code&gt;(&lt;var&gt;num&lt;/var&gt;)&lt;/code&gt; указывает абсолютное количество пикселей. Если &lt;var&gt;num&lt;/var&gt; является символом, &lt;var&gt;symbol&lt;/var&gt; , используется его привязка к локальной переменной в буфере; эта привязка может быть числом или cons-ячейкой форм, показанных выше (включая еще одну cons-ячейку, &lt;code&gt;car&lt;/code&gt; которой является символом, имеющим локальную привязку к буферу).</target>
        </trans-unit>
        <trans-unit id="eefdf767b9da94cedb2272c4d442fd16a210f77a" translate="yes" xml:space="preserve">
          <source>The format of &lt;var&gt;local-address&lt;/var&gt; or &lt;var&gt;remote-address&lt;/var&gt; depends on the address family:</source>
          <target state="translated">Формат &lt;var&gt;local-address&lt;/var&gt; или &lt;var&gt;remote-address&lt;/var&gt; зависит от семейства адресов:</target>
        </trans-unit>
        <trans-unit id="f1523839ef4d5afd7ac94bcc51e58e0b20efc3f4" translate="yes" xml:space="preserve">
          <source>The format of this list is the same as what &lt;code&gt;decode-time&lt;/code&gt; accepts (see &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;), and is described in more detail there. Any element that cannot be determined from the input will be set to &lt;code&gt;nil&lt;/code&gt;. The argument &lt;var&gt;string&lt;/var&gt; should resemble an RFC 822 (or later) or ISO 8601 string, like &amp;ldquo;Fri, 25 Mar 2016 16:24:56 +0100&amp;rdquo; or &amp;ldquo;1998-09-12T12:21:54-0200&amp;rdquo;, but this function will attempt to parse less well-formed time strings as well.</source>
          <target state="translated">Формат этого списка совпадает с форматом, который принимает &lt;code&gt;decode-time&lt;/code&gt; (см. &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Преобразование времени&lt;/a&gt; ), и описан там более подробно. Любой элемент, который не может быть определен из ввода, будет установлен в &lt;code&gt;nil&lt;/code&gt; . &lt;var&gt;string&lt;/var&gt; аргумента должна напоминать строку RFC 822 (или новее) или ISO 8601, например &amp;laquo;Пятница, 25 марта 2016 16:24:56 +0100&amp;raquo; или &amp;laquo;1998-09-12T12: 21: 54-0200&amp;raquo;, но эта функция также попытается проанализировать менее правильно сформированные строки времени.</target>
        </trans-unit>
        <trans-unit id="a420ccf20ba6d5b4c425fdd899162dfbbd53605d" translate="yes" xml:space="preserve">
          <source>The format we use for buffer contents in examples.</source>
          <target state="translated">Формат,который мы используем для содержимого буфера в примерах.</target>
        </trans-unit>
        <trans-unit id="4a56368511816baafb987e4550f7fd019ef9406d" translate="yes" xml:space="preserve">
          <source>The format we use for examples of errors.</source>
          <target state="translated">Формат,который мы используем для примеров ошибок.</target>
        </trans-unit>
        <trans-unit id="39ba77d521c50dab220364437e7b5dabde639177" translate="yes" xml:space="preserve">
          <source>The format we use for examples of evaluation.</source>
          <target state="translated">Формат,который мы используем для примеров оценки.</target>
        </trans-unit>
        <trans-unit id="37518e914cc1faa1cdf2b3e15db2c5a92c8aeff9" translate="yes" xml:space="preserve">
          <source>The format we use when examples print text.</source>
          <target state="translated">Формат,который мы используем,когда примеры печатают текст.</target>
        </trans-unit>
        <trans-unit id="17e1d52af71f6c32ba5e92306abc4c53f00bf057" translate="yes" xml:space="preserve">
          <source>The former is used by overlay arrows. The latter is unused.</source>
          <target state="translated">Первый используется стрелками наложения.Вторая не используется.</target>
        </trans-unit>
        <trans-unit id="203096a174bb892e518022e452e96010dd9a8b89" translate="yes" xml:space="preserve">
          <source>The forms &lt;var&gt;pre-form&lt;/var&gt; and &lt;var&gt;post-form&lt;/var&gt; can be used to initialize before, and cleanup after, &lt;var&gt;anchored-matcher&lt;/var&gt; is used. Typically, &lt;var&gt;pre-form&lt;/var&gt; is used to move point to some position relative to the match of &lt;var&gt;matcher&lt;/var&gt;, before starting with &lt;var&gt;anchored-matcher&lt;/var&gt;. &lt;var&gt;post-form&lt;/var&gt; might be used to move back, before resuming with &lt;var&gt;matcher&lt;/var&gt;.</source>
          <target state="translated">Формы &lt;var&gt;pre-form&lt;/var&gt; и &lt;var&gt;post-form&lt;/var&gt; могут использоваться для инициализации до и очистки после использования &lt;var&gt;anchored-matcher&lt;/var&gt; . Как правило, &lt;var&gt;pre-form&lt;/var&gt; используется для перемещения точки в некоторую позицию относительно соответствия &lt;var&gt;matcher&lt;/var&gt; перед запуском с &lt;var&gt;anchored-matcher&lt;/var&gt; . &lt;var&gt;post-form&lt;/var&gt; может использоваться для возврата перед возобновлением с помощью &lt;var&gt;matcher&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ceadb637a596eb2ee47bea0bcd88b1125c133ad0" translate="yes" xml:space="preserve">
          <source>The fourth argument &lt;var&gt;parents&lt;/var&gt; says whether to create parent directories if they don&amp;rsquo;t exist. Interactively, this happens by default.</source>
          <target state="translated">Четвертый аргумент &lt;var&gt;parents&lt;/var&gt; говорят, создавать ли родительские каталоги, если они не существуют. В интерактивном режиме это происходит по умолчанию.</target>
        </trans-unit>
        <trans-unit id="49ca71782e46f41b945559e28fbf6e1d7928a06f" translate="yes" xml:space="preserve">
          <source>The fourth element is the buffer whose display caused the creation of this parameter. This function may delete &lt;var&gt;window&lt;/var&gt; if and only if it still shows that buffer.</source>
          <target state="translated">Четвертый элемент - буфер, отображение которого вызвало создание этого параметра. Эта функция может удалить &lt;var&gt;window&lt;/var&gt; тогда и только тогда, когда он все еще показывает этот буфер.</target>
        </trans-unit>
        <trans-unit id="d53d197ac8b2d3804741dce6c2249997a484aa11" translate="yes" xml:space="preserve">
          <source>The fourth of these hooks is run when a &lt;em&gt;window state change&lt;/em&gt; has been detected, which means that at least one of the three preceding window changes has occurred.</source>
          <target state="translated">Четвертая из этих ловушек запускается при обнаружении &lt;em&gt;изменения состояния окна&lt;/em&gt; , что означает, что произошло по крайней мере одно из трех предыдущих изменений окна.</target>
        </trans-unit>
        <trans-unit id="d2076a0c8c9f8876e127e6de37bf8d5c9fd0314f" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a GNUstep or Macintosh Cocoa graphical terminal.</source>
          <target state="translated">Рамка отображается на графическом терминале GNUstep или Macintosh Cocoa.</target>
        </trans-unit>
        <trans-unit id="367eb419b499e34c2cd9b561d4ff309824830d6d" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a MS-Windows graphical terminal.</source>
          <target state="translated">Рамка отображается на графическом терминале MS-Windows.</target>
        </trans-unit>
        <trans-unit id="bd7f603302ec782d1f108752979a4bc3b06f4239" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a text terminal.</source>
          <target state="translated">Рамка отображается на текстовом терминале.</target>
        </trans-unit>
        <trans-unit id="fcb9d54a78150d03f883ce9267fb2578c072d2bd" translate="yes" xml:space="preserve">
          <source>The frame is displayed on an MS-DOS terminal.</source>
          <target state="translated">Рамка отображается на терминале MS-DOS.</target>
        </trans-unit>
        <trans-unit id="0cd07edbb9f4b3175639e8806bf60c5f910fe981" translate="yes" xml:space="preserve">
          <source>The frame is displayed on an X graphical terminal.</source>
          <target state="translated">Рамка отображается на графическом терминале X.</target>
        </trans-unit>
        <trans-unit id="fede82ee27758855ee100077f5a256f38ab0e02a" translate="yes" xml:space="preserve">
          <source>The frame parameter &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; controls whether the windows in the frame have horizontal scroll bars. The frame parameter &lt;code&gt;scroll-bar-height&lt;/code&gt; specifies how high they are (&lt;code&gt;nil&lt;/code&gt; meaning the default). See &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;.</source>
          <target state="translated">Параметр frame &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; определяет, есть ли в окнах во фрейме горизонтальные полосы прокрутки. Параметр frame &lt;code&gt;scroll-bar-height&lt;/code&gt; указывает их высоту ( &lt;code&gt;nil&lt;/code&gt; означает значение по умолчанию). См. &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Параметры макета&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="438a2d89a52bbe188d6d849c93e8088d3f1e967a" translate="yes" xml:space="preserve">
          <source>The frame that this window is on, as a Lisp object.</source>
          <target state="translated">Рамка,на которой находится это окно,как объект Lisp.</target>
        </trans-unit>
        <trans-unit id="f2ddf76bbb94fa6e3bd71370e008e9006e3aab9c" translate="yes" xml:space="preserve">
          <source>The frame with input focus might not take up the entire screen, and the user might move the mouse outside the scope of the frame. Inside the &lt;code&gt;track-mouse&lt;/code&gt; special form, that produces an event like this:</source>
          <target state="translated">Рамка с фокусом ввода может не занимать весь экран, и пользователь может переместить мышь за пределы рамки. Внутри специальной формы &lt;code&gt;track-mouse&lt;/code&gt; , которая генерирует подобное событие:</target>
        </trans-unit>
        <trans-unit id="875b4545e11911510ae3368c34f49d2bafeade1c" translate="yes" xml:space="preserve">
          <source>The frames can be used either to represent multiple pages (this is usually the case with multi-frame TIFF files, for example), or to create animation (usually the case with multi-frame GIF files).</source>
          <target state="translated">Кадры могут использоваться как для представления нескольких страниц (обычно это происходит,например,в многокадровых файлах TIFF),так и для создания анимации (обычно это происходит в многокадровых GIF-файлах).</target>
        </trans-unit>
        <trans-unit id="07c1bfad504d407e4dd4bddeff5e7e54de2cc8eb" translate="yes" xml:space="preserve">
          <source>The fringes normally appear between the display margins and the window text. If the value is non-&lt;code&gt;nil&lt;/code&gt;, they appear outside the display margins. See &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;.</source>
          <target state="translated">Полосы обычно появляются между полями отображения и текстом окна. Если значение не равно &lt;code&gt;nil&lt;/code&gt; , они появляются за пределами полей дисплея. См. Раздел &amp;laquo; &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Отображаемые поля&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10a232c8c99be2bcdac3d854a4c57a0b7926f249" translate="yes" xml:space="preserve">
          <source>The full keymap containing default global key bindings. Modes should not modify the Global map.</source>
          <target state="translated">Полная клавиатурная карта,содержащая привязки глобальных ключей по умолчанию.Режимы не должны изменять карту мира.</target>
        </trans-unit>
        <trans-unit id="ab21d625fa99d9e8689a87a9df340768d973d686" translate="yes" xml:space="preserve">
          <source>The full name of the font, a string.</source>
          <target state="translated">Полное имя шрифта,строка.</target>
        </trans-unit>
        <trans-unit id="55c491134e3f247e07eb606aa328fc5be9cb20cc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;accept-process-output&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt; if it got output from &lt;var&gt;process&lt;/var&gt;, or from any process if &lt;var&gt;process&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;; this can occur even after a process has exited if the corresponding connection contains buffered data. The function returns &lt;code&gt;nil&lt;/code&gt; if the timeout expired or the connection was closed before output arrived.</source>
          <target state="translated">Функция &lt;code&gt;accept-process-output&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; если она получила вывод от &lt;var&gt;process&lt;/var&gt; , или от любого процесса, если &lt;var&gt;process&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; ; это может произойти даже после выхода из процесса, если соответствующее соединение содержит буферизованные данные. Функция возвращает &lt;code&gt;nil&lt;/code&gt; если истекло время ожидания или соединение было закрыто до получения вывода.</target>
        </trans-unit>
        <trans-unit id="ec51fe801ce783ab41bbcfb2b068eb8495fcb6f6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;assoc-string&lt;/code&gt; is much like &lt;code&gt;assoc&lt;/code&gt; except that it ignores certain differences between strings. See &lt;a href=&quot;text-comparison#Text-Comparison&quot;&gt;Text Comparison&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;assoc-string&lt;/code&gt; очень похожа на &lt;code&gt;assoc&lt;/code&gt; , за исключением того, что она игнорирует определенные различия между строками. См. &lt;a href=&quot;text-comparison#Text-Comparison&quot;&gt;Сравнение текстов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2e7d56e51665dc0e2c86ee380cef89f5612161" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;backtrace-frame&lt;/code&gt; is intended for use in Lisp debuggers. It returns information about what computation is happening in the stack frame &lt;var&gt;frame-number&lt;/var&gt; levels down.</source>
          <target state="translated">Функция &lt;code&gt;backtrace-frame&lt;/code&gt; предназначена для использования в отладчиках Lisp. Он возвращает информацию о том, какие вычисления происходят в стеке на нижний уровень &lt;var&gt;frame-number&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="2a41471492f0d30da94cc86b34cd0a1d952ae5da" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;backward-prefix-chars&lt;/code&gt; moves back over these characters, as well as over characters whose primary syntax class is prefix (&amp;lsquo;</source>
          <target state="translated">Функция &lt;code&gt;backward-prefix-chars&lt;/code&gt; перемещается назад по этим символам, а также по символам, основным синтаксическим классом которых является prefix ('</target>
        </trans-unit>
        <trans-unit id="ff9303e475f1b984abb99f23fe5e1bde3414024c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; does not call these functions, since it ignores text properties anyway.</source>
          <target state="translated">Функция &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; не вызывает эти функции, так как в любом случае игнорирует текстовые свойства.</target>
        </trans-unit>
        <trans-unit id="ab0ed3a952ff9a1871cc2361e3809682f2c953e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;collapse-delayed-warnings&lt;/code&gt; removes repeated entries from &lt;code&gt;delayed-warnings-list&lt;/code&gt;. The function &lt;code&gt;display-delayed-warnings&lt;/code&gt; calls &lt;code&gt;display-warning&lt;/code&gt; on each of the entries in &lt;code&gt;delayed-warnings-list&lt;/code&gt;, in turn, and then sets &lt;code&gt;delayed-warnings-list&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;collapse-delayed-warnings&lt;/code&gt; удаляет повторяющиеся записи из &lt;code&gt;delayed-warnings-list&lt;/code&gt; . Функция &lt;code&gt;display-delayed-warnings&lt;/code&gt; вызывает &lt;code&gt;display-warning&lt;/code&gt; о каждом из записей в &lt;code&gt;delayed-warnings-list&lt;/code&gt; , в свою очередь, а затем устанавливает &lt;code&gt;delayed-warnings-list&lt;/code&gt; на &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aca3a04eca1514a9f44c05fb78a24a6564571ff6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;completing-read&lt;/code&gt; provides a higher-level interface for completion. A call to &lt;code&gt;completing-read&lt;/code&gt; specifies how to determine the list of valid names. The function then activates the minibuffer with a local keymap that binds a few keys to commands useful for completion. Other functions provide convenient simple interfaces for reading certain kinds of names with completion.</source>
          <target state="translated">Функция &lt;code&gt;completing-read&lt;/code&gt; предоставляет интерфейс более высокого уровня для завершения. Вызов функции &lt;code&gt;completing-read&lt;/code&gt; указывает, как определить список допустимых имен. Затем функция активирует минибуфер с локальной раскладкой клавиш, которая связывает несколько клавиш с командами, полезными для завершения. Другие функции предоставляют удобные простые интерфейсы для чтения определенных видов имен с завершением.</target>
        </trans-unit>
        <trans-unit id="743a6545ecb435ebd9f3de6185649c8ee66cb997" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;completing-read&lt;/code&gt; uses &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; as the keymap if &lt;var&gt;require-match&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and uses &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt; if &lt;var&gt;require-match&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Completion Commands&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;completing-read&lt;/code&gt; использует &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; как карту ключей, если &lt;var&gt;require-match&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , и использует &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt; если &lt;var&gt;require-match&lt;/var&gt; отличное от &lt;code&gt;nil&lt;/code&gt; . См. &amp;laquo; &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Команды завершения&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb114701d962dcc2e639c63a654e62af9ffd7c5a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coordinates-in-window-p&lt;/code&gt; does not require a frame as argument because it always uses the frame that &lt;var&gt;window&lt;/var&gt; is on.</source>
          <target state="translated">Функция &lt;code&gt;coordinates-in-window-p&lt;/code&gt; не требует фрейма в качестве аргумента, поскольку всегда использует фрейм, в котором находится &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b3ded67b9cd070ced5aa2445c9069b81dfc417" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current-kill&lt;/code&gt; rotates the yanking pointer, which designates the front of the kill ring, by &lt;var&gt;n&lt;/var&gt; places (from newer kills to older ones), and returns the text at that place in the ring.</source>
          <target state="translated">Функция &lt;code&gt;current-kill&lt;/code&gt; поворачивает указатель дергания, который обозначает переднюю часть кольца уничтожений, на &lt;var&gt;n&lt;/var&gt; мест (от новых убийств к старым) и возвращает текст в этом месте кольца.</target>
        </trans-unit>
        <trans-unit id="c09d1b87df08862239116751f48f0df4995d72f7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;default-boundp&lt;/code&gt; tells you whether &lt;var&gt;symbol&lt;/var&gt;&amp;rsquo;s default value is nonvoid. If &lt;code&gt;(default-boundp 'foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;(default-value 'foo)&lt;/code&gt; would get an error.</source>
          <target state="translated">Функция &lt;code&gt;default-boundp&lt;/code&gt; сообщает вам, является ли значение &lt;var&gt;symbol&lt;/var&gt; умолчанию недействительным. Если &lt;code&gt;(default-boundp 'foo)&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; , тогда &lt;code&gt;(default-value 'foo)&lt;/code&gt; получит ошибку.</target>
        </trans-unit>
        <trans-unit id="3d944e42054c18a15837fce5fb4f736d90edcbfc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;delete-other-windows&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to make the atomic window fill its frame or main window (see &lt;a href=&quot;side-windows#Side-Windows&quot;&gt;Side Windows&lt;/a&gt;).</source>
          <target state="translated">Функция &lt;code&gt;delete-other-windows&lt;/code&gt; (см. &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Раздел &amp;laquo;Удаление окон&amp;raquo;&lt;/a&gt; ) при применении к составной части атомарного окна будет пытаться заставить атомарное окно заполнить его фрейм или главное окно (см. &lt;a href=&quot;side-windows#Side-Windows&quot;&gt;Боковые окна&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9dffa9767ac8103870c396df1d01712edad9731f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;delete-window&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to delete the entire atomic window instead.</source>
          <target state="translated">Функция &lt;code&gt;delete-window&lt;/code&gt; (см. Раздел &amp;laquo; &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Удаление окон&amp;raquo;&lt;/a&gt; ), когда применяется к составной части атомарного окна, вместо этого будет пытаться удалить все атомарное окно.</target>
        </trans-unit>
        <trans-unit id="6dbf1bcd36e45950ad0668297034db25fc20918d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;elt&lt;/code&gt; is similar, but applies to any kind of sequence. For historical reasons, it takes its arguments in the opposite order. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;elt&lt;/code&gt; аналогична, но применима к любой последовательности. По историческим причинам он приводит аргументы в обратном порядке. См. &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Последовательные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53ea0623909a1543789ee0d4705170a49f5a1097" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;equal&lt;/code&gt; can also compare two window configurations; it regards configurations as unequal if they differ in any respect, even a saved point.</source>
          <target state="translated">Функция &lt;code&gt;equal&lt;/code&gt; также может сравнивать две конфигурации окон; он считает конфигурации неравными, если они различаются в каком-либо отношении, даже если они сохранены.</target>
        </trans-unit>
        <trans-unit id="15f22c5a8ef685b2d1157d55627f2e569a64550a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;foo&lt;/code&gt; subtracts &lt;var&gt;integer1&lt;/var&gt; from &lt;var&gt;integer2&lt;/var&gt;, then adds all the rest of the arguments to the result. If &lt;var&gt;integer2&lt;/var&gt; is not supplied, then the number 19 is used by default.</source>
          <target state="translated">Функция &lt;code&gt;foo&lt;/code&gt; вычитает &lt;var&gt;integer1&lt;/var&gt; из &lt;var&gt;integer2&lt;/var&gt; , а затем добавляет все остальные аргументы к результату. Если &lt;var&gt;integer2&lt;/var&gt; не указан, то по умолчанию используется число 19.</target>
        </trans-unit>
        <trans-unit id="142092b37bd14d5b1415337e59a8ef7820027ffe" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format-spec&lt;/code&gt; described in this section performs a similar function to &lt;code&gt;format&lt;/code&gt;, except it operates on format control strings that use arbitrary specification characters.</source>
          <target state="translated">Функция &lt;code&gt;format-spec&lt;/code&gt; , описанная в этом разделе, выполняет функцию, аналогичную функции &lt;code&gt;format&lt;/code&gt; , за исключением того, что она работает со строками управления форматом, которые используют произвольные символы спецификации.</target>
        </trans-unit>
        <trans-unit id="580c556614ef2beffd862c0457ca3264d0d95fa2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;frame-parameters&lt;/code&gt; returns an alist listing all the parameters of &lt;var&gt;frame&lt;/var&gt; and their values. If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, this returns the selected frame&amp;rsquo;s parameters</source>
          <target state="translated">Функция &lt;code&gt;frame-parameters&lt;/code&gt; возвращает список, в котором перечислены все параметры &lt;var&gt;frame&lt;/var&gt; и их значения. Если &lt;var&gt;frame&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; или опущен, это возвращает параметры выбранного кадра</target>
        </trans-unit>
        <trans-unit id="fc4daa549e176d014e533dbad29a89e4b64d4d76" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;getx&lt;/code&gt; refers to &lt;code&gt;x&lt;/code&gt;. This is a &lt;em&gt;free&lt;/em&gt; reference, in the sense that there is no binding for &lt;code&gt;x&lt;/code&gt; within that &lt;code&gt;defun&lt;/code&gt; construct itself. When we call &lt;code&gt;getx&lt;/code&gt; from within a &lt;code&gt;let&lt;/code&gt; form in which &lt;code&gt;x&lt;/code&gt; is (dynamically) bound, it retrieves the local value (i.e., 1). But when we call &lt;code&gt;getx&lt;/code&gt; outside the &lt;code&gt;let&lt;/code&gt; form, it retrieves the global value (i.e., -99).</source>
          <target state="translated">Функция &lt;code&gt;getx&lt;/code&gt; ссылается на &lt;code&gt;x&lt;/code&gt; . Это &lt;em&gt;бесплатная&lt;/em&gt; ссылка в том смысле, что нет привязки для &lt;code&gt;x&lt;/code&gt; внутри самой этой &lt;code&gt;defun&lt;/code&gt; конструкции. Когда мы вызываем &lt;code&gt;getx&lt;/code&gt; из формы &lt;code&gt;let&lt;/code&gt; , в которой &lt;code&gt;x&lt;/code&gt; (динамически) привязан, он извлекает локальное значение (например, 1). Но когда мы вызываем &lt;code&gt;getx&lt;/code&gt; вне формы &lt;code&gt;let&lt;/code&gt; , он получает глобальное значение (например, -99).</target>
        </trans-unit>
        <trans-unit id="e222099e0dbd9ca9d8f1867678a5de58c410df4b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-file-contents&lt;/code&gt; automatically recognizes file formats when it reads the specified file. It checks the text of the beginning of the file against the regular expressions of the format definitions, and if it finds a match, it calls the decoding function for that format. Then it checks all the known formats over again. It keeps checking them until none of them is applicable.</source>
          <target state="translated">Функция &lt;code&gt;insert-file-contents&lt;/code&gt; автоматически распознает форматы файлов при чтении указанного файла. Он проверяет текст начала файла на соответствие регулярным выражениям определений формата и, если обнаруживает совпадение, вызывает функцию декодирования для этого формата. Затем снова проверяет все известные форматы. Он продолжает проверять их до тех пор, пока ни один из них не подходит.</target>
        </trans-unit>
        <trans-unit id="1b53622592c53b4408af724ef50deb90f84d0660" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-file-contents&lt;/code&gt;:</source>
          <target state="translated">Функция &lt;code&gt;insert-file-contents&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0ced44529508f6a3572121eaa375fc4ced75820b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-for-yank&lt;/code&gt; automatically sets this variable according to the &lt;var&gt;undo&lt;/var&gt; element of the &lt;code&gt;yank-handler&lt;/code&gt; text property, if there is one.</source>
          <target state="translated">Функция &lt;code&gt;insert-for-yank&lt;/code&gt; автоматически устанавливает эту переменную в соответствии с элементом &lt;var&gt;undo&lt;/var&gt; в текстовом свойстве &lt;code&gt;yank-handler&lt;/code&gt; , если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="63c67cfe6f9d58e7894dfaf98f9e257cab3b6ab1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;kill-all-local-variables&lt;/code&gt; runs this normal hook before it does anything else. This gives major modes a way to arrange for something special to be done if the user switches to a different major mode. It is also useful for buffer-specific minor modes that should be forgotten if the user changes the major mode.</source>
          <target state="translated">Функция &lt;code&gt;kill-all-local-variables&lt;/code&gt; запускает этот обычный перехватчик до того, как сделает что-нибудь еще. Это дает основным режимам возможность организовать что-то особенное, если пользователь переключается в другой основной режим. Это также полезно для второстепенных режимов, специфичных для буфера, о которых следует забыть, если пользователь изменяет основной режим.</target>
        </trans-unit>
        <trans-unit id="db6ce2dd6e8f67ccadb8ee5dc896d171a780cbcc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;macroexpand&lt;/code&gt; does not expand calls to inline functions. Normally there is no need for that, since a call to an inline function is no harder to understand than a call to an ordinary function.</source>
          <target state="translated">Функция &lt;code&gt;macroexpand&lt;/code&gt; не расширяет вызовы встроенных функций. Обычно в этом нет необходимости, поскольку вызов встроенной функции понять не сложнее, чем вызов обычной функции.</target>
        </trans-unit>
        <trans-unit id="8ca63acdedc01018b5b5ff8ef5fd299f693dc141" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;map-keymap&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; once for each binding in &lt;var&gt;keymap&lt;/var&gt;. It passes two arguments, the event type and the value of the binding. If &lt;var&gt;keymap&lt;/var&gt; has a parent, the parent&amp;rsquo;s bindings are included as well. This works recursively: if the parent has itself a parent, then the grandparent&amp;rsquo;s bindings are also included and so on.</source>
          <target state="translated">Функция &lt;code&gt;map-keymap&lt;/code&gt; вызывает &lt;var&gt;function&lt;/var&gt; один раз для каждой привязки в &lt;var&gt;keymap&lt;/var&gt; . Он передает два аргумента: тип события и значение привязки. Если у &lt;var&gt;keymap&lt;/var&gt; есть родитель, привязки родителя также включаются. Это работает рекурсивно: если у родителя есть сам родитель, то также включаются привязки дедушки и бабушки и так далее.</target>
        </trans-unit>
        <trans-unit id="4993f97cab68094466e932cb10bb5175cf66f558" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mapbacktrace&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; once for each frame in the backtrace, starting at the first frame whose function is &lt;var&gt;base&lt;/var&gt; (or from the top if &lt;var&gt;base&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">Функция &lt;code&gt;mapbacktrace&lt;/code&gt; вызывает &lt;var&gt;function&lt;/var&gt; один раз для каждого кадра в обратной трассировке, начиная с первого кадра, функция которого является &lt;var&gt;base&lt;/var&gt; (или сверху, если &lt;var&gt;base&lt;/var&gt; опущено или равно &lt;code&gt;nil&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ccd658c08c200f4281112668bf7e651adc648cfe" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;member&lt;/code&gt; tests to see whether &lt;var&gt;object&lt;/var&gt; is a member of &lt;var&gt;list&lt;/var&gt;, comparing members with &lt;var&gt;object&lt;/var&gt; using &lt;code&gt;equal&lt;/code&gt;. If &lt;var&gt;object&lt;/var&gt; is a member, &lt;code&gt;member&lt;/code&gt; returns a list starting with its first occurrence in &lt;var&gt;list&lt;/var&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Функция- &lt;code&gt;member&lt;/code&gt; проверяет, является ли &lt;var&gt;object&lt;/var&gt; членом &lt;var&gt;list&lt;/var&gt; , сравнивая члены с &lt;var&gt;object&lt;/var&gt; с использованием &lt;code&gt;equal&lt;/code&gt; . Если &lt;var&gt;object&lt;/var&gt; является членом, &lt;code&gt;member&lt;/code&gt; возвращает список, начиная с его первого вхождения в &lt;var&gt;list&lt;/var&gt; . В противном случае возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="836706fff80e951f88d58f54e4d11838289bf1e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;memql&lt;/code&gt; tests to see whether &lt;var&gt;object&lt;/var&gt; is a member of &lt;var&gt;list&lt;/var&gt;, comparing members with &lt;var&gt;object&lt;/var&gt; using &lt;code&gt;eql&lt;/code&gt;, so floating-point elements are compared by value. If &lt;var&gt;object&lt;/var&gt; is a member, &lt;code&gt;memql&lt;/code&gt; returns a list starting with its first occurrence in &lt;var&gt;list&lt;/var&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;memql&lt;/code&gt; проверяет, является ли &lt;var&gt;object&lt;/var&gt; членом &lt;var&gt;list&lt;/var&gt; , сравнивая члены с &lt;var&gt;object&lt;/var&gt; с помощью &lt;code&gt;eql&lt;/code&gt; , поэтому элементы с плавающей запятой сравниваются по значению. Если &lt;var&gt;object&lt;/var&gt; является членом, &lt;code&gt;memql&lt;/code&gt; возвращает список, начиная с его первого вхождения в &lt;var&gt;list&lt;/var&gt; . В противном случае возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2086c23f1633b32f5d281ae45401849ef50ca00d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;process-type&lt;/code&gt; returns the symbol &lt;code&gt;serial&lt;/code&gt; for a process object representing a serial port connection.</source>
          <target state="translated">Функция &lt;code&gt;process-type&lt;/code&gt; возвращает символ &lt;code&gt;serial&lt;/code&gt; для объекта процесса , представляющего собой соединение через последовательный порт.</target>
        </trans-unit>
        <trans-unit id="7d5d7ee8f609d032732725e8d3c8c089bc52554d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;push-mark&lt;/code&gt; normally &lt;em&gt;does not&lt;/em&gt; activate the mark. To do that, specify &lt;code&gt;t&lt;/code&gt; for the argument &lt;var&gt;activate&lt;/var&gt;.</source>
          <target state="translated">Функциональная &lt;code&gt;push-mark&lt;/code&gt; обычно &lt;em&gt;не&lt;/em&gt; активирует метку. Для этого укажите &lt;code&gt;t&lt;/code&gt; в качестве аргумента &lt;var&gt;activate&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="e9fa560f2451740cc751b4488378f30d7e73bffc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-key-sequence&lt;/code&gt; also transforms some mouse events. It converts unbound drag events into click events, and discards unbound button-down events entirely. It also reshuffles focus events and miscellaneous window events so that they never appear in a key sequence with any other events.</source>
          <target state="translated">Функция &lt;code&gt;read-key-sequence&lt;/code&gt; также преобразует некоторые события мыши. Он преобразует несвязанные события перетаскивания в события щелчка и полностью отбрасывает несвязанные события нажатия кнопки. Он также перетасовывает события фокуса и разные события окна, чтобы они никогда не появлялись в последовательности клавиш с любыми другими событиями.</target>
        </trans-unit>
        <trans-unit id="411c4d145671b4036ab4f7cb6fa9e30b7580ebe1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-key-sequence&lt;/code&gt; ignores any button-down events that don&amp;rsquo;t have command bindings; therefore, the Emacs command loop ignores them too. This means that you need not worry about defining button-down events unless you want them to do something. The usual reason to define a button-down event is so that you can track mouse motion (by reading motion events) until the button is released. See &lt;a href=&quot;motion-events#Motion-Events&quot;&gt;Motion Events&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;read-key-sequence&lt;/code&gt; игнорирует любые события нажатия кнопки, для которых нет привязки команд; поэтому цикл команд Emacs их тоже игнорирует. Это означает, что вам не нужно беспокоиться об определении событий нажатия кнопки, если вы не хотите, чтобы они что-то делали. Обычная причина для определения события нажатия кнопки состоит в том, чтобы вы могли отслеживать движение мыши (считывая события движения), пока кнопка не будет отпущена. См. &lt;a href=&quot;motion-events#Motion-Events&quot;&gt;События движения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eba65b635c04edcaac2d00aa8b06564194485459" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-key-sequence&lt;/code&gt; suppresses quitting:</source>
          <target state="translated">Функция &lt;code&gt;read-key-sequence&lt;/code&gt; подавляет выход:</target>
        </trans-unit>
        <trans-unit id="56cd8086393902fb3f2fd966bb33828c275959f0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-regexp&lt;/code&gt; may use the value of this variable to determine its list of default regular expressions. If non-&lt;code&gt;nil&lt;/code&gt;, the value of this variable should be either:</source>
          <target state="translated">Функция &lt;code&gt;read-regexp&lt;/code&gt; может использовать значение этой переменной для определения своего списка регулярных выражений по умолчанию. Если не &lt;code&gt;nil&lt;/code&gt; , значение этой переменной должно быть либо:</target>
        </trans-unit>
        <trans-unit id="bfc9d89212eee790f8bef26e1a7f3b5f75f045d1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;redraw-frame&lt;/code&gt; clears and redisplays the entire contents of a given frame (see &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;). This is useful if the screen is corrupted.</source>
          <target state="translated">Функция &lt;code&gt;redraw-frame&lt;/code&gt; очищает и повторно отображает все содержимое заданного кадра (см. &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt; ). Это полезно, если экран поврежден.</target>
        </trans-unit>
        <trans-unit id="bbfc0c7e3b7ab2136aac8aac4311c80559dc8786" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;run-at-time&lt;/code&gt; returns a timer value that identifies the particular scheduled future action. You can use this value to call &lt;code&gt;cancel-timer&lt;/code&gt; (see below).</source>
          <target state="translated">Функция &lt;code&gt;run-at-time&lt;/code&gt; возвращает значение таймера, которое определяет конкретное запланированное будущее действие. Вы можете использовать это значение для вызова &lt;code&gt;cancel-timer&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="ebf16908ab8cdf77cbe0ed4cf8fac00f9d1be78c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;run-with-idle-timer&lt;/code&gt; returns a timer value which you can use in calling &lt;code&gt;cancel-timer&lt;/code&gt; (see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;).</source>
          <target state="translated">Функция &lt;code&gt;run-with-idle-timer&lt;/code&gt; возвращает значение таймера, которое вы можете использовать при вызове &lt;code&gt;cancel-timer&lt;/code&gt; (см. &lt;a href=&quot;timers#Timers&quot;&gt;Таймеры&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8d58a42db5f4f64609112ba848f62aa4f6033e5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;signal&lt;/code&gt; never returns.</source>
          <target state="translated">Функция &lt;code&gt;signal&lt;/code&gt; никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="e957fc96b50a902c38bbd9080cce211dda054fa5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;split-window&lt;/code&gt; (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to create the new window outside of the atomic window.</source>
          <target state="translated">Функция &lt;code&gt;split-window&lt;/code&gt; (см. &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Разделение окон&lt;/a&gt; ), когда применяется к составной части атомарного окна, будет пытаться создать новое окно вне атомарного окна.</target>
        </trans-unit>
        <trans-unit id="6df956fe28921ed43fa43bd2788b8f0492e99c5e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;substitute-key-definition&lt;/code&gt; scans a keymap for keys that have a certain binding and rebinds them with a different binding. Another feature which is cleaner and can often produce the same results is to remap one command into another (see &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;).</source>
          <target state="translated">Функция &lt;code&gt;substitute-key-definition&lt;/code&gt; сканирует раскладку клавиш на предмет ключей, имеющих определенную привязку, и повторно связывает их с другой привязкой. Еще одна функция, более понятная и часто приводящая к одинаковым результатам, - это переназначение одной команды на другую (см. &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Команды&lt;/a&gt; переназначения ).</target>
        </trans-unit>
        <trans-unit id="bc471743e21a847c0361cb115c2214f8054e6289" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; is also the place to define any C variables that are to be visible as Lisp variables. &lt;code&gt;DEFVAR_LISP&lt;/code&gt; makes a C variable of type &lt;code&gt;Lisp_Object&lt;/code&gt; visible in Lisp. &lt;code&gt;DEFVAR_INT&lt;/code&gt; makes a C variable of type &lt;code&gt;int&lt;/code&gt; visible in Lisp with a value that is always an integer. &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; makes a C variable of type &lt;code&gt;int&lt;/code&gt; visible in Lisp with a value that is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. Note that variables defined with &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; are automatically added to the list &lt;code&gt;byte-boolean-vars&lt;/code&gt; used by the byte compiler.</source>
          <target state="translated">Функция &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; также является местом для определения любых переменных C, которые должны быть видны как переменные Lisp. &lt;code&gt;DEFVAR_LISP&lt;/code&gt; делает переменную C типа &lt;code&gt;Lisp_Object&lt;/code&gt; видимой в Лиспе. &lt;code&gt;DEFVAR_INT&lt;/code&gt; делает переменную C типа &lt;code&gt;int&lt;/code&gt; видимой в Lisp со значением, которое всегда является целым числом. &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; делает переменную C типа &lt;code&gt;int&lt;/code&gt; видимой в Лиспе со значением либо &lt;code&gt;t&lt;/code&gt; , либо &lt;code&gt;nil&lt;/code&gt; . Обратите внимание, что переменные, определенные с помощью &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; , автоматически добавляются в список &lt;code&gt;byte-boolean-vars&lt;/code&gt; , используемый компилятором байтов.</target>
        </trans-unit>
        <trans-unit id="3a8cd13dfa2e44b4ddf44780a2531422e59cdecc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;throw&lt;/code&gt; finds the matching &lt;code&gt;catch&lt;/code&gt; based on the first argument: it searches for a &lt;code&gt;catch&lt;/code&gt; whose first argument is &lt;code&gt;eq&lt;/code&gt; to the one specified in the &lt;code&gt;throw&lt;/code&gt;. If there is more than one applicable &lt;code&gt;catch&lt;/code&gt;, the innermost one takes precedence. Thus, in the above example, the &lt;code&gt;throw&lt;/code&gt; specifies &lt;code&gt;foo&lt;/code&gt;, and the &lt;code&gt;catch&lt;/code&gt; in &lt;code&gt;foo-outer&lt;/code&gt; specifies the same symbol, so that &lt;code&gt;catch&lt;/code&gt; is the applicable one (assuming there is no other matching &lt;code&gt;catch&lt;/code&gt; in between).</source>
          <target state="translated">Функция &lt;code&gt;throw&lt;/code&gt; находит соответствующий &lt;code&gt;catch&lt;/code&gt; на основе первого аргумента: он ищет &lt;code&gt;catch&lt;/code&gt; , чей первый аргумент &lt;code&gt;eq&lt;/code&gt; к одному указанным в &lt;code&gt;throw&lt;/code&gt; . Если применимо более одного &lt;code&gt;catch&lt;/code&gt; , приоритет имеет самый внутренний. Таким образом, в приведенном выше примере &lt;code&gt;throw&lt;/code&gt; указывает &lt;code&gt;foo&lt;/code&gt; , а &lt;code&gt;catch&lt;/code&gt; в &lt;code&gt;foo-outer&lt;/code&gt; указывает тот же символ, так что &lt;code&gt;catch&lt;/code&gt; является применимым (при условии, что между ними нет другого подходящего &lt;code&gt;catch&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5661573f71139d597425c8fd348b8554cabd492f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;tool-bar-make-keymap&lt;/code&gt;, in turn, derives the actual tool bar map dynamically from the value of the variable &lt;code&gt;tool-bar-map&lt;/code&gt;. Hence, you should normally adjust the default (global) tool bar by changing that map. Some major modes, such as Info mode, completely replace the global tool bar by making &lt;code&gt;tool-bar-map&lt;/code&gt; buffer-local and setting it to a different keymap.</source>
          <target state="translated">Функция &lt;code&gt;tool-bar-make-keymap&lt;/code&gt; , в свою очередь, динамически извлекает фактическую карту панели инструментов из значения переменной &lt;code&gt;tool-bar-map&lt;/code&gt; . Следовательно, вы должны обычно настраивать стандартную (глобальную) панель инструментов, изменяя эту карту. Некоторые основные режимы, такие как режим информации, полностью заменяют глобальную панель инструментов, делая буфер &lt;code&gt;tool-bar-map&lt;/code&gt; панели инструментов локальным и устанавливая для него другую раскладку клавиатуры.</target>
        </trans-unit>
        <trans-unit id="05e5fdd0ff72a822c0cc55151d5a6c9edaf5d75c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;view-buffer&lt;/code&gt; does not enable View mode in buffers whose mode-class is special, because such modes usually provide their own View-like bindings.</source>
          <target state="translated">Функция &lt;code&gt;view-buffer&lt;/code&gt; не включает режим просмотра в буферах, чей класс режима является особым, поскольку такие режимы обычно предоставляют свои собственные привязки, подобные View.</target>
        </trans-unit>
        <trans-unit id="a049ee6872282215d8c5e6687a889741cbf6e11f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;write-region&lt;/code&gt; converts the data which it writes to the appropriate file formats specified by &lt;code&gt;buffer-file-format&lt;/code&gt; and also calls the functions in the list &lt;code&gt;write-region-annotate-functions&lt;/code&gt;. See &lt;a href=&quot;format-conversion#Format-Conversion&quot;&gt;Format Conversion&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;write-region&lt;/code&gt; преобразует данные, которые она записывает, в соответствующие форматы файлов, указанные в &lt;code&gt;buffer-file-format&lt;/code&gt; , а также вызывает функции из списка &lt;code&gt;write-region-annotate-functions&lt;/code&gt; . См. &lt;a href=&quot;format-conversion#Format-Conversion&quot;&gt;Преобразование формата&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2746b27a56c8ff0cc634f6dc15fff67621f22f61" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;write-region&lt;/code&gt;:</source>
          <target state="translated">Функция &lt;code&gt;write-region&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="37f0357f6437343569a44c1bbed9f09179966f30" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;x-get-resource&lt;/code&gt; retrieves a resource value from the X Window defaults database.</source>
          <target state="translated">Функция &lt;code&gt;x-get-resource&lt;/code&gt; извлекает значение ресурса из базы данных по умолчанию X Window.</target>
        </trans-unit>
        <trans-unit id="fb6053497d7338bd26e25c53f5d17dd9d465fac4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;x-parse-geometry&lt;/code&gt; converts a standard X window geometry string to an alist that you can use as part of the argument to &lt;code&gt;make-frame&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;x-parse-geometry&lt;/code&gt; преобразует стандартную строку геометрии X-окна в список, который вы можете использовать как часть аргумента &lt;code&gt;make-frame&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="765f4cca514fe5d2dfb2aca5ee2926f744c31bf9" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;y-or-n-p-with-timeout&lt;/code&gt; provides a simple way to use a timer to avoid waiting too long for an answer. See &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Yes-or-No Queries&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;y-or-n-p-with-timeout&lt;/code&gt; предоставляет простой способ использовать таймер, чтобы не ждать слишком долго для ответа. См. &amp;laquo; &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Да или нет&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df0ab2f26bcca2763cb6e43bfe8851ca6f1b858d" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;fun&lt;/var&gt; was defined as an autoload.</source>
          <target state="translated">Функция &lt;var&gt;fun&lt;/var&gt; была определена как автозагрузка.</target>
        </trans-unit>
        <trans-unit id="54c8609b51778bf7d45e6af7c3a0089e651dafd8" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;fun&lt;/var&gt; was defined.</source>
          <target state="translated">Была определена функция &lt;var&gt;fun&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="1197aefcb8e997f46503d415a6f7bd440fa422e7" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;fun&lt;/var&gt; was previously an autoload before this library redefined it as a function. The following element is always &lt;code&gt;(defun . &lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt;, which represents defining &lt;var&gt;fun&lt;/var&gt; as a function.</source>
          <target state="translated">Функция &lt;var&gt;fun&lt;/var&gt; раньше была автозагрузкой до того, как эта библиотека переопределила ее как функцию. Следующим элементом всегда является &lt;code&gt;(defun . &lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt; , который представляет определение &lt;var&gt;fun&lt;/var&gt; как функции.</target>
        </trans-unit>
        <trans-unit id="4a8ed9e0e2bf16ef5d1d934174aa221a2fe5895d" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;hash-fn&lt;/var&gt; should accept one argument, a key, and return an integer that is the hash code of that key. For good results, the function should use the whole range of fixnums for hash codes, including negative fixnums.</source>
          <target state="translated">Функция &lt;var&gt;hash-fn&lt;/var&gt; должна принимать один аргумент, ключ, и возвращать целое число, которое является хэш-кодом этого ключа. Для хороших результатов функция должна использовать весь диапазон фиксированных номеров для хэш-кодов, включая отрицательные фиксированные числа.</target>
        </trans-unit>
        <trans-unit id="bceb96a81c6ae7fe6ca85c909a8b34d1e250dcc7" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;restore-buffer-function&lt;/var&gt; will be called with argument list</source>
          <target state="translated">Функция- &lt;var&gt;restore-buffer-function&lt;/var&gt; будет вызываться со списком аргументов</target>
        </trans-unit>
        <trans-unit id="542f7b37d57061c8a923579b6d757e44f707ccd9" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;test-fn&lt;/var&gt; should accept two arguments, two keys, and return non-&lt;code&gt;nil&lt;/code&gt; if they are considered the same.</source>
          <target state="translated">Функция &lt;var&gt;test-fn&lt;/var&gt; должна принимать два аргумента, два ключа и возвращать &lt;code&gt;nil&lt;/code&gt; если они считаются одинаковыми.</target>
        </trans-unit>
        <trans-unit id="0267fd50dfdf570f50991445f5d60831fec0bbb2" translate="yes" xml:space="preserve">
          <source>The function calls &lt;code&gt;set-auto-mode&lt;/code&gt; to choose and set a major mode. If this does not specify a mode, the buffer stays in the major mode determined by the default value of &lt;code&gt;major-mode&lt;/code&gt; (see below).</source>
          <target state="translated">Функция вызывает &lt;code&gt;set-auto-mode&lt;/code&gt; для выбора и установки основного режима. Если здесь не указан режим, буфер остается в основном режиме, определяемом значением по умолчанию &lt;code&gt;major-mode&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="b1b2ebec7b7f741cc24d28e6e32513259cab8c5e" translate="yes" xml:space="preserve">
          <source>The function cell holds a symbol&amp;rsquo;s function definition. Often, we refer to &amp;ldquo;the function &lt;code&gt;foo&lt;/code&gt;&amp;rdquo; when we really mean the function stored in the function cell of &lt;code&gt;foo&lt;/code&gt;; we make the distinction explicit only when necessary. Typically, the function cell is used to hold a function (see &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;) or a macro (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;). However, it can also be used to hold a symbol (see &lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;Function Indirection&lt;/a&gt;), keyboard macro (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;), keymap (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;), or autoload object (see &lt;a href=&quot;autoloading#Autoloading&quot;&gt;Autoloading&lt;/a&gt;). To get the contents of a symbol&amp;rsquo;s function cell, use the function &lt;code&gt;symbol-function&lt;/code&gt; (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;).</source>
          <target state="translated">Функциональная ячейка содержит определение функции символа. Часто мы ссылаемся на &amp;laquo;функцию &lt;code&gt;foo&lt;/code&gt; &amp;raquo;, когда на самом деле имеем в виду функцию, хранящуюся в функциональной ячейке &lt;code&gt;foo&lt;/code&gt; ; мы делаем различие явным только в случае необходимости. Обычно функциональная ячейка используется для хранения функции (см. &lt;a href=&quot;functions#Functions&quot;&gt;Функции&lt;/a&gt; ) или макроса (см. &lt;a href=&quot;macros#Macros&quot;&gt;Макросы&lt;/a&gt; ). Однако его также можно использовать для хранения символа (см . &amp;laquo; &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Обращение к &lt;/a&gt;&lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;функциям&amp;raquo;&lt;/a&gt; ), макроса клавиатуры (см. &amp;laquo; &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Макросы клавиатуры&amp;raquo;&lt;/a&gt; ), раскладки клавиатуры (см. Раскладки клавиатуры ) или объекта автозагрузки (см. &lt;a href=&quot;autoloading#Autoloading&quot;&gt;Автозагрузка&lt;/a&gt; ). Чтобы получить содержимое функциональной ячейки символа, используйте функцию &lt;code&gt;symbol-function&lt;/code&gt; (см. &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Функциональные ячейки&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="16328c91ba726096f5314f142ff38c105df7239d" translate="yes" xml:space="preserve">
          <source>The function cell or the value cell may be &lt;em&gt;void&lt;/em&gt;, which means that the cell does not reference any object. (This is not the same thing as holding the symbol &lt;code&gt;void&lt;/code&gt;, nor the same as holding the symbol &lt;code&gt;nil&lt;/code&gt;.) Examining a function or value cell that is void results in an error, such as &amp;lsquo;</source>
          <target state="translated">Функциональная ячейка или ячейка значения могут быть &lt;em&gt;недействительными&lt;/em&gt; , что означает, что ячейка не ссылается ни на один объект. (Это не то же самое, что удерживание символа &lt;code&gt;void&lt;/code&gt; , и не то же самое, что удерживание символа &lt;code&gt;nil&lt;/code&gt; .) Проверка недействительной ячейки функции или значения приводит к ошибке, например '</target>
        </trans-unit>
        <trans-unit id="77d0d2f3edeb3f16b9066342192972eab714c545" translate="yes" xml:space="preserve">
          <source>The function definition of &lt;var&gt;symbol&lt;/var&gt; is used in place of &lt;var&gt;symbol&lt;/var&gt;. If that too is a symbol, then this process is repeated, any number of times. Ultimately this should lead to an object that is a keymap, a command, or a keyboard macro.</source>
          <target state="translated">Определение функции &lt;var&gt;symbol&lt;/var&gt; используется вместо &lt;var&gt;symbol&lt;/var&gt; . Если это тоже символ, то этот процесс повторяется любое количество раз. В конечном итоге это должно привести к объекту, который является раскладкой клавиатуры, командой или макросом клавиатуры.</target>
        </trans-unit>
        <trans-unit id="70e234ce635436f65ccf5ff5428cbb855d712c68" translate="yes" xml:space="preserve">
          <source>The function is called by &lt;code&gt;syntax-ppss&lt;/code&gt; (see &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt;), and by Font Lock mode during syntactic fontification (see &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;Syntactic Font Lock&lt;/a&gt;). It is called with two arguments, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, which are the starting and ending positions of the text on which it should act. It is allowed to call &lt;code&gt;syntax-ppss&lt;/code&gt; on any position before &lt;var&gt;end&lt;/var&gt;. However, it should not call &lt;code&gt;syntax-ppss-flush-cache&lt;/code&gt;; so, it is not allowed to call &lt;code&gt;syntax-ppss&lt;/code&gt; on some position and later modify the buffer at an earlier position.</source>
          <target state="translated">Функция вызывается &lt;code&gt;syntax-ppss&lt;/code&gt; (см. Анализ &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;положения&lt;/a&gt; ) и режимом Font Lock во время синтаксической фонификации (см. &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;Синтаксическая блокировка шрифта&lt;/a&gt; ). Он вызывается с двумя аргументами, &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; , которые являются начальной и конечной позициями текста, с которым он должен действовать. Разрешено вызывать &lt;code&gt;syntax-ppss&lt;/code&gt; в любой позиции до &lt;var&gt;end&lt;/var&gt; . Однако он не должен вызывать &lt;code&gt;syntax-ppss-flush-cache&lt;/code&gt; ; таким образом, нельзя вызывать &lt;code&gt;syntax-ppss&lt;/code&gt; в какой-либо позиции и позже изменять буфер в более ранней позиции.</target>
        </trans-unit>
        <trans-unit id="7b365c1ea990ed74fa23e69f3e59bb3fef165d33" translate="yes" xml:space="preserve">
          <source>The function is called with one argument, the parse state at point returned by &lt;code&gt;parse-partial-sexp&lt;/code&gt;, and should return a face. The default value returns &lt;code&gt;font-lock-comment-face&lt;/code&gt; for comments and &lt;code&gt;font-lock-string-face&lt;/code&gt; for strings (see &lt;a href=&quot;faces-for-font-lock#Faces-for-Font-Lock&quot;&gt;Faces for Font Lock&lt;/a&gt;).</source>
          <target state="translated">Функция вызывается с одним аргументом, состоянием синтаксического анализа в точке, возвращаемым &lt;code&gt;parse-partial-sexp&lt;/code&gt; , и должна возвращать лицо. Значение по умолчанию возвращает &lt;code&gt;font-lock-comment-face&lt;/code&gt; для комментариев и &lt;code&gt;font-lock-string-face&lt;/code&gt; для строк (см. &lt;a href=&quot;faces-for-font-lock#Faces-for-Font-Lock&quot;&gt;Faces for Font Lock&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9328a25f093f15182803d9023b33252b886864e6" translate="yes" xml:space="preserve">
          <source>The function is called with three arguments, &lt;var&gt;window&lt;/var&gt;, &lt;var&gt;object&lt;/var&gt;, and &lt;var&gt;pos&lt;/var&gt;. The second argument, &lt;var&gt;object&lt;/var&gt;, is either the overlay that had the property (for overlay buttons), or the buffer containing the button (for text property buttons). The other arguments have the same meaning as for the special text property &lt;code&gt;help-echo&lt;/code&gt;.</source>
          <target state="translated">Функция вызывается с тремя аргументами: &lt;var&gt;window&lt;/var&gt; , &lt;var&gt;object&lt;/var&gt; и &lt;var&gt;pos&lt;/var&gt; . Второй аргумент, &lt;var&gt;object&lt;/var&gt; , - это либо наложение, у которого было свойство (для кнопок наложения), либо буфер, содержащий кнопку (для кнопок свойств текста). Остальные аргументы имеют то же значение, что и для специального текстового свойства &lt;code&gt;help-echo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bcf0f786e7063f34c780ba9d084a745154f7f7f" translate="yes" xml:space="preserve">
          <source>The function is called with two arguments, the severity level and its entry in &lt;code&gt;warning-levels&lt;/code&gt;. It should return a list to use as the entry (this value need not be an actual member of &lt;code&gt;warning-levels&lt;/code&gt;). By constructing this value, the function can change the severity of the warning, or specify different handling for a given severity level.</source>
          <target state="translated">Функция вызывается с двумя аргументами: уровнем серьезности и записью в &lt;code&gt;warning-levels&lt;/code&gt; . Он должен возвращать список для использования в качестве записи (это значение не обязательно должно быть фактическим членом уровня &lt;code&gt;warning-levels&lt;/code&gt; ). Создав это значение, функция может изменить серьезность предупреждения или указать другую обработку для заданного уровня серьезности.</target>
        </trans-unit>
        <trans-unit id="a2a2dd9cb6611c3a2fb4ae6ecd12f7c5ac258cb7" translate="yes" xml:space="preserve">
          <source>The function is given three parameters, the standard &lt;var&gt;beg&lt;/var&gt;, &lt;var&gt;end&lt;/var&gt;, and &lt;var&gt;old-len&lt;/var&gt; from &lt;code&gt;after-change-functions&lt;/code&gt; (see &lt;a href=&quot;change-hooks#Change-Hooks&quot;&gt;Change Hooks&lt;/a&gt;). It should return either a cons of the beginning and end buffer positions (in that order) of the region to fontify, or &lt;code&gt;nil&lt;/code&gt; (which means choose the region in the standard way). This function needs to preserve point, the match-data, and the current restriction. The region it returns may start or end in the middle of a line.</source>
          <target state="translated">У функции есть три параметра: стандартный &lt;var&gt;beg&lt;/var&gt; in , &lt;var&gt;end&lt;/var&gt; и &lt;var&gt;old-len&lt;/var&gt; из &lt;code&gt;after-change-functions&lt;/code&gt; (см. &lt;a href=&quot;change-hooks#Change-Hooks&quot;&gt;Ловушки изменения&lt;/a&gt; ). Он должен возвращать либо минусы начальной и конечной буферных позиций (в указанном порядке) области для фонирования, либо &lt;code&gt;nil&lt;/code&gt; (что означает выбор региона стандартным способом). Эта функция должна сохранять точку, данные соответствия и текущее ограничение. Возвращаемый регион может начинаться или заканчиваться в середине строки.</target>
        </trans-unit>
        <trans-unit id="d5d86a312c704be80fff26fc16b50d833ac4546d" translate="yes" xml:space="preserve">
          <source>The function now compares the two candidate prefixes heuristically: if the non-whitespace characters in the line 2 candidate occur in the same order in the line 1 candidate, the function returns the line 2 candidate. Otherwise, it returns the largest initial substring which is common to both candidates (which might be the empty string).</source>
          <target state="translated">Теперь функция сравнивает префиксы двух кандидатов эвристически:если во 2-й строке кандидата встречаются не белые пробельные символы в том же порядке,что и в 1-й строке кандидата,то функция возвращает 2-ю строку кандидата.В противном случае она возвращает самую большую начальную подстроку,которая является общей для обоих кандидатов (это может быть пустая строка).</target>
        </trans-unit>
        <trans-unit id="3010538a15326f7f4a43ca9704f87dc561e6ae88" translate="yes" xml:space="preserve">
          <source>The function now has a list of regular expressions that it passes to &lt;code&gt;read-from-minibuffer&lt;/code&gt; to obtain the user&amp;rsquo;s input. The first element of the list is the default result in case of empty input. All elements of the list are available to the user as the &amp;ldquo;future minibuffer history&amp;rdquo; list (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-History.html#Minibuffer-History&quot;&gt;future list&lt;/a&gt; in</source>
          <target state="translated">Теперь у функции есть список регулярных выражений, которые она передает в &lt;code&gt;read-from-minibuffer&lt;/code&gt; для чтения, чтобы получить ввод пользователя. Первый элемент списка - результат по умолчанию в случае пустого ввода. Все элементы списка доступны пользователю в виде списка &amp;laquo;будущая история минибуфера&amp;raquo; (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-History.html#Minibuffer-History&quot;&gt;Будущий список&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="ba7c33792fef049306216c0a9636aed9d4713b7a" translate="yes" xml:space="preserve">
          <source>The function now has a list of regular expressions that it passes to &lt;code&gt;read-from-minibuffer&lt;/code&gt; to obtain the user&amp;rsquo;s input. The first element of the list is the default result in case of empty input. All elements of the list are available to the user as the &amp;ldquo;future minibuffer history&amp;rdquo; list (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-History.html#Minibuffer-History&quot;&gt;future list&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3712f3990384c32b001189f990196c3e25d4f1c" translate="yes" xml:space="preserve">
          <source>The function passed as &lt;code&gt;:request-dispatcher&lt;/code&gt; is responsible for handling the remote endpoint&amp;rsquo;s requests, which expect a reply from the local endpoint (in this case, the program you&amp;rsquo;re building). Inside that function, you may either return locally (a normal return) or non-locally (an error return). A local return value must be a Lisp object that can be serialized as JSON (see &lt;a href=&quot;parsing-json#Parsing-JSON&quot;&gt;Parsing JSON&lt;/a&gt;). This determines a success response, and the object is forwarded to the server as the JSONRPC &lt;code&gt;result&lt;/code&gt; object. A non-local return, achieved by calling the function &lt;code&gt;jsonrpc-error&lt;/code&gt;, causes an error response to be sent to the server. The details of the accompanying JSONRPC &lt;code&gt;error&lt;/code&gt; are filled out with whatever was passed to &lt;code&gt;jsonrpc-error&lt;/code&gt;. A non-local return triggered by an unexpected error of any other type also causes an error response to be sent (unless you have set &lt;code&gt;debug-on-error&lt;/code&gt;, in which case this calls the Lisp debugger, see &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;).</source>
          <target state="translated">Функция, переданная как &lt;code&gt;:request-dispatcher&lt;/code&gt; , отвечает за обработку запросов удаленной конечной точки, которые ожидают ответа от локальной конечной точки (в данном случае программы, которую вы создаете). Внутри этой функции вы можете либо вернуть локально (нормальный возврат), либо нелокально (возврат ошибки). Локальное возвращаемое значение должно быть объектом Lisp, который может быть сериализован как JSON (см. &lt;a href=&quot;parsing-json#Parsing-JSON&quot;&gt;Анализ JSON&lt;/a&gt; ). Это определяет успешный ответ, и объект пересылается на сервер как объект &lt;code&gt;result&lt;/code&gt; JSONRPC . &lt;code&gt;jsonrpc-error&lt;/code&gt; возврат, достигаемый путем вызова функции jsonrpc-error , вызывает отправку на сервер ответа об ошибке. Детали сопутствующей &lt;code&gt;error&lt;/code&gt; JSONRPC заполняются тем, что было передано в &lt;code&gt;jsonrpc-error&lt;/code&gt; . Нелокальный возврат, вызванный неожиданной ошибкой любого другого типа, также вызывает отправку ответа об ошибке (если вы не установили &lt;code&gt;debug-on-error&lt;/code&gt; , и в этом случае это вызывает отладчик Lisp, см. &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Отладка ошибок&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f4f854a3fe920f9dd18f4fb474ba93f955016a3" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;nil&lt;/code&gt; if images of this type are not supported. Otherwise it returns an image descriptor.</source>
          <target state="translated">Функция возвращает &lt;code&gt;nil&lt;/code&gt; , если изображения этого типа не поддерживаются. В противном случае он возвращает дескриптор изображения.</target>
        </trans-unit>
        <trans-unit id="271e1437bfe3ecbde27422c4523f32b9c7ffd067" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if it actually tried to redisplay, and &lt;code&gt;nil&lt;/code&gt; otherwise. A value of &lt;code&gt;t&lt;/code&gt; does not mean that redisplay proceeded to completion; it could have been preempted by newly arriving input.</source>
          <target state="translated">Функция возвращает &lt;code&gt;t&lt;/code&gt; , если на самом деле пыталась повторно отобразить, и &lt;code&gt;nil&lt;/code&gt; в противном случае. Значение &lt;code&gt;t&lt;/code&gt; не означает, что повторное отображение завершено; это могло быть вытеснено вновь поступившими данными.</target>
        </trans-unit>
        <trans-unit id="a2c86b439365c249c948c8efa2d07fe8ef2ae3a2" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if it succeeds in setting the SELinux context of &lt;var&gt;filename&lt;/var&gt;. It returns &lt;code&gt;nil&lt;/code&gt; if the context was not set (e.g., if SELinux is disabled, or if Emacs was compiled without SELinux support).</source>
          <target state="translated">Функция возвращает &lt;code&gt;t&lt;/code&gt; , если ей удается установить контекст SELinux для &lt;var&gt;filename&lt;/var&gt; . Он возвращает &lt;code&gt;nil&lt;/code&gt; , если контекст не был установлен (например, если SELinux отключен или Emacs был скомпилирован без поддержки SELinux).</target>
        </trans-unit>
        <trans-unit id="8aa3622a93da6a8f83161ce66b0a13088cd542a2" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if it successfully sets the ACL of &lt;var&gt;filename&lt;/var&gt;, &lt;code&gt;nil&lt;/code&gt; otherwise.</source>
          <target state="translated">Функция возвращает &lt;code&gt;t&lt;/code&gt; , если она успешно устанавливает ACL для &lt;var&gt;filename&lt;/var&gt; , в противном случае - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4adc69487e5f1fde8f02ec91f8b4f6899e76a34b" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if the last actual modification time and Emacs&amp;rsquo;s recorded modification time are the same, &lt;code&gt;nil&lt;/code&gt; otherwise. It also returns &lt;code&gt;t&lt;/code&gt; if the buffer has no recorded last modification time, that is if &lt;code&gt;visited-file-modtime&lt;/code&gt; would return zero.</source>
          <target state="translated">Функция возвращает &lt;code&gt;t&lt;/code&gt; , если последнее фактическое время модификации и записанное время модификации Emacs совпадают, в противном случае - &lt;code&gt;nil&lt;/code&gt; . Он также возвращает &lt;code&gt;t&lt;/code&gt; , если в буфере не записано время последней модификации, то есть, если &lt;code&gt;visited-file-modtime&lt;/code&gt; вернет ноль.</target>
        </trans-unit>
        <trans-unit id="eb47fbb29639c623b56d142e3e79686425e3d118" translate="yes" xml:space="preserve">
          <source>The function returns a list of elements that look like this:</source>
          <target state="translated">Функция возвращает список элементов,которые выглядят так:</target>
        </trans-unit>
        <trans-unit id="b576d5d04a96dba46391f5334628078f6e91dee5" translate="yes" xml:space="preserve">
          <source>The function returns an existing buffer if there is one; otherwise it creates a new buffer and reads the file into it. When &lt;code&gt;find-file-noselect&lt;/code&gt; uses an existing buffer, it first verifies that the file has not changed since it was last visited or saved in that buffer. If the file has changed, this function asks the user whether to reread the changed file. If the user says &amp;lsquo;</source>
          <target state="translated">Функция возвращает существующий буфер, если он есть; в противном случае он создает новый буфер и считывает в него файл. Когда &lt;code&gt;find-file-noselect&lt;/code&gt; использует существующий буфер, он сначала проверяет, не изменился ли файл с момента последнего посещения или сохранения в этом буфере. Если файл был изменен, эта функция спрашивает пользователя, следует ли перечитать измененный файл. Если пользователь говорит '</target>
        </trans-unit>
        <trans-unit id="1501aaa047bf3d422b1edc8df28a63aa3d3d72eb" translate="yes" xml:space="preserve">
          <source>The function returns the new buffer position as its value.</source>
          <target state="translated">Функция возвращает в качестве значения новую позицию буфера.</target>
        </trans-unit>
        <trans-unit id="58c3348b08983e8a23db0b1d6c78b02a290ca8f9" translate="yes" xml:space="preserve">
          <source>The function returns the text of the &lt;var&gt;long-answer&lt;/var&gt; selected by the user, regardless of whether long or short answers were shown in the prompt and typed by the user.</source>
          <target state="translated">Функция возвращает текст &lt;var&gt;long-answer&lt;/var&gt; выбранного пользователем, независимо от того, были ли длинные или короткие ответы показаны в подсказке и введены пользователем.</target>
        </trans-unit>
        <trans-unit id="715f03109b9380bc908d0550c413f8b1448908f0" translate="yes" xml:space="preserve">
          <source>The function returns the value that &lt;var&gt;func&lt;/var&gt; returned.</source>
          <target state="translated">Функция возвращает значение , которое &lt;var&gt;func&lt;/var&gt; возвратили.</target>
        </trans-unit>
        <trans-unit id="0e79ba4a0ec06385532067bc2dfd92eef04abf37" translate="yes" xml:space="preserve">
          <source>The function scans text for a change in the &lt;var&gt;prop&lt;/var&gt; property, then returns the position of the change. The scan goes forward from position &lt;var&gt;pos&lt;/var&gt; in the string or buffer &lt;var&gt;object&lt;/var&gt;. In other words, this function returns the position of the first character beyond &lt;var&gt;pos&lt;/var&gt; whose &lt;var&gt;prop&lt;/var&gt; property differs from that of the character just after &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">Функция сканирует текст на предмет изменения свойства &lt;var&gt;prop&lt;/var&gt; , а затем возвращает положение изменения. Сканирование идет вперед с позиции &lt;var&gt;pos&lt;/var&gt; в строке или буферном &lt;var&gt;object&lt;/var&gt; . Другими словами, эта функция возвращает позицию первого символа после &lt;var&gt;pos&lt;/var&gt; , свойство &lt;var&gt;prop&lt;/var&gt; которого отличается от свойства символа сразу после &lt;var&gt;pos&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="bcc76f6509469249f57ba4ca3b63e8ba3ae15e54" translate="yes" xml:space="preserve">
          <source>The function scans the text forward from position &lt;var&gt;pos&lt;/var&gt; in the string or buffer &lt;var&gt;object&lt;/var&gt; until it finds a change in some text property, then returns the position of the change. In other words, it returns the position of the first character beyond &lt;var&gt;pos&lt;/var&gt; whose properties are not identical to those of the character just after &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">Функция просматривает текст вперед от позиции &lt;var&gt;pos&lt;/var&gt; в строке или &lt;var&gt;object&lt;/var&gt; буфера до тех пор, пока не найдет изменение в некотором свойстве текста, а затем возвращает позицию изменения. Другими словами, он возвращает позицию первого символа после &lt;var&gt;pos&lt;/var&gt; , свойства которого не идентичны свойствам символа сразу после &lt;var&gt;pos&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b2569b6d3f2a4920cd818025751b427d49a3a937" translate="yes" xml:space="preserve">
          <source>The function searches for &lt;var&gt;image&lt;/var&gt; first using &lt;code&gt;image-load-path&lt;/code&gt;, excluding</source>
          <target state="translated">Функция сначала ищет &lt;var&gt;image&lt;/var&gt; используя &lt;code&gt;image-load-path&lt;/code&gt; , исключая</target>
        </trans-unit>
        <trans-unit id="f61dc72b5ae5c926752f9b2ea93c7b17926bb658" translate="yes" xml:space="preserve">
          <source>The function should report its choice by placing the region around it. A good choice is a range of text large enough to give proper results, but not too large so that refontification becomes slow. Typical values are &lt;code&gt;mark-defun&lt;/code&gt; for programming modes or &lt;code&gt;mark-paragraph&lt;/code&gt; for textual modes.</source>
          <target state="translated">Функция должна сообщить о своем выборе, поместив вокруг него область. Хороший выбор - это достаточно большой диапазон текста, чтобы дать правильные результаты, но не слишком большой, чтобы переформатирование стало медленным. Типичные значения - это &lt;code&gt;mark-defun&lt;/code&gt; для режимов программирования или &lt;code&gt;mark-paragraph&lt;/code&gt; для текстовых режимов.</target>
        </trans-unit>
        <trans-unit id="e569deba575fd9eecea0636fcb5581d08c592fbf" translate="yes" xml:space="preserve">
          <source>The function specified by this option is called to automatically hide frames. This function is called with one argument&amp;mdash;a frame.</source>
          <target state="translated">Функция, указанная в этой опции, вызывается для автоматического скрытия фреймов. Эта функция вызывается с одним аргументом - фреймом.</target>
        </trans-unit>
        <trans-unit id="9e523dba464ace87982922281becd877253b4c57" translate="yes" xml:space="preserve">
          <source>The function specified here is called by &lt;code&gt;bury-buffer&lt;/code&gt; (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;) when the selected window is dedicated and shows the buffer to bury. It is also called by &lt;code&gt;quit-restore-window&lt;/code&gt; (see above) when the frame of the window to quit has been specially created for displaying that window&amp;rsquo;s buffer and the buffer is not killed.</source>
          <target state="translated">Указанная здесь функция вызывается &lt;code&gt;bury-buffer&lt;/code&gt; (см. &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Список &lt;/a&gt;буферов ), когда выбранное окно выделено и показывает буфер, который нужно скрыть. Он также вызывается &lt;code&gt;quit-restore-window&lt;/code&gt; (см. Выше), когда фрейм окна для выхода был специально создан для отображения буфера этого окна и буфер не уничтожается.</target>
        </trans-unit>
        <trans-unit id="4c5fe7b1d57c09eb96638f6d29a8d55ea70693dc" translate="yes" xml:space="preserve">
          <source>The function to call when the user invokes the button, which is passed the single argument &lt;var&gt;button&lt;/var&gt;. By default this is &lt;code&gt;ignore&lt;/code&gt;, which does nothing.</source>
          <target state="translated">Функция, вызываемая, когда пользователь нажимает кнопку, которой передается &lt;var&gt;button&lt;/var&gt; с одним аргументом . По умолчанию это &lt;code&gt;ignore&lt;/code&gt; , которое ничего не делает.</target>
        </trans-unit>
        <trans-unit id="0d346489c44defc5f50064e457e61d13f6a78be1" translate="yes" xml:space="preserve">
          <source>The function to define a new widget is called &lt;code&gt;define-widget&lt;/code&gt;. The first argument is the symbol we want to make a new widget type. The second argument is a symbol representing an existing widget, the new widget is going to be defined in terms of difference from the existing widget. For the purpose of defining new customization types, the &lt;code&gt;lazy&lt;/code&gt; widget is perfect, because it accepts a &lt;code&gt;:type&lt;/code&gt; keyword argument with the same syntax as the keyword argument to &lt;code&gt;defcustom&lt;/code&gt; with the same name. The third argument is a documentation string for the new widget. You will be able to see that string with the</source>
          <target state="translated">Функция для определения нового виджета называется &lt;code&gt;define-widget&lt;/code&gt; . Первый аргумент - это символ, который мы хотим создать для нового типа виджета. Второй аргумент - это символ, представляющий существующий виджет, новый виджет будет определяться с точки зрения отличия от существующего виджета. Для определения новых типов настройки идеально подходит &lt;code&gt;lazy&lt;/code&gt; виджет, поскольку он принимает аргумент ключевого слова &lt;code&gt;:type&lt;/code&gt; с тем же синтаксисом, что и аргумент ключевого слова для &lt;code&gt;defcustom&lt;/code&gt; с тем же именем. Третий аргумент - это строка документации для нового виджета. Вы сможете увидеть эту строку с</target>
        </trans-unit>
        <trans-unit id="a3be86b3d84b881b3e6d6fe8ec9995afa24e5702" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s return value is the string typed by the user in the minibuffer. However, when called interactively or if the optional argument &lt;var&gt;convert&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it converts any input color name into the corresponding RGB value string and instead returns that. This function requires a valid color specification to be input. Empty color names are allowed when &lt;var&gt;allow-empty&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and the user enters null input.</source>
          <target state="translated">Возвращаемое значение функции - строка, введенная пользователем в минибуфер. Однако при интерактивном вызове или если необязательный аргумент &lt;var&gt;convert&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , он преобразует любое имя входного цвета в соответствующую строку значения RGB и вместо этого возвращает это. Эта функция требует ввода действительной спецификации цвета. Допускаются пустые имена цветов, если &lt;var&gt;allow-empty&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; и пользователь вводит нулевой ввод.</target>
        </trans-unit>
        <trans-unit id="24f9a1a492a75ddcf165b535a392f152caa63130" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;create-image&lt;/code&gt;, &lt;code&gt;defimage&lt;/code&gt; and &lt;code&gt;find-image&lt;/code&gt; provide convenient ways to create image descriptors.</source>
          <target state="translated">Функции &lt;code&gt;create-image&lt;/code&gt; , &lt;code&gt;defimage&lt;/code&gt; и &lt;code&gt;find-image&lt;/code&gt; предоставляют удобные способы создания дескрипторов изображений.</target>
        </trans-unit>
        <trans-unit id="930041ed415a386650d1c27097780e324d3d97ff" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;default-value&lt;/code&gt; and &lt;code&gt;setq-default&lt;/code&gt; access and change a variable&amp;rsquo;s default value regardless of whether the current buffer has a buffer-local binding. For example, you could use &lt;code&gt;setq-default&lt;/code&gt; to change the default setting of &lt;code&gt;paragraph-start&lt;/code&gt; for most buffers; and this would work even when you are in a C or Lisp mode buffer that has a buffer-local value for this variable.</source>
          <target state="translated">Функции &lt;code&gt;default-value&lt;/code&gt; и &lt;code&gt;setq-default&lt;/code&gt; осуществляют доступ и изменяют значение переменной по умолчанию независимо от того, имеет ли текущий буфер привязку к локальному буферу. Например, вы можете использовать &lt;code&gt;setq-default&lt;/code&gt; , чтобы изменить настройку по умолчанию для &lt;code&gt;paragraph-start&lt;/code&gt; для большинства буферов; и это будет работать, даже если вы находитесь в буфере режима C или Lisp, который имеет локальное в буфере значение для этой переменной.</target>
        </trans-unit>
        <trans-unit id="54fbaadcac6b546aa87b794bc4678dae8bd49959" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;event-modifiers&lt;/code&gt; and &lt;code&gt;event-basic-type&lt;/code&gt; are provided to get such information conveniently.</source>
          <target state="translated">Функции &lt;code&gt;event-modifiers&lt;/code&gt; и &lt;code&gt;event-basic-type&lt;/code&gt; предназначены для удобного получения такой информации.</target>
        </trans-unit>
        <trans-unit id="f14e4ed51e1588f4afeb3f2808a8e88fb021c9e4" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;ffloor&lt;/code&gt;, &lt;code&gt;fceiling&lt;/code&gt;, &lt;code&gt;fround&lt;/code&gt;, and &lt;code&gt;ftruncate&lt;/code&gt; take a floating-point argument and return a floating-point result whose value is a nearby integer. &lt;code&gt;ffloor&lt;/code&gt; returns the nearest integer below; &lt;code&gt;fceiling&lt;/code&gt;, the nearest integer above; &lt;code&gt;ftruncate&lt;/code&gt;, the nearest integer in the direction towards zero; &lt;code&gt;fround&lt;/code&gt;, the nearest integer.</source>
          <target state="translated">Функции &lt;code&gt;ffloor&lt;/code&gt; , &lt;code&gt;fceiling&lt;/code&gt; , &lt;code&gt;fround&lt;/code&gt; и &lt;code&gt;ftruncate&lt;/code&gt; принимают аргумент с плавающей запятой и возвращают результат с плавающей запятой, значение которого является ближайшим целым числом. &lt;code&gt;ffloor&lt;/code&gt; возвращает ближайшее целое число ниже; &lt;code&gt;fceiling&lt;/code&gt; , ближайшее целое число выше; &lt;code&gt;ftruncate&lt;/code&gt; , ближайшее целое число в направлении к нулю; &lt;code&gt;fround&lt;/code&gt; , ближайшее целое число.</target>
        </trans-unit>
        <trans-unit id="2c140441fed92d7b6f61e961aac8a0aa69c39764" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;make-progress-reporter&lt;/code&gt; and &lt;code&gt;y-or-n-p&lt;/code&gt; don&amp;rsquo;t have to do anything special to activate the message log combination feature. It operates whenever two consecutive messages are logged that share a common prefix ending in &amp;lsquo;</source>
          <target state="translated">Функции &lt;code&gt;make-progress-reporter&lt;/code&gt; и &lt;code&gt;y-or-n-p&lt;/code&gt; не должны делать ничего особенного, чтобы активировать функцию комбинирования журнала сообщений. Он работает всякий раз, когда регистрируются два последовательных сообщения, имеющих общий префикс, оканчивающийся на '</target>
        </trans-unit>
        <trans-unit id="1da791873fb7d70506573ba68b6bb43c2ea88baa" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;match-data&lt;/code&gt; and &lt;code&gt;set-match-data&lt;/code&gt; read or write the entire match data, all at once.</source>
          <target state="translated">Функции &lt;code&gt;match-data&lt;/code&gt; и &lt;code&gt;set-match-data&lt;/code&gt; читают или записывают все данные совпадения одновременно.</target>
        </trans-unit>
        <trans-unit id="9f3763eba26d0fcd98983ff84241c85f7df4ee68" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;mouse-position&lt;/code&gt; and &lt;code&gt;set-mouse-position&lt;/code&gt; give access to the current position of the mouse.</source>
          <target state="translated">Функции &lt;code&gt;mouse-position&lt;/code&gt; и &lt;code&gt;set-mouse-position&lt;/code&gt; предоставляют доступ к текущему положению мыши.</target>
        </trans-unit>
        <trans-unit id="f6d9b7af5bfb64034127dfa877a8ed48be4859ab" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;window-next-sibling&lt;/code&gt; and &lt;code&gt;window-prev-sibling&lt;/code&gt; should not be confused with the functions &lt;code&gt;next-window&lt;/code&gt; and &lt;code&gt;previous-window&lt;/code&gt;, which return the next and previous window, respectively, in the cyclic ordering of windows (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">Функции &lt;code&gt;window-next-sibling&lt;/code&gt; и &lt;code&gt;window-prev-sibling&lt;/code&gt; не следует путать с функциями &lt;code&gt;next-window&lt;/code&gt; и &lt;code&gt;previous-window&lt;/code&gt; , которые возвращают следующее и предыдущее окно, соответственно, в циклическом порядке окон (см. &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Циклическое упорядочение окон&lt;/a&gt; ). .</target>
        </trans-unit>
        <trans-unit id="a4599c26cca67f961f777727cb6555459567d4a8" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;window-state-get&lt;/code&gt; and &lt;code&gt;window-state-put&lt;/code&gt; also allow to exchange the contents of two live windows. The following function does precisely that:</source>
          <target state="translated">Функции &lt;code&gt;window-state-get&lt;/code&gt; и &lt;code&gt;window-state-put&lt;/code&gt; также позволяют обмениваться содержимым двух живых окон. Следующая функция делает именно это:</target>
        </trans-unit>
        <trans-unit id="9fce438f0ed03253c60350ad3e2d979328b783c3" translate="yes" xml:space="preserve">
          <source>The functions and variables described in this section evaluate forms, specify limits to the evaluation process, or record recently returned values. Loading a file also does evaluation (see &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;).</source>
          <target state="translated">Функции и переменные, описанные в этом разделе, оценивают формы, задают ограничения для процесса оценки или записывают недавно возвращенные значения. При загрузке файла также выполняется оценка (см. &lt;a href=&quot;loading#Loading&quot;&gt;Загрузка&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8e4bd3a8ad416b6b274e61c0311ccc7aceb93329" translate="yes" xml:space="preserve">
          <source>The functions are called in the order listed, with one argument, a buffer position &lt;var&gt;pos&lt;/var&gt;. Collectively they should attempt to assign faces to the text in the current buffer starting at &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">Эти функции вызываются в указанном порядке, с одним аргументом, позиции буфера &lt;var&gt;pos&lt;/var&gt; . Вместе они должны попытаться назначить лица тексту в текущем буфере, начиная с &lt;var&gt;pos&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="6521a8bc086f1a3f8aefcf593df4fa2328b88776" translate="yes" xml:space="preserve">
          <source>The functions below signal an error if &lt;var&gt;keymap&lt;/var&gt; is not a keymap, or if &lt;var&gt;key&lt;/var&gt; is not a string or vector representing a key sequence. You can use event types (symbols) as shorthand for events that are lists. The &lt;code&gt;kbd&lt;/code&gt; function (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;) is a convenient way to specify the key sequence.</source>
          <target state="translated">Приведенные ниже функции сигнализируют об ошибке, если &lt;var&gt;keymap&lt;/var&gt; &lt;var&gt;key&lt;/var&gt; не является раскладкой клавиш или если ключ не является строкой или вектором, представляющим последовательность клавиш. Вы можете использовать типы событий (символы) как сокращение для событий, которые являются списками. Функция &lt;code&gt;kbd&lt;/code&gt; (см. &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Последовательности клавиш&lt;/a&gt; ) - удобный способ указать последовательность клавиш.</target>
        </trans-unit>
        <trans-unit id="78ab65059bf6060d13b0ce32e999f9aebe8f6925" translate="yes" xml:space="preserve">
          <source>The functions described in this section accept a fixed set of specification characters. The next section describes a function &lt;code&gt;format-spec&lt;/code&gt; which can accept custom specification characters, such as &amp;lsquo;</source>
          <target state="translated">Функции, описанные в этом разделе, принимают фиксированный набор символов спецификации. В следующем разделе описывается &lt;code&gt;format-spec&lt;/code&gt; функции , которая может принимать символы пользовательской спецификации, такие как '</target>
        </trans-unit>
        <trans-unit id="e86fa617815c4b094651f86026f3ee350a021eb8" translate="yes" xml:space="preserve">
          <source>The functions described in this section control how terminal colors are used by Emacs.</source>
          <target state="translated">Функции,описанные в этом разделе,управляют тем,как цвета терминала используются Emacs.</target>
        </trans-unit>
        <trans-unit id="f169c28c5651085613c243ee2d7b8b6a97f3524f" translate="yes" xml:space="preserve">
          <source>The functions following next return the pixel widths and heights of the native, outer and inner frame and the text area (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;) of a given frame. For a text terminal, the results are in characters rather than pixels.</source>
          <target state="translated">Следующие далее функции возвращают ширину и высоту в пикселях собственного, внешнего и внутреннего фрейма и текстовой области (см. &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Макет фрейма&lt;/a&gt; ) данного фрейма. Для текстового терминала результаты выражаются в символах, а не в пикселях.</target>
        </trans-unit>
        <trans-unit id="9720c55f16c083bb07299d34092580b6ec7aab89" translate="yes" xml:space="preserve">
          <source>The functions for parsing words described below use the syntax table and &lt;code&gt;char-script-table&lt;/code&gt; to decide whether a given character is part of a word. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;, and see &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;.</source>
          <target state="translated">Функции синтаксического анализа слов, описанные ниже, используют таблицу синтаксиса и таблицу &lt;code&gt;char-script-table&lt;/code&gt; чтобы решить, является ли данный символ частью слова. См. &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Таблицы синтаксиса&lt;/a&gt; и См. &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Свойства символов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84e553855a8b2ca8a57ae076b9aaef6d677d36c1" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;quit-window-hook&lt;/code&gt; are run before doing anything else.</source>
          <target state="translated">Функции в &lt;code&gt;quit-window-hook&lt;/code&gt; запускаются до того, как делать что-либо еще.</target>
        </trans-unit>
        <trans-unit id="0e800d933c2fece3683cecc14ad7da075688816e" translate="yes" xml:space="preserve">
          <source>The functions in this list could be called either when the file is visited and Emacs wants to decode its contents, and/or when the file&amp;rsquo;s buffer is about to be saved and Emacs wants to determine how to encode its contents.</source>
          <target state="translated">Функции в этом списке могут быть вызваны либо при посещении файла, когда Emacs хочет декодировать его содержимое, и / или когда буфер файла собирается быть сохраненным, и Emacs хочет определить, как кодировать его содержимое.</target>
        </trans-unit>
        <trans-unit id="669d58b77eada51f85ff6d10a60632f82115668b" translate="yes" xml:space="preserve">
          <source>The functions in this section are documented mainly because you can customize the naming conventions for backup files by redefining them. If you change one, you probably need to change the rest.</source>
          <target state="translated">Функции,описанные в этом разделе,документированы в основном потому,что вы можете настроить соглашения об именовании файлов резервных копий,переопределив их.Если вы измените одну из них,вам,вероятно,придется изменить и остальные.</target>
        </trans-unit>
        <trans-unit id="ddf6614534160f658305998c350626e957a6f335" translate="yes" xml:space="preserve">
          <source>The functions in this section describe the basic capabilities of a particular display. Lisp programs can use them to adapt their behavior to what the display can do. For example, a program that ordinarily uses a popup menu could use the minibuffer if popup menus are not supported.</source>
          <target state="translated">Функции,описанные в этом разделе,описывают основные возможности конкретного дисплея.С их помощью программы Lisp могут адаптировать свое поведение к тому,на что способен дисплей.Например,программа,которая обычно использует всплывающее меню,может использовать минибуфер,если всплывающие меню не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="f00c70d2142808c1b8036e8e15d164e6ace38175" translate="yes" xml:space="preserve">
          <source>The functions in this section do not actually access files, so they can operate on file names that do not refer to an existing file or directory.</source>
          <target state="translated">Функции,описанные в этом разделе,на самом деле не имеют доступа к файлам,поэтому они могут работать с именами файлов,которые не относятся к существующему файлу или каталогу.</target>
        </trans-unit>
        <trans-unit id="016907d83a21967cc3e08258bf37e7e359803f3f" translate="yes" xml:space="preserve">
          <source>The functions in this section rename, copy, delete, link, and set the modes (permissions) of files. Typically, they signal a &lt;code&gt;file-error&lt;/code&gt; error if they fail to perform their function, reporting the system-dependent error message that describes the reason for the failure. If they fail because a file is missing, they signal a &lt;code&gt;file-missing&lt;/code&gt; error instead.</source>
          <target state="translated">Функции в этом разделе переименовывают, копируют, удаляют, связывают и устанавливают режимы (разрешения) файлов. Как правило, они сигнализируют &lt;code&gt;file-error&lt;/code&gt; ошибке файла, если не выполняют свою функцию, сообщая системно-зависимое сообщение об ошибке, которое описывает причину сбоя. Если они терпят неудачу из-за отсутствия файла, они сигнализируют об ошибке &lt;code&gt;file-missing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="890b0146bfdda395f86d14be742c512118143bed" translate="yes" xml:space="preserve">
          <source>The functions in this section return unpredictable values unless otherwise stated.</source>
          <target state="translated">Функции,описанные в данном разделе,возвращают непредсказуемые значения,если не указано иное.</target>
        </trans-unit>
        <trans-unit id="f48a87c01a2f7dffcffdc543703f3903c8ef0749" translate="yes" xml:space="preserve">
          <source>The functions in this section test for numbers, or for a specific type of number. The functions &lt;code&gt;integerp&lt;/code&gt; and &lt;code&gt;floatp&lt;/code&gt; can take any type of Lisp object as argument (they would not be of much use otherwise), but the &lt;code&gt;zerop&lt;/code&gt; predicate requires a number as its argument. See also &lt;code&gt;integer-or-marker-p&lt;/code&gt; and &lt;code&gt;number-or-marker-p&lt;/code&gt;, in &lt;a href=&quot;predicates-on-markers#Predicates-on-Markers&quot;&gt;Predicates on Markers&lt;/a&gt;.</source>
          <target state="translated">Функции в этом разделе проверяют числа или номера определенного типа. Функции &lt;code&gt;integerp&lt;/code&gt; и &lt;code&gt;floatp&lt;/code&gt; могут принимать любой тип объекта Lisp в качестве аргумента (в противном случае они не имели бы особого &lt;code&gt;zerop&lt;/code&gt; ), но предикат zerop требует в качестве аргумента число. См. Также &lt;code&gt;integer-or-marker-p&lt;/code&gt; и &lt;code&gt;number-or-marker-p&lt;/code&gt; в &lt;a href=&quot;predicates-on-markers#Predicates-on-Markers&quot;&gt;Предикатах по маркерам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64495a754cd6c704e9f9d907a29b2bd6ed3d60e3" translate="yes" xml:space="preserve">
          <source>The functions on this hook should generally return quickly, since they may be called very often (e.g., from &lt;code&gt;post-command-hook&lt;/code&gt;). Supplying a function for &lt;var&gt;collection&lt;/var&gt; is strongly recommended if generating the list of completions is an expensive operation. Emacs may internally call functions in &lt;code&gt;completion-at-point-functions&lt;/code&gt; many times, but care about the value of &lt;var&gt;collection&lt;/var&gt; for only some of these calls. By supplying a function for &lt;var&gt;collection&lt;/var&gt;, Emacs can defer generating completions until necessary. You can use &lt;code&gt;completion-table-dynamic&lt;/code&gt; to create a wrapper function:</source>
          <target state="translated">Функции на этой ловушке обычно должны возвращаться быстро, так как они могут вызываться очень часто (например, из &lt;code&gt;post-command-hook&lt;/code&gt; ). Настоятельно рекомендуется предоставить функцию для &lt;var&gt;collection&lt;/var&gt; , если создание списка завершений - дорогостоящая операция. Emacs может многократно вызывать внутренние функции в функциях &lt;code&gt;completion-at-point-functions&lt;/code&gt; , но заботится о значении &lt;var&gt;collection&lt;/var&gt; только для некоторых из этих вызовов. Предоставляя функцию для &lt;var&gt;collection&lt;/var&gt; , Emacs может отложить создание завершений до тех пор, пока это необходимо. Вы можете использовать &lt;code&gt;completion-table-dynamic&lt;/code&gt; для создания функции-оболочки:</target>
        </trans-unit>
        <trans-unit id="2b93b057b358caf809f0e8e2015f2926ba7f4928" translate="yes" xml:space="preserve">
          <source>The functions should record the faces they assign by setting the &lt;code&gt;face&lt;/code&gt; property. They should also add a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;fontified&lt;/code&gt; property to all the text they have assigned faces to. That property tells redisplay that faces have been assigned to that text already.</source>
          <target state="translated">Функции должны записывать лица, которые они назначают, устанавливая свойство &lt;code&gt;face&lt;/code&gt; . Им также следует добавить свойство, &lt;code&gt;fontified&lt;/code&gt; &lt;code&gt;nil&lt;/code&gt; fontified, для всего текста, которому они назначили лица. Это свойство сообщает redisplay, что лица уже назначены этому тексту.</target>
        </trans-unit>
        <trans-unit id="41a0cd34297ecae8f4a088b103fb22bcddfee322" translate="yes" xml:space="preserve">
          <source>The functions that modify the contents of buffers are described in &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">Функции, изменяющие содержимое буферов, описаны в &lt;a href=&quot;text#Text&quot;&gt;тексте&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f40f1de7f1f1333998ea5f91c2f809716617bf8b" translate="yes" xml:space="preserve">
          <source>The functions you use in these hooks should save and restore the match data if they do anything that uses regular expressions; otherwise, they will interfere in bizarre ways with the editing operations that call them.</source>
          <target state="translated">Функции,которые вы используете в этих перехватчиках,должны сохранять и восстанавливать данные о совпадении,если они делают что-либо,использующее регулярные выражения;в противном случае,они будут причудливым образом вмешиваться в операции редактирования,вызывающие их.</target>
        </trans-unit>
        <trans-unit id="9072c6223cc7e87e04b922ff1eeb8eb85826e5dd" translate="yes" xml:space="preserve">
          <source>The fundamental interface to input methods is through the variable &lt;code&gt;input-method-function&lt;/code&gt;. See &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;Reading One Event&lt;/a&gt;, and &lt;a href=&quot;invoking-the-input-method#Invoking-the-Input-Method&quot;&gt;Invoking the Input Method&lt;/a&gt;.</source>
          <target state="translated">Фундаментальный интерфейс к методам ввода - через переменную &lt;code&gt;input-method-function&lt;/code&gt; . См. &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;Чтение одного события&lt;/a&gt; и &lt;a href=&quot;invoking-the-input-method#Invoking-the-Input-Method&quot;&gt;Вызов метода ввода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="864ab21bc83654287c4cd15a4aee02d9312d9750" translate="yes" xml:space="preserve">
          <source>The gap in the buffer.</source>
          <target state="translated">Зазор в буфере.</target>
        </trans-unit>
        <trans-unit id="2874b04cef330c832d718bb6b17cf07f619d5cf4" translate="yes" xml:space="preserve">
          <source>The garbage collector described above is used to manage data visible from Lisp programs, as well as most of the data internally used by the Lisp interpreter. Sometimes it may be useful to allocate temporary internal objects using the C stack of the interpreter. This can help performance, as stack allocation is typically faster than using heap memory to allocate and the garbage collector to free. The downside is that using such objects after they are freed results in undefined behavior, so uses should be well thought out and carefully debugged by using the &lt;code&gt;GC_CHECK_MARKED_OBJECTS&lt;/code&gt; feature (see</source>
          <target state="translated">Описанный выше сборщик мусора используется для управления данными, видимыми из программ Lisp, а также большей частью данных, используемых внутри интерпретатора Lisp. Иногда может быть полезно выделить временные внутренние объекты с помощью стека C интерпретатора. Это может повысить производительность, поскольку выделение стека обычно происходит быстрее, чем использование памяти кучи для выделения и сборщика мусора для ее освобождения. &lt;code&gt;GC_CHECK_MARKED_OBJECTS&lt;/code&gt; является то, что использование таких объектов после их освобождения приводит к неопределенному поведению, поэтому использование должно быть хорошо продумано и тщательно отлажено с помощью функции GC_CHECK_MARKED_OBJECTS (см.</target>
        </trans-unit>
        <trans-unit id="da7a69d66cc2d899f159c6785baa3eb8aa0ce902" translate="yes" xml:space="preserve">
          <source>The general sequence functions &lt;code&gt;copy-sequence&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are often useful for objects known to be arrays. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">Функции общей последовательности &lt;code&gt;copy-sequence&lt;/code&gt; и &lt;code&gt;length&lt;/code&gt; часто полезны для объектов, известных как массивы. См. &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Последовательные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74ab5893b0c67e70995b4afd47d2628e73c2db5f" translate="yes" xml:space="preserve">
          <source>The geometry of a frame depends on the toolkit that was used to build this instance of Emacs and the terminal that displays the frame. This chapter describes these dependencies and some of the functions to deal with them. Note that the &lt;var&gt;frame&lt;/var&gt; argument of all of these functions has to specify a live frame (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;). If omitted or &lt;code&gt;nil&lt;/code&gt;, it specifies the selected frame (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">Геометрия фрейма зависит от набора инструментов, который использовался для создания этого экземпляра Emacs, и терминала, отображающего фрейм. В этой главе описываются эти зависимости и некоторые функции для работы с ними. Обратите внимание, что аргумент &lt;var&gt;frame&lt;/var&gt; всех этих функций должен указывать живой кадр (см. &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Удаление кадров&lt;/a&gt; ). Если опущен или &lt;code&gt;nil&lt;/code&gt; , он указывает выбранный кадр (см. &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Фокус ввода&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b1b29a18ef7eb3bc56262e0c7ebd91ab2315293b" translate="yes" xml:space="preserve">
          <source>The global break condition is the simplest way to find where in your code some event occurs, but it makes code run much more slowly. So you should reset the condition to &lt;code&gt;nil&lt;/code&gt; when not using it.</source>
          <target state="translated">Условие глобального прерывания - это самый простой способ найти, где в вашем коде происходит какое-либо событие, но оно заставляет код работать намного медленнее. Поэтому вам следует сбросить условие на &lt;code&gt;nil&lt;/code&gt; когда оно не используется.</target>
        </trans-unit>
        <trans-unit id="677591024d62617ead5c6d0b2e26233fd0d1c3c3" translate="yes" xml:space="preserve">
          <source>The global keymap used for the</source>
          <target state="translated">Глобальная ключевая карта,используемая для</target>
        </trans-unit>
        <trans-unit id="f34b8f5f97a899dc0235f5429a6468bfeef23c7c" translate="yes" xml:space="preserve">
          <source>The global value of a variable with buffer-local bindings is also called the &lt;em&gt;default&lt;/em&gt; value, because it is the value that is in effect whenever neither the current buffer nor the selected frame has its own binding for the variable.</source>
          <target state="translated">Глобальное значение переменной с привязками к локальному буферу также называется значением по &lt;em&gt;умолчанию&lt;/em&gt; , потому что это значение, которое действует всякий раз, когда ни текущий буфер, ни выбранный кадр не имеют собственной привязки для переменной.</target>
        </trans-unit>
        <trans-unit id="48d60332f6bc67502145a457cd0abab79aebcbd7" translate="yes" xml:space="preserve">
          <source>The glyph for indicating a character displayed as an octal character code (the default is &amp;lsquo;</source>
          <target state="translated">Глиф для обозначения символа, отображаемого в виде восьмеричного кода символа (по умолчанию '</target>
        </trans-unit>
        <trans-unit id="4c3656eced1ce2d785af3b405b7e21744ff87d83" translate="yes" xml:space="preserve">
          <source>The glyph for indicating a control character (the default is &amp;lsquo;</source>
          <target state="translated">Глиф для обозначения управляющего символа (по умолчанию '</target>
        </trans-unit>
        <trans-unit id="69c90a66f7f1266d48dbdea6d60aeb7561e7e5b2" translate="yes" xml:space="preserve">
          <source>The glyph for the end of a continued line (the default is &amp;lsquo;</source>
          <target state="translated">Символ конца продолжающейся строки (по умолчанию '</target>
        </trans-unit>
        <trans-unit id="306df86e6b80484f756d552795447d03999ab82a" translate="yes" xml:space="preserve">
          <source>The glyph for the end of a truncated screen line (the default for this is &amp;lsquo;</source>
          <target state="translated">Глиф, обозначающий конец усеченной строки экрана (по умолчанию это '</target>
        </trans-unit>
        <trans-unit id="e37bea5e929c17d760a16f5f703fed0ee026e680" translate="yes" xml:space="preserve">
          <source>The glyph used to draw the border between side-by-side windows (the default is &amp;lsquo;</source>
          <target state="translated">Глиф, используемый для рисования границы между соседними окнами (по умолчанию '</target>
        </trans-unit>
        <trans-unit id="97cde47c6c4afb345587e69edf666417f9a205ca" translate="yes" xml:space="preserve">
          <source>The gradient created (and inserted into the SVG object) can later be used by all functions that create shapes.</source>
          <target state="translated">Созданный градиент (и вставленный в объект SVG)в дальнейшем может быть использован всеми функциями,создающими фигуры.</target>
        </trans-unit>
        <trans-unit id="0f64a77472c5aab1a530dafab8dc80afd47098d3" translate="yes" xml:space="preserve">
          <source>The grammar category &lt;code&gt;id&lt;/code&gt; has no right hand side: this does not mean that it can match only the empty string, since as mentioned any sequence of sexps can appear anywhere anyway.</source>
          <target state="translated">Грамматика категория &lt;code&gt;id&lt;/code&gt; не имеет правой стороны: это не значит , что он может соответствовать только пустую строку, так как уже упоминалось любая последовательность s - выражения могут появляться в любом месте в любом случае.</target>
        </trans-unit>
        <trans-unit id="731ba1b7288e05cf815c9c7aa4fd003aeedac70a" translate="yes" xml:space="preserve">
          <source>The greediness of some repetition forms can be controlled using the following constructs. However, it is usually better to use the explicit non-greedy forms above when such matching is required.</source>
          <target state="translated">Жадность некоторых повторяющихся форм можно контролировать с помощью следующих конструкций.Однако,как правило,лучше использовать явные не жадные формы,приведенные выше,когда такое соответствие требуется.</target>
        </trans-unit>
        <trans-unit id="25880d28e40fdac189e642330863b2e6c8e69129" translate="yes" xml:space="preserve">
          <source>The group ID of the effective user ID, a number.</source>
          <target state="translated">Групповой идентификатор действующего пользователя,номер.</target>
        </trans-unit>
        <trans-unit id="b554cee81a954e5281b1fceb788df4a63ce37792" translate="yes" xml:space="preserve">
          <source>The handler function must handle all of the above operations, and possibly others to be added in the future. It need not implement all these operations itself&amp;mdash;when it has nothing special to do for a certain operation, it can reinvoke the primitive, to handle the operation in the usual way. It should always reinvoke the primitive for an operation it does not recognize. Here&amp;rsquo;s one way to do this:</source>
          <target state="translated">Функция-обработчик должна обрабатывать все перечисленные выше операции и, возможно, другие, которые будут добавлены в будущем. Ему не нужно реализовывать все эти операции самим - когда ему нечего делать для определенной операции, он может повторно вызвать примитив, чтобы обработать операцию обычным способом. Он всегда должен повторно вызывать примитив для операции, которую он не распознает. Вот один из способов сделать это:</target>
        </trans-unit>
        <trans-unit id="8c0ade08243887c3328d4d5be685acc33d281985" translate="yes" xml:space="preserve">
          <source>The handler specifies condition name &lt;code&gt;arith-error&lt;/code&gt; so that it will handle only division-by-zero errors. Other kinds of errors will not be handled (by this &lt;code&gt;condition-case&lt;/code&gt;). Thus:</source>
          <target state="translated">Обработчик указывает &lt;code&gt;arith-error&lt;/code&gt; имени условия, чтобы обрабатывать только ошибки деления на ноль. Другие типы ошибок не будут обрабатываться (в этом &lt;code&gt;condition-case&lt;/code&gt; ). Таким образом:</target>
        </trans-unit>
        <trans-unit id="5e2f99bb60355a4bbc279516a684257561edba5f" translate="yes" xml:space="preserve">
          <source>The header and footer strings.</source>
          <target state="translated">Заголовок и нижний колонтитул.</target>
        </trans-unit>
        <trans-unit id="e6adc3e0fab908b197122795c03e598c9a217b17" translate="yes" xml:space="preserve">
          <source>The height in pixels of the mode line and the header line, or -1 if not known.</source>
          <target state="translated">Высота в пикселях линии режима и линии заголовка,или -1,если неизвестно.</target>
        </trans-unit>
        <trans-unit id="9e8ea212a3dcb1bbe9f9c723144aa8ee19f65b61" translate="yes" xml:space="preserve">
          <source>The height is normally the length of &lt;var&gt;bits&lt;/var&gt;. However, you can specify a different height with non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;height&lt;/var&gt;. The width is normally 8, but you can specify a different width with non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;width&lt;/var&gt;. The width must be an integer between 1 and 16.</source>
          <target state="translated">Высота обычно равна длине &lt;var&gt;bits&lt;/var&gt; . Тем не менее, вы можете указать другую высоту с не- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;height&lt;/var&gt; . Ширина обычно 8, но вы можете задать другую ширину с не- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;width&lt;/var&gt; . Ширина должна быть целым числом от 1 до 16.</target>
        </trans-unit>
        <trans-unit id="52397327e47c6d0da26d3462e7bc63626661f579" translate="yes" xml:space="preserve">
          <source>The height of horizontal scroll bars, in pixels, or &lt;code&gt;nil&lt;/code&gt; meaning to use the default height.</source>
          <target state="translated">Высота горизонтальных полос прокрутки в пикселях или &lt;code&gt;nil&lt;/code&gt; ,что означает использование высоты по умолчанию.</target>
        </trans-unit>
        <trans-unit id="085e0e5d1f8cb968ce655bf2b24ca248fa12970b" translate="yes" xml:space="preserve">
          <source>The height of the default face must be specified using an integer; floating point and function values are not allowed.</source>
          <target state="translated">Высота лица по умолчанию должна быть указана с помощью целого числа;значения с плавающей точкой и функции не допускаются.</target>
        </trans-unit>
        <trans-unit id="d18f875e6e2637cf49c5905a5f35264c51a521b7" translate="yes" xml:space="preserve">
          <source>The height of the font in pixels.</source>
          <target state="translated">Высота шрифта в пикселях.</target>
        </trans-unit>
        <trans-unit id="bcc4b1c7f0f04cad27e2f37687ce77b17aac9cc1" translate="yes" xml:space="preserve">
          <source>The height of the font. In the simplest case, this is an integer in units of 1/10 point.</source>
          <target state="translated">Высота шрифта.В простейшем случае это целое число в единицах 1/10 точки.</target>
        </trans-unit>
        <trans-unit id="3ed16f18e3452e0d7fb567a3976b1f69a672c4c7" translate="yes" xml:space="preserve">
          <source>The height of the line contents is the maximum height of any character or image on that display line, including the final newline if there is one. (A display line that is continued doesn&amp;rsquo;t include a final newline.) That is the default line height, if you do nothing to specify a greater height. (In the most common case, this equals the height of the corresponding frame&amp;rsquo;s default font, see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;.)</source>
          <target state="translated">Высота содержимого строки - это максимальная высота любого символа или изображения в этой строке отображения, включая последнюю строку новой строки, если таковая имеется. (Продолжающаяся строка дисплея не включает последний символ новой строки.) Это высота строки по умолчанию, если вы ничего не сделаете для указания большей высоты. (В наиболее распространенном случае это равно высоте шрифта по умолчанию соответствующего фрейма, см. &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Шрифт фрейма&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="fa5537f62fa0722eb0e8bcb5ec344261bd62fa37" translate="yes" xml:space="preserve">
          <source>The help character is special after prefix keys, too. If it has no binding as a subcommand of the prefix key, it runs &lt;code&gt;describe-prefix-bindings&lt;/code&gt;, which displays a list of all the subcommands of the prefix key.</source>
          <target state="translated">Символ справки также является специальным после префиксных ключей. Если у него нет привязки в качестве подкоманды префиксного ключа, он запускает &lt;code&gt;describe-prefix-bindings&lt;/code&gt; , который отображает список всех подкоманд префиксного ключа.</target>
        </trans-unit>
        <trans-unit id="cf1897bec9624ad141a9f5fdb49dabce4abf14b2" translate="yes" xml:space="preserve">
          <source>The high-level completion functions &lt;code&gt;read-file-name&lt;/code&gt;, &lt;code&gt;read-directory-name&lt;/code&gt;, and &lt;code&gt;read-shell-command&lt;/code&gt; are designed to read file names, directory names, and shell commands, respectively. They provide special features, including automatic insertion of the default directory.</source>
          <target state="translated">Функции завершения высокого уровня &lt;code&gt;read-file-name&lt;/code&gt; , &lt;code&gt;read-directory-name&lt;/code&gt; и &lt;code&gt;read-shell-command&lt;/code&gt; предназначены для чтения имен файлов, имен каталогов и команд оболочки соответственно. Они предоставляют специальные функции, включая автоматическую вставку каталога по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fc37323f324eaba3ae4eff83c852720c416eda92" translate="yes" xml:space="preserve">
          <source>The homepage for GNU Emacs is at &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;https://www.gnu.org/software/emacs/&lt;/a&gt;. For information on using Emacs, refer to the &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/emacs.html&quot;&gt;Emacs Manual&lt;/a&gt;. To view this manual in other formats, click &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Домашняя страница GNU Emacs находится по адресу &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;https://www.gnu.org/software/emacs/&lt;/a&gt; . Информацию об использовании Emacs &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/emacs.html&quot;&gt;смотрите в Руководстве&lt;/a&gt; по Emacs . Чтобы просмотреть это руководство в других форматах, щелкните &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b911bf982537bd609db0a1e22baeb6c2bb97081a" translate="yes" xml:space="preserve">
          <source>The hook functions are called both before and after each change. If the functions save the information they receive, and compare notes between calls, they can determine exactly what change has been made in the buffer text.</source>
          <target state="translated">Функции крюка вызываются как до,так и после каждого изменения.Если функции сохраняют полученную информацию и сравнивают заметки между вызовами,они могут точно определить,какое изменение было внесено в текст буфера.</target>
        </trans-unit>
        <trans-unit id="22eea4ac020189ebcc5a0b2b55d9b0917f8943a9" translate="yes" xml:space="preserve">
          <source>The hook functions in &lt;code&gt;write-file-functions&lt;/code&gt; are also responsible for encoding the data (if desired): they must choose a suitable coding system and end-of-line conversion (see &lt;a href=&quot;lisp-and-coding-systems#Lisp-and-Coding-Systems&quot;&gt;Lisp and Coding Systems&lt;/a&gt;), perform the encoding (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;), and set &lt;code&gt;last-coding-system-used&lt;/code&gt; to the coding system that was used (see &lt;a href=&quot;encoding-and-i_002fo#Encoding-and-I_002fO&quot;&gt;Encoding and I/O&lt;/a&gt;).</source>
          <target state="translated">Функции ловушки в функциях &lt;code&gt;write-file-functions&lt;/code&gt; также отвечают за кодирование данных (при желании): они должны выбрать подходящую систему кодирования и преобразование в конце строки (см. &lt;a href=&quot;lisp-and-coding-systems#Lisp-and-Coding-Systems&quot;&gt;Лисп и системы кодирования&lt;/a&gt; ), выполнить кодирование (см. &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Явное кодирование&lt;/a&gt; ) и установите &lt;code&gt;last-coding-system-used&lt;/code&gt; для используемой системы кодирования (см. &lt;a href=&quot;encoding-and-i_002fo#Encoding-and-I_002fO&quot;&gt;Кодирование и ввод-вывод&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a83d039cd150de7d3779ef3fed719d6f59169d0d" translate="yes" xml:space="preserve">
          <source>The hook variable&amp;rsquo;s value can also be a single function&amp;mdash;either a lambda expression or a symbol with a function definition&amp;mdash;which &lt;code&gt;run-hooks&lt;/code&gt; calls. But this usage is obsolete.</source>
          <target state="translated">Значение переменной ловушки также может быть отдельной функцией - либо лямбда-выражением, либо символом с определением функции, - которую вызывает &lt;code&gt;run-hooks&lt;/code&gt; . Но это использование устарело.</target>
        </trans-unit>
        <trans-unit id="917207ef55ed03cab5a1b55d69aa1063946c90b6" translate="yes" xml:space="preserve">
          <source>The horizontal scroll position is measured in units of the normal character width, which is the width of space in the default font. Thus, if the value is 5, that means the window contents are scrolled left by 5 times the normal character width. How many characters actually disappear off to the left depends on their width, and could vary from line to line.</source>
          <target state="translated">Положение горизонтальной прокрутки измеряется в единицах нормальной ширины символа,которая является шириной пробела в шрифте по умолчанию.Таким образом,если значение 5,то это означает,что содержимое окна прокручивается влево в 5 раз шире нормальной ширины символа.Сколько символов на самом деле исчезает слева,зависит от их ширины и может варьироваться от строки к строке.</target>
        </trans-unit>
        <trans-unit id="2c1208df201cdc168e0e1bc7a6b67590a4982002" translate="yes" xml:space="preserve">
          <source>The hour of the day, as an integer between 0 and 23.</source>
          <target state="translated">Час дня,как целое число от 0 до 23.</target>
        </trans-unit>
        <trans-unit id="ff593a5384b2422b04132851d0695820fe2b360f" translate="yes" xml:space="preserve">
          <source>The hyper modifier.</source>
          <target state="translated">Гипер-модификатор.</target>
        </trans-unit>
        <trans-unit id="49029170f2d47fd9fece1b8af2f1320f67032a13" translate="yes" xml:space="preserve">
          <source>The idea of these variables is that you set them once and for all to the defaults you want, and then do not change them again. To specify a particular coding system for a particular operation in a Lisp program, don&amp;rsquo;t change these variables; instead, override them using &lt;code&gt;coding-system-for-read&lt;/code&gt; and &lt;code&gt;coding-system-for-write&lt;/code&gt; (see &lt;a href=&quot;specifying-coding-systems#Specifying-Coding-Systems&quot;&gt;Specifying Coding Systems&lt;/a&gt;).</source>
          <target state="translated">Идея этих переменных заключается в том, что вы устанавливаете их раз и навсегда на значения по умолчанию, которые вам нужны, а затем больше не меняете их. Чтобы указать конкретную систему кодирования для конкретной операции в программе на Лиспе, не изменяйте эти переменные; вместо этого переопределите их, используя &lt;code&gt;coding-system-for-read&lt;/code&gt; и &lt;code&gt;coding-system-for-write&lt;/code&gt; (см. &lt;a href=&quot;specifying-coding-systems#Specifying-Coding-Systems&quot;&gt;Определение систем кодирования&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9bcbe3e1bcf694fbe61bf24fe3189fb33ab88208" translate="yes" xml:space="preserve">
          <source>The identified of the shape.</source>
          <target state="translated">Идентификация формы.</target>
        </trans-unit>
        <trans-unit id="fcfecb9412ebffc1d18084e74054383228e6b207" translate="yes" xml:space="preserve">
          <source>The image is looked for in &lt;code&gt;image-load-path&lt;/code&gt;.</source>
          <target state="translated">Изображение ищется в &lt;code&gt;image-load-path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ea3cffbf70cec22855c36d36842437f817a7f5e" translate="yes" xml:space="preserve">
          <source>The image type. See &lt;a href=&quot;image-formats#Image-Formats&quot;&gt;Image Formats&lt;/a&gt;. Every image descriptor must include this property.</source>
          <target state="translated">Тип изображения. См. &lt;a href=&quot;image-formats#Image-Formats&quot;&gt;Форматы изображений&lt;/a&gt; . Каждый дескриптор изображения должен включать это свойство.</target>
        </trans-unit>
        <trans-unit id="caab580d160dc64b9167916da831f3bf977e17a4" translate="yes" xml:space="preserve">
          <source>The indentation functions are used to examine, move to, and change whitespace that is at the beginning of a line. Some of the functions can also change whitespace elsewhere on a line. Columns and indentation count from zero at the left margin.</source>
          <target state="translated">Функции отступа используются для изучения,перемещения и изменения пробела,который находится в начале строки.Некоторые из функций могут также изменять пробельные символы в других местах строки.Столбцы и отступы отсчитываются от нуля в левом поле.</target>
        </trans-unit>
        <trans-unit id="6cabff1a9cf356561844c4900ceadda4f5c31acc" translate="yes" xml:space="preserve">
          <source>The index alist can have three types of elements. Simple elements look like this:</source>
          <target state="translated">Индекс алиста может иметь три типа элементов.Простые элементы выглядят так:</target>
        </trans-unit>
        <trans-unit id="7a2782dc40deb6629a41f6379bf7a7210bdb0f97" translate="yes" xml:space="preserve">
          <source>The index of the first character of the string is 0, the index of the second character is 1, and so on.</source>
          <target state="translated">Индекс первого символа строки равен 0,индекс второго символа-1 и так далее.</target>
        </trans-unit>
        <trans-unit id="60e96bc26c021609e7a6560eb3d5be49e8d331cc" translate="yes" xml:space="preserve">
          <source>The initial threshold value is &lt;code&gt;GC_DEFAULT_THRESHOLD&lt;/code&gt;, defined in</source>
          <target state="translated">Начальное пороговое значение - &lt;code&gt;GC_DEFAULT_THRESHOLD&lt;/code&gt; , определенное в</target>
        </trans-unit>
        <trans-unit id="9fd1b2d43c07a66938f2a442d8dcfd842c600cd8" translate="yes" xml:space="preserve">
          <source>The initial value must be &lt;code&gt;nil&lt;/code&gt; except in cases where (1) the mode is preloaded in Emacs, or (2) it is painless for loading to enable the mode even though the user did not request it. For instance, if the mode has no effect unless something else is enabled, and will always be loaded by that time, enabling it by default is harmless. But these are unusual circumstances. Normally, the initial value must be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Начальное значение должно быть &lt;code&gt;nil&lt;/code&gt; за исключением случаев, когда (1) режим предварительно загружен в Emacs или (2) безболезненно загружается режим, даже если пользователь не запрашивал его. Например, если режим не действует, если не включено что-то еще, и всегда будет загружаться к этому времени, включение его по умолчанию безвредно. Но это необычные обстоятельства. Обычно начальное значение должно быть &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5ea75158d88e76423df4c71cfe451830055f3b4" translate="yes" xml:space="preserve">
          <source>The initialization function should perform whatever initialization is required for the module. In addition, it can perform the following tasks:</source>
          <target state="translated">Функция инициализации должна выполнять любые действия по инициализации модуля.Кроме того,она может выполнять следующие задачи:</target>
        </trans-unit>
        <trans-unit id="2048f16a290b5e24dd2783eb5cab68b8c1d9c150" translate="yes" xml:space="preserve">
          <source>The input characters are generated by &lt;var&gt;function&lt;/var&gt;, which must support two kinds of calls:</source>
          <target state="translated">Входные символы генерируются &lt;var&gt;function&lt;/var&gt; , которая должна поддерживать два типа вызовов:</target>
        </trans-unit>
        <trans-unit id="d16b3143ae14de892229a66c0119a9b13c4bbc54" translate="yes" xml:space="preserve">
          <source>The input characters are read from &lt;var&gt;buffer&lt;/var&gt;, starting with the character directly after point. Point advances as characters are read.</source>
          <target state="translated">Входные символы читаются из &lt;var&gt;buffer&lt;/var&gt; , начиная с символа сразу после точки. Точка продвигается вперед по мере чтения символов.</target>
        </trans-unit>
        <trans-unit id="b99b6f486be0660a0034322da91996c0f39b3329" translate="yes" xml:space="preserve">
          <source>The input characters are read from the buffer that &lt;var&gt;marker&lt;/var&gt; is in, starting with the character directly after the marker. The marker position advances as characters are read. The value of point in the buffer has no effect when the stream is a marker.</source>
          <target state="translated">Входные символы считываются из буфера, в котором находится &lt;var&gt;marker&lt;/var&gt; , начиная с символа сразу после маркера. Положение маркера увеличивается по мере считывания символов. Значение точки в буфере не действует, если поток является маркером.</target>
        </trans-unit>
        <trans-unit id="d8b5e8488b3fb00ae952a888effb061b3b3f5bf0" translate="yes" xml:space="preserve">
          <source>The input characters are taken from &lt;var&gt;string&lt;/var&gt;, starting at the first character in the string and using as many characters as required.</source>
          <target state="translated">Входные символы берутся из &lt;var&gt;string&lt;/var&gt; , начиная с первого символа в строке и используя столько символов, сколько требуется.</target>
        </trans-unit>
        <trans-unit id="30d1dd399ecaac7e239b3eddf29871a33b0d6701" translate="yes" xml:space="preserve">
          <source>The input method function is not called when reading the second and subsequent events of a key sequence. Thus, these characters are not subject to input method processing. The input method function should test the values of &lt;code&gt;overriding-local-map&lt;/code&gt; and &lt;code&gt;overriding-terminal-local-map&lt;/code&gt;; if either of these variables is non-&lt;code&gt;nil&lt;/code&gt;, the input method should put its argument into a list and return that list with no further processing.</source>
          <target state="translated">Функция метода ввода не вызывается при чтении второго и последующих событий ключевой последовательности. Таким образом, эти символы не подлежат обработке методом ввода. Функция метода ввода должна проверять значения &lt;code&gt;overriding-local-map&lt;/code&gt; и &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; ; если любая из этих переменных не равна &lt;code&gt;nil&lt;/code&gt; , метод ввода должен поместить свой аргумент в список и вернуть этот список без дальнейшей обработки.</target>
        </trans-unit>
        <trans-unit id="f8c4abba5f74f931bc34d6747a6123acafdf7779" translate="yes" xml:space="preserve">
          <source>The input method function should return a list of events which should be used as input. (If the list is &lt;code&gt;nil&lt;/code&gt;, that means there is no input, so &lt;code&gt;read-event&lt;/code&gt; waits for another event.) These events are processed before the events in &lt;code&gt;unread-command-events&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;). Events returned by the input method function are not passed to the input method function again, even if they are printing characters with no modifier bits.</source>
          <target state="translated">Функция метода ввода должна возвращать список событий, которые следует использовать в качестве ввода. (Если список равен &lt;code&gt;nil&lt;/code&gt; , это означает, что нет ввода, поэтому &lt;code&gt;read-event&lt;/code&gt; ожидает другого события.) Эти события обрабатываются перед событиями в &lt;code&gt;unread-command-events&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Ввод события - разное&amp;raquo;&lt;/a&gt; ). События, возвращаемые функцией метода ввода, не передаются снова в функцию метода ввода, даже если они печатают символы без битов модификатора.</target>
        </trans-unit>
        <trans-unit id="539f747cb977830607d3cb710459ac2c2e5fa6fa" translate="yes" xml:space="preserve">
          <source>The inputs to GnuTLS cryptographic functions can be specified in several ways, both as primitive Emacs Lisp types or as lists.</source>
          <target state="translated">Входы в криптографические функции GnuTLS могут быть заданы несколькими способами,как в виде примитивных типов Emacs Lisp,так и в виде списков.</target>
        </trans-unit>
        <trans-unit id="a7b8358b8f766540c234e4f8211a9601148d23fb" translate="yes" xml:space="preserve">
          <source>The inserted whitespace characters inherit text properties from the surrounding text (usually, from the preceding text only). See &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Sticky Properties&lt;/a&gt;.</source>
          <target state="translated">Вставленные символы пробела наследуют свойства текста от окружающего текста (обычно только от предыдущего текста). См. &amp;laquo; &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Липкие свойства&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19fcbfab08e4368504efbf1b8e28b4430ed27384" translate="yes" xml:space="preserve">
          <source>The insertion functions convert text from unibyte to multibyte in order to insert in a multibyte buffer, and vice versa&amp;mdash;if the text comes from a string or from a buffer. However, they do not convert unibyte character codes 128 through 255 to multibyte characters, not even if the current buffer is a multibyte buffer. See &lt;a href=&quot;converting-representations#Converting-Representations&quot;&gt;Converting Representations&lt;/a&gt;.</source>
          <target state="translated">Функции вставки преобразуют текст из однобайтового в многобайтовый, чтобы вставить в многобайтовый буфер, и наоборот - если текст поступает из строки или из буфера. Однако они не преобразуют коды однобайтовых символов от 128 до 255 в многобайтовые символы, даже если текущий буфер является многобайтовым. См. &lt;a href=&quot;converting-representations#Converting-Representations&quot;&gt;Преобразование представлений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9edd2288269cf326b182d9af537f1760ef9f7146" translate="yes" xml:space="preserve">
          <source>The integer -1 looks like this:</source>
          <target state="translated">Целое число -1 выглядит так:</target>
        </trans-unit>
        <trans-unit id="2f33429d3899a8b5708f577a6767b2323bf9589e" translate="yes" xml:space="preserve">
          <source>The integer number of 365-day years.</source>
          <target state="translated">Целое число 365-дневных лет.</target>
        </trans-unit>
        <trans-unit id="e0d849236066efb1e790a734829181ed8c3e9ff5" translate="yes" xml:space="preserve">
          <source>The integer number of days.</source>
          <target state="translated">Целое число дней.</target>
        </trans-unit>
        <trans-unit id="5cf7a7da13ec55fcd8e83c9522a19ff613f26c8a" translate="yes" xml:space="preserve">
          <source>The integer number of hours.</source>
          <target state="translated">Целое число часов.</target>
        </trans-unit>
        <trans-unit id="bb774face5c62942103b0f3a113c848cd3042edd" translate="yes" xml:space="preserve">
          <source>The integer number of minutes.</source>
          <target state="translated">Целое число минут.</target>
        </trans-unit>
        <trans-unit id="9cbc76323d9ab5bd63ae8f77ccce189f3b0df5e3" translate="yes" xml:space="preserve">
          <source>The integer number of seconds.</source>
          <target state="translated">Целое число секунд.</target>
        </trans-unit>
        <trans-unit id="d26badfedc58bbcef7881a113b18e385a9856fff" translate="yes" xml:space="preserve">
          <source>The intent of &lt;code&gt;key-translation-map&lt;/code&gt; is for users to map one character set to another, including ordinary characters normally bound to &lt;code&gt;self-insert-command&lt;/code&gt;.</source>
          <target state="translated">Назначение &lt;code&gt;key-translation-map&lt;/code&gt; состоит в том, чтобы пользователи отображали один набор символов в другой, включая обычные символы, обычно связанные с &lt;code&gt;self-insert-command&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20d665cdf72ab80e27c444ceb9eb5618fb5457fb" translate="yes" xml:space="preserve">
          <source>The interactive declaration is a list of the form &lt;code&gt;(interactive
&lt;var&gt;code-string&lt;/var&gt;)&lt;/code&gt;. This declares how to provide arguments if the function is used interactively. Functions with this declaration are called &lt;em&gt;commands&lt;/em&gt;; they can be called using</source>
          <target state="translated">Интерактивное объявление - это список формы &lt;code&gt;(interactive &lt;var&gt;code-string&lt;/var&gt;)&lt;/code&gt; . Это объявляет, как предоставить аргументы, если функция используется в интерактивном режиме. Функции с этим объявлением называются &lt;em&gt;командами&lt;/em&gt; ; их можно назвать с помощью</target>
        </trans-unit>
        <trans-unit id="ae08d2dbfcabdf279e14b8cbd62c32467dc9f2d0" translate="yes" xml:space="preserve">
          <source>The interactive spec (if any). This can be a string or a Lisp expression. It is &lt;code&gt;nil&lt;/code&gt; for a function that isn&amp;rsquo;t interactive.</source>
          <target state="translated">Интерактивная спецификация (если есть). Это может быть строка или выражение Лиспа. Для неинтерактивной функции он равен &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2978362f714e301a7d1292d0bf49abf86d8926e4" translate="yes" xml:space="preserve">
          <source>The internal border is a border drawn by Emacs around the inner frame (see below). Its width is specified by the &lt;code&gt;internal-border-width&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). Its color is specified by the background of the &lt;code&gt;internal-border&lt;/code&gt; face.</source>
          <target state="translated">Внутренняя граница - это граница, нарисованная Emacs вокруг внутренней рамки (см. Ниже). Его ширина определяется параметром рамки &lt;code&gt;internal-border-width&lt;/code&gt; (см. &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Параметры макета&lt;/a&gt; ). Его цвет определяется фоном лицевой стороны &lt;code&gt;internal-border&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6cb4b170f13ea9783523a2b390523918e77d98d" translate="yes" xml:space="preserve">
          <source>The interval tree which records the text properties of this buffer.</source>
          <target state="translated">Дерево интервалов,в которое записываются текстовые свойства этого буфера.</target>
        </trans-unit>
        <trans-unit id="2b193cdd686eaf4559317677f35332fe025a0bac" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;make-temp-file&lt;/code&gt; is to prevent two different users or two different jobs from trying to use the exact same file name.</source>
          <target state="translated">Задача &lt;code&gt;make-temp-file&lt;/code&gt; - предотвратить попытки двух разных пользователей или двух разных заданий использовать одно и то же имя файла.</target>
        </trans-unit>
        <trans-unit id="7d566fc76f2e6f4607003117618cbc1ab1b17dde" translate="yes" xml:space="preserve">
          <source>The key bindings are not commands, just symbols that are meaningful to the functions that use this map.</source>
          <target state="translated">Связки клавиш-это не команды,это просто символы,которые имеют значение для функций,использующих эту карту.</target>
        </trans-unit>
        <trans-unit id="9bf1df2bbd01f543a3f0da8d68e7df8f3b5f2761" translate="yes" xml:space="preserve">
          <source>The key definition and lookup functions accept an alternate syntax for event types in a key sequence that is a vector: you can use a list containing modifier names plus one base event (a character or function key name). For example, &lt;code&gt;(control ?a)&lt;/code&gt; is equivalent to &lt;code&gt;?\C-a&lt;/code&gt; and &lt;code&gt;(hyper control left)&lt;/code&gt; is equivalent to &lt;code&gt;C-H-left&lt;/code&gt;. One advantage of such lists is that the precise numeric codes for the modifier bits don&amp;rsquo;t appear in compiled files.</source>
          <target state="translated">Функции определения ключа и поиска принимают альтернативный синтаксис для типов событий в последовательности клавиш, которая является вектором: вы можете использовать список, содержащий имена модификаторов плюс одно базовое событие (имя символа или функциональной клавиши). Например, &lt;code&gt;(control ?a)&lt;/code&gt; эквивалентно &lt;code&gt;?\C-a&lt;/code&gt; а &lt;code&gt;(hyper control left)&lt;/code&gt; эквивалентно &lt;code&gt;C-H-left&lt;/code&gt; . Одним из преимуществ таких списков является то, что точные числовые коды для битов модификатора не отображаются в скомпилированных файлах.</target>
        </trans-unit>
        <trans-unit id="628ce08bf218a05f5cf92a428c7d664ca579e0cc" translate="yes" xml:space="preserve">
          <source>The key sequence is translated into a command through the currently active keymaps. See &lt;a href=&quot;key-lookup#Key-Lookup&quot;&gt;Key Lookup&lt;/a&gt;, for information on how this is done. The result should be a keyboard macro or an interactively callable function. If the key is</source>
          <target state="translated">Последовательность клавиш преобразуется в команду через текущие активные раскладки клавиатуры. См. &lt;a href=&quot;key-lookup#Key-Lookup&quot;&gt;Key Lookup&lt;/a&gt; , чтобы узнать, как это делается. Результатом должен быть макрос клавиатуры или интерактивно вызываемая функция. Если ключ</target>
        </trans-unit>
        <trans-unit id="569f93f6d66684562d4fe017a80dce902677f074" translate="yes" xml:space="preserve">
          <source>The key sequences bound in a major mode keymap should usually start with</source>
          <target state="translated">Последовательности клавиш,привязанные в мажорной раскладке,обычно должны начинаться с</target>
        </trans-unit>
        <trans-unit id="7950f6c49354bf68f27de0ba9e4826c034b3d35d" translate="yes" xml:space="preserve">
          <source>The key translation function receives one argument, which is the prompt that was specified in &lt;code&gt;read-key-sequence&lt;/code&gt;&amp;mdash;or &lt;code&gt;nil&lt;/code&gt; if the key sequence is being read by the editor command loop. In most cases you can ignore the prompt value.</source>
          <target state="translated">Функция трансляции клавиш получает один аргумент, который представляет собой приглашение, указанное в &lt;code&gt;read-key-sequence&lt;/code&gt; - или &lt;code&gt;nil&lt;/code&gt; если последовательность клавиш считывается циклом команд редактора. В большинстве случаев вы можете игнорировать значение подсказки.</target>
        </trans-unit>
        <trans-unit id="9c724c94075d725787e5d581c532371826e09281" translate="yes" xml:space="preserve">
          <source>The keymap &lt;var&gt;keymap&lt;/var&gt; is active whenever &lt;var&gt;variable&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt; value. Typically &lt;var&gt;variable&lt;/var&gt; is the variable that enables or disables a minor mode. See &lt;a href=&quot;keymaps-and-minor-modes#Keymaps-and-Minor-Modes&quot;&gt;Keymaps and Minor Modes&lt;/a&gt;.</source>
          <target state="translated">Раскладка раскладки &lt;var&gt;keymap&lt;/var&gt; активна, когда &lt;var&gt;variable&lt;/var&gt; имеет &lt;code&gt;nil&lt;/code&gt; значение. Обычно &lt;var&gt;variable&lt;/var&gt; - это переменная, которая включает или отключает второстепенный режим. См. &lt;a href=&quot;keymaps-and-minor-modes#Keymaps-and-Minor-Modes&quot;&gt;Раскладки клавиатуры и второстепенные режимы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="778deedcebfd753f594652405f80825572066516" translate="yes" xml:space="preserve">
          <source>The keymap binding of a prefix key is used for looking up the event that follows the prefix key. (It may instead be a symbol whose function definition is a keymap. The effect is the same, but the symbol serves as a name for the prefix key.) Thus, the binding of</source>
          <target state="translated">Привязка префиксного ключа к раскладке используется для поиска события,следующего за префиксным ключом.(Вместо этого это может быть символ,чьим определением функции является раскладка.Эффект тот же,но символ служит именем для префиксного ключа).Таким образом,привязка</target>
        </trans-unit>
        <trans-unit id="fd6135585180a24face202b71c46d7d4e0321d54" translate="yes" xml:space="preserve">
          <source>The keymap defining the contents of the tab bar. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html#Tab-Bars&quot;&gt;Tab Bars&lt;/a&gt; in</source>
          <target state="translated">Раскладка, определяющая содержимое панели вкладок. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html#Tab-Bars&quot;&gt;Панели вкладок&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="00481501df4b455e9d0b9f4120448e983b64e522" translate="yes" xml:space="preserve">
          <source>The keymap defining the contents of the tab bar. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html#Tab-Bars&quot;&gt;Tab Bars&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbdf9f5934eb2533828d5b82e95608cabd6b6788" translate="yes" xml:space="preserve">
          <source>The keymap defining the contents of the tool bar. See &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;.</source>
          <target state="translated">Раскладка, определяющая содержимое панели инструментов. См. &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Панель инструментов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e0069d3ae618f793f1fa2e4550594c9b75d2f72" translate="yes" xml:space="preserve">
          <source>The keymap for characters following</source>
          <target state="translated">Клавишная карта для следующих символов</target>
        </trans-unit>
        <trans-unit id="c3be0c367d559d4bcc94776ddab26cb11131700e" translate="yes" xml:space="preserve">
          <source>The keymap for translating key sequences to preferred alternatives. If there are none, then it contains an empty sparse keymap. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">Раскладка для перевода последовательностей клавиш в предпочтительные альтернативы. Если их нет, то он содержит пустую разреженную раскладку клавиатуры. См. &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Раздел Раскладки перевода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13b5ef05286cb723bbea46afe3ee9fb02d42a48b" translate="yes" xml:space="preserve">
          <source>The keymap for translating keypad and function keys. If there are none, then it contains an empty sparse keymap. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">Раскладка для перевода клавиатуры и функциональных клавиш. Если их нет, то он содержит пустую разреженную раскладку клавиатуры. См. &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Раздел Раскладки перевода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7dbb9716bd01a43838b53fe70be9a55bda1567" translate="yes" xml:space="preserve">
          <source>The keymap used by Prog mode. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;.</source>
          <target state="translated">Раскладка клавиатуры, используемая в режиме Prog. См. &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Основные основные режимы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab245ddfa519516f3703f74bf4d4e8acfbe8994" translate="yes" xml:space="preserve">
          <source>The keymap used by Special mode. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;.</source>
          <target state="translated">Раскладка клавиатуры, используемая в специальном режиме. См. &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Основные основные режимы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e1ee3684d67359a88650e4fd1514d3bc1388140" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;&amp;amp;rest&lt;/code&gt; (which must be followed by a single argument name) indicates that any number of arguments can follow. The single argument name following &lt;code&gt;&amp;amp;rest&lt;/code&gt; receives, as its value, a list of all the remaining arguments passed to the function. Do not write &lt;code&gt;&amp;amp;rest&lt;/code&gt; when you call the function.</source>
          <target state="translated">Ключевое слово &lt;code&gt;&amp;amp;rest&lt;/code&gt; (за которым должно следовать одно имя аргумента) указывает, что может следовать любое количество аргументов. Единственное имя аргумента, следующее за &lt;code&gt;&amp;amp;rest&lt;/code&gt; получает в качестве значения список всех оставшихся аргументов, переданных функции. Не пишите &lt;code&gt;&amp;amp;rest&lt;/code&gt; при вызове функции.</target>
        </trans-unit>
        <trans-unit id="b3a2577e25ef4336cea54dd5ba9525c1ac899432" translate="yes" xml:space="preserve">
          <source>The kill ring records killed text as strings in a list, most recent first. A short kill ring, for example, might look like this:</source>
          <target state="translated">Кольцо убийств записывает убитые тексты как строки в списке,последний первый.Короткое кольцо убийства,например,может выглядеть вот так:</target>
        </trans-unit>
        <trans-unit id="5310f9fc7ac635f8fb0f1f88e49865f96859f4ff" translate="yes" xml:space="preserve">
          <source>The kind of background&amp;mdash;either &lt;code&gt;light&lt;/code&gt; or &lt;code&gt;dark&lt;/code&gt;.</source>
          <target state="translated">Тип фона - &lt;code&gt;light&lt;/code&gt; или &lt;code&gt;dark&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bde2896c92556891a9a522e437678bf44d775c73" translate="yes" xml:space="preserve">
          <source>The kind of display associated with the terminal. This is the symbol returned by the function &lt;code&gt;terminal-live-p&lt;/code&gt; (i.e., &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;w32&lt;/code&gt;, &lt;code&gt;ns&lt;/code&gt;, or &lt;code&gt;pc&lt;/code&gt;). See &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;.</source>
          <target state="translated">Вид дисплея, связанный с терминалом. Это символ, возвращаемый функцией &lt;code&gt;terminal-live-p&lt;/code&gt; (т.е. &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;w32&lt;/code&gt; , &lt;code&gt;ns&lt;/code&gt; или &lt;code&gt;pc&lt;/code&gt; ). См. &lt;a href=&quot;frames#Frames&quot;&gt;Кадры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5c7577d4b10f36a18bbab67549b2c58143927c6" translate="yes" xml:space="preserve">
          <source>The kind of window system the terminal uses&amp;mdash;either &lt;code&gt;graphic&lt;/code&gt; (any graphics-capable display), &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;pc&lt;/code&gt; (for the MS-DOS console), &lt;code&gt;w32&lt;/code&gt; (for MS Windows 9X/NT/2K/XP), or &lt;code&gt;tty&lt;/code&gt; (a non-graphics-capable display). See &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;window-system&lt;/a&gt;.</source>
          <target state="translated">Тип оконной системы, которую использует терминал: &lt;code&gt;graphic&lt;/code&gt; (любой дисплей с графической поддержкой), &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;pc&lt;/code&gt; (для консоли MS-DOS), &lt;code&gt;w32&lt;/code&gt; (для MS Windows 9X / NT / 2K / XP) или &lt;code&gt;tty&lt;/code&gt; (не -графический дисплей). См. &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;Оконную систему&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01ef18971dfd086d0f3bdf7cf4fbd00a90436fd8" translate="yes" xml:space="preserve">
          <source>The language that the font should support. The value should be a symbol whose name is a two-letter ISO-639 language name. On X, the value is matched against the &amp;ldquo;Additional Style&amp;rdquo; field of the XLFD name of a font, if it is non-empty. On MS-Windows, fonts matching the spec are required to support codepages needed for the language. Currently, only a small set of CJK languages is supported with this property: &amp;lsquo;</source>
          <target state="translated">The language that the font should support. The value should be a symbol whose name is a two-letter ISO-639 language name. On X, the value is matched against the &amp;ldquo;Additional Style&amp;rdquo; field of the XLFD name of a font, if it is non-empty. On MS-Windows, fonts matching the spec are required to support codepages needed for the language. Currently, only a small set of CJK languages is supported with this property: &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="88a7e776b65a937667815eb3a6eaf67a01ff78ce" translate="yes" xml:space="preserve">
          <source>The last</source>
          <target state="translated">Последний</target>
        </trans-unit>
        <trans-unit id="dccd686ce06e60750b4337124ef02d3ac122a8dc" translate="yes" xml:space="preserve">
          <source>The last form also makes sure that none of the created side windows are accessible via</source>
          <target state="translated">Последняя форма также гарантирует,что ни одно из созданных боковых окон не доступно через</target>
        </trans-unit>
        <trans-unit id="37be7c944a107a298305238e57bd913b69f97266" translate="yes" xml:space="preserve">
          <source>The last line of the documentation string can specify calling conventions different from the actual function arguments. Write text like this:</source>
          <target state="translated">В последней строке строки документации можно указать соглашения о вызове,отличные от реальных аргументов функции.Пишите текст вот так:</target>
        </trans-unit>
        <trans-unit id="ddcb40b64096f3eaa561946b2a19e292247e85b0" translate="yes" xml:space="preserve">
          <source>The last optional item, &lt;var&gt;noerror&lt;/var&gt;, overrides the normal error when the text can&amp;rsquo;t be encoded using the specified or chosen coding system. When &lt;var&gt;noerror&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function silently uses &lt;code&gt;raw-text&lt;/code&gt; coding instead.</source>
          <target state="translated">The last optional item, &lt;var&gt;noerror&lt;/var&gt; , overrides the normal error when the text can&amp;rsquo;t be encoded using the specified or chosen coding system. When &lt;var&gt;noerror&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , this function silently uses &lt;code&gt;raw-text&lt;/code&gt; coding instead.</target>
        </trans-unit>
        <trans-unit id="ab880934452e3eacbf10a61506631f3e7e86eb71" translate="yes" xml:space="preserve">
          <source>The last thing &lt;code&gt;after-find-file&lt;/code&gt; does is call all the functions in the list &lt;code&gt;find-file-hook&lt;/code&gt;.</source>
          <target state="translated">The last thing &lt;code&gt;after-find-file&lt;/code&gt; does is call all the functions in the list &lt;code&gt;find-file-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0003f3c71cb33be508071e1a28e112d5cd1a93de" translate="yes" xml:space="preserve">
          <source>The last three elements give additional information about the font. &lt;var&gt;fixed-p&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; if the font is fixed-pitch. &lt;var&gt;full&lt;/var&gt; is the full name of the font, and &lt;var&gt;registry-and-encoding&lt;/var&gt; is a string giving the registry and encoding of the font.</source>
          <target state="translated">The last three elements give additional information about the font. &lt;var&gt;fixed-p&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; if the font is fixed-pitch. &lt;var&gt;full&lt;/var&gt; is the full name of the font, and &lt;var&gt;registry-and-encoding&lt;/var&gt; is a string giving the registry and encoding of the font.</target>
        </trans-unit>
        <trans-unit id="6c23485a20be9be1024893537c3477b18df28155" translate="yes" xml:space="preserve">
          <source>The last two values in &lt;var&gt;subexp-highlighter&lt;/var&gt;, &lt;var&gt;override&lt;/var&gt; and &lt;var&gt;laxmatch&lt;/var&gt;, are optional flags. If &lt;var&gt;override&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this element can override existing fontification made by previous elements of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If it is &lt;code&gt;keep&lt;/code&gt;, then each character is fontified if it has not been fontified already by some other element. If it is &lt;code&gt;prepend&lt;/code&gt;, the face specified by &lt;var&gt;facespec&lt;/var&gt; is added to the beginning of the &lt;code&gt;font-lock-face&lt;/code&gt; property. If it is &lt;code&gt;append&lt;/code&gt;, the face is added to the end of the &lt;code&gt;font-lock-face&lt;/code&gt; property.</source>
          <target state="translated">The last two values in &lt;var&gt;subexp-highlighter&lt;/var&gt; , &lt;var&gt;override&lt;/var&gt; and &lt;var&gt;laxmatch&lt;/var&gt; , are optional flags. If &lt;var&gt;override&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; , this element can override existing fontification made by previous elements of &lt;code&gt;font-lock-keywords&lt;/code&gt; . If it is &lt;code&gt;keep&lt;/code&gt; , then each character is fontified if it has not been fontified already by some other element. If it is &lt;code&gt;prepend&lt;/code&gt; , the face specified by &lt;var&gt;facespec&lt;/var&gt; is added to the beginning of the &lt;code&gt;font-lock-face&lt;/code&gt; property. If it is &lt;code&gt;append&lt;/code&gt; , the face is added to the end of the &lt;code&gt;font-lock-face&lt;/code&gt; property.</target>
        </trans-unit>
        <trans-unit id="992a1c51c72e3b37e35b641195dd8337943b2596" translate="yes" xml:space="preserve">
          <source>The last way to customize Imenu for a major mode is to set the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt;:</source>
          <target state="translated">The last way to customize Imenu for a major mode is to set the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3ce25b448ce366df7fb622e8f8aa9485fb8699a5" translate="yes" xml:space="preserve">
          <source>The layer 2 address (Ethernet MAC address, for instance).</source>
          <target state="translated">Адрес второго уровня (например,Ethernet MAC-адрес).</target>
        </trans-unit>
        <trans-unit id="a47ca85c8b203a3f800aea8cd96b6a61549d375d" translate="yes" xml:space="preserve">
          <source>The layout of side windows on the left or right of a frame is not affected by the value of this variable.</source>
          <target state="translated">На расположение боковых окон слева или справа от рамы значение этой переменной не влияет.</target>
        </trans-unit>
        <trans-unit id="6009ec89412305c052749a52bf8f3c7e8431cbcf" translate="yes" xml:space="preserve">
          <source>The layout of such a frame might appear as follows:</source>
          <target state="translated">Макет такой рамки может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="3b025a85b17d93fe80056a9fbbc6aa0c12299f7e" translate="yes" xml:space="preserve">
          <source>The least specialized major mode is called &lt;em&gt;Fundamental mode&lt;/em&gt;, which has no mode-specific definitions or variable settings.</source>
          <target state="translated">The least specialized major mode is called &lt;em&gt;Fundamental mode&lt;/em&gt;, which has no mode-specific definitions or variable settings.</target>
        </trans-unit>
        <trans-unit id="cf0a2de49bf1a621f861fc10249ddf1c3e8e8639" translate="yes" xml:space="preserve">
          <source>The left-hand and top edges of this window, measured in pixels, relative to the top-left corner (0, 0) of the window&amp;rsquo;s native frame.</source>
          <target state="translated">The left-hand and top edges of this window, measured in pixels, relative to the top-left corner (0, 0) of the window&amp;rsquo;s native frame.</target>
        </trans-unit>
        <trans-unit id="0e159da910fc18db25e6c0af5e99bdff417543a4" translate="yes" xml:space="preserve">
          <source>The left-hand edge of the window, measured in columns, relative to the leftmost column (column 0) of the window&amp;rsquo;s native frame.</source>
          <target state="translated">The left-hand edge of the window, measured in columns, relative to the leftmost column (column 0) of the window&amp;rsquo;s native frame.</target>
        </trans-unit>
        <trans-unit id="85b6183109a9a7b6efad378049191669aefc0fd8" translate="yes" xml:space="preserve">
          <source>The length of the array is fixed once you create it; you cannot change the length of an existing array.</source>
          <target state="translated">Длина массива фиксируется после его создания;изменить длину существующего массива нельзя.</target>
        </trans-unit>
        <trans-unit id="bb9a27d08446955ce106744ef3b710dbc15d43b6" translate="yes" xml:space="preserve">
          <source>The length of the file this buffer is visiting, when last read or saved. It can have 2 special values: -1 means auto-saving was turned off in this buffer, and -2 means don&amp;rsquo;t turn off auto-saving if buffer text shrinks a lot. This and other fields concerned with saving are not kept in the &lt;code&gt;buffer_text&lt;/code&gt; structure because indirect buffers are never saved.</source>
          <target state="translated">The length of the file this buffer is visiting, when last read or saved. It can have 2 special values: -1 means auto-saving was turned off in this buffer, and -2 means don&amp;rsquo;t turn off auto-saving if buffer text shrinks a lot. This and other fields concerned with saving are not kept in the &lt;code&gt;buffer_text&lt;/code&gt; structure because indirect buffers are never saved.</target>
        </trans-unit>
        <trans-unit id="2735538fcce561a7758f21b1ebbd03c667ab66da" translate="yes" xml:space="preserve">
          <source>The length of the old text is the difference between the buffer positions before and after that text as it was before the change. As for the changed text, its length is simply the difference between the first two arguments.</source>
          <target state="translated">Длина старого текста-это разница между позициями буфера до и после этого текста,как это было до изменения.Что касается измененного текста,то его длина-это просто разница между первыми двумя аргументами.</target>
        </trans-unit>
        <trans-unit id="959fbf29c3f8bb0bab090fdff0de9a589ee90bcb" translate="yes" xml:space="preserve">
          <source>The license for this documentation.</source>
          <target state="translated">Лицензия на эту документацию.</target>
        </trans-unit>
        <trans-unit id="620613354f3eaf838b72f4f12e00f9803d440b0f" translate="yes" xml:space="preserve">
          <source>The line functions in the previous section count text lines, delimited only by newline characters. By contrast, these functions count screen lines, which are defined by the way the text appears on the screen. A text line is a single screen line if it is short enough to fit the width of the selected window, but otherwise it may occupy several screen lines.</source>
          <target state="translated">Функции строки в предыдущей секции подсчитывают текстовые строки,разделенные только новыми символами строки.Эти функции,напротив,подсчитывают строки экрана,которые определяются способом отображения текста на экране.Текстовая строка-это одна строка экрана,если она достаточно коротка,чтобы соответствовать ширине выбранного окна,но в противном случае она может занимать несколько строк экрана.</target>
        </trans-unit>
        <trans-unit id="716452ebec7e673d1d9d81cc51b8547f340814e1" translate="yes" xml:space="preserve">
          <source>The line number of a certain position in the buffer, or zero. This is used for displaying the line number of point in the mode line.</source>
          <target state="translated">Номер строки определенной позиции в буфере,или ноль.Используется для отображения номера линии точки в линии режима.</target>
        </trans-unit>
        <trans-unit id="839f8d216431863a7a00ea59f4be71c60c8c2e5b" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;(rose violet)&lt;/code&gt; is equivalent to &lt;code&gt;(rose . (violet))&lt;/code&gt;, and looks like this:</source>
          <target state="translated">The list &lt;code&gt;(rose violet)&lt;/code&gt; is equivalent to &lt;code&gt;(rose . (violet))&lt;/code&gt; , and looks like this:</target>
        </trans-unit>
        <trans-unit id="962c62424fbca05b4167123b8512730f70e28cc4" translate="yes" xml:space="preserve">
          <source>The list describes the display that &lt;var&gt;frame&lt;/var&gt; is on; if &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it applies to the selected frame&amp;rsquo;s display (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">The list describes the display that &lt;var&gt;frame&lt;/var&gt; is on; if &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , it applies to the selected frame&amp;rsquo;s display (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="a5e7dd03ee241b78dea866b6e88f99a7a8764678" translate="yes" xml:space="preserve">
          <source>The list form is currently similar to how &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;secure-hash&lt;/code&gt; operate.</source>
          <target state="translated">The list form is currently similar to how &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;secure-hash&lt;/code&gt; operate.</target>
        </trans-unit>
        <trans-unit id="f1ee49ad7464cab64ae226a805d7b31a9c327b50" translate="yes" xml:space="preserve">
          <source>The list is ordered so that earlier elements correspond to more recently-shown buffers, and the first element usually corresponds to the buffer most recently removed from the window.</source>
          <target state="translated">Список упорядочен так,чтобы более ранние элементы соответствовали более поздним буферам,а первый элемент обычно соответствовал буферу,последний раз удаленному из окна.</target>
        </trans-unit>
        <trans-unit id="bf28d6cd5c13b4c859c3624b6a63099b610df792" translate="yes" xml:space="preserve">
          <source>The list of the positions of the currently open parentheses, starting with the outermost.</source>
          <target state="translated">Список позиций текущих открытых скобок,начинающийся с крайнего.</target>
        </trans-unit>
        <trans-unit id="42d7eea344ddd2896a97642d094a7e8335564359" translate="yes" xml:space="preserve">
          <source>The list returned by &lt;code&gt;buffer-list&lt;/code&gt; is constructed specifically; it is not an internal Emacs data structure, and modifying it has no effect on the order of buffers. If you want to change the order of buffers in the fundamental buffer list, here is an easy way:</source>
          <target state="translated">The list returned by &lt;code&gt;buffer-list&lt;/code&gt; is constructed specifically; it is not an internal Emacs data structure, and modifying it has no effect on the order of buffers. If you want to change the order of buffers in the fundamental buffer list, here is an easy way:</target>
        </trans-unit>
        <trans-unit id="a8c850e06ee228bef706e71be70435aebad07c66" translate="yes" xml:space="preserve">
          <source>The load functions evaluate all the expressions in a file just as the &lt;code&gt;eval-buffer&lt;/code&gt; function evaluates all the expressions in a buffer. The difference is that the load functions read and evaluate the text in the file as found on disk, not the text in an Emacs buffer.</source>
          <target state="translated">The load functions evaluate all the expressions in a file just as the &lt;code&gt;eval-buffer&lt;/code&gt; function evaluates all the expressions in a buffer. The difference is that the load functions read and evaluate the text in the file as found on disk, not the text in an Emacs buffer.</target>
        </trans-unit>
        <trans-unit id="bcf097db69a4c3e2b9f156a93318f5b55b88be14" translate="yes" xml:space="preserve">
          <source>The loaded file must contain Lisp expressions, either as source code or as byte-compiled code. Each form in the file is called a &lt;em&gt;top-level form&lt;/em&gt;. There is no special format for the forms in a loadable file; any form in a file may equally well be typed directly into a buffer and evaluated there. (Indeed, most code is tested this way.) Most often, the forms are function definitions and variable definitions.</source>
          <target state="translated">The loaded file must contain Lisp expressions, either as source code or as byte-compiled code. Each form in the file is called a &lt;em&gt;top-level form&lt;/em&gt;. There is no special format for the forms in a loadable file; any form in a file may equally well be typed directly into a buffer and evaluated there. (Indeed, most code is tested this way.) Most often, the forms are function definitions and variable definitions.</target>
        </trans-unit>
        <trans-unit id="95d55d2fde6c278fb97386c98daf3e630c566eab" translate="yes" xml:space="preserve">
          <source>The local address, in internal format.</source>
          <target state="translated">Локальный адрес,во внутреннем формате.</target>
        </trans-unit>
        <trans-unit id="56aaea215b4bc49234f9ee74677196b8ffb7af78" translate="yes" xml:space="preserve">
          <source>The local keymap and variable list contain entries that individually override global bindings or values. These are used to customize the behavior of programs in different buffers, without actually changing the programs.</source>
          <target state="translated">Локальная клавиатурная карта и список переменных содержат записи,которые по отдельности переопределяют глобальные привязки или значения.Они используются для настройки поведения программ в различных буферах,без фактического изменения программ.</target>
        </trans-unit>
        <trans-unit id="8497e1e143889552fd6d29f50ee9c1a86ceb2d17" translate="yes" xml:space="preserve">
          <source>The local keymap is normally set by the buffer&amp;rsquo;s major mode, and every buffer with the same major mode shares the same local keymap. Hence, if you call &lt;code&gt;local-set-key&lt;/code&gt; (see &lt;a href=&quot;key-binding-commands#Key-Binding-Commands&quot;&gt;Key Binding Commands&lt;/a&gt;) to change the local keymap in one buffer, that also affects the local keymaps in other buffers with the same major mode.</source>
          <target state="translated">The local keymap is normally set by the buffer&amp;rsquo;s major mode, and every buffer with the same major mode shares the same local keymap. Hence, if you call &lt;code&gt;local-set-key&lt;/code&gt; (see &lt;a href=&quot;key-binding-commands#Key-Binding-Commands&quot;&gt;Key Binding Commands&lt;/a&gt;) to change the local keymap in one buffer, that also affects the local keymaps in other buffers with the same major mode.</target>
        </trans-unit>
        <trans-unit id="c20827cfc5ffe09c075650e5199361a56b68cec0" translate="yes" xml:space="preserve">
          <source>The low-level mechanism for disabling a command is to put a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;disabled&lt;/code&gt; property on the Lisp symbol for the command. These properties are normally set up by the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) with Lisp expressions such as this:</source>
          <target state="translated">The low-level mechanism for disabling a command is to put a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;disabled&lt;/code&gt; property on the Lisp symbol for the command. These properties are normally set up by the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) with Lisp expressions such as this:</target>
        </trans-unit>
        <trans-unit id="23fe2196399552d25b3c061985ee305fa84c2b18" translate="yes" xml:space="preserve">
          <source>The low-level primitives for creating buffers do not use this function, but medium-level commands such as &lt;code&gt;switch-to-buffer&lt;/code&gt; and &lt;code&gt;find-file-noselect&lt;/code&gt; use it whenever they create buffers.</source>
          <target state="translated">The low-level primitives for creating buffers do not use this function, but medium-level commands such as &lt;code&gt;switch-to-buffer&lt;/code&gt; and &lt;code&gt;find-file-noselect&lt;/code&gt; use it whenever they create buffers.</target>
        </trans-unit>
        <trans-unit id="8010635f2bb24a96123a821123a02c24a306bdce" translate="yes" xml:space="preserve">
          <source>The lowest level functions for command input are &lt;code&gt;read-event&lt;/code&gt;, &lt;code&gt;read-char&lt;/code&gt;, and &lt;code&gt;read-char-exclusive&lt;/code&gt;.</source>
          <target state="translated">The lowest level functions for command input are &lt;code&gt;read-event&lt;/code&gt; , &lt;code&gt;read-char&lt;/code&gt; , and &lt;code&gt;read-char-exclusive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14145dceb516643fe37d9fc1ff0f68417500b0ec" translate="yes" xml:space="preserve">
          <source>The lowest-level primitive for modifying a &lt;small&gt;CDR&lt;/small&gt; is &lt;code&gt;setcdr&lt;/code&gt;:</source>
          <target state="translated">The lowest-level primitive for modifying a &lt;small&gt;CDR&lt;/small&gt; is &lt;code&gt;setcdr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3f8ff2bd3febbb80e6a03979190f1d4a93f85b99" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;condition-case-unless-debug&lt;/code&gt; provides another way to handle debugging of such forms. It behaves exactly like &lt;code&gt;condition-case&lt;/code&gt;, unless the variable &lt;code&gt;debug-on-error&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, in which case it does not handle any errors at all.</source>
          <target state="translated">The macro &lt;code&gt;condition-case-unless-debug&lt;/code&gt; provides another way to handle debugging of such forms. It behaves exactly like &lt;code&gt;condition-case&lt;/code&gt; , unless the variable &lt;code&gt;debug-on-error&lt;/code&gt; is non- &lt;code&gt;nil&lt;/code&gt; , in which case it does not handle any errors at all.</target>
        </trans-unit>
        <trans-unit id="69ddcd0a4bf2d4a7d5ed7f86f791b6ffe043c1a1" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;define-alternatives&lt;/code&gt; can be used to define &lt;em&gt;generic commands&lt;/em&gt;. These are interactive functions whose implementation can be selected from several alternatives, as a matter of user preference.</source>
          <target state="translated">The macro &lt;code&gt;define-alternatives&lt;/code&gt; can be used to define &lt;em&gt;generic commands&lt;/em&gt;. These are interactive functions whose implementation can be selected from several alternatives, as a matter of user preference.</target>
        </trans-unit>
        <trans-unit id="5119a1b3dc9bf2349246f3d4b6d6761f1510e515" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;define-minor-mode&lt;/code&gt; offers a convenient way of implementing a mode in one self-contained definition.</source>
          <target state="translated">The macro &lt;code&gt;define-minor-mode&lt;/code&gt; offers a convenient way of implementing a mode in one self-contained definition.</target>
        </trans-unit>
        <trans-unit id="a18ca22eed3764c8d5592c00e25721489dd6a12d" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;gv-letplace&lt;/code&gt; can be useful in defining macros that perform similarly to &lt;code&gt;setf&lt;/code&gt;; for example, the &lt;code&gt;incf&lt;/code&gt; macro of Common Lisp could be implemented this way:</source>
          <target state="translated">The macro &lt;code&gt;gv-letplace&lt;/code&gt; can be useful in defining macros that perform similarly to &lt;code&gt;setf&lt;/code&gt; ; for example, the &lt;code&gt;incf&lt;/code&gt; macro of Common Lisp could be implemented this way:</target>
        </trans-unit>
        <trans-unit id="1e1e3b145e098e8f5ecb2f49f1bfd35918691f45" translate="yes" xml:space="preserve">
          <source>The macro cannot be used to suppress file name handlers from magic file names (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;).</source>
          <target state="translated">The macro cannot be used to suppress file name handlers from magic file names (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="8cf63348f1b08167a736e3e7aac8f62de5938951" translate="yes" xml:space="preserve">
          <source>The macro executes &lt;var&gt;body&lt;/var&gt; normally, but arranges to call the after-change functions just once for a series of several changes&amp;mdash;if that seems safe.</source>
          <target state="translated">The macro executes &lt;var&gt;body&lt;/var&gt; normally, but arranges to call the after-change functions just once for a series of several changes&amp;mdash;if that seems safe.</target>
        </trans-unit>
        <trans-unit id="eae48ac7e81744b77b10a9b79e04ee1eb49c6a47" translate="yes" xml:space="preserve">
          <source>The macros &lt;code&gt;push&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;) and &lt;code&gt;pop&lt;/code&gt; (see &lt;a href=&quot;list-elements#List-Elements&quot;&gt;List Elements&lt;/a&gt;) can manipulate generalized variables, not just lists. &lt;code&gt;(pop &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; removes and returns the first element of the list stored in &lt;var&gt;place&lt;/var&gt;. It is analogous to &lt;code&gt;(prog1 (car &lt;var&gt;place&lt;/var&gt;) (setf &lt;var&gt;place&lt;/var&gt; (cdr &lt;var&gt;place&lt;/var&gt;)))&lt;/code&gt;, except that it takes care to evaluate all subforms only once. &lt;code&gt;(push &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; inserts &lt;var&gt;x&lt;/var&gt; at the front of the list stored in &lt;var&gt;place&lt;/var&gt;. It is analogous to &lt;code&gt;(setf
&lt;var&gt;place&lt;/var&gt; (cons &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;))&lt;/code&gt;, except for evaluation of the subforms. Note that &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; on an &lt;code&gt;nthcdr&lt;/code&gt; place can be used to insert or delete at any position in a list.</source>
          <target state="translated">The macros &lt;code&gt;push&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;) and &lt;code&gt;pop&lt;/code&gt; (see &lt;a href=&quot;list-elements#List-Elements&quot;&gt;List Elements&lt;/a&gt;) can manipulate generalized variables, not just lists. &lt;code&gt;(pop &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; removes and returns the first element of the list stored in &lt;var&gt;place&lt;/var&gt; . It is analogous to &lt;code&gt;(prog1 (car &lt;var&gt;place&lt;/var&gt;) (setf &lt;var&gt;place&lt;/var&gt; (cdr &lt;var&gt;place&lt;/var&gt;)))&lt;/code&gt; , except that it takes care to evaluate all subforms only once. &lt;code&gt;(push &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; inserts &lt;var&gt;x&lt;/var&gt; at the front of the list stored in &lt;var&gt;place&lt;/var&gt; . It is analogous to &lt;code&gt;(setf &lt;var&gt;place&lt;/var&gt; (cons &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;))&lt;/code&gt; , except for evaluation of the subforms. Note that &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; on an &lt;code&gt;nthcdr&lt;/code&gt; place can be used to insert or delete at any position in a list.</target>
        </trans-unit>
        <trans-unit id="09c0ddd15714530f62c1af5eecb2c98c7086baee" translate="yes" xml:space="preserve">
          <source>The macros described in this section use &lt;code&gt;pcase&lt;/code&gt; patterns to perform destructuring binding. The condition of the object to be of compatible structure means that the object must match the pattern, because only then the object&amp;rsquo;s subfields can be extracted. For example:</source>
          <target state="translated">The macros described in this section use &lt;code&gt;pcase&lt;/code&gt; patterns to perform destructuring binding. The condition of the object to be of compatible structure means that the object must match the pattern, because only then the object&amp;rsquo;s subfields can be extracted. For example:</target>
        </trans-unit>
        <trans-unit id="f9f8d8ecb58d3451cb2b5457cb2f37a869983a68" translate="yes" xml:space="preserve">
          <source>The main reason for writing an Emacs module is to make additional functions available to Lisp programs that load the module. This subsection describes how to write such &lt;em&gt;module functions&lt;/em&gt;.</source>
          <target state="translated">The main reason for writing an Emacs module is to make additional functions available to Lisp programs that load the module. This subsection describes how to write such &lt;em&gt;module functions&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="877426dcb86887eef639d5e653cc17f51b41fa0e" translate="yes" xml:space="preserve">
          <source>The main use of &lt;code&gt;const&lt;/code&gt; is inside of &lt;code&gt;choice&lt;/code&gt;. For example, &lt;code&gt;(choice integer (const nil))&lt;/code&gt; allows either an integer or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">The main use of &lt;code&gt;const&lt;/code&gt; is inside of &lt;code&gt;choice&lt;/code&gt; . For example, &lt;code&gt;(choice integer (const nil))&lt;/code&gt; allows either an integer or &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26e9b14420c609493efab668d934c559a0c3429e" translate="yes" xml:space="preserve">
          <source>The main use of &lt;code&gt;current-idle-time&lt;/code&gt; is when an idle timer function wants to &amp;ldquo;take a break&amp;rdquo; for a while. It can set up another idle timer to call the same function again, after a few seconds more idleness. Here&amp;rsquo;s an example:</source>
          <target state="translated">The main use of &lt;code&gt;current-idle-time&lt;/code&gt; is when an idle timer function wants to &amp;ldquo;take a break&amp;rdquo; for a while. It can set up another idle timer to call the same function again, after a few seconds more idleness. Here&amp;rsquo;s an example:</target>
        </trans-unit>
        <trans-unit id="530ebc1f037074c726faee61b32cae1039f33cbf" translate="yes" xml:space="preserve">
          <source>The main use of &lt;code&gt;other&lt;/code&gt; is as the last element of &lt;code&gt;choice&lt;/code&gt;. For example,</source>
          <target state="translated">The main use of &lt;code&gt;other&lt;/code&gt; is as the last element of &lt;code&gt;choice&lt;/code&gt; . For example,</target>
        </trans-unit>
        <trans-unit id="f26c01b277b5d5c1d3d508a4f0fb33a502c2a50b" translate="yes" xml:space="preserve">
          <source>The major mode command may start by calling some other major mode command (called the &lt;em&gt;parent mode&lt;/em&gt;) and then alter some of its settings. A mode that does this is called a &lt;em&gt;derived mode&lt;/em&gt;. The recommended way to define one is to use the &lt;code&gt;define-derived-mode&lt;/code&gt; macro, but this is not required. Such a mode should call the parent mode command inside a &lt;code&gt;delay-mode-hooks&lt;/code&gt; form. (Using &lt;code&gt;define-derived-mode&lt;/code&gt; does this automatically.) See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;, and &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;Mode Hooks&lt;/a&gt;.</source>
          <target state="translated">The major mode command may start by calling some other major mode command (called the &lt;em&gt;parent mode&lt;/em&gt;) and then alter some of its settings. A mode that does this is called a &lt;em&gt;derived mode&lt;/em&gt;. The recommended way to define one is to use the &lt;code&gt;define-derived-mode&lt;/code&gt; macro, but this is not required. Such a mode should call the parent mode command inside a &lt;code&gt;delay-mode-hooks&lt;/code&gt; form. (Using &lt;code&gt;define-derived-mode&lt;/code&gt; does this automatically.) See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;, and &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;Mode Hooks&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5d17a35b712255a2afb0c14c8a0d624c5811e326" translate="yes" xml:space="preserve">
          <source>The major mode command should set the variable &lt;code&gt;major-mode&lt;/code&gt; to the major mode command symbol. This is how &lt;code&gt;describe-mode&lt;/code&gt; discovers which documentation to print.</source>
          <target state="translated">The major mode command should set the variable &lt;code&gt;major-mode&lt;/code&gt; to the major mode command symbol. This is how &lt;code&gt;describe-mode&lt;/code&gt; discovers which documentation to print.</target>
        </trans-unit>
        <trans-unit id="cc2e4f72d7acbc5634e4c8fb360f612e207aadac" translate="yes" xml:space="preserve">
          <source>The major mode command should set the variable &lt;code&gt;mode-name&lt;/code&gt; to the &amp;ldquo;pretty&amp;rdquo; name of the mode, usually a string (but see &lt;a href=&quot;mode-line-data#Mode-Line-Data&quot;&gt;Mode Line Data&lt;/a&gt;, for other possible forms). The name of the mode appears in the mode line.</source>
          <target state="translated">The major mode command should set the variable &lt;code&gt;mode-name&lt;/code&gt; to the &amp;ldquo;pretty&amp;rdquo; name of the mode, usually a string (but see &lt;a href=&quot;mode-line-data#Mode-Line-Data&quot;&gt;Mode Line Data&lt;/a&gt;, for other possible forms). The name of the mode appears in the mode line.</target>
        </trans-unit>
        <trans-unit id="e9542e90f40b187eea4684e0c6016160f19daa55" translate="yes" xml:space="preserve">
          <source>The major mode command should start by calling &lt;code&gt;kill-all-local-variables&lt;/code&gt;. This runs the normal hook &lt;code&gt;change-major-mode-hook&lt;/code&gt;, then gets rid of the buffer-local variables of the major mode previously in effect. See &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;Creating Buffer-Local&lt;/a&gt;.</source>
          <target state="translated">The major mode command should start by calling &lt;code&gt;kill-all-local-variables&lt;/code&gt; . This runs the normal hook &lt;code&gt;change-major-mode-hook&lt;/code&gt; , then gets rid of the buffer-local variables of the major mode previously in effect. See &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;Creating Buffer-Local&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d4edcb1b916452f2aa05fab479bef5803ee546f7" translate="yes" xml:space="preserve">
          <source>The major mode for a newly created buffer is set to Fundamental mode. (The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level; see &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.) If the name begins with a space, the buffer initially disables undo information recording (see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;).</source>
          <target state="translated">The major mode for a newly created buffer is set to Fundamental mode. (The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level; see &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.) If the name begins with a space, the buffer initially disables undo information recording (see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="ba726196ac6572a0dc3557cdc5106eff7f9d6ee0" translate="yes" xml:space="preserve">
          <source>The major mode for the new buffer is set to Fundamental mode. The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level. See &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.</source>
          <target state="translated">The major mode for the new buffer is set to Fundamental mode. The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level. See &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="87268c52362ac57b90f14c23d4e6a6de48b2d02a" translate="yes" xml:space="preserve">
          <source>The major mode should usually have its own keymap, which is used as the local keymap in all buffers in that mode. The major mode command should call &lt;code&gt;use-local-map&lt;/code&gt; to install this local map. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;, for more information.</source>
          <target state="translated">The major mode should usually have its own keymap, which is used as the local keymap in all buffers in that mode. The major mode command should call &lt;code&gt;use-local-map&lt;/code&gt; to install this local map. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;, for more information.</target>
        </trans-unit>
        <trans-unit id="172cb58908f30e86253a48b7781eed8cfd4c158b" translate="yes" xml:space="preserve">
          <source>The major version number of Emacs, as an integer. For Emacs version 23.1, the value is 23.</source>
          <target state="translated">Основной номер версии Emacs,как целое число.Для Emacs версии 23.1,значение 23.</target>
        </trans-unit>
        <trans-unit id="0d1af093b0fd27af29ab4b28e1513e6dc00a63aa" translate="yes" xml:space="preserve">
          <source>The manual should be fully correct in what it does cover, and it is therefore open to criticism on anything it says&amp;mdash;from specific examples and descriptive text, to the ordering of chapters and sections. If something is confusing, or you find that you have to look at the sources or experiment to learn something not covered in the manual, then perhaps the manual should be fixed. Please let us know.</source>
          <target state="translated">The manual should be fully correct in what it does cover, and it is therefore open to criticism on anything it says&amp;mdash;from specific examples and descriptive text, to the ordering of chapters and sections. If something is confusing, or you find that you have to look at the sources or experiment to learn something not covered in the manual, then perhaps the manual should be fixed. Please let us know.</target>
        </trans-unit>
        <trans-unit id="a5e22ef195f16823ddf7673778585082a4f46066" translate="yes" xml:space="preserve">
          <source>The mark for the buffer. The mark is a marker, hence it is also included on the list &lt;code&gt;markers&lt;/code&gt;. See &lt;a href=&quot;the-mark#The-Mark&quot;&gt;The Mark&lt;/a&gt;.</source>
          <target state="translated">The mark for the buffer. The mark is a marker, hence it is also included on the list &lt;code&gt;markers&lt;/code&gt; . See &lt;a href=&quot;the-mark#The-Mark&quot;&gt;The Mark&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b258116b18e88b2e80482d5981d360a38a61fc94" translate="yes" xml:space="preserve">
          <source>The mark is active when this variable is non-&lt;code&gt;nil&lt;/code&gt;. This variable is always buffer-local in each buffer. Do &lt;em&gt;not&lt;/em&gt; use the value of this variable to decide whether a command that normally operates on text near point should operate on the region instead. Use the function &lt;code&gt;use-region-p&lt;/code&gt; for that (see &lt;a href=&quot;the-region#The-Region&quot;&gt;The Region&lt;/a&gt;).</source>
          <target state="translated">The mark is active when this variable is non- &lt;code&gt;nil&lt;/code&gt; . This variable is always buffer-local in each buffer. Do &lt;em&gt;not&lt;/em&gt; use the value of this variable to decide whether a command that normally operates on text near point should operate on the region instead. Use the function &lt;code&gt;use-region-p&lt;/code&gt; for that (see &lt;a href=&quot;the-region#The-Region&quot;&gt;The Region&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="cf467a06fad52dab305b0df8d802a3dd9b6b7599" translate="yes" xml:space="preserve">
          <source>The mark is not active now</source>
          <target state="translated">Метка сейчас не активна.</target>
        </trans-unit>
        <trans-unit id="2294805a57144c8f475dd286330832439e218b3b" translate="yes" xml:space="preserve">
          <source>The mark specifies a position to bound a range of text for many commands, such as &lt;code&gt;kill-region&lt;/code&gt; and &lt;code&gt;indent-rigidly&lt;/code&gt;. These commands typically act on the text between point and the mark, which is called the &lt;em&gt;region&lt;/em&gt;. If you are writing a command that operates on the region, don&amp;rsquo;t examine the mark directly; instead, use &lt;code&gt;interactive&lt;/code&gt; with the &amp;lsquo;</source>
          <target state="translated">The mark specifies a position to bound a range of text for many commands, such as &lt;code&gt;kill-region&lt;/code&gt; and &lt;code&gt;indent-rigidly&lt;/code&gt; . These commands typically act on the text between point and the mark, which is called the &lt;em&gt;region&lt;/em&gt;. If you are writing a command that operates on the region, don&amp;rsquo;t examine the mark directly; instead, use &lt;code&gt;interactive&lt;/code&gt; with the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1b1540074aa53b63216cd2456d72381dd8d0fc52" translate="yes" xml:space="preserve">
          <source>The markers that refer to this buffer. This is actually a single marker, and successive elements in its marker &lt;em&gt;chain&lt;/em&gt; (a linked list) are the other markers referring to this buffer text.</source>
          <target state="translated">The markers that refer to this buffer. This is actually a single marker, and successive elements in its marker &lt;em&gt;chain&lt;/em&gt; (a linked list) are the other markers referring to this buffer text.</target>
        </trans-unit>
        <trans-unit id="bb06b83e3da02615a4f7e9ab6d8336bdd25a1731" translate="yes" xml:space="preserve">
          <source>The matcher processes a &amp;lsquo;</source>
          <target state="translated">The matcher processes a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="92f6e3600296536bb76b7fcd8d76a0af6e42a364" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;e&lt;/em&gt; (2.71828&amp;hellip;).</source>
          <target state="translated">The mathematical constant &lt;em&gt;e&lt;/em&gt; (2.71828&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="1a3e48f3d1745f4908462da41660cc121d6d0f68" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;pi&lt;/em&gt; (3.14159&amp;hellip;).</source>
          <target state="translated">The mathematical constant &lt;em&gt;pi&lt;/em&gt; (3.14159&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="8e605715e3d2691c70b3f21b0b8462b89a7614e5" translate="yes" xml:space="preserve">
          <source>The maximum advance width of the font.</source>
          <target state="translated">Максимальная ширина шрифта.</target>
        </trans-unit>
        <trans-unit id="978782c408873797cfb6aaf7d660218a112071f9" translate="yes" xml:space="preserve">
          <source>The maximum number of changes that can be amalgamated is controlled by the &lt;code&gt;amalgamating-undo-limit&lt;/code&gt; variable. If this variable is 1, no changes are amalgamated.</source>
          <target state="translated">The maximum number of changes that can be amalgamated is controlled by the &lt;code&gt;amalgamating-undo-limit&lt;/code&gt; variable. If this variable is 1, no changes are amalgamated.</target>
        </trans-unit>
        <trans-unit id="82b0cf778d9e1f9d0ac00a5da272e14e2306ca7f" translate="yes" xml:space="preserve">
          <source>The maximum stack size this function needs.</source>
          <target state="translated">Максимальный размер стека,необходимый этой функции.</target>
        </trans-unit>
        <trans-unit id="459b7d57f50aecb28cc2870ce7b74f07723e326b" translate="yes" xml:space="preserve">
          <source>The meaning of a list depends on what it contains:</source>
          <target state="translated">Значение списка зависит от того,что он содержит:</target>
        </trans-unit>
        <trans-unit id="d3fe651ac40ed9579fa5231d4fcd52354eb5372a" translate="yes" xml:space="preserve">
          <source>The meanings of these list elements are as follows:</source>
          <target state="translated">Значения этих элементов списка следующие:</target>
        </trans-unit>
        <trans-unit id="12d4b0de515899d94eda4148e6b314c9f86a96b8" translate="yes" xml:space="preserve">
          <source>The menu bar (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;) can be either internal (drawn by Emacs itself) or external (drawn by the toolkit). Most builds (GTK+, Lucid, Motif and MS-Windows) rely on an external menu bar. NS also uses an external menu bar which, however, is not part of the outer frame. Non-toolkit builds can provide an internal menu bar. On text terminal frames, the menu bar is part of the frame&amp;rsquo;s root window (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;). As a rule, menu bars are never shown on child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;). Display of the menu bar can be suppressed by setting the &lt;code&gt;menu-bar-lines&lt;/code&gt; parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;) to zero.</source>
          <target state="translated">The menu bar (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;) can be either internal (drawn by Emacs itself) or external (drawn by the toolkit). Most builds (GTK+, Lucid, Motif and MS-Windows) rely on an external menu bar. NS also uses an external menu bar which, however, is not part of the outer frame. Non-toolkit builds can provide an internal menu bar. On text terminal frames, the menu bar is part of the frame&amp;rsquo;s root window (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;). As a rule, menu bars are never shown on child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;). Display of the menu bar can be suppressed by setting the &lt;code&gt;menu-bar-lines&lt;/code&gt; parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;) to zero.</target>
        </trans-unit>
        <trans-unit id="9c36ca261c29f5622700c6f2f7d03d8bacd64def" translate="yes" xml:space="preserve">
          <source>The menu bar does not recalculate which items are enabled every time you look at a menu. This is because the X toolkit requires the whole tree of menus in advance. To force recalculation of the menu bar, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">The menu bar does not recalculate which items are enabled every time you look at a menu. This is because the X toolkit requires the whole tree of menus in advance. To force recalculation of the menu bar, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="0671d125fcb3f27fb5c40fddd77a7227205c4dea" translate="yes" xml:space="preserve">
          <source>The menu bar mechanism, which lets you switch between submenus by moving the mouse, cannot look within the definition of a command to see that it calls &lt;code&gt;x-popup-menu&lt;/code&gt;. Therefore, if you try to implement a submenu using &lt;code&gt;x-popup-menu&lt;/code&gt;, it cannot work with the menu bar in an integrated fashion. This is why all menu bar submenus are implemented with menu keymaps within the parent menu, and never with &lt;code&gt;x-popup-menu&lt;/code&gt;. See &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;.</source>
          <target state="translated">The menu bar mechanism, which lets you switch between submenus by moving the mouse, cannot look within the definition of a command to see that it calls &lt;code&gt;x-popup-menu&lt;/code&gt; . Therefore, if you try to implement a submenu using &lt;code&gt;x-popup-menu&lt;/code&gt; , it cannot work with the menu bar in an integrated fashion. This is why all menu bar submenus are implemented with menu keymaps within the parent menu, and never with &lt;code&gt;x-popup-menu&lt;/code&gt; . See &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9fccd406d5e813b76ef7a41fe974c95db256bdc6" translate="yes" xml:space="preserve">
          <source>The menu in this example is intended for use with the mouse. If a menu is intended for use with the keyboard, that is, if it is bound to a key sequence ending with a keyboard event, then the menu items should be bound to characters or real function keys, that can be typed with the keyboard.</source>
          <target state="translated">Меню в данном примере предназначено для использования с помощью мыши.Если меню предназначено для использования с клавиатурой,т.е.если оно привязано к последовательности клавиш,заканчивающейся событием на клавиатуре,то пункты меню должны быть привязаны к символам или реальным функциональным клавишам,которые могут быть набраны с клавиатуры.</target>
        </trans-unit>
        <trans-unit id="884ca4e3a78e0c7d0eb618828c719ec2bc18c4b5" translate="yes" xml:space="preserve">
          <source>The menu&amp;rsquo;s items are the bindings in the keymap. Each binding associates an event type to a definition, but the event types have no significance for the menu appearance. (Usually we use pseudo-events, symbols that the keyboard cannot generate, as the event types for menu item bindings.) The menu is generated entirely from the bindings that correspond in the keymap to these events.</source>
          <target state="translated">The menu&amp;rsquo;s items are the bindings in the keymap. Each binding associates an event type to a definition, but the event types have no significance for the menu appearance. (Usually we use pseudo-events, symbols that the keyboard cannot generate, as the event types for menu item bindings.) The menu is generated entirely from the bindings that correspond in the keymap to these events.</target>
        </trans-unit>
        <trans-unit id="4ffe1db1ee3430043bd7d7cfed2fce90a58b2f33" translate="yes" xml:space="preserve">
          <source>The message is &amp;lsquo;</source>
          <target state="translated">The message is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1b4522d132316958b60412509a75ad9dd71138ff" translate="yes" xml:space="preserve">
          <source>The message is &lt;code&gt;Arithmetic range error&lt;/code&gt;.</source>
          <target state="translated">The message is &lt;code&gt;Arithmetic range error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14845ac05edc00f5ef9aed326e6a4acbb2d66dc1" translate="yes" xml:space="preserve">
          <source>The message is the empty string. See &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;.</source>
          <target state="translated">The message is the empty string. See &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a343531eec6204803775063bd43c8b0c3b1e1d7d" translate="yes" xml:space="preserve">
          <source>The message is usually &amp;lsquo;</source>
          <target state="translated">The message is usually &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="a72cf44ed0b2379b5bd18fbbfcf576f977b2239c" translate="yes" xml:space="preserve">
          <source>The meta modifier.</source>
          <target state="translated">Мета-модификатор.</target>
        </trans-unit>
        <trans-unit id="b1a58020916aba3f6cdf104343f3433939d15e37" translate="yes" xml:space="preserve">
          <source>The meta variants of those characters, with codes in the range of 2**27 to 2**27+127, can also go in the string, but you must change their numeric values. You must set the 2**7 bit instead of the 2**27 bit, resulting in a value between 128 and 255. Only a unibyte string can include these codes.</source>
          <target state="translated">Мета-варианты этих символов,с кодами в диапазоне от 2**27 до 2**27+127,также могут идти в строку,но необходимо изменить их числовые значения.Необходимо установить бит 2**7 вместо бита 2**27,в результате чего значение будет находиться в диапазоне от 128 до 255.Только однобайтовая строка может включать эти коды.</target>
        </trans-unit>
        <trans-unit id="9260d6b48ff908594f1c64bdc5084fd35f5bbde1" translate="yes" xml:space="preserve">
          <source>The minibuffer&amp;rsquo;s window is normally a single line; it grows automatically if the contents require more space. Whilst the minibuffer is active, you can explicitly resize its window temporarily with the window sizing commands; the window reverts to its normal size when the minibuffer is exited. When the minibuffer is not active, you can resize its window permanently by using the window sizing commands in the frame&amp;rsquo;s other window, or dragging the mode line with the mouse. (Due to details of the current implementation, for this to work &lt;code&gt;resize-mini-windows&lt;/code&gt; must be &lt;code&gt;nil&lt;/code&gt;.) If the frame contains just a minibuffer window, you can change its size by changing the frame&amp;rsquo;s size.</source>
          <target state="translated">The minibuffer&amp;rsquo;s window is normally a single line; it grows automatically if the contents require more space. Whilst the minibuffer is active, you can explicitly resize its window temporarily with the window sizing commands; the window reverts to its normal size when the minibuffer is exited. When the minibuffer is not active, you can resize its window permanently by using the window sizing commands in the frame&amp;rsquo;s other window, or dragging the mode line with the mouse. (Due to details of the current implementation, for this to work &lt;code&gt;resize-mini-windows&lt;/code&gt; must be &lt;code&gt;nil&lt;/code&gt; .) If the frame contains just a minibuffer window, you can change its size by changing the frame&amp;rsquo;s size.</target>
        </trans-unit>
        <trans-unit id="fc66b2b22fab10f272a2733f5220517063d244a8" translate="yes" xml:space="preserve">
          <source>The minimum parenthesis depth encountered during this scan.</source>
          <target state="translated">Минимальная глубина скобок,встреченная во время сканирования.</target>
        </trans-unit>
        <trans-unit id="f63caeb9d63ae3ea523b1bd607e47fabe4f9c44a" translate="yes" xml:space="preserve">
          <source>The minor mode should, if possible, support enabling and disabling via Custom (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;). To do this, the mode variable should be defined with &lt;code&gt;defcustom&lt;/code&gt;, usually with &lt;code&gt;:type 'boolean&lt;/code&gt;. If just setting the variable is not sufficient to enable the mode, you should also specify a &lt;code&gt;:set&lt;/code&gt; method which enables the mode by invoking the mode command. Note in the variable&amp;rsquo;s documentation string that setting the variable other than via Custom may not take effect. Also, mark the definition with an autoload cookie (see &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;), and specify a &lt;code&gt;:require&lt;/code&gt; so that customizing the variable will load the library that defines the mode. For example:</source>
          <target state="translated">The minor mode should, if possible, support enabling and disabling via Custom (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;). To do this, the mode variable should be defined with &lt;code&gt;defcustom&lt;/code&gt; , usually with &lt;code&gt;:type 'boolean&lt;/code&gt; . If just setting the variable is not sufficient to enable the mode, you should also specify a &lt;code&gt;:set&lt;/code&gt; method which enables the mode by invoking the mode command. Note in the variable&amp;rsquo;s documentation string that setting the variable other than via Custom may not take effect. Also, mark the definition with an autoload cookie (see &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;), and specify a &lt;code&gt;:require&lt;/code&gt; so that customizing the variable will load the library that defines the mode. For example:</target>
        </trans-unit>
        <trans-unit id="a754ecbf865ded2f8f972fadc0f979ee00b4c003" translate="yes" xml:space="preserve">
          <source>The minor version number of Emacs, as an integer. For Emacs version 23.1, the value is 1.</source>
          <target state="translated">Номер младшей версии Emacs,как целое число.Для Emacs версии 23.1 значение равно 1.</target>
        </trans-unit>
        <trans-unit id="1778e11c806e3d03eed718920a2bdcbe70425f0c" translate="yes" xml:space="preserve">
          <source>The mnemonics of keyboard, terminal, and buffer coding systems.</source>
          <target state="translated">Мнемоника клавиатурных,терминальных и буферных систем кодирования.</target>
        </trans-unit>
        <trans-unit id="d4aa0cdb7029a5f2355863fdbbab99919ce6ce82" translate="yes" xml:space="preserve">
          <source>The mode can specify a local value for &lt;code&gt;eldoc-documentation-function&lt;/code&gt; to tell ElDoc mode how to handle this mode.</source>
          <target state="translated">The mode can specify a local value for &lt;code&gt;eldoc-documentation-function&lt;/code&gt; to tell ElDoc mode how to handle this mode.</target>
        </trans-unit>
        <trans-unit id="354ca13496161c1669222f09fc05f88ea22e29e9" translate="yes" xml:space="preserve">
          <source>The mode can specify how to complete various keywords by adding one or more buffer-local entries to the special hook &lt;code&gt;completion-at-point-functions&lt;/code&gt;. See &lt;a href=&quot;completion-in-buffers#Completion-in-Buffers&quot;&gt;Completion in Buffers&lt;/a&gt;.</source>
          <target state="translated">The mode can specify how to complete various keywords by adding one or more buffer-local entries to the special hook &lt;code&gt;completion-at-point-functions&lt;/code&gt; . See &lt;a href=&quot;completion-in-buffers#Completion-in-Buffers&quot;&gt;Completion in Buffers&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9ced895ea9c1431eb7e76df2f2cbdc9e5d0836c8" translate="yes" xml:space="preserve">
          <source>The mode command should accept one optional argument. If called interactively with no prefix argument, it should toggle the mode (i.e., enable if it is disabled, and disable if it is enabled). If called interactively with a prefix argument, it should enable the mode if the argument is positive and disable it otherwise.</source>
          <target state="translated">Команда режима должна принять один необязательный аргумент.При интерактивном вызове без префиксного аргумента она должна переключить режим (т.е.включить,если он отключен,и отключить,если он включен).Если команда вызывается интерактивно с префиксным аргументом,она должна включить режим при положительном значении аргумента и отключить его в противном случае.</target>
        </trans-unit>
        <trans-unit id="44819a97a0e2f91469bd3f92a2d58321df9329f0" translate="yes" xml:space="preserve">
          <source>The mode line contents are controlled by a data structure called a &lt;em&gt;mode line construct&lt;/em&gt;, made up of lists, strings, symbols, and numbers kept in buffer-local variables. Each data type has a specific meaning for the mode line appearance, as described below. The same data structure is used for constructing frame titles (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;) and header lines (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;).</source>
          <target state="translated">The mode line contents are controlled by a data structure called a &lt;em&gt;mode line construct&lt;/em&gt;, made up of lists, strings, symbols, and numbers kept in buffer-local variables. Each data type has a specific meaning for the mode line appearance, as described below. The same data structure is used for constructing frame titles (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;) and header lines (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="e208e76c5548c1d095dbde47ed20de1a7d12aa6a" translate="yes" xml:space="preserve">
          <source>The mode may have its own abbrev table or may share one with other related modes. If it has its own abbrev table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-abbrev-table&lt;/code&gt;. If the major mode command defines any abbrevs itself, it should pass &lt;code&gt;t&lt;/code&gt; for the &lt;var&gt;system-flag&lt;/var&gt; argument to &lt;code&gt;define-abbrev&lt;/code&gt;. See &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Defining Abbrevs&lt;/a&gt;.</source>
          <target state="translated">The mode may have its own abbrev table or may share one with other related modes. If it has its own abbrev table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-abbrev-table&lt;/code&gt; . If the major mode command defines any abbrevs itself, it should pass &lt;code&gt;t&lt;/code&gt; for the &lt;var&gt;system-flag&lt;/var&gt; argument to &lt;code&gt;define-abbrev&lt;/code&gt; . See &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Defining Abbrevs&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="566eebc546ff4022d5692ebd193f3372e5deedf9" translate="yes" xml:space="preserve">
          <source>The mode may have its own syntax table or may share one with other related modes. If it has its own syntax table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-syntax-table&lt;/code&gt;. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;.</source>
          <target state="translated">The mode may have its own syntax table or may share one with other related modes. If it has its own syntax table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-syntax-table&lt;/code&gt; . See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7febfb2248d6f317197277153f5791a4f2a7185b" translate="yes" xml:space="preserve">
          <source>The mode should specify how Imenu should find the definitions or sections of a buffer, by setting up a buffer-local value for the variable &lt;code&gt;imenu-generic-expression&lt;/code&gt;, for the two variables &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt;, or for the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt; (see &lt;a href=&quot;imenu#Imenu&quot;&gt;Imenu&lt;/a&gt;).</source>
          <target state="translated">The mode should specify how Imenu should find the definitions or sections of a buffer, by setting up a buffer-local value for the variable &lt;code&gt;imenu-generic-expression&lt;/code&gt; , for the two variables &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; , or for the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt; (see &lt;a href=&quot;imenu#Imenu&quot;&gt;Imenu&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="e819d19cb71035bc2b05451e5471df8840dc6d69" translate="yes" xml:space="preserve">
          <source>The mode should specify how to do highlighting for Font Lock mode, by setting up a buffer-local value for the variable &lt;code&gt;font-lock-defaults&lt;/code&gt; (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;).</source>
          <target state="translated">The mode should specify how to do highlighting for Font Lock mode, by setting up a buffer-local value for the variable &lt;code&gt;font-lock-defaults&lt;/code&gt; (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="41a1cfe199d882964dc064f09142206bb96f8e6c" translate="yes" xml:space="preserve">
          <source>The modification time of the visited file. It is set when the file is written or read. Before writing the buffer into a file, this field is compared to the modification time of the file to see if the file has changed on disk. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</source>
          <target state="translated">The modification time of the visited file. It is set when the file is written or read. Before writing the buffer into a file, this field is compared to the modification time of the file to see if the file has changed on disk. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4e9e26b12f5c002c1627a4d332042e4cecc33362" translate="yes" xml:space="preserve">
          <source>The modifiers list for a click event explicitly contains &lt;code&gt;click&lt;/code&gt;, but the event symbol name itself does not contain &amp;lsquo;</source>
          <target state="translated">The modifiers list for a click event explicitly contains &lt;code&gt;click&lt;/code&gt; , but the event symbol name itself does not contain &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="b3b787746e135e4f51648da476a31670954846cd" translate="yes" xml:space="preserve">
          <source>The momentary display remains until the next input event. If the next input event is &lt;var&gt;char&lt;/var&gt;, &lt;code&gt;momentary-string-display&lt;/code&gt; ignores it and returns. Otherwise, that event remains buffered for subsequent use as input. Thus, typing &lt;var&gt;char&lt;/var&gt; will simply remove the string from the display, while typing (say)</source>
          <target state="translated">The momentary display remains until the next input event. If the next input event is &lt;var&gt;char&lt;/var&gt; , &lt;code&gt;momentary-string-display&lt;/code&gt; ignores it and returns. Otherwise, that event remains buffered for subsequent use as input. Thus, typing &lt;var&gt;char&lt;/var&gt; will simply remove the string from the display, while typing (say)</target>
        </trans-unit>
        <trans-unit id="6ccfa1f10310929beb049fb30bcfc7d9086811f9" translate="yes" xml:space="preserve">
          <source>The month of the year, as an integer between 1 and 12.</source>
          <target state="translated">Месяц года,в виде целого числа от 1 до 12.</target>
        </trans-unit>
        <trans-unit id="edb5bce3a7e2bd1bf00ac6d3a9eb55fc41355ba2" translate="yes" xml:space="preserve">
          <source>The most basic primitive for minibuffer input is &lt;code&gt;read-from-minibuffer&lt;/code&gt;, which can be used to read either a string or a Lisp object in textual form. The function &lt;code&gt;read-regexp&lt;/code&gt; is used for reading regular expressions (see &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;Regular Expressions&lt;/a&gt;), which are a special kind of string. There are also specialized functions for reading commands, variables, file names, etc. (see &lt;a href=&quot;completion#Completion&quot;&gt;Completion&lt;/a&gt;).</source>
          <target state="translated">The most basic primitive for minibuffer input is &lt;code&gt;read-from-minibuffer&lt;/code&gt; , which can be used to read either a string or a Lisp object in textual form. The function &lt;code&gt;read-regexp&lt;/code&gt; is used for reading regular expressions (see &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;Regular Expressions&lt;/a&gt;), which are a special kind of string. There are also specialized functions for reading commands, variables, file names, etc. (see &lt;a href=&quot;completion#Completion&quot;&gt;Completion&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="04571e47b6db6005c0928b2d449f301cebe34f7a" translate="yes" xml:space="preserve">
          <source>The most basic way to alter the contents of an existing string is with &lt;code&gt;aset&lt;/code&gt; (see &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Array Functions&lt;/a&gt;). &lt;code&gt;(aset &lt;var&gt;string&lt;/var&gt;
&lt;var&gt;idx&lt;/var&gt; &lt;var&gt;char&lt;/var&gt;)&lt;/code&gt; stores &lt;var&gt;char&lt;/var&gt; into &lt;var&gt;string&lt;/var&gt; at index &lt;var&gt;idx&lt;/var&gt;. Each character occupies one or more bytes, and if &lt;var&gt;char&lt;/var&gt; needs a different number of bytes from the character already present at that index, &lt;code&gt;aset&lt;/code&gt; signals an error.</source>
          <target state="translated">The most basic way to alter the contents of an existing string is with &lt;code&gt;aset&lt;/code&gt; (see &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Array Functions&lt;/a&gt;). &lt;code&gt;(aset &lt;var&gt;string&lt;/var&gt; &lt;var&gt;idx&lt;/var&gt; &lt;var&gt;char&lt;/var&gt;)&lt;/code&gt; stores &lt;var&gt;char&lt;/var&gt; into &lt;var&gt;string&lt;/var&gt; at index &lt;var&gt;idx&lt;/var&gt; . Each character occupies one or more bytes, and if &lt;var&gt;char&lt;/var&gt; needs a different number of bytes from the character already present at that index, &lt;code&gt;aset&lt;/code&gt; signals an error.</target>
        </trans-unit>
        <trans-unit id="bf4dd793bfdf67867b9bdc6495e0ff90954bd76e" translate="yes" xml:space="preserve">
          <source>The most basic way to use the expression parser is to tell it to start at a given position with a certain state, and parse up to a specified end position.</source>
          <target state="translated">Самый простой способ использовать парсер выражений-это сказать ему,что нужно начинать с заданной позиции с определенным состоянием,и разобрать до заданной конечной позиции.</target>
        </trans-unit>
        <trans-unit id="b7f2a6fce568eb37624dbc5a896f8aecf156540b" translate="yes" xml:space="preserve">
          <source>The most common items to autoload are the interactive entry points to a library. For example, if</source>
          <target state="translated">Наиболее распространенными элементами автозагрузки являются интерактивные точки входа в библиотеку.Например,если</target>
        </trans-unit>
        <trans-unit id="00ce30cf3da30f9ec9b191e1b5b38d0ab5c7d881" translate="yes" xml:space="preserve">
          <source>The most common problem in writing macros is doing some of the real work prematurely&amp;mdash;while expanding the macro, rather than in the expansion itself. For instance, one real package had this macro definition:</source>
          <target state="translated">Самая распространенная проблема при написании макросов заключается в преждевременном выполнении некоторой реальной работы - при расширении макроса, а не в самом расширении. Например, у одного реального пакета было это определение макроса:</target>
        </trans-unit>
        <trans-unit id="2cf92a8ba2845654523982a452093a675127ce73" translate="yes" xml:space="preserve">
          <source>The most common reason to use &lt;code&gt;:require&lt;/code&gt; is when a variable enables a feature such as a minor mode, and just setting the variable won&amp;rsquo;t have any effect unless the code which implements the mode is loaded.</source>
          <target state="translated">Наиболее распространенная причина использования &lt;code&gt;:require&lt;/code&gt; - это когда переменная включает такую ​​функцию, как второстепенный режим, и простая установка переменной не будет иметь никакого эффекта, если не загружен код, реализующий режим.</target>
        </trans-unit>
        <trans-unit id="00d251711d163f90f5dc973380466e863d64f7b0" translate="yes" xml:space="preserve">
          <source>The most common repeat events are &lt;em&gt;double-click&lt;/em&gt; events. Emacs generates a double-click event when you click a button twice; the event happens when you release the button (as is normal for all click events).</source>
          <target state="translated">Наиболее частыми повторяющимися событиями являются события &lt;em&gt;двойного щелчка&lt;/em&gt; . Emacs генерирует событие двойного щелчка, когда вы дважды щелкаете кнопку; событие происходит, когда вы отпускаете кнопку (как обычно для всех событий щелчка).</target>
        </trans-unit>
        <trans-unit id="57850c0a76ab6f2efce7f9ee07926b9e3846b613" translate="yes" xml:space="preserve">
          <source>The most common use of buffer-local bindings is for major modes to change variables that control the behavior of commands. For example, C mode and Lisp mode both set the variable &lt;code&gt;paragraph-start&lt;/code&gt; to specify that only blank lines separate paragraphs. They do this by making the variable buffer-local in the buffer that is being put into C mode or Lisp mode, and then setting it to the new value for that mode. See &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Major Modes&lt;/a&gt;.</source>
          <target state="translated">Чаще всего привязки локального буфера используются в основных режимах для изменения переменных, которые управляют поведением команд. Например, режим C и режим Lisp устанавливают переменную &lt;code&gt;paragraph-start&lt;/code&gt; , чтобы указать, что только пустые строки разделяют абзацы. Они делают это, делая переменную buffer-local в буфере, который переводится в режим C или режим Lisp, а затем устанавливают ее на новое значение для этого режима. См. &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Основные режимы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="702580a0fb96dc0456829bb764ce3a637ffd43c4" translate="yes" xml:space="preserve">
          <source>The most common way of invoking a function is by evaluating a list. For example, evaluating the list &lt;code&gt;(concat &quot;a&quot; &quot;b&quot;)&lt;/code&gt; calls the function &lt;code&gt;concat&lt;/code&gt; with arguments &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;b&quot;&lt;/code&gt;. See &lt;a href=&quot;evaluation#Evaluation&quot;&gt;Evaluation&lt;/a&gt;, for a description of evaluation.</source>
          <target state="translated">Наиболее распространенный способ вызова функции - оценка списка. Например, оценка списка &lt;code&gt;(concat &quot;a&quot; &quot;b&quot;)&lt;/code&gt; вызывает функцию &lt;code&gt;concat&lt;/code&gt; с аргументами &lt;code&gt;&quot;a&quot;&lt;/code&gt; и &lt;code&gt;&quot;b&quot;&lt;/code&gt; . См. Описание оценки в разделе &amp;laquo; &lt;a href=&quot;evaluation#Evaluation&quot;&gt;Оценка&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d131735a093456a7b6d24f8f667e2b2a59acf4e8" translate="yes" xml:space="preserve">
          <source>The most common way to compute the length of a list, when you are not worried that it may be circular, is with &lt;code&gt;length&lt;/code&gt;. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">Самый распространенный способ вычисления длины списка, когда вы не беспокоитесь о том, что он может быть круглым, - это &lt;code&gt;length&lt;/code&gt; . См. &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Последовательные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="347c946e7276a21392ff141fa45e82a75d88329c" translate="yes" xml:space="preserve">
          <source>The most general of the two facilities is controlled by the variable &lt;code&gt;format-alist&lt;/code&gt;, a list of &lt;em&gt;file format&lt;/em&gt; specifications, which describe textual representations used in files for the data in an Emacs buffer. The descriptions for reading and writing are paired, which is why we call this &amp;ldquo;round-trip&amp;rdquo; specification (see &lt;a href=&quot;format-conversion-piecemeal#Format-Conversion-Piecemeal&quot;&gt;Format Conversion Piecemeal&lt;/a&gt;, for non-paired specification).</source>
          <target state="translated">Самая общая из двух возможностей управляется переменной &lt;code&gt;format-alist&lt;/code&gt; , списком спецификаций &lt;em&gt;форматов файлов&lt;/em&gt; , которые описывают текстовые представления, используемые в файлах для данных в буфере Emacs. Описания для чтения и записи являются парными, поэтому мы называем эту спецификацию &amp;laquo; &lt;a href=&quot;format-conversion-piecemeal#Format-Conversion-Piecemeal&quot;&gt;двустороннего обмена&lt;/a&gt; &amp;raquo; (см. &amp;laquo;По частям преобразования формата&amp;raquo;, где указана непарная спецификация).</target>
        </trans-unit>
        <trans-unit id="cd8ccdf82fe4e52359af0e8e7311554e454e5dd4" translate="yes" xml:space="preserve">
          <source>The most general way to check the type of an object is to call the function &lt;code&gt;type-of&lt;/code&gt;. Recall that each object belongs to one and only one primitive type; &lt;code&gt;type-of&lt;/code&gt; tells you which one (see &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;). But &lt;code&gt;type-of&lt;/code&gt; knows nothing about non-primitive types. In most cases, it is more convenient to use type predicates than &lt;code&gt;type-of&lt;/code&gt;.</source>
          <target state="translated">Самый общий способ проверить тип объекта - вызвать функцию &lt;code&gt;type-of&lt;/code&gt; . Напомним, что каждый объект принадлежит к одному и только одному примитивному типу; &lt;code&gt;type-of&lt;/code&gt; сообщает вам, какой из них (см. &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Типы данных Lisp&lt;/a&gt; ). Но &lt;code&gt;type-of&lt;/code&gt; ничего не знает о непримитивных типах. В большинстве случаев использовать предикаты &lt;code&gt;type-of&lt;/code&gt; удобнее, чем предикаты типа .</target>
        </trans-unit>
        <trans-unit id="c939ba5fb7000b3ef15a75258275fafbcfabe6bd" translate="yes" xml:space="preserve">
          <source>The most important time to enter the debugger is when a Lisp error happens. This allows you to investigate the immediate causes of the error.</source>
          <target state="translated">Самое важное время для входа в отладчик-это время,когда происходит ошибка Lisp.Это позволяет исследовать непосредственные причины ошибки.</target>
        </trans-unit>
        <trans-unit id="18cb17b94649eed8921d3ce73d54ecd88ad00023" translate="yes" xml:space="preserve">
          <source>The most simple approach to make a new atomic window is to take an existing internal window and apply the following function:</source>
          <target state="translated">Самый простой подход к созданию нового атомарного окна состоит в том,чтобы взять существующее внутреннее окно и применить следующую функцию:</target>
        </trans-unit>
        <trans-unit id="e1e8fa969491d0969bdb64f111c245755eef7fdd" translate="yes" xml:space="preserve">
          <source>The mutex ensures atomicity, and the loop is for robustness&amp;mdash;there may be spurious notifications.</source>
          <target state="translated">Мьютекс обеспечивает атомарность, а цикл - надежность - могут быть ложные уведомления.</target>
        </trans-unit>
        <trans-unit id="20600bb0132abd59b71aa3abecbc6c3c79d7ed11" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt; is an alias for this macro.</source>
          <target state="translated">Имя &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt; является псевдонимом для этого макроса.</target>
        </trans-unit>
        <trans-unit id="0164386da8dab74b0dca8dc21998a6981ad8f3bc" translate="yes" xml:space="preserve">
          <source>The name &lt;var&gt;property&lt;/var&gt; is compared with the existing property names using &lt;code&gt;eq&lt;/code&gt;, so any object is a legitimate property.</source>
          <target state="translated">Название &lt;var&gt;property&lt;/var&gt; сравнивается с существующими именами свойств с использованием &lt;code&gt;eq&lt;/code&gt; , поэтому любой объект является законным свойством.</target>
        </trans-unit>
        <trans-unit id="81686d309fb6971d2f0465f17ae4fbda5d84fd34" translate="yes" xml:space="preserve">
          <source>The name of a face from which to inherit attributes, or a list of face names. Attributes from inherited faces are merged into the face like an underlying face would be, with higher priority than underlying faces (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). If the face to inherit from is &lt;code&gt;unspecified&lt;/code&gt;, it is treated the same as &lt;code&gt;nil&lt;/code&gt;, since Emacs never merges &lt;code&gt;:inherit&lt;/code&gt; attributes. If a list of faces is used, attributes from faces earlier in the list override those from later faces.</source>
          <target state="translated">Имя лица, от которого наследуются атрибуты, или список имен лиц. Атрибуты унаследованных лиц объединяются в лицо, как это было бы с нижележащим лицом, с более высоким приоритетом, чем нижележащие лица (см. &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Отображение лиц&lt;/a&gt; ). Если лицо, от которого требуется наследовать, не &lt;code&gt;unspecified&lt;/code&gt; , оно рассматривается как &lt;code&gt;nil&lt;/code&gt; , поскольку Emacs никогда не объединяет &lt;code&gt;:inherit&lt;/code&gt; атрибуты. Если используется список лиц, атрибуты лиц, представленных ранее в списке, переопределяют атрибуты лиц более поздних лиц.</target>
        </trans-unit>
        <trans-unit id="f14b4e7f3d214e623215de71ea76c596c58a8147" translate="yes" xml:space="preserve">
          <source>The name of an existing buffer. By default, uses the name of the current buffer (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). Existing, Completion, Default, Prompt.</source>
          <target state="translated">Имя существующего буфера. По умолчанию используется имя текущего буфера (см. &lt;a href=&quot;buffers#Buffers&quot;&gt;Буферы&lt;/a&gt; ). Существующий, Завершение, По умолчанию, Запрос.</target>
        </trans-unit>
        <trans-unit id="2d3de7a674caef56f2edb7325689eee077d5c503" translate="yes" xml:space="preserve">
          <source>The name of the &lt;em&gt;font foundry&lt;/em&gt; for the font family specified by the &lt;code&gt;:family&lt;/code&gt; attribute (a string). See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">Название производителя &lt;em&gt;шрифтов&lt;/em&gt; для семейства шрифтов, заданное атрибутом &lt;code&gt;:family&lt;/code&gt; (строка). См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Шрифты&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="bb8aba24892b581b6675f143c2e9d3a6e057a04b" translate="yes" xml:space="preserve">
          <source>The name of the &lt;em&gt;font foundry&lt;/em&gt; for the font family specified by the &lt;code&gt;:family&lt;/code&gt; attribute (a string). See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84e4020bfcfa0d5df12e11e36810c5a458fbc2c" translate="yes" xml:space="preserve">
          <source>The name of the application sending the notification. The default is &lt;code&gt;notifications-application-name&lt;/code&gt;.</source>
          <target state="translated">Название приложения, отправляющего уведомление. По умолчанию - имя &lt;code&gt;notifications-application-name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31bc03ff12180dc54cb103b5e65b3d301c362de1" translate="yes" xml:space="preserve">
          <source>The name of the command that runs in the process. This is a string that usually specifies the name of the executable file of the process, without the leading directories. However, some special system processes can report strings that do not correspond to an executable file of a program.</source>
          <target state="translated">Имя команды,которая выполняется в процессе.Это строка,которая обычно задает имя исполняемого файла процесса,без ведущих каталогов.Однако некоторые специальные системные процессы могут сообщать о строках,которые не соответствуют исполняемому файлу программы.</target>
        </trans-unit>
        <trans-unit id="dd51404aec6b7e3516493114c0df7bd668d69bf8" translate="yes" xml:space="preserve">
          <source>The name of the device used by the terminal (e.g., &amp;lsquo;</source>
          <target state="translated">Имя устройства, используемого терминалом (например, '</target>
        </trans-unit>
        <trans-unit id="86223234e995255179c7f5ed59ad98c61222e8f0" translate="yes" xml:space="preserve">
          <source>The name of the file visited in this buffer, or &lt;code&gt;nil&lt;/code&gt;. This is the value of the buffer-local variable &lt;code&gt;buffer-file-name&lt;/code&gt; (see &lt;a href=&quot;buffer-file-name#Buffer-File-Name&quot;&gt;Buffer File Name&lt;/a&gt;).</source>
          <target state="translated">Имя файла, посещенного в этом буфере, или &lt;code&gt;nil&lt;/code&gt; . Это значение локальной переменной- &lt;code&gt;buffer-file-name&lt;/code&gt; &lt;a href=&quot;buffer-file-name#Buffer-File-Name&quot;&gt;буфера&lt;/a&gt; (см. Имя файла буфера ).</target>
        </trans-unit>
        <trans-unit id="9cf516df8bd70dd62a0f6c98d528269943f52170" translate="yes" xml:space="preserve">
          <source>The name of the font for displaying text in the frame. This is a string, either a valid font name for your system or the name of an Emacs fontset (see &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;). It is equivalent to the &lt;code&gt;font&lt;/code&gt; attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">Название шрифта для отображения текста во фрейме. Это строка, либо допустимое имя шрифта для вашей системы, либо имя набора шрифтов Emacs (см. &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Наборы шрифтов&lt;/a&gt; ). Он эквивалентен атрибуту &lt;code&gt;font&lt;/code&gt; по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c12d93ce989364c1c7d4f9a741900cf941c5dab1" translate="yes" xml:space="preserve">
          <source>The name of the frame. The frame name serves as a default for the frame title, if the &lt;code&gt;title&lt;/code&gt; parameter is unspecified or &lt;code&gt;nil&lt;/code&gt;. If you don&amp;rsquo;t specify a name, Emacs sets the frame name automatically (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;).</source>
          <target state="translated">Название кадра. Имя фрейма используется по умолчанию для заголовка фрейма, если параметр &lt;code&gt;title&lt;/code&gt; не указан или равен &lt;code&gt;nil&lt;/code&gt; . Если вы не укажете имя, Emacs установит имя фрейма автоматически (см. &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Заголовки&lt;/a&gt; фреймов ).</target>
        </trans-unit>
        <trans-unit id="d46a694cb309b5635ce7fcf75332cf135b35bc90" translate="yes" xml:space="preserve">
          <source>The name of the keysym that should stand for the Control modifier (respectively, for Alt, Meta, Hyper, and Super). For example, here is how to swap the Meta and Alt modifiers within Emacs:</source>
          <target state="translated">Название клавиши,которое должно означать модификатор Control (соответственно,для Alt,Meta,Hyper и Super).Например,вот как поменять модификаторы Meta и Alt внутри Emacs:</target>
        </trans-unit>
        <trans-unit id="ea60fe57d26ab008b617db1ef54c09ed08318866" translate="yes" xml:space="preserve">
          <source>The name of the package is the same as the base name of the file, as written on the first line. Here, it is &amp;lsquo;</source>
          <target state="translated">Имя пакета совпадает с базовым именем файла, написанным в первой строке. Вот '</target>
        </trans-unit>
        <trans-unit id="e21cb3a697575e4abea29254c179c8f2f42f271b" translate="yes" xml:space="preserve">
          <source>The name of the process. If &lt;var&gt;name&lt;/var&gt; is not given, &lt;var&gt;port&lt;/var&gt; will serve as the process name as well.</source>
          <target state="translated">Название процесса. Если &lt;var&gt;name&lt;/var&gt; не указано, &lt;var&gt;port&lt;/var&gt; будет служить именем процесса.</target>
        </trans-unit>
        <trans-unit id="33d6a32c269c144c63e53d0f2cba19c64ba4f020" translate="yes" xml:space="preserve">
          <source>The name of the terminal that the subprocess is using, or &lt;code&gt;nil&lt;/code&gt; if it is using pipes.</source>
          <target state="translated">Имя терминала, который использует подпроцесс, или &lt;code&gt;nil&lt;/code&gt; , если он использует каналы.</target>
        </trans-unit>
        <trans-unit id="fb41db266496240f445c6fb5baacf0f57a720b53" translate="yes" xml:space="preserve">
          <source>The name of the variable in the C sources.</source>
          <target state="translated">Имя переменной в источниках на языке С.</target>
        </trans-unit>
        <trans-unit id="a4f65da0bf349454db5eb2650407f2361527b7b0" translate="yes" xml:space="preserve">
          <source>The name of the variable to be used by Lisp programs.</source>
          <target state="translated">Имя переменной,которая будет использоваться программами на языке Lisp.</target>
        </trans-unit>
        <trans-unit id="3670965055037b4c4d3b2f88fc9e6bd05ff338ee" translate="yes" xml:space="preserve">
          <source>The name of this format.</source>
          <target state="translated">Название этого формата.</target>
        </trans-unit>
        <trans-unit id="8b92537c9d27af39ba1f11b476a35f30e67426f9" translate="yes" xml:space="preserve">
          <source>The name to use in the icon for this frame, when and if the icon appears. If this is &lt;code&gt;nil&lt;/code&gt;, the frame&amp;rsquo;s title is used.</source>
          <target state="translated">Имя для использования в значке для этого фрейма, когда и если значок появляется. Если это &lt;code&gt;nil&lt;/code&gt; , используется заголовок фрейма.</target>
        </trans-unit>
        <trans-unit id="773601ddb143e48334daba0a066ba237e287a6d6" translate="yes" xml:space="preserve">
          <source>The name used to open the font, a string.</source>
          <target state="translated">Имя,которое использовалось для открытия шрифта,строки.</target>
        </trans-unit>
        <trans-unit id="8fcccebb07f7dee6937b0795494fd79034dd2f04" translate="yes" xml:space="preserve">
          <source>The named &lt;var&gt;method&lt;/var&gt; was defined by using &lt;code&gt;cl-defmethod&lt;/code&gt;, with &lt;var&gt;specializers&lt;/var&gt; as its specializers.</source>
          <target state="translated">Именованный &lt;var&gt;method&lt;/var&gt; был определен с помощью &lt;code&gt;cl-defmethod&lt;/code&gt; со &lt;var&gt;specializers&lt;/var&gt; качестве его специализаций.</target>
        </trans-unit>
        <trans-unit id="fe3c2e352de1a3150f44a8697619e4fda0c3a43a" translate="yes" xml:space="preserve">
          <source>The names &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; &lt;small&gt;CAR&lt;/small&gt; was an instruction to extract the contents of the address part of a register, and &lt;small&gt;CDR&lt;/small&gt; an instruction to extract the contents of the decrement. By contrast, cons cells are named for the function &lt;code&gt;cons&lt;/code&gt; that creates them, which in turn was named for its purpose, the construction of cells.</source>
          <target state="translated">Имена &lt;small&gt;CAR&lt;/small&gt; и &lt;small&gt;CDR&lt;/small&gt; заимствованы из истории Lisp. Первоначальная реализация Лиспа работала на компьютере IBM 704, который разделял слова на две части: адрес и декремент; &lt;small&gt;CAR&lt;/small&gt; была инструкцией для извлечения содержимого адресной части регистра, а &lt;small&gt;CDR&lt;/small&gt; - инструкцией для извлечения содержимого декремента. Напротив, cons-ячейки названы в честь функции &lt;code&gt;cons&lt;/code&gt; , которая их создает, которая, в свою очередь, была названа по своему назначению - построению ячеек.</target>
        </trans-unit>
        <trans-unit id="ba31422c908b55bb35be7435bbd860d86c29702f" translate="yes" xml:space="preserve">
          <source>The native position of a frame is the reference position for functions that set or return the current position of the mouse (see &lt;a href=&quot;mouse-position#Mouse-Position&quot;&gt;Mouse Position&lt;/a&gt;) and for functions dealing with the position of windows like &lt;code&gt;window-edges&lt;/code&gt;, &lt;code&gt;window-at&lt;/code&gt; or &lt;code&gt;coordinates-in-window-p&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;). It also specifies the (0, 0) origin for locating and positioning child frames within this frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;).</source>
          <target state="translated">Собственная позиция фрейма - это опорная позиция для функций, которые устанавливают или возвращают текущее положение мыши (см. &lt;a href=&quot;mouse-position#Mouse-Position&quot;&gt;Положение мыши&lt;/a&gt; ), а также для функций, имеющих дело с положением окон, таких как &lt;code&gt;window-edges&lt;/code&gt; , &lt;code&gt;window-at&lt;/code&gt; или &lt;code&gt;coordinates-in-window-p&lt;/code&gt; (см. &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Координаты и Windows&lt;/a&gt; ). Он также определяет (0, 0) источник для поиска и позиционирования дочерних кадров внутри этого кадра (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние кадры&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="79b45725606655f4197b9ae82b2b82dab59aede2" translate="yes" xml:space="preserve">
          <source>The native size of a frame is the size Emacs passes to the window-system or window manager when creating or resizing the frame from within Emacs. It is also the size Emacs receives from the window-system or window manager whenever these resize the frame&amp;rsquo;s window-system window, for example, after maximizing the frame by clicking on the corresponding button in the title bar or when dragging its external border with the mouse.</source>
          <target state="translated">Собственный размер фрейма - это размер, который Emacs передает оконной системе или оконному менеджеру при создании или изменении размера фрейма из Emacs. Это также размер, который Emacs получает от оконной системы или оконного менеджера всякий раз, когда они изменяют размер окна оконной системы фрейма, например, после максимизации фрейма, щелкнув соответствующую кнопку в строке заголовка или при перетаскивании его внешней границы с мышь.</target>
        </trans-unit>
        <trans-unit id="14825e98a6bb7730ba468267f3c379f4d50eadd3" translate="yes" xml:space="preserve">
          <source>The network mask.</source>
          <target state="translated">Сетевая маска.</target>
        </trans-unit>
        <trans-unit id="7fc5eefdbee523b516c3a56d241e65616fe5cea8" translate="yes" xml:space="preserve">
          <source>The new command &lt;var&gt;variant&lt;/var&gt; is defined to call the function &lt;var&gt;parent&lt;/var&gt;, then override certain aspects of that parent mode:</source>
          <target state="translated">Новый &lt;var&gt;variant&lt;/var&gt; команды определен для вызова &lt;var&gt;parent&lt;/var&gt; функции , а затем переопределения определенных аспектов этого родительского режима:</target>
        </trans-unit>
        <trans-unit id="5ce6d115e553357dfd304409824efeb325dc1b14" translate="yes" xml:space="preserve">
          <source>The new definition of &lt;code&gt;for&lt;/code&gt; has a new problem: it introduces a local variable named &lt;code&gt;max&lt;/code&gt; which the user does not expect. This causes trouble in examples such as the following:</source>
          <target state="translated">Новое определение &lt;code&gt;for&lt;/code&gt; имеет новую проблему: оно вводит локальную переменную с именем &lt;code&gt;max&lt;/code&gt; , которую пользователь не ожидает. Это вызывает проблемы в следующих примерах:</target>
        </trans-unit>
        <trans-unit id="6a336356f22c547d590556ea521f2dad738c8349" translate="yes" xml:space="preserve">
          <source>The new fontset has two names, one long and one short. The long name is &lt;var&gt;fontpattern&lt;/var&gt; in its entirety. The short name is &amp;lsquo;</source>
          <target state="translated">Новый набор шрифтов имеет два имени: одно длинное и одно короткое. &lt;var&gt;fontpattern&lt;/var&gt; имя - это полностью fontpattern . Краткое название - '</target>
        </trans-unit>
        <trans-unit id="c3a411aa70ab9bb343c22475f4a8a3db7a1aaaa6" translate="yes" xml:space="preserve">
          <source>The new marker&amp;rsquo;s insertion type is specified by the argument &lt;var&gt;insertion-type&lt;/var&gt;. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;.</source>
          <target state="translated">Тип вставки нового маркера определяется &lt;var&gt;insertion-type&lt;/var&gt; аргумента . См. &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Типы вставки маркеров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e53ad877e538af9a720bbb66ac6ff5d4008840d4" translate="yes" xml:space="preserve">
          <source>The new mode has its own abbrev table, kept in the variable &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-abbrev-table&lt;/code&gt;, unless you override this using the &lt;code&gt;:abbrev-table&lt;/code&gt; keyword (see below).</source>
          <target state="translated">В новом режиме есть своя собственная таблица сокращений, хранящаяся в &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-abbrev-table&lt;/code&gt; переменной -abbrev-table , если вы не переопределите это с помощью ключевого слова &lt;code&gt;:abbrev-table&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="b817ae5e0fd787bbcf07fe3487597358970c4e96" translate="yes" xml:space="preserve">
          <source>The new mode has its own mode hook, &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-hook&lt;/code&gt;. It runs this hook, after running the hooks of its ancestor modes, with &lt;code&gt;run-mode-hooks&lt;/code&gt;, as the last thing it does, apart from running any &lt;code&gt;:after-hook&lt;/code&gt; form it may have. See &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;Mode Hooks&lt;/a&gt;.</source>
          <target state="translated">В новом режиме есть собственный режим-крючок, &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-hook&lt;/code&gt; . Он запускает эту ловушку после запуска ловушек своих предшественников с помощью &lt;code&gt;run-mode-hooks&lt;/code&gt; , как последнее, что он делает, кроме запуска любой формы &lt;code&gt;:after-hook&lt;/code&gt; ,которую он может иметь. См. &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;Перехватчики режима&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00570ab789edcc32fb33047192ad9e67acc9f749" translate="yes" xml:space="preserve">
          <source>The new mode has its own sparse keymap, named &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt;. &lt;code&gt;define-derived-mode&lt;/code&gt; makes the parent mode&amp;rsquo;s keymap the parent of the new map, unless &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt; is already set and already has a parent.</source>
          <target state="translated">В новом режиме есть собственная разреженная &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt; именем &lt;var&gt;variant&lt;/var&gt; -map . &lt;code&gt;define-derived-mode&lt;/code&gt; делает &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt; родительского режима родительским для новой карты, если &lt;var&gt;variant&lt;/var&gt; -map уже не установлен и уже имеет родительский элемент.</target>
        </trans-unit>
        <trans-unit id="945a91028fd0f8fc9a5b05174767e7c35cb3f960" translate="yes" xml:space="preserve">
          <source>The new mode has its own syntax table, kept in the variable &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt;, unless you override this using the &lt;code&gt;:syntax-table&lt;/code&gt; keyword (see below). &lt;code&gt;define-derived-mode&lt;/code&gt; makes the parent mode&amp;rsquo;s syntax-table the parent of &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt;, unless the latter is already set and already has a parent different from the standard syntax table.</source>
          <target state="translated">У нового режима есть своя собственная таблица синтаксиса, хранящаяся в &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt; переменной -syntax-table , если вы не переопределите это с помощью ключевого слова &lt;code&gt;:syntax-table&lt;/code&gt; (см. Ниже). &lt;code&gt;define-derived-mode&lt;/code&gt; делает таблицу синтаксиса родительского режима родительским элементом для &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt; , если последняя уже не установлена ​​и не имеет родительского элемента, отличного от стандартной таблицы синтаксиса.</target>
        </trans-unit>
        <trans-unit id="c2597cc1d2ff3aeb01d30bac9fc3cde7623c9599" translate="yes" xml:space="preserve">
          <source>The new thread is created with no local variable bindings in effect. The new thread&amp;rsquo;s current buffer is inherited from the current thread.</source>
          <target state="translated">Новый поток создается без действующих привязок локальных переменных. Текущий буфер нового потока наследуется от текущего потока.</target>
        </trans-unit>
        <trans-unit id="8df0e83e8de1eb380770375b9be1ffb711a27047" translate="yes" xml:space="preserve">
          <source>The newest element in the ring always has index 0. Higher indices correspond to older elements. Indices are computed modulo the ring length. Index -1 corresponds to the oldest element, -2 to the next-oldest, and so forth.</source>
          <target state="translated">Новейший элемент в кольце всегда имеет индекс 0.Более высокие индексы соответствуют более старым элементам.Индексы рассчитываются по модулю длины кольца.Индекс -1 соответствует старому элементу,-2-следующему старому и так далее.</target>
        </trans-unit>
        <trans-unit id="8e1c114485b4df403bf7d12c30cb8c0fba64430c" translate="yes" xml:space="preserve">
          <source>The newline character (character code 10) has a special effect: it ends the preceding line and starts a new line.</source>
          <target state="translated">Символ новой строки (код символа 10)имеет особый эффект:он завершает предыдущую строку и начинает новую.</target>
        </trans-unit>
        <trans-unit id="2e9517c16f2af179f8f22773bf78a93935c17bc6" translate="yes" xml:space="preserve">
          <source>The newline character is not special in the read syntax for strings; if you write a new line between the double-quotes, it becomes a character in the string. But an escaped newline&amp;mdash;one that is preceded by &amp;lsquo;</source>
          <target state="translated">Символ новой строки не является специальным в синтаксисе чтения для строк; если вы напишете новую строку между двойными кавычками, она станет символом в строке. Но экранированный символ новой строки - тот, которому предшествует '</target>
        </trans-unit>
        <trans-unit id="4efa69ac3b7f005e072f33b3c4d9d2015117589e" translate="yes" xml:space="preserve">
          <source>The next &lt;code&gt;pred&lt;/code&gt; (lines 4-5) evaluates &lt;code&gt;(string-match&amp;nbsp;RX&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; and matches if the result is non-&lt;code&gt;nil&lt;/code&gt;, which means that &lt;var&gt;expval&lt;/var&gt; has the desired form: &lt;code&gt;key:NUMBER&lt;/code&gt;. Again, failing this, &lt;code&gt;pred&lt;/code&gt; fails and &lt;code&gt;and&lt;/code&gt;, too.</source>
          <target state="translated">Следующий &lt;code&gt;pred&lt;/code&gt; (строки 4-5) оценивает &lt;code&gt;(string-match&amp;nbsp;RX&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; и соответствует, если результат не равен &lt;code&gt;nil&lt;/code&gt; , что означает, что &lt;var&gt;expval&lt;/var&gt; имеет желаемую форму: &lt;code&gt;key:NUMBER&lt;/code&gt; . Опять же , если это невозможно, &lt;code&gt;pred&lt;/code&gt; терпит неудачу , и &lt;code&gt;and&lt;/code&gt; тоже.</target>
        </trans-unit>
        <trans-unit id="b7694837921d35a54e56c860831d6080ffe61e74" translate="yes" xml:space="preserve">
          <source>The next and previous sibling of this window as Lisp objects. &lt;code&gt;next&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if the window is the right-most or bottom-most in its group; &lt;code&gt;prev&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if it is the left-most or top-most in its group. Whether the sibling is left/right or up/down is determined by the &lt;code&gt;horizontal&lt;/code&gt; field of the sibling&amp;rsquo;s parent: if it&amp;rsquo;s non-zero, the siblings are arranged horizontally.</source>
          <target state="translated">Следующий и предыдущий брат этого окна как объекты Лиспа. &lt;code&gt;next&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; если окно является самым правым или самым нижним в своей группе; &lt;code&gt;prev&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; если он самый левый или самый верхний в своей группе. То, находится ли брат влево / вправо или вверх / вниз, определяется &lt;code&gt;horizontal&lt;/code&gt; полем родительского элемента: если оно не равно нулю, то братья и сестры располагаются горизонтально.</target>
        </trans-unit>
        <trans-unit id="20020241f8b21f6f1b62e467e43654e312585449" translate="yes" xml:space="preserve">
          <source>The next four arguments to &lt;code&gt;sort-subr&lt;/code&gt; are functions that are called to move point across a sort record. They are called many times from within &lt;code&gt;sort-subr&lt;/code&gt;.</source>
          <target state="translated">Следующие четыре аргумента &lt;code&gt;sort-subr&lt;/code&gt; - это функции, которые вызываются для перемещения точки по записи сортировки. Они вызываются много раз из &lt;code&gt;sort-subr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e6df56c6cfd59f81e1889be41424dbd8e05af1c" translate="yes" xml:space="preserve">
          <source>The next four functions all return markers with insertion type &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;.</source>
          <target state="translated">Все следующие четыре функции возвращают маркеры с типом вставки &lt;code&gt;nil&lt;/code&gt; . См. &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Типы вставки маркеров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e450313c4033e8457df931e4950913eecef97c" translate="yes" xml:space="preserve">
          <source>The next redisplay after resumption will redraw the entire screen, unless the variable &lt;code&gt;no-redraw-on-reenter&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;refresh-screen#Refresh-Screen&quot;&gt;Refresh Screen&lt;/a&gt;.</source>
          <target state="translated">Следующее повторное отображение после возобновления приведет к перерисовке всего экрана, если переменная &lt;code&gt;no-redraw-on-reenter&lt;/code&gt; не равна &lt;code&gt;nil&lt;/code&gt; . См. &amp;laquo; &lt;a href=&quot;refresh-screen#Refresh-Screen&quot;&gt;Обновить экран&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c62480706c4435432f9cbd719f04c8c0e8d4d4b" translate="yes" xml:space="preserve">
          <source>The next step is to determine precisely what is wrong. There is no way to be sure of this except by studying the program, but often the existing indentation is a clue to where the parentheses should have been. The easiest way to use this clue is to reindent with</source>
          <target state="translated">Следующий шаг-точно определить,что именно не так.В этом можно быть уверенным только изучая программу,но часто существующий отступ является ключом к разгадке,где скобки должны были быть.Самый простой способ использовать эту подсказку-это перечитать с помощью</target>
        </trans-unit>
        <trans-unit id="e881ec82dc043025b05e415a53a5307e0b9d1a7c" translate="yes" xml:space="preserve">
          <source>The next subsection describes how to define your own fringe bitmaps.</source>
          <target state="translated">В следующем подразделе описано,как определить свои собственные битовые карты.</target>
        </trans-unit>
        <trans-unit id="28f5894deb6be2c66452b9dec8f473fdb6fefb38" translate="yes" xml:space="preserve">
          <source>The next two commands are similar to &lt;code&gt;switch-to-buffer&lt;/code&gt;, except for the described features.</source>
          <target state="translated">Следующие две команды аналогичны &lt;code&gt;switch-to-buffer&lt;/code&gt; , за исключением описанных функций.</target>
        </trans-unit>
        <trans-unit id="7cc9290c0d0d2e4b42ba908efb154f702ea15fc9" translate="yes" xml:space="preserve">
          <source>The next two functions either return the argument &lt;var&gt;string&lt;/var&gt;, or a newly created string with no text properties.</source>
          <target state="translated">Следующие две функции либо возвращают &lt;var&gt;string&lt;/var&gt; аргумента , либо вновь созданную строку без текстовых свойств.</target>
        </trans-unit>
        <trans-unit id="c1bc1e54049d4149bb73763e09a0583d8724361a" translate="yes" xml:space="preserve">
          <source>The next two functions signal an error if the mark does not point anywhere. If Transient Mark mode is enabled and &lt;code&gt;mark-even-if-inactive&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, they also signal an error if the mark is inactive.</source>
          <target state="translated">Следующие две функции сигнализируют об ошибке, если метка никуда не указывает. Если включен режим Transient Mark и значение &lt;code&gt;mark-even-if-inactive&lt;/code&gt; равно &lt;code&gt;nil&lt;/code&gt; , они также сигнализируют об ошибке, если метка неактивна.</target>
        </trans-unit>
        <trans-unit id="377df722feabe51756819277064a7bd38601469b" translate="yes" xml:space="preserve">
          <source>The non-printable &lt;em&gt;&lt;acronym&gt;ASCII&lt;/acronym&gt; control characters&lt;/em&gt;&amp;mdash;character codes 0 through 31, as well as the</source>
          <target state="translated">Непечатаемые &lt;em&gt;управляющие символы &lt;/em&gt;&lt;em&gt;&lt;acronym&gt;ASCII -&lt;/acronym&gt;&lt;/em&gt; коды &lt;em&gt;символов от&lt;/em&gt; 0 до 31, а также</target>
        </trans-unit>
        <trans-unit id="ce617211fc2ab0bb06bc37aae9e870737adcb1d5" translate="yes" xml:space="preserve">
          <source>The nonce is currently unused and only some MACs support it.</source>
          <target state="translated">Нонце в настоящее время не используется,и только некоторые КИПы поддерживают его.</target>
        </trans-unit>
        <trans-unit id="72d8a158209595f8bea693b50b579072c4c32b6d" translate="yes" xml:space="preserve">
          <source>The normal use of this function is to get the window system&amp;rsquo;s clipboard as the most recent kill, even if the selection belongs to another application. See &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;Window System Selections&lt;/a&gt;. However, if the clipboard contents come from the current Emacs session, this function should return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Обычно эта функция используется для получения буфера обмена оконной системы как самого последнего уничтожения, даже если выбор принадлежит другому приложению. См. &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;Выбор оконной системы&lt;/a&gt; . Однако, если содержимое буфера обмена поступает из текущего сеанса Emacs, эта функция должна вернуть &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e4d1f4d52266035590d8daa8fadfd0297361c08" translate="yes" xml:space="preserve">
          <source>The normal use of this function is to put newly killed text in the window system&amp;rsquo;s clipboard. See &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;Window System Selections&lt;/a&gt;.</source>
          <target state="translated">Обычно эта функция используется для помещения недавно убитого текста в буфер обмена оконной системы. См. &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;Выбор оконной системы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1cb8bbe65ec53be9067206dd1dfa6d2cad2dca" translate="yes" xml:space="preserve">
          <source>The normal value of this variable includes &lt;code&gt;user-error&lt;/code&gt;, as well as several errors that happen often during editing but rarely result from bugs in Lisp programs. However, &amp;ldquo;rarely&amp;rdquo; is not &amp;ldquo;never&amp;rdquo;; if your program fails with an error that matches this list, you may try changing this list to debug the error. The easiest way is usually to set &lt;code&gt;debug-ignored-errors&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Нормальное значение этой переменной включает &lt;code&gt;user-error&lt;/code&gt; , а также несколько ошибок, которые часто случаются во время редактирования, но редко являются результатом ошибок в программах на Лиспе. Однако &amp;laquo;редко&amp;raquo; - это не &amp;laquo;никогда&amp;raquo;; если ваша программа выдает ошибку, соответствующую этому списку, вы можете попробовать изменить этот список, чтобы отладить ошибку. Самый простой способ, как правило , в набор &lt;code&gt;debug-ignored-errors&lt;/code&gt; в &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="615cf55184d1614679df8cf6d2cbadac0179b9d2" translate="yes" xml:space="preserve">
          <source>The normal way to use this feature is that the &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; functions add this property, as well as others, to the characters they operate on. That way, they avoid being called over and over for the same text.</source>
          <target state="translated">Обычный способ использования этой функции состоит в том, что функции &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; functions добавляют это свойство, а также другие свойства к символам, с которыми они работают. Таким образом, они избегают многократных повторений одного и того же текста.</target>
        </trans-unit>
        <trans-unit id="5bf403f55157eac254eec47b71824c0e07ba8c39" translate="yes" xml:space="preserve">
          <source>The normal way to use this function is after reading text from a file without decoding, if you decide you would rather have decoded it. Instead of deleting the text and reading it again, this time with decoding, you can call this function.</source>
          <target state="translated">Обычный способ использования этой функции-после чтения текста из файла без расшифровки,если вы решили,что хотите его декодировать.Вместо того,чтобы удалять текст и читать его снова,на этот раз с помощью декодирования,вы можете вызвать эту функцию.</target>
        </trans-unit>
        <trans-unit id="14a4051b3db7273c333fed729bd4705f42b76cf0" translate="yes" xml:space="preserve">
          <source>The notification &lt;var&gt;id&lt;/var&gt; that this notification replaces. &lt;var&gt;id&lt;/var&gt; must be the result of a previous &lt;code&gt;notifications-notify&lt;/code&gt; call.</source>
          <target state="translated">Уведомление &lt;var&gt;id&lt;/var&gt; , что это уведомление заменяет. &lt;var&gt;id&lt;/var&gt; должен быть результатом предыдущего вызова &lt;code&gt;notifications-notify&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="235facb694a3673208a66d292afda77da06ef3e0" translate="yes" xml:space="preserve">
          <source>The notification body text. Depending on the implementation of the notification server, the text could contain HTML markups, like &amp;lsquo;</source>
          <target state="translated">Текст сообщения. В зависимости от реализации сервера уведомлений текст может содержать разметку HTML, например '</target>
        </trans-unit>
        <trans-unit id="d6d14187af51bbbd99a616baf65fac010ae3eeaf" translate="yes" xml:space="preserve">
          <source>The notification title.</source>
          <target state="translated">Название уведомления.</target>
        </trans-unit>
        <trans-unit id="e447b4e8d9dde9805fe495b79d88178d76f80ab4" translate="yes" xml:space="preserve">
          <source>The number and significance of the objects in &lt;var&gt;data&lt;/var&gt; depends on &lt;var&gt;error-symbol&lt;/var&gt;. For example, with a &lt;code&gt;wrong-type-argument&lt;/code&gt; error, there should be two objects in the list: a predicate that describes the type that was expected, and the object that failed to fit that type.</source>
          <target state="translated">Количество и значимость объектов в &lt;var&gt;data&lt;/var&gt; зависит от &lt;var&gt;error-symbol&lt;/var&gt; . Например, при ошибке &lt;code&gt;wrong-type-argument&lt;/code&gt; в списке должно быть два объекта: предикат, описывающий ожидаемый тип, и объект, который не соответствует этому типу.</target>
        </trans-unit>
        <trans-unit id="77b891078bd95b24372c2265e2e2cd84fcd84a78" translate="yes" xml:space="preserve">
          <source>The number of &amp;lsquo;</source>
          <target state="translated">Номер '</target>
        </trans-unit>
        <trans-unit id="69d9f447f26ab68125cf7f7418e7b287e062c516" translate="yes" xml:space="preserve">
          <source>The number of bits per byte, which can be 7 or 8. If &lt;var&gt;bytesize&lt;/var&gt; is not given or &lt;code&gt;nil&lt;/code&gt;, it defaults to 8.</source>
          <target state="translated">Число битов на байт, которое может быть 7 или 8. Если &lt;var&gt;bytesize&lt;/var&gt; не задан или равен &lt;code&gt;nil&lt;/code&gt; , по умолчанию используется 8.</target>
        </trans-unit>
        <trans-unit id="e69db1d2aafc1ecd874d0fd32605ef1930ae4340" translate="yes" xml:space="preserve">
          <source>The number of bool vector entries stored for each row; the smallest multiple of 8 greater than or equal to &lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">Число элементов вектора bool, хранящихся для каждой строки; наименьшее число, кратное 8, больше или равно &lt;var&gt;width&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="0c696104f1d296d98cbf922f187ea8cac7fb9e83" translate="yes" xml:space="preserve">
          <source>The number of buffer objects in use. This includes killed buffers invisible to users, i.e., all buffers in &lt;code&gt;all_buffers&lt;/code&gt; list.</source>
          <target state="translated">Количество используемых буферных объектов. Это включает убитые буферы, невидимые для пользователей, т. &lt;code&gt;all_buffers&lt;/code&gt; Все буферы в списке all_buffers .</target>
        </trans-unit>
        <trans-unit id="252d4f28db846bbf940d1217fadcdf56740580e5" translate="yes" xml:space="preserve">
          <source>The number of characters at the start and end of the text that are known to be unchanged since the last complete redisplay.</source>
          <target state="translated">Количество символов в начале и в конце текста,которые,как известно,остаются неизменными с момента последнего полного переигрывания.</target>
        </trans-unit>
        <trans-unit id="89a302eaa04563e94b2b926ac658405d57a2374e" translate="yes" xml:space="preserve">
          <source>The number of cons cells for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">Количество консольных ячеек,для которых пространство получено из операционной системы,но которые в настоящее время не используются.</target>
        </trans-unit>
        <trans-unit id="928cf9ce73beb664ce217349a8d5e6418448c470" translate="yes" xml:space="preserve">
          <source>The number of cons cells in use.</source>
          <target state="translated">Количество используемых &quot;золотых ячеек&quot;.</target>
        </trans-unit>
        <trans-unit id="24f7af3992f54804406740120a68503980b1aaf3" translate="yes" xml:space="preserve">
          <source>The number of currently active &lt;code&gt;unwind-protect&lt;/code&gt; forms counts, together with the number of local variable bindings, against the limit &lt;code&gt;max-specpdl-size&lt;/code&gt; (see &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;Local Variables&lt;/a&gt;).</source>
          <target state="translated">Количество активных в данный момент форм &lt;code&gt;unwind-protect&lt;/code&gt; от размотки учитывается вместе с количеством привязок локальных переменных к ограничению &lt;code&gt;max-specpdl-size&lt;/code&gt; (см. &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;Локальные переменные&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c35725bb13e2859f8f990b1b6c1b4705566676f" translate="yes" xml:space="preserve">
          <source>The number of currently active calls to &lt;code&gt;eval&lt;/code&gt; is limited to &lt;code&gt;max-lisp-eval-depth&lt;/code&gt; (see below).</source>
          <target state="translated">Количество активных в данный момент вызовов &lt;code&gt;eval&lt;/code&gt; ограничено &lt;code&gt;max-lisp-eval-depth&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="26632f6fb1891fe7db7e3348f1653f11addc21e8" translate="yes" xml:space="preserve">
          <source>The number of floats for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">Количество поплавков,для которых пространство было получено из операционной системы,но которые в настоящее время не используются.</target>
        </trans-unit>
        <trans-unit id="f76646dd4182a8fa6a14d755790c6c7d2864f09c" translate="yes" xml:space="preserve">
          <source>The number of floats in use.</source>
          <target state="translated">Количество используемых поплавков.</target>
        </trans-unit>
        <trans-unit id="7d151b45b0c5d7e9e3c605630f35524687f27612" translate="yes" xml:space="preserve">
          <source>The number of free slots in all vector blocks.</source>
          <target state="translated">Количество свободных слотов во всех векторных блоках.</target>
        </trans-unit>
        <trans-unit id="7a5cbacf926b1512cd0ba23780e03b3e4a98118a" translate="yes" xml:space="preserve">
          <source>The number of intervals for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">Количество интервалов,для которых было получено место от операционной системы,но которые в настоящее время не используются.</target>
        </trans-unit>
        <trans-unit id="602801cbd4078754bb74d81473f6f900a3e284ba" translate="yes" xml:space="preserve">
          <source>The number of intervals in use.</source>
          <target state="translated">Количество используемых интервалов.</target>
        </trans-unit>
        <trans-unit id="92de848307ab335b54cbbb276e13709bea52b86a" translate="yes" xml:space="preserve">
          <source>The number of lines to allocate at the top of the frame for a menu bar (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;). The default is one if Menu Bar mode is enabled and zero otherwise. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;Menu Bars&lt;/a&gt; in</source>
          <target state="translated">Количество строк, которые нужно выделить в верхней части фрейма для строки меню (см. Панель &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;меню&lt;/a&gt; ). Значение по умолчанию равно единице, если включен режим строки меню, и нулю в противном случае. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;Панели меню&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="f80d400cbef17969aa3cb57eca5045cef8587bc0" translate="yes" xml:space="preserve">
          <source>The number of lines to allocate at the top of the frame for a menu bar (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;). The default is one if Menu Bar mode is enabled and zero otherwise. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;Menu Bars&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5827e772cc5045e135130ea07603e84be0177d9b" translate="yes" xml:space="preserve">
          <source>The number of lines to use for the tool bar (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;). The default is one if Tool Bar mode is enabled and zero otherwise. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Tool Bars&lt;/a&gt; in</source>
          <target state="translated">Количество линий, используемых для панели инструментов (см. Панель &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;инструментов&lt;/a&gt; ). По умолчанию используется один, если включен режим панели инструментов, и ноль в противном случае. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Панели инструментов&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="beada725979447960084176a0763b526687ee795" translate="yes" xml:space="preserve">
          <source>The number of lines to use for the tool bar (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;). The default is one if Tool Bar mode is enabled and zero otherwise. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Tool Bars&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f4d7c21579924cbdecd9574578a0259e96375a" translate="yes" xml:space="preserve">
          <source>The number of major page faults caused by the process since its beginning. (Major page faults require a disk to be read, and are thus more expensive than minor page faults.)</source>
          <target state="translated">Количество неисправностей на главной странице,вызванных процессом с момента его начала.(Основные неисправности страницы требуют чтения диска,и поэтому стоят дороже,чем незначительные неисправности страницы).</target>
        </trans-unit>
        <trans-unit id="190fa917612a525a4d94c58578c9ab17ff36e051" translate="yes" xml:space="preserve">
          <source>The number of minor page faults caused by the process since its beginning. (Minor page faults are those that don&amp;rsquo;t involve reading from disk.)</source>
          <target state="translated">Количество незначительных ошибок страниц, вызванных процессом с момента его начала. (Незначительные ошибки страницы - это те, которые не связаны с чтением с диска.)</target>
        </trans-unit>
        <trans-unit id="9d5ec76f037793ae468581429ef386612dd124f8" translate="yes" xml:space="preserve">
          <source>The number of minutes past the hour, as an integer between 0 and 59.</source>
          <target state="translated">Количество минут,прошедших после часа,в виде целого числа от 0 до 59.</target>
        </trans-unit>
        <trans-unit id="ad0f8ee15c9aa29fe5fb9cbe7ca13d4d44b5ef6a" translate="yes" xml:space="preserve">
          <source>The number of names the file has (&lt;code&gt;file-attribute-link-number&lt;/code&gt;). Alternate names, also known as hard links, can be created by using the &lt;code&gt;add-name-to-file&lt;/code&gt; function (see &lt;a href=&quot;changing-files#Changing-Files&quot;&gt;Changing Files&lt;/a&gt;).</source>
          <target state="translated">Количество имен файла ( &lt;code&gt;file-attribute-link-number&lt;/code&gt; ). Альтернативные имена, также известные как жесткие ссылки, можно создать с помощью функции &lt;code&gt;add-name-to-file&lt;/code&gt; (см. &lt;a href=&quot;changing-files#Changing-Files&quot;&gt;Изменение файлов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="325baa1e7adcb16dc50f6245d77c21d0debe4ede" translate="yes" xml:space="preserve">
          <source>The number of pixels from the top of the scroll bar to the click position. On some toolkits, including GTK+, Emacs cannot extract this data, so the value is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Количество пикселей от верха полосы прокрутки до позиции щелчка. В некоторых наборах инструментов, включая GTK +, Emacs не может извлечь эти данные, поэтому значение всегда равно &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81f70c31bc5858d0b9ea55feb80b52d7b0622a5a" translate="yes" xml:space="preserve">
          <source>The number of seconds past the minute, with form described below.</source>
          <target state="translated">Количество секунд,прошедших после минуты,с формой,описанной ниже.</target>
        </trans-unit>
        <trans-unit id="16f645a9b7573d7e0be85843502b2537b32b9812" translate="yes" xml:space="preserve">
          <source>The number of slots in all used vectors. Slot counts might include some or all overhead from vector headers, depending on the platform.</source>
          <target state="translated">Количество слотов во всех используемых векторах.Количество слотов может включать в себя некоторые или все накладные расходы из векторных заголовков,в зависимости от платформы.</target>
        </trans-unit>
        <trans-unit id="b4c7e2965ba0ba590e73e99ea618e58e9f048f9a" translate="yes" xml:space="preserve">
          <source>The number of stopbits used to terminate a transmission of each byte. &lt;var&gt;stopbits&lt;/var&gt; can be 1 or 2. If &lt;var&gt;stopbits&lt;/var&gt; is not given or &lt;code&gt;nil&lt;/code&gt;, it defaults to 1.</source>
          <target state="translated">Количество стоповых битов, используемых для завершения передачи каждого байта. &lt;var&gt;stopbits&lt;/var&gt; могут быть 1 или 2. Если &lt;var&gt;stopbits&lt;/var&gt; не заданы или равны &lt;code&gt;nil&lt;/code&gt; , по умолчанию используется 1.</target>
        </trans-unit>
        <trans-unit id="584465d6a9c8121efa55f5d37a6a82a27d12aa63" translate="yes" xml:space="preserve">
          <source>The number of string headers for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">Количество заголовков строк,для которых в операционной системе было получено место,но которые в настоящее время не используются.</target>
        </trans-unit>
        <trans-unit id="11eee3b04765f2e7c114ec5eb04da8bccc9c8d67" translate="yes" xml:space="preserve">
          <source>The number of string headers in use.</source>
          <target state="translated">Количество используемых заголовков строк.</target>
        </trans-unit>
        <trans-unit id="2adc6fb63d1bc6a3331dbbc9b05d0c9bd724c7c7" translate="yes" xml:space="preserve">
          <source>The number of symbols for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">Количество символов,для которых пространство получено из операционной системы,но которые в настоящее время не используются.</target>
        </trans-unit>
        <trans-unit id="710444e67e6d2313474db8860db1bd9ce9d6ab60" translate="yes" xml:space="preserve">
          <source>The number of symbols in use.</source>
          <target state="translated">Количество используемых символов.</target>
        </trans-unit>
        <trans-unit id="88b7053411bf3b3b073ba4f231a1da2711e2f38c" translate="yes" xml:space="preserve">
          <source>The number of threads in the process.</source>
          <target state="translated">Количество нитей в процессе.</target>
        </trans-unit>
        <trans-unit id="7d720d63753916813fff9649510319aa14c02852" translate="yes" xml:space="preserve">
          <source>The number of vector headers allocated from the vector blocks.</source>
          <target state="translated">Количество заголовков векторов,выделенных из векторных блоков.</target>
        </trans-unit>
        <trans-unit id="59b6b2c7dabce2307e6e799dfef671c14314174a" translate="yes" xml:space="preserve">
          <source>The numeric prefix argument. (Note that this &amp;lsquo;</source>
          <target state="translated">Аргумент числового префикса. (Обратите внимание, что это '</target>
        </trans-unit>
        <trans-unit id="839e8e25e1178c7a8e748322d0c3fe4ba4cb103f" translate="yes" xml:space="preserve">
          <source>The numeric prefix argument; but if there is no prefix argument, read a number as with</source>
          <target state="translated">Числовой префиксный аргумент;но если нет префиксного аргумента,прочтите число,как в случае с</target>
        </trans-unit>
        <trans-unit id="439b92119e69deb37b60614763a2c3dea4cdbbe6" translate="yes" xml:space="preserve">
          <source>The numerical priority of the process.</source>
          <target state="translated">Числовой приоритет процесса.</target>
        </trans-unit>
        <trans-unit id="7fe81b17fc17a93e95e511a73b78731b8a8de04d" translate="yes" xml:space="preserve">
          <source>The numerical process group ID of the foreground process group that uses the process&amp;rsquo;s terminal.</source>
          <target state="translated">Числовой идентификатор группы процессов группы процессов переднего плана, которая использует терминал процесса.</target>
        </trans-unit>
        <trans-unit id="6fa1cb69c8ffa6967bb6548d178d71e54c8286e1" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;nil&lt;/code&gt;, in addition to its other meanings, may be used as a stream. It stands for the value of the variable &lt;code&gt;standard-input&lt;/code&gt; or &lt;code&gt;standard-output&lt;/code&gt;. Also, the object &lt;code&gt;t&lt;/code&gt; as a stream specifies input using the minibuffer (see &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Minibuffers&lt;/a&gt;) or output in the echo area (see &lt;a href=&quot;the-echo-area#The-Echo-Area&quot;&gt;The Echo Area&lt;/a&gt;).</source>
          <target state="translated">Объект &lt;code&gt;nil&lt;/code&gt; , помимо других значений, может использоваться как поток. Он обозначает значение переменной &lt;code&gt;standard-input&lt;/code&gt; или &lt;code&gt;standard-output&lt;/code&gt; . Кроме того, объект &lt;code&gt;t&lt;/code&gt; как поток определяет ввод с использованием минибуфера (см. &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Минибуфер&lt;/a&gt; ) или вывод в эхо-области (см &lt;a href=&quot;the-echo-area#The-Echo-Area&quot;&gt;. Эхо-область&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="39f7982b68fb4ab2fb51b7f5f14923219a3d96cd" translate="yes" xml:space="preserve">
          <source>The object &lt;var&gt;name&lt;/var&gt; is a character (an integer) identifying the register.</source>
          <target state="translated">Объект &lt;var&gt;name&lt;/var&gt; представляет собой символ (целое число) , идентифицирующий регистр.</target>
        </trans-unit>
        <trans-unit id="6833fa0e8edf6ce4aefb60918006191561783d76" translate="yes" xml:space="preserve">
          <source>The objects returned by &lt;code&gt;current-window-configuration&lt;/code&gt; die together with the Emacs process. In order to store a window configuration on disk and read it back in another Emacs session, you can use the functions described next. These functions are also useful to clone the state of a frame into an arbitrary live window (&lt;code&gt;set-window-configuration&lt;/code&gt; effectively clones the windows of a frame into the root window of that very frame only).</source>
          <target state="translated">Объекты, возвращаемые &lt;code&gt;current-window-configuration&lt;/code&gt; , умирают вместе с процессом Emacs. Чтобы сохранить конфигурацию окна на диске и прочитать ее в другом сеансе Emacs, вы можете использовать функции, описанные ниже. Эти функции также полезны для клонирования состояния фрейма в произвольное живое окно ( &lt;code&gt;set-window-configuration&lt;/code&gt; эффективно клонирует окна фрейма только в корневое окно этого самого фрейма).</target>
        </trans-unit>
        <trans-unit id="72b9bbaab48ff0495bbabbd0f0bb821e6641bf93" translate="yes" xml:space="preserve">
          <source>The offset in pixels from the</source>
          <target state="translated">Смещение в пикселях от</target>
        </trans-unit>
        <trans-unit id="ad4a9f69cf841ef935ee2cfa1f4bc790f26c9421" translate="yes" xml:space="preserve">
          <source>The operating system groups files into directories. To specify a file, you must specify the directory and the file&amp;rsquo;s name within that directory. Therefore, Emacs considers a file name as having two main parts: the &lt;em&gt;directory name&lt;/em&gt; part, and the &lt;em&gt;nondirectory&lt;/em&gt; part (or &lt;em&gt;file name within the directory&lt;/em&gt;). Either part may be empty. Concatenating these two parts reproduces the original file name.</source>
          <target state="translated">Операционная система группирует файлы в каталоги. Чтобы указать файл, вы должны указать каталог и имя файла в этом каталоге. Следовательно, Emacs считает, что имя файла состоит из двух основных частей: части имени &lt;em&gt;каталога и&lt;/em&gt; части, не &lt;em&gt;относящейся &lt;/em&gt;&lt;em&gt;к каталогу&lt;/em&gt; (или &lt;em&gt;имени файла в каталоге&lt;/em&gt; ). Любая часть может быть пустой. Объединение этих двух частей воспроизводит исходное имя файла.</target>
        </trans-unit>
        <trans-unit id="97b655f463790a01acf5417028d665f4f17aa3ca" translate="yes" xml:space="preserve">
          <source>The operation for which certain handlers are presently inhibited.</source>
          <target state="translated">Операция,для которой некоторые обработчики в настоящее время заблокированы.</target>
        </trans-unit>
        <trans-unit id="a54beb7452d09412de65a317f1da762f7220f206" translate="yes" xml:space="preserve">
          <source>The operation of inserting text in a buffer also calls the functions listed in the &lt;code&gt;insert-in-front-hooks&lt;/code&gt; property of the following character and in the &lt;code&gt;insert-behind-hooks&lt;/code&gt; property of the preceding character. These functions receive two arguments, the beginning and end of the inserted text. The functions are called &lt;em&gt;after&lt;/em&gt; the actual insertion takes place.</source>
          <target state="translated">Операция вставки текста в буфер также вызывает функции, перечисленные в свойстве &lt;code&gt;insert-in-front-hooks&lt;/code&gt; следующего символа и в свойстве &lt;code&gt;insert-behind-hooks&lt;/code&gt; предыдущего символа. Эти функции получают два аргумента: начало и конец вставленного текста. Функции вызываются &lt;em&gt;после&lt;/em&gt; фактической вставки.</target>
        </trans-unit>
        <trans-unit id="0102d351953df3a2b1f375d80803fca9ebb0a776" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;resize-mini-windows&lt;/code&gt; does not affect the behavior of minibuffer-only frames (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;). The following option allows to automatically resize such frames as well.</source>
          <target state="translated">Параметр &lt;code&gt;resize-mini-windows&lt;/code&gt; не влияет на поведение фреймов только для минибуфера (см. &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Макет фрейма&lt;/a&gt; ). Следующая опция позволяет автоматически изменять размер таких рамок.</target>
        </trans-unit>
        <trans-unit id="ab3586d91a06c5d8405e148f25236777a77f39af" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; and the &lt;code&gt;buffer-predicate&lt;/code&gt; (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;) of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame affect this command as they do for &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; и &lt;code&gt;buffer-predicate&lt;/code&gt; (см. &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Параметры буфера&lt;/a&gt; ) кадра &lt;var&gt;window&lt;/var&gt; влияют на эту команду так же, как и на &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c6688ae5450a1940363973e63c9245b847575d" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; described below can be used to inhibit switching to certain buffers, for example, to those already shown in another window. Also, if &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame has a &lt;code&gt;buffer-predicate&lt;/code&gt; parameter (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;), that predicate may inhibit switching to certain buffers.</source>
          <target state="translated">Описанная ниже опция &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; может использоваться для запрета переключения на определенные буферы, например, на те, которые уже показаны в другом окне. Кроме того, если кадр &lt;var&gt;window&lt;/var&gt; имеет параметр &lt;code&gt;buffer-predicate&lt;/code&gt; (см. &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Параметры буфера&lt;/a&gt; ), этот предикат может препятствовать переключению на определенные буферы.</target>
        </trans-unit>
        <trans-unit id="835de90b506ab91ee5ca88e6c356759c82274cd9" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;form&lt;/var&gt; argument specifies the timestamp form to be returned. If &lt;var&gt;form&lt;/var&gt; is the symbol &lt;code&gt;integer&lt;/code&gt;, this function returns an integer count of seconds. If &lt;var&gt;form&lt;/var&gt; is a positive integer, it specifies a clock frequency and this function returns an integer-pair timestamp &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt;
. &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt;.&lt;a href=&quot;#FOOT25&quot; name=&quot;DOCF25&quot;&gt;&lt;sup&gt;25&lt;/sup&gt;&lt;/a&gt; If &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this function treats it as a positive integer suitable for representing the timestamp; for example, it is treated as 1000000000 if &lt;var&gt;time&lt;/var&gt; is nil and the platform timestamp has nanosecond resolution. If &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;list&lt;/code&gt;, this function returns an integer list &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt; &lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt;. Although an omitted or &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;form&lt;/var&gt; currently acts like &lt;code&gt;list&lt;/code&gt;, this is planned to change in a future Emacs version, so callers requiring list timestamps should pass &lt;code&gt;list&lt;/code&gt; explicitly.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;form&lt;/var&gt; указывает возвращаемую форму отметки времени. Если &lt;var&gt;form&lt;/var&gt; представляет собой &lt;code&gt;integer&lt;/code&gt; символа , эта функция возвращает целое число секунд. Если &lt;var&gt;form&lt;/var&gt; является положительным целым числом, она определяет тактовую частоту, и эта функция возвращает метку времени в &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt; . &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt; пары целых чисел ( &lt;var&gt;ticks&lt;/var&gt; . Форма ) . &lt;a href=&quot;#FOOT25&quot; name=&quot;DOCF25&quot;&gt;&lt;sup&gt;25&lt;/sup&gt;&lt;/a&gt; Если &lt;var&gt;form&lt;/var&gt; - &lt;code&gt;t&lt;/code&gt; , эта функция обрабатывает его как положительное целое число, подходящее для представления метки времени; например, он обрабатывается как 1000000000, если &lt;var&gt;time&lt;/var&gt; равно нулю, а метка времени платформы имеет наносекундное разрешение. Если &lt;var&gt;form&lt;/var&gt; - это &lt;code&gt;list&lt;/code&gt; Эта функция возвращает список целое число &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt; &lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt; . Хотя пропущенная или &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;form&lt;/var&gt; настоящее время действует как &lt;code&gt;list&lt;/code&gt; , это планируется изменить в будущей версии Emacs, поэтому вызывающие программы, которым требуются временные метки списка, должны передавать &lt;code&gt;list&lt;/code&gt; явно.</target>
        </trans-unit>
        <trans-unit id="173acab42d67698663274d178deb55ac822fd58b" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;function&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a function to call with no arguments, to get the user&amp;rsquo;s attention.</source>
          <target state="translated">Необязательная &lt;var&gt;function&lt;/var&gt; , если она не равна &lt;code&gt;nil&lt;/code&gt; , вызывается без аргументов, чтобы привлечь внимание пользователя.</target>
        </trans-unit>
        <trans-unit id="426453a518362f581ab8e263e39b1b78287360b0" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;pred&lt;/var&gt; argument provides a predicate that controls which buffers to ask about (or to save silently if &lt;var&gt;save-silently-p&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;). If &lt;var&gt;pred&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means to use the value of &lt;code&gt;save-some-buffers-default-predicate&lt;/code&gt; instead of &lt;var&gt;pred&lt;/var&gt;. If the result is &lt;code&gt;nil&lt;/code&gt;, it means ask only about file-visiting buffers. If it is &lt;code&gt;t&lt;/code&gt;, that means also offer to save certain other non-file buffers&amp;mdash;those that have a non-&lt;code&gt;nil&lt;/code&gt; buffer-local value of &lt;code&gt;buffer-offer-save&lt;/code&gt; (see &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Killing Buffers&lt;/a&gt;). A user who says &amp;lsquo;</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;pred&lt;/var&gt; предоставляет предикат, который определяет, какие буферы запрашивать (или сохранять молча, если &lt;var&gt;save-silently-p&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; ). Если &lt;var&gt;pred&lt;/var&gt; есть &lt;code&gt;nil&lt;/code&gt; , что означает использовать значение &lt;code&gt;save-some-buffers-default-predicate&lt;/code&gt; вместо &lt;var&gt;pred&lt;/var&gt; . Если результат равен &lt;code&gt;nil&lt;/code&gt; , это означает, что нужно спрашивать только о буферах обращения к файлам. Если это &lt;code&gt;t&lt;/code&gt; , это означает также предложение сохранить некоторые другие нефайловые буферы - те, которые имеют отличное от &lt;code&gt;nil&lt;/code&gt; значение &lt;code&gt;buffer-offer-save&lt;/code&gt; , отличное от nil (см. &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Удаление буферов&lt;/a&gt; ). Пользователь, который говорит &quot;</target>
        </trans-unit>
        <trans-unit id="3b490b732241cae65bd40b66849ce93f50354a12" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;qualifier&lt;/var&gt; allows combining several applicable methods. If it is not present, the defined method is a &lt;em&gt;primary&lt;/em&gt; method, responsible for providing the primary implementation of the generic function for the specialized arguments. You can also define &lt;em&gt;auxiliary methods&lt;/em&gt;, by using one of the following values as &lt;var&gt;qualifier&lt;/var&gt;:</source>
          <target state="translated">Необязательный &lt;var&gt;qualifier&lt;/var&gt; позволяет комбинировать несколько применимых методов. Если его нет, определенный метод является &lt;em&gt;основным&lt;/em&gt; методом, отвечающим за предоставление основной реализации универсальной функции для специализированных аргументов. Вы также можете определить &lt;em&gt;вспомогательные методы&lt;/em&gt; , используя одно из следующих значений в качестве &lt;var&gt;qualifier&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="7e8b24c5a3bacf003c936b526cc2b8bc5211832b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;accept-default-p&lt;/var&gt; determines whether a coding system selected without user interaction is acceptable. If it&amp;rsquo;s omitted or &lt;code&gt;nil&lt;/code&gt;, such a silent selection is always acceptable. If it is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function; &lt;code&gt;select-safe-coding-system&lt;/code&gt; calls this function with one argument, the base coding system of the selected coding system. If the function returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;select-safe-coding-system&lt;/code&gt; rejects the silently selected coding system, and asks the user to select a coding system from a list of possible candidates.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;accept-default-p&lt;/var&gt; определяет, приемлема ли система кодирования, выбранная без взаимодействия с пользователем. Если он опущен или равен &lt;code&gt;nil&lt;/code&gt; , такой тихий выбор всегда приемлем. Если это не &lt;code&gt;nil&lt;/code&gt; , это должна быть функция; &lt;code&gt;select-safe-coding-system&lt;/code&gt; вызывает эту функцию с одним аргументом, базовой системой кодирования выбранной системы кодирования. Если функция возвращает &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;select-safe-coding-system&lt;/code&gt; отклоняет молчаливо выбранную систему кодирования и просит пользователя выбрать систему кодирования из списка возможных кандидатов.</target>
        </trans-unit>
        <trans-unit id="e961ebb3cc87375ff53fb5dbd5c797ff74355be5" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;access-type&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should specify the kind of access that will trigger obsolescence warnings; it can be either &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;access-type&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , должен указывать вид доступа, который будет вызывать предупреждения об устаревании; его можно &lt;code&gt;get&lt;/code&gt; или &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18e8faa626ed3c723b0d4b24ea36af13079f989a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;action&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should normally be a display action (described above). &lt;code&gt;display-buffer&lt;/code&gt; builds a list of action functions and an action alist, by consolidating display actions from the following sources (in order of their precedence, from highest to lowest):</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;action&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , обычно должен быть действием display (описано выше). &lt;code&gt;display-buffer&lt;/code&gt; создает список функций действий и список действий, объединяя действия отображения из следующих источников (в порядке их приоритета, от самого высокого до самого низкого):</target>
        </trans-unit>
        <trans-unit id="86a332db454bd3dbba8b146d609ae20fa7e68ddc" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;add&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies how to add &lt;var&gt;font-spec&lt;/var&gt; to the font specifications previously set. If it is &lt;code&gt;prepend&lt;/code&gt;, &lt;var&gt;font-spec&lt;/var&gt; is prepended. If it is &lt;code&gt;append&lt;/code&gt;, &lt;var&gt;font-spec&lt;/var&gt; is appended. By default, &lt;var&gt;font-spec&lt;/var&gt; overrides the previous settings.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;add&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , указывает, как добавить &lt;var&gt;font-spec&lt;/var&gt; шрифта к ранее установленным спецификациям шрифта. Если &lt;code&gt;prepend&lt;/code&gt; , &lt;var&gt;font-spec&lt;/var&gt; предваряется. Если он &lt;code&gt;append&lt;/code&gt; , добавляется &lt;var&gt;font-spec&lt;/var&gt; . По умолчанию &lt;var&gt;font-spec&lt;/var&gt; отменяет предыдущие настройки.</target>
        </trans-unit>
        <trans-unit id="f8a3ae8e924fd8f4d27674f1685f4ee6a3fbe53e" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;all-frames&lt;/var&gt; has the same meaning as in &lt;code&gt;next-window&lt;/code&gt;, like a &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;minibuf&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt;.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;all-frames&lt;/var&gt; имеет то же значение, что и в &lt;code&gt;next-window&lt;/code&gt; , как аргумент &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;minibuf&lt;/var&gt; для &lt;code&gt;next-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="202962f0de53dff02d10a00270753bbfa1f06e86" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;all-frames&lt;/var&gt; specifies which frames to consider:</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;all-frames&lt;/var&gt; указывает, какие кадры следует учитывать:</target>
        </trans-unit>
        <trans-unit id="bb40d66cb55d279a86899a88dfb077d4f8e79fbc" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;base-url&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be a string specifying the base URL for relative URLs occurring in links.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;base-url&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , должен быть строкой, определяющей базовый URL-адрес для относительных URL-адресов, встречающихся в ссылках.</target>
        </trans-unit>
        <trans-unit id="6a1907330d9a397ccfad9b3e354542f50e48a6fb" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;bury-or-kill&lt;/var&gt; specifies how to deal with &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s buffer. The following values are handled:</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;bury-or-kill&lt;/var&gt; указывает, как работать с буфером &lt;var&gt;window&lt;/var&gt; . Обрабатываются следующие значения:</target>
        </trans-unit>
        <trans-unit id="2049134810f7e761207b9b8b3bd49725d3167d1d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;confirm&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, says to read the password twice and insist it must be the same both times. If it isn&amp;rsquo;t the same, the user has to type it over and over until the last two times match.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;confirm&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , говорит о том, что пароль нужно читать дважды, и настаивает на том, что он должен быть одинаковым оба раза. Если это не то же самое, пользователь должен вводить его снова и снова, пока не совпадут два последних раза.</target>
        </trans-unit>
        <trans-unit id="7bc5835047d79ebfcafd196072cb522b7ad940af" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;contextual&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, forces Font Lock mode to always refontify a syntactically relevant part of the buffer, and not just the modified lines. This argument can usually be omitted.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;contextual&lt;/var&gt; , если не равен &lt;code&gt;nil&lt;/code&gt; , заставляет режим Font Lock всегда обновлять синтаксически значимую часть буфера, а не только измененные строки. Этот аргумент обычно можно опустить.</target>
        </trans-unit>
        <trans-unit id="580eb5a9bd0d61ea92cc5b8878cb5564112b1db4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;count&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a maximum number of rectangles to return. This means that the return value is a list of triples specifying rectangles with the largest rectangle first. &lt;var&gt;count&lt;/var&gt; can be also a cons cell whose car specifies the number of rectangles to return and whose &lt;small&gt;CDR&lt;/small&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, states that all rectangles returned must be disjoint.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;count&lt;/var&gt; , если не &lt;code&gt;nil&lt;/code&gt; , указывает максимальное количество возвращаемых прямоугольников. Это означает, что возвращаемое значение представляет собой список троек, определяющих прямоугольники с наибольшим прямоугольником первым. &lt;var&gt;count&lt;/var&gt; также может быть cons-ячейкой, car которой определяет количество возвращаемых прямоугольников и чей &lt;small&gt;CDR&lt;/small&gt; , если не &lt;code&gt;nil&lt;/code&gt; , утверждает, что все возвращенные прямоугольники должны быть не пересекающимися.</target>
        </trans-unit>
        <trans-unit id="3ebdbb0e5fb0f2b384549756b4989936faa9a770" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;cur-col&lt;/var&gt; specifies the current column when the function is called. This is the window-relative horizontal coordinate of point, measured in units of font width of the frame&amp;rsquo;s default face. Providing it speeds up the function, especially in very long lines, because the function doesn&amp;rsquo;t have to go back in the buffer in order to determine the current column. Note that &lt;var&gt;cur-col&lt;/var&gt; is also counted from the visual start of the line.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;cur-col&lt;/var&gt; указывает текущий столбец при вызове функции. Это координата точки по горизонтали относительно окна, измеряемая в единицах ширины шрифта лицевой стороны фрейма по умолчанию. Это ускоряет выполнение функции, особенно в очень длинных строках, потому что функции не нужно возвращаться в буфер, чтобы определить текущий столбец. Обратите внимание, что &lt;var&gt;cur-col&lt;/var&gt; также отсчитывается от визуального начала строки.</target>
        </trans-unit>
        <trans-unit id="b5a3875cde45d622d71332d1342451631df66196" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;default&lt;/var&gt; is used as in &lt;code&gt;read-from-minibuffer&lt;/code&gt;, except that, if non-&lt;code&gt;nil&lt;/code&gt;, it also specifies a default value to return if the user enters null input. As in &lt;code&gt;read-from-minibuffer&lt;/code&gt; it should be a string, a list of strings, or &lt;code&gt;nil&lt;/code&gt;, which is equivalent to an empty string. When &lt;var&gt;default&lt;/var&gt; is a string, that string is the default value. When it is a list of strings, the first string is the default value. (All these strings are available to the user in the &amp;ldquo;future minibuffer history&amp;rdquo;.)</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;default&lt;/var&gt; используется так же, как и в случае &lt;code&gt;read-from-minibuffer&lt;/code&gt; , за исключением того, что, если не &lt;code&gt;nil&lt;/code&gt; , он также указывает значение по умолчанию, возвращаемое, если пользователь вводит нулевой ввод. Как и в случае &lt;code&gt;read-from-minibuffer&lt;/code&gt; это должна быть строка, список строк или &lt;code&gt;nil&lt;/code&gt; , что эквивалентно пустой строке. Когда по &lt;var&gt;default&lt;/var&gt; является строкой, эта строка является значением по умолчанию. Когда это список строк, первая строка является значением по умолчанию. (Все эти строки доступны пользователю в &amp;laquo;будущей истории минибуфера&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="a8b8f42a687e321f80ab76cd3bccd5897a600a30" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;default&lt;/var&gt; specifies the default password to return if the user enters empty input. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;read-passwd&lt;/code&gt; returns the null string in that case.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;default&lt;/var&gt; указывает пароль по умолчанию, возвращаемый, если пользователь вводит пустой ввод. Если по &lt;var&gt;default&lt;/var&gt; является &lt;code&gt;nil&lt;/code&gt; , то для &lt;code&gt;read-passwd&lt;/code&gt; возвращается пустая строка в этом случае.</target>
        </trans-unit>
        <trans-unit id="0048e481ce17eb199983c7400eaac1a428a4cdd4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;defaults&lt;/var&gt; controls the default value to return if the user enters null input, and should be one of: a string; &lt;code&gt;nil&lt;/code&gt;, which is equivalent to an empty string; a list of strings; or a symbol.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;defaults&lt;/var&gt; управляет значением по умолчанию, возвращаемым, если пользователь вводит нулевой ввод, и должно быть одним из следующих: строка; &lt;code&gt;nil&lt;/code&gt; , что эквивалентно пустой строке; список строк; или символ.</target>
        </trans-unit>
        <trans-unit id="228f1c49688198d5cc5f85c1fed83e79ddfe5a7f" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;display&lt;/var&gt; in these functions specifies which display to ask the question about. It can be a display name, a frame (which designates the display that frame is on), or &lt;code&gt;nil&lt;/code&gt; (which refers to the selected frame&amp;rsquo;s display, see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;display&lt;/var&gt; в этих функциях указывает, о каком дисплее следует задать вопрос. Это может быть отображаемое имя, рамка (которая обозначает дисплей, на котором находится этот кадр) или &lt;code&gt;nil&lt;/code&gt; (что относится к отображению выбранного кадра, см. &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Фокус ввода&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ecafec37f62287ed8dd3cb905ab5b45b69aeeb0b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;frame&lt;/var&gt; specifies which frames to operate on:</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;frame&lt;/var&gt; указывает, с какими кадрами работать:</target>
        </trans-unit>
        <trans-unit id="26bbce4e0ce6d9c586e1c1839883be544a4991a7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;frame&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the frame on which the fonts are to be displayed. The optional argument &lt;var&gt;num&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be an integer that specifies the maximum length of the returned list. The optional argument &lt;var&gt;prefer&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be another font spec, which is used to control the order of the returned list; the returned font entities are sorted in order of decreasing closeness to that font spec.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;frame&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , указывает фрейм, в котором должны отображаться шрифты. Необязательный аргумент &lt;var&gt;num&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , должен быть целым числом, указывающим максимальную длину возвращаемого списка. Необязательный аргумент &lt;var&gt;prefer&lt;/var&gt; , если не &lt;code&gt;nil&lt;/code&gt; , должен быть другой спецификацией шрифта, которая используется для управления порядком возвращаемого списка; возвращенные объекты шрифта сортируются в порядке уменьшения близости к спецификации шрифта.</target>
        </trans-unit>
        <trans-unit id="160ff97d48ba4a8dfa3b003d791595b0262367a7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;frame&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies which frames to check when deciding whether the buffer is already displayed. It is equivalent to adding an element &lt;code&gt;(reusable-frames&amp;nbsp;.&amp;nbsp;&lt;var&gt;frame&lt;/var&gt;)&lt;/code&gt; to the action alist of &lt;var&gt;action&lt;/var&gt; (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;). The &lt;var&gt;frame&lt;/var&gt; argument is provided for compatibility reasons, Lisp programs should not use it.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;frame&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , указывает, какие кадры нужно проверить при принятии решения, отображается ли буфер уже. Это эквивалентно добавлению элемента &lt;code&gt;(reusable-frames&amp;nbsp;.&amp;nbsp;&lt;var&gt;frame&lt;/var&gt;)&lt;/code&gt; в список &lt;var&gt;action&lt;/var&gt; (см. &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Списки действий отображения буфера&lt;/a&gt; ). &lt;var&gt;frame&lt;/var&gt; аргумент предоставляются по причинам совместимости программы Лиспа не должны использовать его.</target>
        </trans-unit>
        <trans-unit id="50b9dbdcad227dd99d40dacb6820fdfcb31ad949" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;from&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the first text position to consider, and defaults to the minimum accessible position of the buffer. If &lt;var&gt;from&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, it stands for the minimum accessible position that is not a newline character. The optional argument &lt;var&gt;to&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the last text position to consider, and defaults to the maximum accessible position of the buffer. If &lt;var&gt;to&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, it stands for the maximum accessible position that is not a newline character.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;from&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , указывает первую позицию текста для рассмотрения, и по умолчанию используется минимальная доступная позиция буфера. Если &lt;var&gt;from&lt;/var&gt; равно &lt;code&gt;t&lt;/code&gt; , это означает минимальную доступную позицию, которая не является символом новой строки. Необязательный аргумент &lt;var&gt;to&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , указывает последнюю позицию текста для рассмотрения и по умолчанию используется максимально доступная позиция буфера. Если &lt;var&gt;to&lt;/var&gt; равно &lt;code&gt;t&lt;/code&gt; , это означает максимально доступную позицию, которая не является символом новой строки.</target>
        </trans-unit>
        <trans-unit id="48d8b7e116733be79108fa56696b0ae152c9cd92" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;history&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a symbol specifying a minibuffer history list to use (see &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;). If it is omitted or &lt;code&gt;nil&lt;/code&gt;, the history list defaults to &lt;code&gt;regexp-history&lt;/code&gt;.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;history&lt;/var&gt; , если не равен &lt;code&gt;nil&lt;/code&gt; , является символом, определяющим список истории минибуфера, который следует использовать (см. &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;История минибуфера&lt;/a&gt; ). Если он опущен или равен &lt;code&gt;nil&lt;/code&gt; , список истории по умолчанию имеет значение &lt;code&gt;regexp-history&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54b2555eb4d6971581a755b86e550d7f706a4369" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;ignore&lt;/var&gt; has the same meaning as for the function &lt;code&gt;window-resizable&lt;/code&gt; above.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;ignore&lt;/var&gt; имеет то же значение, что и для функции &lt;code&gt;window-resizable&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="6bdfa63738d1ccee9b5808f3f8c9f1ebe07b8e9b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;ignore&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means ignore restrictions imposed by fixed size windows, &lt;code&gt;window-min-height&lt;/code&gt; or &lt;code&gt;window-min-width&lt;/code&gt; settings. If &lt;var&gt;ignore&lt;/var&gt; equals &lt;code&gt;safe&lt;/code&gt;, live windows may get as small as &lt;code&gt;window-safe-min-height&lt;/code&gt; lines and &lt;code&gt;window-safe-min-width&lt;/code&gt; columns. If &lt;var&gt;ignore&lt;/var&gt; is a window, ignore restrictions for that window only. Any other non-&lt;code&gt;nil&lt;/code&gt; value means ignore all of the above restrictions for all windows.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;ignore&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , означает игнорирование ограничений, налагаемых окнами фиксированного размера, параметрами &lt;code&gt;window-min-height&lt;/code&gt; или &lt;code&gt;window-min-width&lt;/code&gt; . Если &lt;var&gt;ignore&lt;/var&gt; равно &lt;code&gt;safe&lt;/code&gt; , живые окна могут стать такими же маленькими, как строки &lt;code&gt;window-safe-min-height&lt;/code&gt; и столбцы &lt;code&gt;window-safe-min-width&lt;/code&gt; . Если &lt;var&gt;ignore&lt;/var&gt; окно, игнорировать ограничения только для этого окна. Любое другое значение, отличное от &lt;code&gt;nil&lt;/code&gt; , означает игнорирование всех вышеуказанных ограничений для всех окон.</target>
        </trans-unit>
        <trans-unit id="f03394985cfefcfbe4bccbc2c2b7c937f24aa8ff" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;inverse&lt;/var&gt;, if &lt;code&gt;nil&lt;/code&gt;, means that the y-pixel value returned for any line specifies the distance in pixels from the left edge (body edge if &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;) of &lt;var&gt;window&lt;/var&gt; to the right edge of the last glyph of that line. &lt;var&gt;inverse&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means that the y-pixel value returned for any line specifies the distance in pixels from the right edge of the last glyph of that line to the right edge (body edge if &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;) of &lt;var&gt;window&lt;/var&gt;. This is useful for determining the amount of slack space at the end of each line.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;inverse&lt;/var&gt; , если &lt;code&gt;nil&lt;/code&gt; , означает, что значение y-пикселя, возвращаемое для любой строки, указывает расстояние в пикселях от левого края (край &lt;var&gt;body&lt;/var&gt; если body не равно &lt;code&gt;nil&lt;/code&gt; ) &lt;var&gt;window&lt;/var&gt; до правого края последнего глифа этого линия. &lt;var&gt;inverse&lt;/var&gt; отличная от &lt;code&gt;nil&lt;/code&gt; означает, что значение y-пикселя, возвращаемое для любой строки, указывает расстояние в пикселях от правого края последнего глифа этой строки до правого края (края &lt;var&gt;body&lt;/var&gt; если body не равно &lt;code&gt;nil&lt;/code&gt; ) &lt;var&gt;window&lt;/var&gt; . Это полезно для определения количества свободного места в конце каждой строки.</target>
        </trans-unit>
        <trans-unit id="36d765e78065810838fe4b4dcd7aee5e46b9c2f7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;keymap&lt;/var&gt; specifies the keymap for the minor mode. If non-&lt;code&gt;nil&lt;/code&gt;, it should be a variable name (whose value is a keymap), a keymap, or an alist of the form</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;keymap&lt;/var&gt; указывает раскладку для второстепенного режима. Если не &lt;code&gt;nil&lt;/code&gt; , это должно быть имя переменной (значением которой является таблица ключей), таблица клавиш или список формы</target>
        </trans-unit>
        <trans-unit id="45c7531620e27255788236157222d029e67710a7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;left&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt; means to return the x- and y-coordinates of the lower left corner of the leftmost character on each line. This is the value that should be used for windows that mostly display text from right to left.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;left&lt;/var&gt; , if non- &lt;code&gt;nil&lt;/code&gt; , означает возвращение x- и y-координат нижнего левого угла самого левого символа в каждой строке. Это значение, которое следует использовать для окон, которые в основном отображают текст справа налево.</target>
        </trans-unit>
        <trans-unit id="fac44c195c8956dce4604ab79b6495b05c7787fa" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;left&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to return values suitable for buffers displaying right to left text. In that case, any rectangle returned is assumed to start at the left edge of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s text area.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;left&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , означает возвращение значений, подходящих для буферов, отображающих текст справа налево. В этом случае предполагается, что любой возвращенный прямоугольник начинается с левого края текстовой области &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="6b9c6954a4a938b6fd1e1b213483a278916b13fe" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;locale&lt;/var&gt;, a string, overrides the setting of your current locale identifier for collation. The value is system dependent; a &lt;var&gt;locale&lt;/var&gt;&lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; is applicable on POSIX systems, while it would be, e.g., &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; on MS-Windows systems.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;locale&lt;/var&gt; , строка, переопределяет настройку вашего текущего идентификатора локали для сопоставления. Значение зависит от системы; &lt;var&gt;locale&lt;/var&gt; &lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; применяется в системах POSIX, в то время как было бы, например, &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; в системах MS-Windows.</target>
        </trans-unit>
        <trans-unit id="be924dbedb077a7596937c809656d8809cb7f780" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;locale&lt;/var&gt;, a string, overrides the setting of your current locale identifier for collation. The value is system dependent; a &lt;var&gt;locale&lt;/var&gt;&lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; is applicable on POSIX systems, while it would be, e.g., &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; on MS-Windows systems. The &lt;var&gt;locale&lt;/var&gt; value of &lt;code&gt;&quot;POSIX&quot;&lt;/code&gt; or &lt;code&gt;&quot;C&quot;&lt;/code&gt; lets &lt;code&gt;string-collate-lessp&lt;/code&gt; behave like &lt;code&gt;string-lessp&lt;/code&gt;:</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;locale&lt;/var&gt; , строка, переопределяет настройку вашего текущего идентификатора локали для сопоставления. Значение зависит от системы; &lt;var&gt;locale&lt;/var&gt; &lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; применяется в системах POSIX, в то время как было бы, например, &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; в системах MS-Windows. &lt;var&gt;locale&lt;/var&gt; значение &lt;code&gt;&quot;POSIX&quot;&lt;/code&gt; или &lt;code&gt;&quot;C&quot;&lt;/code&gt; позволяет &lt;code&gt;string-collate-lessp&lt;/code&gt; ведут себя как &lt;code&gt;string-lessp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4edaf13bc53c89e562d674d18afa431f2d97a551" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;lockname&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the file name to use for purposes of locking and unlocking, overriding &lt;var&gt;filename&lt;/var&gt; and &lt;var&gt;visit&lt;/var&gt; for that purpose.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;lockname&lt;/var&gt; , если не равен &lt;code&gt;nil&lt;/code&gt; , указывает имя файла, которое будет использоваться для целей блокировки и разблокировки, переопределения &lt;var&gt;filename&lt;/var&gt; и &lt;var&gt;visit&lt;/var&gt; для этой цели.</target>
        </trans-unit>
        <trans-unit id="505418b83113b1a1864d4371b2abfa1905c1136b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;maximum&lt;/var&gt; sets a limit on how many fonts to return. If it is non-&lt;code&gt;nil&lt;/code&gt;, then the return value is truncated after the first &lt;var&gt;maximum&lt;/var&gt; matching fonts. Specifying a small value for &lt;var&gt;maximum&lt;/var&gt; can make this function much faster, in cases where many fonts match the pattern.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;maximum&lt;/var&gt; устанавливает ограничение на количество возвращаемых шрифтов. Если он не равен &lt;code&gt;nil&lt;/code&gt; , то возвращаемое значение обрезается после первых &lt;var&gt;maximum&lt;/var&gt; совпадающих шрифтов. Указание небольшого значения для &lt;var&gt;maximum&lt;/var&gt; может значительно ускорить эту функцию в случаях, когда многие шрифты соответствуют шаблону.</target>
        </trans-unit>
        <trans-unit id="e2fef78645ec648e97c68254439e56ca0814e67d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;millisec&lt;/var&gt; specifies an additional waiting period measured in milliseconds. This adds to the period specified by &lt;var&gt;seconds&lt;/var&gt;. If the system doesn&amp;rsquo;t support waiting fractions of a second, you get an error if you specify nonzero &lt;var&gt;millisec&lt;/var&gt;.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;millisec&lt;/var&gt; указывает дополнительный период ожидания, измеряемый в миллисекундах. Это увеличивает период, указанный в &lt;var&gt;seconds&lt;/var&gt; . Если система не поддерживает ожидание долей секунды, вы получите сообщение об ошибке, если укажете ненулевое значение &lt;var&gt;millisec&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a79dc72b2d8c8af7d2c6097667a6efcd584162f8" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;minibuf&lt;/var&gt; specifies whether minibuffer windows should be included in the cyclic ordering. Normally, when &lt;var&gt;minibuf&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, a minibuffer window is included only if it is currently active; this matches the behavior of</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;minibuf&lt;/var&gt; указывает, должны ли окна минибуфера быть включены в циклический порядок. Обычно, когда &lt;var&gt;minibuf&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , окно минибуфера включается, только если оно в настоящее время активно; это соответствует поведению</target>
        </trans-unit>
        <trans-unit id="41718d9699e86f654dd2ea26e540ead2023238f1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;minibuffer&lt;/var&gt; specifies whether to include the minibuffer window in the returned list. If &lt;var&gt;minibuffer&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, the minibuffer window is included. If &lt;var&gt;minibuffer&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, the minibuffer window is included only if it is active. If &lt;var&gt;minibuffer&lt;/var&gt; is neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;t&lt;/code&gt;, the minibuffer window is never included.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;minibuffer&lt;/var&gt; указывает, следует ли включать окно минибуфера в возвращаемый список. Если &lt;var&gt;minibuffer&lt;/var&gt; является &lt;code&gt;t&lt;/code&gt; , окно Минибуфера включено. Если &lt;var&gt;minibuffer&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; или опущен, окно минибуфера включается, только если оно активно. Если &lt;var&gt;minibuffer&lt;/var&gt; равен ни &lt;code&gt;nil&lt;/code&gt; , ни &lt;code&gt;t&lt;/code&gt; , окно минибуфера никогда не включается.</target>
        </trans-unit>
        <trans-unit id="295f0ea496d93011b8fee19529ccf2a7cf02e05c" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;mode-and-header-line&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt; or omitted means to not include the height of the mode- or header-line of &lt;var&gt;window&lt;/var&gt; in the return value. If it is either the symbol &lt;code&gt;mode-line&lt;/code&gt; or &lt;code&gt;header-line&lt;/code&gt;, include only the height of that line, if present, in the return value. If it is &lt;code&gt;t&lt;/code&gt;, include the height of both, if present, in the return value.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;mode-and-header-line&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; или пропущенный означает, что не включать высоту строки режима или заголовка &lt;var&gt;window&lt;/var&gt; в возвращаемое значение. Если это либо символ &lt;code&gt;mode-line&lt;/code&gt; или &lt;code&gt;header-line&lt;/code&gt; , включает в себя только высоту этой линии, если присутствует, в возвращаемом значении. Если это &lt;code&gt;t&lt;/code&gt; , включите в возвращаемое значение высоту обоих, если они есть.</target>
        </trans-unit>
        <trans-unit id="e8ec5bd3618893a66ce0e97a3f3a6fa2e9be9058" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;no-activate&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, causes Emacs to update its record of installed packages without actually making them available.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;no-activate&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , заставляет Emacs обновлять свои записи об установленных пакетах, фактически не делая их доступными.</target>
        </trans-unit>
        <trans-unit id="20709a8a77efe587a728d12e613e78b8c48774b1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;noerror&lt;/var&gt; is obsolete, kept for backward compatibility, and has no effect.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;noerror&lt;/var&gt; устарел, сохранен для обратной совместимости и не действует.</target>
        </trans-unit>
        <trans-unit id="2b89e1f5be44e2151710c7bdac8ce82b4cbfb2b4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;object&lt;/var&gt; specifies which text to search, and defaults to the current buffer. If &lt;var&gt;object&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it can be some other buffer, or it can be a string or a window. If it is a string, the function searches that string. If it is a window, the function searches the buffer displayed in that window. If a buffer whose text you want to examine is displayed in some window, we recommend to specify it by that window, rather than pass the buffer to the function. This is because telling the function about the window allows it to correctly account for window-specific overlays, which might change the result of the function if some text in the buffer is covered by overlays.</source>
          <target state="translated">Необязательный &lt;var&gt;object&lt;/var&gt; аргумента указывает, какой текст искать, и по умолчанию используется текущий буфер. Если &lt;var&gt;object&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , это может быть какой-то другой буфер, строка или окно. Если это строка, функция ищет эту строку. Если это окно, функция ищет буфер, отображаемый в этом окне. Если буфер, текст которого вы хотите изучить, отображается в каком-то окне, мы рекомендуем указать его в этом окне, а не передавать буфер функции. Это связано с тем, что сообщение функции об окне позволяет ей правильно учитывать наложения, зависящие от окна, которые могут изменить результат функции, если некоторый текст в буфере покрыт наложениями.</target>
        </trans-unit>
        <trans-unit id="1a510836acc518a4ce80759b09b05d4c9fb80e93" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;object&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a buffer or string to act on, rather than the current buffer. If &lt;var&gt;object&lt;/var&gt; is a string, then &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are zero-based indices into the string.</source>
          <target state="translated">Необязательный &lt;var&gt;object&lt;/var&gt; аргумента , если он не &lt;code&gt;nil&lt;/code&gt; , указывает буфер или строку, с которой нужно действовать, а не текущий буфер. Если &lt;var&gt;object&lt;/var&gt; является строкой, то &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; являются индексами строки с отсчетом от нуля.</target>
        </trans-unit>
        <trans-unit id="6f772ffbd43b315bbe2a2d9ef65a881dd0172794" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;on-exit&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a function that is called, with no arguments, after &lt;var&gt;keymap&lt;/var&gt; is deactivated.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;on-exit&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , указывает функцию, которая вызывается без аргументов после деактивации &lt;var&gt;keymap&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="59f86c6b81e54496f12f978a2ada198f4a69de49" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;only-present&lt;/var&gt; indicates how to handle specification characters in &lt;var&gt;template&lt;/var&gt; that are not found in &lt;var&gt;spec-alist&lt;/var&gt;. If it is &lt;code&gt;nil&lt;/code&gt; or omitted, the function signals an error. Otherwise, those format specifications and any occurrences of &amp;lsquo;</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;only-present&lt;/var&gt; указывает, как обрабатывать символы спецификации в &lt;var&gt;template&lt;/var&gt; , которых нет в &lt;var&gt;spec-alist&lt;/var&gt; . Если он равен &lt;code&gt;nil&lt;/code&gt; или опущен, функция сигнализирует об ошибке. В противном случае эти спецификации формата и любые вхождения '</target>
        </trans-unit>
        <trans-unit id="99357a38b2f2682df0548c2c500e9c64e4f6180b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;padding&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a padding character added at the beginning and end of the result string, to extend it to exactly &lt;var&gt;width&lt;/var&gt; columns. The padding character is used at the end of the result if it falls short of &lt;var&gt;width&lt;/var&gt;. It is also used at the beginning of the result if one multi-column character in &lt;var&gt;string&lt;/var&gt; extends across the column &lt;var&gt;start-column&lt;/var&gt;.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;padding&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , представляет собой символ заполнения, добавляемый в начало и конец строки результата, чтобы расширить ее до столбцов точно по &lt;var&gt;width&lt;/var&gt; . Символ заполнения используется в конце результата, если он не соответствует &lt;var&gt;width&lt;/var&gt; . Он также используется в начале результата, если один многостолбцовый символ в &lt;var&gt;string&lt;/var&gt; проходит через &lt;var&gt;start-column&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="791557e50f0f19bd2818ee21038e7006cdf9270d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;paren&lt;/var&gt; can be any of the following:</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;paren&lt;/var&gt; может быть любым из следующих:</target>
        </trans-unit>
        <trans-unit id="9125d9631a53fcb42a447bf4efdec3689610b1c4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to measure the new width and height in units of pixels instead. Note that if &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, some toolkits may refuse to truly honor the request if it does not increase/decrease the frame size to a multiple of its character size.</source>
          <target state="translated">Необязательного аргумент &lt;var&gt;pixelwise&lt;/var&gt; не- &lt;code&gt;nil&lt;/code&gt; средство для измерения новой ширины и высоты в единицах пикселей вместо этого. Обратите внимание, что если &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; равно &lt;code&gt;nil&lt;/code&gt; , некоторые наборы инструментов могут отказываться действительно выполнять запрос, если он не увеличивает / не уменьшает размер кадра до кратного размера его символа.</target>
        </trans-unit>
        <trans-unit id="1a486c9457c82acbf1a6a199202ab0f46c9a5f6d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to return the minimum size of &lt;var&gt;window&lt;/var&gt; counted in pixels.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;pixelwise&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; означает возвращение минимального размера &lt;var&gt;window&lt;/var&gt; в пикселях.</target>
        </trans-unit>
        <trans-unit id="58f7f9c9311afbc394002bdf8390e5e8a66c15d9" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;positions&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a cons cell whose &lt;small&gt;CAR&lt;/small&gt; specifies the uppermost and whose &lt;small&gt;CDR&lt;/small&gt; specifies the lowermost pixel position that must be covered by any rectangle returned. These positions measure from the start of the text area of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;positions&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , представляет собой cons-ячейку, &lt;small&gt;CAR&lt;/small&gt; которой определяет самый верхний, а &lt;small&gt;CDR&lt;/small&gt; которого определяет положение самого нижнего пикселя, который должен быть покрыт любым возвращаемым прямоугольником. Эти позиции измеряются от начала текстовой области &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d4d8d2c166f79b72f18b93ddb099c08e8746fd52" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;predicate&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a function to filter the buffers that should be considered: the function will be called with every potential candidate as its argument, and should return &lt;code&gt;nil&lt;/code&gt; to reject the candidate, non-&lt;code&gt;nil&lt;/code&gt; to accept it.</source>
          <target state="translated">Необязательный &lt;var&gt;predicate&lt;/var&gt; аргумента , если он не &lt;code&gt;nil&lt;/code&gt; , определяет функцию для фильтрации буферов, которые следует учитывать: функция будет вызываться с каждым потенциальным кандидатом в качестве аргумента и должна возвращать &lt;code&gt;nil&lt;/code&gt; , чтобы отклонить кандидата, non- &lt;code&gt;nil&lt;/code&gt; , чтобы принять его. .</target>
        </trans-unit>
        <trans-unit id="bf6c3432c82d35a85740cbc2f62db8414db80230" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;predicate&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a predicate function for testing whether a candidate file is suitable. The predicate is passed the candidate file name as its single argument. If &lt;var&gt;predicate&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, &lt;code&gt;locate-file&lt;/code&gt; uses &lt;code&gt;file-readable-p&lt;/code&gt; as the predicate. See &lt;a href=&quot;kinds-of-files#Kinds-of-Files&quot;&gt;Kinds of Files&lt;/a&gt;, for other useful predicates, e.g., &lt;code&gt;file-executable-p&lt;/code&gt; and &lt;code&gt;file-directory-p&lt;/code&gt;.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;predicate&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , указывает функцию предиката для проверки, подходит ли файл-кандидат. Предикату передается имя файла-кандидата в качестве единственного аргумента. Если &lt;var&gt;predicate&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; или опущен, &lt;code&gt;locate-file&lt;/code&gt; использует &lt;code&gt;file-readable-p&lt;/code&gt; в качестве предиката. См. &lt;a href=&quot;kinds-of-files#Kinds-of-Files&quot;&gt;Виды файлов&lt;/a&gt; , чтобы узнать о других полезных предикатах, например, &lt;code&gt;file-executable-p&lt;/code&gt; и &lt;code&gt;file-directory-p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e2cb767e72f360984a732e376c1c4554ced51fa" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;preserve-size&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, will install a parameter to preserve the size of &lt;var&gt;window&lt;/var&gt; during future resize operations (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;preserve-size&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , устанавливает параметр для сохранения размера &lt;var&gt;window&lt;/var&gt; во время будущих операций изменения размера (см. &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Сохранение размеров окна&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="435a1b07679e489657de30782052b8d6eab4ec8b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;require-match&lt;/var&gt; has the same meaning as in &lt;code&gt;completing-read&lt;/code&gt;. See &lt;a href=&quot;minibuffer-completion#Minibuffer-Completion&quot;&gt;Minibuffer Completion&lt;/a&gt;.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;require-match&lt;/var&gt; имеет то же значение, что и в случае &lt;code&gt;completing-read&lt;/code&gt; . См. &lt;a href=&quot;minibuffer-completion#Minibuffer-Completion&quot;&gt;Завершение минибуфера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e40feac3d056e5b6f3adcd167b868b54bdefa42a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;rgb&lt;/var&gt;, if specified, is an rgb value, a list of three numbers that specify what the color actually looks like. If you do not specify &lt;var&gt;rgb&lt;/var&gt;, then this color cannot be used by &lt;code&gt;tty-color-approximate&lt;/code&gt; to approximate other colors, because Emacs will not know what it looks like.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;rgb&lt;/var&gt; , если он указан, представляет собой значение rgb, список из трех чисел, которые определяют, как на самом деле выглядит цвет. Если вы не укажете &lt;var&gt;rgb&lt;/var&gt; , тогда этот цвет не может использоваться &lt;code&gt;tty-color-approximate&lt;/code&gt; для аппроксимации других цветов, потому что Emacs не будет знать, как он выглядит.</target>
        </trans-unit>
        <trans-unit id="905cbc5fb211abaa07ac0619c5392cdf3e417dd1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;spec-type&lt;/var&gt; determines which spec to set. If it is omitted or &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;face-override-spec&lt;/code&gt;, this function sets the &lt;em&gt;override spec&lt;/em&gt;, which overrides face specs on &lt;var&gt;face&lt;/var&gt; of all the other types mentioned below. This is useful when calling this function outside of Custom code. If &lt;var&gt;spec-type&lt;/var&gt; is &lt;code&gt;customized-face&lt;/code&gt; or &lt;code&gt;saved-face&lt;/code&gt;, this function sets the customized spec or the saved custom spec, respectively. If it is &lt;code&gt;face-defface-spec&lt;/code&gt;, this function sets the default face spec (the same one set by &lt;code&gt;defface&lt;/code&gt;). If it is &lt;code&gt;reset&lt;/code&gt;, this function clears out all customization specs and override specs from &lt;var&gt;face&lt;/var&gt; (in this case, the value of &lt;var&gt;spec&lt;/var&gt; is ignored). The effect of any other value of &lt;var&gt;spec-type&lt;/var&gt; on the face specs is reserved for internal use, but the function will still define &lt;var&gt;face&lt;/var&gt; itself and recalculate its attributes, as described above.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;spec-type&lt;/var&gt; определяет, какую спецификацию установить. Если он опущен, &lt;code&gt;nil&lt;/code&gt; или &lt;code&gt;face-override-spec&lt;/code&gt; , эта функция устанавливает &lt;em&gt;спецификацию переопределения&lt;/em&gt; , которая переопределяет характеристики &lt;var&gt;face&lt;/var&gt; для всех других типов, упомянутых ниже. Это полезно при вызове этой функции вне пользовательского кода. Если &lt;var&gt;spec-type&lt;/var&gt; является &lt;code&gt;customized-face&lt;/code&gt; или &lt;code&gt;saved-face&lt;/code&gt; , эта функция устанавливает индивидуальную спецификацию или сохраненную пользовательскую спецификацию соответственно. Если это &lt;code&gt;face-defface-spec&lt;/code&gt; , эта функция устанавливает спецификацию лица по умолчанию (такую ​​же, как установленную &lt;code&gt;defface&lt;/code&gt; ). Если он &lt;code&gt;reset&lt;/code&gt; , эта функция удаляет все спецификации настройки и переопределяет спецификации с &lt;var&gt;face&lt;/var&gt; (в этом случае значение &lt;var&gt;spec&lt;/var&gt; игнорируется). Влияние любого другого значения &lt;var&gt;spec-type&lt;/var&gt; на характеристики лица зарезервировано для внутреннего использования, но функция по-прежнему будет определять само &lt;var&gt;face&lt;/var&gt; и пересчитывать его атрибуты, как описано выше.</target>
        </trans-unit>
        <trans-unit id="d6f8de3101851c3382246237fec9a41fcf1e43cd" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;start-column&lt;/var&gt; specifies the starting column. If this is non-&lt;code&gt;nil&lt;/code&gt;, then the first &lt;var&gt;start-column&lt;/var&gt; columns of the string are omitted from the value. If one multi-column character in &lt;var&gt;string&lt;/var&gt; extends across the column &lt;var&gt;start-column&lt;/var&gt;, that character is not included.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;start-column&lt;/var&gt; указывает начальный столбец. Если это не &lt;code&gt;nil&lt;/code&gt; , то первые столбцы &lt;var&gt;start-column&lt;/var&gt; строки исключаются из значения. Если один многостолбцовый символ в &lt;var&gt;string&lt;/var&gt; проходит через &lt;var&gt;start-column&lt;/var&gt; , этот символ не включается.</target>
        </trans-unit>
        <trans-unit id="170877c661c774db6181373f0a88ba3c4809375d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;string&lt;/var&gt; means to get a byte value from that string instead of the current buffer.</source>
          <target state="translated">Необязательная &lt;var&gt;string&lt;/var&gt; аргумента означает получение байтового значения из этой строки вместо текущего буфера.</target>
        </trans-unit>
        <trans-unit id="08690ee1143f80767485ceb61e6025b4e1f6ad5a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;suffixes&lt;/var&gt; gives the list of file-name suffixes to append to &lt;var&gt;filename&lt;/var&gt; when searching. &lt;code&gt;locate-file&lt;/code&gt; tries each possible directory with each of these suffixes. If &lt;var&gt;suffixes&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, or &lt;code&gt;(&quot;&quot;)&lt;/code&gt;, then there are no suffixes, and &lt;var&gt;filename&lt;/var&gt; is used only as-is. Typical values of &lt;var&gt;suffixes&lt;/var&gt; are &lt;code&gt;exec-suffixes&lt;/code&gt; (see &lt;a href=&quot;subprocess-creation#Subprocess-Creation&quot;&gt;Subprocess Creation&lt;/a&gt;), &lt;code&gt;load-suffixes&lt;/code&gt;, &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; and the return value of the function &lt;code&gt;get-load-suffixes&lt;/code&gt; (see &lt;a href=&quot;load-suffixes#Load-Suffixes&quot;&gt;Load Suffixes&lt;/a&gt;).</source>
          <target state="translated">Необязательные &lt;var&gt;suffixes&lt;/var&gt; аргументов дают список суффиксов &lt;var&gt;filename&lt;/var&gt; добавляемых к имени файла при поиске. &lt;code&gt;locate-file&lt;/code&gt; пробует каждый возможный каталог с каждым из этих суффиксов. Если &lt;var&gt;suffixes&lt;/var&gt; является &lt;code&gt;nil&lt;/code&gt; , или &lt;code&gt;(&quot;&quot;)&lt;/code&gt; , то нет никаких суффиксов, и &lt;var&gt;filename&lt;/var&gt; используется только как есть. Типичными значениями &lt;var&gt;suffixes&lt;/var&gt; являются суффиксы &lt;code&gt;exec-suffixes&lt;/code&gt; (см. &lt;a href=&quot;subprocess-creation#Subprocess-Creation&quot;&gt;Создание подпроцесса&lt;/a&gt; ), &lt;code&gt;load-suffixes&lt;/code&gt; &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; , суффиксы загрузки файла-реп и возвращаемое значение функции &lt;code&gt;get-load-suffixes&lt;/code&gt; (см. &lt;a href=&quot;load-suffixes#Load-Suffixes&quot;&gt;Суффиксы загрузки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6929cd262e2ec8e57cb83b3bca611739b4dfbf41" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;translation&lt;/var&gt; specifies a translation table to use for scanning the text (see &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Translation of Characters&lt;/a&gt;). If it is non-&lt;code&gt;nil&lt;/code&gt;, then each character in the region is translated through this table, and the value returned describes the translated characters instead of the characters actually in the buffer.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;translation&lt;/var&gt; указывает таблицу перевода, которая будет использоваться для сканирования текста (см. &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Перевод символов&lt;/a&gt; ). Если оно не равно &lt;code&gt;nil&lt;/code&gt; , то каждый символ в регионе транслируется через эту таблицу, а возвращаемое значение описывает переведенные символы, а не символы, фактически находящиеся в буфере.</target>
        </trans-unit>
        <trans-unit id="c092e151609e9ec5f01fdc51239dc320c81fb40d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;type&lt;/var&gt; is a symbol specifying the image type. If &lt;var&gt;type&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;create-image&lt;/code&gt; tries to determine the image type from the file&amp;rsquo;s first few bytes, or else from the file&amp;rsquo;s name.</source>
          <target state="translated">Необязательный &lt;var&gt;type&lt;/var&gt; аргумента - это символ, определяющий тип изображения. Если &lt;var&gt;type&lt;/var&gt; опущен или равен &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;create-image&lt;/code&gt; пытается определить тип изображения по первым нескольким байтам файла или по имени файла.</target>
        </trans-unit>
        <trans-unit id="cffa81c7cb380096c5547dae42e6cb7a9528d1b2" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;type&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, determines the exact type of Lisp object to check for. In that case, &lt;var&gt;type&lt;/var&gt; should be one of &lt;code&gt;font-object&lt;/code&gt;, &lt;code&gt;font-spec&lt;/code&gt;, or &lt;code&gt;font-entity&lt;/code&gt;.</source>
          <target state="translated">Необязательный &lt;var&gt;type&lt;/var&gt; аргумента , если он не &lt;code&gt;nil&lt;/code&gt; , определяет точный тип объекта Lisp для проверки. В этом случае &lt;var&gt;type&lt;/var&gt; должен быть один из &lt;code&gt;font-object&lt;/code&gt; , &lt;code&gt;font-spec&lt;/code&gt; или &lt;code&gt;font-entity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc15e8d2ee27fc6994759226a8e71c2f534f8ee7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;width&lt;/var&gt; specifies a desired font width. If it is non-&lt;code&gt;nil&lt;/code&gt;, the function only returns those fonts whose characters are (on average) &lt;var&gt;width&lt;/var&gt; times as wide as &lt;var&gt;reference-face&lt;/var&gt;.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;width&lt;/var&gt; указывает желаемую ширину шрифта. Если он не равен &lt;code&gt;nil&lt;/code&gt; , функция возвращает только те шрифты, символы которых (в среднем) по &lt;var&gt;width&lt;/var&gt; разы шире, чем &lt;var&gt;reference-face&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a4adeba927f11ca868cbbc9ac454375db4897015" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;window&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be a live window on the specified frame; then &lt;var&gt;window&lt;/var&gt; will be the first element in the returned list. If &lt;var&gt;window&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the window selected within the frame is the first element.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;window&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , должен быть активным окном в указанном фрейме; тогда &lt;var&gt;window&lt;/var&gt; будет первым элементом в возвращаемом списке. Если &lt;var&gt;window&lt;/var&gt; опущено или равно &lt;code&gt;nil&lt;/code&gt; , окно, выбранное внутри фрейма, является первым элементом.</target>
        </trans-unit>
        <trans-unit id="fdc9182a4b3a92a29afde612fa522b47066e0b79" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;x-limit&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the maximum X coordinate beyond which text should be ignored; it is therefore also the largest value of pixel-width that the function can return. If &lt;var&gt;x-limit&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt; or omitted, it means to use the pixel-width of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body (see &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;); this default means that text of truncated lines wider than the window will be ignored. This default is useful when the caller does not intend to change the width of &lt;var&gt;window&lt;/var&gt;. Otherwise, the caller should specify here the maximum width &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body may assume; in particular, if truncated lines are expected and their text needs to be accounted for, &lt;var&gt;x-limit&lt;/var&gt; should be set to a large value. Since calculating the width of long lines can take some time, it&amp;rsquo;s always a good idea to make this argument as small as needed; in particular, if the buffer might contain long lines that will be truncated anyway.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;x-limit&lt;/var&gt; , если не равен &lt;code&gt;nil&lt;/code&gt; , указывает максимальную координату X, за которой текст следует игнорировать; следовательно, это также самое большое значение ширины в пикселях, которое может вернуть функция. Если &lt;var&gt;x-limit&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; или опущен, это означает использование ширины в пикселях тела &lt;var&gt;window&lt;/var&gt; (см. &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Размеры окна&lt;/a&gt; ); это значение по умолчанию означает, что текст из усеченных строк шире окна будет проигнорирован. Это значение по умолчанию полезно, когда вызывающий абонент не намеревается изменять ширину &lt;var&gt;window&lt;/var&gt; . В противном случае вызывающий должен указать здесь максимальную ширину тела &lt;var&gt;window&lt;/var&gt; ; в частности, если ожидаются усеченные строки и их текст необходимо учитывать, &lt;var&gt;x-limit&lt;/var&gt; должен быть установлен на большое значение. Поскольку вычисление ширины длинных линий может занять некоторое время, всегда рекомендуется делать этот аргумент настолько маленьким, насколько это необходимо; в частности, если буфер может содержать длинные строки, которые все равно будут усечены.</target>
        </trans-unit>
        <trans-unit id="c40e0ed4f1db150d7701a53bd11312d3806432c0" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;xrm-string&lt;/var&gt;, if not &lt;code&gt;nil&lt;/code&gt;, is a string of resource names and values, in the same format used in the</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;xrm-string&lt;/var&gt; , если не &lt;code&gt;nil&lt;/code&gt; , представляет собой строку имен и значений ресурсов в том же формате, что и в</target>
        </trans-unit>
        <trans-unit id="e45d1b4575d0268bdd495d97852d103f4fb454e9" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;y-limit&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the maximum Y coordinate beyond which text is to be ignored; it is therefore also the maximum pixel-height that the function can return. If &lt;var&gt;y-limit&lt;/var&gt; is nil or omitted, it means to considers all the lines of text till the buffer position specified by &lt;var&gt;to&lt;/var&gt;. Since calculating the pixel-height of a large buffer can take some time, it makes sense to specify this argument; in particular, if the caller does not know the size of the buffer.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;y-limit&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , указывает максимальную координату Y, за которой текст игнорируется; следовательно, это также максимальная высота в пикселях, которую может вернуть функция. Если &lt;var&gt;y-limit&lt;/var&gt; равен нулю или опущен, это означает, что учитываются все строки текста до позиции в буфере, указанной в &lt;var&gt;to&lt;/var&gt; . Поскольку вычисление высоты в пикселях большого буфера может занять некоторое время, имеет смысл указать этот аргумент; в частности, если вызывающий не знает размер буфера.</target>
        </trans-unit>
        <trans-unit id="dc3a575ab4003570a9c36540fefa7d4ef44f3823" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;action&lt;/var&gt; and &lt;var&gt;frame&lt;/var&gt; are as for &lt;code&gt;display-buffer&lt;/code&gt;, and only used if a buffer is displayed.</source>
          <target state="translated">Необязательные аргументы &lt;var&gt;action&lt;/var&gt; и &lt;var&gt;frame&lt;/var&gt; такие же, как для &lt;code&gt;display-buffer&lt;/code&gt; , и используются только в том случае, если отображается буфер.</target>
        </trans-unit>
        <trans-unit id="0c0042672620faa70f4c2ac1559a316ba863df5c" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;component&lt;/var&gt; and &lt;var&gt;subclass&lt;/var&gt; add to the key and the class, respectively. You must specify both of them or neither. If you specify them, the key is &amp;lsquo;</source>
          <target state="translated">Необязательные параметры &lt;var&gt;component&lt;/var&gt; и &lt;var&gt;subclass&lt;/var&gt; добавить к ключу и класса, соответственно. Вы должны указать их оба или ни один. Если вы укажете их, ключ будет '</target>
        </trans-unit>
        <trans-unit id="ee91262e4675f009db2d341be5b1d60c2ec7c619" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;min-width&lt;/var&gt; and &lt;var&gt;min-height&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specify the minimum width and height of any rectangle returned.</source>
          <target state="translated">Необязательные аргументы &lt;var&gt;min-width&lt;/var&gt; и &lt;var&gt;min-height&lt;/var&gt; , если они не &lt;code&gt;nil&lt;/code&gt; , указывают минимальную ширину и высоту любого возвращаемого прямоугольника.</target>
        </trans-unit>
        <trans-unit id="372690aff6ae141943d981fae5474ab55ccff89f" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; specify the windows to search, and have the same meanings as in &lt;code&gt;next-window&lt;/code&gt;.</source>
          <target state="translated">Необязательные аргументы &lt;var&gt;minibuf&lt;/var&gt; и &lt;var&gt;all-frames&lt;/var&gt; определяют окна для поиска и имеют то же значение, что и в &lt;code&gt;next-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c1039de00a7678732da9114d34b59102a11647b" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are character positions specifying the portion of &lt;var&gt;object&lt;/var&gt; to compute the message digest for. If they are &lt;code&gt;nil&lt;/code&gt; or omitted, the hash is computed for the whole of &lt;var&gt;object&lt;/var&gt;.</source>
          <target state="translated">Необязательные аргументы &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; - это позиции символов, определяющие часть &lt;var&gt;object&lt;/var&gt; для которой вычисляется дайджест сообщения. Если они равны &lt;code&gt;nil&lt;/code&gt; или опущены, хеш вычисляется для всего &lt;var&gt;object&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="2337e7f6ede507e511fcbe99dd954146514bc80b" translate="yes" xml:space="preserve">
          <source>The optional fifth argument, &lt;var&gt;object&lt;/var&gt;, specifies the string or buffer to scan. Positions are relative to &lt;var&gt;object&lt;/var&gt;. The default for &lt;var&gt;object&lt;/var&gt; is the current buffer.</source>
          <target state="translated">Необязательный пятый аргумент, &lt;var&gt;object&lt;/var&gt; , указывает строку или буфер для сканирования. Позиции относительно &lt;var&gt;object&lt;/var&gt; . По умолчанию для &lt;var&gt;object&lt;/var&gt; используется текущий буфер.</target>
        </trans-unit>
        <trans-unit id="28e7ede94a8e68a6a581d0669d18f692d137189a" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means that &lt;var&gt;frame&lt;/var&gt; should be &lt;var&gt;height&lt;/var&gt; pixels high. Note that if &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, some window managers may refuse to truly honor the request if it does not increase/decrease the frame height to a multiple of its character height.</source>
          <target state="translated">Необязательный четвертого аргумент &lt;var&gt;pixelwise&lt;/var&gt; не- &lt;code&gt;nil&lt;/code&gt; означает , что &lt;var&gt;frame&lt;/var&gt; должен быть &lt;var&gt;height&lt;/var&gt; высокими пикселей. Обратите внимание, что если &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; равно &lt;code&gt;nil&lt;/code&gt; , некоторые оконные менеджеры могут отказываться действительно выполнять запрос, если он не увеличивает / не уменьшает высоту кадра до кратной высоты его символа.</target>
        </trans-unit>
        <trans-unit id="4cea50b6fa2e62214008b025d8e0f2e6fa48a344" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means that &lt;var&gt;frame&lt;/var&gt; should be &lt;var&gt;width&lt;/var&gt; pixels wide. Note that if &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, some window managers may refuse to fully honor the request if it does not increase/decrease the frame width to a multiple of its character width.</source>
          <target state="translated">Необязательный четвертый аргумент &lt;var&gt;pixelwise&lt;/var&gt; не- &lt;code&gt;nil&lt;/code&gt; означает , что &lt;var&gt;frame&lt;/var&gt; должна быть &lt;var&gt;width&lt;/var&gt; пикселей в ширину. Обратите внимание, что если &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; равно &lt;code&gt;nil&lt;/code&gt; , некоторые оконные менеджеры могут отказываться полностью выполнять запрос, если он не увеличивает / не уменьшает ширину кадра до кратной ширины его символа.</target>
        </trans-unit>
        <trans-unit id="46a593eb8b77337d54dd037277b7e1d96651e2a6" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;pixelwise&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to interpret &lt;var&gt;size&lt;/var&gt; in units of pixels, instead of lines and columns.</source>
          <target state="translated">Необязательный четвертый аргумент по &lt;var&gt;pixelwise&lt;/var&gt; , если он не равен &lt;code&gt;nil&lt;/code&gt; , означает интерпретацию &lt;var&gt;size&lt;/var&gt; в пикселях, а не в строках и столбцах.</target>
        </trans-unit>
        <trans-unit id="c1d2d517b24a513e68638fc126f01cf14f00b2b4" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;window&lt;/var&gt; specifies the window for obtaining parameters such as width, horizontal scrolling, and so on. The default is to use the selected window&amp;rsquo;s parameters.</source>
          <target state="translated">Необязательный четвертый аргумент &lt;var&gt;window&lt;/var&gt; определяет окно для получения таких параметров, как ширина, горизонтальная прокрутка и так далее. По умолчанию используются параметры выбранного окна.</target>
        </trans-unit>
        <trans-unit id="32d500e9fa66e6e098845ee8a4f7df222a3a64f2" translate="yes" xml:space="preserve">
          <source>The optional second argument &lt;var&gt;size&lt;/var&gt; determines the sizes of &lt;var&gt;window&lt;/var&gt; and/or the new window. If it is omitted or &lt;code&gt;nil&lt;/code&gt;, both windows are given equal sizes; if there is an odd line, it is allocated to the new window. If &lt;var&gt;size&lt;/var&gt; is a positive number, &lt;var&gt;window&lt;/var&gt; is given &lt;var&gt;size&lt;/var&gt; lines (or columns, depending on the value of &lt;var&gt;side&lt;/var&gt;). If &lt;var&gt;size&lt;/var&gt; is a negative number, the new window is given -&lt;var&gt;size&lt;/var&gt; lines (or columns).</source>
          <target state="translated">Необязательный второй аргумент &lt;var&gt;size&lt;/var&gt; определяет размеры &lt;var&gt;window&lt;/var&gt; и / или нового окна. Если он опущен или равен &lt;code&gt;nil&lt;/code&gt; , обоим окнам дается одинаковый размер; если есть нечетная строка, она размещается в новом окне. Если &lt;var&gt;size&lt;/var&gt; положительное число, &lt;var&gt;window&lt;/var&gt; дается &lt;var&gt;size&lt;/var&gt; строк (или столбцов, в зависимости от значения &lt;var&gt;side&lt;/var&gt; ). Если &lt;var&gt;size&lt;/var&gt; - отрицательное число, дается новое окно - &lt;var&gt;size&lt;/var&gt; строки (или столбцы).</target>
        </trans-unit>
        <trans-unit id="3ea25d87cc8b43ad9b6088e35f93a262a0c645a2" translate="yes" xml:space="preserve">
          <source>The optional string &lt;var&gt;docstring&lt;/var&gt; is the documentation string of the variable &lt;var&gt;tabname&lt;/var&gt;. The property list &lt;var&gt;props&lt;/var&gt; is applied to the abbrev table (see &lt;a href=&quot;abbrev-table-properties#Abbrev-Table-Properties&quot;&gt;Abbrev Table Properties&lt;/a&gt;).</source>
          <target state="translated">Необязательная строка &lt;var&gt;docstring&lt;/var&gt; - это строка документации переменной &lt;var&gt;tabname&lt;/var&gt; . Список свойств &lt;var&gt;props&lt;/var&gt; применяется к таблице Abbrev (см &lt;a href=&quot;abbrev-table-properties#Abbrev-Table-Properties&quot;&gt;Abbrev Свойства таблицы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c222f8e06e9d5450826a8e535233e76c3aefd4d7" translate="yes" xml:space="preserve">
          <source>The optional third argument &lt;var&gt;side&lt;/var&gt; determines the position of the new window relative to &lt;var&gt;window&lt;/var&gt;. If it is &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;below&lt;/code&gt;, the new window is placed below &lt;var&gt;window&lt;/var&gt;. If it is &lt;code&gt;above&lt;/code&gt;, the new window is placed above &lt;var&gt;window&lt;/var&gt;. In both these cases, &lt;var&gt;size&lt;/var&gt; specifies a total window height, in lines.</source>
          <target state="translated">Необязательная третья &lt;var&gt;side&lt;/var&gt; аргумента определяет положение нового окна относительно &lt;var&gt;window&lt;/var&gt; . Если оно равно &lt;code&gt;nil&lt;/code&gt; или &lt;code&gt;below&lt;/code&gt; , новое окно помещается под &lt;var&gt;window&lt;/var&gt; . Если он &lt;code&gt;above&lt;/code&gt; , новое окно размещается над &lt;var&gt;window&lt;/var&gt; . В обоих случаях &lt;var&gt;size&lt;/var&gt; определяет общую высоту окна в строках.</target>
        </trans-unit>
        <trans-unit id="b1108fc16d48a052af5da3a2a313ad2178d4f97c" translate="yes" xml:space="preserve">
          <source>The optional third argument specifies the argument list of &lt;code&gt;shell-mode&lt;/code&gt;. In this case, it takes no arguments (&lt;code&gt;nil&lt;/code&gt; is different from not specifying a value). In other cases, this might be something like &lt;code&gt;(file &amp;amp;optional overwrite)&lt;/code&gt;. You don&amp;rsquo;t have to specify the argument list, but if you do the byte compiler can check that the calls match the declaration.</source>
          <target state="translated">Необязательный третий аргумент определяет список аргументов режима &lt;code&gt;shell-mode&lt;/code&gt; . В этом случае аргументов не требуется ( &lt;code&gt;nil&lt;/code&gt; отличается от отсутствия значения). В других случаях это может быть что-то вроде &lt;code&gt;(file &amp;amp;optional overwrite)&lt;/code&gt; . Вам не нужно указывать список аргументов, но если вы это сделаете, байтовый компилятор может проверить, соответствуют ли вызовы объявлению.</target>
        </trans-unit>
        <trans-unit id="c91189f64260a86a1f42683fa6c4e4a546871bd4" translate="yes" xml:space="preserve">
          <source>The order of items in the menu is the same as the order of bindings in the keymap. Since &lt;code&gt;define-key&lt;/code&gt; puts new bindings at the front, you should define the menu items starting at the bottom of the menu and moving to the top, if you care about the order. When you add an item to an existing menu, you can specify its position in the menu using &lt;code&gt;define-key-after&lt;/code&gt; (see &lt;a href=&quot;modifying-menus#Modifying-Menus&quot;&gt;Modifying Menus&lt;/a&gt;).</source>
          <target state="translated">Порядок пунктов в меню такой же, как порядок привязок в раскладке клавиатуры. Поскольку &lt;code&gt;define-key&lt;/code&gt; помещает новые привязки впереди, вы должны определять элементы меню, начиная с нижней части меню и перемещаясь вверх, если вы заботитесь о порядке. Когда вы добавляете элемент в существующее меню, вы можете указать его положение в меню, используя команду &lt;code&gt;define-key-after&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;modifying-menus#Modifying-Menus&quot;&gt;Изменение меню&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1eb5686cd4b85626eb2e98bbf5e87da933ba4c3c" translate="yes" xml:space="preserve">
          <source>The order of specifications in &lt;var&gt;template&lt;/var&gt; need not correspond to the order of associations in &lt;var&gt;spec-alist&lt;/var&gt;.</source>
          <target state="translated">Порядок спецификаций в &lt;var&gt;template&lt;/var&gt; не обязательно должен соответствовать порядку ассоциаций в &lt;var&gt;spec-alist&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="318b3cee5109ab1253568ca38f5b8b67f4c1e472" translate="yes" xml:space="preserve">
          <source>The ordering information is stored in a hash table on &lt;var&gt;symbol&lt;/var&gt;&amp;rsquo;s &lt;code&gt;list-order&lt;/code&gt; property. &lt;var&gt;symbol&lt;/var&gt; cannot refer to a lexical variable.</source>
          <target state="translated">Информация для заказа хранится в хэш - таблице на &lt;var&gt;symbol&lt;/var&gt; &amp;laquo;s &lt;code&gt;list-order&lt;/code&gt; собственности. &lt;var&gt;symbol&lt;/var&gt; не может ссылаться на лексическую переменную.</target>
        </trans-unit>
        <trans-unit id="2226d00d51a88ba323aae0098cc9991d74673a2e" translate="yes" xml:space="preserve">
          <source>The ordering is determined by a depth-first traversal of each frame&amp;rsquo;s window tree, retrieving the live windows which are the leaf nodes of the tree (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;). If the minibuffer is active, the minibuffer window is included too. The ordering is cyclic, so the last window in the sequence is followed by the first one.</source>
          <target state="translated">Порядок определяется обходом в глубину дерева окон каждого фрейма, извлекая живые окна, которые являются конечными узлами дерева (см. &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Окна и фреймы&lt;/a&gt; ). Если минибуфер активен, окно минибуфера также включается. Порядок является циклическим, поэтому за последним окном в последовательности следует первое.</target>
        </trans-unit>
        <trans-unit id="f22b797aae6cb0756380535cd8ae770baa37540b" translate="yes" xml:space="preserve">
          <source>The ordinary &lt;em&gt;Lisp debugger&lt;/em&gt; provides the ability to suspend evaluation of a form. While evaluation is suspended (a state that is commonly known as a &lt;em&gt;break&lt;/em&gt;), you may examine the run time stack, examine the values of local or global variables, or change those values. Since a break is a recursive edit, all the usual editing facilities of Emacs are available; you can even run programs that will enter the debugger recursively. See &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;.</source>
          <target state="translated">The ordinary &lt;em&gt;Lisp debugger&lt;/em&gt; provides the ability to suspend evaluation of a form. While evaluation is suspended (a state that is commonly known as a &lt;em&gt;break&lt;/em&gt;), you may examine the run time stack, examine the values of local or global variables, or change those values. Since a break is a recursive edit, all the usual editing facilities of Emacs are available; you can even run programs that will enter the debugger recursively. See &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4f996d904bee479b366f2c2d0b17fcd959ce9c44" translate="yes" xml:space="preserve">
          <source>The ordinary elements of the display table are indexed by character codes; the element at index &lt;var&gt;c&lt;/var&gt; says how to display the character code &lt;var&gt;c&lt;/var&gt;. The value should be &lt;code&gt;nil&lt;/code&gt; (which means to display the character &lt;var&gt;c&lt;/var&gt; according to the usual display conventions; see &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;), or a vector of glyph codes (which means to display the character &lt;var&gt;c&lt;/var&gt; as those glyphs; see &lt;a href=&quot;glyphs#Glyphs&quot;&gt;Glyphs&lt;/a&gt;).</source>
          <target state="translated">The ordinary elements of the display table are indexed by character codes; the element at index &lt;var&gt;c&lt;/var&gt; says how to display the character code &lt;var&gt;c&lt;/var&gt; . The value should be &lt;code&gt;nil&lt;/code&gt; (which means to display the character &lt;var&gt;c&lt;/var&gt; according to the usual display conventions; see &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;), or a vector of glyph codes (which means to display the character &lt;var&gt;c&lt;/var&gt; as those glyphs; see &lt;a href=&quot;glyphs#Glyphs&quot;&gt;Glyphs&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="623ff6e7f140985ddebe6c27ee8d097d687ce22b" translate="yes" xml:space="preserve">
          <source>The original argument list, modified with the actual connection information, is available via the &lt;code&gt;process-contact&lt;/code&gt; function.</source>
          <target state="translated">The original argument list, modified with the actual connection information, is available via the &lt;code&gt;process-contact&lt;/code&gt; function.</target>
        </trans-unit>
        <trans-unit id="3d6da09d571fe6e045570a75658c815203791d82" translate="yes" xml:space="preserve">
          <source>The original argument list, possibly modified by later configuration, is available via the function &lt;code&gt;process-contact&lt;/code&gt;.</source>
          <target state="translated">The original argument list, possibly modified by later configuration, is available via the function &lt;code&gt;process-contact&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="783a67e957204d836894a368a238fa5382b7ae1b" translate="yes" xml:space="preserve">
          <source>The other Emacs prefix keys are</source>
          <target state="translated">Другие префиксные ключи Emacs</target>
        </trans-unit>
        <trans-unit id="5e87cdc0bc797ddea7fd188f93a5689b5c8765dd" translate="yes" xml:space="preserve">
          <source>The outer position is specified by and can be set via the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; frame parameters (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For a normal, top-level frame these parameters usually represent its absolute position (see below) with respect to its display&amp;rsquo;s origin. For a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) these parameters represent its position relative to the native position (see below) of its parent frame. For frames on text terminals the values of these parameters are meaningless and always zero.</source>
          <target state="translated">The outer position is specified by and can be set via the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; frame parameters (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For a normal, top-level frame these parameters usually represent its absolute position (see below) with respect to its display&amp;rsquo;s origin. For a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) these parameters represent its position relative to the native position (see below) of its parent frame. For frames on text terminals the values of these parameters are meaningless and always zero.</target>
        </trans-unit>
        <trans-unit id="9b61b570125b083d2bf973be5f7d446a50b1ff1e" translate="yes" xml:space="preserve">
          <source>The output characters are displayed in the echo area.</source>
          <target state="translated">Выходные символы отображаются в области эха.</target>
        </trans-unit>
        <trans-unit id="f760a648322efbb4e113d3ec65ce0e0be54106de" translate="yes" xml:space="preserve">
          <source>The output characters are inserted into &lt;var&gt;buffer&lt;/var&gt; at point. Point advances as characters are inserted.</source>
          <target state="translated">The output characters are inserted into &lt;var&gt;buffer&lt;/var&gt; at point. Point advances as characters are inserted.</target>
        </trans-unit>
        <trans-unit id="847115e1679c724c2cb4444c6559f9fe7c4d8063" translate="yes" xml:space="preserve">
          <source>The output characters are inserted into the buffer that &lt;var&gt;marker&lt;/var&gt; points into, at the marker position. The marker position advances as characters are inserted. The value of point in the buffer has no effect on printing when the stream is a marker, and this kind of printing does not move point (except that if the marker points at or before the position of point, point advances with the surrounding text, as usual).</source>
          <target state="translated">The output characters are inserted into the buffer that &lt;var&gt;marker&lt;/var&gt; points into, at the marker position. The marker position advances as characters are inserted. The value of point in the buffer has no effect on printing when the stream is a marker, and this kind of printing does not move point (except that if the marker points at or before the position of point, point advances with the surrounding text, as usual).</target>
        </trans-unit>
        <trans-unit id="da1c7a7c56317e365d871f2788f8d99dcda43cbf" translate="yes" xml:space="preserve">
          <source>The output characters are passed to &lt;var&gt;function&lt;/var&gt;, which is responsible for storing them away. It is called with a single character as argument, as many times as there are characters to be output, and is responsible for storing the characters wherever you want to put them.</source>
          <target state="translated">The output characters are passed to &lt;var&gt;function&lt;/var&gt; , which is responsible for storing them away. It is called with a single character as argument, as many times as there are characters to be output, and is responsible for storing the characters wherever you want to put them.</target>
        </trans-unit>
        <trans-unit id="97b90b29b23cb79eed0c42878f18676a7f82018f" translate="yes" xml:space="preserve">
          <source>The output from a synchronous subprocess is generally decoded using a coding system, much like text read from a file. The input sent to a subprocess by &lt;code&gt;call-process-region&lt;/code&gt; is encoded using a coding system, much like text written into a file. See &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;.</source>
          <target state="translated">The output from a synchronous subprocess is generally decoded using a coding system, much like text read from a file. The input sent to a subprocess by &lt;code&gt;call-process-region&lt;/code&gt; is encoded using a coding system, much like text written into a file. See &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1bf1d258cf8161b4fe6f560101ccee767cdb33ab" translate="yes" xml:space="preserve">
          <source>The output string need not be newly-allocated. For example, if &lt;code&gt;x&lt;/code&gt; is the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, the expressions &lt;code&gt;(eq x
(format x))&lt;/code&gt; and &lt;code&gt;(eq x (format &quot;%s&quot; x))&lt;/code&gt; might both yield &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">The output string need not be newly-allocated. For example, if &lt;code&gt;x&lt;/code&gt; is the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; , the expressions &lt;code&gt;(eq x (format x))&lt;/code&gt; and &lt;code&gt;(eq x (format &quot;%s&quot; x))&lt;/code&gt; might both yield &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3615d741950845df06c53b6a7f56b4c8a5a4ebc" translate="yes" xml:space="preserve">
          <source>The output that an asynchronous subprocess writes to its standard output stream is passed to a function called the &lt;em&gt;filter function&lt;/em&gt;. The default filter function simply inserts the output into a buffer, which is called the associated buffer of the process (see &lt;a href=&quot;process-buffers#Process-Buffers&quot;&gt;Process Buffers&lt;/a&gt;). If the process has no buffer then the default filter discards the output.</source>
          <target state="translated">The output that an asynchronous subprocess writes to its standard output stream is passed to a function called the &lt;em&gt;filter function&lt;/em&gt;. The default filter function simply inserts the output into a buffer, which is called the associated buffer of the process (see &lt;a href=&quot;process-buffers#Process-Buffers&quot;&gt;Process Buffers&lt;/a&gt;). If the process has no buffer then the default filter discards the output.</target>
        </trans-unit>
        <trans-unit id="1ae9bdf1de6c1b3dee1b8c77f2a066e71cd4bda1" translate="yes" xml:space="preserve">
          <source>The output to the filter may come in chunks of any size. A program that produces the same output twice in a row may send it as one batch of 200 characters one time, and five batches of 40 characters the next. If the filter looks for certain text strings in the subprocess output, make sure to handle the case where one of these strings is split across two or more batches of output; one way to do this is to insert the received text into a temporary buffer, which can then be searched.</source>
          <target state="translated">На выходе к фильтру могут поступать куски любого размера.Программа,производящая один и тот же вывод дважды подряд,может отправить его как одну партию по 200 символов один раз,и пять партий по 40 символов следующую.Если фильтр ищет определенные текстовые строки в подпроцессном выводе,убедитесь,что он обрабатывает случай,когда одна из этих строк разделена на две или более партий вывода;один из способов сделать это-вставить полученный текст во временный буфер,который затем можно искать.</target>
        </trans-unit>
        <trans-unit id="58e6196b6fc1654a77feeadf775e93f2d335a94f" translate="yes" xml:space="preserve">
          <source>The outside window configuration is saved and restored if &lt;code&gt;edebug-save-windows&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;).</source>
          <target state="translated">The outside window configuration is saved and restored if &lt;code&gt;edebug-save-windows&lt;/code&gt; is non- &lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="443f8535af5feac9009b9eb74d0bd0bbb542eca8" translate="yes" xml:space="preserve">
          <source>The overlay-arrow string is displayed in any given buffer if the value of &lt;code&gt;overlay-arrow-position&lt;/code&gt; in that buffer points into that buffer. Thus, it is possible to display multiple overlay arrow strings by creating buffer-local bindings of &lt;code&gt;overlay-arrow-position&lt;/code&gt;. However, it is usually cleaner to use &lt;code&gt;overlay-arrow-variable-list&lt;/code&gt; to achieve this result.</source>
          <target state="translated">The overlay-arrow string is displayed in any given buffer if the value of &lt;code&gt;overlay-arrow-position&lt;/code&gt; in that buffer points into that buffer. Thus, it is possible to display multiple overlay arrow strings by creating buffer-local bindings of &lt;code&gt;overlay-arrow-position&lt;/code&gt; . However, it is usually cleaner to use &lt;code&gt;overlay-arrow-variable-list&lt;/code&gt; to achieve this result.</target>
        </trans-unit>
        <trans-unit id="0c4e900964a2a9c8ee2b6d6918d8e7e1d4ae357a" translate="yes" xml:space="preserve">
          <source>The package&amp;rsquo;s main or only group should be a member of one or more of the standard customization groups. (To display the full list of them, use</source>
          <target state="translated">The package&amp;rsquo;s main or only group should be a member of one or more of the standard customization groups. (To display the full list of them, use</target>
        </trans-unit>
        <trans-unit id="056f01b4a46a37e98b55727e87a95ecf4b9b9d41" translate="yes" xml:space="preserve">
          <source>The parameter&amp;rsquo;s second element is either one of the symbols &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;frame&lt;/code&gt;, or a list whose elements are the buffer shown in &lt;var&gt;window&lt;/var&gt; before, that buffer&amp;rsquo;s window start and window point positions, and &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s height at that time. If that buffer is still live when &lt;var&gt;window&lt;/var&gt; is quit, then this function may reuse &lt;var&gt;window&lt;/var&gt; to display it.</source>
          <target state="translated">The parameter&amp;rsquo;s second element is either one of the symbols &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;frame&lt;/code&gt; , or a list whose elements are the buffer shown in &lt;var&gt;window&lt;/var&gt; before, that buffer&amp;rsquo;s window start and window point positions, and &lt;var&gt;window&lt;/var&gt; &amp;rsquo;s height at that time. If that buffer is still live when &lt;var&gt;window&lt;/var&gt; is quit, then this function may reuse &lt;var&gt;window&lt;/var&gt; to display it.</target>
        </trans-unit>
        <trans-unit id="e0a39a896d6a8873b9effa21ba5ee259cb0e77fd" translate="yes" xml:space="preserve">
          <source>The parameters described below provide support for resizing a frame by dragging its internal borders with the mouse. They also allow moving a frame with the mouse by dragging the header line of its topmost or the mode line of its bottommost window.</source>
          <target state="translated">Параметры,описанные ниже,обеспечивают поддержку изменения размера кадра путем перетаскивания его внутренних границ мышью.Они также позволяют перемещать рамку с помощью мыши,перетаскивая линию заголовка ее самого верхнего окна или линию режима ее самого нижнего окна.</target>
        </trans-unit>
        <trans-unit id="1c21c17502bd64c3a71bdbc3fc9084a51f8eb952" translate="yes" xml:space="preserve">
          <source>The parent keymap of all &lt;code&gt;local-function-key-map&lt;/code&gt; (q.v.) instances.</source>
          <target state="translated">The parent keymap of all &lt;code&gt;local-function-key-map&lt;/code&gt; (q.v.) instances.</target>
        </trans-unit>
        <trans-unit id="83241215538033ded1beeee2b0b4fdef97b639a3" translate="yes" xml:space="preserve">
          <source>The parsing facilities of Emacs consider a string as a single token. The usual syntactic meanings of the characters in the string are suppressed.</source>
          <target state="translated">Средства синтаксического анализа Emacs рассматривают строку как один токен.Обычные синтаксические значения символов в строке подавляются.</target>
        </trans-unit>
        <trans-unit id="a4782b103645e67a505ec03626df6bb33c90727f" translate="yes" xml:space="preserve">
          <source>The parsing skips spaces and tabs at the beginning of &lt;var&gt;string&lt;/var&gt;, then reads as much of &lt;var&gt;string&lt;/var&gt; as it can interpret as a number in the given base. (On some systems it ignores other whitespace at the beginning, not just spaces and tabs.) If &lt;var&gt;string&lt;/var&gt; cannot be interpreted as a number, this function returns 0.</source>
          <target state="translated">The parsing skips spaces and tabs at the beginning of &lt;var&gt;string&lt;/var&gt; , then reads as much of &lt;var&gt;string&lt;/var&gt; as it can interpret as a number in the given base. (On some systems it ignores other whitespace at the beginning, not just spaces and tabs.) If &lt;var&gt;string&lt;/var&gt; cannot be interpreted as a number, this function returns 0.</target>
        </trans-unit>
        <trans-unit id="d08be782a53bbda1ba8dddd6886664346e48d767" translate="yes" xml:space="preserve">
          <source>The parsing technique used by SMIE does not allow tokens to behave differently in different contexts. For most programming languages, this manifests itself by precedence conflicts when converting the BNF grammar.</source>
          <target state="translated">Техника анализа,используемая SMIE,не позволяет маркерам вести себя по-разному в разных контекстах.Для большинства языков программирования это проявляется в конфликтах приоритетов при преобразовании грамматики BNF.</target>
        </trans-unit>
        <trans-unit id="fbb6c29935ae3da3bb37e989df0289bf03fba226" translate="yes" xml:space="preserve">
          <source>The part of the scroll bar on which the click occurred. It is one of the symbols &lt;code&gt;handle&lt;/code&gt; (the scroll bar handle), &lt;code&gt;above-handle&lt;/code&gt; (the area above the handle), &lt;code&gt;below-handle&lt;/code&gt; (the area below the handle), &lt;code&gt;up&lt;/code&gt; (the up arrow at one end of the scroll bar), or &lt;code&gt;down&lt;/code&gt; (the down arrow at one end of the scroll bar).</source>
          <target state="translated">The part of the scroll bar on which the click occurred. It is one of the symbols &lt;code&gt;handle&lt;/code&gt; (the scroll bar handle), &lt;code&gt;above-handle&lt;/code&gt; (the area above the handle), &lt;code&gt;below-handle&lt;/code&gt; (the area below the handle), &lt;code&gt;up&lt;/code&gt; (the up arrow at one end of the scroll bar), or &lt;code&gt;down&lt;/code&gt; (the down arrow at one end of the scroll bar).</target>
        </trans-unit>
        <trans-unit id="1168a5f90813f2fcee380e2f6e20037287e336c0" translate="yes" xml:space="preserve">
          <source>The parts of a lambda expression.</source>
          <target state="translated">Части лямбда-выражения.</target>
        </trans-unit>
        <trans-unit id="b276da95227712619d809e264d610c7532aff153" translate="yes" xml:space="preserve">
          <source>The path to a sound file to play when the notification pops up.</source>
          <target state="translated">Путь к звуковому файлу для воспроизведения при всплывающем уведомлении.</target>
        </trans-unit>
        <trans-unit id="3eb392db1262ef722d3f867992b904857965d5b1" translate="yes" xml:space="preserve">
          <source>The pcase macro</source>
          <target state="translated">Карманный макрос</target>
        </trans-unit>
        <trans-unit id="bfe752af47d77462d05ad0c5ca61909d42248960" translate="yes" xml:space="preserve">
          <source>The pcase patterns that are useful for destructuring bindings are generally those described in &lt;a href=&quot;backquote-patterns#Backquote-Patterns&quot;&gt;Backquote Patterns&lt;/a&gt;, since they express a specification of the structure of objects that will match.</source>
          <target state="translated">The pcase patterns that are useful for destructuring bindings are generally those described in &lt;a href=&quot;backquote-patterns#Backquote-Patterns&quot;&gt;Backquote Patterns&lt;/a&gt;, since they express a specification of the structure of objects that will match.</target>
        </trans-unit>
        <trans-unit id="85e5e6070e7ace2a864fd54495dc677c9fe2f335" translate="yes" xml:space="preserve">
          <source>The percentage of the CPU time used by the process since it started. The corresponding &lt;var&gt;value&lt;/var&gt; is a floating-point number between 0 and 100.</source>
          <target state="translated">The percentage of the CPU time used by the process since it started. The corresponding &lt;var&gt;value&lt;/var&gt; is a floating-point number between 0 and 100.</target>
        </trans-unit>
        <trans-unit id="74a0e3e0b308a0aa69a778516c8eba726d6c3004" translate="yes" xml:space="preserve">
          <source>The percentage of the buffer text above the &lt;strong&gt;top&lt;/strong&gt; of window, or &amp;lsquo;</source>
          <target state="translated">The percentage of the buffer text above the &lt;strong&gt;top&lt;/strong&gt; of window, or &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="5174826a919540ce04dc971e49d9dcc6a90c357a" translate="yes" xml:space="preserve">
          <source>The percentage of the buffer text that is above the &lt;strong&gt;bottom&lt;/strong&gt; of the window (which includes the text visible in the window, as well as the text above the top), plus &amp;lsquo;</source>
          <target state="translated">The percentage of the buffer text that is above the &lt;strong&gt;bottom&lt;/strong&gt; of the window (which includes the text visible in the window, as well as the text above the top), plus &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="0cf9d906bacdebd3353589bccc8f1c56cff833ae" translate="yes" xml:space="preserve">
          <source>The percentage of the total physical memory installed on the machine used by the process&amp;rsquo;s resident set. The value is a floating-point number between 0 and 100.</source>
          <target state="translated">The percentage of the total physical memory installed on the machine used by the process&amp;rsquo;s resident set. The value is a floating-point number between 0 and 100.</target>
        </trans-unit>
        <trans-unit id="745b0bf167534b10d93c434c0e1e395113673fc2" translate="yes" xml:space="preserve">
          <source>The percentages of text above both the &lt;strong&gt;top&lt;/strong&gt; and the &lt;strong&gt;bottom&lt;/strong&gt; of the window, separated by &amp;lsquo;</source>
          <target state="translated">The percentages of text above both the &lt;strong&gt;top&lt;/strong&gt; and the &lt;strong&gt;bottom&lt;/strong&gt; of the window, separated by &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="0de9363c585da842dc94d7cb92e52e9a964df31b" translate="yes" xml:space="preserve">
          <source>The pixel heights of a window&amp;rsquo;s mode and header line can be retrieved with the functions given below. Their return value is usually accurate unless the window has not been displayed before: In that case, the return value is based on an estimate of the font used for the window&amp;rsquo;s frame.</source>
          <target state="translated">The pixel heights of a window&amp;rsquo;s mode and header line can be retrieved with the functions given below. Their return value is usually accurate unless the window has not been displayed before: In that case, the return value is based on an estimate of the font used for the window&amp;rsquo;s frame.</target>
        </trans-unit>
        <trans-unit id="43c14cab8a2b2bb269e27efdcb44906c088989c3" translate="yes" xml:space="preserve">
          <source>The pixel size of the font used to open the font.</source>
          <target state="translated">Размер пикселя шрифта,используемого для открытия шрифта.</target>
        </trans-unit>
        <trans-unit id="0d3304078e97e6d9fcd53507ef3658705f5b3745" translate="yes" xml:space="preserve">
          <source>The pixel size of the font.</source>
          <target state="translated">Пиксельный размер шрифта.</target>
        </trans-unit>
        <trans-unit id="d5e8626e71efeeae5801637fe0d104f5743bf82a" translate="yes" xml:space="preserve">
          <source>The pixel widths of the left and right fringes in this window. A value of -1 means use the values of the frame.</source>
          <target state="translated">Ширина пикселей левой и правой бахромы в этом окне.Значение -1 означает использование значений рамки.</target>
        </trans-unit>
        <trans-unit id="a476ed7f718dc326836a3ad0a813832b8273668d" translate="yes" xml:space="preserve">
          <source>The place where you insert &amp;lsquo;</source>
          <target state="translated">The place where you insert &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="489704a85a579cab25a1f96c62ae86111efc895a" translate="yes" xml:space="preserve">
          <source>The places within a function where Edebug can stop execution are called &lt;em&gt;stop points&lt;/em&gt;. These occur both before and after each subexpression that is a list, and also after each variable reference. Here we use periods to show the stop points in the function &lt;code&gt;fac&lt;/code&gt;:</source>
          <target state="translated">The places within a function where Edebug can stop execution are called &lt;em&gt;stop points&lt;/em&gt;. These occur both before and after each subexpression that is a list, and also after each variable reference. Here we use periods to show the stop points in the function &lt;code&gt;fac&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="31d74db390eea1284d7b4e181bb2f481d81da20c" translate="yes" xml:space="preserve">
          <source>The plural &amp;ldquo;frames&amp;rdquo; in the previous paragraph is deliberate: while Emacs itself has only one selected frame, Emacs can have frames on many different terminals (recall that a connection to a window system counts as a terminal), and each terminal has its own idea of which frame has input focus. When you set the input focus to a frame, you set the focus for that frame&amp;rsquo;s terminal, but frames on other terminals may still remain focused.</source>
          <target state="translated">The plural &amp;ldquo;frames&amp;rdquo; in the previous paragraph is deliberate: while Emacs itself has only one selected frame, Emacs can have frames on many different terminals (recall that a connection to a window system counts as a terminal), and each terminal has its own idea of which frame has input focus. When you set the input focus to a frame, you set the focus for that frame&amp;rsquo;s terminal, but frames on other terminals may still remain focused.</target>
        </trans-unit>
        <trans-unit id="ce65815e1a28f37a72576e7cbec00483473f471a" translate="yes" xml:space="preserve">
          <source>The point of running a program through the shell, rather than directly with &lt;code&gt;make-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, is so that you can employ shell features such as wildcards in the arguments. It follows that if you include any arbitrary user-specified arguments in the command, you should quote them with &lt;code&gt;shell-quote-argument&lt;/code&gt; first, so that any special shell characters do &lt;em&gt;not&lt;/em&gt; have their special shell meanings. See &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;Shell Arguments&lt;/a&gt;. Of course, when executing commands based on user input you should also consider the security implications.</source>
          <target state="translated">The point of running a program through the shell, rather than directly with &lt;code&gt;make-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt; , is so that you can employ shell features such as wildcards in the arguments. It follows that if you include any arbitrary user-specified arguments in the command, you should quote them with &lt;code&gt;shell-quote-argument&lt;/code&gt; first, so that any special shell characters do &lt;em&gt;not&lt;/em&gt; have their special shell meanings. See &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;Shell Arguments&lt;/a&gt;. Of course, when executing commands based on user input you should also consider the security implications.</target>
        </trans-unit>
        <trans-unit id="87e05b91e6233e17b204f23015097c7049303099" translate="yes" xml:space="preserve">
          <source>The position at which the line being indented begins.</source>
          <target state="translated">Положение,при котором начинается смещение линии.</target>
        </trans-unit>
        <trans-unit id="45b07b40e31e169ede72cfe22029fabdc54bc98b" translate="yes" xml:space="preserve">
          <source>The position in the buffer for which the line number is known, or zero meaning none is known. If it is -1, don&amp;rsquo;t display the line number as long as the window shows that buffer.</source>
          <target state="translated">The position in the buffer for which the line number is known, or zero meaning none is known. If it is -1, don&amp;rsquo;t display the line number as long as the window shows that buffer.</target>
        </trans-unit>
        <trans-unit id="7bb41d39783192e6aaaa6d09fb0dcd6b9d067af6" translate="yes" xml:space="preserve">
          <source>The position in the string where the click occurred.</source>
          <target state="translated">Позиция в строке,где произошло нажатие.</target>
        </trans-unit>
        <trans-unit id="1c5737b61d1133d53c07a40026bed5c9ffc696e8" translate="yes" xml:space="preserve">
          <source>The position of a frame on its display.</source>
          <target state="translated">Положение рамки на ее дисплее.</target>
        </trans-unit>
        <trans-unit id="887258f07e45dd70c1b6e53e04e7f416f5a7b904" translate="yes" xml:space="preserve">
          <source>The position of point, as an integer (see &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;). No I/O.</source>
          <target state="translated">The position of point, as an integer (see &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;). No I/O.</target>
        </trans-unit>
        <trans-unit id="6403590e242da2f2207180f395d2c07e997ed88a" translate="yes" xml:space="preserve">
          <source>The position of the frame on the screen.</source>
          <target state="translated">Положение рамки на экране.</target>
        </trans-unit>
        <trans-unit id="255ed0f6aab596c870f5c23defcace62009a4b51" translate="yes" xml:space="preserve">
          <source>The position of the mark, as an integer. No I/O.</source>
          <target state="translated">Положение метки,как целое число.Нет ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="a5dd7b877105dceee61a4c59515a66464dc839be" translate="yes" xml:space="preserve">
          <source>The position of the tool bar when Emacs was built with GTK+. Its value can be one of &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;. The default is &lt;code&gt;top&lt;/code&gt;.</source>
          <target state="translated">The position of the tool bar when Emacs was built with GTK+. Its value can be one of &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;bottom&lt;/code&gt; &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; . The default is &lt;code&gt;top&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02d4165115759fe0837c49ced5e39ea743ea4c2a" translate="yes" xml:space="preserve">
          <source>The position of the top left corner of the native frame specifies the &lt;em&gt;native position&lt;/em&gt; of the frame. (1)&amp;ndash;(3) in the drawing above indicate that position for the various builds:</source>
          <target state="translated">The position of the top left corner of the native frame specifies the &lt;em&gt;native position&lt;/em&gt; of the frame. (1)&amp;ndash;(3) in the drawing above indicate that position for the various builds:</target>
        </trans-unit>
        <trans-unit id="833e5a5239b46b2d55c382c18b023ecd55ad49ca" translate="yes" xml:space="preserve">
          <source>The position of the upper left corner of the outer frame (indicated by &amp;lsquo;</source>
          <target state="translated">The position of the upper left corner of the outer frame (indicated by &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="8410a3b5f6f9e6c84d904b172515815de91f0dd2" translate="yes" xml:space="preserve">
          <source>The position, in pixels, of the left outer edge of the frame with respect to the left edge of the frame&amp;rsquo;s display or parent frame. It can be specified in one of the following ways.</source>
          <target state="translated">The position, in pixels, of the left outer edge of the frame with respect to the left edge of the frame&amp;rsquo;s display or parent frame. It can be specified in one of the following ways.</target>
        </trans-unit>
        <trans-unit id="159bfe6471c89158a22673c87af74200df998625" translate="yes" xml:space="preserve">
          <source>The possible values for an actual subprocess are:</source>
          <target state="translated">Возможные значения для действительного подпроцесса:</target>
        </trans-unit>
        <trans-unit id="ca9c70ab4f2597d1a37484e4797e646e200cc36c" translate="yes" xml:space="preserve">
          <source>The preceding examples all use sequencing patterns which include the &lt;var&gt;symbol&lt;/var&gt; sub-pattern in some way. Here are some important details about that usage.</source>
          <target state="translated">The preceding examples all use sequencing patterns which include the &lt;var&gt;symbol&lt;/var&gt; sub-pattern in some way. Here are some important details about that usage.</target>
        </trans-unit>
        <trans-unit id="a258153ccf268c951438b192904eade1c144e0c6" translate="yes" xml:space="preserve">
          <source>The precise effect of adding a value depends on the customization type of &lt;var&gt;symbol&lt;/var&gt;.</source>
          <target state="translated">The precise effect of adding a value depends on the customization type of &lt;var&gt;symbol&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3f4009f97f05ca5f3cb51352b6efa1949bc23635" translate="yes" xml:space="preserve">
          <source>The precise meaning of a value of &lt;code&gt;nil&lt;/code&gt; for this option depends on the toolkit used. Dragging the external border with the mouse is done character-wise provided the window manager is willing to process the corresponding size hints. Calling &lt;code&gt;set-frame-size&lt;/code&gt; (see below) with arguments that do not specify the frame size as an integer multiple of its character size, however, may: be ignored, cause a rounding (GTK+), or be accepted (Lucid, Motif, MS-Windows).</source>
          <target state="translated">The precise meaning of a value of &lt;code&gt;nil&lt;/code&gt; for this option depends on the toolkit used. Dragging the external border with the mouse is done character-wise provided the window manager is willing to process the corresponding size hints. Calling &lt;code&gt;set-frame-size&lt;/code&gt; (see below) with arguments that do not specify the frame size as an integer multiple of its character size, however, may: be ignored, cause a rounding (GTK+), or be accepted (Lucid, Motif, MS-Windows).</target>
        </trans-unit>
        <trans-unit id="b4aa737004ad2535ebe02bb899113024dc279e7a" translate="yes" xml:space="preserve">
          <source>The precise meaning of the event parameters and the way these parameters are used to display the help-echo text are described in &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</source>
          <target state="translated">The precise meaning of the event parameters and the way these parameters are used to display the help-echo text are described in &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c34b9bbf535e3965b815554ff0467b7f149d988d" translate="yes" xml:space="preserve">
          <source>The previous buffer is usually the buffer shown before the buffer currently shown in &lt;var&gt;window&lt;/var&gt;. However, a buffer that has been buried or killed, or has been already shown by a recent invocation of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;, does not qualify as previous buffer.</source>
          <target state="translated">The previous buffer is usually the buffer shown before the buffer currently shown in &lt;var&gt;window&lt;/var&gt; . However, a buffer that has been buried or killed, or has been already shown by a recent invocation of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; , does not qualify as previous buffer.</target>
        </trans-unit>
        <trans-unit id="28721bd17842d6dccb7fd270c15c4194e8d5baba" translate="yes" xml:space="preserve">
          <source>The primary use of this function is as a subroutine by constructs that define or alter functions, like &lt;code&gt;defun&lt;/code&gt; or &lt;code&gt;advice-add&lt;/code&gt; (see &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;). You can also use it to give a symbol a function definition that is not a function, e.g., a keyboard macro (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;):</source>
          <target state="translated">The primary use of this function is as a subroutine by constructs that define or alter functions, like &lt;code&gt;defun&lt;/code&gt; or &lt;code&gt;advice-add&lt;/code&gt; (see &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;). You can also use it to give a symbol a function definition that is not a function, e.g., a keyboard macro (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;):</target>
        </trans-unit>
        <trans-unit id="ba9b5b776cc5667a85cd400075ca47d55ca09c2c" translate="yes" xml:space="preserve">
          <source>The primitive that extracts text from the buffer along with its properties is &lt;code&gt;buffer-substring&lt;/code&gt;. Before examining the properties, this function runs the abnormal hook &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt;.</source>
          <target state="translated">The primitive that extracts text from the buffer along with its properties is &lt;code&gt;buffer-substring&lt;/code&gt; . Before examining the properties, this function runs the abnormal hook &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a90a548ae4af1e7a922a25155c161c7315ce8da" translate="yes" xml:space="preserve">
          <source>The primitive way to create a byte-code object is with &lt;code&gt;make-byte-code&lt;/code&gt;:</source>
          <target state="translated">The primitive way to create a byte-code object is with &lt;code&gt;make-byte-code&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4906a197371ef069deb8bf9326d82ffeae4a7205" translate="yes" xml:space="preserve">
          <source>The primitives for changing properties apply to a specified range of text in a buffer or string. The function &lt;code&gt;set-text-properties&lt;/code&gt; (see end of section) sets the entire property list of the text in that range; more often, it is useful to add, change, or delete just certain properties specified by name.</source>
          <target state="translated">The primitives for changing properties apply to a specified range of text in a buffer or string. The function &lt;code&gt;set-text-properties&lt;/code&gt; (see end of section) sets the entire property list of the text in that range; more often, it is useful to add, change, or delete just certain properties specified by name.</target>
        </trans-unit>
        <trans-unit id="86e6972405ceac8fb0c2ebcbb1d084d74c15e137" translate="yes" xml:space="preserve">
          <source>The principal function for creating a hash table is &lt;code&gt;make-hash-table&lt;/code&gt;.</source>
          <target state="translated">The principal function for creating a hash table is &lt;code&gt;make-hash-table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e0ef3a61ced98eb5fb2f872d19a707b38cfe6c5" translate="yes" xml:space="preserve">
          <source>The principal purpose of coding systems is for use in reading and writing files. The function &lt;code&gt;insert-file-contents&lt;/code&gt; uses a coding system to decode the file data, and &lt;code&gt;write-region&lt;/code&gt; uses one to encode the buffer contents.</source>
          <target state="translated">The principal purpose of coding systems is for use in reading and writing files. The function &lt;code&gt;insert-file-contents&lt;/code&gt; uses a coding system to decode the file data, and &lt;code&gt;write-region&lt;/code&gt; uses one to encode the buffer contents.</target>
        </trans-unit>
        <trans-unit id="55a4ae7918bc297ffd67f49ed5d08ef37025a3dc" translate="yes" xml:space="preserve">
          <source>The print name cell always holds a string, and cannot be changed. Each of the other three cells can be set to any Lisp object.</source>
          <target state="translated">Ячейка с именем печати всегда содержит строку и не может быть изменена.Каждая из трех других ячеек может быть установлена на любой объект Lisp.</target>
        </trans-unit>
        <trans-unit id="de95f3a3b46a96121feaa824d316764b0883107a" translate="yes" xml:space="preserve">
          <source>The print name cell holds the string that is the name of a symbol. Since symbols are represented textually by their names, it is important not to have two symbols with the same name. The Lisp reader ensures this: every time it reads a symbol, it looks for an existing symbol with the specified name before it creates a new one. To get a symbol&amp;rsquo;s name, use the function &lt;code&gt;symbol-name&lt;/code&gt; (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;).</source>
          <target state="translated">The print name cell holds the string that is the name of a symbol. Since symbols are represented textually by their names, it is important not to have two symbols with the same name. The Lisp reader ensures this: every time it reads a symbol, it looks for an existing symbol with the specified name before it creates a new one. To get a symbol&amp;rsquo;s name, use the function &lt;code&gt;symbol-name&lt;/code&gt; (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="2bbc34bf200918e9a448ed9f1f2b1f066e970b26" translate="yes" xml:space="preserve">
          <source>The printed form represents up to 8 boolean values as a single character:</source>
          <target state="translated">Печатная форма представляет до 8 логических значений в виде одного символа:</target>
        </trans-unit>
        <trans-unit id="12644b40b0774ec2e789694cfc7abf62c019cde5" translate="yes" xml:space="preserve">
          <source>The printed representation and read syntax for a byte-code function object is like that for a vector, with an additional &amp;lsquo;</source>
          <target state="translated">The printed representation and read syntax for a byte-code function object is like that for a vector, with an additional &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="93d512217d9e0e619c1036f6280703870832034c" translate="yes" xml:space="preserve">
          <source>The printed representation for a hash table consists of &amp;lsquo;</source>
          <target state="translated">The printed representation for a hash table consists of &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="861954f964e54658232242a23ea2b7ee8994c956" translate="yes" xml:space="preserve">
          <source>The printed representation for floating-point numbers requires either a decimal point (with at least one digit following), an exponent, or both. For example, &amp;lsquo;</source>
          <target state="translated">The printed representation for floating-point numbers requires either a decimal point (with at least one digit following), an exponent, or both. For example, &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="7b99966b7387dd5ed35f73f081dbe0bcb6cc5e9b" translate="yes" xml:space="preserve">
          <source>The printed representation of a bool-vector is like a string, except that it begins with &amp;lsquo;</source>
          <target state="translated">The printed representation of a bool-vector is like a string, except that it begins with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="9a73160413b74c1de6679be1eae2e2a5562706a0" translate="yes" xml:space="preserve">
          <source>The printed representation of a char-table is like a vector except that there is an extra &amp;lsquo;</source>
          <target state="translated">The printed representation of a char-table is like a vector except that there is an extra &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="cf4d2204ede2ec7542b976b427c02ab6ac905744" translate="yes" xml:space="preserve">
          <source>The printed representation of a vector consists of a left square bracket, the elements, and a right square bracket. This is also the read syntax. Like numbers and strings, vectors are considered constants for evaluation.</source>
          <target state="translated">Печатное представление вектора состоит из левой квадратной скобки,элементов и правой квадратной скобки.Это также читаемый синтаксис.Как и числа и строки,векторы считаются константами для оценки.</target>
        </trans-unit>
        <trans-unit id="54bdda2e2c897bbee3fd6ea2ce6150e050bbdbf0" translate="yes" xml:space="preserve">
          <source>The printed representation of an interned symbol whose name is an empty string (see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;).</source>
          <target state="translated">The printed representation of an interned symbol whose name is an empty string (see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="b6b4f81ab9ddc9b498748d084ab114136d13e0d2" translate="yes" xml:space="preserve">
          <source>The printed representation of an uninterned symbol whose name is &lt;var&gt;foo&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">The printed representation of an uninterned symbol whose name is &lt;var&gt;foo&lt;/var&gt; is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="f0d146789656a2ca889b28283579fa331b709ea3" translate="yes" xml:space="preserve">
          <source>The printed representation of records is &amp;lsquo;</source>
          <target state="translated">The printed representation of records is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="06414aa54aa49ed289b3f642280e72ea07845a4c" translate="yes" xml:space="preserve">
          <source>The priority matters when two or more overlays cover the same character and both specify the same property; the one whose &lt;code&gt;priority&lt;/code&gt; value is larger overrides the other. (For the &lt;code&gt;face&lt;/code&gt; property, the higher priority overlay&amp;rsquo;s value does not completely override the other value; instead, its face attributes override the face attributes of the lower priority &lt;code&gt;face&lt;/code&gt; property.) If two overlays have the same priority value, and one is nested in the other, then the inner one will prevail over the outer one. If neither is nested in the other then you should not make assumptions about which overlay will prevail.</source>
          <target state="translated">The priority matters when two or more overlays cover the same character and both specify the same property; the one whose &lt;code&gt;priority&lt;/code&gt; value is larger overrides the other. (For the &lt;code&gt;face&lt;/code&gt; property, the higher priority overlay&amp;rsquo;s value does not completely override the other value; instead, its face attributes override the face attributes of the lower priority &lt;code&gt;face&lt;/code&gt; property.) If two overlays have the same priority value, and one is nested in the other, then the inner one will prevail over the outer one. If neither is nested in the other then you should not make assumptions about which overlay will prevail.</target>
        </trans-unit>
        <trans-unit id="e73afd850ba19d88fffc870b34d4546ef04a4eba" translate="yes" xml:space="preserve">
          <source>The process ID of the parent process, a number.</source>
          <target state="translated">Идентификатор процесса родительского процесса,номер.</target>
        </trans-unit>
        <trans-unit id="53e1a9ea303ee6836b551778e58f2f51e300eedc" translate="yes" xml:space="preserve">
          <source>The process group ID of the process, a number.</source>
          <target state="translated">Идентификатор группы процесса,номер.</target>
        </trans-unit>
        <trans-unit id="4ccf440991f7f0652996b8ab7560a4dbe5b3aace" translate="yes" xml:space="preserve">
          <source>The process status, as &lt;code&gt;process-status&lt;/code&gt; should return it. This is a Lisp symbol, a cons cell, or a list.</source>
          <target state="translated">The process status, as &lt;code&gt;process-status&lt;/code&gt; should return it. This is a Lisp symbol, a cons cell, or a list.</target>
        </trans-unit>
        <trans-unit id="69ecf0580268b93750c7e889a04309c3293a5f2b" translate="yes" xml:space="preserve">
          <source>The processes are shown in a buffer named</source>
          <target state="translated">Процессы отображаются в буфере с именем</target>
        </trans-unit>
        <trans-unit id="6c8f30c53cf4f4d39e77991527ad73dbc1793851" translate="yes" xml:space="preserve">
          <source>The product name of the server.</source>
          <target state="translated">Название продукта сервера.</target>
        </trans-unit>
        <trans-unit id="0cd39baec68fc236a0a093df363f5e95bd2c4fb6" translate="yes" xml:space="preserve">
          <source>The profiler report buffer shows, on each line, a function that was called, followed by how much resources (cpu or memory) it used in absolute and percentage terms since profiling started. If a given line has a &amp;lsquo;</source>
          <target state="translated">The profiler report buffer shows, on each line, a function that was called, followed by how much resources (cpu or memory) it used in absolute and percentage terms since profiling started. If a given line has a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="d9d8457c45fc52a797df2f33e4e4ba6a34bec404" translate="yes" xml:space="preserve">
          <source>The prompt string can use &amp;lsquo;</source>
          <target state="translated">The prompt string can use &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="0ea085744f883658e286f289c21d5bb3c923b174" translate="yes" xml:space="preserve">
          <source>The proper place to use &lt;code&gt;defalias&lt;/code&gt; is where a specific function name is being defined&amp;mdash;especially where that name appears explicitly in the source file being loaded. This is because &lt;code&gt;defalias&lt;/code&gt; records which file defined the function, just like &lt;code&gt;defun&lt;/code&gt; (see &lt;a href=&quot;unloading#Unloading&quot;&gt;Unloading&lt;/a&gt;).</source>
          <target state="translated">The proper place to use &lt;code&gt;defalias&lt;/code&gt; is where a specific function name is being defined&amp;mdash;especially where that name appears explicitly in the source file being loaded. This is because &lt;code&gt;defalias&lt;/code&gt; records which file defined the function, just like &lt;code&gt;defun&lt;/code&gt; (see &lt;a href=&quot;unloading#Unloading&quot;&gt;Unloading&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="d90fe58bfa2b87a1b1cbc6838a53a60deea67366" translate="yes" xml:space="preserve">
          <source>The proper way to construct a keymap with a parent is to use &lt;code&gt;set-keymap-parent&lt;/code&gt;; if you have code that directly constructs a keymap with a parent, please convert the program to use &lt;code&gt;set-keymap-parent&lt;/code&gt; instead.</source>
          <target state="translated">The proper way to construct a keymap with a parent is to use &lt;code&gt;set-keymap-parent&lt;/code&gt; ; if you have code that directly constructs a keymap with a parent, please convert the program to use &lt;code&gt;set-keymap-parent&lt;/code&gt; instead.</target>
        </trans-unit>
        <trans-unit id="1dfec31a43b4f7ab97faaddb57234977bb256c37" translate="yes" xml:space="preserve">
          <source>The property list cell normally should hold a correctly formatted property list. To get a symbol&amp;rsquo;s property list, use the function &lt;code&gt;symbol-plist&lt;/code&gt;. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;.</source>
          <target state="translated">The property list cell normally should hold a correctly formatted property list. To get a symbol&amp;rsquo;s property list, use the function &lt;code&gt;symbol-plist&lt;/code&gt; . See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c911a8445b3bd7bfea7954dcdd17b841dcbd3fcb" translate="yes" xml:space="preserve">
          <source>The property&amp;rsquo;s value for the character before point applies if it is non-&lt;code&gt;nil&lt;/code&gt; and rear-sticky, and the property&amp;rsquo;s value for the character after point applies if it is non-&lt;code&gt;nil&lt;/code&gt; and front-sticky. (For mouse clicks, the position of the click is used instead of the position of point.)</source>
          <target state="translated">The property&amp;rsquo;s value for the character before point applies if it is non- &lt;code&gt;nil&lt;/code&gt; and rear-sticky, and the property&amp;rsquo;s value for the character after point applies if it is non- &lt;code&gt;nil&lt;/code&gt; and front-sticky. (For mouse clicks, the position of the click is used instead of the position of point.)</target>
        </trans-unit>
        <trans-unit id="78c51406ca787ccde17c730ea362d97d0f2b5d6a" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;throw&lt;/code&gt; is to return from a return point previously established with &lt;code&gt;catch&lt;/code&gt;. The argument &lt;var&gt;tag&lt;/var&gt; is used to choose among the various existing return points; it must be &lt;code&gt;eq&lt;/code&gt; to the value specified in the &lt;code&gt;catch&lt;/code&gt;. If multiple return points match &lt;var&gt;tag&lt;/var&gt;, the innermost one is used.</source>
          <target state="translated">The purpose of &lt;code&gt;throw&lt;/code&gt; is to return from a return point previously established with &lt;code&gt;catch&lt;/code&gt; . The argument &lt;var&gt;tag&lt;/var&gt; is used to choose among the various existing return points; it must be &lt;code&gt;eq&lt;/code&gt; to the value specified in the &lt;code&gt;catch&lt;/code&gt; . If multiple return points match &lt;var&gt;tag&lt;/var&gt; , the innermost one is used.</target>
        </trans-unit>
        <trans-unit id="a798f48d5361b3f20f9b8da5927f51db1ca4bd70" translate="yes" xml:space="preserve">
          <source>The purpose of records is to allow programmers to create objects with new types that are not built into Emacs. They are used as the underlying representation of &lt;code&gt;cl-defstruct&lt;/code&gt; and &lt;code&gt;defclass&lt;/code&gt; instances.</source>
          <target state="translated">The purpose of records is to allow programmers to create objects with new types that are not built into Emacs. They are used as the underlying representation of &lt;code&gt;cl-defstruct&lt;/code&gt; and &lt;code&gt;defclass&lt;/code&gt; instances.</target>
        </trans-unit>
        <trans-unit id="6b48773be77ed3bf897730ad62b02207f496fa84" translate="yes" xml:space="preserve">
          <source>The purpose of this variable is to prevent unreasonably large images from accidentally being loaded into Emacs. It only takes effect the first time an image is loaded. Once an image is placed in the image cache, it can always be displayed, even if the value of &lt;code&gt;max-image-size&lt;/code&gt; is subsequently changed (see &lt;a href=&quot;image-cache#Image-Cache&quot;&gt;Image Cache&lt;/a&gt;).</source>
          <target state="translated">The purpose of this variable is to prevent unreasonably large images from accidentally being loaded into Emacs. It only takes effect the first time an image is loaded. Once an image is placed in the image cache, it can always be displayed, even if the value of &lt;code&gt;max-image-size&lt;/code&gt; is subsequently changed (see &lt;a href=&quot;image-cache#Image-Cache&quot;&gt;Image Cache&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="8b698db8f7ae03128e22b00ae5ae3b89fa737eaf" translate="yes" xml:space="preserve">
          <source>The range of values for a fixnum depends on the machine. The minimum range is -536,870,912 to 536,870,911 (30 bits; i.e., -2**29 to 2**29 - 1) but many machines provide a wider range.</source>
          <target state="translated">Диапазон значений для фиксатора зависит от машины.Минимальный диапазон составляет от -536 870 912 до 536 870 911 (30 бит,т.е.от -2**29 до 2**29-1),но многие машины обеспечивают более широкий диапазон.</target>
        </trans-unit>
        <trans-unit id="af85b0412ddc48c46d5b6e80df88faf36ad2e739" translate="yes" xml:space="preserve">
          <source>The range of values for a fixnum depends on the machine. The minimum range is -536,870,912 to 536,870,911 (30 bits; i.e., -2**29 to 2**29 - 1), but many machines provide a wider range.</source>
          <target state="translated">Диапазон значений для фиксатора зависит от машины.Минимальный диапазон составляет от -536 870 912 до 536 870 911 (30 бит,т.е.от -2**29 до 2**29-1),но многие машины обеспечивают более широкий диапазон.</target>
        </trans-unit>
        <trans-unit id="cce27534771922ba161893777df990814edba95c" translate="yes" xml:space="preserve">
          <source>The range of values for bignums is limited by the amount of main memory, by machine characteristics such as the size of the word used to represent a bignum&amp;rsquo;s exponent, and by the &lt;code&gt;integer-width&lt;/code&gt; variable. These limits are typically much more generous than the limits for fixnums. A bignum is never numerically equal to a fixnum; Emacs always represents an integer in fixnum range as a fixnum, not a bignum.</source>
          <target state="translated">The range of values for bignums is limited by the amount of main memory, by machine characteristics such as the size of the word used to represent a bignum&amp;rsquo;s exponent, and by the &lt;code&gt;integer-width&lt;/code&gt; variable. These limits are typically much more generous than the limits for fixnums. A bignum is never numerically equal to a fixnum; Emacs always represents an integer in fixnum range as a fixnum, not a bignum.</target>
        </trans-unit>
        <trans-unit id="88fcc9a379dd1cc063bcdc17672afd2ddd066644" translate="yes" xml:space="preserve">
          <source>The raw prefix argument value used by the previous command.</source>
          <target state="translated">Значение исходного префикса аргумента,используемого предыдущей командой.</target>
        </trans-unit>
        <trans-unit id="188580ce5aed7a8d00ced05add7b99d84193146d" translate="yes" xml:space="preserve">
          <source>The raw prefix argument. (Note that this &amp;lsquo;</source>
          <target state="translated">The raw prefix argument. (Note that this &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="918eb5fe78ecdeb2b74cf1c707d70d8317c7c8ca" translate="yes" xml:space="preserve">
          <source>The raw process status, as returned by the &lt;code&gt;wait&lt;/code&gt; system call.</source>
          <target state="translated">The raw process status, as returned by the &lt;code&gt;wait&lt;/code&gt; system call.</target>
        </trans-unit>
        <trans-unit id="8d40522328efd69f1813ecc9395f2a99749405bb" translate="yes" xml:space="preserve">
          <source>The read syntax &lt;code&gt;#'&lt;/code&gt; is a short-hand for using &lt;code&gt;function&lt;/code&gt;. The following forms are all equivalent:</source>
          <target state="translated">The read syntax &lt;code&gt;#'&lt;/code&gt; is a short-hand for using &lt;code&gt;function&lt;/code&gt; . The following forms are all equivalent:</target>
        </trans-unit>
        <trans-unit id="f0ccfae7f5d50ab8dd7bf0125292e2e7d92e715d" translate="yes" xml:space="preserve">
          <source>The read syntax and printed representation for lists are identical, and consist of a left parenthesis, an arbitrary number of elements, and a right parenthesis. Here are examples of lists:</source>
          <target state="translated">Прочитанный синтаксис и распечатанное представление для списков идентичны и состоят из левой круглой скобки,произвольного количества элементов и правой круглой скобки.Приведем примеры списков:</target>
        </trans-unit>
        <trans-unit id="699968d5ddfd6c3b251c3bfee7172adb575ecba8" translate="yes" xml:space="preserve">
          <source>The read syntax for a string is a double-quote, an arbitrary number of characters, and another double-quote, &lt;code&gt;&quot;like this&quot;&lt;/code&gt;. To include a double-quote in a string, precede it with a backslash; thus, &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; is a string containing just one double-quote character. Likewise, you can include a backslash by preceding it with another backslash, like this: &lt;code&gt;&quot;this \\ is a single embedded
backslash&quot;&lt;/code&gt;.</source>
          <target state="translated">The read syntax for a string is a double-quote, an arbitrary number of characters, and another double-quote, &lt;code&gt;&quot;like this&quot;&lt;/code&gt; . To include a double-quote in a string, precede it with a backslash; thus, &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; is a string containing just one double-quote character. Likewise, you can include a backslash by preceding it with another backslash, like this: &lt;code&gt;&quot;this \\ is a single embedded backslash&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2db9c5ad71fdc5297e7b04c37c25b525f29392e3" translate="yes" xml:space="preserve">
          <source>The read syntax for floating-point numbers requires either a decimal point, an exponent, or both. Optional signs (&amp;lsquo;</source>
          <target state="translated">Синтаксис чтения для чисел с плавающей запятой требует либо десятичной точки, либо показателя степени, либо того и другого. Необязательные знаки ('</target>
        </trans-unit>
        <trans-unit id="468ea3ba2253c757dfcdac67156c541df702374c" translate="yes" xml:space="preserve">
          <source>The read syntax for integers is a sequence of (base ten) digits with an optional sign at the beginning and an optional period at the end. The printed representation produced by the Lisp interpreter never has a leading &amp;lsquo;</source>
          <target state="translated">Синтаксис чтения для целых чисел представляет собой последовательность (десятичное основание) цифр с необязательным знаком в начале и необязательной точкой в ​​конце. Печатное представление, созданное интерпретатором Лиспа, никогда не имеет ведущего символа '</target>
        </trans-unit>
        <trans-unit id="a0df8f0e56b27b7fdf3f7492d928c4cf0eb4466b" translate="yes" xml:space="preserve">
          <source>The read syntax for meta characters uses &amp;lsquo;</source>
          <target state="translated">Синтаксис чтения для метасимволов использует '</target>
        </trans-unit>
        <trans-unit id="ef7e662450af28ad76f1d8a4260adb6e69ae8a34" translate="yes" xml:space="preserve">
          <source>The reason for a mode to change this variable instead of &lt;code&gt;revert-buffer-function&lt;/code&gt; is to avoid duplicating or replacing the rest of what &lt;code&gt;revert-buffer&lt;/code&gt; does: asking for confirmation, clearing the undo list, deciding the proper major mode, and running the hooks listed below.</source>
          <target state="translated">Причина, по которой режим изменяет эту переменную вместо &lt;code&gt;revert-buffer-function&lt;/code&gt; , состоит в том, чтобы избежать дублирования или замены остальной части того, что делает &lt;code&gt;revert-buffer&lt;/code&gt; : запрос подтверждения, очистка списка отмены, определение правильного основного режима и запуск ловушек перечислено ниже.</target>
        </trans-unit>
        <trans-unit id="4a9fa0be0804d13fd54899e6b26f2ba4d73ac7bd" translate="yes" xml:space="preserve">
          <source>The reason for the name &lt;code&gt;lazy&lt;/code&gt; is that the other composite widgets convert their inferior widgets to internal form when the widget is instantiated in a buffer. This conversion is recursive, so the inferior widgets will convert &lt;em&gt;their&lt;/em&gt; inferior widgets. If the data structure is itself recursive, this conversion is an infinite recursion. The &lt;code&gt;lazy&lt;/code&gt; widget prevents the recursion: it convert its &lt;code&gt;:type&lt;/code&gt; argument only when needed.</source>
          <target state="translated">Причина названия &amp;laquo; &lt;code&gt;lazy&lt;/code&gt; заключается в том, что другие составные виджеты преобразуют свои подчиненные виджеты во внутреннюю форму, когда виджет создается в буфере. Это преобразование является рекурсивным, поэтому подчиненные виджеты будут преобразовывать &lt;em&gt;свои&lt;/em&gt; подчиненные виджеты. Если структура данных сама по себе является рекурсивной, это преобразование является бесконечной рекурсией. &lt;code&gt;lazy&lt;/code&gt; виджет предотвращает рекурсии: он преобразует его &lt;code&gt;:type&lt;/code&gt; аргумента только при необходимости.</target>
        </trans-unit>
        <trans-unit id="97c008ed1abdd793cef86b5d0eab947dc6ccb62d" translate="yes" xml:space="preserve">
          <source>The reason for this somewhat complex behavior is that it lets users easily toggle the minor mode interactively, and also lets the minor mode be easily enabled in a mode hook, like this:</source>
          <target state="translated">Причина такого довольно сложного поведения заключается в том,что оно позволяет пользователям легко интерактивно переключать второстепенный режим,а также позволяет легко включать второстепенный режим с помощью крючка,например,вот так:</target>
        </trans-unit>
        <trans-unit id="ab43773cfe02cb70d41dd331c0415859809fddf1" translate="yes" xml:space="preserve">
          <source>The recommended way to add a hook function to a hook is by calling &lt;code&gt;add-hook&lt;/code&gt; (see &lt;a href=&quot;setting-hooks#Setting-Hooks&quot;&gt;Setting Hooks&lt;/a&gt;). The hook functions may be any of the valid kinds of functions that &lt;code&gt;funcall&lt;/code&gt; accepts (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;). Most normal hook variables are initially void; &lt;code&gt;add-hook&lt;/code&gt; knows how to deal with this. You can add hooks either globally or buffer-locally with &lt;code&gt;add-hook&lt;/code&gt;.</source>
          <target state="translated">Рекомендуемый способ добавить функцию ловушки к ловушке - вызвать &lt;code&gt;add-hook&lt;/code&gt; (см. &lt;a href=&quot;setting-hooks#Setting-Hooks&quot;&gt;Установка ловушек&lt;/a&gt; ). Функции ловушки могут быть любыми из допустимых типов функций, которые принимает &lt;code&gt;funcall&lt;/code&gt; (см. &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;Что такое функция&lt;/a&gt; ). Большинство обычных переменных-ловушек изначально недействительны; &lt;code&gt;add-hook&lt;/code&gt; знает, как с этим бороться. Вы можете добавить хуки глобально или локально в буфер с помощью &lt;code&gt;add-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e72e25c71fad41850c51c81a50b1cd4e2873976c" translate="yes" xml:space="preserve">
          <source>The recommended way to define a new major mode is to derive it from an existing one using &lt;code&gt;define-derived-mode&lt;/code&gt;. If there is no closely related mode, you should inherit from either &lt;code&gt;text-mode&lt;/code&gt;, &lt;code&gt;special-mode&lt;/code&gt;, or &lt;code&gt;prog-mode&lt;/code&gt;. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;. If none of these are suitable, you can inherit from &lt;code&gt;fundamental-mode&lt;/code&gt; (see &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Major Modes&lt;/a&gt;).</source>
          <target state="translated">Рекомендуемый способ определения нового основного режима - это унаследовать его от существующего с помощью &lt;code&gt;define-derived-mode&lt;/code&gt; . Если нет тесно связанного режима, вы должны унаследовать его от &lt;code&gt;text-mode&lt;/code&gt; , &lt;code&gt;special-mode&lt;/code&gt; или &lt;code&gt;prog-mode&lt;/code&gt; . См. &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Основные основные режимы&lt;/a&gt; . Если ни один из них не подходит, вы можете наследовать от &lt;code&gt;fundamental-mode&lt;/code&gt; (см. &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Основные режимы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="55ee00344a022e04c610024dc173a8e737831bfc" translate="yes" xml:space="preserve">
          <source>The recommended way to use this function is to specify a name which fits the conventions of GNU and Unix systems, and pass it to &lt;code&gt;convert-standard-filename&lt;/code&gt;.</source>
          <target state="translated">Рекомендуемый способ использования этой функции - указать имя, которое соответствует соглашениям систем GNU и Unix, и передать его в &lt;code&gt;convert-standard-filename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55eca5446859f2ea52f9e345f8531406554a48b1" translate="yes" xml:space="preserve">
          <source>The redirection lasts until &lt;code&gt;redirect-frame-focus&lt;/code&gt; is called to change it.</source>
          <target state="translated">Перенаправление длится до тех пор, пока для его изменения не будет вызван &lt;code&gt;redirect-frame-focus&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a588fb9e8fcf72cfed3b3eefc36b97e65fb8bbc" translate="yes" xml:space="preserve">
          <source>The reference to &lt;var&gt;variable&lt;/var&gt; must be in the &lt;var&gt;then-form&lt;/var&gt; of the &lt;code&gt;if&lt;/code&gt;, and &lt;var&gt;variable&lt;/var&gt; must appear quoted in the call to &lt;code&gt;boundp&lt;/code&gt;.</source>
          <target state="translated">Ссылка на &lt;var&gt;variable&lt;/var&gt; должна быть в &lt;var&gt;then-form&lt;/var&gt; из &lt;code&gt;if&lt;/code&gt; , и &lt;var&gt;variable&lt;/var&gt; должна появиться цитируемая в вызове &lt;code&gt;boundp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e411de3f279f8655e1e219fed4c21701eca0eed7" translate="yes" xml:space="preserve">
          <source>The references to &lt;code&gt;max&lt;/code&gt; inside the body of the &lt;code&gt;for&lt;/code&gt;, which are supposed to refer to the user&amp;rsquo;s binding of &lt;code&gt;max&lt;/code&gt;, really access the binding made by &lt;code&gt;for&lt;/code&gt;.</source>
          <target state="translated">Ссылки на &lt;code&gt;max&lt;/code&gt; внутри тела &lt;code&gt;for&lt;/code&gt; , которые должны относиться к пользовательской привязке &lt;code&gt;max&lt;/code&gt; , действительно обращаются к привязке, созданной &lt;code&gt;for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5e79117bc2adbb317bdcd941ebc194bbe9e52a9" translate="yes" xml:space="preserve">
          <source>The reformulation demonstrates &lt;var&gt;symbol&lt;/var&gt; binding as well as &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;pred&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">Переформулировка демонстрирует привязку &lt;var&gt;symbol&lt;/var&gt; а также &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;pred&lt;/code&gt; , &lt;code&gt;app&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b316e0a4b7481395ac11f35d1a9f8c1cc3b4cde" translate="yes" xml:space="preserve">
          <source>The relative pixel coordinates of the click. For clicks in the text area of a window, the coordinate origin &lt;code&gt;(0 . 0)&lt;/code&gt; is taken to be the top left corner of the text area. See &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;. For clicks in a mode line, header line or tab line, the coordinate origin is the top left corner of the window itself. For fringes, margins, and the vertical border, &lt;var&gt;x&lt;/var&gt; does not have meaningful data. For fringes and margins, &lt;var&gt;y&lt;/var&gt; is relative to the bottom edge of the header line. In all cases, the &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; coordinates increase rightward and downward respectively.</source>
          <target state="translated">Относительные пиксельные координаты щелчка. Для щелчков в текстовой области окна за начало координат &lt;code&gt;(0 . 0)&lt;/code&gt; берется верхний левый угол текстовой области. См. &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Размеры окон&lt;/a&gt; . Для щелчков в строке режима, строке заголовка или строке табуляции началом координат является верхний левый угол самого окна. Для полос, полей и вертикальной границы &lt;var&gt;x&lt;/var&gt; не имеет значимых данных. Для бахромы и полей &lt;var&gt;y&lt;/var&gt; относительно нижнего края строки заголовка. Во всех случаях координаты &lt;var&gt;x&lt;/var&gt; и &lt;var&gt;y&lt;/var&gt; увеличиваются вправо и вниз соответственно.</target>
        </trans-unit>
        <trans-unit id="6789ca1a5596f585de1cc2056e90783a15f620b8" translate="yes" xml:space="preserve">
          <source>The reliable and easy way to extract events from a key sequence so as to put them in &lt;code&gt;unread-command-events&lt;/code&gt; is to use &lt;code&gt;listify-key-sequence&lt;/code&gt; (see below).</source>
          <target state="translated">Надежный и простой способ извлечь события из ключевой последовательности, чтобы поместить их в &lt;code&gt;unread-command-events&lt;/code&gt; , - это использовать &lt;code&gt;listify-key-sequence&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="6ce491e62987f2bb55f95694ce453e7531e85c7c" translate="yes" xml:space="preserve">
          <source>The remainder of this section covers six hooks that are called during redisplay provided a significant, non-scrolling change of a window has been detected. For simplicity, these hooks and the functions they call will be collectively referred to as &lt;em&gt;window change functions&lt;/em&gt;.</source>
          <target state="translated">Оставшаяся часть этого раздела охватывает шесть перехватчиков, которые вызываются во время повторного отображения при обнаружении значительного изменения окна без прокрутки. Для простоты эти хуки и вызываемые ими функции будут вместе называться &lt;em&gt;функциями изменения окна&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fccefbe9e1b3ac84a03c9262e101056ef8f24db4" translate="yes" xml:space="preserve">
          <source>The remaining arguments (&lt;var&gt;args&lt;/var&gt;) will be passed to the process verbatim. Emacs is not involved in processing file names that are present in &lt;var&gt;args&lt;/var&gt;. To avoid confusion, it may be best to avoid absolute file names in &lt;var&gt;args&lt;/var&gt;, but rather to specify all file names as relative to &lt;code&gt;default-directory&lt;/code&gt;. The function &lt;code&gt;file-relative-name&lt;/code&gt; is useful for constructing such relative file names. Alternatively, you can use &lt;code&gt;file-local-name&lt;/code&gt; (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;) to obtain an absolute file name as seen from the remote host&amp;rsquo;s perspective.</source>
          <target state="translated">Остальные аргументы ( &lt;var&gt;args&lt;/var&gt; ) будут переданы процессу дословно. Emacs не участвует в обработке имен файлов, присутствующих в &lt;var&gt;args&lt;/var&gt; . Чтобы избежать путаницы, может быть лучше избегать абсолютных имен файлов в &lt;var&gt;args&lt;/var&gt; , а вместо этого указывать все имена файлов относительно &lt;code&gt;default-directory&lt;/code&gt; по умолчанию . Функция &lt;code&gt;file-relative-name&lt;/code&gt; полезна для построения таких относительных имен файлов. В качестве альтернативы вы можете использовать &lt;code&gt;file-local-name&lt;/code&gt; (см. &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Волшебные имена файлов&lt;/a&gt; ) для получения абсолютного имени файла, видимого с точки зрения удаленного хоста.</target>
        </trans-unit>
        <trans-unit id="670a4e0596da84e4ab53487725c486bc97b4f1aa" translate="yes" xml:space="preserve">
          <source>The remaining arguments &lt;var&gt;parameters&lt;/var&gt; are keyword/argument pairs that are mainly relevant to encrypted connections:</source>
          <target state="translated">Остальные &lt;var&gt;parameters&lt;/var&gt; аргументов представляют собой пары ключевое слово / аргумент, которые в основном относятся к зашифрованным соединениям:</target>
        </trans-unit>
        <trans-unit id="711c3203fb757fbb6071fddfb4565e07916d99bb" translate="yes" xml:space="preserve">
          <source>The remaining arguments control the rate of echo area updates. The progress reporter will wait for at least &lt;var&gt;min-change&lt;/var&gt; more percents of the operation to be completed before printing next message; the default is one percent. &lt;var&gt;min-time&lt;/var&gt; specifies the minimum time in seconds to pass between successive prints; the default is 0.2 seconds. (On some operating systems, the progress reporter may handle fractions of seconds with varying precision).</source>
          <target state="translated">Остальные аргументы управляют скоростью обновления эхо-области. Перед тем, как печатать следующее сообщение, программа- репортер будет ждать завершения хотя бы &lt;var&gt;min-change&lt;/var&gt; процентов операции; по умолчанию - один процент. &lt;var&gt;min-time&lt;/var&gt; указывает минимальное время в секундах для перехода между последовательными отпечатками; по умолчанию - 0,2 секунды. (В некоторых операционных системах средство отслеживания прогресса может обрабатывать доли секунды с разной точностью).</target>
        </trans-unit>
        <trans-unit id="922b5762bb85df57750f37171cdcbbec00eba4ff" translate="yes" xml:space="preserve">
          <source>The remaining arguments should be the same arguments that might be given to the corresponding I/O primitive. Depending on the primitive, one of those arguments is selected as the &lt;em&gt;target&lt;/em&gt;. For example, if &lt;var&gt;operation&lt;/var&gt; does file I/O, whichever argument specifies the file name is the target. For subprocess primitives, the process name is the target. For &lt;code&gt;open-network-stream&lt;/code&gt;, the target is the service name or port number.</source>
          <target state="translated">Остальные аргументы должны быть теми же аргументами, которые могут быть переданы соответствующему примитиву ввода-вывода. В зависимости от примитива в качестве &lt;em&gt;цели&lt;/em&gt; выбирается один из этих аргументов . Например, если &lt;var&gt;operation&lt;/var&gt; выполняет файловый ввод-вывод, какой бы аргумент ни определял имя файла, является целью. Для примитивов подпроцесса целью является имя процесса. Для &lt;code&gt;open-network-stream&lt;/code&gt; целью является имя службы или номер порта.</target>
        </trans-unit>
        <trans-unit id="3a337a486bdd471460754fa0fdb9252c1ad6a6e1" translate="yes" xml:space="preserve">
          <source>The remaining arguments, &lt;var&gt;args&lt;/var&gt;, are strings that specify command line arguments for the program.</source>
          <target state="translated">Остальные аргументы, &lt;var&gt;args&lt;/var&gt; , представляют собой строки, которые определяют аргументы командной строки для программы.</target>
        </trans-unit>
        <trans-unit id="c5f9c78575e39313d5c394dcec0f4646b698aca7" translate="yes" xml:space="preserve">
          <source>The remaining arguments, &lt;var&gt;args&lt;/var&gt;, are strings that specify command line arguments for the program. Each string is passed to &lt;var&gt;program&lt;/var&gt; as a separate argument.</source>
          <target state="translated">Остальные аргументы, &lt;var&gt;args&lt;/var&gt; , представляют собой строки, которые определяют аргументы командной строки для программы. Каждая строка передается &lt;var&gt;program&lt;/var&gt; как отдельный аргумент.</target>
        </trans-unit>
        <trans-unit id="e63ff1b06b54edf88e3df6de1b60c7d8bc9065cf" translate="yes" xml:space="preserve">
          <source>The remaining arguments, &lt;var&gt;props&lt;/var&gt;, specify additional image properties&amp;mdash;for example,</source>
          <target state="translated">Остальные аргументы, &lt;var&gt;props&lt;/var&gt; , определяют дополнительные свойства изображения, например</target>
        </trans-unit>
        <trans-unit id="fbf07a85ca35fefe0fcea21832b76725d5868901" translate="yes" xml:space="preserve">
          <source>The remaining clauses use core patterns. &lt;code&gt;(pred numberp)&lt;/code&gt; matches if &lt;code&gt;form&lt;/code&gt; is a number. On match, the body evaluates it. &lt;code&gt;(pred symbolp)&lt;/code&gt; matches if &lt;code&gt;form&lt;/code&gt; is a symbol. On match, the body looks up the symbol in &lt;code&gt;env&lt;/code&gt; and returns its association. Finally, &lt;code&gt;_&lt;/code&gt; is the catch-all pattern that matches anything, so it&amp;rsquo;s suitable for reporting syntax errors.</source>
          <target state="translated">В остальных предложениях используются основные шаблоны. &lt;code&gt;(pred numberp)&lt;/code&gt; совпадает, если &lt;code&gt;form&lt;/code&gt; является числом. При совпадении тело оценивает это. &lt;code&gt;(pred symbolp)&lt;/code&gt; соответствует, если &lt;code&gt;form&lt;/code&gt; является символом. При совпадении тело ищет символ в &lt;code&gt;env&lt;/code&gt; и возвращает его ассоциацию. Наконец, &lt;code&gt;_&lt;/code&gt; - это универсальный шаблон, который соответствует чему угодно, поэтому он подходит для сообщения об ошибках синтаксиса.</target>
        </trans-unit>
        <trans-unit id="169a2fbaa470aeea2e4b7eb66378820fbb16842f" translate="yes" xml:space="preserve">
          <source>The remaining elements in &lt;var&gt;menu&lt;/var&gt; are menu items.</source>
          <target state="translated">Остальные элементы в &lt;var&gt;menu&lt;/var&gt; являются пунктами меню.</target>
        </trans-unit>
        <trans-unit id="4e6dd61e2904f012d61dbb3c359b6a7c4039effd" translate="yes" xml:space="preserve">
          <source>The remaining image types that Emacs can support are:</source>
          <target state="translated">Остальные типы изображений,которые Emacs может поддерживать:</target>
        </trans-unit>
        <trans-unit id="66a6e23b71c61a3f987d7762c7e2a5b7599aa9c3" translate="yes" xml:space="preserve">
          <source>The reordering algorithm uses the bidirectional properties of the characters stored as their &lt;code&gt;bidi-class&lt;/code&gt; property (see &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;). Lisp programs can change these properties by calling the &lt;code&gt;put-char-code-property&lt;/code&gt; function. However, doing this requires a thorough understanding of the</source>
          <target state="translated">Алгоритм переупорядочения использует двунаправленные свойства символов, сохраненные как их свойство &lt;code&gt;bidi-class&lt;/code&gt; (см. &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Свойства символа&lt;/a&gt; ). Программы на Лиспе могут изменять эти свойства, вызывая функцию &lt;code&gt;put-char-code-property&lt;/code&gt; . Однако для этого требуется глубокое понимание</target>
        </trans-unit>
        <trans-unit id="0e2760fb3d24d66fd982b8a9de029f1dc2534fb7" translate="yes" xml:space="preserve">
          <source>The replacement buffer in each window is chosen via &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;). Any dedicated window displaying &lt;var&gt;buffer-or-name&lt;/var&gt; is deleted if possible (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;). If such a window is the only window on its frame and there are other frames on the same terminal, the frame is deleted as well. If the dedicated window is the only window on the only frame on its terminal, the buffer is replaced anyway.</source>
          <target state="translated">Буфер замены в каждом окне выбирается с помощью &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (см. &lt;a href=&quot;window-history#Window-History&quot;&gt;История окон&lt;/a&gt; ). Любое выделенное окно, отображающее имя &lt;var&gt;buffer-or-name&lt;/var&gt; по возможности удаляется (см. &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Выделенные окна&lt;/a&gt; ). Если такое окно является единственным окном в своем фрейме и на том же терминале есть другие фреймы, фрейм также удаляется. Если выделенное окно является единственным окном в единственном фрейме на своем терминале, буфер все равно заменяется.</target>
        </trans-unit>
        <trans-unit id="a7bc26f1c46834e48b01bc54d1856ec2c2513fe6" translate="yes" xml:space="preserve">
          <source>The replacement is performed using &lt;code&gt;replace-buffer-contents&lt;/code&gt; (see above) which also describes the &lt;var&gt;max-secs&lt;/var&gt; and &lt;var&gt;max-costs&lt;/var&gt; arguments and the return value.</source>
          <target state="translated">Замена выполняется с помощью &lt;code&gt;replace-buffer-contents&lt;/code&gt; (см. Выше), которая также описывает аргументы &lt;var&gt;max-secs&lt;/var&gt; и &lt;var&gt;max-costs&lt;/var&gt; и возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="ec1321a0692fb6ebcc794193c05c46720ae0b1d2" translate="yes" xml:space="preserve">
          <source>The representation of letters, numbers and control characters.</source>
          <target state="translated">Представление букв,цифр и управляющих символов.</target>
        </trans-unit>
        <trans-unit id="1888fa813111440fef4cca1b17158b44c62b32a0" translate="yes" xml:space="preserve">
          <source>The rest of &lt;var&gt;args&lt;/var&gt; are strings that specify command line arguments for the subprocess.</source>
          <target state="translated">Остальные &lt;var&gt;args&lt;/var&gt; - это строки, которые определяют аргументы командной строки для подпроцесса.</target>
        </trans-unit>
        <trans-unit id="e64cb5cbfa4900b03ef274ea22ff266b957788b6" translate="yes" xml:space="preserve">
          <source>The rest of the elements are the &lt;em&gt;body&lt;/em&gt; of the function: the Lisp code to do the work of the function (or, as a Lisp programmer would say, &amp;ldquo;a list of Lisp forms to evaluate&amp;rdquo;). The value returned by the function is the value returned by the last element of the body.</source>
          <target state="translated">Остальные элементы - это &lt;em&gt;тело&lt;/em&gt; функции: код Лиспа, выполняющий работу функции (или, как сказал бы программист на Лиспе, &amp;laquo;список форм Лиспа для оценки&amp;raquo;). Значение, возвращаемое функцией, - это значение, возвращаемое последним элементом тела.</target>
        </trans-unit>
        <trans-unit id="0d7105d802c517da10dece05da93fcc235f044de" translate="yes" xml:space="preserve">
          <source>The rest of this section describes several kinds of display specifications and what they mean.</source>
          <target state="translated">В остальной части этого раздела описаны несколько видов спецификаций дисплеев и их значение.</target>
        </trans-unit>
        <trans-unit id="75d16b63e700fca272954b8d5c9cbea0eaebf3a4" translate="yes" xml:space="preserve">
          <source>The rest of this subsection describes different forms of core patterns, presents some examples, and concludes with important caveats on using the let-binding facility provided by some pattern forms. A core pattern can have the following forms:</source>
          <target state="translated">В остальной части этого подраздела описаны различные формы основных шаблонов,приведены некоторые примеры,и в заключение даны важные предостережения об использовании привязки,предоставляемой некоторыми формами шаблонов.В качестве основных шаблонов могут использоваться следующие формы:</target>
        </trans-unit>
        <trans-unit id="d3d63b344006851896165eee8891a4b8d2a80cdd" translate="yes" xml:space="preserve">
          <source>The result &lt;var&gt;prevhpos&lt;/var&gt; is the horizontal position one character back from &lt;var&gt;pos&lt;/var&gt;. The result &lt;var&gt;contin&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; if the last line was continued after (or within) the previous character.</source>
          <target state="translated">Результат &lt;var&gt;prevhpos&lt;/var&gt; - это горизонтальная позиция на один символ назад от &lt;var&gt;pos&lt;/var&gt; . Результатом &lt;var&gt;contin&lt;/var&gt; ue является &lt;code&gt;t&lt;/code&gt; , если последняя строка была продолжена после (или внутри) предыдущего символа.</target>
        </trans-unit>
        <trans-unit id="daae51971c3e086b5b343e27b0d5f3425265bcec" translate="yes" xml:space="preserve">
          <source>The result is not &lt;code&gt;(&quot;&quot; &quot;two&quot; &quot;words&quot; &quot;&quot;)&lt;/code&gt;, which would rarely be useful. If you need such a result, use an explicit value for &lt;var&gt;separators&lt;/var&gt;:</source>
          <target state="translated">Результат не будет &lt;code&gt;(&quot;&quot; &quot;two&quot; &quot;words&quot; &quot;&quot;)&lt;/code&gt; , что редко будет полезно. Если вам нужен такой результат, используйте явное значение для &lt;var&gt;separators&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="b472acbf6233b1409a248f2d33fb8eb9ab0e8df6" translate="yes" xml:space="preserve">
          <source>The result must be accurate. The function may need to encode and decode a large part of the buffer, which is expensive and can be slow.</source>
          <target state="translated">Результат должен быть точным.Функция может потребовать кодирования и декодирования большой части буфера,что дорого и может быть медленным.</target>
        </trans-unit>
        <trans-unit id="3fc3ca66f906ee6817d9bc3b5bb03a793a75bf8c" translate="yes" xml:space="preserve">
          <source>The result of encoding is logically a sequence of bytes, but the buffer remains multibyte if it was multibyte before, and any 8-bit bytes are converted to their multibyte representation (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;).</source>
          <target state="translated">Результатом кодирования логически является последовательность байтов, но буфер остается многобайтовым, если до этого он был многобайтовым, и любые 8-битные байты преобразуются в их многобайтовое представление (см. &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Текстовые представления&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c0ac4c7f55c94e4e68eece5bab668740b85fd079" translate="yes" xml:space="preserve">
          <source>The result of encoding, and the input to decoding, are not ordinary text. They logically consist of a series of byte values; that is, a series of</source>
          <target state="translated">Результатом кодирования и ввода для расшифровки является не обычный текст.Логически они состоят из серии значений байтов,то есть из серии</target>
        </trans-unit>
        <trans-unit id="f2f9b59d04c4a67bead42edef8ea82ec9bf8264f" translate="yes" xml:space="preserve">
          <source>The result of evaluating &lt;var&gt;form&lt;/var&gt; determines whether the item is enabled (non-&lt;code&gt;nil&lt;/code&gt; means yes). If the item is not enabled, you can&amp;rsquo;t really click on it.</source>
          <target state="translated">Результат оценки &lt;var&gt;form&lt;/var&gt; определяет, включен ли элемент ( &lt;code&gt;nil&lt;/code&gt; означает да). Если элемент не включен, вы не можете щелкнуть по нему.</target>
        </trans-unit>
        <trans-unit id="0ef7684b6652c1f298625050dc4e7b22d73f9616" translate="yes" xml:space="preserve">
          <source>The result of evaluating &lt;var&gt;form&lt;/var&gt; determines whether the item should actually appear in the menu (non-&lt;code&gt;nil&lt;/code&gt; means yes). If the item does not appear, then the menu is displayed as if this item were not defined at all.</source>
          <target state="translated">Результат оценки &lt;var&gt;form&lt;/var&gt; определяет, должен ли элемент действительно отображаться в меню (отличное от &lt;code&gt;nil&lt;/code&gt; означает да). Если элемент не отображается, то меню отображается так, как если бы этот элемент вообще не был определен.</target>
        </trans-unit>
        <trans-unit id="acbd2ddb72baf0b207a6321fedc1407724073a97" translate="yes" xml:space="preserve">
          <source>The result of this form is &lt;code&gt;t&lt;/code&gt; if it works to specify &lt;var&gt;keyword&lt;/var&gt; with value &lt;var&gt;value&lt;/var&gt; in &lt;code&gt;make-network-process&lt;/code&gt;. Here are some of the &lt;var&gt;keyword&lt;/var&gt;&amp;mdash;&lt;var&gt;value&lt;/var&gt; pairs you can test in this way.</source>
          <target state="translated">Результатом этой формы будет &lt;code&gt;t&lt;/code&gt; , если она работает для указания &lt;var&gt;keyword&lt;/var&gt; со значением &lt;var&gt;value&lt;/var&gt; в &lt;code&gt;make-network-process&lt;/code&gt; . Вот несколько пар &quot; &lt;var&gt;keyword&lt;/var&gt; - &lt;var&gt;value&lt;/var&gt; вы можете протестировать таким образом.</target>
        </trans-unit>
        <trans-unit id="a66be8edbff7bbe7579ce3f3a75abe46a384d47a" translate="yes" xml:space="preserve">
          <source>The result of this macro is the result returned by &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">Результатом этого макроса является результат, возвращаемый &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="27bbea73aa5cdc064da3e057ed92e4ba32abfaad" translate="yes" xml:space="preserve">
          <source>The result of using contradictory flags (for instance, both upper and lower case) is undefined.</source>
          <target state="translated">Результат использования противоречивых флагов (например,как в верхнем,так и в нижнем регистре)неопределен.</target>
        </trans-unit>
        <trans-unit id="46a20d33611240a9e0e5211ef91f6aa318813c3c" translate="yes" xml:space="preserve">
          <source>The resulting mouse position is constrained to the native frame of &lt;var&gt;frame&lt;/var&gt;. If &lt;var&gt;frame&lt;/var&gt; is not visible, this function does nothing. The return value is not significant.</source>
          <target state="translated">Результирующая позиция мыши ограничена собственным фреймом &lt;var&gt;frame&lt;/var&gt; . Если &lt;var&gt;frame&lt;/var&gt; не отображается, эта функция ничего не делает. Возвращаемое значение не имеет значения.</target>
        </trans-unit>
        <trans-unit id="27f056d37a6f909c9875b9547c995c37a964153d" translate="yes" xml:space="preserve">
          <source>The resulting mouse position is not constrained to the native frame of &lt;var&gt;frame&lt;/var&gt;. If &lt;var&gt;frame&lt;/var&gt; is not visible, this function does nothing. The return value is not significant.</source>
          <target state="translated">Результирующее положение мыши не ограничивается собственным фреймом &lt;var&gt;frame&lt;/var&gt; . Если &lt;var&gt;frame&lt;/var&gt; не отображается, эта функция ничего не делает. Возвращаемое значение не имеет значения.</target>
        </trans-unit>
        <trans-unit id="97e907e5a3426231ca925e4df1a09f1c6f27899f" translate="yes" xml:space="preserve">
          <source>The resulting pixel is computed from the color intensity of the color resulting from summing up the RGB values of surrounding pixels, multiplied by the specified factors, and dividing that sum by the sum of the factors&amp;rsquo; absolute values.</source>
          <target state="translated">Результирующий пиксель вычисляется из интенсивности цвета, полученного в результате суммирования значений RGB окружающих пикселей, умножения на указанные коэффициенты и деления этой суммы на сумму абсолютных значений факторов.</target>
        </trans-unit>
        <trans-unit id="a850c2e30c134550ab81c49f18e64cc8581aca70" translate="yes" xml:space="preserve">
          <source>The resulting regexp is preceded by &lt;var&gt;paren&lt;/var&gt; and followed by &amp;lsquo;</source>
          <target state="translated">Результирующему регулярному выражению предшествует &lt;var&gt;paren&lt;/var&gt; за которым следует '</target>
        </trans-unit>
        <trans-unit id="5cb20d9a2af4a08675a28d5ca902bb392372a3c0" translate="yes" xml:space="preserve">
          <source>The resulting regexp is surrounded by &amp;lsquo;</source>
          <target state="translated">Результирующее регулярное выражение заключено в '</target>
        </trans-unit>
        <trans-unit id="75f74b291859bcb8fbacd8a981cca3c5abbd5e9c" translate="yes" xml:space="preserve">
          <source>The return value has the form &lt;code&gt;(&lt;var&gt;left&lt;/var&gt; &lt;var&gt;top&lt;/var&gt; &lt;var&gt;right&lt;/var&gt;
&lt;var&gt;bottom&lt;/var&gt;)&lt;/code&gt;. These list elements are, respectively, the X coordinate of the leftmost column occupied by the window, the Y coordinate of the topmost row, the X coordinate one column to the right of the rightmost column, and the Y coordinate one row down from the bottommost row.</source>
          <target state="translated">Возвращаемое значение имеет форму &lt;code&gt;(&lt;var&gt;left&lt;/var&gt; &lt;var&gt;top&lt;/var&gt; &lt;var&gt;right&lt;/var&gt; &lt;var&gt;bottom&lt;/var&gt;)&lt;/code&gt; . Эти элементы списка представляют собой, соответственно, координату X крайнего левого столбца, занятого окном, координату Y самой верхней строки, координату X на один столбец справа от самого правого столбца и координату Y на одну строку ниже самого нижнего. строка.</target>
        </trans-unit>
        <trans-unit id="d012e9e07ddcadec4d4bdcd9c6d25ee2bd788334" translate="yes" xml:space="preserve">
          <source>The return value includes mode and header line, a horizontal scroll bar and a bottom divider, if any. If &lt;var&gt;window&lt;/var&gt; is an internal window, its pixel height is the pixel height of the screen areas spanned by its children.</source>
          <target state="translated">Возвращаемое значение включает режим и строку заголовка, горизонтальную полосу прокрутки и нижний разделитель, если таковой имеется. Если &lt;var&gt;window&lt;/var&gt; является внутренним окном, его высота в пикселях - это высота в пикселях областей экрана, охватываемых его дочерними элементами.</target>
        </trans-unit>
        <trans-unit id="02435ab528a9d458375ad989e9c07e91ea1d1315" translate="yes" xml:space="preserve">
          <source>The return value includes the fringes and margins of &lt;var&gt;window&lt;/var&gt; as well as any vertical dividers or scroll bars belonging to &lt;var&gt;window&lt;/var&gt;. If &lt;var&gt;window&lt;/var&gt; is an internal window, its pixel width is the width of the screen areas spanned by its children.</source>
          <target state="translated">Возвращаемое значение включает границы и поля &lt;var&gt;window&lt;/var&gt; а также любые вертикальные разделители или полосы прокрутки, принадлежащие &lt;var&gt;window&lt;/var&gt; . Если &lt;var&gt;window&lt;/var&gt; является внутренним окном, его ширина в пикселях - это ширина областей экрана, охватываемых его дочерними элементами.</target>
        </trans-unit>
        <trans-unit id="3a98f39fffcef1b3f518f4676f34cc9b1b32069e" translate="yes" xml:space="preserve">
          <source>The return value indicates the distance traveled. It is an integer that is zero or less.</source>
          <target state="translated">Возвращаемое значение указывает пройденное расстояние.Это целое число,которое равно нулю или меньше.</target>
        </trans-unit>
        <trans-unit id="3fde61c2b5f5d76aef05339847ec2609e0a0f8e5" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;t&lt;/code&gt; if the function actually changed some property&amp;rsquo;s value; &lt;code&gt;nil&lt;/code&gt; otherwise (if &lt;var&gt;props&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or if no character in the specified text had any of those properties).</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;t&lt;/code&gt; , если функция действительно изменила значение некоторого свойства; &lt;code&gt;nil&lt;/code&gt; в противном случае (если &lt;var&gt;props&lt;/var&gt; является &lt;code&gt;nil&lt;/code&gt; , или если ни один символ в указанном тексте не было какой - либо из этих свойств).</target>
        </trans-unit>
        <trans-unit id="90f56f2b19d2b305eccb19f73983ee226bf52495" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;t&lt;/code&gt; if the function actually changed some property&amp;rsquo;s value; &lt;code&gt;nil&lt;/code&gt; otherwise (if &lt;var&gt;props&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or its values agree with those in the text).</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;t&lt;/code&gt; , если функция действительно изменила значение некоторого свойства; &lt;code&gt;nil&lt;/code&gt; противном случае - &lt;code&gt;nil&lt;/code&gt; (если &lt;var&gt;props&lt;/var&gt; равен нулю или его значения соответствуют значениям в тексте).</target>
        </trans-unit>
        <trans-unit id="d966c0a5582546e03dd65e09ce5f5b7511e5eb89" translate="yes" xml:space="preserve">
          <source>The return value is &lt;var&gt;overlay&lt;/var&gt;.</source>
          <target state="translated">Возвращаемое значение - &lt;var&gt;overlay&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c9c05af5fac5434c5acee584935759af38f45178" translate="yes" xml:space="preserve">
          <source>The return value is &lt;var&gt;value&lt;/var&gt; from the chosen alternative.</source>
          <target state="translated">Возвращаемое значение - это &lt;var&gt;value&lt;/var&gt; из выбранной альтернативы.</target>
        </trans-unit>
        <trans-unit id="414de02915422d70149abb88fd20a6bbe77b52b9" translate="yes" xml:space="preserve">
          <source>The return value is a Lisp object that serves as a cookie; you can pass this object as an argument to &lt;code&gt;face-remap-remove-relative&lt;/code&gt; if you need to remove the remapping later.</source>
          <target state="translated">Возвращаемое значение - объект Lisp, который служит файлом cookie; вы можете передать этот объект в качестве аргумента функции &lt;code&gt;face-remap-remove-relative&lt;/code&gt; , если вам потребуется удалить переназначение позже.</target>
        </trans-unit>
        <trans-unit id="640083b382042a0f9ab141b72092b58d3b3db8e7" translate="yes" xml:space="preserve">
          <source>The return value is a decoded time structure.</source>
          <target state="translated">Возвращаемое значение представляет собой декодированную временную структуру.</target>
        </trans-unit>
        <trans-unit id="6948835c6ed35bc81ffd72935c26a9c6a4b01e26" translate="yes" xml:space="preserve">
          <source>The return value is a list of five elements:</source>
          <target state="translated">Возвращаемое значение представляет собой список из пяти элементов:</target>
        </trans-unit>
        <trans-unit id="90615d81da8d652dcb6154d1dc922a071b14b8e3" translate="yes" xml:space="preserve">
          <source>The return value is a list of the form &lt;code&gt;(&lt;var&gt;root&lt;/var&gt; &lt;var&gt;mini&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;root&lt;/var&gt; represents the window tree of the frame&amp;rsquo;s root window, and &lt;var&gt;mini&lt;/var&gt; is the frame&amp;rsquo;s minibuffer window.</source>
          <target state="translated">Возвращаемое значение - это список формы &lt;code&gt;(&lt;var&gt;root&lt;/var&gt; &lt;var&gt;mini&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;root&lt;/var&gt; представляет дерево окон корневого окна фрейма, а &lt;var&gt;mini&lt;/var&gt; - окно минибуфера фрейма.</target>
        </trans-unit>
        <trans-unit id="52c6a1791b31a7b0eaccc6801b2780ff866415de" translate="yes" xml:space="preserve">
          <source>The return value is a triple of the width and the start and end y-coordinates of the largest rectangle that can be inscribed into the empty space (space not displaying any text) of the text area of &lt;var&gt;window&lt;/var&gt;. No x-coordinates are returned by this function&amp;mdash;any such rectangle is assumed to end at the right edge of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s text area. If no empty space can be found, the return value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - это тройная ширина и начальная и конечная координаты y самого большого прямоугольника, который может быть вписан в пустое пространство (пространство, не отображающее никакого текста) текстовой области &lt;var&gt;window&lt;/var&gt; . Эта функция не возвращает x-координаты - предполагается, что любой такой прямоугольник оканчивается на правом краю текстовой области &lt;var&gt;window&lt;/var&gt; . Если пустое пространство не может быть найдено, возвращаемое значение - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e42df57a0cc7d257e5e9f1e666fc7a3621ad67" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение всегда равно &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fc3028050b974b5c5985a3e65b383b27350e24c" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;nil&lt;/code&gt;; to make calls to &lt;code&gt;map-char-table&lt;/code&gt; useful, &lt;var&gt;function&lt;/var&gt; should have side effects. For example, here is how to examine the elements of the syntax table:</source>
          <target state="translated">Возвращаемое значение всегда равно &lt;code&gt;nil&lt;/code&gt; ; чтобы сделать вызовы &lt;code&gt;map-char-table&lt;/code&gt; полезными, &lt;var&gt;function&lt;/var&gt; должна иметь побочные эффекты. Например, вот как исследовать элементы синтаксической таблицы:</target>
        </trans-unit>
        <trans-unit id="6e1ef02d50eb6d3d11a008ae86a182534aaddd6c" translate="yes" xml:space="preserve">
          <source>The return value is like what &lt;code&gt;insert-file-contents&lt;/code&gt; returns: a list of the absolute file name and the length of the data inserted (after conversion).</source>
          <target state="translated">Возвращаемое значение похоже на то, что возвращает &lt;code&gt;insert-file-contents&lt;/code&gt; : список абсолютного имени файла и длины вставленных данных (после преобразования).</target>
        </trans-unit>
        <trans-unit id="1667a16b49f259c48f935a06b46d348e1b7a9a28" translate="yes" xml:space="preserve">
          <source>The return value is never negative. It is zero when no horizontal scrolling has been done in &lt;var&gt;window&lt;/var&gt; (which is usually the case).</source>
          <target state="translated">Возвращаемое значение никогда не бывает отрицательным. Он равен нулю, если в &lt;var&gt;window&lt;/var&gt; не выполнялась горизонтальная прокрутка (что обычно имеет место).</target>
        </trans-unit>
        <trans-unit id="2493392e7fec786dd0b57b9149f6a4de24a60362" translate="yes" xml:space="preserve">
          <source>The return value is the column number actually moved to.</source>
          <target state="translated">Возвращаемое значение-это номер столбца,в который фактически перемещен.</target>
        </trans-unit>
        <trans-unit id="728cf9e0720907dab6445cd97c1a912356f7f43f" translate="yes" xml:space="preserve">
          <source>The return value is the distance traveled, which is a nonnegative integer.</source>
          <target state="translated">Возвращаемое значение-это пройденное расстояние,которое является неотрицательным целым числом.</target>
        </trans-unit>
        <trans-unit id="e8f11031b2e43a095f2b7b7de82a02dfcbe6b156" translate="yes" xml:space="preserve">
          <source>The return value is the matching value from &lt;var&gt;choices&lt;/var&gt;.</source>
          <target state="translated">Возвращаемое значение - это совпадающее значение из &lt;var&gt;choices&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="6d181ed19740d80d79cf1130d7058743bf3e3b57" translate="yes" xml:space="preserve">
          <source>The return value is the new window, &lt;code&gt;nil&lt;/code&gt; when creating that window failed.</source>
          <target state="translated">Возвращаемое значение - новое окно, &lt;code&gt;nil&lt;/code&gt; при ошибке создания этого окна.</target>
        </trans-unit>
        <trans-unit id="f65065166d5e0c6aa1c92410eeb9adf0999014fa" translate="yes" xml:space="preserve">
          <source>The return value is the number of screen lines over which point was moved. The value may be less in absolute value than &lt;var&gt;count&lt;/var&gt; if the beginning or end of the buffer was reached.</source>
          <target state="translated">Возвращаемое значение - количество экранных линий, на которые была перемещена точка. Значение может быть меньше по абсолютной величине, чем &lt;var&gt;count&lt;/var&gt; , если было достигнуто начало или конец буфера.</target>
        </trans-unit>
        <trans-unit id="9d83169f48bfa8d22f5e0a5baa5652dbdd9ad387" translate="yes" xml:space="preserve">
          <source>The return value is the result of this rounding.</source>
          <target state="translated">Возвращаемое значение является результатом этого округления.</target>
        </trans-unit>
        <trans-unit id="a97826aadd65e5acdd8dae2f1cc5f5396c5e9f4d" translate="yes" xml:space="preserve">
          <source>The return value is the same as if you call the low-level parsing function &lt;code&gt;parse-partial-sexp&lt;/code&gt; to parse from the beginning of the visible portion of the buffer to &lt;var&gt;pos&lt;/var&gt; (see &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;Low-Level Parsing&lt;/a&gt;). However, &lt;code&gt;syntax-ppss&lt;/code&gt; uses caches to speed up the computation. Due to this optimization, the second value (previous complete subexpression) and sixth value (minimum parenthesis depth) in the returned parser state are not meaningful.</source>
          <target state="translated">Возвращаемое значение такое же, как если бы вы вызывали функцию &lt;code&gt;parse-partial-sexp&lt;/code&gt; низкого уровня parse-partial-sexp для синтаксического анализа от начала видимой части буфера до &lt;var&gt;pos&lt;/var&gt; (см. &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;Анализ низкого уровня&lt;/a&gt; ). Однако &lt;code&gt;syntax-ppss&lt;/code&gt; использует кеши для ускорения вычислений. Из-за этой оптимизации второе значение (предыдущее полное подвыражение) и шестое значение (минимальная глубина скобок) в возвращенном состоянии синтаксического анализатора не имеют смысла.</target>
        </trans-unit>
        <trans-unit id="e18c940c557733fa2d17296522cd2ee2f382b25f" translate="yes" xml:space="preserve">
          <source>The return value is the total amount of leftward horizontal scrolling in effect after the change&amp;mdash;just like the value returned by &lt;code&gt;window-hscroll&lt;/code&gt; (below).</source>
          <target state="translated">Возвращаемое значение - это общий объем горизонтальной прокрутки влево, действующий после изменения - точно так же, как значение, возвращаемое &lt;code&gt;window-hscroll&lt;/code&gt; (ниже).</target>
        </trans-unit>
        <trans-unit id="d57cd36326fa59864f8c712bddff5dc5bb7f668f" translate="yes" xml:space="preserve">
          <source>The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. The current buffer is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">Возвращаемое значение - это значение последней формы в &lt;var&gt;body&lt;/var&gt; . Текущий буфер восстанавливается даже в случае аварийного выхода из-за &lt;code&gt;throw&lt;/code&gt; или ошибки (см. &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Нелокальные выходы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eb0d4689de602d882bfebd89386a5243b7f33720" translate="yes" xml:space="preserve">
          <source>The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. You can return the contents of the temporary buffer by using &lt;code&gt;(buffer-string)&lt;/code&gt; as the last form.</source>
          <target state="translated">Возвращаемое значение - это значение последней формы в &lt;var&gt;body&lt;/var&gt; . Вы можете вернуть содержимое временного буфера, используя &lt;code&gt;(buffer-string)&lt;/code&gt; в качестве последней формы.</target>
        </trans-unit>
        <trans-unit id="98b96176f1db00d3485afd4a66e4aa0f4d04fd5e" translate="yes" xml:space="preserve">
          <source>The return value makes sure that all components of &lt;var&gt;window&lt;/var&gt; remain fully visible if &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s size were actually set to it. With &lt;var&gt;horizontal&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt; it includes the mode and header line, the horizontal scroll bar and the bottom divider, if present. With &lt;var&gt;horizontal&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; it includes the margins and fringes, the vertical scroll bar and the right divider, if present.</source>
          <target state="translated">Возвращаемое значение гарантирует, что все компоненты &lt;var&gt;window&lt;/var&gt; остаются полностью видимыми, если размер &lt;var&gt;window&lt;/var&gt; действительно установлен на это. С &lt;var&gt;horizontal&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; он включает в себя режим и строку заголовка, горизонтальную полосу прокрутки и нижний разделитель, если он есть. При &lt;var&gt;horizontal&lt;/var&gt; ненулевом &lt;code&gt;nil&lt;/code&gt; он включает поля и полосы, вертикальную полосу прокрутки и правый разделитель, если он есть.</target>
        </trans-unit>
        <trans-unit id="56acd2a554fb8715a71ba301e194647feef1c650" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;call-process-region&lt;/code&gt; is just like that of &lt;code&gt;call-process&lt;/code&gt;: &lt;code&gt;nil&lt;/code&gt; if you told it to return without waiting; otherwise, a number or string which indicates how the subprocess terminated.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;call-process-region&lt;/code&gt; такое же, как и &lt;code&gt;call-process&lt;/code&gt; : &lt;code&gt;nil&lt;/code&gt; , если вы приказали ему вернуться без ожидания; в противном случае - число или строка, указывающая, как завершился подпроцесс.</target>
        </trans-unit>
        <trans-unit id="5069facca425b351b86dde2c2ae0c0771e388177" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;completion-table-dynamic&lt;/code&gt; is a function that can be used as the 2nd argument to &lt;code&gt;try-completion&lt;/code&gt; and &lt;code&gt;all-completions&lt;/code&gt;. Note that this function will always return empty metadata and trivial boundaries (see &lt;a href=&quot;#Programmed-Completion&quot;&gt;Programmed Completion&lt;/a&gt;).</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;completion-table-dynamic&lt;/code&gt; - это функция, которую можно использовать как второй аргумент для &lt;code&gt;try-completion&lt;/code&gt; s и &lt;code&gt;all-completions&lt;/code&gt; . Обратите внимание, что эта функция всегда будет возвращать пустые метаданные и тривиальные границы (см. &lt;a href=&quot;#Programmed-Completion&quot;&gt;Запрограммированное завершение&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eb1115fc8b41440862e5616560ee61c6930b3d4e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;defun&lt;/code&gt; is undefined.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;defun&lt;/code&gt; не определено.</target>
        </trans-unit>
        <trans-unit id="a22f1787f8edaffd1df1c076115e598858217063" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;indent-relative&lt;/code&gt; is unpredictable.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;indent-relative&lt;/code&gt; непредсказуемо.</target>
        </trans-unit>
        <trans-unit id="40830d574522cf348ebff2db025053eb30711de0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;map-y-or-n-p&lt;/code&gt; is the number of objects acted on.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;map-y-or-n-p&lt;/code&gt; - это количество объектов, над которыми действовали.</target>
        </trans-unit>
        <trans-unit id="bcb50cbd862df1ce6221c36f84f21509e97f8fb8" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;momentary-string-display&lt;/code&gt; is not meaningful.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;momentary-string-display&lt;/code&gt; не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="ee4347aba22a42b7519b85d2086502c660164bde" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;translate-region&lt;/code&gt; is the number of characters that were actually changed by the translation. This does not count characters that were mapped into themselves in the translation table.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;translate-region&lt;/code&gt; - это количество символов, которые были фактически изменены переводом. При этом не учитываются символы, которые были сопоставлены сами с собой в таблице перевода.</target>
        </trans-unit>
        <trans-unit id="ccc82eb191bcbf19332876523e72f6c383beea99" translate="yes" xml:space="preserve">
          <source>The return value of this function is &lt;code&gt;t&lt;/code&gt; if the text would be completely hidden on display, or a non-&lt;code&gt;nil&lt;/code&gt;, non-&lt;code&gt;t&lt;/code&gt; value if the text would be replaced by an ellipsis.</source>
          <target state="translated">Возвращаемое значение этой функции - &lt;code&gt;t&lt;/code&gt; , если текст будет полностью скрыт на дисплее, или &lt;code&gt;nil&lt;/code&gt; , отличное от &lt;code&gt;t&lt;/code&gt; , если текст будет заменен многоточием.</target>
        </trans-unit>
        <trans-unit id="43b0ec1a11637964920ecb2540843fb9ed801524" translate="yes" xml:space="preserve">
          <source>The return value of this function. If omitted or &lt;code&gt;nil&lt;/code&gt;, return a process object. Otherwise, a cons of the form &lt;code&gt;(&lt;var&gt;process-object&lt;/var&gt;
. &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;plist&lt;/var&gt; has keywords:</source>
          <target state="translated">Возвращаемое значение этой функции. Если опущено или &lt;code&gt;nil&lt;/code&gt; , вернуть объект процесса. В противном случае, минусы формы &lt;code&gt;(&lt;var&gt;process-object&lt;/var&gt; . &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; , где в &lt;var&gt;plist&lt;/var&gt; есть ключевые слова:</target>
        </trans-unit>
        <trans-unit id="6b902298331d5acafbc78a6a866439d8f418148b" translate="yes" xml:space="preserve">
          <source>The returned &lt;em&gt;prec2&lt;/em&gt; table holds constraints between pairs of tokens, and for any given pair only one constraint can be present: T1 &amp;lt; T2, T1 = T2, or T1 &amp;gt; T2.</source>
          <target state="translated">Возвращается &lt;em&gt;prec2&lt;/em&gt; таблица содержит ограничений между парами маркеров, и для любой данной пары только одно ограничение может присутствовать: Т1 &amp;lt;Т2, Т1 = Т2, или T1&amp;gt; T2.</target>
        </trans-unit>
        <trans-unit id="dbc5dc6672398dd058c6b4f7b7fadc842548ff7b" translate="yes" xml:space="preserve">
          <source>The returned event may come directly from the user, or from a keyboard macro. It is not decoded by the keyboard&amp;rsquo;s input coding system (see &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;Terminal I/O Encoding&lt;/a&gt;).</source>
          <target state="translated">Возвращаемое событие может исходить непосредственно от пользователя или из макроса клавиатуры. Он не декодируется системой кодирования ввода клавиатуры (см. &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;Кодирование ввода / вывода терминала&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4cdf1e97bec67e330632316ef5395fcf7caf2e12" translate="yes" xml:space="preserve">
          <source>The returned regexp is ordered in such a way that it will always match the longest string possible.</source>
          <target state="translated">Возвращаемый регеxp заказывается таким образом,чтобы он всегда совпадал с самой длинной строкой.</target>
        </trans-unit>
        <trans-unit id="efdbd6df6dfdf2a517533221caa6311ed4d1e39a" translate="yes" xml:space="preserve">
          <source>The returned string may be &lt;var&gt;string&lt;/var&gt; itself if it does not contain any special characters.</source>
          <target state="translated">Возвращенная строка может быть самой &lt;var&gt;string&lt;/var&gt; , если она не содержит специальных символов.</target>
        </trans-unit>
        <trans-unit id="fd9bc80d26777c7e0a2a7afa6c8e55fbe066df53" translate="yes" xml:space="preserve">
          <source>The returned value is a descriptor for the added watch. Its type depends on the underlying library, it cannot be assumed to be an integer as in the example below. It should be used for comparison by &lt;code&gt;equal&lt;/code&gt; only.</source>
          <target state="translated">Возвращаемое значение является дескриптором добавленных часов. Его тип зависит от базовой библиотеки, его нельзя считать целым числом, как в примере ниже. Она должна использоваться для сравнения на &lt;code&gt;equal&lt;/code&gt; только.</target>
        </trans-unit>
        <trans-unit id="5526f73a053a966e99ef6b773d23afe60ad9d26c" translate="yes" xml:space="preserve">
          <source>The returned value is a string.</source>
          <target state="translated">Возвращаемое значение-строка.</target>
        </trans-unit>
        <trans-unit id="265dcc02f70278df1fa86f8ca9c808c95d187ef5" translate="yes" xml:space="preserve">
          <source>The returned value is unpredictable.</source>
          <target state="translated">Возвращаемое значение непредсказуемо.</target>
        </trans-unit>
        <trans-unit id="d67d7a62afb4deb22a1a4750f3d9471f23d28534" translate="yes" xml:space="preserve">
          <source>The right way to use this variable is to bind it with &lt;code&gt;let&lt;/code&gt; for a specific I/O operation. Its global value is normally &lt;code&gt;nil&lt;/code&gt;, and you should not globally set it to any other value. Here is an example of the right way to use the variable:</source>
          <target state="translated">Правильный способ использования этой переменной - связать ее с &lt;code&gt;let&lt;/code&gt; для конкретной операции ввода-вывода. Его глобальное значение обычно равно &lt;code&gt;nil&lt;/code&gt; , и вы не должны глобально устанавливать для него какое-либо другое значение. Вот пример правильного использования переменной:</target>
        </trans-unit>
        <trans-unit id="39952ca9e7a27cc76fd0f660398052f252830c23" translate="yes" xml:space="preserve">
          <source>The root window of this frame is an internal window, &lt;var&gt;W1&lt;/var&gt;. Its child windows form a horizontal combination, consisting of the live window &lt;var&gt;W2&lt;/var&gt; and the internal window &lt;var&gt;W3&lt;/var&gt;. The child windows of &lt;var&gt;W3&lt;/var&gt; form a vertical combination, consisting of the live windows &lt;var&gt;W4&lt;/var&gt; and &lt;var&gt;W5&lt;/var&gt;. Hence, the live windows in this window tree are &lt;var&gt;W2&lt;/var&gt;, &lt;var&gt;W4&lt;/var&gt;, and &lt;var&gt;W5&lt;/var&gt;.</source>
          <target state="translated">Корневым окном этого фрейма является внутреннее окно &lt;var&gt;W1&lt;/var&gt; . Его дочерние окна образуют горизонтальную комбинацию, состоящую из окна живых изображений &lt;var&gt;W2&lt;/var&gt; и внутреннего окна &lt;var&gt;W3&lt;/var&gt; . Дочерние окна &lt;var&gt;W3&lt;/var&gt; образуют вертикальную комбинацию, состоящую из живых окон &lt;var&gt;W4&lt;/var&gt; и &lt;var&gt;W5&lt;/var&gt; . Следовательно, окна реального времени в этом дереве окон - это &lt;var&gt;W2&lt;/var&gt; , &lt;var&gt;W4&lt;/var&gt; и &lt;var&gt;W5&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="814d3881be5a72669b9ab4a2a2237b0156c64c15" translate="yes" xml:space="preserve">
          <source>The rule for finding the binding of a key sequence assumes that the intermediate bindings (found for the events before the last) are all keymaps; if this is not so, the sequence of events does not form a unit&amp;mdash;it is not really one key sequence. In other words, removing one or more events from the end of any valid key sequence must always yield a prefix key. For example,</source>
          <target state="translated">Правило нахождения привязки ключевой последовательности предполагает, что все промежуточные привязки (найденные для событий перед последним) представляют собой таблицы клавиш; если это не так, последовательность событий не образует единое целое - на самом деле это не одна ключевая последовательность. Другими словами, удаление одного или нескольких событий из конца любой допустимой последовательности ключей всегда должно давать префиксный ключ. Например,</target>
        </trans-unit>
        <trans-unit id="2122fb4e21ddd11686b2348d982b3ec0119e1727" translate="yes" xml:space="preserve">
          <source>The rule for indentation after &lt;code&gt;&quot;:=&quot;&lt;/code&gt; exists because otherwise SMIE would treat &lt;code&gt;&quot;:=&quot;&lt;/code&gt; as an infix operator and would align the right argument with the left one.</source>
          <target state="translated">Правило для отступа после &lt;code&gt;&quot;:=&quot;&lt;/code&gt; существует, потому что в противном случае SMIE будет рассматривать &lt;code&gt;&quot;:=&quot;&lt;/code&gt; как инфиксный оператор и выровнять правый аргумент с левым.</target>
        </trans-unit>
        <trans-unit id="37f434c4f0270c5122c827e81b52b88938539dd1" translate="yes" xml:space="preserve">
          <source>The rule for indentation before &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is an example of the use of virtual indentation: This rule is used only when &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is hanging, which can happen only when &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is not at the beginning of a line. So this is not used when indenting &lt;code&gt;&quot;begin&quot;&lt;/code&gt; itself but only when indenting something relative to this &lt;code&gt;&quot;begin&quot;&lt;/code&gt;. Concretely, this rule changes the indentation from:</source>
          <target state="translated">Правило для отступа перед словом &lt;code&gt;&quot;begin&quot;&lt;/code&gt; является примером использования виртуального отступа: это правило используется только тогда, когда &lt;code&gt;&quot;begin&quot;&lt;/code&gt; зависает, что может произойти только тогда, когда &lt;code&gt;&quot;begin&quot;&lt;/code&gt; не находится в начале строки. Таким образом, это не используется, когда отступ &lt;code&gt;&quot;begin&quot;&lt;/code&gt; сам по себе, а только когда отступ чего-либо относительно этого &lt;code&gt;&quot;begin&quot;&lt;/code&gt; . Конкретно это правило изменяет отступ с:</target>
        </trans-unit>
        <trans-unit id="d2ae301bb08cbc756929fb8516392dcfbc907e46" translate="yes" xml:space="preserve">
          <source>The rule for indentation before &lt;code&gt;&quot;if&quot;&lt;/code&gt; is similar to the one for &lt;code&gt;&quot;begin&quot;&lt;/code&gt;, but where the purpose is to treat &lt;code&gt;&quot;else if&quot;&lt;/code&gt; as a single unit, so as to align a sequence of tests rather than indent each test further to the right. This function does this only in the case where the &lt;code&gt;&quot;if&quot;&lt;/code&gt; is not placed on a separate line, hence the &lt;code&gt;smie-rule-bolp&lt;/code&gt; test.</source>
          <target state="translated">Правило для отступа перед &lt;code&gt;&quot;if&quot;&lt;/code&gt; аналогично правилу для &lt;code&gt;&quot;begin&quot;&lt;/code&gt; , но его цель состоит в том, чтобы рассматривать &lt;code&gt;&quot;else if&quot;&lt;/code&gt; как единую единицу, чтобы выровнять последовательность тестов, а не делать отступ каждого теста дальше правильно. Эта функция делает это только в том случае, если &lt;code&gt;&quot;if&quot;&lt;/code&gt; не помещается в отдельную строку, отсюда и &lt;code&gt;smie-rule-bolp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e51195c9e4bef9ac5fed369ac13d21d4ecbb83d" translate="yes" xml:space="preserve">
          <source>The rule for the token &lt;code&gt;&quot;,&quot;&lt;/code&gt; make SMIE try to be more clever when the comma separator is placed at the beginning of lines. It tries to outdent the separator so as to align the code after the comma; for example:</source>
          <target state="translated">Правило для токена &lt;code&gt;&quot;,&quot;&lt;/code&gt; заставляет SMIE пытаться быть более умным, когда разделитель запятой ставится в начале строк. Он пытается выйти за пределы разделителя, чтобы выровнять код после запятой; например:</target>
        </trans-unit>
        <trans-unit id="2ea9d036c2f0944a227079154b59cbdc7f4c6f40" translate="yes" xml:space="preserve">
          <source>The rx Structured Regexp Notation</source>
          <target state="translated">Структурированная регэкспресс-нотация.</target>
        </trans-unit>
        <trans-unit id="b8ef342720c667ded9bb4a10754ff3f59b3c59dd" translate="yes" xml:space="preserve">
          <source>The safe value definitions specified with &lt;code&gt;autoload&lt;/code&gt; are copied into the package&amp;rsquo;s autoloads file (</source>
          <target state="translated">Определения безопасных значений, указанные с помощью &lt;code&gt;autoload&lt;/code&gt; , копируются в файл автозагрузки пакета (</target>
        </trans-unit>
        <trans-unit id="3d3cd8e2cc092de1d198d6e2528520fe0e19f022" translate="yes" xml:space="preserve">
          <source>The same alist shown above could be regarded as having the associated value in the &lt;small&gt;CDR&lt;/small&gt; of the element; the value associated with &lt;code&gt;rose&lt;/code&gt; would be the list &lt;code&gt;(red)&lt;/code&gt;.</source>
          <target state="translated">Тот же список, показанный выше, можно рассматривать как имеющий ассоциированное значение в &lt;small&gt;CDR&lt;/small&gt; элемента; значение, связанное с &lt;code&gt;rose&lt;/code&gt; будет списком &lt;code&gt;(red)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b598a52d532ebb9508666d7703290c6b51b2a77" translate="yes" xml:space="preserve">
          <source>The same comparison is made for the characters before the old and new locations. The result may be to execute two &lt;code&gt;point-left&lt;/code&gt; functions (which may be the same function) and/or two &lt;code&gt;point-entered&lt;/code&gt; functions (which may be the same function). In any case, all the &lt;code&gt;point-left&lt;/code&gt; functions are called first, followed by all the &lt;code&gt;point-entered&lt;/code&gt; functions.</source>
          <target state="translated">Такое же сравнение проводится для персонажей до старой и новой локаций. Результатом может быть выполнение двух функций &amp;laquo; &lt;code&gt;point-left&lt;/code&gt; (которые могут быть одной и той же функцией) и / или двух функций, &lt;code&gt;point-entered&lt;/code&gt; (которые могут быть одной и той же функцией). В любом случае сначала вызываются все функции &lt;code&gt;point-left&lt;/code&gt; , а затем все функции, &lt;code&gt;point-entered&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76be1f3a5b9d85ac92db6757c8aa658e4c83550f" translate="yes" xml:space="preserve">
          <source>The same list represented in the second box notation looks like this:</source>
          <target state="translated">Тот же самый список,представленный во второй бокс-нотации,выглядит так:</target>
        </trans-unit>
        <trans-unit id="de2afa602b0c6c3641bec0bd9db4c0990c1cd810" translate="yes" xml:space="preserve">
          <source>The same magic comment can copy any kind of form into</source>
          <target state="translated">Один и тот же магический комментарий может скопировать любую форму в</target>
        </trans-unit>
        <trans-unit id="4a6fb3f7c0f51bfade6342cfbde9264dd003c537" translate="yes" xml:space="preserve">
          <source>The same sort of thing goes for macros and &lt;code&gt;defsubst&lt;/code&gt; functions defined locally and only for use within the file. They are needed for compiling the file, but in most cases they are not needed for execution of the compiled file. For example,</source>
          <target state="translated">То же самое касается макросов и функций &lt;code&gt;defsubst&lt;/code&gt; , определенных локально и только для использования в файле. Они нужны для компиляции файла, но в большинстве случаев не нужны для выполнения скомпилированного файла. Например,</target>
        </trans-unit>
        <trans-unit id="9eafcd90784684c4b6941c5a7e212f4389f29375" translate="yes" xml:space="preserve">
          <source>The scope of the &lt;code&gt;rx-let&lt;/code&gt; bindings is lexical, which means that they are not visible outside &lt;var&gt;body&lt;/var&gt; itself, even in functions called from &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">Область привязки &lt;code&gt;rx-let&lt;/code&gt; является лексической, что означает, что они не видны вне &lt;var&gt;body&lt;/var&gt; , даже в функциях, вызываемых из &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b2fa435053db7e98e5d129031c4eef40310ac931" translate="yes" xml:space="preserve">
          <source>The screen position of the left edge of the frame&amp;rsquo;s icon, in pixels, counting from the left edge of the screen. This takes effect when the frame is iconified, if the window manager supports this feature. If you specify a value for this parameter, then you must also specify a value for &lt;code&gt;icon-top&lt;/code&gt; and vice versa.</source>
          <target state="translated">Положение левого края значка кадра на экране в пикселях, считая от левого края экрана. Это вступает в силу, когда фрейм отображается в виде значка, если оконный менеджер поддерживает эту функцию. Если вы указываете значение для этого параметра, вы также должны указать значение для &lt;code&gt;icon-top&lt;/code&gt; и наоборот.</target>
        </trans-unit>
        <trans-unit id="e50e923623c82eb23aa190894066a65503358e35" translate="yes" xml:space="preserve">
          <source>The screen position of the top (or bottom) edge, in pixels, with respect to the top (or bottom) edge of the display or parent frame. It works just like &lt;code&gt;left&lt;/code&gt;, except vertically instead of horizontally.</source>
          <target state="translated">Положение верхнего (или нижнего) края экрана в пикселях относительно верхнего (или нижнего) края дисплея или родительского кадра. Он работает так же, как &lt;code&gt;left&lt;/code&gt; , за исключением вертикального, а не горизонтального.</target>
        </trans-unit>
        <trans-unit id="0cda3076dfbc17092f6e7b4b160ef022e7169a19" translate="yes" xml:space="preserve">
          <source>The screen position of the top edge of the frame&amp;rsquo;s icon, in pixels, counting from the top edge of the screen. This takes effect when the frame is iconified, if the window manager supports this feature.</source>
          <target state="translated">Положение верхнего края значка кадра на экране в пикселях, считая от верхнего края экрана. Это вступает в силу, когда фрейм отображается в виде значка, если оконный менеджер поддерживает эту функцию.</target>
        </trans-unit>
        <trans-unit id="e751536ab732a9f489e9afb199afec619dbdde42" translate="yes" xml:space="preserve">
          <source>The script that the font must support (a symbol).</source>
          <target state="translated">Сценарий,который шрифт должен поддерживать (символ).</target>
        </trans-unit>
        <trans-unit id="5ca4bb9976c740ecc0981b8e9b17319d5ac9d81d" translate="yes" xml:space="preserve">
          <source>The search for an applicable handler checks all the established handlers starting with the most recently established one. Thus, if two nested &lt;code&gt;condition-case&lt;/code&gt; forms offer to handle the same error, the inner of the two gets to handle it.</source>
          <target state="translated">Поиск подходящего обработчика проверяет все установленные обработчики, начиная с самого последнего установленного. Таким образом, если две вложенные формы &lt;code&gt;condition-case&lt;/code&gt; предлагают обработать одну и ту же ошибку, внутренняя из двух форм сможет ее обработать.</target>
        </trans-unit>
        <trans-unit id="473e360900bfeca8b04b8a805f75bfd348f74028" translate="yes" xml:space="preserve">
          <source>The second argument &lt;var&gt;infile&lt;/var&gt; may invoke a file name handler. The file name handler could be different from the handler chosen for the &lt;code&gt;process-file&lt;/code&gt; function itself. (For example, &lt;code&gt;default-directory&lt;/code&gt; could be on one remote host, and &lt;var&gt;infile&lt;/var&gt; on a different remote host. Or &lt;code&gt;default-directory&lt;/code&gt; could be non-special, whereas &lt;var&gt;infile&lt;/var&gt; is on a remote host.)</source>
          <target state="translated">Второй аргумент &lt;var&gt;infile&lt;/var&gt; может вызывать обработчик имени файла. Обработчик имени файла может отличаться от обработчика, выбранного для самой функции &lt;code&gt;process-file&lt;/code&gt; . (Например, &lt;code&gt;default-directory&lt;/code&gt; может находиться на одном удаленном хосте, а &lt;var&gt;infile&lt;/var&gt; - на другом удаленном хосте. Или &lt;code&gt;default-directory&lt;/code&gt; может быть &lt;var&gt;infile&lt;/var&gt; , тогда как infile находится на удаленном хосте.)</target>
        </trans-unit>
        <trans-unit id="79312a7cce37d37bed367239a38284f2028a8f95" translate="yes" xml:space="preserve">
          <source>The second argument &lt;var&gt;size&lt;/var&gt; is the size of text, in characters, following point. The function examines text only within &lt;var&gt;size&lt;/var&gt; characters after point. Normally, the buffer should be positioned at the beginning when this function is called, because one of the places for the &lt;code&gt;coding:&lt;/code&gt; tag is the first one or two lines of the file; in that case, &lt;var&gt;size&lt;/var&gt; should be the size of the buffer.</source>
          <target state="translated">Второй аргумент &lt;var&gt;size&lt;/var&gt; - это размер текста в символах после точки. Функция проверяет текст только в пределах &lt;var&gt;size&lt;/var&gt; символов после точки. Обычно при вызове этой функции буфер должен располагаться в начале, потому что одно из мест для тега &lt;code&gt;coding:&lt;/code&gt; - это первые одна или две строки файла; в этом случае &lt;var&gt;size&lt;/var&gt; должен быть размером с буфер.</target>
        </trans-unit>
        <trans-unit id="b1571642b672d840c71b1f3b7f58f82da1c8dc26" translate="yes" xml:space="preserve">
          <source>The second argument of &lt;code&gt;condition-case&lt;/code&gt; is called the &lt;em&gt;protected form&lt;/em&gt;. (In the example above, the protected form is a call to &lt;code&gt;delete-file&lt;/code&gt;.) The error handlers go into effect when this form begins execution and are deactivated when this form returns. They remain in effect for all the intervening time. In particular, they are in effect during the execution of functions called by this form, in their subroutines, and so on. This is a good thing, since, strictly speaking, errors can be signaled only by Lisp primitives (including &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;) called by the protected form, not by the protected form itself.</source>
          <target state="translated">Второй аргумент &lt;code&gt;condition-case&lt;/code&gt; называется &lt;em&gt;защищенной формой&lt;/em&gt; . (В приведенном выше примере защищенная форма - это вызов &lt;code&gt;delete-file&lt;/code&gt; .) Обработчики ошибок вступают в силу, когда эта форма начинает выполнение, и деактивируются, когда эта форма возвращается. Они остаются в силе все время. В частности, они действуют во время выполнения функций, вызываемых этой формой, в их подпрограммах и т. Д. Это хорошо, поскольку, строго говоря, об ошибках могут сигнализировать только примитивы Лиспа (включая &lt;code&gt;signal&lt;/code&gt; и &lt;code&gt;error&lt;/code&gt; ), вызываемые защищенной формой, а не самой защищенной формой.</target>
        </trans-unit>
        <trans-unit id="335d04a9fb11a0984d4c4b395642d49eb8062099" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;var&gt;minibuf&lt;/var&gt;, says which frames to consider:</source>
          <target state="translated">Второй аргумент, &lt;var&gt;minibuf&lt;/var&gt; , говорит, какие кадры следует учитывать:</target>
        </trans-unit>
        <trans-unit id="043e175330e7a9266b5fd9e72aad0ac9c4f497a2" translate="yes" xml:space="preserve">
          <source>The second cons cell, which previously held the element &lt;code&gt;b&lt;/code&gt;, still exists and its &lt;small&gt;CAR&lt;/small&gt; is still &lt;code&gt;b&lt;/code&gt;, but it no longer forms part of this list.</source>
          <target state="translated">Вторая cons-ячейка, которая ранее содержала элемент &lt;code&gt;b&lt;/code&gt; , все еще существует, и ее &lt;small&gt;CAR&lt;/small&gt; по-прежнему &lt;code&gt;b&lt;/code&gt; , но она больше не является частью этого списка.</target>
        </trans-unit>
        <trans-unit id="cc4971cc83ebc92e997f73e4a1271f23051fec45" translate="yes" xml:space="preserve">
          <source>The second crucial difference between macros and functions is that the value returned by the macro body is an alternate Lisp expression, also known as the &lt;em&gt;expansion&lt;/em&gt; of the macro. The Lisp interpreter proceeds to evaluate the expansion as soon as it comes back from the macro.</source>
          <target state="translated">Второе важное различие между макросами и функциями заключается в том, что значение, возвращаемое телом макроса, является альтернативным выражением Лиспа, также известным как &lt;em&gt;раскрытие&lt;/em&gt; макроса. Интерпретатор Лиспа приступает к оценке расширения, как только оно возвращается из макроса.</target>
        </trans-unit>
        <trans-unit id="f1a6950eaae19621908380f623f25ce6e57c63a4" translate="yes" xml:space="preserve">
          <source>The second element is a list of symbols&amp;mdash;the argument variable names. This is called the &lt;em&gt;lambda list&lt;/em&gt;. When a Lisp function is called, the argument values are matched up against the variables in the lambda list, which are given local bindings with the values provided. See &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;.</source>
          <target state="translated">Второй элемент - это список символов - имен переменных аргументов. Это называется &lt;em&gt;лямбда-списком&lt;/em&gt; . Когда вызывается функция Lisp, значения аргументов сопоставляются с переменными в лямбда-списке, которым присваиваются локальные привязки с предоставленными значениями. См. &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Локальные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca40c0325b239bb969d90b6c5d596d17aee4f342" translate="yes" xml:space="preserve">
          <source>The second element, &lt;var&gt;keywords-only&lt;/var&gt;, specifies the value of the variable &lt;code&gt;font-lock-keywords-only&lt;/code&gt;. If this is omitted or &lt;code&gt;nil&lt;/code&gt;, syntactic fontification (of strings and comments) is also performed. If this is non-&lt;code&gt;nil&lt;/code&gt;, syntactic fontification is not performed. See &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;Syntactic Font Lock&lt;/a&gt;.</source>
          <target state="translated">Второй элемент, &amp;laquo; &lt;var&gt;keywords-only&lt;/var&gt; , определяет значение переменной &lt;code&gt;font-lock-keywords-only&lt;/code&gt; . Если он опущен или равен &lt;code&gt;nil&lt;/code&gt; , синтаксическая фонификация (строк и комментариев) также выполняется. Если это не &lt;code&gt;nil&lt;/code&gt; , синтаксическая фонификация не выполняется. См. Раздел &amp;laquo; &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;Синтаксическая блокировка шрифта&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05af5100d6bbcd92ab672dd54e8a7002bdd81fa9" translate="yes" xml:space="preserve">
          <source>The second example shows that when the final argument is a sequence but not a list, the sequence&amp;rsquo;s elements do not become elements of the resulting list. Instead, the sequence becomes the final &lt;small&gt;CDR&lt;/small&gt;, like any other non-list final argument.</source>
          <target state="translated">Второй пример показывает, что, когда последний аргумент является последовательностью, а не списком, элементы последовательности не становятся элементами результирующего списка. Вместо этого последовательность становится последней &lt;small&gt;CDR&lt;/small&gt; , как и любой другой конечный аргумент, не входящий в список.</target>
        </trans-unit>
        <trans-unit id="78870468f3063c31ec99a482f80bcfe4fdf9caa7" translate="yes" xml:space="preserve">
          <source>The second item in the list, &lt;var&gt;regexp&lt;/var&gt;, is a regular expression (see &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;Regular Expressions&lt;/a&gt;); anything in the buffer that it matches is considered a definition, something to mention in the buffer index. The third item, &lt;var&gt;index&lt;/var&gt;, is a non-negative integer that indicates which subexpression in &lt;var&gt;regexp&lt;/var&gt; matches the definition&amp;rsquo;s name.</source>
          <target state="translated">Второй элемент в списке, &lt;var&gt;regexp&lt;/var&gt; , является регулярным выражением (см. &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;Регулярные выражения&lt;/a&gt; ); все в буфере, которому он соответствует, считается определением, что-то, что следует упомянуть в индексе буфера. Третий элемент, &lt;var&gt;index&lt;/var&gt; , представляет собой неотрицательное целое число, указывающее, какое подвыражение в &lt;var&gt;regexp&lt;/var&gt; соответствует имени определения.</target>
        </trans-unit>
        <trans-unit id="39db81295962c9250ac04e8024ae7b73da16e061" translate="yes" xml:space="preserve">
          <source>The second of these hooks is run when a &lt;em&gt;window size change&lt;/em&gt; has been detected which means that a window was created, assigned another buffer, or changed its total size or that of its text area.</source>
          <target state="translated">Второй из этих перехватчиков запускается, когда обнаруживается &lt;em&gt;изменение размера окна,&lt;/em&gt; что означает, что окно было создано, назначено другому буферу или изменило его общий размер или размер его текстовой области.</target>
        </trans-unit>
        <trans-unit id="e10a4024014db92893950553799fa332ec4eec91" translate="yes" xml:space="preserve">
          <source>The second part of the pattern matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark. The &lt;code&gt;\&quot;&lt;/code&gt; is Lisp syntax for a double-quote in a string. The &amp;lsquo;</source>
          <target state="translated">Вторая часть шаблона соответствует любым закрывающим скобкам и кавычкам, нулю или более, которые могут следовать за точкой, вопросительным или восклицательным знаком. &lt;code&gt;\&quot;&lt;/code&gt; Является синтаксис Lisp для двойной кавычки в строке.</target>
        </trans-unit>
        <trans-unit id="7da34c753b40326f37f6172c1b58a8c5f825b8f9" translate="yes" xml:space="preserve">
          <source>The selected frame is on a graphical display supporting such dialogs.</source>
          <target state="translated">Выбранный кадр находится на графическом дисплее,поддерживающем такие диалоги.</target>
        </trans-unit>
        <trans-unit id="dda9cd63960f9a91b850378b1927da3e714f3287" translate="yes" xml:space="preserve">
          <source>The selected window if it is either specified by a &lt;code&gt;previous-window&lt;/code&gt;&lt;var&gt;alist&lt;/var&gt; entry or showed &lt;var&gt;buffer&lt;/var&gt; before.</source>
          <target state="translated">Выбранное окно, если оно либо указано в записи &lt;var&gt;alist&lt;/var&gt; &lt;code&gt;previous-window&lt;/code&gt; либо показывало &lt;var&gt;buffer&lt;/var&gt; раньше.</target>
        </trans-unit>
        <trans-unit id="4beffd62ee0e9328af316739d55ab903054a8e51" translate="yes" xml:space="preserve">
          <source>The selected window is considered part of a group when the buffer local variable &lt;code&gt;selected-window-group-function&lt;/code&gt; is set to a function. In this case, &lt;code&gt;selected-window-group&lt;/code&gt; calls it with no arguments and returns its result (which should be the list of windows in the group).</source>
          <target state="translated">Выбранное окно считается частью группы, когда локальная переменная буфера &lt;code&gt;selected-window-group-function&lt;/code&gt; установлена ​​на функцию. В этом случае &lt;code&gt;selected-window-group&lt;/code&gt; вызывает его без аргументов и возвращает результат (который должен быть списком окон в группе).</target>
        </trans-unit>
        <trans-unit id="c7b994494213138fb5de0429d794e7e303777bef" translate="yes" xml:space="preserve">
          <source>The selected window is the one that you edit in.</source>
          <target state="translated">Выбранное окно-это окно,в котором вы редактируете.</target>
        </trans-unit>
        <trans-unit id="8665184a4907ab2354fc3286c669e4a6527d1f62" translate="yes" xml:space="preserve">
          <source>The selected window&amp;rsquo;s mode line is usually displayed in a different color using the face &lt;code&gt;mode-line&lt;/code&gt;. Other windows&amp;rsquo; mode lines appear in the face &lt;code&gt;mode-line-inactive&lt;/code&gt; instead. See &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;.</source>
          <target state="translated">Строка режима выбранного окна обычно отображается другим цветом с помощью линии &lt;code&gt;mode-line&lt;/code&gt; лица . Вместо этого строки режима других окон отображаются в &lt;code&gt;mode-line-inactive&lt;/code&gt; лица неактивно . См. &lt;a href=&quot;faces#Faces&quot;&gt;Лица&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8000cca8be137f75ed18782493ccc880df1113c" translate="yes" xml:space="preserve">
          <source>The semantics of maximizing and iconifying child frames is highly window-system dependent. As a rule, applications should never invoke these operations on child frames. By default, invoking &lt;code&gt;iconify-frame&lt;/code&gt; on a child frame will try to iconify the top-level frame corresponding to that child frame instead. To obtain a different behavior, users may customize the option &lt;code&gt;iconify-child-frame&lt;/code&gt; described below.</source>
          <target state="translated">Семантика развертывания дочерних фреймов и их пиктограммы сильно зависит от оконной системы. Как правило, приложения никогда не должны вызывать эти операции с дочерними кадрами. По умолчанию при вызове &lt;code&gt;iconify-frame&lt;/code&gt; для дочернего фрейма вместо этого будет предпринята попытка превратить в иконку фрейм верхнего уровня, соответствующий этому дочернему фрейму. Чтобы получить другое поведение, пользователи могут настроить параметр &lt;code&gt;iconify-child-frame&lt;/code&gt; , описанный ниже.</target>
        </trans-unit>
        <trans-unit id="1fdee8f54d168addba0e7230f98080d05a806af9" translate="yes" xml:space="preserve">
          <source>The sequence of calls to &lt;code&gt;select-window&lt;/code&gt; with a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;norecord&lt;/var&gt; argument determines an ordering of windows by their selection time. The function &lt;code&gt;get-lru-window&lt;/code&gt; can be used to retrieve the least recently selected live window (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">Последовательность вызовов &lt;code&gt;select-window&lt;/code&gt; с аргументом, &lt;var&gt;norecord&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; norecord, определяет порядок окон по времени их выбора. Функцию &lt;code&gt;get-lru-window&lt;/code&gt; можно использовать для получения последнего выбранного живого окна (см. &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Циклический порядок окон&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b6126ae190f28d94232911a10b32f330dbd4538f" translate="yes" xml:space="preserve">
          <source>The sequence of kills in the kill ring wraps around, so that after the oldest one comes the newest one, and before the newest one goes the oldest.</source>
          <target state="translated">Последовательность убийств в убойном кольце обертывается так,что после самого старого приходит самый новый,а перед самым новым уходит самый старый.</target>
        </trans-unit>
        <trans-unit id="d17460f17018f05e49ff10eb23d17bcf4ac2e075" translate="yes" xml:space="preserve">
          <source>The serial port can be configured at run-time, without having to close and re-open it. The function &lt;code&gt;serial-process-configure&lt;/code&gt; lets you change the speed, bytesize, and other parameters. In a terminal window created by &lt;code&gt;serial-term&lt;/code&gt;, you can click on the mode line for configuration.</source>
          <target state="translated">Последовательный порт можно настроить во время выполнения, без необходимости его закрывать и повторно открывать. Функция &lt;code&gt;serial-process-configure&lt;/code&gt; позволяет изменять скорость, размер в байтах и ​​другие параметры. В окне терминала, созданном с помощью &lt;code&gt;serial-term&lt;/code&gt; , вы можете щелкнуть строку режима для настройки.</target>
        </trans-unit>
        <trans-unit id="d2a9ae6c941e0bf24383fb2647a4f9171e1de594" translate="yes" xml:space="preserve">
          <source>The server supports hyperlinks in the notifications.</source>
          <target state="translated">Сервер поддерживает гиперссылки в уведомлениях.</target>
        </trans-unit>
        <trans-unit id="1636c548d4728e3546b4e61c467b130421fb3043" translate="yes" xml:space="preserve">
          <source>The server supports images in the notifications.</source>
          <target state="translated">Сервер поддерживает изображения в уведомлениях.</target>
        </trans-unit>
        <trans-unit id="3b6b682f52a52c12c8f9b21281af0b720bd16c65" translate="yes" xml:space="preserve">
          <source>The server supports persistence of notifications.</source>
          <target state="translated">Сервер поддерживает постоянство уведомлений.</target>
        </trans-unit>
        <trans-unit id="21a9b47dbf0032eaa7cb77326a6a549f6f528a88" translate="yes" xml:space="preserve">
          <source>The server supports sounds on notifications.</source>
          <target state="translated">Сервер поддерживает звуки в уведомлениях.</target>
        </trans-unit>
        <trans-unit id="32a2fb16a21966056b09359c49d25b26580e0735" translate="yes" xml:space="preserve">
          <source>The server will provide the specified actions to the user.</source>
          <target state="translated">Сервер предоставит пользователю указанные действия.</target>
        </trans-unit>
        <trans-unit id="487bc1e1eea831388d87886ebed5499c261328d4" translate="yes" xml:space="preserve">
          <source>The server will render an animation of all the frames in a given image array.</source>
          <target state="translated">Сервер визуализирует анимацию всех кадров в заданном массиве изображений.</target>
        </trans-unit>
        <trans-unit id="3d669bc7256cde6bc52048dc9f7dc18c0ff77233" translate="yes" xml:space="preserve">
          <source>The server&amp;rsquo;s process buffer value is never used directly, but the log function can retrieve it and use it to log connections by inserting text there.</source>
          <target state="translated">Значение буфера процесса сервера никогда не используется напрямую, но функция журнала может извлечь его и использовать для регистрации соединений, вставив туда текст.</target>
        </trans-unit>
        <trans-unit id="d4af74ba408681f224f4eae7dc1fcceae876b1eb" translate="yes" xml:space="preserve">
          <source>The server&amp;rsquo;s version number.</source>
          <target state="translated">Номер версии сервера.</target>
        </trans-unit>
        <trans-unit id="850499dab30d08985261f9268e55591d68aa5d33" translate="yes" xml:space="preserve">
          <source>The session ID of the process. This is a number that is the process ID of the process&amp;rsquo;s &lt;em&gt;session leader&lt;/em&gt;.</source>
          <target state="translated">Идентификатор сеанса процесса. Это число, которое является идентификатором процесса &lt;em&gt;лидера сеанса&lt;/em&gt; процесса .</target>
        </trans-unit>
        <trans-unit id="76fb62b9ff894328ee87291f8886595e1599a44b" translate="yes" xml:space="preserve">
          <source>The set of abbrevs currently in effect is recorded in an &lt;em&gt;abbrev table&lt;/em&gt;. Each buffer has a local abbrev table, but normally all buffers in the same major mode share one abbrev table. There is also a global abbrev table. Normally both are used.</source>
          <target state="translated">Набор действующих &lt;em&gt;сокращений&lt;/em&gt; записывается в &lt;em&gt;таблице сокращений&lt;/em&gt; . Каждый буфер имеет локальную таблицу сокращений, но обычно все буферы в одном основном режиме используют одну таблицу сокращений. Также существует глобальная таблица сокращений. Обычно используются оба.</target>
        </trans-unit>
        <trans-unit id="13bc56e40d973a547522dffd931b5104b534cbab" translate="yes" xml:space="preserve">
          <source>The set of possible multi-event key sequences depends on the bindings for prefix keys; therefore, it can be different for different keymaps, and can change when bindings are changed. However, a one-event sequence is always a key sequence, because it does not depend on any prefix keys for its well-formedness.</source>
          <target state="translated">Набор возможных последовательностей ключей для нескольких событий зависит от привязки для префиксных ключей,поэтому он может быть разным для разных раскладок,и может меняться при изменении привязки.Тем не менее,последовательность однособытий всегда является последовательностью ключей,поскольку она не зависит от каких-либо ключей префиксов для ее правильной фиксации.</target>
        </trans-unit>
        <trans-unit id="ea89afa3ebcf085515befba35c098def36ebf120" translate="yes" xml:space="preserve">
          <source>The set of supported &lt;code&gt;TZ&lt;/code&gt; strings is system-dependent. GNU and many other systems support the tzdata database, e.g., &amp;lsquo;</source>
          <target state="translated">Набор поддерживаемых строк &lt;code&gt;TZ&lt;/code&gt; зависит от системы. GNU и многие другие системы поддерживают базу данных tzdata, например, '</target>
        </trans-unit>
        <trans-unit id="ed52d340e29425d0c36d441fce1706eefbff92a9" translate="yes" xml:space="preserve">
          <source>The setf Macro</source>
          <target state="translated">Сетф Макро</target>
        </trans-unit>
        <trans-unit id="656aedcd7cd333555b5a910bc06a2f9bb048509a" translate="yes" xml:space="preserve">
          <source>The shell command &lt;code&gt;printenv&lt;/code&gt; prints all or part of the environment:</source>
          <target state="translated">Команда оболочки &lt;code&gt;printenv&lt;/code&gt; печатает всю среду или ее часть:</target>
        </trans-unit>
        <trans-unit id="697532010a390342417a302aa64e0eeb89a98cb2" translate="yes" xml:space="preserve">
          <source>The shell command &lt;code&gt;uptime&lt;/code&gt; returns similar information.</source>
          <target state="translated">Аналогичную информацию возвращает команда оболочки &lt;code&gt;uptime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c0ee07626a06ec319c5fa6dda80e5cd02b895c5" translate="yes" xml:space="preserve">
          <source>The shift modifier.</source>
          <target state="translated">Модификатор сдвига.</target>
        </trans-unit>
        <trans-unit id="526047c002039949790c223830818877585cd005" translate="yes" xml:space="preserve">
          <source>The significant way that errors are classified is by their condition names&amp;mdash;the names used to match errors with handlers. An error symbol serves only as a convenient way to specify the intended error message and list of condition names. It would be cumbersome to give &lt;code&gt;signal&lt;/code&gt; a list of condition names rather than one error symbol.</source>
          <target state="translated">Важный способ классификации ошибок - это их имена условий - имена, используемые для сопоставления ошибок с обработчиками. Символ ошибки служит только удобным способом указать предполагаемое сообщение об ошибке и список имен условий. Было бы обременительно давать &lt;code&gt;signal&lt;/code&gt; список имен условий, а не один символ ошибки.</target>
        </trans-unit>
        <trans-unit id="701a4ad01ef06b4bddd59b324ead42eff350dde1" translate="yes" xml:space="preserve">
          <source>The simple way to define an inline function, is to write &lt;code&gt;defsubst&lt;/code&gt; instead of &lt;code&gt;defun&lt;/code&gt;. The rest of the definition looks just the same, but using &lt;code&gt;defsubst&lt;/code&gt; says to make it inline for byte compilation.</source>
          <target state="translated">Самый простой способ определить встроенную функцию - написать &lt;code&gt;defsubst&lt;/code&gt; вместо &lt;code&gt;defun&lt;/code&gt; . Остальная часть определения выглядит так же, но использование &lt;code&gt;defsubst&lt;/code&gt; говорит о том, чтобы сделать его встроенным для байтовой компиляции.</target>
        </trans-unit>
        <trans-unit id="51e0da75b610832dceffa32e7fc903b0a72cc0e2" translate="yes" xml:space="preserve">
          <source>The simpler (and original) way to define a menu item is to bind some event type (it doesn&amp;rsquo;t matter what event type) to a binding like this:</source>
          <target state="translated">Более простой (и оригинальный) способ определить пункт меню - это привязать некоторый тип события (неважно, какой тип события) к такой привязке:</target>
        </trans-unit>
        <trans-unit id="c63bdaac10002dfd9144bf4493ac37c5ee6a7227" translate="yes" xml:space="preserve">
          <source>The simplest order of execution is sequential execution: first form &lt;var&gt;a&lt;/var&gt;, then form &lt;var&gt;b&lt;/var&gt;, and so on. This is what happens when you write several forms in succession in the body of a function, or at top level in a file of Lisp code&amp;mdash;the forms are executed in the order written. We call this &lt;em&gt;textual order&lt;/em&gt;. For example, if a function body consists of two forms &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt;, evaluation of the function evaluates first &lt;var&gt;a&lt;/var&gt; and then &lt;var&gt;b&lt;/var&gt;. The result of evaluating &lt;var&gt;b&lt;/var&gt; becomes the value of the function.</source>
          <target state="translated">Самый простой порядок выполнения - это последовательное выполнение: сначала формируем &lt;var&gt;a&lt;/var&gt; , затем формируем &lt;var&gt;b&lt;/var&gt; и так далее. Вот что происходит, когда вы пишете несколько форм подряд в теле функции или на верхнем уровне в файле кода Лиспа - формы выполняются в том порядке, в котором они написаны. Мы называем это &lt;em&gt;текстовым порядком&lt;/em&gt; . Например, если тело функции состоит из двух форм &lt;var&gt;a&lt;/var&gt; и &lt;var&gt;b&lt;/var&gt; , вычисление функции вычисляет сначала &lt;var&gt;a&lt;/var&gt; , а затем &lt;var&gt;b&lt;/var&gt; . Результат вычисления &lt;var&gt;b&lt;/var&gt; становится значением функции.</target>
        </trans-unit>
        <trans-unit id="2e0a2f8802289814697d3ff9bc642bb98ac915eb" translate="yes" xml:space="preserve">
          <source>The simplest way to add an element to an alist is like this:</source>
          <target state="translated">Самый простой способ добавить элемент в алист-это вот так:</target>
        </trans-unit>
        <trans-unit id="b58a2304ffb2d18ce86b489ba35624a904a8a1e9" translate="yes" xml:space="preserve">
          <source>The simplest way to examine text properties is to ask for the value of a particular property of a particular character. For that, use &lt;code&gt;get-text-property&lt;/code&gt;. Use &lt;code&gt;text-properties-at&lt;/code&gt; to get the entire property list of a character. See &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;, for functions to examine the properties of a number of characters at once.</source>
          <target state="translated">Самый простой способ проверить свойства текста - это спросить значение определенного свойства конкретного символа. Для этого используйте &lt;code&gt;get-text-property&lt;/code&gt; . Используйте &lt;code&gt;text-properties-at&lt;/code&gt; , чтобы получить полный список свойств символа. См. &amp;laquo; &lt;a href=&quot;property-search#Property-Search&quot;&gt;Поиск свойств&amp;raquo;&lt;/a&gt; для получения информации о функциях одновременного изучения свойств нескольких символов.</target>
        </trans-unit>
        <trans-unit id="adc76fb843de7f5b33d2478fbfc134dfe5c4dcf3" translate="yes" xml:space="preserve">
          <source>The simplest way to use a variable is &lt;em&gt;globally&lt;/em&gt;. This means that the variable has just one value at a time, and this value is in effect (at least for the moment) throughout the Lisp system. The value remains in effect until you specify a new one. When a new value replaces the old one, no trace of the old value remains in the variable.</source>
          <target state="translated">Самый простой способ использовать переменную - &lt;em&gt;глобально&lt;/em&gt; . Это означает, что переменная имеет только одно значение за раз, и это значение действует (по крайней мере, на данный момент) во всей системе Lisp. Значение остается в силе, пока вы не укажете новое. Когда новое значение заменяет старое, в переменной не остается следов старого значения.</target>
        </trans-unit>
        <trans-unit id="2b36ac08912d39209d118742c10208da562be7cf" translate="yes" xml:space="preserve">
          <source>The size of buffer&amp;rsquo;s gap. See &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;Buffer Gap&lt;/a&gt;.</source>
          <target state="translated">Размер буферного зазора. См. &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;Buffer Gap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="873e96ede3bbdf4e5518603c5529cf1eece61c3f" translate="yes" xml:space="preserve">
          <source>The size of the accessible part of the current buffer; basically &lt;code&gt;(- (point-max) (point-min))&lt;/code&gt;.</source>
          <target state="translated">Размер доступной части текущего буфера; в основном &lt;code&gt;(- (point-max) (point-min))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a849ae6a00f9521aec6d2261f95fba3341d311e" translate="yes" xml:space="preserve">
          <source>The size of the file in bytes (&lt;code&gt;file-attribute-size&lt;/code&gt;).</source>
          <target state="translated">Размер файла в байтах ( &lt;code&gt;file-attribute-size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f563b6a9a8db0e9d2b8a141ce4f9b7d9e8e1e86" translate="yes" xml:space="preserve">
          <source>The size of the new window can be adjusted by supplying &lt;code&gt;window-height&lt;/code&gt; and &lt;code&gt;window-width&lt;/code&gt; entries in &lt;var&gt;alist&lt;/var&gt;. If &lt;var&gt;alist&lt;/var&gt; contains a &lt;code&gt;preserve-size&lt;/code&gt; entry, Emacs will also try to preserve the size of the new window during future resize operations (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</source>
          <target state="translated">Размер нового окна можно настроить, указав значения &lt;code&gt;window-height&lt;/code&gt; и &lt;code&gt;window-width&lt;/code&gt; в &lt;var&gt;alist&lt;/var&gt; . Если &lt;var&gt;alist&lt;/var&gt; содержит запись с &lt;code&gt;preserve-size&lt;/code&gt; , Emacs также попытается сохранить размер нового окна во время будущих операций изменения размера (см. &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Сохранение размеров окна&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="43af7be726f5955aa5ff42c15118a19504247059" translate="yes" xml:space="preserve">
          <source>The size of the process&amp;rsquo;s &lt;em&gt;resident set&lt;/em&gt;, the number of kilobytes occupied by the process in the machine&amp;rsquo;s physical memory.</source>
          <target state="translated">Размер &lt;em&gt;резидентного набора&lt;/em&gt; процесса , количество килобайт, занимаемых процессом в физической памяти машины.</target>
        </trans-unit>
        <trans-unit id="576b8e3ff0609705a9b9504b486dacc40004ea6d" translate="yes" xml:space="preserve">
          <source>The sorting functions described in this section all rearrange text in a buffer. This is in contrast to the function &lt;code&gt;sort&lt;/code&gt;, which rearranges the order of the elements of a list (see &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;Rearrangement&lt;/a&gt;). The values returned by these functions are not meaningful.</source>
          <target state="translated">Все функции сортировки, описанные в этом разделе, переупорядочивают текст в буфере. Это отличается от функции &lt;code&gt;sort&lt;/code&gt; , которая меняет порядок элементов списка (см. &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;Перестановка&lt;/a&gt; ). Значения, возвращаемые этими функциями, не имеют смысла.</target>
        </trans-unit>
        <trans-unit id="4c3d2a4b26d988675d4c78f53514dab4c53dcc03" translate="yes" xml:space="preserve">
          <source>The sound must be stored as a file in RIFF-WAVE format (&amp;lsquo;</source>
          <target state="translated">Звук необходимо сохранить в виде файла в формате RIFF-WAVE ('</target>
        </trans-unit>
        <trans-unit id="0497cf1b10750bd04c03011dc18b4f0cfdc47413" translate="yes" xml:space="preserve">
          <source>The space of possible character codes is divided into various character sets.</source>
          <target state="translated">Пространство возможных символьных кодов разделено на различные наборы символов.</target>
        </trans-unit>
        <trans-unit id="9432d6b9187cb979929edaa344995bf72578704f" translate="yes" xml:space="preserve">
          <source>The special commands of Edebug are available in the source code buffer in addition to the commands of Emacs Lisp mode. For example, you can type the Edebug command</source>
          <target state="translated">Специальные команды Edebug доступны в буфере исходного кода в дополнение к командам режима Emacs Lisp.Например,вы можете ввести команду Edebug</target>
        </trans-unit>
        <trans-unit id="749a997c2ad2240b06198fe40cd85ef622970354" translate="yes" xml:space="preserve">
          <source>The special commands of these modes bind &lt;code&gt;buffer-read-only&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; (with &lt;code&gt;let&lt;/code&gt;) or bind &lt;code&gt;inhibit-read-only&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; around the places where they themselves change the text.</source>
          <target state="translated">Специальные команды этих режимов привязывают &lt;code&gt;buffer-read-only&lt;/code&gt; для чтения к &lt;code&gt;nil&lt;/code&gt; (с помощью &lt;code&gt;let&lt;/code&gt; ) или связывают &lt;code&gt;inhibit-read-only&lt;/code&gt; для чтения с &lt;code&gt;t&lt;/code&gt; вокруг тех мест, где они сами изменяют текст.</target>
        </trans-unit>
        <trans-unit id="388ba11e949e8870ac609c14e29761f15abdd417" translate="yes" xml:space="preserve">
          <source>The special form &lt;code&gt;interactive&lt;/code&gt; turns a Lisp function into a command. The &lt;code&gt;interactive&lt;/code&gt; form must be located at top-level in the function body, usually as the first form in the body; this applies to both lambda expressions (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;) and &lt;code&gt;defun&lt;/code&gt; forms (see &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;). This form does nothing during the actual execution of the function; its presence serves as a flag, telling the Emacs command loop that the function can be called interactively. The argument of the &lt;code&gt;interactive&lt;/code&gt; form specifies how the arguments for an interactive call should be read.</source>
          <target state="translated">&lt;code&gt;interactive&lt;/code&gt; специальная форма превращает функцию Лиспа в команду. &lt;code&gt;interactive&lt;/code&gt; форма должна быть расположена на верхнем уровне в теле функции, как правило , в качестве первой формы в организме; это относится и к лямбда - выражения (см &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Лямбда - выражение&lt;/a&gt; ) и &lt;code&gt;defun&lt;/code&gt; форма (см &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Определение функций&lt;/a&gt; ). Эта форма ничего не делает во время фактического выполнения функции; его присутствие служит флагом, сообщающим командному циклу Emacs, что функция может быть вызвана интерактивно. Аргумент &lt;code&gt;interactive&lt;/code&gt; формы определяет, как следует читать аргументы интерактивного вызова.</target>
        </trans-unit>
        <trans-unit id="0005a6b722d00b053f8a1c5bab2e99c2e0e932c1" translate="yes" xml:space="preserve">
          <source>The special form &lt;code&gt;quote&lt;/code&gt; returns its single argument, as written, without evaluating it. This provides a way to include constant symbols and lists, which are not self-evaluating objects, in a program. (It is not necessary to quote self-evaluating objects such as numbers, strings, and vectors.)</source>
          <target state="translated">&lt;code&gt;quote&lt;/code&gt; специальной формы возвращает свой единственный аргумент в том виде, в котором он написан, без его оценки. Это дает возможность включать в программу постоянные символы и списки, которые не являются объектами самооценки. (Необязательно указывать самооценочные объекты, такие как числа, строки и векторы.)</target>
        </trans-unit>
        <trans-unit id="244f4b5640ec3dae1a8ddb2bdbc59df8cee21b33" translate="yes" xml:space="preserve">
          <source>The special form &lt;code&gt;track-mouse&lt;/code&gt; enables generation of motion events within its body. Outside of &lt;code&gt;track-mouse&lt;/code&gt; forms, Emacs does not generate events for mere motion of the mouse, and these events do not appear. See &lt;a href=&quot;mouse-tracking#Mouse-Tracking&quot;&gt;Mouse Tracking&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;track-mouse&lt;/code&gt; специальной формы позволяет генерировать события движения внутри своего тела. Вне форм &lt;code&gt;track-mouse&lt;/code&gt; Emacs не генерирует события для простого движения мыши, и эти события не появляются. См. &lt;a href=&quot;mouse-tracking#Mouse-Tracking&quot;&gt;Отслеживание мыши&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28ba34c98e1a089b9214cef4dc2999430a1d7a09" translate="yes" xml:space="preserve">
          <source>The special forms &lt;code&gt;defvar&lt;/code&gt; and &lt;code&gt;defconst&lt;/code&gt; also set the default value (if they set the variable at all), rather than any buffer-local value.</source>
          <target state="translated">Специальные формы &lt;code&gt;defvar&lt;/code&gt; и &lt;code&gt;defconst&lt;/code&gt; также устанавливают значение по умолчанию (если они вообще устанавливают переменную), а не какое-либо локальное значение в буфере.</target>
        </trans-unit>
        <trans-unit id="5e119bef1e610c9f0380fd95f6e4af11230682fc" translate="yes" xml:space="preserve">
          <source>The special forms &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;let*&lt;/code&gt; exist to create local bindings:</source>
          <target state="translated">Специальные формы &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;let*&lt;/code&gt; существовать для создания локальных привязок:</target>
        </trans-unit>
        <trans-unit id="67b8199effbdb879bbf1f5d04029672e2a21aec2" translate="yes" xml:space="preserve">
          <source>The special marker &amp;lsquo;</source>
          <target state="translated">Специальный маркер '</target>
        </trans-unit>
        <trans-unit id="417f26037bec7ec878e05ef7fce97d3107e1525c" translate="yes" xml:space="preserve">
          <source>The special position where editing takes place.</source>
          <target state="translated">Особое положение,в котором происходит редактирование.</target>
        </trans-unit>
        <trans-unit id="6604b0bf24124b0211a16d199be68fe327c5aa41" translate="yes" xml:space="preserve">
          <source>The special properties &lt;code&gt;point-entered&lt;/code&gt; and &lt;code&gt;point-left&lt;/code&gt; record hook functions that report motion of point. Each time point moves, Emacs compares these two property values:</source>
          <target state="translated">Специальные свойства &amp;laquo; &lt;code&gt;point-entered&lt;/code&gt; и &amp;laquo; &lt;code&gt;point-left&lt;/code&gt; записывают функции ловушки, которые сообщают о движении точки. Каждый раз при перемещении точки времени Emacs сравнивает эти два значения свойств:</target>
        </trans-unit>
        <trans-unit id="84235cb39de6ef4fc27674810653ef520a1cb95c" translate="yes" xml:space="preserve">
          <source>The special return value &amp;lsquo;</source>
          <target state="translated">Специальное возвращаемое значение '</target>
        </trans-unit>
        <trans-unit id="3cfd33d505b3e301ef67641d59464fa7fe2f87dd" translate="yes" xml:space="preserve">
          <source>The special value &lt;code&gt;child-frame&lt;/code&gt; means to make a minibuffer-only child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) whose parent becomes the frame created. As if specified as &lt;code&gt;nil&lt;/code&gt;, Emacs will set this parameter to the minibuffer window of the child frame but will not select the child frame after its creation.</source>
          <target state="translated">Специальное значение &lt;code&gt;child-frame&lt;/code&gt; означает создание дочернего кадра только для минибуфера (см. &amp;laquo; &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние кадры&amp;raquo;&lt;/a&gt; ), родительский элемент которого становится созданным кадром. Как будто задано как &lt;code&gt;nil&lt;/code&gt; , Emacs установит этот параметр для окна минибуфера дочернего фрейма, но не будет выбирать дочерний фрейм после его создания.</target>
        </trans-unit>
        <trans-unit id="fcdc41fab620d4b9e47384a2bf4786023f64d828" translate="yes" xml:space="preserve">
          <source>The specification for backquote below illustrates how to match dotted lists and use &lt;code&gt;nil&lt;/code&gt; to terminate recursion. It also illustrates how components of a vector may be matched. (The actual specification defined by Edebug is a little different, and does not support dotted lists because doing so causes very deep recursion that could fail.)</source>
          <target state="translated">В спецификации обратной кавычки ниже показано, как сопоставить точечные списки и использовать &lt;code&gt;nil&lt;/code&gt; для завершения рекурсии. Он также показывает, как можно сопоставить компоненты вектора. (Фактическая спецификация, определенная Edebug, немного отличается и не поддерживает точечные списки, потому что это вызывает очень глубокую рекурсию, которая может привести к сбою.)</target>
        </trans-unit>
        <trans-unit id="27d6230ee26567ac631f3131ae7886bcc7a72c78" translate="yes" xml:space="preserve">
          <source>The specification string also says which fonts to use in the fontset. See below for the details.</source>
          <target state="translated">В строке спецификации также указано,какие шрифты использовать в наборе шрифтов.Подробности см.ниже.</target>
        </trans-unit>
        <trans-unit id="7f25f9498af3ebb82fd4fd0ed6c991c529aa68e9" translate="yes" xml:space="preserve">
          <source>The specification version the server is compliant with.</source>
          <target state="translated">Версия спецификации,которой соответствует сервер.</target>
        </trans-unit>
        <trans-unit id="9a30b5e6e028131d98090823da5db94954c0fdbe" translate="yes" xml:space="preserve">
          <source>The specified &lt;var&gt;alist&lt;/var&gt; is an association list of symbols and values. The following symbols have a special meaning:</source>
          <target state="translated">Указанный &lt;var&gt;alist&lt;/var&gt; ассоциативного список символов и значений. Следующие символы имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="e407764dfcb6e2f1247a11cf715cac7ed4f26bbf" translate="yes" xml:space="preserve">
          <source>The specified &lt;var&gt;frame&lt;/var&gt; becomes the selected frame, and its terminal becomes the selected terminal. This function then calls &lt;code&gt;select-window&lt;/code&gt; as a subroutine, passing the window selected within &lt;var&gt;frame&lt;/var&gt; as its first argument and &lt;var&gt;norecord&lt;/var&gt; as its second argument (hence, if &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this avoids changing the order of recently selected windows and the buffer list). See &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Selecting Windows&lt;/a&gt;.</source>
          <target state="translated">Указанный &lt;var&gt;frame&lt;/var&gt; становится выбранным кадром, а его терминал становится выбранным терминалом. Затем эта функция вызывает &lt;code&gt;select-window&lt;/code&gt; как подпрограмму, передавая окно, выбранное в пределах &lt;var&gt;frame&lt;/var&gt; качестве первого аргумента и &lt;var&gt;norecord&lt;/var&gt; в качестве второго аргумента (следовательно, если &lt;var&gt;norecord&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , это позволяет избежать изменения порядка недавно выбранных окон и списка буферов. ). См. &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Выбор Windows&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87e2533bf5024d0890c44a2a577f82288504b5ca" translate="yes" xml:space="preserve">
          <source>The specified functions are stored in the property list of &lt;var&gt;name&lt;/var&gt; under the property &lt;code&gt;hash-table-test&lt;/code&gt;; the property value&amp;rsquo;s form is &lt;code&gt;(&lt;var&gt;test-fn&lt;/var&gt; &lt;var&gt;hash-fn&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">Указанные функции хранятся в списке свойств &lt;var&gt;name&lt;/var&gt; под свойством &lt;code&gt;hash-table-test&lt;/code&gt; ; форма значения свойства - &lt;code&gt;(&lt;var&gt;test-fn&lt;/var&gt; &lt;var&gt;hash-fn&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91455a3d8f4bdb484463e73b427656cc16a89567" translate="yes" xml:space="preserve">
          <source>The speed of the serial port in bits per second, a.k.a. &lt;em&gt;baud rate&lt;/em&gt;. The value can be any number, but most serial ports work only at a few defined values between 1200 and 115200, with 9600 being the most common value. If &lt;var&gt;speed&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the function ignores all other arguments and does not configure the port. This may be useful for special serial ports such as Bluetooth-to-serial converters, which can only be configured through &amp;lsquo;</source>
          <target state="translated">Скорость последовательного порта в битах в секунду, также известная как &lt;em&gt;скорость передачи данных&lt;/em&gt; . Значение может быть любым числом, но большинство последовательных портов работают только с несколькими определенными значениями от 1200 до 115200, причем 9600 является наиболее распространенным значением. Если &lt;var&gt;speed&lt;/var&gt; равна &lt;code&gt;nil&lt;/code&gt; , функция игнорирует все остальные аргументы и не настраивает порт. Это может быть полезно для специальных последовательных портов, таких как преобразователи Bluetooth-to-serial, которые можно настроить только через '</target>
        </trans-unit>
        <trans-unit id="52128a6146c27dc1c3960ab9a318c70adfaf8c01" translate="yes" xml:space="preserve">
          <source>The speed of the serial port in bits per second. This function calls &lt;code&gt;serial-process-configure&lt;/code&gt; to handle the speed; see the following documentation of that function for more details.</source>
          <target state="translated">Скорость последовательного порта в битах в секунду. Эта функция вызывает &lt;code&gt;serial-process-configure&lt;/code&gt; для управления скоростью; см. следующую документацию по этой функции для получения дополнительных сведений.</target>
        </trans-unit>
        <trans-unit id="fbb6c823ca23a02980eeae5e0a0001e4cc0886fe" translate="yes" xml:space="preserve">
          <source>The square brackets indicate that the &lt;code&gt;&amp;amp;optional&lt;/code&gt; and &lt;code&gt;&amp;amp;rest&lt;/code&gt; clauses, and the variables that follow them, are optional.</source>
          <target state="translated">Квадратные скобки указывают, что предложения &lt;code&gt;&amp;amp;optional&lt;/code&gt; и &lt;code&gt;&amp;amp;rest&lt;/code&gt; , а также следующие за ними переменные являются необязательными.</target>
        </trans-unit>
        <trans-unit id="81a3604cf4a5ac01501948bd0680c4975564433d" translate="yes" xml:space="preserve">
          <source>The stack frame made for the function call which enters the debugger in this way will be flagged automatically so that the debugger will be called again when the frame is exited. You can use the</source>
          <target state="translated">Фрейм стека,сделанный для вызова функции,которая таким образом поступает в отладчик,будет автоматически помечен,так что отладчик будет вызван снова при выходе из кадра.Вы можете использовать</target>
        </trans-unit>
        <trans-unit id="9a119c8d6df162a4c1cd3d34b9608179ca3eb2aa" translate="yes" xml:space="preserve">
          <source>The standard GNU Emacs Lisp directory tree contains the code for several major modes, in files such as</source>
          <target state="translated">Стандартное дерево каталогов GNU Emacs Lisp содержит код для нескольких основных режимов,в таких файлах как</target>
        </trans-unit>
        <trans-unit id="88217deefb3d70a4db90b540339f6b3e6d2c6eee" translate="yes" xml:space="preserve">
          <source>The standard definition of the &lt;code&gt;delete-frame&lt;/code&gt; event is to delete &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">Стандартное определение события &lt;code&gt;delete-frame&lt;/code&gt; - удалить &lt;var&gt;frame&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="03b918691e790a880d4fba6e47f98dbbdb8910de" translate="yes" xml:space="preserve">
          <source>The standard definition of this function is as follows:</source>
          <target state="translated">Стандартное определение этой функции следующее:</target>
        </trans-unit>
        <trans-unit id="6292beb7dc766e9cc6bfb7027445782776c9d55b" translate="yes" xml:space="preserve">
          <source>The standard definition of this function, on most operating systems, is as follows:</source>
          <target state="translated">Стандартное определение этой функции на большинстве операционных систем следующее:</target>
        </trans-unit>
        <trans-unit id="259daec623d20179dd6c873402018404fce5ae52" translate="yes" xml:space="preserve">
          <source>The standard input for the new process comes from file &lt;var&gt;infile&lt;/var&gt; if &lt;var&gt;infile&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt;, and from the null device otherwise. The argument &lt;var&gt;destination&lt;/var&gt; says where to put the process output. Here are the possibilities:</source>
          <target state="translated">Стандартный ввод для нового процесса поступает из файла &lt;var&gt;infile&lt;/var&gt; , если &lt;var&gt;infile&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , и из нулевого устройства в противном случае. Аргумент &lt;var&gt;destination&lt;/var&gt; говорит , куда поместить результат процесса. Вот возможности:</target>
        </trans-unit>
        <trans-unit id="44c287ca4b32485d2fbd1b0533c6bc30851eaea0" translate="yes" xml:space="preserve">
          <source>The standard letter-codes for reading arguments in various ways.</source>
          <target state="translated">Стандартные буквенные коды для чтения аргументов различными способами.</target>
        </trans-unit>
        <trans-unit id="8f49ffda7284df4c0cd9b03dae4b8a52126166b8" translate="yes" xml:space="preserve">
          <source>The start of the documentation string is usually indented in the source file, but since these spaces come before the starting double-quote, they are not part of the string. Some people make a practice of indenting any additional lines of the string so that the text lines up in the program source. &lt;em&gt;That is a mistake.&lt;/em&gt; The indentation of the following lines is inside the string; what looks nice in the source code will look ugly when displayed by the help commands.</source>
          <target state="translated">Начало строки документации обычно имеет отступ в исходном файле, но, поскольку эти пробелы стоят перед начальной двойной кавычкой, они не являются частью строки. Некоторые люди делают отступы для любых дополнительных строк строки, чтобы текст выровнялся в исходном коде программы. &lt;em&gt;Это ошибка. &lt;/em&gt;Отступ следующих строк находится внутри строки; то, что хорошо выглядит в исходном коде, будет выглядеть некрасиво при отображении с помощью команд справки.</target>
        </trans-unit>
        <trans-unit id="4c672e151d200c22d18367c0a5d6b7e540bedaea" translate="yes" xml:space="preserve">
          <source>The state code of the process. This is a short string that encodes the scheduling state of the process. Here&amp;rsquo;s a list of the most frequently seen codes:</source>
          <target state="translated">Государственный код процесса. Это короткая строка, которая кодирует состояние планирования процесса. Вот список наиболее часто встречающихся кодов:</target>
        </trans-unit>
        <trans-unit id="f2d7146dc12f6d9513c21cfa997b6a60f75f956d" translate="yes" xml:space="preserve">
          <source>The state of keyboard macro definition is saved and restored. While Edebug is active, &lt;code&gt;defining-kbd-macro&lt;/code&gt; is bound to &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt;.</source>
          <target state="translated">Состояние определения макроса клавиатуры сохраняется и восстанавливается. Пока Edebug активен, &lt;code&gt;defining-kbd-macro&lt;/code&gt; привязано к &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c91d0e0a6d197098d1a02ec3a2503f351103980" translate="yes" xml:space="preserve">
          <source>The state of keyboard macro execution is saved and restored. While Edebug is active, &lt;code&gt;executing-kbd-macro&lt;/code&gt; is bound to &lt;code&gt;nil&lt;/code&gt; unless &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Состояние выполнения макроса клавиатуры сохраняется и восстанавливается. Пока Edebug активен, &lt;code&gt;executing-kbd-macro&lt;/code&gt; привязано к &lt;code&gt;nil&lt;/code&gt; , если &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; не равно &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf9ddd67b0e2736562e5e1b48123ad8e5e1a7a7d" translate="yes" xml:space="preserve">
          <source>The state of visibility of the frame. There are three possibilities: &lt;code&gt;nil&lt;/code&gt; for invisible, &lt;code&gt;t&lt;/code&gt; for visible, and &lt;code&gt;icon&lt;/code&gt; for iconified. See &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;.</source>
          <target state="translated">Состояние видимости кадра. Есть три возможности: &lt;code&gt;nil&lt;/code&gt; для невидимого, &lt;code&gt;t&lt;/code&gt; для видимого и &lt;code&gt;icon&lt;/code&gt; для значка. См. &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Видимость рамок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e8a0a928375b331768ea9541d2c2a6c4d37acbb" translate="yes" xml:space="preserve">
          <source>The status of the subprocess belonging to the current buffer, obtained with &lt;code&gt;process-status&lt;/code&gt;. See &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;.</source>
          <target state="translated">Статус подпроцесса, принадлежащего текущему буферу, полученный с помощью &lt;code&gt;process-status&lt;/code&gt; . См. &lt;a href=&quot;process-information#Process-Information&quot;&gt;Информацию о процессе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="999eb55350809e41053d193b69ed4373f0358a4b" translate="yes" xml:space="preserve">
          <source>The string &lt;var&gt;buffer-name&lt;/var&gt; specifies the temporary buffer, which need not already exist. The argument must be a string, not a buffer. The buffer is erased initially (with no questions asked), and it is marked as unmodified after &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; exits.</source>
          <target state="translated">Строка &lt;var&gt;buffer-name&lt;/var&gt; указывает временный буфер, который может не существовать. Аргумент должен быть строкой, а не буфером. Изначально буфер стирается (без вопросов) и помечается как неизмененный после &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4d3cb799dfeca2e1bb98a62be5a7ac517d5ffb4" translate="yes" xml:space="preserve">
          <source>The string &lt;var&gt;lighter&lt;/var&gt; says what to display in the mode line when the mode is enabled; if it is &lt;code&gt;nil&lt;/code&gt;, the mode is not displayed in the mode line.</source>
          <target state="translated">Строка &lt;var&gt;lighter&lt;/var&gt; говорит , что будет отображаться в строке состояния, когда включен режим; если он равен &lt;code&gt;nil&lt;/code&gt; , режим не отображается в строке режима.</target>
        </trans-unit>
        <trans-unit id="a03446e19ee8800b453720d31c0b60da78dc7e80" translate="yes" xml:space="preserve">
          <source>The string containing the byte-code instructions.</source>
          <target state="translated">Строка,содержащая инструкции по байт-коду.</target>
        </trans-unit>
        <trans-unit id="1ba6ac8d60c10283435c94518d321e4f95295bb9" translate="yes" xml:space="preserve">
          <source>The string describing the event looks like one of the following:</source>
          <target state="translated">Строка,описывающая событие,выглядит как одна из следующих:</target>
        </trans-unit>
        <trans-unit id="26291a7cd459e196bf1c635f5e136cb0085033bb" translate="yes" xml:space="preserve">
          <source>The string is inserted literally.</source>
          <target state="translated">Строка вставлена буквально.</target>
        </trans-unit>
        <trans-unit id="c1cb47cdeee50f6839e7f1b4e7667115d1fdbb0c" translate="yes" xml:space="preserve">
          <source>The string or comment start position. While inside a comment, this is the position where the comment began; while inside a string, this is the position where the string began. When outside of strings and comments, this element is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Позиция начала строки или комментария. Находясь внутри комментария, это позиция, с которой комментарий начинался; находясь внутри строки, это позиция начала строки. За пределами строк и комментариев этот элемент равен &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ad211627a8eba28dd5ef9816837befb4643331" translate="yes" xml:space="preserve">
          <source>The string that this function returns is what is recorded in the symbolic link; it may or may not include any leading directories. This function does &lt;em&gt;not&lt;/em&gt; expand the link target to produce a fully-qualified file name, and in particular does not use the leading directories, if any, of the &lt;var&gt;filename&lt;/var&gt; argument if the link target is not an absolute file name. Here&amp;rsquo;s an example:</source>
          <target state="translated">Строка, которую возвращает эта функция, записана в символической ссылке; он может включать или не включать какие-либо ведущие каталоги. Эта функция &lt;em&gt;не&lt;/em&gt; расширяет цель ссылки для создания полного имени файла и, в частности, не использует ведущие каталоги, если они есть, аргумента &lt;var&gt;filename&lt;/var&gt; если цель ссылки не является абсолютным именем файла. Вот пример:</target>
        </trans-unit>
        <trans-unit id="ed696d53e7ac7bcc7d08d01175d6eb89bf0c571f" translate="yes" xml:space="preserve">
          <source>The string to be completed.</source>
          <target state="translated">Строка,которая должна быть завершена.</target>
        </trans-unit>
        <trans-unit id="07cf4d672d43fc0025d53260f62ef95ec1c50b45" translate="yes" xml:space="preserve">
          <source>The string which was clicked on, including any properties.</source>
          <target state="translated">Строка,которая была нажата,включая любые свойства.</target>
        </trans-unit>
        <trans-unit id="9e01c44c700489e51d428a65abb3864ced471545" translate="yes" xml:space="preserve">
          <source>The strings are compared by the numeric values of their characters. For instance, &lt;var&gt;str1&lt;/var&gt; is considered less than &lt;var&gt;str2&lt;/var&gt; if its first differing character has a smaller numeric value. If &lt;var&gt;ignore-case&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, characters are converted to upper-case before comparing them. Unibyte strings are converted to multibyte for comparison (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;), so that a unibyte string and its conversion to multibyte are always regarded as equal.</source>
          <target state="translated">Строки сравниваются по числовым значениям их символов. Например, &lt;var&gt;str1&lt;/var&gt; считается меньше &lt;var&gt;str2&lt;/var&gt; , если его первый отличающийся символ имеет меньшее числовое значение. Если &lt;var&gt;ignore-case&lt;/var&gt; отличен от &lt;code&gt;nil&lt;/code&gt; , символы преобразуются в верхний регистр перед их сравнением. Строки Unibyte преобразуются в многобайтовые для сравнения (см. &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Представления текста&lt;/a&gt; ), поэтому однобайтная строка и ее преобразование в многобайтовые всегда рассматриваются как равные.</target>
        </trans-unit>
        <trans-unit id="44b6399fd6b44ca0035a1f2fc79dfcc1e1445a5f" translate="yes" xml:space="preserve">
          <source>The strings in &lt;var&gt;list-of-strings&lt;/var&gt; that need quoting are those that include &lt;var&gt;separator&lt;/var&gt; as their substring. Quoting a string encloses it in double quotes &lt;code&gt;&quot;&amp;hellip;&quot;&lt;/code&gt;. In the simplest case, if you are consing a command from the individual command-line arguments, every argument that includes embedded blanks will be quoted.</source>
          <target state="translated">Строки в &lt;var&gt;list-of-strings&lt;/var&gt; которые нуждаются в кавычках, - это те, которые включают в себя &lt;var&gt;separator&lt;/var&gt; качестве своей подстроки. Цитирование строки заключается в двойные кавычки &lt;code&gt;&quot;&amp;hellip;&quot;&lt;/code&gt; . В простейшем случае, если вы составляете команду из отдельных аргументов командной строки, каждый аргумент, который включает встроенные пробелы, будет заключен в кавычки.</target>
        </trans-unit>
        <trans-unit id="6eb3410ffb193ecb3bb6cdb461cdb85ed0d15602" translate="yes" xml:space="preserve">
          <source>The strings matching the first nine grouping constructs appearing in the entire regular expression passed to a search or matching function are assigned numbers 1 through 9 in the order that the open parentheses appear in the regular expression. So you can use &amp;lsquo;</source>
          <target state="translated">Строкам, соответствующим первым девяти конструкциям группировки, появляющимся во всем регулярном выражении, переданном в функцию поиска или сопоставления, присваиваются номера от 1 до 9 в том порядке, в котором открытые круглые скобки появляются в регулярном выражении. Итак, вы можете использовать '</target>
        </trans-unit>
        <trans-unit id="d581c2599c93c8f407b1007bbe2ce48ba6714abb" translate="yes" xml:space="preserve">
          <source>The subprocess inherits its environment from Emacs, but you can specify overrides for it with &lt;code&gt;process-environment&lt;/code&gt;. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;. The subprocess gets its current directory from the value of &lt;code&gt;default-directory&lt;/code&gt;.</source>
          <target state="translated">Подпроцесс наследует свою среду от Emacs, но вы можете указать для него переопределения с помощью &lt;code&gt;process-environment&lt;/code&gt; . См. &lt;a href=&quot;system-environment#System-Environment&quot;&gt;Системная среда&lt;/a&gt; . Подпроцесс получает свой текущий каталог из значения &lt;code&gt;default-directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36e61db0284478d461aa89c79eac1cab50f7a0e0" translate="yes" xml:space="preserve">
          <source>The substitutions performed by &amp;lsquo;</source>
          <target state="translated">Замены, выполненные '</target>
        </trans-unit>
        <trans-unit id="8b19565b999d7f6150d2a072214b083a7f92bdb0" translate="yes" xml:space="preserve">
          <source>The subtype controls the number of &lt;em&gt;extra slots&lt;/em&gt; in the char-table. This number is specified by the subtype&amp;rsquo;s &lt;code&gt;char-table-extra-slots&lt;/code&gt; symbol property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;), whose value should be an integer between 0 and 10. If the subtype has no such symbol property, the char-table has no extra slots.</source>
          <target state="translated">Подтип управляет количеством &lt;em&gt;дополнительных слотов&lt;/em&gt; в таблице символов. Это число определяется свойством символа &lt;code&gt;char-table-extra-slots&lt;/code&gt; подтипа (см. &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Свойства символа&lt;/a&gt; ), значение которого должно быть целым числом от 0 до 10. Если подтип не имеет такого свойства символа, таблица символов не имеет дополнительных слотов. .</target>
        </trans-unit>
        <trans-unit id="3b7c16dd882ba705b433c0230563b93def38601b" translate="yes" xml:space="preserve">
          <source>The subtype provides an easy way to tell what the char-table is for. For instance, display tables are char-tables with &lt;code&gt;display-table&lt;/code&gt; as the subtype, and syntax tables are char-tables with &lt;code&gt;syntax-table&lt;/code&gt; as the subtype. The subtype can be queried using the function &lt;code&gt;char-table-subtype&lt;/code&gt;, described below.</source>
          <target state="translated">Подтип предоставляет простой способ определить, для чего предназначена таблица символов. Например, таблицы отображения - это таблицы символов с &lt;code&gt;display-table&lt;/code&gt; в качестве подтипа, а таблицы синтаксиса - таблицы символов с &lt;code&gt;syntax-table&lt;/code&gt; в качестве подтипа. Подтип можно запросить с помощью функции &lt;code&gt;char-table-subtype&lt;/code&gt; , описанной ниже.</target>
        </trans-unit>
        <trans-unit id="68ac4cd83ea417c1f7f9af452e5cc5b822c521ce" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;utime&lt;/code&gt; and &lt;code&gt;stime&lt;/code&gt;. The corresponding &lt;var&gt;value&lt;/var&gt; is a Lisp timestamp.</source>
          <target state="translated">Сумма &lt;code&gt;utime&lt;/code&gt; и &lt;code&gt;stime&lt;/code&gt; . Соответствующее &lt;var&gt;value&lt;/var&gt; - метка времени Лиспа.</target>
        </trans-unit>
        <trans-unit id="d35712cec496be81a5cc381ab6d618570491eb43" translate="yes" xml:space="preserve">
          <source>The super modifier.</source>
          <target state="translated">Супер-модификатор.</target>
        </trans-unit>
        <trans-unit id="8e705c61a14589689176e3b34a3649287549f965" translate="yes" xml:space="preserve">
          <source>The sweep phase puts unused cons cells onto a &lt;em&gt;free list&lt;/em&gt; for future allocation; likewise for symbols and markers. It compacts the accessible strings so they occupy fewer 8k blocks; then it frees the other 8k blocks. Unreachable vectors from vector blocks are coalesced to create largest possible free areas; if a free area spans a complete 4k block, that block is freed. Otherwise, the free area is recorded in a free list array, where each entry corresponds to a free list of areas of the same size. Large vectors, buffers, and other large objects are allocated and freed individually.</source>
          <target state="translated">Фаза развертки помещает неиспользуемые cons-ячейки в &lt;em&gt;свободный список&lt;/em&gt; для будущего распределения; то же самое для символов и маркеров. Он сжимает доступные строки, поэтому они занимают меньше 8k блоков; затем он освобождает остальные 8k блоков. Недостижимые векторы из векторных блоков объединяются для создания максимально возможных свободных областей; если свободная область охватывает полный блок размером 4 КБ, этот блок освобождается. В противном случае свободная область записывается в массив свободных списков, где каждая запись соответствует свободному списку областей того же размера. Большие векторы, буферы и другие большие объекты выделяются и освобождаются индивидуально.</target>
        </trans-unit>
        <trans-unit id="80c81c27e3f0ac4ab84d01b9b6f0b0331d39a84e" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;-&lt;/code&gt;. This indicates that</source>
          <target state="translated">Символ &lt;code&gt;-&lt;/code&gt; . Это указывает на то, что</target>
        </trans-unit>
        <trans-unit id="d524cc19731a4d7319fdb32e1fd42c2468c1ccdb" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;undefined&lt;/code&gt; is worth special mention: it means to treat the key as undefined. Strictly speaking, the key is defined, and its binding is the command &lt;code&gt;undefined&lt;/code&gt;; but that command does the same thing that is done automatically for an undefined key: it rings the bell (by calling &lt;code&gt;ding&lt;/code&gt;) but does not signal an error.</source>
          <target state="translated">Особого упоминания заслуживает символ &lt;code&gt;undefined&lt;/code&gt; : он означает, что ключ следует рассматривать как неопределенный. Строго говоря, ключ определен, а его привязка - это команда &lt;code&gt;undefined&lt;/code&gt; ; но эта команда делает то же самое, что автоматически делается для неопределенного ключа: она звонит в колокольчик (вызывая &lt;code&gt;ding&lt;/code&gt; ), но не сигнализирует об ошибке.</target>
        </trans-unit>
        <trans-unit id="262aaa6e5851917f322ee907187b949e88c9ea3d" translate="yes" xml:space="preserve">
          <source>The symbol &lt;var&gt;var&lt;/var&gt; was defined as a variable.</source>
          <target state="translated">Символ &lt;var&gt;var&lt;/var&gt; был определен как переменная.</target>
        </trans-unit>
        <trans-unit id="5b0a7c1e7a600f3ceec6a0c096061763b149143e" translate="yes" xml:space="preserve">
          <source>The symbol must have an Edebug specification, which is used instead. This indirection is repeated until another kind of specification is found. This allows you to inherit the specification from another macro.</source>
          <target state="translated">Символ должен иметь спецификацию Edebug,которая используется вместо него.Это указание повторяется до тех пор,пока не будет найдена другая спецификация.Это позволяет унаследовать спецификацию от другого макроса.</target>
        </trans-unit>
        <trans-unit id="6db9e28485fd698ef52d7e3eb3a2773fea9702ff" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s current value as a variable.</source>
          <target state="translated">Текущее значение символа как переменная.</target>
        </trans-unit>
        <trans-unit id="a0a66fbe0304b2b0365a8eb85d918232ae7d5a27" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s function definition. It can also hold a symbol, a keymap, or a keyboard macro.</source>
          <target state="translated">Определение функции символа. Он также может содержать символ, раскладку клавиатуры или макрос клавиатуры.</target>
        </trans-unit>
        <trans-unit id="116bb8f437931ac9fdc82686fd01e5886bbdad99" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s name.</source>
          <target state="translated">Название символа.</target>
        </trans-unit>
        <trans-unit id="4815883f12f3ddda91c2ff86c5cf8ead169410ab" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s property list.</source>
          <target state="translated">Список свойств символа.</target>
        </trans-unit>
        <trans-unit id="0da588e9c066744bf4c6e6a6cdf66d1b7de2d7a2" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s value is used.</source>
          <target state="translated">Используется значение символа.</target>
        </trans-unit>
        <trans-unit id="4757d314ae2103a000ffd713b4431bdf90047a13" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; are treated specially, so that the value of &lt;code&gt;nil&lt;/code&gt; is always &lt;code&gt;nil&lt;/code&gt;, and the value of &lt;code&gt;t&lt;/code&gt; is always &lt;code&gt;t&lt;/code&gt;; you cannot set or bind them to any other values. Thus, these two symbols act like self-evaluating forms, even though &lt;code&gt;eval&lt;/code&gt; treats them like any other symbol. A symbol whose name starts with &amp;lsquo;</source>
          <target state="translated">Символы &lt;code&gt;nil&lt;/code&gt; и &lt;code&gt;t&lt;/code&gt; обрабатываются особым образом, так что значение &lt;code&gt;nil&lt;/code&gt; всегда равно &lt;code&gt;nil&lt;/code&gt; , а значение &lt;code&gt;t&lt;/code&gt; всегда равно &lt;code&gt;t&lt;/code&gt; ; вы не можете установить или привязать их к каким-либо другим значениям. Таким образом, эти два символа действуют как самооценочные формы, хотя &lt;code&gt;eval&lt;/code&gt; рассматривает их как любой другой символ. Символ, имя которого начинается с '</target>
        </trans-unit>
        <trans-unit id="f0a7fe54d498086e0224f1254ce0302e2d45b30e" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;user-login-name&lt;/code&gt;, &lt;code&gt;user-real-login-name&lt;/code&gt; and &lt;code&gt;user-full-name&lt;/code&gt; are variables as well as functions. The functions return the same values that the variables hold. These variables allow you to fake out Emacs by telling the functions what to return. The variables are also useful for constructing frame titles (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;).</source>
          <target state="translated">Символы &lt;code&gt;user-login-name&lt;/code&gt; , &lt;code&gt;user-real-login-name&lt;/code&gt; и &lt;code&gt;user-full-name&lt;/code&gt; являются переменными, а также функциями. Функции возвращают те же значения, что и переменные. Эти переменные позволяют обмануть Emacs, сообщая функциям, что возвращать. Переменные также полезны для создания заголовков фреймов (см. &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Названия&lt;/a&gt; фреймов ).</target>
        </trans-unit>
        <trans-unit id="0804f73f2468d63be3d44abb01edffb59c0ad975" translate="yes" xml:space="preserve">
          <source>The synchronous subprocess functions return an indication of how the process terminated.</source>
          <target state="translated">Функции синхронного подпроцесса возвращают индикацию завершения процесса.</target>
        </trans-unit>
        <trans-unit id="42db7ccb5bf39d0ef36aec66fdcf39beff2dbdf3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;(rose . violet . buttercup)&lt;/code&gt; is invalid because there is nothing that it could mean. If anything, it would say to put &lt;code&gt;buttercup&lt;/code&gt; in the &lt;small&gt;CDR&lt;/small&gt; of a cons cell whose &lt;small&gt;CDR&lt;/small&gt; is already used for &lt;code&gt;violet&lt;/code&gt;.</source>
          <target state="translated">Синтаксис &lt;code&gt;(rose . violet . buttercup)&lt;/code&gt; недействителен, потому что он ничего не может означать. Во всяком случае, он сказал бы поместить &lt;code&gt;buttercup&lt;/code&gt; в &lt;small&gt;CDR&lt;/small&gt; cons-ячейки, чья &lt;small&gt;CDR&lt;/small&gt; уже используется для &lt;code&gt;violet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cab7667e7d8ac62d20cdad9ef7c79cda38e5bc22" translate="yes" xml:space="preserve">
          <source>The syntax for integers in bases other than 10 consists of &amp;lsquo;</source>
          <target state="translated">Синтаксис целых чисел с основанием, отличным от 10, состоит из '</target>
        </trans-unit>
        <trans-unit id="88b43371f5f28d88c8b06cc0133c5c8be8a7772e" translate="yes" xml:space="preserve">
          <source>The syntax is changed only for &lt;var&gt;table&lt;/var&gt;, which defaults to the current buffer&amp;rsquo;s syntax table, and not in any other syntax table.</source>
          <target state="translated">Синтаксис изменяется только для &lt;var&gt;table&lt;/var&gt; , которая по умолчанию соответствует таблице синтаксиса текущего буфера, но не для любой другой таблицы синтаксиса.</target>
        </trans-unit>
        <trans-unit id="239ff1bb3df2ca92e1729acd450422ea90926247" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;EMACSLOADPATH&lt;/code&gt; is the same as used for &lt;code&gt;PATH&lt;/code&gt;; directories are separated by &amp;lsquo;</source>
          <target state="translated">Синтаксис &lt;code&gt;EMACSLOADPATH&lt;/code&gt; такой же, как и для &lt;code&gt;PATH&lt;/code&gt; ; каталоги разделяются '</target>
        </trans-unit>
        <trans-unit id="1999b037e6c53b71c64122a6e2bea19301ea2ee4" translate="yes" xml:space="preserve">
          <source>The syntax of format specifications accepted by &lt;code&gt;format-spec&lt;/code&gt; is similar, but not identical, to that accepted by &lt;code&gt;format&lt;/code&gt;. In both cases, a format specification is a sequence of characters beginning with &amp;lsquo;</source>
          <target state="translated">Синтаксис спецификации формата принятого &lt;code&gt;format-spec&lt;/code&gt; подобен, но не идентичен, к тому , что принято &lt;code&gt;format&lt;/code&gt; . В обоих случаях спецификация формата - это последовательность символов, начинающаяся с '</target>
        </trans-unit>
        <trans-unit id="a7719f40601bdc59c72de428210fe56812c73911" translate="yes" xml:space="preserve">
          <source>The syntax table controls the interpretation of characters, so these functions can be used for Lisp expressions when in Lisp mode and for C expressions when in C mode. See &lt;a href=&quot;list-motion#List-Motion&quot;&gt;List Motion&lt;/a&gt;, for convenient higher-level functions for moving over balanced expressions.</source>
          <target state="translated">Таблица синтаксиса управляет интерпретацией символов, поэтому эти функции могут использоваться для выражений Lisp в режиме Lisp и для выражений C в режиме C. См. Раздел &amp;laquo; Перемещение &lt;a href=&quot;list-motion#List-Motion&quot;&gt;списка&amp;raquo;&lt;/a&gt; для получения информации об удобных высокоуровневых функциях для перемещения по сбалансированным выражениям.</target>
        </trans-unit>
        <trans-unit id="1d3dd35ac27520d192421173419189f92bfde5f7" translate="yes" xml:space="preserve">
          <source>The syntax table controls word and list parsing.</source>
          <target state="translated">Таблица синтаксиса управляет разбором слов и списков.</target>
        </trans-unit>
        <trans-unit id="1b828fe7a14532d3214216229166278069ec53be" translate="yes" xml:space="preserve">
          <source>The tab character (character code 9) displays as whitespace stretching up to the next tab stop column. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Display.html#Text-Display&quot;&gt;Text Display&lt;/a&gt; in</source>
          <target state="translated">Символ табуляции (код символа 9) отображается как пробел, растягивающийся до следующего столбца табуляции. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Display.html#Text-Display&quot;&gt;Отображение текста&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="cf1dafcaadd381ea3ab28a9f4fdbcfdc0a3e6f6a" translate="yes" xml:space="preserve">
          <source>The tab character (character code 9) displays as whitespace stretching up to the next tab stop column. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Display.html#Text-Display&quot;&gt;Text Display&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdb77457b03ae8e4189510caa2d2cd8affcf775" translate="yes" xml:space="preserve">
          <source>The tail of the list, &lt;var&gt;item-property-list&lt;/var&gt;, has the form of a property list which contains other information.</source>
          <target state="translated">Конец списка, &lt;var&gt;item-property-list&lt;/var&gt; , имеет форму списка свойств, который содержит другую информацию.</target>
        </trans-unit>
        <trans-unit id="7527554605fcb9db76071476569c6f6b0cf4a1ce" translate="yes" xml:space="preserve">
          <source>The term &lt;em&gt;function&lt;/em&gt; refers to all Emacs functions, whether written in Lisp or C. See &lt;a href=&quot;function-type#Function-Type&quot;&gt;Function Type&lt;/a&gt;, for information about the functions written in Lisp.</source>
          <target state="translated">Термин &lt;em&gt;функция&lt;/em&gt; относится ко всем функциям Emacs, написанным на Лиспе или C. См. &lt;a href=&quot;function-type#Function-Type&quot;&gt;Тип функции&lt;/a&gt; для получения информации о функциях, написанных на Лиспе.</target>
        </trans-unit>
        <trans-unit id="bd8132ad5a485b9ab38224ae63509adce1e85797" translate="yes" xml:space="preserve">
          <source>The terminal and keyboard coding systems used on the terminal. See &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;Terminal I/O Encoding&lt;/a&gt;.</source>
          <target state="translated">Системы кодирования терминала и клавиатуры, используемые на терминале. См. &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;Кодирование терминального ввода-вывода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ad03be7d14630f60e2cb6b2a4f58289b95b8877" translate="yes" xml:space="preserve">
          <source>The terminal output functions send output to a text terminal, or keep track of output sent to the terminal. The variable &lt;code&gt;baud-rate&lt;/code&gt; tells you what Emacs thinks is the output speed of the terminal.</source>
          <target state="translated">Функции вывода терминала отправляют вывод на текстовый терминал или отслеживают вывод, отправленный на терминал. Переменная &lt;code&gt;baud-rate&lt;/code&gt; сообщает вам, что Emacs считает выходной скоростью терминала.</target>
        </trans-unit>
        <trans-unit id="3a63395bf693f4ea5dbf2a2a8a31fd4771954d08" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;line height&lt;/em&gt; and &lt;em&gt;canonical character height&lt;/em&gt; are sometimes used instead of &amp;ldquo;default character height&amp;rdquo;. Similarly, the terms &lt;em&gt;column width&lt;/em&gt; and &lt;em&gt;canonical character width&lt;/em&gt; are used instead of &amp;ldquo;default character width&amp;rdquo;.</source>
          <target state="translated">Иногда вместо &amp;laquo;высота символа по умолчанию&amp;raquo; используются термины &amp;laquo; &lt;em&gt;высота строки&amp;raquo;&lt;/em&gt; и &amp;laquo; &lt;em&gt;каноническая высота&lt;/em&gt; символа&amp;raquo;. Точно так же термины &amp;laquo; &lt;em&gt;ширина столбца&amp;raquo;&lt;/em&gt; и &amp;laquo; &lt;em&gt;каноническая ширина символа&amp;raquo;&lt;/em&gt; используются вместо &amp;laquo;ширина символа по умолчанию&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4e683c537d7a88f401925ed633251e10fa4e0d2a" translate="yes" xml:space="preserve">
          <source>The terms used herein, such as IV (Initialization Vector), require some familiarity with cryptography and will not be defined in detail. Please consult &lt;a href=&quot;https://www.gnutls.org/&quot;&gt;https://www.gnutls.org/&lt;/a&gt; for specific documentation which may help you understand the terminology and structure of the GnuTLS library.</source>
          <target state="translated">Используемые здесь термины, такие как IV (вектор инициализации), требуют некоторого знакомства с криптографией и не будут определяться подробно. Пожалуйста, обратитесь к &lt;a href=&quot;https://www.gnutls.org/&quot;&gt;https://www.gnutls.org/&lt;/a&gt; для получения конкретной документации, которая может помочь вам понять терминологию и структуру библиотеки GnuTLS.</target>
        </trans-unit>
        <trans-unit id="6650dc3f7c947a7cc0f8b1e2e8887236711ab190" translate="yes" xml:space="preserve">
          <source>The test for an existing file, when &lt;var&gt;mustbenew&lt;/var&gt; is &lt;code&gt;excl&lt;/code&gt;, uses a special system feature. At least for files on a local disk, there is no chance that some other program could create a file of the same name before Emacs does, without Emacs&amp;rsquo;s noticing.</source>
          <target state="translated">При проверке существующего файла, когда &lt;var&gt;mustbenew&lt;/var&gt; является &lt;code&gt;excl&lt;/code&gt; , используется специальная системная функция. По крайней мере, для файлов на локальном диске нет шансов, что какая-то другая программа сможет создать файл с тем же именем раньше, чем это сделает Emacs, без ведома Emacs.</target>
        </trans-unit>
        <trans-unit id="f4bec060d8606173e4510214d476948b1b689bd6" translate="yes" xml:space="preserve">
          <source>The text between point and the mark is known as &lt;em&gt;the region&lt;/em&gt;. Various functions operate on text delimited by point and the mark, but only those functions specifically related to the region itself are described here.</source>
          <target state="translated">Текст между точкой и меткой называется &lt;em&gt;областью&lt;/em&gt; . Различные функции работают с текстом, разделенным точкой и меткой, но здесь описаны только те функции, которые относятся к самой области.</target>
        </trans-unit>
        <trans-unit id="427235673649693cef34eec5a1c49c535c367214" translate="yes" xml:space="preserve">
          <source>The text in the minibuffer always starts with the &lt;em&gt;prompt string&lt;/em&gt;, the text that was specified by the program that is using the minibuffer to tell the user what sort of input to type. This text is marked read-only so you won&amp;rsquo;t accidentally delete or change it. It is also marked as a field (see &lt;a href=&quot;fields#Fields&quot;&gt;Fields&lt;/a&gt;), so that certain motion functions, including &lt;code&gt;beginning-of-line&lt;/code&gt;, &lt;code&gt;forward-word&lt;/code&gt;, &lt;code&gt;forward-sentence&lt;/code&gt;, and &lt;code&gt;forward-paragraph&lt;/code&gt;, stop at the boundary between the prompt and the actual text.</source>
          <target state="translated">Текст в минибуфере всегда начинается со &lt;em&gt;строки приглашения&lt;/em&gt; , текста, который был задан программой, использующей минибуфер, чтобы сообщить пользователю, какой тип ввода вводить. Этот текст помечен как доступный только для чтения, поэтому вы случайно не удалите или не измените его. Он также отмечен как поле (см &lt;a href=&quot;fields#Fields&quot;&gt;Fields&lt;/a&gt; ), так что некоторые функции движения, в том числе &lt;code&gt;beginning-of-line&lt;/code&gt; , &lt;code&gt;forward-word&lt;/code&gt; , &lt;code&gt;forward-sentence&lt;/code&gt; , и &lt;code&gt;forward-paragraph&lt;/code&gt; , остановка на границе между оперативным и самим текстом.</target>
        </trans-unit>
        <trans-unit id="e254c01685b37e41ab942a41fbf59829e6d11ec6" translate="yes" xml:space="preserve">
          <source>The text of the indirect buffer is always identical to the text of its base buffer; changes made by editing either one are visible immediately in the other. This includes the text properties as well as the characters themselves.</source>
          <target state="translated">Текст косвенного буфера всегда идентичен тексту его базового буфера;изменения,внесенные путем редактирования одного из них,сразу видны в другом.Сюда относятся свойства текста,а также сами символы.</target>
        </trans-unit>
        <trans-unit id="af246ddc000534af5859563e36f5153516e93316" translate="yes" xml:space="preserve">
          <source>The text properties &lt;code&gt;front-sticky&lt;/code&gt; and &lt;code&gt;rear-nonsticky&lt;/code&gt;, when used, take precedence over the default &lt;var&gt;nonstickiness&lt;/var&gt; specified in &lt;code&gt;text-property-default-nonsticky&lt;/code&gt;.</source>
          <target state="translated">Свойства текста &lt;code&gt;front-sticky&lt;/code&gt; и &lt;code&gt;rear-nonsticky&lt;/code&gt; , когда они используются, имеют приоритет над &lt;var&gt;nonstickiness&lt;/var&gt; по умолчанию, заданной в &lt;code&gt;text-property-default-nonsticky&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61de37a77d48c5a03418142f4c57cbd435c8202a" translate="yes" xml:space="preserve">
          <source>The text properties in &lt;code&gt;minibuffer-prompt-properties&lt;/code&gt; are applied to the prompt. By default, this property list defines a face to use for the prompt. This face, if present, is applied to the end of the face list and merged before display.</source>
          <target state="translated">Свойства текста в свойствах &lt;code&gt;minibuffer-prompt-properties&lt;/code&gt; применяются к подсказке. По умолчанию этот список свойств определяет лицо, используемое для приглашения. Это лицо, если оно есть, применяется к концу списка лиц и объединяется перед отображением.</target>
        </trans-unit>
        <trans-unit id="53d1c0b3638f705814caf89c18a7ce3da885e071" translate="yes" xml:space="preserve">
          <source>The text size of any frame can be set and retrieved with the help of the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; frame parameters (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;). The text size of the initial frame can be also set with the help of an X-style geometry specification. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Invocation.html#Emacs-Invocation&quot;&gt;Command Line Arguments for Emacs Invocation&lt;/a&gt; in</source>
          <target state="translated">Размер текста любого фрейма можно задать и получить с помощью параметров фрейма &lt;code&gt;height&lt;/code&gt; и &lt;code&gt;width&lt;/code&gt; (см. &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Параметры размера&lt;/a&gt; ). Размер текста исходного фрейма также может быть установлен с помощью спецификации геометрии в стиле X. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Invocation.html#Emacs-Invocation&quot;&gt;Аргументы командной строки для вызова Emacs&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="eda7e7ff0a0945b0a426e8efa30587133000d2d3" translate="yes" xml:space="preserve">
          <source>The text size of any frame can be set and retrieved with the help of the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; frame parameters (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;). The text size of the initial frame can be also set with the help of an X-style geometry specification. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Invocation.html#Emacs-Invocation&quot;&gt;Command Line Arguments for Emacs Invocation&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67ee1668cafc5069fd19fd9ac4ce5d1dfafd95a" translate="yes" xml:space="preserve">
          <source>The text&amp;rsquo;s start position in the buffer.</source>
          <target state="translated">Начальная позиция текста в буфере.</target>
        </trans-unit>
        <trans-unit id="459ecfaa7406a56efb8cf84eab33df64259674fe" translate="yes" xml:space="preserve">
          <source>The third argument &lt;var&gt;keep-time&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to preserve the modification time of the copied files. A prefix arg makes &lt;var&gt;keep-time&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Третий аргумент &lt;var&gt;keep-time&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; означает сохранение времени модификации скопированных файлов. Префикс arg делает время &lt;var&gt;keep-time&lt;/var&gt; отличным от &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da9ba46202c97f906aff04419daf0a2467b172a5" translate="yes" xml:space="preserve">
          <source>The third element is the window selected at the time the parameter was created. If this function deletes &lt;var&gt;window&lt;/var&gt;, it subsequently tries to reselect the window named by that element.</source>
          <target state="translated">Третий элемент - это окно, выбранное во время создания параметра. Если эта функция удаляет &lt;var&gt;window&lt;/var&gt; , она впоследствии пытается повторно выбрать окно, названное этим элементом.</target>
        </trans-unit>
        <trans-unit id="290b74a62fe3a2fe85d724d61465dc891525fd6f" translate="yes" xml:space="preserve">
          <source>The third element, &lt;var&gt;case-fold&lt;/var&gt;, specifies the value of &lt;code&gt;font-lock-keywords-case-fold-search&lt;/code&gt;. If it is non-&lt;code&gt;nil&lt;/code&gt;, Font Lock mode ignores case during search-based fontification.</source>
          <target state="translated">Третий элемент, &lt;var&gt;case-fold&lt;/var&gt; , определяет значение &lt;code&gt;font-lock-keywords-case-fold-search&lt;/code&gt; . Если оно не равно &lt;code&gt;nil&lt;/code&gt; , режим Font Lock игнорирует регистр во время фонификации на основе поиска.</target>
        </trans-unit>
        <trans-unit id="a0049f036ce91322d4b97e568763827ed24c4fa6" translate="yes" xml:space="preserve">
          <source>The third element, &lt;var&gt;real-binding&lt;/var&gt;, can be the command to execute (in which case you get a normal menu item). It can also be a keymap, which will result in a submenu. Finally, it can be &lt;code&gt;nil&lt;/code&gt;, in which case you will get a non-selectable menu item. This is mostly useful when creating separator lines and the like.</source>
          <target state="translated">Третий элемент, &lt;var&gt;real-binding&lt;/var&gt; , может быть командой для выполнения (в этом случае вы получаете обычный пункт меню). Это также может быть раскладка клавиатуры, которая приведет к подменю. Наконец, он может быть равен &lt;code&gt;nil&lt;/code&gt; , и в этом случае вы получите недоступный для выбора пункт меню. Это в основном полезно при создании разделительных линий и т.п.</target>
        </trans-unit>
        <trans-unit id="5ded74e35ae11b189414eb3a2feeeaf0372642b2" translate="yes" xml:space="preserve">
          <source>The third of these hooks is run when a &lt;em&gt;window selection change&lt;/em&gt; has selected another window since the last redisplay.</source>
          <target state="translated">Третий из этих хуков запускается, когда при &lt;em&gt;изменении выбора окна&lt;/em&gt; было выбрано другое окно с момента последнего повторного отображения.</target>
        </trans-unit>
        <trans-unit id="c89651a099ca91af6c8a8b83f402ae4da806d1ff" translate="yes" xml:space="preserve">
          <source>The third part of the pattern matches the whitespace that follows the end of a sentence: the end of a line (optionally with a space), or a tab, or two spaces. The double backslashes mark the parentheses and vertical bars as regular expression syntax; the parentheses delimit a group and the vertical bars separate alternatives. The dollar sign is used to match the end of a line.</source>
          <target state="translated">Третья часть шаблона соответствует пробелу,который следует за концом предложения:конец строки (по желанию с пробелом),или табуляция,или два пробела.Двойные обратные слеши обозначают круглые скобки и вертикальные столбики как синтаксис регулярного выражения;круглые скобки разделяют группу,а вертикальные столбики-как отдельные альтернативы.Знак доллара используется для обозначения конца строки.</target>
        </trans-unit>
        <trans-unit id="607c3d642b7b987d71b42da79930af648e956246" translate="yes" xml:space="preserve">
          <source>The three Lisp modes (Lisp mode, Emacs Lisp mode, and Lisp Interaction mode) have more features than Text mode and the code is correspondingly more complicated. Here are excerpts from</source>
          <target state="translated">Три режима Лисп (режим Лисп,режим Эмакс Лисп и режим Взаимодействия Лисп)имеют больше возможностей,чем Текстовый режим,и,соответственно,код сложнее.Вот выдержки из</target>
        </trans-unit>
        <trans-unit id="45ee5df28937c07f3548f70fd6cc8c94bf25c3ce" translate="yes" xml:space="preserve">
          <source>The three modes for Lisp share much of their code. For instance, each calls the following function to set various variables:</source>
          <target state="translated">Три режима для Лисп разделяют большую часть своего кода.Например,каждый из них вызывает следующую функцию для установки различных переменных:</target>
        </trans-unit>
        <trans-unit id="54870091d56fd5e724ee385ddc157eb207f13d76" translate="yes" xml:space="preserve">
          <source>The time at which the event occurred, as an integer number of milliseconds since a system-dependent initial time.</source>
          <target state="translated">Время,в течение которого произошло событие,в виде целого числа миллисекунд с системно-зависимого начального времени.</target>
        </trans-unit>
        <trans-unit id="1ebfb539c64783c4344442794aee02ad7006a6f2" translate="yes" xml:space="preserve">
          <source>The time at which the event occurred, in milliseconds. On some toolkits, including GTK+, Emacs cannot extract this data, so the value is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Время, в которое произошло событие, в миллисекундах. В некоторых наборах инструментов, включая GTK +, Emacs не может извлечь эти данные, поэтому значение всегда равно &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98e57126dedf2d6400ffdfdef20aa57a4ca36ef3" translate="yes" xml:space="preserve">
          <source>The time elapsed since the process started, as a Lisp timestamp.</source>
          <target state="translated">Время,прошедшее с момента начала процесса,как временная метка Листа.</target>
        </trans-unit>
        <trans-unit id="00b925b3b99613c5ebaf63a3e99e731129a59a23" translate="yes" xml:space="preserve">
          <source>The time of last access as a Lisp timestamp (&lt;code&gt;file-attribute-access-time&lt;/code&gt;). The timestamp is in the style of &lt;code&gt;current-time&lt;/code&gt; (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;) and is truncated to that of the filesystem&amp;rsquo;s timestamp resolution; for example, on some FAT-based filesystems, only the date of last access is recorded, so this time will always hold the midnight of the day of the last access.</source>
          <target state="translated">Время последнего доступа в виде отметки времени Lisp (время- &lt;code&gt;file-attribute-access-time&lt;/code&gt; ). &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Временная&lt;/a&gt; метка имеет стиль &lt;code&gt;current-time&lt;/code&gt; (см. &amp;laquo; Время дня&amp;raquo; ) и усечена до разрешения временной метки файловой системы; например, в некоторых файловых системах на основе FAT записывается только дата последнего доступа, поэтому на этот раз всегда будет находиться полночь дня последнего доступа.</target>
        </trans-unit>
        <trans-unit id="96f255ff11207f96a6ff4be345f0df83a02d827c" translate="yes" xml:space="preserve">
          <source>The time of last modification as a Lisp timestamp (&lt;code&gt;file-attribute-modification-time&lt;/code&gt;). This is the last time when the file&amp;rsquo;s contents were modified.</source>
          <target state="translated">Время последней модификации в виде отметки времени Lisp (время &lt;code&gt;file-attribute-modification-time&lt;/code&gt; ). Это последний раз, когда содержимое файла было изменено.</target>
        </trans-unit>
        <trans-unit id="7647d2bb474bf5d47880005e9fa4aa2091b44379" translate="yes" xml:space="preserve">
          <source>The time of last status change as a Lisp timestamp (&lt;code&gt;file-attribute-status-change-time&lt;/code&gt;). This is the time of the last change to the file&amp;rsquo;s access mode bits, its owner and group, and other information recorded in the filesystem for the file, beyond the file&amp;rsquo;s contents.</source>
          <target state="translated">Время последнего изменения статуса в виде отметки времени Lisp ( &lt;code&gt;file-attribute-status-change-time&lt;/code&gt; ). Это время последнего изменения битов режима доступа к файлу, его владельца и группы, а также другой информации, записанной в файловой системе для файла, помимо содержимого файла.</target>
        </trans-unit>
        <trans-unit id="24c20ed315222312a2625d91bebf7c20d8b009b0" translate="yes" xml:space="preserve">
          <source>The time to use &lt;code&gt;make-variable-buffer-local&lt;/code&gt; is when it is crucial that no two buffers ever share the same binding. For example, when a variable is used for internal purposes in a Lisp program which depends on having separate values in separate buffers, then using &lt;code&gt;make-variable-buffer-local&lt;/code&gt; can be the best solution.</source>
          <target state="translated">Время использовать &lt;code&gt;make-variable-buffer-local&lt;/code&gt; - это когда критически важно, чтобы никакие два буфера никогда не использовали одну и ту же привязку. Например, когда переменная используется для внутренних целей в программе на Лиспе, которая зависит от наличия отдельных значений в отдельных буферах, тогда использование &lt;code&gt;make-variable-buffer-local&lt;/code&gt; может быть лучшим решением.</target>
        </trans-unit>
        <trans-unit id="c627015afbabd38bf35740a5ee9f2c3cb23dc48d" translate="yes" xml:space="preserve">
          <source>The time when the buffer was last auto-saved.</source>
          <target state="translated">Время,когда буфер был последним автосохранением.</target>
        </trans-unit>
        <trans-unit id="1e0d0c1f4808016965104728546b5791c182f028" translate="yes" xml:space="preserve">
          <source>The time when the process was started, as a Lisp timestamp.</source>
          <target state="translated">Время,когда процесс был начат,как временная метка Липа.</target>
        </trans-unit>
        <trans-unit id="802393edc2b9a42653a80bc4d4ec3e5e5f24f1f4" translate="yes" xml:space="preserve">
          <source>The timeout time in milliseconds since the display of the notification at which the notification should automatically close. If -1, the notification&amp;rsquo;s expiration time is dependent on the notification server&amp;rsquo;s settings, and may vary for the type of notification. If 0, the notification never expires. Default value is -1.</source>
          <target state="translated">Время ожидания в миллисекундах с момента отображения уведомления, по истечении которого уведомление должно автоматически закрыться. Если -1, время истечения срока действия уведомления зависит от настроек сервера уведомлений и может различаться в зависимости от типа уведомления. Если 0, срок уведомления никогда не истекает. Значение по умолчанию -1.</target>
        </trans-unit>
        <trans-unit id="5f4688992c1cae810c4b2847d1acc4a25d6a81f0" translate="yes" xml:space="preserve">
          <source>The title (only on a window system) or the name of the selected frame. See &lt;a href=&quot;basic-parameters#Basic-Parameters&quot;&gt;Basic Parameters&lt;/a&gt;.</source>
          <target state="translated">Заголовок (только в оконной системе) или имя выбранного фрейма. См. &lt;a href=&quot;basic-parameters#Basic-Parameters&quot;&gt;Основные параметры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00a751eb6540114fecfd6321e7957f9e5fe58259" translate="yes" xml:space="preserve">
          <source>The title of the notification. If &lt;var&gt;title&lt;/var&gt; is a string, it is displayed in a larger font immediately above the body text. The title text can be up to 63 characters long; longer text will be truncated.</source>
          <target state="translated">Заголовок уведомления. Если &lt;var&gt;title&lt;/var&gt; является строкой, он отображается более крупным шрифтом непосредственно над основным текстом. Текст заголовка может содержать до 63 символов; более длинный текст будет обрезан.</target>
        </trans-unit>
        <trans-unit id="fb5b566b508b98eab0c7c5b9ce2a802059ff0fbe" translate="yes" xml:space="preserve">
          <source>The toggle command takes one optional (prefix) argument. If called interactively with no argument it toggles the mode on or off. A positive prefix argument enables the mode, any other prefix argument disables it. From Lisp, an argument of &lt;code&gt;toggle&lt;/code&gt; toggles the mode, whereas an omitted or &lt;code&gt;nil&lt;/code&gt; argument enables the mode. This makes it easy to enable the minor mode in a major mode hook, for example. If &lt;var&gt;doc&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the macro supplies a default documentation string explaining the above.</source>
          <target state="translated">Команда переключения принимает один необязательный (префиксный) аргумент. Если вызывается в интерактивном режиме без аргументов, он включает или выключает режим. Положительный аргумент префикса включает режим, любой другой аргумент префикса отключает его. В Лиспе аргумент &lt;code&gt;toggle&lt;/code&gt; переключает режим, тогда как опущенный аргумент или аргумент &lt;code&gt;nil&lt;/code&gt; включает режим. Это упрощает, например, включение второстепенного режима в ловушке основного режима. Если &lt;var&gt;doc&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , макрос предоставляет строку документации по умолчанию, объясняющую вышеизложенное.</target>
        </trans-unit>
        <trans-unit id="ee396be1bc2edeec5a010e520887af01b2c0ec1a" translate="yes" xml:space="preserve">
          <source>The tool bar contents are controlled by a menu keymap attached to a fake function key called</source>
          <target state="translated">Содержимое панели инструментов управляется с помощью клавиатуры меню,прикрепленной к поддельной функциональной клавише с именем</target>
        </trans-unit>
        <trans-unit id="c8e2bf3f449141de6022307bd19ac291ae6a42dd" translate="yes" xml:space="preserve">
          <source>The top edge of the window, measured in lines, relative to the topmost line (line 0) of the window&amp;rsquo;s native frame.</source>
          <target state="translated">Верхний край окна, измеряемый в строках, относительно самой верхней линии (строка 0) собственного фрейма окна.</target>
        </trans-unit>
        <trans-unit id="80ecb166938baeaaabb20112d9fe96a939c773d4" translate="yes" xml:space="preserve">
          <source>The top level variable, mode-line-format.</source>
          <target state="translated">Переменная верхнего уровня,модно-линейный формат.</target>
        </trans-unit>
        <trans-unit id="10fcd8fbdfa1f56f99b62be921ede3801375f31b" translate="yes" xml:space="preserve">
          <source>The top-level forms in the file defining the mode should be written so that they may be evaluated more than once without adverse consequences. For instance, use &lt;code&gt;defvar&lt;/code&gt; or &lt;code&gt;defcustom&lt;/code&gt; to set mode-related variables, so that they are not reinitialized if they already have a value (see &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;).</source>
          <target state="translated">Формы верхнего уровня в файле, определяющие режим, должны быть написаны так, чтобы их можно было оценивать более одного раза без неблагоприятных последствий. Например, используйте &lt;code&gt;defvar&lt;/code&gt; или &lt;code&gt;defcustom&lt;/code&gt; для установки переменных, связанных с режимом, чтобы они не переинициализировались, если они уже имеют значение (см. &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Определение переменных&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e0bf6b79b51361600ab0d2d09d4929d9f08d380a" translate="yes" xml:space="preserve">
          <source>The total height of each display line consists of the height of the contents of the line, plus optional additional vertical line spacing above or below the display line.</source>
          <target state="translated">Общая высота каждой строки дисплея складывается из высоты содержимого строки,а также дополнительного вертикального расстояния между строками над или под строкой дисплея.</target>
        </trans-unit>
        <trans-unit id="31d0e82b6a88e74d0b24a216385d5fc85a5cec98" translate="yes" xml:space="preserve">
          <source>The total length, in pixels, of the scroll bar. On some toolkits, including GTK+, Emacs cannot extract this data, so the value is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Общая длина полосы прокрутки в пикселях. В некоторых наборах инструментов, включая GTK +, Emacs не может извлечь эти данные, поэтому значение всегда равно &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b25cf92e537fbc457f73f8b8ccd34da35b4b1e0f" translate="yes" xml:space="preserve">
          <source>The total number of cons cells that have been allocated so far in this Emacs session.</source>
          <target state="translated">Общее количество конс-ячеек,которые были распределены до сих пор в этом сеансе Emacs.</target>
        </trans-unit>
        <trans-unit id="a994cddf9b826ab8c3b89d449d09ae2a9b73e706" translate="yes" xml:space="preserve">
          <source>The total number of floats that have been allocated so far in this Emacs session.</source>
          <target state="translated">Общее количество флотов,выделенных до сих пор в этой сессии Emacs.</target>
        </trans-unit>
        <trans-unit id="fdcf07b9e5a059b00bbaae5593cd683d00025222" translate="yes" xml:space="preserve">
          <source>The total number of intervals that have been allocated so far in this Emacs session.</source>
          <target state="translated">Общее количество интервалов,которые были распределены до сих пор в этой сессии Emacs.</target>
        </trans-unit>
        <trans-unit id="614654e18f37f5b5f422dea3bbdcbb3a165f297e" translate="yes" xml:space="preserve">
          <source>The total number of string characters that have been allocated so far in this session.</source>
          <target state="translated">Общее количество символов строки,выделенных до сих пор в этой сессии.</target>
        </trans-unit>
        <trans-unit id="abb717f47f8933d7923fb2b52cfb28bd464f36e9" translate="yes" xml:space="preserve">
          <source>The total number of strings that have been allocated so far in this Emacs session.</source>
          <target state="translated">Общее количество строк,которые были выделены до сих пор в этой сессии Emacs.</target>
        </trans-unit>
        <trans-unit id="e9b8f06e1c94173e7b8d8a404718b1b724454813" translate="yes" xml:space="preserve">
          <source>The total number of symbols that have been allocated so far in this Emacs session.</source>
          <target state="translated">Общее количество символов,которые были выделены до сих пор в этой сессии Emacs.</target>
        </trans-unit>
        <trans-unit id="27a10a08d892e6a91c5cf07d46fe77aa2af1a3fa" translate="yes" xml:space="preserve">
          <source>The total number of vector cells that have been allocated so far in this Emacs session. This includes vector-like objects such as markers and overlays, plus certain objects not visible to users.</source>
          <target state="translated">Общее количество векторных ячеек,выделенных до сих пор в этом сеансе Emacs.Сюда входят векторные объекты,такие как маркеры и оверлеи,а также некоторые объекты,невидимые пользователям.</target>
        </trans-unit>
        <trans-unit id="441a3e680eaafec796a9e2a7060e2a280535485a" translate="yes" xml:space="preserve">
          <source>The total size of all string data in bytes.</source>
          <target state="translated">Общий размер всех строковых данных в байтах.</target>
        </trans-unit>
        <trans-unit id="c7d14b13c564dd0ff16404189a2b255627fffdf3" translate="yes" xml:space="preserve">
          <source>The total width and height of the window measured in pixels.</source>
          <target state="translated">Общая ширина и высота окна измеряются в пикселях.</target>
        </trans-unit>
        <trans-unit id="1ccf2de5b65512cde61e59a9ed444c1197414f54" translate="yes" xml:space="preserve">
          <source>The total width and height of the window, measured in columns and lines respectively. The values include scroll bars and fringes, dividers and/or the separator line on the right of the window (if any).</source>
          <target state="translated">Общая ширина и высота окна,измеренные в столбцах и линиях соответственно.Значения включают полосы прокрутки и бахромы,перегородки и/или линию разделителя справа от окна (если таковая имеется).</target>
        </trans-unit>
        <trans-unit id="bc966a52b3595d2fcaff1f0ffe9ad07780edb9e3" translate="yes" xml:space="preserve">
          <source>The translation table &lt;var&gt;table&lt;/var&gt; is a string or a char-table; &lt;code&gt;(aref &lt;var&gt;table&lt;/var&gt; &lt;var&gt;ochar&lt;/var&gt;)&lt;/code&gt; gives the translated character corresponding to &lt;var&gt;ochar&lt;/var&gt;. If &lt;var&gt;table&lt;/var&gt; is a string, any characters with codes larger than the length of &lt;var&gt;table&lt;/var&gt; are not altered by the translation.</source>
          <target state="translated">Таблица &lt;var&gt;table&lt;/var&gt; перевода представляет собой строку или таблицу символов; &lt;code&gt;(aref &lt;var&gt;table&lt;/var&gt; &lt;var&gt;ochar&lt;/var&gt;)&lt;/code&gt; дает переведенный символ, соответствующий &lt;var&gt;ochar&lt;/var&gt; . Если &lt;var&gt;table&lt;/var&gt; является строкой, любые символы с кодами, превышающими длину &lt;var&gt;table&lt;/var&gt; , переводом не изменяются.</target>
        </trans-unit>
        <trans-unit id="397c955cc662600cfb57e3c9c25331b73b22fe24" translate="yes" xml:space="preserve">
          <source>The two constructs described next are mostly identical to &lt;code&gt;with-temp-buffer-window&lt;/code&gt; but differ from it as specified:</source>
          <target state="translated">Две описанные ниже конструкции в основном идентичны &lt;code&gt;with-temp-buffer-window&lt;/code&gt; , но отличаются от нее указанным ниже образом:</target>
        </trans-unit>
        <trans-unit id="04a05211cdc885470090771446510a238e8b75f7" translate="yes" xml:space="preserve">
          <source>The type &lt;var&gt;type&lt;/var&gt; was defined.</source>
          <target state="translated">Тип &lt;var&gt;type&lt;/var&gt; был определен.</target>
        </trans-unit>
        <trans-unit id="9989a67db7c219bdacd778e97cc75a29828fcbdc" translate="yes" xml:space="preserve">
          <source>The type of connection. Options are:</source>
          <target state="translated">Тип соединения.Возможны варианты:</target>
        </trans-unit>
        <trans-unit id="10723b34477adf1a54c090dcb75c1b850f7f8519" translate="yes" xml:space="preserve">
          <source>The type of flow control to use for this connection, which is either &lt;code&gt;nil&lt;/code&gt; (don&amp;rsquo;t use flow control), the symbol &lt;code&gt;hw&lt;/code&gt; (use RTS/CTS hardware flow control), or the symbol &lt;code&gt;sw&lt;/code&gt; (use XON/XOFF software flow control). If &lt;var&gt;flowcontrol&lt;/var&gt; is not given, it defaults to no flow control.</source>
          <target state="translated">Тип управления потоком, который следует использовать для этого соединения: либо &lt;code&gt;nil&lt;/code&gt; (не использовать управление потоком), либо символ &lt;code&gt;hw&lt;/code&gt; (использовать аппаратное управление потоком RTS / CTS), либо символ &lt;code&gt;sw&lt;/code&gt; (использовать программное управление потоком XON / XOFF) . Если управление &lt;var&gt;flowcontrol&lt;/var&gt; не задано, по умолчанию не используется управление потоком.</target>
        </trans-unit>
        <trans-unit id="824546068f92ce5ea60e0deff376010de3e1fec4" translate="yes" xml:space="preserve">
          <source>The type of icon to use for this frame. If the value is a string, that specifies a file containing a bitmap to use; &lt;code&gt;nil&lt;/code&gt; specifies no icon (in which case the window manager decides what to show); any other non-&lt;code&gt;nil&lt;/code&gt; value specifies the default Emacs icon.</source>
          <target state="translated">Тип значка, который будет использоваться для этого фрейма. Если значение является строкой, это указывает файл, содержащий растровое изображение для использования; &lt;code&gt;nil&lt;/code&gt; не указывает значок (в этом случае оконный менеджер решает, что показывать); любое другое значение, отличное от &lt;code&gt;nil&lt;/code&gt; , определяет значок Emacs по умолчанию.</target>
        </trans-unit>
        <trans-unit id="77d40006d2d51026df28ce9827773f880edd24d6" translate="yes" xml:space="preserve">
          <source>The type of notification this is, a string. See the &lt;a href=&quot;https://developer.gnome.org/notification-spec/#categories&quot;&gt;Desktop Notifications Specification&lt;/a&gt; for a list of standard categories.</source>
          <target state="translated">Тип уведомления - строка. Список стандартных категорий см. В &lt;a href=&quot;https://developer.gnome.org/notification-spec/#categories&quot;&gt;Спецификации уведомлений&lt;/a&gt; на рабочем столе .</target>
        </trans-unit>
        <trans-unit id="55bdf0d544649480b63a1172ccccf6ea3ae2d63d" translate="yes" xml:space="preserve">
          <source>The type slot should be a symbol or a type descriptor. If it&amp;rsquo;s a type descriptor, the symbol naming its type will be returned; &lt;a href=&quot;type-descriptors#Type-Descriptors&quot;&gt;Type Descriptors&lt;/a&gt;. Any other kind of object is returned as-is.</source>
          <target state="translated">Слот типа должен быть символом или дескриптором типа. Если это дескриптор типа, будет возвращен символ, обозначающий его тип; &lt;a href=&quot;type-descriptors#Type-Descriptors&quot;&gt;Дескрипторы типа&lt;/a&gt; . Любой другой объект возвращается как есть.</target>
        </trans-unit>
        <trans-unit id="e025c62fbc48998b73600c44b54165169adc5d17" translate="yes" xml:space="preserve">
          <source>The type specializer, &lt;code&gt;(&lt;var&gt;arg&lt;/var&gt; &lt;var&gt;type&lt;/var&gt;)&lt;/code&gt;, can specify one of the &lt;em&gt;system types&lt;/em&gt; in the following list. When a parent type is specified, an argument whose type is any of its more specific child types, as well as grand-children, grand-grand-children, etc. will also be compatible.</source>
          <target state="translated">Специализатор типов &lt;code&gt;(&lt;var&gt;arg&lt;/var&gt; &lt;var&gt;type&lt;/var&gt;)&lt;/code&gt; может указывать один из &lt;em&gt;типов системы&lt;/em&gt; в следующем списке. Когда указан родительский тип, аргумент, тип которого является любым из его более конкретных дочерних типов, а также внучатыми, внучатыми и т. Д., Также будет совместим.</target>
        </trans-unit>
        <trans-unit id="918de08f5d10241b12396b2606b071d4bc53db4a" translate="yes" xml:space="preserve">
          <source>The type, height, and width of the cursor that was last displayed on this window.</source>
          <target state="translated">Тип,высота и ширина курсора,который последний раз отображался в этом окне.</target>
        </trans-unit>
        <trans-unit id="813fe6c3982289dedb90eb513614087f1cf82291" translate="yes" xml:space="preserve">
          <source>The types in the previous section are used for general programming purposes, and most of them are common to most Lisp dialects. Emacs Lisp provides several additional data types for purposes connected with editing.</source>
          <target state="translated">Типы,приведенные в предыдущем разделе,используются для общих целей программирования,и большинство из них являются общими для большинства диалектов Lisp.Emacs Lisp предоставляет несколько дополнительных типов данных для целей,связанных с редактированием.</target>
        </trans-unit>
        <trans-unit id="e4129664d859d9f2877eb29408df21ab5cb6661f" translate="yes" xml:space="preserve">
          <source>The types of this window&amp;rsquo;s vertical and horizontal scroll bars.</source>
          <target state="translated">Типы вертикальной и горизонтальной полос прокрутки этого окна.</target>
        </trans-unit>
        <trans-unit id="4ebd8369f764b15f8731d7001594b37607f527c5" translate="yes" xml:space="preserve">
          <source>The underlying ACL implementation is platform-specific; on GNU/Linux and BSD, Emacs uses the POSIX ACL interface, while on MS-Windows Emacs emulates the POSIX ACL interface with native file security APIs.</source>
          <target state="translated">Базовая реализация ACL специфична для платформы;в GNU/Linux и BSD Emacs использует ACL-интерфейс POSIX,в то время как в MS-Windows Emacs эмулирует ACL-интерфейс POSIX с собственными API-интерфейсами безопасности файлов.</target>
        </trans-unit>
        <trans-unit id="32e0037f866c0451ac34d2bce4ba7d40d8a695e5" translate="yes" xml:space="preserve">
          <source>The unibyte and multibyte text representations use different character codes. The valid character codes for unibyte representation range from 0 to &lt;code&gt;#xFF&lt;/code&gt; (255)&amp;mdash;the values that can fit in one byte. The valid character codes for multibyte representation range from 0 to &lt;code&gt;#x3FFFFF&lt;/code&gt;. In this code space, values 0 through &lt;code&gt;#x7F&lt;/code&gt; (127) are for</source>
          <target state="translated">В однобайтовых и многобайтовых текстовых представлениях используются разные коды символов. Допустимые коды символов для однобайтового представления варьируются от 0 до &lt;code&gt;#xFF&lt;/code&gt; (255) - значения, которые могут поместиться в один байт. Допустимые коды символов для многобайтового представления находятся в диапазоне от 0 до &lt;code&gt;#x3FFFFF&lt;/code&gt; . В этом кодовом пространстве значения от 0 до &lt;code&gt;#x7F&lt;/code&gt; (127) предназначены для</target>
        </trans-unit>
        <trans-unit id="9cca45442a6da20dbdae7b6615f2dc10baadc419" translate="yes" xml:space="preserve">
          <source>The unit of heap space measurement, always equal to 1024 bytes.</source>
          <target state="translated">Единица измерения пространства кучи,всегда равна 1024 байтам.</target>
        </trans-unit>
        <trans-unit id="63b023b466e3bce22e9d5ba36aecbcf660e048b0" translate="yes" xml:space="preserve">
          <source>The upcase table maps each character into the corresponding upper case character.</source>
          <target state="translated">В верхней строке таблицы каждый символ отображается в соответствующий символ в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="a0c17633f0138ef3e9286c2d1a5c0258bfdb10e0" translate="yes" xml:space="preserve">
          <source>The urgency level. It can be &lt;code&gt;low&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, or &lt;code&gt;critical&lt;/code&gt;.</source>
          <target state="translated">Уровень срочности. Он может быть &lt;code&gt;low&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt; или &lt;code&gt;critical&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ce53fb4d208bc4c27337bdd863033417c703f3c" translate="yes" xml:space="preserve">
          <source>The use of a special variable as a formal argument in a function is discouraged. Doing so gives rise to unspecified behavior when lexical binding mode is enabled (it may use lexical binding sometimes, and dynamic binding other times).</source>
          <target state="translated">Использование специальной переменной в качестве формального аргумента в функции не рекомендуется.Это приводит к неуточненному поведению при включенном режиме лексического связывания (иногда может использоваться лексическое связывание,иногда динамическое-динамическое).</target>
        </trans-unit>
        <trans-unit id="143e85103669e6f3a73e45520cffeb3311a2e64f" translate="yes" xml:space="preserve">
          <source>The use of numbered backups ultimately leads to a large number of backup versions, which must then be deleted. Emacs can do this automatically or it can ask the user whether to delete them.</source>
          <target state="translated">Использование пронумерованных резервных копий в конечном итоге приводит к большому количеству резервных копий,которые затем необходимо удалить.Emacs может сделать это автоматически или может спросить пользователя,следует ли их удалить.</target>
        </trans-unit>
        <trans-unit id="a8707423f159b173b39f4962f0556071463cb869" translate="yes" xml:space="preserve">
          <source>The use of the &lt;var&gt;debugger-args&lt;/var&gt; is that &lt;code&gt;debug&lt;/code&gt; displays the rest of its arguments at the top of the</source>
          <target state="translated">Использование &lt;var&gt;debugger-args&lt;/var&gt; заключается в том, что &lt;code&gt;debug&lt;/code&gt; отображает остальные аргументы в верхней части</target>
        </trans-unit>
        <trans-unit id="511c6540e54c5649d62befa61b017dde79ffef3a" translate="yes" xml:space="preserve">
          <source>The user can add any key matching the specified key type, but you can give some keys a preferential treatment by specifying them with the &lt;code&gt;:options&lt;/code&gt; (see &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Variable Definitions&lt;/a&gt;). The specified keys will always be shown in the customize buffer (together with a suitable value), with a checkbox to include or exclude or disable the key/value pair from the alist. The user will not be able to edit the keys specified by the &lt;code&gt;:options&lt;/code&gt; keyword argument.</source>
          <target state="translated">Пользователь может добавить любой ключ, соответствующий указанному типу ключа, но вы можете предоставить некоторым ключам приоритетное обращение, указав их с помощью &lt;code&gt;:options&lt;/code&gt; (см. &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Определения переменных&lt;/a&gt; ). Указанные ключи всегда будут отображаться в буфере настройки (вместе с подходящим значением) с флажком для включения, исключения или отключения пары ключ / значение из списка. Пользователь не сможет редактировать ключи, указанные в аргументе ключевого слова &lt;code&gt;:options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdfe999c9bdc85b3810a58353ece516fc9370b63" translate="yes" xml:space="preserve">
          <source>The user can type</source>
          <target state="translated">Пользователь может вводить</target>
        </trans-unit>
        <trans-unit id="fd064556685bc85b9d72d2d84d2adeec46f6b9f6" translate="yes" xml:space="preserve">
          <source>The user option &lt;code&gt;display-buffer-alist&lt;/code&gt;.</source>
          <target state="translated">Пользовательская опция &lt;code&gt;display-buffer-alist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51ded933043196b29f2223baab0f1acb3d9183ff" translate="yes" xml:space="preserve">
          <source>The user option &lt;code&gt;display-buffer-base-action&lt;/code&gt;.</source>
          <target state="translated">Пользовательская опция &lt;code&gt;display-buffer-base-action&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
