<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="3a21eefa10a38bebd685a041bc883db13a690f78" translate="yes" xml:space="preserve">
          <source>A sparse keymap used by buttons.</source>
          <target state="translated">Разреженная карта клавиш,используемая кнопками.</target>
        </trans-unit>
        <trans-unit id="7a6d924c29a314704225148c6f1e8e4dd9598ef6" translate="yes" xml:space="preserve">
          <source>A sparse keymap used for responses in &lt;code&gt;query-replace&lt;/code&gt; and related commands; also for &lt;code&gt;y-or-n-p&lt;/code&gt; and &lt;code&gt;map-y-or-n-p&lt;/code&gt;. The functions that use this map do not support prefix keys; they look up one event at a time. &lt;code&gt;multi-query-replace-map&lt;/code&gt; extends &lt;code&gt;query-replace-map&lt;/code&gt; for multi-buffer replacements. See &lt;a href=&quot;search-and-replace#Search-and-Replace&quot;&gt;query-replace-map&lt;/a&gt;.</source>
          <target state="translated">Редкая раскладка клавиатуры, используемая для ответов в командах &lt;code&gt;query-replace&lt;/code&gt; и связанных командах; также для &lt;code&gt;y-or-n-p&lt;/code&gt; и &lt;code&gt;map-y-or-n-p&lt;/code&gt; . Функции, использующие эту карту, не поддерживают префиксные ключи; они просматривают одно событие за раз. &lt;code&gt;multi-query-replace-map&lt;/code&gt; расширяет &lt;code&gt;query-replace-map&lt;/code&gt; для многобуферных замен. См. &lt;a href=&quot;search-and-replace#Search-and-Replace&quot;&gt;Query-replace-map&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2273ae4dbb377e2aa911010dd8b2da0b64c40b7c" translate="yes" xml:space="preserve">
          <source>A sparse keymap used for the</source>
          <target state="translated">Разреженная карта-схема,используемая для</target>
        </trans-unit>
        <trans-unit id="7144fe372d5198217578856f61ea2cf40f8209ff" translate="yes" xml:space="preserve">
          <source>A sparse keymap used to map certain keys under graphical frames. The function &lt;code&gt;x-setup-function-keys&lt;/code&gt; uses this.</source>
          <target state="translated">Редкая раскладка клавиатуры, используемая для сопоставления определенных клавиш под графическими фреймами. Функциональные &lt;code&gt;x-setup-function-keys&lt;/code&gt; используют это.</target>
        </trans-unit>
        <trans-unit id="88e891a88be3fe4e62330f9bb2210843e83520a9" translate="yes" xml:space="preserve">
          <source>A sparse keymap used while processing</source>
          <target state="translated">Разреженная карта-схема,используемая во время обработки.</target>
        </trans-unit>
        <trans-unit id="765649c4f2ad56ec8ad2f598cca04c9ff7b7da2a" translate="yes" xml:space="preserve">
          <source>A sparse keymap useful for buffers containing buffers. You may want to use this as a parent keymap. See &lt;a href=&quot;buttons#Buttons&quot;&gt;Buttons&lt;/a&gt;.</source>
          <target state="translated">Редкая раскладка клавиатуры полезна для буферов, содержащих буферы. Вы можете использовать это как родительскую раскладку. См. &lt;a href=&quot;buttons#Buttons&quot;&gt;Кнопки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f4ac56519c11e0fe0577b1cad8ce3bbe4207fc9" translate="yes" xml:space="preserve">
          <source>A special feature allows you to specify expressions to evaluate if and when a file is loaded (see &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt;). That feature is not exactly a hook, but does a similar job.</source>
          <target state="translated">Специальная функция позволяет вам определять выражения для оценки того, загружен ли файл и когда (см. &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Хуки для загрузки&lt;/a&gt; ). Эта функция не совсем ловушка, но выполняет аналогичную работу.</target>
        </trans-unit>
        <trans-unit id="5be02abf64fa9f6d03c8545ca5b0ef5253cf8321" translate="yes" xml:space="preserve">
          <source>A special kind of key binding can be used to &lt;em&gt;remap&lt;/em&gt; one command to another, without having to refer to the key sequence(s) bound to the original command. To use this feature, make a key binding for a key sequence that starts with the dummy event &lt;code&gt;remap&lt;/code&gt;, followed by the command name you want to remap; for the binding, specify the new definition (usually a command name, but possibly any other valid definition for a key binding).</source>
          <target state="translated">Для &lt;em&gt;переназначения&lt;/em&gt; одной команды на другую можно использовать особый вид привязки клавиш без необходимости ссылаться на последовательность (и) клавиш, привязанную к исходной команде. Чтобы использовать эту функцию, сделайте привязку клавиш для последовательности клавиш, которая начинается с фиктивного &lt;code&gt;remap&lt;/code&gt; события , за которым следует имя команды, которую вы хотите переназначить; для привязки укажите новое определение (обычно имя команды, но, возможно, любое другое допустимое определение для привязки ключа).</target>
        </trans-unit>
        <trans-unit id="b3b13190b49396edf46334298af39e2a2e3045a9" translate="yes" xml:space="preserve">
          <source>A specially constructed list.</source>
          <target state="translated">Специально составленный список.</target>
        </trans-unit>
        <trans-unit id="cdeb8b40b772b9f3c7e2c98e3c8b8dec4698471b" translate="yes" xml:space="preserve">
          <source>A specification can have a &lt;em&gt;width&lt;/em&gt;, which is a decimal number that appears after any field number and flags. If the printed representation of the object contains fewer characters than this width, &lt;code&gt;format&lt;/code&gt; extends it with padding. Any padding introduced by the width normally consists of spaces inserted on the left:</source>
          <target state="translated">Спецификация может иметь &lt;em&gt;ширину&lt;/em&gt; , которая представляет собой десятичное число, которое появляется после любого номера поля и флагов. Если печатное представление объекта содержит меньше символов, чем указанная ширина, &lt;code&gt;format&lt;/code&gt; расширяет его с помощью заполнения. Любое заполнение, введенное шириной, обычно состоит из пробелов, вставленных слева:</target>
        </trans-unit>
        <trans-unit id="fffe787c50a5092035410b47c5d5ac737f027fa9" translate="yes" xml:space="preserve">
          <source>A specification list may contain sublists, which match arguments that are themselves lists, or it may contain vectors used for grouping. Sublists and groups thus subdivide the specification list into a hierarchy of levels. Specification keywords apply only to the remainder of the sublist or group they are contained in.</source>
          <target state="translated">Список спецификаций может содержать подлисты,которые соответствуют аргументам,являющимся самими списками,или содержать векторы,используемые для группировки.Таким образом,подлисты и группы подразделяют спецификационный список на иерархию уровней.Ключевые слова спецификации применяются только к остальной части подлиста или группы,в которой они содержатся.</target>
        </trans-unit>
        <trans-unit id="9468aabf9aff18dfe4927c4df0cf6ef94a873fcf" translate="yes" xml:space="preserve">
          <source>A string as a mode line construct appears verbatim except for &lt;em&gt;&lt;code&gt;%&lt;/code&gt;-constructs&lt;/em&gt; in it. These stand for substitution of other data; see &lt;a href=&quot;_0025_002dconstructs#g_t_0025_002dConstructs&quot;&gt;%-Constructs&lt;/a&gt;.</source>
          <target state="translated">Строка как конструкция строки режима отображается дословно, за исключением &lt;em&gt; &lt;code&gt;%&lt;/code&gt; -конструкций&lt;/em&gt; в ней. Они заменяют собой другие данные; см. &lt;a href=&quot;_0025_002dconstructs#g_t_0025_002dConstructs&quot;&gt;% -конструкции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2532fec68eb63f66911855847dedf967f8f81556" translate="yes" xml:space="preserve">
          <source>A string as input will be used directly. It may be modified by the function (unlike most other Emacs Lisp functions) to reduce the chance of exposing sensitive data after the function does its work.</source>
          <target state="translated">Строка в качестве входного сигнала будет использоваться непосредственно.Она может быть модифицирована функцией (в отличие от большинства других функций Emacs Lisp),чтобы уменьшить вероятность раскрытия конфиденциальных данных после того,как функция выполнит свою работу.</target>
        </trans-unit>
        <trans-unit id="a8bebc2f246c21ea650e3cb3ac8fe99ed1f62459" translate="yes" xml:space="preserve">
          <source>A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between strings and buffers to copy the text&amp;rsquo;s properties with no special effort. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;, for an explanation of what text properties mean. Strings with text properties use a special read and print syntax:</source>
          <target state="translated">Строка может содержать свойства символов, которые она содержит, помимо самих символов. Это позволяет программам, копирующим текст между строками и буферами, копировать свойства текста без особых усилий. См. &amp;laquo; &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Свойства текста&amp;raquo;&lt;/a&gt; для объяснения того, что означают свойства текста. Строки с текстовыми свойствами используют специальный синтаксис чтения и печати:</target>
        </trans-unit>
        <trans-unit id="dfef331cf99173b597cb3a4f9ebbdb7c1f294c0a" translate="yes" xml:space="preserve">
          <source>A string containing the same byte sequence as an XBM file would contain. You must not specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; in this case, because omitting them is what indicates the data has the format of an XBM file. The file contents specify the height and width of the image.</source>
          <target state="translated">Строка, содержащая ту же последовательность байтов, что и файл XBM. Вы не должны указывать &lt;code&gt;:height&lt;/code&gt; и &lt;code&gt;:width&lt;/code&gt; в этом случае, потому что их исключение означает, что данные имеют формат файла XBM. В содержимом файла указывается высота и ширина изображения.</target>
        </trans-unit>
        <trans-unit id="b80138eb0e7d2ee11a5334072539786172a5e2bd" translate="yes" xml:space="preserve">
          <source>A string displayed by the Emacs tooltip help system; by default, &lt;code&gt;&quot;mouse-2, RET: Push this button&quot;&lt;/code&gt;. Alternatively, a function that returns, or a form that evaluates to, a string to be displayed or &lt;code&gt;nil&lt;/code&gt;. For details see &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</source>
          <target state="translated">Строка, отображаемая справочной системой всплывающих подсказок Emacs; по умолчанию &lt;code&gt;&quot;mouse-2, RET: Push this button&quot;&lt;/code&gt; . В качестве альтернативы, функция, которая возвращает, или форма, которая оценивает строку, которая должна отображаться, или &lt;code&gt;nil&lt;/code&gt; . Для получения дополнительной информации см. &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e28e179ae46e636da2eca587a2ddde99c5d0cd9" translate="yes" xml:space="preserve">
          <source>A string in Emacs Lisp is an array that contains an ordered sequence of characters. Strings are used as names of symbols, buffers, and files; to send messages to users; to hold text being copied between buffers; and for many other purposes. Because strings are so important, Emacs Lisp has many functions expressly for manipulating them. Emacs Lisp programs use strings more often than individual characters.</source>
          <target state="translated">Строка в Emacs Lisp-это массив,содержащий упорядоченную последовательность символов.Строки используются как имена символов,буферов и файлов;для отправки сообщений пользователям;для хранения текста,копируемого между буферами;и для многих других целей.Поскольку строки так важны,Emacs Lisp имеет множество функций для работы с ними.Программы Emacs Lisp используют строки чаще,чем отдельные символы.</target>
        </trans-unit>
        <trans-unit id="97d89176884a6777ab0a93f14e9b3cf203593d01" translate="yes" xml:space="preserve">
          <source>A string is a fixed sequence of characters. It is a type of sequence called a &lt;em&gt;array&lt;/em&gt;, meaning that its length is fixed and cannot be altered once it is created (see &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;). Unlike in C, Emacs Lisp strings are &lt;em&gt;not&lt;/em&gt; terminated by a distinguished character code.</source>
          <target state="translated">Строка - это фиксированная последовательность символов. Это тип последовательности, называемой &lt;em&gt;массивом&lt;/em&gt; , что означает, что ее длина фиксирована и не может быть изменена после ее создания (см. &amp;laquo; &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Векторы массивов последовательностей&amp;raquo;&lt;/a&gt; ). В отличие от C, строки Emacs Lisp &lt;em&gt;не&lt;/em&gt; заканчиваются выделенным символьным кодом.</target>
        </trans-unit>
        <trans-unit id="fe9aa772c2d97bd3d2707cc2379051eb1e145422" translate="yes" xml:space="preserve">
          <source>A string is an array of characters and a vector is an array of arbitrary objects. A bool-vector can hold only &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. These kinds of array may have any length up to the largest fixnum, subject to system architecture limits and available memory. Char-tables are sparse arrays indexed by any valid character code; they can hold arbitrary objects.</source>
          <target state="translated">Строка - это массив символов, а вектор - это массив произвольных объектов. Логический вектор может содержать только &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;nil&lt;/code&gt; . Эти типы массивов могут иметь любую длину до наибольшего фиксированного числа, в зависимости от ограничений архитектуры системы и доступной памяти. Таблицы символов - это разреженные массивы, индексированные любым допустимым кодом символа; они могут удерживать произвольные объекты.</target>
        </trans-unit>
        <trans-unit id="2441898090949c6885e0d3b806fb9b48c4944a10" translate="yes" xml:space="preserve">
          <source>A string is text saved in the register.</source>
          <target state="translated">Строка-это текст,сохраненный в регистре.</target>
        </trans-unit>
        <trans-unit id="49f6b3f288e48e7a1e61f7ccbc7a20aa90fb1620" translate="yes" xml:space="preserve">
          <source>A string or a bool-vector containing the bits of the image (plus perhaps some extra bits at the end that will not be used). It should contain at least &lt;code&gt;&lt;var&gt;stride&lt;/var&gt;&amp;nbsp;*&amp;nbsp;&lt;var&gt;height&lt;/var&gt;&lt;/code&gt; bits, where &lt;var&gt;stride&lt;/var&gt; is the smallest multiple of 8 greater than or equal to the width of the image. In this case, you should specify &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:stride&lt;/code&gt;, both to indicate that the string contains just the bits rather than a whole XBM file, and to specify the size of the image.</source>
          <target state="translated">Строка или логический вектор, содержащий биты изображения (плюс, возможно, некоторые дополнительные биты в конце, которые не будут использоваться). Он должен содержать как минимум биты &lt;code&gt;&lt;var&gt;stride&lt;/var&gt;&amp;nbsp;*&amp;nbsp;&lt;var&gt;height&lt;/var&gt;&lt;/code&gt; , где &lt;var&gt;stride&lt;/var&gt; - наименьшее число, кратное 8, больше или равно ширине изображения. В этом случае, вы должны указать &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:width&lt;/code&gt; и &lt;code&gt;:stride&lt;/code&gt; , как указать , что строка содержит только биты , а не весь файл XBM, и указать размер изображения.</target>
        </trans-unit>
        <trans-unit id="036a59e22e9f954ee65be3ccd2c0ddd139f906a5" translate="yes" xml:space="preserve">
          <source>A string or vector as &lt;var&gt;command&lt;/var&gt; is executed with &lt;code&gt;execute-kbd-macro&lt;/code&gt;. A function is passed to &lt;code&gt;call-interactively&lt;/code&gt; (see above), along with the &lt;var&gt;record-flag&lt;/var&gt; and &lt;var&gt;keys&lt;/var&gt; arguments.</source>
          <target state="translated">Строка или вектор как &lt;var&gt;command&lt;/var&gt; выполняется с помощью &lt;code&gt;execute-kbd-macro&lt;/code&gt; . Функция передается в &lt;code&gt;call-interactively&lt;/code&gt; (см. Выше) вместе с аргументами &lt;var&gt;record-flag&lt;/var&gt; и &lt;var&gt;keys&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fb505d9a7d4b3f1a25ce86b9d3dae98375c606b2" translate="yes" xml:space="preserve">
          <source>A string starting with two or more dashes specifies a separator line; see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;.</source>
          <target state="translated">Строка, начинающаяся с двух или более дефисов, определяет разделительную линию; см. &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;разделители меню&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45afeec22e5b1392a38afb3af0c622aa891ec190" translate="yes" xml:space="preserve">
          <source>A string that gives the repository branch from which Emacs was built. In the most cases this is &lt;code&gt;&quot;master&quot;&lt;/code&gt;. If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Строка, указывающая ветку репозитория, из которой был собран Emacs. В большинстве случаев это &lt;code&gt;&quot;master&quot;&lt;/code&gt; . Если Emacs был собран без контроля версий, значение равно &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a176c29cb00e1ce1efdc8fd4de377dd60ec1aa7c" translate="yes" xml:space="preserve">
          <source>A string that gives the repository revision from which Emacs was built. If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Строка, указывающая версию репозитория, из которой был собран Emacs. Если Emacs был собран без контроля версий, значение равно &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32c2c310a05a2e4299069228d4059ebe12c87d4e" translate="yes" xml:space="preserve">
          <source>A string that is the name of the process&amp;rsquo;s controlling terminal. On Unix and GNU systems, this is normally the file name of the corresponding terminal device, such as</source>
          <target state="translated">Строка, представляющая собой имя управляющего терминала процесса. В системах Unix и GNU это обычно имя файла соответствующего терминального устройства, например</target>
        </trans-unit>
        <trans-unit id="a07b76952ae2e1b9491a1beda81ccc1a2fb843d7" translate="yes" xml:space="preserve">
          <source>A structure describing where the cursor is in this window.</source>
          <target state="translated">Структура,описывающая,где находится курсор в этом окне.</target>
        </trans-unit>
        <trans-unit id="20ca76b446ea261daca0ab9858048669216bed62" translate="yes" xml:space="preserve">
          <source>A structure describing where the cursor of this window physically is.</source>
          <target state="translated">Структура,описывающая,где физически находится курсор этого окна.</target>
        </trans-unit>
        <trans-unit id="283fbe00ae8cce4ea280dfbb7b15b846c6c4c692" translate="yes" xml:space="preserve">
          <source>A sublist specification may be a dotted list and the corresponding list argument may then be a dotted list. Alternatively, the last &lt;small&gt;CDR&lt;/small&gt; of a dotted list specification may be another sublist specification (via a grouping or an indirect specification, e.g., &lt;code&gt;(spec .  [(more
specs&amp;hellip;)])&lt;/code&gt;) whose elements match the non-dotted list arguments. This is useful in recursive specifications such as in the backquote example. Also see the description of a &lt;code&gt;nil&lt;/code&gt; specification above for terminating such recursion.</source>
          <target state="translated">Спецификация подсписка может быть точечным списком, а соответствующий аргумент списка может быть точечным списком. В качестве альтернативы, последняя &lt;small&gt;CDR&lt;/small&gt; спецификации списка с точками может быть другой спецификацией подсписка (через группировку или косвенную спецификацию, например, &lt;code&gt;(spec . [(more specs&amp;hellip;)])&lt;/code&gt; ), элементы которой соответствуют аргументам списка без точек. Это полезно в рекурсивных спецификациях, таких как пример обратных кавычек. Также см. Описание спецификации &lt;code&gt;nil&lt;/code&gt; выше для завершения такой рекурсии.</target>
        </trans-unit>
        <trans-unit id="e6bd63f0d6eed94cca2c1d7fa955eac6382d7a76" translate="yes" xml:space="preserve">
          <source>A subprocess of Emacs may be &lt;em&gt;synchronous&lt;/em&gt; or &lt;em&gt;asynchronous&lt;/em&gt;, depending on how it is created. When you create a synchronous subprocess, the Lisp program waits for the subprocess to terminate before continuing execution. When you create an asynchronous subprocess, it can run in parallel with the Lisp program. This kind of subprocess is represented within Emacs by a Lisp object which is also called a &amp;ldquo;process&amp;rdquo;. Lisp programs can use this object to communicate with the subprocess or to control it. For example, you can send signals, obtain status information, receive output from the process, or send input to it.</source>
          <target state="translated">Подпроцесс Emacs может быть &lt;em&gt;синхронным&lt;/em&gt; или &lt;em&gt;асинхронным&lt;/em&gt; , в зависимости от того, как он создан. Когда вы создаете синхронный подпроцесс, программа на Лиспе ожидает завершения подпроцесса, прежде чем продолжить выполнение. Когда вы создаете асинхронный подпроцесс, он может работать параллельно с программой Lisp. Этот вид подпроцесса представлен в Emacs объектом Lisp, который также называется &amp;laquo;процессом&amp;raquo;. Программы на Лиспе могут использовать этот объект для связи с подпроцессом или для управления им. Например, вы можете отправлять сигналы, получать информацию о статусе, получать выходные данные от процесса или отправлять ему входные данные.</target>
        </trans-unit>
        <trans-unit id="087de830e58dec95d6c61960121c78d539705185" translate="yes" xml:space="preserve">
          <source>A subprocess of Emacs running on the underlying OS.</source>
          <target state="translated">Подпроцесс Emacs,работающий на базовой операционной системе.</target>
        </trans-unit>
        <trans-unit id="35507e345942623bfb6aa6be63bdded05b6c5918" translate="yes" xml:space="preserve">
          <source>A suitable kind of &lt;code&gt;file-error&lt;/code&gt; error is signaled if the file does not exist, or is not deletable. (On GNU and other POSIX-like systems, a file is deletable if its directory is writable.)</source>
          <target state="translated">Подходящий вид &lt;code&gt;file-error&lt;/code&gt; сигнализируется, если файл не существует или не удаляется. (В GNU и других системах, подобных POSIX, файл можно удалить, если его каталог доступен для записи.)</target>
        </trans-unit>
        <trans-unit id="58e5791b58ed962f6049e196b317aabc08f3c119" translate="yes" xml:space="preserve">
          <source>A symbol as a mode line construct stands for its value. The value of &lt;var&gt;symbol&lt;/var&gt; is used as a mode line construct, in place of &lt;var&gt;symbol&lt;/var&gt;. However, the symbols &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; are ignored, as is any symbol whose value is void.</source>
          <target state="translated">Символ в качестве конструкции строки режима обозначает ее значение. Значение &lt;var&gt;symbol&lt;/var&gt; используется как конструкция строки режима вместо &lt;var&gt;symbol&lt;/var&gt; . Однако символы &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;nil&lt;/code&gt; игнорируются, как и любой символ, значение которого недействительно.</target>
        </trans-unit>
        <trans-unit id="136dfe6f1f6290980b0a544df03bc8031bada37f" translate="yes" xml:space="preserve">
          <source>A symbol as input stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</source>
          <target state="translated">Символ как входной поток эквивалентен определению функции символа (если есть).</target>
        </trans-unit>
        <trans-unit id="11075144c8ce3c1e072d1e5adaac43cdc6ed22f8" translate="yes" xml:space="preserve">
          <source>A symbol as output stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</source>
          <target state="translated">Символ как выходной поток эквивалентен определению функции символа (если есть).</target>
        </trans-unit>
        <trans-unit id="bce876b9cd2acba081d2ad07d0fc80b3afe79b3c" translate="yes" xml:space="preserve">
          <source>A symbol can serve as a variable, as a function name, or to hold a property list. Or it may serve only to be distinct from all other Lisp objects, so that its presence in a data structure may be recognized reliably. In a given context, usually only one of these uses is intended. But you can use one symbol in all of these ways, independently.</source>
          <target state="translated">Символ может служить переменной,именем функции или содержать список свойств.Или же он может служить только для того,чтобы быть отличным от всех других объектов Lisp,чтобы его присутствие в структуре данных могло быть надежно распознано.В данном контексте,как правило,предназначено только одно из этих применений.Но во всех этих случаях можно использовать один символ независимо друг от друга.</target>
        </trans-unit>
        <trans-unit id="1b40c765dfb974c4520f948565e6ea3abebbf26c" translate="yes" xml:space="preserve">
          <source>A symbol can serve as the name of a function.</source>
          <target state="translated">Символ может служить названием функции.</target>
        </trans-unit>
        <trans-unit id="2522095758f15f287bcb68febcef4a1aef3c93ca" translate="yes" xml:space="preserve">
          <source>A symbol can serve as the name of a function. This happens when the symbol&amp;rsquo;s &lt;em&gt;function cell&lt;/em&gt; (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;) contains a function object (e.g., a lambda expression). Then the symbol itself becomes a valid, callable function, equivalent to the function object in its function cell.</source>
          <target state="translated">Символ может служить именем функции. Это происходит, когда &lt;em&gt;функциональная ячейка &lt;/em&gt;&lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;символа&lt;/a&gt; (см. Компоненты символа ) содержит объект функции (например, лямбда-выражение). Затем сам символ становится действительной вызываемой функцией, эквивалентной объекту функции в ее функциональной ячейке.</target>
        </trans-unit>
        <trans-unit id="dc66ecbc9c4221d50048e15206869a3b042473a6" translate="yes" xml:space="preserve">
          <source>A symbol is a function to compute the height. It is called with the current height as argument, and should return the new height to use.</source>
          <target state="translated">Символ-это функция вычисления высоты.Она вызывается с текущей высотой в качестве аргумента и должна вернуть новую высоту для использования.</target>
        </trans-unit>
        <trans-unit id="1735c25eacfa5dbfa81d50d3791a7b3948064021" translate="yes" xml:space="preserve">
          <source>A symbol may possess any number of &lt;em&gt;symbol properties&lt;/em&gt;, which can be used to record miscellaneous information about the symbol. For example, when a symbol has a &lt;code&gt;risky-local-variable&lt;/code&gt; property with a non-&lt;code&gt;nil&lt;/code&gt; value, that means the variable which the symbol names is a risky file-local variable (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;).</source>
          <target state="translated">Символ может обладать любым количеством &lt;em&gt;свойств символа&lt;/em&gt; , которые можно использовать для записи различной информации о символе. Например, когда символ имеет свойство &lt;code&gt;risky-local-variable&lt;/code&gt; с &lt;code&gt;nil&lt;/code&gt; значением, это означает, что переменная, имя которой символизирует, является опасной локальной переменной &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;файла&lt;/a&gt; (см. Локальные переменные файла ).</target>
        </trans-unit>
        <trans-unit id="4af456786cdb930cf51a2fe8cb251937c0f92f76" translate="yes" xml:space="preserve">
          <source>A symbol name can contain any characters whatever. Most symbol names are written with letters, digits, and the punctuation characters &amp;lsquo;</source>
          <target state="translated">Имя символа может содержать любые символы. Большинство имен символов пишутся буквами, цифрами и знаками препинания.</target>
        </trans-unit>
        <trans-unit id="c152fe70962941670ef3592324bbdb47115752ec" translate="yes" xml:space="preserve">
          <source>A symbol whose name starts with a colon (&amp;lsquo;</source>
          <target state="translated">Символ, имя которого начинается с двоеточия ('</target>
        </trans-unit>
        <trans-unit id="3728c8c2eb3343e2a05d9141c3b791e811332750" translate="yes" xml:space="preserve">
          <source>A symbol. In other words, &lt;code&gt;(setf x y)&lt;/code&gt; is exactly equivalent to &lt;code&gt;(setq x y)&lt;/code&gt;, and &lt;code&gt;setq&lt;/code&gt; itself is strictly speaking redundant given that &lt;code&gt;setf&lt;/code&gt; exists. Most programmers will continue to prefer &lt;code&gt;setq&lt;/code&gt; for setting simple variables, though, for stylistic and historical reasons. The macro &lt;code&gt;(setf x y)&lt;/code&gt; actually expands to &lt;code&gt;(setq x y)&lt;/code&gt;, so there is no performance penalty for using it in compiled code.</source>
          <target state="translated">Символ. Другими словами, &lt;code&gt;(setf x y)&lt;/code&gt; в точности эквивалентен &lt;code&gt;(setq x y)&lt;/code&gt; , а сам &lt;code&gt;setq&lt;/code&gt; , строго говоря, избыточен, учитывая, что &lt;code&gt;setf&lt;/code&gt; существует. Однако большинство программистов по-прежнему предпочитают &lt;code&gt;setq&lt;/code&gt; для установки простых переменных по стилистическим и историческим причинам. Макрос &lt;code&gt;(setf x y)&lt;/code&gt; фактически расширяется до &lt;code&gt;(setq x y)&lt;/code&gt; , поэтому его использование в скомпилированном коде не снижает производительности.</target>
        </trans-unit>
        <trans-unit id="1954d27d0637fd3ddd907ebc88c0499752335e55" translate="yes" xml:space="preserve">
          <source>A syntax table can &lt;em&gt;inherit&lt;/em&gt; from another syntax table, which is called its &lt;em&gt;parent syntax table&lt;/em&gt;. A syntax table can leave the syntax class of some characters unspecified, by giving them the &amp;ldquo;inherit&amp;rdquo; syntax class; such a character then acquires the syntax class specified by the parent syntax table (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;). Emacs defines a &lt;em&gt;standard syntax table&lt;/em&gt;, which is the default parent syntax table, and is also the syntax table used by Fundamental mode.</source>
          <target state="translated">Таблица синтаксиса может &lt;em&gt;наследовать&lt;/em&gt; от другой таблицы синтаксиса, которая называется &lt;em&gt;родительской таблицей синтаксиса&lt;/em&gt; . В таблице синтаксиса можно оставить класс синтаксиса некоторых символов неуказанным, предоставив им класс синтаксиса &amp;laquo;наследование&amp;raquo;; такой символ затем получает класс синтаксиса, указанный в родительской таблице синтаксиса (см. &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Таблицу классов синтаксиса&lt;/a&gt; ). Emacs определяет &lt;em&gt;стандартную таблицу синтаксиса&lt;/em&gt; , которая является родительской таблицей синтаксиса по умолчанию, а также является таблицей синтаксиса, используемой в режиме Fundamental.</target>
        </trans-unit>
        <trans-unit id="b659b2d3d03e0d7773e900b73de02d70d5ddcd88" translate="yes" xml:space="preserve">
          <source>A syntax table is a data structure which can be used to look up the &lt;em&gt;syntax class&lt;/em&gt; and other syntactic properties of each character. Syntax tables are used by Lisp programs for scanning and moving across text.</source>
          <target state="translated">Таблица синтаксиса - это структура данных, которая может использоваться для поиска &lt;em&gt;класса синтаксиса&lt;/em&gt; и других синтаксических свойств каждого символа. Таблицы синтаксиса используются программами на Лиспе для сканирования и перемещения по тексту.</target>
        </trans-unit>
        <trans-unit id="611cab9bf171d524f8bb167ff2d975371afdf4c3" translate="yes" xml:space="preserve">
          <source>A terminal device displays frames.</source>
          <target state="translated">Терминальное устройство отображает кадры.</target>
        </trans-unit>
        <trans-unit id="154579a3c3d7f8dbf4dedff1e12b0784abbfebd3" translate="yes" xml:space="preserve">
          <source>A themable named sound from the freedesktop.org sound naming specification from &amp;lsquo;</source>
          <target state="translated">Тематический именованный звук из спецификации именования звуков freedesktop.org от '</target>
        </trans-unit>
        <trans-unit id="26c5fb26d2d40b902e4464e332d9e274ac27ae65" translate="yes" xml:space="preserve">
          <source>A thread of Emacs Lisp execution.</source>
          <target state="translated">Нитка казни Эмака Липа.</target>
        </trans-unit>
        <trans-unit id="57dfda42a48a44a57cc294b3f4f34e2af8232910" translate="yes" xml:space="preserve">
          <source>A token can be an &lt;code&gt;opener&lt;/code&gt; (something similar to an open-paren), a &lt;code&gt;closer&lt;/code&gt; (like a close-paren), or &lt;code&gt;neither&lt;/code&gt; of the two (e.g., an infix operator, or an inner token like &lt;code&gt;&quot;else&quot;&lt;/code&gt;).</source>
          <target state="translated">Маркер может быть &lt;code&gt;opener&lt;/code&gt; (что - то похожее на ОТКРЫТОЕ Paren), А &lt;code&gt;closer&lt;/code&gt; (например , крупный Paren), или &lt;code&gt;neither&lt;/code&gt; из два (например, оператора инфиксных или внутреннего знака как &lt;code&gt;&quot;else&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d764cf0b69eb00f7e2c9718e179e351b46213d5" translate="yes" xml:space="preserve">
          <source>A tool bar is a row of images.</source>
          <target state="translated">Панель инструментов представляет собой ряд изображений.</target>
        </trans-unit>
        <trans-unit id="b6e511e3067670e626e12e33340269d446fde317" translate="yes" xml:space="preserve">
          <source>A translation table has two extra slots. The first is either &lt;code&gt;nil&lt;/code&gt; or a translation table that performs the reverse translation; the second is the maximum number of characters to look up for translating sequences of characters (see the description of &lt;code&gt;make-translation-table-from-alist&lt;/code&gt; below).</source>
          <target state="translated">В таблице трансляции есть два дополнительных слота. Первый - это либо &lt;code&gt;nil&lt;/code&gt; , либо таблица перевода, которая выполняет обратное преобразование; второй - это максимальное количество символов для поиска переводимых последовательностей символов (см. описание &lt;code&gt;make-translation-table-from-alist&lt;/code&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="fdc3d3499bd5bb07db44fa25b08d5a6a535373e6" translate="yes" xml:space="preserve">
          <source>A true mirror-image of &lt;code&gt;re-search-forward&lt;/code&gt; would require a special feature for matching regular expressions from end to beginning. It&amp;rsquo;s not worth the trouble of implementing that.</source>
          <target state="translated">Истинное зеркальное отображение &lt;code&gt;re-search-forward&lt;/code&gt; потребует специальной функции для сопоставления регулярных выражений от конца до начала. Это не стоит того.</target>
        </trans-unit>
        <trans-unit id="d8e822f12fc2d0ada4fa0abd7fbe433aba2b4039" translate="yes" xml:space="preserve">
          <source>A type predicate function takes one argument; it returns &lt;code&gt;t&lt;/code&gt; if the argument belongs to the appropriate type, and &lt;code&gt;nil&lt;/code&gt; otherwise. Following a general Lisp convention for predicate functions, most type predicates&amp;rsquo; names end with &amp;lsquo;</source>
          <target state="translated">Функция предиката типа принимает один аргумент; он возвращает &lt;code&gt;t&lt;/code&gt; , если аргумент принадлежит соответствующему типу, и &lt;code&gt;nil&lt;/code&gt; в противном случае. Следуя общему соглашению Lisp для функций предикатов, имена большинства предикатов типов заканчиваются на</target>
        </trans-unit>
        <trans-unit id="0d50bc7f95aabd11c78a01358b272f4c298b3579" translate="yes" xml:space="preserve">
          <source>A type used for automatically loading seldom-used functions.</source>
          <target state="translated">Тип,используемый для автоматической загрузки редко используемых функций.</target>
        </trans-unit>
        <trans-unit id="b25d98417944fbcf3fe27fffb07995fdd6887711" translate="yes" xml:space="preserve">
          <source>A typical value might look like this:</source>
          <target state="translated">Типичное значение может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="7068fb3333ff355206cad1f5c8ac4e885a7b5eaa" translate="yes" xml:space="preserve">
          <source>A unique number assigned to this window when it was created.</source>
          <target state="translated">Уникальный номер,присвоенный этому окну при его создании.</target>
        </trans-unit>
        <trans-unit id="1f49c36b6b4f969d94158af5c04fa459e6fb756b" translate="yes" xml:space="preserve">
          <source>A user interface for building JSONRPC applications</source>
          <target state="translated">Пользовательский интерфейс для создания приложений JSONRPC</target>
        </trans-unit>
        <trans-unit id="da28673ff5250624bbd9c79fdce5b46476250e40" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;nil&lt;/code&gt; is equivalent to .5, since its effect is to center point. This variable automatically becomes buffer-local when set in any fashion.</source>
          <target state="translated">Значение &lt;code&gt;nil&lt;/code&gt; эквивалентно 0,5, поскольку его действие распространяется на центральную точку. Эта переменная автоматически становится локальной в буфере, если задана любым способом.</target>
        </trans-unit>
        <trans-unit id="761af930570eba02ee4263e0c4625df53668e35d" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;nil&lt;/code&gt; says to ignore the lock and let this user edit the file anyway.</source>
          <target state="translated">Значение &lt;code&gt;nil&lt;/code&gt; говорит о том, что блокировку следует игнорировать и позволить этому пользователю редактировать файл в любом случае.</target>
        </trans-unit>
        <trans-unit id="2614ea86270afac8b5acd08878d712db67414cd0" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;t&lt;/code&gt; says to grab the lock on the file. Then this user may edit the file and &lt;var&gt;other-user&lt;/var&gt; loses the lock.</source>
          <target state="translated">Значение &lt;code&gt;t&lt;/code&gt; говорит о захвате блокировки файла. Затем этот пользователь может редактировать файл, и &lt;var&gt;other-user&lt;/var&gt; теряет блокировку.</target>
        </trans-unit>
        <trans-unit id="0f7035c80e73faf961d120dfe6ba3e3b9a60ff4c" translate="yes" xml:space="preserve">
          <source>A value of the form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt; . &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt; stands for the product of the values of &lt;var&gt;num&lt;/var&gt; and &lt;var&gt;expr&lt;/var&gt;. For example, &lt;code&gt;(2 . in)&lt;/code&gt; specifies a width of 2 inches, while &lt;code&gt;(0.5 .
&lt;var&gt;image&lt;/var&gt;)&lt;/code&gt; specifies half the width (or height) of the specified &lt;var&gt;image&lt;/var&gt; (which should be given by its image spec).</source>
          <target state="translated">Значение формы &lt;code&gt;(&lt;var&gt;num&lt;/var&gt; . &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt; обозначает произведение значений &lt;var&gt;num&lt;/var&gt; и &lt;var&gt;expr&lt;/var&gt; . Например, &lt;code&gt;(2 . in)&lt;/code&gt; указывает ширину 2 дюйма, а &lt;code&gt;(0.5 . &lt;var&gt;image&lt;/var&gt;)&lt;/code&gt; указывает половину ширины (или высоты) указанного &lt;var&gt;image&lt;/var&gt; (которая должна быть задана его спецификацией изображения).</target>
        </trans-unit>
        <trans-unit id="7d6f07646985192c4276dea56a0bd52c3ee59a86" translate="yes" xml:space="preserve">
          <source>A variable can be let-bound (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;) to a value. This makes its global value shadowed by the binding; &lt;code&gt;default-value&lt;/code&gt; will then return the value from that binding, not the global value, and &lt;code&gt;set-default&lt;/code&gt; will be prevented from setting the global value (it will change the let-bound value instead). The following two functions allow to reference the global value even if it&amp;rsquo;s shadowed by a let-binding.</source>
          <target state="translated">Переменная может быть привязана к значению (см. &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Локальные переменные&lt;/a&gt; ). Это делает его глобальное значение затененным привязкой; &lt;code&gt;default-value&lt;/code&gt; затем вернет значение из этой привязки, а не глобальное значение, и &lt;code&gt;set-default&lt;/code&gt; не сможет установить глобальное значение (вместо этого он изменит значение let-bound). Следующие две функции позволяют ссылаться на глобальное значение, даже если оно затенено let-привязкой.</target>
        </trans-unit>
        <trans-unit id="42469365ae54b87406fe0c4580eafab3e15cd7f7" translate="yes" xml:space="preserve">
          <source>A variable can have buffer-local bindings in some buffers but not in other buffers. The default binding is shared by all the buffers that don&amp;rsquo;t have their own bindings for the variable. (This includes all newly-created buffers.) If you set the variable in a buffer that does not have a buffer-local binding for it, this sets the default binding, so the new value is visible in all the buffers that see the default binding.</source>
          <target state="translated">Переменная может иметь привязки к локальному буферу в некоторых буферах, но не в других буферах. Привязка по умолчанию используется всеми буферами, у которых нет собственных привязок для переменной. (Это включает в себя все вновь созданные буферы.) Если вы устанавливаете переменную в буфере, который не имеет привязки к локальному буферу для нее, это устанавливает привязку по умолчанию, поэтому новое значение отображается во всех буферах, которые видят значение по умолчанию привязка.</target>
        </trans-unit>
        <trans-unit id="7229e30ed01c65b1f554b2be31bb3ad0ddba289e" translate="yes" xml:space="preserve">
          <source>A variable can have more than one local binding at a time (e.g., if there are nested &lt;code&gt;let&lt;/code&gt; forms that bind the variable). The &lt;em&gt;current binding&lt;/em&gt; is the local binding that is actually in effect. It determines the value returned by evaluating the variable symbol, and it is the binding acted on by &lt;code&gt;setq&lt;/code&gt;.</source>
          <target state="translated">Переменная может иметь более одной локальной привязки одновременно (например, если есть вложенные &lt;code&gt;let&lt;/code&gt; - формы, которые связывают переменную). &lt;em&gt;Тока связывания&lt;/em&gt; является локальным связывания , что на самом деле в действительности. Он определяет возвращаемое значение, оценивая символ переменной, и это привязка, на которую действует &lt;code&gt;setq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1ac65fb2f3cee8bab9b33ddf4b381098337ecd1" translate="yes" xml:space="preserve">
          <source>A variable declared to be a user option (i.e., satisfying the predicate &lt;code&gt;custom-variable-p&lt;/code&gt;). This reads the variable using &lt;code&gt;read-variable&lt;/code&gt;. See &lt;a href=&quot;high_002dlevel-completion#Definition-of-read_002dvariable&quot;&gt;Definition of read-variable&lt;/a&gt;. Existing, Completion, Prompt.</source>
          <target state="translated">Переменная, объявленная как опция пользователя (т. Е. Удовлетворяющая предикату &lt;code&gt;custom-variable-p&lt;/code&gt; ). Это считывает переменную с помощью переменной &lt;code&gt;read-variable&lt;/code&gt; . См. &lt;a href=&quot;high_002dlevel-completion#Definition-of-read_002dvariable&quot;&gt;Определение переменной чтения&lt;/a&gt; . Существующий, Завершение, Подсказка.</target>
        </trans-unit>
        <trans-unit id="714788a2d69016197f589516788c6c86a085d831" translate="yes" xml:space="preserve">
          <source>A variable definition serves three purposes. First, it informs people who read the code that the symbol is &lt;em&gt;intended&lt;/em&gt; to be used a certain way (as a variable). Second, it informs the Lisp system of this, optionally supplying an initial value and a documentation string. Third, it provides information to programming tools such as &lt;code&gt;etags&lt;/code&gt;, allowing them to find where the variable was defined.</source>
          <target state="translated">Определение переменной служит трем целям. Во-первых, он информирует людей, читающих код, о том, что символ &lt;em&gt;предназначен&lt;/em&gt; для использования определенным образом (как переменная). Во-вторых, он сообщает об этом системе Lisp, опционально предоставляя начальное значение и строку документации. В-третьих, он предоставляет информацию инструментам программирования, таким как &lt;code&gt;etags&lt;/code&gt; , позволяя им найти, где была определена переменная.</target>
        </trans-unit>
        <trans-unit id="6d8469682cf6ae5ee24fbb06b606a67a9bdca6f1" translate="yes" xml:space="preserve">
          <source>A vector of elements groups the elements into a single &lt;em&gt;group specification&lt;/em&gt;. Its meaning has nothing to do with vectors.</source>
          <target state="translated">Вектор элементов группирует элементы в единую &lt;em&gt;групповую спецификацию&lt;/em&gt; . Его значение не имеет ничего общего с векторами.</target>
        </trans-unit>
        <trans-unit id="907ba2db0b69ea3ac390ffc8957c9f20ac952af1" translate="yes" xml:space="preserve">
          <source>A vector of glyphs for indicating the presence of invisible lines (the default is &amp;lsquo;</source>
          <target state="translated">Вектор глифов для индикации наличия невидимых линий (по умолчанию '</target>
        </trans-unit>
        <trans-unit id="5b9d67749d8a12ed598e9d50f8a2fa40ed3d9434" translate="yes" xml:space="preserve">
          <source>A vector of strings or bool-vectors, each specifying one line of the image. Do specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt;.</source>
          <target state="translated">Вектор строк или bool-векторов, каждый из которых определяет одну строку изображения. Укажите &lt;code&gt;:height&lt;/code&gt; и &lt;code&gt;:width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd393f14b47e46b8b1b11b3ee71f7e6e4effd32" translate="yes" xml:space="preserve">
          <source>A vector, like a string or a number, is considered a constant for evaluation: the result of evaluating it is the same vector. This does not evaluate or even examine the elements of the vector. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;. Vectors written with square brackets should not be modified via &lt;code&gt;aset&lt;/code&gt; or other destructive operations. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">Вектор, такой как строка или число, считается константой для оценки: результат вычисления - это тот же вектор. Это не оценивает и даже не проверяет элементы вектора. См. &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Формы для самооценки&lt;/a&gt; . Векторы, записанные в квадратных скобках, не должны изменяться с помощью &lt;code&gt;aset&lt;/code&gt; или других деструктивных операций. См. &quot; &lt;a href=&quot;mutability#Mutability&quot;&gt;Изменчивость&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cea3cbc11949c249de3312f294eef9cb9f938425" translate="yes" xml:space="preserve">
          <source>A version number, in a form that the function &lt;code&gt;version-to-list&lt;/code&gt; understands (e.g., &amp;lsquo;</source>
          <target state="translated">Номер версии в форме, понятной функции от &lt;code&gt;version-to-list&lt;/code&gt; (например, '</target>
        </trans-unit>
        <trans-unit id="d6f9261a2dce5769b4273b16b8e7e92056f25007" translate="yes" xml:space="preserve">
          <source>A very simple parsing technique.</source>
          <target state="translated">Очень простая техника анализа.</target>
        </trans-unit>
        <trans-unit id="a21b6bc0e953a05c7047f6926acdf8cdb6092af2" translate="yes" xml:space="preserve">
          <source>A visible child frame always appears on top of its parent frame thus obscuring parts of it, except on NS builds where it may be positioned beneath the parent. This is comparable to the window-system window of a top-level frame which also always appears on top of its parent window&amp;mdash;the desktop&amp;rsquo;s root window. When a parent frame is iconified or made invisible (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;), its child frames are made invisible. When a parent frame is deiconified or made visible, its child frames are made visible.</source>
          <target state="translated">Видимый дочерний фрейм всегда появляется поверх своего родительского фрейма, закрывая его части, за исключением сборок NS, где он может быть расположен под родительским фреймом. Это сравнимо с окном оконной системы фрейма верхнего уровня, который также всегда появляется поверх своего родительского окна - корневого окна рабочего стола. Когда родительский фрейм отображается в виде значка или становится невидимым (см. &amp;laquo; &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Видимость фреймов&amp;raquo;&lt;/a&gt; ), его дочерние фреймы становятся невидимыми. Когда родительский фрейм деиконифицируется или становится видимым, его дочерние фреймы становятся видимыми.</target>
        </trans-unit>
        <trans-unit id="3f15d83470f651a16357e3fbbafed38889367d47" translate="yes" xml:space="preserve">
          <source>A visible frame occupies a rectangular area on its terminal&amp;rsquo;s display. This area may contain a number of nested rectangles, each serving a different purpose. The drawing below sketches the layout of a frame on a graphical terminal:</source>
          <target state="translated">Видимая рамка занимает прямоугольную область на экране терминала. Эта область может содержать несколько вложенных прямоугольников, каждый из которых служит своей цели. На рисунке ниже схематично показано расположение фрейма на графическом терминале:</target>
        </trans-unit>
        <trans-unit id="9dc2f20dda99554f7dead3ef07cf05023791995d" translate="yes" xml:space="preserve">
          <source>A watch can become invalid if the file or directory it watches is deleted, or if the watcher thread exits abnormally for any other reason. Removing the watch by calling &lt;code&gt;file-notify-rm-watch&lt;/code&gt; also makes it invalid.</source>
          <target state="translated">Наблюдение может стать недействительным, если файл или каталог, который он отслеживает, будет удален, или если поток-наблюдатель завершится ненормально по любой другой причине. Удаление часов с помощью вызова &lt;code&gt;file-notify-rm-watch&lt;/code&gt; также делает их недействительными.</target>
        </trans-unit>
        <trans-unit id="efb12abaf84e2ff0588000ce76b06f219405368d" translate="yes" xml:space="preserve">
          <source>A web server providing access to a package archive must support the following queries:</source>
          <target state="translated">Веб-сервер,предоставляющий доступ к архиву пакетов,должен поддерживать следующие запросы:</target>
        </trans-unit>
        <trans-unit id="96a8665d6abd124bc5fe28303880a92b178554c2" translate="yes" xml:space="preserve">
          <source>A well-designed macro definition takes steps to avoid this problem by producing an expansion that evaluates the argument expressions exactly once unless repeated evaluation is part of the intended purpose of the macro. Here is a correct expansion for the &lt;code&gt;for&lt;/code&gt; macro:</source>
          <target state="translated">Хорошо спроектированное определение макроса предпринимает шаги, чтобы избежать этой проблемы, создавая расширение, которое оценивает выражения аргументов ровно один раз, если повторное вычисление не является частью предполагаемой цели макроса. Вот правильное расширение &lt;code&gt;for&lt;/code&gt; макроса for :</target>
        </trans-unit>
        <trans-unit id="b1827635d79dea77c5cd2894c432de677a45e87a" translate="yes" xml:space="preserve">
          <source>A window can get resized explicitly by using one of the functions from the preceding section or implicitly, for example, when resizing an adjacent window, when splitting or deleting a window (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;, see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) or when resizing the window&amp;rsquo;s frame (see &lt;a href=&quot;frame-size#Frame-Size&quot;&gt;Frame Size&lt;/a&gt;).</source>
          <target state="translated">Размер окна можно изменить явно с помощью одной из функций из предыдущего раздела или неявно, например, при изменении размера соседнего окна, при разделении или удалении окна (см. &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Разделение окон&lt;/a&gt; , см. &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Удаление окон&lt;/a&gt; ) или при изменении размера рамки окна ( см. &lt;a href=&quot;frame-size#Frame-Size&quot;&gt;Размер кадра&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="da0f4aabb2b28d1adb4d16bd804393865c93bf0e" translate="yes" xml:space="preserve">
          <source>A window can have a &lt;em&gt;header line&lt;/em&gt; at the top, just as it can have a mode line at the bottom. The header line feature works just like the mode line feature, except that it&amp;rsquo;s controlled by &lt;code&gt;header-line-format&lt;/code&gt;:</source>
          <target state="translated">Окно может иметь &lt;em&gt;строку заголовка&lt;/em&gt; вверху, так же как и строку режима внизу. Функция строки заголовка работает так же, как функция строки режима, за исключением того, что она управляется &lt;code&gt;header-line-format&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7eb040f86ff87638d96bfd4ec298244d1a1c95a8" translate="yes" xml:space="preserve">
          <source>A window is resized if and only if it has been specially created for the buffer. In particular, windows that have shown another buffer before are not resized. By default, this mode uses &lt;code&gt;fit-window-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;) for resizing. You can specify a different function by customizing the options &lt;code&gt;temp-buffer-max-height&lt;/code&gt; and &lt;code&gt;temp-buffer-max-width&lt;/code&gt; below.</source>
          <target state="translated">Размер окна изменяется тогда и только тогда, когда оно было специально создано для буфера. В частности, окна, в которых раньше отображался другой буфер, не изменяются. По умолчанию в этом режиме для изменения размера используется &lt;code&gt;fit-window-to-buffer&lt;/code&gt; (см. &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Изменение размера окна&lt;/a&gt; ). Вы можете указать другую функцию, настроив параметры &lt;code&gt;temp-buffer-max-height&lt;/code&gt; и &lt;code&gt;temp-buffer-max-width&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="5b181ae523d21d580fe4dc9490e28d52beda4e36" translate="yes" xml:space="preserve">
          <source>A window showing a temporary buffer can be fitted to the size of that buffer using the following mode:</source>
          <target state="translated">Окно,показывающее временный буфер,может быть подогнано под размер этого буфера с помощью следующего режима:</target>
        </trans-unit>
        <trans-unit id="10b80aceee959c8dcb16c72ed1a2553043421e82" translate="yes" xml:space="preserve">
          <source>A window that is just one line tall never displays a header line. A window that is two lines tall cannot display both a mode line and a header line at once; if it has a mode line, then it does not display a header line.</source>
          <target state="translated">Окно высотой всего в одну строку никогда не отображает строку заголовка.Окно высотой в две строки не может отображать одновременно и линию режима,и линию заголовка;если у него есть линия режима,то линия заголовка не отображается.</target>
        </trans-unit>
        <trans-unit id="6004ea783485bff5b8ff0a2c4b58ed331fceaf67" translate="yes" xml:space="preserve">
          <source>A window that showed &lt;var&gt;buffer&lt;/var&gt; before, provided it is not the selected window.</source>
          <target state="translated">Окно, которое раньше показывало &lt;var&gt;buffer&lt;/var&gt; , при условии, что это не выбранное окно.</target>
        </trans-unit>
        <trans-unit id="24fac820e9dc3bcfec792e9cbea05e313a184dd9" translate="yes" xml:space="preserve">
          <source>A working buffer for decoding.</source>
          <target state="translated">Рабочий буфер для декодирования.</target>
        </trans-unit>
        <trans-unit id="a0c46d9d748b73163c147c1ce7040c6c5f099f4e" translate="yes" xml:space="preserve">
          <source>A working buffer for encoding.</source>
          <target state="translated">Рабочий буфер для кодирования.</target>
        </trans-unit>
        <trans-unit id="616b07ea95b58bd9c829efac045d8e3b914aeaa6" translate="yes" xml:space="preserve">
          <source>A wrap prefix may also be specified for regions of text, using the &lt;code&gt;wrap-prefix&lt;/code&gt; text or overlay property. This takes precedence over the &lt;code&gt;wrap-prefix&lt;/code&gt; variable. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">Префикс переноса также может быть указан для областей текста, используя текст &lt;code&gt;wrap-prefix&lt;/code&gt; переноса или свойство наложения. Это имеет приоритет над переменной &lt;code&gt;wrap-prefix&lt;/code&gt; переноса. См. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Особые свойства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b61659ac0aca26e539585c1b71cc13614c39334" translate="yes" xml:space="preserve">
          <source>A wrap-prefix may also be specified for an entire buffer using the &lt;code&gt;wrap-prefix&lt;/code&gt; buffer-local variable (however, a &lt;code&gt;wrap-prefix&lt;/code&gt; text-property takes precedence over the value of the &lt;code&gt;wrap-prefix&lt;/code&gt; variable). See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">Префикс переноса также может быть указан для всего буфера с использованием локальной переменной буфера &lt;code&gt;wrap-prefix&lt;/code&gt; переноса (однако текстовое свойство &lt;code&gt;wrap-prefix&lt;/code&gt; переноса имеет приоритет над значением переменной &lt;code&gt;wrap-prefix&lt;/code&gt; переноса). См. &lt;a href=&quot;truncation#Truncation&quot;&gt;Усечение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a6a3baa60990f601b340b07ecccc1672c3cca03" translate="yes" xml:space="preserve">
          <source>A-</source>
          <target state="translated">A-</target>
        </trans-unit>
        <trans-unit id="a85e90f9835e6411e691ebde65582614cea81732" translate="yes" xml:space="preserve">
          <source>ALT</source>
          <target state="translated">ALT</target>
        </trans-unit>
        <trans-unit id="80d305c58f97edfae92a3627f5a66d9bef4d8d46" translate="yes" xml:space="preserve">
          <source>AM</source>
          <target state="translated">AM</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="031fd11ba8734ab304116a023b5216306b246bee" translate="yes" xml:space="preserve">
          <source>AT</source>
          <target state="translated">AT</target>
        </trans-unit>
        <trans-unit id="99122025a15b80d993018f40997751b62445924e" translate="yes" xml:space="preserve">
          <source>AT&amp;amp;T Unix System V.</source>
          <target state="translated">AT&amp;amp;T Unix System V.</target>
        </trans-unit>
        <trans-unit id="54f90b5155803aae21271b2ad64b0075c858dfb3" translate="yes" xml:space="preserve">
          <source>Abbrev Properties</source>
          <target state="translated">Аббревиатура Свойства</target>
        </trans-unit>
        <trans-unit id="f784445cdd616480acdfafb0159b1dd57c47999c" translate="yes" xml:space="preserve">
          <source>Abbrev Table Properties</source>
          <target state="translated">Аббревиатура Свойства</target>
        </trans-unit>
        <trans-unit id="2a8b96a9acfbae4f72a46878195e3d362ca12a6d" translate="yes" xml:space="preserve">
          <source>Abbrev Tables</source>
          <target state="translated">аббревиатуры</target>
        </trans-unit>
        <trans-unit id="a762e02aeaccf777576ff3c307e562d8de1c9496" translate="yes" xml:space="preserve">
          <source>Abbrev tables used by various major modes.</source>
          <target state="translated">Таблицы аббревиатур,используемые различными основными режимами.</target>
        </trans-unit>
        <trans-unit id="49470700c92eb0723c4ce23a16459e8c3cadae63" translate="yes" xml:space="preserve">
          <source>Abbrevs</source>
          <target state="translated">Abbrevs</target>
        </trans-unit>
        <trans-unit id="0305dceae89338799d1bdcabaff23a024687a7d6" translate="yes" xml:space="preserve">
          <source>Abbrevs and Abbrev Expansion</source>
          <target state="translated">Аббревиатура и аббревиатура Экспансия</target>
        </trans-unit>
        <trans-unit id="b4aa8f55f18e483e3d99ff9bebe3bd5c52648359" translate="yes" xml:space="preserve">
          <source>Abbrevs are usually expanded by certain interactive commands, including &lt;code&gt;self-insert-command&lt;/code&gt;. This section describes the subroutines used in writing such commands, as well as the variables they use for communication.</source>
          <target state="translated">Сокращения обычно расширяются некоторыми интерактивными командами, включая &lt;code&gt;self-insert-command&lt;/code&gt; . В этом разделе описаны подпрограммы, используемые при написании таких команд, а также переменные, которые они используют для связи.</target>
        </trans-unit>
        <trans-unit id="1631d5afa2a3227c2b1fff62aedf669a7aee3c55" translate="yes" xml:space="preserve">
          <source>Abbrevs have properties, some of which influence the way they work. You can provide them as arguments to &lt;code&gt;define-abbrev&lt;/code&gt;, and manipulate them with the following functions:</source>
          <target state="translated">У сокращений есть свойства, некоторые из которых влияют на то, как они работают. Вы можете предоставить их в качестве аргументов для &lt;code&gt;define-abbrev&lt;/code&gt; и управлять ими с помощью следующих функций:</target>
        </trans-unit>
        <trans-unit id="fd64ebde815890af94b19555b946c61d882f6e1a" translate="yes" xml:space="preserve">
          <source>Abort one level back to the previous command level (&lt;code&gt;abort-recursive-edit&lt;/code&gt;).</source>
          <target state="translated">Отменить один уровень назад к предыдущему командному уровню ( &lt;code&gt;abort-recursive-edit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="649f859d67e712421f56a26ae61a458542dd60ea" translate="yes" xml:space="preserve">
          <source>Absolute and Relative File Names</source>
          <target state="translated">Абсолютные и относительные имена файлов</target>
        </trans-unit>
        <trans-unit id="059d44280b6e5c431c206b204f4f62d2e05d3635" translate="yes" xml:space="preserve">
          <source>Absolute times may be specified using a string with a limited variety of formats, and are taken to be times &lt;em&gt;today&lt;/em&gt;, even if already in the past. The recognized forms are &amp;lsquo;</source>
          <target state="translated">Абсолютное время может быть указано с использованием строки с ограниченным набором форматов, и считается, что это время &lt;em&gt;сегодня&lt;/em&gt; , даже если оно уже было в прошлом. Признанные формы:</target>
        </trans-unit>
        <trans-unit id="c2929c3c521daab9f85d0df0bc4e1eb3e6ff7ace" translate="yes" xml:space="preserve">
          <source>Abstract Display</source>
          <target state="translated">Абстрактный дисплей</target>
        </trans-unit>
        <trans-unit id="0dd14bcbc9ae50a4fc5b86a822cc2f2f4d8cca03" translate="yes" xml:space="preserve">
          <source>Abstract Display Example</source>
          <target state="translated">Абстрактный пример дисплея</target>
        </trans-unit>
        <trans-unit id="8ca47e66401ef945d4b28414ef0d5576741f3686" translate="yes" xml:space="preserve">
          <source>Abstract Display Functions</source>
          <target state="translated">Функции абстрактного отображения</target>
        </trans-unit>
        <trans-unit id="69257aa08447c746dd43fabf319f01b5bf36c541" translate="yes" xml:space="preserve">
          <source>Accepting Output from Processes</source>
          <target state="translated">Приемка выхода из процессов</target>
        </trans-unit>
        <trans-unit id="b3e3bbc9103b04d543a6204da8e18664e43f77be" translate="yes" xml:space="preserve">
          <source>Access control</source>
          <target state="translated">Контроль доступа</target>
        </trans-unit>
        <trans-unit id="c95b17f402b7316d8ba7de52ef60427ce9506d18" translate="yes" xml:space="preserve">
          <source>Access to Documentation Strings</source>
          <target state="translated">Доступ к строкам документации</target>
        </trans-unit>
        <trans-unit id="ad4938a0faaa972c17f8af4c4d5fdcca75e5ab35" translate="yes" xml:space="preserve">
          <source>Access to Frame Parameters</source>
          <target state="translated">Доступ к параметрам кадра</target>
        </trans-unit>
        <trans-unit id="51a874cb0f96d3ea9f2ce946b1290deba1b58fd0" translate="yes" xml:space="preserve">
          <source>Access, manipulate and search the</source>
          <target state="translated">Доступ,манипуляция и поиск</target>
        </trans-unit>
        <trans-unit id="21dbc590326eedf17d212f7c64c83e8331fddf48" translate="yes" xml:space="preserve">
          <source>Accessing Elements of Lists</source>
          <target state="translated">Доступ к элементам списков</target>
        </trans-unit>
        <trans-unit id="b4efd1b0aae332f4b617e49e2f68b08f45ba40e4" translate="yes" xml:space="preserve">
          <source>Accessing Function Cell Contents</source>
          <target state="translated">Доступ к содержимому функциональных ячеек</target>
        </trans-unit>
        <trans-unit id="2ae0d4aab84373932fbdccdc1dd027efe8eb99b1" translate="yes" xml:space="preserve">
          <source>Accessing Mouse Events</source>
          <target state="translated">События,связанные с доступом к мыши</target>
        </trans-unit>
        <trans-unit id="7b70ffbc5424e39bca6adad4e4d11285e1ac347b" translate="yes" xml:space="preserve">
          <source>Accessing Other Processes</source>
          <target state="translated">Доступ к другим процессам</target>
        </trans-unit>
        <trans-unit id="8339c289bb6c2a3facc1658bda0b35c1d194fecf" translate="yes" xml:space="preserve">
          <source>Accessing Scroll Bar Events</source>
          <target state="translated">Доступ к событиям панели прокрутки</target>
        </trans-unit>
        <trans-unit id="8eb474e9f84ed1c8d415f59983dd55f6ddf51322" translate="yes" xml:space="preserve">
          <source>Accessing Symbol Properties</source>
          <target state="translated">Символ доступа Свойства</target>
        </trans-unit>
        <trans-unit id="dd21e1a656d1c33e1a0961edb1425706c4dca0fb" translate="yes" xml:space="preserve">
          <source>Accessing Variable Values</source>
          <target state="translated">Доступ к переменным значениям</target>
        </trans-unit>
        <trans-unit id="8572c608682fbb32c330cfe123c0c1e48efb3125" translate="yes" xml:space="preserve">
          <source>Accessing a window&amp;rsquo;s size.</source>
          <target state="translated">Доступ к размеру окна.</target>
        </trans-unit>
        <trans-unit id="f8f65e4cb3dd5208adf445a32728a6ff8fca1a80" translate="yes" xml:space="preserve">
          <source>Accessing and changing buffer names.</source>
          <target state="translated">Доступ к буферам и изменение их имен.</target>
        </trans-unit>
        <trans-unit id="3129221bf25c4d4b56aa75c86a37cdcc52d7977f" translate="yes" xml:space="preserve">
          <source>Accessing and recording terminal input.</source>
          <target state="translated">Доступ к входу терминала записи.</target>
        </trans-unit>
        <trans-unit id="8631d7461d61b93f0e7f285fa1d91660e92fcc8e" translate="yes" xml:space="preserve">
          <source>Accessing files.</source>
          <target state="translated">Доступ к файлам.</target>
        </trans-unit>
        <trans-unit id="6ab94f81e36e6a4e03c0557995d9d781180dfde7" translate="yes" xml:space="preserve">
          <source>Accessing or setting the function definition of a symbol.</source>
          <target state="translated">Доступ или настройка определения функции символа.</target>
        </trans-unit>
        <trans-unit id="febe729637e545444f7ff407ae1d3c58bfa2095e" translate="yes" xml:space="preserve">
          <source>Accessing other processes running on your system.</source>
          <target state="translated">Доступ к другим процессам,запущенным в вашей системе.</target>
        </trans-unit>
        <trans-unit id="317d74ecc1929588bf8f86c73cd8f7de6158a955" translate="yes" xml:space="preserve">
          <source>Accessing property lists stored elsewhere.</source>
          <target state="translated">Доступ к спискам свойств,хранящимся в других местах.</target>
        </trans-unit>
        <trans-unit id="4de3522fad93f3eb20523cf511d421cb8eef7ca4" translate="yes" xml:space="preserve">
          <source>Accessing run-status and other attributes.</source>
          <target state="translated">Доступ к статусу выполнения и другим атрибутам.</target>
        </trans-unit>
        <trans-unit id="e4d2ebfdc40bb29558e41e11ad7b405042d411f3" translate="yes" xml:space="preserve">
          <source>Accessing single items of match data, such as where a particular subexpression started.</source>
          <target state="translated">Доступ к отдельным элементам совпадающих данных,например,откуда начинается определенное подвыражение.</target>
        </trans-unit>
        <trans-unit id="e47d1cd990a7768c115296fc95220fcfe9f44b0e" translate="yes" xml:space="preserve">
          <source>Accessing symbol properties.</source>
          <target state="translated">Доступ к свойствам символов.</target>
        </trans-unit>
        <trans-unit id="97a8946bf0993a5ece0972055df9d2232582c889" translate="yes" xml:space="preserve">
          <source>Accessing the Entire Match Data</source>
          <target state="translated">Доступ ко всем совпадающим данным</target>
        </trans-unit>
        <trans-unit id="0098eec4c4a85cc7153b9941ac7e084d9e2e8113" translate="yes" xml:space="preserve">
          <source>Accessing the entire match data at once, as a list.</source>
          <target state="translated">Доступ ко всем данным о совпадении сразу,в виде списка.</target>
        </trans-unit>
        <trans-unit id="6d51c3b889a7d39ffb0cd69aa7cdd6137813bf7a" translate="yes" xml:space="preserve">
          <source>Accessor functions are provided to access the elements in this list. The accessors are mentioned along with the descriptions of the elements below.</source>
          <target state="translated">Для доступа к элементам из этого списка предусмотрены функции аксессуара.Аксессуары упоминаются вместе с описанием элементов ниже.</target>
        </trans-unit>
        <trans-unit id="a16eff51e0f2460918136851c80aba409432bd14" translate="yes" xml:space="preserve">
          <source>Accordingly, the native height of a frame may include the height of the tool bar but not that of the menu bar (Lucid, Motif, MS-Windows) or those of the menu bar and the tool bar (non-toolkit and text terminal frames).</source>
          <target state="translated">Соответственно,собственная высота кадра может включать в себя высоту панели инструментов,но не высоту панели меню (Lucid,Motif,MS-Windows)или высоту панели меню и панели инструментов (неинструментальные и текстовые терминальные кадры).</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="8be718ab6c21edb41bfaec3e8d4ff0416d658fc0" translate="yes" xml:space="preserve">
          <source>Action Alists for Buffer Display</source>
          <target state="translated">Акционные списки для буферного дисплея</target>
        </trans-unit>
        <trans-unit id="ce9f32ee0623ab47f4c96611c146ef4fcb105048" translate="yes" xml:space="preserve">
          <source>Action Functions for Buffer Display</source>
          <target state="translated">Действие Функции для отображения буфера</target>
        </trans-unit>
        <trans-unit id="bea1043802a5a73ba6a935cc95001c4084c8eed4" translate="yes" xml:space="preserve">
          <source>Active Display Table</source>
          <target state="translated">Таблица активного отображения</target>
        </trans-unit>
        <trans-unit id="1b42bb970933421bd7fe384eb941f0b135fc8d12" translate="yes" xml:space="preserve">
          <source>Active Keymaps</source>
          <target state="translated">Активные Клавиатуры</target>
        </trans-unit>
        <trans-unit id="8bae209835d078ba1a2b628e6a1e2a530501a3e6" translate="yes" xml:space="preserve">
          <source>Adapting code using the old defadvice</source>
          <target state="translated">Адаптация кода с помощью старого дефадвиса</target>
        </trans-unit>
        <trans-unit id="fb2cba4aab141960fa84cebe7cdaa1f7b5ca40f1" translate="yes" xml:space="preserve">
          <source>Adapting code using the old defadvice.</source>
          <target state="translated">Адаптация кода с помощью старого дефадвиса.</target>
        </trans-unit>
        <trans-unit id="d3aca0f70608cde924c0c717aa6f76cc5b6dd2c8" translate="yes" xml:space="preserve">
          <source>Adaptive Fill Mode</source>
          <target state="translated">Режим адаптивного заполнения</target>
        </trans-unit>
        <trans-unit id="ad3177b884766938f06c1f5cfe5f60876bbecbb6" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode chooses a fill prefix from context.</source>
          <target state="translated">В режиме адаптивной заливки префикс заливки выбирается из контекста.</target>
        </trans-unit>
        <trans-unit id="45867255fd797585e4916e018bbccee9a35d212f" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode is enabled when this variable is non-&lt;code&gt;nil&lt;/code&gt;. It is &lt;code&gt;t&lt;/code&gt; by default.</source>
          <target state="translated">Режим адаптивного заполнения включается, когда эта переменная не равна &lt;code&gt;nil&lt;/code&gt; . По умолчанию это &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41fe7af53eab5acab9f4d23fedd7b9d027e07088" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode matches this regular expression against the text starting after the left margin whitespace (if any) on a line; the characters it matches are that line&amp;rsquo;s candidate for the fill prefix.</source>
          <target state="translated">В режиме адаптивной заливки это регулярное выражение сопоставляется с текстом, начинающимся после левого пробела (если есть) в строке; символы, которые он соответствует, являются кандидатом этой строки на префикс заполнения.</target>
        </trans-unit>
        <trans-unit id="1298942391d0f9524543f2b581a0f4733a3cd521" translate="yes" xml:space="preserve">
          <source>Add &lt;var&gt;child&lt;/var&gt; to &lt;var&gt;node&lt;/var&gt;&amp;rsquo;s child list before the &lt;var&gt;before&lt;/var&gt; node. If &lt;var&gt;before&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, make &lt;var&gt;child&lt;/var&gt; the first child.</source>
          <target state="translated">Добавить &lt;var&gt;child&lt;/var&gt; к &lt;var&gt;node&lt;/var&gt; списка ребенка s до &lt;var&gt;before&lt;/var&gt; того узла. Если &lt;var&gt;before&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , сделайте &lt;var&gt;child&lt;/var&gt; первым.</target>
        </trans-unit>
        <trans-unit id="86a8c842c5f2e03db4ed77dc6cfb42a4e1d59a0e" translate="yes" xml:space="preserve">
          <source>Add a clipping path to &lt;var&gt;svg&lt;/var&gt;. If applied to a shape via the &lt;var&gt;:clip-path&lt;/var&gt; property, parts of that shape which lie outside of the clipping path are not drawn.</source>
          <target state="translated">Добавьте обтравочный контур в &lt;var&gt;svg&lt;/var&gt; . При применении к фигуре через свойство &lt;var&gt;:clip-path&lt;/var&gt; части этой фигуры, лежащие за пределами контура обрезки , не прорисовываются.</target>
        </trans-unit>
        <trans-unit id="ca2976f450cc856aed523c528c25b64c84e61f8c" translate="yes" xml:space="preserve">
          <source>Add a function to &lt;code&gt;font-lock-extend-region-functions&lt;/code&gt; that does the &lt;em&gt;identification&lt;/em&gt; and extends the scan so that the scanned text never starts or ends in the middle of a multiline construct.</source>
          <target state="translated">Добавьте функцию к &lt;code&gt;font-lock-extend-region-functions&lt;/code&gt; , которая выполняет &lt;em&gt;идентификацию&lt;/em&gt; и расширяет сканирование, чтобы отсканированный текст никогда не начинался и не заканчивался в середине многострочной конструкции.</target>
        </trans-unit>
        <trans-unit id="2437c12b4ee8245aff3c6e915602340a5cb79372" translate="yes" xml:space="preserve">
          <source>Add a polygon to &lt;var&gt;svg&lt;/var&gt; where &lt;var&gt;points&lt;/var&gt; is a list of X/Y pairs that describe the outer circumference of the polygon.</source>
          <target state="translated">Добавьте многоугольник в &lt;var&gt;svg&lt;/var&gt; , где &lt;var&gt;points&lt;/var&gt; - это список пар X / Y, описывающих внешнюю окружность многоугольника.</target>
        </trans-unit>
        <trans-unit id="d0cd8a519df07a3ed1321bd58a41305e60e7eb92" translate="yes" xml:space="preserve">
          <source>Add a watch for filesystem events pertaining to &lt;var&gt;file&lt;/var&gt;. This arranges for filesystem events pertaining to &lt;var&gt;file&lt;/var&gt; to be reported to Emacs.</source>
          <target state="translated">Добавьте наблюдение за событиями файловой системы, относящимися к &lt;var&gt;file&lt;/var&gt; . Это позволяет сообщать Emacs о событиях файловой системы, относящихся к &lt;var&gt;file&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="e14f3bd4b7856be2d474146674d049259534d312" translate="yes" xml:space="preserve">
          <source>Add an element to &lt;code&gt;minor-mode-alist&lt;/code&gt; for each minor mode (see &lt;a href=&quot;mode-line-variables#Definition-of-minor_002dmode_002dalist&quot;&gt;Definition of minor-mode-alist&lt;/a&gt;), if you want to indicate the minor mode in the mode line. This element should be a list of the following form:</source>
          <target state="translated">Добавьте элемент в &lt;code&gt;minor-mode-alist&lt;/code&gt; для каждого второстепенного режима (см. &lt;a href=&quot;mode-line-variables#Definition-of-minor_002dmode_002dalist&quot;&gt;Определение minor-mode-alist&lt;/a&gt; ), если вы хотите указать второстепенный режим в строке режима. Этот элемент должен быть списком следующего вида:</target>
        </trans-unit>
        <trans-unit id="7cff03d7e41619c195637edc380375b892f0845c" translate="yes" xml:space="preserve">
          <source>Add an embedded (raster) image to &lt;var&gt;svg&lt;/var&gt;. If &lt;var&gt;datap&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;image&lt;/var&gt; should be a file name; otherwise it should be a string containing the image data as raw bytes. &lt;var&gt;image-type&lt;/var&gt; should be a</source>
          <target state="translated">Добавить внедренное (растровое) изображение в &lt;var&gt;svg&lt;/var&gt; . Если &lt;var&gt;datap&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;image&lt;/var&gt; должно быть именем файла; в противном случае это должна быть строка, содержащая данные изображения в виде необработанных байтов. &lt;var&gt;image-type&lt;/var&gt; должен быть</target>
        </trans-unit>
        <trans-unit id="a711fa29586567ced283637a07f291daf9eccd20" translate="yes" xml:space="preserve">
          <source>Add line breaks and indentation to the top-level Lisp form at point to make it more readable.</source>
          <target state="translated">Добавьте разрывы строк и отступы в форму Lisp верхнего уровня,чтобы сделать ее более читабельной.</target>
        </trans-unit>
        <trans-unit id="4d943f97d99246a36fad53c87be01c95f3a766cf" translate="yes" xml:space="preserve">
          <source>Add the advice &lt;var&gt;function&lt;/var&gt; to the named function &lt;var&gt;symbol&lt;/var&gt;. &lt;var&gt;where&lt;/var&gt; and &lt;var&gt;props&lt;/var&gt; have the same meaning as for &lt;code&gt;add-function&lt;/code&gt; (see &lt;a href=&quot;core-advising-primitives#Core-Advising-Primitives&quot;&gt;Core Advising Primitives&lt;/a&gt;).</source>
          <target state="translated">Добавьте &lt;var&gt;function&lt;/var&gt; совета к названному &lt;var&gt;symbol&lt;/var&gt; функции . &lt;var&gt;where&lt;/var&gt; и &lt;var&gt;props&lt;/var&gt; имеют то же значение, что и для &lt;code&gt;add-function&lt;/code&gt; (см. &lt;a href=&quot;core-advising-primitives#Core-Advising-Primitives&quot;&gt;Основные рекомендательные примитивы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="83a774fd7318f04762e68de4e2b137225620ce7f" translate="yes" xml:space="preserve">
          <source>Add the custom node &lt;var&gt;tag&lt;/var&gt; to &lt;var&gt;svg&lt;/var&gt;.</source>
          <target state="translated">Добавьте настраиваемый &lt;var&gt;tag&lt;/var&gt; узла в &lt;var&gt;svg&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3861b616706cb862303f0503ef614aace33c9de7" translate="yes" xml:space="preserve">
          <source>Add the outline of a shape to &lt;var&gt;svg&lt;/var&gt; according to &lt;var&gt;commands&lt;/var&gt;, see &lt;a href=&quot;#SVG-Path-Commands&quot;&gt;SVG Path Commands&lt;/a&gt;.</source>
          <target state="translated">Добавьте контур формы в &lt;var&gt;svg&lt;/var&gt; в соответствии с &lt;var&gt;commands&lt;/var&gt; , см. &lt;a href=&quot;#SVG-Path-Commands&quot;&gt;Команды SVG Path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9913c193acde9c02d5ae3b24bc390ab6d78afa81" translate="yes" xml:space="preserve">
          <source>Add the specified &lt;var&gt;text&lt;/var&gt; to &lt;var&gt;svg&lt;/var&gt;.</source>
          <target state="translated">Добавьте указанный &lt;var&gt;text&lt;/var&gt; в &lt;var&gt;svg&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="8aacc8a54a520b2ac614e1a90f78fb2eedfee11f" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a circle whose center is at &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt; and whose radius is &lt;var&gt;radius&lt;/var&gt;.</source>
          <target state="translated">Добавьте в &lt;var&gt;svg&lt;/var&gt; круг, центр которого находится в &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; , а радиус - &lt;var&gt;radius&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="4fe52fae4d07b75457a9542137a4b9b5c60d0aef" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a line that starts at &lt;var&gt;x1&lt;/var&gt;/&lt;var&gt;y1&lt;/var&gt; and extends to &lt;var&gt;x2&lt;/var&gt;/&lt;var&gt;y2&lt;/var&gt;.</source>
          <target state="translated">Добавьте в &lt;var&gt;svg&lt;/var&gt; строку, которая начинается с &lt;var&gt;x1&lt;/var&gt; / &lt;var&gt;y1&lt;/var&gt; и продолжается до &lt;var&gt;x2&lt;/var&gt; / &lt;var&gt;y2&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="6a286d1f3e95235d9468003833dcabc092caa2e1" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a multiple-segment line (a.k.a. &amp;ldquo;polyline&amp;rdquo;) that goes through &lt;var&gt;points&lt;/var&gt;, which is a list of X/Y position pairs.</source>
          <target state="translated">Добавьте в &lt;var&gt;svg&lt;/var&gt; многосегментную линию (также известную как &amp;laquo;полилиния&amp;raquo;), проходящую через &lt;var&gt;points&lt;/var&gt; , которая представляет собой список пар позиций X / Y.</target>
        </trans-unit>
        <trans-unit id="565a0d4084aef376e27a550cb97be439640f51cd" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a rectangle whose upper left corner is at position &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt; and whose size is &lt;var&gt;width&lt;/var&gt;/&lt;var&gt;height&lt;/var&gt;.</source>
          <target state="translated">Добавьте в &lt;var&gt;svg&lt;/var&gt; прямоугольник, верхний левый угол которого находится в позиции &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; , а размер - &lt;var&gt;width&lt;/var&gt; / &lt;var&gt;height&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f117e38663daed515f31d78095890b69b59541be" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; an ellipse whose center is at &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt;, and whose horizontal radius is &lt;var&gt;x-radius&lt;/var&gt; and the vertical radius is &lt;var&gt;y-radius&lt;/var&gt;.</source>
          <target state="translated">Добавьте в &lt;var&gt;svg&lt;/var&gt; эллипс, центр которого находится в &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; , а горизонтальный радиус - &lt;var&gt;x-radius&lt;/var&gt; , а вертикальный радиус - &lt;var&gt;y-radius&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a72995a8fcd466eb526d56641ee9c271fda926c9" translate="yes" xml:space="preserve">
          <source>Adding additional information about a function.</source>
          <target state="translated">Добавление дополнительной информации о функции.</target>
        </trans-unit>
        <trans-unit id="8d9d382c9e9984ab00e1fba4ef0f8c1158adf2d5" translate="yes" xml:space="preserve">
          <source>Adding buttons to Emacs buffers.</source>
          <target state="translated">Добавление кнопок в буферы Emacs.</target>
        </trans-unit>
        <trans-unit id="53b2f670a3f5ad65cee3f0da686a14d79f042bed" translate="yes" xml:space="preserve">
          <source>Adding clickable buttons to Emacs buffers.</source>
          <target state="translated">Добавление кликабельных кнопок в буферы Emacs.</target>
        </trans-unit>
        <trans-unit id="4679096d507cd2c89ee536f4f3c0706150098e70" translate="yes" xml:space="preserve">
          <source>Adding new text to a buffer.</source>
          <target state="translated">Добавление нового текста в буфер.</target>
        </trans-unit>
        <trans-unit id="95751041c5c1654a609b5b64e61a15f9bddb79a0" translate="yes" xml:space="preserve">
          <source>Adding to the definition of a function.</source>
          <target state="translated">Добавление к определению функции.</target>
        </trans-unit>
        <trans-unit id="58b99f3d38ede1597b9ac02693be3ab80822e821" translate="yes" xml:space="preserve">
          <source>Adding, subtracting, comparing times, etc.</source>
          <target state="translated">Добавление,вычитание,сравнение времени и т.д.</target>
        </trans-unit>
        <trans-unit id="500196012d89f448a3af179ba361faa20093707c" translate="yes" xml:space="preserve">
          <source>Additional Options for Displaying Buffers</source>
          <target state="translated">Дополнительные опции для отображения буферов</target>
        </trans-unit>
        <trans-unit id="58c09d8cc944ca4e37be6c32b0108073f18357b2" translate="yes" xml:space="preserve">
          <source>Additional alist entries may be defined in the future.</source>
          <target state="translated">Дополнительные списки могут быть определены в будущем.</target>
        </trans-unit>
        <trans-unit id="a22e777afc57137b40767d7ea63841431e6d681d" translate="yes" xml:space="preserve">
          <source>Additional customization facilities.</source>
          <target state="translated">Дополнительные возможности для настройки.</target>
        </trans-unit>
        <trans-unit id="d931ed9a4962a5016c462de8f0c48ae86a47f189" translate="yes" xml:space="preserve">
          <source>Additional flags each character can have.</source>
          <target state="translated">Дополнительные флаги,которые может иметь каждый символ.</target>
        </trans-unit>
        <trans-unit id="94e8d86d4f239006083ee80460e98ca2f47369d1" translate="yes" xml:space="preserve">
          <source>Additional image properties supported for the &lt;code&gt;xbm&lt;/code&gt; image type are:</source>
          <target state="translated">Дополнительные свойства изображения, поддерживаемые для &lt;code&gt;xbm&lt;/code&gt; изображения xbm :</target>
        </trans-unit>
        <trans-unit id="6431dff5a05dff6ce51567fbc49ea8750d45e21d" translate="yes" xml:space="preserve">
          <source>Additional keypad duplicates of keys ordinarily found elsewhere. Emacs normally translates these into the like-named non-keypad keys.</source>
          <target state="translated">Дополнительные дубликаты клавиш клавиатуры,которые обычно находятся в других местах.Emacs обычно переводит их в одноимённые неклавиатурные ключи.</target>
        </trans-unit>
        <trans-unit id="6338a470de402714fad49d59e574ee2a004eb402" translate="yes" xml:space="preserve">
          <source>Additional relevant functions for net connections.</source>
          <target state="translated">Дополнительные соответствующие функции для сетевых соединений.</target>
        </trans-unit>
        <trans-unit id="3c7e388f967fe300edc4c7b897df6b058218b157" translate="yes" xml:space="preserve">
          <source>Additional space to leave below each text line, in pixels (a positive integer). See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;, for more information.</source>
          <target state="translated">Дополнительное пространство, которое следует оставить под каждой текстовой строкой в ​​пикселях (положительное целое число). См. Раздел &amp;laquo; &lt;a href=&quot;line-height#Line-Height&quot;&gt;Высота линии&amp;raquo;&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b1fd54e2342c288944104eeefd68ecbc3f125806" translate="yes" xml:space="preserve">
          <source>Additional typographic style information for the font, such as &amp;lsquo;</source>
          <target state="translated">Дополнительная информация о типографском стиле шрифта, например &quot;</target>
        </trans-unit>
        <trans-unit id="ee273060f190cc74f93860343b827ad47759d5a0" translate="yes" xml:space="preserve">
          <source>Additionally, C code can modify the value of variables directly, bypassing the watchpoint mechanism.</source>
          <target state="translated">Кроме того,код C может изменять значение переменных напрямую,минуя часовой механизм.</target>
        </trans-unit>
        <trans-unit id="a8a4e955fb763f3e97efcc9f314ccd7894853f87" translate="yes" xml:space="preserve">
          <source>Additionally, arrange to display &lt;var&gt;doc&lt;/var&gt; along with the docstring of &lt;code&gt;pcase&lt;/code&gt;. By convention, &lt;var&gt;doc&lt;/var&gt; should use &lt;code&gt;EXPVAL&lt;/code&gt; to stand for the result of evaluating &lt;var&gt;expression&lt;/var&gt; (first arg to &lt;code&gt;pcase&lt;/code&gt;).</source>
          <target state="translated">Кроме того, организуйте отображение &lt;var&gt;doc&lt;/var&gt; вместе со &lt;code&gt;pcase&lt;/code&gt; документации pcase . По соглашению, &lt;var&gt;doc&lt;/var&gt; должен использовать &lt;code&gt;EXPVAL&lt;/code&gt; для обозначения результата вычисления &lt;var&gt;expression&lt;/var&gt; (от первого аргумента до &lt;code&gt;pcase&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="21af65202f21fc2dc93653ae03092063c5b61dff" translate="yes" xml:space="preserve">
          <source>Additionally, conflicts can occur:</source>
          <target state="translated">Кроме того,могут возникать конфликты:</target>
        </trans-unit>
        <trans-unit id="e75498292efb2e16310b12aff15b14972a22b009" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;var&gt;collection&lt;/var&gt; should generally not be pre-filtered based on the current text between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, because that is the responsibility of the caller of &lt;code&gt;completion-at-point-functions&lt;/code&gt; to do that according to the completion styles it decides to use.</source>
          <target state="translated">Кроме того, как правило , &lt;var&gt;collection&lt;/var&gt; не следует предварительно фильтровать на основе текущего текста между &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; , потому что это ответственность вызывающего функции &lt;code&gt;completion-at-point-functions&lt;/code&gt; чтобы сделать это в соответствии со стилями завершения, которые он решает использовать.</target>
        </trans-unit>
        <trans-unit id="82ec8503880130af95fe77d33f6e32d8d45be1c7" translate="yes" xml:space="preserve">
          <source>Adjustable Tab Stops</source>
          <target state="translated">Регулируемые упоры табуляции</target>
        </trans-unit>
        <trans-unit id="cce71d8b4de0fbe7b1d1416d923c41d53c78a09c" translate="yes" xml:space="preserve">
          <source>Adjustable, typewriter-like tab stops.</source>
          <target state="translated">Регулируемая,как печатная машинка,закладка останавливается.</target>
        </trans-unit>
        <trans-unit id="3b315ad397f4b4a0ed97547b767a1277549aaf87" translate="yes" xml:space="preserve">
          <source>Adjusting Point After Commands</source>
          <target state="translated">Настройка точки после команды</target>
        </trans-unit>
        <trans-unit id="9a61906e01d69a6bb351e657b21352956d8d32ce" translate="yes" xml:space="preserve">
          <source>Adjustment of point after a command.</source>
          <target state="translated">Настройка точки после команды.</target>
        </trans-unit>
        <trans-unit id="e59f2f2723f7c1f609f3550bb2671a6cb90986fe" translate="yes" xml:space="preserve">
          <source>Advice and coding conventions for Emacs Lisp.</source>
          <target state="translated">Консультации и конвенции по кодированию для Emacs Lisp.</target>
        </trans-unit>
        <trans-unit id="40d1b99315ff674405912fd3cc10e5b67c67dd32" translate="yes" xml:space="preserve">
          <source>Advising Emacs Lisp Functions</source>
          <target state="translated">Консультирование Emacs Lisp Functions</target>
        </trans-unit>
        <trans-unit id="7d52de2eb6adab7304f81575e610e6fdaba9cc2d" translate="yes" xml:space="preserve">
          <source>Advising Named Functions</source>
          <target state="translated">Консультирование по названным функциям</target>
        </trans-unit>
        <trans-unit id="ab277db91341f63fab17a1c61d2a97a801877f92" translate="yes" xml:space="preserve">
          <source>Advising named functions.</source>
          <target state="translated">Консультирую по названным функциям.</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="2001d34da0f06a489ff0edce787794897f4aeb55" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;set-text-properties&lt;/code&gt; returns, all the characters in the specified range have identical properties.</source>
          <target state="translated">После возврата &lt;code&gt;set-text-properties&lt;/code&gt; все символы в указанном диапазоне имеют идентичные свойства.</target>
        </trans-unit>
        <trans-unit id="26622072ea6b71fa07e70b43c76041b80e7e5a30" translate="yes" xml:space="preserve">
          <source>After Emacs changes a file, there are two reasons the changes might not survive later failures of power or media, both having to do with efficiency. First, the operating system might alias written data with data already stored elsewhere on secondary storage until one file or the other is later modified; this will lose both files if the only copy on secondary storage is lost due to media failure. Second, the operating system might not write data to secondary storage immediately, which will lose the data if power is lost.</source>
          <target state="translated">После того,как Emacs изменит файл,есть две причины,по которым изменения могут не выдержать последующих сбоев питания или носителя,обе из которых связаны с эффективностью.Во-первых,операционная система может называть записанные данные данными,которые уже хранятся в другом месте на вторичном носителе,до тех пор,пока один файл или другой не будет изменен позже;это приведет к потере обоих файлов,если единственная копия на вторичном носителе будет потеряна из-за сбоя носителя.Во-вторых,операционная система может не записать данные на вторичное хранилище сразу же,что приведет к потере данных в случае отключения питания.</target>
        </trans-unit>
        <trans-unit id="9f89518425e409284cb01cc7c3c6a1775a6a510d" translate="yes" xml:space="preserve">
          <source>After Emacs reads your init file, it initializes &lt;code&gt;auto-save-list-file-name&lt;/code&gt; (if you have not already set it non-&lt;code&gt;nil&lt;/code&gt;) based on this prefix, adding the host name and process ID. If you set this to &lt;code&gt;nil&lt;/code&gt; in your init file, then Emacs does not initialize &lt;code&gt;auto-save-list-file-name&lt;/code&gt;.</source>
          <target state="translated">После того, как Emacs прочитает ваш файл инициализации, он инициализирует &lt;code&gt;auto-save-list-file-name&lt;/code&gt; (если вы еще не установили его отличным от &lt;code&gt;nil&lt;/code&gt; ) на основе этого префикса, добавляя имя хоста и идентификатор процесса. Если вы установите это значение в &lt;code&gt;nil&lt;/code&gt; в вашем файле инициализации, то Emacs не инициализирует &lt;code&gt;auto-save-list-file-name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6d6ee5d7d9a1dbc90deb665a4ae3ffff4b1c578" translate="yes" xml:space="preserve">
          <source>After Font Lock evaluates &lt;var&gt;pre-form&lt;/var&gt;, it does not search for &lt;var&gt;anchored-matcher&lt;/var&gt; beyond the end of the line. However, if &lt;var&gt;pre-form&lt;/var&gt; returns a buffer position that is greater than the position of point after &lt;var&gt;pre-form&lt;/var&gt; is evaluated, then the position returned by &lt;var&gt;pre-form&lt;/var&gt; is used as the limit of the search instead. It is generally a bad idea to return a position greater than the end of the line; in other words, the &lt;var&gt;anchored-matcher&lt;/var&gt; search should not span lines.</source>
          <target state="translated">После того, как Font Lock оценивает &lt;var&gt;pre-form&lt;/var&gt; , он не выполняет поиск &lt;var&gt;anchored-matcher&lt;/var&gt; за пределами конца строки. Однако, если &lt;var&gt;pre-form&lt;/var&gt; возвращает позицию в буфере, которая больше, чем позиция точки после оценки &lt;var&gt;pre-form&lt;/var&gt; , то позиция, возвращаемая &lt;var&gt;pre-form&lt;/var&gt; вместо этого используется в качестве ограничения поиска. Как правило, возвращать позицию больше конца строки - плохая идея; другими словами, поиск &lt;var&gt;anchored-matcher&lt;/var&gt; не должен охватывать строки.</target>
        </trans-unit>
        <trans-unit id="0d5f3b64280f526c25116915081cc07a4ccb40b7" translate="yes" xml:space="preserve">
          <source>After a &lt;em&gt;synchronous process&lt;/em&gt; is created, Emacs waits for the process to terminate before continuing. Starting Dired on GNU or Unix&lt;a href=&quot;#FOOT21&quot; name=&quot;DOCF21&quot;&gt;&lt;sup&gt;21&lt;/sup&gt;&lt;/a&gt; is an example of this: it runs &lt;code&gt;ls&lt;/code&gt; in a synchronous process, then modifies the output slightly. Because the process is synchronous, the entire directory listing arrives in the buffer before Emacs tries to do anything with it.</source>
          <target state="translated">После создания &lt;em&gt;синхронного процесса&lt;/em&gt; Emacs ожидает завершения процесса перед продолжением. Примером этого является запуск Dired в GNU или Unix &lt;a href=&quot;#FOOT21&quot; name=&quot;DOCF21&quot;&gt;&lt;sup&gt;21&lt;/sup&gt;&lt;/a&gt; : он запускает &lt;code&gt;ls&lt;/code&gt; в синхронном процессе, а затем немного изменяет вывод. Поскольку процесс является синхронным, весь список каталогов попадает в буфер до того, как Emacs попытается что-либо с ним сделать.</target>
        </trans-unit>
        <trans-unit id="79d05caca5759ed0ecaf87a1fc890988221544d6" translate="yes" xml:space="preserve">
          <source>After adding this advice, if you call &lt;code&gt;my-double&lt;/code&gt; with &amp;lsquo;</source>
          <target state="translated">После добавления этого совета, если вы назовете &lt;code&gt;my-double&lt;/code&gt; с помощью '</target>
        </trans-unit>
        <trans-unit id="b482ecda0086b5db531f75dfdba2467dc5429ef2" translate="yes" xml:space="preserve">
          <source>After an inline function is defined, its inline expansion can be performed later on in the same file, just like macros.</source>
          <target state="translated">После определения встроенной функции ее расширение может быть позже выполнено в том же файле,что и макросы.</target>
        </trans-unit>
        <trans-unit id="1711c03422a1600eb8ad808ec0bc8cf24123cdd2" translate="yes" xml:space="preserve">
          <source>After defining &lt;var&gt;name&lt;/var&gt; in this way, you can use it as the &lt;var&gt;test&lt;/var&gt; argument in &lt;code&gt;make-hash-table&lt;/code&gt;. When you do that, the hash table will use &lt;var&gt;test-fn&lt;/var&gt; to compare key values, and &lt;var&gt;hash-fn&lt;/var&gt; to compute a hash code from a key value.</source>
          <target state="translated">Определив &lt;var&gt;name&lt;/var&gt; таким образом, вы можете использовать его как &lt;var&gt;test&lt;/var&gt; аргумент в &lt;code&gt;make-hash-table&lt;/code&gt; . Когда вы это сделаете, хеш-таблица будет использовать &lt;var&gt;test-fn&lt;/var&gt; для сравнения значений ключей и &lt;var&gt;hash-fn&lt;/var&gt; для вычисления хеш-кода из значения ключа.</target>
        </trans-unit>
        <trans-unit id="cb84be952166d7a786e0f5810ef1b95aefca141b" translate="yes" xml:space="preserve">
          <source>After executing the body of the handler, the &lt;code&gt;condition-case&lt;/code&gt; returns normally, using the value of the last form in the handler body as the overall value.</source>
          <target state="translated">После выполнения тела обработчика &lt;code&gt;condition-case&lt;/code&gt; возвращается в обычном режиме, используя значение последней формы в теле обработчика в качестве общего значения.</target>
        </trans-unit>
        <trans-unit id="4dcf95c5a0c487e8209e489fa588abd672d9e8b8" translate="yes" xml:space="preserve">
          <source>After execution of the handler body, execution returns from the &lt;code&gt;condition-case&lt;/code&gt; form. Because the protected form is exited completely before execution of the handler, the handler cannot resume execution at the point of the error, nor can it examine variable bindings that were made within the protected form. All it can do is clean up and proceed.</source>
          <target state="translated">После выполнения тела обработчика выполнение возвращается из формы &lt;code&gt;condition-case&lt;/code&gt; . Поскольку защищенная форма полностью завершается перед выполнением обработчика, обработчик не может возобновить выполнение в точке ошибки, а также не может проверить привязки переменных, которые были сделаны в защищенной форме. Все, что он может сделать, это очистить и продолжить.</target>
        </trans-unit>
        <trans-unit id="f9f96cc122b695225532f65f8c1dc5af1dd81ad0" translate="yes" xml:space="preserve">
          <source>After installation, the installed package is &lt;em&gt;loaded&lt;/em&gt;: Emacs adds the package&amp;rsquo;s content directory to &lt;code&gt;load-path&lt;/code&gt;, and evaluates the autoload definitions in</source>
          <target state="translated">После установки установленный пакет &lt;em&gt;загружается&lt;/em&gt; : Emacs добавляет каталог содержимого пакета в &lt;code&gt;load-path&lt;/code&gt; и оценивает определения автозагрузки в</target>
        </trans-unit>
        <trans-unit id="7d8f54422101c3e253d2eea8938b01fa0aa88a65" translate="yes" xml:space="preserve">
          <source>After moving point, you may wish to jump back to the stop point. You can do that with</source>
          <target state="translated">После точки перемещения можно перепрыгнуть обратно к точке остановки.Вы можете сделать это с</target>
        </trans-unit>
        <trans-unit id="70f30068f24e099728f9220f33c66de8c45b3661" translate="yes" xml:space="preserve">
          <source>After selecting</source>
          <target state="translated">После выбора</target>
        </trans-unit>
        <trans-unit id="6b47650b2f0eeaae057157d2f6dba970bba4bcc2" translate="yes" xml:space="preserve">
          <source>After substitution, if a &amp;lsquo;</source>
          <target state="translated">После замены, если '</target>
        </trans-unit>
        <trans-unit id="11efe5f0fdddc5460cc69a92a923925429424bb2" translate="yes" xml:space="preserve">
          <source>After switching windows or buffers, and in some other cases, if the window start is in the middle of a line, Emacs adjusts the window start to the start of a line. This prevents certain operations from leaving the window start at a meaningless point within a line. This feature may interfere with testing some Lisp code by executing it using the commands of Lisp mode, because they trigger this readjustment. To test such code, put it into a command and bind the command to a key.</source>
          <target state="translated">После переключения окон или буферов,а также в некоторых других случаях,если начало окна находится в середине линии,Emacs подстраивает начало окна под начало линии.Это не позволяет некоторым операциям оставить старт окна в бессмысленной точке внутри линии.Эта возможность может помешать тестированию некоторого кода на языке Lisp,выполняя его с помощью команд режима Lisp,так как они инициируют эту перенастройку.Чтобы проверить такой код,поместите его в команду и привяжите команду к ключу.</target>
        </trans-unit>
        <trans-unit id="495827ab1d768e91f37fdef6604e6f5836895698" translate="yes" xml:space="preserve">
          <source>After that, &lt;var&gt;body&lt;/var&gt; is executed, and the connection-local variables are unwound. Example:</source>
          <target state="translated">После этого выполняется &lt;var&gt;body&lt;/var&gt; и разматываются локальные переменные соединения. Пример:</target>
        </trans-unit>
        <trans-unit id="6ba43c834d967b77f336f5c21c19c92d28a6987a" translate="yes" xml:space="preserve">
          <source>After the &amp;lsquo;</source>
          <target state="translated">После '</target>
        </trans-unit>
        <trans-unit id="d9009ae4cb68e38ac581c27d4e2acc4e2c297d9b" translate="yes" xml:space="preserve">
          <source>After the call to the &lt;code&gt;DEFUN&lt;/code&gt; macro, you must write the argument list for the C function, including the types for the arguments. If the primitive accepts a fixed maximum number of Lisp arguments, there must be one C argument for each Lisp argument, and each argument must be of type &lt;code&gt;Lisp_Object&lt;/code&gt;. (Various macros and functions for creating values of type &lt;code&gt;Lisp_Object&lt;/code&gt; are declared in the file</source>
          <target state="translated">После вызова макроса &lt;code&gt;DEFUN&lt;/code&gt; вы должны написать список аргументов для функции C, включая типы аргументов. Если примитив принимает фиксированное максимальное количество аргументов Лиспа, должен быть один аргумент C для каждого аргумента Лиспа, и каждый аргумент должен иметь тип &lt;code&gt;Lisp_Object&lt;/code&gt; . (В &lt;code&gt;Lisp_Object&lt;/code&gt; объявлены различные макросы и функции для создания значений типа Lisp_Object.</target>
        </trans-unit>
        <trans-unit id="33d79aff6f896ac6094c3c7ab2c4138388d48ec5" translate="yes" xml:space="preserve">
          <source>After the command loop has translated a key sequence into a command, it invokes that command using the function &lt;code&gt;command-execute&lt;/code&gt;. If the command is a function, &lt;code&gt;command-execute&lt;/code&gt; calls &lt;code&gt;call-interactively&lt;/code&gt;, which reads the arguments and calls the command. You can also call these functions yourself.</source>
          <target state="translated">После того, как командный цикл преобразовал последовательность клавиш в команду, он вызывает эту команду с помощью функции &lt;code&gt;command-execute&lt;/code&gt; . Если команда является функцией, &lt;code&gt;command-execute&lt;/code&gt; вызывает &lt;code&gt;call-interactively&lt;/code&gt; , который считывает аргументы и вызывает команду. Вы также можете вызвать эти функции самостоятельно.</target>
        </trans-unit>
        <trans-unit id="eb00eb8abe509aa0e806964b17e030d795a6dcae" translate="yes" xml:space="preserve">
          <source>After the file has been loaded, the symbol should have a new function definition that is not an autoload object. The new definition is then called as if it had been there to begin with. From the user&amp;rsquo;s point of view, the function call works as expected, using the function definition in the loaded file.</source>
          <target state="translated">После загрузки файла у символа должно быть определение новой функции, не являющееся объектом автозагрузки. Затем вызывается новое определение, как если бы оно было изначально. С точки зрения пользователя вызов функции работает должным образом с использованием определения функции в загруженном файле.</target>
        </trans-unit>
        <trans-unit id="5e64aa108dd56236b255a2bfaa30873fae10d663" translate="yes" xml:space="preserve">
          <source>After the lines are joined, the function &lt;code&gt;fixup-whitespace&lt;/code&gt; is responsible for deciding whether to leave a space at the junction.</source>
          <target state="translated">После соединения строк функция &lt;code&gt;fixup-whitespace&lt;/code&gt; отвечает за решение, оставлять ли пробел на стыке.</target>
        </trans-unit>
        <trans-unit id="8028d1d381d5b478f2dffeace51ce5901d720198" translate="yes" xml:space="preserve">
          <source>After the terminal is initialized, this is set to the terminal-specific initialization function.</source>
          <target state="translated">После инициализации клеммы она устанавливается на функцию инициализации для конкретной клеммы.</target>
        </trans-unit>
        <trans-unit id="c2df18475dff27329715d9ae9944a0845bdbbdd4" translate="yes" xml:space="preserve">
          <source>After these mandatory arguments follow the keyword arguments. The most important is &lt;code&gt;:type&lt;/code&gt;, which describes the data type we want to match with this widget. Here a &lt;code&gt;binary-tree-of-string&lt;/code&gt; is described as being either a string, or a cons-cell whose car and cdr are themselves both &lt;code&gt;binary-tree-of-string&lt;/code&gt;. Note the reference to the widget type we are currently in the process of defining. The &lt;code&gt;:tag&lt;/code&gt; attribute is a string to name the widget in the user interface, and the &lt;code&gt;:offset&lt;/code&gt; argument is there to ensure that child nodes are indented four spaces relative to the parent node, making the tree structure apparent in the customization buffer.</source>
          <target state="translated">После этих обязательных аргументов следует ключевое слово arguments. Наиболее важным является &lt;code&gt;:type&lt;/code&gt; , который описывает тип данных, который мы хотим сопоставить с этим виджетом. Здесь &lt;code&gt;binary-tree-of-string&lt;/code&gt; описывается как строка или cons-ячейка, car и cdr которой сами являются &lt;code&gt;binary-tree-of-string&lt;/code&gt; . Обратите внимание на ссылку на тип виджета, который мы в настоящее время определяем. &lt;code&gt;:tag&lt;/code&gt; атрибут представляет собой строку имени виджета в пользовательском интерфейсе, а также &lt;code&gt;:offset&lt;/code&gt; аргумент там , чтобы гарантировать , что дочерние узлы отступ в четыре пробела относительно родительского узла, в результате чего структуры дерева проявляется в буфере настройки.</target>
        </trans-unit>
        <trans-unit id="fdf9c94744bf9492e6805756a0c97707a0c90bae" translate="yes" xml:space="preserve">
          <source>After writing your C code for a module function, you should make a Lisp function object from it using the &lt;code&gt;make_function&lt;/code&gt; function, whose pointer is provided in the environment (recall that the pointer to the environment is returned by &lt;code&gt;get_environment&lt;/code&gt;). This is normally done in the module initialization function (see &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;module initialization function&lt;/a&gt;), after verifying the</source>
          <target state="translated">После написания кода C для функции модуля вы должны создать из него объект функции Lisp, используя функцию &lt;code&gt;make_function&lt;/code&gt; , указатель которой предоставляется в среде (напомним, что указатель на среду возвращается &lt;code&gt;get_environment&lt;/code&gt; ). Обычно это делается в функции инициализации модуля (см. &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;Функцию инициализации модуля&lt;/a&gt; ) после проверки</target>
        </trans-unit>
        <trans-unit id="01273641f1108e9334b3ff2f2de5aac2328b0349" translate="yes" xml:space="preserve">
          <source>After you activate the change group, any changes you make in that buffer become part of it. Once you have made all the desired changes in the buffer, you must &lt;em&gt;finish&lt;/em&gt; the change group. There are two ways to do this: you can either accept (and finalize) all the changes, or cancel them all.</source>
          <target state="translated">После активации группы изменений любые изменения, которые вы вносите в этот буфер, становятся ее частью. После того, как вы внесли все желаемые изменения в буфер, вы должны &lt;em&gt;завершить&lt;/em&gt; группу изменений. Это можно сделать двумя способами: вы можете либо принять (и завершить) все изменения, либо отменить их все.</target>
        </trans-unit>
        <trans-unit id="156a361715177a7a195a547edfc720451b956bc1" translate="yes" xml:space="preserve">
          <source>After you create an archive, remember that it is not accessible in the Package Menu interface unless it is in &lt;code&gt;package-archives&lt;/code&gt;.</source>
          <target state="translated">После создания архива помните, что он недоступен в интерфейсе меню пакетов, если он не находится в &lt;code&gt;package-archives&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6177c7642a19bf3ac0b659b32ac63c9a38ada82" translate="yes" xml:space="preserve">
          <source>After you think you have fixed the problem, use</source>
          <target state="translated">После того,как вы думаете,что решили проблему,используйте</target>
        </trans-unit>
        <trans-unit id="26afb7a30b02ada3701025dcae553b3342d65c03" translate="yes" xml:space="preserve">
          <source>Alias Menu Items</source>
          <target state="translated">Меню псевдонимов Пункты</target>
        </trans-unit>
        <trans-unit id="4ecfd05f5c4a9c12f77ec0ab644b70282ba9ee84" translate="yes" xml:space="preserve">
          <source>Alist with elements</source>
          <target state="translated">Алист с элементами</target>
        </trans-unit>
        <trans-unit id="4a7098b2dd254466abcb5233fdc2c39c1c9bc767" translate="yes" xml:space="preserve">
          <source>Alists for fine-tuning buffer display.</source>
          <target state="translated">Списки для точной настройки отображения буфера.</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="a745dcd86b59cafb3c0ca3bc7c385a6602657fcf" translate="yes" xml:space="preserve">
          <source>All &lt;var&gt;exp&lt;/var&gt;s are evaluated first, after which they are matched against their respective &lt;var&gt;pattern&lt;/var&gt;, introducing new variable bindings that can then be used inside &lt;var&gt;body&lt;/var&gt;. The variable bindings are produced by destructuring binding of elements of &lt;var&gt;pattern&lt;/var&gt; to the values of the corresponding elements of the evaluated &lt;var&gt;exp&lt;/var&gt;.</source>
          <target state="translated">Сначала оцениваются все &lt;var&gt;exp&lt;/var&gt; , после чего они сопоставляются с их соответствующим &lt;var&gt;pattern&lt;/var&gt; , вводя новые привязки переменных, которые затем могут использоваться внутри &lt;var&gt;body&lt;/var&gt; . Привязки переменных производятся путем деструктурирования привязки элементов &lt;var&gt;pattern&lt;/var&gt; к значениям соответствующих элементов оцениваемого &lt;var&gt;exp&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="aa4b6e4b0a07d4d70f84e83caad6fff48d32fad3" translate="yes" xml:space="preserve">
          <source>All Emacs Lisp arrays are one-dimensional. (Most other programming languages support multidimensional arrays, but they are not essential; you can get the same effect with nested one-dimensional arrays.) Each type of array has its own read syntax; see the following sections for details.</source>
          <target state="translated">Все массивы Emacs Lisp одномерны.(Большинство других языков программирования поддерживают многомерные массивы,но они не являются существенными;такой же эффект можно получить и со вложенными одномерными массивами).Каждый тип массива имеет свой читаемый синтаксис;подробнее об этом читайте в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="78dab1ef3770dfe21362526370a14bdcd828cdca" translate="yes" xml:space="preserve">
          <source>All arguments are instrumented for evaluation.</source>
          <target state="translated">Все аргументы охарактеризованы для оценки.</target>
        </trans-unit>
        <trans-unit id="b6a1d847b868b0a62fa982b38796821b2fb0c23f" translate="yes" xml:space="preserve">
          <source>All arguments are numbers. Floating-point arguments can be tricky, because floating-point arithmetic is inexact. For instance, depending on the machine, it may quite well happen that &lt;code&gt;(number-sequence 0.4 0.6 0.2)&lt;/code&gt; returns the one element list &lt;code&gt;(0.4)&lt;/code&gt;, whereas &lt;code&gt;(number-sequence 0.4 0.8 0.2)&lt;/code&gt; returns a list with three elements. The &lt;var&gt;n&lt;/var&gt;th element of the list is computed by the exact formula &lt;code&gt;(+ &lt;var&gt;from&lt;/var&gt; (* &lt;var&gt;n&lt;/var&gt; &lt;var&gt;separation&lt;/var&gt;))&lt;/code&gt;. Thus, if one wants to make sure that &lt;var&gt;to&lt;/var&gt; is included in the list, one can pass an expression of this exact type for &lt;var&gt;to&lt;/var&gt;. Alternatively, one can replace &lt;var&gt;to&lt;/var&gt; with a slightly larger value (or a slightly more negative value if &lt;var&gt;separation&lt;/var&gt; is negative).</source>
          <target state="translated">Все аргументы - числа. Аргументы с плавающей запятой могут быть сложными, потому что арифметика с плавающей запятой неточна. Например, в зависимости от машины, вполне может случиться, что &lt;code&gt;(number-sequence 0.4 0.6 0.2)&lt;/code&gt; вернет список из одного элемента &lt;code&gt;(0.4)&lt;/code&gt; , тогда как &lt;code&gt;(number-sequence 0.4 0.8 0.2)&lt;/code&gt; вернет список из трех элементов. &lt;var&gt;n&lt;/var&gt; - й элемент списка вычисляется по точной формуле &lt;code&gt;(+ &lt;var&gt;from&lt;/var&gt; (* &lt;var&gt;n&lt;/var&gt; &lt;var&gt;separation&lt;/var&gt;))&lt;/code&gt; . Таким образом, если кто-то хочет убедиться, что &lt;var&gt;to&lt;/var&gt; включен в список, можно передать выражение этого точного типа для &lt;var&gt;to&lt;/var&gt; . В качестве альтернативы можно заменить &lt;var&gt;to&lt;/var&gt; с немного большим значением (или немного более отрицательным значением, если &lt;var&gt;separation&lt;/var&gt; отрицательное).</target>
        </trans-unit>
        <trans-unit id="2208c34161ce80d7a782807d1e4cec6e6a7dd001" translate="yes" xml:space="preserve">
          <source>All breakpoints in a definition are forgotten each time you reinstrument it. If you wish to make a breakpoint that won&amp;rsquo;t be forgotten, you can write a &lt;em&gt;source breakpoint&lt;/em&gt;, which is simply a call to the function &lt;code&gt;edebug&lt;/code&gt; in your source code. You can, of course, make such a call conditional. For example, in the &lt;code&gt;fac&lt;/code&gt; function, you can insert the first line as shown below, to stop when the argument reaches zero:</source>
          <target state="translated">Все точки останова в определении забываются каждый раз, когда вы его заново настраиваете. Если вы хотите создать точку останова, которая не будет забыта, вы можете написать &lt;em&gt;исходную &lt;/em&gt; &lt;code&gt;edebug&lt;/code&gt; &lt;em&gt;останова&lt;/em&gt; , которая представляет собой просто вызов функции edebug в исходном коде. Вы, конечно, можете сделать такой вызов условным. Например, в функции &lt;code&gt;fac&lt;/code&gt; вы можете вставить первую строку, как показано ниже, чтобы остановиться, когда аргумент достигнет нуля:</target>
        </trans-unit>
        <trans-unit id="9bb2b7fe1708d34d491b12dd030e589c31b4ac12" translate="yes" xml:space="preserve">
          <source>All built-in functions do check the types of their actual arguments when appropriate, and signal a &lt;code&gt;wrong-type-argument&lt;/code&gt; error if an argument is of the wrong type. For example, here is what happens if you pass an argument to &lt;code&gt;+&lt;/code&gt; that it cannot handle:</source>
          <target state="translated">Все встроенные функции при необходимости проверяют типы своих фактических аргументов и сигнализируют об &lt;code&gt;wrong-type-argument&lt;/code&gt; если аргумент имеет неправильный тип. Например, вот что произойдет, если вы передадите аргумент &lt;code&gt;+&lt;/code&gt; , который он не может обработать:</target>
        </trans-unit>
        <trans-unit id="0a8b2cb5ecd2f67ffd2840d4654471062074ad24" translate="yes" xml:space="preserve">
          <source>All buttons have a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;button&lt;/code&gt; property, which may be useful in finding regions of text that comprise buttons (which is what the standard button functions do).</source>
          <target state="translated">Все кнопки имеют не- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;button&lt;/code&gt; свойства, которое может быть полезным в поиске областей текста , которые содержат кнопки (что стандартные функции кнопок делают).</target>
        </trans-unit>
        <trans-unit id="0de9e1669bff9ffa03c0a6b06c8fc7f25b299da9" translate="yes" xml:space="preserve">
          <source>All command loops, including recursive ones, set up all-purpose error handlers so that an error in a command run from the command loop will not exit the loop.</source>
          <target state="translated">Все циклы команд,в том числе и рекурсивные,настраивают универсальные обработчики ошибок таким образом,чтобы ошибка в команде,запущенной из командного цикла,не выходила из цикла.</target>
        </trans-unit>
        <trans-unit id="2bf532e176c9ef15e8a341ec22d44645c0ae9a2a" translate="yes" xml:space="preserve">
          <source>All connection-local variables, which are specified by &lt;code&gt;default-directory&lt;/code&gt;, are applied.</source>
          <target state="translated">Применяются все локальные переменные соединения, указанные в &lt;code&gt;default-directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f6062bb49c083289ef91ea0670a9dad56b4214" translate="yes" xml:space="preserve">
          <source>All customization types are implemented as widgets; see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</source>
          <target state="translated">Все типы настроек реализованы в виде виджетов; см. &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Введение&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="dca342b020ceabede3de91c0d8473d75e1b019c2" translate="yes" xml:space="preserve">
          <source>All following elements in the specification list are optional; as soon as one does not match, Edebug stops matching at this level.</source>
          <target state="translated">Все следующие элементы в списке спецификаций являются необязательными;как только один из них не совпадает,Edebug останавливает совпадение на этом уровне.</target>
        </trans-unit>
        <trans-unit id="2c01d7a4983336c611392d0fc00fd2b83de2bc6d" translate="yes" xml:space="preserve">
          <source>All following elements in the specification list are repeated zero or more times. In the last repetition, however, it is not a problem if the expression runs out before matching all of the elements of the specification list.</source>
          <target state="translated">Все следующие элементы в списке спецификаций повторяются нолью или более раз.Однако при последнем повторении не возникает проблем,если выражение заканчивается до совпадения всех элементов спецификационного списка.</target>
        </trans-unit>
        <trans-unit id="25b37db993c79b5143fd020bfa5984f4943de615" translate="yes" xml:space="preserve">
          <source>All four kinds of array share these characteristics:</source>
          <target state="translated">Все четыре типа массивов имеют эти характеристики:</target>
        </trans-unit>
        <trans-unit id="b65738468b638316e78cf6dcd55faa5077ce8a18" translate="yes" xml:space="preserve">
          <source>All functions defined in this library are free of side-effects; i.e., they do not modify any sequence (list, vector, or string) that you pass as an argument. Unless otherwise stated, the result is a sequence of the same type as the input. For those functions that take a predicate, this should be a function of one argument.</source>
          <target state="translated">Все функции,определенные в этой библиотеке,не имеют побочных эффектов,т.е.не изменяют какую-либо последовательность (список,вектор или строку),которую вы передаете в качестве аргумента.Если не указано иное,результатом является последовательность того же типа,что и входной.Для тех функций,которые принимают предикат,это должна быть функция одного аргумента.</target>
        </trans-unit>
        <trans-unit id="c71e30856d625975a83aead946dd7f4e5c8c274a" translate="yes" xml:space="preserve">
          <source>All functions that create markers without accepting an argument that specifies the insertion type, create them with insertion type &lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;creating-markers#Creating-Markers&quot;&gt;Creating Markers&lt;/a&gt;). Also, the mark has, by default, insertion type &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Все функции, которые создают маркеры, не принимая аргумент, определяющий тип вставки, создают их с типом вставки &lt;code&gt;nil&lt;/code&gt; (см. &lt;a href=&quot;creating-markers#Creating-Markers&quot;&gt;Создание маркеров&lt;/a&gt; ). Кроме того, метка по умолчанию имеет тип вставки &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e5df34fc50a10cee1104c398dc0d288148f5677" translate="yes" xml:space="preserve">
          <source>All numbers can be compared with &lt;code&gt;eql&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt;; fixnums can also be compared with &lt;code&gt;eq&lt;/code&gt;. To test whether an integer is a fixnum or a bignum, you can compare it to &lt;code&gt;most-negative-fixnum&lt;/code&gt; and &lt;code&gt;most-positive-fixnum&lt;/code&gt;, or you can use the convenience predicates &lt;code&gt;fixnump&lt;/code&gt; and &lt;code&gt;bignump&lt;/code&gt; on any object.</source>
          <target state="translated">Все числа можно сравнить с помощью &lt;code&gt;eql&lt;/code&gt; или &lt;code&gt;=&lt;/code&gt; ; fixnums также можно сравнить с &lt;code&gt;eq&lt;/code&gt; . Чтобы проверить, является ли целое число fixnum или bignum, вы можете сравнить его с &lt;code&gt;most-negative-fixnum&lt;/code&gt; и &lt;code&gt;most-positive-fixnum&lt;/code&gt; , или вы можете использовать удобные предикаты &lt;code&gt;fixnump&lt;/code&gt; и &lt;code&gt;bignump&lt;/code&gt; для любого объекта.</target>
        </trans-unit>
        <trans-unit id="c2c85ce8bd7457b271669cf5c05e295e1385ce6f" translate="yes" xml:space="preserve">
          <source>All of the &lt;var&gt;value-form&lt;/var&gt;s in &lt;var&gt;bindings&lt;/var&gt; are evaluated in the order they appear and &lt;em&gt;before&lt;/em&gt; binding any of the symbols to them. Here is an example of this: &lt;code&gt;z&lt;/code&gt; is bound to the old value of &lt;code&gt;y&lt;/code&gt;, which is 2, not the new value of &lt;code&gt;y&lt;/code&gt;, which is 1.</source>
          <target state="translated">Все &lt;var&gt;value-form&lt;/var&gt; в &lt;var&gt;bindings&lt;/var&gt; оцениваются в том порядке, в котором они появляются, и &lt;em&gt;до&lt;/em&gt; привязки к ним любого из символов. Вот пример этого: &lt;code&gt;z&lt;/code&gt; привязан к старому значению &lt;code&gt;y&lt;/code&gt; , равному 2, а не к новому значению &lt;code&gt;y&lt;/code&gt; , равному 1.</target>
        </trans-unit>
        <trans-unit id="cb57c7da298437e1c1c392f0acf73eba41691d75" translate="yes" xml:space="preserve">
          <source>All of the deletion functions operate on the current buffer.</source>
          <target state="translated">Все функции удаления работают на текущем буфере.</target>
        </trans-unit>
        <trans-unit id="af4a5a5cd065f9f5dbe42b33024e60fb527b8391" translate="yes" xml:space="preserve">
          <source>All of the functions described below are actually &lt;em&gt;function pointers&lt;/em&gt; provided via the pointer to the environment which every module function accepts. Therefore, module code should call these functions through the environment pointer, like this:</source>
          <target state="translated">Все функции, описанные ниже, на самом деле являются &lt;em&gt;указателями на функции,&lt;/em&gt; предоставляемыми через указатель на среду, которую принимает каждая функция модуля. Следовательно, код модуля должен вызывать эти функции через указатель среды, например:</target>
        </trans-unit>
        <trans-unit id="2486aadd4696b33394cf13a628e5e81f8336dc69" translate="yes" xml:space="preserve">
          <source>All of these keywords, except &lt;code&gt;:tag&lt;/code&gt;, can be used more than once in a given item. Each use of the keyword has an independent effect. The keyword &lt;code&gt;:tag&lt;/code&gt; is an exception because any given item can only display one name.</source>
          <target state="translated">Все эти ключевые слова, кроме &lt;code&gt;:tag&lt;/code&gt; , могут использоваться более одного раза в данном элементе. Каждое использование ключевого слова имеет независимый эффект. &lt;code&gt;:tag&lt;/code&gt; keyword : является исключением, потому что любой заданный элемент может отображать только одно имя.</target>
        </trans-unit>
        <trans-unit id="7c58a8aa90e29eb8cc586744cbf0bae2b76d1c9b" translate="yes" xml:space="preserve">
          <source>All the Emacs primitives for file access and file name transformation check the given file name against &lt;code&gt;file-name-handler-alist&lt;/code&gt;. If the file name matches &lt;var&gt;regexp&lt;/var&gt;, the primitives handle that file by calling &lt;var&gt;handler&lt;/var&gt;.</source>
          <target state="translated">Все примитивы Emacs для доступа к файлам и преобразования имени файла проверяют данное имя &lt;code&gt;file-name-handler-alist&lt;/code&gt; имен файлов . Если имя файла совпадает с &lt;var&gt;regexp&lt;/var&gt; , примитивы обрабатывают этот файл, вызывая &lt;var&gt;handler&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="9a0d1e07e928a09c5cfab793d66c3b83e32a68e0" translate="yes" xml:space="preserve">
          <source>All the buffer properties that are related to the buffer text are swapped as well: the positions of point and mark, all the markers, the overlays, the text properties, the undo list, the value of the &lt;code&gt;enable-multibyte-characters&lt;/code&gt; flag (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;enable-multibyte-characters&lt;/a&gt;), etc.</source>
          <target state="translated">Все свойства буфера, относящиеся к тексту буфера, также меняются местами: позиции точки и метки, все маркеры, наложения, свойства текста, список отмены, значение флага &lt;code&gt;enable-multibyte-characters&lt;/code&gt; (см. &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;enable-multibyte-characters&lt;/a&gt; ) и т. д.</target>
        </trans-unit>
        <trans-unit id="41d1c4b0b8ba4df658a7d43aad707edd6505e753" translate="yes" xml:space="preserve">
          <source>All the directories in the file system form a tree starting at the root directory. A file name can specify all the directory names starting from the root of the tree; then it is called an &lt;em&gt;absolute&lt;/em&gt; file name. Or it can specify the position of the file in the tree relative to a default directory; then it is called a &lt;em&gt;relative&lt;/em&gt; file name. On GNU and other POSIX-like systems, after any leading &amp;lsquo;</source>
          <target state="translated">Все каталоги файловой системы образуют дерево, начинающееся с корневого каталога. Имя файла может указывать все имена каталогов, начиная с корня дерева; тогда это называется &lt;em&gt;абсолютным&lt;/em&gt; именем файла. Или он может указать положение файла в дереве относительно каталога по умолчанию; тогда это называется &lt;em&gt;относительным&lt;/em&gt; именем файла. В GNU и других системах, подобных POSIX, после любого ведущего символа '</target>
        </trans-unit>
        <trans-unit id="6d03c2077a45424604dd5945928dd7d581573444" translate="yes" xml:space="preserve">
          <source>All the flags except &amp;lsquo;</source>
          <target state="translated">Все флаги, кроме '</target>
        </trans-unit>
        <trans-unit id="1fa32ceee23a50f9250c28b0af70936b4c7fea6b" translate="yes" xml:space="preserve">
          <source>All the following functions take an optional list of keyword parameters that alter the various attributes from their default values. Valid attributes include:</source>
          <target state="translated">Все следующие функции берут опциональный список параметров ключевых слов,которые изменяют различные атрибуты от их значений по умолчанию.К достоверным атрибутам относятся:</target>
        </trans-unit>
        <trans-unit id="fd4e3414635a6335aabdd75003f817dd7df606f1" translate="yes" xml:space="preserve">
          <source>All the operations that transfer text in and out of Emacs have the ability to use a coding system to encode or decode the text. You can also explicitly encode and decode text using the functions in this section.</source>
          <target state="translated">Все операции по передаче текста в Emacs и из Emacs имеют возможность использовать систему кодирования для кодирования или декодирования текста.Вы также можете явно кодировать и декодировать текст,используя функции,описанные в этом разделе.</target>
        </trans-unit>
        <trans-unit id="3d0ec5a014b164fea677713adc2d6869587a38a2" translate="yes" xml:space="preserve">
          <source>All the remaining elements (if any) are collectively called &lt;var&gt;other-vars&lt;/var&gt;. Each of these elements should have the form &lt;code&gt;(&lt;var&gt;variable&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;&amp;mdash;which means, make &lt;var&gt;variable&lt;/var&gt; buffer-local and then set it to &lt;var&gt;value&lt;/var&gt;. You can use these &lt;var&gt;other-vars&lt;/var&gt; to set other variables that affect fontification, aside from those you can control with the first five elements. See &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">Все остальные элементы (если есть) собирательно называются &lt;var&gt;other-vars&lt;/var&gt; . Каждый из этих элементов должен иметь форму &lt;code&gt;(&lt;var&gt;variable&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; , то есть сделать &lt;var&gt;variable&lt;/var&gt; локальной для буфера и затем установить для нее &lt;var&gt;value&lt;/var&gt; . Вы можете использовать эти &lt;var&gt;other-vars&lt;/var&gt; для установки других переменных, влияющих на фонтификацию, помимо тех, которыми вы можете управлять с помощью первых пяти элементов. См. &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Другие переменные блокировки шрифта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eef34056c9664b484982e4f51615ce7ab9a41812" translate="yes" xml:space="preserve">
          <source>All the specification characters allow an optional &lt;em&gt;precision&lt;/em&gt; after the field number, flags and width, if present. The precision is a decimal-point &amp;lsquo;</source>
          <target state="translated">Все символы спецификации допускают необязательную &lt;em&gt;точность&lt;/em&gt; после номера поля, флагов и ширины, если они есть. Точность - десятичная точка '</target>
        </trans-unit>
        <trans-unit id="ca4ef7026f0627fed1dbae0beb181539bc4f6f15" translate="yes" xml:space="preserve">
          <source>All the usual rules for documentation strings in Lisp code (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Documentation Tips&lt;/a&gt;) apply to C code documentation strings too.</source>
          <target state="translated">All the usual rules for documentation strings in Lisp code (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Documentation Tips&lt;/a&gt;) apply to C code documentation strings too.</target>
        </trans-unit>
        <trans-unit id="58d526aa213005ab745d03bed480a0d5feb42ba3" translate="yes" xml:space="preserve">
          <source>All three of the subprocess-creating functions allow to specify command-line arguments for the process to run. For &lt;code&gt;call-process&lt;/code&gt; and &lt;code&gt;call-process-region&lt;/code&gt;, these come in the form of a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, &lt;var&gt;args&lt;/var&gt;. For &lt;code&gt;make-process&lt;/code&gt;, both the program to run and its command-line arguments are specified as a list of strings. The command-line arguments must all be strings, and they are supplied to the program as separate argument strings. Wildcard characters and other shell constructs have no special meanings in these strings, since the strings are passed directly to the specified program.</source>
          <target state="translated">Все три функции создания подпроцесса позволяют указать аргументы командной строки для запуска процесса. Для &lt;code&gt;call-process&lt;/code&gt; и &lt;code&gt;call-process-region&lt;/code&gt; они имеют форму аргумента &lt;code&gt;&amp;amp;rest&lt;/code&gt; , &lt;var&gt;args&lt;/var&gt; . Для &lt;code&gt;make-process&lt;/code&gt; и программа, которую нужно запустить, и ее аргументы командной строки указываются в виде списка строк. Все аргументы командной строки должны быть строками, и они предоставляются программе как отдельные строки аргументов. Подстановочные знаки и другие конструкции оболочки не имеют особого значения в этих строках, поскольку строки передаются непосредственно в указанную программу.</target>
        </trans-unit>
        <trans-unit id="0dd2c1f56aad50efd70754bd7b0f1448e6dee489" translate="yes" xml:space="preserve">
          <source>All you need to do is add a &lt;code&gt;declare-function&lt;/code&gt; statement before the first use of the function in question:</source>
          <target state="translated">Все, что вам нужно сделать, это добавить оператор &lt;code&gt;declare-function&lt;/code&gt; перед первым использованием рассматриваемой функции:</target>
        </trans-unit>
        <trans-unit id="83a5fc8fd0c6232ad2485feb2941be6df4658ce5" translate="yes" xml:space="preserve">
          <source>Allow &lt;var&gt;command&lt;/var&gt; (a symbol) to be executed without special confirmation from now on, and alter the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) so that this will apply to future sessions.</source>
          <target state="translated">С этого момента разрешите выполнение &lt;var&gt;command&lt;/var&gt; (символа) без специального подтверждения и измените файл инициализации пользователя (см. &lt;a href=&quot;init-file#Init-File&quot;&gt;Файл&lt;/a&gt; инициализации ), чтобы это применимо к будущим сеансам.</target>
        </trans-unit>
        <trans-unit id="fbe56df0c14a0941bf2865207a4eec4975a429b2" translate="yes" xml:space="preserve">
          <source>Almost all the messages displayed in the echo area are also recorded in the</source>
          <target state="translated">Почти все сообщения,отображаемые в эхо-зоне,также записываются в файл</target>
        </trans-unit>
        <trans-unit id="0a6cdeb0d1c09e0504231be0c620803ea8ce80be" translate="yes" xml:space="preserve">
          <source>Along with the mandatory &lt;code&gt;:request-dispatcher&lt;/code&gt; and &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs, users of the &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; class should pass the following initargs as keyword-value pairs to &lt;code&gt;make-instance&lt;/code&gt;:</source>
          <target state="translated">Наряду с обязательными аргументами initargs &lt;code&gt;:request-dispatcher&lt;/code&gt; и &lt;code&gt;:notification-dispatcher&lt;/code&gt; , пользователи класса &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; должны передавать следующие аргументы инициализации как пары ключевое слово-значение в &lt;code&gt;make-instance&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="986ce8469a3d5002d455b0f41722b9928e133cc8" translate="yes" xml:space="preserve">
          <source>Alphabetical sorting means that two sort keys are compared by comparing the first characters of each, the second characters of each, and so on. If a mismatch is found, it means that the sort keys are unequal; the sort key whose character is less at the point of first mismatch is the lesser sort key. The individual characters are compared according to their numerical character codes in the Emacs character set.</source>
          <target state="translated">Алфавитная сортировка означает,что две клавиши сортировки сравниваются путем сравнения первых символов каждого из них,вторых символов каждого из них и так далее.Если обнаружено несовпадение,это означает,что ключи сортировки неравны;ключ сортировки,чей символ меньше в точке первого несовпадения,является меньшим ключом сортировки.Сравнение отдельных символов производится в соответствии с их числовыми символьными кодами в наборе символов Emacs.</target>
        </trans-unit>
        <trans-unit id="3397c8f08539eaf212b8a514976581cd47575863" translate="yes" xml:space="preserve">
          <source>Also by convention, the &lt;small&gt;CDR&lt;/small&gt; of the last cons cell in a list is &lt;code&gt;nil&lt;/code&gt;. We call such a &lt;code&gt;nil&lt;/code&gt;-terminated structure a &lt;em&gt;proper list&lt;/em&gt;&lt;a href=&quot;#FOOT3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;. In Emacs Lisp, the symbol &lt;code&gt;nil&lt;/code&gt; is both a symbol and a list with no elements. For convenience, the symbol &lt;code&gt;nil&lt;/code&gt; is considered to have &lt;code&gt;nil&lt;/code&gt; as its &lt;small&gt;CDR&lt;/small&gt; (and also as its &lt;small&gt;CAR&lt;/small&gt;).</source>
          <target state="translated">Также по соглашению &lt;small&gt;CDR&lt;/small&gt; последней cons-ячейки в списке равен &lt;code&gt;nil&lt;/code&gt; . Мы называем такую ​​структуру с &lt;code&gt;nil&lt;/code&gt; окончанием &lt;em&gt;правильным списком &lt;/em&gt;&lt;a href=&quot;#FOOT3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; . В Emacs Lisp символ &lt;code&gt;nil&lt;/code&gt; является одновременно символом и списком без элементов. Для удобства считается , что символ &lt;code&gt;nil&lt;/code&gt; имеет значение &lt;code&gt;nil&lt;/code&gt; в качестве &lt;small&gt;CDR&lt;/small&gt; (а также в качестве &lt;small&gt;CAR&lt;/small&gt; ).</target>
        </trans-unit>
        <trans-unit id="fff39e0b11dcde645d91107c5004ab17b6696524" translate="yes" xml:space="preserve">
          <source>Also note that this variable is not meant to be a generic facility for accessing external libraries; only those already known by Emacs can be loaded through it.</source>
          <target state="translated">Также обратите внимание,что эта переменная не предназначена для общего доступа к внешним библиотекам;через нее могут быть загружены только те,которые уже известны Emacs.</target>
        </trans-unit>
        <trans-unit id="b0218093aabf50731b0dfd5f6bc99d6da5f04d9a" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;edebug-tracing&lt;/code&gt;, in &lt;a href=&quot;trace-buffer#Trace-Buffer&quot;&gt;Trace Buffer&lt;/a&gt;.</source>
          <target state="translated">См. Также &lt;code&gt;edebug-tracing&lt;/code&gt; в &lt;a href=&quot;trace-buffer#Trace-Buffer&quot;&gt;буфере трассировки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d0d7b652d689c605bbb8e508dce118b76e3835d" translate="yes" xml:space="preserve">
          <source>Also see the following function.</source>
          <target state="translated">См.также следующую функцию.</target>
        </trans-unit>
        <trans-unit id="f91d8e06c0823bced203ecdc95d5ffb09f2dca97" translate="yes" xml:space="preserve">
          <source>Also see the functions &lt;code&gt;bolp&lt;/code&gt; and &lt;code&gt;eolp&lt;/code&gt; in &lt;a href=&quot;near-point#Near-Point&quot;&gt;Near Point&lt;/a&gt;. These functions do not move point, but test whether it is already at the beginning or end of a line.</source>
          <target state="translated">Также см. Функции &lt;code&gt;bolp&lt;/code&gt; и &lt;code&gt;eolp&lt;/code&gt; в &lt;a href=&quot;near-point#Near-Point&quot;&gt;Near Point&lt;/a&gt; . Эти функции не перемещают точку, а проверяют, находится ли она уже в начале или в конце строки.</target>
        </trans-unit>
        <trans-unit id="1c151f9dd941153aa652ba089e31237c83748274" translate="yes" xml:space="preserve">
          <source>Also, if &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, this function does not delete any window whose &lt;code&gt;no-delete-other-windows&lt;/code&gt; parameter is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Кроме того, если &lt;code&gt;ignore-window-parameters&lt;/code&gt; равно &lt;code&gt;nil&lt;/code&gt; , эта функция не удаляет ни одно окно, чей параметр &lt;code&gt;no-delete-other-windows&lt;/code&gt; не равен &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7732936fed3ff7cd50aeba214305d9cb5cc02021" translate="yes" xml:space="preserve">
          <source>Also, inline functions do not behave well with respect to debugging, tracing, and advising (see &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;). Since ease of debugging and the flexibility of redefining functions are important features of Emacs, you should not make a function inline, even if it&amp;rsquo;s small, unless its speed is really crucial, and you&amp;rsquo;ve timed the code to verify that using &lt;code&gt;defun&lt;/code&gt; actually has performance problems.</source>
          <target state="translated">Кроме того, встроенные функции плохо себя ведут в отношении отладки, трассировки и рекомендаций (см. &amp;laquo; &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Функции-рекомендации&amp;raquo;&lt;/a&gt; ). Поскольку простота отладки и гибкость переопределения функций являются важными особенностями Emacs, вам не следует делать функцию встроенной, даже если она небольшая, если только ее скорость не является действительно важной, и вы рассчитали код, чтобы убедиться, что использование &lt;code&gt;defun&lt;/code&gt; действительно имеет проблемы с производительностью.</target>
        </trans-unit>
        <trans-unit id="3a284929ebe4ecbc4627599844c16f8ee2075a18" translate="yes" xml:space="preserve">
          <source>Also, this variable is bound to non-&lt;code&gt;nil&lt;/code&gt; while running those same hook variables, so that by default modifying the buffer from a modification hook does not cause other modification hooks to be run. If you do want modification hooks to be run in a particular piece of code that is itself run from a modification hook, then rebind locally &lt;code&gt;inhibit-modification-hooks&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;. However, doing this may cause recursive calls to the modification hooks, so be sure to prepare for that (for example, by binding some variable which tells your hook to do nothing).</source>
          <target state="translated">Кроме того, эта переменная связана с &lt;code&gt;nil&lt;/code&gt; при запуске тех же переменных ловушки, так что по умолчанию изменение буфера из ловушки модификации не вызывает запуск других ловушек модификации. Если вы действительно хотите, чтобы обработчики модификации запускались в конкретном фрагменте кода, который сам запускается из обработчика модификации, то повторно привяжите локально обработчики &lt;code&gt;inhibit-modification-hooks&lt;/code&gt; к &lt;code&gt;nil&lt;/code&gt; . Однако выполнение этого может вызвать рекурсивные вызовы хуков модификации, поэтому обязательно подготовьтесь к этому (например, привязав некоторую переменную, которая сообщает вашему хуку ничего не делать).</target>
        </trans-unit>
        <trans-unit id="e30eff925100b7c3e119ed678e39009e962455b0" translate="yes" xml:space="preserve">
          <source>Alt</source>
          <target state="translated">Alt</target>
        </trans-unit>
        <trans-unit id="a5a07d26b576b4c962f39501eaa335d2542ec41a" translate="yes" xml:space="preserve">
          <source>Alt-Hyper-Meta-x</source>
          <target state="translated">Alt-Hyper-Meta-x</target>
        </trans-unit>
        <trans-unit id="ce59e9b5171b68822f40796bb3f0c52339cf67a2" translate="yes" xml:space="preserve">
          <source>Alt-TAB</source>
          <target state="translated">Alt-TAB</target>
        </trans-unit>
        <trans-unit id="3569cde666bf1d56550417379b59c63f9186f81c" translate="yes" xml:space="preserve">
          <source>Altering List Elements with setcar</source>
          <target state="translated">Элементы меняющегося списка с сетчаркой</target>
        </trans-unit>
        <trans-unit id="c23b06af6029fc510471e91f93630d6b95133fec" translate="yes" xml:space="preserve">
          <source>Altering the CDR of a List</source>
          <target state="translated">Изменение CDR списка</target>
        </trans-unit>
        <trans-unit id="32b911a69c85aa2eed0e0429593ee1d599f1648f" translate="yes" xml:space="preserve">
          <source>Altering the contents of an existing string.</source>
          <target state="translated">Изменение содержимого существующей строки.</target>
        </trans-unit>
        <trans-unit id="03e916d44308e382702efa38414c976b82eebcbb" translate="yes" xml:space="preserve">
          <source>Alternative foreground color, a string. This is like &lt;code&gt;:foreground&lt;/code&gt; but the color is only used as a foreground when the background color is near to the foreground that would have been used. This is useful for example when marking text (i.e., the region face). If the text has a foreground that is visible with the region face, that foreground is used. If the foreground is near the region face background, &lt;code&gt;:distant-foreground&lt;/code&gt; is used instead so the text is readable.</source>
          <target state="translated">Альтернативный цвет переднего плана - строка. Это похоже на &lt;code&gt;:foreground&lt;/code&gt; но цвет используется как передний план только тогда, когда цвет фона близок к переднему плану, который мог бы использоваться. Это полезно, например, при маркировке текста (например, лица области). Если текст имеет передний план, который виден лицевой стороной области, используется этот передний план. Если передний план находится рядом с фоном лица области, вместо этого используется &lt;code&gt;:distant-foreground&lt;/code&gt; , чтобы текст был читабельным.</target>
        </trans-unit>
        <trans-unit id="b201fde3a76a13fb565d2139c2505d62747c3f3d" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;var&gt;menu&lt;/var&gt; can have the following form:</source>
          <target state="translated">Как вариант, &lt;var&gt;menu&lt;/var&gt; может иметь следующий вид:</target>
        </trans-unit>
        <trans-unit id="612d416a8c5c9032e5eee36eda3e173bd67f6d8e" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item can be a list with the same format as &lt;var&gt;menu&lt;/var&gt;. This is a submenu.</source>
          <target state="translated">В качестве альтернативы, пункт меню может быть списком того же формата, что и &lt;var&gt;menu&lt;/var&gt; . Это подменю.</target>
        </trans-unit>
        <trans-unit id="0f3215559a2b65437e72958763c4ad5ae7956797" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item can be a string. Then that string appears in the menu as unselectable text. A string consisting of dashes is displayed as a separator (see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;).</source>
          <target state="translated">Как вариант, пункт меню может быть строкой. Затем эта строка появляется в меню в виде невыбираемого текста. Строка, состоящая из дефисов, отображается как разделитель (см. &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Разделители меню&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f86166f09a2fa545f30584a0fa07bc98a8228018" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item may have the form:</source>
          <target state="translated">В качестве альтернативы пункт меню может иметь форму:</target>
        </trans-unit>
        <trans-unit id="2a475682f68cc8d5942ac33225fa6641ddb131e3" translate="yes" xml:space="preserve">
          <source>Alternatively, an &lt;code&gt;interactive&lt;/code&gt; form may be specified in a function symbol&amp;rsquo;s &lt;code&gt;interactive-form&lt;/code&gt; property. A non-&lt;code&gt;nil&lt;/code&gt; value for this property takes precedence over any &lt;code&gt;interactive&lt;/code&gt; form in the function body itself. This feature is seldom used.</source>
          <target state="translated">В качестве альтернативы &lt;code&gt;interactive&lt;/code&gt; форма может быть указана в свойстве &lt;code&gt;interactive-form&lt;/code&gt; функционального символа . Не - &lt;code&gt;nil&lt;/code&gt; значение этого свойства имеет приоритет над любой &lt;code&gt;interactive&lt;/code&gt; формой в самом теле функции. Эта функция используется редко.</target>
        </trans-unit>
        <trans-unit id="70290e19eb34b55b8e6acff0975f8bd70f0b8116" translate="yes" xml:space="preserve">
          <source>Alternatively, the problems sketched above can be avoided by always resizing all windows in the same combination whenever one of its windows is split or deleted. This also permits splitting windows that would be otherwise too small for such an operation.</source>
          <target state="translated">Кроме того,проблем,описанных выше,можно избежать,если всегда изменять размер всех окон в одной комбинации,когда одно из окон разбивается или удаляется.Это также позволяет разбивать окна,которые в противном случае были бы слишком малы для такой операции.</target>
        </trans-unit>
        <trans-unit id="b26670ac06db641e3e84463f0ad2daa068f83654" translate="yes" xml:space="preserve">
          <source>Alternatively, the value can specify the bitmap directly, with a list of the form &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; specify the size in pixels, and &lt;var&gt;data&lt;/var&gt; is a string containing the raw bits of the bitmap, row by row. Each row occupies &lt;em&gt;(&lt;var&gt;width&lt;/var&gt; + 7) / 8&lt;/em&gt; consecutive bytes in the string (which should be a unibyte string for best results). This means that each row always occupies at least one whole byte.</source>
          <target state="translated">В качестве альтернативы значение может указывать растровое изображение напрямую со списком формы &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; . Здесь &lt;var&gt;width&lt;/var&gt; и &lt;var&gt;height&lt;/var&gt; определяют размер в пикселях, а &lt;var&gt;data&lt;/var&gt; представляют собой строку, содержащую необработанные биты растрового изображения, строка за строкой. Каждая строка занимает &lt;em&gt;( &lt;var&gt;width&lt;/var&gt; + 7) / 8&lt;/em&gt; последовательных байтов в строке (которая должна быть однобайтовой строкой для наилучших результатов). Это означает, что каждая строка всегда занимает не менее одного целого байта.</target>
        </trans-unit>
        <trans-unit id="3fffa4436d30acad881ee763e3e490d5b00c5e0b" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use the &lt;code&gt;with-current-buffer&lt;/code&gt; macro:</source>
          <target state="translated">В качестве альтернативы мы можем использовать макрос &lt;code&gt;with-current-buffer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b512dedf489786abd4f584013029d9c643312107" translate="yes" xml:space="preserve">
          <source>Alternatively, you can define a function by providing the code which will inline it as a compiler macro. The following macros make this possible.</source>
          <target state="translated">В качестве альтернативы можно определить функцию,предоставив код,который вставит ее в качестве макроса компилятора.Следующие макросы делают это возможным.</target>
        </trans-unit>
        <trans-unit id="a6177cf1ed61859e6ad146c7a2e9af66ea184b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can set &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; to &lt;code&gt;nil&lt;/code&gt;. In that case, the progress reporter does not report process percentages; it instead displays a &amp;ldquo;spinner&amp;rdquo; that rotates a notch each time you update the progress reporter.</source>
          <target state="translated">Кроме того , вы можете установить &lt;var&gt;min-value&lt;/var&gt; и &lt;var&gt;max-value&lt;/var&gt; в &lt;code&gt;nil&lt;/code&gt; . В этом случае отчет о ходе выполнения не сообщает проценты процесса; вместо этого он отображает &amp;laquo;счетчик&amp;raquo;, который поворачивает метку каждый раз, когда вы обновляете отчет о прогрессе.</target>
        </trans-unit>
        <trans-unit id="92226f9d87069cd2db7b3d326f09e83f23a82036" translate="yes" xml:space="preserve">
          <source>Alternatively, you could use the &lt;code&gt;:stderr&lt;/code&gt; parameter with a non-&lt;code&gt;nil&lt;/code&gt; value in a call to &lt;code&gt;make-process&lt;/code&gt; (see &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;make-process&lt;/a&gt;) to make the destination of the error output separate from the standard output; in that case, Emacs will use pipes for communicating with the subprocess.</source>
          <target state="translated">В качестве альтернативы вы можете использовать параметр &lt;code&gt;:stderr&lt;/code&gt; со значением, отличным от &lt;code&gt;nil&lt;/code&gt; , в вызове &lt;code&gt;make-process&lt;/code&gt; (см. &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Make-process&lt;/a&gt; ), чтобы разделить место назначения вывода ошибок от стандартного вывода; в этом случае Emacs будет использовать каналы для связи с подпроцессом.</target>
        </trans-unit>
        <trans-unit id="67171d73924b845a3534e0ecdf7ce358ebf03943" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;(time-convert nil nil)&lt;/code&gt; is equivalent to &lt;code&gt;(current-time)&lt;/code&gt;, the latter may be a bit faster.</source>
          <target state="translated">Хотя &lt;code&gt;(time-convert nil nil)&lt;/code&gt; эквивалентно &lt;code&gt;(current-time)&lt;/code&gt; , последнее может быть немного быстрее.</target>
        </trans-unit>
        <trans-unit id="ada9e95e67f8cc5ff4fdc84a7549ab0fbfa66304" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;redisplay&lt;/code&gt; tries immediately to redisplay, it does not change how Emacs decides which parts of its frame(s) to redisplay. By contrast, the following function adds certain windows to the pending redisplay work (as if their contents had completely changed), but does not immediately try to perform redisplay.</source>
          <target state="translated">Хотя &lt;code&gt;redisplay&lt;/code&gt; пытается немедленно повторно отобразить, это не меняет того, как Emacs решает, какие части его кадра (ов) отображать повторно. В отличие от этого, следующая функция добавляет определенные окна к ожидающей работе повторного отображения (как если бы их содержимое полностью изменилось), но не пытается немедленно выполнить повторное отображение.</target>
        </trans-unit>
        <trans-unit id="1b09322d9e876baf3954f8eeffbc89a79699d7f4" translate="yes" xml:space="preserve">
          <source>Although Emacs normally respects access permissions of the underlying operating system, in some cases it handles accesses specially. For example, file names can have handlers that treat the files specially, with their own access checking. See &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;. Also, a buffer can be read-only even if the corresponding file is writable, and vice versa, which can result in messages such as &amp;lsquo;</source>
          <target state="translated">Хотя Emacs обычно уважает права доступа базовой операционной системы, в некоторых случаях он обрабатывает доступ особым образом. Например, имена файлов могут иметь обработчики, которые обрабатывают файлы особым образом, со своей собственной проверкой доступа. См. &amp;laquo; &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Волшебные имена файлов&amp;raquo;&lt;/a&gt; . Кроме того, буфер может быть доступен только для чтения, даже если соответствующий файл доступен для записи, и наоборот, что может привести к появлению таких сообщений, как '</target>
        </trans-unit>
        <trans-unit id="41aec9e3c0639b5cbc769510aa631eca22825357" translate="yes" xml:space="preserve">
          <source>Although a &amp;lsquo;</source>
          <target state="translated">Хотя</target>
        </trans-unit>
        <trans-unit id="0f3c6c13e12239c0128c12d87359384cf4720010" translate="yes" xml:space="preserve">
          <source>Although a character alternative can include duplicates, it is better style to avoid them. For example, &amp;lsquo;</source>
          <target state="translated">Хотя альтернативный вариант символа может включать дубликаты, лучше избегать их. Например, '</target>
        </trans-unit>
        <trans-unit id="003ff1a62df2fa3817a8fd6c5d1dd5fe04cc547c" translate="yes" xml:space="preserve">
          <source>Although a range can denote just one, two, or three characters, it is simpler to list the characters. For example, &amp;lsquo;</source>
          <target state="translated">Хотя диапазон может обозначать только один, два или три символа, их проще перечислить. Например, '</target>
        </trans-unit>
        <trans-unit id="743be7d85c6dff8ab2c12b47e5caa1355172e2a0" translate="yes" xml:space="preserve">
          <source>Although a range&amp;rsquo;s bound can be almost any character, it is better style to stay within natural sequences of ASCII letters and digits because most people have not memorized character code tables. For example, &amp;lsquo;</source>
          <target state="translated">Хотя границей диапазона может быть почти любой символ, лучше оставаться в пределах естественных последовательностей букв и цифр ASCII, потому что большинство людей не запомнили таблицы кодов символов. Например, '</target>
        </trans-unit>
        <trans-unit id="a6f6b98c4f64609315a55f827d800190bc2958cc" translate="yes" xml:space="preserve">
          <source>Although both sorts of failures can largely be avoided by a suitably configured file system, such systems are typically more expensive or less efficient. In more-typical systems, to survive media failure you can copy the file to a different device, and to survive a power failure you can use the &lt;code&gt;write-region&lt;/code&gt; function with the &lt;code&gt;write-region-inhibit-fsync&lt;/code&gt; variable set to &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;Writing to Files&lt;/a&gt;.</source>
          <target state="translated">Хотя обоих видов сбоев можно в значительной степени избежать с помощью правильно настроенной файловой системы, такие системы обычно более дороги или менее эффективны. В более-типичных системах, чтобы выжить ошибки носителя вы можете скопировать файл на другое устройство, и , чтобы выжить сбой питания можно использовать для &lt;code&gt;write-region&lt;/code&gt; функции с &lt;code&gt;write-region-inhibit-fsync&lt;/code&gt; набора переменного к &lt;code&gt;nil&lt;/code&gt; . См. &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;Запись в файлы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d6a6f038f930d539ab3543bcd22fa56a80436b0" translate="yes" xml:space="preserve">
          <source>Although completion is usually done in the minibuffer, the completion facility can also be used on the text in ordinary Emacs buffers. In many major modes, in-buffer completion is performed by the</source>
          <target state="translated">Хотя завершение обычно выполняется в минибуфере,функция завершения также может быть использована на тексте в обычных Emacs буферах.Во многих основных режимах завершение в буфере выполняется с помощью функции</target>
        </trans-unit>
        <trans-unit id="67fae8b88cdfb0b03098409367fbfcfd4933ca60" translate="yes" xml:space="preserve">
          <source>Although functions are usually defined with &lt;code&gt;defun&lt;/code&gt; and given names at the same time, it is sometimes convenient to use an explicit lambda expression&amp;mdash;an &lt;em&gt;anonymous function&lt;/em&gt;. Anonymous functions are valid wherever function names are. They are often assigned as variable values, or as arguments to functions; for instance, you might pass one as the &lt;var&gt;function&lt;/var&gt; argument to &lt;code&gt;mapcar&lt;/code&gt;, which applies that function to each element of a list (see &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;Mapping Functions&lt;/a&gt;). See &lt;a href=&quot;accessing-documentation#describe_002dsymbols-example&quot;&gt;describe-symbols example&lt;/a&gt;, for a realistic example of this.</source>
          <target state="translated">Хотя функции обычно определяются с помощью &lt;code&gt;defun&lt;/code&gt; и получают имена одновременно, иногда удобно использовать явное лямбда-выражение - &lt;em&gt;анонимную функцию&lt;/em&gt; . Анонимные функции действительны везде, где есть имена функций. Они часто назначаются как значения переменных или как аргументы функций; например, вы можете передать его в качестве аргумента &lt;var&gt;function&lt;/var&gt; &lt;code&gt;mapcar&lt;/code&gt; , который применяет эту функцию к каждому элементу списка (см. &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;Функции сопоставления&lt;/a&gt; ). См. &lt;a href=&quot;accessing-documentation#describe_002dsymbols-example&quot;&gt;Пример описания-символов&lt;/a&gt; , чтобы увидеть реалистичный пример этого.</target>
        </trans-unit>
        <trans-unit id="1be7de9f1b9c2d003e43c343730f7fd8d2bd62d3" translate="yes" xml:space="preserve">
          <source>Although numbers never change and all markers are mutable, some types have members some of which are mutable and others not. These types include conses, vectors, and strings. For example, although &lt;code&gt;&quot;cons&quot;&lt;/code&gt; and &lt;code&gt;(symbol-name 'cons)&lt;/code&gt; both yield strings that should not be changed, &lt;code&gt;(copy-sequence &quot;cons&quot;)&lt;/code&gt; and &lt;code&gt;(make-string 3 ?a)&lt;/code&gt; both yield mutable strings that can be changed via later calls to &lt;code&gt;aset&lt;/code&gt;.</source>
          <target state="translated">Хотя числа никогда не меняются и все маркеры изменяемы, некоторые типы имеют члены, некоторые из которых являются изменяемыми, а другие - нет. К этим типам относятся конусы, векторы и строки. Например, хотя &lt;code&gt;&quot;cons&quot;&lt;/code&gt; и &lt;code&gt;(symbol-name 'cons)&lt;/code&gt; оба дают строки, которые не следует изменять, &lt;code&gt;(copy-sequence &quot;cons&quot;)&lt;/code&gt; и &lt;code&gt;(make-string 3 ?a)&lt;/code&gt; оба дают изменяемые строки, которые можно изменить с помощью позже звонки в &lt;code&gt;aset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd89d9ee767436b48e243e1fec03f6f21ceca0df" translate="yes" xml:space="preserve">
          <source>Although packing and unpacking operations change the organization of data (in memory), they preserve the data&amp;rsquo;s &lt;em&gt;total length&lt;/em&gt;, which is the sum of all the fields&amp;rsquo; lengths, in bytes. This value is not generally inherent in either the specification or alist alone; instead, both pieces of information contribute to its calculation. Likewise, the length of a string or array being unpacked may be longer than the data&amp;rsquo;s total length as described by the specification.</source>
          <target state="translated">Хотя операции упаковки и распаковки изменяют организацию данных (в памяти), они сохраняют &lt;em&gt;общую длину данных&lt;/em&gt; , которая является суммой длин всех полей в байтах. Это значение обычно присуще не только спецификации или списку; вместо этого обе части информации участвуют в его расчетах. Точно так же длина распаковываемой строки или массива может быть больше, чем общая длина данных, как описано в спецификации.</target>
        </trans-unit>
        <trans-unit id="d96567dd4450662d62d221615f9401c0781977ac" translate="yes" xml:space="preserve">
          <source>Although the expressions &lt;code&gt;(list '+ 1 2)&lt;/code&gt; and &lt;code&gt;'(+ 1 2)&lt;/code&gt; both yield lists equal to &lt;code&gt;(+ 1 2)&lt;/code&gt;, the former yields a freshly-minted mutable list whereas the latter yields a list built from conses that might be shared and should not be modified. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;.</source>
          <target state="translated">Хотя выражения &lt;code&gt;(list '+ 1 2)&lt;/code&gt; и &lt;code&gt;'(+ 1 2)&lt;/code&gt; оба дают списки, равные &lt;code&gt;(+ 1 2)&lt;/code&gt; , первое дает только что созданный изменяемый список, тогда как второе дает список, построенный из conses, которые могут быть общими и не должны быть изменены. См. &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Формы для самооценки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22404d7c1088551650eedf30d445b02f32c8b26a" translate="yes" xml:space="preserve">
          <source>Although the list &lt;code&gt;(0.5)&lt;/code&gt; was mutable when it was created, it should not have been changed via &lt;code&gt;setcar&lt;/code&gt; because it given to &lt;code&gt;eval&lt;/code&gt;. The reverse does not occur: an object that should not be changed never becomes mutable afterwards.</source>
          <target state="translated">Хотя список &lt;code&gt;(0.5)&lt;/code&gt; был изменяемым при создании, его не следовало изменять с помощью &lt;code&gt;setcar&lt;/code&gt; , потому что он был передан в &lt;code&gt;eval&lt;/code&gt; . Обратного не происходит: объект, который нельзя изменять, впоследствии никогда не становится изменяемым.</target>
        </trans-unit>
        <trans-unit id="391c1ca03938de65f008bec7937cdacbb0a5f7c8" translate="yes" xml:space="preserve">
          <source>Although the portable dumper code can run on many platforms, the dump files that it produces are not portable&amp;mdash;they can be loaded only by the Emacs executable that dumped them.</source>
          <target state="translated">Хотя переносимый код дампера может работать на многих платформах, создаваемые им файлы дампа не переносимы - они могут быть загружены только исполняемым файлом Emacs, который их сбросил.</target>
        </trans-unit>
        <trans-unit id="6fa602a74e291da2cfde0e718a9868c53eb69aef" translate="yes" xml:space="preserve">
          <source>Although top-level calls to &lt;code&gt;require&lt;/code&gt; are evaluated during byte compilation, &lt;code&gt;provide&lt;/code&gt; calls are not. Therefore, you can ensure that a file of definitions is loaded before it is byte-compiled by including a &lt;code&gt;provide&lt;/code&gt; followed by a &lt;code&gt;require&lt;/code&gt; for the same feature, as in the following example.</source>
          <target state="translated">Хотя вызовы верхнего уровня для &lt;code&gt;require&lt;/code&gt; оцениваются во время компиляции байта, вызовы &lt;code&gt;provide&lt;/code&gt; - нет. Следовательно, вы можете убедиться, что файл определений загружен до его побайтной компиляции, включив в него строку &lt;code&gt;provide&lt;/code&gt; , за которой следует &lt;code&gt;require&lt;/code&gt; для той же функции, как в следующем примере.</target>
        </trans-unit>
        <trans-unit id="0d330d60bab6b0316e891e9303762414649958a9" translate="yes" xml:space="preserve">
          <source>Although traditionally Lisp timestamps were integer pairs, their form has evolved and programs ordinarily should not depend on the current default form. If your program needs a particular timestamp form, you can use the &lt;code&gt;time-convert&lt;/code&gt; function to convert it to the needed form. See &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;.</source>
          <target state="translated">Хотя традиционно метки времени Lisp были целочисленными парами, их форма эволюционировала, и программы обычно не должны зависеть от текущей формы по умолчанию. Если вашей программе требуется конкретная форма временной метки, вы можете использовать функцию преобразования &lt;code&gt;time-convert&lt;/code&gt; чтобы преобразовать ее в нужную форму. См. &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Преобразование времени&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03d337a2cc5120b55c2c85cdc5a80ad1a0f608d6" translate="yes" xml:space="preserve">
          <source>Always use the &lt;code&gt;:set&lt;/code&gt; function to initialize the variable. If the variable is already non-void, reset it by calling the &lt;code&gt;:set&lt;/code&gt; function using the current value (returned by the &lt;code&gt;:get&lt;/code&gt; method). This is the default &lt;code&gt;:initialize&lt;/code&gt; function.</source>
          <target state="translated">Всегда используйте функцию &lt;code&gt;:set&lt;/code&gt; для инициализации переменной. Если переменная уже не является недействительной, сбросьте ее, вызвав функцию &lt;code&gt;:set&lt;/code&gt; , используя текущее значение (возвращенное методом &lt;code&gt;:get&lt;/code&gt; ). Это функция по умолчанию &lt;code&gt;:initialize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d4ac6bb796b287295b9fa9b0f33f9196a9c4247" translate="yes" xml:space="preserve">
          <source>Amongst other things, this function sets up the &lt;code&gt;comment-start&lt;/code&gt; variable to handle Lisp comments:</source>
          <target state="translated">Среди прочего, эта функция устанавливает переменную &lt;code&gt;comment-start&lt;/code&gt; для обработки комментариев Lisp:</target>
        </trans-unit>
        <trans-unit id="55327aa4b2861fca2f67242dee6031a0481c6441" translate="yes" xml:space="preserve">
          <source>An (efficient) array of characters.</source>
          <target state="translated">(эффективный)массив символов.</target>
        </trans-unit>
        <trans-unit id="b24fa2adc3461b8097e9865ddc5d05a962a6075d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;end-of-file&lt;/code&gt; error is signaled if reading encounters an unterminated list, vector, or string.</source>
          <target state="translated">Об ошибке &lt;code&gt;end-of-file&lt;/code&gt; сообщается, если при чтении обнаруживается незавершенный список, вектор или строка.</target>
        </trans-unit>
        <trans-unit id="4fa8eeb2346c8a9639fa3ee155f83ec1952beb3e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action alist&lt;/em&gt; is an association list mapping predefined symbols recognized by action functions to values these functions are supposed to interpret accordingly. In each call, &lt;code&gt;display-buffer&lt;/code&gt; constructs a new, possibly empty action alist and passes that entire list on to any action function it calls.</source>
          <target state="translated">&lt;em&gt;Крен действия&lt;/em&gt; ассоциативного список картографирование предопределены символы распознаются функциями действий для значений этих функций , как предполагается интерпретировать соответствующим образом . В каждом вызове &lt;code&gt;display-buffer&lt;/code&gt; создает новый, возможно, пустой список действий и передает весь этот список любой вызываемой функции действия.</target>
        </trans-unit>
        <trans-unit id="6fbb202e704ca6497d62596b4b24317b48567731" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action function&lt;/em&gt; is a function &lt;code&gt;display-buffer&lt;/code&gt; calls for choosing a window to display a buffer. Action functions take two arguments: &lt;var&gt;buffer&lt;/var&gt;, the buffer to display, and &lt;var&gt;alist&lt;/var&gt;, an action alist (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;). They are supposed to return a window displaying &lt;var&gt;buffer&lt;/var&gt; if they succeed and &lt;code&gt;nil&lt;/code&gt; if they fail.</source>
          <target state="translated">&lt;em&gt;Функция действия&lt;/em&gt; является функцией &lt;code&gt;display-buffer&lt;/code&gt; вызовов для выбора окна для отображения буфера. Функции действий принимают два аргумента: &lt;var&gt;buffer&lt;/var&gt; , отображаемый буфер, и &lt;var&gt;alist&lt;/var&gt; , список действий (см. &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Списки действий отображения буфера&lt;/a&gt; ). Они должны возвращать &lt;var&gt;buffer&lt;/var&gt; отображения окна в случае успеха и &lt;code&gt;nil&lt;/code&gt; случае неудачи.</target>
        </trans-unit>
        <trans-unit id="42d3eec2eded4ad1f09d03ecadb028b0fe97c946" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; is a fixed-length object with a slot for each of its elements. All the elements are accessible in constant time. The four types of arrays are strings, vectors, char-tables and bool-vectors.</source>
          <target state="translated">&lt;em&gt;Массив&lt;/em&gt; является фиксированной длиной объекта с прорезью для каждого из его элементов. Все элементы доступны в постоянное время. Четыре типа массивов - это строки, векторы, таблицы символов и векторы типа bool.</target>
        </trans-unit>
        <trans-unit id="a4bee20b16add7aae2f3af434413439ac2fc3a32" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; is composed of an arbitrary number of slots for holding or referring to other Lisp objects, arranged in a contiguous block of memory. Accessing any element of an array takes approximately the same amount of time. In contrast, accessing an element of a list requires time proportional to the position of the element in the list. (Elements at the end of a list take longer to access than elements at the beginning of a list.)</source>
          <target state="translated">&lt;em&gt;Массив&lt;/em&gt; состоит из произвольного числа слотов для удержания или ссылок на другие объекты лисповских, расположенных в непрерывном блоке памяти. Доступ к любому элементу массива занимает примерно такое же время. Напротив, для доступа к элементу списка требуется время, пропорциональное положению элемента в списке. (Доступ к элементам в конце списка занимает больше времени, чем к элементам в начале списка.)</target>
        </trans-unit>
        <trans-unit id="553ed232664b5e6ef74691641b0767d1d08a7cfd" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; object has slots that hold a number of other Lisp objects, called the elements of the array. Any element of an array may be accessed in constant time. In contrast, the time to access an element of a list is proportional to the position of that element in the list.</source>
          <target state="translated">У объекта &lt;em&gt;массива&lt;/em&gt; есть слоты, которые содержат ряд других объектов Лиспа, называемых элементами массива. Доступ к любому элементу массива можно получить в постоянное время. Напротив, время доступа к элементу списка пропорционально положению этого элемента в списке.</target>
        </trans-unit>
        <trans-unit id="51d6c8f716e9b88b14b6fb96e89f9851f7407153" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;association list&lt;/em&gt; or &lt;em&gt;alist&lt;/em&gt; is a specially-constructed list whose elements are cons cells. In each element, the &lt;small&gt;CAR&lt;/small&gt; is considered a &lt;em&gt;key&lt;/em&gt;, and the &lt;small&gt;CDR&lt;/small&gt; is considered an &lt;em&gt;associated value&lt;/em&gt;. (In some cases, the associated value is stored in the &lt;small&gt;CAR&lt;/small&gt; of the &lt;small&gt;CDR&lt;/small&gt;.) Association lists are often used as stacks, since it is easy to add or remove associations at the front of the list.</source>
          <target state="translated">&lt;em&gt;Ассоциативный список&lt;/em&gt; или &lt;em&gt;ассоциативный список&lt;/em&gt; является специально построенный список, элементы которого являются минусы клетки. В каждом элементе &lt;small&gt;CAR&lt;/small&gt; считается &lt;em&gt;ключом&lt;/em&gt; , а &lt;small&gt;CDR&lt;/small&gt; - &lt;em&gt;ассоциированным значением&lt;/em&gt; . (В некоторых случаях, ассоциированное значение сохраняется в &lt;small&gt;ЦАР&lt;/small&gt; в &lt;small&gt;CDR&lt;/small&gt; .) Ассоциативные списки часто используются как стеки, так как легко добавлять или удалять ассоциации в передней части списка.</target>
        </trans-unit>
        <trans-unit id="1abfa47a133f69e41aaa18f7e94f5e435978d98b" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;association list&lt;/em&gt;, or &lt;em&gt;alist&lt;/em&gt; for short, records a mapping from keys to values. It is a list of cons cells called &lt;em&gt;associations&lt;/em&gt;: the &lt;small&gt;CAR&lt;/small&gt; of each cons cell is the &lt;em&gt;key&lt;/em&gt;, and the &lt;small&gt;CDR&lt;/small&gt; is the &lt;em&gt;associated value&lt;/em&gt;.&lt;a href=&quot;#FOOT5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Ассоциативный список&lt;/em&gt; , или &lt;em&gt;крен&lt;/em&gt; для краткости, записывает отображение ключей к значениям. Это список cons-ячеек, называемых &lt;em&gt;ассоциациями&lt;/em&gt; : &lt;small&gt;CAR&lt;/small&gt; каждой cons-ячейки является &lt;em&gt;ключом&lt;/em&gt; , а &lt;small&gt;CDR&lt;/small&gt; - &lt;em&gt;связанным значением&lt;/em&gt; . &lt;a href=&quot;#FOOT5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5d765e12413afb561974dbf3e3027981ca84c13" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;autoload object&lt;/em&gt; is a list whose first element is the symbol &lt;code&gt;autoload&lt;/code&gt;. It is stored as the function definition of a symbol, where it serves as a placeholder for the real definition. The autoload object says that the real definition is found in a file of Lisp code that should be loaded when necessary. It contains the name of the file, plus some other information about the real definition.</source>
          <target state="translated">Объект &lt;em&gt;автозагрузки&lt;/em&gt; - это список, первым элементом которого является &lt;code&gt;autoload&lt;/code&gt; символа . Он сохраняется как определение функции символа, где он служит заполнителем для реального определения. Объект автозагрузки сообщает, что настоящее определение находится в файле кода Лиспа, который должен быть загружен при необходимости. Он содержит имя файла и некоторую другую информацию о реальном определении.</target>
        </trans-unit>
        <trans-unit id="24cadccfe6209dab134eadc89a088981a88134fc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;ewoc&lt;/em&gt; is a structure that organizes information required to construct buffer text that represents certain Lisp data. The buffer text of the ewoc has three parts, in order: first, fixed &lt;em&gt;header&lt;/em&gt; text; next, textual descriptions of a series of data elements (Lisp objects that you specify); and last, fixed &lt;em&gt;footer&lt;/em&gt; text. Specifically, an ewoc contains information on:</source>
          <target state="translated">&lt;em&gt;Ewoc&lt;/em&gt; представляет собой структуру , которая организует информацию , необходимую для построения буфера текста , который представляет определенные данные лисповских. Буферный текст ewoc состоит из трех частей по порядку: первая, фиксированный текст &lt;em&gt;заголовка&lt;/em&gt; ; затем текстовые описания серии элементов данных (объектов Lisp, которые вы указываете); и, наконец, исправленный текст &lt;em&gt;нижнего колонтитула&lt;/em&gt; . В частности, ewoc содержит информацию о:</target>
        </trans-unit>
        <trans-unit id="45ade8aa3c0307591d943018dc5e837198a89448" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;image descriptor&lt;/em&gt; is a list which specifies the underlying data for an image, and how to display it. It is typically used as the value of a &lt;code&gt;display&lt;/code&gt; overlay or text property (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;); but See &lt;a href=&quot;showing-images#Showing-Images&quot;&gt;Showing Images&lt;/a&gt;, for convenient helper functions to insert images into buffers.</source>
          <target state="translated">&lt;em&gt;Дескриптор изображения&lt;/em&gt; является списком , который определяет основные данные для изображения, и как отобразить его. Обычно он используется как значение свойства наложения &lt;code&gt;display&lt;/code&gt; или текста (см. &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Другие характеристики дисплея&lt;/a&gt; ); но см. &lt;a href=&quot;showing-images#Showing-Images&quot;&gt;Отображение изображений&lt;/a&gt; , где описаны удобные вспомогательные функции для вставки изображений в буферы.</target>
        </trans-unit>
        <trans-unit id="8ee4088b1e46a6b8823f17c1848dbfa1804acba9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;indirect buffer&lt;/em&gt; shares the text of some other buffer, which is called the &lt;em&gt;base buffer&lt;/em&gt; of the indirect buffer. In some ways it is the analogue, for buffers, of a symbolic link among files. The base buffer may not itself be an indirect buffer.</source>
          <target state="translated">An &lt;em&gt;косвенного буфер&lt;/em&gt; разделяет текст какого - либо другого буфера, который называется &lt;em&gt;базовым буфером&lt;/em&gt; косвенного буфера. В некотором смысле для буферов это аналог символической ссылки между файлами. Базовый буфер сам по себе не может быть косвенным буфером.</target>
        </trans-unit>
        <trans-unit id="5d4ce81396c742a0b613f8351db2ccbce4a6b846" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;inline function&lt;/em&gt; is a function that works just like an ordinary function, except for one thing: when you byte-compile a call to the function (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;), the function&amp;rsquo;s definition is expanded into the caller.</source>
          <target state="translated">Встроенная &lt;em&gt;функция&lt;/em&gt; - это функция, которая работает так же, как обычная функция, за исключением одного: при побайтовой компиляции вызова функции (см. &amp;laquo; &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Байтовая компиляция&amp;raquo;&lt;/a&gt; ) определение функции расширяется до вызывающего.</target>
        </trans-unit>
        <trans-unit id="9f6630c098c66be4689d2cdd9cd8bef1da6dd18e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;overlay&lt;/em&gt; specifies properties that apply to a part of a buffer. Each overlay applies to a specified range of the buffer, and contains a property list (a list whose elements are alternating property names and values). Overlay properties are used to present parts of the buffer temporarily in a different display style. Overlays have no read syntax, and print in hash notation, giving the buffer name and range of positions.</source>
          <target state="translated">&lt;em&gt;Наложения&lt;/em&gt; определяют свойства , которые относятся к части буфера. Каждое наложение применяется к указанному диапазону буфера и содержит список свойств (список, элементами которого являются чередующиеся имена и значения свойств). Свойства наложения используются для временного представления частей буфера в другом стиле отображения. Оверлеи не имеют синтаксиса чтения и печатаются в хеш-нотации с указанием имени буфера и диапазона позиций.</target>
        </trans-unit>
        <trans-unit id="07799df1b9d386af6360d33cd65d6f9fe665cd6d" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;rhs&lt;/var&gt; cannot be an empty list (an empty list is never needed, since SMIE allows all non-terminals to match the empty string anyway).</source>
          <target state="translated">An &lt;var&gt;rhs&lt;/var&gt; не может быть пустой список (пустой список никогда не требуется, так как SMIE позволяет всем нетерминалы соответствовать пустой строке в любом случае).</target>
        </trans-unit>
        <trans-unit id="ad5b32c399f18af984f9755a3f1132417efccd31" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;rhs&lt;/var&gt; cannot have 2 consecutive non-terminals: each pair of non-terminals needs to be separated by a terminal (aka token). This is a fundamental limitation of operator precedence grammars.</source>
          <target state="translated">An &lt;var&gt;rhs&lt;/var&gt; не может иметь 2 последовательных нетерминалы: каждая пара потребностей нетерминалы быть отделены друг от терминала (он же маркера). Это фундаментальное ограничение грамматик приоритета операторов.</target>
        </trans-unit>
        <trans-unit id="7922709da81f687d8271ff998b16af874b1814ac" translate="yes" xml:space="preserve">
          <source>An Emacs &lt;em&gt;character set&lt;/em&gt;, or &lt;em&gt;charset&lt;/em&gt;, is a set of characters in which each character is assigned a numeric code point. (The Unicode Standard calls this a &lt;em&gt;coded character set&lt;/em&gt;.) Each Emacs charset has a name which is a symbol. A single character can belong to any number of different character sets, but it will generally have a different code point in each charset. Examples of character sets include &lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, &lt;code&gt;greek-iso8859-7&lt;/code&gt;, and &lt;code&gt;windows-1255&lt;/code&gt;. The code point assigned to a character in a charset is usually different from its code point used in Emacs buffers and strings.</source>
          <target state="translated">&lt;em&gt;Набор символов&lt;/em&gt; Emacs или &lt;em&gt;набор &lt;/em&gt;&lt;em&gt;символов&lt;/em&gt; - это набор символов, в котором каждому символу присвоена числовая кодовая точка. (Стандарт Unicode называет это &lt;em&gt;набором кодированных символов&lt;/em&gt; .) Каждая кодировка Emacs имеет имя, которое является символом. Один символ может принадлежать к любому количеству различных наборов символов, но, как правило, он будет иметь разные кодовые точки в каждой кодировке. Примеры наборов символов включают &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;iso-8859-1&lt;/code&gt; , &lt;code&gt;greek-iso8859-7&lt;/code&gt; и &lt;code&gt;windows-1255&lt;/code&gt; . Кодовая точка, присвоенная символу в кодировке, обычно отличается от ее кодовой точки, используемой в буферах и строках Emacs.</target>
        </trans-unit>
        <trans-unit id="b460981854f34e1d2df2695ccac2e570ff87d223" translate="yes" xml:space="preserve">
          <source>An Emacs installation may have a &lt;em&gt;default init file&lt;/em&gt;, which is a Lisp library named</source>
          <target state="translated">В установке Emacs может быть &lt;em&gt;файл инициализации по умолчанию&lt;/em&gt; , который является библиотекой Lisp с именем</target>
        </trans-unit>
        <trans-unit id="e2785779758cffeebac8e8b91c79bc832a2d5aa1" translate="yes" xml:space="preserve">
          <source>An abbrev table is represented as an obarray. See &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;, for information about obarrays. Each abbreviation is represented by a symbol in the obarray. The symbol&amp;rsquo;s name is the abbreviation; its value is the expansion; its function definition is the hook function for performing the expansion (see &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Defining Abbrevs&lt;/a&gt;); and its property list cell contains various additional properties, including the use count and the number of times the abbreviation has been expanded (see &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;).</source>
          <target state="translated">Таблица сокращений представлена ​​в виде массива. См. &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Создание символов&lt;/a&gt; для получения информации об образцах. Каждая аббревиатура представлена ​​символом в массиве. Название символа - это аббревиатура; его ценность - расширение; определение его функции - это функция-перехватчик для выполнения раскрытия (см. &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Определение сокращений&lt;/a&gt; ); а его ячейка со списком свойств содержит различные дополнительные свойства, в том числе количество использований и количество раз, когда сокращение было расширено (см. &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Свойства аббревиатуры&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e708d184dee6ca64093dbe415ec262b16c5b9ff2" translate="yes" xml:space="preserve">
          <source>An abbreviation or &lt;em&gt;abbrev&lt;/em&gt; is a string of characters that may be expanded to a longer string. The user can insert the abbrev string and find it replaced automatically with the expansion of the abbrev. This saves typing.</source>
          <target state="translated">Аббревиатура или &lt;em&gt;аббревиатура&lt;/em&gt; - это строка символов, которая может быть расширена до более длинной строки. Пользователь может вставить строку аббревиатуры и обнаружить, что она автоматически заменяется расширением аббревиатуры. Это экономит набор текста.</target>
        </trans-unit>
        <trans-unit id="8be78449d783fd1e94ea043c27376e317eb4caa7" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by &lt;code&gt;delete-terminal&lt;/code&gt;. Each function receives one argument, the &lt;var&gt;terminal&lt;/var&gt; argument passed to &lt;code&gt;delete-terminal&lt;/code&gt;. Due to technical details, the functions may be called either just before the terminal is deleted, or just afterwards.</source>
          <target state="translated">Аномальный перехватчик, запущенный &lt;code&gt;delete-terminal&lt;/code&gt; . Каждая функция получает один аргумент, аргумент &lt;var&gt;terminal&lt;/var&gt; передается в &lt;code&gt;delete-terminal&lt;/code&gt; . По техническим причинам функции могут быть вызваны либо непосредственно перед удалением терминала, либо сразу после него.</target>
        </trans-unit>
        <trans-unit id="6b8b396e23526cbc99aafc9321a68ad76aeb57a7" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by &lt;code&gt;make-frame&lt;/code&gt; after it created the frame. Each function in &lt;code&gt;after-make-frame-functions&lt;/code&gt; receives one argument, the frame just created.</source>
          <target state="translated">Аномальный обработчик, запускаемый &lt;code&gt;make-frame&lt;/code&gt; после создания кадра. Каждая функция в &lt;code&gt;after-make-frame-functions&lt;/code&gt; получает один аргумент - только что созданный фрейм.</target>
        </trans-unit>
        <trans-unit id="d8587f99198f36ccc0868cfa884bdb9eebf7fda4" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by prefix commands (such as</source>
          <target state="translated">Ненормальный крюк,запускаемый префиксными командами (такими как</target>
        </trans-unit>
        <trans-unit id="a76206aa6573ab5f6706b29d3c45607d86b5bf4d" translate="yes" xml:space="preserve">
          <source>An action function accepts two arguments: the buffer to display and an action alist. It attempts to display the buffer in some window, picking or creating a window according to its own criteria. If successful, it returns the window; otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Функция действия принимает два аргумента: отображаемый буфер и список действий. Он пытается отобразить буфер в каком-то окне, выбирая или создавая окно в соответствии со своими критериями. В случае успеха возвращает окно; в противном случае возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f8b239306495b67e6a33c553a3311a22ea8108" translate="yes" xml:space="preserve">
          <source>An action function for displaying buffers in side windows.</source>
          <target state="translated">Функция действия для отображения буферов в боковых окнах.</target>
        </trans-unit>
        <trans-unit id="8d4ccdf032d06b3ff88d7877263294cc83765270" translate="yes" xml:space="preserve">
          <source>An alist of the minor modes of this buffer.</source>
          <target state="translated">Список второстепенных режимов этого буфера.</target>
        </trans-unit>
        <trans-unit id="9d0b7856c0ae1bba2fe0095e327228fef5e6cbeb" translate="yes" xml:space="preserve">
          <source>An alternative to keeping around C data structures that need to be passed to module functions later is to create &lt;em&gt;user pointer&lt;/em&gt; objects. A user pointer, or &lt;code&gt;user-ptr&lt;/code&gt;, object is a Lisp object that encapsulates a C pointer and can have an associated finalizer function, which is called when the object is garbage-collected (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;). The module</source>
          <target state="translated">Альтернативой хранению структур данных C, которые необходимо передать функциям модуля позже, является создание объектов- &lt;em&gt;указателей пользователя&lt;/em&gt; . Пользовательский указатель или объект &lt;code&gt;user-ptr&lt;/code&gt; - это объект Lisp, который инкапсулирует указатель C и может иметь связанную функцию финализатора, которая вызывается, когда объект собирается сборщиком мусора (см. &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Сборка мусора&lt;/a&gt; ). Модуль</target>
        </trans-unit>
        <trans-unit id="76745f9f38a9adc0e71accf01a6af367ec394a13" translate="yes" xml:space="preserve">
          <source>An alternative, structured regexp notation.</source>
          <target state="translated">Альтернативная,структурированная регэкспертная нотация.</target>
        </trans-unit>
        <trans-unit id="49d23cb0a4197518f11c87451f54d2c79b88ddd3" translate="yes" xml:space="preserve">
          <source>An anonymous face: a property list of the form &lt;code&gt;(&lt;var&gt;keyword&lt;/var&gt;
&lt;var&gt;value&lt;/var&gt; &amp;hellip;)&lt;/code&gt;, where each &lt;var&gt;keyword&lt;/var&gt; is a face attribute name and &lt;var&gt;value&lt;/var&gt; is a value for that attribute.</source>
          <target state="translated">Анонимное лицо: список свойств в форме &lt;code&gt;(&lt;var&gt;keyword&lt;/var&gt; &lt;var&gt;value&lt;/var&gt; &amp;hellip;)&lt;/code&gt; , где каждое &lt;var&gt;keyword&lt;/var&gt; является именем атрибута лица, а &lt;var&gt;value&lt;/var&gt; - значением этого атрибута.</target>
        </trans-unit>
        <trans-unit id="0cb1807f666d0b9ab5deb699a6ca67714dc0387b" translate="yes" xml:space="preserve">
          <source>An application can bind this variable to a non-&lt;code&gt;nil&lt;/code&gt; value around calls to these functions. If it does so, the application is fully responsible for correctly assigning the parameters of all involved windows when exiting that function.</source>
          <target state="translated">Приложение может привязать эту переменную к значению, отличному от &lt;code&gt;nil&lt;/code&gt; , вокруг вызовов этих функций. В этом случае приложение полностью отвечает за правильное назначение параметров всех задействованных окон при выходе из этой функции.</target>
        </trans-unit>
        <trans-unit id="17ba397de5d1c307ab7dde751562e065ea00e3df" translate="yes" xml:space="preserve">
          <source>An arrow in the left fringe indicates the line where the function is executing. Point initially shows where within the line the function is executing, but this ceases to be true if you move point yourself.</source>
          <target state="translated">Стрелка в левой полосе указывает на строку,в которой выполняется функция.Точка изначально показывает,где внутри строки выполняется функция,но это перестает быть правдой,если вы сами переместите точку.</target>
        </trans-unit>
        <trans-unit id="ac945ca03e1203355b8e2eb7095f27f8bf8a33d9" translate="yes" xml:space="preserve">
          <source>An asynchronous process is controlled either via a &lt;em&gt;pty&lt;/em&gt; (pseudo-terminal) or a &lt;em&gt;pipe&lt;/em&gt;. The choice of pty or pipe is made when creating the process, by default based on the value of the variable &lt;code&gt;process-connection-type&lt;/code&gt; (see below). If available, ptys are usually preferable for processes visible to the user, as in Shell mode, because they allow for job control (</source>
          <target state="translated">Асинхронный процесс управляется либо через &lt;em&gt;pty&lt;/em&gt; (псевдотерминал), либо через &lt;em&gt;канал&lt;/em&gt; . Выбор pty или pipe выполняется при создании процесса по умолчанию на основе значения переменной &lt;code&gt;process-connection-type&lt;/code&gt; (см. Ниже). Если доступно, ptys обычно предпочтительнее для процессов, видимых пользователю, как в режиме оболочки, поскольку они позволяют управлять заданиями (</target>
        </trans-unit>
        <trans-unit id="fed2f1ab264295d6199c8837444baee7f96bfb5c" translate="yes" xml:space="preserve">
          <source>An autoload object is usually created with the function &lt;code&gt;autoload&lt;/code&gt;, which stores the object in the function cell of a symbol. See &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;, for more details.</source>
          <target state="translated">Объект автозагрузки обычно создается с помощью функции &lt;code&gt;autoload&lt;/code&gt; , которая сохраняет объект в функциональной ячейке символа. Подробнее см. &lt;a href=&quot;autoload#Autoload&quot;&gt;Автозагрузка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="224896b7315afde30421b984952b3f7096f2d130" translate="yes" xml:space="preserve">
          <source>An autoloaded keymap loads automatically during key lookup when a prefix key&amp;rsquo;s binding is the symbol &lt;var&gt;function&lt;/var&gt;. Autoloading does not occur for other kinds of access to the keymap. In particular, it does not happen when a Lisp program gets the keymap from the value of a variable and calls &lt;code&gt;define-key&lt;/code&gt;; not even if the variable name is the same symbol &lt;var&gt;function&lt;/var&gt;.</source>
          <target state="translated">Автоматически загружаемая раскладка клавиатуры загружается автоматически во время поиска ключа, когда привязка префиксного ключа является &lt;var&gt;function&lt;/var&gt; символа . Автозагрузки не происходит для других видов доступа к раскладке клавиатуры. В частности, этого не происходит, когда программа на Лиспе получает таблицу ключей из значения переменной и вызывает команду &lt;code&gt;define-key&lt;/code&gt; ; нет, даже если имя переменной является той же &lt;var&gt;function&lt;/var&gt; символа .</target>
        </trans-unit>
        <trans-unit id="b47c8f66af20cead9b4237e06f3de8a32193907c" translate="yes" xml:space="preserve">
          <source>An element can also look like this:</source>
          <target state="translated">Элемент также может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="d07aa0262359efa83d0dc291cc7ca1c53bb48bad" translate="yes" xml:space="preserve">
          <source>An empty element in the value of the environment variable, whether trailing (as in the above example), leading, or embedded, is replaced by the default value of &lt;code&gt;load-path&lt;/code&gt; as determined by the standard initialization procedure. If there are no such empty elements, then &lt;code&gt;EMACSLOADPATH&lt;/code&gt; specifies the entire &lt;code&gt;load-path&lt;/code&gt;. You must include either an empty element, or the explicit path to the directory containing the standard Lisp files, else Emacs will not function. (Another way to modify &lt;code&gt;load-path&lt;/code&gt; is to use the</source>
          <target state="translated">Пустой элемент в значении переменной среды, завершающий (как в приведенном выше примере), ведущий или встроенный, заменяется значением по умолчанию &lt;code&gt;load-path&lt;/code&gt; , как определено стандартной процедурой инициализации. Если таких пустых элементов нет, то &lt;code&gt;EMACSLOADPATH&lt;/code&gt; задает весь &lt;code&gt;load-path&lt;/code&gt; . Вы должны включить либо пустой элемент, либо явный путь к каталогу, содержащему стандартные файлы Lisp, иначе Emacs не будет работать. (Другой способ изменить &lt;code&gt;load-path&lt;/code&gt; - использовать</target>
        </trans-unit>
        <trans-unit id="4ebff7dd30b4758ff88bcc9a085f45ded794db52" translate="yes" xml:space="preserve">
          <source>An empty sequence contributes nothing to the value returned by &lt;code&gt;append&lt;/code&gt;. As a consequence of this, a final &lt;code&gt;nil&lt;/code&gt; argument forces a copy of the previous argument:</source>
          <target state="translated">Пустая последовательность ничего не влияет на значение, возвращаемое &lt;code&gt;append&lt;/code&gt; . Как следствие этого, последний аргумент &lt;code&gt;nil&lt;/code&gt; заставляет копию предыдущего аргумента:</target>
        </trans-unit>
        <trans-unit id="a86a8ba20f9c2d16da923dc8e59ec1f1d98d5dee" translate="yes" xml:space="preserve">
          <source>An equivalent expression for &lt;code&gt;(add-to-list '&lt;var&gt;var&lt;/var&gt;
&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; is this:</source>
          <target state="translated">Эквивалентное выражение для &lt;code&gt;(add-to-list '&lt;var&gt;var&lt;/var&gt; &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; следующее:</target>
        </trans-unit>
        <trans-unit id="d3b3af3cc140e3e00a2eb7021cf621de45339c06" translate="yes" xml:space="preserve">
          <source>An error in &lt;var&gt;body&lt;/var&gt; does not undo the load, but does prevent execution of the rest of &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">Ошибка в &lt;var&gt;body&lt;/var&gt; не отменяет загрузку, но препятствует выполнению остальной части &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="780991d8624f2cb2ad931ebb1b65ed8116e288c9" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;command&lt;/var&gt; is not a function or if it cannot be called interactively (i.e., is not a command). Note that keyboard macros (strings and vectors) are not accepted, even though they are considered commands, because they are not functions. If &lt;var&gt;command&lt;/var&gt; is a symbol, then &lt;code&gt;call-interactively&lt;/code&gt; uses its function definition.</source>
          <target state="translated">Об ошибке сообщается, если &lt;var&gt;command&lt;/var&gt; не является функцией или не может быть вызвана интерактивно (т. Е. Не является командой). Обратите внимание, что макросы клавиатуры (строки и векторы) не принимаются, даже если они считаются командами, поскольку не являются функциями. Если &lt;var&gt;command&lt;/var&gt; является символом, то в &lt;code&gt;call-interactively&lt;/code&gt; используется определение ее функции.</target>
        </trans-unit>
        <trans-unit id="61727b4effcd7b8d96ef35b8becbc54d386ea1fd" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;directory&lt;/var&gt; is not the name of a directory that can be read.</source>
          <target state="translated">Об ошибке сообщается, если &lt;var&gt;directory&lt;/var&gt; не является именем каталога, который можно прочитать.</target>
        </trans-unit>
        <trans-unit id="a857332d53570982c6dc820fa3fd199f30c64bac" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;frame&lt;/var&gt; has no side windows and no saved state is found for it.</source>
          <target state="translated">Об ошибке сигнализируется, если у &lt;var&gt;frame&lt;/var&gt; нет боковых окон и для него не найдено сохраненное состояние.</target>
        </trans-unit>
        <trans-unit id="4c7868057424e94cc2ec18aa245abf34334cd76a" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;marker&lt;/var&gt; is neither a marker nor an integer.</source>
          <target state="translated">Об ошибке сообщается, если &lt;var&gt;marker&lt;/var&gt; является ни маркером, ни целым числом.</target>
        </trans-unit>
        <trans-unit id="ce502c5c14b3dd5ab57c7b1bc0667e1dce7ae3f1" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;name&lt;/var&gt; is not a string.</source>
          <target state="translated">Если &lt;var&gt;name&lt;/var&gt; не является строкой, сигнализируется ошибка .</target>
        </trans-unit>
        <trans-unit id="d180f585f076cc17698606f42a90ec93eb4bf554" translate="yes" xml:space="preserve">
          <source>An error is signaled if you cannot write or create &lt;var&gt;filename&lt;/var&gt;.</source>
          <target state="translated">Если вы не можете записать или создать &lt;var&gt;filename&lt;/var&gt; об ошибке .</target>
        </trans-unit>
        <trans-unit id="4b96760d80ee8b7d0f895bcbd78c4d4e13017398" translate="yes" xml:space="preserve">
          <source>An error is signaled unless both &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are integers or markers that indicate positions in the current buffer. (It is unimportant which number is larger.)</source>
          <target state="translated">Сигнализируется об ошибке, если &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; являются целыми числами или маркерами, указывающими позиции в текущем буфере. (Неважно, какое число больше.)</target>
        </trans-unit>
        <trans-unit id="c51f55b2646e08b61f713ce7217e4887d1b95bfb" translate="yes" xml:space="preserve">
          <source>An error that has no explicit handler may call the Lisp debugger. The debugger is enabled if the variable &lt;code&gt;debug-on-error&lt;/code&gt; (see &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;) is non-&lt;code&gt;nil&lt;/code&gt;. Unlike error handlers, the debugger runs in the environment of the error, so that you can examine values of variables precisely as they were at the time of the error.</source>
          <target state="translated">Ошибка, у которой нет явного обработчика, может вызвать отладчик Lisp. Отладчик включается, если переменная &lt;code&gt;debug-on-error&lt;/code&gt; (см. &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Отладка ошибок&lt;/a&gt; ) не равна &lt;code&gt;nil&lt;/code&gt; . В отличие от обработчиков ошибок, отладчик работает в среде ошибки, поэтому вы можете проверять значения переменных точно такими, какими они были во время ошибки.</target>
        </trans-unit>
        <trans-unit id="826bd3cc8d084ab396a2d00d5bdbe16d54e818a5" translate="yes" xml:space="preserve">
          <source>An ewoc maintains its text in the buffer that is current when you create it, so switch to the intended buffer before calling &lt;code&gt;ewoc-create&lt;/code&gt;.</source>
          <target state="translated">Ewoc сохраняет свой текст в буфере, который является текущим при его создании, поэтому переключитесь на предполагаемый буфер перед вызовом &lt;code&gt;ewoc-create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc38d0c598a08a05ef1cbe7256ecba3cfbdd4bb4" translate="yes" xml:space="preserve">
          <source>An example of a major mode derived from Special mode is Buffer Menu mode, which is used by the</source>
          <target state="translated">Примером основного режима,полученного из Специального режима,является режим буферного меню,который используется в</target>
        </trans-unit>
        <trans-unit id="7d6bea7b0ca20a81d8dc92f7b4dfca2a43542cbd" translate="yes" xml:space="preserve">
          <source>An example of a major mode derived from Text mode is HTML mode. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html#HTML-Mode&quot;&gt;SGML and HTML Modes&lt;/a&gt; in</source>
          <target state="translated">Примером основного режима, производного от текстового режима, является режим HTML. Смотрите &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html#HTML-Mode&quot;&gt;режимы SGML и HTML&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="ade7f0bd288bb8a7ac97abf2b4ebdf07442ec432" translate="yes" xml:space="preserve">
          <source>An example of a special form is the definition of &lt;code&gt;or&lt;/code&gt;, from</source>
          <target state="translated">Примером особой формы является определение &lt;code&gt;or&lt;/code&gt; , от</target>
        </trans-unit>
        <trans-unit id="ef33cd83c0ed34c69762159ed48693bced9fc15f" translate="yes" xml:space="preserve">
          <source>An example of a type descriptor is any instance of &lt;code&gt;cl-structure-class&lt;/code&gt;.</source>
          <target state="translated">Примером дескриптора типа является любой экземпляр &lt;code&gt;cl-structure-class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24242de3c100a999285b6229c3f4ecef7f0ccd1f" translate="yes" xml:space="preserve">
          <source>An example of speedup from byte compilation.</source>
          <target state="translated">Пример ускорения от компиляции байтов.</target>
        </trans-unit>
        <trans-unit id="db343fa7b3e5ada913fce5ea3283f949a1870619" translate="yes" xml:space="preserve">
          <source>An example of the use of &lt;code&gt;defconst&lt;/code&gt; is Emacs&amp;rsquo;s definition of &lt;code&gt;float-pi&lt;/code&gt;&amp;mdash;the mathematical constant &lt;em&gt;pi&lt;/em&gt;, which ought not to be changed by anyone (attempts by the Indiana State Legislature notwithstanding). As the second form illustrates, however, &lt;code&gt;defconst&lt;/code&gt; is only advisory.</source>
          <target state="translated">Примером использования &lt;code&gt;defconst&lt;/code&gt; является определение Emacs &lt;code&gt;float-pi&lt;/code&gt; - математической константы &lt;em&gt;пи&lt;/em&gt; , которую никто не должен изменять (несмотря на попытки законодательного собрания штата Индиана). Однако, как показывает вторая форма, &lt;code&gt;defconst&lt;/code&gt; носит рекомендательный характер.</target>
        </trans-unit>
        <trans-unit id="33511a390c0a0778aeb50d2d3d11dc55b02fecef" translate="yes" xml:space="preserve">
          <source>An exclusive lock for thread synchronization.</source>
          <target state="translated">Эксклюзивный замок для синхронизации потоков.</target>
        </trans-unit>
        <trans-unit id="33cdd5563375ee0f1deecf7207e816fded24f27d" translate="yes" xml:space="preserve">
          <source>An extended-format menu item is a more flexible and also cleaner alternative to the simple format. You define an event type with a binding that&amp;rsquo;s a list starting with the symbol &lt;code&gt;menu-item&lt;/code&gt;. For a non-selectable string, the binding looks like this:</source>
          <target state="translated">Пункт меню расширенного формата является более гибкой и более чистой альтернативой простому формату. Вы определяете тип события с привязкой, которая представляет собой список, начинающийся с символа &lt;code&gt;menu-item&lt;/code&gt; . Для невыбираемой строки привязка выглядит так:</target>
        </trans-unit>
        <trans-unit id="dd1c3b20fbc2c4f6fdbfa727cc037df93e3d480a" translate="yes" xml:space="preserve">
          <source>An extra vertical space, with no actual line.</source>
          <target state="translated">Дополнительное вертикальное пространство,без фактической линии.</target>
        </trans-unit>
        <trans-unit id="7d946c1cee5e1ba6a2795eaa7494b0742a37aa80" translate="yes" xml:space="preserve">
          <source>An image map is an alist where each element has the format &lt;code&gt;(&lt;var&gt;area&lt;/var&gt; &lt;var&gt;id&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;. An &lt;var&gt;area&lt;/var&gt; is specified as either a rectangle, a circle, or a polygon.</source>
          <target state="translated">Изображение карты является ассоциативный список , где каждый элемент имеет формат &lt;code&gt;(&lt;var&gt;area&lt;/var&gt; &lt;var&gt;id&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; . &lt;var&gt;area&lt;/var&gt; задаются либо как прямоугольник, круг, или многоугольник.</target>
        </trans-unit>
        <trans-unit id="13e8bfffc43f95cb01c82af877179e85c97c1ef2" translate="yes" xml:space="preserve">
          <source>An important function of each major mode is to customize the</source>
          <target state="translated">Важной функцией каждого основного режима является настройка</target>
        </trans-unit>
        <trans-unit id="3b4e015d01f5bbc54743f05646c0292a69c90141" translate="yes" xml:space="preserve">
          <source>An indication of the depth of recursive editing levels (not counting minibuffer levels): one &amp;lsquo;</source>
          <target state="translated">Индикация глубины рекурсивного редактирования уровней (без учета уровней минибуфера): один '</target>
        </trans-unit>
        <trans-unit id="93f69cd72673e3fad1210d3ff536f5eac200198d" translate="yes" xml:space="preserve">
          <source>An indirect buffer cannot visit a file, but its base buffer can. If you try to save the indirect buffer, that actually saves the base buffer.</source>
          <target state="translated">Косвенный буфер не может посещать файл,но его базовый буфер может.Если вы попытаетесь сохранить непрямой буфер,это фактически сохранит базовый буфер.</target>
        </trans-unit>
        <trans-unit id="f4f16819d5893d8be64117345439137741280e45" translate="yes" xml:space="preserve">
          <source>An indirect buffer shares text with some other buffer.</source>
          <target state="translated">Косвенный буфер делит текст с каким-либо другим буфером.</target>
        </trans-unit>
        <trans-unit id="dd71440c52babfc9828665c875dc912c73851196" translate="yes" xml:space="preserve">
          <source>An input character event consists of a &lt;em&gt;basic code&lt;/em&gt; between 0 and 524287, plus any or all of these &lt;em&gt;modifier bits&lt;/em&gt;:</source>
          <target state="translated">Событие входного символа состоит из &lt;em&gt;базового кода&lt;/em&gt; от 0 до 524287, а также любого или всех этих &lt;em&gt;битов-модификаторов&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b3693e265751b6a87adf1612d2ffab4f6ae73018" translate="yes" xml:space="preserve">
          <source>An integer indicating the Universal Time offset in seconds, i.e., the number of seconds east of Greenwich.</source>
          <target state="translated">Целое число,указывающее смещение по универсальному времени в секундах,т.е.количество секунд к востоку от Гринвича.</target>
        </trans-unit>
        <trans-unit id="1b85b9238ec8e0326b1ff24adce97a9f1339ccd1" translate="yes" xml:space="preserve">
          <source>An integer number specifies the desired total height of the chosen window in lines.</source>
          <target state="translated">Целым числом в строках указывается желаемая общая высота выбранного окна.</target>
        </trans-unit>
        <trans-unit id="ae5275ccb64692a25834f62374d3e39ff8168087" translate="yes" xml:space="preserve">
          <source>An integer specifies the desired total width of the chosen window in columns.</source>
          <target state="translated">Целое число задает желаемую общую ширину выбранного окна в столбцах.</target>
        </trans-unit>
        <trans-unit id="c25162540c717d611e1426ca74b4483ad68c8fe4" translate="yes" xml:space="preserve">
          <source>An integer that increments each time Emacs is built in the same directory (without cleaning). This is only of relevance when developing Emacs.</source>
          <target state="translated">Целое число,которое увеличивается каждый раз,когда Emacs собирается в одном каталоге (без очистки).Это актуально только при разработке Emacs.</target>
        </trans-unit>
        <trans-unit id="a372e2277d8f20cbea84272110bbfb45b40e134a" translate="yes" xml:space="preserve">
          <source>An integer that represents the minimum number of colors the terminal should support. This matches a terminal if its &lt;code&gt;display-color-cells&lt;/code&gt; value is at least the specified integer.</source>
          <target state="translated">Целое число, представляющее минимальное количество цветов, которое должен поддерживать терминал. Это соответствует терминалу, если его значение &lt;code&gt;display-color-cells&lt;/code&gt; не меньше указанного целого числа.</target>
        </trans-unit>
        <trans-unit id="666998409bcbf2ebf0bfb7f00ef2a1f48383fd05" translate="yes" xml:space="preserve">
          <source>An integer, the operating system&amp;rsquo;s process</source>
          <target state="translated">Целое число, процесс операционной системы</target>
        </trans-unit>
        <trans-unit id="85068ddc5e4eeb621888a2f24d4968195abea28e" translate="yes" xml:space="preserve">
          <source>An integer, which stands for itself.</source>
          <target state="translated">Целое число,которое означает само себя.</target>
        </trans-unit>
        <trans-unit id="483624c83a349249c67af72f64c85e27874fdcce" translate="yes" xml:space="preserve">
          <source>An integer. Although this is the simplest form, it cannot represent subsecond timestamps.</source>
          <target state="translated">Целое число.Несмотря на то,что это самая простая форма,она не может представлять собой субвторое число.</target>
        </trans-unit>
        <trans-unit id="210e35e78b0bac1a6f24a3e4af59acfd7b9cae5d" translate="yes" xml:space="preserve">
          <source>An interned symbol whose name is read in the minibuffer. Terminate the input with either</source>
          <target state="translated">Внутренний символ,имя которого прочитывается в минибуфере.Завершите ввод любым из следующих способов</target>
        </trans-unit>
        <trans-unit id="d5c7d47ecad208491b6f75958ec8b743a987742f" translate="yes" xml:space="preserve">
          <source>An irrelevant argument. This code always supplies &lt;code&gt;nil&lt;/code&gt; as the argument&amp;rsquo;s value. No I/O.</source>
          <target state="translated">Неуместный аргумент. Этот код всегда предоставляет &lt;code&gt;nil&lt;/code&gt; в качестве значения аргумента. Нет ввода / вывода.</target>
        </trans-unit>
        <trans-unit id="27856a404b93377dd2ce26256cf827f21924ee05" translate="yes" xml:space="preserve">
          <source>An object which can be invoked via the &lt;code&gt;command-execute&lt;/code&gt; primitive, usually due to the user typing in a key sequence &lt;em&gt;bound&lt;/em&gt; to that command. See &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;. A command is usually a function; if the function is written in Lisp, it is made into a command by an &lt;code&gt;interactive&lt;/code&gt; form in the function definition (see &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;). Commands that are functions can also be called from Lisp expressions, just like other functions.</source>
          <target state="translated">Объект, который может быть вызван с помощью примитива &lt;code&gt;command-execute&lt;/code&gt; , обычно из-за того, что пользователь вводит последовательность клавиш, &lt;em&gt;привязанную&lt;/em&gt; к этой команде. См. &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Интерактивный вызов&lt;/a&gt; . Команда обычно является функцией; если функция написана на Лиспе, она превращается в команду с помощью &lt;code&gt;interactive&lt;/code&gt; формы в определении функции (см. &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Определение команд&lt;/a&gt; ). Команды, которые являются функциями, также могут вызываться из выражений Лиспа, как и другие функции.</target>
        </trans-unit>
        <trans-unit id="187267476807f080e4cb1366bd55dc6c3a734b11" translate="yes" xml:space="preserve">
          <source>An old piece of advice such as:</source>
          <target state="translated">Старый совет,например:</target>
        </trans-unit>
        <trans-unit id="a4f4924d6a637db199a3dbbcbcca04ca29c457ed" translate="yes" xml:space="preserve">
          <source>An ordinary, unencrypted connection.</source>
          <target state="translated">Обычное,незашифрованное соединение.</target>
        </trans-unit>
        <trans-unit id="8f179ba3c57cb5057b94b469bdc747796dcb263d" translate="yes" xml:space="preserve">
          <source>An output stream specifies what to do with the characters produced by printing. Most print functions accept an output stream as an optional argument. Here are the possible types of output stream:</source>
          <target state="translated">Выходной поток указывает,что делать с символами,полученными при печати.Большинство функций печати принимают выходной поток в качестве необязательного аргумента.Вот возможные типы выходного потока:</target>
        </trans-unit>
        <trans-unit id="4a4e0e2275538ba1b3ea01efe71801a7f7f08073" translate="yes" xml:space="preserve">
          <source>An overlay uses markers to record its beginning and end; thus, editing the text of the buffer adjusts the beginning and end of each overlay so that it stays with the text. When you create the overlay, you can specify whether text inserted at the beginning should be inside the overlay or outside, and likewise for the end of the overlay.</source>
          <target state="translated">Оверлей использует маркеры для записи своего начала и конца;таким образом,редактирование текста буфера подстраивает начало и конец каждого оверлея так,чтобы он оставался с текстом.При создании оверлея можно указать,должен ли текст,вставленный в начало,находиться внутри оверлея или снаружи,а также в конце оверлея.</target>
        </trans-unit>
        <trans-unit id="b25d5a56d0ee9ca005469f384e566fa726e58945" translate="yes" xml:space="preserve">
          <source>An overlay whose &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; specify the same buffer position is known as &lt;em&gt;empty&lt;/em&gt;. A non-empty overlay can become empty if the text between its &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; is deleted. When that happens, the overlay is by default not deleted, but you can cause it to be deleted by giving it the &amp;lsquo;</source>
          <target state="translated">Наложение, &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; задают одну и ту же позицию в буфере, называется &lt;em&gt;пустым&lt;/em&gt; . Непустой оверлей может стать пустым, если удалить текст между его &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; . Когда это происходит, наложение по умолчанию не удаляется, но вы можете удалить его, указав для него '</target>
        </trans-unit>
        <trans-unit id="51ba330dcf0b0a0baa7674c3887cbac685290344" translate="yes" xml:space="preserve">
          <source>An overview of all the special sequences.</source>
          <target state="translated">Обзор всех специальных последовательностей.</target>
        </trans-unit>
        <trans-unit id="045422a0880a1615b24f5a3a512245b1c27b53c3" translate="yes" xml:space="preserve">
          <source>An unspecified value, present for backward compatibility.</source>
          <target state="translated">Неопределенное значение,присутствует для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="55764c2c6ec8109ce06467af931be863e9f31e08" translate="yes" xml:space="preserve">
          <source>And here is the code to set up the keymap for Lisp mode:</source>
          <target state="translated">А вот код для настройки карты-клавиатуры для режима Lisp:</target>
        </trans-unit>
        <trans-unit id="b6e7a99ffdd1e497ee1a0b6591309c08b6de6ce9" translate="yes" xml:space="preserve">
          <source>Animation operates by means of a timer. Note that Emacs imposes a minimum frame delay of 0.01 (&lt;code&gt;image-minimum-frame-delay&lt;/code&gt;) seconds. If the image itself does not specify a delay, Emacs uses &lt;code&gt;image-default-frame-delay&lt;/code&gt;.</source>
          <target state="translated">Анимация работает с помощью таймера. Обратите внимание, что Emacs устанавливает минимальную задержку кадра 0,01 ( &lt;code&gt;image-minimum-frame-delay&lt;/code&gt; ) секунды. Если в самом изображении не указана задержка, Emacs использует &lt;code&gt;image-default-frame-delay&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">Анонимные функции</target>
        </trans-unit>
        <trans-unit id="d155a6db1755fd84bc4701702679a300873b3893" translate="yes" xml:space="preserve">
          <source>Another annoyance (more an inconvenience than a limitation) is that when a series of &lt;var&gt;condition&lt;/var&gt; predicates implement equality tests, there is a lot of repeated code. (&lt;code&gt;cl-case&lt;/code&gt; solves this inconvenience.)</source>
          <target state="translated">Еще одно неудобство (скорее неудобство, чем ограничение) заключается в том, что когда ряд предикатов &lt;var&gt;condition&lt;/var&gt; реализуют тесты на равенство, возникает много повторяющегося кода. ( &lt;code&gt;cl-case&lt;/code&gt; решает это неудобство.)</target>
        </trans-unit>
        <trans-unit id="5303f5dba20cc28da9809fdf0b019eb440c2beee" translate="yes" xml:space="preserve">
          <source>Another command,</source>
          <target state="translated">Еще одна команда,</target>
        </trans-unit>
        <trans-unit id="46429506bccc14a1fccf369e49c5519916a0ddea" translate="yes" xml:space="preserve">
          <source>Another difference from &lt;code&gt;rx-let&lt;/code&gt; is that the &lt;var&gt;bindings&lt;/var&gt; are dynamically scoped, and thus also available in functions called from &lt;var&gt;body&lt;/var&gt;. However, they are not visible inside functions defined in &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">Еще одно отличие от &lt;code&gt;rx-let&lt;/code&gt; заключается в том, что &lt;var&gt;bindings&lt;/var&gt; имеют динамическую область видимости и, следовательно, также доступны в функциях, вызываемых из &lt;var&gt;body&lt;/var&gt; . Однако они не видны внутри функций, определенных в &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="60eaf91aef5f334ebb5d4be6e2c8a0357829b694" translate="yes" xml:space="preserve">
          <source>Another disadvantage is that making a large function inline can increase the size of compiled code both in files and in memory. Since the speed advantage of inline functions is greatest for small functions, you generally should not make large functions inline.</source>
          <target state="translated">Другим недостатком является то,что выполнение большой функции inline может увеличить объем скомпилированного кода как в файлах,так и в памяти.Так как преимущество скорости встраивания функций является наибольшим для небольших функций,обычно не следует делать большие функции встраиваемыми.</target>
        </trans-unit>
        <trans-unit id="6f719d65bc588f6114e05a3ba91ae2e2b8b0fa12" translate="yes" xml:space="preserve">
          <source>Another effect of calling this function is to cause unconditional redisplay of the mode line for the current buffer. In fact, the function &lt;code&gt;force-mode-line-update&lt;/code&gt; works by doing this:</source>
          <target state="translated">Другой эффект вызова этой функции - вызвать безусловное повторное отображение строки режима для текущего буфера. Фактически, функция &lt;code&gt;force-mode-line-update&lt;/code&gt; работает следующим образом:</target>
        </trans-unit>
        <trans-unit id="fe8d47ec903dba59decabf21d52ed6b989d5e361" translate="yes" xml:space="preserve">
          <source>Another element is &lt;code&gt;(selinux-context . &lt;var&gt;context&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;context&lt;/var&gt; is the SELinux context, in the same form returned by &lt;code&gt;file-selinux-context&lt;/code&gt;.</source>
          <target state="translated">Другой элемент - &lt;code&gt;(selinux-context . &lt;var&gt;context&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;context&lt;/var&gt; - это контекст SELinux, в той же форме, что и &lt;code&gt;file-selinux-context&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4a41e64a0f4d5fb203b7d54e395a3a3c7314af2" translate="yes" xml:space="preserve">
          <source>Another file for site-customization is</source>
          <target state="translated">Другим файлом для настройки сайта является</target>
        </trans-unit>
        <trans-unit id="dc46fb6acabbfa966b8518e0f2262bc229a7fdf8" translate="yes" xml:space="preserve">
          <source>Another important concept is the notion of &lt;em&gt;parent&lt;/em&gt;: The &lt;em&gt;parent&lt;/em&gt; of a token, is the head token of the nearest enclosing syntactic construct. For example, the parent of an &lt;code&gt;else&lt;/code&gt; is the &lt;code&gt;if&lt;/code&gt; to which it belongs, and the parent of an &lt;code&gt;if&lt;/code&gt;, in turn, is the lead token of the surrounding construct. The command &lt;code&gt;backward-sexp&lt;/code&gt; jumps from a token to its parent, but there are some caveats: for &lt;em&gt;openers&lt;/em&gt; (tokens which start a construct, like &lt;code&gt;if&lt;/code&gt;), you need to start with point before the token, while for others you need to start with point after the token. &lt;code&gt;backward-sexp&lt;/code&gt; stops with point before the parent token if that is the &lt;em&gt;opener&lt;/em&gt; of the token of interest, and otherwise it stops with point after the parent token.</source>
          <target state="translated">Еще одна важная концепция - это понятие &lt;em&gt;родителя&lt;/em&gt; : &lt;em&gt;родительский&lt;/em&gt; элемент токена - это главный токен ближайшей включающей синтаксической конструкции. Например, родительский элемент &lt;code&gt;else&lt;/code&gt; - это &lt;code&gt;if&lt;/code&gt; , которому он принадлежит, а родительский элемент &lt;code&gt;if&lt;/code&gt; , в свою очередь, является ведущим токеном окружающей конструкции. Команда &lt;code&gt;backward-sexp&lt;/code&gt; переходит от токена к его родительскому элементу, но есть некоторые предостережения: для &lt;em&gt;открывателей&lt;/em&gt; (токенов, которые запускают конструкцию, например, &lt;code&gt;if&lt;/code&gt; ), вам нужно начинать с точки перед токеном, а для других нужно начинать с точка после токена. &lt;code&gt;backward-sexp&lt;/code&gt; останавливается с точкой перед родительским токеном, если это&lt;em&gt;открыватель&lt;/em&gt; интересующего токена, в противном случае он останавливается с точкой после родительского токена.</target>
        </trans-unit>
        <trans-unit id="b9deb7098c7fabbe640d3f39576b579bcc48e2d3" translate="yes" xml:space="preserve">
          <source>Another problem can happen if the macro definition itself evaluates any of the macro argument expressions, such as by calling &lt;code&gt;eval&lt;/code&gt; (see &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;). If the argument is supposed to refer to the user&amp;rsquo;s variables, you may have trouble if the user happens to use a variable with the same name as one of the macro arguments. Inside the macro body, the macro argument binding is the most local binding of this variable, so any references inside the form being evaluated do refer to it. Here is an example:</source>
          <target state="translated">Другая проблема может возникнуть, если само определение макроса вычисляет любое из выражений аргумента макроса, например, путем вызова &lt;code&gt;eval&lt;/code&gt; (см. &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt; ). Если предполагается, что аргумент относится к пользовательским переменным, у вас могут возникнуть проблемы, если пользователь использует переменную с тем же именем, что и один из аргументов макроса. Внутри тела макроса привязка аргумента макроса является самой локальной привязкой этой переменной, поэтому любые ссылки внутри оцениваемой формы ссылаются на нее. Вот пример:</target>
        </trans-unit>
        <trans-unit id="0557ba812636c13b28f9c028bebedfc50e7d0d42" translate="yes" xml:space="preserve">
          <source>Another problem with calling &lt;code&gt;eval&lt;/code&gt; in a macro definition is that it probably won&amp;rsquo;t do what you intend in a compiled program. The byte compiler runs macro definitions while compiling the program, when the program&amp;rsquo;s own computations (which you might have wished to access with &lt;code&gt;eval&lt;/code&gt;) don&amp;rsquo;t occur and its local variable bindings don&amp;rsquo;t exist.</source>
          <target state="translated">Еще одна проблема с вызовом &lt;code&gt;eval&lt;/code&gt; в определении макроса заключается в том, что он, вероятно, не будет делать то, что вы намереваетесь сделать в скомпилированной программе. Компилятор байтов запускает определения макросов во время компиляции программы, когда собственные вычисления программы (к которым вы, возможно, хотели получить доступ с помощью &lt;code&gt;eval&lt;/code&gt; ) не выполняются и привязки к ее локальным переменным не существуют.</target>
        </trans-unit>
        <trans-unit id="2808e270cef0e3cc098d7ecd467a657ae4eca448" translate="yes" xml:space="preserve">
          <source>Another prominent use of property lists is for storing symbol properties. Every symbol possesses a list of properties, used to record miscellaneous information about the symbol; these properties are stored in the form of a property list. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;.</source>
          <target state="translated">Еще одно видное применение списков свойств - хранение свойств символа. Каждый символ обладает списком свойств, используемых для записи разной информации о символе; эти свойства хранятся в виде списка свойств. См. &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Свойства символа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7cde5f29771c6fd0640e059c163a4125f612e60" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;image-flush&lt;/code&gt; is for memory conservation. If your Lisp program creates a large number of temporary images over a period much shorter than &lt;code&gt;image-cache-eviction-delay&lt;/code&gt; (see below), you can opt to flush unused images yourself, instead of waiting for Emacs to do it automatically.</source>
          <target state="translated">Еще одно применение &lt;code&gt;image-flush&lt;/code&gt; - сохранение памяти. Если ваша программа на Лиспе создает большое количество временных изображений за период, намного меньший, чем &lt;code&gt;image-cache-eviction-delay&lt;/code&gt; (см. Ниже), вы можете выбрать очистку неиспользуемых образов самостоятельно, вместо того, чтобы ждать, пока Emacs сделает это автоматически.</target>
        </trans-unit>
        <trans-unit id="641eb2680ee1c66beb56d48bd54946b6ae9853e6" translate="yes" xml:space="preserve">
          <source>Another way of classifying character syntax.</source>
          <target state="translated">Другой способ классификации синтаксиса персонажей.</target>
        </trans-unit>
        <trans-unit id="4bd2ea34cde1c693974149a710eecd977a89a21d" translate="yes" xml:space="preserve">
          <source>Another way to customize Imenu for a major mode is to set the variables &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt;:</source>
          <target state="translated">Другой способ настроить Imenu для основного режима - установить переменные &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; и &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6a0538015d82239738c87e340807fdb7d0f6e3a0" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;no&amp;rdquo;, and give up on the entire series of questions for the current buffer. Continue to the next buffer in the sequence.</source>
          <target state="translated">Ответьте на этот вопрос &amp;laquo;нет&amp;raquo; и откажитесь от всей серии вопросов для текущего буфера. Перейти к следующему буферу в последовательности.</target>
        </trans-unit>
        <trans-unit id="274994b09ea810169b43f8a646ebc9ffc6bce18b" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;no&amp;rdquo;, and give up on the entire series of questions, assuming that the answers will be &amp;ldquo;no&amp;rdquo;.</source>
          <target state="translated">Ответьте на этот вопрос &amp;laquo;нет&amp;raquo; и откажитесь от всей серии вопросов, предполагая, что ответ будет &amp;laquo;нет&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d8496e3b1f926969c35562be91206a0af61ee16e" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;yes&amp;rdquo;, and give up on the entire series of questions, assuming that subsequent answers will be &amp;ldquo;no&amp;rdquo;.</source>
          <target state="translated">Ответьте на этот вопрос &amp;laquo;да&amp;raquo; и откажитесь от всей серии вопросов, предполагая, что последующие ответы будут &amp;laquo;нет&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f56b5305911f928e39581a218bfd705b0028549b" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;yes&amp;rdquo;, but show the results&amp;mdash;don&amp;rsquo;t advance yet to the next question.</source>
          <target state="translated">Ответьте на этот вопрос &amp;laquo;да&amp;raquo;, но покажите результаты - не переходите пока к следующему вопросу.</target>
        </trans-unit>
        <trans-unit id="c32d375e1b285db59346c4795a32d1241b4b196d" translate="yes" xml:space="preserve">
          <source>Answer this question and all subsequent questions in the series with &amp;ldquo;yes&amp;rdquo;, without further user interaction, for all remaining buffers.</source>
          <target state="translated">Ответьте на этот вопрос и на все последующие вопросы серии &amp;laquo;да&amp;raquo;, без дальнейшего взаимодействия с пользователем, для всех оставшихся буферов.</target>
        </trans-unit>
        <trans-unit id="cf8d75f96842754b6fdf5c2cb0d9b07cc288c581" translate="yes" xml:space="preserve">
          <source>Answer this question and all subsequent questions in the series with &amp;ldquo;yes&amp;rdquo;, without further user interaction.</source>
          <target state="translated">Ответьте на этот вопрос и на все последующие вопросы серии &amp;laquo;да&amp;raquo; без дальнейшего взаимодействия с пользователем.</target>
        </trans-unit>
        <trans-unit id="58980dd0f49cd2faac7cab10b446ea677250ef35" translate="yes" xml:space="preserve">
          <source>Antinews</source>
          <target state="translated">Antinews</target>
        </trans-unit>
        <trans-unit id="1fa1accc626834eb5e37df54ce5a411a8faa2f5a" translate="yes" xml:space="preserve">
          <source>Any Lisp program output that would normally go to the echo area, either using &lt;code&gt;message&lt;/code&gt;, or using &lt;code&gt;prin1&lt;/code&gt;, etc., with &lt;code&gt;t&lt;/code&gt; as the stream, goes instead to Emacs&amp;rsquo;s standard descriptors when in batch mode: &lt;code&gt;message&lt;/code&gt; writes to the standard error descriptor, while &lt;code&gt;prin1&lt;/code&gt; and other print functions write to the standard output. Similarly, input that would normally come from the minibuffer is read from the standard input descriptor. Thus, Emacs behaves much like a noninteractive application program. (The echo area output that Emacs itself normally generates, such as command echoing, is suppressed entirely.)</source>
          <target state="translated">Любой вывод программы Lisp, который обычно попадает в эхо-область, либо с использованием &lt;code&gt;message&lt;/code&gt; , либо с использованием &lt;code&gt;prin1&lt;/code&gt; и &lt;code&gt;t&lt;/code&gt; Д. С t в качестве потока, вместо этого отправляется в стандартные дескрипторы Emacs в пакетном режиме: &lt;code&gt;message&lt;/code&gt; записывается в стандартный дескриптор ошибки, тогда как &lt;code&gt;prin1&lt;/code&gt; и другие функции печати записывают в стандартный вывод. Точно так же ввод, который обычно поступает из минибуфера, читается из стандартного дескриптора ввода. Таким образом, Emacs ведет себя как неинтерактивная прикладная программа. (Вывод эхо-области, который обычно генерирует сам Emacs, например, эхо-сигнал команды, полностью подавляется.)</target>
        </trans-unit>
        <trans-unit id="050f2a1f992936a9f3bd70f97c3df722975a4ffc" translate="yes" xml:space="preserve">
          <source>Any buffer which does not specify values for these variables uses the values specified by the &lt;code&gt;left-fringe&lt;/code&gt; and &lt;code&gt;right-fringe&lt;/code&gt; frame parameters (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;).</source>
          <target state="translated">Любой буфер, который не задает значения для этих переменных, использует значения, заданные параметрами &lt;code&gt;left-fringe&lt;/code&gt; и &lt;code&gt;right-fringe&lt;/code&gt; (см. &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Параметры макета&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd492b9bb3754cde03d33417c72155f2cdb192d7" translate="yes" xml:space="preserve">
          <source>Any conditional construct can be expressed with &lt;code&gt;cond&lt;/code&gt; or with &lt;code&gt;if&lt;/code&gt;. Therefore, the choice between them is a matter of style. For example:</source>
          <target state="translated">Любая условная конструкция может быть выражена с помощью &lt;code&gt;cond&lt;/code&gt; или &lt;code&gt;if&lt;/code&gt; . Поэтому выбор между ними - дело стиля. Например:</target>
        </trans-unit>
        <trans-unit id="6a06364a7a0a952bf465c39928bf99f3f61b0422" translate="yes" xml:space="preserve">
          <source>Any connection profile of &lt;var&gt;profiles&lt;/var&gt; must have been already defined by &lt;code&gt;connection-local-set-profile-variables&lt;/code&gt;.</source>
          <target state="translated">Любой профиль соединения &lt;var&gt;profiles&lt;/var&gt; должен быть уже определен &lt;code&gt;connection-local-set-profile-variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a92544790b0c628c4a67c0d9ad0654a8710429c7" translate="yes" xml:space="preserve">
          <source>Any function or macro defined as Lisp code may be set to break on entry, regardless of whether it is interpreted code or compiled code. If the function is a command, it will enter the debugger when called from Lisp and when called interactively (after the reading of the arguments). You can also set debug-on-entry for primitive functions (i.e., those written in C) this way, but it only takes effect when the primitive is called from Lisp code. Debug-on-entry is not allowed for special forms.</source>
          <target state="translated">Любая функция или макрос,определенный как код Lisp,может быть настроен на разрыв при вводе,независимо от того,интерпретируется ли он кодом или компилируется.Если функция является командой,она будет вводиться в отладчик при вызове из Lisp и при интерактивном вызове (после чтения аргументов).Таким же образом можно установить отладку на вход для примитивных функций (т.е.тех,что написаны на Си),но она вступает в силу только при вызове примитива из кода на языке Lisp.Для специальных форм отладка не допускается.</target>
        </trans-unit>
        <trans-unit id="8638b648157581df0efb6302834ee2f03492764d" translate="yes" xml:space="preserve">
          <source>Any integer glyph code greater than or equal to the length of the glyph table is displayed literally.</source>
          <target state="translated">Любой целочисленный глиф-код,превышающий или равный длине глиф-таблицы,отображается буквально.</target>
        </trans-unit>
        <trans-unit id="4c6a27c6563d69b7aca82f351f60298b13184203" translate="yes" xml:space="preserve">
          <source>Any kind of Lisp code is valid inside &lt;var&gt;body&lt;/var&gt;, but &lt;code&gt;iter-yield&lt;/code&gt; and &lt;code&gt;iter-yield-from&lt;/code&gt; cannot appear inside &lt;code&gt;unwind-protect&lt;/code&gt; forms.</source>
          <target state="translated">Любой вид кода Lisp допустим внутри &lt;var&gt;body&lt;/var&gt; , но &lt;code&gt;iter-yield&lt;/code&gt; и &lt;code&gt;iter-yield-from&lt;/code&gt; не могут появляться внутри форм &lt;code&gt;unwind-protect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4fc7cbf2349da81499a5258b7f6c62e471e0a86" translate="yes" xml:space="preserve">
          <source>Any of the above window elements (except &lt;code&gt;text&lt;/code&gt;) can also be used with &lt;code&gt;:align-to&lt;/code&gt; to specify that the position is relative to the left edge of the given area. Once the base offset for a relative position has been set (by the first occurrence of one of these symbols), further occurrences of these symbols are interpreted as the width of the specified area. For example, to align to the center of the left-margin, use</source>
          <target state="translated">Любой из вышеперечисленных оконных элементов (кроме &lt;code&gt;text&lt;/code&gt; ) также можно использовать с &lt;code&gt;:align-to&lt;/code&gt; , чтобы указать, что позиция находится относительно левого края данной области. После того, как базовое смещение для относительного положения было установлено (по первому появлению одного из этих символов), дальнейшие появления этих символов интерпретируются как ширина указанной области. Например, чтобы выровнять по центру левого поля, используйте</target>
        </trans-unit>
        <trans-unit id="947bbfa4cfb925a66b42d553b356034e0c632a8d" translate="yes" xml:space="preserve">
          <source>Any of these arguments can be given to identify the process that is to be configured. If none of these arguments is given, the current buffer&amp;rsquo;s process is used.</source>
          <target state="translated">Любой из этих аргументов может быть использован для идентификации процесса, который необходимо настроить. Если ни один из этих аргументов не указан, используется процесс текущего буфера.</target>
        </trans-unit>
        <trans-unit id="d761e83aca259b6c169b8f0ba443733debb02169" translate="yes" xml:space="preserve">
          <source>Any other character following &amp;lsquo;</source>
          <target state="translated">Любой другой персонаж, следующий за '</target>
        </trans-unit>
        <trans-unit id="8b9b2ed191d1fda99979a3c9c2769788ca05c905" translate="yes" xml:space="preserve">
          <source>Any other format character results in an &amp;lsquo;</source>
          <target state="translated">Любой другой символ формата приводит к '</target>
        </trans-unit>
        <trans-unit id="da32c3cdd65afe4fd7df1698891716e553030ff9" translate="yes" xml:space="preserve">
          <source>Any other keyword arguments are passed directly to the &lt;code&gt;defcustom&lt;/code&gt; generated for the variable &lt;var&gt;mode&lt;/var&gt;.</source>
          <target state="translated">Любые другие аргументы ключевого слова передаются непосредственно в &lt;code&gt;defcustom&lt;/code&gt; , сгенерированный для &lt;var&gt;mode&lt;/var&gt; переменной .</target>
        </trans-unit>
        <trans-unit id="a9dd7d9e5f6c66323cdba5127ceece8bda299da3" translate="yes" xml:space="preserve">
          <source>Any other kind of property value is a height spec, which translates into a number&amp;mdash;the specified line height. There are several ways to write a height spec; here&amp;rsquo;s how each of them translates into a number:</source>
          <target state="translated">Любой другой вид значения свойства - это спецификация высоты, которая переводится в число - указанную высоту строки. Есть несколько способов написать спецификацию высоты; вот как каждое из них переводится в число:</target>
        </trans-unit>
        <trans-unit id="80c9ec34ade8e4048b77d042cf2894fc4d219cf7" translate="yes" xml:space="preserve">
          <source>Any other list is a &lt;em&gt;sublist specification&lt;/em&gt; and the argument must be a list whose elements match the specification &lt;var&gt;elements&lt;/var&gt;.</source>
          <target state="translated">Любой другой список является &lt;em&gt;спецификацией Подсписка&lt;/em&gt; и аргумент должен быть списком, элементы которого соответствуют спецификациям &lt;var&gt;elements&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="efc5f087f8ebb1db404013a2d9b97f161e290782" translate="yes" xml:space="preserve">
          <source>Any other non-&lt;code&gt;nil&lt;/code&gt; value means to resize minibuffer-only frames by calling &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;).</source>
          <target state="translated">Любое другое значение, отличное от &lt;code&gt;nil&lt;/code&gt; , означает изменение размера фреймов только в минибуфере путем вызова &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (см. &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Изменение размера окна&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="de1dca44c2e30439c9ac0151a01ef3eee3bfac38" translate="yes" xml:space="preserve">
          <source>Any other non-&lt;code&gt;nil&lt;/code&gt; value means to select a window instantaneously as soon as the mouse pointer enters it.</source>
          <target state="translated">Любое другое значение, отличное от &lt;code&gt;nil&lt;/code&gt; , означает мгновенный выбор окна, как только указатель мыши входит в него.</target>
        </trans-unit>
        <trans-unit id="e871933984652498dd2af321ce39af05be929b56" translate="yes" xml:space="preserve">
          <source>Any other symbol in a specification list may be a predicate or an indirect specification.</source>
          <target state="translated">Любой другой символ в списке спецификаций может быть предикатной или косвенной спецификацией.</target>
        </trans-unit>
        <trans-unit id="dbbabe65f60d7295c7911e33efd55bcf43789dbf" translate="yes" xml:space="preserve">
          <source>Any other value for &lt;var&gt;order&lt;/var&gt; removes the numeric order of &lt;var&gt;element&lt;/var&gt; if it already has one; otherwise, it is equivalent to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Любое другое значение для &lt;var&gt;order&lt;/var&gt; удаляет числовой порядок &lt;var&gt;element&lt;/var&gt; если он уже есть; в противном случае это эквивалентно &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8680b4e68cce538925a1e5ee144f0189a305515f" translate="yes" xml:space="preserve">
          <source>Any other value means consider windows on the selected frame.</source>
          <target state="translated">Любое другое значение означает рассмотрение окон на выбранной рамке.</target>
        </trans-unit>
        <trans-unit id="15b4bce70cfe3f06b7b1a2f9ed3099030510e5dc" translate="yes" xml:space="preserve">
          <source>Any other value means to try iconifying the child frame. Since such an attempt may not be honored by all window managers and can even lead to making the child frame unresponsive to user actions, the default is to iconify the top level frame instead.</source>
          <target state="translated">Любое другое значение означает,что нужно попробовать иконку с дочерней рамкой.Так как такая попытка может быть выполнена не всеми оконными менеджерами и даже может привести к тому,что дочерний фрейм не будет реагировать на действия пользователя,по умолчанию вместо этого используется иконка фрейма верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="ebda99dde61c93e02da1a43ffb05fdba89a8d98e" translate="yes" xml:space="preserve">
          <source>Any other value of &lt;var&gt;require-match&lt;/var&gt; behaves like &lt;code&gt;t&lt;/code&gt;, except that the exit commands won&amp;rsquo;t exit if it performs completion.</source>
          <target state="translated">Любое другое значение &lt;var&gt;require-match&lt;/var&gt; ведет себя как &lt;code&gt;t&lt;/code&gt; , за исключением того, что команды выхода не завершаются, если выполняется завершение.</target>
        </trans-unit>
        <trans-unit id="86b521e158439e11f2ef9516804d10581a8219f2" translate="yes" xml:space="preserve">
          <source>Any parameters not mentioned in &lt;var&gt;parameters&lt;/var&gt; default to the values in the alist &lt;code&gt;default-frame-alist&lt;/code&gt; (see &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt;); parameters not specified there default from the X resources or its equivalent on your operating system (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;X Resources&lt;/a&gt; in</source>
          <target state="translated">Любые параметры, не упомянутые в &lt;var&gt;parameters&lt;/var&gt; умолчанию имеют значения в alist &lt;code&gt;default-frame-alist&lt;/code&gt; (см. &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Начальные параметры&lt;/a&gt; ); параметры, не указанные там, по умолчанию из ресурсов X или их эквивалента в вашей операционной системе (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;Ресурсы X&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="9860f00e606061647e41c129f0e0903be5e003a1" translate="yes" xml:space="preserve">
          <source>Any processes that have this buffer as the &lt;code&gt;process-buffer&lt;/code&gt; are sent the &lt;code&gt;SIGHUP&lt;/code&gt; (hangup) signal, which normally causes them to terminate. See &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Signals to Processes&lt;/a&gt;.</source>
          <target state="translated">Любые процессы, которые имеют этот буфер в качестве буфера &lt;code&gt;process-buffer&lt;/code&gt; , отправляют сигнал &lt;code&gt;SIGHUP&lt;/code&gt; (зависание), который обычно приводит к их завершению. См. &amp;laquo; &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Сигналы для процессов&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="545802d960c72afb533f784369e021b83a96956f" translate="yes" xml:space="preserve">
          <source>Any redisplay triggering the run of window change functions may be aborted. If the abort occurs before window change functions have run to their completion, they will be run again with the previous values, that is, as if redisplay had not been performed. If aborted later, they will be run with the new values, that is, as if redisplay had been actually performed.</source>
          <target state="translated">Любое повторное отображение,вызывающее запуск функций смены окон,может быть прервано.Если прерывание происходит до того,как функции смены окон завершат свою работу,то они будут снова запущены с предыдущими значениями,т.е.так,как будто повторное отображение не было выполнено.Если прерывание выполняется позже,то они запускаются с новыми значениями,то есть так,как если бы повторное отображение было выполнено на самом деле.</target>
        </trans-unit>
        <trans-unit id="7024b793b36bc3e3bb195637c26938af29b056cc" translate="yes" xml:space="preserve">
          <source>Any two distinct Lisp objects are different as keys.</source>
          <target state="translated">Любые два разных объекта Lisp отличаются друг от друга в качестве ключей.</target>
        </trans-unit>
        <trans-unit id="2402827e518f1d5fcdc03543bf7c6c4f8b5d7ef6" translate="yes" xml:space="preserve">
          <source>Any two regular expressions &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; can be concatenated. The result is a regular expression that matches a string if &lt;var&gt;a&lt;/var&gt; matches some amount of the beginning of that string and &lt;var&gt;b&lt;/var&gt; matches the rest of the string.</source>
          <target state="translated">Любые два регулярных выражения &lt;var&gt;a&lt;/var&gt; и &lt;var&gt;b&lt;/var&gt; можно объединить. Результатом является регулярное выражение, которое соответствует строке, если &lt;var&gt;a&lt;/var&gt; соответствует некоторому количеству начала этой строки, а &lt;var&gt;b&lt;/var&gt; соответствует остальной части строки.</target>
        </trans-unit>
        <trans-unit id="45ffc4ae2f26e287178694c6132c38fe72023bb0" translate="yes" xml:space="preserve">
          <source>Any unhandled errors while loading a file terminate loading. If the load was done for the sake of &lt;code&gt;autoload&lt;/code&gt;, any function definitions made during the loading are undone.</source>
          <target state="translated">Любые необработанные ошибки при загрузке файла прекращают загрузку. Если загрузка была произведена ради &lt;code&gt;autoload&lt;/code&gt; , любые определения функций, сделанные во время загрузки, отменяются.</target>
        </trans-unit>
        <trans-unit id="1ceb1e23a710f2ab6b34678613c9db79937409cd" translate="yes" xml:space="preserve">
          <source>Any variable whose name has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;risky-local-variable&lt;/code&gt; property is considered risky. When you define a user option using &lt;code&gt;defcustom&lt;/code&gt;, you can set its &lt;code&gt;risky-local-variable&lt;/code&gt; property by adding the arguments &lt;code&gt;:risky &lt;var&gt;value&lt;/var&gt;&lt;/code&gt; to &lt;code&gt;defcustom&lt;/code&gt; (see &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Variable Definitions&lt;/a&gt;). In addition, any variable whose name ends in any of &amp;lsquo;</source>
          <target state="translated">Любая переменная, имя которой имеет &lt;code&gt;nil&lt;/code&gt; свойство &lt;code&gt;risky-local-variable&lt;/code&gt; риска, считается рискованной. При определении параметра пользователя с помощью &lt;code&gt;defcustom&lt;/code&gt; , вы можете установить его &lt;code&gt;risky-local-variable&lt;/code&gt; свойство, добавив аргументы &lt;code&gt;:risky &lt;var&gt;value&lt;/var&gt;&lt;/code&gt; для &lt;code&gt;defcustom&lt;/code&gt; (см &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Определения переменного&lt;/a&gt; ). Кроме того, любая переменная, имя которой заканчивается на любую из '</target>
        </trans-unit>
        <trans-unit id="2146f7db0997563acb7fa242e2c3506c43699f4a" translate="yes" xml:space="preserve">
          <source>Anything else means to consider windows on &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame, and no others.</source>
          <target state="translated">Все остальное означает рассматривать окна в рамке &lt;var&gt;window&lt;/var&gt; и никакие другие.</target>
        </trans-unit>
        <trans-unit id="ed179d7c24b9f78db2acddd1c26cf5d5e3a10309" translate="yes" xml:space="preserve">
          <source>Apart from Fundamental mode, there are three major modes that other major modes commonly derive from: Text mode, Prog mode, and Special mode. While Text mode is useful in its own right (e.g., for editing files ending in</source>
          <target state="translated">Кроме Фундаментального режима,существуют три основных режима,из которых обычно исходят другие основные режимы:Текстовый режим,Прог-режим и Специальный режим.Текстовый режим полезен сам по себе (например,для редактирования файлов,заканчивающихся на</target>
        </trans-unit>
        <trans-unit id="d92f266ff96117cb3b55d3ff2938ee734d58418c" translate="yes" xml:space="preserve">
          <source>Apart from the above usual keymaps, Emacs provides special ways for programs to make other keymaps active. Firstly, the variable &lt;code&gt;overriding-local-map&lt;/code&gt; specifies a keymap that replaces the usual active keymaps, except for the global keymap. Secondly, the terminal-local variable &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; specifies a keymap that takes precedence over &lt;em&gt;all&lt;/em&gt; other keymaps (including &lt;code&gt;overriding-local-map&lt;/code&gt;); this is normally used for modal/transient keybindings (the function &lt;code&gt;set-transient-map&lt;/code&gt; provides a convenient interface for this). See &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;, for details.</source>
          <target state="translated">Помимо описанных выше обычных раскладок клавиш, Emacs предоставляет программам особые способы сделать другие раскладки активными. Во-первых, переменная &lt;code&gt;overriding-local-map&lt;/code&gt; определяет раскладку клавиатуры, которая заменяет обычные активные раскладки клавиатуры, за исключением глобальной раскладки клавиатуры. Во-вторых, локальная переменная &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; определяет таблицу ключей, которая имеет приоритет над &lt;em&gt;всеми&lt;/em&gt; другими таблицами клавиш (включая &lt;code&gt;overriding-local-map&lt;/code&gt; ); это обычно используется для модальных / временных привязок клавиш (функция &lt;code&gt;set-transient-map&lt;/code&gt; предоставляет удобный интерфейс для этого). Подробнее см. &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Управление активными картами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a68119502a0311abd68d0719c5b77a5911c9e84f" translate="yes" xml:space="preserve">
          <source>Apart from the functions documented in this section, you can print Lisp objects to the echo area by specifying &lt;code&gt;t&lt;/code&gt; as the output stream. See &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;Output Streams&lt;/a&gt;.</source>
          <target state="translated">Помимо функций, описанных в этом разделе, вы можете печатать объекты Lisp в эхо-области, указав &lt;code&gt;t&lt;/code&gt; как выходной поток. Смотрите &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;выходные потоки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cd2802aef7e489fd6909738c550b3b9f5ec028d" translate="yes" xml:space="preserve">
          <source>Apart from the values given below, each face attribute can have the value &lt;code&gt;unspecified&lt;/code&gt;. This special value means that the face doesn&amp;rsquo;t specify that attribute directly. An &lt;code&gt;unspecified&lt;/code&gt; attribute tells Emacs to refer instead to a parent face (see the description &lt;code&gt;:inherit&lt;/code&gt; attribute below); or, failing that, to an underlying face (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). The &lt;code&gt;default&lt;/code&gt; face must specify all attributes.</source>
          <target state="translated">Помимо значений, указанных ниже, каждый атрибут лица может иметь &lt;code&gt;unspecified&lt;/code&gt; значение . Это специальное значение означает, что лицо не указывает этот атрибут напрямую. &lt;code&gt;unspecified&lt;/code&gt; атрибут указывает Emacs вместо того, чтобы обратиться к родительскому лица (см описание &lt;code&gt;:inherit&lt;/code&gt; атрибута ниже); или, в противном случае, к нижележащему лицу (см. &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Отображение лиц&lt;/a&gt; ). На грани по &lt;code&gt;default&lt;/code&gt; должны быть указаны все атрибуты.</target>
        </trans-unit>
        <trans-unit id="f240948e5698f084e306e2f0433d5215c7e9dc03" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;child&lt;/var&gt; as the last child of &lt;var&gt;node&lt;/var&gt;.</source>
          <target state="translated">Добавить &lt;var&gt;child&lt;/var&gt; элемент в качестве последнего дочернего элемента &lt;var&gt;node&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="6453a2437bbdcb5f8fffb150dbc05d248106b629" translate="yes" xml:space="preserve">
          <source>Applications should put a function on this hook only if they want to react to changes that happened on (or have been signaled for) two or more frames since last redisplay. In every other case, putting the function on &lt;code&gt;window-state-change-functions&lt;/code&gt; should be preferred.</source>
          <target state="translated">Приложения должны помещать функцию в эту ловушку только в том случае, если они хотят реагировать на изменения, которые произошли (или были зарегистрированы) два или более кадров с момента последнего повторного отображения. В любом другом случае предпочтительнее поместить функцию в функции &lt;code&gt;window-state-change-functions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26de2593285b5ae9fccf013cfbb25224e0f5a299" translate="yes" xml:space="preserve">
          <source>Applying Customizations</source>
          <target state="translated">Применение настроек</target>
        </trans-unit>
        <trans-unit id="36aa9251a3a7a8564f2137c662428024f6ade2c8" translate="yes" xml:space="preserve">
          <source>Applying a function to each element of a list, etc.</source>
          <target state="translated">Применение функции к каждому элементу списка и т.д.</target>
        </trans-unit>
        <trans-unit id="8d1feffaedb79bbeb47768ea8d15131f798d1c88" translate="yes" xml:space="preserve">
          <source>Arbitrary text, read in the minibuffer and returned as a string (see &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Text from Minibuffer&lt;/a&gt;). Terminate the input with either</source>
          <target state="translated">Произвольный текст, читаемый в минибуфере и возвращаемый в виде строки (см. &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Текст из минибуфера&lt;/a&gt; ). Завершите ввод одним из</target>
        </trans-unit>
        <trans-unit id="7d9f86d28b0c0c91c1eb18ed796eb1ba12533f22" translate="yes" xml:space="preserve">
          <source>Arbitrary text, read in the minibuffer using the current buffer&amp;rsquo;s input method, and returned as a string (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Input-Methods.html#Input-Methods&quot;&gt;Input Methods&lt;/a&gt; in</source>
          <target state="translated">Произвольный текст, читаемый в минибуфере с использованием метода ввода текущего буфера и возвращаемый в виде строки (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Input-Methods.html#Input-Methods&quot;&gt;Методы ввода&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="bd4951fd6a7c3feab0f23a3cd32635bc99258318" translate="yes" xml:space="preserve">
          <source>Args out of range</source>
          <target state="translated">Арги вне зоны досягаемости</target>
        </trans-unit>
        <trans-unit id="0c474d136d838c73efef53606031eb17d140e04e" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;literal&lt;/code&gt; and &lt;code&gt;regexp&lt;/code&gt; forms in &lt;var&gt;rx-expr&lt;/var&gt; must be string literals.</source>
          <target state="translated">Аргументы для форм &lt;code&gt;literal&lt;/code&gt; и &lt;code&gt;regexp&lt;/code&gt; в &lt;var&gt;rx-expr&lt;/var&gt; должны быть строковыми литералами.</target>
        </trans-unit>
        <trans-unit id="067d717a61de8fed36456114a24a52f9975bc09e" translate="yes" xml:space="preserve">
          <source>Arithmetic Operations</source>
          <target state="translated">арифметические действия</target>
        </trans-unit>
        <trans-unit id="e9ba134322b748a6c1b2b91140e83920bb3352f8" translate="yes" xml:space="preserve">
          <source>Arithmetic error</source>
          <target state="translated">арифметическая ошибка</target>
        </trans-unit>
        <trans-unit id="11d55c8ac9f9031983e49487cf4e01cc836699f5" translate="yes" xml:space="preserve">
          <source>Arithmetic overflow error</source>
          <target state="translated">ошибка арифметического переполнения</target>
        </trans-unit>
        <trans-unit id="d11aaaa37e2311485d3875fbb3013fe0f23d4b0b" translate="yes" xml:space="preserve">
          <source>Around advice such as:</source>
          <target state="translated">Круглый совет,например:</target>
        </trans-unit>
        <trans-unit id="41fcc6cba3496dc0275b2af2eceda84dfb41da3d" translate="yes" xml:space="preserve">
          <source>Arrange to scan these files when producing the</source>
          <target state="translated">Упорядочить сканирование этих файлов при создании</target>
        </trans-unit>
        <trans-unit id="5a208284047f94a448814865ab5ceb940cbbaf32" translate="yes" xml:space="preserve">
          <source>Arranging to run a cleanup form if an error happens.</source>
          <target state="translated">Упорядочение запуска формы очистки в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="238a5476b2b099dbf0d0f2fd0cf448d18972ec8a" translate="yes" xml:space="preserve">
          <source>Array Type</source>
          <target state="translated">Тип массива</target>
        </trans-unit>
        <trans-unit id="73e54889ed8e57216f0ca1581847b9782331ae4c" translate="yes" xml:space="preserve">
          <source>Array, a fixed-size set of Lisp objects which may be accessed by an index.</source>
          <target state="translated">Массив-набор объектов Lisp фиксированного размера,к которым можно получить доступ с помощью индекса.</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="081ca36507218ed52666e78775654403a5cbd1aa" translate="yes" xml:space="preserve">
          <source>Arrays are fixed-length sequences. They are further subdivided into strings, vectors, char-tables and bool-vectors. Vectors can hold elements of any type, whereas string elements must be characters, and bool-vector elements must be &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. Char-tables are like vectors except that they are indexed by any valid character code. The characters in a string can have text properties like characters in a buffer (see &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;), but vectors do not support text properties, even when their elements happen to be characters.</source>
          <target state="translated">Массивы представляют собой последовательности фиксированной длины. Далее они подразделяются на строки, векторы, таблицы символов и векторы типа bool. Векторы могут содержать элементы любого типа, тогда как строковые элементы должны быть символами, а элементы bool-vector должны иметь значение &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;nil&lt;/code&gt; . Таблицы символов похожи на векторы, за исключением того, что они индексируются любым допустимым кодом символа. Символы в строке могут иметь свойства текста, такие как символы в буфере (см. &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Свойства текста&lt;/a&gt; ), но векторы не поддерживают свойства текста, даже если их элементы являются символами.</target>
        </trans-unit>
        <trans-unit id="ce9ceca356ae903e8b84ce8876d693efd3ec5212" translate="yes" xml:space="preserve">
          <source>Arrays include strings and vectors.</source>
          <target state="translated">Массивы включают в себя строки и векторы.</target>
        </trans-unit>
        <trans-unit id="2a256f62beeee99618180946ede4c7802661b91b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;lsh&lt;/code&gt; behaves like &lt;code&gt;ash&lt;/code&gt; except when &lt;var&gt;integer1&lt;/var&gt; and &lt;var&gt;count1&lt;/var&gt; are both negative, the following examples focus on these exceptional cases. These examples assume 30-bit fixnums.</source>
          <target state="translated">Поскольку &lt;code&gt;lsh&lt;/code&gt; ведет себя как &lt;code&gt;ash&lt;/code&gt; , за исключением случаев, когда &lt;var&gt;integer1&lt;/var&gt; и &lt;var&gt;count1&lt;/var&gt; отрицательны, следующие примеры сосредоточены на этих исключительных случаях. Эти примеры предполагают 30-битные фиксированные числа.</target>
        </trans-unit>
        <trans-unit id="85514a867e7a20560268b28853e86e5aa494f0b6" translate="yes" xml:space="preserve">
          <source>As a &amp;lsquo;</source>
          <target state="translated">Как '</target>
        </trans-unit>
        <trans-unit id="06830ace04b31c9ec49e44f925889f374b949f5a" translate="yes" xml:space="preserve">
          <source>As a final step, before returning the chosen coding system, &lt;code&gt;select-safe-coding-system&lt;/code&gt; checks whether that coding system is consistent with what would be selected if the contents of the region were read from a file. (If not, this could lead to data corruption in a file subsequently re-visited and edited.) Normally, &lt;code&gt;select-safe-coding-system&lt;/code&gt; uses &lt;code&gt;buffer-file-name&lt;/code&gt; as the file for this purpose, but if &lt;var&gt;file&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it uses that file instead (this can be relevant for &lt;code&gt;write-region&lt;/code&gt; and similar functions). If it detects an apparent inconsistency, &lt;code&gt;select-safe-coding-system&lt;/code&gt; queries the user before selecting the coding system.</source>
          <target state="translated">В качестве последнего шага, перед возвратом выбранной системы кодирования, &lt;code&gt;select-safe-coding-system&lt;/code&gt; проверяет, согласуется ли эта система кодирования с тем, что было бы выбрано, если бы содержимое области было прочитано из файла. (В противном случае это может привести к повреждению данных в файле, который впоследствии будет повторно посещен и отредактирован.) Обычно система &lt;code&gt;select-safe-coding-system&lt;/code&gt; использует для этой цели &lt;code&gt;buffer-file-name&lt;/code&gt; в качестве файла, но если &lt;var&gt;file&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , вместо этого он использует этот файл (это может быть актуально для &lt;code&gt;write-region&lt;/code&gt; и подобных функций). Если обнаруживается явное несоответствие, &lt;code&gt;select-safe-coding-system&lt;/code&gt; запрашивает пользователя перед выбором системы кодирования.</target>
        </trans-unit>
        <trans-unit id="8347ee4e8693c87255357e7f5883850b386cce75" translate="yes" xml:space="preserve">
          <source>As a general recommendation, try to avoid using &lt;code&gt;looking-back&lt;/code&gt; wherever possible, since it is slow. For this reason, there are no plans to add a &lt;code&gt;looking-back-p&lt;/code&gt; function.</source>
          <target state="translated">В качестве общей рекомендации старайтесь по возможности избегать использования &lt;code&gt;looking-back&lt;/code&gt; анализа, поскольку он медленный. По этой причине не планируется добавлять функцию &lt;code&gt;looking-back-p&lt;/code&gt; анализа.</target>
        </trans-unit>
        <trans-unit id="082ed7d43ef6ed77537415a322f89e49796457df" translate="yes" xml:space="preserve">
          <source>As a historical accident, &lt;var&gt;position&lt;/var&gt; was implemented inconsistently in different functions. In &lt;code&gt;completing-read&lt;/code&gt;, &lt;var&gt;position&lt;/var&gt;&amp;rsquo;s value is interpreted as origin-zero; that is, a value of 0 means the beginning of the string, 1 means after the first character, etc. In &lt;code&gt;read-minibuffer&lt;/code&gt;, and the other non-completion minibuffer input functions that support this argument, 1 means the beginning of the string, 2 means after the first character, etc.</source>
          <target state="translated">Как историческая случайность, &lt;var&gt;position&lt;/var&gt; в разных функциях реализовывалась непоследовательно. В &lt;code&gt;completing-read&lt;/code&gt; , &lt;var&gt;position&lt;/var&gt; значение &amp;laquo;ы интерпретируются как происхождение от нуля; то есть значение 0 означает начало строки, 1 означает после первого символа и т.д. В &lt;code&gt;read-minibuffer&lt;/code&gt; и других незавершенных функциях ввода минибуфера, которые поддерживают этот аргумент, 1 означает начало строки, 2 означает после первого символа и т. Д.</target>
        </trans-unit>
        <trans-unit id="4294650896b83fd9e5d4be93d12e4c592d4f0ccc" translate="yes" xml:space="preserve">
          <source>As a practical matter, if you are writing text for other people to read, you should set &lt;code&gt;fill-column&lt;/code&gt; to no more than 70. Otherwise the line will be too long for people to read comfortably, and this can make the text seem clumsy.</source>
          <target state="translated">На практике, если вы пишете текст для чтения другими людьми, вам следует установить &lt;code&gt;fill-column&lt;/code&gt; равным не более 70. В противном случае строка будет слишком длинной, чтобы людям было удобно читать, и это может сделать текст неуклюжим.</target>
        </trans-unit>
        <trans-unit id="bb4aaf8789bdd2420621e991adcf2190aa28b7df" translate="yes" xml:space="preserve">
          <source>As a result, it is currently not possible to represent the character</source>
          <target state="translated">В результате,в настоящее время невозможно изобразить персонаж</target>
        </trans-unit>
        <trans-unit id="b5eb1265a3a71f4ed8bb8ff9aa6033bf57cae934" translate="yes" xml:space="preserve">
          <source>As a rule, the inner frame is subdivided into the frame&amp;rsquo;s root window (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) and the frame&amp;rsquo;s minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;). There are two notable exceptions to this rule: A &lt;em&gt;minibuffer-less frame&lt;/em&gt; contains a root window only and does not contain a minibuffer window. A &lt;em&gt;minibuffer-only frame&lt;/em&gt; contains only a minibuffer window which also serves as that frame&amp;rsquo;s root window. See &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt; for how to create such frame configurations.</source>
          <target state="translated">Как правило, внутренний фрейм подразделяется на корневое окно фрейма (см. &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Окна и фреймы&lt;/a&gt; ) и окно минибуфера фрейма (см. &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Окна минибуфера&lt;/a&gt; ). Из этого правила есть два заметных исключения: &lt;em&gt;кадр без минибуфера&lt;/em&gt; содержит только корневое окно и не содержит окно минибуфера. &lt;em&gt;Минибуфер только кадр&lt;/em&gt; содержит только окно минибуфера , который также служит в качестве корневого окна этого фрейма. См. Раздел &amp;laquo; &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Начальные параметры&amp;raquo;,&lt;/a&gt; чтобы узнать, как создавать такие конфигурации рамы.</target>
        </trans-unit>
        <trans-unit id="7658703b932157d4e051dbdce1277e8475ac36f2" translate="yes" xml:space="preserve">
          <source>As a side effect, backups are necessarily made by copying. See &lt;a href=&quot;rename-or-copy#Rename-or-Copy&quot;&gt;Rename or Copy&lt;/a&gt;. Yet, at the same time, saving a precious file always breaks all hard links between the file you save and other file names.</source>
          <target state="translated">Как побочный эффект, резервные копии обязательно делаются путем копирования. См. &lt;a href=&quot;rename-or-copy#Rename-or-Copy&quot;&gt;Переименование или Копирование&lt;/a&gt; . Но в то же время при сохранении ценного файла всегда прерываются все жесткие связи между сохраняемым файлом и другими именами файлов.</target>
        </trans-unit>
        <trans-unit id="c897a9ef1100434cc7715e3fbb47fdb7454824de" translate="yes" xml:space="preserve">
          <source>As a simple example, we can concatenate the regular expressions &amp;lsquo;</source>
          <target state="translated">В качестве простого примера мы можем объединить регулярные выражения '</target>
        </trans-unit>
        <trans-unit id="bc0e4551b2a377b6cea04f402200bc2b67248275" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;next&lt;/code&gt; of a frame&amp;rsquo;s root window points to the frame&amp;rsquo;s minibuffer window, provided this is not a minibuffer-only or minibuffer-less frame. On such frames &lt;code&gt;prev&lt;/code&gt; of the minibuffer window points to that frame&amp;rsquo;s root window. In any other case, the root window&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; and the minibuffer window&amp;rsquo;s (if present) &lt;code&gt;prev&lt;/code&gt; fields are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В качестве особого случая &lt;code&gt;next&lt;/code&gt; из корневого окна фрейма указывает на окно минибуфера фрейма, при условии, что это не фрейм, состоящий только из минибуфера или без минибуфера. На таких кадрах &lt;code&gt;prev&lt;/code&gt; окна минибуфера указывает на корневое окно этого кадра. В любом другом случае, корневое окно &lt;code&gt;next&lt;/code&gt; и минибуфер окно (если существует) &lt;code&gt;prev&lt;/code&gt; поля являются &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="640b1e7193c0828a7e9c0e26231c2f3a2ad3a5f4" translate="yes" xml:space="preserve">
          <source>As a special case, a function may return with a different buffer current. Emacs takes this to mean that the current buffer contains altered text to be output. It therefore changes the &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; arguments of the &lt;code&gt;write-region&lt;/code&gt; call, giving them the values of &lt;code&gt;point-min&lt;/code&gt; and &lt;code&gt;point-max&lt;/code&gt; in the new buffer, respectively. It also discards all previous annotations, because they should have been dealt with by this function.</source>
          <target state="translated">В особом случае функция может возвращаться с другим током буфера. Emacs считает, что текущий буфер содержит измененный текст для вывода. Поэтому он изменяет &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; аргументы вызова &lt;code&gt;write-region&lt;/code&gt; , давая им значения &lt;code&gt;point-min&lt;/code&gt; и &lt;code&gt;point-max&lt;/code&gt; в новом буфере соответственно. Он также отбрасывает все предыдущие аннотации, потому что они должны были обрабатываться этой функцией.</target>
        </trans-unit>
        <trans-unit id="538f59aab9497ba8d48e55c2e55b2635fbda077a" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;cons-cell&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt;. Therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В особом случае, если &lt;var&gt;cons-cell&lt;/var&gt; равна &lt;code&gt;nil&lt;/code&gt; , эта функция возвращает &lt;code&gt;nil&lt;/code&gt; . Следовательно, любой список является допустимым аргументом. Об ошибке сообщается, если аргумент не является cons-ячейкой или &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e59f0605f808bdde6a150c85073aac9e660ad27" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;cons-cell&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt;; therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В особом случае, если &lt;var&gt;cons-cell&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , эта функция возвращает &lt;code&gt;nil&lt;/code&gt; ; следовательно, любой список является допустимым аргументом. Об ошибке сообщается, если аргумент не является cons-ячейкой или &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca7cece4ddf32f2b45c2031fd9e867d6b7889049" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;flag&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, &lt;var&gt;window&lt;/var&gt; becomes &lt;em&gt;strongly&lt;/em&gt; dedicated to its buffer. &lt;code&gt;set-window-buffer&lt;/code&gt; signals an error when the window it acts upon is strongly dedicated to its buffer and does not already display the buffer it is asked to display. Other functions do not treat &lt;code&gt;t&lt;/code&gt; differently from any non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">Как особый случай, если &lt;var&gt;flag&lt;/var&gt; равен &lt;code&gt;t&lt;/code&gt; , &lt;var&gt;window&lt;/var&gt; становится &lt;em&gt;строго&lt;/em&gt; выделенным для своего буфера. &lt;code&gt;set-window-buffer&lt;/code&gt; сигнализирует об ошибке, когда окно, с которым он работает, строго выделено для своего буфера и еще не отображает буфер, который его просят отобразить. Другие функции не обрабатывают &lt;code&gt;t&lt;/code&gt; иначе, чем любое &lt;code&gt;nil&lt;/code&gt; значение.</target>
        </trans-unit>
        <trans-unit id="4aced0063585f5b279a49199acec884cc3288ce9" translate="yes" xml:space="preserve">
          <source>As a special exception, the error symbol &lt;code&gt;quit&lt;/code&gt; does not have the condition &lt;code&gt;error&lt;/code&gt;, because quitting is not considered an error.</source>
          <target state="translated">В качестве особого исключения символ ошибки &lt;code&gt;quit&lt;/code&gt; не содержит условия &lt;code&gt;error&lt;/code&gt; , поскольку завершение работы не считается ошибкой.</target>
        </trans-unit>
        <trans-unit id="07d6ca82a5135dea4c0b8a8393dd8ef483c67bf7" translate="yes" xml:space="preserve">
          <source>As a technical detail, when &lt;var&gt;switches&lt;/var&gt; contains the long &amp;lsquo;</source>
          <target state="translated">В качестве технической детали, когда &lt;var&gt;switches&lt;/var&gt; содержат длинное '</target>
        </trans-unit>
        <trans-unit id="8f4f9b3b2bfdbcd1a575981570d572a49858acde" translate="yes" xml:space="preserve">
          <source>As a trivial example, here&amp;rsquo;s how to add advice that&amp;rsquo;ll modify the return value of a function every time it&amp;rsquo;s called:</source>
          <target state="translated">В качестве тривиального примера вот как добавить совет, который будет изменять возвращаемое значение функции при каждом ее вызове:</target>
        </trans-unit>
        <trans-unit id="b1f3d0120b8c51d503e5e5327b8ce35d598fd0fd" translate="yes" xml:space="preserve">
          <source>As always, there must be no possibility of intervening searches between the call to a search function and the call to &lt;code&gt;match-data&lt;/code&gt; that is intended to access the match data for that search.</source>
          <target state="translated">Как всегда, не должно быть возможности вмешиваться в поиски между вызовом функции поиска и вызовом &lt;code&gt;match-data&lt;/code&gt; которые предназначены для доступа к данным соответствия для этого поиска.</target>
        </trans-unit>
        <trans-unit id="1472e06e8a8fc0331e8821e03360d8c11b163707" translate="yes" xml:space="preserve">
          <source>As an alternative to the string-based syntax, Emacs provides the structured &lt;code&gt;rx&lt;/code&gt; notation based on Lisp S-expressions. This notation is usually easier to read, write and maintain than regexp strings, and can be indented and commented freely. It requires a conversion into string form since that is what regexp functions expect, but that conversion typically takes place during byte-compilation rather than when the Lisp code using the regexp is run.</source>
          <target state="translated">В качестве альтернативы синтаксису на основе строк Emacs предоставляет структурированную нотацию &lt;code&gt;rx&lt;/code&gt; , основанную на S-выражениях Lisp. Эту нотацию обычно легче читать, писать и поддерживать, чем строки регулярного выражения, и ее можно свободно изменять с отступом и комментировать. Он требует преобразования в строковую форму, поскольку именно этого ожидают функции регулярного выражения, но это преобразование обычно происходит во время байтовой компиляции, а не при запуске кода Лиспа, использующего регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="95b6d5f91746264f4dd9c82e53bfbbe800efcb96" translate="yes" xml:space="preserve">
          <source>As an example of &lt;code&gt;sort-subr&lt;/code&gt;, here is the complete function definition for &lt;code&gt;sort-lines&lt;/code&gt;:</source>
          <target state="translated">В качестве примера &lt;code&gt;sort-subr&lt;/code&gt; приведено полное определение функции для &lt;code&gt;sort-lines&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39d7c3afd50025e1aeeb3300312260fc1e12eaba" translate="yes" xml:space="preserve">
          <source>As an example, here is a sequence of &lt;code&gt;split-window&lt;/code&gt; calls that yields the window configuration discussed in &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;. This example demonstrates splitting a live window as well as splitting an internal window. We begin with a frame containing a single window (a live root window), which we denote by &lt;var&gt;W4&lt;/var&gt;. Calling &lt;code&gt;(split-window W4)&lt;/code&gt; yields this window configuration:</source>
          <target state="translated">В качестве примера приведем последовательность вызовов &lt;code&gt;split-window&lt;/code&gt; которая дает конфигурацию окна, обсуждаемую в разделе &amp;laquo; &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Окна и фреймы&amp;raquo;&lt;/a&gt; . Этот пример демонстрирует разделение живого окна, а также разделение внутреннего окна. Мы начинаем с кадра, содержащего одно окно (живое корневое окно), которое мы обозначаем &lt;var&gt;W4&lt;/var&gt; . Вызов &lt;code&gt;(split-window W4)&lt;/code&gt; дает такую ​​конфигурацию окна:</target>
        </trans-unit>
        <trans-unit id="3000460ba524b76305a7ac5b84a2be2cc384cf2b" translate="yes" xml:space="preserve">
          <source>As an example, here&amp;rsquo;s a simplified (and inefficient) version of the primitive function &lt;code&gt;next-single-char-property-change&lt;/code&gt; (see &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;). It searches forward from position &lt;var&gt;pos&lt;/var&gt; for the next position where the value of a given property &lt;code&gt;prop&lt;/code&gt;, as obtained from either overlays or text properties, changes.</source>
          <target state="translated">В качестве примера приведем упрощенную (и неэффективную) версию примитивной функции &lt;code&gt;next-single-char-property-change&lt;/code&gt; (см. &lt;a href=&quot;property-search#Property-Search&quot;&gt;Поиск свойств&lt;/a&gt; ). Он ищет вперед от позиции &lt;var&gt;pos&lt;/var&gt; к следующей позиции, где изменяется значение заданного свойства &lt;code&gt;prop&lt;/code&gt; , полученное из наложений или свойств текста.</target>
        </trans-unit>
        <trans-unit id="ac2005a3b3b773dfac881bf44c6dc9ffab49bfce" translate="yes" xml:space="preserve">
          <source>As an exception to the rule that a symbol&amp;rsquo;s name serves as its printed representation, &amp;lsquo;</source>
          <target state="translated">В качестве исключения из правила, согласно которому имя символа служит его печатным представлением, '</target>
        </trans-unit>
        <trans-unit id="2daa82fa454d2ab6dd7bfac54a9eefb51ae6ff85" translate="yes" xml:space="preserve">
          <source>As an exception, if you evaluate a &lt;code&gt;defface&lt;/code&gt; form with</source>
          <target state="translated">В качестве исключения, если вы оцениваете форму &lt;code&gt;defface&lt;/code&gt; с</target>
        </trans-unit>
        <trans-unit id="1a2d268c77084e31235d0ca81e4bd6ebfe990b03" translate="yes" xml:space="preserve">
          <source>As an exception, this function reads a file name using a graphical file dialog instead of the minibuffer, if all of the following are true:</source>
          <target state="translated">В порядке исключения,эта функция читает имя файла с помощью графического диалогового окна,а не минибуфера,если все нижеследующее верно:</target>
        </trans-unit>
        <trans-unit id="7f170945bb4b449cfc683c1ed37876c06db96463" translate="yes" xml:space="preserve">
          <source>As an obsolescent calling convention, this function can be given six or more arguments. The first six arguments &lt;var&gt;second&lt;/var&gt;, &lt;var&gt;minute&lt;/var&gt;, &lt;var&gt;hour&lt;/var&gt;, &lt;var&gt;day&lt;/var&gt;, &lt;var&gt;month&lt;/var&gt;, and &lt;var&gt;year&lt;/var&gt; specify most of the components of a decoded time. If there are more than six arguments the &lt;em&gt;last&lt;/em&gt; argument is used as &lt;var&gt;zone&lt;/var&gt; and any other extra arguments are ignored, so that &lt;code&gt;(apply
#'encode-time (decode-time ...))&lt;/code&gt; works. In this obsolescent convention, &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule (see &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Time Zone Rules&lt;/a&gt;), and &lt;var&gt;dst&lt;/var&gt; is treated as if it was -1.</source>
          <target state="translated">В качестве устаревшего соглашения о вызовах этой функции можно дать шесть или более аргументов. Первые шесть аргументов &lt;var&gt;second&lt;/var&gt; , &lt;var&gt;minute&lt;/var&gt; , &lt;var&gt;hour&lt;/var&gt; , &lt;var&gt;day&lt;/var&gt; , &lt;var&gt;month&lt;/var&gt; и &lt;var&gt;year&lt;/var&gt; определяют большинство компонентов декодированного времени. Если имеется более шести аргументов, &lt;em&gt;последний&lt;/em&gt; аргумент используется как &lt;var&gt;zone&lt;/var&gt; а любые другие дополнительные аргументы игнорируются, так что &lt;code&gt;(apply #'encode-time (decode-time ...))&lt;/code&gt; работает. В этом устаревшем соглашении для &lt;var&gt;zone&lt;/var&gt; умолчанию используется правило текущего часового пояса (см. &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Правила&lt;/a&gt; часовых поясов ), а &lt;var&gt;dst&lt;/var&gt; обрабатывается так, как если бы оно было -1.</target>
        </trans-unit>
        <trans-unit id="2491282a6d1f8281ac0fcd08cc3d8281fc7d632e" translate="yes" xml:space="preserve">
          <source>As editing continues, undo lists get longer and longer. To prevent them from using up all available memory space, garbage collection trims them back to size limits you can set. (For this purpose, the size of an undo list measures the cons cells that make up the list, plus the strings of deleted text.) Three variables control the range of acceptable sizes: &lt;code&gt;undo-limit&lt;/code&gt;, &lt;code&gt;undo-strong-limit&lt;/code&gt; and &lt;code&gt;undo-outer-limit&lt;/code&gt;. In these variables, size is counted as the number of bytes occupied, which includes both saved text and other data.</source>
          <target state="translated">По мере продолжения редактирования списки отмены становятся все длиннее и длиннее. Чтобы они не использовали все доступное пространство памяти, сборка мусора обрезает их до установленных вами ограничений по размеру. (Для этой цели размер списка отмены измеряет cons-ячейки, составляющие список, плюс строки удаленного текста.) Диапазон допустимых размеров регулируется тремя переменными: &lt;code&gt;undo-limit&lt;/code&gt; , &lt;code&gt;undo-strong-limit&lt;/code&gt; и &lt;code&gt;undo-outer-limit&lt;/code&gt; . В этих переменных размер рассчитывается как количество занятых байтов, которое включает как сохраненный текст, так и другие данные.</target>
        </trans-unit>
        <trans-unit id="39fc3a710f302293efc2b0bded9197ae640e963b" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;, Emacs can optionally enable lexical binding of variables. When lexical binding is enabled, any named function that you create (e.g., with &lt;code&gt;defun&lt;/code&gt;), as well as any anonymous function that you create using the &lt;code&gt;lambda&lt;/code&gt; macro or the &lt;code&gt;function&lt;/code&gt; special form or the &lt;code&gt;#'&lt;/code&gt; syntax (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), is automatically converted into a &lt;em&gt;closure&lt;/em&gt;.</source>
          <target state="translated">Как объяснялось в &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;разделе &amp;laquo;Область действия переменных&amp;raquo;&lt;/a&gt; , Emacs может дополнительно включать лексическое связывание переменных. Когда лексическая привязка включена, любая именованная функция, которую вы создаете (например, с &lt;code&gt;defun&lt;/code&gt; ), а также любая анонимная функция, которую вы создаете с помощью &lt;code&gt;lambda&lt;/code&gt; макроса, специальной формы &lt;code&gt;function&lt;/code&gt; или синтаксиса &lt;code&gt;#'&lt;/code&gt; (см. &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Анонимные функции&lt;/a&gt; ), автоматически преобразован в &lt;em&gt;закрытие&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="72d71c3cc374384e0af0a0724fbb040625e0c496" translate="yes" xml:space="preserve">
          <source>As far as &lt;code&gt;define-key&lt;/code&gt; is concerned, &lt;var&gt;item-string&lt;/var&gt; and &lt;var&gt;help-string&lt;/var&gt; are part of the event&amp;rsquo;s binding. However, &lt;code&gt;lookup-key&lt;/code&gt; returns just &lt;var&gt;real-binding&lt;/var&gt;, and only &lt;var&gt;real-binding&lt;/var&gt; is used for executing the key.</source>
          <target state="translated">Что касается &lt;code&gt;define-key&lt;/code&gt; , то, &lt;var&gt;item-string&lt;/var&gt; и &lt;var&gt;help-string&lt;/var&gt; являются частью мероприятия переплета. Однако &lt;code&gt;lookup-key&lt;/code&gt; возвращает только &lt;var&gt;real-binding&lt;/var&gt; , и только &lt;var&gt;real-binding&lt;/var&gt; используется для выполнения ключа.</target>
        </trans-unit>
        <trans-unit id="04371b35f248ca488e9627aecf5dda4a949a350a" translate="yes" xml:space="preserve">
          <source>As far as possible, new major modes should be derived, either directly or indirectly, from one of these three modes. One reason is that this allows users to customize a single mode hook (e.g., &lt;code&gt;prog-mode-hook&lt;/code&gt;) for an entire family of relevant modes (e.g., all programming language modes).</source>
          <target state="translated">Насколько это возможно, новые основные режимы должны происходить прямо или косвенно от одного из этих трех режимов. Одна из причин заключается в том, что это позволяет пользователям настраивать единственный режим (например, &lt;code&gt;prog-mode-hook&lt;/code&gt; ) для всего семейства соответствующих режимов (например, для всех режимов языка программирования).</target>
        </trans-unit>
        <trans-unit id="ff3ef6be607829903e8a6baac8628d90d56c089f" translate="yes" xml:space="preserve">
          <source>As far as the Lisp reader is concerned, &amp;lsquo;</source>
          <target state="translated">Что касается читателя Лиспа,</target>
        </trans-unit>
        <trans-unit id="c87e482a1ccf8205de796dac23a5ade838dbdd25" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;nil&lt;/code&gt;, but if</source>
          <target state="translated">Что касается &lt;code&gt;nil&lt;/code&gt; , но если</target>
        </trans-unit>
        <trans-unit id="e20b47eb8e540da13af46101ac4dc2b6a5827bfb" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;x-popup-menu&lt;/code&gt;, an element of the list may be just a string instead of a cons cell &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;. That makes a box that cannot be selected.</source>
          <target state="translated">Что касается &lt;code&gt;x-popup-menu&lt;/code&gt; , элемент списка может быть просто строкой, а не cons-ячейкой &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; . Это делает окно, которое нельзя выбрать.</target>
        </trans-unit>
        <trans-unit id="18f02bf364dcfbbb51fe785b93d6502cf175baf7" translate="yes" xml:space="preserve">
          <source>As in the previous example (see &lt;a href=&quot;#pcase_002dexample_002d1&quot;&gt;Example 1&lt;/a&gt;), &lt;code&gt;and&lt;/code&gt; begins with a &lt;code&gt;pred&lt;/code&gt; sub-pattern to ensure the following sub-patterns work with an object of the correct type (string, in this case). If &lt;code&gt;(stringp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;pred&lt;/code&gt; fails, and thus &lt;code&gt;and&lt;/code&gt; fails, too.</source>
          <target state="translated">Как и в предыдущем примере (см. &lt;a href=&quot;#pcase_002dexample_002d1&quot;&gt;Пример 1&lt;/a&gt; ), &lt;code&gt;and&lt;/code&gt; начинается с &lt;code&gt;pred&lt;/code&gt; , чтобы гарантировать, что следующие подшаблоны работают с объектом правильного типа (в данном случае строка). Если &lt;code&gt;(stringp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; , то &lt;code&gt;pred&lt;/code&gt; не работает, а значит, &lt;code&gt;and&lt;/code&gt; не работает.</target>
        </trans-unit>
        <trans-unit id="aca399bc248b6540182b97cdc8a6ceed399a0db7" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;code&gt;format&lt;/code&gt;, a format specification can include a width, which is a decimal number that appears after any flags. If a substitution contains fewer characters than its specified width, it is padded on the left:</source>
          <target state="translated">Как и в случае с &lt;code&gt;format&lt;/code&gt; , спецификация формата может включать ширину, которая представляет собой десятичное число, которое появляется после любых флагов. Если подстановка содержит меньше символов, чем указанная ширина, она дополняется слева:</target>
        </trans-unit>
        <trans-unit id="9007d393cbc677946e3b508fd46f178b4ffc51b8" translate="yes" xml:space="preserve">
          <source>As long as the selected window displays the current buffer, the window&amp;rsquo;s point and the buffer&amp;rsquo;s point always move together; they remain equal.</source>
          <target state="translated">Пока в выбранном окне отображается текущий буфер, точка окна и точка буфера всегда перемещаются вместе; они остаются равными.</target>
        </trans-unit>
        <trans-unit id="a4599968f503223a9b7899912e9301addb3f9878" translate="yes" xml:space="preserve">
          <source>As long as the value of &lt;code&gt;meta-prefix-char&lt;/code&gt; remains 27, key lookup translates</source>
          <target state="translated">Пока значение &lt;code&gt;meta-prefix-char&lt;/code&gt; остается 27, поиск по ключу переводит</target>
        </trans-unit>
        <trans-unit id="2403f847930ce8798404ebfea8bddc7017e3a7dd" translate="yes" xml:space="preserve">
          <source>As previously noted in this manual, a Lisp program is represented primarily by Lisp objects, and only secondarily as text. The textual form of a Lisp program is given by the read syntax of the Lisp objects that constitute the program. Hence, the textual form of a variable in a Lisp program is written using the read syntax for the symbol representing the variable.</source>
          <target state="translated">Как уже отмечалось ранее в данном руководстве,программа на языке Lisp представлена в основном объектами Lisp,и только во вторую очередь-текстом.Текстовая форма программы на языке Lisp задается прочитанным синтаксисом объектов Lisp,составляющих программу.Следовательно,текстовая форма переменной в программе на языке Lisp записывается с использованием синтаксиса чтения для символа,представляющего переменную.</target>
        </trans-unit>
        <trans-unit id="6c8a180c05fd7458e0ef38127404fa2fa9ac26b5" translate="yes" xml:space="preserve">
          <source>As previously noted, Emacs Lisp allows the same symbol to be defined both as a variable (e.g., with &lt;code&gt;defvar&lt;/code&gt;) and as a function or macro (e.g., with &lt;code&gt;defun&lt;/code&gt;). Such definitions do not conflict.</source>
          <target state="translated">Как отмечалось ранее, Emacs Lisp позволяет определять один и тот же символ как как переменную (например, с &lt;code&gt;defvar&lt;/code&gt; ), так и как функцию или макрос (например, с &lt;code&gt;defun&lt;/code&gt; ). Такие определения не противоречат друг другу.</target>
        </trans-unit>
        <trans-unit id="2a0ddcf1c50ca193923f438a27950fa2767aba7b" translate="yes" xml:space="preserve">
          <source>As the examples in this section illustrate, &lt;code&gt;format-spec&lt;/code&gt; is often used for selectively formatting an assortment of different pieces of information. This is useful in programs that provide user-customizable format strings, as the user can choose to format with a regular syntax and in any desired order only a subset of the information that the program makes available.</source>
          <target state="translated">Как показывают примеры в этом разделе, &lt;code&gt;format-spec&lt;/code&gt; часто используется для выборочного форматирования набора различных частей информации. Это полезно в программах, которые предоставляют настраиваемые пользователем строки формата, поскольку пользователь может выбрать форматирование с использованием обычного синтаксиса и в любом желаемом порядке только подмножество информации, которую программа делает доступной.</target>
        </trans-unit>
        <trans-unit id="fcae404ca40596bab0f46fcb1d1aebb078adf297" translate="yes" xml:space="preserve">
          <source>As the heap size increases, the time to perform a garbage collection increases. Thus, it can be desirable to do them less frequently in proportion.</source>
          <target state="translated">С увеличением размера кучи увеличивается время на сбор мусора.Таким образом,может быть желательно делать их реже в пропорциях.</target>
        </trans-unit>
        <trans-unit id="7e3df73939184a50a6120a14310b27d84575c14c" translate="yes" xml:space="preserve">
          <source>As the name implies, this function does not display any messages.</source>
          <target state="translated">Как следует из названия,эта функция не отображает никаких сообщений.</target>
        </trans-unit>
        <trans-unit id="e31d6bc3247e331efa29ece4c6b4b7ecd35823cc" translate="yes" xml:space="preserve">
          <source>As these examples show, you can use a form with a lambda expression as its &lt;small&gt;CAR&lt;/small&gt; to make local variables and give them values. In the old days of Lisp, this technique was the only way to bind and initialize local variables. But nowadays, it is clearer to use the special form &lt;code&gt;let&lt;/code&gt; for this purpose (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;). Lambda expressions are mainly used as anonymous functions for passing as arguments to other functions (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), or stored as symbol function definitions to produce named functions (see &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;).</source>
          <target state="translated">Как показывают эти примеры, вы можете использовать форму с лямбда-выражением в качестве &lt;small&gt;CAR&lt;/small&gt; для создания локальных переменных и присвоения им значений. В старые времена Лиспа этот метод был единственным способом привязать и инициализировать локальные переменные. Но в настоящее время для этой цели проще использовать специальную форму &lt;code&gt;let&lt;/code&gt; (см. &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Локальные переменные&lt;/a&gt; ). Лямбда-выражения в основном используются как анонимные функции для передачи в качестве аргументов другим функциям (см. &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Анонимные функции&lt;/a&gt; ) или сохраняются как определения символьных функций для создания именованных функций (см. &lt;a href=&quot;function-names#Function-Names&quot;&gt;Имена функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="37412dfde91c59b85070a1fa6f6188f685c97c7f" translate="yes" xml:space="preserve">
          <source>As you use this manual, we ask that you send corrections as soon as you find them. If you think of a simple, real life example for a function or group of functions, please make an effort to write it up and send it in. Please reference any comments to the node name and function or variable name, as appropriate. Also state the number of the edition you are criticizing.</source>
          <target state="translated">Поскольку вы используете это руководство,мы просим вас присылать исправления,как только вы их найдете.Если вы думаете о простом,реальном примере функции или группы функций,пожалуйста,приложите усилия,чтобы записать его и прислать.Пожалуйста,присылайте любые комментарии к имени узла и функции или переменной,соответственно.Также укажите номер редакции,которую вы критикуете.</target>
        </trans-unit>
        <trans-unit id="875666f6d9c3564876142613c6760e04a0da95b2" translate="yes" xml:space="preserve">
          <source>Aside from elements that specify bindings for keys, a keymap can also have a string as an element. This is called the &lt;em&gt;overall prompt string&lt;/em&gt; and makes it possible to use the keymap as a menu. See &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;.</source>
          <target state="translated">Помимо элементов, которые задают привязки для ключей, таблица ключей также может иметь строку в качестве элемента. Это называется &lt;em&gt;общей строкой приглашения&lt;/em&gt; и позволяет использовать раскладку клавиатуры в качестве меню. См. Раздел &amp;laquo; &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Определение меню&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d3719187ae715d19fbc05c49ed805a355d60c95" translate="yes" xml:space="preserve">
          <source>Aside from some technical details, the body of the &lt;code&gt;find-file&lt;/code&gt; function is basically equivalent to:</source>
          <target state="translated">Помимо некоторых технических деталей, тело функции &lt;code&gt;find-file&lt;/code&gt; в основном эквивалентно:</target>
        </trans-unit>
        <trans-unit id="e8854395183315465f485147e2c0e5d0dad0bf04" translate="yes" xml:space="preserve">
          <source>Aside from the four basic conditional forms, Emacs Lisp also has a pattern-matching conditional form, the &lt;code&gt;pcase&lt;/code&gt; macro, a hybrid of &lt;code&gt;cond&lt;/code&gt; and &lt;code&gt;cl-case&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Conditionals.html#Conditionals&quot;&gt;Conditionals&lt;/a&gt; in</source>
          <target state="translated">Помимо четырех основных условных форм, Emacs Lisp также имеет сопоставление с образцом условной формы, &lt;code&gt;pcase&lt;/code&gt; макро, гибрид &lt;code&gt;cond&lt;/code&gt; и &lt;code&gt;cl-case&lt;/code&gt; (см &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Conditionals.html#Conditionals&quot;&gt;Условных&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="d784be167f97d7b6e1444587a023ff8462f0adde" translate="yes" xml:space="preserve">
          <source>Aside from the mathematical incorrectness of asserting that 9 is a double-digit integer, there is another problem with &lt;code&gt;MAYBE&lt;/code&gt;. The body form references &lt;code&gt;n&lt;/code&gt; once more, yet we do not see the updated value&amp;mdash;10&amp;mdash;at all. What happened to it?</source>
          <target state="translated">Помимо математической неверности утверждения, что 9 - это двузначное целое число, с &lt;code&gt;MAYBE&lt;/code&gt; есть еще одна проблема . Основная форма ссылается на &lt;code&gt;n&lt;/code&gt; еще раз, но мы не видим обновленное значение - 10 - вообще. Что с ним случилось?</target>
        </trans-unit>
        <trans-unit id="3562777bc6a3edbbbfe49bb7c58769707930308b" translate="yes" xml:space="preserve">
          <source>Ask</source>
          <target state="translated">Ask</target>
        </trans-unit>
        <trans-unit id="5cc8d5b1e25410343b6c6d03e6144240950ba693" translate="yes" xml:space="preserve">
          <source>Ask user a multiple choice question. &lt;var&gt;prompt&lt;/var&gt; should be a string that will be displayed as the prompt.</source>
          <target state="translated">Задайте пользователю вопрос с несколькими вариантами ответов. &lt;var&gt;prompt&lt;/var&gt; должно быть строкой, которая будет отображаться как приглашение.</target>
        </trans-unit>
        <trans-unit id="a575156671adcef0e66c96ca9986973728b1a5e6" translate="yes" xml:space="preserve">
          <source>Asking Multiple-Choice Questions</source>
          <target state="translated">Задавать вопросы по нескольким выборам</target>
        </trans-unit>
        <trans-unit id="f48d4ab0834bb43d119ea91a0df80bf7d9b32ab7" translate="yes" xml:space="preserve">
          <source>Asking a question with a simple answer.</source>
          <target state="translated">Задать вопрос с простым ответом.</target>
        </trans-unit>
        <trans-unit id="fe7e00f4a1fa3a5c1a99ddf9345528ef0e23e5df" translate="yes" xml:space="preserve">
          <source>Asking complex questions.</source>
          <target state="translated">Задавать сложные вопросы.</target>
        </trans-unit>
        <trans-unit id="27b0c683fbfb99510b0eaaaf16a761a3b451a6a0" translate="yes" xml:space="preserve">
          <source>Asking the user to choose a coding system.</source>
          <target state="translated">Попросить пользователя выбрать систему кодирования.</target>
        </trans-unit>
        <trans-unit id="e753d0e9020f53ad0de8df59f25fdea5680ef2fc" translate="yes" xml:space="preserve">
          <source>Asking the user to specify a character.</source>
          <target state="translated">Попросить пользователя указать символ.</target>
        </trans-unit>
        <trans-unit id="79f255d18c150763000984a919eb61a8c62cb802" translate="yes" xml:space="preserve">
          <source>Asking where the mouse is, or moving it.</source>
          <target state="translated">Спросить,где мышь,или переместить ее.</target>
        </trans-unit>
        <trans-unit id="9a8aef5df06c4a0630dba0718222fbda7f2ae98b" translate="yes" xml:space="preserve">
          <source>Assertion failed</source>
          <target state="translated">Утверждение не подтвердилось</target>
        </trans-unit>
        <trans-unit id="906762c6281b489fa4d8cc099d0c4e13c1902efd" translate="yes" xml:space="preserve">
          <source>Assigning Lisp property lists to text characters.</source>
          <target state="translated">Назначение списков свойств Lisp текстовым символам.</target>
        </trans-unit>
        <trans-unit id="8f9fb7e8c09158fb874cf09f8dbca8383f6a050c" translate="yes" xml:space="preserve">
          <source>Associate &lt;var&gt;stderr&lt;/var&gt; with the standard error of the process. A non-&lt;code&gt;nil&lt;/code&gt; value should be either a buffer or a pipe process created with &lt;code&gt;make-pipe-process&lt;/code&gt;, described below. If &lt;var&gt;stderr&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, standard error is mixed with standard output, and both are sent to &lt;var&gt;buffer&lt;/var&gt; or &lt;var&gt;filter&lt;/var&gt;.</source>
          <target state="translated">Ассоциированный &lt;var&gt;stderr&lt;/var&gt; со стандартной погрешностью процесса. Не - &lt;code&gt;nil&lt;/code&gt; значение должно быть либо буфер или процесс трубы создается с &lt;code&gt;make-pipe-process&lt;/code&gt; , как описано ниже. Если &lt;var&gt;stderr&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , стандартная ошибка смешивается со стандартным выводом, и оба отправляются в &lt;var&gt;buffer&lt;/var&gt; или &lt;var&gt;filter&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="e3024403263d4d843f0e51777623d2a49c1231db" translate="yes" xml:space="preserve">
          <source>Associating additional information with windows.</source>
          <target state="translated">Связь дополнительной информации с окнами.</target>
        </trans-unit>
        <trans-unit id="e463ae7c0c475efc422013c7bb62639251e2604f" translate="yes" xml:space="preserve">
          <source>Association List Type</source>
          <target state="translated">Список ассоциаций</target>
        </trans-unit>
        <trans-unit id="c1eecc79e49a6ca7a499806fc8e58814d3aeda58" translate="yes" xml:space="preserve">
          <source>Association Lists</source>
          <target state="translated">Списки Ассоциации</target>
        </trans-unit>
        <trans-unit id="a0f646334656079aafb8f68fbbd7ae734d08ae78" translate="yes" xml:space="preserve">
          <source>Association lists (see &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Association Lists&lt;/a&gt;) are very similar to property lists. In contrast to association lists, the order of the pairs in the property list is not significant, since the property names must be distinct.</source>
          <target state="translated">Списки ассоциаций (см. &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Списки ассоциаций&lt;/a&gt; ) очень похожи на списки свойств. В отличие от списков ассоциаций, порядок пар в списке свойств не имеет значения, поскольку имена свойств должны быть разными.</target>
        </trans-unit>
        <trans-unit id="14ba3cbc75793dbade1b890546d72c62627ca897" translate="yes" xml:space="preserve">
          <source>Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list. When searching an association list for an association with a given key, the first one found is returned, if there is more than one.</source>
          <target state="translated">Списки ассоциаций часто используются для записи информации,которую в противном случае вы могли бы хранить в стеке,так как новые ассоциации могут быть легко добавлены на первой странице списка.При поиске в списке ассоциаций ассоциации с заданным ключом,если их несколько,возвращается первый найденный.</target>
        </trans-unit>
        <trans-unit id="c3f9b4c0afa65ab472f88a447b5b643be2caa8ed" translate="yes" xml:space="preserve">
          <source>Asynchronous subprocesses receive input when it is sent to them by Emacs, which is done with the functions in this section. You must specify the process to send input to, and the input data to send. If the subprocess runs a program, the data appears on the standard input of that program; for connections, the data is sent to the connected device or program.</source>
          <target state="translated">Асинхронные подпроцессы получают входной сигнал,когда он посылается им Emacs,что и делается с функциями,описанными в этом разделе.Необходимо указать процесс для отправки входных данных и входные данные для отправки.Если подпроцесс выполняет программу,то данные появляются на стандартном входе этой программы;для соединений данные отправляются подключенному устройству или программе.</target>
        </trans-unit>
        <trans-unit id="a5bb8623a169e7bd4940e5f36d437427d3e09d1b" translate="yes" xml:space="preserve">
          <source>At any time, one frame in Emacs is the &lt;em&gt;selected frame&lt;/em&gt;. The selected window always resides on the selected frame.</source>
          <target state="translated">В любой момент &lt;em&gt;выбранным фреймом&lt;/em&gt; является один фрейм в Emacs . Выбранное окно всегда находится на выбранном фрейме.</target>
        </trans-unit>
        <trans-unit id="4c816364377c69602fd91de24b490b44a6fcd129" translate="yes" xml:space="preserve">
          <source>At any time, several primary keymaps are &lt;em&gt;active&lt;/em&gt;&amp;mdash;that is, in use for finding key bindings. These are the &lt;em&gt;global map&lt;/em&gt;, which is shared by all buffers; the &lt;em&gt;local keymap&lt;/em&gt;, which is usually associated with a specific major mode; and zero or more &lt;em&gt;minor mode keymaps&lt;/em&gt;, which belong to currently enabled minor modes. (Not all minor modes have keymaps.) The local keymap bindings shadow (i.e., take precedence over) the corresponding global bindings. The minor mode keymaps shadow both local and global keymaps. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;, for details.</source>
          <target state="translated">В любое время &lt;em&gt;активны&lt;/em&gt; несколько первичных таблиц клавиш, то есть используются для поиска привязок клавиш. Это &lt;em&gt;глобальная карта&lt;/em&gt; , которая используется всеми буферами; &lt;em&gt;локальная раскладка&lt;/em&gt; , которая обычно связана с конкретным основным режимом; и ноль или более &lt;em&gt;раскладок вспомогательных режимов&lt;/em&gt; , которые принадлежат текущим включенным второстепенным режимам. (Не все второстепенные режимы имеют раскладки клавиатуры.) Привязки локальной раскладки клавиатуры затеняют (т. Е. Имеют приоритет) соответствующие глобальные привязки. Раскладки вспомогательного режима затеняют как локальные, так и глобальные раскладки клавиатуры. Подробности см. В разделе &amp;laquo; &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Активные раскладки клавиатуры&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d93bb5f9a38a88b4da1e36b6fa1f9cb4bfd6596" translate="yes" xml:space="preserve">
          <source>At each stage, if a face has a valid &lt;code&gt;:inherit&lt;/code&gt; attribute, Emacs treats any attribute with an &lt;code&gt;unspecified&lt;/code&gt; value as having the corresponding value drawn from the parent face(s). see &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Face Attributes&lt;/a&gt;. Note that the parent face(s) may also leave the attribute unspecified; in that case, the attribute remains unspecified at the next level of face merging.</source>
          <target state="translated">На каждом этапе, если лицо имеет атрибут valid &lt;code&gt;:inherit&lt;/code&gt; , Emacs обрабатывает любой атрибут с &lt;code&gt;unspecified&lt;/code&gt; значением как имеющий соответствующее значение, полученное из родительского лица (-ей). см. &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Атрибуты лица&lt;/a&gt; . Обратите внимание, что родительские грани также могут оставить атрибут неопределенным; в этом случае атрибут остается неопределенным на следующем уровне слияния граней.</target>
        </trans-unit>
        <trans-unit id="621cbe593d12331614294e33d27df98bfb14d296" translate="yes" xml:space="preserve">
          <source>At some point in the future the base C dialect will no doubt change to C11.</source>
          <target state="translated">В какой-то момент в будущем базовый диалект C,несомненно,изменится на C11.</target>
        </trans-unit>
        <trans-unit id="2d46551267fccda2366ce110501bc5c0ac875511" translate="yes" xml:space="preserve">
          <source>At the beginning or end of a line, the appropriate amount of space is none. Before a character with close parenthesis syntax, or after a character with open parenthesis or expression-prefix syntax, no space is also appropriate. Otherwise, one space is appropriate. See &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;.</source>
          <target state="translated">В начале или в конце строки подходящее пространство отсутствует. Перед символом с синтаксисом закрывающей круглой скобки или после символа с синтаксисом открытой круглой скобки или префикса выражения пробел также не подходит. В противном случае подходит один пробел. См. &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Таблицу классов синтаксиса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="007e79f90925179d568d16a8deaddb8c8e8caa2f" translate="yes" xml:space="preserve">
          <source>At the center of the window is the &lt;em&gt;text area&lt;/em&gt;, or &lt;em&gt;body&lt;/em&gt;, where the buffer text is displayed. The text area can be surrounded by a series of optional areas. On the left and right, from innermost to outermost, these are the left and right fringes, denoted by LF and RF (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;); the left and right margins, denoted by LM and RM in the schematic (see &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;); the left or right vertical scroll bar, only one of which is present at any time, denoted by LS and RS (see &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Scroll Bars&lt;/a&gt;); and the right divider, denoted by RD (see &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;Window Dividers&lt;/a&gt;). At the top of the window is the header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;). At the bottom of the window are the horizontal scroll bar (see &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Scroll Bars&lt;/a&gt;); the mode line (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;); and the bottom divider (see &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;Window Dividers&lt;/a&gt;).</source>
          <target state="translated">В центре окна находится &lt;em&gt;текстовая область&lt;/em&gt; или &lt;em&gt;тело&lt;/em&gt; , где отображается текст буфера. Текстовая область может быть окружена рядом дополнительных областей. Слева и справа, от самого внутреннего к самому внешнему, это левая и правая полосы, обозначенные LF и RF (см. &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt; ); левое и правое поля, обозначенные на схеме LM и RM (см. &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Поля отображения&lt;/a&gt; ); левая или правая вертикальная полоса прокрутки, только одна из которых присутствует в любой момент, обозначается LS и RS (см. &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Полосы прокрутки&lt;/a&gt; ); и правый разделитель, обозначенный RD (см. Разделители &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;окон&lt;/a&gt; ). Вверху окна находится строка заголовка (см. &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Строки заголовка&lt;/a&gt;). Внизу окна расположена горизонтальная полоса прокрутки (см. &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Полосы прокрутки&lt;/a&gt; ); строка режима (см. &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Формат&lt;/a&gt; строки режима ); и нижний разделитель (см. Разделители &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;окон&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fce2ab087a5fd08a2230eb11f4e344519f5c8db6" translate="yes" xml:space="preserve">
          <source>At the level of C code, quitting cannot happen just anywhere; only at the special places that check &lt;code&gt;quit-flag&lt;/code&gt;. The reason for this is that quitting at other places might leave an inconsistency in Emacs&amp;rsquo;s internal state. Because quitting is delayed until a safe place, quitting cannot make Emacs crash.</source>
          <target state="translated">На уровне кода C выход не может произойти где-нибудь; только в специальных местах, где установлен флажок &lt;code&gt;quit-flag&lt;/code&gt; . Причина этого в том, что завершение работы в других местах может привести к несогласованности во внутреннем состоянии Emacs. Поскольку выход откладывается до безопасного места, завершение не может привести к аварийному завершению работы Emacs.</target>
        </trans-unit>
        <trans-unit id="d255c59db332c87b9a24623a21d91ebeac724f41" translate="yes" xml:space="preserve">
          <source>At this moment typing</source>
          <target state="translated">В данный момент набирая</target>
        </trans-unit>
        <trans-unit id="ede1fb5d661ab864aba9032ff56e1ac325b126c0" translate="yes" xml:space="preserve">
          <source>Atomic Change Groups</source>
          <target state="translated">Группы по атомным изменениям</target>
        </trans-unit>
        <trans-unit id="aab81d84cf8514fae3d044627f17a742d2c5166b" translate="yes" xml:space="preserve">
          <source>Atomic Windows</source>
          <target state="translated">Атомные окна</target>
        </trans-unit>
        <trans-unit id="ccb118068fddf7824a58d856e2c3e7b40ebb74f7" translate="yes" xml:space="preserve">
          <source>Atomic windows are implemented with the help of the reserved &lt;code&gt;window-atom&lt;/code&gt; window parameter (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) and an internal window (see &lt;a href=&quot;basic-windows#Basic-Windows&quot;&gt;Basic Windows&lt;/a&gt;) called the root window of the atomic window. All windows that are part of the same atomic window have this root window as their common ancestor and are assigned a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;window-atom&lt;/code&gt; parameter.</source>
          <target state="translated">Атомные окна осуществляются при помощи зарезервированного &lt;code&gt;window-atom&lt;/code&gt; параметра окна (см &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Окна Параметры&lt;/a&gt; ) и внутреннее окно (см &lt;a href=&quot;basic-windows#Basic-Windows&quot;&gt;базовой Windows&lt;/a&gt; ) называются корневое окном атомного окна. Все окна , которые являются частью одного и того же атомного окна имеют этот корень окна , как их общего предка и присваивается не- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;window-atom&lt;/code&gt; параметра.</target>
        </trans-unit>
        <trans-unit id="a163ce0a704c17ae2c4e7f0c3f6ff0be652a3729" translate="yes" xml:space="preserve">
          <source>Atomic windows are rectangular compositions of at least two live windows. They have the following distinctive characteristics:</source>
          <target state="translated">Атомные окна-это прямоугольные композиции как минимум из двух живых окон.Они имеют следующие отличительные характеристики:</target>
        </trans-unit>
        <trans-unit id="84b84a11114f20365d178505da52d54f0c432b05" translate="yes" xml:space="preserve">
          <source>Atomic windows are useful to construct and preserve window layouts that are meaningful only when all involved buffers are shown simultaneously in a specific manner, such as when showing differences between file revisions, or the same text in different languages or markups. They can also be used to permanently display information pertinent to a specific window in bars on that window&amp;rsquo;s sides.</source>
          <target state="translated">Атомарные окна полезны для создания и сохранения макетов окон, которые имеют смысл только тогда, когда все задействованные буферы отображаются одновременно определенным образом, например, при отображении различий между версиями файлов или одного и того же текста на разных языках или разметках. Их также можно использовать для постоянного отображения информации, относящейся к определенному окну, в полосах по бокам этого окна.</target>
        </trans-unit>
        <trans-unit id="7ac3939a8902c4e5ec26fa6e697cca7abee0c334" translate="yes" xml:space="preserve">
          <source>Atomic windows automatically cease to exist when one of their constituents gets deleted. To dissolve an atomic window manually, reset the &lt;code&gt;window-atom&lt;/code&gt; parameter of its constituents&amp;mdash;the root of the atomic window and all its descendants.</source>
          <target state="translated">Атомарные окна автоматически перестают существовать, когда одна из их составляющих удаляется. Чтобы растворить атомное окно вручную, сбросьте параметр &lt;code&gt;window-atom&lt;/code&gt; его составляющих - корень атомарного окна и всех его потомков.</target>
        </trans-unit>
        <trans-unit id="b9ac22b82065cc69d28fef7fb37ebf9456c2f8c5" translate="yes" xml:space="preserve">
          <source>Attempt to set a constant symbol</source>
          <target state="translated">Попытка установить постоянный символ</target>
        </trans-unit>
        <trans-unit id="040459de5fdc40f82378844a0d54d538e77e475c" translate="yes" xml:space="preserve">
          <source>Attempts to match &lt;var&gt;pattern1&lt;/var&gt;&amp;hellip;, in order, until one of them fails to match. In that case, &lt;code&gt;and&lt;/code&gt; likewise fails to match, and the rest of the sub-patterns are not tested. If all sub-patterns match, &lt;code&gt;and&lt;/code&gt; matches.</source>
          <target state="translated">Попытки сопоставить &lt;var&gt;pattern1&lt;/var&gt; &amp;hellip; по порядку, пока один из них не перестанет соответствовать. В этом случае, &lt;code&gt;and&lt;/code&gt; также не совпадают, а остальные подшаблоны не проверяются. Если все подшаблоны совпадают, &lt;code&gt;and&lt;/code&gt; совпадает.</target>
        </trans-unit>
        <trans-unit id="d62c51b00eb3d0f88c19008784cb02b23b4ba495" translate="yes" xml:space="preserve">
          <source>Attempts to match &lt;var&gt;pattern1&lt;/var&gt;, &lt;var&gt;pattern2&lt;/var&gt;, &amp;hellip;, in order, until one of them succeeds. In that case, &lt;code&gt;or&lt;/code&gt; likewise matches, and the rest of the sub-patterns are not tested. (Note that there must be at least two sub-patterns. Simply &lt;code&gt;(or&amp;nbsp;&lt;var&gt;pattern1&lt;/var&gt;)&lt;/code&gt; signals error.)</source>
          <target state="translated">Попытки соответствовать &lt;var&gt;pattern1&lt;/var&gt; , &lt;var&gt;pattern2&lt;/var&gt; , ..., в порядке, пока один из них не удастся. В этом случае &lt;code&gt;or&lt;/code&gt; аналогичным образом совпадают, а остальные подшаблоны не проверяются. (Обратите внимание, что должно быть как минимум два подшаблона. Просто &lt;code&gt;(or&amp;nbsp;&lt;var&gt;pattern1&lt;/var&gt;)&lt;/code&gt; сигнализирует об ошибке.)</target>
        </trans-unit>
        <trans-unit id="5b2467f53cc44078cb438b0c2750bc2ec1578c8a" translate="yes" xml:space="preserve">
          <source>Attract focus to the window chosen</source>
          <target state="translated">Привлечь внимание к выбранному окну</target>
        </trans-unit>
        <trans-unit id="19a9640f6e74bf975fe0db395e61ad03d3ece1c7" translate="yes" xml:space="preserve">
          <source>Audible signal to the user.</source>
          <target state="translated">Звуковой сигнал для пользователя.</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="2667d909be440bdf6583125971872bea1221d4db" translate="yes" xml:space="preserve">
          <source>Auto Fill mode also enables the functions that change the margins and justification style to refill portions of the text. See &lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;.</source>
          <target state="translated">Режим автозаполнения также включает функции, которые изменяют поля и стиль выравнивания для заполнения частей текста. См. &lt;a href=&quot;margins#Margins&quot;&gt;Поля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="555de047487d343cd666ab6a903a79ef6c09e487" translate="yes" xml:space="preserve">
          <source>Auto Fill mode is a minor mode that fills lines automatically as text is inserted. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Fill.html#Auto-Fill&quot;&gt;Auto Fill&lt;/a&gt; in</source>
          <target state="translated">Режим автозаполнения - это второстепенный режим, при котором строки автоматически заполняются при вставке текста. См &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Fill.html#Auto-Fill&quot;&gt;автозаполнения&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="850ade7a51d735a464313dc8f30adc7d11e8a00d" translate="yes" xml:space="preserve">
          <source>Auto Filling</source>
          <target state="translated">Автозаполнение</target>
        </trans-unit>
        <trans-unit id="0b4ed412ef994ca0c43e1b7bd22d818d428bb6c5" translate="yes" xml:space="preserve">
          <source>Auto-Saving</source>
          <target state="translated">Auto-Saving</target>
        </trans-unit>
        <trans-unit id="845b01108562c3d927a2af1812a0c1bf88795555" translate="yes" xml:space="preserve">
          <source>Auto-saving...</source>
          <target state="translated">Auto-saving...</target>
        </trans-unit>
        <trans-unit id="c2e779e790c1d4dc28d4326306803dbf362b481e" translate="yes" xml:space="preserve">
          <source>Autoload</source>
          <target state="translated">Autoload</target>
        </trans-unit>
        <trans-unit id="06d7988cf794172658af0153fd1a2481ba35d7d2" translate="yes" xml:space="preserve">
          <source>Autoload Type</source>
          <target state="translated">Тип автозагрузки</target>
        </trans-unit>
        <trans-unit id="85e513dae1246e61ba8640eb87ad292a21840742" translate="yes" xml:space="preserve">
          <source>Autoload by Prefix</source>
          <target state="translated">Автозагрузка с помощью префикса</target>
        </trans-unit>
        <trans-unit id="a316cd16d04dc567c3b4909645684cb65b1f615f" translate="yes" xml:space="preserve">
          <source>Autoload by Prefix.</source>
          <target state="translated">Автозагрузка с помощью префикса.</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="eb9cb47e9f34f586b55a9d914f6b2f6403badd01" translate="yes" xml:space="preserve">
          <source>Automatic Face Assignment</source>
          <target state="translated">Автоматическое назначение лица</target>
        </trans-unit>
        <trans-unit id="ae90bbb56c1aa1c308fb3a413aa144f52a6ccd37" translate="yes" xml:space="preserve">
          <source>Automatic Indentation of code</source>
          <target state="translated">Автоматическое смещение кода</target>
        </trans-unit>
        <trans-unit id="a8cc32cc81dbf9afed120141fd3975ae43627630" translate="yes" xml:space="preserve">
          <source>Automatic updating of frame titles.</source>
          <target state="translated">Автоматическое обновление названий кадров.</target>
        </trans-unit>
        <trans-unit id="a5bc07194f48e4d3351e56450cd28e631e2382b0" translate="yes" xml:space="preserve">
          <source>Automatically re-evaluate a list of expressions and display their results each time Edebug updates the display.</source>
          <target state="translated">Автоматически пересматривает список выражений и отображает их результаты каждый раз,когда Edebug обновляет дисплей.</target>
        </trans-unit>
        <trans-unit id="1cd844466867bdaf6e1db628300b6112623f0e83" translate="yes" xml:space="preserve">
          <source>Automatically selecting windows with the mouse.</source>
          <target state="translated">Автоматическое выделение окон мышью.</target>
        </trans-unit>
        <trans-unit id="c89d8ac98afcea167130340f5b561c866ca98fd5" translate="yes" xml:space="preserve">
          <source>Autotyping</source>
          <target state="translated">Autotyping</target>
        </trans-unit>
        <trans-unit id="361af9ca637df41d1dd709df4b2eb262901b3fd8" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;ssize_t&lt;/code&gt; except when communicating to low-level APIs that have &lt;code&gt;ssize_t&lt;/code&gt;-related limitations. Although it&amp;rsquo;s equivalent to &lt;code&gt;ptrdiff_t&lt;/code&gt; on typical platforms, &lt;code&gt;ssize_t&lt;/code&gt; is occasionally narrower, so using it for size-related calculations could overflow. Also, &lt;code&gt;ptrdiff_t&lt;/code&gt; is more ubiquitous and better-standardized, has standard &lt;code&gt;printf&lt;/code&gt; formats, and is the basis for Emacs&amp;rsquo;s internal size-overflow checking. When using &lt;code&gt;ssize_t&lt;/code&gt;, please note that POSIX requires support only for values in the range -1 .. &lt;code&gt;SSIZE_MAX&lt;/code&gt;.</source>
          <target state="translated">Избегайте &lt;code&gt;ssize_t&lt;/code&gt; , за исключением случаев взаимодействия с низкоуровневыми API, которые имеют ограничения, связанные с &lt;code&gt;ssize_t&lt;/code&gt; . Хотя он эквивалентен &lt;code&gt;ptrdiff_t&lt;/code&gt; на типичных платформах, &lt;code&gt;ssize_t&lt;/code&gt; иногда бывает уже, поэтому его использование для вычислений, связанных с размером , может вызвать переполнение. Кроме того, &lt;code&gt;ptrdiff_t&lt;/code&gt; более распространен и лучше стандартизирован, имеет стандартные форматы &lt;code&gt;printf&lt;/code&gt; и является основой для внутренней проверки переполнения размера Emacs. При использовании &lt;code&gt;ssize_t&lt;/code&gt; обратите внимание, что POSIX требует поддержки только значений в диапазоне -1 .. &lt;code&gt;SSIZE_MAX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4db5c02b78c97409e22545eb6907ca4a351e1990" translate="yes" xml:space="preserve">
          <source>Avoid arbitrary limits. For example, avoid &lt;code&gt;int len = strlen
(s);&lt;/code&gt; unless the length of &lt;code&gt;s&lt;/code&gt; is required for other reasons to fit in &lt;code&gt;int&lt;/code&gt; range.</source>
          <target state="translated">Избегайте произвольных ограничений. Например, избегайте &lt;code&gt;int len = strlen (s);&lt;/code&gt; если длина &lt;code&gt;s&lt;/code&gt; не требуется по другим причинам, чтобы соответствовать диапазону &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d6e79e0cc19181112cfd0c36a5750ae8c092fc5" translate="yes" xml:space="preserve">
          <source>Avoid depending on how many times expansion is done.</source>
          <target state="translated">Избегайте в зависимости от того,сколько раз производится расширение.</target>
        </trans-unit>
        <trans-unit id="2e549352e5b71cd7798ed53124f97e4a4c19088d" translate="yes" xml:space="preserve">
          <source>Avoiding evaluation (to put constants in the program).</source>
          <target state="translated">Избегание оценки (введение констант в программу).</target>
        </trans-unit>
        <trans-unit id="98c63cc59f3d9c3c7c9d29e55ddfee0b39d55b90" translate="yes" xml:space="preserve">
          <source>Avoiding problems with dynamic binding.</source>
          <target state="translated">Избежать проблем с динамической связью.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="16374ac2b9a2eb53d18fcede0cdf14c4d6e18ba5" translate="yes" xml:space="preserve">
          <source>BS</source>
          <target state="translated">BS</target>
        </trans-unit>
        <trans-unit id="b52b36b7269fbfc58ec24bb724691951a3decbe8" translate="yes" xml:space="preserve">
          <source>Back</source>
          <target state="translated">Back</target>
        </trans-unit>
        <trans-unit id="17c0e560f6eadc671493346fc0a13caf302e9875" translate="yes" xml:space="preserve">
          <source>Background color, a string. The value can be a system-defined color name, or a hexadecimal color specification. See &lt;a href=&quot;color-names#Color-Names&quot;&gt;Color Names&lt;/a&gt;.</source>
          <target state="translated">Цвет фона, строка. Значение может быть системным именем цвета или шестнадцатеричной спецификацией цвета. См. &lt;a href=&quot;color-names#Color-Names&quot;&gt;Названия цветов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc48ef84cf0ee761d58df4dcb6d99bd10746fd9a" translate="yes" xml:space="preserve">
          <source>Backquote</source>
          <target state="translated">Backquote</target>
        </trans-unit>
        <trans-unit id="1c6ba351e6ca20e8a37172efc2c86d4aab598c50" translate="yes" xml:space="preserve">
          <source>Backquote-Style Patterns</source>
          <target state="translated">Стиль обратного отсчета Шаблоны</target>
        </trans-unit>
        <trans-unit id="c0ecdab9574e4ebcb9dc4d8aec5335a6fb1dc637" translate="yes" xml:space="preserve">
          <source>Backquote-style patterns are a powerful set of &lt;code&gt;pcase&lt;/code&gt; pattern extensions (created using &lt;code&gt;pcase-defmacro&lt;/code&gt;) that make it easy to match &lt;var&gt;expval&lt;/var&gt; against specifications of its &lt;em&gt;structure&lt;/em&gt;.</source>
          <target state="translated">Шаблоны в стиле обратных кавычек - это мощный набор &lt;code&gt;pcase&lt;/code&gt; шаблона pcase (созданный с помощью &lt;code&gt;pcase-defmacro&lt;/code&gt; ), который упрощает сопоставление &lt;var&gt;expval&lt;/var&gt; со спецификациями его &lt;em&gt;структуры&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a017b7b51d9d23728fcdbbcaa591b2596fe0b09a" translate="yes" xml:space="preserve">
          <source>Backslash Constructs in Regular Expressions</source>
          <target state="translated">Обратная косая черта строится в регулярных выражениях</target>
        </trans-unit>
        <trans-unit id="807e6daac187d064954fd59f10abb8e716892ec1" translate="yes" xml:space="preserve">
          <source>Backslash-sequences in regular expressions.</source>
          <target state="translated">Обратные последовательности в регулярных выражениях.</target>
        </trans-unit>
        <trans-unit id="9bfb245aa5d9e794b82e574165fbbc700e3e2a72" translate="yes" xml:space="preserve">
          <source>Backtraces</source>
          <target state="translated">Backtraces</target>
        </trans-unit>
        <trans-unit id="c3e2b2ecbdd4245dd6be8d66bf5a99a7880e1508" translate="yes" xml:space="preserve">
          <source>Backtracking in Specifications</source>
          <target state="translated">Отступление от спецификаций</target>
        </trans-unit>
        <trans-unit id="efef7b78f24a9457b9578006ead1a23980b022a2" translate="yes" xml:space="preserve">
          <source>Backtracking is also disabled after successfully matching a quoted symbol or string specification, since this usually indicates a recognized construct. But if you have a set of alternative constructs that all begin with the same symbol, you can usually work around this constraint by factoring the symbol out of the alternatives, e.g., &lt;code&gt;[&quot;foo&quot; &amp;amp;or [first case] [second case] ...]&lt;/code&gt;.</source>
          <target state="translated">Отслеживание с возвратом также отключается после успешного сопоставления указанного символа или строки в кавычках, поскольку обычно это указывает на распознанную конструкцию. Но если у вас есть набор альтернативных конструкций, которые начинаются с одного и того же символа, вы обычно можете обойти это ограничение, вычленив символ из альтернатив, например, &lt;code&gt;[&quot;foo&quot; &amp;amp;or [first case] [second case] ...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b80345f727522e6032bad01fc94ae4ee43720c6" translate="yes" xml:space="preserve">
          <source>Backtracking is disabled while matching any of the form specifications (that is, &lt;code&gt;form&lt;/code&gt;, &lt;code&gt;body&lt;/code&gt;, &lt;code&gt;def-form&lt;/code&gt;, and &lt;code&gt;def-body&lt;/code&gt;). These specifications will match any form so any error must be in the form itself rather than at a higher level.</source>
          <target state="translated">Отслеживание с возвратом отключено при сопоставлении любой из спецификаций формы (то есть &lt;code&gt;form&lt;/code&gt; , &lt;code&gt;body&lt;/code&gt; , &lt;code&gt;def-form&lt;/code&gt; и &lt;code&gt;def-body&lt;/code&gt; ). Эти спецификации будут соответствовать любой форме, поэтому любая ошибка должна быть в самой форме, а не на более высоком уровне.</target>
        </trans-unit>
        <trans-unit id="a4fc1af88bf3a7f32329f6577445d6679643e427" translate="yes" xml:space="preserve">
          <source>Backup Files</source>
          <target state="translated">Резервные файлы</target>
        </trans-unit>
        <trans-unit id="40a0ef48a621ee3ca348b1e08eee5e6ff78084ac" translate="yes" xml:space="preserve">
          <source>Backup by Renaming or by Copying?</source>
          <target state="translated">Резервное копирование с помощью переименования или копирования?</target>
        </trans-unit>
        <trans-unit id="3e24bb9e6bf592cfc87438fc7775b2a394418349" translate="yes" xml:space="preserve">
          <source>Backup files and auto-save files are two methods by which Emacs tries to protect the user from the consequences of crashes or of the user&amp;rsquo;s own errors. Auto-saving preserves the text from earlier in the current editing session; backup files preserve file contents prior to the current session.</source>
          <target state="translated">Файлы резервного копирования и файлы автосохранения - это два метода, с помощью которых Emacs пытается защитить пользователя от последствий сбоев или собственных ошибок пользователя. Автосохранение сохраняет текст, сделанный ранее в текущем сеансе редактирования; файлы резервных копий сохраняют содержимое файла до текущего сеанса.</target>
        </trans-unit>
        <trans-unit id="2b47ba4274b19191cdf1a5d7d53d13dd0235dd70" translate="yes" xml:space="preserve">
          <source>Backups and Auto-Saving</source>
          <target state="translated">Резервное копирование и автоматическое сохранение</target>
        </trans-unit>
        <trans-unit id="0cea14da6f943b9330cb8b19aa3f92fa39fb6f16" translate="yes" xml:space="preserve">
          <source>Backups are usually made by renaming the visited file to a new name. Optionally, you can specify that backup files should be made by copying the visited file. This choice makes a difference for files with multiple names; it also can affect whether the edited file remains owned by the original owner or becomes owned by the user editing it.</source>
          <target state="translated">Резервное копирование обычно производится путем переименования посещенного файла на новое имя.Дополнительно можно указать,что резервные копии файлов должны быть сделаны путем копирования посещенного файла.Этот выбор имеет значение для файлов с несколькими именами;он также может повлиять на то,останется ли отредактированный файл собственностью первоначального владельца или станет собственностью пользователя,который его редактирует.</target>
        </trans-unit>
        <trans-unit id="980a00caa2a5856cb63bd39c2e2070bc841c28b4" translate="yes" xml:space="preserve">
          <source>Backups of files with names matching &lt;var&gt;regexp&lt;/var&gt; will be made in &lt;var&gt;directory&lt;/var&gt;. &lt;var&gt;directory&lt;/var&gt; may be relative or absolute. If it is absolute, so that all matching files are backed up into the same directory, the file names in this directory will be the full name of the file backed up with all directory separators changed to &amp;lsquo;</source>
          <target state="translated">Резервные копии файлов с именами, соответствующими &lt;var&gt;regexp&lt;/var&gt; , будут сделаны в &lt;var&gt;directory&lt;/var&gt; . &lt;var&gt;directory&lt;/var&gt; может быть относительным или абсолютным. Если он абсолютный, так что все совпадающие файлы копируются в один и тот же каталог, имена файлов в этом каталоге будут полным именем файла, для которого создана резервная копия, со всеми разделителями каталогов, измененными на '</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">Обратная совместимость</target>
        </trans-unit>
        <trans-unit id="e514a03485d2668ef95953c312b10de6213c5a6b" translate="yes" xml:space="preserve">
          <source>Base 64 Encoding</source>
          <target state="translated">Базовое 64 Кодирование</target>
        </trans-unit>
        <trans-unit id="2da9b468199d7990437f4078993fd373ed775585" translate="yes" xml:space="preserve">
          <source>Base 64 code is used in email to encode a sequence of 8-bit bytes as a longer sequence of</source>
          <target state="translated">Базовый 64 код используется в электронной почте для кодирования последовательности из 8 байт как более длинной последовательности из</target>
        </trans-unit>
        <trans-unit id="4c671100c5a64e216a5296532f998860991bfe71" translate="yes" xml:space="preserve">
          <source>Based on the provided grammar, SMIE will be able to provide automatic indentation without any extra effort. But in practice, this default indentation style will probably not be good enough. You will want to tweak it in many different cases.</source>
          <target state="translated">Основываясь на предоставленной грамматике,SMIE сможет обеспечить автоматический отпечаток без дополнительных усилий.Но на практике этот стиль отступов по умолчанию,вероятно,не будет достаточно хорош.Вы захотите его откорректировать во многих различных случаях.</target>
        </trans-unit>
        <trans-unit id="ed7c8b81e81eeb80d5baed6aff985328d2115ad0" translate="yes" xml:space="preserve">
          <source>Basic Char Syntax</source>
          <target state="translated">Основной синтаксис Шар</target>
        </trans-unit>
        <trans-unit id="ca917eb6ff98062e696cf80a8ae061ef35888178" translate="yes" xml:space="preserve">
          <source>Basic Completion Functions</source>
          <target state="translated">Основные функции завершения</target>
        </trans-unit>
        <trans-unit id="50e2e3f56e746aee43ca80ef4e5fffdf4609c4f8" translate="yes" xml:space="preserve">
          <source>Basic Concepts of Coding Systems</source>
          <target state="translated">Основные понятия систем кодирования</target>
        </trans-unit>
        <trans-unit id="ad89db73741185f622afaecb510f561259b3dde6" translate="yes" xml:space="preserve">
          <source>Basic Concepts of Emacs Windows</source>
          <target state="translated">Основные понятия Emacs Windows</target>
        </trans-unit>
        <trans-unit id="00f4714f957a02625aba98347f399df3258beab7" translate="yes" xml:space="preserve">
          <source>Basic Faces</source>
          <target state="translated">Основные лица</target>
        </trans-unit>
        <trans-unit id="ff9602efc9e32b4e2b30281afa47a5ad0c076c75" translate="yes" xml:space="preserve">
          <source>Basic Major Modes</source>
          <target state="translated">Основные основные режимы</target>
        </trans-unit>
        <trans-unit id="7f5daf3307f72897980331dcafb0dc7eac1c3f87" translate="yes" xml:space="preserve">
          <source>Basic Parameters</source>
          <target state="translated">Основные параметры</target>
        </trans-unit>
        <trans-unit id="57d59d1f9034406d74ff83e18c697246b75a0ddb" translate="yes" xml:space="preserve">
          <source>Basic Thread Functions</source>
          <target state="translated">Основные функции резьбы</target>
        </trans-unit>
        <trans-unit id="566fc95e858fa38a59a695bd7cab6cae3b6d8fa3" translate="yes" xml:space="preserve">
          <source>Basic concepts of keymaps.</source>
          <target state="translated">Основные понятия ключевых карт.</target>
        </trans-unit>
        <trans-unit id="a25b5cf184191bab8faa27ed59d923cece314ddb" translate="yes" xml:space="preserve">
          <source>Basic concepts of syntax tables.</source>
          <target state="translated">Основные понятия таблиц синтаксиса.</target>
        </trans-unit>
        <trans-unit id="8b4ea8050a775a0f3ea3c2ccd48f52d29c5611ab" translate="yes" xml:space="preserve">
          <source>Basic concepts.</source>
          <target state="translated">Основные концепции.</target>
        </trans-unit>
        <trans-unit id="0f70f9424495752a5144291186246e76da91be5b" translate="yes" xml:space="preserve">
          <source>Basic ideas of mode line control.</source>
          <target state="translated">Основные идеи управления линией режима.</target>
        </trans-unit>
        <trans-unit id="1d42c96aca54ef9a010f6e17d0638352d113a90e" translate="yes" xml:space="preserve">
          <source>Basic information about minibuffers.</source>
          <target state="translated">Основная информация о минибуферах.</target>
        </trans-unit>
        <trans-unit id="3d3ef0f3067180013beb55c1d6dc1d28f43802f5" translate="yes" xml:space="preserve">
          <source>Basic information on using windows.</source>
          <target state="translated">Основная информация об использовании окон.</target>
        </trans-unit>
        <trans-unit id="1b6019974338c229459a64e3a602d1c23dece46e" translate="yes" xml:space="preserve">
          <source>Basic layout of frames.</source>
          <target state="translated">Базовая раскладка рам.</target>
        </trans-unit>
        <trans-unit id="2a42ee27cdcf6bfedbc7c589958206e56696aee1" translate="yes" xml:space="preserve">
          <source>Basic properties of strings and characters.</source>
          <target state="translated">Основные свойства строк и символов.</target>
        </trans-unit>
        <trans-unit id="3c23a95b197dbd7c57081385c609a0440865eff0" translate="yes" xml:space="preserve">
          <source>Basic thread functions.</source>
          <target state="translated">Основные функции резьбы.</target>
        </trans-unit>
        <trans-unit id="8b6d8cb0fe44b1ea97c8dffd9944957e48ec1ad8" translate="yes" xml:space="preserve">
          <source>Batch Mode</source>
          <target state="translated">Пакетный режим</target>
        </trans-unit>
        <trans-unit id="9b540e8dec8ec13cb761e2f53dc0c1414e9d9fbf" translate="yes" xml:space="preserve">
          <source>Be careful not to redefine existing functions unintentionally. &lt;code&gt;defun&lt;/code&gt; redefines even primitive functions such as &lt;code&gt;car&lt;/code&gt; without any hesitation or notification. Emacs does not prevent you from doing this, because redefining a function is sometimes done deliberately, and there is no way to distinguish deliberate redefinition from unintentional redefinition.</source>
          <target state="translated">Будьте осторожны, чтобы случайно не переопределить существующие функции. &lt;code&gt;defun&lt;/code&gt; переопределяет даже примитивные функции, такие как &lt;code&gt;car&lt;/code&gt; без каких-либо колебаний или уведомлений. Emacs не мешает вам сделать это, потому что переопределение функции иногда выполняется намеренно, и нет способа отличить преднамеренное переопределение от непреднамеренного переопределения.</target>
        </trans-unit>
        <trans-unit id="13b72a62f4358262651a47272a3079ef92b405df" translate="yes" xml:space="preserve">
          <source>Be careful when composing these regular expressions; a poorly written pattern can dramatically slow things down! The function &lt;code&gt;regexp-opt&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) is useful for calculating optimal regular expressions to match several keywords.</source>
          <target state="translated">Будьте осторожны при составлении этих регулярных выражений; плохо написанный шаблон может значительно замедлить работу! Функция &lt;code&gt;regexp-opt&lt;/code&gt; (см. &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Функции Regexp&lt;/a&gt; ) полезна для вычисления оптимальных регулярных выражений для соответствия нескольким ключевым словам.</target>
        </trans-unit>
        <trans-unit id="27bc044b4c8d3ad73080a8adb64df2e5a46f2bb1" translate="yes" xml:space="preserve">
          <source>Be careful when using non-</source>
          <target state="translated">Будьте осторожны при использовании не</target>
        </trans-unit>
        <trans-unit id="e685f45a3679a7ec991ede319ba164f9a2bcda4c" translate="yes" xml:space="preserve">
          <source>Be careful when writing macro calls in files that you intend to byte-compile. Since macro calls are expanded when they are compiled, the macros need to be loaded into Emacs or the byte compiler will not do the right thing. The usual way to handle this is with &lt;code&gt;require&lt;/code&gt; forms which specify the files containing the needed macro definitions (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Normally, the byte compiler does not evaluate the code that it is compiling, but it handles &lt;code&gt;require&lt;/code&gt; forms specially, by loading the specified libraries. To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;). For more details, See &lt;a href=&quot;compiling-macros#Compiling-Macros&quot;&gt;Compiling Macros&lt;/a&gt;.</source>
          <target state="translated">Будьте осторожны при записи вызовов макросов в файлы, которые вы собираетесь компилировать побайтно. Поскольку вызовы макросов раскрываются при компиляции, макросы нужно загружать в Emacs, иначе байтовый компилятор не будет делать правильных действий. Обычный способ справиться с этим - &lt;code&gt;require&lt;/code&gt; формы require, в которых указаны файлы, содержащие необходимые определения макросов (см. &lt;a href=&quot;named-features#Named-Features&quot;&gt;Именованные функции&lt;/a&gt; ). Обычно байтовый компилятор не оценивает код, который он компилирует, но он обрабатывает &lt;code&gt;require&lt;/code&gt; формы специально, загружая указанные библиотеки. Чтобы избежать загрузки файлов определения макроса, когда кто-то &lt;em&gt;запускает&lt;/em&gt; скомпилированную программу, напишите &lt;code&gt;eval-when-compile&lt;/code&gt; вокруг вызовов &lt;code&gt;require&lt;/code&gt; (см. &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval во время компиляции&lt;/a&gt;). Дополнительные сведения см. В разделе &amp;laquo; &lt;a href=&quot;compiling-macros#Compiling-Macros&quot;&gt;Компиляция макросов&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6856b62c3a77e855fac355ce1578434726e9581" translate="yes" xml:space="preserve">
          <source>Be careful with file names that end in spaces. On some filesystems (notably, MS-Windows), trailing whitespace characters in file names are silently and automatically ignored.</source>
          <target state="translated">Будьте осторожны с именами файлов,которые заканчиваются пробелами.На некоторых файловых системах (в частности,MS-Windows)пробельные символы в именах файлов игнорируются автоматически.</target>
        </trans-unit>
        <trans-unit id="7baa8406b5920aeefae8bb15fe88275a07b0c0a0" translate="yes" xml:space="preserve">
          <source>Be sure to verify that the file name is relative before doing that. If you use an absolute file name, the results could be syntactically invalid or refer to the wrong file.</source>
          <target state="translated">Прежде чем это сделать,убедитесь,что имя файла является относительным.Если вы используете абсолютное имя файла,результаты могут быть синтаксически недействительными или ссылаться на неправильный файл.</target>
        </trans-unit>
        <trans-unit id="98789dc3354690dfbeaecf0f3ce9c8a96fe9026d" translate="yes" xml:space="preserve">
          <source>Because &amp;lsquo;</source>
          <target state="translated">Потому как '</target>
        </trans-unit>
        <trans-unit id="e6dbac2a93ea4cf3cf393a42d12efb8fd86797f8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;kill-emacs&lt;/code&gt; can be called in situations where user interaction is impossible (e.g., when the terminal is disconnected), functions on this hook should not attempt to interact with the user. If you want to interact with the user when Emacs is shutting down, use &lt;code&gt;kill-emacs-query-functions&lt;/code&gt;, described below.</source>
          <target state="translated">Поскольку &lt;code&gt;kill-emacs&lt;/code&gt; может быть вызван в ситуациях, когда взаимодействие с пользователем невозможно (например, когда терминал отключен), функции на этой ловушке не должны пытаться взаимодействовать с пользователем. Если вы хотите взаимодействовать с пользователем при завершении работы Emacs, используйте &lt;code&gt;kill-emacs-query-functions&lt;/code&gt; , описанные ниже.</target>
        </trans-unit>
        <trans-unit id="0b34653ccb844a855bf2a53664633d4afdefaf2b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;quote&lt;/code&gt; is used so often in programs, Lisp provides a convenient read syntax for it. An apostrophe character (&amp;lsquo;</source>
          <target state="translated">Поскольку &lt;code&gt;quote&lt;/code&gt; так часто используются в программах, Lisp предоставляет для них удобный синтаксис чтения. Символ апострофа ('</target>
        </trans-unit>
        <trans-unit id="b2bc1f0e771e6eb95b71dcedaea02b03d8a8a123" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;save-excursion&lt;/code&gt; only saves point for the buffer that was current at the start of the excursion, any changes made to point in other buffers, during the excursion, will remain in effect afterward. This frequently leads to unintended consequences, so the byte compiler warns if you call &lt;code&gt;set-buffer&lt;/code&gt; during an excursion:</source>
          <target state="translated">Поскольку &lt;code&gt;save-excursion&lt;/code&gt; сохраняет точку только для буфера, который был текущим в начале экскурсии, любые изменения, внесенные в точку в других буферах во время экскурсии, останутся в силе и после этого. Это часто приводит к непредвиденным последствиям, поэтому байтовый компилятор предупреждает, если вы вызываете &lt;code&gt;set-buffer&lt;/code&gt; во время экскурсии:</target>
        </trans-unit>
        <trans-unit id="1d3ee6e492f4a143386c60288985612cf7687a32" translate="yes" xml:space="preserve">
          <source>Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called &lt;em&gt;atoms&lt;/em&gt;.</source>
          <target state="translated">Поскольку cons-ячейки занимают центральное место в Lisp, у нас также есть слово для объекта, который не является cons-ячейкой. Эти объекты называются &lt;em&gt;атомами&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8e02576b56371153350d8d25bb27cbfbf989dce0" translate="yes" xml:space="preserve">
          <source>Because each symbol has separate value and function cells, variables names and function names do not conflict. For example, the symbol &lt;code&gt;buffer-file-name&lt;/code&gt; has a value (the name of the file being visited in the current buffer) as well as a function definition (a primitive function that returns the name of the file):</source>
          <target state="translated">Поскольку каждый символ имеет отдельные ячейки значений и функций, имена переменных и имена функций не конфликтуют. Например, символ имя- &lt;code&gt;buffer-file-name&lt;/code&gt; имеет значение (имя файла, который посещается в текущем буфере), а также определение функции (примитивная функция, возвращающая имя файла):</target>
        </trans-unit>
        <trans-unit id="d2ece29760102e60138459a857930034eb578422" translate="yes" xml:space="preserve">
          <source>Because it is common to perform arithmetic operations on a marker position, most of these operations (including &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) accept markers as arguments. In such cases, the marker stands for its current position.</source>
          <target state="translated">Поскольку над положением маркера обычно выполняются арифметические операции, большинство этих операций (включая &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;-&lt;/code&gt; ) принимают маркеры в качестве аргументов. В таких случаях маркер обозначает его текущее положение.</target>
        </trans-unit>
        <trans-unit id="29cedf8199b58b0444621f3b1384580f106a0af6" translate="yes" xml:space="preserve">
          <source>Because it takes some time to load the standard Lisp files, the</source>
          <target state="translated">Потому что для загрузки стандартных файлов Lisp требуется некоторое время,а именно</target>
        </trans-unit>
        <trans-unit id="42fc09422aef4da2bc16d41efb01630156afbdf1" translate="yes" xml:space="preserve">
          <source>Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</source>
          <target state="translated">Поскольку большинство cons-ячеек используются как часть списков, мы называем любую структуру, состоящую из cons-ячеек, &lt;em&gt;структурой списка&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aecbe3fd5b632bec5904e4eeb626bf628ddaa189" translate="yes" xml:space="preserve">
          <source>Because non terminals cannot appear consecutively in the BNF grammar, it is difficult to correctly handle tokens that act as terminators, so the above grammar treats &lt;code&gt;&quot;;&quot;&lt;/code&gt; as a statement &lt;em&gt;separator&lt;/em&gt; instead, which SMIE can handle very well.</source>
          <target state="translated">Поскольку нетерминалы не могут появляться последовательно в грамматике BNF, трудно правильно обрабатывать токены, которые действуют как терминаторы, поэтому приведенная выше грамматика обрабатывает &lt;code&gt;&quot;;&quot;&lt;/code&gt; вместо этого в качестве &lt;em&gt;разделителя&lt;/em&gt; операторов , с которым SMIE может справиться очень хорошо.</target>
        </trans-unit>
        <trans-unit id="5527da9c81f706f4f494272f6a72b5e6c955dbcd" translate="yes" xml:space="preserve">
          <source>Because of the special nature of lazily bound variables, it is an error to set them (e.g. with &lt;code&gt;setq&lt;/code&gt;).</source>
          <target state="translated">Из-за особого характера переменных с отложенным связыванием их установка (например, с помощью &lt;code&gt;setq&lt;/code&gt; ) является ошибкой .</target>
        </trans-unit>
        <trans-unit id="4cc7eee6b3274dd2df5b26429c74414bad10f743" translate="yes" xml:space="preserve">
          <source>Because of the way lists are implemented on top of cons cells, you can treat &lt;code&gt;list-alist&lt;/code&gt; in the example above as a cons cell alist, where the value type is a list with a single element containing the real value.</source>
          <target state="translated">Поскольку списки реализованы поверх cons-ячеек, вы можете рассматривать &lt;code&gt;list-alist&lt;/code&gt; в приведенном выше примере как список cons-ячеек, где тип значения - это список с единственным элементом, содержащим реальное значение.</target>
        </trans-unit>
        <trans-unit id="d4920f7b17cfb9be5d144cd02f205a26abedb351" translate="yes" xml:space="preserve">
          <source>Because regular expression matching works only going forward, this is implemented by searching backwards from point for a match that ends at point. That can be quite slow if it has to search a long distance. You can bound the time required by specifying a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;limit&lt;/var&gt;, which says not to search before &lt;var&gt;limit&lt;/var&gt;. In this case, the match that is found must begin at or after &lt;var&gt;limit&lt;/var&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">Поскольку сопоставление регулярных выражений работает только в прямом направлении, это реализуется путем поиска в обратном направлении от точки совпадения, которое заканчивается в точке. Это может быть довольно медленным, если ему нужно искать на большом расстоянии. Вы можете ограничить необходимое время, указав &lt;code&gt;nil&lt;/code&gt; значение для &lt;var&gt;limit&lt;/var&gt; , которое говорит о том, что поиск не должен выполняться раньше &lt;var&gt;limit&lt;/var&gt; . В этом случае найденное совпадение должно начинаться на &lt;var&gt;limit&lt;/var&gt; или после него . Вот пример:</target>
        </trans-unit>
        <trans-unit id="891978e65a108dec966a02f2c109e3c7ab27e318" translate="yes" xml:space="preserve">
          <source>Because the byte-compiled code is evaluated by the byte-code interpreter, instead of being executed directly by the machine&amp;rsquo;s hardware (as true compiled code is), byte-code is completely transportable from machine to machine without recompilation. It is not, however, as fast as true compiled code.</source>
          <target state="translated">Поскольку скомпилированный в байтах код оценивается интерпретатором байт-кода, вместо того, чтобы выполняться непосредственно аппаратным обеспечением машины (как истинный скомпилированный код), байт-код полностью переносится с машины на машину без перекомпиляции. Однако это не так быстро, как настоящий скомпилированный код.</target>
        </trans-unit>
        <trans-unit id="9807276681c6c1286c20092e4291987485eca98a" translate="yes" xml:space="preserve">
          <source>Because the match data normally describe the most recent search only, you must be careful not to do another search inadvertently between the search you wish to refer back to and the use of the match data. If you can&amp;rsquo;t avoid another intervening search, you must save and restore the match data around it, to prevent it from being overwritten.</source>
          <target state="translated">Поскольку данные соответствия обычно описывают только самый последний поиск, вы должны быть осторожны, чтобы случайно не выполнить другой поиск между поиском, к которому вы хотите вернуться, и использованием данных соответствия. Если вы не можете избежать другого промежуточного поиска, вы должны сохранить и восстановить данные совпадений вокруг него, чтобы предотвратить их перезапись.</target>
        </trans-unit>
        <trans-unit id="2a9a557d3ce6491f8ae2018c1e6773fb2de8d6d8" translate="yes" xml:space="preserve">
          <source>Because the result of the evaluation is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;guard&lt;/code&gt; matches, &lt;code&gt;and&lt;/code&gt; matches, and control passes to that clause&amp;rsquo;s body forms.</source>
          <target state="translated">Поскольку результат оценки не равен &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;guard&lt;/code&gt; совпадения &lt;code&gt;and&lt;/code&gt; совпадения, а управление передается формам тела этого предложения.</target>
        </trans-unit>
        <trans-unit id="1db90825a22716e728468e821da490caab60e2bd" translate="yes" xml:space="preserve">
          <source>Because the symbols used for abbrevs are not interned in the usual obarray, they will never appear as the result of reading a Lisp expression; in fact, normally they are never used except by the code that handles abbrevs. Therefore, it is safe to use them in a nonstandard way.</source>
          <target state="translated">Поскольку символы,используемые для аббревиатур,не помещаются в обычный обаррей,они никогда не появятся в результате чтения выражения Lisp;на самом деле,обычно они никогда не используются,за исключением кода,который обрабатывает аббревиатуры.Поэтому их безопасно использовать нестандартным образом.</target>
        </trans-unit>
        <trans-unit id="4c851d66714e2bb452c04ba43899f653d596ccbc" translate="yes" xml:space="preserve">
          <source>Because the width of a given string depends on the flags that control the appearance of certain characters, &lt;code&gt;vertical-motion&lt;/code&gt; behaves differently, for a given piece of text, depending on the buffer it is in, and even on the selected window (because the width, the truncation flag, and display table may vary between windows). See &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;.</source>
          <target state="translated">Поскольку ширина данной строки зависит от флагов, которые управляют внешним видом определенных символов, &lt;code&gt;vertical-motion&lt;/code&gt; ведет себя по-разному для данного фрагмента текста, в зависимости от буфера, в котором он находится, и даже от выбранного окна (поскольку ширина , флаг усечения и таблица отображения могут различаться в разных окнах). См. &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Обычное отображение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed8353d04454f502b14b0705a480aaefdecdb99f" translate="yes" xml:space="preserve">
          <source>Because threads were a relatively late addition to Emacs Lisp, and due to the way dynamic binding was sometimes used in conjunction with &lt;code&gt;accept-process-output&lt;/code&gt;, by default a process is locked to the thread that created it. When a process is locked to a thread, output from the process can only be accepted by that thread.</source>
          <target state="translated">Поскольку потоки были относительно поздним добавлением к Emacs Lisp и из-за того, как динамическое связывание иногда использовалось вместе с &lt;code&gt;accept-process-output&lt;/code&gt; , по умолчанию процесс блокируется для потока, который его создал. Когда процесс заблокирован для потока, вывод процесса может быть принят только этим потоком.</target>
        </trans-unit>
        <trans-unit id="edefffca965b0362f640503f05f0a22864aaf0c5" translate="yes" xml:space="preserve">
          <source>Because we read from side to side in the inner loop, and from top to bottom in the outer loop, the effect of horizontal scrolling is not like that of textual or vertical scrolling. Textual scrolling involves selection of a portion of text to display, and vertical scrolling moves the window contents contiguously; but horizontal scrolling causes part of &lt;em&gt;each line&lt;/em&gt; to go off screen.</source>
          <target state="translated">Поскольку мы читаем из стороны в сторону во внутреннем цикле и сверху вниз во внешнем цикле, эффект горизонтальной прокрутки не похож на текстовую или вертикальную прокрутку. Текстовая прокрутка включает выбор части текста для отображения, а вертикальная прокрутка перемещает содержимое окна непрерывно; но при горизонтальной прокрутке часть &lt;em&gt;каждой строки&lt;/em&gt; уходит за пределы экрана.</target>
        </trans-unit>
        <trans-unit id="ca1ce0d49ba0f409cab2f1c7bbd925fafa44fcfe" translate="yes" xml:space="preserve">
          <source>Beeping</source>
          <target state="translated">Beeping</target>
        </trans-unit>
        <trans-unit id="17f7918b2f07183d74812fc33ccac59180f7ee50" translate="yes" xml:space="preserve">
          <source>Before Emacs can draw a character on a graphical display, it must select a &lt;em&gt;font&lt;/em&gt; for that character&lt;a href=&quot;#FOOT23&quot; name=&quot;DOCF23&quot;&gt;&lt;sup&gt;23&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">Прежде чем Emacs сможет нарисовать символ на графическом дисплее, он должен выбрать &lt;em&gt;шрифт&lt;/em&gt; для этого символа &lt;a href=&quot;#FOOT23&quot; name=&quot;DOCF23&quot;&gt;&lt;sup&gt;23&lt;/sup&gt;&lt;/a&gt; . См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Шрифты&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="13e5148e87ac77ce622c012484f91f5a2b40ed38" translate="yes" xml:space="preserve">
          <source>Before actually playing the sound, &lt;code&gt;play-sound&lt;/code&gt; calls the functions in the list &lt;code&gt;play-sound-functions&lt;/code&gt;. Each function is called with one argument, &lt;var&gt;sound&lt;/var&gt;.</source>
          <target state="translated">Перед фактическим воспроизведением звука &lt;code&gt;play-sound&lt;/code&gt; вызывает функции из списка &lt;code&gt;play-sound-functions&lt;/code&gt; . Каждая функция вызывается с одним аргументом - &lt;var&gt;sound&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="acfa912275db6abf7aab479d6b8b835a2b7d945e" translate="yes" xml:space="preserve">
          <source>Before any attempt to send the request, the application-specific conditions are checked. Since the &lt;code&gt;jsonrpc&lt;/code&gt; library can&amp;rsquo;t know what these conditions are, the program can use the &lt;code&gt;jsonrpc-connection-ready-p&lt;/code&gt; generic function (see &lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;Generic Functions&lt;/a&gt;) to specify them. The default method for this function returns &lt;code&gt;t&lt;/code&gt;, but you can add overriding methods that return &lt;code&gt;nil&lt;/code&gt; in some situations, based on the arguments passed to it, which are the &lt;code&gt;jsonrpc-connection&lt;/code&gt; object (see &lt;a href=&quot;jsonrpc-overview#JSONRPC-Overview&quot;&gt;JSONRPC Overview&lt;/a&gt;) and whichever value you passed as the &lt;code&gt;:deferred&lt;/code&gt; keyword argument.</source>
          <target state="translated">Перед любой попыткой отправить запрос проверяются условия конкретного приложения. Поскольку библиотека &lt;code&gt;jsonrpc&lt;/code&gt; не может знать, что это за условия, программа может использовать универсальную функцию &lt;code&gt;jsonrpc-connection-ready-p&lt;/code&gt; (см. &lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;Общие функции&lt;/a&gt; ), чтобы указать их. Метод по умолчанию для этой функции возвращает &lt;code&gt;t&lt;/code&gt; , но вы можете добавить методы переопределения, которые возвращают &lt;code&gt;nil&lt;/code&gt; в некоторых ситуациях на основе переданных ему аргументов, которыми являются объект &lt;code&gt;jsonrpc-connection&lt;/code&gt; (см. &lt;a href=&quot;jsonrpc-overview#JSONRPC-Overview&quot;&gt;Обзор JSONRPC&lt;/a&gt; ) и любое значение, которое вы передали как &lt;code&gt;:deferred&lt;/code&gt; аргумент ключевого слова.</target>
        </trans-unit>
        <trans-unit id="dcb73aafe29a27771bb410a3cc2ea9ba475e91b4" translate="yes" xml:space="preserve">
          <source>Before confirming unsaved changes, &lt;code&gt;kill-buffer&lt;/code&gt; calls the functions in the list &lt;code&gt;kill-buffer-query-functions&lt;/code&gt;, in order of appearance, with no arguments. The buffer being killed is the current buffer when they are called. The idea of this feature is that these functions will ask for confirmation from the user. If any of them returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;kill-buffer&lt;/code&gt; spares the buffer&amp;rsquo;s life.</source>
          <target state="translated">Перед подтверждением несохраненных изменений &lt;code&gt;kill-buffer&lt;/code&gt; вызывает функции из списка &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; в порядке появления без аргументов. Убиваемый буфер - это текущий буфер при их вызове. Идея этой функции заключается в том, что эти функции будут запрашивать подтверждение у пользователя. Если какой-либо из них возвращает &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;kill-buffer&lt;/code&gt; экономит жизнь буфера.</target>
        </trans-unit>
        <trans-unit id="b2c6df81ff9d3d92d5524e2fbe564a5cd653b1ec" translate="yes" xml:space="preserve">
          <source>Before creating the frame, this function ensures that Emacs is set up to display graphics. For instance, if Emacs has not processed X resources (e.g., if it was started on a text terminal), it does so at this time. In all other respects, this function behaves like &lt;code&gt;make-frame&lt;/code&gt; (see &lt;a href=&quot;creating-frames#Creating-Frames&quot;&gt;Creating Frames&lt;/a&gt;).</source>
          <target state="translated">Перед созданием фрейма эта функция гарантирует, что Emacs настроен для отображения графики. Например, если Emacs не обработал X-ресурсы (например, если он был запущен на текстовом терминале), он делает это в это время. Во всем остальном эта функция ведет себя как &lt;code&gt;make-frame&lt;/code&gt; (см. &lt;a href=&quot;creating-frames#Creating-Frames&quot;&gt;Создание кадров&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="838498ac25b34bcaba38e8d1736cb5d1213cbd8a" translate="yes" xml:space="preserve">
          <source>Before restoring the previous definitions, &lt;code&gt;unload-feature&lt;/code&gt; runs &lt;code&gt;remove-hook&lt;/code&gt; to remove functions in the library from certain hooks. These hooks include variables whose names end in &amp;lsquo;</source>
          <target state="translated">Перед восстановлением предыдущих определений &lt;code&gt;unload-feature&lt;/code&gt; запускает &lt;code&gt;remove-hook&lt;/code&gt; для удаления функций в библиотеке из определенных хуков. Эти хуки включают переменные, имена которых заканчиваются на '</target>
        </trans-unit>
        <trans-unit id="1f9591d8d77ddb1cb74b81db22ada52f623b6efb" translate="yes" xml:space="preserve">
          <source>Before suspending, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-hook&lt;/code&gt;. After the user resumes Emacs, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-resume-hook&lt;/code&gt;. See &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="translated">Перед приостановкой &lt;code&gt;suspend-emacs&lt;/code&gt; запускает обычный обработчик &lt;code&gt;suspend-hook&lt;/code&gt; . После того, как пользователь возобновляет работу Emacs, &lt;code&gt;suspend-emacs&lt;/code&gt; запускает обычную ловушку &lt;code&gt;suspend-resume-hook&lt;/code&gt; . См. &lt;a href=&quot;hooks#Hooks&quot;&gt;Крючки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88b944d20a7b391474416844b970d522dd303815" translate="yes" xml:space="preserve">
          <source>Before the display margins can display anything, you must give them a nonzero width. The usual way to do that is to set these variables:</source>
          <target state="translated">Перед тем,как на полях дисплея появится что-либо,необходимо дать им ненулевую ширину.Обычный способ сделать это-установить эти переменные:</target>
        </trans-unit>
        <trans-unit id="b44b66b4a5c9db407d2757ab95949e425a1d30d3" translate="yes" xml:space="preserve">
          <source>Before the double-click or double-drag event, Emacs generates a &lt;em&gt;double-down&lt;/em&gt; event when the user presses the button down for the second time. Its event type contains &amp;lsquo;</source>
          <target state="translated">Перед двойной щелчок или двойной дрэг случае, Emacs генерирует &lt;em&gt;двойной вниз&lt;/em&gt; событие , когда пользователь нажимает на кнопку вниз во второй раз. Его тип события содержит '</target>
        </trans-unit>
        <trans-unit id="27eeeabd3ce039e5d19034d398eafd77b5b99419" translate="yes" xml:space="preserve">
          <source>Before you do this, make sure the defun has enough close parentheses. Otherwise,</source>
          <target state="translated">Перед тем,как это сделать,убедитесь,что на дефунте достаточно круглых скобок.В противном случае,</target>
        </trans-unit>
        <trans-unit id="cb9703a6b294ccc0880d4c1dfd4f9f3daf981cdb" translate="yes" xml:space="preserve">
          <source>Begin your module by including the header file</source>
          <target state="translated">Начните работу модуля с включения заголовочного файла</target>
        </trans-unit>
        <trans-unit id="b4042d6d0e34481a13a0bd70105a92db402dff7f" translate="yes" xml:space="preserve">
          <source>Beginning of buffer</source>
          <target state="translated">Начало буфера</target>
        </trans-unit>
        <trans-unit id="7967dbe1bdfdc4fa11437c00eb1b6a94e7b1839d" translate="yes" xml:space="preserve">
          <source>Being quick and simple, &lt;code&gt;unsafep&lt;/code&gt; does a very light analysis and rejects many Lisp expressions that are actually safe. There are no known cases where &lt;code&gt;unsafep&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; for an unsafe expression. However, a safe Lisp expression can return a string with a &lt;code&gt;display&lt;/code&gt; property, containing an associated Lisp expression to be executed after the string is inserted into a buffer. This associated expression can be a virus. In order to be safe, you must delete properties from all strings calculated by user code before inserting them into buffers.</source>
          <target state="translated">Будучи быстрым и простым, &lt;code&gt;unsafep&lt;/code&gt; выполняет очень легкий анализ и отклоняет многие выражения Лиспа, которые на самом деле безопасны. Нет известных случаев, когда &lt;code&gt;unsafep&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; для небезопасного выражения. Однако безопасное выражение Лиспа может возвращать строку со свойством &lt;code&gt;display&lt;/code&gt; , содержащую связанное выражение Лиспа, которое должно быть выполнено после того, как строка вставлена ​​в буфер. Это ассоциированное выражение может быть вирусом. В целях безопасности вы должны удалить свойства из всех строк, вычисленных пользовательским кодом, прежде чем вставлять их в буферы.</target>
        </trans-unit>
        <trans-unit id="cd79998f02d02ee1f54b550965880ade28c0e5ae" translate="yes" xml:space="preserve">
          <source>Below is a table explaining each element. Note that last &lt;code&gt;heap&lt;/code&gt; entry is optional and present only if an underlying &lt;code&gt;malloc&lt;/code&gt; implementation provides &lt;code&gt;mallinfo&lt;/code&gt; function.</source>
          <target state="translated">Ниже приводится таблица, объясняющая каждый элемент. Обратите внимание, что последняя запись в &lt;code&gt;heap&lt;/code&gt; является необязательной и присутствует только в том случае, если базовая реализация &lt;code&gt;malloc&lt;/code&gt; предоставляет функцию &lt;code&gt;mallinfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3840ae760c97e9024f5cab124e17dbea9c19d2c" translate="yes" xml:space="preserve">
          <source>Below is a table of the classes you can use in a character alternative, and what they mean. Note that the &amp;lsquo;</source>
          <target state="translated">Ниже приведена таблица классов, которые можно использовать в качестве альтернативы символов, и их значения. Обратите внимание, что '</target>
        </trans-unit>
        <trans-unit id="01bae04f3ae2801c065a4011c8954162185dde4a" translate="yes" xml:space="preserve">
          <source>Below there is a description of a few subtypes of &lt;code&gt;Lisp_Vectorlike&lt;/code&gt;. Buffer object represents the text to display and edit. Window is the part of display structure which shows the buffer or is used as a container to recursively place other windows on the same frame. (Do not confuse Emacs Lisp window object with the window as an entity managed by the user interface system like X; in Emacs terminology, the latter is called frame.) Finally, process object is used to manage the subprocesses.</source>
          <target state="translated">Ниже приводится описание нескольких подтипов &lt;code&gt;Lisp_Vectorlike&lt;/code&gt; . Объект Buffer представляет текст для отображения и редактирования. Окно - это часть структуры отображения, которая показывает буфер или используется как контейнер для рекурсивного размещения других окон в том же кадре. (Не путайте объект окна Emacs Lisp с окном как объектом, управляемым системой пользовательского интерфейса, такой как X; в терминологии Emacs последний называется фреймом.) Наконец, объект процесса используется для управления подпроцессами.</target>
        </trans-unit>
        <trans-unit id="5c8be3db4820388729d86b1200b856644093f20c" translate="yes" xml:space="preserve">
          <source>Below we will give a number of guidelines to redeem the frustration mentioned above and thus to avoid literally losing buffers in-between the windows of a frame.</source>
          <target state="translated">Ниже мы дадим ряд рекомендаций,чтобы выкупить разочарование,упомянутое выше,и таким образом избежать буквально потери буферов между окнами рамы.</target>
        </trans-unit>
        <trans-unit id="0353802f217c5a533a465f68ec4f0d8faa7c50cf" translate="yes" xml:space="preserve">
          <source>Below, we show first the regexp as a string in Lisp syntax (to distinguish spaces from tab characters), and then the result of evaluating it. The string constant begins and ends with a double-quote. &amp;lsquo;</source>
          <target state="translated">Ниже мы сначала показываем регулярное выражение как строку в синтаксисе Лиспа (чтобы отличить пробелы от символов табуляции), а затем результат его вычисления. Строковая константа начинается и заканчивается двойными кавычками. '</target>
        </trans-unit>
        <trans-unit id="3cca15ebda8dce9819d62b75dc10ad2c1696871b" translate="yes" xml:space="preserve">
          <source>Berkeley BSD and its variants.</source>
          <target state="translated">Беркли BSD и его варианты.</target>
        </trans-unit>
        <trans-unit id="01ea07f92a42549b5de550cce8a6d1e85ce49161" translate="yes" xml:space="preserve">
          <source>Beware: this property operates at a very low level, and affects a lot of code in unexpected ways. So use it with extreme caution. A common misuse is to put an intangible property on invisible text, which is actually unnecessary since the command loop will move point outside of the invisible text at the end of each command anyway. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;. For these reasons, this property is obsolete; use the &lt;code&gt;cursor-intangible&lt;/code&gt; property instead.</source>
          <target state="translated">Осторожно: это свойство работает на очень низком уровне и неожиданным образом влияет на большой объем кода. Поэтому используйте его с особой осторожностью. Распространенное неправильное использование - наложение неосязаемого свойства на невидимый текст, что на самом деле не нужно, поскольку цикл команд все равно перемещает точку за пределы невидимого текста в конце каждой команды. См. Раздел &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Регулировка точки&lt;/a&gt; . По этим причинам это свойство устарело; используйте &lt;code&gt;cursor-intangible&lt;/code&gt; вместо свойства.</target>
        </trans-unit>
        <trans-unit id="f7f5f613a250e0e11c1b4577276a09871c48b610" translate="yes" xml:space="preserve">
          <source>Beyond the basic vector, a lot of objects like markers, overlays and buffers are managed as if they were vectors. The corresponding C data structures include the &lt;code&gt;union vectorlike_header&lt;/code&gt; field whose &lt;code&gt;size&lt;/code&gt; member contains the subtype enumerated by &lt;code&gt;enum pvec_type&lt;/code&gt; and an information about how many &lt;code&gt;Lisp_Object&lt;/code&gt; fields this structure contains and what the size of the rest data is. This information is needed to calculate the memory footprint of an object, and used by the vector allocation code while iterating over the vector blocks.</source>
          <target state="translated">Помимо базового вектора, многие объекты, такие как маркеры, наложения и буферы, управляются так, как если бы они были векторами. Соответствующие структуры данных C включают &lt;code&gt;union vectorlike_header&lt;/code&gt; поле vectorlike_header , член &lt;code&gt;size&lt;/code&gt; которого содержит подтип, перечисляемый &lt;code&gt;enum pvec_type&lt;/code&gt; , и информацию о том, сколько полей &lt;code&gt;Lisp_Object&lt;/code&gt; содержит эта структура и каков размер остальных данных. Эта информация необходима для расчета объема памяти, занимаемого объектом, и используется кодом распределения векторов при итерации по векторным блокам.</target>
        </trans-unit>
        <trans-unit id="f2b8d702e0ae298ec5dfa21f68f107c0b717e304" translate="yes" xml:space="preserve">
          <source>Bidirectional Display</source>
          <target state="translated">Двунаправленный дисплей</target>
        </trans-unit>
        <trans-unit id="0f761761aa75d96b2cf2c46b89a33d4202f1f95c" translate="yes" xml:space="preserve">
          <source>Bidirectional reordering can have surprising and unpleasant effects when two strings with bidirectional content are juxtaposed in a buffer, or otherwise programmatically concatenated into a string of text. A typical problematic case is when a buffer consists of sequences of text fields separated by whitespace or punctuation characters, like Buffer Menu mode or Rmail Summary Mode. Because the punctuation characters used as separators have &lt;em&gt;weak directionality&lt;/em&gt;, they take on the directionality of surrounding text. As result, a numeric field that follows a field with bidirectional content can be displayed &lt;em&gt;to the left&lt;/em&gt; of the preceding field, messing up the expected layout. There are several ways to avoid this problem:</source>
          <target state="translated">Двунаправленное переупорядочение может иметь неожиданные и неприятные последствия, когда две строки с двунаправленным содержимым сопоставляются в буфере или иным образом программно объединяются в строку текста. Типичный проблемный случай - это когда буфер состоит из последовательностей текстовых полей, разделенных пробелами или знаками пунктуации, как в режиме меню буфера или в режиме сводки Rmail. Поскольку символы пунктуации, используемые в качестве разделителей, имеют &lt;em&gt;слабую направленность&lt;/em&gt; , они принимают направленность окружающего текста. В результате числовое поле, следующее за полем с двунаправленным содержимым, может отображаться &lt;em&gt;слева&lt;/em&gt; от предыдущего поля, нарушая ожидаемый макет. Есть несколько способов избежать этой проблемы:</target>
        </trans-unit>
        <trans-unit id="7618266932012d1bb7d78a709b3b8de0c7e01623" translate="yes" xml:space="preserve">
          <source>Bignums can have arbitrary precision. Operations that overflow a fixnum will return a bignum instead.</source>
          <target state="translated">Сигналы могут иметь произвольную точность.Операции,которые переполняют фикснум,возвращают двоичную единицу.</target>
        </trans-unit>
        <trans-unit id="fb38340a365bddb7a78416de50a44b6a7efdea98" translate="yes" xml:space="preserve">
          <source>Bind the symbol &lt;var&gt;ref&lt;/var&gt; to a submatch that matches &lt;var&gt;rx-expr&lt;/var&gt;&lt;small&gt;...&lt;/small&gt;. &lt;var&gt;ref&lt;/var&gt; is bound in &lt;var&gt;body-forms&lt;/var&gt; to the string of the submatch or nil, but can also be used in &lt;code&gt;backref&lt;/code&gt;.</source>
          <target state="translated">Bind символ &lt;var&gt;ref&lt;/var&gt; к submatch , что матчи &lt;var&gt;rx-expr&lt;/var&gt; &lt;small&gt;...&lt;/small&gt; . &lt;var&gt;ref&lt;/var&gt; привязан в &lt;var&gt;body-forms&lt;/var&gt; к строке submatch или nil, но также может использоваться в &lt;code&gt;backref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4379c6bcd5778b843b030784559be7b79a5580f0" translate="yes" xml:space="preserve">
          <source>Binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value prevents output primitives from calling the function specified by &lt;code&gt;select-safe-coding-system-function&lt;/code&gt; (see &lt;a href=&quot;user_002dchosen-coding-systems#User_002dChosen-Coding-Systems&quot;&gt;User-Chosen Coding Systems&lt;/a&gt;). This is because</source>
          <target state="translated">Привязка &lt;code&gt;coding-system-for-write&lt;/code&gt; к значению, отличному от &lt;code&gt;nil&lt;/code&gt; ,не позволяет выходным примитивам вызывать функцию, указанную &lt;code&gt;select-safe-coding-system-function&lt;/code&gt; (см. &lt;a href=&quot;user_002dchosen-coding-systems#User_002dChosen-Coding-Systems&quot;&gt;Выбранные пользователем системы кодирования&lt;/a&gt; ). Это потому что</target>
        </trans-unit>
        <trans-unit id="fd1754f82b6bd628f04b3f5c068badfc9846c322" translate="yes" xml:space="preserve">
          <source>Binding module functions to Lisp symbols</source>
          <target state="translated">Функции привязного модуля к символам Lisp</target>
        </trans-unit>
        <trans-unit id="5d759eb09f19bf06ed84ff18e43aee3a19e46979" translate="yes" xml:space="preserve">
          <source>Bitwise Operations on Integers</source>
          <target state="translated">Побитовые операции с интеграторами</target>
        </trans-unit>
        <trans-unit id="93fd851ff63a4d886e2fa5d2be01e88deb486b52" translate="yes" xml:space="preserve">
          <source>Blinking Parentheses</source>
          <target state="translated">Мигающие скобки</target>
        </trans-unit>
        <trans-unit id="6ac648d45e59dfdc6715fe0e3cbd86c82820c6b6" translate="yes" xml:space="preserve">
          <source>Block until &lt;var&gt;thread&lt;/var&gt; exits, or until the current thread is signaled. It returns the result of the &lt;var&gt;thread&lt;/var&gt; function. If &lt;var&gt;thread&lt;/var&gt; has already exited, this returns immediately.</source>
          <target state="translated">Блокировать, пока &lt;var&gt;thread&lt;/var&gt; завершится, или пока текущий поток не получит сигнал. Он возвращает результат функции &lt;var&gt;thread&lt;/var&gt; . Если &lt;var&gt;thread&lt;/var&gt; уже вышел, это немедленно возвращается.</target>
        </trans-unit>
        <trans-unit id="c6929c141afbaefdc4afd63ac4b5596956cfa67c" translate="yes" xml:space="preserve">
          <source>Bool-Vector Type</source>
          <target state="translated">тип Бул-Вектор</target>
        </trans-unit>
        <trans-unit id="882f4e1ca02e65db176c079c22995b90c25fc39c" translate="yes" xml:space="preserve">
          <source>Bool-vectors</source>
          <target state="translated">Bool-vectors</target>
        </trans-unit>
        <trans-unit id="c0a12baab63ceb798d7bac34fa38c4622e4b0373" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;kill-ring&lt;/code&gt; and &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; are Lisp variables whose values are normally lists. The word &amp;ldquo;pointer&amp;rdquo; in the name of the &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; indicates that the variable&amp;rsquo;s purpose is to identify one element of the list for use by the next yank command.</source>
          <target state="translated">И &lt;code&gt;kill-ring&lt;/code&gt; , и &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; - это переменные Лиспа, значения которых обычно являются списками. Слово &amp;laquo;указатель&amp;raquo; в имени &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; указывает, что цель переменной - идентифицировать один элемент списка для использования следующей командой восстановления.</target>
        </trans-unit>
        <trans-unit id="2fdc0bac385ea879dbde52d2dd508f2b5a448d88" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;read-from-minibuffer&lt;/code&gt; and &lt;code&gt;completing-read&lt;/code&gt; add new elements to the history list automatically, and provide commands to allow the user to reuse items on the list. The only thing your program needs to do to use a history list is to initialize it and to pass its name to the input functions when you wish. But it is safe to modify the list by hand when the minibuffer input functions are not using it.</source>
          <target state="translated">Как &lt;code&gt;read-from-minibuffer&lt;/code&gt; и &lt;code&gt;completing-read&lt;/code&gt; автоматически добавляют новые элементы в список истории и предоставляют команды, позволяющие пользователю повторно использовать элементы в списке. Единственное, что нужно сделать вашей программе для использования списка истории, - это инициализировать его и передать его имя входным функциям, когда вы захотите. Но можно безопасно изменять список вручную, когда функции ввода минибуфера его не используют.</target>
        </trans-unit>
        <trans-unit id="fc66435a82b20252191500c38ab3e5707fac603e" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;yes-or-no-p&lt;/code&gt; and &lt;code&gt;y-or-n-p&lt;/code&gt; use the minibuffer.</source>
          <target state="translated">И &lt;code&gt;yes-or-no-p&lt;/code&gt; , и &lt;code&gt;y-or-n-p&lt;/code&gt; используют минибуфер.</target>
        </trans-unit>
        <trans-unit id="dfd6cff3dbda1d13ebd279438e41124efaba93e7" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;error-symbol&lt;/var&gt; and &lt;var&gt;data&lt;/var&gt; are available to any error handlers that handle the error: &lt;code&gt;condition-case&lt;/code&gt; binds a local variable to a list of the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; .
&lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; (see &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Handling Errors&lt;/a&gt;).</source>
          <target state="translated">И &lt;var&gt;error-symbol&lt;/var&gt; и &lt;var&gt;data&lt;/var&gt; доступны для любых обработчиков ошибок, которые обрабатывают ошибку: &lt;code&gt;condition-case&lt;/code&gt; привязывает локальную переменную к списку формы &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; . &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; (см. &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Обработка ошибок&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="62da8c794cc6a7eb9ffe501a46f505c4219f98f2" translate="yes" xml:space="preserve">
          <source>Both forms of this definition (with backquote and without) suffer from the defect that &lt;var&gt;final&lt;/var&gt; is evaluated on every iteration. If &lt;var&gt;final&lt;/var&gt; is a constant, this is not a problem. If it is a more complex form, say &lt;code&gt;(long-complex-calculation x)&lt;/code&gt;, this can slow down the execution significantly. If &lt;var&gt;final&lt;/var&gt; has side effects, executing it more than once is probably incorrect.</source>
          <target state="translated">Обе формы этого определения (с обратной кавычкой и без) страдают от дефекта, заключающегося в том, что &lt;var&gt;final&lt;/var&gt; вычисляется на каждой итерации. Если &lt;var&gt;final&lt;/var&gt; является константой, это не проблема. Если это более сложная форма, скажем &lt;code&gt;(long-complex-calculation x)&lt;/code&gt; , это может значительно замедлить выполнение. Если &lt;var&gt;final&lt;/var&gt; имеет побочные эффекты, выполнение его более одного раза, вероятно, неверно.</target>
        </trans-unit>
        <trans-unit id="4b35a12cfb8382543b92627bbee4b04423faea8d" translate="yes" xml:space="preserve">
          <source>Both lists and arrays are classified as sequences.</source>
          <target state="translated">И списки,и массивы классифицируются как последовательности.</target>
        </trans-unit>
        <trans-unit id="d2f3804efa9fdf3073f4d412bb85880a0a67b5c0" translate="yes" xml:space="preserve">
          <source>Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol &lt;code&gt;a&lt;/code&gt; is associated with the number &lt;code&gt;1&lt;/code&gt;, and the string &lt;code&gt;&quot;b&quot;&lt;/code&gt; is associated with the &lt;em&gt;list&lt;/em&gt;&lt;code&gt;(2 3)&lt;/code&gt;, which is the &lt;small&gt;CDR&lt;/small&gt; of the alist element:</source>
          <target state="translated">И значения, и ключи в списке могут быть любыми объектами Lisp. Например, в следующем alist символ &lt;code&gt;a&lt;/code&gt; связан с числом &lt;code&gt;1&lt;/code&gt; , а строка &lt;code&gt;&quot;b&quot;&lt;/code&gt; связана со &lt;em&gt;списком &lt;/em&gt; &lt;code&gt;(2 3)&lt;/code&gt; , который является &lt;small&gt;CDR&lt;/small&gt; элемента alist:</target>
        </trans-unit>
        <trans-unit id="cce7f2f2f0dc525117a70d581d9c335212145e5b" translate="yes" xml:space="preserve">
          <source>Bottom</source>
          <target state="translated">Bottom</target>
        </trans-unit>
        <trans-unit id="e61ada95a3801a523f8d48042eaed868415934b4" translate="yes" xml:space="preserve">
          <source>Breaking on an event.</source>
          <target state="translated">Разрыв на мероприятии.</target>
        </trans-unit>
        <trans-unit id="25a85b6e8b7cc5b5a89123c777d9b420bfa8cc33" translate="yes" xml:space="preserve">
          <source>Breakpoints at stop points.</source>
          <target state="translated">Точки останова в точках остановки.</target>
        </trans-unit>
        <trans-unit id="50f88da05c8e174324af021a4ee24bc168eb0c3d" translate="yes" xml:space="preserve">
          <source>Breaks</source>
          <target state="translated">Breaks</target>
        </trans-unit>
        <trans-unit id="ee60d60ea805fbda38f6f538481a92d3787df0b9" translate="yes" xml:space="preserve">
          <source>Brief description</source>
          <target state="translated">краткое описание</target>
        </trans-unit>
        <trans-unit id="3fb0fc86dfa0b9d7362bd38d269b717749f04cef" translate="yes" xml:space="preserve">
          <source>Buffer Basics</source>
          <target state="translated">Основы буфера</target>
        </trans-unit>
        <trans-unit id="c027215488849466cacd3006649b1340a2edd0fc" translate="yes" xml:space="preserve">
          <source>Buffer File Name</source>
          <target state="translated">Имя файла буфера</target>
        </trans-unit>
        <trans-unit id="a4af6911c145bae353cfba5cde3bbb16bdca445e" translate="yes" xml:space="preserve">
          <source>Buffer Internals</source>
          <target state="translated">Буферные интерналы</target>
        </trans-unit>
        <trans-unit id="5032b3933a4bf66e8948fdd3b1195bf2ec955ec7" translate="yes" xml:space="preserve">
          <source>Buffer Modification</source>
          <target state="translated">Модификация буфера</target>
        </trans-unit>
        <trans-unit id="a1220d5a5dc0d3413a288b7d866d2b909c573bb8" translate="yes" xml:space="preserve">
          <source>Buffer Modification Time</source>
          <target state="translated">Время модификации буфера</target>
        </trans-unit>
        <trans-unit id="44e02f9bcee199b59cbd729f000935b0a07991dd" translate="yes" xml:space="preserve">
          <source>Buffer Names</source>
          <target state="translated">имена буферов</target>
        </trans-unit>
        <trans-unit id="ccf9f9fdff4870f16ae30767ca4be6fe76523e15" translate="yes" xml:space="preserve">
          <source>Buffer Parameters</source>
          <target state="translated">Параметры буфера</target>
        </trans-unit>
        <trans-unit id="e93f01132bbaec25c49799efddeb64957f02afd2" translate="yes" xml:space="preserve">
          <source>Buffer Text Notation</source>
          <target state="translated">Нотация текста буфера</target>
        </trans-unit>
        <trans-unit id="f1294c425911ac20d751cb9d1c51979e6e34f62e" translate="yes" xml:space="preserve">
          <source>Buffer Type</source>
          <target state="translated">Тип буфера</target>
        </trans-unit>
        <trans-unit id="abcd68a1e18c1b87353060b6dc458244da82927b" translate="yes" xml:space="preserve">
          <source>Buffer is read-only</source>
          <target state="translated">Буфер доступен только для чтения</target>
        </trans-unit>
        <trans-unit id="344030f3634d1baa3762609d3692b8f3c1316b48" translate="yes" xml:space="preserve">
          <source>Buffer positions and motion functions.</source>
          <target state="translated">Положения буфера и функции движения.</target>
        </trans-unit>
        <trans-unit id="6246ccf7dd19ff26d69c92fb853ac66fb5ae4f89" translate="yes" xml:space="preserve">
          <source>Buffer positions are measured in character units. This function returns the byte-position corresponding to buffer position &lt;var&gt;position&lt;/var&gt; in the current buffer. This is 1 at the start of the buffer, and counts upward in bytes. If &lt;var&gt;position&lt;/var&gt; is out of range, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Позиции буфера измеряются в символьных единицах. Эта функция возвращает байт-положение , соответствующее позиции буфера &lt;var&gt;position&lt;/var&gt; в текущем буфере. Это 1 в начале буфера и увеличивается в байтах. Если &lt;var&gt;position&lt;/var&gt; вне допустимого диапазона, значение равно &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35ca209a656833f1530433e2982a81634d31ea0e" translate="yes" xml:space="preserve">
          <source>Buffer positions indicating which text is on-screen in a window.</source>
          <target state="translated">Позиции буфера,указывающие на то,какой текст находится на экране в окне.</target>
        </trans-unit>
        <trans-unit id="8a53998ea65d2c55189b85c0ba6f6abc07875258" translate="yes" xml:space="preserve">
          <source>Buffer-Local Variables</source>
          <target state="translated">буферно-локальные переменные</target>
        </trans-unit>
        <trans-unit id="e1f999c3ef7294166b2203dddf8a38a2a12863ad" translate="yes" xml:space="preserve">
          <source>Buffer-specific information that is directly accessible is stored in &lt;em&gt;buffer-local&lt;/em&gt; variable bindings, which are variable values that are effective only in a particular buffer. This feature allows each buffer to override the values of certain variables. Most major modes override variables such as &lt;code&gt;fill-column&lt;/code&gt; or &lt;code&gt;comment-column&lt;/code&gt; in this way. For more information about buffer-local variables and functions related to them, see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</source>
          <target state="translated">Информация о конкретном &lt;em&gt;буфере,&lt;/em&gt; доступная напрямую, хранится в привязках переменных, &lt;em&gt;локальных&lt;/em&gt; в &lt;em&gt;буфере&lt;/em&gt; , которые представляют собой значения переменных, которые действуют только в определенном буфере. Эта функция позволяет каждому буферу переопределять значения определенных переменных. Таким образом, большинство основных режимов переопределяют такие переменные, как &lt;code&gt;fill-column&lt;/code&gt; или &lt;code&gt;comment-column&lt;/code&gt; . Дополнительные сведения о переменных, локальных в буфере, и связанных с ними функциях см. В разделе &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Локальные переменные буфера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea28d2b0e2e067c2d49b361f79f8dd13430b1c1f" translate="yes" xml:space="preserve">
          <source>Buffer-wide commands and bindings for buttons.</source>
          <target state="translated">Широкие буферные команды и привязки для кнопок.</target>
        </trans-unit>
        <trans-unit id="4cbcd2f7b704b607643b54842a2d38a1465e1a06" translate="yes" xml:space="preserve">
          <source>Buffers</source>
          <target state="translated">Buffers</target>
        </trans-unit>
        <trans-unit id="c34ea999c856831b2f1f1b93ec2c55bca01f7339" translate="yes" xml:space="preserve">
          <source>Buffers and Windows</source>
          <target state="translated">Буферы и Windows</target>
        </trans-unit>
        <trans-unit id="89fab4e05ae4baad776ec1df498d67259c031ce8" translate="yes" xml:space="preserve">
          <source>Buffers are displayed in windows.</source>
          <target state="translated">Буферы отображаются в окнах.</target>
        </trans-unit>
        <trans-unit id="813e70bd28e3a98cb6625b026a7542aa93fd1a0a" translate="yes" xml:space="preserve">
          <source>Buffers exist until explicitly killed.</source>
          <target state="translated">Буферы существуют до тех пор,пока их не убьют.</target>
        </trans-unit>
        <trans-unit id="5807d4a79a20e298c7a061e07bafbf257b7f1329" translate="yes" xml:space="preserve">
          <source>Buffers have no read syntax. They print in hash notation, showing the buffer name.</source>
          <target state="translated">У буферов нет синтаксиса чтения.Они печатают в хэш-нотации,показывая имя буфера.</target>
        </trans-unit>
        <trans-unit id="c849b71243437a37c01b415363a9e00d3f75220f" translate="yes" xml:space="preserve">
          <source>Buffers in Emacs editing are objects that have distinct names and hold text that can be edited. Buffers appear to Lisp programs as a special data type. You can think of the contents of a buffer as a string that you can extend; insertions and deletions may occur in any part of the buffer. See &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">Буферы при редактировании Emacs - это объекты, которые имеют разные имена и содержат текст, который можно редактировать. Для программ на Лиспе буферы представляют собой особый тип данных. Вы можете думать о содержимом буфера как о строке, которую вы можете расширить; вставки и удаления могут происходить в любой части буфера. См. &lt;a href=&quot;text#Text&quot;&gt;Текст&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d9c37d98ed9d04e80b306fce37d88ced34649fb" translate="yes" xml:space="preserve">
          <source>Buffers that are ephemeral and generally uninteresting to the user have names starting with a space, so that the &lt;code&gt;list-buffers&lt;/code&gt; and &lt;code&gt;buffer-menu&lt;/code&gt; commands don&amp;rsquo;t mention them (but if such a buffer visits a file, it &lt;strong&gt;is&lt;/strong&gt; mentioned). A name starting with space also initially disables recording undo information; see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;.</source>
          <target state="translated">Буфера , которые являются эфемерными и вообще неинтересны пользователем имеют имена , начинающиеся с пробелом, так что &lt;code&gt;list-buffers&lt;/code&gt; и &lt;code&gt;buffer-menu&lt;/code&gt; команд не упоминать о них (но если таком буфере посещения файл, он &lt;strong&gt;будет&lt;/strong&gt; указан). Имя, начинающееся с пробела, также изначально отключает запись информации об отмене; см. &lt;a href=&quot;undo#Undo&quot;&gt;Отменить&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="330d744f9b4b4abc2c70c54c6b6b286c98dced2b" translate="yes" xml:space="preserve">
          <source>Build a new evaluation list from the contents of the buffer (&lt;code&gt;edebug-update-eval-list&lt;/code&gt;).</source>
          <target state="translated">Создайте новый оценочный список из содержимого буфера ( &lt;code&gt;edebug-update-eval-list&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="317d4e3a3a04e5eea5fc26c035b1ef9dd209902c" translate="yes" xml:space="preserve">
          <source>Build new types from other types or data.</source>
          <target state="translated">Постройте новые типы из других типов или данных.</target>
        </trans-unit>
        <trans-unit id="b1f5f048510e296c0efaf69fd58cab73cd422bd8" translate="yes" xml:space="preserve">
          <source>Building Cons Cells and Lists</source>
          <target state="translated">Строить клетки и списки Cons</target>
        </trans-unit>
        <trans-unit id="bdc049a5ba45c2fd12b217cecac69626d97e5db0" translate="yes" xml:space="preserve">
          <source>Building Emacs</source>
          <target state="translated">Строительный Имакс</target>
        </trans-unit>
        <trans-unit id="f53b042cb4d6b635c59397892faa831033884cbc" translate="yes" xml:space="preserve">
          <source>Building Emacs requires GNU Make version 3.81 or later.</source>
          <target state="translated">Для сборки Emacs требуется GNU Make версии 3.81 или более поздней.</target>
        </trans-unit>
        <trans-unit id="79b6b1f02a69a8e5241277580817571424a17daa" translate="yes" xml:space="preserve">
          <source>Building and dumping Emacs; internal data structures.</source>
          <target state="translated">Строительство и демпинг Emacs;внутренние структуры данных.</target>
        </trans-unit>
        <trans-unit id="34812aaa741da1103c385a52808aa91b80e9594f" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;rx&lt;/code&gt; forms, like &lt;code&gt;digit&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;, cannot be redefined.</source>
          <target state="translated">Встроенные формы &lt;code&gt;rx&lt;/code&gt; , такие как &lt;code&gt;digit&lt;/code&gt; и &lt;code&gt;group&lt;/code&gt; , не могут быть переопределены.</target>
        </trans-unit>
        <trans-unit id="f1c7bd5dfbc70feff63bb4c975105aed8228177c" translate="yes" xml:space="preserve">
          <source>Builtin Commands</source>
          <target state="translated">Команды строителей</target>
        </trans-unit>
        <trans-unit id="eb37717154ce80760d9e952968529a057b6b75e2" translate="yes" xml:space="preserve">
          <source>Builtin Constants</source>
          <target state="translated">Строить константы</target>
        </trans-unit>
        <trans-unit id="ce64a3485e5540eb2d738ffca93bc4a6a99dac9d" translate="yes" xml:space="preserve">
          <source>Builtin Functions</source>
          <target state="translated">Функции сборки</target>
        </trans-unit>
        <trans-unit id="a9cc087245dc67aa0bcbea3954c8f85e35fb9e6d" translate="yes" xml:space="preserve">
          <source>Builtin Macros</source>
          <target state="translated">Builtin Macros</target>
        </trans-unit>
        <trans-unit id="c87bbec5d329be7d9ab3d4f7f28179b67b985893" translate="yes" xml:space="preserve">
          <source>Builtin Special Forms</source>
          <target state="translated">Строить специальные формы</target>
        </trans-unit>
        <trans-unit id="ce27ad322fdf4fa3514cbeb626501e0ed27f14ae" translate="yes" xml:space="preserve">
          <source>Builtin User Options</source>
          <target state="translated">Сборка параметров пользователя</target>
        </trans-unit>
        <trans-unit id="843ed68047eb8a91c66fd38a5ea1a9307d042738" translate="yes" xml:space="preserve">
          <source>Builtin Variables</source>
          <target state="translated">Строительные переменные</target>
        </trans-unit>
        <trans-unit id="5067c37a304c3bbf7192b5da6e72fcd4d8ed1b67" translate="yes" xml:space="preserve">
          <source>But if you type a control combination not in</source>
          <target state="translated">Но если вы набираете комбинацию управления не в</target>
        </trans-unit>
        <trans-unit id="5a9ec335ac0058bc8871067e4469ec28043b246e" translate="yes" xml:space="preserve">
          <source>But this will create conflicts for &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt;: on the one hand, the IF rule implies (among many other things) that &lt;code&gt;&quot;ELSE&quot; = &quot;END&quot;&lt;/code&gt;; but on the other hand, since &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; appears within &lt;code&gt;cases&lt;/code&gt;, which appears left of &lt;code&gt;&quot;END&quot;&lt;/code&gt;, we also have &lt;code&gt;&quot;ELSE&quot; &amp;gt; &quot;END&quot;&lt;/code&gt;. We can solve the conflict either by using:</source>
          <target state="translated">Но это вызовет конфликты для &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; : с одной стороны, правило ЕСЛИ подразумевает (среди прочего), что &lt;code&gt;&quot;ELSE&quot; = &quot;END&quot;&lt;/code&gt; ; но с другой стороны, так как &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; появляется в тех &lt;code&gt;cases&lt;/code&gt; , которые появляются слева от &lt;code&gt;&quot;END&quot;&lt;/code&gt; , мы также имеем &lt;code&gt;&quot;ELSE&quot; &amp;gt; &quot;END&quot;&lt;/code&gt; . Мы можем решить конфликт, используя:</target>
        </trans-unit>
        <trans-unit id="2a081c2786dbf00aa6d8f9b177ec4a1ad92a73fe" translate="yes" xml:space="preserve">
          <source>But this would add multiple elements if the library is reloaded. To avoid the problem, use &lt;code&gt;add-to-list&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;):</source>
          <target state="translated">Но это добавит несколько элементов, если библиотека будет перезагружена. Чтобы избежать проблемы, используйте &lt;code&gt;add-to-list&lt;/code&gt; (см. &lt;a href=&quot;list-variables#List-Variables&quot;&gt;Переменные списка&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="07ec1dfa598ebfb12e7443602444d7a051d224dd" translate="yes" xml:space="preserve">
          <source>But we recommend &lt;code&gt;copy-sequence&lt;/code&gt; for this purpose (see &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;).</source>
          <target state="translated">Но для этой цели мы рекомендуем &lt;code&gt;copy-sequence&lt;/code&gt; (см. &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Функции последовательности&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c0bd785491e817f0f44e14205af6a59e1a447d90" translate="yes" xml:space="preserve">
          <source>But you should use &lt;code&gt;advice-add&lt;/code&gt; and &lt;code&gt;advice-remove&lt;/code&gt; for that instead. This separate set of functions to manipulate pieces of advice applied to named functions, offers the following extra features compared to &lt;code&gt;add-function&lt;/code&gt;: they know how to deal with macros and autoloaded functions, they let &lt;code&gt;describe-function&lt;/code&gt; preserve the original docstring as well as document the added advice, and they let you add and remove advice before a function is even defined.</source>
          <target state="translated">Но вместо этого вы должны использовать &lt;code&gt;advice-add&lt;/code&gt; и &lt;code&gt;advice-remove&lt;/code&gt; . Этот отдельный набор функций для управления советами, применяемыми к именованным функциям, предлагает следующие дополнительные функции по сравнению с &lt;code&gt;add-function&lt;/code&gt; : они знают, как работать с макросами и автоматически загружаемыми функциями, они позволяют &lt;code&gt;describe-function&lt;/code&gt; сохранять исходную строку документации, а также документ добавленный совет, и они позволяют добавлять и удалять совет еще до того, как функция будет определена.</target>
        </trans-unit>
        <trans-unit id="7d8a0e63cd1a06ea0e2679c87030f5570105b2a4" translate="yes" xml:space="preserve">
          <source>Button Buffer Commands</source>
          <target state="translated">Команды буфера с кнопками</target>
        </trans-unit>
        <trans-unit id="d055960c135678f62a49f9b6f7a5d94add754440" translate="yes" xml:space="preserve">
          <source>Button Properties</source>
          <target state="translated">Кнопка Свойства</target>
        </trans-unit>
        <trans-unit id="41fa24540db10de11f239ddb922c6363c465adf0" translate="yes" xml:space="preserve">
          <source>Button Types</source>
          <target state="translated">Типы кнопок</target>
        </trans-unit>
        <trans-unit id="1e308eff60f72b546296987374ea4612fa02db86" translate="yes" xml:space="preserve">
          <source>Button properties with special meanings.</source>
          <target state="translated">Свойства кнопки с особыми значениями.</target>
        </trans-unit>
        <trans-unit id="e8bf727af91015f6f823f13b436c2880666b454a" translate="yes" xml:space="preserve">
          <source>Button-Down Events</source>
          <target state="translated">События с нажатием кнопки</target>
        </trans-unit>
        <trans-unit id="503d46db37b0db45db898aabed77244252918ca2" translate="yes" xml:space="preserve">
          <source>Buttons</source>
          <target state="translated">Buttons</target>
        </trans-unit>
        <trans-unit id="4c379f628ac77bed975fa656ab1146980f7bff07" translate="yes" xml:space="preserve">
          <source>Buttons are associated with a region of text, using an overlay or text properties to hold button-specific information, all of which are initialized from the button&amp;rsquo;s type (which defaults to the built-in button type &lt;code&gt;button&lt;/code&gt;). Like all Emacs text, the appearance of the button is governed by the &lt;code&gt;face&lt;/code&gt; property; by default (via the &lt;code&gt;face&lt;/code&gt; property inherited from the &lt;code&gt;button&lt;/code&gt; button-type) this is a simple underline, like a typical web-page link.</source>
          <target state="translated">Кнопки связаны с областью текста с использованием наложения или свойств текста для хранения информации, относящейся к кнопкам, каждая из которых инициализируется типом кнопки (который по умолчанию - кнопка встроенного типа &lt;code&gt;button&lt;/code&gt; ). Как и весь текст Emacs, внешний вид кнопки определяется свойством &lt;code&gt;face&lt;/code&gt; ; по умолчанию (через свойство &lt;code&gt;face&lt;/code&gt; , унаследованное от &lt;code&gt;button&lt;/code&gt; button-type), это простое подчеркивание, как и обычная ссылка на веб-страницу.</target>
        </trans-unit>
        <trans-unit id="91c7c66c2c1453401e19d50861895a10fdbd7d8e" translate="yes" xml:space="preserve">
          <source>By &lt;em&gt;separator&lt;/em&gt;, we mean here a token whose sole purpose is to separate various elements within some enclosing syntactic construct, and which does not have any semantic significance in itself (i.e., it would typically not exist as a node in an abstract syntax tree).</source>
          <target state="translated">Под &lt;em&gt;разделителем&lt;/em&gt; мы подразумеваем здесь токен, единственной целью которого является разделение различных элементов в пределах некоторой включающей синтаксической конструкции, и который сам по себе не имеет никакого семантического значения (т. Е. Обычно не существует как узел в абстрактном синтаксическом дереве).</target>
        </trans-unit>
        <trans-unit id="1286985575cca5c62cde4a1b9229a630c85b3182" translate="yes" xml:space="preserve">
          <source>By contrast, a Lisp program can do insertion with inheritance or without, depending on the choice of insertion primitive. The ordinary text insertion functions, such as &lt;code&gt;insert&lt;/code&gt;, do not inherit any properties. They insert text with precisely the properties of the string being inserted, and no others. This is correct for programs that copy text from one context to another&amp;mdash;for example, into or out of the kill ring. To insert with inheritance, use the special primitives described in this section. Self-inserting characters inherit properties because they work using these primitives.</source>
          <target state="translated">Напротив, программа на Лиспе может выполнять вставку с наследованием или без, в зависимости от выбора примитива вставки. Обычные функции вставки текста, такие как &lt;code&gt;insert&lt;/code&gt; , не наследуют никаких свойств. Они вставляют текст в точности со свойствами вставляемой строки и никакими другими. Это верно для программ, которые копируют текст из одного контекста в другой - например, в список уничтожений или из него. Для вставки с наследованием используйте специальные примитивы, описанные в этом разделе. Самовставляющиеся символы наследуют свойства, потому что они работают с этими примитивами.</target>
        </trans-unit>
        <trans-unit id="78d9ed9ffae62086921d390616b3fa2296925abd" translate="yes" xml:space="preserve">
          <source>By contrast, for an array of keyboard input characters (such as a key sequence), a vector may be necessary, because many keyboard input characters are outside the range that will fit in a string. See &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;.</source>
          <target state="translated">Напротив, для массива символов ввода с клавиатуры (например, последовательности клавиш) может потребоваться вектор, поскольку многие символы ввода с клавиатуры находятся за пределами диапазона, который может поместиться в строку. См. &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Ввод последовательности клавиш&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12144324278ff8b90e0a364f623b2e54380c481c" translate="yes" xml:space="preserve">
          <source>By contrast, in programs that manipulate function definitions for other purposes, it is better to use &lt;code&gt;fset&lt;/code&gt;, which does not keep such records. See &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;.</source>
          <target state="translated">Напротив, в программах, которые манипулируют определениями функций для других целей, лучше использовать &lt;code&gt;fset&lt;/code&gt; , который не хранит такие записи. См. &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Функциональные ячейки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e28b30f108e8c96578a3e1fc9b8f49f98c5c829d" translate="yes" xml:space="preserve">
          <source>By contrast, object-oriented programs use &lt;em&gt;polymorphic functions&lt;/em&gt;: a set of specialized functions having the same name, each one of which was written for a certain specific set of argument types. Which of the functions is actually called is decided at run time based on the types of the actual arguments.</source>
          <target state="translated">Напротив, объектно-ориентированные программы используют &lt;em&gt;полиморфные функции&lt;/em&gt; : набор специализированных функций с одинаковыми именами, каждая из которых была написана для определенного определенного набора типов аргументов. Решение о том, какая из функций действительно вызывается, определяется во время выполнения на основе типов фактических аргументов.</target>
        </trans-unit>
        <trans-unit id="955d83a02806ccf2dfd155108f9d134b64fbc8d8" translate="yes" xml:space="preserve">
          <source>By contrast, the following example calls a function without any symbol function indirection, because the first element is an anonymous Lisp function, not a symbol.</source>
          <target state="translated">В следующем примере,напротив,функция вызывается без какой-либо символьной функции,так как первый элемент является анонимной функцией Lisp,а не символом.</target>
        </trans-unit>
        <trans-unit id="90d9b7ac9f08bada9648d4c6e90292b9adc5f05d" translate="yes" xml:space="preserve">
          <source>By contrast, using only error symbols without condition names would seriously decrease the power of &lt;code&gt;condition-case&lt;/code&gt;. Condition names make it possible to categorize errors at various levels of generality when you write an error handler. Using error symbols alone would eliminate all but the narrowest level of classification.</source>
          <target state="translated">Напротив, использование только символов ошибок без имен условий серьезно снизило бы силу &lt;code&gt;condition-case&lt;/code&gt; . Когда вы пишете обработчик ошибок, имена условий позволяют категоризировать ошибки на различных уровнях универсальности. Использование одних только символов ошибок устранит все, кроме самого узкого уровня классификации.</target>
        </trans-unit>
        <trans-unit id="c262827c2a008bc82000c720bb603706e79b1b54" translate="yes" xml:space="preserve">
          <source>By convention, any argument whose name contains the name of a type (e.g., &lt;var&gt;integer&lt;/var&gt;, &lt;var&gt;integer1&lt;/var&gt; or &lt;var&gt;buffer&lt;/var&gt;) is expected to be of that type. A plural of a type (such as &lt;var&gt;buffers&lt;/var&gt;) often means a list of objects of that type. An argument named &lt;var&gt;object&lt;/var&gt; may be of any type. (For a list of Emacs object types, see &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;.) An argument with any other sort of name (e.g., &lt;var&gt;new-file&lt;/var&gt;) is specific to the function; if the function has a documentation string, the type of the argument should be described there (see &lt;a href=&quot;documentation#Documentation&quot;&gt;Documentation&lt;/a&gt;).</source>
          <target state="translated">По соглашению ожидается , что любой аргумент, имя которого содержит имя типа (например, &lt;var&gt;integer&lt;/var&gt; , &lt;var&gt;integer1&lt;/var&gt; или &lt;var&gt;buffer&lt;/var&gt; ), будет принадлежать к этому типу. Множественное число типа (например, &lt;var&gt;buffers&lt;/var&gt; ) часто означает список объектов этого типа. Аргумент с именем &lt;var&gt;object&lt;/var&gt; может быть любого типа. (Список типов объектов Emacs см. В разделе &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Типы данных Lisp&lt;/a&gt; .) Аргумент с любым другим видом имени (например, &lt;var&gt;new-file&lt;/var&gt; ) специфичен для функции; если у функции есть строка документации, в ней должен быть описан тип аргумента (см. &lt;a href=&quot;documentation#Documentation&quot;&gt;Документацию&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29edadc76625945d3e9732385f723229ac2c6358" translate="yes" xml:space="preserve">
          <source>By convention, if a function&amp;rsquo;s symbol consists of two names separated by &amp;lsquo;</source>
          <target state="translated">По соглашению, если символ функции состоит из двух имен, разделенных '</target>
        </trans-unit>
        <trans-unit id="81288ed35b7f8aec4f961beebc97c447985deae4" translate="yes" xml:space="preserve">
          <source>By convention, the entries &lt;code&gt;window-height&lt;/code&gt;, &lt;code&gt;window-width&lt;/code&gt; and &lt;code&gt;preserve-size&lt;/code&gt; are applied after the chosen window&amp;rsquo;s buffer has been set up and if and only if that window never showed another buffer before. More precisely, the latter means that the window must have been either created by the current &lt;code&gt;display-buffer&lt;/code&gt; call or the window was created earlier by &lt;code&gt;display-buffer&lt;/code&gt; to show the buffer and never was used to show another buffer until it was reused by the current invocation of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">По соглашению, значения &lt;code&gt;window-height&lt;/code&gt; , &lt;code&gt;window-width&lt;/code&gt; и &lt;code&gt;preserve-size&lt;/code&gt; применяются после того, как выбранный буфер окна был установлен, и тогда и только тогда, когда это окно никогда не показывало другой буфер раньше. Точнее, последнее означает, что окно должно быть либо создано текущим вызовом &lt;code&gt;display-buffer&lt;/code&gt; , либо окно было создано ранее &lt;code&gt;display-buffer&lt;/code&gt; для отображения буфера и никогда не использовалось для отображения другого буфера, пока оно не было повторно использовано текущим вызов &lt;code&gt;display-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961315a74279b10aa81793f8f190e6ad9e46b005" translate="yes" xml:space="preserve">
          <source>By convention, the height of the chosen window is adjusted only if the window is part of a vertical combination (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) to avoid changing the height of other, unrelated windows. Also, this entry should be processed only under certain conditions which are specified right below this list.</source>
          <target state="translated">По соглашению, высота выбранного окна регулируется только в том случае, если окно является частью вертикальной комбинации (см. &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Окна и фреймы&lt;/a&gt; ), чтобы избежать изменения высоты других, не связанных между собой окон. Кроме того, эта запись должна обрабатываться только при определенных условиях, которые указаны прямо под этим списком.</target>
        </trans-unit>
        <trans-unit id="46e87bdc0265fdf29ddfc65a07831e51565c646d" translate="yes" xml:space="preserve">
          <source>By convention, the pixels of the display at the values returned for &lt;var&gt;left&lt;/var&gt; and &lt;var&gt;top&lt;/var&gt; are considered to be inside (part of) &lt;var&gt;frame&lt;/var&gt;. Hence, if &lt;var&gt;left&lt;/var&gt; and &lt;var&gt;top&lt;/var&gt; are both zero, the pixel at the display&amp;rsquo;s origin is part of &lt;var&gt;frame&lt;/var&gt;. The pixels at &lt;var&gt;bottom&lt;/var&gt; and &lt;var&gt;right&lt;/var&gt;, on the other hand, are considered to lie immediately outside &lt;var&gt;frame&lt;/var&gt;. This means that if you have, for example, two side-by-side frames positioned such that the right outer edge of the frame on the left equals the left outer edge of the frame on the right, the pixels at that edge show a part of the frame on the right.</source>
          <target state="translated">По соглашению пиксели дисплея при значениях, возвращаемых для &lt;var&gt;left&lt;/var&gt; и &lt;var&gt;top&lt;/var&gt; края, считаются находящимися внутри (частью) &lt;var&gt;frame&lt;/var&gt; . Следовательно, если &lt;var&gt;left&lt;/var&gt; и &lt;var&gt;top&lt;/var&gt; равны нулю, пиксель в исходной точке дисплея является частью &lt;var&gt;frame&lt;/var&gt; . С другой стороны, пиксели &lt;var&gt;bottom&lt;/var&gt; и &lt;var&gt;right&lt;/var&gt; считаются лежащими непосредственно за пределами &lt;var&gt;frame&lt;/var&gt; . Это означает, что если у вас есть, например, два соседних кадра, расположенных так, что правый внешний край кадра слева равен левому внешнему краю кадра справа, пиксели на этом краю показывают часть рамки справа.</target>
        </trans-unit>
        <trans-unit id="6a4bd0ccbb65351d0542d9701b9e76e9ff39eb97" translate="yes" xml:space="preserve">
          <source>By convention, the width of the chosen window is adjusted only if the window is part of a horizontal combination (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) to avoid changing the width of other, unrelated windows. Also, this entry should be processed under only certain conditions which are specified right below this list.</source>
          <target state="translated">По соглашению, ширина выбранного окна регулируется только в том случае, если окно является частью горизонтальной комбинации (см. &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Окна и фреймы&lt;/a&gt; ), чтобы избежать изменения ширины других, не связанных между собой окон. Кроме того, эта запись должна обрабатываться только при определенных условиях, которые указаны прямо под этим списком.</target>
        </trans-unit>
        <trans-unit id="f1f59fea98d20db1b1e18d570c20cefba2dd601a" translate="yes" xml:space="preserve">
          <source>By convention, vertical offsets increase &amp;ldquo;downwards&amp;rdquo;. This means that the height of a frame is obtained by subtracting the offset of its top edge from that of its bottom edge. Horizontal offsets increase &amp;ldquo;rightwards&amp;rdquo;, as expected, so a frame&amp;rsquo;s width is calculated by subtracting the offset of its left edge from that of its right edge.</source>
          <target state="translated">По соглашению вертикальные смещения увеличиваются &amp;laquo;вниз&amp;raquo;. Это означает, что высота кадра получается вычитанием смещения его верхнего края из смещения его нижнего края. Горизонтальные смещения увеличиваются &amp;laquo;вправо&amp;raquo;, как и ожидалось, поэтому ширина кадра рассчитывается путем вычитания смещения его левого края из смещения его правого края.</target>
        </trans-unit>
        <trans-unit id="5bc4ab559bcd3485770406aa3206099c2c318a03" translate="yes" xml:space="preserve">
          <source>By convention, when defining variables of a &amp;ldquo;native&amp;rdquo; type (&lt;code&gt;int&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;), the name of the C variable is the name of the Lisp variable with &lt;code&gt;-&lt;/code&gt; replaced by &lt;code&gt;_&lt;/code&gt;. When the variable has type &lt;code&gt;Lisp_Object&lt;/code&gt;, the convention is to also prefix the C variable name with &lt;code&gt;V&lt;/code&gt;. i.e.</source>
          <target state="translated">По соглашению, при определении переменных &amp;laquo;родного&amp;raquo; типа ( &lt;code&gt;int&lt;/code&gt; и &lt;code&gt;bool&lt;/code&gt; ) имя переменной C - это имя переменной Lisp с &lt;code&gt;-&lt;/code&gt; замененным на &lt;code&gt;_&lt;/code&gt; . Когда переменная имеет тип &lt;code&gt;Lisp_Object&lt;/code&gt; , по соглашению также префикс имени переменной C с &lt;code&gt;V&lt;/code&gt; . т.е.</target>
        </trans-unit>
        <trans-unit id="0b42bb254be6d5ac55cc35f34239ee11afcaf79a" translate="yes" xml:space="preserve">
          <source>By convention, you should put the &lt;code&gt;interactive&lt;/code&gt; form in the function body, as the first top-level form. If there is an &lt;code&gt;interactive&lt;/code&gt; form in both the &lt;code&gt;interactive-form&lt;/code&gt; symbol property and the function body, the former takes precedence. The &lt;code&gt;interactive-form&lt;/code&gt; symbol property can be used to add an interactive form to an existing function, or change how its arguments are processed interactively, without redefining the function.</source>
          <target state="translated">По соглашению вы должны поместить &lt;code&gt;interactive&lt;/code&gt; форму в тело функции как первую форму верхнего уровня. Если &lt;code&gt;interactive&lt;/code&gt; форма присутствует как в свойстве символа &lt;code&gt;interactive-form&lt;/code&gt; и в теле функции, первое имеет приоритет. Свойство символа &lt;code&gt;interactive-form&lt;/code&gt; можно использовать для добавления интерактивной формы к существующей функции или для изменения способа обработки ее аргументов в интерактивном режиме без переопределения функции.</target>
        </trans-unit>
        <trans-unit id="bd6cd1964a58199f17af10ed0710e7304dbef795" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; can switch to a buffer that is already shown in another window. The following option can be used to override this behavior.</source>
          <target state="translated">По умолчанию &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; и &lt;code&gt;switch-to-next-buffer&lt;/code&gt; могут переключаться на буфер, который уже отображается в другом окне. Следующая опция может использоваться для отмены этого поведения.</target>
        </trans-unit>
        <trans-unit id="c2e5b9fa592a3409a2011f26d6c0a6701c7e5da1" translate="yes" xml:space="preserve">
          <source>By default both IPv4 and IPv6 lookups are attempted. The optional argument &lt;var&gt;family&lt;/var&gt; controls this behavior, specifying the symbol &lt;code&gt;ipv4&lt;/code&gt; or &lt;code&gt;ipv6&lt;/code&gt; restricts lookups to IPv4 and IPv6 respectively.</source>
          <target state="translated">По умолчанию предпринимаются попытки поиска как по IPv4, так и по IPv6. Необязательное &lt;var&gt;family&lt;/var&gt; аргументов управляет этим поведением, указав символ &lt;code&gt;ipv4&lt;/code&gt; или &lt;code&gt;ipv6&lt;/code&gt; ,который ограничивает поиск до IPv4 и IPv6 соответственно.</target>
        </trans-unit>
        <trans-unit id="af6f338f5f9982890241460392dfd56c79820ad8" translate="yes" xml:space="preserve">
          <source>By default the dumped</source>
          <target state="translated">По умолчанию сброшенный</target>
        </trans-unit>
        <trans-unit id="ec8b6ebd7649499745ebeafd06ed0b949a38dabd" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;eval-region&lt;/code&gt; does not produce any output. However, if &lt;var&gt;stream&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, any output produced by output functions (see &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Output Functions&lt;/a&gt;), as well as the values that result from evaluating the expressions in the region are printed using &lt;var&gt;stream&lt;/var&gt;. See &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;Output Streams&lt;/a&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;eval-region&lt;/code&gt; не производит никакого вывода. Однако, если &lt;var&gt;stream&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , любой вывод, производимый функциями вывода (см. &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Функции вывода&lt;/a&gt; ), а также значения, полученные в результате вычисления выражений в области, печатаются с использованием &lt;var&gt;stream&lt;/var&gt; . Смотрите &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;выходные потоки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a53473f0b03225bb59517eff6e8b663daa1b7774" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;switch-to-buffer&lt;/code&gt; tries to preserve &lt;code&gt;window-point&lt;/code&gt;. This behavior can be tuned using the following option.</source>
          <target state="translated">По умолчанию &lt;code&gt;switch-to-buffer&lt;/code&gt; пытается сохранить &lt;code&gt;window-point&lt;/code&gt; . Это поведение можно настроить с помощью следующей опции.</target>
        </trans-unit>
        <trans-unit id="ee1412f6a4896bbf8989a04623bf820b553fdea4" translate="yes" xml:space="preserve">
          <source>By default, &lt;var&gt;keywords&lt;/var&gt; are added at the beginning of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If the optional argument &lt;var&gt;how&lt;/var&gt; is &lt;code&gt;set&lt;/code&gt;, they are used to replace the value of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If &lt;var&gt;how&lt;/var&gt; is any other non-&lt;code&gt;nil&lt;/code&gt; value, they are added at the end of &lt;code&gt;font-lock-keywords&lt;/code&gt;.</source>
          <target state="translated">По умолчанию &lt;var&gt;keywords&lt;/var&gt; добавляются в начало &lt;code&gt;font-lock-keywords&lt;/code&gt; . Если необязательный аргумент , &lt;var&gt;how&lt;/var&gt; будет &lt;code&gt;set&lt;/code&gt; , что они используются для замены значения &lt;code&gt;font-lock-keywords&lt;/code&gt; . Если &lt;var&gt;how&lt;/var&gt; любое другое значение, отличное от &lt;code&gt;nil&lt;/code&gt; , они добавляются в конец &lt;code&gt;font-lock-keywords&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10521942e8c52f15b21a03de5615c1566c427141" translate="yes" xml:space="preserve">
          <source>By default, Emacs determines the base direction of each paragraph by looking at the text at its beginning. The precise method of determining the base direction is specified by the</source>
          <target state="translated">По умолчанию Emacs определяет базовое направление каждого параграфа,глядя на текст в его начале.Точный метод определения базового направления определяется с помощью параметра</target>
        </trans-unit>
        <trans-unit id="d9bc871638c9fc2d81d98a2b4d5d096f7d797fd7" translate="yes" xml:space="preserve">
          <source>By default, Emacs makes a single backup file for each file edited. You can alternatively request numbered backups; then each new backup file gets a new name. You can delete old numbered backups when you don&amp;rsquo;t want them any more, or Emacs can delete them automatically.</source>
          <target state="translated">По умолчанию Emacs создает отдельный файл резервной копии для каждого редактируемого файла. Вы также можете запросить нумерованные резервные копии; тогда каждый новый файл резервной копии получает новое имя. Вы можете удалить старые пронумерованные резервные копии, если они вам больше не нужны, или Emacs может удалить их автоматически.</target>
        </trans-unit>
        <trans-unit id="eb5fb3e174ce7ebaa56506756450880c9f6707f5" translate="yes" xml:space="preserve">
          <source>By default, Emacs starts in multibyte mode: it stores the contents of buffers and strings using an internal encoding that represents non-</source>
          <target state="translated">По умолчанию Emacs запускается в многобайтовом режиме:он хранит содержимое буферов и строк,используя внутреннюю кодировку,которая представляет не</target>
        </trans-unit>
        <trans-unit id="2439b1b4fb24aa8804e6e4ef3da82558ce16fc14" translate="yes" xml:space="preserve">
          <source>By default, Emacs tries to keep the number of lines and columns of a frame&amp;rsquo;s text area unaltered when, for example, toggling its menu or tool bar, changing its default font or setting the width of any of its scroll bars. This means that in such case Emacs must ask the window manager to resize the frame&amp;rsquo;s window in order to accommodate the size change.</source>
          <target state="translated">По умолчанию Emacs пытается сохранить неизменным количество строк и столбцов в текстовой области фрейма, например, при переключении меню или панели инструментов, изменении шрифта по умолчанию или установке ширины любой из полос прокрутки. Это означает, что в таком случае Emacs должен попросить оконный менеджер изменить размер окна фрейма, чтобы приспособиться к изменению размера.</target>
        </trans-unit>
        <trans-unit id="c3302471f75eaf89ac88db46d17c6df0b07bc2a8" translate="yes" xml:space="preserve">
          <source>By default, a text property is rear-sticky but not front-sticky; thus, the default is to inherit all the properties of the preceding character, and nothing from the following character.</source>
          <target state="translated">По умолчанию свойством текста является задняя прилипала,но не передняя прилипала;таким образом,по умолчанию все свойства предыдущего символа унаследованы,и ничего от следующего символа.</target>
        </trans-unit>
        <trans-unit id="b6bdb814df1ff8f4484bd14e8665079dde59b196" translate="yes" xml:space="preserve">
          <source>By default, all subdirectories are descended into. If &lt;var&gt;predicate&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, errors when trying to descend into a subdirectory (for instance, if it&amp;rsquo;s not readable by this user) are ignored. If it&amp;rsquo;s neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;t&lt;/code&gt;, it should be a function that takes one parameter (the subdirectory name) and should return non-&lt;code&gt;nil&lt;/code&gt; if the directory is to be descended into.</source>
          <target state="translated">По умолчанию все подкаталоги переходят в. Если &lt;var&gt;predicate&lt;/var&gt; является &lt;code&gt;t&lt;/code&gt; , ошибки при попытке спуститься в подкаталог (например, если он не доступен для чтения этого пользователя) игнорируются. Если это ни &lt;code&gt;nil&lt;/code&gt; , ни &lt;code&gt;t&lt;/code&gt; , это должна быть функция, которая принимает один параметр (имя подкаталога) и должна возвращать &lt;code&gt;nil&lt;/code&gt; если каталог должен быть спущен.</target>
        </trans-unit>
        <trans-unit id="34620b2db91cbe790eb8b807c0d8c806964cdff3" translate="yes" xml:space="preserve">
          <source>By default, format specifications correspond to successive values from &lt;var&gt;objects&lt;/var&gt;. Thus, the first format specification in &lt;var&gt;string&lt;/var&gt; uses the first such value, the second format specification uses the second such value, and so on. Any extra format specifications (those for which there are no corresponding values) cause an error. Any extra values to be formatted are ignored.</source>
          <target state="translated">По умолчанию спецификации формата соответствуют последовательным значениям из &lt;var&gt;objects&lt;/var&gt; . Таким образом, первая спецификация формата в &lt;var&gt;string&lt;/var&gt; использует первое такое значение, вторая спецификация формата использует второе такое значение и так далее. Любые дополнительные спецификации формата (те, для которых нет соответствующих значений) вызывают ошибку. Любые дополнительные форматируемые значения игнорируются.</target>
        </trans-unit>
        <trans-unit id="cfab6cab0b08bc4c2da07991fa913322ec8175a9" translate="yes" xml:space="preserve">
          <source>By default, frame parameters are saved and restored by the desktop library functions (see &lt;a href=&quot;desktop-save-mode#Desktop-Save-Mode&quot;&gt;Desktop Save Mode&lt;/a&gt;) when the variable &lt;code&gt;desktop-restore-frames&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. It&amp;rsquo;s the responsibility of applications that their parameters are included in &lt;code&gt;frameset-persistent-filter-alist&lt;/code&gt; to avoid that they get meaningless or even harmful values in restored sessions.</source>
          <target state="translated">По умолчанию параметры фрейма сохраняются и восстанавливаются функциями библиотеки рабочего стола (см. &lt;a href=&quot;desktop-save-mode#Desktop-Save-Mode&quot;&gt;Режим сохранения рабочего стола&lt;/a&gt; ), когда переменная &lt;code&gt;desktop-restore-frames&lt;/code&gt; не равна &lt;code&gt;nil&lt;/code&gt; . Приложения несут ответственность за то, чтобы их параметры были включены в &lt;code&gt;frameset-persistent-filter-alist&lt;/code&gt; , чтобы избежать получения бессмысленных или даже вредных значений в восстановленных сеансах.</target>
        </trans-unit>
        <trans-unit id="4ff08fda735af5f6543bdd7e51226e1a37b99336" translate="yes" xml:space="preserve">
          <source>By default, if the latest auto-save file is more recent than the visited file, and the argument &lt;var&gt;ignore-auto&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;revert-buffer&lt;/code&gt; asks the user whether to use that auto-save instead. When you invoke this command interactively, &lt;var&gt;ignore-auto&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; if there is no numeric prefix argument; thus, the interactive default is not to check the auto-save file.</source>
          <target state="translated">По умолчанию, если последний файл автосохранения более свежий, чем посещенный файл, и аргумент &lt;var&gt;ignore-auto&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;revert-buffer&lt;/code&gt; спрашивает пользователя, использовать ли вместо этого это автосохранение. Когда вы вызываете эту команду в интерактивном режиме, &lt;var&gt;ignore-auto&lt;/var&gt; будет &lt;code&gt;t&lt;/code&gt; , если нет аргумента числового префикса; таким образом, интерактивное значение по умолчанию не проверять файл автосохранения.</target>
        </trans-unit>
        <trans-unit id="2816188a5a0e8a3ed928cd480d7464b05373951a" translate="yes" xml:space="preserve">
          <source>By default, it also defines a variable named &lt;var&gt;mode&lt;/var&gt;, which is set to &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; by enabling or disabling the mode. The variable is initialized to &lt;var&gt;init-value&lt;/var&gt;. Except in unusual circumstances (see below), this value must be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">По умолчанию он также определяет переменную с именем &lt;var&gt;mode&lt;/var&gt; , для которой устанавливается значение &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;nil&lt;/code&gt; путем включения или отключения режима. Переменная инициализируется &lt;var&gt;init-value&lt;/var&gt; . За исключением необычных обстоятельств (см. Ниже), это значение должно быть &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1adc609228685b29696e0ff7e75061c83ffb5bde" translate="yes" xml:space="preserve">
          <source>By default, output is put in a buffer.</source>
          <target state="translated">По умолчанию вывод помещается в буфер.</target>
        </trans-unit>
        <trans-unit id="410cbb685716930dfd39abc9cbf65a643f166d48" translate="yes" xml:space="preserve">
          <source>By default, process output is inserted in the associated buffer. (You can change this by defining a custom filter function, see &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.) The position to insert the output is determined by the &lt;code&gt;process-mark&lt;/code&gt;, which is then updated to point to the end of the text just inserted. Usually, but not always, the &lt;code&gt;process-mark&lt;/code&gt; is at the end of the buffer.</source>
          <target state="translated">По умолчанию вывод процесса вставляется в связанный буфер. (Вы можете изменить это, определив пользовательскую функцию фильтра, см. &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Функции фильтров&lt;/a&gt; .) Позиция для вставки вывода определяется &lt;code&gt;process-mark&lt;/code&gt; , которая затем обновляется, чтобы указать на конец только что вставленного текста. Обычно, но не всегда, &lt;code&gt;process-mark&lt;/code&gt; находится в конце буфера.</target>
        </trans-unit>
        <trans-unit id="f08b23f065e4db8b7e347aa8e9d5f1dfa79f259d" translate="yes" xml:space="preserve">
          <source>By default, searches in Emacs ignore the case of the text they are searching through; if you specify searching for &amp;lsquo;</source>
          <target state="translated">По умолчанию поиск в Emacs игнорирует регистр текста, в котором выполняется поиск; если вы укажете поиск &quot;</target>
        </trans-unit>
        <trans-unit id="1fd764f8ebd1a38813dea49832550f50112ed16b" translate="yes" xml:space="preserve">
          <source>By default, side windows cannot be split via &lt;code&gt;split-window&lt;/code&gt; (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;). Also, a side window is not reused or split by any buffer display action (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) unless it is explicitly specified as target of that action. Note also that &lt;code&gt;delete-other-windows&lt;/code&gt; cannot make a side window the only window on its frame (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;).</source>
          <target state="translated">По умолчанию боковые окна не могут быть разделены с помощью &lt;code&gt;split-window&lt;/code&gt; (см. &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Разделение окон&lt;/a&gt; ). Кроме того, боковое окно не используется повторно или не разделяется каким-либо действием отображения буфера (см. &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Функции действий отображения буфера&lt;/a&gt; ), если оно явно не указано как цель этого действия. Также обратите внимание, что &lt;code&gt;delete-other-windows&lt;/code&gt; не может сделать боковое окно единственным окном в своем фрейме (см. &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Удаление окон&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="337f680b05ae479de5bb330579bb081a7cad8c38" translate="yes" xml:space="preserve">
          <source>By default, the error output from the process, if any, is also passed to the filter function, unless the destination for the standard error stream of the process was separated from the standard output when the process was created. Emacs will only call the filter function during certain function calls. See &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Output from Processes&lt;/a&gt;. Note that if any of those functions are called by the filter, the filter may be called recursively.</source>
          <target state="translated">По умолчанию вывод ошибок процесса, если таковые имеются, также передается в функцию фильтра, если место назначения для стандартного потока ошибок процесса не было отделено от стандартного вывода при создании процесса. Emacs будет вызывать функцию фильтра только во время определенных вызовов функций. См. &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Вывод из процессов&lt;/a&gt; . Обратите внимание, что если какая-либо из этих функций вызывается фильтром, фильтр может вызываться рекурсивно.</target>
        </trans-unit>
        <trans-unit id="06b7d4e5494854a61c5e08ae9fc06e3dd1a74a05" translate="yes" xml:space="preserve">
          <source>By default, the functions that save and restore window configurations or the states of windows (see &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;) do not care about window parameters. This means that when you change the value of a parameter within the body of a &lt;code&gt;save-window-excursion&lt;/code&gt;, the previous value is not restored when that macro exits. It also means that when you restore via &lt;code&gt;window-state-put&lt;/code&gt; a window state saved earlier by &lt;code&gt;window-state-get&lt;/code&gt;, all cloned windows have their parameters reset to &lt;code&gt;nil&lt;/code&gt;. The following variable allows you to override the standard behavior:</source>
          <target state="translated">По умолчанию функции, сохраняющие и восстанавливающие конфигурации окон или состояния окон (см. &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Конфигурации окон&lt;/a&gt; ), не заботятся о параметрах окна. Это означает, что когда вы изменяете значение параметра в теле &lt;code&gt;save-window-excursion&lt;/code&gt; , предыдущее значение не восстанавливается при выходе из этого макроса. Это также означает, что когда вы восстанавливаете с помощью &lt;code&gt;window-state-put&lt;/code&gt; состояние окна, сохраненное ранее с помощью &lt;code&gt;window-state-get&lt;/code&gt; , все клонированные окна сбрасывают свои параметры на &lt;code&gt;nil&lt;/code&gt; . Следующая переменная позволяет переопределить стандартное поведение:</target>
        </trans-unit>
        <trans-unit id="42d60f64d2f3044aeab0d538900375a76783a13e" translate="yes" xml:space="preserve">
          <source>By default, the global map binds &lt;code&gt;[tool-bar]&lt;/code&gt; as follows:</source>
          <target state="translated">По умолчанию глобальная карта связывает &lt;code&gt;[tool-bar]&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="7273860db2763e093bd47c6c91c3aff5ba16714f" translate="yes" xml:space="preserve">
          <source>By default, the local bindings that Emacs creates are &lt;em&gt;dynamic bindings&lt;/em&gt;. Such a binding has &lt;em&gt;dynamic scope&lt;/em&gt;, meaning that any part of the program can potentially access the variable binding. It also has &lt;em&gt;dynamic extent&lt;/em&gt;, meaning that the binding lasts only while the binding construct (such as the body of a &lt;code&gt;let&lt;/code&gt; form) is being executed.</source>
          <target state="translated">По умолчанию локальные привязки, создаваемые Emacs, являются &lt;em&gt;динамическими&lt;/em&gt; . Такая привязка имеет &lt;em&gt;динамическую область видимости&lt;/em&gt; , что означает, что любая часть программы потенциально может получить доступ к привязке переменной. Он также имеет &lt;em&gt;динамическую протяженность&lt;/em&gt; , что означает, что привязка длится только пока выполняется конструкция привязки (например, тело &lt;code&gt;let&lt;/code&gt; - формы).</target>
        </trans-unit>
        <trans-unit id="fd1815fd5a5c0fb02829db09a71557be08961cdb" translate="yes" xml:space="preserve">
          <source>By default, the local variable bindings made by Emacs are dynamic bindings. When a variable is dynamically bound, its current binding at any point in the execution of the Lisp program is simply the most recently-created dynamic local binding for that symbol, or the global binding if there is no such local binding.</source>
          <target state="translated">По умолчанию локальные привязки переменных,сделанные Emacs,являются динамическими привязками.При динамической привязке переменной ее текущая привязка в любой момент выполнения программы на языке Lisp является просто самой последней динамической локальной привязкой для этого символа,или глобальной привязкой,если такой локальной привязки нет.</target>
        </trans-unit>
        <trans-unit id="47f31a9758da1b80f09abc18f1231cee612e7b61" translate="yes" xml:space="preserve">
          <source>By default, the range of codepoints passed to &lt;var&gt;function&lt;/var&gt; includes all the characters in &lt;var&gt;charset&lt;/var&gt;, but optional arguments &lt;var&gt;from-code&lt;/var&gt; and &lt;var&gt;to-code&lt;/var&gt; limit that to the range of characters between these two codepoints of &lt;var&gt;charset&lt;/var&gt;. If either of them is &lt;code&gt;nil&lt;/code&gt;, it defaults to the first or last codepoint of &lt;var&gt;charset&lt;/var&gt;, respectively.</source>
          <target state="translated">По умолчанию диапазон кодовых точек, переданных в &lt;var&gt;function&lt;/var&gt; включает все символы в &lt;var&gt;charset&lt;/var&gt; , но необязательные аргументы &lt;var&gt;from-code&lt;/var&gt; и &lt;var&gt;to-code&lt;/var&gt; ограничивают диапазон символов между этими двумя кодовыми точками &lt;var&gt;charset&lt;/var&gt; . Если любой из них равен &lt;code&gt;nil&lt;/code&gt; , по умолчанию используется первая или последняя кодовая точка &lt;var&gt;charset&lt;/var&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="3d1494bcaafdc3c540ef160a9f8e6f65dd4261e3" translate="yes" xml:space="preserve">
          <source>By default, the space taken up by &lt;var&gt;window&lt;/var&gt; is given to one of its adjacent sibling windows, if any. However, if the variable &lt;code&gt;window-combination-resize&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the space is proportionally distributed among any remaining windows in the same window combination. See &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Recombining Windows&lt;/a&gt;.</source>
          <target state="translated">По умолчанию пространство, занимаемое &lt;var&gt;window&lt;/var&gt; , отводится одному из соседних соседних окон, если таковые имеются. Однако, если переменная &lt;code&gt;window-combination-resize&lt;/code&gt; равна &lt;code&gt;nil&lt;/code&gt; , пространство пропорционально распределяется между любыми оставшимися окнами в той же комбинации окон. См. Раздел &amp;laquo; &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Перекомпоновка Windows&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1defe0245424aab283006a635faaa0b360d0c56" translate="yes" xml:space="preserve">
          <source>By default, the value is a function that asks the user whether to proceed.</source>
          <target state="translated">По умолчанию,значение представляет собой функцию,которая спрашивает пользователя,следует ли продолжать.</target>
        </trans-unit>
        <trans-unit id="6d7d2b01d1d4f6143cd45dbac4779e0cc9e9e7c9" translate="yes" xml:space="preserve">
          <source>By default, the values are integers that are 100 times the system load averages, but if &lt;var&gt;use-float&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then they are returned as floating-point numbers without multiplying by 100.</source>
          <target state="translated">По умолчанию значения представляют собой целые числа, которые в 100 раз превышают средние значения загрузки системы, но если &lt;var&gt;use-float&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , то они возвращаются как числа с плавающей запятой без умножения на 100.</target>
        </trans-unit>
        <trans-unit id="e561fba1f476b09361515566e3c64701551c6912" translate="yes" xml:space="preserve">
          <source>By default, this alist contains one entry with the key &lt;code&gt;edebug&lt;/code&gt; and a list of three functions, which are the default implementations of the functions inserted in instrumented code: &lt;code&gt;edebug-enter&lt;/code&gt;, &lt;code&gt;edebug-before&lt;/code&gt; and &lt;code&gt;edebug-after&lt;/code&gt;. To change Edebug&amp;rsquo;s behavior globally, modify the default entry.</source>
          <target state="translated">По умолчанию этот список содержит одну запись с ключом &lt;code&gt;edebug&lt;/code&gt; и список из трех функций, которые являются реализациями по умолчанию для функций, вставленных в инструментированный код: &lt;code&gt;edebug-enter&lt;/code&gt; , &lt;code&gt;edebug-before&lt;/code&gt; и &lt;code&gt;edebug-after&lt;/code&gt; . Чтобы изменить поведение Edebug глобально, измените запись по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a30c2c9f6f69702d4744ebbd4fe0caff5ca90a07" translate="yes" xml:space="preserve">
          <source>By default, this function also moves &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s buffer to the front of the buffer list (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;) and makes &lt;var&gt;window&lt;/var&gt; the most recently selected window. If the optional argument &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these additional actions are omitted.</source>
          <target state="translated">По умолчанию эта функция также перемещает буфер &lt;var&gt;window&lt;/var&gt; в начало списка буферов (см. &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Список&lt;/a&gt; буферов ) и делает &lt;var&gt;window&lt;/var&gt; последним выбранным окном. Если необязательный аргумент &lt;var&gt;norecord&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , эти дополнительные действия не выполняются.</target>
        </trans-unit>
        <trans-unit id="314e04d83201875669bd5820e278b79ec5e410e1" translate="yes" xml:space="preserve">
          <source>By default, this function resets &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s position, display margins, fringe widths, and scroll bar settings, based on the local variables in the specified buffer. However, if the optional argument &lt;var&gt;keep-margins&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it leaves &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s display margins, fringes and scroll bar settings alone.</source>
          <target state="translated">По умолчанию эта функция сбрасывает положение &lt;var&gt;window&lt;/var&gt; , поля отображения, ширину границ и настройки полосы прокрутки на основе локальных переменных в указанном буфере. Однако, если дополнительный аргумент &lt;var&gt;keep-margins&lt;/var&gt; отлично от &lt;code&gt;nil&lt;/code&gt; , он оставляет &lt;var&gt;window&lt;/var&gt; отображения полей &amp;laquo;s, бахрому и настройку полосы прокрутки в одиночку.</target>
        </trans-unit>
        <trans-unit id="c8d7822491c87018aaf653bdc89135199d35d678" translate="yes" xml:space="preserve">
          <source>By default, this variable is always set to &lt;code&gt;t&lt;/code&gt;, meaning that a call of &lt;code&gt;process-file&lt;/code&gt; could potentially change any file on a remote host. When set to &lt;code&gt;nil&lt;/code&gt;, a file name handler could optimize its behavior with respect to remote file attribute caching.</source>
          <target state="translated">По умолчанию эта переменная всегда имеет значение &lt;code&gt;t&lt;/code&gt; , что означает, что вызов &lt;code&gt;process-file&lt;/code&gt; потенциально может изменить любой файл на удаленном хосте. Если установлено значение &lt;code&gt;nil&lt;/code&gt; , обработчик имени файла может оптимизировать свое поведение в отношении кэширования атрибутов удаленного файла.</target>
        </trans-unit>
        <trans-unit id="fe49d9f104dc3f50cf901776febad4cfc3162c78" translate="yes" xml:space="preserve">
          <source>By default, this variable&amp;rsquo;s value is &lt;code&gt;read&lt;/code&gt;. See &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;read&lt;/code&gt; значение этой переменной . См. &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Функции ввода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2688defb0c98a25897334d05cea4581b8ab7493" translate="yes" xml:space="preserve">
          <source>By design, action functions are free in their interpretation of action alist entries. In fact, some entries like &lt;code&gt;allow-no-window&lt;/code&gt; or &lt;code&gt;previous-window&lt;/code&gt; have a meaning only for one or a few action functions, and are ignored by the rest. Other entries, like &lt;code&gt;inhibit-same-window&lt;/code&gt; or &lt;code&gt;window-parameters&lt;/code&gt;, are supposed to be respected by most action functions, including those provided by application programs and external packages.</source>
          <target state="translated">По замыслу функции действий могут свободно интерпретировать записи списка действий. Фактически, некоторые записи, такие как &lt;code&gt;allow-no-window&lt;/code&gt; или &lt;code&gt;previous-window&lt;/code&gt; , имеют значение только для одной или нескольких функций действия и игнорируются остальными. Другие записи, такие как &lt;code&gt;inhibit-same-window&lt;/code&gt; или &lt;code&gt;window-parameters&lt;/code&gt; , должны соблюдаться большинством функций действий, включая те, которые предоставляются прикладными программами и внешними пакетами.</target>
        </trans-unit>
        <trans-unit id="5df52f7953c9e1e23b06b07d93d36bf7c4082b84" translate="yes" xml:space="preserve">
          <source>By design, operations to make or modify child frames are implemented with the help of frame parameters (see &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;Frame Parameters&lt;/a&gt;) without any specialized functions or customizable variables. Note that child frames are meaningful on graphical terminals only.</source>
          <target state="translated">По замыслу, операции по созданию или изменению дочерних фреймов реализованы с помощью параметров фрейма (см. &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;Параметры фрейма&lt;/a&gt; ) без каких-либо специализированных функций или настраиваемых переменных. Обратите внимание, что дочерние фреймы имеют смысл только на графических терминалах.</target>
        </trans-unit>
        <trans-unit id="bc5e006af20582138d39d0ef5f207bc52db0c4b3" translate="yes" xml:space="preserve">
          <source>By editing the buffer in place. In this case, &lt;var&gt;to-fn&lt;/var&gt; should return the end-position of the range of text, as modified.</source>
          <target state="translated">Редактируя буфер на месте. В этом случае &lt;var&gt;to-fn&lt;/var&gt; должна возвращать конечную позицию диапазона текста, как изменено.</target>
        </trans-unit>
        <trans-unit id="63b5c76c72ae22fa7a5d14c68660da304cacecaf" translate="yes" xml:space="preserve">
          <source>By returning a list of annotations. This is a list of elements of the form &lt;code&gt;(&lt;var&gt;position&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;position&lt;/var&gt; is an integer specifying the relative position in the text to be written, and &lt;var&gt;string&lt;/var&gt; is the annotation to add there. The list must be sorted in order of position when &lt;var&gt;to-fn&lt;/var&gt; returns it.</source>
          <target state="translated">Вернув список аннотаций. Это список элементов формы &lt;code&gt;(&lt;var&gt;position&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;position&lt;/var&gt; - это целое число, указывающее относительную позицию в записываемом тексте, а &lt;var&gt;string&lt;/var&gt; - это добавляемая туда аннотация. Список должен быть отсортирован в порядке позиции, когда &lt;var&gt;to-fn&lt;/var&gt; возвращает его.</target>
        </trans-unit>
        <trans-unit id="b9df056fb7a4026d67a3485fe6622bd0ac5e4705" translate="yes" xml:space="preserve">
          <source>By setting the &lt;var&gt;action&lt;/var&gt; argument, an application effectively overrules any customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt;. Our user can now either accept the choice of the application, or redouble by customizing the option &lt;code&gt;display-buffer-alist&lt;/code&gt; as follows:</source>
          <target state="translated">Устанавливая аргумент &lt;var&gt;action&lt;/var&gt; , приложение эффективно отменяет любую настройку &lt;code&gt;display-buffer-base-action&lt;/code&gt; . Теперь наш пользователь может либо принять выбор приложения, либо выполнить двойную операцию, настроив опцию &lt;code&gt;display-buffer-alist&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="3d82e754d3481447db663d32552753c526295b30" translate="yes" xml:space="preserve">
          <source>Byte Compilation</source>
          <target state="translated">Байтовая компиляция</target>
        </trans-unit>
        <trans-unit id="38293ea2f575b674a58092e2860f65e375cf569f" translate="yes" xml:space="preserve">
          <source>Byte compilation functions.</source>
          <target state="translated">Функции компиляции байтов.</target>
        </trans-unit>
        <trans-unit id="05bc2b18f50e1c59ce5be83b3a043fed7d8464a5" translate="yes" xml:space="preserve">
          <source>Byte compiler warnings can be controlled more precisely by setting the variable &lt;code&gt;byte-compile-warnings&lt;/code&gt;. See its documentation string for details.</source>
          <target state="translated">Предупреждения компилятора байта можно контролировать более точно, установив переменную &lt;code&gt;byte-compile-warnings&lt;/code&gt; . Подробности смотрите в его документации.</target>
        </trans-unit>
        <trans-unit id="30c3dfd8676a2b612dc32e5e0e6e366336cdb1d2" translate="yes" xml:space="preserve">
          <source>Byte-Code Function Objects</source>
          <target state="translated">Объекты байт-кодовой функции</target>
        </trans-unit>
        <trans-unit id="11dfd8a56350515cd4673e500974d1d76f92ac16" translate="yes" xml:space="preserve">
          <source>Byte-Code Function Type</source>
          <target state="translated">Байт-кодовый тип функции</target>
        </trans-unit>
        <trans-unit id="59fecc0a37710dd91bf58606dfa13b25c3069f87" translate="yes" xml:space="preserve">
          <source>Byte-Compilation Functions</source>
          <target state="translated">Функции байт-компиляции</target>
        </trans-unit>
        <trans-unit id="1a37ba1d3be3c3de01e4d5d496b8285b080495ba" translate="yes" xml:space="preserve">
          <source>Byte-compiled functions have a special data type: they are &lt;em&gt;byte-code function objects&lt;/em&gt;. Whenever such an object appears as a function to be called, Emacs uses the byte-code interpreter to execute the byte-code.</source>
          <target state="translated">Байт-скомпилированные функции имеют особый тип данных: они являются &lt;em&gt;объектами функций байт-кода&lt;/em&gt; . Каждый раз, когда такой объект появляется как вызываемая функция, Emacs использует интерпретатор байт-кода для выполнения байт-кода.</target>
        </trans-unit>
        <trans-unit id="3bb9f8596b1e76a28bc9081c521014596231e12a" translate="yes" xml:space="preserve">
          <source>Byte-compiling a file also executes any &lt;code&gt;require&lt;/code&gt; calls at top-level in the file, so you can ensure that necessary macro definitions are available during compilation by requiring the files that define them (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;).</source>
          <target state="translated">При байтовой компиляции файла также выполняются любые вызовы &lt;code&gt;require&lt;/code&gt; на верхнем уровне файла, поэтому вы можете гарантировать, что необходимые определения макросов доступны во время компиляции, запрашивая файлы, которые их определяют (см. &lt;a href=&quot;named-features#Named-Features&quot;&gt;Именованные функции&lt;/a&gt; ). Чтобы избежать загрузки файлов определения макросов, когда кто-то &lt;em&gt;запускает&lt;/em&gt; скомпилированную программу, напишите &lt;code&gt;eval-when-compile&lt;/code&gt; вокруг вызовов &lt;code&gt;require&lt;/code&gt; (см. &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval во время компиляции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc41f45aabe0cfaf8f1fb19aff9d4d9cd35def84" translate="yes" xml:space="preserve">
          <source>Byte-compiling a file often produces warnings about functions that the compiler doesn&amp;rsquo;t know about (see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;). Sometimes this indicates a real problem, but usually the functions in question are defined in other files which would be loaded if that code is run. For example, byte-compiling</source>
          <target state="translated">При байтовой компиляции файла часто появляются предупреждения о функциях, о которых компилятор не знает (см. &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Ошибки компилятора&lt;/a&gt; ). Иногда это указывает на реальную проблему, но обычно рассматриваемые функции определены в других файлах, которые будут загружены, если этот код будет запущен. Например, байтовая компиляция</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="440395ca055b9f07fbed0d7cf4596c35fc237caa" translate="yes" xml:space="preserve">
          <source>C Dialect</source>
          <target state="translated">диалект C</target>
        </trans-unit>
        <trans-unit id="161c19c41476b0282b81eeb78bdaec44cc5f26eb" translate="yes" xml:space="preserve">
          <source>C Integer Types</source>
          <target state="translated">C Целочисленные Типы</target>
        </trans-unit>
        <trans-unit id="f1dfdb58024fd801bb8d8d91b16183f255579149" translate="yes" xml:space="preserve">
          <source>C-</source>
          <target state="translated">C-</target>
        </trans-unit>
        <trans-unit id="e98b70997278aacbb8d37c462eeefc3cbd3956d9" translate="yes" xml:space="preserve">
          <source>C-=</source>
          <target state="translated">C-=</target>
        </trans-unit>
        <trans-unit id="f91ccd340101fead85b132fc626cf86c66e71760" translate="yes" xml:space="preserve">
          <source>C-@</source>
          <target state="translated">C-@</target>
        </trans-unit>
        <trans-unit id="5a32717cd694e62b994ffe84487a025e94d4ba8d" translate="yes" xml:space="preserve">
          <source>C-A</source>
          <target state="translated">C-A</target>
        </trans-unit>
        <trans-unit id="a0720f926a1edd4fcb28152926e89547a933d93b" translate="yes" xml:space="preserve">
          <source>C-DEL</source>
          <target state="translated">C-DEL</target>
        </trans-unit>
        <trans-unit id="e8de50b9ffc20496735696fad0e0b83e070a5838" translate="yes" xml:space="preserve">
          <source>C-M-S-v</source>
          <target state="translated">C-M-S-v</target>
        </trans-unit>
        <trans-unit id="a587267328d8d782313379e66ff7b0b685da74e3" translate="yes" xml:space="preserve">
          <source>C-M-a</source>
          <target state="translated">C-M-a</target>
        </trans-unit>
        <trans-unit id="523363599c87501263758c3178a881d56b0ca0f3" translate="yes" xml:space="preserve">
          <source>C-M-b</source>
          <target state="translated">C-M-b</target>
        </trans-unit>
        <trans-unit id="9ab2ef69a1c8dee51e5c638f3f4dfb634fbe96a6" translate="yes" xml:space="preserve">
          <source>C-M-c</source>
          <target state="translated">C-M-c</target>
        </trans-unit>
        <trans-unit id="a2b4c4a3c492ba7d8900be9b332ed927f932ea89" translate="yes" xml:space="preserve">
          <source>C-M-e</source>
          <target state="translated">C-M-e</target>
        </trans-unit>
        <trans-unit id="1415d2b0c002711c0b18baff2ffb42f215277da7" translate="yes" xml:space="preserve">
          <source>C-M-f</source>
          <target state="translated">C-M-f</target>
        </trans-unit>
        <trans-unit id="e1283736390e7ca8f0e8dae4d7c15501e7285305" translate="yes" xml:space="preserve">
          <source>C-M-i</source>
          <target state="translated">C-M-i</target>
        </trans-unit>
        <trans-unit id="5554d733d6164f6f3c0310969979f52f4373a6f3" translate="yes" xml:space="preserve">
          <source>C-M-q</source>
          <target state="translated">C-M-q</target>
        </trans-unit>
        <trans-unit id="e48088e6addb18372a14ed6b8da1a6b58ad7c957" translate="yes" xml:space="preserve">
          <source>C-M-v</source>
          <target state="translated">C-M-v</target>
        </trans-unit>
        <trans-unit id="e3d2747af9266236b31cfe9dbcc1d21c148863e4" translate="yes" xml:space="preserve">
          <source>C-M-x</source>
          <target state="translated">C-M-x</target>
        </trans-unit>
        <trans-unit id="d149ce62d1e517cc3bc28b8250bb976be43efcc0" translate="yes" xml:space="preserve">
          <source>C-\</source>
          <target state="translated">C-\</target>
        </trans-unit>
        <trans-unit id="015b01935f205cea280aafb1b1c1757c49bc1bf4" translate="yes" xml:space="preserve">
          <source>C-]</source>
          <target state="translated">C-]</target>
        </trans-unit>
        <trans-unit id="5ec9d3dadc7abaeb1f5f16db2365b2aeb6a2f74b" translate="yes" xml:space="preserve">
          <source>C-_</source>
          <target state="translated">C-_</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="b3b7965656c0921692a30673d7781acd51c4eed9" translate="yes" xml:space="preserve">
          <source>C-c</source>
          <target state="translated">C-c</target>
        </trans-unit>
        <trans-unit id="2922399c2d547241985d2d9050d0f4a253f10c73" translate="yes" xml:space="preserve">
          <source>C-c 3</source>
          <target state="translated">C-c 3</target>
        </trans-unit>
        <trans-unit id="8c846cf1bd5b4fe56864ee3f4c9665e8b3b8fcc4" translate="yes" xml:space="preserve">
          <source>C-c &lt;var&gt;letter&lt;/var&gt;</source>
          <target state="translated">Копия &lt;var&gt;letter&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="63d94b505b28b164240bf9389a0b04f654a4efe7" translate="yes" xml:space="preserve">
          <source>C-c C-d</source>
          <target state="translated">C-c C-d</target>
        </trans-unit>
        <trans-unit id="d0bed7baa3038554c15ed1dd0d2b6090b9910013" translate="yes" xml:space="preserve">
          <source>C-c C-u</source>
          <target state="translated">C-c C-u</target>
        </trans-unit>
        <trans-unit id="f74c88ff9d7e7d40f5d62f507900f4cb7519ee90" translate="yes" xml:space="preserve">
          <source>C-c C-w</source>
          <target state="translated">C-c C-w</target>
        </trans-unit>
        <trans-unit id="e396508e7aa9423085342ba159b546882b435194" translate="yes" xml:space="preserve">
          <source>C-c C-z</source>
          <target state="translated">C-c C-z</target>
        </trans-unit>
        <trans-unit id="98c56570dd5671b7a19fbc0ebf8785f9ff91eddc" translate="yes" xml:space="preserve">
          <source>C-c ESC</source>
          <target state="translated">C-c ESC</target>
        </trans-unit>
        <trans-unit id="f9d21da244350a9db0114ec30af406d5bef1cb45" translate="yes" xml:space="preserve">
          <source>C-c ESC O P</source>
          <target state="translated">C-c ESC O P</target>
        </trans-unit>
        <trans-unit id="57e4e54e9967cd42daed8a76a5aa899b154b7b12" translate="yes" xml:space="preserve">
          <source>C-c PF1</source>
          <target state="translated">C-c PF1</target>
        </trans-unit>
        <trans-unit id="d2e5a2b66c696b957548f71ee728ee1ae137f0c0" translate="yes" xml:space="preserve">
          <source>C-c h</source>
          <target state="translated">К-к-ч</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a4b41cc50f9ee3592ac03dec905ea87299f64719" translate="yes" xml:space="preserve">
          <source>C-f C-n</source>
          <target state="translated">C-f C-n</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="a8d14a9f4bc55d9a8a84935ad37682321efb17a6" translate="yes" xml:space="preserve">
          <source>C-h</source>
          <target state="translated">C-h</target>
        </trans-unit>
        <trans-unit id="131f9a03ecbf035173b42486265daa4c059aa594" translate="yes" xml:space="preserve">
          <source>C-h C-h</source>
          <target state="translated">Ч-ч-ч</target>
        </trans-unit>
        <trans-unit id="8fc1636b1726f0f848e9110d7df8ad94624fe8a2" translate="yes" xml:space="preserve">
          <source>C-h P</source>
          <target state="translated">Ч-ч-р</target>
        </trans-unit>
        <trans-unit id="d24cf6f79d3eca79589b614119c65a877786e8e3" translate="yes" xml:space="preserve">
          <source>C-h a</source>
          <target state="translated">Ч-ч-а</target>
        </trans-unit>
        <trans-unit id="c947b2d5d96ff5df49e3e32802fd4fbc37367b9c" translate="yes" xml:space="preserve">
          <source>C-h b</source>
          <target state="translated">Ч-ч-б</target>
        </trans-unit>
        <trans-unit id="2f32ced337101528820a543fba4ae73fd0b8a020" translate="yes" xml:space="preserve">
          <source>C-h c</source>
          <target state="translated">Ч-ч-ч</target>
        </trans-unit>
        <trans-unit id="b6509cacdcc73abddf104ea8e33a97a3ac5575fa" translate="yes" xml:space="preserve">
          <source>C-h f</source>
          <target state="translated">Ч-ч-ч</target>
        </trans-unit>
        <trans-unit id="044ffa482f401d4a34b0ce3d2fc0aa8a6c6451c5" translate="yes" xml:space="preserve">
          <source>C-h m</source>
          <target state="translated">Ч-ч-ч</target>
        </trans-unit>
        <trans-unit id="94df7f22a37722547e0a4acb987c3e85a4c7583c" translate="yes" xml:space="preserve">
          <source>C-h v</source>
          <target state="translated">Ч-Ч-В</target>
        </trans-unit>
        <trans-unit id="223627ab9c74b5ae56858c226557c9e9be301085" translate="yes" xml:space="preserve">
          <source>C-i</source>
          <target state="translated">C-i</target>
        </trans-unit>
        <trans-unit id="4d83990cce829d69d972a1ed2a1e206afb6b5b37" translate="yes" xml:space="preserve">
          <source>C-j</source>
          <target state="translated">C-j</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="023f8e3d8a24aa022603e7bc5546978051323321" translate="yes" xml:space="preserve">
          <source>C-p 6</source>
          <target state="translated">С-п-6</target>
        </trans-unit>
        <trans-unit id="7e58e0990d0a53938ca001b4ad01a74ad57ecbdf" translate="yes" xml:space="preserve">
          <source>C-p C-f</source>
          <target state="translated">C-p C-f</target>
        </trans-unit>
        <trans-unit id="1666955c646a9bb3fabdb2404112bd45b66ccb34" translate="yes" xml:space="preserve">
          <source>C-q</source>
          <target state="translated">C-q</target>
        </trans-unit>
        <trans-unit id="74b18abb702cb69395f60707416dd8e1f9e92a32" translate="yes" xml:space="preserve">
          <source>C-r</source>
          <target state="translated">C-r</target>
        </trans-unit>
        <trans-unit id="78540d990eb5e51e46b3d550d8999b517398872e" translate="yes" xml:space="preserve">
          <source>C-s</source>
          <target state="translated">C-s</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="d22f544f91c38776df9e98de756eed3debe16cdc" translate="yes" xml:space="preserve">
          <source>C-u -</source>
          <target state="translated">К-У -</target>
        </trans-unit>
        <trans-unit id="10f8bc5307f68632db725ed0931d63de1460ddfa" translate="yes" xml:space="preserve">
          <source>C-u -1 C-M-u</source>
          <target state="translated">C-u -1 C-M-u</target>
        </trans-unit>
        <trans-unit id="5f418fb7321d2ab8c56f997e5658b00a3040a2d1" translate="yes" xml:space="preserve">
          <source>C-u 0 C-j</source>
          <target state="translated">C-u 0 C-j</target>
        </trans-unit>
        <trans-unit id="da79c04f91b004dd27140e6acdba5d94bb656395" translate="yes" xml:space="preserve">
          <source>C-u 0 C-x C-e</source>
          <target state="translated">C-u 0 C-x C-e</target>
        </trans-unit>
        <trans-unit id="9abc686ab642db3617ba866712386a2c3367c984" translate="yes" xml:space="preserve">
          <source>C-u 1 2 3-</source>
          <target state="translated">C-u 1 2 3-</target>
        </trans-unit>
        <trans-unit id="078553441ff260418cd0fae179ba0b421b563072" translate="yes" xml:space="preserve">
          <source>C-u 4</source>
          <target state="translated">C-u 4</target>
        </trans-unit>
        <trans-unit id="b45852e2bb35925480811fa34c28817e312757e2" translate="yes" xml:space="preserve">
          <source>C-u C-M-u</source>
          <target state="translated">К-У К-М-У</target>
        </trans-unit>
        <trans-unit id="320929c2d1df45760946518161a90d14f7c50bd7" translate="yes" xml:space="preserve">
          <source>C-u C-M-x</source>
          <target state="translated">C-u C-M-x</target>
        </trans-unit>
        <trans-unit id="c64b6c2b2de84365236fe039ef1643ad9097b181" translate="yes" xml:space="preserve">
          <source>C-u C-f</source>
          <target state="translated">К-у К-ф</target>
        </trans-unit>
        <trans-unit id="144ed887662b97ccd7d5e4df38590e6b0c9188ee" translate="yes" xml:space="preserve">
          <source>C-u RET</source>
          <target state="translated">К-у ТВЭ</target>
        </trans-unit>
        <trans-unit id="c228f37d7ea330bf7c0d73a894ac443b387f3c40" translate="yes" xml:space="preserve">
          <source>C-u-</source>
          <target state="translated">C-u-</target>
        </trans-unit>
        <trans-unit id="0a23d9de112f4305bbf7d308788b4615cc11e2a2" translate="yes" xml:space="preserve">
          <source>C-v</source>
          <target state="translated">C-v</target>
        </trans-unit>
        <trans-unit id="298ef629795cfb23ea736c739c02035ede13e0c6" translate="yes" xml:space="preserve">
          <source>C-x</source>
          <target state="translated">C-x</target>
        </trans-unit>
        <trans-unit id="4347a3678ac074d5ec07c3503e15ff18b018adc3" translate="yes" xml:space="preserve">
          <source>C-x 0</source>
          <target state="translated">C-x 0</target>
        </trans-unit>
        <trans-unit id="10124bcc79d4680d2849a4ecb1654c7898083a7b" translate="yes" xml:space="preserve">
          <source>C-x 1</source>
          <target state="translated">C-x 1</target>
        </trans-unit>
        <trans-unit id="4d47f604c607b6bcf678aa67ec1bf75bf4ba7c33" translate="yes" xml:space="preserve">
          <source>C-x 2</source>
          <target state="translated">C-x 2</target>
        </trans-unit>
        <trans-unit id="556f397c3864e7f8b2430507a0e9a218c58fd56b" translate="yes" xml:space="preserve">
          <source>C-x 3</source>
          <target state="translated">C-x 3</target>
        </trans-unit>
        <trans-unit id="abc0d3ddf5ac08765cf41363b262bc421ad3ed38" translate="yes" xml:space="preserve">
          <source>C-x 4</source>
          <target state="translated">C-x 4</target>
        </trans-unit>
        <trans-unit id="63307f15d6b42550d550cea24aeaa5bda8c024a5" translate="yes" xml:space="preserve">
          <source>C-x 4 C-f</source>
          <target state="translated">C-x 4 C-f</target>
        </trans-unit>
        <trans-unit id="d7e8408a7a87b24eb8ce1e9cd577a71f1abc5c24" translate="yes" xml:space="preserve">
          <source>C-x 4 C-o</source>
          <target state="translated">C-x 4 C-o</target>
        </trans-unit>
        <trans-unit id="d4b75cbe5b9f13c775f58fb5aadb4fd2fca9c73f" translate="yes" xml:space="preserve">
          <source>C-x 5</source>
          <target state="translated">C-x 5</target>
        </trans-unit>
        <trans-unit id="74dc274a8f353a10c8762b6eeb01cd5d80e205ba" translate="yes" xml:space="preserve">
          <source>C-x 6</source>
          <target state="translated">C-x 6</target>
        </trans-unit>
        <trans-unit id="b0c7a6e9bf270123c8284d4924a852cb0abe30d2" translate="yes" xml:space="preserve">
          <source>C-x @</source>
          <target state="translated">C-x @</target>
        </trans-unit>
        <trans-unit id="9ac0e333a25e06893ccf8044371d24b9f4683984" translate="yes" xml:space="preserve">
          <source>C-x C-\</source>
          <target state="translated">C-x C-\</target>
        </trans-unit>
        <trans-unit id="fdd391c7388aca6906f3e720a86ca5447e7d9c38" translate="yes" xml:space="preserve">
          <source>C-x C-a C-m</source>
          <target state="translated">C-x C-a C-a C-m</target>
        </trans-unit>
        <trans-unit id="38858c4b382736f825616a2e73e26265ca9bb63a" translate="yes" xml:space="preserve">
          <source>C-x C-c</source>
          <target state="translated">C-x C-c</target>
        </trans-unit>
        <trans-unit id="2e574ba4b6c51b8c22a26b1eabc3a75c78d4ea7e" translate="yes" xml:space="preserve">
          <source>C-x C-e</source>
          <target state="translated">C-x C-e</target>
        </trans-unit>
        <trans-unit id="94093db9cb5d3fcd6ac5d93df4e2811d80860744" translate="yes" xml:space="preserve">
          <source>C-x C-f</source>
          <target state="translated">C-x C-f</target>
        </trans-unit>
        <trans-unit id="5aa04c1406d2bc59f9f02c65f0475fb37d41d69f" translate="yes" xml:space="preserve">
          <source>C-x C-g</source>
          <target state="translated">C-x C-g</target>
        </trans-unit>
        <trans-unit id="42560a5db134ba65783348e3bb0520d740376d48" translate="yes" xml:space="preserve">
          <source>C-x C-k</source>
          <target state="translated">C-x C-k</target>
        </trans-unit>
        <trans-unit id="92e72c608b382e9a997922e89877037677057e63" translate="yes" xml:space="preserve">
          <source>C-x C-k RET</source>
          <target state="translated">C-x C-k RET</target>
        </trans-unit>
        <trans-unit id="1c401be2ef044065bde20ae40271bd4ce7c9dbaa" translate="yes" xml:space="preserve">
          <source>C-x C-q</source>
          <target state="translated">C-x C-q</target>
        </trans-unit>
        <trans-unit id="a35119fcea09407a970dc0c67d75cdf4c7493695" translate="yes" xml:space="preserve">
          <source>C-x C-v</source>
          <target state="translated">C-x C-v</target>
        </trans-unit>
        <trans-unit id="380c2576bb1153c21b82305ecfd8e9cf75bb83cb" translate="yes" xml:space="preserve">
          <source>C-x C-w</source>
          <target state="translated">C-x C-w</target>
        </trans-unit>
        <trans-unit id="ad8e8247f1608bee89a7e56cab4034588ceeed4a" translate="yes" xml:space="preserve">
          <source>C-x ESC</source>
          <target state="translated">C-x ESC</target>
        </trans-unit>
        <trans-unit id="08a670503878dc334b05f1ec67cd80daa09a543f" translate="yes" xml:space="preserve">
          <source>C-x RET</source>
          <target state="translated">C-x RET</target>
        </trans-unit>
        <trans-unit id="33f00fe6ae825deab6e618f2518c895513248309" translate="yes" xml:space="preserve">
          <source>C-x RET c</source>
          <target state="translated">C-x RET c</target>
        </trans-unit>
        <trans-unit id="79182736a3f6f4a9b73be73dd66c6a963d18e6ef" translate="yes" xml:space="preserve">
          <source>C-x X =</source>
          <target state="translated">C-x X =</target>
        </trans-unit>
        <trans-unit id="06fec4fbfa2b40b5ba7dcd2878f2262be7a89cc4" translate="yes" xml:space="preserve">
          <source>C-x X W</source>
          <target state="translated">C-x X W</target>
        </trans-unit>
        <trans-unit id="b2d82441407b634931a0202fcd846528c8356104" translate="yes" xml:space="preserve">
          <source>C-x X X</source>
          <target state="translated">C-x X X</target>
        </trans-unit>
        <trans-unit id="0eabb8db03adc6a93c843bc7c3b4405a882bfbbf" translate="yes" xml:space="preserve">
          <source>C-x X w</source>
          <target state="translated">C-x X w</target>
        </trans-unit>
        <trans-unit id="a433c8910fd90328a865425f7cba86d9473bd9b8" translate="yes" xml:space="preserve">
          <source>C-x a</source>
          <target state="translated">C-x a</target>
        </trans-unit>
        <trans-unit id="d678c9278cafdf31c68ce0a63d4dfdb3f69b7e79" translate="yes" xml:space="preserve">
          <source>C-x a i</source>
          <target state="translated">C-x a i</target>
        </trans-unit>
        <trans-unit id="2aaaca2013569838cb0a146bd12e35301c230558" translate="yes" xml:space="preserve">
          <source>C-x b</source>
          <target state="translated">C-x b</target>
        </trans-unit>
        <trans-unit id="81a4dfc7002c34a5db314fd55a88c71ce9f8561c" translate="yes" xml:space="preserve">
          <source>C-x l</source>
          <target state="translated">C-x l</target>
        </trans-unit>
        <trans-unit id="b228794009dfb59282b23e84edcb2dc535059148" translate="yes" xml:space="preserve">
          <source>C-x left</source>
          <target state="translated">C-x влево</target>
        </trans-unit>
        <trans-unit id="0b13a73400d0c3c495b50621ca5fbf45fa714316" translate="yes" xml:space="preserve">
          <source>C-x m</source>
          <target state="translated">C-x м</target>
        </trans-unit>
        <trans-unit id="e78aa0259487687b23094dfc0b1d246956ee5054" translate="yes" xml:space="preserve">
          <source>C-x n</source>
          <target state="translated">C-x n</target>
        </trans-unit>
        <trans-unit id="37419a3d9d60f9f4a3c3ceeae49cb867b0552dd5" translate="yes" xml:space="preserve">
          <source>C-x o</source>
          <target state="translated">C-x o</target>
        </trans-unit>
        <trans-unit id="06bba06d9146ec872930935a408ff9e6db7b540e" translate="yes" xml:space="preserve">
          <source>C-x q</source>
          <target state="translated">C-x q</target>
        </trans-unit>
        <trans-unit id="6e1b8f11e4e004ffcd85260453eb416fadd8becd" translate="yes" xml:space="preserve">
          <source>C-x r</source>
          <target state="translated">C-x r</target>
        </trans-unit>
        <trans-unit id="c03a751f3df1d75c00ca555cdecb7ea0f12e35b3" translate="yes" xml:space="preserve">
          <source>C-x t</source>
          <target state="translated">C-x t</target>
        </trans-unit>
        <trans-unit id="16f34907c9a94600e9a207daf61c838d0b36dc8a" translate="yes" xml:space="preserve">
          <source>C-x v</source>
          <target state="translated">C-x v</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="acbbb692ba3dcc7f0dd54066ac8990ff1950dc9c" translate="yes" xml:space="preserve">
          <source>C-z</source>
          <target state="translated">C-z</target>
        </trans-unit>
        <trans-unit id="ee5254754a61a705597a6d10837027cbbdd49eb6" translate="yes" xml:space="preserve">
          <source>CLOS</source>
          <target state="translated">CLOS</target>
        </trans-unit>
        <trans-unit id="8a9cbc4396b103e6b251b294230c1bb9eed38e2f" translate="yes" xml:space="preserve">
          <source>COM1</source>
          <target state="translated">COM1</target>
        </trans-unit>
        <trans-unit id="23f35962de37902073c854bc889f0133b87d83ae" translate="yes" xml:space="preserve">
          <source>COM9</source>
          <target state="translated">COM9</target>
        </trans-unit>
        <trans-unit id="cbb44b8d4066ca53d103823d7579880a884c46f2" translate="yes" xml:space="preserve">
          <source>CTL</source>
          <target state="translated">CTL</target>
        </trans-unit>
        <trans-unit id="b38bed0f0e9601a07358ec72777da31f91720f2a" translate="yes" xml:space="preserve">
          <source>CTRL</source>
          <target state="translated">CTRL</target>
        </trans-unit>
        <trans-unit id="5e1dd8155002a7d7db24335015acaddd25a44f09" translate="yes" xml:space="preserve">
          <source>CVS</source>
          <target state="translated">CVS</target>
        </trans-unit>
        <trans-unit id="36e5803b7728bb1569947feca18d17ebe22e40b0" translate="yes" xml:space="preserve">
          <source>Calendrical conversion functions always use the Gregorian calendar, even for dates before the Gregorian calendar was introduced. Year numbers count the number of years since the year 1 BC, and do not skip zero as traditional Gregorian years do; for example, the year number -37 represents the Gregorian year 38 BC.</source>
          <target state="translated">Функции преобразования календаря всегда используют григорианский календарь,даже для дат,предшествовавших введению григорианского календаря.Цифры года подсчитывают количество лет с года 1 до н.э.и не пропускают ноль,как это делают традиционные григорианские годы;например,номер года -37 представляет григорианский год 38 до н.э..</target>
        </trans-unit>
        <trans-unit id="de42e995f53f7e732b05aa461dce2010e145fa00" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;button&lt;/var&gt;&amp;rsquo;s &lt;code&gt;action&lt;/code&gt; property (i.e., invoke the function that is the value of that property, passing it the single argument &lt;var&gt;button&lt;/var&gt;). If &lt;var&gt;use-mouse-action&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, try to invoke the button&amp;rsquo;s &lt;code&gt;mouse-action&lt;/code&gt; property instead of &lt;code&gt;action&lt;/code&gt;; if the button has no &lt;code&gt;mouse-action&lt;/code&gt; property, use &lt;code&gt;action&lt;/code&gt; as normal. If the &lt;code&gt;button-data&lt;/code&gt; property is present in &lt;var&gt;button&lt;/var&gt;, use that as the argument for the &lt;code&gt;action&lt;/code&gt; function instead of &lt;var&gt;button&lt;/var&gt;.</source>
          <target state="translated">Вызов &lt;var&gt;button&lt;/var&gt; &amp;laquo;s &lt;code&gt;action&lt;/code&gt; свойство (т.е. вызвать функцию , которая является значением этого свойства, передавая ему единственный аргумент &lt;var&gt;button&lt;/var&gt; ). Если &lt;var&gt;use-mouse-action&lt;/var&gt; не &lt;code&gt;nil&lt;/code&gt; , попробуйте вызвать свойство кнопки &lt;code&gt;mouse-action&lt;/code&gt; вместо &lt;code&gt;action&lt;/code&gt; ; если кнопка не имеет свойства &lt;code&gt;mouse-action&lt;/code&gt; , используйте &lt;code&gt;action&lt;/code&gt; как обычно. Если свойство &lt;code&gt;button-data&lt;/code&gt; присутствует в &lt;var&gt;button&lt;/var&gt; , используйте его в качестве аргумента для функции &lt;code&gt;action&lt;/code&gt; вместо &lt;var&gt;button&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f7e81e62a0bc26dffa21e5943c5b76d235ec9103" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function and only if the old function returned &lt;code&gt;nil&lt;/code&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">Вызов &lt;var&gt;function&lt;/var&gt; после старой функции и только в том случае, если старая функция вернула &lt;code&gt;nil&lt;/code&gt; . Более конкретно, композиция двух функций ведет себя так:</target>
        </trans-unit>
        <trans-unit id="15f89cad7964a4c4ff36312550efc21a307afff6" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function and only if the old function returned non-&lt;code&gt;nil&lt;/code&gt;. Both functions receive the same arguments, and the return value of the composition is the return value of &lt;var&gt;function&lt;/var&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">Вызов &lt;var&gt;function&lt;/var&gt; после старой функции и только в том случае, если старая функция вернула &lt;code&gt;nil&lt;/code&gt; . Обе функции получают одинаковые аргументы, а возвращаемое значение композиции является возвращаемым значением &lt;var&gt;function&lt;/var&gt; . Более конкретно, композиция двух функций ведет себя так:</target>
        </trans-unit>
        <trans-unit id="11b9ee6402d0942f809e7bacb34c109edce11c8a" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">Вызов &lt;var&gt;function&lt;/var&gt; после старой функции. Обе функции получают одинаковые аргументы, а возвращаемое значение композиции - это возвращаемое значение старой функции. Более конкретно, композиция двух функций ведет себя так:</target>
        </trans-unit>
        <trans-unit id="dd45f95fef4e571698af292b7cdd92bffd8265e2" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function and don&amp;rsquo;t call the old function if &lt;var&gt;function&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">Вызывайте &lt;var&gt;function&lt;/var&gt; перед старой функцией и не вызывайте старую функцию, если &lt;var&gt;function&lt;/var&gt; возвращает &lt;code&gt;nil&lt;/code&gt; . Обе функции получают одинаковые аргументы, а возвращаемое значение композиции - это возвращаемое значение старой функции. Более конкретно, композиция двух функций ведет себя так:</target>
        </trans-unit>
        <trans-unit id="e177089f3e47a75e445f46873115fbe430078933" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function and only call the old function if &lt;var&gt;function&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">Вызов &lt;var&gt;function&lt;/var&gt; перед старой функцией и вызов старой функции только в том случае, если &lt;var&gt;function&lt;/var&gt; возвращает &lt;code&gt;nil&lt;/code&gt; . Более конкретно, композиция двух функций ведет себя так:</target>
        </trans-unit>
        <trans-unit id="5a61495f3b296416244dbb85cc0933049276d9d5" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">Вызов &lt;var&gt;function&lt;/var&gt; перед старой функцией. Обе функции получают одни и те же аргументы, а возвращаемое значение композиции - это возвращаемое значение старой функции. Более конкретно, композиция двух функций ведет себя так:</target>
        </trans-unit>
        <trans-unit id="f4cc04f8d665904345400ebc070afe6901974fc2" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; first and use the result (which should be a list) as the new arguments to pass to the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">Сначала вызовите &lt;var&gt;function&lt;/var&gt; и используйте результат (который должен быть списком) в качестве новых аргументов для передачи старой функции. Более конкретно, композиция двух функций ведет себя так:</target>
        </trans-unit>
        <trans-unit id="e77c6828a07ec693781d6efe3e57ff1a5a36a8c0" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; for characters in &lt;var&gt;charset&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; is called with two arguments. The first one is a cons cell &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; .  &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; indicate a range of characters contained in charset. The second argument passed to &lt;var&gt;function&lt;/var&gt; is &lt;var&gt;arg&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; вызова для символов в &lt;var&gt;charset&lt;/var&gt; . &lt;var&gt;function&lt;/var&gt; вызывается с двумя аргументами. Первый из них является против клеток &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;from&lt;/var&gt; и &lt;var&gt;to&lt;/var&gt; указать диапазон символов , содержащийся в кодировке. Второй аргумент, переданный &lt;var&gt;function&lt;/var&gt; - это &lt;var&gt;arg&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fae0114c2201a949abeef4209c12323f1f0e324b" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; for every piece of advice that was added to the named function &lt;var&gt;symbol&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; is called with two arguments: the advice function and its properties.</source>
          <target state="translated">Вызов &lt;var&gt;function&lt;/var&gt; для каждого совета, который был добавлен к названному &lt;var&gt;symbol&lt;/var&gt; функции . &lt;var&gt;function&lt;/var&gt; вызывается с двумя аргументами: функцией совета и ее свойствами.</target>
        </trans-unit>
        <trans-unit id="567ee80f88e9b6fcfc133e840199c180bb8db2d1" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; instead of the old function, but provide the old function as an extra argument to &lt;var&gt;function&lt;/var&gt;. This is the most flexible composition. For example, it lets you call the old function with different arguments, or many times, or within a let-binding, or you can sometimes delegate the work to the old function and sometimes override it completely. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">Вызов &lt;var&gt;function&lt;/var&gt; вместо старой функции, но предоставьте старую функцию в качестве дополнительного аргумента &lt;var&gt;function&lt;/var&gt; . Это наиболее гибкий состав. Например, он позволяет вам вызывать старую функцию с разными аргументами или много раз, или в рамках let-привязки, или вы можете иногда делегировать работу старой функции, а иногда полностью переопределять ее. Более конкретно, композиция двух функций ведет себя так:</target>
        </trans-unit>
        <trans-unit id="d1a7d71503696cf38410fc1322aa1095b06486f0" translate="yes" xml:space="preserve">
          <source>Call the anonymous function with one argument, &lt;var&gt;expval&lt;/var&gt; (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;).</source>
          <target state="translated">Вызовите анонимную функцию с одним аргументом, &lt;var&gt;expval&lt;/var&gt; (см. &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Лямбда-выражения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7476fa450c9cf57b9d41330c2668e502b573753f" translate="yes" xml:space="preserve">
          <source>Call the function (the first element of the function call) with &lt;var&gt;n&lt;/var&gt; arguments (the other elements) and an additional &lt;var&gt;n&lt;/var&gt;+1-th argument that is &lt;var&gt;expval&lt;/var&gt;.</source>
          <target state="translated">Вызовите функцию (первый элемент вызова функции) с &lt;var&gt;n&lt;/var&gt; аргументами (другими элементами) и дополнительным &lt;var&gt;n&lt;/var&gt; + 1-м аргументом, который является &lt;var&gt;expval&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="cce8159a07f7ca94dd3aede2fb066a149472cac4" translate="yes" xml:space="preserve">
          <source>Call the function &lt;var&gt;f&lt;/var&gt; for every piece of advice that was added to &lt;var&gt;function-def&lt;/var&gt;. &lt;var&gt;f&lt;/var&gt; is called with two arguments: the advice function and its properties.</source>
          <target state="translated">Вызывайте функцию &lt;var&gt;f&lt;/var&gt; для каждого совета, добавленного в &lt;var&gt;function-def&lt;/var&gt; . &lt;var&gt;f&lt;/var&gt; вызывается с двумя аргументами: функцией совета и ее свойствами.</target>
        </trans-unit>
        <trans-unit id="f7bee42ac2cfe40e42c5b3d7a4488a39eab8279c" translate="yes" xml:space="preserve">
          <source>Call the named function with one argument, &lt;var&gt;expval&lt;/var&gt;.</source>
          <target state="translated">Вызовите названную функцию с одним аргументом, &lt;var&gt;expval&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c5bef85c072afa5ae3f80c86a71f855f8cba1aac" translate="yes" xml:space="preserve">
          <source>Call the old function first and pass the result to &lt;var&gt;function&lt;/var&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">Сначала вызовите старую функцию и передайте результат &lt;var&gt;function&lt;/var&gt; . Более конкретно, композиция двух функций ведет себя так:</target>
        </trans-unit>
        <trans-unit id="6afd776be5db841a6dc68b637bb932e7dfca56a9" translate="yes" xml:space="preserve">
          <source>Call this command after using &lt;code&gt;smie-config-guess&lt;/code&gt;, to save your settings for future sessions.</source>
          <target state="translated">Вызовите эту команду после использования &lt;code&gt;smie-config-guess&lt;/code&gt; , чтобы сохранить настройки для будущих сеансов.</target>
        </trans-unit>
        <trans-unit id="8506342e0260dd8016e03d646af20a2c9018a199" translate="yes" xml:space="preserve">
          <source>Call this function instead of using a literal value (usually, zero) of the column number for indenting top-level program constructs. The function&amp;rsquo;s value is the column number to use for top-level constructs. When no superior mode is in effect, this function returns zero.</source>
          <target state="translated">Вызовите эту функцию вместо использования буквального значения (обычно нуля) номера столбца для отступов программных конструкций верхнего уровня. Значение функции - это номер столбца, используемый для конструкций верхнего уровня. Если вышестоящий режим не действует, функция возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="98d6a6a2c4f2e6e0e83bdfbcc0730217802507ab" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;concat&lt;/code&gt; converts the list to a string so you can see its contents more clearly.</source>
          <target state="translated">Вызов &lt;code&gt;concat&lt;/code&gt; преобразует список в строку, чтобы вы могли более четко видеть ее содержимое.</target>
        </trans-unit>
        <trans-unit id="aa38eb2554dbe5c7a33e4b709e55fe4dded0e886" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;smie-setup&lt;/code&gt; is also sufficient to make</source>
          <target state="translated">Вызов &lt;code&gt;smie-setup&lt;/code&gt; также достаточно , чтобы сделать</target>
        </trans-unit>
        <trans-unit id="511ba4c0240efeaabfee01e6c6a8c90f51297283" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;substitute-in-file-name&lt;/code&gt; on output produced by &lt;code&gt;substitute-in-file-name&lt;/code&gt; tends to give incorrect results. For instance, use of &amp;lsquo;</source>
          <target state="translated">Вызов &lt;code&gt;substitute-in-file-name&lt;/code&gt; на выходе, произведенном с помощью функции &lt;code&gt;substitute-in-file-name&lt;/code&gt; имеет тенденцию давать неверные результаты. Например, использование '</target>
        </trans-unit>
        <trans-unit id="9ac3d844132b984a3eb47bf8dcb79e4bbd848878" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;window-preserve-size&lt;/code&gt; (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;) will try to keep the size of the argument window unchanged when popping up a new window. You have to make sure that another window in the same combination can be shrunk instead, though.</source>
          <target state="translated">Вызов &lt;code&gt;window-preserve-size&lt;/code&gt; (см. &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Раздел &amp;laquo;Сохранение размеров окна&amp;raquo;&lt;/a&gt; ) будет пытаться сохранить размер окна аргументов неизменным при открытии нового окна. Однако вы должны убедиться, что другое окно в той же комбинации может быть уменьшено вместо этого.</target>
        </trans-unit>
        <trans-unit id="2f2b1f5f71d89e54c8503e6cf93a04999cc1b58a" translate="yes" xml:space="preserve">
          <source>Calling Functions</source>
          <target state="translated">Функции вызова</target>
        </trans-unit>
        <trans-unit id="504886a8ce3a7ab2de140289b5cdac7f6b388ff2" translate="yes" xml:space="preserve">
          <source>Calling a command, so that it will read arguments.</source>
          <target state="translated">Вызов команды,чтобы она прочитала аргументы.</target>
        </trans-unit>
        <trans-unit id="a961505da75e77209eaa6b59e8f61a3dffb36635" translate="yes" xml:space="preserve">
          <source>Calling the major mode command twice in direct succession should not fail and should do the same thing as calling the command only once. In other words, the major mode command should be idempotent.</source>
          <target state="translated">Дважды вызывать команду основного режима в прямой последовательности не должно быть неудачным и должно быть сделано то же самое,что и вызывать команду только один раз.Другими словами,команда основного режима должна быть idempotent.</target>
        </trans-unit>
        <trans-unit id="1e6c66b20a23a26c0a918b56cec3c86770820c22" translate="yes" xml:space="preserve">
          <source>Calling this function explicitly is useful for splitting the effects of a command into more than one unit. For example, &lt;code&gt;query-replace&lt;/code&gt; calls &lt;code&gt;undo-boundary&lt;/code&gt; after each replacement, so that the user can undo individual replacements one by one.</source>
          <target state="translated">Явный вызов этой функции полезен для разделения эффектов команды на несколько единиц. Например, &lt;code&gt;query-replace&lt;/code&gt; вызывает &lt;code&gt;undo-boundary&lt;/code&gt; после каждой замены, чтобы пользователь мог отменять отдельные замены одну за другой.</target>
        </trans-unit>
        <trans-unit id="8a5bda3d28236066116676706c47de1d0f0328a6" translate="yes" xml:space="preserve">
          <source>Calling this function is sufficient to make commands such as &lt;code&gt;forward-sexp&lt;/code&gt;, &lt;code&gt;backward-sexp&lt;/code&gt;, and &lt;code&gt;transpose-sexps&lt;/code&gt; be able to properly handle structural elements other than just the paired parentheses already handled by syntax tables. For example, if the provided grammar is precise enough, &lt;code&gt;transpose-sexps&lt;/code&gt; can correctly transpose the two arguments of a &lt;code&gt;+&lt;/code&gt; operator, taking into account the precedence rules of the language.</source>
          <target state="translated">Вызова этой функции достаточно, чтобы такие команды, как &lt;code&gt;forward-sexp&lt;/code&gt; , &lt;code&gt;backward-sexp&lt;/code&gt; и &lt;code&gt;transpose-sexps&lt;/code&gt; , могли правильно обрабатывать структурные элементы, отличные от парных скобок, уже обработанных синтаксическими таблицами. Например, если предоставленная грамматика достаточно точна, &lt;code&gt;transpose-sexps&lt;/code&gt; может правильно транспонировать два аргумента оператора &lt;code&gt;+&lt;/code&gt; с учетом правил приоритета языка.</target>
        </trans-unit>
        <trans-unit id="e5b34fd5a2e36cd4eafb9c4fcecc3d11f251e2e3" translate="yes" xml:space="preserve">
          <source>Cannot determine image type</source>
          <target state="translated">Не могу определить тип изображения</target>
        </trans-unit>
        <trans-unit id="c1186dd76154d57de923217a8dd3d16441be124a" translate="yes" xml:space="preserve">
          <source>Cannot open load file &lt;var&gt;filename&lt;/var&gt;</source>
          <target state="translated">Не удается открыть файл загрузки &lt;var&gt;filename&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="311dff8ce71dc0b4b0666e7280ad010d93e7918a" translate="yes" xml:space="preserve">
          <source>Capture groups</source>
          <target state="translated">Захватные группы</target>
        </trans-unit>
        <trans-unit id="5fe52af8b2d198c370691f5d3a5caec003b55dcc" translate="yes" xml:space="preserve">
          <source>Case Changes</source>
          <target state="translated">Изменения в деле</target>
        </trans-unit>
        <trans-unit id="ff5641735ee7c07e5eed18f7107abe940e61dcc3" translate="yes" xml:space="preserve">
          <source>Case Conversion in Lisp</source>
          <target state="translated">Преобразование дела в липосакцию</target>
        </trans-unit>
        <trans-unit id="ee05e5edf5d51051d5e8ea58e5fb1140b748c002" translate="yes" xml:space="preserve">
          <source>Case conversion functions.</source>
          <target state="translated">Функции преобразования корпуса.</target>
        </trans-unit>
        <trans-unit id="4fc7e1d52f22796c47c268de900d6e7082017f5a" translate="yes" xml:space="preserve">
          <source>Case conversion of parts of the buffer.</source>
          <target state="translated">Преобразование части буфера в регистр.</target>
        </trans-unit>
        <trans-unit id="60f886006f4b5be396aef39220ae04232401704b" translate="yes" xml:space="preserve">
          <source>Case tables (see &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;Case Tables&lt;/a&gt;).</source>
          <target state="translated">Таблицы случаев (см. &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;Таблицы случаев&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="760a611d6b77c0b6b7da5b461fa97629808e415a" translate="yes" xml:space="preserve">
          <source>Case-independent or case-significant searching.</source>
          <target state="translated">Поиск без учета регистра или с учетом регистра.</target>
        </trans-unit>
        <trans-unit id="6ccb60071be8f00760a3824d9f7d0fad57de789f" translate="yes" xml:space="preserve">
          <source>Categories</source>
          <target state="translated">Categories</target>
        </trans-unit>
        <trans-unit id="c62bb44b2dbb1eab36c5fe60b6989181f7595720" translate="yes" xml:space="preserve">
          <source>Category character</source>
          <target state="translated">категориальный характер</target>
        </trans-unit>
        <trans-unit id="ed3dc45ada47ab5b03a62a82e4fe63e2c08a4aa5" translate="yes" xml:space="preserve">
          <source>Category name</source>
          <target state="translated">наименование категории</target>
        </trans-unit>
        <trans-unit id="21ee11841e5216e7932316a3ba9dbe3bf176d378" translate="yes" xml:space="preserve">
          <source>Causes the server to suppress playing any sounds, if it has that ability.</source>
          <target state="translated">Заставляет сервер подавлять воспроизведение любых звуков,если у него есть такая способность.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="983a41bf08948cb10ca36f96d754fedb2fa51108" translate="yes" xml:space="preserve">
          <source>Caveats for &lt;var&gt;symbol&lt;/var&gt; in Sequencing Patterns</source>
          <target state="translated">Предостережения для &lt;var&gt;symbol&lt;/var&gt; в шаблонах секвенирования</target>
        </trans-unit>
        <trans-unit id="10c846191e34dad7942410f081d90ef9a60dccb4" translate="yes" xml:space="preserve">
          <source>Certain &lt;em&gt;special events&lt;/em&gt; are handled at a very low level&amp;mdash;as soon as they are read. The &lt;code&gt;read-event&lt;/code&gt; function processes these events itself, and never returns them. Instead, it keeps waiting for the first event that is not special and returns that one.</source>
          <target state="translated">Некоторые &lt;em&gt;специальные события&lt;/em&gt; обрабатываются на очень низком уровне - как только они прочитаны. Функция &lt;code&gt;read-event&lt;/code&gt; события сама обрабатывает эти события и никогда их не возвращает. Вместо этого он продолжает ждать первого события, которое не является особенным, и возвращает его.</target>
        </trans-unit>
        <trans-unit id="2668c38616b8f82385530ab10556316664076de7" translate="yes" xml:space="preserve">
          <source>Certain abbrevs, called &lt;em&gt;system abbrevs&lt;/em&gt;, are defined by a major mode instead of the user. A system abbrev is identified by its non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;:system&lt;/code&gt; property (see &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;). When abbrevs are saved to an abbrev file, system abbrevs are omitted. See &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;Abbrev Files&lt;/a&gt;.</source>
          <target state="translated">Некоторые сокращения, называемые &lt;em&gt;системными&lt;/em&gt; , определяются основным режимом, а не пользователем. Системное сокращение идентифицируется своим свойством, &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;отличным&lt;/a&gt; от &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;:system&lt;/code&gt; (см. Свойства сокращений ). Когда сокращения сохраняются в файле сокращений, системные сокращения опускаются. См. &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;Файлы сокращений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb70bbca935cc9ba0d3270144cb857746601caf3" translate="yes" xml:space="preserve">
          <source>Certain format specifications require values of particular types. If you supply a value that doesn&amp;rsquo;t fit the requirements, an error is signaled.</source>
          <target state="translated">Для некоторых спецификаций формата требуются значения определенных типов. Если вы вводите значение, не соответствующее требованиям, выдается сигнал об ошибке.</target>
        </trans-unit>
        <trans-unit id="17f9520304f622d054d6e6a095bc91eb04688136" translate="yes" xml:space="preserve">
          <source>Certain function-like objects, called &lt;em&gt;special forms&lt;/em&gt; and &lt;em&gt;macros&lt;/em&gt;, also accept arguments to carry out computations. However, as explained below, these are not considered functions in Emacs Lisp.</source>
          <target state="translated">Некоторые функционально-подобные объекты, называемые &lt;em&gt;специальными формами&lt;/em&gt; и &lt;em&gt;макросами&lt;/em&gt; , также принимают аргументы для выполнения вычислений. Однако, как объяснено ниже, они не считаются функциями в Emacs Lisp.</target>
        </trans-unit>
        <trans-unit id="a3317a453486426103c83a8405cdf6293656cb02" translate="yes" xml:space="preserve">
          <source>Certain functions such as &lt;code&gt;read-key-sequence&lt;/code&gt; or &lt;code&gt;read-quoted-char&lt;/code&gt; prevent quitting entirely even though they wait for input. Instead of quitting,</source>
          <target state="translated">Некоторые функции, такие как &lt;code&gt;read-key-sequence&lt;/code&gt; или &lt;code&gt;read-quoted-char&lt;/code&gt; , полностью предотвращают завершение работы, даже если они ждут ввода. Вместо того, чтобы уйти,</target>
        </trans-unit>
        <trans-unit id="9781a84dc281e4b3ac7e8fb884e18e00f10c91d8" translate="yes" xml:space="preserve">
          <source>Certain other values of &lt;var&gt;separator-type&lt;/var&gt; specify a different style of separator. Here is a table of them:</source>
          <target state="translated">Некоторые другие значения типа &lt;var&gt;separator-type&lt;/var&gt; определяют другой стиль разделителя. Вот их таблица:</target>
        </trans-unit>
        <trans-unit id="b28516fbcb8e500a178b2a631de8639fdef46b0f" translate="yes" xml:space="preserve">
          <source>Certain text properties are meaningful in the mode line. The &lt;code&gt;face&lt;/code&gt; property affects the appearance of text; the &lt;code&gt;help-echo&lt;/code&gt; property associates help strings with the text, and &lt;code&gt;keymap&lt;/code&gt; can make the text mouse-sensitive.</source>
          <target state="translated">Некоторые текстовые свойства имеют значение в строке режима. Свойство &lt;code&gt;face&lt;/code&gt; влияет на внешний вид текста; в &lt;code&gt;help-echo&lt;/code&gt; связывает свойство помощи строка с текстом, и &lt;code&gt;keymap&lt;/code&gt; могут сделать текст мыши чувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="78b3210742dadf1e3c0eabba8c8ed5204a166dda" translate="yes" xml:space="preserve">
          <source>Change Hooks</source>
          <target state="translated">Крючки для смены</target>
        </trans-unit>
        <trans-unit id="b474b780b926dcbfa75d96cb86ad31c3233c390b" translate="yes" xml:space="preserve">
          <source>Change the font-related attributes of &lt;var&gt;face&lt;/var&gt; to those of &lt;var&gt;font&lt;/var&gt; (a string or a font object). See &lt;a href=&quot;face-attributes#face_002dfont_002dattribute&quot;&gt;face-font-attribute&lt;/a&gt;, for the supported formats of the &lt;var&gt;font&lt;/var&gt; argument. This function sets the attribute &lt;code&gt;:font&lt;/code&gt; of the face, and indirectly also the &lt;code&gt;:family&lt;/code&gt;, &lt;code&gt;:foundry&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:weight&lt;/code&gt;, and &lt;code&gt;:slant&lt;/code&gt; attributes, as defined by the font. If &lt;var&gt;frame&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, only change the attributes on the specified frame.</source>
          <target state="translated">Измените связанные со шрифтом атрибуты &lt;var&gt;face&lt;/var&gt; на атрибуты &lt;var&gt;font&lt;/var&gt; (строка или объект шрифта). См. &lt;a href=&quot;face-attributes#face_002dfont_002dattribute&quot;&gt;Атрибут face-font-attribute&lt;/a&gt; , чтобы узнать о поддерживаемых форматах аргумента &lt;var&gt;font&lt;/var&gt; . Эта функция устанавливает атрибут &lt;code&gt;:font&lt;/code&gt; лица, а также косвенным образом &lt;code&gt;:family&lt;/code&gt; , &lt;code&gt;:foundry&lt;/code&gt; , &lt;code&gt;:width&lt;/code&gt; , &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:weight&lt;/code&gt; , а также &lt;code&gt;:slant&lt;/code&gt; атрибуты, как определенно шрифтом. Если &lt;var&gt;frame&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , изменяйте атрибуты только в указанном кадре.</target>
        </trans-unit>
        <trans-unit id="100a984c74cd76a27c5abd1250aa8a0325533085" translate="yes" xml:space="preserve">
          <source>Changes in process sentinels take effect immediately&amp;mdash;if the sentinel is slated to be run but has not been called yet, and you specify a new sentinel, the eventual call to the sentinel will use the new one.</source>
          <target state="translated">Изменения в дозорных процессах вступают в силу немедленно - если дозорный планируется запустить, но он еще не был вызван, и вы указываете нового дозорного, при последующем вызове дозорного будет использоваться новый.</target>
        </trans-unit>
        <trans-unit id="156524b67d9176e9980be07f37b022c85504061b" translate="yes" xml:space="preserve">
          <source>Changing File Names and Attributes</source>
          <target state="translated">Изменение имен и атрибутов файлов</target>
        </trans-unit>
        <trans-unit id="51016b235a030223e05c662ad0783ea8a9b72574" translate="yes" xml:space="preserve">
          <source>Changing Key Bindings</source>
          <target state="translated">Изменение креплений для ключей</target>
        </trans-unit>
        <trans-unit id="7594cb533c4a496e3f17056c9667959d56338aee" translate="yes" xml:space="preserve">
          <source>Changing Text Properties</source>
          <target state="translated">Изменение текстовых свойств</target>
        </trans-unit>
        <trans-unit id="de45395bd6cb72dc2da08ba6aae7cf507d1e0f7f" translate="yes" xml:space="preserve">
          <source>Changing any of the &lt;code&gt;scroll-bar-width&lt;/code&gt;, &lt;code&gt;scroll-bar-height&lt;/code&gt;, &lt;code&gt;vertical-scroll-bars&lt;/code&gt;, &lt;code&gt;horizontal-scroll-bars&lt;/code&gt;, &lt;code&gt;left-fringe&lt;/code&gt; and &lt;code&gt;right-fringe&lt;/code&gt; frame parameters is handled as if the frame contained just one live window. This means, for example, that removing vertical scroll bars on a frame containing several side by side windows will shrink the outer frame width by the width of one scroll bar provided this option is &lt;code&gt;nil&lt;/code&gt; and keep it unchanged if this option is &lt;code&gt;t&lt;/code&gt; or a list containing &lt;code&gt;vertical-scroll-bars&lt;/code&gt;.</source>
          <target state="translated">Изменение любого из параметров рамки &lt;code&gt;scroll-bar-width&lt;/code&gt; , &lt;code&gt;scroll-bar-height&lt;/code&gt; , &lt;code&gt;vertical-scroll-bars&lt;/code&gt; , &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; полос прокрутки , &lt;code&gt;left-fringe&lt;/code&gt; и &lt;code&gt;right-fringe&lt;/code&gt; обрабатывается так, как если бы кадр содержал только одно живое окно. Это означает, например, что удаление вертикальных полос прокрутки на фрейме, содержащем несколько бок о бок окон, уменьшит внешнюю ширину фрейма на ширину одной полосы прокрутки, если этот параметр равен &lt;code&gt;nil&lt;/code&gt; и оставит его неизменным, если этот параметр - &lt;code&gt;t&lt;/code&gt; или список содержащие &lt;code&gt;vertical-scroll-bars&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7f426a8c11556d236e6fe7c9beb52aa001a64a" translate="yes" xml:space="preserve">
          <source>Changing point.</source>
          <target state="translated">Точка смены.</target>
        </trans-unit>
        <trans-unit id="35bbf3ed9b965bfacb89f9f800e62d4fe12c4c01" translate="yes" xml:space="preserve">
          <source>Changing the &lt;small&gt;CAR&lt;/small&gt; of a cons cell is done with &lt;code&gt;setcar&lt;/code&gt;. When used on a list, &lt;code&gt;setcar&lt;/code&gt; replaces one element of a list with a different element.</source>
          <target state="translated">Изменение &lt;small&gt;CAR&lt;/small&gt; для cons-ячейки выполняется с помощью &lt;code&gt;setcar&lt;/code&gt; . При использовании в списке &lt;code&gt;setcar&lt;/code&gt; заменяет один элемент списка другим элементом.</target>
        </trans-unit>
        <trans-unit id="562e2b4207b6c404cf6c751160157bd49ac95781" translate="yes" xml:space="preserve">
          <source>Changing the sizes of windows.</source>
          <target state="translated">Изменение размеров окон.</target>
        </trans-unit>
        <trans-unit id="6a1f8e8787fc1acb606cc50f5b6e9d8f7bdd458d" translate="yes" xml:space="preserve">
          <source>Changing this variable does not force an update of the mode line.</source>
          <target state="translated">Изменение этой переменной не приводит к обновлению строки режима.</target>
        </trans-unit>
        <trans-unit id="f0c739408abd052ee5d44db4e8e0adc91f0b680a" translate="yes" xml:space="preserve">
          <source>Char-Table Type</source>
          <target state="translated">Тип таблички</target>
        </trans-unit>
        <trans-unit id="ce090131f8a640a66d14740f37efd79c98da2f52" translate="yes" xml:space="preserve">
          <source>Char-Tables</source>
          <target state="translated">Char-Tables</target>
        </trans-unit>
        <trans-unit id="89a0d26064c88761be4481b9b52065531e5e024c" translate="yes" xml:space="preserve">
          <source>Character Classes</source>
          <target state="translated">Классы персонажей</target>
        </trans-unit>
        <trans-unit id="8cd166d7b5c972d19c78d965c26afe0d852a6bbc" translate="yes" xml:space="preserve">
          <source>Character Codes</source>
          <target state="translated">Коды символов</target>
        </trans-unit>
        <trans-unit id="198408dd9120e5714424c5f00fa2e02c78a9427b" translate="yes" xml:space="preserve">
          <source>Character Display</source>
          <target state="translated">Отображение персонажей</target>
        </trans-unit>
        <trans-unit id="b1c5fa0155ae3ab9ad380fa3cfc349d0a0ec23e9" translate="yes" xml:space="preserve">
          <source>Character Properties</source>
          <target state="translated">Характеристики Свойства</target>
        </trans-unit>
        <trans-unit id="0e7c11d7a7200a36005057b0e953e12aae6033f0" translate="yes" xml:space="preserve">
          <source>Character Sets</source>
          <target state="translated">Наборы персонажей</target>
        </trans-unit>
        <trans-unit id="275450cc1e4926b0829cc65cd3f2b3d835f4e048" translate="yes" xml:space="preserve">
          <source>Character Type</source>
          <target state="translated">Тип персонажа</target>
        </trans-unit>
        <trans-unit id="ea8d87953a98f75b2aa021b7b8cb876f766bf6b9" translate="yes" xml:space="preserve">
          <source>Character attributes that define their behavior and handling.</source>
          <target state="translated">Атрибуты символов,определяющие их поведение и обращение с ними.</target>
        </trans-unit>
        <trans-unit id="5978dbfeccf01151025eeaa59ed56b27e00fec9f" translate="yes" xml:space="preserve">
          <source>Character category tables (see &lt;a href=&quot;categories#Categories&quot;&gt;Categories&lt;/a&gt;).</source>
          <target state="translated">Таблицы категорий персонажей (см. &lt;a href=&quot;categories#Categories&quot;&gt;Категории&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9755699503a79e3114d0435a6c41d83696a2d623" translate="yes" xml:space="preserve">
          <source>Character classes used in regular expressions.</source>
          <target state="translated">Классы символов,используемые в регулярных выражениях.</target>
        </trans-unit>
        <trans-unit id="1d5a2032f34ffea795feb6720457cf5de1c95dbd" translate="yes" xml:space="preserve">
          <source>Character quotes: &amp;lsquo;</source>
          <target state="translated">Цитаты персонажей: '</target>
        </trans-unit>
        <trans-unit id="d4eeaab110722d926fe33c40dc614e75f6d0aef8" translate="yes" xml:space="preserve">
          <source>Characteristics of arrays in Emacs Lisp.</source>
          <target state="translated">Характеристики массивов в Эмаксе Липе.</target>
        </trans-unit>
        <trans-unit id="7295605dcc69f48d0631634d8294614f5cae238b" translate="yes" xml:space="preserve">
          <source>Characters for which there is no suitable font, or which cannot be encoded by the terminal&amp;rsquo;s coding system.</source>
          <target state="translated">Символы, для которых нет подходящего шрифта или которые не могут быть закодированы системой кодирования терминала.</target>
        </trans-unit>
        <trans-unit id="f395a989f7613a08007721455bd0e01ef846f3c5" translate="yes" xml:space="preserve">
          <source>Characters in strings and buffers are currently limited to the range of 0 to 4194303&amp;mdash;twenty two bits (see &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;). Codes 0 through 127 are</source>
          <target state="translated">Символы в строках и буферах в настоящее время ограничены диапазоном от 0 до 4194303 - двадцать два бита (см. &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Коды символов&lt;/a&gt; ). Коды с 0 по 127 являются</target>
        </trans-unit>
        <trans-unit id="2f2d8febd021625a726bddcf901f92bcf114c32e" translate="yes" xml:space="preserve">
          <source>Characters in this class count as part of words if &lt;code&gt;words-include-escapes&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;word-motion#Word-Motion&quot;&gt;Word Motion&lt;/a&gt;.</source>
          <target state="translated">Символы в этом классе считаются частью слов, если &lt;code&gt;words-include-escapes&lt;/code&gt; не &lt;code&gt;nil&lt;/code&gt; . Смотрите &lt;a href=&quot;word-motion#Word-Motion&quot;&gt;Word Motion&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a10df5b911a93e079b9555a76636c96ac49a9a5" translate="yes" xml:space="preserve">
          <source>Characters of Unicode General Category [Cf], such as U+200E &lt;small&gt;LEFT-TO-RIGHT MARK&lt;/small&gt;, but excluding characters that have graphic images, such as U+00AD &lt;small&gt;SOFT HYPHEN&lt;/small&gt;.</source>
          <target state="translated">Символы общей категории Unicode [Cf], такие как U + 200E &lt;small&gt;LEFT-TO-RIGHT MARK&lt;/small&gt; , за исключением символов с графическими изображениями, таких как U + 00AD &lt;small&gt;SOFT&lt;/small&gt; HYPHEN .</target>
        </trans-unit>
        <trans-unit id="d64597528b4665933dfaeebfdafad56f74f0e55b" translate="yes" xml:space="preserve">
          <source>Characters that have the property &lt;code&gt;inhibit-read-only&lt;/code&gt; can be edited even in read-only buffers. See &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;.</source>
          <target state="translated">Символы, которые имеют свойство &lt;code&gt;inhibit-read-only&lt;/code&gt; можно редактировать даже в буферах только для чтения. См. &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Буферы только для чтения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e63d767e9c8b2c1671e34752b2089312848063bf" translate="yes" xml:space="preserve">
          <source>Characters that separate symbols and words from each other. Typically, whitespace characters have no other syntactic significance, and multiple whitespace characters are syntactically equivalent to a single one. Space, tab, and formfeed are classified as whitespace in almost all major modes.</source>
          <target state="translated">Символы,которые отделяют символы и слова друг от друга.Обычно символы пробела не имеют другого синтаксического значения,а несколько символов пробела синтаксически эквивалентны одному.Пробел,табуляция и форма подачи классифицируются как пробельные символы почти во всех основных режимах.</target>
        </trans-unit>
        <trans-unit id="fa30e64c5637f1d5a32a9a352ecb5ba52a350acf" translate="yes" xml:space="preserve">
          <source>Characters that start an escape sequence, such as is used in string and character constants. The character &amp;lsquo;</source>
          <target state="translated">Символы, которые начинают escape-последовательность, например, используемую в строковых и символьных константах. Персонаж '</target>
        </trans-unit>
        <trans-unit id="c81c548b4c8ec05d54666a049f54eb670318ccea" translate="yes" xml:space="preserve">
          <source>Characters that start or end a special kind of comment. &lt;em&gt;Any&lt;/em&gt; generic comment delimiter matches &lt;em&gt;any&lt;/em&gt; generic comment delimiter, but they cannot match a comment starter or comment ender; generic comment delimiters can only match each other.</source>
          <target state="translated">Символы, которые начинают или заканчивают особый комментарий. &lt;em&gt;Любой&lt;/em&gt; универсальный разделитель комментариев соответствует &lt;em&gt;любому&lt;/em&gt; универсальному разделителю комментариев, но они не могут совпадать с начальным или конечным элементом комментария; общие разделители комментариев могут соответствовать только друг другу.</target>
        </trans-unit>
        <trans-unit id="ac7296c49b8b1a6c9dc8eb94911bbbba5328c176" translate="yes" xml:space="preserve">
          <source>Characters that start or end a string. This class differs from the string quote class in that &lt;em&gt;any&lt;/em&gt; generic string delimiter can match any other generic string delimiter; but they do not match ordinary string quote characters.</source>
          <target state="translated">Символы, которые начинают или заканчивают строку. Этот класс отличается от класса строковых кавычек тем, что &lt;em&gt;любой&lt;/em&gt; общий разделитель строк может соответствовать любому другому универсальному разделителю строк; но они не соответствуют обычным строковым кавычкам.</target>
        </trans-unit>
        <trans-unit id="878c9eb0cca3656e2070d507e9c66472d4b16d58" translate="yes" xml:space="preserve">
          <source>Characters used as punctuation in a human language, or used in a programming language to separate symbols from one another. Some programming language modes, such as Emacs Lisp mode, have no characters in this class since the few characters that are not symbol or word constituents all have other uses. Other programming language modes, such as C mode, use punctuation syntax for operators.</source>
          <target state="translated">Символы,используемые в качестве знаков препинания в человеческом языке или используемые в языке программирования для отделения символов друг от друга.Некоторые режимы языка программирования,такие как режим Emacs Lisp,не имеют символов в этом классе,так как несколько символов,которые не являются символами или словесными составляющими,имеют другое применение.Другие режимы языка программирования,такие как режим С,используют синтаксис пунктуации для операторов.</target>
        </trans-unit>
        <trans-unit id="06f7786b4e99ee5ceb3cb305cfc63a98ff812c14" translate="yes" xml:space="preserve">
          <source>Characters used for syntactic operators that are considered as part of an expression if they appear next to one. In Lisp modes, these characters include the apostrophe, &amp;lsquo;</source>
          <target state="translated">Символы, используемые для синтаксических операторов, которые считаются частью выражения, если они появляются рядом с ним. В режимах Lisp эти символы включают апостроф, '</target>
        </trans-unit>
        <trans-unit id="b0de87a3961de259dc33f8a42911d09393a940b8" translate="yes" xml:space="preserve">
          <source>Characters used in dissimilar pairs to surround sentences or expressions. Such a grouping is begun with an open parenthesis character and terminated with a close. Each open parenthesis character matches a particular close parenthesis character, and vice versa. Normally, Emacs indicates momentarily the matching open parenthesis when you insert a close parenthesis. See &lt;a href=&quot;blinking#Blinking&quot;&gt;Blinking&lt;/a&gt;.</source>
          <target state="translated">Символы, используемые в разных парах для окружения предложений или выражений. Такая группировка начинается с открывающей круглой скобки и заканчивается закрытием. Каждый символ открытой круглой скобки соответствует определенному символу закрывающей скобки, и наоборот. Обычно Emacs на мгновение указывает соответствующую открытую скобку, когда вы вставляете закрывающую скобку. См. &lt;a href=&quot;blinking#Blinking&quot;&gt;Мигание&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4150dd70fbcba800bf39a3d8687d1d7aeb5b8bb0" translate="yes" xml:space="preserve">
          <source>Characters used in various languages to delimit comments. Human text has no comment characters. In Lisp, the semicolon (&amp;lsquo;</source>
          <target state="translated">Символы, используемые на разных языках для обозначения комментариев. Текст без комментариев. В Лиспе точка с запятой ('</target>
        </trans-unit>
        <trans-unit id="48fc8012fa06ff8528f92e294cf2c321f8c94197" translate="yes" xml:space="preserve">
          <source>Characters used to delimit string constants. The same string quote character appears at the beginning and the end of a string. Such quoted strings do not nest.</source>
          <target state="translated">Символы,используемые для разделения строковых констант.В начале и в конце строки появляется один и тот же символ кавычки.Такие цитируемые строки не гнездятся.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
