<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="ded2b381f768b0426ee02fc11e7b1ea526d86382" translate="yes" xml:space="preserve">
          <source>M-p</source>
          <target state="translated">M-p</target>
        </trans-unit>
        <trans-unit id="0f8046567a7777233033e7c62fcbaaf077eb077a" translate="yes" xml:space="preserve">
          <source>M-r</source>
          <target state="translated">M-r</target>
        </trans-unit>
        <trans-unit id="0006025ee1ee308621c9836f080cfbad730b00dd" translate="yes" xml:space="preserve">
          <source>M-s</source>
          <target state="translated">M-s</target>
        </trans-unit>
        <trans-unit id="e2dbd97a24cfd42feafe4155928e5e36e05f30f3" translate="yes" xml:space="preserve">
          <source>M-v</source>
          <target state="translated">M-v</target>
        </trans-unit>
        <trans-unit id="5516e58102890d870825312fe7edb083af235de4" translate="yes" xml:space="preserve">
          <source>M-x</source>
          <target state="translated">M-x</target>
        </trans-unit>
        <trans-unit id="e96ee2840300f270b45095c2f0ec40521a00cde5" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;command&lt;/var&gt; Mx</target>
        </trans-unit>
        <trans-unit id="30b1c3d10bd4ea36dfe161af71f9b59cff94dfbf" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;RET</source>
          <target state="translated">Mx &lt;var&gt;command&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="c8f918be9ef0d86eff9e8b262b173a76afb5d823" translate="yes" xml:space="preserve">
          <source>M-x apropos RET x-pointer RET</source>
          <target state="translated">M-x apropos RET x pointer RET</target>
        </trans-unit>
        <trans-unit id="19d036c0bdece7df51bbb22b25a57a912bb781fc" translate="yes" xml:space="preserve">
          <source>M-x customize</source>
          <target state="translated">M-x настройка</target>
        </trans-unit>
        <trans-unit id="350cf2e68d92268174ae9d7178734cce54adaa8c" translate="yes" xml:space="preserve">
          <source>M-x describe-categories RET</source>
          <target state="translated">M-x описание-категории ТВЭ</target>
        </trans-unit>
        <trans-unit id="28a7266291890a298f219fa24bf612c876e68a3a" translate="yes" xml:space="preserve">
          <source>M-x dired-default-directory-on-left</source>
          <target state="translated">M-x директ-директ-ракт-ракт-ракт-ракт-ракт-ракт-ракт-ракт-ракт на-лево</target>
        </trans-unit>
        <trans-unit id="d0dbe2e240aeb6f1a78c981c88c230cc06b9fce7" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-defs</source>
          <target state="translated">M-x edebug-all-defs</target>
        </trans-unit>
        <trans-unit id="c71a2298fbf3e6b350d972a5f6758ef0c7f37945" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-forms</source>
          <target state="translated">M-x edebug-all-forms</target>
        </trans-unit>
        <trans-unit id="66031655733aef9ceba93288111a34d690630332" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-hide-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-Hide-instrumentation</target>
        </trans-unit>
        <trans-unit id="f849db42cc80a644b891cceb796496aea5a33446" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-show-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-шоу-инструментарий</target>
        </trans-unit>
        <trans-unit id="0e0239d280915da82047b3562e0edc1ef7e13f61" translate="yes" xml:space="preserve">
          <source>M-x edebug-eval-top-level-form</source>
          <target state="translated">M-x форма edebug-eval-top-уровня</target>
        </trans-unit>
        <trans-unit id="95fa4b4069fcd95b6d5ac0204ea4c9cff0ee6f75" translate="yes" xml:space="preserve">
          <source>M-x edit-tab-stops</source>
          <target state="translated">M-x остановки редактирования</target>
        </trans-unit>
        <trans-unit id="924625b2d7b939bdd69c369a8e0e7552d4621132" translate="yes" xml:space="preserve">
          <source>M-x list-colors-display</source>
          <target state="translated">M-x список-цвета-дисплей</target>
        </trans-unit>
        <trans-unit id="2d76ea9e63fcbb859b33f48edd7feb794a1730b1" translate="yes" xml:space="preserve">
          <source>M-x list-processes</source>
          <target state="translated">списковые процессы</target>
        </trans-unit>
        <trans-unit id="84edc9f7052f2c9a7f036d7890685dfe8db762ec" translate="yes" xml:space="preserve">
          <source>M-x load-library RET package-x RET</source>
          <target state="translated">M-x загрузка-библиотека RET упаковка-x RET</target>
        </trans-unit>
        <trans-unit id="b609619759aa9b92d26776cb6f14ab4bcfcc31de" translate="yes" xml:space="preserve">
          <source>M-x profiler-&amp;hellip;</source>
          <target state="translated">MX Profiler-&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0773bdccb110b28fb0a67898b66d8dd11444e9cc" translate="yes" xml:space="preserve">
          <source>M-x profiler-report</source>
          <target state="translated">M-x профилировщик-отчет</target>
        </trans-unit>
        <trans-unit id="4f21aa5941ccf75086060a4caa6ef135d1f402a8" translate="yes" xml:space="preserve">
          <source>M-x profiler-start</source>
          <target state="translated">M-x профилировочный старт</target>
        </trans-unit>
        <trans-unit id="7f9fd75200c3ba11f87c5df3770346f3beaa6c06" translate="yes" xml:space="preserve">
          <source>M-x profiler-stop</source>
          <target state="translated">M-x профилировочная остановка</target>
        </trans-unit>
        <trans-unit id="e1f1559513ee5a73bed6212288039c357856e5b7" translate="yes" xml:space="preserve">
          <source>M-x python-mode</source>
          <target state="translated">M-x питон-режим</target>
        </trans-unit>
        <trans-unit id="9a178593a35bbea7f02403c42d651edd7a1bdd3d" translate="yes" xml:space="preserve">
          <source>M-x re-builder</source>
          <target state="translated">M-x перестройщик</target>
        </trans-unit>
        <trans-unit id="02844767c038cdd2dda139c1d2eab250404388db" translate="yes" xml:space="preserve">
          <source>M-x report-emacs-bug</source>
          <target state="translated">M-x отчёт-эмакс-жучок</target>
        </trans-unit>
        <trans-unit id="4a8d44402484cf1af704bb5188c0b2f67fd9deae" translate="yes" xml:space="preserve">
          <source>M-x serial-term</source>
          <target state="translated">M-x серийный терминал</target>
        </trans-unit>
        <trans-unit id="d262f66141e61698a64505a1167b86f852cd6537" translate="yes" xml:space="preserve">
          <source>M-x set-visited-file-name</source>
          <target state="translated">M-x набор посещенных-имя файла</target>
        </trans-unit>
        <trans-unit id="ddd4cde942039a43aa69d7aaf7874a8689013014" translate="yes" xml:space="preserve">
          <source>M-x shell</source>
          <target state="translated">оболочка M-x</target>
        </trans-unit>
        <trans-unit id="aeb29959992cb9268370a1bd309d2ce9f465185c" translate="yes" xml:space="preserve">
          <source>M-x testcover-mark-all</source>
          <target state="translated">M-x тест-over-mark-all</target>
        </trans-unit>
        <trans-unit id="e8f70ba057d5e0dc5100fc76829c8002a8f06257" translate="yes" xml:space="preserve">
          <source>M-x testcover-next-mark</source>
          <target state="translated">M-x тест-оверка-некст-марка</target>
        </trans-unit>
        <trans-unit id="91f5f461f2c3a31e68b3789ab862a2b579739b85" translate="yes" xml:space="preserve">
          <source>M-x testcover-start RET&lt;var&gt;file&lt;/var&gt;RET</source>
          <target state="translated">Mx testcover-start &lt;var&gt;file&lt;/var&gt; RET RET</target>
        </trans-unit>
        <trans-unit id="0cb1249115b25aa2690a25b8910733c67b4a92a4" translate="yes" xml:space="preserve">
          <source>M-x untabify</source>
          <target state="translated">M-x унифицировать</target>
        </trans-unit>
        <trans-unit id="8938bda20b679e9984362cfe3b0025e2957609de" translate="yes" xml:space="preserve">
          <source>M-x update-directory-autoloads</source>
          <target state="translated">M-x обновление-директория-автозагрузки</target>
        </trans-unit>
        <trans-unit id="17a3a65ded9cf97168d2d48abac758964baf3233" translate="yes" xml:space="preserve">
          <source>M-x update-file-autoloads</source>
          <target state="translated">M-x файлы обновления-автозагрузки</target>
        </trans-unit>
        <trans-unit id="157b9065ca9092b93a2cd86b2065b6f97cb3c423" translate="yes" xml:space="preserve">
          <source>M-x widget-browse RET binary-tree-of-string RET</source>
          <target state="translated">M-x виджет-бросок RET с двоичным треугольным разрядом RET</target>
        </trans-unit>
        <trans-unit id="3aa424326e8c65a4310c522189aff3bdb49730f9" translate="yes" xml:space="preserve">
          <source>M-xelp-instrument-listRET nil RET</source>
          <target state="translated">M-xelp-instrument-listRET ноль RET</target>
        </trans-unit>
        <trans-unit id="d61a0439c16b301031a2c72fbbf40aec0781473a" translate="yes" xml:space="preserve">
          <source>M-xelp-results</source>
          <target state="translated">M-xelp-results</target>
        </trans-unit>
        <trans-unit id="4cb98f7867f1180986c1b84ef1785ff0b2c4dc15" translate="yes" xml:space="preserve">
          <source>M-xlist-buffers</source>
          <target state="translated">M-xlist-buffers</target>
        </trans-unit>
        <trans-unit id="05b684cd2cc4407a760fc4776a9afa8ac8eaddb7" translate="yes" xml:space="preserve">
          <source>M-xlist-tags</source>
          <target state="translated">M-xlist-tags</target>
        </trans-unit>
        <trans-unit id="7555a33395fef6db20d121fb58c3221aa124e48c" translate="yes" xml:space="preserve">
          <source>M-y</source>
          <target state="translated">M-y</target>
        </trans-unit>
        <trans-unit id="db42242da8c9daf4dc32a3e8f6a8c77ab461abee" translate="yes" xml:space="preserve">
          <source>MENU-BAR</source>
          <target state="translated">MENU-BAR</target>
        </trans-unit>
        <trans-unit id="40bb78ac4a8f75b73057a2a259dcfa335c88dad4" translate="yes" xml:space="preserve">
          <source>META</source>
          <target state="translated">META</target>
        </trans-unit>
        <trans-unit id="2d4aa5a5271bf55bf5139dda546f0f30ba06a6bd" translate="yes" xml:space="preserve">
          <source>MIME</source>
          <target state="translated">MIME</target>
        </trans-unit>
        <trans-unit id="240ac4da20e27f25d9defe42a63eca4461adbce9" translate="yes" xml:space="preserve">
          <source>MS-DOS and MS-Windows systems usually lack the standard Unix program &lt;code&gt;ls&lt;/code&gt;, so this function emulates the standard Unix program &lt;code&gt;ls&lt;/code&gt; with Lisp code.</source>
          <target state="translated">В системах MS-DOS и MS-Windows обычно отсутствует стандартная программа Unix &lt;code&gt;ls&lt;/code&gt; , поэтому эта функция имитирует стандартную программу Unix &lt;code&gt;ls&lt;/code&gt; с кодом Lisp.</target>
        </trans-unit>
        <trans-unit id="a6a56e5df064567806bfd2d02ec60d53d177da70" translate="yes" xml:space="preserve">
          <source>MS-DOS doesn&amp;rsquo;t support asynchronous subprocesses, so this option doesn&amp;rsquo;t work there.</source>
          <target state="translated">MS-DOS не поддерживает асинхронные подпроцессы, поэтому этот параметр там не работает.</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="0d2da2eb949e2df3a96a434a98613935cdfa18a4" translate="yes" xml:space="preserve">
          <source>Macro Type</source>
          <target state="translated">Макро-тип</target>
        </trans-unit>
        <trans-unit id="3764e4ae50932da915ec9a84fd2ba1b1c33188ce" translate="yes" xml:space="preserve">
          <source>Macro calls (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</source>
          <target state="translated">Макро-вызовы (см. &lt;a href=&quot;macros#Macros&quot;&gt;Макросы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="730c77b761075cf87c04f675fec25c96f12254c7" translate="yes" xml:space="preserve">
          <source>Macro expansion can have counterintuitive consequences. This section describes some important consequences that can lead to trouble, and rules to follow to avoid trouble.</source>
          <target state="translated">Макрорасширение может иметь интуитивно понятные последствия.В этом разделе описаны некоторые важные последствия,которые могут привести к неприятностям,и правила,которым необходимо следовать,чтобы избежать неприятностей.</target>
        </trans-unit>
        <trans-unit id="7c8148b5f3e72ae81e30a87c1414a699978cee33" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;1value&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</source>
          <target state="translated">Макрос: &lt;strong&gt;1 &lt;/strong&gt;&lt;em&gt;форма значения&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f625904d011437c920c24217d1112932e75fdede" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</source>
          <target state="translated">Макрос: &lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f63e91ed8761158e2824094f3c035978e33f0b75" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;add-function&lt;/strong&gt;&lt;em&gt;where place function &amp;amp;optional props&lt;/em&gt;</source>
          <target state="translated">Макрос: &lt;strong&gt;добавление функции, в &lt;/strong&gt;&lt;em&gt;которой размещаются функции и дополнительные реквизиты&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5429d225c6285d485886a63d9a654b44fd9af85a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defgeneric&lt;/strong&gt;&lt;em&gt;name arguments [documentation] [options-and-methods&amp;hellip;] &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;cl-defgeneric&lt;/strong&gt;&lt;em&gt;name arguments [documentation] [options-and-methods&amp;hellip;] &amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba5cedae4a4b306427387f90edd4dbd185e02578" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defmethod&lt;/strong&gt;&lt;em&gt;name [qualifier] arguments [&amp;amp;context (expr spec)&amp;hellip;] &amp;amp;rest [docstring] body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;cl-defmethod&lt;/strong&gt;&lt;em&gt;name [qualifier] arguments [&amp;amp;context (expr spec)&amp;hellip;] &amp;amp;rest [docstring] body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ff2b909c891d19da7650f8ccd70d4ff20d5f0ef" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-after-change-calls&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;combine-after-change-calls&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ee51599c974e6734d6444e666498d94c6309037" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-change-calls&lt;/strong&gt;&lt;em&gt;beg end body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;combine-change-calls&lt;/strong&gt;&lt;em&gt;beg end body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3aee740831df3fe36c5e3627bd95688debd9b10c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;condition-case-unless-debug&lt;/strong&gt;&lt;em&gt;var protected-form handlers&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;condition-case-unless-debug&lt;/strong&gt;&lt;em&gt;var protected-form handlers&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be46ac442c6b283fe5303544430db1733ede80cf" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare-function&lt;/strong&gt;&lt;em&gt;function file &amp;amp;optional arglist fileonly&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;declare-function&lt;/strong&gt;&lt;em&gt;function file &amp;amp;optional arglist fileonly&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5106ba44b52792efba46fd9abcd6f50d2a690" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare&lt;/strong&gt;&lt;em&gt;specs&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;declare&lt;/strong&gt;&lt;em&gt;specs&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aad917e7e24305c69cc7b616287145940c7bc611" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;def-edebug-spec&lt;/strong&gt;&lt;em&gt;macro specification&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;def-edebug-spec&lt;/strong&gt;&lt;em&gt;macro specification&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8850ae7654fdd0f9e7e3643b836d299119c8eb3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defcustom&lt;/strong&gt;&lt;em&gt;option standard doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;defcustom&lt;/strong&gt;&lt;em&gt;option standard doc [keyword value]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5434cd21483dbb5ef69be871541753221bd178a5" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defface&lt;/strong&gt;&lt;em&gt;face spec doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;defface&lt;/strong&gt;&lt;em&gt;face spec doc [keyword value]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14c7fabc7b52a8375cc5c9e142c3ac122d2ea4bc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defgroup&lt;/strong&gt;&lt;em&gt;group members doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;defgroup&lt;/strong&gt;&lt;em&gt;group members doc [keyword value]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28b55593ba483070425de7736987bf774bd2c491" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defimage&lt;/strong&gt;&lt;em&gt;symbol specs &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;defimage&lt;/strong&gt;&lt;em&gt;symbol specs &amp;amp;optional doc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fea6bef8b59da7c79bbd75395190d7484736ecf9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-advice&lt;/strong&gt;&lt;em&gt;symbol (where lambda-list &amp;amp;optional name depth) &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-advice&lt;/strong&gt;&lt;em&gt;symbol (where lambda-list &amp;amp;optional name depth) &amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70852342716d3e0bca8b4f3d79c1ec5991f6b9cc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-alternatives&lt;/strong&gt;&lt;em&gt;command &amp;amp;rest customizations&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-alternatives&lt;/strong&gt;&lt;em&gt;command &amp;amp;rest customizations&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af424b3d2ee378903109c9532c12c3d915726f60" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-derived-mode&lt;/strong&gt;&lt;em&gt;variant parent name docstring keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-derived-mode&lt;/strong&gt;&lt;em&gt;variant parent name docstring keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d039443b2fcf2ccb94276b2881ba59ab7c4bef6e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-generic-mode&lt;/strong&gt;&lt;em&gt;mode comment-list keyword-list font-lock-list auto-mode-list function-list &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-generic-mode&lt;/strong&gt;&lt;em&gt;mode comment-list keyword-list font-lock-list auto-mode-list function-list &amp;amp;optional docstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3be7a42eb17b3b478f941dfaad3f2a091b3d9de0" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-globalized-minor-mode&lt;/strong&gt;&lt;em&gt;global-mode mode turn-on keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-globalized-minor-mode&lt;/strong&gt;&lt;em&gt;global-mode mode turn-on keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3698aa5f5a4cf22d04e63dba4fd63eeab2b198c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-inline&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-inline&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1872fe945d43990f77596fefa545da1cad14ecf2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-minor-mode&lt;/strong&gt;&lt;em&gt;mode doc [init-value [lighter [keymap]]] keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-minor-mode&lt;/strong&gt;&lt;em&gt;mode doc [init-value [lighter [keymap]]] keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e428f2f8e85f45dc22b5c0ef48e7d972c7378dba" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-face-alias&lt;/strong&gt;&lt;em&gt;obsolete-face current-face when&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-obsolete-face-alias&lt;/strong&gt;&lt;em&gt;obsolete-face current-face when&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="803af6ea30a01f534dc197a816a8b6feeabe7985" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-function-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name when &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-obsolete-function-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name when &amp;amp;optional doc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c5b6a54e8e1d18babd8fbf3277042db07db8a8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-variable-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name &amp;amp;optional when docstring&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;define-obsolete-variable-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name &amp;amp;optional when docstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10f5376be352b9daee65a34b48f0eb2a91bc607c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78c0fc24e6b16b98abe1b0908482cec19956ca6f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defsubst&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;defsubst&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1683d10fb7854b9d19dee990d4fa2a5c7aa5855c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;deftheme&lt;/strong&gt;&lt;em&gt;theme &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;deftheme&lt;/strong&gt;&lt;em&gt;theme &amp;amp;optional doc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f549c138328cc6f82aa82edd990d79c318eb798" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10c945e44b82a451a5291eaa330f70caa9d10af2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defvar-local&lt;/strong&gt;&lt;em&gt;variable value &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;defvar-local&lt;/strong&gt;&lt;em&gt;variable value &amp;amp;optional docstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc1f8d335ca6f3d1108310f49f1d7c79312c2310" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;delay-mode-hooks&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;delay-mode-hooks&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="236c5615e3d9ad7c6a4ecbd45a98af3f3547666f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;dolist-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af38a7273fecb69f9c319a26123467a4b36e125d" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist&lt;/strong&gt;&lt;em&gt;(var list [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;dolist&lt;/strong&gt;&lt;em&gt;(var list [result]) body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f09315db5afa839072a62fbc1535685142261f35" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;dotimes-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f92ffa9680e321f5b7958eb9df3da33cc00a96e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes&lt;/strong&gt;&lt;em&gt;(var count [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;dotimes&lt;/strong&gt;&lt;em&gt;(var count [result]) body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27132dd2125d6a24d297f0e928ce24fd5c66c2a4" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;easy-menu-define&lt;/strong&gt;&lt;em&gt;symbol maps doc menu&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;easy-menu-define&lt;/strong&gt;&lt;em&gt;symbol maps doc menu&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4202975359e6a5a35e94aebc824c1980bfa133ab" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;edebug-tracing&lt;/strong&gt;&lt;em&gt;string body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;edebug-tracing&lt;/strong&gt;&lt;em&gt;string body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97209372ca87135e65cd9c81713566e0e5ffbbed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-quote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;file-name-quote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d492c007d3e41ed8529a79c7de06f64a383b0bb4" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-quoted-p&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;file-name-quoted-p&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84eef64536eebdfb99700969216aebc1568b1a93" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-unquote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;file-name-unquote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="726f23b904d3162d0b6b2ce258aedc6f34085b01" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-expander&lt;/strong&gt;&lt;em&gt;name handler&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;gv-define-expander&lt;/strong&gt;&lt;em&gt;name handler&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e8e8e6f9fb8ae64c4b81b0efb77b3aec46b1848" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-setter&lt;/strong&gt;&lt;em&gt;name arglist &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;gv-define-setter&lt;/strong&gt;&lt;em&gt;name arglist &amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ba4267fb86a2133c14e3991e850bf82e933e6cf" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-simple-setter&lt;/strong&gt;&lt;em&gt;name setter &amp;amp;optional fix-return&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;gv-define-simple-setter&lt;/strong&gt;&lt;em&gt;name setter &amp;amp;optional fix-return&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe36114bc819fefed7ef2aa455dfe1201e1f3794" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-letplace&lt;/strong&gt;&lt;em&gt;(getter setter) place &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;gv-letplace&lt;/strong&gt;&lt;em&gt;(getter setter) place &amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d988bb7298849df77bbbf913cc1608cf1c65a48" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;ignore-error&lt;/strong&gt;&lt;em&gt;condition body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;ignore-error&lt;/strong&gt;&lt;em&gt;condition body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0a70bba890a42f68ebbfdbefb8d53b65ab046ba" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;ignore-errors&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;ignore-errors&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d8cf7a6718df181f54afa400b67ca2ca8fa1da3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-const-p&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;inline-const-p&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2f83ce40aaee4b4c13e471e1088895be676b70e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-const-val&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;inline-const-val&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53a8c04b7bc095c6f92dc2e1ef62aceb2230f983" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-error&lt;/strong&gt;&lt;em&gt;format &amp;amp;rest args&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;inline-error&lt;/strong&gt;&lt;em&gt;format &amp;amp;rest args&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18c258c00d0a0eefa18864e32e22a05027f102ed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-letevals&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;inline-letevals&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ea22905659127e33e1bae1fa9ee88c436a06ea8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-quote&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;inline-quote&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="591cc65dde8d823c972143bbff5028af79cbb9db" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;iter-defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dec5c51dc2ec952f84f4bbfed169751066042a1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-do&lt;/strong&gt;&lt;em&gt;(var iterator) body &amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;iter-do&lt;/strong&gt;&lt;em&gt;(var iterator) body &amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6af415e6cbf9f96bba0dce565e09bab755f1b4a1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;iter-lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d034239c1317860ddb076eb18efff19e3bf9b86f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-yield-from&lt;/strong&gt;&lt;em&gt;iterator&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;iter-yield-from&lt;/strong&gt;&lt;em&gt;iterator&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8295211938d4a3f738add01d06599196ba528680" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-yield&lt;/strong&gt;&lt;em&gt;value&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;iter-yield&lt;/strong&gt;&lt;em&gt;value&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb4abdbc2718878523fc62e401ee9bbb454e720e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97e12fdbcb9c7d29cfa4fb4a4d5bebd3b572b4be" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;lazy-completion-table&lt;/strong&gt;&lt;em&gt;var fun&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;lazy-completion-table&lt;/strong&gt;&lt;em&gt;var fun&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a13b390be25a1fbc366c265b47e90db671786c62" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;let-alist&lt;/strong&gt;&lt;em&gt;alist body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;let-alist&lt;/strong&gt;&lt;em&gt;alist body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ff539998c76c30f04c81c659cfe2406d40230c9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;make-help-screen&lt;/strong&gt;&lt;em&gt;fname help-line help-text help-map&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;make-help-screen&lt;/strong&gt;&lt;em&gt;fname help-line help-text help-map&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcb098a03ed9e790b3a8274d37d20c47f9829b78" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;minibuffer-with-setup-hook&lt;/strong&gt;&lt;em&gt;function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;minibuffer-with-setup-hook&lt;/strong&gt;&lt;em&gt;function &amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8438b00f04bfd18b4b0ae35e53a7cc991b2b59c9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;noreturn&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;noreturn&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cec782422ca74e562fbd1f338919db0b374e18fc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;pcase-defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] &amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cbac1c3a887c3fb24e6cc7cf54c7c2199087fe99" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-dolist&lt;/strong&gt;&lt;em&gt;(pattern list) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;pcase-dolist&lt;/strong&gt;&lt;em&gt;(pattern list) body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c05dbc3c6db6b261f36f043c6e80c8f33eda5de" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-let*&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;pcase-let*&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb51fe5b0cf3705a47723c876b1e4bcd04dc577a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-let&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;pcase-let&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca87b97e541c841df38930296559cb00658e2768" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase&lt;/strong&gt;&lt;em&gt;expression &amp;amp;rest clauses&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;pcase&lt;/strong&gt;&lt;em&gt;expression &amp;amp;rest clauses&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983e88ae1faa1be0650589312d5418fdde60f1bc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pop&lt;/strong&gt;&lt;em&gt;listname&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;pop&lt;/strong&gt;&lt;em&gt;listname&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e0e2b6a982aeda0e4decaf96d35ea59a59bd598" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;provide-theme&lt;/strong&gt;&lt;em&gt;theme&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;provide-theme&lt;/strong&gt;&lt;em&gt;theme&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1dc602f484a77596e515278730a111ba18108235" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;push&lt;/strong&gt;&lt;em&gt;element listname&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;push&lt;/strong&gt;&lt;em&gt;element listname&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f156a8123bbcf74aa52f2b693a342c402f146879" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;remove-function&lt;/strong&gt;&lt;em&gt;place function&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;remove-function&lt;/strong&gt;&lt;em&gt;place function&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dade05721b4bb5b2388ba9e36428808b0bd35b85" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-define&lt;/strong&gt;&lt;em&gt;name [arglist] rx-form&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;rx-define&lt;/strong&gt;&lt;em&gt;name [arglist] rx-form&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96bddb173e4fc87b0212f01a02bc2ff46662fd79" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-let-eval&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;rx-let-eval&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f690b0183cee377b178ae7b310b55bed43dc046" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;rx-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6b7d03766c09f7e22083ae5f1e5632dbe96a4075" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx&lt;/strong&gt;&lt;em&gt;rx-expr&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;rx&lt;/strong&gt;&lt;em&gt;rx-expr&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e38445717db19d10c7b2ff0da1e3c8e5606a741" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-mark-and-excursion&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;save-mark-and-excursion&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9f08975e9fff445dfb403167bb2325ccb174e76" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-match-data&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;save-match-data&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92793bf9d32a9540658805cb43a3ae0efa7f3128" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-selected-window&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;save-selected-window&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e56a36e57644762b26c7a8043ad96444679ee21f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-window-excursion&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;save-window-excursion&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12a277b9203d5ab428dff62199f053203e4f9360" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;seq-doseq&lt;/strong&gt;&lt;em&gt;(var sequence) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;seq-doseq&lt;/strong&gt;&lt;em&gt;(var sequence) body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b835674eb567909d999b1d3adb5b36f56b21eb76" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;seq-let&lt;/strong&gt;&lt;em&gt;var-sequence val-sequence body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;seq-let&lt;/strong&gt;&lt;em&gt;var-sequence val-sequence body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e1c8aece33f7cb04f9bb4e8e78e941ba25f10c8a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;setf&lt;/strong&gt;&lt;em&gt;[place form]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;setf&lt;/strong&gt;&lt;em&gt;[place form]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ae20fe71c0e147bb6bc4871d96f5e92f5c5660a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;setq-local&lt;/strong&gt;&lt;em&gt;&amp;amp;rest pairs&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;setq-local&lt;/strong&gt;&lt;em&gt;&amp;amp;rest pairs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7fc00650723cfa16788a6eb8c490f8e2cbe554c7" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-delay&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;thunk-delay&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f74169099eddfe8865dcdf5990bc129a1fdc6673" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-let*&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;thunk-let*&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a1e217877c5526cceda285dd42d4924b08e82f6" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;thunk-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="766201ee854ac160680cf24ccec173e582e1a7ed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;track-mouse&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;track-mouse&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb84a0ba8e8559be9ca8af3789ff323f8333f22" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;unless&lt;/strong&gt;&lt;em&gt;condition forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;unless&lt;/strong&gt;&lt;em&gt;condition forms&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5aff66224e617a69f0607a954cf4ce95d91c0fc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;when&lt;/strong&gt;&lt;em&gt;condition then-forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;when&lt;/strong&gt;&lt;em&gt;condition then-forms&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f205733ce1922f5715da64c2f9555232afd3f01c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;while-no-input&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;while-no-input&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f712914bd7ea1c83173b9e57d39ac648cc864f03" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-case-table&lt;/strong&gt;&lt;em&gt;table body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-case-table&lt;/strong&gt;&lt;em&gt;table body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="756ee1443c1beb536eabc9fa307af9516c8aef78" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-coding-priority&lt;/strong&gt;&lt;em&gt;coding-systems &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-coding-priority&lt;/strong&gt;&lt;em&gt;coding-systems &amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0626d3bcff6d0f9b11bce251e24405f3aef3212" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-connection-local-variables&lt;/strong&gt;&lt;em&gt;&amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-connection-local-variables&lt;/strong&gt;&lt;em&gt;&amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e90a90d3854565590ceddc4b00fa70821a122a93" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-current-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-current-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e67efe0226ce402a3b6577c2572b74269dde5f8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-current-buffer&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-current-buffer&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a213d0fd2a350c51fd6e821ffbef2c3c4e957b3f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-demoted-errors&lt;/strong&gt;&lt;em&gt;format body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-demoted-errors&lt;/strong&gt;&lt;em&gt;format body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92216dc544bae7ab562994e1580bab8f27e5c500" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-displayed-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-displayed-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="02e7d013fbb53c92f365f47d71935d53a79d3a44" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-eval-after-load&lt;/strong&gt;&lt;em&gt;library body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-eval-after-load&lt;/strong&gt;&lt;em&gt;library body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3ef9c7bbb2f8fd032cb894c0974bac62ca556b08" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-file-modes&lt;/strong&gt;&lt;em&gt;mode body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-file-modes&lt;/strong&gt;&lt;em&gt;mode body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e1ad0b0fa15e75e81fefccc043649d47a0ec7e8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-help-window&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-help-window&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe85851374c7d77e353d19f39d6c72494baf5727" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-local-quit&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-local-quit&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf3fce278bf45ed1fb14e057cc0160271c67cbe1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-mutex&lt;/strong&gt;&lt;em&gt;mutex body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-mutex&lt;/strong&gt;&lt;em&gt;mutex body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5ce9ef0c5615794d7bdaada637134dc5ef72f95" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-output-to-string&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro: &lt;strong&gt;with-output-to-string&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="145e9acb2514daffd471084b4b74175db21ac6c3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-output-to-temp-buffer&lt;/strong&gt;&lt;em&gt;buffer-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Макрос: &lt;strong&gt;with-output-to-temp-buffer &lt;/strong&gt;&lt;em&gt;имя &lt;/em&gt;&lt;strong&gt;- &lt;/strong&gt;&lt;em&gt;буфера тело&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="014aa5fdf2960526d77b8827eae2e874906c5c72" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-selected-window&lt;/strong&gt;&lt;em&gt;window forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Макрос: &lt;em&gt;формы окна &lt;/em&gt;&lt;strong&gt;с выбранным &lt;/strong&gt;&lt;em&gt;окном&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a68f1966ed297f73ea9922e372523354a6209aeb" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-silent-modifications&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Макро: &lt;strong&gt;с-сайлент-доработками &lt;/strong&gt;&lt;em&gt;кузов&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b76c740d791472ee05bb84bd685f4830fbd0565" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-syntax-table&lt;/strong&gt;&lt;em&gt;table body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Макрос: &lt;em&gt;тело таблицы &lt;/em&gt;&lt;strong&gt;with-syntax-table &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7179c68d1d61234db5bb28f842f04ab503193f52" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Макрос: &lt;strong&gt;with-temp-buffer-window имя- &lt;/strong&gt;&lt;em&gt;буфера или действие quit-function body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb335e848f2b8117c60546cedb994f0aab8f2d72" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-buffer&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Макрос: &lt;em&gt;тело &lt;/em&gt;&lt;strong&gt;with-temp-buffer &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="68e9e5f62833f7dad75fa42c04a754f63c197fe2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-file&lt;/strong&gt;&lt;em&gt;file body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Макрос: &lt;em&gt;тело файла &lt;/em&gt;&lt;strong&gt;с временным &lt;/strong&gt;&lt;em&gt;файлом&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e02315ac7e8b3f0ae1f5ca75a9f6f493bcaeceb" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-message&lt;/strong&gt;&lt;em&gt;message &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">Макрос: сообщение &lt;strong&gt;with-temp- &lt;/strong&gt;&lt;em&gt;message и тело отдыха&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87f26c950e83c00d565896bc264176d651cbc638" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-timeout&lt;/strong&gt;&lt;em&gt;(seconds timeout-forms&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Макрос: &lt;strong&gt;with-timeout &lt;/strong&gt;&lt;em&gt;(секунды timeout -forms&amp;hellip;) body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="b7ffee61760e61c23c93306e84f4ed865540a241" translate="yes" xml:space="preserve">
          <source>Macros and Byte Compilation</source>
          <target state="translated">Компиляция макросов и байтов</target>
        </trans-unit>
        <trans-unit id="e9174412561f9b06e7358a460619f423a936460d" translate="yes" xml:space="preserve">
          <source>Macros are a way to extend the Lisp language.</source>
          <target state="translated">Макросы-это способ расширить язык Лисп.</target>
        </trans-unit>
        <trans-unit id="df1edfc722b17bf0432a6a39f4d123de99bb02e1" translate="yes" xml:space="preserve">
          <source>Macros can do this because they operate on the unevaluated expressions for the arguments, not on the argument values as functions do. They can therefore construct an expansion containing these argument expressions or parts of them.</source>
          <target state="translated">Макросы могут делать это,потому что они работают с неоцененными выражениями для аргументов,а не со значениями аргументов,как это делают функции.Поэтому они могут построить расширение,содержащее эти выражения аргументов или их части.</target>
        </trans-unit>
        <trans-unit id="86ad4286948aac2e22fb320469457597f40e25e9" translate="yes" xml:space="preserve">
          <source>Macros like &lt;code&gt;save-window-excursion&lt;/code&gt;, &lt;code&gt;with-selected-window&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt; can be used when running window change functions.</source>
          <target state="translated">Такие макросы, как &lt;code&gt;save-window-excursion&lt;/code&gt; , &lt;code&gt;with-selected-window&lt;/code&gt; или &lt;code&gt;with-current-buffer&lt;/code&gt; , могут использоваться при запуске функций изменения окна.</target>
        </trans-unit>
        <trans-unit id="8609149c2452193a39482806645c173c455fdb7e" translate="yes" xml:space="preserve">
          <source>Macros often need to construct large list structures from a mixture of constants and nonconstant parts. To make this easier, use the &amp;lsquo;</source>
          <target state="translated">Макросы часто нуждаются в создании больших структур списков из смеси констант и непостоянных частей. Чтобы упростить это, используйте '</target>
        </trans-unit>
        <trans-unit id="e02a2089bfc650b4d78c5778356a47b4f6c929d4" translate="yes" xml:space="preserve">
          <source>Maintaining Undo Lists</source>
          <target state="translated">Ведение списков аннулирования</target>
        </trans-unit>
        <trans-unit id="b4800c1dbe2e7fe97716c9f437b2d989b0114297" translate="yes" xml:space="preserve">
          <source>Maintaining a public package archive entails a degree of responsibility. When Emacs users install packages from your archive, those packages can cause Emacs to run arbitrary code with the permissions of the installing user. (This is true for Emacs code in general, not just for packages.) So you should ensure that your archive is well-maintained and keep the hosting system secure.</source>
          <target state="translated">Ведение архива общественного пакета влечет за собой определенную степень ответственности.Когда пользователи Emacs устанавливают пакеты из вашего архива,эти пакеты могут привести к тому,что Emacs будет выполнять произвольный код с разрешения пользователя,выполняющего установку.(Это справедливо для кода Emacs в целом,а не только для пакетов.)Поэтому вы должны убедиться,что ваш архив хорошо поддерживается и обеспечивает безопасность хостинговой системы.</target>
        </trans-unit>
        <trans-unit id="c19746ba61877a021e38d926e000d62be983a896" translate="yes" xml:space="preserve">
          <source>Maintaining package archives.</source>
          <target state="translated">Ведение архивов пакетов.</target>
        </trans-unit>
        <trans-unit id="606cf8196868e5f549fd1168472b48701f267c5f" translate="yes" xml:space="preserve">
          <source>Major Mode Conventions</source>
          <target state="translated">Основные конвенции о режимах</target>
        </trans-unit>
        <trans-unit id="bb282fd14bccfc29a60ab093b4041c44964f43f9" translate="yes" xml:space="preserve">
          <source>Major Mode Examples</source>
          <target state="translated">Примеры основных режимов</target>
        </trans-unit>
        <trans-unit id="a8b5ad1cdceba549e2a4b89898c34005d52785df" translate="yes" xml:space="preserve">
          <source>Major Modes</source>
          <target state="translated">Основные режимы</target>
        </trans-unit>
        <trans-unit id="cd5fed78b53dc008bcaa949f077e4002fa314735" translate="yes" xml:space="preserve">
          <source>Major and Minor Modes</source>
          <target state="translated">Мажорная и малая режимы</target>
        </trans-unit>
        <trans-unit id="e37f2a35397994a75b440b8e162b38fe39bb718b" translate="yes" xml:space="preserve">
          <source>Major modes for editing text should not define</source>
          <target state="translated">Основные режимы редактирования текста не должны определять</target>
        </trans-unit>
        <trans-unit id="4fa4f3d22c7a7ae10c0e45ce33e8b5151b9a09b1" translate="yes" xml:space="preserve">
          <source>Major modes should not alter options that are primarily a matter of user preference, such as whether Auto-Fill mode is enabled. Leave this to each user to decide. However, a major mode should customize other variables so that Auto-Fill mode will work usefully &lt;em&gt;if&lt;/em&gt; the user decides to use it.</source>
          <target state="translated">Основные режимы не должны изменять параметры, которые в первую очередь зависят от предпочтений пользователя, например, включен ли режим автозаполнения. Оставьте это на усмотрение каждого пользователя. Однако основной режим должен настраивать другие переменные, чтобы режим автозаполнения работал с пользой, &lt;em&gt;если&lt;/em&gt; пользователь решит его использовать.</target>
        </trans-unit>
        <trans-unit id="d5246cd7371de3f7eda0f9bf9b7e1bf7a313c280" translate="yes" xml:space="preserve">
          <source>Major modes should run their mode hook using this function. It is similar to &lt;code&gt;run-hooks&lt;/code&gt; (see &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;), but it also runs &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt;, &lt;code&gt;hack-local-variables&lt;/code&gt; (when the buffer is visiting a file) (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;), and &lt;code&gt;after-change-major-mode-hook&lt;/code&gt;. The last thing it does is to evaluate any &lt;code&gt;:after-hook&lt;/code&gt; forms declared by parent modes (see &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;).</source>
          <target state="translated">Основные режимы должны запускать свой обработчик режима, используя эту функцию. Он похож на &lt;code&gt;run-hooks&lt;/code&gt; (см. &lt;a href=&quot;hooks#Hooks&quot;&gt;Хуки&lt;/a&gt; ), но также запускает &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt; , &lt;code&gt;hack-local-variables&lt;/code&gt; (когда буфер обращается к файлу) (см. &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;Локальные переменные файла&lt;/a&gt; ) и &lt;code&gt;after-change-major-mode-hook&lt;/code&gt; . Последнее, что он делает, это оценивает любые формы &lt;code&gt;:after-hook&lt;/code&gt; , объявленные родительскими режимами (см. &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Производные режимы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2923364acdd14ce08c91c050cf84d8d42591bb6e" translate="yes" xml:space="preserve">
          <source>Major modes specialize Emacs for editing or interacting with particular kinds of text. Each buffer has exactly one major mode at a time. Every major mode is associated with a &lt;em&gt;major mode command&lt;/em&gt;, whose name should end in &amp;lsquo;</source>
          <target state="translated">Основные режимы специализируются на Emacs для редактирования или взаимодействия с определенными типами текста. У каждого буфера одновременно есть ровно один основной режим. Каждый основной режим связан с &lt;em&gt;командой основного режима&lt;/em&gt; , имя которой должно заканчиваться на '</target>
        </trans-unit>
        <trans-unit id="38d00cb263c96ca2a52e27564fd94babb43bab35" translate="yes" xml:space="preserve">
          <source>Make a finalizer that will run &lt;var&gt;function&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; will be called after garbage collection when the returned finalizer object becomes unreachable. If the finalizer object is reachable only through references from finalizer objects, it does not count as reachable for the purpose of deciding whether to run &lt;var&gt;function&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; will be run once per finalizer object.</source>
          <target state="translated">Сделайте финализатор, который будет запускать &lt;var&gt;function&lt;/var&gt; . &lt;var&gt;function&lt;/var&gt; будет вызываться после сборки мусора, когда возвращенный объект финализатора станет недоступным. Если объект финализатора доступен только через ссылки из объектов финализатора, он не считается достижимым с целью принятия решения о запуске &lt;var&gt;function&lt;/var&gt; . &lt;var&gt;function&lt;/var&gt; будет запускаться один раз для каждого объекта финализатора.</target>
        </trans-unit>
        <trans-unit id="7d05b1ed3c0802c954e67c3ed43ecc3f76f2dcb8" translate="yes" xml:space="preserve">
          <source>Make a new condition variable associated with &lt;var&gt;mutex&lt;/var&gt;. If &lt;var&gt;name&lt;/var&gt; is specified, it is a name given to the condition variable. It must be a string. The name is for debugging purposes only; it has no meaning to Emacs.</source>
          <target state="translated">Создайте новую переменную условия, связанную с &lt;var&gt;mutex&lt;/var&gt; . Если указано &lt;var&gt;name&lt;/var&gt; , это имя, присвоенное переменной условия. Это должна быть строка. Имя предназначено только для целей отладки; для Emacs это не имеет значения.</target>
        </trans-unit>
        <trans-unit id="1c29998a0cfecf6c2e9ce2a81215d8045a8a6c92" translate="yes" xml:space="preserve">
          <source>Make numbered backups if the visited file already has numbered backups; otherwise, do not. This is the default.</source>
          <target state="translated">Делайте пронумерованные резервные копии,если в посещенном файле уже есть пронумерованные резервные копии;в противном случае не делайте этого.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="2da90c1787d3c7d351f1c46baa7a638097f08e65" translate="yes" xml:space="preserve">
          <source>Make numbered backups.</source>
          <target state="translated">Сделайте пронумерованные резервные копии.</target>
        </trans-unit>
        <trans-unit id="711b2ff4a299052a936b40c6f84cbfef1eba50db" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;jit-lock-contextually&lt;/code&gt; is set and rely on it doing its job. This will only rehighlight the part of the construct that follows the actual change, and will do it after a short delay. This only works if the highlighting of the various parts of your multiline construct never depends on text in subsequent lines. Since &lt;code&gt;jit-lock-contextually&lt;/code&gt; is activated by default, this can be an attractive solution.</source>
          <target state="translated">Убедитесь, что &lt;code&gt;jit-lock-contextually&lt;/code&gt; установлен, и полагайтесь на его работу. Это приведет к повторному выделению только той части конструкции, которая следует за фактическим изменением, и сделает это с небольшой задержкой. Это работает только в том случае, если выделение различных частей многострочной конструкции никогда не зависит от текста в последующих строках. Поскольку &lt;code&gt;jit-lock-contextually&lt;/code&gt; активирован по умолчанию, это может быть привлекательным решением.</target>
        </trans-unit>
        <trans-unit id="b6a7dff46b149b27821f54fd9ae7b59aa7b81e46" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;rx&lt;/code&gt; definitions in &lt;var&gt;bindings&lt;/var&gt; available locally for &lt;code&gt;rx&lt;/code&gt; macro invocations in &lt;var&gt;body&lt;/var&gt;, which is then evaluated.</source>
          <target state="translated">Сделайте определения &lt;code&gt;rx&lt;/code&gt; в &lt;var&gt;bindings&lt;/var&gt; доступными локально для вызовов макросов &lt;code&gt;rx&lt;/code&gt; в &lt;var&gt;body&lt;/var&gt; , которое затем оценивается.</target>
        </trans-unit>
        <trans-unit id="7cbe1d5e07a300b4e199aa52e31ab4c25575ef27" translate="yes" xml:space="preserve">
          <source>Making Backup Files</source>
          <target state="translated">Создание резервных копий файлов</target>
        </trans-unit>
        <trans-unit id="d519807d2832f393ececd53cc3b5b0781e852aed" translate="yes" xml:space="preserve">
          <source>Making Buttons</source>
          <target state="translated">Кнопки приготовления</target>
        </trans-unit>
        <trans-unit id="6bc49c91daf67a006b0afd80b17ad707dc94b52d" translate="yes" xml:space="preserve">
          <source>Making Certain File Names &amp;ldquo;Magic&amp;rdquo;</source>
          <target state="translated">Превращение определенных имен файлов в &amp;laquo;волшебные&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="c34b468d532d0ce0f0dafb7d482d36723b3412cd" translate="yes" xml:space="preserve">
          <source>Making Certain File Names “Magic”</source>
          <target state="translated">Сделать некоторые имена файлов &quot;Волшебство&quot;.</target>
        </trans-unit>
        <trans-unit id="c51c6eff7a755274f117eedefbb312175db7a807" translate="yes" xml:space="preserve">
          <source>Making a command distinguish interactive calls.</source>
          <target state="translated">Заставить команду различать интерактивные вызовы.</target>
        </trans-unit>
        <trans-unit id="7318dd947ef8c106ed8ecd66b4999fa87252517d" translate="yes" xml:space="preserve">
          <source>Making a frame the child of another.</source>
          <target state="translated">Сделать подставкой чужого ребенка.</target>
        </trans-unit>
        <trans-unit id="a4f8e97640cd04a362c1fe6f0e955802fe3826fe" translate="yes" xml:space="preserve">
          <source>Making a frame visible usually makes all its child frames (and their descendants) visible as well (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;).</source>
          <target state="translated">Когда фрейм становится видимым, обычно становятся видимыми все его дочерние фреймы (и их потомки) (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="681222f25961ab30aded517088045711c219585c" translate="yes" xml:space="preserve">
          <source>Making a function inline often makes its function calls run faster. But it also has disadvantages. For one thing, it reduces flexibility; if you change the definition of the function, calls already inlined still use the old definition until you recompile them.</source>
          <target state="translated">Сделав функцию встроенной,вызовы функций часто ускоряются.Но у нее есть и недостатки.Во-первых,это снижает гибкость;если вы измените определение функции,то вызовы,уже встроенные,будут использовать старое определение до тех пор,пока вы не перекомпилируете их.</target>
        </trans-unit>
        <trans-unit id="f2089d7853bf8479df80e0abc427bb46a0ae24ca" translate="yes" xml:space="preserve">
          <source>Making a simple menu.</source>
          <target state="translated">Создание простого меню.</target>
        </trans-unit>
        <trans-unit id="8439e43257d843b9c56d5b30e329b96824cfd5a0" translate="yes" xml:space="preserve">
          <source>Making a trace buffer is not the same thing as using trace execution mode (see &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;).</source>
          <target state="translated">Создание буфера трассировки - это не то же самое, что использование режима выполнения трассировки (см. &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Режимы выполнения Edebug&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e9a2a5554b24dffde38c378df6b1ed44b56af090" translate="yes" xml:space="preserve">
          <source>Making a variable buffer-local within a &lt;code&gt;let&lt;/code&gt;-binding for that variable does not work reliably, unless the buffer in which you do this is not current either on entry to or exit from the &lt;code&gt;let&lt;/code&gt;. This is because &lt;code&gt;let&lt;/code&gt; does not distinguish between different kinds of bindings; it knows only which variable the binding was made for.</source>
          <target state="translated">Создание переменной buffer-local в &lt;code&gt;let&lt;/code&gt; -binding для этой переменной не работает надежно, если только буфер, в котором вы это делаете, не является текущим при входе в &lt;code&gt;let&lt;/code&gt; или выходе из него . Это связано с тем, что &lt;code&gt;let&lt;/code&gt; не делает различий между разными типами привязок; он знает только, для какой переменной была сделана привязка.</target>
        </trans-unit>
        <trans-unit id="1a77df4e83035e98ff42ae3948f6a82cd13e6bb3" translate="yes" xml:space="preserve">
          <source>Making and Deleting Numbered Backup Files</source>
          <target state="translated">Создание и удаление пронумерованных резервных файлов</target>
        </trans-unit>
        <trans-unit id="502cd69036f8965c9870fb3f5a0ea43cc7a0e64d" translate="yes" xml:space="preserve">
          <source>Making elements that match multiline constructs work properly has two aspects: correct &lt;em&gt;identification&lt;/em&gt; and correct &lt;em&gt;rehighlighting&lt;/em&gt;. The first means that Font Lock finds all multiline constructs. The second means that Font Lock will correctly rehighlight all the relevant text when a multiline construct is changed&amp;mdash;for example, if some of the text that was previously part of a multiline construct ceases to be part of it. The two aspects are closely related, and often getting one of them to work will appear to make the other also work. However, for reliable results you must attend explicitly to both aspects.</source>
          <target state="translated">Обеспечение правильной работы элементов, соответствующих многострочным конструкциям, имеет два аспекта: правильная &lt;em&gt;идентификация&lt;/em&gt; и правильное &lt;em&gt;повторное выделение&lt;/em&gt; . Первый означает, что Font Lock находит все многострочные конструкции. Второй означает, что Font Lock будет правильно повторно выделять весь соответствующий текст при изменении многострочной конструкции - например, если какой-то текст, который ранее был частью многострочной конструкции, перестает быть ее частью. Эти два аспекта тесно связаны, и часто оказывается, что заставляя один из них работать, заставляет работать и другой. Однако для получения надежных результатов вы должны четко учитывать оба аспекта.</target>
        </trans-unit>
        <trans-unit id="098d22cd28360badafbde33dc08e76c95b4320aa" translate="yes" xml:space="preserve">
          <source>Making empty markers or markers at certain places.</source>
          <target state="translated">Изготовление пустых маркеров или маркеров в определенных местах.</target>
        </trans-unit>
        <trans-unit id="525dbea9386c59969f103c79f75f5f87fc2f3fcd" translate="yes" xml:space="preserve">
          <source>Making keymaps active is not the only way to use them. Keymaps are also used in other ways, such as for translating events within &lt;code&gt;read-key-sequence&lt;/code&gt;. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">Активизация раскладки клавиатуры - не единственный способ их использования. Раскладки также используются и другими способами, например, для преобразования событий в &lt;code&gt;read-key-sequence&lt;/code&gt; . См. &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Раздел Раскладки перевода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="541485b8dffefaa5c41c8732b845592eb77e4506" translate="yes" xml:space="preserve">
          <source>Making multiple system-level windows.</source>
          <target state="translated">Создание нескольких системных окон.</target>
        </trans-unit>
        <trans-unit id="7aea42fe562cd12b8ebe2dbf3e921b54d524ae69" translate="yes" xml:space="preserve">
          <source>Making printable descriptions of non-printing characters and key sequences.</source>
          <target state="translated">Создание печатных описаний непечатаемых символов и последовательностей клавиш.</target>
        </trans-unit>
        <trans-unit id="a8c2048498ddf380173f943840a29bb5648daa3a" translate="yes" xml:space="preserve">
          <source>Making variables and faces customizable.</source>
          <target state="translated">Сделать переменные и лица настраиваемыми.</target>
        </trans-unit>
        <trans-unit id="f955f72d31d474b19bd9671e9ef2cb781d7e8a14" translate="yes" xml:space="preserve">
          <source>Making windows atomic (see &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;) avoids breaking an existing window composition when popping up a new window. The new window will pop up outside the composition instead.</source>
          <target state="translated">Создание атомарных окон (см. &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Атомарные окна&lt;/a&gt; ) позволяет избежать нарушения существующей композиции окна при открытии нового окна. Вместо этого новое окно появится за пределами композиции.</target>
        </trans-unit>
        <trans-unit id="e6360d86a643276430e992495fad2c7dbbc295a9" translate="yes" xml:space="preserve">
          <source>Managing Overlays</source>
          <target state="translated">Управление накладками</target>
        </trans-unit>
        <trans-unit id="debda63f7ddcebd0c0dfe38a3022559f7abc90ec" translate="yes" xml:space="preserve">
          <source>Managing a Fixed-Size Ring of Objects</source>
          <target state="translated">Управление кольцом объектов фиксированного размера</target>
        </trans-unit>
        <trans-unit id="fdce057e8f54be9a848c2533b0fadb72cdfd78bc" translate="yes" xml:space="preserve">
          <source>Managing a fixed-size ring of objects.</source>
          <target state="translated">Управление кольцом объектов фиксированного размера.</target>
        </trans-unit>
        <trans-unit id="75bd65a788f8528d79762b0605df956da0550547" translate="yes" xml:space="preserve">
          <source>Manipulating Buttons</source>
          <target state="translated">Манипулирующие кнопки</target>
        </trans-unit>
        <trans-unit id="e43177bf40b32f1208c84ad9ee839111b074ef8c" translate="yes" xml:space="preserve">
          <source>Manipulating windows and displaying buffers.</source>
          <target state="translated">Манипулирование окнами и отображение буферов.</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="7492182c02f487bb6ba19f1d0693155fc4bbcfd0" translate="yes" xml:space="preserve">
          <source>Many 32-bit operating systems are limited to system times containing 32 bits of information in their seconds component; these systems typically handle only the times from 1901-12-13 20:45:52 through 2038-01-19 03:14:07 Universal Time. However, 64-bit and some 32-bit operating systems have larger seconds components, and can represent times far in the past or future.</source>
          <target state="translated">Многие 32-битные операционные системы ограничиваются системным временем,содержащим 32 бита информации в своей секундной составляющей;эти системы обычно обрабатывают только время с 1901-12-13 20:45:52 до 2038-01-19 03:14:07 по универсальному времени.Однако,64-битные и некоторые 32-битные операционные системы имеют более крупную секундную компоненту,и могут представлять время далеко в прошлом или будущем.</target>
        </trans-unit>
        <trans-unit id="79e5ea61e3cd212d27c82f4613eb12341df1f45d" translate="yes" xml:space="preserve">
          <source>Many alists use lists with two elements, instead of cons cells. For example,</source>
          <target state="translated">Многие списки используют списки с двумя элементами,а не с минусами.Например,</target>
        </trans-unit>
        <trans-unit id="cb227181787da48817c942e26d864e081c59be50" translate="yes" xml:space="preserve">
          <source>Many efforts in the design of &lt;code&gt;display-buffer&lt;/code&gt; have been given to maintain compatibility with code that uses older options like &lt;code&gt;pop-up-windows&lt;/code&gt;, &lt;code&gt;pop-up-frames&lt;/code&gt;, &lt;code&gt;pop-up-frame-alist&lt;/code&gt;, &lt;code&gt;same-window-buffer-names&lt;/code&gt; and &lt;code&gt;same-window-regexps&lt;/code&gt;. Lisp Programs and users should refrain from using these options. Above we already warned against customizing &lt;code&gt;pop-up-frame-alist&lt;/code&gt;. Here we describe how to convert the remaining options to use display actions instead.</source>
          <target state="translated">При разработке &lt;code&gt;display-buffer&lt;/code&gt; было приложено много усилий для обеспечения совместимости с кодом, который использует более старые параметры, такие как &lt;code&gt;pop-up-windows&lt;/code&gt; , &lt;code&gt;pop-up-frames&lt;/code&gt; , &lt;code&gt;pop-up-frame-alist&lt;/code&gt; , &lt;code&gt;same-window-buffer-names&lt;/code&gt; и &lt;code&gt;same-window-regexps&lt;/code&gt; . Программы и пользователи Lisp должны воздерживаться от использования этих опций. Выше мы уже предостерегали от настройки &lt;code&gt;pop-up-frame-alist&lt;/code&gt; . Здесь мы описываем, как преобразовать оставшиеся параметры для использования вместо них действий отображения.</target>
        </trans-unit>
        <trans-unit id="4b9ab87576a609558bdd9e7bef4e47ebe7d12419" translate="yes" xml:space="preserve">
          <source>Many filter functions sometimes (or always) insert the output in the process&amp;rsquo;s buffer, mimicking the actions of the default filter. Such filter functions need to make sure that they save the current buffer, select the correct buffer (if different) before inserting output, and then restore the original buffer. They should also check whether the buffer is still alive, update the process marker, and in some cases update the value of point. Here is how to do these things:</source>
          <target state="translated">Многие функции фильтрации иногда (или всегда) вставляют вывод в буфер процесса, имитируя действия фильтра по умолчанию. Такие функции фильтрации должны быть уверены, что они сохраняют текущий буфер, выбирают правильный буфер (если он другой) перед вставкой вывода, а затем восстанавливают исходный буфер. Они также должны проверить, жив ли буфер, обновить маркер процесса и в некоторых случаях обновить значение точки. Вот как это сделать:</target>
        </trans-unit>
        <trans-unit id="bd93bafe41da62c5221706aaaa782fac79369062" translate="yes" xml:space="preserve">
          <source>Many functions are provided to look at the characters around point. Several simple functions are described here. See also &lt;code&gt;looking-at&lt;/code&gt; in &lt;a href=&quot;regexp-search#Regexp-Search&quot;&gt;Regexp Search&lt;/a&gt;.</source>
          <target state="translated">Для просмотра символов вокруг точки предусмотрено множество функций. Здесь описано несколько простых функций. См. Также &lt;code&gt;looking-at&lt;/code&gt; в &lt;a href=&quot;regexp-search#Regexp-Search&quot;&gt;Regexp Search&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99061e430b89d1f2aeaea52a5d8f4cb245b9c411" translate="yes" xml:space="preserve">
          <source>Many functions build lists, as lists reside at the very heart of Lisp. &lt;code&gt;cons&lt;/code&gt; is the fundamental list-building function; however, it is interesting to note that &lt;code&gt;list&lt;/code&gt; is used more times in the source code for Emacs than &lt;code&gt;cons&lt;/code&gt;.</source>
          <target state="translated">Многие функции создают списки, поскольку списки лежат в основе Lisp. &lt;code&gt;cons&lt;/code&gt; - это основная функция построения списков; однако интересно отметить, что &lt;code&gt;list&lt;/code&gt; используется в исходном коде Emacs чаще, чем &lt;code&gt;cons&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b118195a9372d8b227bd6e9ed5773cbb28b54e10" translate="yes" xml:space="preserve">
          <source>Many functions like &lt;code&gt;current-time&lt;/code&gt; and &lt;code&gt;file-attributes&lt;/code&gt; return &lt;em&gt;Lisp timestamp&lt;/em&gt; values that count seconds, and that can represent absolute time by counting seconds since the &lt;em&gt;epoch&lt;/em&gt; of 1970-01-01 00:00:00 UTC.</source>
          <target state="translated">Многие функции, такие как &lt;code&gt;current-time&lt;/code&gt; и &lt;code&gt;file-attributes&lt;/code&gt; , возвращают значения &lt;em&gt;временной метки Lisp,&lt;/em&gt; которые считают секунды и могут представлять абсолютное время, считая секунды с &lt;em&gt;эпохи&lt;/em&gt; 1970-01-01 00:00:00 UTC.</target>
        </trans-unit>
        <trans-unit id="802952a287eebffddbd929e1038f8cdef315746b" translate="yes" xml:space="preserve">
          <source>Many functions that interact with process objects, (for instance, &lt;code&gt;process-datagram-address&lt;/code&gt;) rely on them at least having a socket before they can return a useful value. These functions will block until the socket has achieved the desired status. The recommended way of interacting with asynchronous sockets is to place a sentinel on the process, and not try to interact with it before it has changed status to &amp;lsquo;</source>
          <target state="translated">Многие функции, которые взаимодействуют с объектами процесса (например, &lt;code&gt;process-datagram-address&lt;/code&gt; ), полагаются на них, по крайней мере, на наличие сокета, прежде чем они смогут вернуть полезное значение. Эти функции будут заблокированы, пока сокет не достигнет желаемого статуса. Рекомендуемый способ взаимодействия с асинхронными сокетами состоит в том, чтобы поставить на процесс стража, а не пытаться взаимодействовать с ним, пока он не изменит статус на '</target>
        </trans-unit>
        <trans-unit id="34060d8cea305615df58234c0c74340b92bdbb96" translate="yes" xml:space="preserve">
          <source>Many of the examples in this manual print text when they are evaluated. If you execute example code in a Lisp Interaction buffer (such as the buffer</source>
          <target state="translated">Многие из примеров в этом руководстве печатают текст,когда они оцениваются.Если вы выполняете код примера в буфере Lisp Interaction (например,в буфере</target>
        </trans-unit>
        <trans-unit id="2cb6eeef569da5d2926960dd49593235b8a4de19" translate="yes" xml:space="preserve">
          <source>Many of the file functions take one or more arguments that are file names. A file name is a string. Most of these functions expand file name arguments using the function &lt;code&gt;expand-file-name&lt;/code&gt;, so that</source>
          <target state="translated">Многие файловые функции принимают один или несколько аргументов, которые являются именами файлов. Имя файла - это строка. Большинство этих функций расширяют аргументы имени файла с помощью функции &lt;code&gt;expand-file-name&lt;/code&gt; , так что</target>
        </trans-unit>
        <trans-unit id="856002faf420bf01c022be5d9fd84713d7c5ea95" translate="yes" xml:space="preserve">
          <source>Many of the functions described in this chapter accept markers for arguments in place of numbers. (See &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;.) Since the actual arguments to such functions may be either numbers or markers, we often give these arguments the name &lt;var&gt;number-or-marker&lt;/var&gt;. When the argument value is a marker, its position value is used and its buffer is ignored.</source>
          <target state="translated">Многие из функций, описанных в этой главе, принимают маркеры в качестве аргументов вместо чисел. (См . Раздел &amp;laquo; &lt;a href=&quot;markers#Markers&quot;&gt;Маркеры&amp;raquo;&lt;/a&gt; .) Поскольку фактическими аргументами таких функций могут быть числа или маркеры, мы часто даем этим аргументам имя &amp;laquo; &lt;var&gt;number-or-marker&lt;/var&gt; . Когда значением аргумента является маркер, используется его значение позиции, а его буфер игнорируется.</target>
        </trans-unit>
        <trans-unit id="ede60666649bf60156d4a427812b20ad852466a6" translate="yes" xml:space="preserve">
          <source>Many of the specialized editing and I/O facilities of Emacs accept only strings. For example, you cannot insert a vector of characters into a buffer the way you can insert a string. See &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Strings and Characters&lt;/a&gt;.</source>
          <target state="translated">Многие специализированные средства редактирования и ввода-вывода Emacs принимают только строки. Например, вы не можете вставить вектор символов в буфер, как вы можете вставить строку. См. &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Строки и символы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3629e89080e09e327cdd6dfb7f47d74e11faec96" translate="yes" xml:space="preserve">
          <source>Many of the standard Emacs functions manipulate or test the characters in the current buffer; a whole chapter in this manual is devoted to describing these functions (see &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;).</source>
          <target state="translated">Многие стандартные функции Emacs управляют или проверяют символы в текущем буфере; целая глава в этом руководстве посвящена описанию этих функций (см. &lt;a href=&quot;text#Text&quot;&gt;Текст&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d945fb20602aed4abd69b2e84e025e54ece264be" translate="yes" xml:space="preserve">
          <source>Many of the valid output streams are also valid as input streams. The difference between input and output streams is therefore more a matter of how you use a Lisp object, than of different types of object.</source>
          <target state="translated">Многие из действительных выходных потоков также действительны как входные.Поэтому разница между входным и выходным потоками больше зависит от того,как вы используете объект Lisp,чем от различных типов объектов.</target>
        </trans-unit>
        <trans-unit id="f337e3c741b2e5363e4452e88afb97f9e466bc3f" translate="yes" xml:space="preserve">
          <source>Many overlay properties have special meanings; here is a table of them:</source>
          <target state="translated">Многие свойства наложения имеют особое значение,вот их таблица:</target>
        </trans-unit>
        <trans-unit id="28669a5c2141fd75140a0f1efc7ec3dc89659c90" translate="yes" xml:space="preserve">
          <source>Many text-related functions operate on a region of text defined by two buffer positions passed in arguments named &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;. These arguments should be either markers (see &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;) or numeric character positions (see &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;). The order of these arguments does not matter; it is all right for &lt;var&gt;start&lt;/var&gt; to be the end of the region and &lt;var&gt;end&lt;/var&gt; the beginning. For example, &lt;code&gt;(delete-region 1
10)&lt;/code&gt; and &lt;code&gt;(delete-region 10 1)&lt;/code&gt; are equivalent. An &lt;code&gt;args-out-of-range&lt;/code&gt; error is signaled if either &lt;var&gt;start&lt;/var&gt; or &lt;var&gt;end&lt;/var&gt; is outside the accessible portion of the buffer. In an interactive call, point and the mark are used for these arguments.</source>
          <target state="translated">Многие функции, связанные с текстом, работают с областью текста, определяемой двумя позициями буфера, переданными в аргументах с именами &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; . Эти аргументы должны быть маркерами (см. &lt;a href=&quot;markers#Markers&quot;&gt;Маркеры&lt;/a&gt; ) или позициями числовых символов (см. &lt;a href=&quot;positions#Positions&quot;&gt;Позиции&lt;/a&gt; ). Порядок этих аргументов не имеет значения; это нормально, что &lt;var&gt;start&lt;/var&gt; должно быть концом области, а &lt;var&gt;end&lt;/var&gt; - началом. Например, &lt;code&gt;(delete-region 1 10)&lt;/code&gt; и &lt;code&gt;(delete-region 10 1)&lt;/code&gt; эквивалентны. &lt;code&gt;args-out-of-range&lt;/code&gt; сигнализируется ошибка , если либо &lt;var&gt;start&lt;/var&gt; или &lt;var&gt;end&lt;/var&gt; находится за пределами доступной части буфера. В интерактивном вызове для этих аргументов используются точка и метка.</target>
        </trans-unit>
        <trans-unit id="6ed3e3bf0cc6abbeb7fc11924e0595f7cbb9b258" translate="yes" xml:space="preserve">
          <source>Many window-systems are not able to change the opacity (see &lt;a href=&quot;font-and-color-parameters#Font-and-Color-Parameters&quot;&gt;Font and Color Parameters&lt;/a&gt;) of child frames.</source>
          <target state="translated">Многие оконные системы не могут изменять прозрачность (см. &lt;a href=&quot;font-and-color-parameters#Font-and-Color-Parameters&quot;&gt;Параметры шрифта и цвета&lt;/a&gt; ) дочерних фреймов.</target>
        </trans-unit>
        <trans-unit id="213b455d1f0caf22fcf0e2374a037400baed7c91" translate="yes" xml:space="preserve">
          <source>Mapping Functions</source>
          <target state="translated">Картографические функции</target>
        </trans-unit>
        <trans-unit id="7b7987be97e32819225bc7a4606b16bf612de0b6" translate="yes" xml:space="preserve">
          <source>Mapping for such special cases are taken from &lt;code&gt;special-uppercase&lt;/code&gt;, &lt;code&gt;special-lowercase&lt;/code&gt; and &lt;code&gt;special-titlecase&lt;/code&gt; See &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;.</source>
          <target state="translated">Отображение для таких особых случаев берутся из &lt;code&gt;special-uppercase&lt;/code&gt; , &lt;code&gt;special-lowercase&lt;/code&gt; и &lt;code&gt;special-titlecase&lt;/code&gt; См. &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Свойства символа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f093ddf02abeed7e13d39bb01f441baf4324273f" translate="yes" xml:space="preserve">
          <source>Margins for Filling</source>
          <target state="translated">Маргины для заполнения</target>
        </trans-unit>
        <trans-unit id="e693e76b5d2e33add6fdff9ff18a57f6b466043e" translate="yes" xml:space="preserve">
          <source>Mark set</source>
          <target state="translated">Набор меток</target>
        </trans-unit>
        <trans-unit id="40c9d9aab143333b8799668f89011a977e366648" translate="yes" xml:space="preserve">
          <source>Mark the function or macro as obsolete, similar to a call to &lt;code&gt;make-obsolete&lt;/code&gt; (see &lt;a href=&quot;obsolete-functions#Obsolete-Functions&quot;&gt;Obsolete Functions&lt;/a&gt;). &lt;var&gt;current-name&lt;/var&gt; should be a symbol (in which case the warning message says to use that instead), a string (specifying the warning message), or &lt;code&gt;nil&lt;/code&gt; (in which case the warning message gives no extra details). &lt;var&gt;when&lt;/var&gt; should be a string indicating when the function or macro was first made obsolete.</source>
          <target state="translated">Отметьте функцию или макрос как устаревшие, аналогично вызову &lt;code&gt;make-obsolete&lt;/code&gt; (см. &lt;a href=&quot;obsolete-functions#Obsolete-Functions&quot;&gt;Устаревшие функции&lt;/a&gt; ). &lt;var&gt;current-name&lt;/var&gt; должно быть символом (в этом случае в предупреждающем сообщении говорится, что следует использовать его), строкой (с указанием предупреждающего сообщения) или &lt;code&gt;nil&lt;/code&gt; (в этом случае предупреждающее сообщение не содержит дополнительных сведений). &lt;var&gt;when&lt;/var&gt; должно быть строкой, указывающей, когда функция или макрос были впервые сделаны устаревшими.</target>
        </trans-unit>
        <trans-unit id="75ec2d229775005fdc921c3a210ff1b8c8b13b6e" translate="yes" xml:space="preserve">
          <source>Marker Insertion Types</source>
          <target state="translated">Типы вставки маркеров</target>
        </trans-unit>
        <trans-unit id="20a369b8d549cf56bd368b32f6f9b7f7febde165" translate="yes" xml:space="preserve">
          <source>Marker Type</source>
          <target state="translated">Тип маркера</target>
        </trans-unit>
        <trans-unit id="c64fa883b0b011047af44d0deea4165129c087b1" translate="yes" xml:space="preserve">
          <source>Markers</source>
          <target state="translated">Markers</target>
        </trans-unit>
        <trans-unit id="3a15c9c37c23f1de054f9f2fb2d0661fb9245c11" translate="yes" xml:space="preserve">
          <source>Markers have no read syntax. They print in hash notation, giving the current character position and the name of the buffer.</source>
          <target state="translated">У маркеров нет синтаксиса чтения.Они печатают в хэш-нотации,указывая текущую позицию символа и имя буфера.</target>
        </trans-unit>
        <trans-unit id="90ec4189b2e9a955fa94b8f4c8d3ea5a03189fdd" translate="yes" xml:space="preserve">
          <source>Markers pointing into any sort records are left with no useful position after &lt;code&gt;sort-subr&lt;/code&gt; returns.</source>
          <target state="translated">Маркеры, указывающие на любые записи сортировки, остаются без полезной позиции после возврата &lt;code&gt;sort-subr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6e97fbd0e2de79918f6c8ca8bf38d32ac3071bf" translate="yes" xml:space="preserve">
          <source>Markers represent positions and update automatically when the text is changed.</source>
          <target state="translated">Маркеры представляют позиции и обновляются автоматически при изменении текста.</target>
        </trans-unit>
        <trans-unit id="c3ffcb290c16e09210daad56e90773ef95a42fa0" translate="yes" xml:space="preserve">
          <source>Marking multiline chunks with a text property.</source>
          <target state="translated">Маркировка многолинейных кусков с свойством текста.</target>
        </trans-unit>
        <trans-unit id="adb842e548d37ba30e15d8d71ecca123602b790c" translate="yes" xml:space="preserve">
          <source>Marks the selected window as non-dedicated and proceeds.</source>
          <target state="translated">Пометит выбранное окно как невыделенное и продолжает работу.</target>
        </trans-unit>
        <trans-unit id="63136e6c72133709fdd14fe590280a9e7adfb5ae" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;rx&lt;/var&gt;, with &lt;code&gt;zero-or-more&lt;/code&gt;, &lt;code&gt;0+&lt;/code&gt;, &lt;code&gt;one-or-more&lt;/code&gt;, &lt;code&gt;1+&lt;/code&gt;, &lt;code&gt;zero-or-one&lt;/code&gt;, &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;optional&lt;/code&gt; using greedy matching. This is the default.</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; с &lt;code&gt;zero-or-more&lt;/code&gt; , &lt;code&gt;0+&lt;/code&gt; , &lt;code&gt;one-or-more&lt;/code&gt; , &lt;code&gt;1+&lt;/code&gt; , &lt;code&gt;zero-or-one&lt;/code&gt; , &lt;code&gt;opt&lt;/code&gt; и &lt;code&gt;optional&lt;/code&gt; с использованием жадного сопоставления. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2e1d4ec9e304a391aeeff942a7e3f04f60b8de56" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;rx&lt;/var&gt;, with &lt;code&gt;zero-or-more&lt;/code&gt;, &lt;code&gt;0+&lt;/code&gt;, &lt;code&gt;one-or-more&lt;/code&gt;, &lt;code&gt;1+&lt;/code&gt;, &lt;code&gt;zero-or-one&lt;/code&gt;, &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;optional&lt;/code&gt; using non-greedy matching.</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; с &lt;code&gt;zero-or-more&lt;/code&gt; , &lt;code&gt;0+&lt;/code&gt; , &lt;code&gt;one-or-more&lt;/code&gt; , &lt;code&gt;1+&lt;/code&gt; , &lt;code&gt;zero-or-one&lt;/code&gt; , &lt;code&gt;opt&lt;/code&gt; и &lt;code&gt;optional&lt;/code&gt; используя нежадное сопоставление.</target>
        </trans-unit>
        <trans-unit id="71abe0286e229c1d876f4a021f7e016ea6b1fc99" translate="yes" xml:space="preserve">
          <source>Match a character from a named character class:</source>
          <target state="translated">Подходит персонаж из класса именованных персонажей:</target>
        </trans-unit>
        <trans-unit id="ad6d6fc231dbd73dfc165b65f61e36d58bad1af7" translate="yes" xml:space="preserve">
          <source>Match a character in category &lt;var&gt;category&lt;/var&gt;, which is either one of the names below or its category character.</source>
          <target state="translated">Соответствует символу в категории &lt;var&gt;category&lt;/var&gt; , который является либо одним из имен ниже, либо его символом категории.</target>
        </trans-unit>
        <trans-unit id="de8031dd3712abe87445e83aadf5d0e6910dc120" translate="yes" xml:space="preserve">
          <source>Match a character included in all of the &lt;var&gt;charset&lt;/var&gt;s. Each &lt;var&gt;charset&lt;/var&gt; can be a character, a single-character string, an &lt;code&gt;any&lt;/code&gt; form without character classes, or an &lt;code&gt;intersection&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; form whose arguments are also &lt;var&gt;charset&lt;/var&gt;s.</source>
          <target state="translated">Соответствует символу, включенному во все &lt;var&gt;charset&lt;/var&gt; . Каждый &lt;var&gt;charset&lt;/var&gt; может быть символ, строка одной герой, &lt;code&gt;any&lt;/code&gt; формы без классов символов, или &lt;code&gt;intersection&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , или &lt;code&gt;not&lt;/code&gt; формы , чьи аргументы также &lt;var&gt;charset&lt;/var&gt; с.</target>
        </trans-unit>
        <trans-unit id="1d6ce8155afacb2f041062878ec1c97fa63888c6" translate="yes" xml:space="preserve">
          <source>Match a character not included in &lt;var&gt;charspec&lt;/var&gt;. &lt;var&gt;charspec&lt;/var&gt; can be a character, a single-character string, an &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;intersection&lt;/code&gt;, &lt;code&gt;syntax&lt;/code&gt; or &lt;code&gt;category&lt;/code&gt; form, or a character class. If &lt;var&gt;charspec&lt;/var&gt; is an &lt;code&gt;or&lt;/code&gt; form, its arguments have the same restrictions as those of &lt;code&gt;intersection&lt;/code&gt;; see below. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Соответствует символу, не включенному в &lt;var&gt;charspec&lt;/var&gt; . &lt;var&gt;charspec&lt;/var&gt; может быть символом, односимвольной строкой, &lt;code&gt;any&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;intersection&lt;/code&gt; , &lt;code&gt;syntax&lt;/code&gt; или формой &lt;code&gt;category&lt;/code&gt; или классом символов. Если &lt;var&gt;charspec&lt;/var&gt; является формой &lt;code&gt;or&lt;/code&gt; , его аргументы имеют те же ограничения, что и аргументы &lt;code&gt;intersection&lt;/code&gt; ; Смотри ниже. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="20528df965fcdab88638f3141ed3bb0a4816a094" translate="yes" xml:space="preserve">
          <source>Match a character with syntax &lt;var&gt;syntax&lt;/var&gt;, being one of the following names:</source>
          <target state="translated">Сопоставьте символ с синтаксисом &lt;var&gt;syntax&lt;/var&gt; , являющийся одним из следующих имен:</target>
        </trans-unit>
        <trans-unit id="d97d65b8ec18624513dc0b5597c7a311786d6e2f" translate="yes" xml:space="preserve">
          <source>Match a single character from one of the &lt;var&gt;set&lt;/var&gt;s. Each &lt;var&gt;set&lt;/var&gt; is a character, a string representing the set of its characters, a range or a character class (see below). A range is either a hyphen-separated string like &lt;code&gt;&quot;A-Z&quot;&lt;/code&gt;, or a cons of characters like &lt;code&gt;(?A . ?Z)&lt;/code&gt;.</source>
          <target state="translated">Соответствует одиночному символу из &lt;var&gt;set&lt;/var&gt; s. Каждый &lt;var&gt;set&lt;/var&gt; - это символ, строка, представляющая набор своих символов, диапазон или класс символов (см. Ниже). Диапазон - это либо строка, разделенная дефисом, например &lt;code&gt;&quot;A-Z&quot;&lt;/code&gt; , либо минус символов, например &lt;code&gt;(?A . ?Z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dd2fbec99fc2ab616903412ba0cff721c4c9e90" translate="yes" xml:space="preserve">
          <source>Match alphabetic characters and digits. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">Сопоставьте буквенные символы и цифры. Точнее, сопоставьте символы, у которых Unicode '</target>
        </trans-unit>
        <trans-unit id="82708ce98f9d023741d282ec7721747edbd6f773" translate="yes" xml:space="preserve">
          <source>Match alphabetic characters. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">Соответствие буквенным символам. Точнее, сопоставьте символы, у которых Unicode '</target>
        </trans-unit>
        <trans-unit id="8bb62c1f38a88090666bab18fcce11f7a820ad8a" translate="yes" xml:space="preserve">
          <source>Match any</source>
          <target state="translated">Подходит любой</target>
        </trans-unit>
        <trans-unit id="c6bedd2c326b64596143cbeea5bbc65702a26806" translate="yes" xml:space="preserve">
          <source>Match any character except a newline. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Соответствует любому символу, кроме новой строки. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="cc22989554162915a08cc2b0ae06291b07457a73" translate="yes" xml:space="preserve">
          <source>Match any character except whitespace,</source>
          <target state="translated">Подходит для любого символа,за исключением пробела,</target>
        </trans-unit>
        <trans-unit id="7e7f303c256818204aa47a2cf16fd245fafcb2e6" translate="yes" xml:space="preserve">
          <source>Match any character that has whitespace syntax (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">Соответствует любому символу, имеющему синтаксис пробелов (см. &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Таблицу классов синтаксиса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="20fbfb2c118e7dfaf594921c0c9ef8d863759b77" translate="yes" xml:space="preserve">
          <source>Match any character that has word syntax (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">Соответствует любому символу, имеющему синтаксис слова (см. &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Таблицу классов синтаксиса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="68242dc98a557b85cf91e4b3c6ac38743362dde2" translate="yes" xml:space="preserve">
          <source>Match any character whose code is in the range 0&amp;ndash;31.</source>
          <target state="translated">Соответствует любому символу, код которого находится в диапазоне 0&amp;ndash;31.</target>
        </trans-unit>
        <trans-unit id="a9facac9ba78f72ef2c064b0654d33707cf5d808" translate="yes" xml:space="preserve">
          <source>Match any character. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Соответствует любому персонажу. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="d134eaf7cc09f30a884da1beb70b95fea1c42f48" translate="yes" xml:space="preserve">
          <source>Match any non-</source>
          <target state="translated">Матч любой не</target>
        </trans-unit>
        <trans-unit id="ef8bad91a3175348513872b6c54736f0c4acdee3" translate="yes" xml:space="preserve">
          <source>Match any punctuation character. (At present, for multibyte characters, anything that has non-word syntax.)</source>
          <target state="translated">Подходит для любого знака препинания.(В настоящее время для многобайтовых символов-все,что имеет синтаксис,отличный от синтаксиса слова).</target>
        </trans-unit>
        <trans-unit id="b234e5cee3141027589e4ab45ac9e2ef3aef0df9" translate="yes" xml:space="preserve">
          <source>Match anything lower-case, as determined by the current case table. If &lt;code&gt;case-fold-search&lt;/code&gt; is non-nil, this also matches any upper-case letter.</source>
          <target state="translated">Соответствует чему-либо в нижнем регистре, как определено в текущей таблице регистров. Если &lt;code&gt;case-fold-search&lt;/code&gt; отлична от nil, это также соответствует любой заглавной букве.</target>
        </trans-unit>
        <trans-unit id="b2217b7ab7ecff3396b14564129755a0ed8ebb52" translate="yes" xml:space="preserve">
          <source>Match anything upper-case, as determined by the current case table. If &lt;code&gt;case-fold-search&lt;/code&gt; is non-nil, this also matches any lower-case letter.</source>
          <target state="translated">Соответствует чему-либо в верхнем регистре, как определено в текущей таблице регистров. Если &lt;code&gt;case-fold-search&lt;/code&gt; отлична от nil, это также соответствует любой строчной букве.</target>
        </trans-unit>
        <trans-unit id="407d34a704815e72fde4647d011a88e9c5656f33" translate="yes" xml:space="preserve">
          <source>Match anywhere but at the beginning or end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Совпадение в любом месте, кроме начала или конца слова. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="a152ee853f24a37ea457df3b8d2fdc8d7fc9b34c" translate="yes" xml:space="preserve">
          <source>Match at point. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Матч в точке. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="f259a5bdb641748dc6291dbf1194b2479f6cc58c" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a line. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Матч в начале строки. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="381a3b6056cd0802e4c2d50199de3b52bc4cc745" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a symbol. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Совпадение в начале символа. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="06202c9463fb84fe0562bd42d6d713a2880e374b" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Соответствует началу слова. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="96950b0283f2ce0a0d3b906dc2439e842ea803e8" translate="yes" xml:space="preserve">
          <source>Match at the beginning or end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Соответствует началу или концу слова. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="44efaac71dd0cf46b4e63e407bdb35817ac76578" translate="yes" xml:space="preserve">
          <source>Match at the end of a line. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Матч в конце строки. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="290249cf5c2235f1cd6f27816d45a80df534d2c5" translate="yes" xml:space="preserve">
          <source>Match at the end of a symbol. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Матч в конце символа. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="e8ba6be4fdd0b132f04646bba49b7c6fc783a283" translate="yes" xml:space="preserve">
          <source>Match at the end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Совпадение в конце слова. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="c43211f21a3160a9d519576413e4b08b88f31ae7" translate="yes" xml:space="preserve">
          <source>Match at the end of the string or buffer being matched against. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставление в конце строки или буфера, с которым сопоставляется. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="8efde31ba8632a39a1c15dd9f32b844f802c7c3d" translate="yes" xml:space="preserve">
          <source>Match at the start of the string or buffer being matched against. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Соответствует началу строки или буфера, с которым сравнивается. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="b731924293870a882dd28691dfcda9844f7ce67b" translate="yes" xml:space="preserve">
          <source>Match exactly one of the &lt;var&gt;rx&lt;/var&gt;s. If all arguments are strings, characters, or &lt;code&gt;or&lt;/code&gt; forms so constrained, the longest possible match will always be used. Otherwise, either the longest match or the first (in left-to-right order) will be used. Without arguments, the expression will not match anything at all. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Соответствует ровно одному из &lt;var&gt;rx&lt;/var&gt; s. Если все аргументы являются строками, символами &lt;code&gt;or&lt;/code&gt; формами, ограниченными таким образом, всегда будет использоваться максимально возможное совпадение. В противном случае будет использоваться либо самое длинное совпадение, либо первое (в порядке слева направо). Без аргументов выражение вообще ни с чем не будет соответствовать. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="7248472c4540b5bb98fb3d7078116ee5540becd2" translate="yes" xml:space="preserve">
          <source>Match horizontal whitespace. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">Соответствует горизонтальным пробелам. Точнее, сопоставьте символы, у которых Unicode '</target>
        </trans-unit>
        <trans-unit id="39ffee8a3eb0d7a19803afa6abf19912b7bfc01e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s &lt;var&gt;n&lt;/var&gt; or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s &lt;var&gt;n&lt;/var&gt; или более раз. Жадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="88b7d7bd4b35ad1b528a3b8246e2f6305909616e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s at least &lt;var&gt;n&lt;/var&gt; but no more than &lt;var&gt;m&lt;/var&gt; times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s не менее &lt;var&gt;n&lt;/var&gt; , но не более &lt;var&gt;m&lt;/var&gt; раз. Жадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="de1b336fa7f4a968c25a0903b00419f673937ea9" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s exactly &lt;var&gt;n&lt;/var&gt; times. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s ровно &lt;var&gt;n&lt;/var&gt; раз. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="54969cf7c5583dafecdf62c967082837d0ecd45e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s in sequence. Without arguments, the expression matches the empty string. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s последовательно. Без аргументов выражение соответствует пустой строке. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="812a5d6c5321c4869a91d7591bbf90a4ff04128c" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s once or an empty string. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s один раз или пустую строку. По умолчанию жадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="9d0e81755a90f55e663c35482e9b674dfc7de4d6" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s once or an empty string. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s один раз или пустую строку. Жадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="fd8b263c55e5ec0df49c18d0e47fbf0a1224d33d" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s один или несколько раз. По умолчанию жадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="2490a514c7217f45471d9b7c69875762fbd73841" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s один или несколько раз. Жадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="5f0c30af008a7a0ac54edf6206107e136e38294e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s один или несколько раз. Нежадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="83cd886da13deacda47e2fa48ca143a7370599e2" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s or an empty string. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s или пустую строку. Нежадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="3ab134fd7cf12648498ed41926f7c6ef78bd3c0f" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s ноль или более раз. По умолчанию жадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="d5a7ac9731ccc96d5cf2d592aa59dafb6c31bd41" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s ноль или более раз. Жадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="f105243e42ef3ab66e32f5d3b154f392aaed42cc" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s ноль или более раз. Нежадный. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="5fe3267ec0ff2cb20b90f39f1574039c8a4d6b35" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s, making the matched text and position accessible in the match data. The first group in a regexp is numbered 1; subsequent groups will be numbered one higher than the previous group. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте &lt;var&gt;rx&lt;/var&gt; s, сделав сопоставленный текст и позицию доступными в данных сопоставления. Первая группа в регулярном выражении имеет номер 1; последующие группы будут нумероваться на единицу выше, чем предыдущая группа. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="d7ef5aa9b8bbb06530907d3195d5d192d80e7284" translate="yes" xml:space="preserve">
          <source>Match the character &amp;lsquo;</source>
          <target state="translated">Соответствовать персонажу '</target>
        </trans-unit>
        <trans-unit id="40ed76ce7b1c68d6b3c8c8bd4b855cfc96f6c033" translate="yes" xml:space="preserve">
          <source>Match the digits &amp;lsquo;</source>
          <target state="translated">Сопоставьте цифры '</target>
        </trans-unit>
        <trans-unit id="365ffcf90847f5dfedeacb92fb74bfd5ac33dc8a" translate="yes" xml:space="preserve">
          <source>Match the hexadecimal digits &amp;lsquo;</source>
          <target state="translated">Сопоставьте шестнадцатеричные цифры '</target>
        </trans-unit>
        <trans-unit id="4a6978bcd14cd4f93782a8738d7349ba0d760be5" translate="yes" xml:space="preserve">
          <source>Match the literal string that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at call time, in the current lexical environment.</source>
          <target state="translated">Сопоставьте буквальную строку, которая является результатом вычисления выражения &lt;var&gt;expr&lt;/var&gt; Лиспа . Оценка происходит во время вызова в текущей лексической среде.</target>
        </trans-unit>
        <trans-unit id="1b502a84ddadc23f3da402b6793e0b908501bce7" translate="yes" xml:space="preserve">
          <source>Match the rx form that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at macro-expansion time for &lt;code&gt;rx&lt;/code&gt;, at call time for &lt;code&gt;rx-to-string&lt;/code&gt;, in the current global environment.</source>
          <target state="translated">Сопоставьте форму rx, которая является результатом вычисления выражения &lt;var&gt;expr&lt;/var&gt; Лиспа . Оценка происходит во время макрорасширения для &lt;code&gt;rx&lt;/code&gt; , во время вызова для &lt;code&gt;rx-to-string&lt;/code&gt; в текущей глобальной среде.</target>
        </trans-unit>
        <trans-unit id="3205c51d28824b4cbb8711f257894d8bb4c2f6f1" translate="yes" xml:space="preserve">
          <source>Match the string &amp;lsquo;</source>
          <target state="translated">Сопоставьте строку '</target>
        </trans-unit>
        <trans-unit id="7b75719d500955e334549481f6c7ea7b50a1ad73" translate="yes" xml:space="preserve">
          <source>Match the string regexp that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at call time, in the current lexical environment.</source>
          <target state="translated">Сопоставьте строковое выражение regexp, которое является результатом вычисления выражения &lt;var&gt;expr&lt;/var&gt; Лиспа . Оценка происходит во время вызова в текущей лексической среде.</target>
        </trans-unit>
        <trans-unit id="ae757acb76ba91417eef2b42ffb76c4521c4b810" translate="yes" xml:space="preserve">
          <source>Match the text previously matched by group number &lt;var&gt;n&lt;/var&gt;. &lt;var&gt;n&lt;/var&gt; must be in the range 1&amp;ndash;9. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Сопоставьте текст, ранее сопоставленный с номером группы &lt;var&gt;n&lt;/var&gt; . &lt;var&gt;n&lt;/var&gt; должно быть в диапазоне 1&amp;ndash;9. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="a9d49dbe39ad1efa260b09b12e904b32531ad43c" translate="yes" xml:space="preserve">
          <source>Match whitespace or a character matched by &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">Соответствует пробелу или символу, указанному на &lt;code&gt;graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54273900d77a58b496b801254cfc591edb749bf9" translate="yes" xml:space="preserve">
          <source>Matches any &lt;var&gt;expval&lt;/var&gt;, and additionally let-binds &lt;var&gt;symbol&lt;/var&gt; to &lt;var&gt;expval&lt;/var&gt;, such that this binding is available to &lt;var&gt;body-forms&lt;/var&gt; (see &lt;a href=&quot;dynamic-binding#Dynamic-Binding&quot;&gt;Dynamic Binding&lt;/a&gt;).</source>
          <target state="translated">Соответствует любому &lt;var&gt;expval&lt;/var&gt; и дополнительно let-связывает &lt;var&gt;symbol&lt;/var&gt; с &lt;var&gt;expval&lt;/var&gt; , так что эта привязка доступна для &lt;var&gt;body-forms&lt;/var&gt; (см. &lt;a href=&quot;dynamic-binding#Dynamic-Binding&quot;&gt;Динамическое связывание&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="132befd5d9407a174f4ad033d6cea023a4b37857" translate="yes" xml:space="preserve">
          <source>Matches any &lt;var&gt;expval&lt;/var&gt;. This is also known as &lt;em&gt;don&amp;rsquo;t care&lt;/em&gt; or &lt;em&gt;wildcard&lt;/em&gt;.</source>
          <target state="translated">Соответствует любому &lt;var&gt;expval&lt;/var&gt; . Это также известно как &amp;laquo; &lt;em&gt;безразлично&amp;raquo;&lt;/em&gt; или &amp;laquo; &lt;em&gt;подстановочный знак&amp;raquo;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="282c53348f7fcd0ad68d33bb9c7f6cccc54a4565" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;boolean-expression&lt;/var&gt; evaluates to non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Соответствует, если значение &lt;var&gt;boolean-expression&lt;/var&gt; не &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="257d039f7b35b3e0442ca76380b5ef90a0d77303" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; equals &lt;var&gt;val&lt;/var&gt;. The comparison is done as if by &lt;code&gt;equal&lt;/code&gt; (see &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicates&lt;/a&gt;).</source>
          <target state="translated">Соответствует, если &lt;var&gt;expval&lt;/var&gt; равно &lt;var&gt;val&lt;/var&gt; . Сравнение выполняется, как если бы оно было &lt;code&gt;equal&lt;/code&gt; (см. &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Предикаты равенства&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b1481ca7fe064087aacfb37775ecc46665629cf" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; equals the literal object. This is a special case of &lt;code&gt;'&lt;var&gt;val&lt;/var&gt;&lt;/code&gt;, above, possible because literal objects of these types are self-quoting.</source>
          <target state="translated">Соответствует, если &lt;var&gt;expval&lt;/var&gt; равен литеральному объекту. Это особый случай &lt;code&gt;'&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; , выше, возможно потому , что буквальные объекты этих типов себя процитировать.</target>
        </trans-unit>
        <trans-unit id="978883ed6eed2d6a28b654dbedeb42b8609b3fad" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; is a cons cell whose &lt;code&gt;car&lt;/code&gt; matches &lt;var&gt;qpat1&lt;/var&gt; and whose &lt;code&gt;cdr&lt;/code&gt; matches &lt;var&gt;qpat2&lt;/var&gt;. This readily generalizes to lists as in &lt;code&gt;(&lt;var&gt;qpat1&lt;/var&gt;&amp;nbsp;&lt;var&gt;qpat2&lt;/var&gt;&amp;nbsp;&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">Соответствует, если &lt;var&gt;expval&lt;/var&gt; является cons-ячейкой, &lt;code&gt;car&lt;/code&gt; которой соответствует &lt;var&gt;qpat1&lt;/var&gt; , а &lt;code&gt;cdr&lt;/code&gt; соответствует &lt;var&gt;qpat2&lt;/var&gt; . Это легко обобщается на списки, как в &lt;code&gt;(&lt;var&gt;qpat1&lt;/var&gt;&amp;nbsp;&lt;var&gt;qpat2&lt;/var&gt;&amp;nbsp;&amp;hellip;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d421ecc7a203998190360c012b97d967bb56647" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; is a vector of length &lt;var&gt;m&lt;/var&gt; whose &lt;code&gt;0&lt;/code&gt;..&lt;code&gt;(&lt;var&gt;m&lt;/var&gt;-1)&lt;/code&gt;th elements match &lt;var&gt;qpat1&lt;/var&gt;, &lt;var&gt;qpat2&lt;/var&gt; &amp;hellip; &lt;var&gt;qpatm&lt;/var&gt;, respectively.</source>
          <target state="translated">Соответствует, если &lt;var&gt;expval&lt;/var&gt; является вектором длины &lt;var&gt;m&lt;/var&gt; , элементы &lt;code&gt;0&lt;/code&gt; .. &lt;code&gt;(&lt;var&gt;m&lt;/var&gt;-1)&lt;/code&gt; th которого соответствуют &lt;var&gt;qpat1&lt;/var&gt; , &lt;var&gt;qpat2&lt;/var&gt; &amp;hellip; &lt;var&gt;qpatm&lt;/var&gt; , соответственно.</target>
        </trans-unit>
        <trans-unit id="7ae908cffb91a06454159f03a0002153cc9d96fb" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;function&lt;/var&gt; called on &lt;var&gt;expval&lt;/var&gt; returns a value that matches &lt;var&gt;pattern&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; can take one of the forms described for &lt;code&gt;pred&lt;/code&gt;, above. Unlike &lt;code&gt;pred&lt;/code&gt;, however, &lt;code&gt;app&lt;/code&gt; tests the result against &lt;var&gt;pattern&lt;/var&gt;, rather than against a boolean truth value.</source>
          <target state="translated">Срабатывает , если &lt;var&gt;function&lt;/var&gt; называется на &lt;var&gt;expval&lt;/var&gt; возвращает значение , которое соответствует &lt;var&gt;pattern&lt;/var&gt; . &lt;var&gt;function&lt;/var&gt; может принимать одну из форм, описанных выше для &lt;code&gt;pred&lt;/code&gt; . Однако, в отличие от &lt;code&gt;pred&lt;/code&gt; , &lt;code&gt;app&lt;/code&gt; проверяет результат по &lt;var&gt;pattern&lt;/var&gt; , а не по логическому значению истинности.</target>
        </trans-unit>
        <trans-unit id="739f57f309dcf068954c6199fcd5d3b33f050610" translate="yes" xml:space="preserve">
          <source>Matches if the corresponding element of &lt;var&gt;expval&lt;/var&gt; is &lt;code&gt;equal&lt;/code&gt; to the specified literal object.</source>
          <target state="translated">Похожее , если соответствующий элемент &lt;var&gt;expval&lt;/var&gt; является &lt;code&gt;equal&lt;/code&gt; по указанному буквальному объекту.</target>
        </trans-unit>
        <trans-unit id="674ff3b825d9ae7d265a12ff2ae08223fcb7d64f" translate="yes" xml:space="preserve">
          <source>Matches if the corresponding element of &lt;var&gt;expval&lt;/var&gt; matches &lt;var&gt;pattern&lt;/var&gt;. Note that &lt;var&gt;pattern&lt;/var&gt; is any kind that &lt;code&gt;pcase&lt;/code&gt; supports. (In the example above, &lt;code&gt;second-elem&lt;/code&gt; is a &lt;var&gt;symbol&lt;/var&gt; core pattern; it therefore matches anything, and let-binds &lt;code&gt;second-elem&lt;/code&gt;.)</source>
          <target state="translated">Соответствует, если соответствующий элемент &lt;var&gt;expval&lt;/var&gt; соответствует &lt;var&gt;pattern&lt;/var&gt; . Обратите внимание, что &lt;var&gt;pattern&lt;/var&gt; - это любой тип, который поддерживает &lt;code&gt;pcase&lt;/code&gt; . (В приведенном выше примере &lt;code&gt;second-elem&lt;/code&gt; является шаблоном ядра &lt;var&gt;symbol&lt;/var&gt; ; поэтому он соответствует чему угодно и let-связывает &lt;code&gt;second-elem&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="1308a03f9d82916c80a7d812b1deda28157315b6" translate="yes" xml:space="preserve">
          <source>Matches if the predicate &lt;var&gt;function&lt;/var&gt; returns non-&lt;code&gt;nil&lt;/code&gt; when called on &lt;var&gt;expval&lt;/var&gt;. the predicate &lt;var&gt;function&lt;/var&gt; can have one of the following forms:</source>
          <target state="translated">Срабатывает , если предикат &lt;var&gt;function&lt;/var&gt; возвращает не - &lt;code&gt;nil&lt;/code&gt; , когда призвали &lt;var&gt;expval&lt;/var&gt; . &lt;var&gt;function&lt;/var&gt; предиката может иметь одну из следующих форм:</target>
        </trans-unit>
        <trans-unit id="6d30d930e31b7cc8d8611f9ee7e28b703c1f1f15" translate="yes" xml:space="preserve">
          <source>Matches strings against the regexp &lt;var&gt;rx-expr&lt;/var&gt;&amp;hellip;, using the &lt;code&gt;rx&lt;/code&gt; regexp notation (see &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt;), as if by &lt;code&gt;string-match&lt;/code&gt;.</source>
          <target state="translated">Сопоставляет строки с regexp &lt;var&gt;rx-expr&lt;/var&gt; &amp;hellip;, используя нотацию &lt;code&gt;rx&lt;/code&gt; regexp (см. &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt; ), как если бы &lt;code&gt;string-match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c220368bb4219d0ac89ca454946be8bddd2829b" translate="yes" xml:space="preserve">
          <source>Matching single characters</source>
          <target state="translated">Совпадающие одиночные символы</target>
        </trans-unit>
        <trans-unit id="0c2d501ea6626d380ec030a4b996efde369c2ab2" translate="yes" xml:space="preserve">
          <source>Measuring the resources that your code uses.</source>
          <target state="translated">Измерение ресурсов,которые использует ваш код.</target>
        </trans-unit>
        <trans-unit id="03a68b7d8b854f2e082850074e2a8ddc1224e602" translate="yes" xml:space="preserve">
          <source>Memory Usage</source>
          <target state="translated">Использование памяти</target>
        </trans-unit>
        <trans-unit id="3b9c0cfb66cbc7f431d2be01c6c671bec7a34644" translate="yes" xml:space="preserve">
          <source>Menu Bar</source>
          <target state="translated">бар Меню</target>
        </trans-unit>
        <trans-unit id="16caad169ee406031f21f23e1b6301b797fa0084" translate="yes" xml:space="preserve">
          <source>Menu Example</source>
          <target state="translated">Пример меню</target>
        </trans-unit>
        <trans-unit id="b12062efe3af477059c284119d8434d41ae242a3" translate="yes" xml:space="preserve">
          <source>Menu Keymaps</source>
          <target state="translated">Клавиатуры меню</target>
        </trans-unit>
        <trans-unit id="6fb0b0290e8b0a35d56be9fedd24c4318262e46c" translate="yes" xml:space="preserve">
          <source>Menu Separators</source>
          <target state="translated">Разделители меню</target>
        </trans-unit>
        <trans-unit id="15c6cdd8a7fcc3254e0110b90d40dcb9521b5c10" translate="yes" xml:space="preserve">
          <source>Menus and the Keyboard</source>
          <target state="translated">Меню и клавиатура</target>
        </trans-unit>
        <trans-unit id="7ed3131770bb3cf28e7cdf82c3c9fbd8d687f5e1" translate="yes" xml:space="preserve">
          <source>Menus and the Mouse</source>
          <target state="translated">Меню и мышь</target>
        </trans-unit>
        <trans-unit id="c18bb98ae36a93e8052f0d6c9f161d8d49feaa19" translate="yes" xml:space="preserve">
          <source>Messages like &amp;lsquo;</source>
          <target state="translated">Сообщения типа &quot;</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="7d26ac8fefd98dd2e2239d0d83cfc7025404ed00" translate="yes" xml:space="preserve">
          <source>Meta-Character Syntax</source>
          <target state="translated">Синтаксис мета-символов</target>
        </trans-unit>
        <trans-unit id="25523a0222c9047ee4b9673f05cad4ee5f070cad" translate="yes" xml:space="preserve">
          <source>Method definitions can make use of a new argument-list keyword, &lt;code&gt;&amp;amp;context&lt;/code&gt;, which introduces extra specializers that test the environment at the time the method is run. This keyword should appear after the list of required arguments, but before any &lt;code&gt;&amp;amp;rest&lt;/code&gt; or &lt;code&gt;&amp;amp;optional&lt;/code&gt; keywords. The &lt;code&gt;&amp;amp;context&lt;/code&gt; specializers look much like regular argument specializers&amp;mdash;(&lt;var&gt;expr&lt;/var&gt;&lt;var&gt;spec&lt;/var&gt;)&amp;mdash;except that &lt;var&gt;expr&lt;/var&gt; is an expression to be evaluated in the current context, and the &lt;var&gt;spec&lt;/var&gt; is a value to compare against. For example, &lt;code&gt;&amp;amp;context (overwrite-mode (eql t))&lt;/code&gt; will make the method applicable only when &lt;code&gt;overwrite-mode&lt;/code&gt; is turned on. The &lt;code&gt;&amp;amp;context&lt;/code&gt; keyword can be followed by any number of context specializers. Because the context specializers are not part of the generic function&amp;rsquo;s argument signature, they may be omitted in methods that don&amp;rsquo;t require them.</source>
          <target state="translated">В определениях методов можно использовать новое ключевое слово списка аргументов &lt;code&gt;&amp;amp;context&lt;/code&gt; , которое вводит дополнительные специалисты, проверяющие среду во время выполнения метода. Это ключевое слово должно появиться после списка обязательных аргументов, но перед ключевыми словами &lt;code&gt;&amp;amp;rest&lt;/code&gt; или &lt;code&gt;&amp;amp;optional&lt;/code&gt; . Специализаторы &lt;code&gt;&amp;amp;context&lt;/code&gt; очень похожи на обычные специализаторы аргументов ( &lt;var&gt;expr&lt;/var&gt; &lt;var&gt;spec&lt;/var&gt; ), за исключением того, что &lt;var&gt;expr&lt;/var&gt; - это выражение, которое нужно оценить в текущем контексте, а &lt;var&gt;spec&lt;/var&gt; - это значение, с которым нужно сравнивать. Например, &lt;code&gt;&amp;amp;context (overwrite-mode (eql t))&lt;/code&gt; сделает метод применимым только тогда, когда включен &lt;code&gt;overwrite-mode&lt;/code&gt; . В &lt;code&gt;&amp;amp;context&lt;/code&gt; ключевым словом &amp;amp; context может следовать любое количество специализаторов контекста. Поскольку специализаторы контекста не являются частью сигнатуры аргумента универсальной функции, они могут быть опущены в методах, для которых они не требуются.</target>
        </trans-unit>
        <trans-unit id="3814dd76362cfffd02ba4b1937ed1c2c87e7844e" translate="yes" xml:space="preserve">
          <source>Microsoft Windows NT, 9X and later. The value of &lt;code&gt;system-type&lt;/code&gt; is always &lt;code&gt;windows-nt&lt;/code&gt;, e.g., even on Windows 10.</source>
          <target state="translated">Microsoft Windows NT, 9X и новее. Значение &lt;code&gt;system-type&lt;/code&gt; всегда &lt;code&gt;windows-nt&lt;/code&gt; , например, даже в Windows 10.</target>
        </trans-unit>
        <trans-unit id="2767e46afcc3ac1795e792eb132101e2b44c1778" translate="yes" xml:space="preserve">
          <source>Microsoft&amp;rsquo;s DOS. Emacs compiled with DJGPP for MS-DOS binds &lt;code&gt;system-type&lt;/code&gt; to &lt;code&gt;ms-dos&lt;/code&gt; even when you run it on MS-Windows.</source>
          <target state="translated">DOS от Microsoft. Emacs, скомпилированный с DJGPP для MS-DOS, привязывает &lt;code&gt;system-type&lt;/code&gt; к &lt;code&gt;ms-dos&lt;/code&gt; , даже когда вы запускаете его в MS-Windows.</target>
        </trans-unit>
        <trans-unit id="f9c9c8db7156a7448700d445deeeb649c319eb70" translate="yes" xml:space="preserve">
          <source>Minibuffer Commands</source>
          <target state="translated">Команды минибуфера</target>
        </trans-unit>
        <trans-unit id="b66e5aaaf448e820ada310fc0fc7cfcb0f0786b0" translate="yes" xml:space="preserve">
          <source>Minibuffer Commands that Do Completion</source>
          <target state="translated">Минибуфер Команды,которые делают Завершение</target>
        </trans-unit>
        <trans-unit id="6a3f154cb3d12adeba658562da192d175d080908" translate="yes" xml:space="preserve">
          <source>Minibuffer Contents</source>
          <target state="translated">Минибуфер Содержание</target>
        </trans-unit>
        <trans-unit id="c9ecc01b5e1b40232e2354f19e5d6b7647cfab66" translate="yes" xml:space="preserve">
          <source>Minibuffer History</source>
          <target state="translated">История минибуфера</target>
        </trans-unit>
        <trans-unit id="5711d65bace0facc4ca32fe822109910ac6088d3" translate="yes" xml:space="preserve">
          <source>Minibuffer Miscellany</source>
          <target state="translated">Минибуфер Мисельяны</target>
        </trans-unit>
        <trans-unit id="7af96936c990ed708387e7161673b6638521b972" translate="yes" xml:space="preserve">
          <source>Minibuffer Windows</source>
          <target state="translated">Минибуферные окна</target>
        </trans-unit>
        <trans-unit id="d3a911d1b2be32f6461ffe02d45b48c543df77a1" translate="yes" xml:space="preserve">
          <source>Minibuffer commands that do completion.</source>
          <target state="translated">Команды минибуфера,которые делают завершение.</target>
        </trans-unit>
        <trans-unit id="d54ac200a7fb55100cb14bfbd0ecda71c040d192" translate="yes" xml:space="preserve">
          <source>Minibuffer input is a special kind of recursive editing. It has a few special wrinkles, such as enabling display of the minibuffer and the minibuffer window, but fewer than you might suppose. Certain keys behave differently in the minibuffer, but that is only because of the minibuffer&amp;rsquo;s local map; if you switch windows, you get the usual Emacs commands.</source>
          <target state="translated">Ввод в минибуфер - это особый вид рекурсивного редактирования. У него есть несколько особых недостатков, таких как включение отображения минибуфера и окна минибуфера, но их меньше, чем вы можете предположить. Некоторые ключи ведут себя в минибуфере по-разному, но это только из-за локальной карты минибуфера; если вы переключаете окна, вы получаете обычные команды Emacs.</target>
        </trans-unit>
        <trans-unit id="367762892b20350b19f7bd8cd60d6489ac911db6" translate="yes" xml:space="preserve">
          <source>Minibuffers</source>
          <target state="translated">Minibuffers</target>
        </trans-unit>
        <trans-unit id="edccf3bc0f1044797feeb7318644812ec8808a04" translate="yes" xml:space="preserve">
          <source>Minibuffers and Frames</source>
          <target state="translated">Минибуфера и рамки</target>
        </trans-unit>
        <trans-unit id="a6078aaad32f5816f061d4e9117bdbc1d7ee3400" translate="yes" xml:space="preserve">
          <source>Minimum value of &lt;code&gt;hscroll&lt;/code&gt;, set by the user via &lt;code&gt;set-window-hscroll&lt;/code&gt; (see &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;Horizontal Scrolling&lt;/a&gt;). When only the current line is hscrolled, this describes the horizontal scrolling of lines other than the current one.</source>
          <target state="translated">Минимальное значение &lt;code&gt;hscroll&lt;/code&gt; , устанавливаемое пользователем через &lt;code&gt;set-window-hscroll&lt;/code&gt; (см. &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;Горизонтальная прокрутка&lt;/a&gt; ). Когда прокручивается только текущая строка, это описывает горизонтальную прокрутку строк, отличных от текущей.</target>
        </trans-unit>
        <trans-unit id="64f24a9a0dc69d512190fb4f05f76bebd963ffc9" translate="yes" xml:space="preserve">
          <source>Minor Modes</source>
          <target state="translated">Малые модели</target>
        </trans-unit>
        <trans-unit id="63be5c97e7240142a22356e2f1777fc2c8d3904a" translate="yes" xml:space="preserve">
          <source>Minor modes may bind commands to key sequences consisting of</source>
          <target state="translated">Незначительные режимы могут связывать команды с последовательностями клавиш,состоящими из</target>
        </trans-unit>
        <trans-unit id="8df431838fe5f9e1d63617cd34c66e591a88b4ec" translate="yes" xml:space="preserve">
          <source>Misc Network Facilities</source>
          <target state="translated">Сетевые объекты Майкл</target>
        </trans-unit>
        <trans-unit id="8e515a2e618367c7a4a06c28d8c1be931f8c03d1" translate="yes" xml:space="preserve">
          <source>Miscellaneous Convenience Functions for Modules</source>
          <target state="translated">Различные функции удобства для модулей</target>
        </trans-unit>
        <trans-unit id="7a052e4f76928458969464505a52746d5a78fea2" translate="yes" xml:space="preserve">
          <source>Miscellaneous Edebug Commands</source>
          <target state="translated">Различные команды по отладке</target>
        </trans-unit>
        <trans-unit id="a47827783224a9ce5dd490948eb1ebddc3b4d684" translate="yes" xml:space="preserve">
          <source>Miscellaneous Event Input Features</source>
          <target state="translated">Входные характеристики различных событий</target>
        </trans-unit>
        <trans-unit id="b29522452ab33d2ad0ba96dda015a6308c7b2c75" translate="yes" xml:space="preserve">
          <source>Miscellaneous System Events</source>
          <target state="translated">Различные системные события</target>
        </trans-unit>
        <trans-unit id="03e893e20e6aedf9fdd003184f4239c14fa31543" translate="yes" xml:space="preserve">
          <source>Miscellaneous commands.</source>
          <target state="translated">Разные команды.</target>
        </trans-unit>
        <trans-unit id="513913e8f1b8df71a57aef2147717f04b5a5ff53" translate="yes" xml:space="preserve">
          <source>Miscellaneous.</source>
          <target state="translated">Miscellaneous.</target>
        </trans-unit>
        <trans-unit id="b841515cb79574557871d33c6c685c8b786e812e" translate="yes" xml:space="preserve">
          <source>Mode Hooks</source>
          <target state="translated">Крючки режима</target>
        </trans-unit>
        <trans-unit id="1660228964a84777507d5db30661351095dda9bc" translate="yes" xml:space="preserve">
          <source>Mode Line Basics</source>
          <target state="translated">Линия режимов Основы</target>
        </trans-unit>
        <trans-unit id="92a5ca248b99dee1b2ae58ed98e940b4cbfc322d" translate="yes" xml:space="preserve">
          <source>Mode Line Format</source>
          <target state="translated">Режим Линейный формат</target>
        </trans-unit>
        <trans-unit id="1a4b9da8f1b1256a549fb046003a7eb28cd18a68" translate="yes" xml:space="preserve">
          <source>Mode line construct for miscellaneous information. By default, this shows the information specified by &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">Построение строки режима для разной информации. По умолчанию здесь отображается информация, указанная в &lt;code&gt;global-mode-string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f5b225cffab11e22dc40b6f05abef1d33d1561" translate="yes" xml:space="preserve">
          <source>Modes</source>
          <target state="translated">Modes</target>
        </trans-unit>
        <trans-unit id="72b2168254baad89e5c1ab9acb3b6040544bd8fb" translate="yes" xml:space="preserve">
          <source>Modes derived from Tabulated List mode should call this after setting the above variables (in particular, only after setting &lt;code&gt;tabulated-list-format&lt;/code&gt;).</source>
          <target state="translated">Режимы, производные от режима табличного списка, должны вызывать это после установки вышеуказанных переменных (в частности, только после установки &lt;code&gt;tabulated-list-format&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f37280f5c8b796776063d76ead3db5950069843b" translate="yes" xml:space="preserve">
          <source>Modes for program source code should set this to &lt;code&gt;left-to-right&lt;/code&gt;. Prog mode does this by default, so modes derived from Prog mode do not need to set this explicitly (see &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;).</source>
          <target state="translated">В режимах исходного кода программы следует установить значение &lt;code&gt;left-to-right&lt;/code&gt; . Режим Prog делает это по умолчанию, поэтому для режимов, производных от режима Prog, нет необходимости устанавливать это явно (см. &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Основные основные режимы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5803becd9e65746e44a5fb6727af1b147951979" translate="yes" xml:space="preserve">
          <source>Modes such as Dired and Rmail make buffers read-only when altering the contents with the usual editing commands would probably be a mistake.</source>
          <target state="translated">Такие режимы,как Dired и Rmail,делают буферы доступными только для чтения при изменении содержимого обычными командами редактирования,вероятно,будут ошибкой.</target>
        </trans-unit>
        <trans-unit id="3e0d60bdae51618466cc5411408a226c74100aa3" translate="yes" xml:space="preserve">
          <source>Modes such as Dired mode, in which the text being edited does not consist of a file&amp;rsquo;s contents but can be regenerated in some other fashion, can give this variable a buffer-local value that is a special function to regenerate the contents.</source>
          <target state="translated">Такие режимы, как режим Dired, в котором редактируемый текст не состоит из содержимого файла, а может быть регенерирован каким-либо другим способом, могут дать этой переменной локальное в буфере значение, которое является специальной функцией для восстановления содержимого.</target>
        </trans-unit>
        <trans-unit id="2a24cfeea8738c2ef8dbe6b0b8299a0d52050626" translate="yes" xml:space="preserve">
          <source>Modes that other modes are often derived from.</source>
          <target state="translated">Режимы,из которых часто извлекаются другие режимы.</target>
        </trans-unit>
        <trans-unit id="9b381b9e6c64fcffa354dbacacd2ce3c1b8c0754" translate="yes" xml:space="preserve">
          <source>Modifying Existing List Structure</source>
          <target state="translated">Изменение структуры существующего списка</target>
        </trans-unit>
        <trans-unit id="c3379a41bf4759b0d4c70d3387480936a6059e23" translate="yes" xml:space="preserve">
          <source>Modifying List Variables</source>
          <target state="translated">Переменные изменяемого списка</target>
        </trans-unit>
        <trans-unit id="df42359d215a53db6ed9a7c4b8cbe68fd027284d" translate="yes" xml:space="preserve">
          <source>Modifying Menus</source>
          <target state="translated">Меню изменения</target>
        </trans-unit>
        <trans-unit id="06b27e179bc67d2eb79dac2d1e6d2015650bd5ca" translate="yes" xml:space="preserve">
          <source>Modifying Strings</source>
          <target state="translated">Модифицирующие строки</target>
        </trans-unit>
        <trans-unit id="8e9379a55961a6ef4c12aeb1fda47c055107980d" translate="yes" xml:space="preserve">
          <source>Modifying and Translating Input Events</source>
          <target state="translated">Изменение и перевод входных событий</target>
        </trans-unit>
        <trans-unit id="0c57ccfc431bc2516e5717214f07522071c88c48" translate="yes" xml:space="preserve">
          <source>Modifying lists stored in variables.</source>
          <target state="translated">Изменение списков,хранящихся в переменных.</target>
        </trans-unit>
        <trans-unit id="0a7be6ae1c4a45d3076b49b4bc3c1a4ee48cb902" translate="yes" xml:space="preserve">
          <source>Modifying text is not allowed in a read-only buffer.</source>
          <target state="translated">Изменение текста в буфере,доступном только для чтения,запрещено.</target>
        </trans-unit>
        <trans-unit id="23f3dc3212ed2957d48473bfbcff7fdc730bbb06" translate="yes" xml:space="preserve">
          <source>Module Initialization Code</source>
          <target state="translated">Код инициализации модуля</target>
        </trans-unit>
        <trans-unit id="71d4613afbc49b703267c29c22712c23464539a5" translate="yes" xml:space="preserve">
          <source>Module functions including the &lt;code&gt;emacs_module_init&lt;/code&gt; function (see &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;module initialization function&lt;/a&gt;) may only interact with Emacs by calling environment functions from some live &lt;code&gt;emacs_env&lt;/code&gt; pointer while being called directly or indirectly from Emacs. In other words, if a module function wants to call Lisp functions or Emacs primitives, convert &lt;code&gt;emacs_value&lt;/code&gt; objects to and from C datatypes (see &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;), or interact with Emacs in any other way, some call from Emacs to &lt;code&gt;emacs_module_init&lt;/code&gt; or to a module function must be in the call stack. Module function may not interact with Emacs while garbage collection is running; see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;. They may only interact with Emacs from Lisp interpreter threads (including the main thread) created by Emacs; see &lt;a href=&quot;threads#Threads&quot;&gt;Threads&lt;/a&gt;. The</source>
          <target state="translated">Функции модуля, включая функцию &lt;code&gt;emacs_module_init&lt;/code&gt; (см. &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;Функцию инициализации модуля&lt;/a&gt; ), могут взаимодействовать с Emacs только путем вызова функций среды из некоторого &lt;code&gt;emacs_env&lt;/code&gt; указателя emacs_env, при этом они вызываются прямо или косвенно из Emacs. Другими словами, если функция модуля хочет вызывать функции Lisp или примитивы Emacs, преобразовывать объекты &lt;code&gt;emacs_value&lt;/code&gt; в типы данных C и из них (см. &lt;a href=&quot;module-values#Module-Values&quot;&gt;Значения модулей&lt;/a&gt; ) или взаимодействовать с Emacs каким-либо другим способом, некоторый вызов Emacs в &lt;code&gt;emacs_module_init&lt;/code&gt; или в модуль функция должна быть в стеке вызовов. Функция модуля может не взаимодействовать с Emacs во время сборки мусора; см. &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Сборку мусора&lt;/a&gt;. Они могут взаимодействовать с Emacs только из потоков интерпретатора Лиспа (включая основной поток), созданных Emacs; см. &lt;a href=&quot;threads#Threads&quot;&gt;Темы&lt;/a&gt; . В</target>
        </trans-unit>
        <trans-unit id="aa62ecac906e7dae2c8e2d7e79864dfd62f36887" translate="yes" xml:space="preserve">
          <source>Module functions use the type &lt;code&gt;emacs_value&lt;/code&gt; to communicate Lisp objects between Emacs and the module (see &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;). The</source>
          <target state="translated">Функции модуля используют тип &lt;code&gt;emacs_value&lt;/code&gt; для обмена объектами Lisp между Emacs и модулем (см. &lt;a href=&quot;module-values#Module-Values&quot;&gt;Значения модуля&lt;/a&gt; ). В</target>
        </trans-unit>
        <trans-unit id="53078183c7061fe0cd9edd96cc36e5ce37d0a31b" translate="yes" xml:space="preserve">
          <source>Modules can create &lt;code&gt;user-ptr&lt;/code&gt; Lisp objects that embed pointers to C struct&amp;rsquo;s defined by the module. This is useful for keeping around complex data structures created by a module, to be passed back to the module&amp;rsquo;s functions. User-ptr objects can also have associated &lt;em&gt;finalizers&lt;/em&gt; &amp;ndash; functions to be run when the object is GC&amp;rsquo;ed; this is useful for freeing any resources allocated for the underlying data structure, such as memory, open file descriptors, etc. See &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;.</source>
          <target state="translated">Модули могут создавать объекты Lisp &lt;code&gt;user-ptr&lt;/code&gt; , которые встраивают указатели на структуры C, определенные модулем. Это полезно для хранения сложных структур данных, созданных модулем, для передачи обратно функциям модуля. Объекты User-ptr также могут иметь связанные &lt;em&gt;финализаторы&lt;/em&gt; - функции, которые будут запускаться при создании объекта GC; это полезно для освобождения любых ресурсов, выделенных для базовой структуры данных, таких как память, дескрипторы открытых файлов и т. д. См. &lt;a href=&quot;module-values#Module-Values&quot;&gt;Значения модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cdaf1615e9fcf09128f766c4a11eb97589359016" translate="yes" xml:space="preserve">
          <source>Modules provide additional Lisp primitives.</source>
          <target state="translated">Модули предоставляют дополнительные примитивы Lisp.</target>
        </trans-unit>
        <trans-unit id="6ec2f205aeddb216abff070de47e318b831ed982" translate="yes" xml:space="preserve">
          <source>More commonly, a face is referred to via a &lt;em&gt;face name&lt;/em&gt;: a Lisp symbol associated with a set of face attributes&lt;a href=&quot;#FOOT22&quot; name=&quot;DOCF22&quot;&gt;&lt;sup&gt;22&lt;/sup&gt;&lt;/a&gt;. Named faces are defined using the &lt;code&gt;defface&lt;/code&gt; macro (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;). Emacs comes with several standard named faces (see &lt;a href=&quot;basic-faces#Basic-Faces&quot;&gt;Basic Faces&lt;/a&gt;).</source>
          <target state="translated">Чаще лицо упоминается через &lt;em&gt;имя лица&lt;/em&gt; : символ Лиспа, связанный с набором атрибутов лица &lt;a href=&quot;#FOOT22&quot; name=&quot;DOCF22&quot;&gt;&lt;sup&gt;22&lt;/sup&gt;&lt;/a&gt; . Именованные грани определяются с &lt;code&gt;defface&lt;/code&gt; макроса defface (см. &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Определение&lt;/a&gt; граней ). Emacs поставляется с несколькими стандартными именованными гранями (см. &lt;a href=&quot;basic-faces#Basic-Faces&quot;&gt;Основные грани&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b94de5ef15a44f90d2da93f96e38f761c889651d" translate="yes" xml:space="preserve">
          <source>More complex menu item definitions.</source>
          <target state="translated">Более сложные определения пунктов меню.</target>
        </trans-unit>
        <trans-unit id="754bbd6d917505e0487bb8bfca83939b74396492" translate="yes" xml:space="preserve">
          <source>More generally,</source>
          <target state="translated">В общем,</target>
        </trans-unit>
        <trans-unit id="d436056747a2fab716975cd61c740bc6fb24a4a3" translate="yes" xml:space="preserve">
          <source>More generally, &lt;code&gt;listname&lt;/code&gt; can be a generalized variable. In that case, this macro does the equivalent of &lt;code&gt;(setf&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;&amp;nbsp;(cons&amp;nbsp;&lt;var&gt;element&lt;/var&gt;&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;))&lt;/code&gt;. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">В более общем смысле &lt;code&gt;listname&lt;/code&gt; может быть обобщенной переменной. В этом случае этот макрос выполняет эквивалент &lt;code&gt;(setf&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;&amp;nbsp;(cons&amp;nbsp;&lt;var&gt;element&lt;/var&gt;&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;))&lt;/code&gt; . См. &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Обобщенные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55172490781de7bea7e9de094ce64599830a7212" translate="yes" xml:space="preserve">
          <source>More generally, &lt;var&gt;listname&lt;/var&gt; can be a generalized variable. In that case, this macro saves into &lt;var&gt;listname&lt;/var&gt; using &lt;code&gt;setf&lt;/code&gt;. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">В более общем смысле &lt;var&gt;listname&lt;/var&gt; может быть обобщенной переменной. В этом случае этот макрос сохраняется в &lt;var&gt;listname&lt;/var&gt; с помощью &lt;code&gt;setf&lt;/code&gt; . См. &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Обобщенные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7ab2fa4e143762f1cbf98c94412199e5e759c95" translate="yes" xml:space="preserve">
          <source>More generally, &lt;var&gt;mode-line-string&lt;/var&gt; can be any mode line construct. It appears in the mode line when the value of &lt;var&gt;minor-mode-variable&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and not otherwise. These strings should begin with spaces so that they don&amp;rsquo;t run together. Conventionally, the &lt;var&gt;minor-mode-variable&lt;/var&gt; for a specific mode is set to a non-&lt;code&gt;nil&lt;/code&gt; value when that minor mode is activated.</source>
          <target state="translated">В более общем смысле, &lt;var&gt;mode-line-string&lt;/var&gt; режима может быть любой конструкцией строки режима. Он появляется в строке режима, когда значение &lt;var&gt;minor-mode-variable&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , и не иначе. Эти строки должны начинаться с пробелов, чтобы они не сливались. Обычно &lt;var&gt;minor-mode-variable&lt;/var&gt; для определенного режима устанавливается в &lt;code&gt;nil&lt;/code&gt; значение, когда этот второстепенный режим активирован.</target>
        </trans-unit>
        <trans-unit id="759e70a01a264315afd54c72c902aa5e03d4acbc" translate="yes" xml:space="preserve">
          <source>More generally, the final argument to &lt;code&gt;append&lt;/code&gt; may be any Lisp object. The final argument is not copied or converted; it becomes the &lt;small&gt;CDR&lt;/small&gt; of the last cons cell in the new list. If the final argument is itself a list, then its elements become in effect elements of the result list. If the final element is not a list, the result is a dotted list since its final &lt;small&gt;CDR&lt;/small&gt; is not &lt;code&gt;nil&lt;/code&gt; as required in a proper list (see &lt;a href=&quot;cons-cells#Cons-Cells&quot;&gt;Cons Cells&lt;/a&gt;).</source>
          <target state="translated">В более общем смысле, последним аргументом для &lt;code&gt;append&lt;/code&gt; может быть любой объект Lisp. Последний аргумент не копируется и не конвертируется; он становится &lt;small&gt;CDR&lt;/small&gt; последней cons-ячейки в новом списке. Если последний аргумент сам по себе является списком, то его элементы становятся фактически элементами списка результатов. Если последний элемент не является списком, результатом будет список с точками, поскольку его окончательный &lt;small&gt;CDR&lt;/small&gt; не равен &lt;code&gt;nil&lt;/code&gt; как требуется в правильном списке (см. &lt;a href=&quot;cons-cells#Cons-Cells&quot;&gt;Cons Cells&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5c06fdd4f23cd4daee8d294f03b24245dc305ec4" translate="yes" xml:space="preserve">
          <source>More generally, you can use the variable &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; to control which values of the &lt;code&gt;invisible&lt;/code&gt; property make text invisible. This permits you to classify the text into different subsets in advance, by giving them different &lt;code&gt;invisible&lt;/code&gt; values, and subsequently make various subsets visible or invisible by changing the value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt;.</source>
          <target state="translated">В более общем плане вы можете использовать переменную &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; , чтобы управлять тем, какие значения свойства &lt;code&gt;invisible&lt;/code&gt; делают текст невидимым. Это позволяет вам заранее классифицировать текст на разные подмножества, давая им разные &lt;code&gt;invisible&lt;/code&gt; значения, и впоследствии делать различные подмножества видимыми или невидимыми, изменяя значение &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60a18e357538be44773938629786b367e89b0ffd" translate="yes" xml:space="preserve">
          <source>More individual control is possible by using a cons cell: In that case the frame&amp;rsquo;s width ratio is preserved if the &lt;small&gt;CAR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;width-only&lt;/code&gt;. The height ratio is preserved if the &lt;small&gt;CAR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;height-only&lt;/code&gt;. The left position ratio is preserved if the &lt;small&gt;CDR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;left-only&lt;/code&gt;. The top position ratio is preserved if the &lt;small&gt;CDR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;top-only&lt;/code&gt;.</source>
          <target state="translated">Более индивидуальное управление возможно при использовании cons-ячейки: в этом случае соотношение ширины кадра сохраняется, если &lt;small&gt;CAR&lt;/small&gt; ячейки либо &lt;code&gt;t&lt;/code&gt; , либо &lt;code&gt;width-only&lt;/code&gt; . Отношение высоты сохраняется, если &lt;small&gt;CAR&lt;/small&gt; ячейки равен &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;height-only&lt;/code&gt; . Соотношение левого положения сохраняется, если &lt;small&gt;CDR&lt;/small&gt; ячейки равен &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;left-only&lt;/code&gt; . Отношение верхней позиции сохраняется, если &lt;small&gt;CDR&lt;/small&gt; ячейки - &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;top-only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d35b8a3c91aa8470e9a099d606cc2c1c7acaba3" translate="yes" xml:space="preserve">
          <source>More precisely, we should now have a Lisp function (a lambda expression), a byte-code function, a primitive function, a Lisp macro, a special form, or an autoload object. Each of these types is a case described in one of the following sections. If the object is not one of these types, Emacs signals an &lt;code&gt;invalid-function&lt;/code&gt; error.</source>
          <target state="translated">Точнее, теперь у нас должна быть функция Lisp (лямбда-выражение), функция байтового кода, примитивная функция, макрос Lisp, специальная форма или объект автозагрузки. Каждый из этих типов описывается в одном из следующих разделов. Если объект не относится к одному из этих типов, Emacs сигнализирует об ошибке &lt;code&gt;invalid-function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d1907fa94271e60953cb92c6af32f80577dca2a" translate="yes" xml:space="preserve">
          <source>Most Emacs Lisp file-manipulation functions get errors when used on files that are directories. For example, you cannot delete a directory with &lt;code&gt;delete-file&lt;/code&gt;. These special functions exist to create and delete directories.</source>
          <target state="translated">Большинство функций Emacs Lisp для работы с файлами выдают ошибки при использовании с файлами, которые являются каталогами. Например, вы не можете удалить каталог с помощью &lt;code&gt;delete-file&lt;/code&gt; . Эти специальные функции существуют для создания и удаления каталогов.</target>
        </trans-unit>
        <trans-unit id="09eed349899d3e99c3026461a2438ccf55662d6f" translate="yes" xml:space="preserve">
          <source>Most Emacs commands can use a &lt;em&gt;prefix argument&lt;/em&gt;, a number specified before the command itself. (Don&amp;rsquo;t confuse prefix arguments with prefix keys.) The prefix argument is at all times represented by a value, which may be &lt;code&gt;nil&lt;/code&gt;, meaning there is currently no prefix argument. Each command may use the prefix argument or ignore it.</source>
          <target state="translated">Большинство команд Emacs могут использовать &lt;em&gt;префиксный аргумент&lt;/em&gt; - число, указанное перед самой командой. (Не путайте аргументы префикса с ключами префикса.) Аргумент префикса всегда представлен значением, которое может быть &lt;code&gt;nil&lt;/code&gt; , что означает, что в настоящее время аргумент префикса отсутствует. Каждая команда может использовать аргумент префикса или игнорировать его.</target>
        </trans-unit>
        <trans-unit id="964d2f546749ab746319cf9bf92a58945c9983a6" translate="yes" xml:space="preserve">
          <source>Most Lisp code should not use this macro; &lt;code&gt;save-selected-window&lt;/code&gt; is typically sufficient. In particular, this macro cannot reliably prevent the code in &lt;var&gt;forms&lt;/var&gt; from opening new windows, because new windows might be opened in other frames (see &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;), and &lt;code&gt;save-window-excursion&lt;/code&gt; only saves and restores the window configuration on the current frame.</source>
          <target state="translated">Большая часть кода на Лиспе не должна использовать этот макрос; &lt;code&gt;save-selected-window&lt;/code&gt; обычно достаточно. В частности, этот макрос не может надежно предотвратить открытие новых окон кодом в &lt;var&gt;forms&lt;/var&gt; , потому что новые окна могут открываться в других фреймах (см. &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Выбор окна&lt;/a&gt; ), а &lt;code&gt;save-window-excursion&lt;/code&gt; сохраняет и восстанавливает конфигурацию окна только в текущем фрейме.</target>
        </trans-unit>
        <trans-unit id="fe2ae73f5ba28b3bd7e0ab7c9daa9a827c4bf56e" translate="yes" xml:space="preserve">
          <source>Most applications should not use recursive editing, except as part of using the minibuffer. Usually it is more convenient for the user if you change the major mode of the current buffer temporarily to a special major mode, which should have a command to go back to the previous mode. (The</source>
          <target state="translated">Большинство приложений не должны использовать рекурсивное редактирование,кроме как в рамках использования минибуфера.Обычно пользователю удобнее сменить мажорный режим текущего буфера на специальный мажорный режим,в котором должна быть команда на возврат в предыдущий режим.(The</target>
        </trans-unit>
        <trans-unit id="1eaf100a3aafa712a449e3207bf7cabe96c9c0ab" translate="yes" xml:space="preserve">
          <source>Most buffers have an &lt;em&gt;undo list&lt;/em&gt;, which records all changes made to the buffer&amp;rsquo;s text so that they can be undone. (The buffers that don&amp;rsquo;t have one are usually special-purpose buffers for which Emacs assumes that undoing is not useful. In particular, any buffer whose name begins with a space has its undo recording off by default; see &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;.) All the primitives that modify the text in the buffer automatically add elements to the front of the undo list, which is in the variable &lt;code&gt;buffer-undo-list&lt;/code&gt;.</source>
          <target state="translated">Большинство буферов имеют &lt;em&gt;список отмены&lt;/em&gt; , в котором записываются все изменения, внесенные в текст буфера, чтобы их можно было отменить. (Буферы, у которых его нет, обычно являются буферами специального назначения, для которых Emacs предполагает, что отмена не нужна. В частности, для любого буфера, имя которого начинается с пробела, по умолчанию отключена запись отмены; см. &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Имена&lt;/a&gt; буферов .) Все. примитивы, которые изменяют текст в буфере, автоматически добавляют элементы в начало списка отмены, который находится в переменной &lt;code&gt;buffer-undo-list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6dcfcc1ab586c7c06232994a3f579a591ce8d2a" translate="yes" xml:space="preserve">
          <source>Most control constructs affect only the flow of control within the construct itself. The function &lt;code&gt;throw&lt;/code&gt; is the exception to this rule of normal program execution: it performs a nonlocal exit on request. (There are other exceptions, but they are for error handling only.) &lt;code&gt;throw&lt;/code&gt; is used inside a &lt;code&gt;catch&lt;/code&gt;, and jumps back to that &lt;code&gt;catch&lt;/code&gt;. For example:</source>
          <target state="translated">Большинство управляющих конструкций влияют только на поток управления внутри самой конструкции. Функция &lt;code&gt;throw&lt;/code&gt; является исключением из этого правила нормального выполнения программы: она выполняет нелокальный выход по запросу. (Есть и другие исключения, но они предназначены только для обработки ошибок.) &lt;code&gt;throw&lt;/code&gt; используется внутри &lt;code&gt;catch&lt;/code&gt; и переходит к этому &lt;code&gt;catch&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="72373bc3f93b6102b1ff980fc9edb816c70fbcbd" translate="yes" xml:space="preserve">
          <source>Most errors are signaled automatically within Lisp primitives which you call for other purposes, such as if you try to take the &lt;small&gt;CAR&lt;/small&gt; of an integer or move forward a character at the end of the buffer. You can also signal errors explicitly with the functions &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt;.</source>
          <target state="translated">Большинство ошибок выдается автоматически в примитивах Лиспа, которые вы вызываете для других целей, например, если вы пытаетесь взять &lt;small&gt;CAR&lt;/small&gt; целого числа или переместить вперед символ в конце буфера. Вы также можете явно сигнализировать об ошибках с помощью функций &lt;code&gt;error&lt;/code&gt; и &lt;code&gt;signal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="266fa78b8886478b8a397f099e61b861826a3118" translate="yes" xml:space="preserve">
          <source>Most keyboards also have &lt;em&gt;function keys&lt;/em&gt;&amp;mdash;keys that have names or symbols that are not characters. Function keys are represented in Emacs Lisp as symbols; the symbol&amp;rsquo;s name is the function key&amp;rsquo;s label, in lower case. For example, pressing a key labeled</source>
          <target state="translated">На большинстве клавиатур также есть &lt;em&gt;функциональные клавиши - клавиши&lt;/em&gt; с именами или символами, не являющимися символами. Функциональные клавиши представлены в Emacs Lisp как символы; имя символа - это подпись функциональной клавиши в нижнем регистре. Например, нажатие клавиши с надписью</target>
        </trans-unit>
        <trans-unit id="9f00659321a54a5b7e744a95bacbe846e1ba78fa" translate="yes" xml:space="preserve">
          <source>Most minor modes implement features that are independent of the major mode, and can thus be used with most major modes. For example, Auto Fill mode works with any major mode that permits text insertion. A few minor modes, however, are specific to a particular major mode. For example, Diff Auto Refine mode is a minor mode that is intended to be used only with Diff mode.</source>
          <target state="translated">Большинство второстепенных режимов реализуют функции,не зависящие от основного режима,и,таким образом,могут использоваться с большинством основных режимов.Например,режим Автозаполнение работает с любым основным режимом,допускающим вставку текста.Несколько второстепенных режимов,однако,специфичны для конкретного основного режима.Например,Дифф-режим автозаполнения является минорным режимом,который предназначен для использования только с Дифф-режимом.</target>
        </trans-unit>
        <trans-unit id="c397a5c428cdfab905c1bb14033fe204e686e090" translate="yes" xml:space="preserve">
          <source>Most needs are satisfied by these two ways that backtracking is automatically disabled, but occasionally it is useful to explicitly disable backtracking by using the &lt;code&gt;gate&lt;/code&gt; specification. This is useful when you know that no higher alternatives could apply. See the example of the &lt;code&gt;let&lt;/code&gt; specification.</source>
          <target state="translated">Большинство потребностей удовлетворяются этими двумя способами автоматического отключения отслеживания с возвратом, но иногда полезно явно отключить отслеживание с возвратом с помощью спецификации &lt;code&gt;gate&lt;/code&gt; . Это полезно, когда вы знаете, что альтернативы более высокого уровня не применимы. См. Пример спецификации &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc4ca8d6208ffb0d4a36e05a18b9c69498324dc6" translate="yes" xml:space="preserve">
          <source>Most of the Lisp functions for reading text take an &lt;em&gt;input stream&lt;/em&gt; as an argument. The input stream specifies where or how to get the characters of the text to be read. Here are the possible types of input stream:</source>
          <target state="translated">Большинство функций Lisp для чтения текста принимают &lt;em&gt;входной поток&lt;/em&gt; в качестве аргумента. Входной поток указывает, где и как получить символы текста для чтения. Вот возможные типы входного потока:</target>
        </trans-unit>
        <trans-unit id="f7fb5ab8ace2fa15e51d35ce50aee4d936080390" translate="yes" xml:space="preserve">
          <source>Most of the commands in this section return values that are not meaningful. All the functions that do filling take note of the current left margin, current right margin, and current justification style (see &lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;). If the current justification style is &lt;code&gt;none&lt;/code&gt;, the filling functions don&amp;rsquo;t actually do anything.</source>
          <target state="translated">Большинство команд в этом разделе возвращают значения, которые не имеют смысла. Все функции, выполняющие заливку, принимают во внимание текущее левое поле, текущее правое поле и текущий стиль выравнивания (см. &lt;a href=&quot;margins#Margins&quot;&gt;Поля&lt;/a&gt; ). Если текущий стиль выравнивания - &lt;code&gt;none&lt;/code&gt; , функции заполнения фактически ничего не делают.</target>
        </trans-unit>
        <trans-unit id="cbad2a18a2d91f80015c7e2ea18ca8a1aab103fa" translate="yes" xml:space="preserve">
          <source>Most of the functions below take a name and sometimes an obarray as arguments. A &lt;code&gt;wrong-type-argument&lt;/code&gt; error is signaled if the name is not a string, or if the obarray is not a vector.</source>
          <target state="translated">Большинство функций, представленных ниже, принимают в качестве аргументов имя, а иногда и массив. Ошибка &lt;code&gt;wrong-type-argument&lt;/code&gt; сигнализируется, если имя не является строкой или если объектный массив не является вектором.</target>
        </trans-unit>
        <trans-unit id="68726f32511ba6a9522b1792a27d11825f7b4a12" translate="yes" xml:space="preserve">
          <source>Most of the functions described below became available in Emacs 25, the first Emacs release that supported dynamic modules. For the few functions that became available in later Emacs releases, we mention the first Emacs version that supported them.</source>
          <target state="translated">Большинство функций,описанных ниже,стали доступны в Emacs 25,первом релизе Emacs,который поддерживал динамические модули.Для тех немногих функций,которые стали доступны в более поздних релизах Emacs,мы упоминаем первую версию Emacs,которая их поддерживала.</target>
        </trans-unit>
        <trans-unit id="b3d67ad5f3eb4dfd9ab8ef87986f724f3ad34348" translate="yes" xml:space="preserve">
          <source>Most of the hooks in Emacs are &lt;em&gt;normal hooks&lt;/em&gt;. These variables contain lists of functions to be called with no arguments. By convention, whenever the hook name ends in &amp;lsquo;</source>
          <target state="translated">Большинство хуков в Emacs - это &lt;em&gt;обычные хуки&lt;/em&gt; . Эти переменные содержат списки функций, которые нужно вызывать без аргументов. По соглашению, когда имя крючка заканчивается на '</target>
        </trans-unit>
        <trans-unit id="fbcca09d8ca07315a2c9111b156bdf457cc5150a" translate="yes" xml:space="preserve">
          <source>Most of the kill commands are primarily for interactive use, and are not described here. What we do describe are the functions provided for use in writing such commands. You can use these functions to write commands for killing text. When you need to delete text for internal purposes within a Lisp function, you should normally use deletion functions, so as not to disturb the kill ring contents. See &lt;a href=&quot;deletion#Deletion&quot;&gt;Deletion&lt;/a&gt;.</source>
          <target state="translated">Большинство команд уничтожения предназначены в основном для интерактивного использования и здесь не описываются. Мы описываем функции, предназначенные для написания таких команд. Вы можете использовать эти функции для написания команд для уничтожения текста. Когда вам нужно удалить текст для внутренних целей в функции Lisp, вы обычно должны использовать функции удаления, чтобы не нарушать содержимое кольца уничтожения. См. &lt;a href=&quot;deletion#Deletion&quot;&gt;Удаление&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc3c2124fc3bae720b8252b979a43c48fb44d9b9" translate="yes" xml:space="preserve">
          <source>Most of the time, functions are called when their names are written in Lisp expressions in Lisp programs. However, you can construct or obtain a function object at run time and then call it with the primitive functions &lt;code&gt;funcall&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;. See &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;Calling Functions&lt;/a&gt;.</source>
          <target state="translated">В большинстве случаев функции вызываются, когда их имена записаны в выражениях Лиспа в программах на Лиспе. Однако вы можете создать или получить объект функции во время выполнения, а затем вызвать его с помощью примитивных функций &lt;code&gt;funcall&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; . См. &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;Вызов функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad2a15ba084ba8bc4aa18e87ac5aa225a45b1c5d" translate="yes" xml:space="preserve">
          <source>Most of the time, it&amp;rsquo;s not useful to distinguish the two. So normally &lt;code&gt;local-function-key-map&lt;/code&gt; (see &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;) is set up to map &lt;code&gt;tab&lt;/code&gt; into 9. Thus, a key binding for character code 9 (the character</source>
          <target state="translated">В большинстве случаев различать их нецелесообразно. Таким образом, обычно &lt;code&gt;local-function-key-map&lt;/code&gt; (см. &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Таблицы клавиш перевода&lt;/a&gt; ) настраивается для отображения &lt;code&gt;tab&lt;/code&gt; в 9. Таким образом, привязка клавиш для кода символа 9 (символ</target>
        </trans-unit>
        <trans-unit id="abe6f1d63c7f88d045c5b31ba7795c4ed74c53bd" translate="yes" xml:space="preserve">
          <source>Most of these error symbols are defined in C (mainly</source>
          <target state="translated">Большинство этих символов ошибок определены в C (в основном</target>
        </trans-unit>
        <trans-unit id="49da26863e7f22566b2cf4a25068c25f6cd2d052" translate="yes" xml:space="preserve">
          <source>Most of these variables have names ending with &amp;lsquo;</source>
          <target state="translated">Большинство этих переменных имеют имена, оканчивающиеся на '</target>
        </trans-unit>
        <trans-unit id="9c4e0cce8a81ef3708db9a9d44182e2b8fe94a9d" translate="yes" xml:space="preserve">
          <source>Most often, forms are evaluated automatically, by virtue of their occurrence in a program being run. On rare occasions, you may need to write code that evaluates a form that is computed at run time, such as after reading a form from text being edited or getting one from a property list. On these occasions, use the &lt;code&gt;eval&lt;/code&gt; function. Often &lt;code&gt;eval&lt;/code&gt; is not needed and something else should be used instead. For example, to get the value of a variable, while &lt;code&gt;eval&lt;/code&gt; works, &lt;code&gt;symbol-value&lt;/code&gt; is preferable; or rather than store expressions in a property list that then need to go through &lt;code&gt;eval&lt;/code&gt;, it is better to store functions instead that are then passed to &lt;code&gt;funcall&lt;/code&gt;.</source>
          <target state="translated">Чаще всего формы оцениваются автоматически в силу их появления в выполняемой программе. В редких случаях может потребоваться написать код, оценивающий форму, вычисляемую во время выполнения, например, после чтения формы из редактируемого текста или получения формы из списка свойств. В этих случаях используйте функцию &lt;code&gt;eval&lt;/code&gt; . Часто &lt;code&gt;eval&lt;/code&gt; не нужен, и вместо него нужно использовать что-то другое. Например, чтобы получить значение переменной, пока работает &lt;code&gt;eval&lt;/code&gt; , предпочтительнее использовать &lt;code&gt;symbol-value&lt;/code&gt; ; или вместо того, чтобы сохранять выражения в списке свойств, которые затем должны пройти через &lt;code&gt;eval&lt;/code&gt; , лучше вместо этого хранить функции, которые затем передаются в &lt;code&gt;funcall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa3d06d22c97d444806afc27e617f43b0ad086a7" translate="yes" xml:space="preserve">
          <source>Most often, the &lt;var&gt;types&lt;/var&gt; in a &lt;code&gt;set&lt;/code&gt; are &lt;code&gt;const&lt;/code&gt; types, as shown here:</source>
          <target state="translated">Чаще всего &lt;var&gt;types&lt;/var&gt; в &lt;code&gt;set&lt;/code&gt; являются &lt;code&gt;const&lt;/code&gt; типами, как показано здесь:</target>
        </trans-unit>
        <trans-unit id="2104b44b9ba0cc9d20b66b199ac691005bd0bed2" translate="yes" xml:space="preserve">
          <source>Most uses of &lt;code&gt;eval-and-compile&lt;/code&gt; are fairly sophisticated.</source>
          <target state="translated">Большинство &lt;code&gt;eval-and-compile&lt;/code&gt; использования eval-and-compile довольно изощренны.</target>
        </trans-unit>
        <trans-unit id="81869f1759c2b1872ff235184d70faf9f4fd2d64" translate="yes" xml:space="preserve">
          <source>Most window systems use a desktop metaphor. Part of this metaphor is the idea that system-level windows (representing, e.g., Emacs frames) are stacked in a notional third dimension perpendicular to the screen surface. The order induced by stacking is total and usually referred to as stacking (or Z-) order. Where the areas of two windows overlap, the one higher up in that order will (partially) cover the one underneath.</source>
          <target state="translated">Большинство оконных систем используют метафору рабочего стола.Частью этой метафоры является идея о том,что окна системного уровня (представляющие,например,рамки Emacs)укладываются в условное третье измерение,перпендикулярное поверхности экрана.Порядок,вызываемый штабелированием,является полным и обычно называется порядком штабелирования (или Z-).Если области двух окон перекрываются,то вышестоящее в этом порядке окно будет (частично)перекрывать находящееся под ним окно.</target>
        </trans-unit>
        <trans-unit id="0a9fbf9f714ce6a3a5ea4ced3ed7f3d62099211d" translate="yes" xml:space="preserve">
          <source>Most window-systems clip a child frame at the native edges (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) of its parent frame&amp;mdash;everything outside these edges is usually invisible. A child frame&amp;rsquo;s &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; parameters specify a position relative to the top-left corner of its parent&amp;rsquo;s native frame. When the parent frame is resized, this position remains conceptually unaltered.</source>
          <target state="translated">Большинство оконных систем обрезают дочерний фрейм по родным краям (см. &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Геометрия фрейма&lt;/a&gt; ) его родительского фрейма - все за пределами этих краев обычно невидимо. Параметры &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;top&lt;/code&gt; дочернего фрейма определяют положение относительно левого верхнего угла собственного фрейма его родителя. Когда размер родительского фрейма изменяется, это положение концептуально остается неизменным.</target>
        </trans-unit>
        <trans-unit id="852329adec48160b733c7ed9efcc2bd1ea539df5" translate="yes" xml:space="preserve">
          <source>Mostly, however, this function is called automatically at an appropriate time.</source>
          <target state="translated">Однако в большинстве случаев эта функция вызывается автоматически в соответствующее время.</target>
        </trans-unit>
        <trans-unit id="e040db2b7f1361a938099464de9858040e353ddb" translate="yes" xml:space="preserve">
          <source>Motion</source>
          <target state="translated">Motion</target>
        </trans-unit>
        <trans-unit id="4c333f9eac917041de2dbe5d4e12612fb84fb008" translate="yes" xml:space="preserve">
          <source>Motion Commands Based on Parsing</source>
          <target state="translated">Команды движения на основе парсинга</target>
        </trans-unit>
        <trans-unit id="e8a12b0b4cf9966d415d89a1d69b08c8352f976f" translate="yes" xml:space="preserve">
          <source>Motion Events</source>
          <target state="translated">События движения</target>
        </trans-unit>
        <trans-unit id="91315d6877510cf4da5e405826b3221c94135c3e" translate="yes" xml:space="preserve">
          <source>Motion and Syntax</source>
          <target state="translated">Движение и синтаксис</target>
        </trans-unit>
        <trans-unit id="e092df3cd889f7ec86f740980f392f5d6e8af02e" translate="yes" xml:space="preserve">
          <source>Motion by Characters</source>
          <target state="translated">Движение по персонажам</target>
        </trans-unit>
        <trans-unit id="d2ce7e2f90144ab22f36527dc8781160c756549d" translate="yes" xml:space="preserve">
          <source>Motion by Screen Lines</source>
          <target state="translated">Движение по линиям экрана</target>
        </trans-unit>
        <trans-unit id="4dce4bd28a86b1ce27d0bd612a7561462c7cc60b" translate="yes" xml:space="preserve">
          <source>Motion by Text Lines</source>
          <target state="translated">Движение по текстовым линиям</target>
        </trans-unit>
        <trans-unit id="2d29ecb574b2bce083871d9d9c13f5b680f74abd" translate="yes" xml:space="preserve">
          <source>Motion by Words</source>
          <target state="translated">Движение словами</target>
        </trans-unit>
        <trans-unit id="633150abc226c78ac7b073c2e31944ab3ddd0ae8" translate="yes" xml:space="preserve">
          <source>Motion functions change the value of point, either relative to the current value of point, relative to the beginning or end of the buffer, or relative to the edges of the selected window. See &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;.</source>
          <target state="translated">Функции движения изменяют значение точки относительно текущего значения точки, относительно начала или конца буфера или относительно краев выбранного окна. См. &lt;a href=&quot;point#Point&quot;&gt;Пункт&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="013a79eacf73d8474d69b249a7fcb74f3bc7d072" translate="yes" xml:space="preserve">
          <source>Motion functions that work by parsing.</source>
          <target state="translated">Функции движения,которые работают по разбору.</target>
        </trans-unit>
        <trans-unit id="37802ebb8eb19a12e9b66522e9d801b5abfc80a9" translate="yes" xml:space="preserve">
          <source>Motion to an End of the Buffer</source>
          <target state="translated">Ходатайство о конце буфера</target>
        </trans-unit>
        <trans-unit id="48637a9a84940dbd837461865518bd9300ca2cf2" translate="yes" xml:space="preserve">
          <source>Mouse Dragging Parameters</source>
          <target state="translated">Параметры перетаскивания мыши</target>
        </trans-unit>
        <trans-unit id="b239ecd4f1b125963a812db57dc3cec60573502b" translate="yes" xml:space="preserve">
          <source>Mouse Events</source>
          <target state="translated">Мышей События</target>
        </trans-unit>
        <trans-unit id="99a6a713af3081ea16c4b4ba861aeaea079ffefd" translate="yes" xml:space="preserve">
          <source>Mouse Position</source>
          <target state="translated">Положение мыши</target>
        </trans-unit>
        <trans-unit id="c15f4049211f898d49c97d76dd71469c52292f33" translate="yes" xml:space="preserve">
          <source>Mouse Tracking</source>
          <target state="translated">Отслеживание мыши</target>
        </trans-unit>
        <trans-unit id="4a803cb0d07554c2f9f3761b9162a772b63c4e18" translate="yes" xml:space="preserve">
          <source>Mouse Window Auto-selection</source>
          <target state="translated">Автоматический выбор окна мыши</target>
        </trans-unit>
        <trans-unit id="f47c56f8e3df66caa71e2d0ce49ed9adb3c1a9bd" translate="yes" xml:space="preserve">
          <source>Mouse auto-selection can be used to emulate a focus follows mouse policy for child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) which usually are not tracked by the window manager. This requires to set the value of &lt;code&gt;focus-follows-mouse&lt;/code&gt; (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;) to a non-&lt;code&gt;nil&lt;/code&gt; value. If the value of &lt;code&gt;focus-follows-mouse&lt;/code&gt; is &lt;code&gt;auto-raise&lt;/code&gt;, entering a child frame with the mouse will raise it automatically above all other child frames of that frame&amp;rsquo;s parent frame.</source>
          <target state="translated">Автоматический выбор мыши можно использовать для имитации фокуса в соответствии с политикой мыши для дочерних фреймов (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ), которые обычно не отслеживаются оконным менеджером. Для этого необходимо установить значение &lt;code&gt;focus-follows-mouse&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Фокус ввода&amp;raquo;&lt;/a&gt; ) на значение, отличное от &lt;code&gt;nil&lt;/code&gt; . Если значение &lt;code&gt;focus-follows-mouse&lt;/code&gt; является &lt;code&gt;auto-raise&lt;/code&gt; , входя в детскую рамку с помощью мыши поднимет его автоматически выше всех других дочерних фреймов родительского фрейма этого фрейма.</target>
        </trans-unit>
        <trans-unit id="2df64335cf98c72ba6ba9a9e8bb30c7f288e379f" translate="yes" xml:space="preserve">
          <source>Mouse auto-selection selects the minibuffer window only if it is active, and never deselects the active minibuffer window.</source>
          <target state="translated">Мышь автоматически выбирает окно минибуфера только в том случае,если оно активно,и никогда не снимает выделение с активного окна минибуфера.</target>
        </trans-unit>
        <trans-unit id="e56ccfe134223b80437e24ef8272e7c77b397941" translate="yes" xml:space="preserve">
          <source>Move back to the previous place that a question was asked about.</source>
          <target state="translated">Вернись на прежнее место,о котором был задан вопрос.</target>
        </trans-unit>
        <trans-unit id="fcfc1a5d81c2fd67d3d58302e0edda1d94a48c17" translate="yes" xml:space="preserve">
          <source>Move point back to the current stop point in the source code buffer (&lt;code&gt;edebug-where&lt;/code&gt;).</source>
          <target state="translated">Переместите точку обратно в текущую точку остановки в буфере исходного кода ( &lt;code&gt;edebug-where&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e8011edd1eeb2660ed2ab6bdc47c4b387b009944" translate="yes" xml:space="preserve">
          <source>Move point to &lt;var&gt;limit&lt;/var&gt; (or the end of the accessible portion of the buffer) and return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Переместите точку на &lt;var&gt;limit&lt;/var&gt; (или конец доступной части буфера) и верните &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97b7fff41223832602e81589fc86fce13dac6227" translate="yes" xml:space="preserve">
          <source>Move point to the next breakpoint in the current definition (&lt;code&gt;edebug-next-breakpoint&lt;/code&gt;).</source>
          <target state="translated">Переместите точку к следующей точке останова в текущем определении ( &lt;code&gt;edebug-next-breakpoint&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ef08217195a398b9b9595051fd75d3bbcfe68238" translate="yes" xml:space="preserve">
          <source>Move the pen to the first point in &lt;var&gt;points&lt;/var&gt;. Additional points are connected with lines. &lt;var&gt;points&lt;/var&gt; is a list of X/Y coordinate pairs. Subsequent &lt;code&gt;moveto&lt;/code&gt; commands represent the start of a new &lt;em&gt;subpath&lt;/em&gt;.</source>
          <target state="translated">Переместите перо в первую точку в &lt;var&gt;points&lt;/var&gt; . Дополнительные точки соединяются линиями. &lt;var&gt;points&lt;/var&gt; - это список пар координат X / Y. Последующие команды &lt;code&gt;moveto&lt;/code&gt; представляют собой начало нового &lt;em&gt;подпути&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f66eccc892556cafb6abe680c2768bcdf1cc6f5c" translate="yes" xml:space="preserve">
          <source>Move to first non-blank character.</source>
          <target state="translated">Переходим к первому непустому символу.</target>
        </trans-unit>
        <trans-unit id="77f061b9a5f55737090245a4c987a501fd31859d" translate="yes" xml:space="preserve">
          <source>Move to the &lt;var&gt;n&lt;/var&gt;th next button, or &lt;var&gt;n&lt;/var&gt;th previous button if &lt;var&gt;n&lt;/var&gt; is negative. If &lt;var&gt;n&lt;/var&gt; is zero, move to the start of any button at point. If &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, moving past either end of the buffer continues from the other end. If &lt;var&gt;display-message&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the button&amp;rsquo;s help-echo string is displayed. Any button with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;skip&lt;/code&gt; property is skipped over. Returns the button found, and signals an error if no buttons can be found. If &lt;var&gt;no-error&lt;/var&gt; in non-&lt;code&gt;nil&lt;/code&gt;, return nil instead of signaling the error.</source>
          <target state="translated">Переход к &lt;var&gt;n&lt;/var&gt; - й следующей кнопке или &lt;var&gt;n&lt;/var&gt; - й предыдущей кнопке, если &lt;var&gt;n&lt;/var&gt; отрицательное. Если &lt;var&gt;n&lt;/var&gt; равно нулю, перейти к началу любой кнопки в точке. Если &lt;var&gt;wrap&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , перемещение за любой конец буфера продолжается с другого конца. Если &lt;var&gt;display-message&lt;/var&gt; не &lt;code&gt;nil&lt;/code&gt; , отображается строка help-echo кнопки. Любая кнопка с непостоянной &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;skip&lt;/code&gt; собственности пропускается. Возвращает найденную кнопку и сигнализирует об ошибке, если кнопки не могут быть найдены. Если &lt;var&gt;no-error&lt;/var&gt; в ненулевом &lt;code&gt;nil&lt;/code&gt; , вернуть nil вместо сообщения об ошибке.</target>
        </trans-unit>
        <trans-unit id="43a8000e954824d989286ea299c734a6c7cfc47e" translate="yes" xml:space="preserve">
          <source>Move to the &lt;var&gt;n&lt;/var&gt;th previous button, or &lt;var&gt;n&lt;/var&gt;th next button if &lt;var&gt;n&lt;/var&gt; is negative. If &lt;var&gt;n&lt;/var&gt; is zero, move to the start of any button at point. If &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, moving past either end of the buffer continues from the other end. If &lt;var&gt;display-message&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the button&amp;rsquo;s help-echo string is displayed. Any button with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;skip&lt;/code&gt; property is skipped over. Returns the button found, and signals an error if no buttons can be found. If &lt;var&gt;no-error&lt;/var&gt; in non-&lt;code&gt;nil&lt;/code&gt;, return nil instead of signaling the error.</source>
          <target state="translated">Переход к &lt;var&gt;n&lt;/var&gt; - ой предыдущей кнопке или &lt;var&gt;n&lt;/var&gt; - ой следующей кнопке, если &lt;var&gt;n&lt;/var&gt; отрицательное. Если &lt;var&gt;n&lt;/var&gt; равно нулю, перейти к началу любой кнопки в точке. Если &lt;var&gt;wrap&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , перемещение за любой конец буфера продолжается с другого конца. Если &lt;var&gt;display-message&lt;/var&gt; не &lt;code&gt;nil&lt;/code&gt; , отображается строка help-echo кнопки. Любая кнопка с непостоянной &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;skip&lt;/code&gt; собственности пропускается. Возвращает найденную кнопку и сигнализирует об ошибке, если кнопки не могут быть найдены. Если &lt;var&gt;no-error&lt;/var&gt; в ненулевом &lt;code&gt;nil&lt;/code&gt; , вернуть nil вместо сообщения об ошибке.</target>
        </trans-unit>
        <trans-unit id="82c00742d33b45dc4a64242477e55b1102b66060" translate="yes" xml:space="preserve">
          <source>Move to the beginning of the frame, or to the beginning of the previous frame.</source>
          <target state="translated">Переместитесь в начало кадра или в начало предыдущего кадра.</target>
        </trans-unit>
        <trans-unit id="f893b5353d62ff9e12c35b7fb0f50fcaa8318d21" translate="yes" xml:space="preserve">
          <source>Move to the beginning of the next frame.</source>
          <target state="translated">Переходите к началу следующего кадра.</target>
        </trans-unit>
        <trans-unit id="f297af264dbf0d0932fcc470cbe1fecf16841cb6" translate="yes" xml:space="preserve">
          <source>Moving Marker Positions</source>
          <target state="translated">Перемещение позиции маркера</target>
        </trans-unit>
        <trans-unit id="0bd65246c05a2e512da13871350157d560493acf" translate="yes" xml:space="preserve">
          <source>Moving around the existing windows.</source>
          <target state="translated">Перемещение по существующим окнам.</target>
        </trans-unit>
        <trans-unit id="2450710a86f0e38a5a79572127c7c737f5ad650e" translate="yes" xml:space="preserve">
          <source>Moving by parsing lists and sexps.</source>
          <target state="translated">Перемещение по разбору списков и секс-списков.</target>
        </trans-unit>
        <trans-unit id="bcf6a5cad29fb42b7bcbea23a358b3e4f0f14190" translate="yes" xml:space="preserve">
          <source>Moving in terms of characters.</source>
          <target state="translated">Двигаться в терминах персонажей.</target>
        </trans-unit>
        <trans-unit id="5a0a7594babae65e9fe76da6d52f721490d43cae" translate="yes" xml:space="preserve">
          <source>Moving in terms of lines as displayed.</source>
          <target state="translated">Перемещение в терминах строк,как показано на рисунке.</target>
        </trans-unit>
        <trans-unit id="13133c035ed058b88d7defb0074a4f22a2f70555" translate="yes" xml:space="preserve">
          <source>Moving in terms of lines of text.</source>
          <target state="translated">Перемещение в терминах строк текста.</target>
        </trans-unit>
        <trans-unit id="26b889272e175455d666cb66239aca23e15df9b4" translate="yes" xml:space="preserve">
          <source>Moving in terms of words.</source>
          <target state="translated">Двигаясь в терминах слов.</target>
        </trans-unit>
        <trans-unit id="53e7a90c8dae3998834ecec2913e2cd430599962" translate="yes" xml:space="preserve">
          <source>Moving over Balanced Expressions</source>
          <target state="translated">Перемещение по сбалансированным выражениям</target>
        </trans-unit>
        <trans-unit id="8693a264fbf00aa36cb635bdd23ca472a4fefbca" translate="yes" xml:space="preserve">
          <source>Moving over characters with certain syntaxes.</source>
          <target state="translated">Перемещение по персонажам с определенным синтаксисом.</target>
        </trans-unit>
        <trans-unit id="042aaa586f3cf81580cc5e1f174b18fabcc9a6c1" translate="yes" xml:space="preserve">
          <source>Moving text up and down through the window.</source>
          <target state="translated">Перемещение текста вверх и вниз через окно.</target>
        </trans-unit>
        <trans-unit id="e0d03b42d9316b69bb4bfb00e411362bd9b92f0d" translate="yes" xml:space="preserve">
          <source>Moving the contents sideways on the window.</source>
          <target state="translated">Перемещение содержимого в сторону окна.</target>
        </trans-unit>
        <trans-unit id="16062acc29ac83c08f815d725d13ca53166d371d" translate="yes" xml:space="preserve">
          <source>Moving the contents up and down on the window.</source>
          <target state="translated">Перемещение содержимого вверх и вниз по окну.</target>
        </trans-unit>
        <trans-unit id="7d1c895a6a69bb551cb3ab05a9436825b15affd7" translate="yes" xml:space="preserve">
          <source>Moving the marker to a new buffer or position.</source>
          <target state="translated">Перемещение маркера в новый буфер или в новую позицию.</target>
        </trans-unit>
        <trans-unit id="ef6300d4905ba5885914045db1c0057a8e7f4297" translate="yes" xml:space="preserve">
          <source>Moving the mouse before releasing the button.</source>
          <target state="translated">Перемещение мыши перед отпусканием кнопки.</target>
        </trans-unit>
        <trans-unit id="96d5ebfd5d41e3ac266699afa4c07f17d42dc6a2" translate="yes" xml:space="preserve">
          <source>Moving the mouse between frames.</source>
          <target state="translated">Перемещение мыши между кадрами.</target>
        </trans-unit>
        <trans-unit id="1a17774ff24591b3f0339a2975566bc3052acf2a" translate="yes" xml:space="preserve">
          <source>Moving to the beginning or end of the buffer.</source>
          <target state="translated">Перемещение в начало или конец буфера.</target>
        </trans-unit>
        <trans-unit id="6bc8df29048775edb3b67797f960add5fb20f24e" translate="yes" xml:space="preserve">
          <source>Multi-Frame Images</source>
          <target state="translated">Многокадровые изображения</target>
        </trans-unit>
        <trans-unit id="075c17f7c3e017a54cdac2a44040577e98923617" translate="yes" xml:space="preserve">
          <source>Multi-file Packages</source>
          <target state="translated">Многофайловые пакеты</target>
        </trans-unit>
        <trans-unit id="5dd969976c5aa3ebe5d20441de8bf258343ebb9c" translate="yes" xml:space="preserve">
          <source>Multiline Font Lock Constructs</source>
          <target state="translated">Многострочные конструкции шрифтовых замков</target>
        </trans-unit>
        <trans-unit id="850c8a0b5e9ff569211d95d52d7ed685c25d8241" translate="yes" xml:space="preserve">
          <source>Multiple Terminals</source>
          <target state="translated">Несколько терминалов</target>
        </trans-unit>
        <trans-unit id="0b79f8e4890c8608e67c29a1e344d765772f2753" translate="yes" xml:space="preserve">
          <source>Mutability</source>
          <target state="translated">Mutability</target>
        </trans-unit>
        <trans-unit id="ad5e52be06b8d534aed54257f0dbf7aa8ff2ec03" translate="yes" xml:space="preserve">
          <source>Mutex Type</source>
          <target state="translated">Тип Мутекса</target>
        </trans-unit>
        <trans-unit id="dd060da851122b430bf0f99b458f73ce7b008e14" translate="yes" xml:space="preserve">
          <source>Mutex objects have no read syntax. They print in hash notation, giving the name of the mutex (if it has been given a name) or its address in core:</source>
          <target state="translated">Объекты мьютекса не имеют синтаксиса для чтения.Они печатают в хэш-нотации,указывая имя мьютекса (если ему было дано имя)или его адрес в ядре:</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5255835bbfa8722501d3084e2ba916530d5a554c" translate="yes" xml:space="preserve">
          <source>Mutexes allow exclusive access to data.</source>
          <target state="translated">Мутексы обеспечивают эксклюзивный доступ к данным.</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="ad4ff2f947bcd2ef0dc89fd3a7ca83591ba37e18" translate="yes" xml:space="preserve">
          <source>NS builds consider the tool bar to be a decoration, and therefore hide it on an undecorated frame.</source>
          <target state="translated">NS конструкторы считают инструментальную панель декоративным элементом и поэтому прячут ее на недекорированной раме.</target>
        </trans-unit>
        <trans-unit id="e97a54619a408647abe8729216664f6e3b8d47e9" translate="yes" xml:space="preserve">
          <source>NS builds do not clip child frames at the parent frame&amp;rsquo;s edges, allowing them to be positioned so they do not obscure the parent frame while still being visible themselves.</source>
          <target state="translated">Сборки NS не обрезают дочерние фреймы по краям родительского фрейма, что позволяет им размещать их так, чтобы они не закрывали родительский фрейм, оставаясь при этом видимыми сами по себе.</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="93ba4abc16637fa77fe2aca725d91f288b90cfbb" translate="yes" xml:space="preserve">
          <source>NaCl</source>
          <target state="translated">NaCl</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="33b8ab26e443037c1b6a008d5daac383b918372d" translate="yes" xml:space="preserve">
          <source>Name of the physical monitor as &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">Имя физического монитора в виде &lt;var&gt;string&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="33fc3e5c2e89aacc9b50f1169d442c12bb23fe2c" translate="yes" xml:space="preserve">
          <source>Naming Backup Files</source>
          <target state="translated">Именование резервных копий файлов</target>
        </trans-unit>
        <trans-unit id="e93d31d911fab1a3e2aba574d0e113197a0b7e55" translate="yes" xml:space="preserve">
          <source>Naming a Function</source>
          <target state="translated">Наименование функции</target>
        </trans-unit>
        <trans-unit id="697edbe4acd10b9466b672837ee81bd016c23b79" translate="yes" xml:space="preserve">
          <source>Narrow</source>
          <target state="translated">Narrow</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="ba453f44e68e8506ff49aa121453956a2b98d6dd" translate="yes" xml:space="preserve">
          <source>Narrowing is specified with two buffer positions, which become the beginning and end of the accessible portion. For most editing commands and primitives, these positions replace the values of the beginning and end of the buffer. While narrowing is in effect, no text outside the accessible portion is displayed, and point cannot move outside the accessible portion. Note that narrowing does not alter actual buffer positions (see &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;); it only determines which positions are considered the accessible portion of the buffer. Most functions refuse to operate on text that is outside the accessible portion.</source>
          <target state="translated">Сужение определяется двумя буферными позициями, которые становятся началом и концом доступной части. Для большинства команд редактирования и примитивов эти позиции заменяют значения начала и конца буфера. Пока действует сужение, текст за пределами доступной части не отображается, и точка не может перемещаться за пределы доступной части. Обратите внимание, что сужение не меняет фактических позиций буфера (см. &lt;a href=&quot;point#Point&quot;&gt;Пункт&lt;/a&gt; ); он только определяет, какие позиции считаются доступной частью буфера. Большинство функций отказываются работать с текстом, находящимся за пределами доступной части.</target>
        </trans-unit>
        <trans-unit id="7bdf9620ee53a876bad1749f32c91f0860d2de5f" translate="yes" xml:space="preserve">
          <source>Native Frame</source>
          <target state="translated">коренная система</target>
        </trans-unit>
        <trans-unit id="bd2f2298f83f47b01df37aff3486ab3d7c655bdf" translate="yes" xml:space="preserve">
          <source>Naturally, Emacs will never signal &lt;code&gt;new-error&lt;/code&gt; on its own; only an explicit call to &lt;code&gt;signal&lt;/code&gt; (see &lt;a href=&quot;signaling-errors#Definition-of-signal&quot;&gt;Definition of signal&lt;/a&gt;) in your code can do this:</source>
          <target state="translated">Естественно, Emacs никогда не будет сигнализировать о &lt;code&gt;new-error&lt;/code&gt; по себе; только явный вызов &lt;code&gt;signal&lt;/code&gt; (см. &lt;a href=&quot;signaling-errors#Definition-of-signal&quot;&gt;Определение сигнала&lt;/a&gt; ) в вашем коде может сделать это:</target>
        </trans-unit>
        <trans-unit id="3d596b97b9719e1805fb3852fa7a7684551f102c" translate="yes" xml:space="preserve">
          <source>Negative parameter values position the right edge of the outer frame by &lt;var&gt;-x&lt;/var&gt; pixels left from the right edge of the screen (or the parent frame&amp;rsquo;s native rectangle) and the bottom edge by &lt;var&gt;-y&lt;/var&gt; pixels up from the bottom edge of the screen (or the parent frame&amp;rsquo;s native rectangle).</source>
          <target state="translated">Отрицательные значения параметров позиционируют правый край внешнего кадра на &lt;var&gt;-x&lt;/var&gt; пикселей слева от правого края экрана (или собственного прямоугольника родительского кадра), а нижний край на &lt;var&gt;-y&lt;/var&gt; пикселей вверх от нижнего края экрана (или собственный прямоугольник родительского фрейма).</target>
        </trans-unit>
        <trans-unit id="5806a4fdd1b51a9d2dde88f7b0063ac5bf8c2a79" translate="yes" xml:space="preserve">
          <source>Negative values never indicate an offset from the right or bottom edge of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display or parent frame. Rather, they mean that &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s outer position is on the left and/or above the origin of its display or the native position of its parent frame. This usually means that &lt;var&gt;frame&lt;/var&gt; is only partially visible (or completely invisible). However, on systems where the display&amp;rsquo;s origin does not coincide with its top-left corner, the frame may be visible on a secondary monitor.</source>
          <target state="translated">Отрицательные значения не указывает на смещение от правого или нижнего края &lt;var&gt;frame&lt;/var&gt; дисплея &amp;laquo;s или родительском фрейме. Скорее, они означают, что внешнее положение &lt;var&gt;frame&lt;/var&gt; находится слева и / или над исходной точкой его отображения или исходной позицией его родительского кадра. Обычно это означает, что &lt;var&gt;frame&lt;/var&gt; видна только частично (или полностью невидима). Однако в системах, где исходная точка дисплея не совпадает с его верхним левым углом, рамка может быть видна на дополнительном мониторе.</target>
        </trans-unit>
        <trans-unit id="50f671274ba560467341410034be03976b38330e" translate="yes" xml:space="preserve">
          <source>Nested association lists is supported:</source>
          <target state="translated">Поддерживаются списки вложенных ассоциаций:</target>
        </trans-unit>
        <trans-unit id="c347c211993fddc45bd180abc87a138a590651c8" translate="yes" xml:space="preserve">
          <source>Nested use of several change groups for the same buffer works as you would expect. Non-nested use of change groups for the same buffer will get Emacs confused, so don&amp;rsquo;t let it happen; the first change group you start for any given buffer should be the last one finished.</source>
          <target state="translated">Вложенное использование нескольких групп изменений для одного и того же буфера работает, как и следовало ожидать. Использование невложенных групп изменений для одного и того же буфера запутает Emacs, так что не позволяйте этому случиться; первая группа изменений, которую вы запускаете для любого заданного буфера, должна быть последней завершенной.</target>
        </trans-unit>
        <trans-unit id="d179e139906d2dd2f78172ff8723394a1290a6a3" translate="yes" xml:space="preserve">
          <source>Nesting &lt;code&gt;let-alist&lt;/code&gt; inside each other is allowed, but the code in the inner &lt;code&gt;let-alist&lt;/code&gt; can&amp;rsquo;t access the variables bound by the outer &lt;code&gt;let-alist&lt;/code&gt;.</source>
          <target state="translated">Вложение &lt;code&gt;let-alist&lt;/code&gt; друг в друга допускается, но код во внутреннем &lt;code&gt;let-alist&lt;/code&gt; не может получить доступ к переменным, связанным внешним &lt;code&gt;let-alist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4512de22f11934fdb81d9289bb39ac4b395feae" translate="yes" xml:space="preserve">
          <source>Network Connections</source>
          <target state="translated">Сетевые подключения</target>
        </trans-unit>
        <trans-unit id="1a2ceca984e39b172fda21e503d83194676acb77" translate="yes" xml:space="preserve">
          <source>Network Options</source>
          <target state="translated">Опции сети</target>
        </trans-unit>
        <trans-unit id="92a0a91f7ea484b5d2e0caa0572673102ce764e4" translate="yes" xml:space="preserve">
          <source>Network Servers</source>
          <target state="translated">Сетевые серверы</target>
        </trans-unit>
        <trans-unit id="5e5da2cd3c810a62709e4258b89df7da017dd9e1" translate="yes" xml:space="preserve">
          <source>Network access</source>
          <target state="translated">Доступ к сетям</target>
        </trans-unit>
        <trans-unit id="4db16d13f459789c5e4f3a0b0eb58ac0b72836a4" translate="yes" xml:space="preserve">
          <source>Network connections and servers are created by calling &lt;code&gt;make-network-process&lt;/code&gt; with an argument list consisting of keyword/argument pairs, for example &lt;code&gt;:server t&lt;/code&gt; to create a server process, or &lt;code&gt;:type 'datagram&lt;/code&gt; to create a datagram connection. See &lt;a href=&quot;low_002dlevel-network#Low_002dLevel-Network&quot;&gt;Low-Level Network&lt;/a&gt;, for details. You can also use the &lt;code&gt;open-network-stream&lt;/code&gt; function described below.</source>
          <target state="translated">Сетевые соединения и серверы создаются путем вызова &lt;code&gt;make-network-process&lt;/code&gt; со списком аргументов, состоящим из пар ключевое слово / аргумент, например &lt;code&gt;:server t&lt;/code&gt; для создания серверного процесса или &lt;code&gt;:type 'datagram&lt;/code&gt; для создания датаграммного соединения. См. Подробности в разделе &amp;laquo; &lt;a href=&quot;low_002dlevel-network#Low_002dLevel-Network&quot;&gt;Сеть низкого уровня&amp;raquo;&lt;/a&gt; . Вы также можете использовать функцию &lt;code&gt;open-network-stream&lt;/code&gt; описанную ниже.</target>
        </trans-unit>
        <trans-unit id="03c2b7b3aa6dd8790276a40fdff32df5fbd4ba6e" translate="yes" xml:space="preserve">
          <source>Network servers let Emacs accept net connections.</source>
          <target state="translated">Сетевые серверы позволяют Emacs принимать сетевые соединения.</target>
        </trans-unit>
        <trans-unit id="f7f37df5443218422ad6ebd50122d98556ecefca" translate="yes" xml:space="preserve">
          <source>Never add an autoload &lt;em&gt;comment&lt;/em&gt; to silence a compiler warning in another file. In the file that produces the warning, use &lt;code&gt;(defvar foo)&lt;/code&gt; to silence an undefined variable warning, and &lt;code&gt;declare-function&lt;/code&gt; (see &lt;a href=&quot;declaring-functions#Declaring-Functions&quot;&gt;Declaring Functions&lt;/a&gt;) to silence an undefined function warning; or require the relevant library; or use an explicit autoload &lt;em&gt;statement&lt;/em&gt;.</source>
          <target state="translated">Никогда не добавляйте &lt;em&gt;комментарий&lt;/em&gt; автозагрузки, чтобы отключить предупреждение компилятора в другом файле. В файле, который генерирует предупреждение, используйте &lt;code&gt;(defvar foo)&lt;/code&gt; , чтобы отключить предупреждение о неопределенной переменной, и &lt;code&gt;declare-function&lt;/code&gt; (см. &lt;a href=&quot;declaring-functions#Declaring-Functions&quot;&gt;Объявление функций&lt;/a&gt; ), чтобы отключить предупреждение о неопределенной функции; или потребовать соответствующую библиотеку; или используйте явный &lt;em&gt;оператор&lt;/em&gt; автозагрузки .</target>
        </trans-unit>
        <trans-unit id="9c2964759b06a2623b93cf7c65f17e2ef21aa268" translate="yes" xml:space="preserve">
          <source>Next in precedence are keymaps specified by enabled minor modes. These keymaps, if any, are specified by the variables &lt;code&gt;emulation-mode-map-alists&lt;/code&gt;, &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt;, and &lt;code&gt;minor-mode-map-alist&lt;/code&gt;. See &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;.</source>
          <target state="translated">Следующими по приоритету идут раскладки, заданные включенными второстепенными режимами. Эти раскладки клавиатуры, если есть, задаются переменными &lt;code&gt;emulation-mode-map-alists&lt;/code&gt; , &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; и &lt;code&gt;minor-mode-map-alist&lt;/code&gt; . См. &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Управление активными картами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf11fa80110f5add1f6e8df89357b576825e8423" translate="yes" xml:space="preserve">
          <source>Next in precedence is the buffer&amp;rsquo;s &lt;em&gt;local keymap&lt;/em&gt;, containing key bindings specific to the buffer. The minibuffer also has a local keymap (see &lt;a href=&quot;intro-to-minibuffers#Intro-to-Minibuffers&quot;&gt;Intro to Minibuffers&lt;/a&gt;). If there is a &lt;code&gt;local-map&lt;/code&gt; text or overlay property at point, that specifies the local keymap to use, in place of the buffer&amp;rsquo;s default local keymap.</source>
          <target state="translated">Следующим по приоритету идет &lt;em&gt;локальная таблица&lt;/em&gt; ключей буфера , содержащая привязки клавиш, специфичные для буфера. Минибуфер также имеет локальную &lt;a href=&quot;intro-to-minibuffers#Intro-to-Minibuffers&quot;&gt;раскладку клавиш&lt;/a&gt; (см. Введение в минибуферы ). Если в точке есть текст &lt;code&gt;local-map&lt;/code&gt; или свойство наложения, которое определяет используемую локальную карту клавиш вместо локальной карты клавиш по умолчанию для буфера.</target>
        </trans-unit>
        <trans-unit id="ea6e9f5900f2c58fe85d30179802bd1c82319521" translate="yes" xml:space="preserve">
          <source>Next to every menu bar item, Emacs displays a key binding that runs the same command (if such a key binding exists). This serves as a convenient hint for users who do not know the key binding. If a command has multiple bindings, Emacs normally displays the first one it finds. You can specify one particular key binding by assigning an &lt;code&gt;:advertised-binding&lt;/code&gt; symbol property to the command. See &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;.</source>
          <target state="translated">Рядом с каждым элементом строки меню Emacs отображает привязку клавиш, которая запускает ту же команду (если такая привязка клавиш существует). Это служит удобной подсказкой для пользователей, которые не знают привязки клавиш. Если команда имеет несколько привязок, Emacs обычно отображает первую найденную. Вы можете указать одну конкретную привязку клавиш, назначив команде свойство символа &lt;code&gt;:advertised-binding&lt;/code&gt; . См. &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Ключи в документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27f58e46bfcfa765f0350cd6b6821ef674d81fef" translate="yes" xml:space="preserve">
          <source>Next we define the menu items:</source>
          <target state="translated">Далее мы определяем пункты меню:</target>
        </trans-unit>
        <trans-unit id="71ae8da1cccbc9f22418d39bfa80cb8b8749d267" translate="yes" xml:space="preserve">
          <source>Next, Emacs adds any extra load directories that you specify using the</source>
          <target state="translated">Далее Emacs добавляет любые дополнительные каталоги загрузки,которые вы указываете с помощью параметра</target>
        </trans-unit>
        <trans-unit id="d62380513230c1ed3241e1f5ee2099ae36407b91" translate="yes" xml:space="preserve">
          <source>Next, we call &lt;code&gt;(split-window W3 nil 'left)&lt;/code&gt;, passing the internal window &lt;var&gt;W3&lt;/var&gt; as the argument. The result:</source>
          <target state="translated">Затем мы вызываем &lt;code&gt;(split-window W3 nil 'left)&lt;/code&gt; , передавая внутреннее окно &lt;var&gt;W3&lt;/var&gt; в качестве аргумента. Результат:</target>
        </trans-unit>
        <trans-unit id="b961cdbb90d8271bcd99e03aa14df9f662fda815" translate="yes" xml:space="preserve">
          <source>Next, write an initialization function for the module.</source>
          <target state="translated">Далее напишите функцию инициализации для модуля.</target>
        </trans-unit>
        <trans-unit id="e71dbb9278b56b980f41278b5bdbd5ad829743eb" translate="yes" xml:space="preserve">
          <source>Next: stop at the next stop point encountered after an expression (&lt;code&gt;edebug-next-mode&lt;/code&gt;). Also see &lt;code&gt;edebug-forward-sexp&lt;/code&gt; in &lt;a href=&quot;jumping#Jumping&quot;&gt;Jumping&lt;/a&gt;.</source>
          <target state="translated">Далее: остановиться в следующей точке остановки, обнаруженной после выражения ( &lt;code&gt;edebug-next-mode&lt;/code&gt; ). Также см. &lt;code&gt;edebug-forward-sexp&lt;/code&gt; в &lt;a href=&quot;jumping#Jumping&quot;&gt;Прыжки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e86fd1a5ff5402fe649662053b5f46f96ea16c3" translate="yes" xml:space="preserve">
          <source>No argument is matched but backtracking through the gate is disabled while matching the remainder of the specifications at this level. This is primarily used to generate more specific syntax error messages. See &lt;a href=&quot;backtracking#Backtracking&quot;&gt;Backtracking&lt;/a&gt;, for more details. Also see the &lt;code&gt;let&lt;/code&gt; example.</source>
          <target state="translated">Никакой аргумент не сопоставлен, но обратное отслеживание через шлюз отключено при сопоставлении остальных спецификаций на этом уровне. В основном это используется для создания более конкретных сообщений об ошибках синтаксиса. См. &lt;a href=&quot;backtracking#Backtracking&quot;&gt;Обратный поиск&lt;/a&gt; , для более подробной информации. Также см. Пример &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cadafbd2e7190a2f1d2b8eedb1454e2868f07a2" translate="yes" xml:space="preserve">
          <source>No catch for tag</source>
          <target state="translated">Нет подвоха для бирки</target>
        </trans-unit>
        <trans-unit id="bbeb07f8bf2d7e3c732cf8947945435e8e59adfe" translate="yes" xml:space="preserve">
          <source>No obarray contains all symbols; in fact, some symbols are not in any obarray. They are called &lt;em&gt;uninterned symbols&lt;/em&gt;. An uninterned symbol has the same four cells as other symbols; however, the only way to gain access to it is by finding it in some other object or as the value of a variable.</source>
          <target state="translated">Никакой obarray не содержит всех символов; на самом деле некоторые символы не находятся ни в каком массиве. Их называют &lt;em&gt;неинтернированными символами&lt;/em&gt; . Неинтернированный символ имеет те же четыре ячейки, что и другие символы; однако единственный способ получить к нему доступ - найти его в каком-либо другом объекте или в качестве значения переменной.</target>
        </trans-unit>
        <trans-unit id="8838111d4610c90296b30fc380a23778ca2a7a0e" translate="yes" xml:space="preserve">
          <source>No text is inserted.</source>
          <target state="translated">Текст не вставлен.</target>
        </trans-unit>
        <trans-unit id="de830dc532a97e327dc9112b349772dda4316853" translate="yes" xml:space="preserve">
          <source>Non-</source>
          <target state="translated">Non-</target>
        </trans-unit>
        <trans-unit id="dd3e47873c08c1cbf08bc18047d3d358e469fc94" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if IPv6 is supported.</source>
          <target state="translated">Non- &lt;code&gt;nil&lt;/code&gt; , если IPv6 поддерживается.</target>
        </trans-unit>
        <trans-unit id="c137cc4db2df7f4be1c8cd466be3bbfbab527f39" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if datagrams are supported.</source>
          <target state="translated">Non- &lt;code&gt;nil&lt;/code&gt; , если дейтаграммы поддерживаются.</target>
        </trans-unit>
        <trans-unit id="85ba9cd318b20fd143c7eef7c3f80b8dac2a20df" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if inside a string. More precisely, this is the character that will terminate the string, or &lt;code&gt;t&lt;/code&gt; if a generic string delimiter character should terminate it.</source>
          <target state="translated">Non- &lt;code&gt;nil&lt;/code&gt; , если внутри строки. Точнее, это символ, который завершает строку, или &lt;code&gt;t&lt;/code&gt; , если общий символ-разделитель строки должен завершать ее.</target>
        </trans-unit>
        <trans-unit id="9c329207815f864cfe40c306c4b2308f01044b65" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if local (a.k.a. &amp;ldquo;UNIX domain&amp;rdquo;) sockets are supported.</source>
          <target state="translated">Non- &lt;code&gt;nil&lt;/code&gt; , если местный ( так называемый &amp;laquo;домен UNIX&amp;raquo;) сокет.</target>
        </trans-unit>
        <trans-unit id="5b4d81358027d2cd5d76892ec114515c0d94000f" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if non-blocking connect is supported.</source>
          <target state="translated">Non- &lt;code&gt;nil&lt;/code&gt; , если не блокирующие подключения поддерживается.</target>
        </trans-unit>
        <trans-unit id="6a0195fbc2801af663ba0ec5723eebf901180bde" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if the system can select the port for a server.</source>
          <target state="translated">Non- &lt;code&gt;nil&lt;/code&gt; , если система может выбрать порт для сервера.</target>
        </trans-unit>
        <trans-unit id="298a4e63bde074768d01508f47e1e3a7d52b639a" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if this window is dedicated to its buffer.</source>
          <target state="translated">Non- &lt;code&gt;nil&lt;/code&gt; , если это окно посвящено в буфер.</target>
        </trans-unit>
        <trans-unit id="2d45527490c53e7bb3fcf4095792dbed717b907d" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; means current value of &lt;code&gt;start&lt;/code&gt; was the beginning of a line when it was chosen.</source>
          <target state="translated">Номера для &lt;code&gt;nil&lt;/code&gt; означает , что текущее значение &lt;code&gt;start&lt;/code&gt; было начало строки , когда она была выбрана.</target>
        </trans-unit>
        <trans-unit id="97e7e8cff888f916fc069faab013939aece0c530" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; means that regular expression matching for the sake of &lt;code&gt;font-lock-keywords&lt;/code&gt; should be case-insensitive.</source>
          <target state="translated">ОТСУТСТВИЯ &lt;code&gt;nil&lt;/code&gt; означает , что регулярное выражение для &lt;code&gt;font-lock-keywords&lt;/code&gt; должно быть чувствителен к регистру.</target>
        </trans-unit>
        <trans-unit id="17f14e42cfe6c0c5fa4278037593c1cf2a9f7e46" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;region-noncontiguous-p&lt;/var&gt; means that the region between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; is composed of noncontiguous pieces. The most common example of this is a rectangular region, where the pieces are separated by newline characters.</source>
          <target state="translated">Непро- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;region-noncontiguous-p&lt;/var&gt; означает , что область между &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; состоит из несмежных частей. Самый распространенный пример - прямоугольная область, где части разделены символами новой строки.</target>
        </trans-unit>
        <trans-unit id="5d29f2d794a4e41245bc116e7d56afd0854763f8" translate="yes" xml:space="preserve">
          <source>Non-ASCII Characters</source>
          <target state="translated">Не-ASCII Персонажи</target>
        </trans-unit>
        <trans-unit id="9a1964e6f1fd92781e6b1f5855e1a8b90a085deb" translate="yes" xml:space="preserve">
          <source>Non-ASCII Characters in Strings</source>
          <target state="translated">Не-ASCII-символы в строках</target>
        </trans-unit>
        <trans-unit id="ee03ca40fe0fddf419289b00e54d3e235f27f181" translate="yes" xml:space="preserve">
          <source>Non-ASCII text in buffers and strings.</source>
          <target state="translated">Не-ASCII текст в буферах и строках.</target>
        </trans-unit>
        <trans-unit id="6371bd35cb6aae61f199a61590cfd0399446eef8" translate="yes" xml:space="preserve">
          <source>Non-ASCII text written to the standard output or error descriptors is by default encoded using &lt;code&gt;locale-coding-system&lt;/code&gt; (see &lt;a href=&quot;locales#Locales&quot;&gt;Locales&lt;/a&gt;) if it is non-&lt;code&gt;nil&lt;/code&gt;; this can be overridden by binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a coding system of you choice (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;).</source>
          <target state="translated">Текст, отличный от ASCII, записываемый в стандартный вывод или дескрипторы ошибок, по умолчанию кодируется с использованием &lt;code&gt;locale-coding-system&lt;/code&gt; (см. &lt;a href=&quot;locales#Locales&quot;&gt;Локали&lt;/a&gt; ), если он не равен &lt;code&gt;nil&lt;/code&gt; ; это можно изменить, &lt;code&gt;coding-system-for-write&lt;/code&gt; к выбранной вами системе кодирования (см. &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Явное кодирование&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f9dde119327e925337a2b9bade0b26729d73142" translate="yes" xml:space="preserve">
          <source>Non-constant variables whose value can &lt;em&gt;not&lt;/em&gt; be an arbitrary Lisp object.</source>
          <target state="translated">Непостоянные переменные, значение которых &lt;em&gt;не&lt;/em&gt; может быть произвольным объектом Lisp.</target>
        </trans-unit>
        <trans-unit id="ba5ac4c4b4eca5c161d4957f66dd2e8e98dbac8b" translate="yes" xml:space="preserve">
          <source>Non-printing control flag. When it is used, other specifiers must be given in the order of decreasing size, i.e., years before days, hours before minutes, etc. Nothing will be produced in the result string to the left of &amp;lsquo;</source>
          <target state="translated">Контрольный флаг непечатаемого изображения. Когда он используется, другие спецификаторы должны быть указаны в порядке уменьшения размера, т. Е. Годы перед днями, часы перед минутами и т. Д. В строке результата слева от '</target>
        </trans-unit>
        <trans-unit id="0978c4a08e7aa3c2e4530a665830e83fac749d6d" translate="yes" xml:space="preserve">
          <source>Non-zero if communication with the subprocess uses a pty; zero if it uses a pipe.</source>
          <target state="translated">Нулевой,если связь с подпроцессом использует pty;нулевой,если используется труба.</target>
        </trans-unit>
        <trans-unit id="5f22d5c13ab24217b6cce33d3adbd30e573e6278" translate="yes" xml:space="preserve">
          <source>Non-zero if this window is a &lt;em&gt;pseudo window&lt;/em&gt;. A pseudo window is either a window used to display the menu bar or the tool bar (when Emacs uses toolkits that don&amp;rsquo;t display their own menu bar and tool bar) or the tab bar or a window showing a tooltip on a tooltip frame. Pseudo windows are in general not accessible from Lisp code.</source>
          <target state="translated">Ненулевое значение, если это окно является &lt;em&gt;псевдоокном&lt;/em&gt; . Псевдоокно - это либо окно, используемое для отображения строки меню или панели инструментов (когда Emacs использует наборы инструментов, которые не отображают свою собственную строку меню и панель инструментов), либо панель вкладок, либо окно, показывающее всплывающую подсказку во фрейме всплывающей подсказки. Псевдоокна обычно недоступны из кода Lisp.</target>
        </trans-unit>
        <trans-unit id="54314d871cb31d9ea8c00c7bd36602724ec562af" translate="yes" xml:space="preserve">
          <source>Non-zero if this window is a minibuffer window, a window showing the minibuffer or the echo area.</source>
          <target state="translated">Ненулевое,если это окно является окном минибуфера,окном,показывающим минибуфер или область эха.</target>
        </trans-unit>
        <trans-unit id="0ba1c3d1e346952de45a35d971ea7bad1bf252e0" translate="yes" xml:space="preserve">
          <source>Non-zero means the cursor in this window is logically off. This is used for blinking the cursor.</source>
          <target state="translated">Ненулевой означает,что курсор в этом окне логически выключен.Это используется для мигания курсора.</target>
        </trans-unit>
        <trans-unit id="16075a3db57978fdbecdd0a45ee972e34d651059" translate="yes" xml:space="preserve">
          <source>Non-zero means this window&amp;rsquo;s mode line needs to be updated.</source>
          <target state="translated">Ненулевое значение означает, что строку режима этого окна необходимо обновить.</target>
        </trans-unit>
        <trans-unit id="71fab370af08ad66d6e2717a8c670408d7a79d19" translate="yes" xml:space="preserve">
          <source>None of the above functions suppress quitting.</source>
          <target state="translated">Ни одна из вышеперечисленных функций не подавляет завершение работы.</target>
        </trans-unit>
        <trans-unit id="9bfc03cabd4be3ad4520d8a6d451463b5aa1986e" translate="yes" xml:space="preserve">
          <source>None of the arguments is instrumented.</source>
          <target state="translated">Ни один из аргументов не озвучен.</target>
        </trans-unit>
        <trans-unit id="2df251e672be89a4e3f1f02e5d89d7600b0e8d4d" translate="yes" xml:space="preserve">
          <source>None of these three functions will make a frame smaller than needed to display all of its windows together with their scroll bars, fringes, margins, dividers, mode and header lines. This contrasts with requests by the window manager triggered, for example, by dragging the external border of a frame with the mouse. Such requests are always honored by clipping, if necessary, portions that cannot be displayed at the right, bottom corner of the frame. The parameters &lt;code&gt;min-width&lt;/code&gt; and &lt;code&gt;min-height&lt;/code&gt; (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) can be used to obtain a similar behavior when changing the frame size from within Emacs.</source>
          <target state="translated">Ни одна из этих трех функций не сделает фрейм меньше, чем необходимо для отображения всех его окон вместе с их полосами прокрутки, полосами, полями, разделителями, режимом и строками заголовка. Это контрастирует с запросами оконного менеджера, инициируемыми, например, перетаскиванием внешней границы фрейма мышью. Такие запросы всегда выполняются путем отсечения, если необходимо, частей, которые не могут быть отображены в правом нижнем углу кадра. Параметры &lt;code&gt;min-width&lt;/code&gt; и &lt;code&gt;min-height&lt;/code&gt; (см. &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Параметры размера&lt;/a&gt; ) могут использоваться для получения аналогичного поведения при изменении размера кадра из Emacs.</target>
        </trans-unit>
        <trans-unit id="a13391618a7eb550b931b1ca7f5e7dea3f609549" translate="yes" xml:space="preserve">
          <source>Nonlocal Exits</source>
          <target state="translated">Неместные выходы</target>
        </trans-unit>
        <trans-unit id="04cfa77523068f9d99f2dadfb2d56696bd61d7b4" translate="yes" xml:space="preserve">
          <source>Nonlocal Exits in Modules</source>
          <target state="translated">Нелокальные выходы в модулях</target>
        </trans-unit>
        <trans-unit id="989a5aecc184b93ecbd769ecbad5acdea9c400aa" translate="yes" xml:space="preserve">
          <source>Nonlocal exits for the program&amp;rsquo;s own purposes.</source>
          <target state="translated">Нелокальные выходы для собственных целей.</target>
        </trans-unit>
        <trans-unit id="9fd8001fd6d82a32c9adc0fec8386196b8416cea" translate="yes" xml:space="preserve">
          <source>Nonprinting Characters in Strings</source>
          <target state="translated">Символы в строках без печати</target>
        </trans-unit>
        <trans-unit id="f8770b24b50ea318a926e10ce75d22b10fca1574" translate="yes" xml:space="preserve">
          <source>Normally all the elements are markers or &lt;code&gt;nil&lt;/code&gt;, but if &lt;var&gt;integers&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means to use integers instead of markers. (In that case, the buffer itself is appended as an additional element at the end of the list, to facilitate complete restoration of the match data.) If the last match was done on a string with &lt;code&gt;string-match&lt;/code&gt;, then integers are always used, since markers can&amp;rsquo;t point into a string.</source>
          <target state="translated">Обычно все элементы являются маркерами или &lt;code&gt;nil&lt;/code&gt; , но если &lt;var&gt;integers&lt;/var&gt; не равны &lt;code&gt;nil&lt;/code&gt; , это означает использование целых чисел вместо маркеров. (В этом случае сам буфер добавляется как дополнительный элемент в конце списка, чтобы облегчить полное восстановление данных совпадения.) Если последнее совпадение было выполнено для строки с &lt;code&gt;string-match&lt;/code&gt; , то всегда используются целые числа , поскольку маркеры не могут указывать на строку.</target>
        </trans-unit>
        <trans-unit id="192d978732b9939fab239d8824137b1ba2ec3243" translate="yes" xml:space="preserve">
          <source>Normally any upper case event is converted to lower case if the original event is undefined and the lower case equivalent is defined. The argument &lt;var&gt;dont-downcase-last&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means do not convert the last event to lower case. This is appropriate for reading a key sequence to be defined.</source>
          <target state="translated">Обычно любое событие в верхнем регистре преобразуется в нижний регистр, если исходное событие не определено и определен его эквивалент в нижнем регистре. Аргумент &lt;var&gt;dont-downcase-last&lt;/var&gt; , если не равен &lt;code&gt;nil&lt;/code&gt; , означает, что последнее событие не преобразовывается в нижний регистр. Это подходит для чтения ключевой последовательности, которую необходимо определить.</target>
        </trans-unit>
        <trans-unit id="dad78cd65a27cbbd2fd73355d58cb98bdd207435" translate="yes" xml:space="preserve">
          <source>Normally completion operates on the whole string, so for all normal collections, this will always return &lt;code&gt;(0 . (length
&lt;var&gt;suffix&lt;/var&gt;))&lt;/code&gt;. But more complex completion such as completion on files is done one field at a time. For example, completion of &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; will include &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; but not &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; even if &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; exists. Also &lt;code&gt;all-completions&lt;/code&gt; on &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; will not include &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; but only &lt;code&gt;&quot;share/&quot;&lt;/code&gt;. So if &lt;var&gt;string&lt;/var&gt; is &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; and &lt;var&gt;suffix&lt;/var&gt; is &lt;code&gt;&quot;e/doc&quot;&lt;/code&gt;, &lt;code&gt;completion-boundaries&lt;/code&gt; will return &lt;code&gt;(5 . 1)&lt;/code&gt; which tells us that the &lt;var&gt;collection&lt;/var&gt; will only return completion information that pertains to the area after &lt;code&gt;&quot;/usr/&quot;&lt;/code&gt; and before &lt;code&gt;&quot;/doc&quot;&lt;/code&gt;.</source>
          <target state="translated">Обычно завершение работает со всей строкой, поэтому для всех обычных коллекций всегда будет возвращаться &lt;code&gt;(0 . (length &lt;var&gt;suffix&lt;/var&gt;))&lt;/code&gt; . Но более сложное завершение, такое как завершение файлов, выполняется по одному полю за раз. Например, завершение &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; будет включать &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; но не &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; даже если &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; существует. Кроме того, &lt;code&gt;all-completions&lt;/code&gt; на &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; не будут включать &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; а только &lt;code&gt;&quot;share/&quot;&lt;/code&gt; . Так что, если &lt;var&gt;string&lt;/var&gt; является &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; и &lt;var&gt;suffix&lt;/var&gt; является &lt;code&gt;&quot;e/doc&quot;&lt;/code&gt; , &lt;code&gt;completion-boundaries&lt;/code&gt; вернет &lt;code&gt;(5 . 1)&lt;/code&gt; что говорит нам, что &lt;var&gt;collection&lt;/var&gt; будет возвращать только информацию о завершении, которая относится к области после &lt;code&gt;&quot;/usr/&quot;&lt;/code&gt; и до &lt;code&gt;&quot;/doc&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eef86229b8453b39f2aa268e50526cd24df0ce4f" translate="yes" xml:space="preserve">
          <source>Normally the frame parameter &lt;code&gt;vertical-scroll-bars&lt;/code&gt; controls whether the windows in the frame have vertical scroll bars, and whether they are on the left or right. The frame parameter &lt;code&gt;scroll-bar-width&lt;/code&gt; specifies how wide they are (&lt;code&gt;nil&lt;/code&gt; meaning the default).</source>
          <target state="translated">Обычно параметр frame &lt;code&gt;vertical-scroll-bars&lt;/code&gt; определяет, есть ли у окон в кадре вертикальные полосы прокрутки и находятся ли они слева или справа. Параметр frame &lt;code&gt;scroll-bar-width&lt;/code&gt; указывает их ширину ( &lt;code&gt;nil&lt;/code&gt; означает значение по умолчанию).</target>
        </trans-unit>
        <trans-unit id="b67289438b7d78753fd70ed6a9106b4a91cda89b" translate="yes" xml:space="preserve">
          <source>Normally the menu bar shows global items followed by items defined by the local maps.</source>
          <target state="translated">Обычно в строке меню отображаются глобальные элементы,за которыми следуют элементы,определенные локальными картами.</target>
        </trans-unit>
        <trans-unit id="b4ce40396bab6737ba31fe0b078bdd852088010f" translate="yes" xml:space="preserve">
          <source>Normally the strings in this menu are determined automatically from the choices; however, you can specify different strings for the menu by including the &lt;code&gt;:tag&lt;/code&gt; keyword in the alternatives. For example, if an integer stands for a number of spaces, while a string is text to use verbatim, you might write the customization type this way,</source>
          <target state="translated">Обычно строки в этом меню определяются автоматически из вариантов; однако вы можете указать другие строки для меню, включив ключевое слово &lt;code&gt;:tag&lt;/code&gt; в альтернативные варианты. Например, если целое число означает количество пробелов, а строка - это текст для дословного использования, вы можете написать тип настройки таким образом,</target>
        </trans-unit>
        <trans-unit id="62b64002f4f8b319511bb978309afeb856e1036e" translate="yes" xml:space="preserve">
          <source>Normally this function returns a list of coding systems that could handle decoding the text that was scanned. They are listed in order of decreasing priority. But if &lt;var&gt;highest&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the return value is just one coding system, the one that is highest in priority.</source>
          <target state="translated">Обычно эта функция возвращает список систем кодирования, которые могут обрабатывать декодирование отсканированного текста. Они перечислены в порядке убывания приоритета. Но если &lt;var&gt;highest&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , то возвращаемое значение - это только одна система кодирования, имеющая наивысший приоритет.</target>
        </trans-unit>
        <trans-unit id="ab4019dfe8ddc7d2f4af3e844b877df3f30a8685" translate="yes" xml:space="preserve">
          <source>Normally you add events to the front of this list, so that the events most recently unread will be reread first.</source>
          <target state="translated">Обычно вы добавляете события на обложку этого списка,так что последние непрочитанные события будут перечитываться первыми.</target>
        </trans-unit>
        <trans-unit id="9b2e214efb7720744217eac6eff20d8f98ffd008" translate="yes" xml:space="preserve">
          <source>Normally you do not need to set the stipple attribute, because it is used automatically to handle certain shades of gray.</source>
          <target state="translated">Обычно нет необходимости задавать атрибут stipple,так как он используется автоматически для обработки определенных оттенков серого.</target>
        </trans-unit>
        <trans-unit id="c998bbdbb3cbe3ac5764a0951dbc909e2665a30b" translate="yes" xml:space="preserve">
          <source>Normally you don&amp;rsquo;t specify the name explicitly, and Emacs computes the frame name automatically based on a template stored in the variable &lt;code&gt;frame-title-format&lt;/code&gt;. Emacs recomputes the name each time the frame is redisplayed.</source>
          <target state="translated">Обычно вы не указываете имя явно, и Emacs вычисляет имя фрейма автоматически на основе шаблона, хранящегося в переменной &lt;code&gt;frame-title-format&lt;/code&gt; . Emacs пересчитывает имя каждый раз при повторном отображении кадра.</target>
        </trans-unit>
        <trans-unit id="802f45620f0b9ed768e00202f167ac521857caf7" translate="yes" xml:space="preserve">
          <source>Normally you should not change the value of this variable.</source>
          <target state="translated">Обычно не следует изменять значение этой переменной.</target>
        </trans-unit>
        <trans-unit id="7a23d4c059b6f9f25f5adc759fee5b9b134865c2" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;add-to-history&lt;/code&gt; removes duplicate members from the history list if &lt;code&gt;history-delete-duplicates&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. However, if &lt;var&gt;keep-all&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says not to remove duplicates, and to add &lt;var&gt;newelt&lt;/var&gt; to the list even if it is empty.</source>
          <target state="translated">Обычно &lt;code&gt;add-to-history&lt;/code&gt; удаляет повторяющиеся элементы из списка &lt;code&gt;history-delete-duplicates&lt;/code&gt; если history-delete-duplicates не равно &lt;code&gt;nil&lt;/code&gt; . Однако, если &lt;var&gt;keep-all&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , это означает , что не следует удалять дубликаты и добавлять &lt;var&gt;newelt&lt;/var&gt; в список, даже если он пуст.</target>
        </trans-unit>
        <trans-unit id="84a125fd6e14f51bb1790a0c3b9796a123e66347" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;define-abbrev&lt;/code&gt; sets the variable &lt;code&gt;abbrevs-changed&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;, if it actually changes the abbrev. This is so that some commands will offer to save the abbrevs. It does not do this for a system abbrev, since those aren&amp;rsquo;t saved anyway.</source>
          <target state="translated">Как правило, &lt;code&gt;define-abbrev&lt;/code&gt; устанавливает переменное &lt;code&gt;abbrevs-changed&lt;/code&gt; в &lt;code&gt;t&lt;/code&gt; , если он на самом деле изменяет сокращение. Это сделано для того, чтобы некоторые команды предлагали сохранить сокращения. Он не делает этого для системных сокращений, поскольку они все равно не сохраняются.</target>
        </trans-unit>
        <trans-unit id="970594f1826445de648390764f7d9d23076e7277" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;emacs_value&lt;/code&gt; objects have a rather short lifetime: it ends when the &lt;code&gt;emacs_env&lt;/code&gt; pointer used for their creation goes out of scope. Occasionally, you may need to create &lt;em&gt;global references&lt;/em&gt;: &lt;code&gt;emacs_value&lt;/code&gt; objects that live as long as you wish. Use the following two functions to manage such objects.</source>
          <target state="translated">Обычно &lt;code&gt;emacs_value&lt;/code&gt; объектов emacs_value довольно короткое время жизни: оно заканчивается, когда указатель &lt;code&gt;emacs_env&lt;/code&gt; , использованный для их создания, выходит за пределы области видимости. Иногда вам может потребоваться создать &lt;em&gt;глобальные ссылки&lt;/em&gt; : объекты &lt;code&gt;emacs_value&lt;/code&gt; , которые живут столько, сколько вы хотите. Используйте следующие две функции для управления такими объектами.</target>
        </trans-unit>
        <trans-unit id="39b787a71e5fbae9edb48d71ec234482e20b431b" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;map-y-or-n-p&lt;/code&gt; binds &lt;code&gt;cursor-in-echo-area&lt;/code&gt; while prompting. But if &lt;var&gt;no-cursor-in-echo-area&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it does not do that.</source>
          <target state="translated">Обычно &lt;code&gt;map-y-or-n-p&lt;/code&gt; связывает &lt;code&gt;cursor-in-echo-area&lt;/code&gt; во время запроса. Но если &lt;var&gt;no-cursor-in-echo-area&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , этого не происходит.</target>
        </trans-unit>
        <trans-unit id="b1b62f370a1c1a6e7086ac926443ce71d3d50fde" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;md5&lt;/code&gt; signals an error if the text can&amp;rsquo;t be encoded using the specified or chosen coding system. However, if &lt;var&gt;noerror&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it silently uses &lt;code&gt;raw-text&lt;/code&gt; coding instead.</source>
          <target state="translated">Обычно &lt;code&gt;md5&lt;/code&gt; сигнализирует об ошибке, если текст не может быть закодирован с использованием указанной или выбранной системы кодирования. Однако, если &lt;var&gt;noerror&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , вместо этого используется кодирование &lt;code&gt;raw-text&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c4fc931c5f12a4d2220d2a0743fc463a725a420" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;revert-buffer&lt;/code&gt; asks for confirmation before it changes the buffer; but if the argument &lt;var&gt;noconfirm&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;revert-buffer&lt;/code&gt; does not ask for confirmation.</source>
          <target state="translated">Обычно &lt;code&gt;revert-buffer&lt;/code&gt; запрашивает подтверждение перед изменением буфера; но если аргумент &lt;var&gt;noconfirm&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;revert-buffer&lt;/code&gt; не запрашивает подтверждения.</target>
        </trans-unit>
        <trans-unit id="c7a8f6a1665078c7e303220251e8e70e9878aff0" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;transpose-regions&lt;/code&gt; relocates markers with the transposed text; a marker previously positioned within one of the two transposed portions moves along with that portion, thus remaining between the same two characters in their new position. However, if &lt;var&gt;leave-markers&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;transpose-regions&lt;/code&gt; does not do this&amp;mdash;it leaves all markers unrelocated.</source>
          <target state="translated">Обычно &lt;code&gt;transpose-regions&lt;/code&gt; перемещают маркеры с транспонированным текстом; маркер, ранее помещенный в одну из двух транспонированных частей, перемещается вместе с этой частью, таким образом, оставаясь между теми же двумя символами в их новом положении. Однако, если &lt;var&gt;leave-markers&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;transpose-regions&lt;/code&gt; region этого не делает - он оставляет все маркеры нерасположенными.</target>
        </trans-unit>
        <trans-unit id="c224a495efc6cae4ffaacc3200216d71860a3648" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;write-region&lt;/code&gt; displays the message &amp;lsquo;</source>
          <target state="translated">Обычно &lt;code&gt;write-region&lt;/code&gt; отображает сообщение '</target>
        </trans-unit>
        <trans-unit id="a463efccfae5102145810b771db2db6ac9df4444" translate="yes" xml:space="preserve">
          <source>Normally, &lt;var&gt;keymap&lt;/var&gt; is used just once, to look up the very next key. If the optional argument &lt;var&gt;keep-pred&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, the map stays active as long as the user types keys defined in &lt;var&gt;keymap&lt;/var&gt;; when the user types a key that is not in &lt;var&gt;keymap&lt;/var&gt;, the transient keymap is deactivated and normal key lookup continues for that key.</source>
          <target state="translated">Обычно &lt;var&gt;keymap&lt;/var&gt; используется только один раз, чтобы найти следующую клавишу. Если необязательный аргумент &lt;var&gt;keep-pred&lt;/var&gt; равен &lt;code&gt;t&lt;/code&gt; , карта остается активной, пока пользователь вводит ключи, определенные в &lt;var&gt;keymap&lt;/var&gt; клавиш ; когда пользователь вводит ключ, которого нет в &lt;var&gt;keymap&lt;/var&gt; ключей , временная таблица ключей деактивируется и для этого ключа продолжается обычный поиск ключа.</target>
        </trans-unit>
        <trans-unit id="f65ffe59e12caca0f23c215b2caa4e497fa21c12" translate="yes" xml:space="preserve">
          <source>Normally, Emacs uses the face specs of each face to automatically calculate its attributes on each frame (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;). The function &lt;code&gt;set-face-attribute&lt;/code&gt; can override this calculation by directly assigning attributes to a face, either on a specific frame or for all frames. This function is mostly intended for internal usage.</source>
          <target state="translated">Обычно Emacs использует характеристики каждого лица для автоматического вычисления его атрибутов в каждом кадре (см. &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Определение граней&lt;/a&gt; ). Функция &lt;code&gt;set-face-attribute&lt;/code&gt; может переопределить это вычисление, напрямую назначая атрибуты лицу, либо на конкретном кадре, либо для всех кадров. Эта функция в основном предназначена для внутреннего использования.</target>
        </trans-unit>
        <trans-unit id="56d71e2eece71984f9cf83046339cf5cde803b82" translate="yes" xml:space="preserve">
          <source>Normally, a face is declared just once, using &lt;code&gt;defface&lt;/code&gt;, and any further changes to its appearance are applied using the Customize framework (e.g., via the Customize user interface or via the &lt;code&gt;custom-set-faces&lt;/code&gt; function; see &lt;a href=&quot;applying-customizations#Applying-Customizations&quot;&gt;Applying Customizations&lt;/a&gt;), or by face remapping (see &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;Face Remapping&lt;/a&gt;). In the rare event that you need to change a face spec directly from Lisp, you can use the &lt;code&gt;face-spec-set&lt;/code&gt; function.</source>
          <target state="translated">Обычно лицо объявляется только один раз, используя &lt;code&gt;defface&lt;/code&gt; , и любые дальнейшие изменения его внешнего вида применяются с использованием инфраструктуры Customize (например, через пользовательский интерфейс Customize или через функцию &lt;code&gt;custom-set-faces&lt;/code&gt; ; см. &lt;a href=&quot;applying-customizations#Applying-Customizations&quot;&gt;Применение настроек&lt;/a&gt; ) или с помощью переназначение лиц (см. &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;Переназначение лиц&lt;/a&gt; ). В редких случаях, когда вам нужно изменить спецификацию лица прямо из Lisp, вы можете использовать функцию &lt;code&gt;face-spec-set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef564d0438f8b582059c4f06fa6f5901a7eb5fe3" translate="yes" xml:space="preserve">
          <source>Normally, a newline is automatically inserted after the header, the footer and every node&amp;rsquo;s textual description. If &lt;var&gt;nosep&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, no newline is inserted. This may be useful for displaying an entire ewoc on a single line, for example, or for making nodes invisible by arranging for &lt;var&gt;pretty-printer&lt;/var&gt; to do nothing for those nodes.</source>
          <target state="translated">Обычно новая строка автоматически вставляется после заголовка, нижнего колонтитула и текстового описания каждого узла. Если &lt;var&gt;nosep&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , новая строка не вставляется. Это может быть полезно для отображения всего электронного документа в одной строке, например, или для того, чтобы сделать узлы невидимыми, сделав так, чтобы &lt;var&gt;pretty-printer&lt;/var&gt; ничего не делал для этих узлов.</target>
        </trans-unit>
        <trans-unit id="78ecfe635d86fae4e7dabe6c5a40c28ac6789c76" translate="yes" xml:space="preserve">
          <source>Normally, a red highlight indicates the form was never completely evaluated; a brown highlight means it always evaluated to the same value (meaning there has been little testing of what is done with the result). However, the red highlight is skipped for forms that can&amp;rsquo;t possibly complete their evaluation, such as &lt;code&gt;error&lt;/code&gt;. The brown highlight is skipped for forms that are expected to always evaluate to the same value, such as &lt;code&gt;(setq x 14)&lt;/code&gt;.</source>
          <target state="translated">Обычно красный цвет указывает на то, что форма никогда полностью не оценивалась; коричневая подсветка означает, что он всегда оценивается с одним и тем же значением (это означает, что было мало проверок того, что делается с результатом). Однако красная подсветка пропускается для форм, которые не могут завершить свою оценку, например, &lt;code&gt;error&lt;/code&gt; . Коричневая подсветка пропускается для форм, которые, как ожидается, всегда будут вычислять одно и то же значение, например &lt;code&gt;(setq x 14)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7854440eb6b90acf05dcac089bc58cb02d3786d" translate="yes" xml:space="preserve">
          <source>Normally, commands specify which representation to use for the prefix argument, either numeric or raw, in the &lt;code&gt;interactive&lt;/code&gt; specification. (See &lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;Using Interactive&lt;/a&gt;.) Alternatively, functions may look at the value of the prefix argument directly in the variable &lt;code&gt;current-prefix-arg&lt;/code&gt;, but this is less clean.</source>
          <target state="translated">Обычно команды указывают, какое представление использовать для аргумента префикса, числовое или необработанное, в &lt;code&gt;interactive&lt;/code&gt; спецификации. (См. &lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;Использование интерактивного&lt;/a&gt; .) В качестве альтернативы, функции могут смотреть на значение аргумента префикса непосредственно в переменной &lt;code&gt;current-prefix-arg&lt;/code&gt; , но это менее чисто.</target>
        </trans-unit>
        <trans-unit id="0922fd40705d46e517e311d0b4534c4d4aea3a25" translate="yes" xml:space="preserve">
          <source>Normally, deleting a large amount of text from a buffer inhibits further auto-saving of that buffer because it has shrunk. However, &lt;code&gt;erase-buffer&lt;/code&gt; does not do this, the idea being that the future text is not really related to the former text, and its size should not be compared with that of the former text.</source>
          <target state="translated">Обычно удаление большого количества текста из буфера препятствует дальнейшему автосохранению этого буфера, поскольку он уменьшился. Однако &lt;code&gt;erase-buffer&lt;/code&gt; этого не делает, поскольку идея состоит в том, что будущий текст на самом деле не связан с предыдущим текстом, и его размер не следует сравнивать с размером прежнего текста.</target>
        </trans-unit>
        <trans-unit id="2b35691422f5a8a262ba1ccbae353a8209b947f0" translate="yes" xml:space="preserve">
          <source>Normally, displaying a long message resizes the echo area to display the entire message. But if the variable &lt;code&gt;message-truncate-lines&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the echo area does not resize, and the message is truncated to fit it.</source>
          <target state="translated">Обычно при отображении длинного сообщения размер эхо-области изменяется для отображения всего сообщения. Но если переменная &lt;code&gt;message-truncate-lines&lt;/code&gt; не равна &lt;code&gt;nil&lt;/code&gt; , размер эхо-области не изменяется, и сообщение усекается, чтобы соответствовать ему.</target>
        </trans-unit>
        <trans-unit id="f23d4ac50b4b0692f85e2c612a9dbf51f5ee0c69" translate="yes" xml:space="preserve">
          <source>Normally, each entry in a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; type specification describes a single element type. But when an entry contains &lt;code&gt;:inline t&lt;/code&gt;, the value it matches is merged directly into the containing sequence. For example, if the entry matches a list with three elements, those become three elements of the overall sequence. This is analogous to &amp;lsquo;</source>
          <target state="translated">Обычно каждая запись в спецификации типа &lt;code&gt;list&lt;/code&gt; или &lt;code&gt;vector&lt;/code&gt; описывает один тип элемента. Но когда запись содержит &lt;code&gt;:inline t&lt;/code&gt; , значение, которому она соответствует, объединяется непосредственно в содержащую последовательность. Например, если запись соответствует списку из трех элементов, они становятся тремя элементами общей последовательности. Это аналогично '</target>
        </trans-unit>
        <trans-unit id="467a0b75a915def14074129749af0e39f8c66a1c" translate="yes" xml:space="preserve">
          <source>Normally, each frame has its own minibuffer window at the bottom, which is used whenever that frame is selected. You can get that window with the function &lt;code&gt;minibuffer-window&lt;/code&gt; (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;).</source>
          <target state="translated">Обычно каждый кадр имеет собственное окно минибуфера внизу, которое используется всякий раз, когда этот кадр выбирается. Вы можете получить это окно с помощью функции &lt;code&gt;minibuffer-window&lt;/code&gt; (см. &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Окна минибуфера&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f47235bc295fc9ef73d437c414c49bbdf12a693c" translate="yes" xml:space="preserve">
          <source>Normally, elements of &lt;code&gt;font-lock-keywords&lt;/code&gt; should not match across multiple lines; that doesn&amp;rsquo;t work reliably, because Font Lock usually scans just part of the buffer, and it can miss a multi-line construct that crosses the line boundary where the scan starts. (The scan normally starts at the beginning of a line.)</source>
          <target state="translated">Обычно элементы &lt;code&gt;font-lock-keywords&lt;/code&gt; не должны совпадать в нескольких строках; это работает ненадежно, потому что Font Lock обычно сканирует только часть буфера и может пропустить многострочную конструкцию, которая пересекает границу строки, где начинается сканирование. (Сканирование обычно начинается с начала строки.)</target>
        </trans-unit>
        <trans-unit id="d12bd9c60258b05b553df099e61b1e0db5cc0eb0" translate="yes" xml:space="preserve">
          <source>Normally, errors caught by &lt;code&gt;condition-case&lt;/code&gt; never invoke the debugger. The &lt;code&gt;condition-case&lt;/code&gt; gets a chance to handle the error before the debugger gets a chance.</source>
          <target state="translated">Обычно ошибки, обнаруженные с помощью &lt;code&gt;condition-case&lt;/code&gt; никогда не вызывают отладчик. &lt;code&gt;condition-case&lt;/code&gt; получает возможность обработать ошибку до того , как отладчик получает шанс.</target>
        </trans-unit>
        <trans-unit id="54a2bd94783a47980369965cd627bee242490611" translate="yes" xml:space="preserve">
          <source>Normally, if &lt;var&gt;character&lt;/var&gt; is an</source>
          <target state="translated">Обычно, если &lt;var&gt;character&lt;/var&gt; является</target>
        </trans-unit>
        <trans-unit id="d50713f555db79e954a816742203790399e0673d" translate="yes" xml:space="preserve">
          <source>Normally, if &lt;var&gt;element&lt;/var&gt; is added, it is added to the front of &lt;var&gt;symbol&lt;/var&gt;, but if the optional argument &lt;var&gt;append&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it is added at the end.</source>
          <target state="translated">Обычно, если &lt;var&gt;element&lt;/var&gt; добавлен, он добавляется в начало &lt;var&gt;symbol&lt;/var&gt; , но если необязательный аргумент &lt;var&gt;append&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , он добавляется в конце.</target>
        </trans-unit>
        <trans-unit id="d6187789e5ea59be13e6c842c07c9deb29b1d4bb" translate="yes" xml:space="preserve">
          <source>Normally, it is not necessary to manipulate fonts directly. In case you need to do so, this section explains how.</source>
          <target state="translated">Обычно нет необходимости манипулировать шрифтами напрямую.В случае необходимости,в этом разделе объясняется,как это сделать.</target>
        </trans-unit>
        <trans-unit id="becd1bd4e621ec277e1f58244c23bb4b5b4c4b17" translate="yes" xml:space="preserve">
          <source>Normally, it modifies a category set by adding &lt;var&gt;category&lt;/var&gt; to it. But if &lt;var&gt;reset&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it deletes &lt;var&gt;category&lt;/var&gt; instead.</source>
          <target state="translated">Обычно он изменяет набор категорий, добавляя к нему &lt;var&gt;category&lt;/var&gt; . Но если &lt;var&gt;reset&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , он вместо этого удаляет &lt;var&gt;category&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="33a09b1e73b35c5e6e469be538e26ad9f62399d8" translate="yes" xml:space="preserve">
          <source>Normally, prefer &lt;code&gt;intptr_t&lt;/code&gt; for internal representations of pointers, or for integers bounded only by the number of objects that can exist at any given time or by the total number of bytes that can be allocated. However, prefer &lt;code&gt;uintptr_t&lt;/code&gt; to represent pointer arithmetic that could cross page boundaries. For example, on a machine with a 32-bit address space an array could cross the 0x7fffffff/0x80000000 boundary, which would cause an integer overflow when adding 1 to &lt;code&gt;(intptr_t) 0x7fffffff&lt;/code&gt;.</source>
          <target state="translated">Обычно предпочитают &lt;code&gt;intptr_t&lt;/code&gt; для внутреннего представления указателей или для целых чисел, ограниченных только количеством объектов, которые могут существовать в любой момент времени, или общим количеством байтов, которые могут быть выделены. Однако предпочитайте &lt;code&gt;uintptr_t&lt;/code&gt; для представления арифметики указателя, которая может пересекать границы страницы. Например, на машине с 32-битным адресным пространством массив может пересечь границу 0x7fffffff / 0x80000000, что вызовет целочисленное переполнение при добавлении 1 к &lt;code&gt;(intptr_t) 0x7fffffff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e6c689be8312b59b07bf40709097a3c5731537c" translate="yes" xml:space="preserve">
          <source>Normally, repetition forms are greedy, in that they attempt to match as many times as possible. Some forms are non-greedy; they try to match as few times as possible (see &lt;a href=&quot;regexp-special#Non_002dgreedy-repetition&quot;&gt;Non-greedy repetition&lt;/a&gt;).</source>
          <target state="translated">Обычно формы повторения жадны в том смысле, что они пытаются сопоставить как можно больше раз. Некоторые формы не являются жадными; они пытаются сопоставить как можно меньше раз (см. &lt;a href=&quot;regexp-special#Non_002dgreedy-repetition&quot;&gt;Нежадное повторение&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8afe6491950d0be63d8da54adfd8c5f2338d800f" translate="yes" xml:space="preserve">
          <source>Normally, the</source>
          <target state="translated">Обычно</target>
        </trans-unit>
        <trans-unit id="30802bf54b72f5663b6407f90667f9e51d089434" translate="yes" xml:space="preserve">
          <source>Normally, the argument expressions are not evaluated as part of computing the macro expansion, but instead appear as part of the expansion, so they are computed when the expansion is evaluated.</source>
          <target state="translated">Обычно выражения аргументов не вычисляются как часть вычисления макроразложения,а появляются в составе разложения,поэтому они вычисляются при вычислении разложения.</target>
        </trans-unit>
        <trans-unit id="629b571150fb4d121b8cb2e6cf7f1cf6cc68f709" translate="yes" xml:space="preserve">
          <source>Normally, the buffer displayed in the selected window is the current buffer, but this is not always so: a Lisp program can temporarily designate any buffer as current in order to operate on its contents, without changing what is displayed on the screen. The most basic function for designating a current buffer is &lt;code&gt;set-buffer&lt;/code&gt;.</source>
          <target state="translated">Обычно буфер, отображаемый в выбранном окне, является текущим буфером, но это не всегда так: программа на Лиспе может временно назначить любой буфер текущим, чтобы работать с его содержимым, не изменяя то, что отображается на экране. Самая основная функция для обозначения текущего буфера - это &lt;code&gt;set-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ef79e40f4fe75ea19a532d8a9828e867c6dc545" translate="yes" xml:space="preserve">
          <source>Normally, the cursor is displayed at the beginning or the end of any overlay and text property strings present at the current buffer position. You can place the cursor on any desired character of these strings by giving that character a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;cursor&lt;/code&gt; text property. In addition, if the value of the &lt;code&gt;cursor&lt;/code&gt; property is an integer, it specifies the number of buffer&amp;rsquo;s character positions, starting with the position where the overlay or the &lt;code&gt;display&lt;/code&gt; property begins, for which the cursor should be displayed on that character. Specifically, if the value of the &lt;code&gt;cursor&lt;/code&gt; property of a character is the number &lt;var&gt;n&lt;/var&gt;, the cursor will be displayed on this character for any buffer position in the range &lt;code&gt;[&lt;var&gt;ovpos&lt;/var&gt;..&lt;var&gt;ovpos&lt;/var&gt;+&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;ovpos&lt;/var&gt; is the overlay&amp;rsquo;s starting position given by &lt;code&gt;overlay-start&lt;/code&gt; (see &lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt;Managing Overlays&lt;/a&gt;), or the position where the &lt;code&gt;display&lt;/code&gt; text property begins in the buffer.</source>
          <target state="translated">Обычно курсор отображается в начале или в конце любых строк свойств наложения и текста, присутствующих в текущей позиции буфера. Вы можете поместить курсор на любой желаемый символ в этих строках, присвоив этому символу текстовое свойство &lt;code&gt;cursor&lt;/code&gt; отличное от &lt;code&gt;nil&lt;/code&gt; . Кроме того, если значение свойства &lt;code&gt;cursor&lt;/code&gt; является целым числом, оно определяет количество позиций символа буфера, начиная с позиции, где начинается оверлей или свойство &lt;code&gt;display&lt;/code&gt; , для которых курсор должен отображаться на этом символе. В частности, если значением свойства &lt;code&gt;cursor&lt;/code&gt; символа является число &lt;var&gt;n&lt;/var&gt; , курсор будет отображаться на этом символе для любой позиции буфера в диапазоне &lt;code&gt;[&lt;var&gt;ovpos&lt;/var&gt;..&lt;var&gt;ovpos&lt;/var&gt;+&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;ovpos&lt;/var&gt; .. &lt;var&gt;ovpos&lt;/var&gt; + &lt;var&gt;n&lt;/var&gt; ) , где &lt;var&gt;ovpos&lt;/var&gt; - это начальная позиция наложения, заданная параметром &lt;code&gt;overlay-start&lt;/code&gt; (см.&lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt; Управление наложениями&lt;/a&gt; ), или позиция, в которойсвойство &lt;code&gt;display&lt;/code&gt; текста начинается в буфере.</target>
        </trans-unit>
        <trans-unit id="6e260092c506bb0904c31069887686f085d03db5" translate="yes" xml:space="preserve">
          <source>Normally, the keymap &lt;code&gt;query-replace-map&lt;/code&gt; defines the possible user responses for queries. The argument &lt;var&gt;map&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a keymap to use instead of &lt;code&gt;query-replace-map&lt;/code&gt;.</source>
          <target state="translated">Обычно &lt;code&gt;query-replace-map&lt;/code&gt; клавиатуры определяет возможные ответы пользователя на запросы. Довод &lt;var&gt;map&lt;/var&gt; , если не - &lt;code&gt;nil&lt;/code&gt; , задает раскладку использовать вместо &lt;code&gt;query-replace-map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9bc529dca0e2a9cf79b4d035ef919efc70874fc" translate="yes" xml:space="preserve">
          <source>Normally, the specified buffer is put at the front of the buffer list&amp;mdash;both the global buffer list and the selected frame&amp;rsquo;s buffer list (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;). However, this is not done if the optional argument &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Обычно указанный буфер помещается в начало списка буферов - как глобального списка буферов, так и списка буферов выбранного кадра (см. &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Список&lt;/a&gt; буферов ). Однако этого не происходит, если необязательный аргумент &lt;var&gt;norecord&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7936ac8e02ea68233dc9ba1fd5cca740f87f5020" translate="yes" xml:space="preserve">
          <source>Normally, the variables &lt;code&gt;window-min-height&lt;/code&gt; and &lt;code&gt;window-min-width&lt;/code&gt; specify the smallest allowable window size (see &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;). However, if the optional argument &lt;var&gt;ignore&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function ignores &lt;code&gt;window-min-height&lt;/code&gt; and &lt;code&gt;window-min-width&lt;/code&gt;, as well as &lt;code&gt;window-size-fixed&lt;/code&gt;. Instead, it considers the minimum-height window to be one consisting of a header and a mode line, a horizontal scrollbar and a bottom divider (if any), plus a text area one line tall; and a minimum-width window as one consisting of fringes, margins, a scroll bar and a right divider (if any), plus a text area two columns wide.</source>
          <target state="translated">Обычно переменные &lt;code&gt;window-min-height&lt;/code&gt; и &lt;code&gt;window-min-width&lt;/code&gt; определяют наименьший допустимый размер окна (см. &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Размеры окна&lt;/a&gt; ). Однако, если дополнительный аргумент &lt;var&gt;ignore&lt;/var&gt; отличен &lt;code&gt;nil&lt;/code&gt; , эта функция игнорирует &lt;code&gt;window-min-height&lt;/code&gt; и &lt;code&gt;window-min-width&lt;/code&gt; , а также &lt;code&gt;window-size-fixed&lt;/code&gt; . Вместо этого он считает, что окно минимальной высоты состоит из заголовка и строки режима, горизонтальной полосы прокрутки и нижнего разделителя (если есть), а также текстовой области высотой в одну строку; и окно минимальной ширины, состоящее из полос, полей, полосы прокрутки и правого разделителя (если есть), а также текстовой области шириной в два столбца.</target>
        </trans-unit>
        <trans-unit id="c5713371bb37a8cdef55c3106ef4460970d0eab6" translate="yes" xml:space="preserve">
          <source>Normally, this command puts point before the inserted text, and the mark after it. However, if the optional second argument &lt;var&gt;beforep&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it puts the mark before and point after.</source>
          <target state="translated">Обычно эта команда ставит точку перед вставленным текстом, а метку - после него. Однако, если необязательный второй аргумент &lt;var&gt;beforep&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , он ставит знак перед и после него.</target>
        </trans-unit>
        <trans-unit id="3d42087a0d42cd57b27861aa1a1b4a750c8b489d" translate="yes" xml:space="preserve">
          <source>Normally, this command reinitializes the buffer&amp;rsquo;s major and minor modes using &lt;code&gt;normal-mode&lt;/code&gt;. But if &lt;var&gt;preserve-modes&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the modes remain unchanged.</source>
          <target state="translated">Обычно эта команда повторно инициализирует основной и вспомогательный режимы буфера, используя &lt;code&gt;normal-mode&lt;/code&gt; . Но если &lt;var&gt;preserve-modes&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , режимы остаются неизменными.</target>
        </trans-unit>
        <trans-unit id="aa1a4bffdaf1e62a462694623e95b20201dc51ec" translate="yes" xml:space="preserve">
          <source>Normally, this function asks the user for confirmation if there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt;. If &lt;var&gt;no-query&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that prevents asking this question. If there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt;, and the user confirms or &lt;var&gt;no-query&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function makes the new buffer name unique by appending a number inside of &amp;lsquo;</source>
          <target state="translated">Обычно эта функция запрашивает у пользователя подтверждение, существует ли уже &lt;var&gt;filename&lt;/var&gt; посещения буфера . Если &lt;var&gt;no-query&lt;/var&gt; не &lt;code&gt;nil&lt;/code&gt; , это не позволяет задать этот вопрос. Если &lt;var&gt;filename&lt;/var&gt; посещения буфера уже существует , и пользователь подтверждает, или &lt;var&gt;no-query&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , эта функция делает новое имя буфера уникальным, добавляя число внутри '</target>
        </trans-unit>
        <trans-unit id="64fcbebdb92f9124f1312a1ae2441a038070f262" translate="yes" xml:space="preserve">
          <source>Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these newlines are not added, so the output is just one long line.</source>
          <target state="translated">Обычно эта функция вставляет символы новой строки в закодированный текст, чтобы избежать слишком длинных строк. Однако, если необязательный аргумент &lt;var&gt;no-line-break&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , эти новые строки не добавляются, поэтому на выходе получается всего одна длинная строка.</target>
        </trans-unit>
        <trans-unit id="f43ac9933802532b28a287e5f45c7854bcc33b0b" translate="yes" xml:space="preserve">
          <source>Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these newlines are not added, so the result string is just one long line.</source>
          <target state="translated">Обычно эта функция вставляет символы новой строки в закодированный текст, чтобы избежать слишком длинных строк. Однако, если необязательный аргумент &lt;var&gt;no-line-break&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , эти новые строки не добавляются, поэтому строка результата представляет собой всего одну длинную строку.</target>
        </trans-unit>
        <trans-unit id="d37dcdec76f9e6b7d0121007f21ec47b7057c83e" translate="yes" xml:space="preserve">
          <source>Normally, this function signals an error if you attempt to delete the sole active terminal, but if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, you are allowed to do so. Emacs automatically calls this function when the last frame on a terminal is deleted (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;).</source>
          <target state="translated">Обычно эта функция сигнализирует об ошибке, если вы пытаетесь удалить единственный активный терминал, но если &lt;var&gt;force&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , вы можете это сделать. Emacs автоматически вызывает эту функцию, когда последний кадр на терминале удаляется (см. &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Удаление кадров&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6dd336d19d532b36fa2861068df8621fa7546f25" translate="yes" xml:space="preserve">
          <source>Normally, well-designed Lisp programs should not use &lt;code&gt;with-eval-after-load&lt;/code&gt;. If you need to examine and set the variables defined in another library (those meant for outside use), you can do it immediately&amp;mdash;there is no need to wait until the library is loaded. If you need to call functions defined by that library, you should load the library, preferably with &lt;code&gt;require&lt;/code&gt; (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;).</source>
          <target state="translated">Обычно хорошо спроектированные программы на Лиспе не должны использовать &lt;code&gt;with-eval-after-load&lt;/code&gt; . Если вам нужно проверить и установить переменные, определенные в другой библиотеке (предназначенные для внешнего использования), вы можете сделать это немедленно - нет необходимости ждать, пока библиотека загрузится. Если вам нужно вызвать функции, определенные этой библиотекой, вы должны загрузить библиотеку, желательно с помощью &lt;code&gt;require&lt;/code&gt; (см. &lt;a href=&quot;named-features#Named-Features&quot;&gt;Именованные функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="32213d153ad203f84c268998070d9c91fd7446c2" translate="yes" xml:space="preserve">
          <source>Normally, when &lt;var&gt;tree&lt;/var&gt; is anything other than a cons cell, &lt;code&gt;copy-tree&lt;/code&gt; simply returns &lt;var&gt;tree&lt;/var&gt;. However, if &lt;var&gt;vecp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it copies vectors too (and operates recursively on their elements).</source>
          <target state="translated">Обычно, когда &lt;var&gt;tree&lt;/var&gt; является чем-либо, кроме cons-ячейки, &lt;code&gt;copy-tree&lt;/code&gt; просто возвращает &lt;var&gt;tree&lt;/var&gt; . Однако, если &lt;var&gt;vecp&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , он также копирует векторы (и рекурсивно обрабатывает их элементы).</target>
        </trans-unit>
        <trans-unit id="a3c03c3e2f02de6a73dd67dd8665632ac3ecb4d6" translate="yes" xml:space="preserve">
          <source>Normally, you specify the Edebug execution mode by typing a command to continue the program in a certain mode. Here is a table of these commands; all except for</source>
          <target state="translated">Обычно вы указываете режим выполнения Edebug,набирая команду для продолжения программы в определенном режиме.Вот таблица этих команд;все,кроме</target>
        </trans-unit>
        <trans-unit id="28a2d6a083bc6ad019b2a98e4e29d81c91548221" translate="yes" xml:space="preserve">
          <source>Not all convenient formats are strings. If &lt;var&gt;time&lt;/var&gt; is a number (integer or floating point), that specifies a relative time measured in seconds. The result of &lt;code&gt;encode-time&lt;/code&gt; can also be used to specify an absolute value for &lt;var&gt;time&lt;/var&gt;.</source>
          <target state="translated">Не все удобные форматы - это строки. Если &lt;var&gt;time&lt;/var&gt; является числом (целым или с плавающей запятой), это указывает относительное время, измеряемое в секундах. Результат &lt;code&gt;encode-time&lt;/code&gt; также может использоваться для указания абсолютного значения &lt;var&gt;time&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="cb74d9cca41ce9c386501e0756ab5861fff45519" translate="yes" xml:space="preserve">
          <source>Not all grammars are accepted:</source>
          <target state="translated">Не все грамматики принимаются:</target>
        </trans-unit>
        <trans-unit id="99f0e2cc9f83cb30e3ae050f9b9f847c4120fdb6" translate="yes" xml:space="preserve">
          <source>Not every string is a valid regular expression. For example, a string that ends inside a character alternative without a terminating &amp;lsquo;</source>
          <target state="translated">Не каждая строка является допустимым регулярным выражением. Например, строка, которая заканчивается внутри альтернативного символа без завершающего символа '</target>
        </trans-unit>
        <trans-unit id="43ff9e862a86dab0a657fc6384f26e1419f49f75" translate="yes" xml:space="preserve">
          <source>Not used by core Emacs features.</source>
          <target state="translated">Не используется в основных функциях Emacs.</target>
        </trans-unit>
        <trans-unit id="c7c5413b8718cba59a931876fd41b752eae55f77" translate="yes" xml:space="preserve">
          <source>Notation for describing functions, variables, etc.</source>
          <target state="translated">Примечание для описания функций,переменных и т.д.</target>
        </trans-unit>
        <trans-unit id="4c3b785fe5302404be7fd8ebefe6a435a4164b8b" translate="yes" xml:space="preserve">
          <source>Note also that &lt;code&gt;expand-file-name&lt;/code&gt; does not follow symbolic links at any level. This results in a difference between the way &lt;code&gt;file-truename&lt;/code&gt; and &lt;code&gt;expand-file-name&lt;/code&gt; treat &amp;lsquo;</source>
          <target state="translated">Также обратите внимание, что &lt;code&gt;expand-file-name&lt;/code&gt; не следует за символическими ссылками ни на каком уровне. Это приводит к различию в способах обработки &lt;code&gt;file-truename&lt;/code&gt; и &lt;code&gt;expand-file-name&lt;/code&gt; '</target>
        </trans-unit>
        <trans-unit id="e8c1e3068af42529c71ce3761f404a8c7cb2b54f" translate="yes" xml:space="preserve">
          <source>Note also that the native position of a frame usually remains unaltered on its display when removing or adding the window manager decorations by changing the frame&amp;rsquo;s &lt;code&gt;override-redirect&lt;/code&gt; or &lt;code&gt;undecorated&lt;/code&gt; parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">Отметим также , что нативный положение кадра обычно остается неизменным на его дисплее при удалении или добавлении декорации оконного менеджера путем изменения фрейма &lt;code&gt;override-redirect&lt;/code&gt; или &lt;code&gt;undecorated&lt;/code&gt; параметр (см &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Параметры управления&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e06a1498bcc4e46f5b08f1b485bfe2d29db14c40" translate="yes" xml:space="preserve">
          <source>Note also that this translation is done before the characters are supplied to input methods (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;). Use &lt;code&gt;translation-table-for-input&lt;/code&gt; (see &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Translation of Characters&lt;/a&gt;), if you want to translate characters after input methods operate.</source>
          <target state="translated">Также обратите внимание, что этот перевод выполняется до того, как символы будут переданы в методы ввода (см. &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Методы ввода&lt;/a&gt; ). Используйте &lt;code&gt;translation-table-for-input&lt;/code&gt; (см. &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Перевод символов&lt;/a&gt; ), если вы хотите переводить символы после срабатывания методов ввода.</target>
        </trans-unit>
        <trans-unit id="f37c9faec19e5f322f365ce34f1cd5f26d62fd9b" translate="yes" xml:space="preserve">
          <source>Note also that under certain circumstances &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; may ignore this option, for example, when there is only one buffer left these functions can switch to.</source>
          <target state="translated">Также обратите внимание, что при определенных обстоятельствах &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; и &lt;code&gt;switch-to-next-buffer&lt;/code&gt; могут игнорировать эту опцию, например, когда остается только один буфер, на который эти функции могут переключаться.</target>
        </trans-unit>
        <trans-unit id="e43f096d72c1fa7eda8bb11cbb26469630c96a62" translate="yes" xml:space="preserve">
          <source>Note also that window managers usually do not ask for resizing a frame when they change the number of lines occupied by an external menu or tool bar. Typically, such &amp;ldquo;wrappings&amp;rdquo; occur when a user shrinks a frame horizontally, making it impossible to display all elements of its menu or tool bar. They may also result from a change of the major mode altering the number of items of a menu or tool bar. Any such wrappings may implicitly alter the number of lines of a frame&amp;rsquo;s text area and are unaffected by the setting of this option.</source>
          <target state="translated">Также обратите внимание, что оконные менеджеры обычно не запрашивают изменение размера фрейма, когда они меняют количество строк, занимаемых внешним меню или панелью инструментов. Обычно такие &amp;laquo;обертывания&amp;raquo; происходят, когда пользователь сжимает фрейм по горизонтали, что делает невозможным отображение всех элементов его меню или панели инструментов. Они также могут быть результатом изменения основного режима, изменяющего количество элементов меню или панели инструментов. Любые такие оболочки могут неявно изменять количество строк в текстовой области фрейма, и на них не влияет установка этого параметра.</target>
        </trans-unit>
        <trans-unit id="c02c5b53625103bbcd1e981469317bde4d2eff01" translate="yes" xml:space="preserve">
          <source>Note also the function &lt;code&gt;window-largest-empty-rectangle&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;) which can be used to inscribe a child frame in the largest empty area of an existing window. This can be useful to avoid that a child frame obscures any text shown in that window.</source>
          <target state="translated">Обратите внимание также на функцию &lt;code&gt;window-largest-empty-rectangle&lt;/code&gt; (см. &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Координаты и окна&lt;/a&gt; ), которую можно использовать для вписывания дочернего фрейма в самую большую пустую область существующего окна. Это может быть полезно, чтобы дочерний фрейм не заслонял любой текст, отображаемый в этом окне.</target>
        </trans-unit>
        <trans-unit id="ac296846d6e88621711014648ad3889107526b49" translate="yes" xml:space="preserve">
          <source>Note also, that positions specified relative to the right/bottom edge of a display, workarea or parent frame as well as floating-point offsets are stored internally as integer offsets relative to the left/top edge of the display, workarea or parent frame edge. They are also returned as such by functions like &lt;code&gt;frame-parameters&lt;/code&gt; and restored as such by the desktop saving routines.</source>
          <target state="translated">Также обратите внимание, что позиции, указанные относительно правого / нижнего края дисплея, рабочей области или родительского кадра, а также смещения с плавающей запятой сохраняются внутри как целочисленные смещения относительно левого / верхнего края дисплея, рабочей области или края родительского кадра. . Они также возвращаются такими функциями, как &lt;code&gt;frame-parameters&lt;/code&gt; и восстанавливаются как таковые подпрограммами сохранения рабочего стола.</target>
        </trans-unit>
        <trans-unit id="4ee808f9b4d3b62c6e1c4ae8210950ef2323557e" translate="yes" xml:space="preserve">
          <source>Note also, that the combined action alist may contain duplicate entries and entries for the same key with different values. As a rule, action functions always use the first association of a key they find. Hence, the association an action function uses is not necessarily the association provided by the display action that specified that action function,</source>
          <target state="translated">Обратите внимание,что комбинированный список действий может содержать дубликаты записей и записей для одного и того же ключа с разными значениями.Как правило,функции действия всегда используют первую ассоциацию найденного ключа.Следовательно,ассоциация,используемая функцией действия,не обязательно является ассоциацией,обеспечиваемой отображающим действием,в котором была указана эта функция действия,</target>
        </trans-unit>
        <trans-unit id="e5cf53f2f379d0df5750245ed5d07f62c700d148" translate="yes" xml:space="preserve">
          <source>Note how both &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; sub-patterns finish in the same way: by trying (always successfully) to match against the &lt;var&gt;symbol&lt;/var&gt; pattern &lt;code&gt;val&lt;/code&gt;, in the process binding &lt;code&gt;val&lt;/code&gt;. Thus, &lt;code&gt;or&lt;/code&gt; always matches and control always passes to the body form (line 9). Because that is the last body form in a successfully matched &lt;code&gt;pcase&lt;/code&gt; clause, it is the value of &lt;code&gt;pcase&lt;/code&gt; and likewise the return value of &lt;code&gt;grok/pcase&lt;/code&gt; (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание на то, как &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; подшаблоны заканчиваются одинаково: пытаясь (всегда успешно) сопоставить с шаблоном &lt;var&gt;symbol&lt;/var&gt; &lt;code&gt;val&lt;/code&gt; в процессе привязки &lt;code&gt;val&lt;/code&gt; . Таким образом, &lt;code&gt;or&lt;/code&gt; always соответствует и управление всегда переходит к форме тела (строка 9). Поскольку это последняя форма тела в успешно сопоставленном предложении &lt;code&gt;pcase&lt;/code&gt; , это значение &lt;code&gt;pcase&lt;/code&gt; , а также возвращаемое значение &lt;code&gt;grok/pcase&lt;/code&gt; (см. &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;Что такое функция&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="da5b870679158a8dc429765e73588de68e861a6b" translate="yes" xml:space="preserve">
          <source>Note that &amp;lsquo;</source>
          <target state="translated">Обратите внимание, что '</target>
        </trans-unit>
        <trans-unit id="5a8aa4751bb1c982814a77bf1d580dce6aad70e9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(car foo)&lt;/code&gt; is not executed if &lt;code&gt;(consp foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, thus avoiding an error.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;(car foo)&lt;/code&gt; не выполняется, если &lt;code&gt;(consp foo)&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; , что позволяет избежать ошибки.</target>
        </trans-unit>
        <trans-unit id="82cc38abe8d3c167aceee216d425c0ab550d1382" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(delq 'c sample-list)&lt;/code&gt; modifies &lt;code&gt;sample-list&lt;/code&gt; to splice out the third element, but &lt;code&gt;(delq 'a sample-list)&lt;/code&gt; does not splice anything&amp;mdash;it just returns a shorter list. Don&amp;rsquo;t assume that a variable which formerly held the argument &lt;var&gt;list&lt;/var&gt; now has fewer elements, or that it still holds the original list! Instead, save the result of &lt;code&gt;delq&lt;/code&gt; and use that. Most often we store the result back into the variable that held the original list:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;(delq 'c sample-list)&lt;/code&gt; модифицирует список &lt;code&gt;sample-list&lt;/code&gt; чтобы &lt;code&gt;(delq 'a sample-list)&lt;/code&gt; третий элемент, но (delq' a sample-list) ничего не объединяет - он просто возвращает более короткий список. Не думайте, что переменная, которая раньше содержала &lt;var&gt;list&lt;/var&gt; аргументов, теперь имеет меньше элементов или что она по-прежнему содержит исходный список! Вместо этого сохраните результат &lt;code&gt;delq&lt;/code&gt; и используйте его. Чаще всего мы сохраняем результат обратно в переменную, которая содержала исходный список:</target>
        </trans-unit>
        <trans-unit id="88ce8d10722b09594fee9067ec46be961db1010b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ad-activate&lt;/code&gt; had a global effect: it activated all pieces of advice enabled for that specified function. If you wanted to only activate or deactivate a particular piece, you needed to &lt;em&gt;enable&lt;/em&gt; or &lt;em&gt;disable&lt;/em&gt; it with &lt;code&gt;ad-enable-advice&lt;/code&gt; and &lt;code&gt;ad-disable-advice&lt;/code&gt;. The new mechanism does away with this distinction.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;ad-activate&lt;/code&gt; имеет глобальный эффект: он активирует все советы, включенные для этой указанной функции. Если вы хотели активировать или деактивировать только определенную часть, вам нужно было &lt;em&gt;включить&lt;/em&gt; или &lt;em&gt;отключить&lt;/em&gt; ее с помощью &lt;code&gt;ad-enable-advice&lt;/code&gt; и &lt;code&gt;ad-disable-advice&lt;/code&gt; . Новый механизм устраняет это различие.</target>
        </trans-unit>
        <trans-unit id="a8b9b0264afaff2247ccc31f5609c567f52bbb12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; appears redundant in the customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt; because it is already part of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; and should be tried there anyway. However, that would fail because due to the precedence of &lt;code&gt;display-buffer-base-action&lt;/code&gt; over &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;, at that time &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; would have already won the race. In fact, this:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; кажется избыточным при настройке &lt;code&gt;display-buffer-base-action&lt;/code&gt; , потому что оно уже является частью &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; и должно быть опробовано в любом случае. Однако это не получилось бы, потому что из-за приоритета &lt;code&gt;display-buffer-base-action&lt;/code&gt; над &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; в то время &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; уже выигрывал бы гонку. На самом деле это:</target>
        </trans-unit>
        <trans-unit id="420700b2d9abe3e5aa5c3ba405713ee29ec392d5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;eval-expression-debug-on-error&lt;/code&gt; overrides this variable in some cases; see below.</source>
          <target state="translated">Обратите внимание, что в некоторых случаях &lt;code&gt;eval-expression-debug-on-error&lt;/code&gt; переопределяет эту переменную; Смотри ниже.</target>
        </trans-unit>
        <trans-unit id="bcbdaf4d50a8c86ab39d55059a3ac469c00b587e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;expand-file-name&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; expand environment variables; only &lt;code&gt;substitute-in-file-name&lt;/code&gt; does that:</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;expand-file-name&lt;/code&gt; никак &lt;em&gt;не&lt;/em&gt; переменные окружения; только имя- &lt;code&gt;substitute-in-file-name&lt;/code&gt; делает это:</target>
        </trans-unit>
        <trans-unit id="ab80ac2f4a9d468cbc4712bf3ee278edec445477" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;let&lt;/code&gt; bindings are treated specially by the Emacs Lisp implementation. There is no way to duplicate this unwinding and rewinding behavior other than by using &lt;code&gt;let&lt;/code&gt;. For example, a manual implementation of &lt;code&gt;let&lt;/code&gt; written using &lt;code&gt;unwind-protect&lt;/code&gt; cannot arrange for variable values to be thread-specific.</source>
          <target state="translated">Обратите внимание, что привязки &lt;code&gt;let&lt;/code&gt; обрабатываются реализацией Emacs Lisp специально. Невозможно воспроизвести это поведение при разматывании и перемотке, кроме как с помощью &lt;code&gt;let&lt;/code&gt; . Например, ручная реализация &lt;code&gt;let&lt;/code&gt; , написанная с использованием функции &lt;code&gt;unwind-protect&lt;/code&gt; , не может обеспечить привязку значений переменных к потоку.</target>
        </trans-unit>
        <trans-unit id="89f00f3fb6940c8e5695af8eb8543d457737771c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;macroexpand&lt;/code&gt; does not look at the subexpressions of &lt;var&gt;form&lt;/var&gt; (although some macro definitions may do so). Even if they are macro calls themselves, &lt;code&gt;macroexpand&lt;/code&gt; does not expand them.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;macroexpand&lt;/code&gt; не смотрит на подвыражения &lt;var&gt;form&lt;/var&gt; (хотя некоторые определения макросов могут это делать). Даже если они сами являются вызовами макросов, &lt;code&gt;macroexpand&lt;/code&gt; не расширяет их.</target>
        </trans-unit>
        <trans-unit id="d670e88e4393319b698452d1022060ef368672e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;nil&lt;/code&gt;, being both a valid alist and a valid plist, represents &lt;code&gt;{}&lt;/code&gt;, the empty JSON object; not &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, or an empty array, all of which are different JSON values.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;nil&lt;/code&gt; , будучи одновременно действительным списком и действительным списком, представляет &lt;code&gt;{}&lt;/code&gt; , пустой объект JSON; не &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; или пустой массив, все из которых являются разными значениями JSON.</target>
        </trans-unit>
        <trans-unit id="9fa6019796c4614fd1ce6adb41579f6d542fd75e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;set-window-hscroll&lt;/code&gt; may appear not to work if you test it by evaluating a call with</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;set-window-hscroll&lt;/code&gt; может показаться неработающим, если вы проверите его, оценив вызов с помощью</target>
        </trans-unit>
        <trans-unit id="2ea6c975bcb32bc398a9332341b86368aab4d1e0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sort-columns&lt;/code&gt; rejects text that contains tabs, because tabs could be split across the specified columns. Use</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;sort-columns&lt;/code&gt; отклоняет текст, содержащий вкладки, поскольку вкладки могут быть разделены по указанным столбцам. Использовать</target>
        </trans-unit>
        <trans-unit id="e14386726913a3c2fd59bf734e821066eca6e0b8" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;condition&lt;/var&gt; will only be evaluated when redisplay examines the text where this display spec is located, so this feature is best suited for conditions that are relatively stable, i.e. yield, for each particular buffer position, the same results on every evaluation. If the results change for the same text location, e.g., if the result depends on the position of point, then the conditional specification might not do what you want, because redisplay examines only those parts of buffer text where it has reasons to assume that something changed since the last display cycle.</source>
          <target state="translated">Обратите внимание, что &lt;var&gt;condition&lt;/var&gt; будет оцениваться только тогда, когда redisplay исследует текст, в котором находится эта спецификация отображения, поэтому эта функция лучше всего подходит для условий, которые являются относительно стабильными, то есть дают для каждой конкретной позиции буфера одинаковые результаты при каждой оценке. Если результаты меняются для одного и того же места текста, например, если результат зависит от положения точки, тогда условная спецификация может не делать то, что вы хотите, потому что при повторном отображении проверяются только те части текста буфера, где есть основания предполагать, что что-то изменилось с момента последнего цикла отображения.</target>
        </trans-unit>
        <trans-unit id="11c86dc7160f3159d0caf4f8ca652e035830aeb9" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;row&lt;/var&gt; is counted from the top of the text area. If the window given by &lt;var&gt;position&lt;/var&gt; possesses a header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;) or a tab line, they are &lt;em&gt;not&lt;/em&gt; included in the &lt;var&gt;row&lt;/var&gt; count.</source>
          <target state="translated">Обратите внимание, что &lt;var&gt;row&lt;/var&gt; отсчитывается от верха текстовой области. Если окно, заданное &lt;var&gt;position&lt;/var&gt; имеет строку заголовка (см. &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Строки заголовка&lt;/a&gt; ) или строку табуляции, они &lt;em&gt;не&lt;/em&gt; включаются в счетчик &lt;var&gt;row&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="36140c7862902330c0ed8b4c4f62d98557115715" translate="yes" xml:space="preserve">
          <source>Note that C code cannot call functions by name unless they are defined in C. The way to call a function written in Lisp is to use &lt;code&gt;Ffuncall&lt;/code&gt;, which embodies the Lisp function &lt;code&gt;funcall&lt;/code&gt;. Since the Lisp function &lt;code&gt;funcall&lt;/code&gt; accepts an unlimited number of arguments, in C it takes two: the number of Lisp-level arguments, and a one-dimensional array containing their values. The first Lisp-level argument is the Lisp function to call, and the rest are the arguments to pass to it.</source>
          <target state="translated">Обратите внимание, что код C не может вызывать функции по имени, если они не определены в C. Способ вызова функции, написанной на Lisp, заключается в использовании &lt;code&gt;Ffuncall&lt;/code&gt; , который воплощает Lisp-функцию &lt;code&gt;funcall&lt;/code&gt; . Поскольку Lisp-функция &lt;code&gt;funcall&lt;/code&gt; принимает неограниченное количество аргументов, в C она принимает два: количество аргументов уровня Lisp и одномерный массив, содержащий их значения. Первый аргумент уровня Lisp - это вызываемая функция Lisp, а остальные - аргументы, передаваемые ей.</target>
        </trans-unit>
        <trans-unit id="e556b978b826723508b3c9b15f0f641cf8aad16e" translate="yes" xml:space="preserve">
          <source>Note that Emacs automatically saves and restores the match data while executing filter functions. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что Emacs автоматически сохраняет и восстанавливает данные совпадений при выполнении функций фильтрации. См. &lt;a href=&quot;match-data#Match-Data&quot;&gt;Данные соответствия&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="849766f54cbb0ac387cb87a85961815edd45103c" translate="yes" xml:space="preserve">
          <source>Note that Emacs automatically saves and restores the match data while executing sentinels. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что Emacs автоматически сохраняет и восстанавливает данные совпадений при выполнении контрольных сигналов. См. &lt;a href=&quot;match-data#Match-Data&quot;&gt;Данные соответствия&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd5df05fa87dff11a9d0af24fb74e840bb6e9f14" translate="yes" xml:space="preserve">
          <source>Note that Emacs sometimes uses non-numeric priority values for some of its internal overlays, so do not try to do arithmetic on the priority of an overlay (unless it is one that you created). In particular, the overlay used for showing the region uses a priority value of the form &lt;code&gt;(&lt;var&gt;primary&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;secondary&lt;/var&gt;)&lt;/code&gt;, where the &lt;var&gt;primary&lt;/var&gt; value is used as described above, and &lt;var&gt;secondary&lt;/var&gt; is the fallback value used when &lt;var&gt;primary&lt;/var&gt; and the nesting considerations fail to resolve the precedence between overlays. However, you are advised not to design Lisp programs based on this implementation detail; if you need to put overlays in priority order, use the &lt;var&gt;sorted&lt;/var&gt; argument of &lt;code&gt;overlays-at&lt;/code&gt;. See &lt;a href=&quot;finding-overlays#Finding-Overlays&quot;&gt;Finding Overlays&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что Emacs иногда использует нечисловые значения приоритета для некоторых из своих внутренних оверлеев, поэтому не пытайтесь выполнять арифметические действия с приоритетом наложения (если только он не создан вами). В частности, наложение используется для показа области использует значение приоритета формы &lt;code&gt;(&lt;var&gt;primary&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;secondary&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;primary&lt;/var&gt; значение используются , как описано выше, и &lt;var&gt;secondary&lt;/var&gt; является резервным значение используется , когда &lt;var&gt;primary&lt;/var&gt; и гнездовые соображения не разрешить приоритет между наложениями. Однако вам не рекомендуется разрабатывать программы на Лиспе на основе этой детали реализации; если вам нужно расположить оверлеи в порядке приоритета, используйте аргумент &lt;var&gt;sorted&lt;/var&gt; &lt;code&gt;overlays-at&lt;/code&gt; . См. &lt;a href=&quot;finding-overlays#Finding-Overlays&quot;&gt;Поиск наложений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d3be1a87b3711b91ae65cc80a7d5b435901ca0c" translate="yes" xml:space="preserve">
          <source>Note that Emacs tries to expand macros when loading an uncompiled Lisp file. This is not always possible, but if it is, it speeds up subsequent execution. See &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;How Programs Do Loading&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что Emacs пытается раскрыть макросы при загрузке некомпилированного файла Lisp. Это не всегда возможно, но если да, то последующее выполнение ускоряется. Посмотрите, &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;как программы загружаются&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b3adfb09c7f22559fa8fff3314fa3e947a0a9c9" translate="yes" xml:space="preserve">
          <source>Note that a frame cannot be deleted as long as its minibuffer serves as surrogate minibuffer for another frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;). Normally, you cannot delete a frame if all other frames are invisible, but if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then you are allowed to do so.</source>
          <target state="translated">Обратите внимание, что кадр не может быть удален, пока его минибуфер служит суррогатным минибуфером для другого кадра (см. &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Минибуферы и кадры&lt;/a&gt; ). Обычно вы не можете удалить фрейм, если все остальные фреймы невидимы, но если &lt;var&gt;force&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , вы можете это сделать.</target>
        </trans-unit>
        <trans-unit id="6c88bb0b96b0659e2468d8c7144a4535dc553f33" translate="yes" xml:space="preserve">
          <source>Note that a sublist specification written as &lt;code&gt;(specs .  nil)&lt;/code&gt; is equivalent to &lt;code&gt;(specs)&lt;/code&gt;, and &lt;code&gt;(specs .
(sublist-elements&amp;hellip;))&lt;/code&gt; is equivalent to &lt;code&gt;(specs
sublist-elements&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что спецификация подсписка, записанная как &lt;code&gt;(specs . nil)&lt;/code&gt; , эквивалентна &lt;code&gt;(specs)&lt;/code&gt; , а &lt;code&gt;(specs . (sublist-elements&amp;hellip;))&lt;/code&gt; эквивалентна &lt;code&gt;(specs sublist-elements&amp;hellip;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b700a940d8e3ee969e5d08838da33d645a36c49b" translate="yes" xml:space="preserve">
          <source>Note that a symbol used as a function name may also be used as a variable; these two uses of a symbol are independent and do not conflict. (This is not the case in some dialects of Lisp, like Scheme.)</source>
          <target state="translated">Обратите внимание,что символ,используемый в качестве имени функции,может также использоваться в качестве переменной;эти два вида использования символа являются независимыми и не конфликтуют друг с другом.(Это не так в некоторых диалектах Lisp,например Scheme).</target>
        </trans-unit>
        <trans-unit id="0e7d278c76ca3c97b7fc7f52a288a7ed8d2b5fc0" translate="yes" xml:space="preserve">
          <source>Note that all functions described below will respect the adherence of frames (and all other window-system windows) to their respective z-group (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, you usually cannot lower a frame below that of the desktop window and you cannot raise a frame whose &lt;code&gt;z-group&lt;/code&gt; parameter is &lt;code&gt;nil&lt;/code&gt; above the window-system&amp;rsquo;s taskbar or tooltip window.</source>
          <target state="translated">Обратите внимание, что все функции, описанные ниже, будут учитывать соответствие фреймов (и всех других окон оконной системы) их соответствующей z-группе (см. &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Параметры положения&lt;/a&gt; ). Например, вы обычно не можете опустить фрейм ниже окна рабочего стола, и вы не можете поднять фрейм, чей параметр &lt;code&gt;z-group&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; над панелью задач оконной системы или окном всплывающей подсказки.</target>
        </trans-unit>
        <trans-unit id="1eca8603245bea5b809eedfce8382a27e1e6ac6e" translate="yes" xml:space="preserve">
          <source>Note that among the internal functions listed here, &lt;code&gt;display-buffer--maybe-same-window&lt;/code&gt; is effectively ignored while &lt;code&gt;display-buffer--maybe-pop-up-frame-or-window&lt;/code&gt; actually runs &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что среди внутренних функций, перечисленных здесь, &lt;code&gt;display-buffer--maybe-same-window&lt;/code&gt; эффективно игнорируется, а &lt;code&gt;display-buffer--maybe-pop-up-frame-or-window&lt;/code&gt; фактически запускает &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; . .</target>
        </trans-unit>
        <trans-unit id="7d006d7d82c4cf8967401facb8495eb53ce2b548" translate="yes" xml:space="preserve">
          <source>Note that any functions added to these hooks by your initial file are usually not run for the initial frame, since Emacs reads the initial file only after creating that frame. However, if the initial frame is specified to use a separate minibuffer frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;), the functions will be run for both, the minibuffer-less and the minibuffer frame.</source>
          <target state="translated">Обратите внимание, что любые функции, добавленные к этим перехватчикам вашим начальным файлом, обычно не запускаются для начального кадра, поскольку Emacs читает начальный файл только после создания этого кадра. Однако, если начальный кадр задан для использования отдельного кадра минибуфера (см. &amp;laquo; &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Минибуферы и кадры&amp;raquo;&lt;/a&gt; ), функции будут выполняться как для кадра без минибуфера, так и для кадра минибуфера.</target>
        </trans-unit>
        <trans-unit id="6b08f2421a6c05a0ee00e59222f1df594f4fd0e9" translate="yes" xml:space="preserve">
          <source>Note that any non-&lt;code&gt;nil&lt;/code&gt; symbol might be used as an event or an event type; &lt;code&gt;eventp&lt;/code&gt; cannot distinguish whether a symbol is intended by Lisp code to be used as an event.</source>
          <target state="translated">Обратите внимание, что любой символ, отличный от &lt;code&gt;nil&lt;/code&gt; , может использоваться как событие или тип события; &lt;code&gt;eventp&lt;/code&gt; не может определить, предназначен ли символ для использования в коде Lisp в качестве события.</target>
        </trans-unit>
        <trans-unit id="d1591e27e69961a04460b2fe1820737613f07080" translate="yes" xml:space="preserve">
          <source>Note that case conversion is not a one-to-one mapping of codepoints and length of the result may differ from length of the argument. Furthermore, because passing a character forces return type to be a character, functions are unable to perform proper substitution and result may differ compared to treating a one-character string. For example:</source>
          <target state="translated">Обратите внимание,что преобразование регистра не является отображением кодовых точек один к одному и длина результата может отличаться от длины аргумента.Более того,поскольку передача символа заставляет возвращаемый тип быть символом,функции не могут выполнять правильную замену,и результат может отличаться от обработки односимвольной строки.Например:</target>
        </trans-unit>
        <trans-unit id="ce70eb5a1727174c7a315b786b751a0ce2e6823e" translate="yes" xml:space="preserve">
          <source>Note that display tables affect how the mode line is displayed, so if you want to force redisplay of the mode line using a new display table, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что таблицы отображения влияют на способ отображения строки режима, поэтому, если вы хотите принудительно повторно отобразить строку режима с помощью новой таблицы отображения, вызовите &lt;code&gt;force-mode-line-update&lt;/code&gt; (см. &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Формат строки режима&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3e027fd5d05afab1bae33a36130ab5cf384d7efa" translate="yes" xml:space="preserve">
          <source>Note that elements of &lt;code&gt;minor-mode-map-alist&lt;/code&gt; do not have the same structure as elements of &lt;code&gt;minor-mode-alist&lt;/code&gt;. The map must be the &lt;small&gt;CDR&lt;/small&gt; of the element; a list with the map as the second element will not do. The &lt;small&gt;CDR&lt;/small&gt; can be either a keymap (a list) or a symbol whose function definition is a keymap.</source>
          <target state="translated">Обратите внимание, что элементы &lt;code&gt;minor-mode-map-alist&lt;/code&gt; не имеют такой же структуры, как элементы &lt;code&gt;minor-mode-alist&lt;/code&gt; . Карта должна быть &lt;small&gt;CDR&lt;/small&gt; элемента; список с картой в качестве второго элемента не годится. &lt;small&gt;CDR&lt;/small&gt; может быть либо раскладкой (список) или символ, функция которого определение является раскладкой.</target>
        </trans-unit>
        <trans-unit id="5c6f5e6a17b21c98d8da299e04e71ec5bc5fccaa" translate="yes" xml:space="preserve">
          <source>Note that for &lt;code&gt;nthcdr&lt;/code&gt;, the list argument of the function must itself be a valid &lt;var&gt;place&lt;/var&gt; form. For example, &lt;code&gt;(setf (nthcdr
0 foo) 7)&lt;/code&gt; will set &lt;code&gt;foo&lt;/code&gt; itself to 7.</source>
          <target state="translated">Обратите внимание, что для &lt;code&gt;nthcdr&lt;/code&gt; аргумент list функции должен сам быть допустимой формой &lt;var&gt;place&lt;/var&gt; . Например, &lt;code&gt;(setf (nthcdr 0 foo) 7)&lt;/code&gt; установит для самого &lt;code&gt;foo&lt;/code&gt; значение 7.</target>
        </trans-unit>
        <trans-unit id="b7031d4a6bb1fd17ff90dc3b21b4c28dae0691db" translate="yes" xml:space="preserve">
          <source>Note that hyphen (&lt;code&gt;-&lt;/code&gt;) is special in strings in this construct, since it acts as a range separator. To include a hyphen, add it as a separate character or single-character string. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Обратите внимание, что дефис ( &lt;code&gt;-&lt;/code&gt; ) используется в строках этой конструкции специально, поскольку он действует как разделитель диапазона. Чтобы включить дефис, добавьте его как отдельный символ или односимвольную строку. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="71a252b7e10406a1efe10d060f22023cc1adeb54" translate="yes" xml:space="preserve">
          <source>Note that if Emacs already has a buffer visiting the same file non-literally, it will not visit the same file literally, but instead just switch to the existing buffer. If you want to be sure of accessing a file&amp;rsquo;s contents literally, you should create a temporary buffer and then read the file contents into it using &lt;code&gt;insert-file-contents-literally&lt;/code&gt; (see &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что если в Emacs уже есть буфер, обращающийся к тому же файлу не буквально, он не будет посещать тот же файл буквально, а вместо этого просто переключится на существующий буфер. Если вы хотите быть уверены в буквальном доступе к содержимому файла, вам следует создать временный буфер, а затем прочитать в него содержимое файла, используя команду &lt;code&gt;insert-file-contents-literally&lt;/code&gt; (см. &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Чтение из файлов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7aabecd82de173080e0d6a40e3c8b6bd5b301744" translate="yes" xml:space="preserve">
          <source>Note that if the string to be displayed in the margin doesn&amp;rsquo;t specify a face, its face is determined using the same rules and priorities as it is for strings displayed in the text area (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). If this results in undesirable &amp;ldquo;leaking&amp;rdquo; of faces into the margin, make sure the string has an explicit face specified for it.</source>
          <target state="translated">Обратите внимание, что если строка, которая должна отображаться на поле, не указывает грань, ее грань определяется с использованием тех же правил и приоритетов, что и для строк, отображаемых в текстовой области (см. &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Отображение граней&lt;/a&gt; ). Если это приводит к нежелательному &amp;laquo;просачиванию&amp;raquo; граней на поля, убедитесь, что для строки указано явное лицо.</target>
        </trans-unit>
        <trans-unit id="d4e506505176e0289fea2ef20ed99c25d90708a5" translate="yes" xml:space="preserve">
          <source>Note that if the text also has a &lt;code&gt;height&lt;/code&gt; display specification, which was specified before (i.e. to the left of) &lt;code&gt;raise&lt;/code&gt;, the latter will affect the amount of raising or lowering in pixels, because that is based on the height of the text being raised. Therefore, if you want to display a sub- or superscript that is smaller than the normal text height, consider specifying &lt;code&gt;raise&lt;/code&gt; before &lt;code&gt;height&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если текст также имеет спецификацию отображения &lt;code&gt;height&lt;/code&gt; , которая была указана до (то есть слева от) &lt;code&gt;raise&lt;/code&gt; , последнее повлияет на величину поднятия или опускания в пикселях, потому что это зависит от высоты поднимаемого текста. . Поэтому, если вы хотите отобразить дополнительный или верхний индекс, который меньше нормальной высоты текста, подумайте о том, чтобы указать &lt;code&gt;raise&lt;/code&gt; перед &lt;code&gt;height&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f83321e2dc6362ff6bb142d1319ba7d1841f375" translate="yes" xml:space="preserve">
          <source>Note that image types &lt;code&gt;pbm&lt;/code&gt; and &lt;code&gt;xbm&lt;/code&gt; do not need entries in this variable because they do not depend on external libraries and are always available in Emacs.</source>
          <target state="translated">Обратите внимание, что типы изображений &lt;code&gt;pbm&lt;/code&gt; и &lt;code&gt;xbm&lt;/code&gt; не нуждаются в записях в этой переменной, потому что они не зависят от внешних библиотек и всегда доступны в Emacs.</target>
        </trans-unit>
        <trans-unit id="2b90bd2256efbea7d91a8f1731d6cbc9dc04839d" translate="yes" xml:space="preserve">
          <source>Note that in contrast to &lt;code&gt;or&lt;/code&gt;, both arguments are always evaluated.</source>
          <target state="translated">Обратите внимание, что, в отличие от &lt;code&gt;or&lt;/code&gt; , всегда оцениваются оба аргумента.</target>
        </trans-unit>
        <trans-unit id="f1d398c647559c7e5536cae0d92bd8598b1b5529" translate="yes" xml:space="preserve">
          <source>Note that in the third example, the function returned</source>
          <target state="translated">Обратите внимание,что в третьем примере возвращаемая функция</target>
        </trans-unit>
        <trans-unit id="f10b1133c79e4544a6c4fd2a1bf8f43bddfa17d8" translate="yes" xml:space="preserve">
          <source>Note that keymaps and keyboard macros (strings and vectors) are not valid functions, so a symbol with a keymap, string, or vector as its function definition is invalid as a function. It is, however, valid as a key binding. If the definition is a keyboard macro, then the symbol is also valid as an argument to &lt;code&gt;command-execute&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что раскладки клавиатуры и макросы клавиатуры (строки и векторы) не являются допустимыми функциями, поэтому символ с раскладкой клавиатуры, строкой или вектором в качестве определения функции недействителен как функция. Однако он действителен как привязка ключа. Если определение является макросом клавиатуры, то символ также действителен в качестве аргумента для &lt;code&gt;command-execute&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Интерактивный вызов&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f7ca497421798c821a09facd3f3452f27743e204" translate="yes" xml:space="preserve">
          <source>Note that negative values do not permit to align the right or bottom edge of &lt;var&gt;frame&lt;/var&gt; exactly at the right or bottom edge of its display or parent frame. Neither do they allow to specify a position that does not lie within the edges of the display or parent frame. The frame parameters &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) allow to do that, but may still fail to provide good results for the initial or a new frame.</source>
          <target state="translated">Обратите внимание, что отрицательные значения не позволяют выровнять правый или нижний край &lt;var&gt;frame&lt;/var&gt; точно по правому или нижнему краю его дисплея или родительского кадра. Они также не позволяют указывать позицию, которая не находится в пределах границ дисплея или родительского кадра. Параметры кадра &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;top&lt;/code&gt; (см. &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Параметры положения&lt;/a&gt; ) позволяют это сделать, но все же могут не обеспечить хороших результатов для исходного или нового кадра.</target>
        </trans-unit>
        <trans-unit id="6bb86bc06ff9fe96cf961221500aba7002f6114c" translate="yes" xml:space="preserve">
          <source>Note that on multi-monitor displays (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;), the window manager might position the frame differently than specified by the positional parameters in &lt;var&gt;parameters&lt;/var&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, some window managers have a policy of displaying the frame on the monitor that contains the largest part of the window (a.k.a. the &lt;em&gt;dominating&lt;/em&gt; monitor).</source>
          <target state="translated">Обратите внимание, что на дисплеях с несколькими мониторами (см. &amp;laquo; &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Несколько терминалов&amp;raquo;&lt;/a&gt; ) оконный менеджер может позиционировать фрейм иначе, чем указано в позиционных параметрах в &lt;var&gt;parameters&lt;/var&gt; (см. &amp;laquo; &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Параметры положения&amp;raquo;&lt;/a&gt; ). Например, некоторые оконные менеджеры имеют политику отображения кадра на мониторе, который содержит большую часть окна (также известный как &lt;em&gt;доминирующий&lt;/em&gt; монитор).</target>
        </trans-unit>
        <trans-unit id="451dabba0c45d6a9da92c12dfcbef25151b92f65" translate="yes" xml:space="preserve">
          <source>Note that once you have defined a face (usually with &lt;code&gt;defface&lt;/code&gt;), you cannot later undefine this face safely, except by restarting Emacs.</source>
          <target state="translated">Обратите внимание, что после того, как вы определили грань (обычно с помощью &lt;code&gt;defface&lt;/code&gt; ), вы не сможете впоследствии безопасно отменить определение этой грани, кроме как перезапустив Emacs.</target>
        </trans-unit>
        <trans-unit id="8be3a3df08c2c43245d05ddcd5d07fbab7b209b4" translate="yes" xml:space="preserve">
          <source>Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once. See &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;, for a comparison of property lists and association lists.</source>
          <target state="translated">Обратите внимание, что списки свойств похожи на списки ассоциаций в нескольких отношениях. Список свойств ведет себя как список ассоциаций, в котором каждый ключ может встречаться только один раз. См. &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Списки свойств&lt;/a&gt; для сравнения списков свойств и списков ассоциаций.</target>
        </trans-unit>
        <trans-unit id="cf01d48b51913f0cf00ab32bac6c884aa95173f2" translate="yes" xml:space="preserve">
          <source>Note that providing such an entry alone does not necessarily make the window as tall as specified by its value. To actually resize an existing window or make a new window as tall as specified by that value, a &lt;code&gt;window-height&lt;/code&gt; entry specifying that value should be provided as well. Such a &lt;code&gt;window-height&lt;/code&gt; entry can, however, specify a completely different value or ask the window height to be fit to that of its buffer in which case the &lt;code&gt;window-min-height&lt;/code&gt; entry provides the guaranteed minimum height of the window used.</source>
          <target state="translated">Обратите внимание, что предоставление только такой записи не обязательно делает окно таким высоким, как указано в его значении. Чтобы фактически изменить размер существующего окна или сделать новое окно таким же высоким, как указано в этом значении, также должна быть предоставлена ​​запись &lt;code&gt;window-height&lt;/code&gt; определяющая это значение. Однако такая запись &lt;code&gt;window-height&lt;/code&gt; может указывать совершенно другое значение или требовать, чтобы высота окна соответствовала высоте его буфера, и в этом случае запись &lt;code&gt;window-min-height&lt;/code&gt; обеспечивает гарантированную минимальную высоту используемого окна.</target>
        </trans-unit>
        <trans-unit id="a8d1c86e0cb1777d5c4381401ecb75f9d100b2f8" translate="yes" xml:space="preserve">
          <source>Note that references to &lt;code&gt;foo&lt;/code&gt; in &lt;var&gt;body&lt;/var&gt; access the buffer-local binding of buffer &amp;lsquo;</source>
          <target state="translated">Обратите внимание, что ссылки на &lt;code&gt;foo&lt;/code&gt; в &lt;var&gt;body&lt;/var&gt; обращаются к локальной привязке буфера buffer '</target>
        </trans-unit>
        <trans-unit id="944ce22b3c1e0e4361ff98e0b47922f894f4954d" translate="yes" xml:space="preserve">
          <source>Note that remapping only takes place through active keymaps; for example, putting a remapping in a prefix keymap like &lt;code&gt;ctl-x-map&lt;/code&gt; typically has no effect, as such keymaps are not themselves active. In addition, remapping only works through a single level; in the following example,</source>
          <target state="translated">Обратите внимание, что переназначение происходит только через активные раскладки клавиатуры; например, установка переназначения в префиксную раскладку клавиатуры, такую как &lt;code&gt;ctl-x-map&lt;/code&gt; , обычно не имеет никакого эффекта, так как такие раскладки сами по себе не активны. Кроме того, переназначение работает только на одном уровне; в следующем примере</target>
        </trans-unit>
        <trans-unit id="aa44f3362212f49d475dc95b39b81576e77893a3" translate="yes" xml:space="preserve">
          <source>Note that setting this variable to a non-&lt;code&gt;nil&lt;/code&gt; value does not change the fact that auto-saving is different from saving the buffer; e.g., the hooks described in &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Saving Buffers&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; run when a buffer is auto-saved.</source>
          <target state="translated">Обратите внимание, что установка для этой переменной значения, отличного от &lt;code&gt;nil&lt;/code&gt; , не меняет того факта, что автосохранение отличается от сохранения буфера; например, перехватчики, описанные в разделе &amp;laquo; &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Сохранение буферов&amp;raquo;&lt;/a&gt; , &lt;em&gt;не&lt;/em&gt; запускаются, когда буфер автоматически сохраняется.</target>
        </trans-unit>
        <trans-unit id="ce4d07d18464ef749e1edb147a33de09d0f7af7e" translate="yes" xml:space="preserve">
          <source>Note that several rings in Emacs, like the kill ring and the mark ring, are actually implemented as simple lists, &lt;em&gt;not&lt;/em&gt; using the &lt;code&gt;ring&lt;/code&gt; package; thus the following functions won&amp;rsquo;t work on them.</source>
          <target state="translated">Обратите внимание, что некоторые кольца в Emacs, такие как кольцо уничтожения и кольцо меток, фактически реализованы как простые списки, а &lt;em&gt;не&lt;/em&gt; с использованием пакета &lt;code&gt;ring&lt;/code&gt; ; поэтому следующие функции с ними работать не будут.</target>
        </trans-unit>
        <trans-unit id="ada2f27c9ba203cc421e71266f32365f19ed4b0f" translate="yes" xml:space="preserve">
          <source>Note that since &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; is called by &lt;code&gt;bury-buffer&lt;/code&gt;, &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; and &lt;code&gt;quit-restore-window&lt;/code&gt; as well, customizing this option may also affect the behavior of Emacs when a window is quit or a buffer gets buried or killed.</source>
          <target state="translated">Обратите внимание: поскольку &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; вызывается &lt;code&gt;bury-buffer&lt;/code&gt; , &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; и &lt;code&gt;quit-restore-window&lt;/code&gt; , настройка этого параметра также может повлиять на поведение Emacs при выходе из окна или буфер похоронен или убит.</target>
        </trans-unit>
        <trans-unit id="df75894a436d2ac6f25b076d7908978b97f93102" translate="yes" xml:space="preserve">
          <source>Note that since this is a function, it can only return non-&lt;code&gt;nil&lt;/code&gt; for variables which are permanently special, but not for those that are only special in the current lexical scope.</source>
          <target state="translated">Обратите внимание, что поскольку это функция, она может возвращать &lt;code&gt;nil&lt;/code&gt; для переменных, которые являются постоянно особенными, но не для тех, которые являются особенными только в текущей лексической области видимости.</target>
        </trans-unit>
        <trans-unit id="2fac15f40439742424e3aa18f0429ca4f01e2aaf" translate="yes" xml:space="preserve">
          <source>Note that sometimes selecting a window is not enough to show it, or make its frame the top-most frame on display: you may also need to raise the frame or make sure input focus is directed to that frame. See &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что иногда выбора окна недостаточно, чтобы его показать или сделать его фрейм самым верхним фреймом на экране: вам также может потребоваться поднять фрейм или убедиться, что фокус ввода направлен на этот фрейм. См. &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Фокус ввода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1028e973fd6d45e7d7652a7eded330cbb5470222" translate="yes" xml:space="preserve">
          <source>Note that space properties are treated as paragraph separators for the purposes of reordering bidirectional text for display. See &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;, for the details.</source>
          <target state="translated">Обратите внимание, что свойства пробелов обрабатываются как разделители абзацев с целью переупорядочения двунаправленного текста для отображения. Подробнее см. &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Двунаправленное отображение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb5ad3eb4a2271a938c9aa7f77ae8d741838eaf" translate="yes" xml:space="preserve">
          <source>Note that specifying a value, even &lt;code&gt;nil&lt;/code&gt;, marks the variable as special permanently. Whereas if &lt;var&gt;value&lt;/var&gt; is omitted then the variable is only marked special locally (i.e. within the current lexical scope, or file if at the top-level). This can be useful for suppressing byte compilation warnings, see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что указание значения, даже &lt;code&gt;nil&lt;/code&gt; , навсегда отмечает переменную как особую. В то время как, если &lt;var&gt;value&lt;/var&gt; не указано, переменная помечается как специальная только локально (то есть в пределах текущей лексической области видимости или файла, если она находится на верхнем уровне). Это может быть полезно для подавления предупреждений о компиляции байтов, см. &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Ошибки компилятора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0bceaee80bf44f350b2b336e7bdc4aca04effe6" translate="yes" xml:space="preserve">
          <source>Note that storing a new binding for</source>
          <target state="translated">Обратите внимание,что хранение нового переплета для</target>
        </trans-unit>
        <trans-unit id="ca0f3720c830567e36124202fdc192dd9c282156" translate="yes" xml:space="preserve">
          <source>Note that storing new values into the &lt;small&gt;CDR&lt;/small&gt;s of cons cells in this list does &lt;em&gt;not&lt;/em&gt; change the buffer-local values of the variables.</source>
          <target state="translated">Обратите внимание, что сохранение новых значений в &lt;small&gt;CDR&lt;/small&gt; cons-ячеек в этом списке &lt;em&gt;не&lt;/em&gt; изменяет локальные в буфере значения переменных.</target>
        </trans-unit>
        <trans-unit id="bcb5445ab75b38c5ccd760396b2859fa80f84f86" translate="yes" xml:space="preserve">
          <source>Note that text in paragraphs whose base direction is right-to-left (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;) moves in the opposite direction: e.g., it moves to the right when &lt;code&gt;scroll-left&lt;/code&gt; is invoked with a positive value of &lt;var&gt;count&lt;/var&gt;.</source>
          <target state="translated">Обратите внимание, что текст в абзацах, у которых базовое направление - справа налево (см. &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Двунаправленное отображение&lt;/a&gt; ), перемещается в противоположном направлении: например, он перемещается вправо, когда &lt;code&gt;scroll-left&lt;/code&gt; вызывается с положительным значением &lt;var&gt;count&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">Обратите внимание,что</target>
        </trans-unit>
        <trans-unit id="e36a773ef709e536a82e2d886a7cd51f572df233" translate="yes" xml:space="preserve">
          <source>Note that the &amp;lsquo;</source>
          <target state="translated">Обратите внимание, что '</target>
        </trans-unit>
        <trans-unit id="a6469f422f7ec9a279d6ed4b82f424847330e523" translate="yes" xml:space="preserve">
          <source>Note that the argument &lt;code&gt;(assq 'handler list)&lt;/code&gt; appears in the expansion.</source>
          <target state="translated">Обратите внимание, что аргумент &lt;code&gt;(assq 'handler list)&lt;/code&gt; появляется в раскрытии.</target>
        </trans-unit>
        <trans-unit id="4368eeb627f6bc57851f8ed6589cb35a499c91b1" translate="yes" xml:space="preserve">
          <source>Note that the arguments can be the results of other function calls, as in this example:</source>
          <target state="translated">Обратите внимание,что аргументами могут быть результаты вызова других функций,как в данном примере:</target>
        </trans-unit>
        <trans-unit id="60b6c61854c649097ce19157cbb7f0ddb8c5eefa" translate="yes" xml:space="preserve">
          <source>Note that the docstrings mention &lt;var&gt;args&lt;/var&gt; (in this case, only one: &lt;code&gt;n&lt;/code&gt;) in the usual way, and also mention &lt;code&gt;EXPVAL&lt;/code&gt; by convention. The first rewrite (i.e., &lt;var&gt;body&lt;/var&gt; for &lt;code&gt;less-than&lt;/code&gt;) uses one core pattern: &lt;code&gt;pred&lt;/code&gt;. The second uses two core patterns: &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt;, as well as the newly-defined pattern &lt;code&gt;less-than&lt;/code&gt;. Both use a single backquote construct (see &lt;a href=&quot;backquote#Backquote&quot;&gt;Backquote&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что в строках документации указываются &lt;var&gt;args&lt;/var&gt; (в данном случае только один: &lt;code&gt;n&lt;/code&gt; ) обычным способом, а также упоминается &lt;code&gt;EXPVAL&lt;/code&gt; по соглашению. Первая перезапись (т. Е. &lt;var&gt;body&lt;/var&gt; для &lt;code&gt;less-than&lt;/code&gt; ) использует один основной шаблон: &lt;code&gt;pred&lt;/code&gt; . Второй использует два основных шаблона: &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;pred&lt;/code&gt; , а также новый шаблон &amp;laquo; &lt;code&gt;less-than&lt;/code&gt; . Оба используют одну конструкцию &lt;a href=&quot;backquote#Backquote&quot;&gt;обратной кавычки&lt;/a&gt; (см. Обратная кавычка ).</target>
        </trans-unit>
        <trans-unit id="c2edb0886e867e4ca5989b4ab0140428caf42280" translate="yes" xml:space="preserve">
          <source>Note that the documentation strings for Emacs are not the same thing as the Emacs manual. Manuals have their own source files, written in the Texinfo language; documentation strings are specified in the definitions of the functions and variables they apply to. A collection of documentation strings is not sufficient as a manual because a good manual is not organized in that fashion; it is organized in terms of topics of discussion.</source>
          <target state="translated">Обратите внимание,что строки документации для Emacs не являются тем же самым,что и руководство Emacs.Руководства имеют собственные исходные файлы,написанные на языке Texinfo;строки документации указываются в определениях функций и переменных,к которым они применяются.Коллекции строк документации недостаточно в качестве руководства,потому что хорошее руководство не организовано таким образом;оно организовано с точки зрения тем для обсуждения.</target>
        </trans-unit>
        <trans-unit id="fca742cf8fd5cf459a0d4b4751312094297df69c" translate="yes" xml:space="preserve">
          <source>Note that the effect of restacking will only hold as long as neither of the involved frames is iconified or made invisible. You can use the &lt;code&gt;z-group&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) frame parameter to add a frame to a group of frames permanently shown above or below other frames. As long as a frame belongs to one of these groups, restacking it will only affect its relative stacking position within that group. The effect of restacking frames belonging to different z-groups is undefined. You can list frames in their current stacking order with the function &lt;code&gt;frame-list-z-order&lt;/code&gt; (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что эффект переупаковки будет сохраняться только до тех пор, пока ни один из задействованных фреймов не будет отмечен значком или не станет невидимым. Вы можете использовать &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;параметр&lt;/a&gt; кадра &lt;code&gt;z-group&lt;/code&gt; (см. Параметры положения ), чтобы добавить кадр к группе кадров, постоянно отображаемой над или под другими кадрами. Пока фрейм принадлежит к одной из этих групп, переупаковка повлияет только на его относительное положение в стопке внутри этой группы. Эффект от переупаковки кадров, принадлежащих разным z-группам, не определен. Вы можете перечислить фреймы в их текущем порядке наложения с помощью функции &lt;code&gt;frame-list-z-order&lt;/code&gt; (см. &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Поиск всех фреймов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2582678e0a51538e9f647014c2a05c8ea4765da3" translate="yes" xml:space="preserve">
          <source>Note that the first &lt;var&gt;form&lt;/var&gt; is evaluated, then the first &lt;var&gt;symbol&lt;/var&gt; is set, then the second &lt;var&gt;form&lt;/var&gt; is evaluated, then the second &lt;var&gt;symbol&lt;/var&gt; is set, and so on:</source>
          <target state="translated">Обратите внимание, что сначала оценивается первая &lt;var&gt;form&lt;/var&gt; , затем устанавливается первый &lt;var&gt;symbol&lt;/var&gt; , затем оценивается вторая &lt;var&gt;form&lt;/var&gt; , затем устанавливается второй &lt;var&gt;symbol&lt;/var&gt; и так далее:</target>
        </trans-unit>
        <trans-unit id="9173ba72010925230c9678e4a9c448ec671403eb" translate="yes" xml:space="preserve">
          <source>Note that the first read skips a space. Reading skips any amount of whitespace preceding the significant text.</source>
          <target state="translated">Обратите внимание,что первое чтение пропускает пробел.При чтении пропускается любое количество пробельных символов,предшествующих основному тексту.</target>
        </trans-unit>
        <trans-unit id="5b4a82bbf9da4eb3b066c08dd5991f582e95b2ff" translate="yes" xml:space="preserve">
          <source>Note that the function specified by this option is called only if the specified frame contains just one live window and there is at least one other frame on the same terminal.</source>
          <target state="translated">Обратите внимание,что функция,указанная этой опцией,вызывается только в том случае,если указанный кадр содержит только одно живое окно и на том же терминале есть хотя бы один другой кадр.</target>
        </trans-unit>
        <trans-unit id="43a4f6baecfda8409de3b10f1d269557bab73567" translate="yes" xml:space="preserve">
          <source>Note that the handling of &lt;code&gt;command-switch-alist&lt;/code&gt; doesn&amp;rsquo;t treat equals signs in &lt;var&gt;option&lt;/var&gt; specially. That is, if there&amp;rsquo;s an option like &lt;code&gt;--name=value&lt;/code&gt; on the command line, then only a &lt;code&gt;command-switch-alist&lt;/code&gt; member whose &lt;code&gt;car&lt;/code&gt; is literally &lt;code&gt;--name=value&lt;/code&gt; will match this option. If you want to parse such options, you need to use &lt;code&gt;command-line-functions&lt;/code&gt; instead (see below).</source>
          <target state="translated">Обратите внимание, что обработка &lt;code&gt;command-switch-alist&lt;/code&gt; не обрабатывает знаки равенства в &lt;var&gt;option&lt;/var&gt; специально. То есть, если в командной строке есть такая опция, как &lt;code&gt;--name=value&lt;/code&gt; , то только член &lt;code&gt;command-switch-alist&lt;/code&gt; , чей &lt;code&gt;car&lt;/code&gt; буквально &lt;code&gt;--name=value&lt;/code&gt; , будет соответствовать этому параметру. Если вы хотите проанализировать такие параметры, вам нужно вместо этого использовать функции &lt;code&gt;command-line-functions&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="10d410d8d2209e47d081d1091cbeb510cad74888" translate="yes" xml:space="preserve">
          <source>Note that the meaning of &lt;code&gt;nil&lt;/code&gt; differs slightly from that of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что значение &lt;code&gt;nil&lt;/code&gt; немного отличается от значения аргумента &lt;var&gt;all-frames&lt;/var&gt; для &lt;code&gt;next-window&lt;/code&gt; (см. &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Циклический порядок окон&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="46305bb5f2b4deb49120db52fdc405524ee1ca0b" translate="yes" xml:space="preserve">
          <source>Note that the minibuffer window used by a frame need not be part of that frame&amp;mdash;a frame that has no minibuffer of its own necessarily uses some other frame&amp;rsquo;s minibuffer window. The minibuffer window of a minibuffer-less frame can be changed by setting that frame&amp;rsquo;s &lt;code&gt;minibuffer&lt;/code&gt; frame parameter (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что окно минибуфера, используемое фреймом, не обязательно должно быть частью этого фрейма - фрейм, не имеющий собственного минибуфера, обязательно использует окно минибуфера какого-либо другого фрейма. Окно минибуфера кадра без минибуфера можно изменить, установив параметр кадра &lt;code&gt;minibuffer&lt;/code&gt; кадра (см. &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Параметры буфера&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29787cca83afbad5cb5731b6b829bddd7a5a6e3f" translate="yes" xml:space="preserve">
          <source>Note that the open and close parentheses remain in the list. The Lisp reader encountered the open parenthesis, decided that it ended the input, and unread it. Another attempt to read from the stream at this point would read &amp;lsquo;</source>
          <target state="translated">Обратите внимание, что открывающая и закрывающая круглые скобки остаются в списке. Читатель Лиспа обнаружил открытую скобку, решил, что она завершает ввод, и не прочитал его. Другая попытка чтения из потока в этот момент будет читать '</target>
        </trans-unit>
        <trans-unit id="59f13de0f3c2b965927d50d1e0831d83e4c0b4e3" translate="yes" xml:space="preserve">
          <source>Note that the option &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; must have a non-&lt;code&gt;nil&lt;/code&gt; value in order to allow horizontal adjustment of windows. Entries are also added that ask for preserving the height of side windows at the top and bottom of the frame and the width of side windows at the left or right of the frame. To assure that side windows retain their respective sizes when maximizing the frame, the variable &lt;code&gt;window-resize-pixelwise&lt;/code&gt; is set to a non-&lt;code&gt;nil&lt;/code&gt; value. See &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что опция &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; должна иметь значение, отличное от &lt;code&gt;nil&lt;/code&gt; , чтобы разрешить горизонтальную настройку окон. Также добавляются записи, которые просят сохранить высоту боковых окон вверху и внизу рамки и ширину боковых окон слева или справа от рамки. Чтобы гарантировать, что боковые окна сохраняют свои соответствующие размеры при максимальном увеличении кадра, для переменной &lt;code&gt;window-resize-pixelwise&lt;/code&gt; установлено значение, отличное от &lt;code&gt;nil&lt;/code&gt; . См. Раздел &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Изменение размера Windows&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a70f1cf74ad105152fa3a136ffd4bd441d193a1" translate="yes" xml:space="preserve">
          <source>Note that the second argument is always the list of &lt;em&gt;all&lt;/em&gt; action alist entries specified by the sources named above. Hence, the first element of that list is the first action alist entry specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, if any. Its last element is the last alist entry of &lt;code&gt;display-buffer-base-action&lt;/code&gt;, if any (the action alist of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; is empty).</source>
          <target state="translated">Обратите внимание, что вторым аргументом всегда является список &lt;em&gt;всех&lt;/em&gt; записей списка действий, указанных в источниках, указанных выше. Следовательно, первый элемент этого списка - первая запись списка действий, заданная &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; , если таковая имеется. Его последний элемент - это последняя запись в списке &lt;code&gt;display-buffer-base-action&lt;/code&gt; , если таковая имеется (список действий &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; пуст).</target>
        </trans-unit>
        <trans-unit id="074011f5871b6c0968cba6e5251ad570a7913126" translate="yes" xml:space="preserve">
          <source>Note that the term &amp;ldquo;command&amp;rdquo;, in this context, refers to an interactively callable function (or function-like object), or a keyboard macro. It does not refer to the key sequence used to invoke a command (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что термин &amp;laquo;команда&amp;raquo; в этом контексте относится к интерактивно вызываемой функции (или объекту, подобному функции), или макросу клавиатуры. Это не относится к последовательности клавиш, используемой для вызова команды (см. &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Таблицы ключей&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b48ed316676b2a77757a76ff8c81c0c3beb1931" translate="yes" xml:space="preserve">
          <source>Note that the time returned by this function excludes the time Emacs was not using the processor, and if the Emacs process has several threads, the returned value is the sum of the processor times used up by all Emacs threads.</source>
          <target state="translated">Обратите внимание,что время,возвращаемое этой функцией,исключает время,в течение которого Emacs не использовал процессор,а если процесс Emacs имеет несколько потоков,то возвращаемое значение-это сумма процессорного времени,израсходованного всеми потоками Emacs.</target>
        </trans-unit>
        <trans-unit id="87ffd6d39e1afd8a7828b54719c1a46abb2defc0" translate="yes" xml:space="preserve">
          <source>Note that the user-level incremental search feature handles case distinctions differently. When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive. But this has nothing to do with the searching functions used in Lisp code. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;Incremental Search&lt;/a&gt; in</source>
          <target state="translated">Обратите внимание, что функция инкрементного поиска на уровне пользователя по-разному обрабатывает регистр символов. Когда строка поиска содержит только буквы нижнего регистра, поиск игнорирует регистр, но когда строка поиска содержит одну или несколько букв верхнего регистра, поиск становится чувствительным к регистру. Но это не имеет ничего общего с функциями поиска, используемыми в коде Lisp. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;Инкрементный поиск&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="aa30ecc6a9801e96a10f51cc845ae8140b1365d1" translate="yes" xml:space="preserve">
          <source>Note that the user-level incremental search feature handles case distinctions differently. When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive. But this has nothing to do with the searching functions used in Lisp code. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;Incremental Search&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06cef1accb1f0afe0d8f8b378512094228d0996" translate="yes" xml:space="preserve">
          <source>Note that the value of the &lt;code&gt;window-atom&lt;/code&gt; parameter does not really matter as long as it is non-&lt;code&gt;nil&lt;/code&gt;. The values assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; just allow for easy retrieval of the original and the new window after that function has been applied. Note also that the &lt;code&gt;window-atom&lt;/code&gt; parameter is the only window parameter assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt;. Further parameters have to be set by the application explicitly via a &lt;code&gt;window-parameters&lt;/code&gt; entry in &lt;var&gt;alist&lt;/var&gt;.</source>
          <target state="translated">Обратите внимание, что значение параметра &lt;code&gt;window-atom&lt;/code&gt; на самом деле не имеет значения, если оно не равно &lt;code&gt;nil&lt;/code&gt; . Значения, присвоенные &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; , просто позволяют легко получить исходное и новое окно после применения этой функции. Также обратите внимание, что параметр &lt;code&gt;window-atom&lt;/code&gt; - единственный параметр окна, назначаемый &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; . Дополнительные параметры должны быть установлены приложением явно через запись &lt;code&gt;window-parameters&lt;/code&gt; в &lt;var&gt;alist&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3fb6d667bc03880b5ccfb18ddea5d35e1c03ca93" translate="yes" xml:space="preserve">
          <source>Note that the value of this variable is ignored when &lt;code&gt;make-process&lt;/code&gt; is called with a non-&lt;code&gt;nil&lt;/code&gt; value of the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, Emacs will communicate with the process using pipes. It is also ignored if ptys are unavailable (MS-Windows).</source>
          <target state="translated">Обратите внимание, что значение этой переменной игнорируется, когда &lt;code&gt;make-process&lt;/code&gt; вызывается с &lt;code&gt;nil&lt;/code&gt; значением параметра &lt;code&gt;:stderr&lt;/code&gt; ; в этом случае Emacs будет взаимодействовать с процессом с помощью каналов. Он также игнорируется, если ptys недоступны (MS-Windows).</target>
        </trans-unit>
        <trans-unit id="4a97b13e6f37fae9d240fea05dd6e0d29f53c80f" translate="yes" xml:space="preserve">
          <source>Note that the values of the above two variables take effect at display time, so let-binding them around code which produces echo-area messages will not work. If you want to prevent resizing of minibuffer windows when displaying long messages, bind the &lt;code&gt;message-truncate-lines&lt;/code&gt; variable instead (see &lt;a href=&quot;echo-area-customization#Echo-Area-Customization&quot;&gt;Echo Area Customization&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что значения двух вышеуказанных переменных вступают в силу во время отображения, поэтому привязка их к коду, который создает сообщения эхо-области, не будет работать. Если вы хотите предотвратить изменение размера окон минибуфера при отображении длинных сообщений, вместо этого привяжите переменную &lt;code&gt;message-truncate-lines&lt;/code&gt; (см. &lt;a href=&quot;echo-area-customization#Echo-Area-Customization&quot;&gt;Настройка эхо-области&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc4faf74f63a3bd8358aed546107967e25cd284b" translate="yes" xml:space="preserve">
          <source>Note that there is no conflict between the variable named &lt;code&gt;list&lt;/code&gt; used in this example and the function named &lt;code&gt;list&lt;/code&gt; described below; any symbol can serve both purposes.</source>
          <target state="translated">Обратите внимание, что нет конфликта между переменной с именем &lt;code&gt;list&lt;/code&gt; , используемой в этом примере, и функцией с именем &lt;code&gt;list&lt;/code&gt; , описанной ниже; любой символ может служить обоим целям.</target>
        </trans-unit>
        <trans-unit id="f915f57254052f46a7173c363fa3e8ad81bbb90f" translate="yes" xml:space="preserve">
          <source>Note that these are the actual outer edges of the window, including any header line, mode line, scroll bar, fringes, window divider and display margins. On a text terminal, if the window has a neighbor on its right, its right edge includes the separator line between the window and its neighbor.</source>
          <target state="translated">Обратите внимание,что это действительные внешние края окна,включая любую линию заголовка,линию режима,полосу прокрутки,бахрому,разделитель окна и поля отображения.На текстовом терминале,если окно имеет соседа справа,его правый край включает в себя линию разделителя между окном и соседом.</target>
        </trans-unit>
        <trans-unit id="3e29252ca0099b32f668a2f0acad91a2370dc400" translate="yes" xml:space="preserve">
          <source>Note that these meanings differ slightly from those of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). This function may be changed in a future version of Emacs to eliminate this discrepancy.</source>
          <target state="translated">Обратите внимание, что эти значения немного отличаются от значений аргумента &lt;var&gt;all-frames&lt;/var&gt; для &lt;code&gt;next-window&lt;/code&gt; (см. &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Циклический порядок окон&lt;/a&gt; ). Эта функция может быть изменена в будущей версии Emacs, чтобы устранить это несоответствие.</target>
        </trans-unit>
        <trans-unit id="aeecc111a3fa90e2f602220a93eb501df7032c35" translate="yes" xml:space="preserve">
          <source>Note that these two map variables do affect the execution of key sequences entered using the menu bar, even if they do not affect the menu bar display. So if a menu bar key sequence comes in, you should clear the variables before looking up and executing that key sequence. Modes that use the variables would typically do this anyway; normally they respond to events that they do not handle by &amp;ldquo;unreading&amp;rdquo; them and exiting.</source>
          <target state="translated">Обратите внимание, что эти две переменные карты действительно влияют на выполнение последовательностей клавиш, вводимых с помощью строки меню, даже если они не влияют на отображение строки меню. Поэтому, если появляется последовательность клавиш строки меню, вы должны очистить переменные перед поиском и выполнением этой последовательности клавиш. Режимы, в которых используются переменные, обычно делают это в любом случае; обычно они реагируют на события, которые не обрабатывают, &amp;laquo;не читая&amp;raquo; их и завершая их.</target>
        </trans-unit>
        <trans-unit id="e346e2d0ff56f6335dc3e655ea9c25b7e0e40014" translate="yes" xml:space="preserve">
          <source>Note that this argument does not have the same meaning as in other functions which scan all live windows (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Specifically, the meanings of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; here are the opposite of what they are in those other functions.</source>
          <target state="translated">Обратите внимание, что этот аргумент не имеет того же значения, что и в других функциях, которые сканируют все живые окна (см. &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Циклический порядок окон&lt;/a&gt; ). В частности, значения &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;nil&lt;/code&gt; здесь противоположны тому, что они есть в этих других функциях.</target>
        </trans-unit>
        <trans-unit id="894d286209e758f0c8e4e2de8dc595b49367a3dd" translate="yes" xml:space="preserve">
          <source>Note that this does not tell you whether the display you are using really supports that color. When using X, you can ask for any defined color on any kind of display, and you will get some result&amp;mdash;typically, the closest it can do. To determine whether a frame can really display a certain color, use &lt;code&gt;color-supported-p&lt;/code&gt; (see below).</source>
          <target state="translated">Обратите внимание, что это не говорит вам, действительно ли используемый вами дисплей поддерживает этот цвет. При использовании X вы можете запросить любой определенный цвет на любом типе дисплея, и вы получите какой-то результат - обычно самый близкий из возможных. Чтобы определить, действительно ли рамка может отображать определенный цвет, используйте &lt;code&gt;color-supported-p&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="9c87143dafdf2015bda6be19171c454f6308b5a5" translate="yes" xml:space="preserve">
          <source>Note that this function disregards the minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;). Hence, with &lt;var&gt;side&lt;/var&gt; equal to &lt;code&gt;bottom&lt;/code&gt; it may return &lt;code&gt;t&lt;/code&gt; also when the minibuffer window appears right below &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">Обратите внимание, что эта функция игнорирует окно минибуфера (см. &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Окна минибуфера&lt;/a&gt; ). Следовательно, со &lt;var&gt;side&lt;/var&gt; равной &lt;code&gt;bottom&lt;/code&gt; он может вернуть &lt;code&gt;t&lt;/code&gt; также, когда окно минибуфера появляется прямо под &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3c74267c9a9889a0868c5053a41c16d0ecce8ab6" translate="yes" xml:space="preserve">
          <source>Note that this function doesn&amp;rsquo;t account for the visual width of characters on display, like the number of visual columns taken by a tab character or an image. If you need the coordinates in canonical character units, use &lt;code&gt;posn-col-row&lt;/code&gt; instead.</source>
          <target state="translated">Обратите внимание, что эта функция не учитывает визуальную ширину отображаемых символов, например количество визуальных столбцов, занимаемых символом табуляции или изображением. Если вам нужны координаты в канонических символьных единицах, используйте &lt;code&gt;posn-col-row&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="998f1206a8bc180e46c0f799b8b5a670212afaad" translate="yes" xml:space="preserve">
          <source>Note that this function has an ambiguity if the found element is identical to &lt;var&gt;default&lt;/var&gt;, as in that case it cannot be known whether an element was found or not.</source>
          <target state="translated">Обратите внимание, что эта функция имеет двусмысленность, если найденный элемент идентичен элементу по &lt;var&gt;default&lt;/var&gt; , поскольку в этом случае нельзя узнать, был ли элемент найден или нет.</target>
        </trans-unit>
        <trans-unit id="6df96098672080fc58058b91a33fcbca6a21515b" translate="yes" xml:space="preserve">
          <source>Note that this function has to retrieve the dimensions of each line of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s glyph matrix via &lt;code&gt;window-lines-pixel-dimensions&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;). Hence, this function may also return &lt;code&gt;nil&lt;/code&gt; when the current glyph matrix of &lt;var&gt;window&lt;/var&gt; is not up-to-date.</source>
          <target state="translated">Обратите внимание , что эта функция должна получить размеры каждой строки &lt;var&gt;window&lt;/var&gt; &amp;laquo;с помощью матрицы глифов &lt;code&gt;window-lines-pixel-dimensions&lt;/code&gt; (см &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Размера отображаемого текста&lt;/a&gt; ). Следовательно, эта функция может также возвращать &lt;code&gt;nil&lt;/code&gt; , если текущая матрица глифов &lt;var&gt;window&lt;/var&gt; не обновлена.</target>
        </trans-unit>
        <trans-unit id="c5054dbcacc1045ce838f26e3713bfdb492fb165" translate="yes" xml:space="preserve">
          <source>Note that this function might return inaccurate results in some situations, such as the following:</source>
          <target state="translated">Обратите внимание,что эта функция может возвращать неточные результаты в некоторых ситуациях,например,в следующих:</target>
        </trans-unit>
        <trans-unit id="28e1bb3bf31dd9667c950f330d082131ff2cc74a" translate="yes" xml:space="preserve">
          <source>Note that this function only changes the buffer contents; it does not alter &lt;code&gt;tabulated-list-entries&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что эта функция изменяет только содержимое буфера; он не изменяет записи в &lt;code&gt;tabulated-list-entries&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f915802707d0be2b41295f510d267fae8df11a6" translate="yes" xml:space="preserve">
          <source>Note that this function returns only IPv4 information.</source>
          <target state="translated">Обратите внимание,что эта функция возвращает только информацию IPv4.</target>
        </trans-unit>
        <trans-unit id="20b5e54b67d99f5fc2e693cae10cc92ff59c28aa" translate="yes" xml:space="preserve">
          <source>Note that this incorporates the submenu keymap, which is the value of the variable &lt;code&gt;menu-bar-replace-menu&lt;/code&gt;, rather than the symbol &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; itself. Using that symbol in the parent menu item would be meaningless because &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; is not a command.</source>
          <target state="translated">Обратите внимание, что это включает в себя раскладку подменю, которая является значением переменной &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; , а не сам символ &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; . Использование этого символа в родительском пункте меню было бы бессмысленным, потому что &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; не является командой.</target>
        </trans-unit>
        <trans-unit id="aa1d2cd987fde9747e5aba9be8d033f0786b741e" translate="yes" xml:space="preserve">
          <source>Note that this option does not distinguish &amp;ldquo;sloppy&amp;rdquo; focus (where the frame that previously had focus retains focus as long as the mouse pointer does not move into another window manager window) from &amp;ldquo;strict&amp;rdquo; focus (where a frame immediately loses focus when it&amp;rsquo;s left by the mouse pointer). Neither does it recognize whether your window manager supports delayed focusing or auto-raising where you can explicitly specify the time until a new frame gets focus or is auto-raised.</source>
          <target state="translated">Обратите внимание, что этот параметр не отличает &amp;laquo;неаккуратный&amp;raquo; фокус (когда фрейм, у которого ранее был фокус, сохраняет фокус, пока указатель мыши не переместится в другое окно оконного менеджера) от &amp;laquo;строгого&amp;raquo; фокуса (когда фрейм сразу теряет фокус, когда он слева от указателя мыши). Он также не распознает, поддерживает ли ваш оконный менеджер отложенную фокусировку или автоподъем, где вы можете явно указать время, пока новый кадр не получит фокус или не будет автоматически поднят.</target>
        </trans-unit>
        <trans-unit id="a7ad66f5d269e6734f06cb2f3c0014bbfb55b77d" translate="yes" xml:space="preserve">
          <source>Note that this translation is the first thing that happens to a character after it is read from the terminal. Record-keeping features such as &lt;code&gt;recent-keys&lt;/code&gt; and dribble files record the characters after translation.</source>
          <target state="translated">Обратите внимание, что этот перевод - первое, что происходит с символом после его чтения с терминала. Функции ведения записи, такие как &lt;code&gt;recent-keys&lt;/code&gt; и файлы для записи, записывают символы после перевода.</target>
        </trans-unit>
        <trans-unit id="8b01ecccbe829efd57fc886cd453e999a2cf9884" translate="yes" xml:space="preserve">
          <source>Note that this variable applies only to events that really come from the keyboard, and has no effect on mouse events or any other events.</source>
          <target state="translated">Обратите внимание,что эта переменная применяется только к событиям,которые действительно происходят с клавиатуры,и не влияет на события мыши или любые другие события.</target>
        </trans-unit>
        <trans-unit id="879e8333c0e4e7f970d5416ebcdb0f1f832c6b93" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;reverse&lt;/code&gt;, this function doesn&amp;rsquo;t work with strings. Although you can alter string data by using &lt;code&gt;aset&lt;/code&gt;, it is strongly encouraged to treat strings as immutable even when they are mutable. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что в отличие от &lt;code&gt;reverse&lt;/code&gt; , эта функция не работает со строками. Хотя вы можете изменять строковые данные с помощью &lt;code&gt;aset&lt;/code&gt; , настоятельно рекомендуется рассматривать строки как неизменяемые, даже если они являются изменяемыми. См. &quot; &lt;a href=&quot;mutability#Mutability&quot;&gt;Изменчивость&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95e0f840e124ea1d4b479e3c1de97bffda6d36fe" translate="yes" xml:space="preserve">
          <source>Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler). Therefore, functions which take a symbol argument (like &lt;code&gt;symbol-value&lt;/code&gt;, &lt;code&gt;boundp&lt;/code&gt;, and &lt;code&gt;set&lt;/code&gt;) can only retrieve or modify a variable&amp;rsquo;s dynamic binding (i.e., the contents of its symbol&amp;rsquo;s value cell).</source>
          <target state="translated">Обратите внимание, что в отличие от динамических переменных, которые привязаны к самому объекту символа, связь между лексическими переменными и символами присутствует только в интерпретаторе (или компиляторе). Следовательно, функции, которые принимают аргумент символа (например, &lt;code&gt;symbol-value&lt;/code&gt; , &lt;code&gt;boundp&lt;/code&gt; и &lt;code&gt;set&lt;/code&gt; ), могут только извлекать или изменять динамическую привязку переменной (т. Е. Содержимое ячейки значения ее символа).</target>
        </trans-unit>
        <trans-unit id="b42ea23442a5852b3e3945f946840be547f84efc" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;mode-line&lt;/code&gt;, &lt;code&gt;mode-line-inactive&lt;/code&gt;, or &lt;code&gt;header-line&lt;/code&gt; as &lt;var&gt;face&lt;/var&gt; will actually redisplay the mode line or the header line, respectively, using the current definitions of the corresponding face, in addition to returning the formatted string. (Other faces do not cause redisplay.)</source>
          <target state="translated">Обратите внимание, что использование &lt;code&gt;mode-line&lt;/code&gt; , &lt;code&gt;mode-line-inactive&lt;/code&gt; или &lt;code&gt;header-line&lt;/code&gt; в качестве &lt;var&gt;face&lt;/var&gt; фактически повторно отобразит строку режима или строку заголовка, соответственно, с использованием текущих определений соответствующего лица в дополнение к возврату отформатированной строки. (Другие лица не вызывают повторного отображения.)</target>
        </trans-unit>
        <trans-unit id="da7485093f3e51570042141c7d27e976a6d49566" translate="yes" xml:space="preserve">
          <source>Note that versions of Windows before W2K support only &lt;code&gt;:icon&lt;/code&gt; and &lt;code&gt;:tip&lt;/code&gt;. The other parameters can be passed, but they will be ignored on those old systems.</source>
          <target state="translated">Обратите внимание, что версии Windows до W2K поддерживают только &lt;code&gt;:icon&lt;/code&gt; и &lt;code&gt;:tip&lt;/code&gt; . Остальные параметры можно передать, но они будут игнорироваться в этих старых системах.</target>
        </trans-unit>
        <trans-unit id="32213ce9630018bd32281e740807f4edfc3f4d49" translate="yes" xml:space="preserve">
          <source>Note that void is not the same as &lt;code&gt;nil&lt;/code&gt; or the symbol &lt;code&gt;void&lt;/code&gt;. The symbols &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; are Lisp objects, and can be stored into a function cell just as any other object can be (and they can be valid functions if you define them in turn with &lt;code&gt;defun&lt;/code&gt;). A void function cell contains no object whatsoever.</source>
          <target state="translated">Обратите внимание, что void - это не то же самое, что &lt;code&gt;nil&lt;/code&gt; или символ &lt;code&gt;void&lt;/code&gt; . Символы &lt;code&gt;nil&lt;/code&gt; и &lt;code&gt;void&lt;/code&gt; являются объектами Lisp и могут храниться в ячейке функции, как и любой другой объект (и они могут быть действительными функциями, если вы определяете их по очереди с помощью &lt;code&gt;defun&lt;/code&gt; ). Ячейка функции void не содержит никаких объектов.</target>
        </trans-unit>
        <trans-unit id="c55ed2cdfec3c287af375d8415ca35326ee5ad2a" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t care to specify a &lt;code&gt;reusable-frames&lt;/code&gt; action alist entry in our specification of &lt;code&gt;display-buffer-alist&lt;/code&gt;. &lt;code&gt;display-buffer&lt;/code&gt; always takes the first one it finds&amp;mdash;in our case the one specified by &lt;code&gt;display-buffer-base-action&lt;/code&gt;. If we wanted to use a different specification, for example, to exclude iconified frames showing</source>
          <target state="translated">Обратите внимание, что мы не позаботились указать запись списка действий &lt;code&gt;reusable-frames&lt;/code&gt; в нашей спецификации &lt;code&gt;display-buffer-alist&lt;/code&gt; . &lt;code&gt;display-buffer&lt;/code&gt; всегда берет первый найденный - в нашем случае тот, который указан в &lt;code&gt;display-buffer-base-action&lt;/code&gt; . Если бы мы хотели использовать другую спецификацию, например, для исключения значков фреймов, показывающих</target>
        </trans-unit>
        <trans-unit id="695d219c90e242ce9ab38b41dd5442dca50f0c95" translate="yes" xml:space="preserve">
          <source>Note that we do not quote the &lt;code&gt;lambda&lt;/code&gt; form.</source>
          <target state="translated">Обратите внимание, что мы не цитируем &lt;code&gt;lambda&lt;/code&gt; форму.</target>
        </trans-unit>
        <trans-unit id="27279efa933392e2845851f38f8ebb1579dfb1cb" translate="yes" xml:space="preserve">
          <source>Note that we never modify the data in each node, which is fixed when the ewoc is created to be either &lt;code&gt;nil&lt;/code&gt; or an index into the vector &lt;code&gt;colorcomp-data&lt;/code&gt;, the actual color components.</source>
          <target state="translated">Обратите внимание, что мы никогда не изменяем данные в каждом узле, что фиксируется, когда создается ewoc, чтобы быть либо &lt;code&gt;nil&lt;/code&gt; либо индексом в векторных &lt;code&gt;colorcomp-data&lt;/code&gt; , фактических компонентов цвета.</target>
        </trans-unit>
        <trans-unit id="e11f9f08db090622f4787f9d406b1aa205d88060" translate="yes" xml:space="preserve">
          <source>Note that when a frame is not large enough to accommodate a change of any of the parameters listed above, Emacs may try to enlarge the frame even if this option is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Заметьте, что когда размер фрейма недостаточно велик, чтобы приспособиться к изменению любого из параметров, перечисленных выше, Emacs может попытаться увеличить фрейм, даже если этот параметр не равен &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93e5de1e980991d9fdbf3fb24041ced46918aafe" translate="yes" xml:space="preserve">
          <source>Note that when a frame&amp;rsquo;s pixel size is not a multiple of its character size, at least one window may get resized pixelwise even if this option is &lt;code&gt;nil&lt;/code&gt;. The default value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если размер кадра в пикселях не кратен размеру его символа, по крайней мере одно окно может быть изменено по пикселям, даже если этот параметр равен &lt;code&gt;nil&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0488512718b2693ed44b51fbae789514d6f0a966" translate="yes" xml:space="preserve">
          <source>Note that when evaluating under lexical binding the result is a closure object (see &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что при вычислении под лексическим связыванием результатом является закрывающий объект (см. &lt;a href=&quot;closures#Closures&quot;&gt;Замыкания&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b2dcc95bd27b61f320e52671bde8d565c5541e0" translate="yes" xml:space="preserve">
          <source>Note that window change functions provide no information about which windows have been deleted since the last time they were run. If necessary, applications should remember any window showing a specific buffer in a local variable of that buffer and update it in a function run by the default values of any of the hooks that are run when a window buffer change was detected.</source>
          <target state="translated">Обратите внимание,что функции изменения окон не предоставляют никакой информации о том,какие окна были удалены с момента их последнего запуска.При необходимости приложения должны помнить любое окно,показывающее конкретный буфер в локальной переменной этого буфера,и обновлять его в функции,запущенной по умолчанию,значения любого из крюков,которые запускаются при обнаружении изменения оконного буфера.</target>
        </trans-unit>
        <trans-unit id="b1db01bbe0bf3270ff266bbfef6dae125e24f80a" translate="yes" xml:space="preserve">
          <source>Note that with multiple monitors, the origin of the display does not necessarily coincide with the top-left corner of the entire usable display area of the terminal. Hence the absolute position of a frame can be negative in such an environment even when that frame is completely visible.</source>
          <target state="translated">Обратите внимание,что при использовании нескольких мониторов происхождение дисплея не обязательно совпадает с левым верхним углом всей полезной зоны дисплея терминала.Следовательно,абсолютное положение кадра в такой среде может быть отрицательным,даже если этот кадр полностью виден.</target>
        </trans-unit>
        <trans-unit id="c81d4cca0834a0ff81c0a8aba5344f507503f4ac" translate="yes" xml:space="preserve">
          <source>Note that you cannot specify a hash table whose initial contents include objects that have no read syntax, such as buffers and frames. Such objects may be added to the hash table after it is created.</source>
          <target state="translated">Обратите внимание,что вы не можете указать хэш-таблицу,в исходное содержимое которой входят объекты,не имеющие синтаксиса чтения,такие как буферы и фреймы.Такие объекты могут быть добавлены в хэш-таблицу после ее создания.</target>
        </trans-unit>
        <trans-unit id="df97661ee2013a21758ac0f65cab67196b09b407" translate="yes" xml:space="preserve">
          <source>Note that you could implement an equivalent test by using &lt;code&gt;intern&lt;/code&gt; to get an &lt;code&gt;emacs_value&lt;/code&gt; representing &lt;code&gt;nil&lt;/code&gt;, then use &lt;code&gt;eq&lt;/code&gt;, described above, to test for equality. But using this function is more convenient.</source>
          <target state="translated">Обратите внимание, что вы можете реализовать эквивалентный тест, используя &lt;code&gt;intern&lt;/code&gt; для получения &lt;code&gt;emacs_value&lt;/code&gt; , представляющего &lt;code&gt;nil&lt;/code&gt; , а затем использовать &lt;code&gt;eq&lt;/code&gt; , описанный выше, для проверки равенства. Но пользоваться этой функцией удобнее.</target>
        </trans-unit>
        <trans-unit id="8085c903afbf6def946357e85a074fc45d960104" translate="yes" xml:space="preserve">
          <source>Note that you may reenter the same Edebug level several times if, for example, an instrumented function is called several times from one command.</source>
          <target state="translated">Обратите внимание,что вы можете повторно войти на один и тот же уровень Edebug несколько раз,если,например,инструментированная функция вызывается несколько раз из одной команды.</target>
        </trans-unit>
        <trans-unit id="9728aac91e0d5d7d3233a093047d1e3cf2f7b5fb" translate="yes" xml:space="preserve">
          <source>Note that, unlike in message-based OO languages, such as C</source>
          <target state="translated">Обратите внимание,что в отличие от языков OO,основанных на сообщениях,таких как C</target>
        </trans-unit>
        <trans-unit id="906465653e9352a3acf19ee4e06fa8005cc8906b" translate="yes" xml:space="preserve">
          <source>Note the call to &lt;code&gt;maybe_quit&lt;/code&gt; inside the loop: this function checks whether the user pressed</source>
          <target state="translated">Обратите внимание на вызов &lt;code&gt;maybe_quit&lt;/code&gt; внутри цикла: эта функция проверяет, нажал ли пользователь</target>
        </trans-unit>
        <trans-unit id="18449a6bba4a3bf6dccfca75e5c0114afa84bfeb" translate="yes" xml:space="preserve">
          <source>Note the symbols which the bindings are made for; these appear inside square brackets, in the key sequence being defined. In some cases, this symbol is the same as the command name; sometimes it is different. These symbols are treated as function keys, but they are not real function keys on the keyboard. They do not affect the functioning of the menu itself, but they are echoed in the echo area when the user selects from the menu, and they appear in the output of &lt;code&gt;where-is&lt;/code&gt; and &lt;code&gt;apropos&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание на символы, для которых сделаны привязки; они появляются в квадратных скобках в определяемой последовательности клавиш. В некоторых случаях этот символ совпадает с именем команды; иногда бывает иначе. Эти символы рассматриваются как функциональные клавиши, но они не являются настоящими функциональными клавишами на клавиатуре. Они не влияют на работу самого меню, но они отражаются в эхо-области, когда пользователь выбирает из меню, и появляются в выводе &lt;code&gt;where-is&lt;/code&gt; и &lt;code&gt;apropos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="090bff393075f6b58e2d0efa3893f085f97dd09d" translate="yes" xml:space="preserve">
          <source>Note: If the replacement is a string, it will be placed in a temporary buffer so that &lt;code&gt;replace-buffer-contents&lt;/code&gt; can operate on it. Therefore, if you already have the replacement in a buffer, it makes no sense to convert it to a string using &lt;code&gt;buffer-substring&lt;/code&gt; or similar.</source>
          <target state="translated">Примечание. Если замена представляет собой строку, она будет помещена во временный буфер, чтобы с ней можно было работать с &lt;code&gt;replace-buffer-contents&lt;/code&gt; . Следовательно, если у вас уже есть замена в буфере, нет смысла преобразовывать ее в строку с помощью &lt;code&gt;buffer-substring&lt;/code&gt; или чего-то подобного.</target>
        </trans-unit>
        <trans-unit id="15b8243f03b0e985c78ff44d43c977a16ec664d5" translate="yes" xml:space="preserve">
          <source>Note: The interactive spec of &lt;var&gt;function&lt;/var&gt; will apply to the combined function and should hence obey the calling convention of the combined function rather than that of &lt;var&gt;function&lt;/var&gt;. In many cases, it makes no difference since they are identical, but it does matter for &lt;code&gt;:around&lt;/code&gt;, &lt;code&gt;:filter-args&lt;/code&gt;, and &lt;code&gt;:filter-return&lt;/code&gt;, where &lt;var&gt;function&lt;/var&gt; receives different arguments than the original function stored in &lt;var&gt;place&lt;/var&gt;.</source>
          <target state="translated">Примечание. Интерактивная спецификация &lt;var&gt;function&lt;/var&gt; будет применяться к комбинированной функции и, следовательно, должна подчиняться соглашению о вызовах комбинированной функции, а не &lt;var&gt;function&lt;/var&gt; . Во многих случаях это не имеет никакого значения , так как они идентичны, но это дело &lt;code&gt;:around&lt;/code&gt; , &lt;code&gt;:filter-args&lt;/code&gt; и &lt;code&gt;:filter-return&lt;/code&gt; , где &lt;var&gt;function&lt;/var&gt; принимает различные аргументы , чем исходная функция , хранящейся в &lt;var&gt;place&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="086829d75bac2c9e339b5bb59f87867c9bac04d0" translate="yes" xml:space="preserve">
          <source>Note: face remapping is non-recursive. If &lt;var&gt;remapping&lt;/var&gt; references the same face name &lt;var&gt;face&lt;/var&gt;, either directly or via the &lt;code&gt;:inherit&lt;/code&gt; attribute of some other face in &lt;var&gt;remapping&lt;/var&gt;, that reference uses the normal definition of &lt;var&gt;face&lt;/var&gt;. For instance, if the &lt;code&gt;mode-line&lt;/code&gt; face is remapped using this entry in &lt;code&gt;face-remapping-alist&lt;/code&gt;:</source>
          <target state="translated">Примечание: переназначение лиц нерекурсивно. Если &lt;var&gt;remapping&lt;/var&gt; сопоставление ссылается на одно и то же лицо с именем &lt;var&gt;face&lt;/var&gt; либо напрямую, либо через атрибут &lt;code&gt;:inherit&lt;/code&gt; некоторого другого лица при &lt;var&gt;remapping&lt;/var&gt; сопоставлении, эта ссылка использует обычное определение &lt;var&gt;face&lt;/var&gt; . Например, если лицо &lt;code&gt;mode-line&lt;/code&gt; переназначено с использованием этой записи в &lt;code&gt;face-remapping-alist&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="48c1f7cc7802f63e35b4a25aa793c719285304f9" translate="yes" xml:space="preserve">
          <source>Note: the properties &lt;code&gt;composition&lt;/code&gt;, &lt;code&gt;display&lt;/code&gt;, &lt;code&gt;invisible&lt;/code&gt; and &lt;code&gt;intangible&lt;/code&gt; can also cause point to move to an acceptable place, after each Emacs command. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;.</source>
          <target state="translated">Примечание: свойства &lt;code&gt;composition&lt;/code&gt; , &lt;code&gt;display&lt;/code&gt; , &lt;code&gt;invisible&lt;/code&gt; и &lt;code&gt;intangible&lt;/code&gt; также могут вызывать перемещение точки в приемлемое место после каждой команды Emacs. См. Раздел &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Регулировка точки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6cd208317b8407557bf5e9e8a5213d6396ae797" translate="yes" xml:space="preserve">
          <source>Notice how those lexers return the empty string when in front of parentheses. This is because SMIE automatically takes care of the parentheses defined in the syntax table. More specifically if the lexer returns &lt;code&gt;nil&lt;/code&gt; or an empty string, SMIE tries to handle the corresponding text as a sexp according to syntax tables.</source>
          <target state="translated">Обратите внимание, как эти лексеры возвращают пустую строку перед круглыми скобками. Это связано с тем, что SMIE автоматически обрабатывает скобки, определенные в таблице синтаксиса. В частности, если лексический анализатор возвращает &lt;code&gt;nil&lt;/code&gt; или пустую строку, SMIE пытается обработать соответствующий текст как sexp в соответствии с таблицами синтаксиса.</target>
        </trans-unit>
        <trans-unit id="1e7899e05f54c7cf4e3b193d5da99af8fc028b7c" translate="yes" xml:space="preserve">
          <source>Notice that all functions are allowed to overwrite the match data unless they&amp;rsquo;re explicitly documented not to do so. A consequence is that functions that are run implicitly in the background (see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;, and &lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;Idle Timers&lt;/a&gt;) should likely save and restore the match data explicitly.</source>
          <target state="translated">Обратите внимание, что всем функциям разрешено перезаписывать данные соответствия, если они явно не задокументированы, чтобы этого не делать. Следствием этого является то, что функции, которые неявно выполняются в фоновом режиме (см. &lt;a href=&quot;timers#Timers&quot;&gt;Таймеры&lt;/a&gt; и &lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;Таймеры простоя&lt;/a&gt; ), вероятно, должны явно сохранять и восстанавливать данные соответствия.</target>
        </trans-unit>
        <trans-unit id="7bf3df555a929d338861ed3b64bf8199a25afe42" translate="yes" xml:space="preserve">
          <source>Notification severity level, one of &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, or &lt;code&gt;error&lt;/code&gt;. If given, the value determines the icon displayed to the left of the notification title, but only if the &lt;code&gt;:title&lt;/code&gt; parameter (see below) is also specified and is a string.</source>
          <target state="translated">Уровень важности уведомления: &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; или &lt;code&gt;error&lt;/code&gt; . Если задано, значение определяет значок, отображаемый слева от заголовка уведомления, но только если параметр &lt;code&gt;:title&lt;/code&gt; (см. Ниже) также указан и является строкой.</target>
        </trans-unit>
        <trans-unit id="864d97d356a80a5cd27ad60eb5336174f9507562" translate="yes" xml:space="preserve">
          <source>Notifications on File Changes</source>
          <target state="translated">Уведомления об изменении файлов</target>
        </trans-unit>
        <trans-unit id="e3768fb5cf0372c526b5e173f1befdd62061f9c9" translate="yes" xml:space="preserve">
          <source>Notify &lt;var&gt;cond&lt;/var&gt;. The mutex with &lt;var&gt;cond&lt;/var&gt; must be held before calling this. Ordinarily a single waiting thread is woken by &lt;code&gt;condition-notify&lt;/code&gt;; but if &lt;var&gt;all&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt;, then all threads waiting on &lt;var&gt;cond&lt;/var&gt; are notified.</source>
          <target state="translated">Уведомить &lt;var&gt;cond&lt;/var&gt; . Перед его вызовом необходимо удерживать мьютекс с &lt;var&gt;cond&lt;/var&gt; . Обычно единственный ожидающий поток разбуждается &lt;code&gt;condition-notify&lt;/code&gt; ; но если &lt;var&gt;all&lt;/var&gt; не &lt;code&gt;nil&lt;/code&gt; , то уведомляются все потоки, ожидающие &lt;var&gt;cond&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f36fcd20d98f1c2ef6f745daf470b6fc6dd07587" translate="yes" xml:space="preserve">
          <source>Novice Emacs Lisp programmers often try to use the mark for the wrong purposes. The mark saves a location for the user&amp;rsquo;s convenience. An editing command should not alter the mark unless altering the mark is part of the user-level functionality of the command. (And, in that case, this effect should be documented.) To remember a location for internal use in the Lisp program, store it in a Lisp variable. For example:</source>
          <target state="translated">Начинающие программисты на Emacs Lisp часто пытаются использовать метку в неправильных целях. Знак сохраняет местоположение для удобства пользователя. Команда редактирования не должна изменять метку, если изменение метки не является частью функциональных возможностей команды на уровне пользователя. (И в этом случае этот эффект должен быть задокументирован.) Чтобы запомнить место для внутреннего использования в программе Lisp, сохраните его в переменной Lisp. Например:</target>
        </trans-unit>
        <trans-unit id="93fe86956bd461c4f9006b03bcbecd888324bf7d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s change the argument given to &lt;code&gt;catch2&lt;/code&gt;:</source>
          <target state="translated">Теперь давайте изменим аргумент, данный для &lt;code&gt;catch2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7551c107ba5514ae35edf328fbdb7f4e01b52801" translate="yes" xml:space="preserve">
          <source>Now that &lt;code&gt;app&lt;/code&gt; has matched, all &lt;code&gt;and&lt;/code&gt; sub-patterns have matched, and so &lt;code&gt;and&lt;/code&gt; matches. Likewise, once &lt;code&gt;and&lt;/code&gt; has matched, &lt;code&gt;or&lt;/code&gt; matches and does not proceed to try sub-pattern &lt;code&gt;let&lt;/code&gt; (line 8).</source>
          <target state="translated">Теперь, когда &lt;code&gt;app&lt;/code&gt; совпало, все &lt;code&gt;and&lt;/code&gt; суб-модели совпали, и так &lt;code&gt;and&lt;/code&gt; матчи. Аналогичным образом, один раз &lt;code&gt;and&lt;/code&gt; соответствует, &lt;code&gt;or&lt;/code&gt; соответствует и не переходит к попытке подшаблона &lt;code&gt;let&lt;/code&gt; (строка 8).</target>
        </trans-unit>
        <trans-unit id="8bf81c47d3466cac8f8f1e05225e708ff47181f9" translate="yes" xml:space="preserve">
          <source>Now we can put the output in the proper order by reversing the list:</source>
          <target state="translated">Теперь мы можем расположить вывод в нужном порядке,перевернув список:</target>
        </trans-unit>
        <trans-unit id="5d2c4f3b6b617ec480f6e2553990ecdaa4eb658c" translate="yes" xml:space="preserve">
          <source>Now we create a hard link, by calling &lt;code&gt;add-name-to-file&lt;/code&gt;, then list the files again. This shows two names for one file,</source>
          <target state="translated">Теперь мы создаем жесткую ссылку, вызывая &lt;code&gt;add-name-to-file&lt;/code&gt; , а затем снова перечисляем файлы. Это показывает два имени для одного файла,</target>
        </trans-unit>
        <trans-unit id="07f78a209cc321ded7c29827738886e3593f46f8" translate="yes" xml:space="preserve">
          <source>Now we read using the stream thus constructed:</source>
          <target state="translated">Теперь мы читаем,используя построенный таким образом поток:</target>
        </trans-unit>
        <trans-unit id="429cf392dcfad2eb5b3fb43671b8d50dc62f2be6" translate="yes" xml:space="preserve">
          <source>Now we show a use of a marker as an output stream. Initially, the marker is in buffer &lt;code&gt;foo&lt;/code&gt;, between the &amp;lsquo;</source>
          <target state="translated">Теперь мы покажем использование маркера в качестве выходного потока. Изначально маркер находится в буфере &lt;code&gt;foo&lt;/code&gt; , между '</target>
        </trans-unit>
        <trans-unit id="6fb2e1a0ad356df5d65425e68c286f81f8d8b450" translate="yes" xml:space="preserve">
          <source>Now you can go to the beginning of the defun and type</source>
          <target state="translated">Теперь вы можете перейти к началу настройки и напечатать</target>
        </trans-unit>
        <trans-unit id="e23718dfb830dd77b88fcfc0d1b3bea6a5e6fca3" translate="yes" xml:space="preserve">
          <source>Now, when enlarging a window vertically, Emacs tries to obtain the corresponding space from its lower sibling, provided such a window exists. In our scenario, enlarging &lt;var&gt;W4&lt;/var&gt; will steal space from &lt;var&gt;W3&lt;/var&gt;.</source>
          <target state="translated">Теперь, увеличивая окно по вертикали, Emacs пытается получить соответствующее пространство от своего младшего брата, при условии, что такое окно существует. В нашем сценарии увеличение &lt;var&gt;W4&lt;/var&gt; отнимет место у &lt;var&gt;W3&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="9e06af5545a3e4354b7d4ee0852c0eed7a91cb67" translate="yes" xml:space="preserve">
          <source>Number of seconds to pause when a breakpoint is reached and the execution mode is trace or continue. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</source>
          <target state="translated">Количество секунд для паузы при достижении точки останова и режиме выполнения - трассировка или продолжение. См. &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Раздел Режимы выполнения Edebug&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="322456515cb687e293b524d7ce7beddddcb9bc80" translate="yes" xml:space="preserve">
          <source>Number of spaces</source>
          <target state="translated">Количество пробелов</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="7e3c0a7716da4e48fa5db56b8609023d7442bc77" translate="yes" xml:space="preserve">
          <source>Numbers and arithmetic functions.</source>
          <target state="translated">Числа и арифметические функции.</target>
        </trans-unit>
        <trans-unit id="f004d111f9eecf4e07d15edb9e80b8c6a0bb7fb8" translate="yes" xml:space="preserve">
          <source>Numbers controlling how to compose characters.</source>
          <target state="translated">Цифры,управляющие составлением символов.</target>
        </trans-unit>
        <trans-unit id="4632fc07fc740627ec8979b8ae726d58ce6441a0" translate="yes" xml:space="preserve">
          <source>Numbers with fractional parts and with a large range.</source>
          <target state="translated">Цифры с дробными деталями и с большим диапазоном.</target>
        </trans-unit>
        <trans-unit id="238f75d73961cd8ec3a93e41f8eca572c815790b" translate="yes" xml:space="preserve">
          <source>Numbers without fractional parts.</source>
          <target state="translated">Цифры без дробных частей.</target>
        </trans-unit>
        <trans-unit id="30a62380404b3b267a5c4e21b5e111455d09031e" translate="yes" xml:space="preserve">
          <source>Numeric</source>
          <target state="translated">Numeric</target>
        </trans-unit>
        <trans-unit id="f72c4497b8297399ea538316ed693eb0b0f69dbb" translate="yes" xml:space="preserve">
          <source>Numeric Conversions</source>
          <target state="translated">числовые преобразования</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="a7947cd1693d4f1df0716adaabddf52493ff1007" translate="yes" xml:space="preserve">
          <source>O P</source>
          <target state="translated">О П</target>
        </trans-unit>
        <trans-unit id="c363dc3457ef24cf6ba8971bbc948dded316392b" translate="yes" xml:space="preserve">
          <source>Obarrays are also a kind of hash table, but they are a different type of object and are used only for recording interned symbols (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;).</source>
          <target state="translated">Массивы также являются своего рода хеш-таблицей, но они представляют собой объект другого типа и используются только для записи интернированных символов (см. &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Создание символов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f56ee4a102e69c064a8440479a96623086d8758" translate="yes" xml:space="preserve">
          <source>Object Internals</source>
          <target state="translated">Интернэшнл объектов</target>
        </trans-unit>
        <trans-unit id="9101d7a347d0a3885fc114e1cef91162863e5343" translate="yes" xml:space="preserve">
          <source>Objects holding information about types.</source>
          <target state="translated">Объекты,содержащие информацию о типах.</target>
        </trans-unit>
        <trans-unit id="d2b0ba186e391135f71f9fbac7110335d650cacf" translate="yes" xml:space="preserve">
          <source>Objects that have no read syntax are presented like this (see &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Printed Representation&lt;/a&gt;).</source>
          <target state="translated">Объекты, не имеющие синтаксиса чтения, представлены следующим образом (см. &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Печатное представление&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d7717e27b11c625514b5d6b2df3dc3a2a3bbea53" translate="yes" xml:space="preserve">
          <source>Obtain rudimentary coverage testing and frequency counts.</source>
          <target state="translated">Получить элементарное тестирование покрытия и подсчет частот.</target>
        </trans-unit>
        <trans-unit id="523942562b4a55d93a983d95b45b7177c8e4772d" translate="yes" xml:space="preserve">
          <source>Obtaining random integers, predictable or not.</source>
          <target state="translated">Получение случайных целых чисел,предсказуемых или нет.</target>
        </trans-unit>
        <trans-unit id="46a01ce0f03ec80a793aa30a264989482df496b0" translate="yes" xml:space="preserve">
          <source>Obviously, this does not actually modify &lt;code&gt;previous-line&lt;/code&gt;. For that the old advice needed:</source>
          <target state="translated">Очевидно, это не изменяет &lt;code&gt;previous-line&lt;/code&gt; . Для этого нужен старый совет:</target>
        </trans-unit>
        <trans-unit id="264277b0376bfa4b86c520e9ec23072a05a7fe4d" translate="yes" xml:space="preserve">
          <source>Occasionally problems result from the fact that a macro call is expanded each time it is evaluated in an interpreted function, but is expanded only once (during compilation) for a compiled function. If the macro definition has side effects, they will work differently depending on how many times the macro is expanded.</source>
          <target state="translated">Иногда проблемы возникают из-за того,что макровызов расширяется каждый раз,когда он вычисляется в интерпретируемой функции,но расширяется только один раз (во время компиляции)для скомпилированной функции.Если определение макроса имеет побочные эффекты,то они будут работать по-разному в зависимости от того,сколько раз макрос будет расширен.</target>
        </trans-unit>
        <trans-unit id="bce973a751cd4a03300fce0010a6712f601f9f80" translate="yes" xml:space="preserve">
          <source>Occasionally you will want to test explicitly whether a library has already been loaded. If the library uses &lt;code&gt;provide&lt;/code&gt; to provide a named feature, you can use &lt;code&gt;featurep&lt;/code&gt; earlier in the file to test whether the &lt;code&gt;provide&lt;/code&gt; call has been executed before (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Alternatively, you could use something like this:</source>
          <target state="translated">Иногда вам может понадобиться явно проверить, загружена ли уже библиотека. Если библиотека использует &lt;code&gt;provide&lt;/code&gt; для предоставления именованной функции, вы можете использовать функцию &lt;code&gt;featurep&lt;/code&gt; ранее в файле, чтобы проверить, выполнялся ли ранее вызов &lt;code&gt;provide&lt;/code&gt; (см. &lt;a href=&quot;named-features#Named-Features&quot;&gt;Именованные функции&lt;/a&gt; ). В качестве альтернативы вы можете использовать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="3bce6877b2fad79bb26a891e5eaabc5fa131f26b" translate="yes" xml:space="preserve">
          <source>Occasionally, Emacs needs to hold and manipulate encoded text or binary non-text data in its buffers or strings. For example, when Emacs visits a file, it first reads the file&amp;rsquo;s text verbatim into a buffer, and only then converts it to the internal representation. Before the conversion, the buffer holds encoded text.</source>
          <target state="translated">Иногда Emacs необходимо хранить и обрабатывать закодированный текст или двоичные нетекстовые данные в своих буферах или строках. Например, когда Emacs посещает файл, он сначала дословно считывает текст файла в буфер и только затем преобразует его во внутреннее представление. Перед преобразованием в буфере хранится закодированный текст.</target>
        </trans-unit>
        <trans-unit id="3dbe249e6f95e11f5e11808a2753212c83d62b34" translate="yes" xml:space="preserve">
          <source>Occasionally, such &lt;em&gt;implied frame resizing&lt;/em&gt; may be unwanted, for example, when a frame has been maximized or made full-screen (where it&amp;rsquo;s turned off by default). In general, users can disable implied resizing with the following option:</source>
          <target state="translated">Иногда такое &lt;em&gt;подразумеваемое изменение размера кадра&lt;/em&gt; может быть нежелательным, например, когда кадр был развернут или сделан в полноэкранном режиме (где он отключен по умолчанию). Как правило, пользователи могут отключить подразумеваемое изменение размера с помощью следующей опции:</target>
        </trans-unit>
        <trans-unit id="0aff50bf865a5c17280fbf067141c1f7c36c3a36" translate="yes" xml:space="preserve">
          <source>Occasionally, you may want to reference a variable which is only determined at run time. In that case, you cannot specify the variable name in the text of the program. You can use the &lt;code&gt;symbol-value&lt;/code&gt; function to extract the value.</source>
          <target state="translated">Иногда вам может потребоваться ссылка на переменную, которая определяется только во время выполнения. В этом случае вы не можете указать имя переменной в тексте программы. Вы можете использовать функцию &lt;code&gt;symbol-value&lt;/code&gt; для извлечения значения.</target>
        </trans-unit>
        <trans-unit id="22fc935449693a1e814188a46a216288f35c0512" translate="yes" xml:space="preserve">
          <source>Of course, if the actual value of the option fits this alternative, it will appear showing the actual value, not &lt;var&gt;default&lt;/var&gt;.</source>
          <target state="translated">Конечно, если фактическое значение параметра соответствует этой альтернативе, оно будет отображать фактическое значение, а не &lt;var&gt;default&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="15696db648937c4ccbe88be9cf5f24c7996a1367" translate="yes" xml:space="preserve">
          <source>Of these usual keymaps, the highest-precedence one is specified by the &lt;code&gt;keymap&lt;/code&gt; text or overlay property at point, if any. (For a mouse input event, Emacs uses the event position instead of point; see &lt;a href=&quot;searching-keymaps#Searching-Keymaps&quot;&gt;Searching Keymaps&lt;/a&gt;.)</source>
          <target state="translated">Из этих обычных раскладок клавиш самый высокий приоритет определяется текстом &lt;code&gt;keymap&lt;/code&gt; или свойством наложения в точке, если таковые имеются. (Для события ввода мыши Emacs использует позицию события вместо точки; см. &lt;a href=&quot;searching-keymaps#Searching-Keymaps&quot;&gt;Поиск раскладки клавиатуры&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="4dc8a5d2b3bac37c9f0883d213f98c63e2f5757f" translate="yes" xml:space="preserve">
          <source>Often &lt;code&gt;window-size-fixed&lt;/code&gt; is overly aggressive because it inhibits any attempt to explicitly resize or split an affected window as well. This may even happen after the window has been resized implicitly, for example, when deleting an adjacent window or resizing the window&amp;rsquo;s frame. The following function tries hard to never disallow resizing such a window explicitly:</source>
          <target state="translated">Часто &lt;code&gt;window-size-fixed&lt;/code&gt; является чрезмерно агрессивным, потому что он также запрещает любую попытку явно изменить размер или разделить затронутое окно. Это может произойти даже после неявного изменения размера окна, например, при удалении соседнего окна или изменении размера рамки окна. Следующая функция изо всех сил пытается никогда не запрещать явное изменение размера такого окна:</target>
        </trans-unit>
        <trans-unit id="eee3f476e8d88bba8df49970967c0f8d91d77b1e" translate="yes" xml:space="preserve">
          <source>Often we want to execute the last clause whenever none of the previous clauses was successful. To do this, we use &lt;code&gt;t&lt;/code&gt; as the &lt;var&gt;condition&lt;/var&gt; of the last clause, like this: &lt;code&gt;(t
&lt;var&gt;body-forms&lt;/var&gt;)&lt;/code&gt;. The form &lt;code&gt;t&lt;/code&gt; evaluates to &lt;code&gt;t&lt;/code&gt;, which is never &lt;code&gt;nil&lt;/code&gt;, so this clause never fails, provided the &lt;code&gt;cond&lt;/code&gt; gets to it at all. For example:</source>
          <target state="translated">Часто мы хотим выполнить последнее предложение, когда ни одно из предыдущих предложений не было успешным. Для этого мы используем &lt;code&gt;t&lt;/code&gt; как &lt;var&gt;condition&lt;/var&gt; последнего предложения, например: &lt;code&gt;(t &lt;var&gt;body-forms&lt;/var&gt;)&lt;/code&gt; . Форма &lt;code&gt;t&lt;/code&gt; оценивается как &lt;code&gt;t&lt;/code&gt; , которое никогда не равно &lt;code&gt;nil&lt;/code&gt; , поэтому это предложение никогда не дает &lt;code&gt;cond&lt;/code&gt; , при условии, что cond вообще до него дойдет. Например:</target>
        </trans-unit>
        <trans-unit id="ab20aa539406f6dcc74005792b8dba230e5c4baa" translate="yes" xml:space="preserve">
          <source>Older implementations of &lt;code&gt;display-buffer&lt;/code&gt; frequently caused users and applications to fight over the settings of user options like &lt;code&gt;pop-up-frames&lt;/code&gt; and &lt;code&gt;pop-up-windows&lt;/code&gt; (see &lt;a href=&quot;choosing-window-options#Choosing-Window-Options&quot;&gt;Choosing Window Options&lt;/a&gt;). This was one major reason for redesigning &lt;code&gt;display-buffer&lt;/code&gt;&amp;mdash;to provide a clear framework specifying what users and applications should be allowed to do.</source>
          <target state="translated">Старые реализации &lt;code&gt;display-buffer&lt;/code&gt; часто заставляли пользователей и приложения бороться за настройки пользовательских параметров, таких как &lt;code&gt;pop-up-frames&lt;/code&gt; и &lt;code&gt;pop-up-windows&lt;/code&gt; (см. &lt;a href=&quot;choosing-window-options#Choosing-Window-Options&quot;&gt;Выбор параметров окна&lt;/a&gt; ). Это было одной из основных причин переделки &lt;code&gt;display-buffer&lt;/code&gt; - предоставить четкую структуру, определяющую, что пользователям и приложениям следует разрешить делать.</target>
        </trans-unit>
        <trans-unit id="bde4db5a93db0c668793ff17fa3effb0028c7b23" translate="yes" xml:space="preserve">
          <source>Omitting the argument &lt;var&gt;end&lt;/var&gt; is equivalent to specifying &lt;code&gt;nil&lt;/code&gt;. It follows that &lt;code&gt;(substring &lt;var&gt;string&lt;/var&gt; 0)&lt;/code&gt; returns a copy of all of &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">Пропуск &lt;var&gt;end&lt;/var&gt; аргумента эквивалентен указанию &lt;code&gt;nil&lt;/code&gt; . Отсюда следует, что &lt;code&gt;(substring &lt;var&gt;string&lt;/var&gt; 0)&lt;/code&gt; возвращает копию всей &lt;var&gt;string&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="066afc902473c5cdc45a4d6cd87ac56bcadb3222" translate="yes" xml:space="preserve">
          <source>On GNU and Unix systems, each X display is a separate graphical terminal. When Emacs is started from within the X window system, it uses the X display specified by the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable, or by the &amp;lsquo;</source>
          <target state="translated">В системах GNU и Unix каждый дисплей X представляет собой отдельный графический терминал. Когда Emacs запускается из оконной системы X, он использует отображение X, указанное переменной среды &lt;code&gt;DISPLAY&lt;/code&gt; или параметром '</target>
        </trans-unit>
        <trans-unit id="091b227d1e7a53734313af3b399630351b76696a" translate="yes" xml:space="preserve">
          <source>On GNU and Unix systems, you can create additional frames on any available terminal, within a single Emacs session, regardless of whether Emacs was started on a text or graphical terminal. Emacs can display on both graphical and text terminals simultaneously. This comes in handy, for instance, when you connect to the same session from several remote locations. See &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;.</source>
          <target state="translated">В системах GNU и Unix вы можете создавать дополнительные фреймы на любом доступном терминале в рамках одного сеанса Emacs, независимо от того, был ли Emacs запущен на текстовом или графическом терминале. Emacs может одновременно отображать и графический, и текстовый терминалы. Это удобно, например, когда вы подключаетесь к одному сеансу из нескольких удаленных мест. См. &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Несколько терминалов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86008f191b802986f9373390d1207c585a06279d" translate="yes" xml:space="preserve">
          <source>On GNU and other POSIX-like systems, a string returned by this function always ends in a slash. On MS-DOS it can also end in a colon.</source>
          <target state="translated">В GNU и других POSIX-подобных системах строка,возвращаемая этой функцией,всегда заканчивается косой чертой.В MS-DOS она также может заканчиваться двоеточием.</target>
        </trans-unit>
        <trans-unit id="3ec76dde782f694fa2ff646fa44724ed20f56abf" translate="yes" xml:space="preserve">
          <source>On GNU and other POSIX-like systems, this simply returns &lt;var&gt;filename&lt;/var&gt;. On other operating systems, it may enforce system-specific file name conventions; for example, on MS-DOS this function performs a variety of changes to enforce MS-DOS file name limitations, including converting any leading &amp;lsquo;</source>
          <target state="translated">В GNU и других системах, подобных POSIX, это просто возвращает &lt;var&gt;filename&lt;/var&gt; . В других операционных системах он может применять системные соглашения об именах файлов; например, в MS-DOS эта функция выполняет множество изменений для обеспечения соблюдения ограничений имени файла MS-DOS, включая преобразование любых ведущих символов '</target>
        </trans-unit>
        <trans-unit id="d87da634547b00223204825e52b32ac75a53d3aa" translate="yes" xml:space="preserve">
          <source>On GNU platforms when operating on a local file, this function is atomic: if the filesystem is simultaneously being changed by some other process, this function returns the file&amp;rsquo;s attributes either before or after the change. Otherwise this function is not atomic, and might return &lt;code&gt;nil&lt;/code&gt; if it detects the race condition, or might return a hodgepodge of the previous and current file attributes.</source>
          <target state="translated">На платформах GNU при работе с локальным файлом эта функция является атомарной: если файловая система одновременно изменяется каким-либо другим процессом, эта функция возвращает атрибуты файла до или после изменения. В противном случае эта функция не является атомарной и может возвращать &lt;code&gt;nil&lt;/code&gt; если обнаруживает состояние гонки, или может возвращать мешанину из предыдущих и текущих атрибутов файла.</target>
        </trans-unit>
        <trans-unit id="b8d088ebe683822c85b3d4ba7ca6f051bd5326f5" translate="yes" xml:space="preserve">
          <source>On MS-DOS and MS-Windows, these functions (like the function that actually operate on files) accept MS-DOS or MS-Windows file-name syntax, where backslashes separate the components, as well as POSIX syntax; but they always return POSIX syntax. This enables Lisp programs to specify file names in POSIX syntax and work properly on all systems without change.&lt;a href=&quot;#FOOT15&quot; name=&quot;DOCF15&quot;&gt;&lt;sup&gt;15&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">В MS-DOS и MS-Windows эти функции (как и функции, которые фактически работают с файлами) принимают синтаксис имени файла MS-DOS или MS-Windows, где обратная косая черта разделяет компоненты, а также синтаксис POSIX; но они всегда возвращают синтаксис POSIX. Это позволяет программам на Лиспе указывать имена файлов в синтаксисе POSIX и правильно работать во всех системах без изменений. &lt;a href=&quot;#FOOT15&quot; name=&quot;DOCF15&quot;&gt;&lt;sup&gt;15&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2928e4c3bab1512e37407ed35b34ba158366a196" translate="yes" xml:space="preserve">
          <source>On MS-DOS filesystems without long names this variable is always ignored.</source>
          <target state="translated">На файловых системах MS-DOS без длинных имен эта переменная всегда игнорируется.</target>
        </trans-unit>
        <trans-unit id="e12a5b8ff044d26de039b2ea5eb8fbb324b2d8e4" translate="yes" xml:space="preserve">
          <source>On MS-DOS, Emacs sets the &lt;code&gt;TERM&lt;/code&gt; environment variable to &amp;lsquo;</source>
          <target state="translated">В MS-DOS Emacs устанавливает для переменной среды &lt;code&gt;TERM&lt;/code&gt; значение '</target>
        </trans-unit>
        <trans-unit id="ec2bac6013926e2f9b7a2cc7618659e3f89fcfa1" translate="yes" xml:space="preserve">
          <source>On MS-Windows the &lt;var&gt;noactivate&lt;/var&gt; argument has no effect. However, if &lt;var&gt;frame&lt;/var&gt; is a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;), this function usually focuses &lt;var&gt;frame&lt;/var&gt; without raising it above other child frames.</source>
          <target state="translated">В MS-Windows аргумент &lt;var&gt;noactivate&lt;/var&gt; не действует. Однако, если &lt;var&gt;frame&lt;/var&gt; является дочерним фреймом (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ), эта функция обычно фокусирует &lt;var&gt;frame&lt;/var&gt; не поднимая его над другими дочерними фреймами.</target>
        </trans-unit>
        <trans-unit id="ef4fecbe41a5626c5f763eccb62f475909804106" translate="yes" xml:space="preserve">
          <source>On Windows 2000 and later, Emacs by default uses Unicode APIs to pass file names to the OS, so the value of &lt;code&gt;file-name-coding-system&lt;/code&gt; is largely ignored. Lisp applications that need to encode or decode file names on the Lisp level should use &lt;code&gt;utf-8&lt;/code&gt; coding-system when &lt;code&gt;system-type&lt;/code&gt; is &lt;code&gt;windows-nt&lt;/code&gt;; the conversion of UTF-8 encoded file names to the encoding appropriate for communicating with the OS is performed internally by Emacs.</source>
          <target state="translated">В Windows 2000 и более поздних версиях Emacs по умолчанию использует Unicode API для передачи имен файлов в ОС, поэтому значение &lt;code&gt;file-name-coding-system&lt;/code&gt; в значительной степени игнорируется. Приложения Lisp, которым необходимо кодировать или декодировать имена файлов на уровне Lisp, должны использовать систему кодирования &lt;code&gt;utf-8&lt;/code&gt; , если &lt;code&gt;system-type&lt;/code&gt; - &lt;code&gt;windows-nt&lt;/code&gt; ; преобразование имен файлов в кодировке UTF-8 в кодировку, подходящую для взаимодействия с ОС, выполняется внутри Emacs.</target>
        </trans-unit>
        <trans-unit id="3d9d3c2776e23b63f854890fc4c9449192d7124d" translate="yes" xml:space="preserve">
          <source>On a graphical display, tiny arrow images in the window fringes indicate truncated and continued lines (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;). On a text terminal, a &amp;lsquo;</source>
          <target state="translated">На графическом дисплее крошечные изображения стрелок на краях окон обозначают усеченные и продолженные линии (см. &lt;a href=&quot;fringes#Fringes&quot;&gt;Края&lt;/a&gt; ). На текстовом терминале символ '</target>
        </trans-unit>
        <trans-unit id="80f59247bbce1d1c9f874202c878dbd846f48819" translate="yes" xml:space="preserve">
          <source>On a graphical terminal that supports extended</source>
          <target state="translated">На графическом терминале,поддерживающем расширенный</target>
        </trans-unit>
        <trans-unit id="71814826cf878c3c911d09d9a92001d4a2a4fb2c" translate="yes" xml:space="preserve">
          <source>On a graphical terminal the following two functions allow the absolute position of the mouse cursor to be retrieved and set.</source>
          <target state="translated">На графическом терминале следующие две функции позволяют получить и установить абсолютное положение курсора мыши.</target>
        </trans-unit>
        <trans-unit id="da4884a418379ce0d9a42cbe8229e4ebb6fbeeba" translate="yes" xml:space="preserve">
          <source>On a graphical terminal this form &amp;ldquo;warps&amp;rdquo; the mouse cursor to the upper left corner of the glyph at the selected window&amp;rsquo;s point. A position calculated this way can be also used to show a tooltip window there.</source>
          <target state="translated">На графическом терминале эта форма &amp;laquo;перемещает&amp;raquo; курсор мыши в верхний левый угол глифа в выбранной точке окна. Позиция, рассчитанная таким образом, также может использоваться для отображения окна всплывающей подсказки.</target>
        </trans-unit>
        <trans-unit id="c638ecc2a4ea2d5a12f6c70496e911bec175971e" translate="yes" xml:space="preserve">
          <source>On a graphical terminal we distinguish two types of frames: A normal &lt;em&gt;top-level frame&lt;/em&gt; is a frame whose window-system window is a child of the window-system&amp;rsquo;s root window for that terminal. A child frame is a frame whose window-system window is the child of the window-system window of another Emacs frame. See &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;.</source>
          <target state="translated">В графическом терминале мы различаем два типа фреймов: Нормальный &lt;em&gt;фрейм верхнего уровня&lt;/em&gt; - это фрейм, окно оконной системы которого является дочерним по отношению к корневому окну оконной системы для этого терминала. Дочерний фрейм - это фрейм, окно оконной системы которого является потомком окна оконной системы другого фрейма Emacs. См. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние рамки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c566ed32a5007176cbb7b1c85495717dc12a7b9d" translate="yes" xml:space="preserve">
          <source>On a text terminal frame both values are zero.</source>
          <target state="translated">В рамке текстового терминала оба значения равны нулю.</target>
        </trans-unit>
        <trans-unit id="a9edfd72a3d801155297af0b22f3986badadf241" translate="yes" xml:space="preserve">
          <source>On a text terminal, all frames are considered visible for the purposes of this function, even though only one frame is displayed. See &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Raising and Lowering&lt;/a&gt;.</source>
          <target state="translated">В текстовом терминале все фреймы считаются видимыми для этой функции, даже если отображается только один фрейм. См. &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Подъем и опускание&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c4eb786d6a56a9b0991f45bcfa777150db81f17" translate="yes" xml:space="preserve">
          <source>On each frame, the frame parameter &lt;code&gt;tool-bar-lines&lt;/code&gt; controls how many lines&amp;rsquo; worth of height to reserve for the tool bar. A zero value suppresses the tool bar. If the value is nonzero, and &lt;code&gt;auto-resize-tool-bars&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the tool bar expands and contracts automatically as needed to hold the specified contents. If the value is &lt;code&gt;grow-only&lt;/code&gt;, the tool bar expands automatically, but does not contract automatically.</source>
          <target state="translated">На каждом кадре параметр кадра &lt;code&gt;tool-bar-lines&lt;/code&gt; контролирует, сколько линий высоты следует зарезервировать для панели инструментов. Нулевое значение подавляет панель инструментов. Если значение не равно нулю, а &lt;code&gt;auto-resize-tool-bars&lt;/code&gt; равно &lt;code&gt;nil&lt;/code&gt; , панель инструментов автоматически расширяется и сжимается, чтобы удерживать указанное содержимое. Если значение &lt;code&gt;grow-only&lt;/code&gt; , панель инструментов расширяется автоматически, но не сужается автоматически.</target>
        </trans-unit>
        <trans-unit id="a47451314dff3dd8ebd99643acb7f9a5e541559a" translate="yes" xml:space="preserve">
          <source>On graphical displays, Emacs draws &lt;em&gt;fringes&lt;/em&gt; next to each window: thin vertical strips down the sides which can display bitmaps indicating truncation, continuation, horizontal scrolling, and so on.</source>
          <target state="translated">На графических дисплеях Emacs рисует &lt;em&gt;полосы&lt;/em&gt; рядом с каждым окном: тонкие вертикальные полосы по сторонам, которые могут отображать растровые изображения, указывающие на усечение, продолжение, горизонтальную прокрутку и так далее.</target>
        </trans-unit>
        <trans-unit id="bc01dccb2a56362cf18d4aefcda75bb95fe48802" translate="yes" xml:space="preserve">
          <source>On graphical systems, the position of a normal top-level frame is specified as the absolute position of its outer frame (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;). The position of a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) is specified via pixel offsets of its outer edges relative to the native position of its parent frame.</source>
          <target state="translated">В графических системах положение нормального фрейма верхнего уровня определяется как абсолютное положение его внешнего фрейма (см. &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Геометрия фрейма&lt;/a&gt; ). Положение дочернего кадра (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние кадры&lt;/a&gt; ) указывается через пиксельные смещения его внешних краев относительно исходного положения его родительского кадра.</target>
        </trans-unit>
        <trans-unit id="ec338cdd1a9ff313906eec5d348a8022f6c825b7" translate="yes" xml:space="preserve">
          <source>On graphical terminals, you can specify the line spacing for all lines in a frame, using the &lt;code&gt;line-spacing&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). However, if the default value of &lt;code&gt;line-spacing&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it overrides the frame&amp;rsquo;s &lt;code&gt;line-spacing&lt;/code&gt; parameter. An integer specifies the number of pixels put below lines. A floating-point number specifies the spacing relative to the frame&amp;rsquo;s default line height.</source>
          <target state="translated">На графических терминалах вы можете указать межстрочный интервал для всех строк в кадре, используя параметр &lt;code&gt;line-spacing&lt;/code&gt; кадра (см. &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Параметры макета&lt;/a&gt; ). Однако, если значение по умолчанию &lt;code&gt;line-spacing&lt;/code&gt; является не- &lt;code&gt;nil&lt;/code&gt; , он переопределяет фрейм &lt;code&gt;line-spacing&lt;/code&gt; параметра. Целое число определяет количество пикселей, помещаемых под строками. Число с плавающей запятой определяет интервал относительно высоты строки фрейма по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b46ca9680188aa91809e991a0175bded9c6cfada" translate="yes" xml:space="preserve">
          <source>On match, the clause&amp;rsquo;s body forms can reference the set of symbols the pattern let-binds. When &lt;var&gt;seqpat&lt;/var&gt; is &lt;code&gt;and&lt;/code&gt;, this set is the union of all the symbols each of its sub-patterns let-binds. This makes sense because, for &lt;code&gt;and&lt;/code&gt; to match, all the sub-patterns must match.</source>
          <target state="translated">При совпадении формы тела предложения могут ссылаться на набор символов, которые связывает шаблон. Когда &lt;var&gt;seqpat&lt;/var&gt; равен &lt;code&gt;and&lt;/code&gt; , этот набор представляет собой объединение всех символов, которые каждый из его подшаблонов связывает let-bings. Это имеет смысл , потому что, &lt;code&gt;and&lt;/code&gt; , чтобы соответствовать, все суб-модели должны совпадать.</target>
        </trans-unit>
        <trans-unit id="c2fe00d1b0cab19cc3dbd01c42a2c9d3f1167cf5" translate="yes" xml:space="preserve">
          <source>On most systems, the directory part is everything up to and including the last slash (backslash is also allowed in input on MS-DOS or MS-Windows); the nondirectory part is the rest.</source>
          <target state="translated">На большинстве систем каталожная часть-это все,вплоть до последнего слеша (обратный слеш также разрешен при вводе в MS-DOS или MS-Windows);не каталожная часть-это остальная часть.</target>
        </trans-unit>
        <trans-unit id="d9f9275391241753a0fc3733e8b2d3b0ad7002b2" translate="yes" xml:space="preserve">
          <source>On most systems, this function works by running a directory listing program whose name is in the variable &lt;code&gt;insert-directory-program&lt;/code&gt;. If &lt;var&gt;wildcard&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it also runs the shell specified by &lt;code&gt;shell-file-name&lt;/code&gt;, to expand the wildcards.</source>
          <target state="translated">В большинстве систем эта функция работает путем запуска программы вывода каталогов, имя которой находится в переменной &lt;code&gt;insert-directory-program&lt;/code&gt; . Если &lt;var&gt;wildcard&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , он также запускает оболочку, указанную в имени &lt;code&gt;shell-file-name&lt;/code&gt; , для расширения подстановочных знаков.</target>
        </trans-unit>
        <trans-unit id="6d4535f8da402c43490a2180be3f0732c9111726" translate="yes" xml:space="preserve">
          <source>On multi-monitor displays it is possible to use the command &lt;code&gt;make-frame-on-monitor&lt;/code&gt; to make frames on the specified monitor.</source>
          <target state="translated">На дисплеях с несколькими мониторами можно использовать команду &lt;code&gt;make-frame-on-monitor&lt;/code&gt; для создания кадров на указанном мониторе.</target>
        </trans-unit>
        <trans-unit id="424aff0ac8fca763b6c89e454a579a4f615d419e" translate="yes" xml:space="preserve">
          <source>On some multi-monitor setups, a single X display outputs to more than one physical monitor. You can use the functions &lt;code&gt;display-monitor-attributes-list&lt;/code&gt; and &lt;code&gt;frame-monitor-attributes&lt;/code&gt; to obtain information about such setups.</source>
          <target state="translated">В некоторых конфигурациях с несколькими мониторами один X-дисплей выводится на несколько физических мониторов. Вы можете использовать функции &lt;code&gt;display-monitor-attributes-list&lt;/code&gt; и &lt;code&gt;frame-monitor-attributes&lt;/code&gt; для получения информации о таких настройках.</target>
        </trans-unit>
        <trans-unit id="25a3df6f65657e687d2e69c45bc13942a081601f" translate="yes" xml:space="preserve">
          <source>On some operating systems, an absolute file name begins with a device name. On such systems, &lt;var&gt;filename&lt;/var&gt; has no relative equivalent based on &lt;var&gt;directory&lt;/var&gt; if they start with two different device names. In this case, &lt;code&gt;file-relative-name&lt;/code&gt; returns &lt;var&gt;filename&lt;/var&gt; in absolute form.</source>
          <target state="translated">В некоторых операционных системах абсолютное имя файла начинается с имени устройства. В таких системах &lt;var&gt;filename&lt;/var&gt; не имеет относительного эквивалента на основе &lt;var&gt;directory&lt;/var&gt; если они начинаются с двух разных имен устройств. В этом случае &lt;code&gt;file-relative-name&lt;/code&gt; &lt;var&gt;filename&lt;/var&gt; возвращает имя файла в абсолютной форме.</target>
        </trans-unit>
        <trans-unit id="213a628dbf886420d394fb191adc21bae49c70bf" translate="yes" xml:space="preserve">
          <source>On some operating systems, each file can be associated with arbitrary &lt;em&gt;extended file attributes&lt;/em&gt;. At present, Emacs supports querying and setting two specific sets of extended file attributes: Access Control Lists (ACLs) and SELinux contexts. These extended file attributes are used, on some systems, to impose more sophisticated file access controls than the basic Unix-style permissions discussed in the previous sections.</source>
          <target state="translated">В некоторых операционных системах каждый файл может быть связан с произвольными &lt;em&gt;расширенными атрибутами файла&lt;/em&gt; . В настоящее время Emacs поддерживает запросы и установку двух конкретных наборов расширенных атрибутов файлов: списков управления доступом (ACL) и контекстов SELinux. Эти расширенные атрибуты файлов используются в некоторых системах для введения более сложных элементов управления доступом к файлам, чем базовые разрешения в стиле Unix, которые обсуждались в предыдущих разделах.</target>
        </trans-unit>
        <trans-unit id="73e008db2f82ffdcf0d72c8e1923a9faeb539e93" translate="yes" xml:space="preserve">
          <source>On some operating systems, more complex sets of access permissions can be specified, via mechanisms such as Access Control Lists (ACLs). See &lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;Extended Attributes&lt;/a&gt;, for how to query and set those permissions.</source>
          <target state="translated">В некоторых операционных системах можно указать более сложные наборы разрешений доступа с помощью таких механизмов, как списки управления доступом (ACL). См. &lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;Расширенные атрибуты&lt;/a&gt; , чтобы узнать, как запрашивать и устанавливать эти разрешения.</target>
        </trans-unit>
        <trans-unit id="c32f84426cac9a32d45d101e0d8f5f9e2996aa5c" translate="yes" xml:space="preserve">
          <source>On some systems, when Emacs reads the output from a subprocess, the output data is read in very small blocks, potentially resulting in very poor performance. This behavior can be remedied to some extent by setting the variable &lt;code&gt;process-adaptive-read-buffering&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value (the default), as it will automatically delay reading from such processes, thus allowing them to produce more output before Emacs tries to read it.</source>
          <target state="translated">В некоторых системах, когда Emacs считывает выходные данные подпроцесса, выходные данные считываются очень маленькими блоками, что может привести к очень низкой производительности. Это поведение можно до некоторой степени исправить, установив для переменной &lt;code&gt;process-adaptive-read-buffering&lt;/code&gt; значение, отличное от &lt;code&gt;nil&lt;/code&gt; (по умолчанию), так как это автоматически задерживает чтение из таких процессов, что позволяет им производить больше вывода до того, как Emacs попытается прочитать это.</target>
        </trans-unit>
        <trans-unit id="819b49b75e3e8487d55fbdd732a2765e416d401d" translate="yes" xml:space="preserve">
          <source>On success, it returns a list of a binary string (the output) and the IV used.</source>
          <target state="translated">В случае успеха,он возвращает список двоичной строки (вывод)и IV использованный.</target>
        </trans-unit>
        <trans-unit id="5b8c9a445132c5cf6d56dccf077cd1f1c5b172c2" translate="yes" xml:space="preserve">
          <source>On text terminals, it is possible to &lt;em&gt;suspend Emacs&lt;/em&gt;, which means stopping Emacs temporarily and returning control to its superior process, which is usually the shell. This allows you to resume editing later in the same Emacs process, with the same buffers, the same kill ring, the same undo history, and so on. To resume Emacs, use the appropriate command in the parent shell&amp;mdash;most likely &lt;code&gt;fg&lt;/code&gt;.</source>
          <target state="translated">На текстовых терминалах можно &lt;em&gt;приостановить Emacs&lt;/em&gt; , что означает временную остановку Emacs и возврат управления его вышестоящему процессу, которым обычно является оболочка. Это позволяет вам возобновить редактирование позже в том же процессе Emacs, с теми же буферами, тем же кругом уничтожений, той же историей отмены и так далее. Чтобы возобновить работу Emacs, используйте соответствующую команду в родительской оболочке - скорее всего, &lt;code&gt;fg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e13395725f09ad2c8856d110ef6337fce6ac46" translate="yes" xml:space="preserve">
          <source>On text terminals, suspending and resuming Emacs normally also refreshes the screen. Some terminal emulators record separate contents for display-oriented programs such as Emacs and for ordinary sequential display. If you are using such a terminal, you might want to inhibit the redisplay on resumption.</source>
          <target state="translated">На текстовых терминалах при приостановке и возобновлении работы Emacs обычно также освежает экран.Некоторые терминальные эмуляторы записывают отдельное содержимое для дисплейно-ориентированных программ,таких как Emacs,и для обычного последовательного отображения.Если вы используете такой терминал,возможно,вы захотите запретить повторное отображение при возобновлении.</target>
        </trans-unit>
        <trans-unit id="20d88ccd4c937138f50db938fd11563e2dd25a8e" translate="yes" xml:space="preserve">
          <source>On text terminals, the line spacing cannot be altered.</source>
          <target state="translated">На текстовых терминалах расстояние между строками не может быть изменено.</target>
        </trans-unit>
        <trans-unit id="e069fc175afc43cf759588b838318611f81e51ce" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;assq&lt;/code&gt; is not usually useful in alists where the keys may not be symbols:</source>
          <target state="translated">С другой стороны, &lt;code&gt;assq&lt;/code&gt; обычно не используется в списках, где ключи не могут быть символами:</target>
        </trans-unit>
        <trans-unit id="2812f8f2bcfa7413b908d5f9a288205c2972743e" translate="yes" xml:space="preserve">
          <source>On the other hand, the order of &lt;em&gt;bindings&lt;/em&gt; is unspecified: in the following example, either 1 or 2 might be printed.</source>
          <target state="translated">С другой стороны, порядок &lt;em&gt;привязок&lt;/em&gt; не указан: в следующем примере может быть напечатано 1 или 2.</target>
        </trans-unit>
        <trans-unit id="5f85ff0be4cebfcaf47b004ec226b3b02a71dc33" translate="yes" xml:space="preserve">
          <source>On the whole, Emacs follows the Unicode Standard in its implementation of character properties. In particular, Emacs supports the &lt;a href=&quot;https://www.unicode.org/reports/tr23/&quot;&gt;Unicode Character Property Model&lt;/a&gt;, and the Emacs character property database is derived from the Unicode Character Database (</source>
          <target state="translated">В целом Emacs следует стандарту Unicode в реализации свойств символов. В частности, Emacs поддерживает &lt;a href=&quot;https://www.unicode.org/reports/tr23/&quot;&gt;модель свойств символов Unicode&lt;/a&gt; , а база данных свойств символов Emacs является производной базы данных символов Unicode (</target>
        </trans-unit>
        <trans-unit id="0df1af20ccce16453cf49d86077bec23de12dd86" translate="yes" xml:space="preserve">
          <source>On window systems that support it, Emacs tries by default to make the text size of a frame measured in pixels a multiple of the frame&amp;rsquo;s character size. This, however, usually means that a frame can be resized only in character size increments when dragging its external borders. It also may break attempts to truly maximize the frame or making it &amp;ldquo;fullheight&amp;rdquo; or &amp;ldquo;fullwidth&amp;rdquo; (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) leaving some empty space below and/or on the right of the frame. The following option may help in that case.</source>
          <target state="translated">В оконных системах, которые его поддерживают, Emacs по умолчанию пытается сделать размер текста кадра, измеренный в пикселях, кратным размеру символа кадра. Это, однако, обычно означает, что размер кадра можно изменять только с приращением размера символа при перетаскивании его внешних границ. Это также может помешать попыткам по-настоящему развернуть кадр или сделать его &amp;laquo;на полную высоту&amp;raquo; или &amp;laquo;на полную ширину&amp;raquo; (см. &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Параметры размера&lt;/a&gt; ), оставив некоторое пустое пространство ниже и / или справа от кадра. В этом случае может помочь следующий вариант.</target>
        </trans-unit>
        <trans-unit id="841d1d478ab20c6c338cac784c3bcdb7e40083b9" translate="yes" xml:space="preserve">
          <source>On window systems, you can also enable auto-raising (on frame selection) or auto-lowering (on frame deselection) using frame parameters. See &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;.</source>
          <target state="translated">В оконных системах вы также можете включить автоматическое повышение (при выборе кадра) или автоматическое опускание (при отмене выбора кадра) с помощью параметров кадра. См. &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Параметры управления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77c8d598496ec2e71e45a895d0ca263179948375" translate="yes" xml:space="preserve">
          <source>On-demand loading of support libraries.</source>
          <target state="translated">Загрузка библиотек поддержки по требованию.</target>
        </trans-unit>
        <trans-unit id="ad07b4aac29586e1b0b7c1f1bda28884c7ab4bca" translate="yes" xml:space="preserve">
          <source>Once Emacs decides that a certain handler handles the error, it returns control to that handler. To do so, Emacs unbinds all variable bindings made by binding constructs that are being exited, and executes the cleanups of all &lt;code&gt;unwind-protect&lt;/code&gt; forms that are being exited. Once control arrives at the handler, the body of the handler executes normally.</source>
          <target state="translated">Как только Emacs решает, что определенный обработчик обрабатывает ошибку, он возвращает управление этому обработчику. Для этого Emacs отвязывает все привязки переменных, сделанные конструкциями привязки, из которых происходит выход, и выполняет очистку всех форм &lt;code&gt;unwind-protect&lt;/code&gt; от размотки, которые выходят. Как только управление поступает в обработчик, тело обработчика выполняется нормально.</target>
        </trans-unit>
        <trans-unit id="778c77b00697e4553fcdfbf4f104e11fe2eb93ee" translate="yes" xml:space="preserve">
          <source>Once a function is instrumented, any call to the function activates Edebug. Depending on which Edebug execution mode you have selected, activating Edebug may stop execution and let you step through the function, or it may update the display and continue execution while checking for debugging commands. The default execution mode is step, which stops execution. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</source>
          <target state="translated">После инструментирования функции любой вызов функции активирует Edebug. В зависимости от того, какой режим выполнения Edebug вы выбрали, активация Edebug может остановить выполнение и позволить вам перейти к выполнению функции или может обновить отображение и продолжить выполнение при проверке команд отладки. Режим выполнения по умолчанию - шаг, который останавливает выполнение. См. &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Раздел Режимы выполнения Edebug&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e4ee3d26197fcab8232cca69fb16d0f05f95688" translate="yes" xml:space="preserve">
          <source>Once a series has begun, the value is a marker which points to the buffer position in the warnings buffer of the start of the series.</source>
          <target state="translated">После начала серии значение представляет собой маркер,указывающий на позицию буфера в буфере предупреждений начала серии.</target>
        </trans-unit>
        <trans-unit id="36b6d567cfa67a7659808b6d1ff19d545a0d2c63" translate="yes" xml:space="preserve">
          <source>Once set up, side windows also change the behavior of the commands &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;). In particular, these commands will refrain from showing, in a side window, buffers that have not been displayed in that window before. They will also refrain from having a normal, non-side window show a buffer that has been already displayed in a side window. A notable exception to the latter rule occurs when an application, after displaying a buffer, resets that buffer&amp;rsquo;s local variables.</source>
          <target state="translated">После настройки боковые окна также изменяют поведение команд &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; и &lt;code&gt;switch-to-next-buffer&lt;/code&gt; (см. &lt;a href=&quot;window-history#Window-History&quot;&gt;История окон&lt;/a&gt; ). В частности, эти команды будут воздерживаться от отображения в боковом окне буферов, которые ранее не отображались в этом окне. Они также будут воздерживаться от того, чтобы в обычном небоковом окне отображался буфер, который уже был отображен в боковом окне. Заметное исключение из последнего правила возникает, когда приложение после отображения буфера сбрасывает локальные переменные этого буфера.</target>
        </trans-unit>
        <trans-unit id="46c1926d71b4e8e4b97adb3110fa61cac0093fb9" translate="yes" xml:space="preserve">
          <source>Once the buffer has a suitable &lt;code&gt;revert-buffer-function&lt;/code&gt; and &lt;code&gt;buffer-stale-function&lt;/code&gt;, several problems usually remain.</source>
          <target state="translated">После того , как буфер имеет подходящую &lt;code&gt;revert-buffer-function&lt;/code&gt; и &lt;code&gt;buffer-stale-function&lt;/code&gt; , несколько проблем , как правило , остаются.</target>
        </trans-unit>
        <trans-unit id="59381f9a9d9f927b9e2c3c74e1d9f85d8c8d831a" translate="yes" xml:space="preserve">
          <source>Once the mark exists in a buffer, it normally never ceases to exist. However, it may become &lt;em&gt;inactive&lt;/em&gt;, if Transient Mark mode is enabled. The buffer-local variable &lt;code&gt;mark-active&lt;/code&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that the mark is active. A command can call the function &lt;code&gt;deactivate-mark&lt;/code&gt; to deactivate the mark directly, or it can request deactivation of the mark upon return to the editor command loop by setting the variable &lt;code&gt;deactivate-mark&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">Как только метка существует в буфере, она обычно никогда не перестает существовать. Однако он может стать &lt;em&gt;неактивным&lt;/em&gt; , если включен режим Transient Mark. Локальная в буфере переменная &lt;code&gt;mark-active&lt;/code&gt; , если она не равна &lt;code&gt;nil&lt;/code&gt; , означает, что метка активна. Команда может вызвать функцию &lt;code&gt;deactivate-mark&lt;/code&gt; для непосредственной деактивации метки, или она может запросить деактивацию метки при возврате в цикл команд редактора, установив для переменной &lt;code&gt;deactivate-mark&lt;/code&gt; значение, отличное от &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="197124b549991ea7d2db5253b6de18d693ff5eb3" translate="yes" xml:space="preserve">
          <source>Once the variable has a value, you can refer to it by using the symbol itself as an expression. Thus,</source>
          <target state="translated">После того,как переменная имеет значение,к ней можно обратиться,используя в качестве выражения сам символ.Таким образом,</target>
        </trans-unit>
        <trans-unit id="fd18cae1d555d9632ceb9466f9b376521bcb7fd1" translate="yes" xml:space="preserve">
          <source>Once you scroll a window as far right as it can go, back to its normal position where the total leftward scrolling is zero, attempts to scroll any farther right have no effect.</source>
          <target state="translated">После прокрутки окна до упора вправо и возвращения его в нормальное положение,когда полная прокрутка влево равна нулю,попытки прокрутки дальше вправо не дают никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="e2ef1484d788b8e71ea675fa55e9514ec4d62317" translate="yes" xml:space="preserve">
          <source>Once your module function detected that a nonlocal exit is pending, it can either return to Emacs (after performing the necessary local cleanup), or it can attempt to recover from the nonlocal exit. The following</source>
          <target state="translated">Как только функция модуля обнаружит,что нелокальный выход находится в ожидании,он может либо вернуться в Emacs (после выполнения необходимой локальной очистки),либо попытаться восстановиться после нелокального выхода.Далее</target>
        </trans-unit>
        <trans-unit id="d1513ef69753da579d30dff357ebb3c01e465563" translate="yes" xml:space="preserve">
          <source>Once your module is written, compile it to produce a shared library, according to the conventions of the underlying platform. Then place the shared library in a directory mentioned in &lt;code&gt;load-path&lt;/code&gt; (see &lt;a href=&quot;library-search#Library-Search&quot;&gt;Library Search&lt;/a&gt;), where Emacs will find it.</source>
          <target state="translated">Как только ваш модуль будет написан, скомпилируйте его для создания общей библиотеки в соответствии с соглашениями базовой платформы. Затем поместите разделяемую библиотеку в каталог, указанный в &lt;code&gt;load-path&lt;/code&gt; (см. &lt;a href=&quot;library-search#Library-Search&quot;&gt;Поиск библиотеки&lt;/a&gt; ), где Emacs найдет ее.</target>
        </trans-unit>
        <trans-unit id="f3c0b70cb22f00da9b2ba81dbf3bf978932a071a" translate="yes" xml:space="preserve">
          <source>One &amp;lsquo;</source>
          <target state="translated">Один '</target>
        </trans-unit>
        <trans-unit id="4adda958bb416b9b9ce93994e71859b6fceded90" translate="yes" xml:space="preserve">
          <source>One example of a case where this variable makes a difference is when the default font has no italic equivalent. With the default ordering, the &lt;code&gt;italic&lt;/code&gt; face will use a non-italic font that is similar to the default one. But if you put &lt;code&gt;:slant&lt;/code&gt; before &lt;code&gt;:height&lt;/code&gt;, the &lt;code&gt;italic&lt;/code&gt; face will use an italic font, even if its height is not quite right.</source>
          <target state="translated">Один из примеров того, когда эта переменная имеет значение, - это когда шрифт по умолчанию не имеет курсивного эквивалента. При порядке по умолчанию для &lt;code&gt;italic&lt;/code&gt; будет использоваться не курсивный шрифт, аналогичный шрифту по умолчанию. Но если вы поставите &lt;code&gt;:slant&lt;/code&gt; перед &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;italic&lt;/code&gt; будет использовать курсивный шрифт, даже если его высота не совсем правильная.</target>
        </trans-unit>
        <trans-unit id="577e046c059fefb7e07e716cb84ee3c1d1a8d0ea" translate="yes" xml:space="preserve">
          <source>One object can have multiple textual representations. For example, &amp;lsquo;</source>
          <target state="translated">Один объект может иметь несколько текстовых представлений. Например, '</target>
        </trans-unit>
        <trans-unit id="e131db88539c1a117d848bab11ab32a20ff4ae32" translate="yes" xml:space="preserve">
          <source>One of the effects of making a minor mode global is that the &lt;var&gt;mode&lt;/var&gt; variable becomes a customization variable. Toggling it through the Customize interface turns the mode on and off, and its value can be saved for future Emacs sessions (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;Saving Customizations&lt;/a&gt; in</source>
          <target state="translated">Одним из следствий создания глобального второстепенного режима является то, что переменная &lt;var&gt;mode&lt;/var&gt; становится переменной настройки. Переключение его через интерфейс настройки включает и выключает режим, и его значение может быть сохранено для будущих сеансов Emacs (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;Сохранение настроек&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="8145e40ecbe1251ccfc0d64cf4ef8a0311780a53" translate="yes" xml:space="preserve">
          <source>One of the effects of making a minor mode global is that the &lt;var&gt;mode&lt;/var&gt; variable becomes a customization variable. Toggling it through the Customize interface turns the mode on and off, and its value can be saved for future Emacs sessions (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;Saving Customizations&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45c275128e0b9c2732acf99d11b72a739cabbf7" translate="yes" xml:space="preserve">
          <source>One of the elements is &lt;code&gt;(acl . &lt;var&gt;acl&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;acl&lt;/var&gt; has the same form returned by &lt;code&gt;file-acl&lt;/code&gt;.</source>
          <target state="translated">Один из элементов - &lt;code&gt;(acl . &lt;var&gt;acl&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;acl&lt;/var&gt; имеет ту же форму, что и &lt;code&gt;file-acl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33b9427a7425593acc13906a9fe5a0f436f2867b" translate="yes" xml:space="preserve">
          <source>One of the files in the content directory must be named</source>
          <target state="translated">Один из файлов в каталоге содержимого должен иметь имя</target>
        </trans-unit>
        <trans-unit id="889f4e481c60baff17ff497b3fc3a3ae3d75286d" translate="yes" xml:space="preserve">
          <source>One or more flag characters can appear immediately after the &amp;lsquo;</source>
          <target state="translated">Один или несколько символов флага могут появиться сразу после '</target>
        </trans-unit>
        <trans-unit id="b9aff7d2a1cda9fb1100f1f1c7d6d8ce23f3a07d" translate="yes" xml:space="preserve">
          <source>One possible consequence of this process is an infinite loop, in the event that a symbol&amp;rsquo;s function cell refers to the same symbol. Otherwise, we eventually obtain a non-symbol, which ought to be a function or other suitable object.</source>
          <target state="translated">Одним из возможных последствий этого процесса является бесконечный цикл в случае, если функциональная ячейка символа относится к тому же самому символу. В противном случае мы в конечном итоге получим не-символ, который должен быть функцией или другим подходящим объектом.</target>
        </trans-unit>
        <trans-unit id="2efc7bf28038f291b21bb7d6c5b6e4024d66a9f9" translate="yes" xml:space="preserve">
          <source>One potential reason for such a failure to instrument is that some macro definitions are not yet known to Emacs. To work around this, load the file which defines the function you are about to instrument.</source>
          <target state="translated">Одной из потенциальных причин такого отказа от инструмента является то,что некоторые макроопределения еще не известны Emacs.Чтобы обойти это,загрузите файл,который определяет функцию,с которой вы собираетесь работать.</target>
        </trans-unit>
        <trans-unit id="c73c9472ca68902783f9eff8fc7a9275e411bae6" translate="yes" xml:space="preserve">
          <source>One responsibility of &lt;var&gt;from-fn&lt;/var&gt; is to make sure that the beginning of the file no longer matches &lt;var&gt;regexp&lt;/var&gt;. Otherwise it is likely to get called again. Also, &lt;var&gt;from-fn&lt;/var&gt; must not involve buffers or files other than the one being decoded, otherwise the internal buffer used for formatting might be overwritten.</source>
          <target state="translated">Одна из обязанностей &lt;var&gt;from-fn&lt;/var&gt; - убедиться, что начало файла больше не соответствует &lt;var&gt;regexp&lt;/var&gt; . В противном случае, скорее всего, вам снова позвонят. Кроме того, &lt;var&gt;from-fn&lt;/var&gt; не должен включать буферы или файлы, кроме декодируемого, иначе внутренний буфер, используемый для форматирования, может быть перезаписан.</target>
        </trans-unit>
        <trans-unit id="a512c4c508943629411341265b0a1b3580ada561" translate="yes" xml:space="preserve">
          <source>One special kind of side effect can&amp;rsquo;t be avoided: constructing Lisp objects. Almost all macro expansions include constructed lists; that is the whole point of most macros. This is usually safe; there is just one case where you must be careful: when the object you construct is part of a quoted constant in the macro expansion.</source>
          <target state="translated">Нельзя избежать одного особого побочного эффекта: конструирования объектов Lisp. Почти все расширения макросов включают построенные списки; в этом весь смысл большинства макросов. Обычно это безопасно; есть только один случай, когда вы должны быть осторожны: когда создаваемый вами объект является частью указанной в кавычках константы в раскрытии макроса.</target>
        </trans-unit>
        <trans-unit id="c55a9d4e3055cc50dcbf39304bdeafccb27e6553" translate="yes" xml:space="preserve">
          <source>One unusual thing about this command is that the entire line containing position &lt;var&gt;beg&lt;/var&gt;, and the entire line containing position &lt;var&gt;end&lt;/var&gt;, are included in the region sorted.</source>
          <target state="translated">Одна необычная вещь об этой команде, что вся строка , содержащая положение &lt;var&gt;beg&lt;/var&gt; , и вся строка , содержащая положение &lt;var&gt;end&lt;/var&gt; , включены в область сортировки.</target>
        </trans-unit>
        <trans-unit id="a2d226d6e0986fd5ff1e62cb952a91648093c02f" translate="yes" xml:space="preserve">
          <source>One use for &lt;code&gt;image-flush&lt;/code&gt; is to tell Emacs about a change in an image file. If an image specification contains a &lt;code&gt;:file&lt;/code&gt; property, the image is cached based on the file&amp;rsquo;s contents when the image is first displayed. Even if the file subsequently changes, Emacs continues displaying the old version of the image. Calling &lt;code&gt;image-flush&lt;/code&gt; flushes the image from the cache, forcing Emacs to re-read the file the next time it needs to display that image.</source>
          <target state="translated">Один из способов использования &lt;code&gt;image-flush&lt;/code&gt; - сообщить Emacs об изменении файла образа. Если спецификация изображения содержит свойство &lt;code&gt;:file&lt;/code&gt; , изображение кэшируется на основе содержимого файла при первом отображении изображения. Даже если файл впоследствии изменится, Emacs продолжит отображать старую версию изображения. Вызов &lt;code&gt;image-flush&lt;/code&gt; очищает изображение из кеша, заставляя Emacs перечитать файл в следующий раз, когда ему потребуется отобразить это изображение.</target>
        </trans-unit>
        <trans-unit id="6f05610b66d19812d3d46bdeffc2bf46fe230ffa" translate="yes" xml:space="preserve">
          <source>One use of &lt;code&gt;regexp-quote&lt;/code&gt; is to combine an exact string match with context described as a regular expression. For example, this searches for the string that is the value of &lt;var&gt;string&lt;/var&gt;, surrounded by whitespace:</source>
          <target state="translated">Одно из применений &lt;code&gt;regexp-quote&lt;/code&gt; - объединить точное совпадение строки с контекстом, описанным как регулярное выражение. Например, выполняется поиск строки, являющейся значением &lt;var&gt;string&lt;/var&gt; , окруженной пробелами:</target>
        </trans-unit>
        <trans-unit id="6b443615f7088e219757f3ce2e0767b4fb5de64b" translate="yes" xml:space="preserve">
          <source>One use of focus redirection is for frames that don&amp;rsquo;t have minibuffers. These frames use minibuffers on other frames. Activating a minibuffer on another frame redirects focus to that frame. This puts the focus on the minibuffer&amp;rsquo;s frame, where it belongs, even though the mouse remains in the frame that activated the minibuffer.</source>
          <target state="translated">Одно из применений перенаправления фокуса - для кадров, у которых нет минибуфера. Эти фреймы используют минибуферы на других фреймах. Активация минибуфера на другом кадре перенаправляет фокус на этот кадр. Это помещает фокус на фрейм минибуфера, которому он принадлежит, даже если мышь остается в фрейме, который активировал минибуфер.</target>
        </trans-unit>
        <trans-unit id="55ca5f8a1f3a2f9f4a1e3fefe222967bb4301ed6" translate="yes" xml:space="preserve">
          <source>One use of minor mode keymaps is to modify the behavior of certain self-inserting characters so that they do something else as well as self-insert. (Another way to customize &lt;code&gt;self-insert-command&lt;/code&gt; is through &lt;code&gt;post-self-insert-hook&lt;/code&gt;, see &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;Commands for Insertion&lt;/a&gt;. Apart from this, the facilities for customizing &lt;code&gt;self-insert-command&lt;/code&gt; are limited to special cases, designed for abbrevs and Auto Fill mode. Do not try substituting your own definition of &lt;code&gt;self-insert-command&lt;/code&gt; for the standard one. The editor command loop handles this function specially.)</source>
          <target state="translated">Одним из способов использования раскладок вспомогательного режима является изменение поведения некоторых самовставляющихся символов, чтобы они делали что-то еще, кроме самовставки. (Другой способ настроить &lt;code&gt;self-insert-command&lt;/code&gt; - использовать &lt;code&gt;post-self-insert-hook&lt;/code&gt; , см. &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;Команды для вставки&lt;/a&gt; . Помимо этого, возможности для настройки &lt;code&gt;self-insert-command&lt;/code&gt; ограничены особыми случаями, разработанными для сокращений и автозаполнения mode. Не пытайтесь заменить стандартное определение &lt;code&gt;self-insert-command&lt;/code&gt; своим собственным . Цикл команд редактора обрабатывает эту функцию специально.)</target>
        </trans-unit>
        <trans-unit id="964a845b7c3be261e46e6c16cfdd2b39ae693122" translate="yes" xml:space="preserve">
          <source>One use of this function is in preparation for defining a longer key that uses &lt;var&gt;key&lt;/var&gt; as a prefix&amp;mdash;which would not be allowed if &lt;var&gt;key&lt;/var&gt; has a non-prefix binding. For example:</source>
          <target state="translated">Одно из применений этой функции - подготовка к определению более длинного ключа, который использует &lt;var&gt;key&lt;/var&gt; в качестве префикса, что было бы недопустимо, если бы &lt;var&gt;key&lt;/var&gt; не имел привязки к префиксу. Например:</target>
        </trans-unit>
        <trans-unit id="992da344af8495da1bf5875640a42f02ebd76cdf" translate="yes" xml:space="preserve">
          <source>One use of this function is to define function keys on terminals that have downloadable function key definitions. For example, this is how (on certain terminals) to define function key 4 to move forward four characters (by transmitting the characters</source>
          <target state="translated">Одним из способов использования этой функции является определение функциональных клавиш на терминалах,которые имеют загружаемые определения функциональных клавиш.Например,таким образом (на некоторых терминалах)для определения функциональной клавиши 4 можно перемещать вперед четыре символа (передавая символы</target>
        </trans-unit>
        <trans-unit id="023abc72efceee06dfb7ea03706101194c813d2e" translate="yes" xml:space="preserve">
          <source>One use of this variable is for telling &lt;code&gt;x-popup-menu&lt;/code&gt; where to pop up a menu. It is also used internally by &lt;code&gt;y-or-n-p&lt;/code&gt; (see &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Yes-or-No Queries&lt;/a&gt;).</source>
          <target state="translated">Одно из применений этой переменной - указать &lt;code&gt;x-popup-menu&lt;/code&gt; , где открыть всплывающее меню. Он также используется внутри &lt;code&gt;y-or-n-p&lt;/code&gt; (см. &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Запросы типа &amp;laquo;да или нет&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bde8277d79875f5ea95a8ec30aa3980302baf104" translate="yes" xml:space="preserve">
          <source>One way or another, these mechanisms specify a Lisp value for the spacing of each line. The value is a height spec, and it translates into a Lisp value as described above. However, in this case the numeric height value specifies the line spacing, rather than the line height.</source>
          <target state="translated">Так или иначе,эти механизмы задают значение Lisp для интервала между строками.Это значение является спецификацией высоты и переводится в значение Lisp,как описано выше.Однако,в данном случае значение числовой высоты определяет расстояние между строками,а не их высоту.</target>
        </trans-unit>
        <trans-unit id="f712e3c7ea934966609bea4ea08c88d53b0d34d7" translate="yes" xml:space="preserve">
          <source>One way to avoid pathological cases like this is to think of &lt;code&gt;empty-object&lt;/code&gt; as a funny kind of constant, not as a memory allocation construct. You wouldn&amp;rsquo;t use &lt;code&gt;setcar&lt;/code&gt; on a constant such as &lt;code&gt;'(nil)&lt;/code&gt;, so naturally you won&amp;rsquo;t use it on &lt;code&gt;(empty-object)&lt;/code&gt; either.</source>
          <target state="translated">Один из способов избежать подобных патологических случаев - рассматривать &lt;code&gt;empty-object&lt;/code&gt; как забавную константу, а не как конструкцию распределения памяти. Вы бы не использовали &lt;code&gt;setcar&lt;/code&gt; для константы, такой как &lt;code&gt;'(nil)&lt;/code&gt; , поэтому, естественно, вы не будете использовать ее и для &lt;code&gt;(empty-object)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21005527907c627869027aeb58d2b47e207aa33d" translate="yes" xml:space="preserve">
          <source>One way to cope with circular structure is to set &lt;code&gt;print-length&lt;/code&gt; or &lt;code&gt;print-level&lt;/code&gt; to truncate the printing. Edebug does this for you; it binds &lt;code&gt;print-length&lt;/code&gt; and &lt;code&gt;print-level&lt;/code&gt; to the values of the variables &lt;code&gt;edebug-print-length&lt;/code&gt; and &lt;code&gt;edebug-print-level&lt;/code&gt; (so long as they have non-&lt;code&gt;nil&lt;/code&gt; values). See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">Один из способов справиться с круговой структурой - установить &lt;code&gt;print-length&lt;/code&gt; &lt;code&gt;print-level&lt;/code&gt; или уровень печати, чтобы обрезать печать. Edebug сделает это за вас; он связывает &lt;code&gt;print-length&lt;/code&gt; и &lt;code&gt;print-level&lt;/code&gt; со значениями переменных &lt;code&gt;edebug-print-length&lt;/code&gt; и &lt;code&gt;edebug-print-level&lt;/code&gt; (если они имеют &lt;code&gt;nil&lt;/code&gt; значения). См. &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Выходные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb79df4c6bc7c681333d9bd2d1fe18512e30d371" translate="yes" xml:space="preserve">
          <source>One way to ensure reliable rehighlighting of multiline Font Lock constructs is to put on them the text property &lt;code&gt;font-lock-multiline&lt;/code&gt;. It should be present and non-&lt;code&gt;nil&lt;/code&gt; for text that is part of a multiline construct.</source>
          <target state="translated">Один из способов обеспечить надежное повторное выделение многострочных конструкций Font Lock - это присвоить им текстовое свойство &lt;code&gt;font-lock-multiline&lt;/code&gt; . Он должен присутствовать и отличаться от &lt;code&gt;nil&lt;/code&gt; для текста, который является частью многострочной конструкции.</target>
        </trans-unit>
        <trans-unit id="c715d20a7533e9f52b8676dee0de643ff507bb6b" translate="yes" xml:space="preserve">
          <source>One way to increase the security of your packages is to &lt;em&gt;sign&lt;/em&gt; them using a cryptographic key. If you have generated a private/public gpg key pair, you can use gpg to sign the package like this:</source>
          <target state="translated">Один из способов повысить безопасность ваших пакетов - &lt;em&gt;подписать&lt;/em&gt; их с помощью криптографического ключа. Если вы сгенерировали пару закрытых / общедоступных ключей gpg, вы можете использовать gpg для подписи пакета следующим образом:</target>
        </trans-unit>
        <trans-unit id="fbc2d56b429ee910d28dbf2fbd89ff2226fc991f" translate="yes" xml:space="preserve">
          <source>One way to represent a face is as a property list of attributes, like &lt;code&gt;(:foreground &quot;red&quot; :weight bold)&lt;/code&gt;. Such a list is called an &lt;em&gt;anonymous face&lt;/em&gt;. For example, you can assign an anonymous face as the value of the &lt;code&gt;face&lt;/code&gt; text property, and Emacs will display the underlying text with the specified attributes. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">Один из способов представить лицо - это список свойств атрибутов, например &lt;code&gt;(:foreground &quot;red&quot; :weight bold)&lt;/code&gt; . Такой список называется &lt;em&gt;анонимным лицом&lt;/em&gt; . Например, вы можете назначить анонимное лицо в качестве значения свойства текста &lt;code&gt;face&lt;/code&gt; , и Emacs отобразит базовый текст с указанными атрибутами. См. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Особые свойства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85f792f34f1609454c8ad7752317553e8a6aea26" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; is to exit from a doubly nested loop. (In most languages, this would be done with a &lt;code&gt;goto&lt;/code&gt;.) Here we compute &lt;code&gt;(foo &lt;var&gt;i&lt;/var&gt; &lt;var&gt;j&lt;/var&gt;)&lt;/code&gt; for &lt;var&gt;i&lt;/var&gt; and &lt;var&gt;j&lt;/var&gt; varying from 0 to 9:</source>
          <target state="translated">Один из способов использования &lt;code&gt;catch&lt;/code&gt; и &lt;code&gt;throw&lt;/code&gt; - выйти из двояко вложенного цикла. (В большинстве языков это будет сделано с помощью &lt;code&gt;goto&lt;/code&gt; .) Здесь мы вычисляем &lt;code&gt;(foo &lt;var&gt;i&lt;/var&gt; &lt;var&gt;j&lt;/var&gt;)&lt;/code&gt; для &lt;var&gt;i&lt;/var&gt; и &lt;var&gt;j&lt;/var&gt; от 0 до 9:</target>
        </trans-unit>
        <trans-unit id="48d778b2ad99cdef9eebb6a0fb329935a9f7da52" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays of &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Одномерные массивы &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6073cf4225ea4cf9fd99b377fa082aad9eea6d61" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays.</source>
          <target state="translated">Одномерные массивы.</target>
        </trans-unit>
        <trans-unit id="be996260ce0e4df49d84c11ecb1d8434ceb9918f" translate="yes" xml:space="preserve">
          <source>One-dimensional sparse arrays indexed by characters.</source>
          <target state="translated">Одномерные разреженные массивы,проиндексированные символами.</target>
        </trans-unit>
        <trans-unit id="ae88654faca91364a5a35b8017f9b11dd388a0bf" translate="yes" xml:space="preserve">
          <source>Only &lt;var&gt;body-form&lt;/var&gt; is protected by the &lt;code&gt;unwind-protect&lt;/code&gt;. If any of the &lt;var&gt;cleanup-forms&lt;/var&gt; themselves exits nonlocally (via a &lt;code&gt;throw&lt;/code&gt; or an error), &lt;code&gt;unwind-protect&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to evaluate the rest of them. If the failure of one of the &lt;var&gt;cleanup-forms&lt;/var&gt; has the potential to cause trouble, then protect it with another &lt;code&gt;unwind-protect&lt;/code&gt; around that form.</source>
          <target state="translated">Только &lt;var&gt;body-form&lt;/var&gt; защищена защитой от &lt;code&gt;unwind-protect&lt;/code&gt; . Если какие - либо из &lt;var&gt;cleanup-forms&lt;/var&gt; самих выездов с нелокально (через &lt;code&gt;throw&lt;/code&gt; или ошибку), &lt;code&gt;unwind-protect&lt;/code&gt; являются &lt;em&gt;не&lt;/em&gt; гарантированы , чтобы оценить остальные. Если сбой одной из &lt;var&gt;cleanup-forms&lt;/var&gt; может вызвать проблемы, то защитите ее с помощью другой &lt;code&gt;unwind-protect&lt;/code&gt; вокруг этой формы.</target>
        </trans-unit>
        <trans-unit id="5ddbb81d5905d23be7a9282a488499d00d5db21e" translate="yes" xml:space="preserve">
          <source>Only available on macOS, if non-&lt;code&gt;nil&lt;/code&gt;, set the titlebar and toolbar to be transparent. This effectively sets the background color of both to match the Emacs background color.</source>
          <target state="translated">Доступно только в macOS, если не &lt;code&gt;nil&lt;/code&gt; , установите прозрачность заголовка и панели инструментов. Это эффективно устанавливает цвет фона обоих в соответствии с цветом фона Emacs.</target>
        </trans-unit>
        <trans-unit id="18179e6d777e1c5274c1d80de143a1698c76c5dd" translate="yes" xml:space="preserve">
          <source>Only available on macOS, if set to &lt;code&gt;dark&lt;/code&gt; draw this frame&amp;rsquo;s window-system window using the &amp;ldquo;vibrant dark&amp;rdquo; theme, otherwise use the system default. The &amp;ldquo;vibrant dark&amp;rdquo; theme can be used to set the toolbar and scrollbars to a dark appearance when using an Emacs theme with a dark background.</source>
          <target state="translated">Доступно только в macOS, если установлено значение &amp;laquo; &lt;code&gt;dark&lt;/code&gt; нарисуйте окно оконной системы этого фрейма, используя &amp;laquo;яркую темную&amp;raquo; тему, в противном случае используйте системное значение по умолчанию. &amp;laquo;Яркая темная&amp;raquo; тема может использоваться для настройки темного вида панели инструментов и полос прокрутки при использовании темы Emacs с темным фоном.</target>
        </trans-unit>
        <trans-unit id="c4e0867e177c2c0fb6455a0e2fbcd920632c9814" translate="yes" xml:space="preserve">
          <source>Only if creating a new frame fails, &lt;code&gt;display-buffer&lt;/code&gt; will apply the actions supplied by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; which means to again try reusing a window, popping up a new window and so on. A trivial way to make frame creation fail is supplied by the following form:</source>
          <target state="translated">Только в случае сбоя создания нового кадра &lt;code&gt;display-buffer&lt;/code&gt; применит действия, предоставленные &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; , что означает повторную попытку повторного использования окна, появление нового окна и т. Д. Тривиальный способ сделать невозможным создание фрейма - это следующая форма:</target>
        </trans-unit>
        <trans-unit id="586047e86826f6dbd9c9e2881cee476941126e1e" translate="yes" xml:space="preserve">
          <source>Only top-level values (arrays and objects) can be serialized to JSON. The subobjects within these top-level values can be of any type. Likewise, the parsing functions will only return vectors, hashtables, alists, and plists.</source>
          <target state="translated">Только значения верхнего уровня (массивы и объекты)могут быть сериализованы в JSON.Подобъекты внутри этих значений верхнего уровня могут быть любого типа.Аналогично,функции синтаксического анализа будут возвращать только векторы,хэш-таблицы,алисты и списки.</target>
        </trans-unit>
        <trans-unit id="d7386c857a6085eb01544217b3270be05da5ce62" translate="yes" xml:space="preserve">
          <source>Open parenthesis characters: &amp;lsquo;</source>
          <target state="translated">Открытые круглые скобки: '</target>
        </trans-unit>
        <trans-unit id="7c1e62f5f482a805fbc3795b139cfba4a6ee67ba" translate="yes" xml:space="preserve">
          <source>Opening network connections.</source>
          <target state="translated">Открытие сетевых соединений.</target>
        </trans-unit>
        <trans-unit id="8a38f5abc74dccf57ac90365fb1a9bb0148242a3" translate="yes" xml:space="preserve">
          <source>Operating System Environment</source>
          <target state="translated">Среда операционной системы</target>
        </trans-unit>
        <trans-unit id="47ccf7c0529a8c5659311c8f82bec6086b29bb6c" translate="yes" xml:space="preserve">
          <source>Operating System Interface</source>
          <target state="translated">Интерфейс операционной системы</target>
        </trans-unit>
        <trans-unit id="686c6069aa66b3b4e21a44c27c9586de497a2f96" translate="yes" xml:space="preserve">
          <source>Operating on X11 Keysyms</source>
          <target state="translated">Работа на клавишах X11</target>
        </trans-unit>
        <trans-unit id="1f124ca397e717abcc79b77c1f05d2b73214fbd7" translate="yes" xml:space="preserve">
          <source>Operating on key symbols for X Windows.</source>
          <target state="translated">Работа с символами ключей для X Windows.</target>
        </trans-unit>
        <trans-unit id="f100a2b248d1a840348b4d7eb2abbcfa1fd0b916" translate="yes" xml:space="preserve">
          <source>Operating on the special minibuffer windows.</source>
          <target state="translated">Работает на специальных окнах минибуфера.</target>
        </trans-unit>
        <trans-unit id="30642cc8933c44209f3f574d7f685d3dbe69cad1" translate="yes" xml:space="preserve">
          <source>Operator Precedence Grammars</source>
          <target state="translated">Приоритет оператора Грамматика</target>
        </trans-unit>
        <trans-unit id="9abbe311bb8d8a0022002079a7ed956ab53457b0" translate="yes" xml:space="preserve">
          <source>Operator precedence grammar is a very primitive technology for parsing compared to some of the more common techniques used in compilers. It has the following characteristics: its parsing power is very limited, and it is largely unable to detect syntax errors, but it has the advantage of being algorithmically efficient and able to parse forward just as well as backward. In practice that means that SMIE can use it for indentation based on backward parsing, that it can provide both &lt;code&gt;forward-sexp&lt;/code&gt; and &lt;code&gt;backward-sexp&lt;/code&gt; functionality, and that it will naturally work on syntactically incorrect code without any extra effort. The downside is that it also means that most programming languages cannot be parsed correctly using SMIE, at least not without resorting to some special tricks (see &lt;a href=&quot;smie-tricks#SMIE-Tricks&quot;&gt;SMIE Tricks&lt;/a&gt;).</source>
          <target state="translated">Грамматика приоритета операторов - это очень примитивная технология синтаксического анализа по сравнению с некоторыми из наиболее распространенных методов, используемых в компиляторах. Он имеет следующие характеристики: его возможности синтаксического анализа очень ограничены, и он в значительной степени неспособен обнаруживать синтаксические ошибки, но он имеет преимущество в том, что он алгоритмически эффективен и может анализировать как вперед, так и назад. На практике это означает, что SMIE может использовать его для отступов на основе обратного синтаксического анализа, что он может обеспечивать функциональность как &lt;code&gt;forward-sexp&lt;/code&gt; и &lt;code&gt;backward-sexp&lt;/code&gt; , и что он, естественно, будет работать с синтаксически неверным кодом без каких-либо дополнительных усилий. Обратной стороной является то, что это также означает, что большинство языков программирования не могут быть правильно проанализированы с помощью SMIE, по крайней мере, без использования некоторых специальных приемов (см.&lt;a href=&quot;smie-tricks#SMIE-Tricks&quot;&gt;SMIE Tricks&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="433ecb082f2de86ea14497d016e6339cef126f75" translate="yes" xml:space="preserve">
          <source>Option variables for customizing Edebug.</source>
          <target state="translated">Опциональные переменные для настройки Edebug.</target>
        </trans-unit>
        <trans-unit id="41725bd17665c6ac89cc5165603ca309d1ea2d7c" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;family&lt;/var&gt; specified as symbol &lt;code&gt;ipv4&lt;/code&gt; or &lt;code&gt;ipv6&lt;/code&gt; restricts the returned information to IPv4 and IPv6 addresses respectively, independently of the value of &lt;var&gt;full&lt;/var&gt;. Specifying &lt;code&gt;ipv6&lt;/code&gt; when IPv6 support is not available will result in an error being signaled.</source>
          <target state="translated">Необязательное &lt;var&gt;family&lt;/var&gt; аргументов, указанное как символ &lt;code&gt;ipv4&lt;/code&gt; или &lt;code&gt;ipv6&lt;/code&gt; , ограничивает возвращаемую информацию адресами IPv4 и IPv6 соответственно, независимо от значения &lt;var&gt;full&lt;/var&gt; . Указание &lt;code&gt;ipv6&lt;/code&gt; , когда поддержка IPv6 недоступна, приведет к выдаче сигнала об ошибке.</target>
        </trans-unit>
        <trans-unit id="b0205e865ebbb646fcce5e119e547b665d053edb" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;full&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to instead return a list of one or more elements of the form &lt;code&gt;(&lt;var&gt;ifname&lt;/var&gt;&amp;nbsp;&lt;var&gt;addr&lt;/var&gt;&amp;nbsp;&lt;var&gt;bcast&lt;/var&gt;&amp;nbsp;&lt;var&gt;netmask&lt;/var&gt;)&lt;/code&gt;. &lt;var&gt;ifname&lt;/var&gt; is a non-unique string naming the interface. &lt;var&gt;addr&lt;/var&gt;, &lt;var&gt;bcast&lt;/var&gt;, and &lt;var&gt;netmask&lt;/var&gt; are vectors of integers detailing the IP address, broadcast address, and network mask.</source>
          <target state="translated">Необязательный аргумент &lt;var&gt;full&lt;/var&gt; не- &lt;code&gt;nil&lt;/code&gt; средство вместо возвращать список из одного или более элементов вида &lt;code&gt;(&lt;var&gt;ifname&lt;/var&gt;&amp;nbsp;&lt;var&gt;addr&lt;/var&gt;&amp;nbsp;&lt;var&gt;bcast&lt;/var&gt;&amp;nbsp;&lt;var&gt;netmask&lt;/var&gt;)&lt;/code&gt; . &lt;var&gt;ifname&lt;/var&gt; - это неуникальная строка, называющая интерфейс. &lt;var&gt;addr&lt;/var&gt; , &lt;var&gt;bcast&lt;/var&gt; , и &lt;var&gt;netmask&lt;/var&gt; являются векторами целых чисел , детализирующих IP - адрес, широковещательный адрес и сетевой маски.</target>
        </trans-unit>
        <trans-unit id="3ce281c8a118cd3ed61dcec4880e6886db816d03" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;size&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to try swapping the sizes of &lt;var&gt;window-1&lt;/var&gt; and &lt;var&gt;window-2&lt;/var&gt; as well. A value of &lt;code&gt;height&lt;/code&gt; means to swap heights only, a value of &lt;code&gt;width&lt;/code&gt; means to swap widths only, while &lt;code&gt;t&lt;/code&gt; means to swap both widths and heights, if possible. Frames are not resized by this function.</source>
          <target state="translated">Необязательный &lt;var&gt;size&lt;/var&gt; аргумента, отличный от &lt;code&gt;nil&lt;/code&gt; , означает попытку поменять местами также размеры &lt;var&gt;window-1&lt;/var&gt; и &lt;var&gt;window-2&lt;/var&gt; . Значение &lt;code&gt;height&lt;/code&gt; означает замену только высоты, значение &lt;code&gt;width&lt;/code&gt; означает замену только ширины, а &lt;code&gt;t&lt;/code&gt; означает замену и ширины, и высоты, если это возможно. Эта функция не меняет размер фреймов.</target>
        </trans-unit>
        <trans-unit id="ce411d37922de190b756838011d8fc8421d7f336" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;suffix&lt;/var&gt; is a string to be displayed after &lt;var&gt;reporter&lt;/var&gt;&amp;rsquo;s main message and progress text. If &lt;var&gt;reporter&lt;/var&gt; is a non-numerical reporter, then &lt;var&gt;value&lt;/var&gt; should be &lt;code&gt;nil&lt;/code&gt;, or a string to use instead of &lt;var&gt;suffix&lt;/var&gt;.</source>
          <target state="translated">Необязательный &lt;var&gt;suffix&lt;/var&gt; аргумента - это строка, которая отображается после основного сообщения &lt;var&gt;reporter&lt;/var&gt; и текста о ходе выполнения. Если &lt;var&gt;reporter&lt;/var&gt; является числовым репортером, тогда &lt;var&gt;value&lt;/var&gt; должно быть &lt;code&gt;nil&lt;/code&gt; или строкой, которая будет использоваться вместо &lt;var&gt;suffix&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a305373f5ab4c8179b157e7348094ea4ce59f3c4" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;type&lt;/var&gt; specifies the type of the edges to return: &lt;code&gt;outer-edges&lt;/code&gt; means to return the outer edges of &lt;var&gt;frame&lt;/var&gt;, &lt;code&gt;native-edges&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt;) means to return its native edges and &lt;code&gt;inner-edges&lt;/code&gt; means to return its inner edges.</source>
          <target state="translated">Необязательный &lt;var&gt;type&lt;/var&gt; аргумента указывает тип возвращаемых краев: &lt;code&gt;outer-edges&lt;/code&gt; означает возврат внешних краев &lt;var&gt;frame&lt;/var&gt; , &lt;code&gt;native-edges&lt;/code&gt; (или &lt;code&gt;nil&lt;/code&gt; ) означает возврат его собственных краев, а &lt;code&gt;inner-edges&lt;/code&gt; означает возврат его внутренних краев.</target>
        </trans-unit>
        <trans-unit id="b389bdb03281d5aed10905c4bf13e4c443b15b78" translate="yes" xml:space="preserve">
          <source>Options for how input is processed.</source>
          <target state="translated">Опции обработки входных данных.</target>
        </trans-unit>
        <trans-unit id="676740d3b53e425b59a5051ef0cf6614000f6153" translate="yes" xml:space="preserve">
          <source>Ordinarily the first argument is a list &lt;code&gt;(&lt;var&gt;second&lt;/var&gt; &lt;var&gt;minute&lt;/var&gt; &lt;var&gt;hour&lt;/var&gt; &lt;var&gt;day&lt;/var&gt; &lt;var&gt;month&lt;/var&gt;
&lt;var&gt;year&lt;/var&gt; &lt;var&gt;ignored&lt;/var&gt; &lt;var&gt;dst&lt;/var&gt; &lt;var&gt;zone&lt;/var&gt;)&lt;/code&gt; that specifies a decoded time in the style of &lt;code&gt;decode-time&lt;/code&gt;, so that &lt;code&gt;(encode-time (decode-time ...))&lt;/code&gt; works. For the meanings of these list members, see the table under &lt;code&gt;decode-time&lt;/code&gt;.</source>
          <target state="translated">Обычно первым аргументом является список &lt;code&gt;(&lt;var&gt;second&lt;/var&gt; &lt;var&gt;minute&lt;/var&gt; &lt;var&gt;hour&lt;/var&gt; &lt;var&gt;day&lt;/var&gt; &lt;var&gt;month&lt;/var&gt; &lt;var&gt;year&lt;/var&gt; &lt;var&gt;ignored&lt;/var&gt; &lt;var&gt;dst&lt;/var&gt; &lt;var&gt;zone&lt;/var&gt;)&lt;/code&gt; который указывает декодированное время в стиле &lt;code&gt;decode-time&lt;/code&gt; , так что &lt;code&gt;(encode-time (decode-time ...))&lt;/code&gt; работает. Значения этих членов списка см. В таблице в разделе время &lt;code&gt;decode-time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c6d5310c1a644ae25978f7caf49bad39c82c0ef" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;fill-individual-paragraphs&lt;/code&gt; regards each change in indentation as starting a new paragraph. If &lt;code&gt;fill-individual-varying-indent&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then only separator lines separate paragraphs. That mode can handle indented paragraphs with additional indentation on the first line.</source>
          <target state="translated">Обычно команда &lt;code&gt;fill-individual-paragraphs&lt;/code&gt; рассматривает каждое изменение отступа как начало нового абзаца. Если &lt;code&gt;fill-individual-varying-indent&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; , то только разделительные линии разделяют абзацы. В этом режиме можно обрабатывать абзацы с отступом с дополнительным отступом в первой строке.</target>
        </trans-unit>
        <trans-unit id="375f3605b67b9e5591350d037468627ffa4a6244" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;rename-buffer&lt;/code&gt; signals an error if &lt;var&gt;newname&lt;/var&gt; is already in use. However, if &lt;var&gt;unique&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it modifies &lt;var&gt;newname&lt;/var&gt; to make a name that is not in use. Interactively, you can make &lt;var&gt;unique&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; with a numeric prefix argument. (This is how the command &lt;code&gt;rename-uniquely&lt;/code&gt; is implemented.)</source>
          <target state="translated">Обычно &lt;code&gt;rename-buffer&lt;/code&gt; сигнализирует об ошибке, если &lt;var&gt;newname&lt;/var&gt; уже используется. Однако, если &lt;var&gt;unique&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , он изменяет &lt;var&gt;newname&lt;/var&gt; , чтобы сделать имя, которое не используется. В интерактивном режиме вы можете сделать &lt;var&gt;unique&lt;/var&gt; отличным от &lt;code&gt;nil&lt;/code&gt; аргументом числового префикса. (Так реализована команда &lt;code&gt;rename-uniquely&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="49604b10b3ce6fc4e228c33eaf4c9eabebbafb54" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;unload-feature&lt;/code&gt; refuses to unload a library on which other loaded libraries depend. (A library &lt;var&gt;a&lt;/var&gt; depends on library &lt;var&gt;b&lt;/var&gt; if &lt;var&gt;a&lt;/var&gt; contains a &lt;code&gt;require&lt;/code&gt; for &lt;var&gt;b&lt;/var&gt;.) If the optional argument &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, dependencies are ignored and you can unload any library.</source>
          <target state="translated">Обычно &lt;code&gt;unload-feature&lt;/code&gt; отказывается выгружать библиотеку, от которой зависят другие загруженные библиотеки. (Библиотека &lt;var&gt;a&lt;/var&gt; зависит от библиотеки &lt;var&gt;b&lt;/var&gt; , если &lt;var&gt;a&lt;/var&gt; содержит &lt;code&gt;require&lt;/code&gt; для &lt;var&gt;b&lt;/var&gt; .) Если необязательный аргумент &lt;var&gt;force&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , зависимости игнорируются, и вы можете выгрузить любую библиотеку.</target>
        </trans-unit>
        <trans-unit id="1bfbb016c1886fa701a54a40747d69fbc68c3719" translate="yes" xml:space="preserve">
          <source>Ordinarily, functions that operate on text or move point do not care whether the text is invisible, they process invisible characters and visible characters alike. The user-level line motion commands, such as &lt;code&gt;next-line&lt;/code&gt;, &lt;code&gt;previous-line&lt;/code&gt;, ignore invisible newlines if &lt;code&gt;line-move-ignore-invisible&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (the default), i.e., behave like these invisible newlines didn&amp;rsquo;t exist in the buffer, but only because they are explicitly programmed to do so.</source>
          <target state="translated">Обычно функции, которые работают с текстом или перемещают точку, не заботятся о том, является ли текст невидимым, они обрабатывают как невидимые, так и видимые символы. Команды перемещения строки на уровне пользователя, такие как &lt;code&gt;next-line&lt;/code&gt; , &lt;code&gt;previous-line&lt;/code&gt; , игнорируют невидимые символы новой строки, если &lt;code&gt;line-move-ignore-invisible&lt;/code&gt; не равен &lt;code&gt;nil&lt;/code&gt; (по умолчанию), т.е. ведут себя так, как будто эти невидимые новые строки не существовали в буфер, но только потому, что они явно запрограммированы на это.</target>
        </trans-unit>
        <trans-unit id="2931150327a52dd944296ebe55052fed18d6a2ee" translate="yes" xml:space="preserve">
          <source>Ordinarily, this function deletes all existing frames not listed in &lt;var&gt;configuration&lt;/var&gt;. But if &lt;var&gt;nodelete&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the unwanted frames are iconified instead.</source>
          <target state="translated">Обычно эта функция удаляет все существующие кадры, не указанные в &lt;var&gt;configuration&lt;/var&gt; . Но если &lt;var&gt;nodelete&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , вместо этого отображаются ненужные кадры.</target>
        </trans-unit>
        <trans-unit id="87302b912cb01c9639fa44884323306db9210741" translate="yes" xml:space="preserve">
          <source>Ordinary Lisp variables can be assigned any value that is a valid Lisp object. However, certain Lisp variables are not defined in Lisp, but in C. Most of these variables are defined in the C code using &lt;code&gt;DEFVAR_LISP&lt;/code&gt;. Like variables defined in Lisp, these can take on any value. However, some variables are defined using &lt;code&gt;DEFVAR_INT&lt;/code&gt; or &lt;code&gt;DEFVAR_BOOL&lt;/code&gt;. See &lt;a href=&quot;writing-emacs-primitives#Defining-Lisp-variables-in-C&quot;&gt;Writing Emacs Primitives&lt;/a&gt;, in particular the description of functions of the type &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt;, for a brief discussion of the C implementation.</source>
          <target state="translated">Обычным переменным Lisp может быть присвоено любое значение, которое является допустимым объектом Lisp. Однако некоторые переменные Lisp определены не в Lisp, а в C. Большинство этих переменных определены в коде C с помощью &lt;code&gt;DEFVAR_LISP&lt;/code&gt; . Подобно переменным, определенным в Лиспе, они могут принимать любое значение. Однако некоторые переменные определяются с помощью &lt;code&gt;DEFVAR_INT&lt;/code&gt; или &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; . См. &lt;a href=&quot;writing-emacs-primitives#Defining-Lisp-variables-in-C&quot;&gt;Написание примитивов Emacs&lt;/a&gt; , в частности описание функций типа &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; , для краткого обсуждения реализации C.</target>
        </trans-unit>
        <trans-unit id="9aa2f051f923703f2af383ff67fd2ab1b21d7049" translate="yes" xml:space="preserve">
          <source>Ordinary characters &amp;ndash; keys with symbols on them.</source>
          <target state="translated">Обычные символы - клавиши с символами на них.</target>
        </trans-unit>
        <trans-unit id="ea6b2ec77fa1c5f39197cbc7ea3990c82fb9841d" translate="yes" xml:space="preserve">
          <source>Ordinary evaluation of a macro call finishes by evaluating the expansion. However, the macro expansion is not necessarily evaluated right away, or at all, because other programs also expand macro calls, and they may or may not evaluate the expansions.</source>
          <target state="translated">Обычная оценка макрозапроса заканчивается оценкой расширения.Однако макрорасширение не обязательно оценивается сразу или вообще,потому что другие программы также расширяют макрозапросы,и они могут оценивать или не оценивать расширения.</target>
        </trans-unit>
        <trans-unit id="08b529b0be834d360e6ea5bc83de04138368fecc" translate="yes" xml:space="preserve">
          <source>Ordinary quitting gives no information about why the program was looping. To get more information, you can set the variable &lt;code&gt;debug-on-quit&lt;/code&gt; to non-&lt;code&gt;nil&lt;/code&gt;. Once you have the debugger running in the middle of the infinite loop, you can proceed from the debugger using the stepping commands. If you step through the entire loop, you may get enough information to solve the problem.</source>
          <target state="translated">Обычный выход не дает информации о том, почему программа зацикливалась. Чтобы получить дополнительную информацию, вы можете установить для переменной &lt;code&gt;debug-on-quit&lt;/code&gt; значение, отличное от &lt;code&gt;nil&lt;/code&gt; . Когда отладчик запущен в середине бесконечного цикла, вы можете продолжить работу с отладчиком, используя пошаговые команды. Если вы пройдете через весь цикл, вы можете получить достаточно информации для решения проблемы.</target>
        </trans-unit>
        <trans-unit id="34d1e835211103e55315f8950b093575e40b4d28" translate="yes" xml:space="preserve">
          <source>Other Character Modifier Bits</source>
          <target state="translated">Другие биты модификаторов символов</target>
        </trans-unit>
        <trans-unit id="33198adc02f29100fbe001bcd24af108bb8d17c8" translate="yes" xml:space="preserve">
          <source>Other Display Specifications</source>
          <target state="translated">Другие характеристики дисплея</target>
        </trans-unit>
        <trans-unit id="e1b5fab73cfe1a3afaa115ab03f0edad57c69f7f" translate="yes" xml:space="preserve">
          <source>Other Features of Argument Lists</source>
          <target state="translated">Другие особенности списков Аргументов</target>
        </trans-unit>
        <trans-unit id="4e097fdc9bb03d4937b671db92b45a0f360cd315" translate="yes" xml:space="preserve">
          <source>Other Font Lock Variables</source>
          <target state="translated">Другие переменные шрифта</target>
        </trans-unit>
        <trans-unit id="46737ad394242fbdb99171fff4fda522659876cd" translate="yes" xml:space="preserve">
          <source>Other Hash Table Functions</source>
          <target state="translated">Другие функции хэш-стола</target>
        </trans-unit>
        <trans-unit id="56044b82f8d646d772974c14d2a91bcbcbcb3ce7" translate="yes" xml:space="preserve">
          <source>Other Image Types</source>
          <target state="translated">Другие типы изображений</target>
        </trans-unit>
        <trans-unit id="edfdae8d79c7493898f253dfe960e84840b69477" translate="yes" xml:space="preserve">
          <source>Other Lisp objects are &lt;em&gt;mutable&lt;/em&gt;: it is safe to change their values via destructive operations involving side effects. For example, an existing marker can be changed by moving the marker to point to somewhere else.</source>
          <target state="translated">Другие объекты Lisp &lt;em&gt;изменчивы&lt;/em&gt; : их значения можно безопасно изменять с помощью деструктивных операций, включающих побочные эффекты. Например, существующий маркер можно изменить, переместив маркер в другое место.</target>
        </trans-unit>
        <trans-unit id="041cab119371080f5c14fa74fa5fa41d2e6a8bf9" translate="yes" xml:space="preserve">
          <source>Other Topics Related to Functions</source>
          <target state="translated">Другие темы,связанные с функциями</target>
        </trans-unit>
        <trans-unit id="6eb08d88c80caa45384446348816e55ba7c955ae" translate="yes" xml:space="preserve">
          <source>Other aspects of tooltip display are controlled by several customizable settings; see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;Tooltips&lt;/a&gt; in</source>
          <target state="translated">Другие аспекты отображения всплывающей подсказки управляются несколькими настраиваемыми параметрами; см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;всплывающие подсказки&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="2807813fd14e72f66d18c3e9088c2eaa37295f37" translate="yes" xml:space="preserve">
          <source>Other aspects of tooltip display are controlled by several customizable settings; see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;Tooltips&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a64c877816cb35a6c766c7fbbe33ffb08e05d25" translate="yes" xml:space="preserve">
          <source>Other definition types:</source>
          <target state="translated">Другие типы определений:</target>
        </trans-unit>
        <trans-unit id="21ad92f8be5dc4e33dd7afb9682a8336e5b8df9f" translate="yes" xml:space="preserve">
          <source>Other events the system can generate.</source>
          <target state="translated">Другие события,которые может генерировать система.</target>
        </trans-unit>
        <trans-unit id="d9542df9ae63b6d508bd2e2ee21aec4ef7962dc9" translate="yes" xml:space="preserve">
          <source>Other frequently used commands are</source>
          <target state="translated">Другие часто используемые команды</target>
        </trans-unit>
        <trans-unit id="db54d46555d1f340a37db3a33c9204c8396d6479" translate="yes" xml:space="preserve">
          <source>Other functions to compare with this one include &lt;code&gt;make-vector&lt;/code&gt; (see &lt;a href=&quot;vectors#Vectors&quot;&gt;Vectors&lt;/a&gt;) and &lt;code&gt;make-list&lt;/code&gt; (see &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Lists&lt;/a&gt;).</source>
          <target state="translated">Другие функции, которые можно сравнить с этой, включают &lt;code&gt;make-vector&lt;/code&gt; (см. &lt;a href=&quot;vectors#Vectors&quot;&gt;Векторы&lt;/a&gt; ) и &lt;code&gt;make-list&lt;/code&gt; (см. &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Списки сборки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="408167f431dbe022874b25fe0cbeecaf0058b490" translate="yes" xml:space="preserve">
          <source>Other functions you can use to create buffers include &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;) and &lt;code&gt;create-file-buffer&lt;/code&gt; (see &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Visiting Files&lt;/a&gt;). Starting a subprocess can also create a buffer (see &lt;a href=&quot;processes#Processes&quot;&gt;Processes&lt;/a&gt;).</source>
          <target state="translated">Другие функции, которые вы можете использовать для создания буферов, включают &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; (см. &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Временные дисплеи&lt;/a&gt; ) и &lt;code&gt;create-file-buffer&lt;/code&gt; (см. &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Посещение файлов&lt;/a&gt; ). Запуск подпроцесса также может создать буфер (см. &lt;a href=&quot;processes#Processes&quot;&gt;Процессы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="12da01fa29e6553cd0e8cb48e03d6be151f33875" translate="yes" xml:space="preserve">
          <source>Other keyboard character events cannot fit in a string. This includes keyboard events in the range of 128 to 255.</source>
          <target state="translated">Другие события символов клавиатуры не могут поместиться в строку.К ним относятся события клавиатуры в диапазоне от 128 до 255.</target>
        </trans-unit>
        <trans-unit id="4ac0b6dbdd8cbd1b63c08a470ab7011f7b3c910a" translate="yes" xml:space="preserve">
          <source>Other primitives to look inside of window configurations would make sense, but are not implemented because we did not need them. See the file</source>
          <target state="translated">Другие примитивы,чтобы заглянуть внутрь оконных конфигураций,имели бы смысл,но не реализованы,потому что они нам не нужны.Смотрите файл</target>
        </trans-unit>
        <trans-unit id="f2e96a7c2811cdfc73c1ef4d1bd1a2c29ec6dda7" translate="yes" xml:space="preserve">
          <source>Other programs can also use custom printing; see</source>
          <target state="translated">Другие программы могут также использовать пользовательскую печать;см.</target>
        </trans-unit>
        <trans-unit id="0656cfe9687d5b1c6eec51fbeb7667af045fb347" translate="yes" xml:space="preserve">
          <source>Other quoting constructs include &lt;code&gt;function&lt;/code&gt; (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), which causes an anonymous lambda expression written in Lisp to be compiled, and &amp;lsquo;</source>
          <target state="translated">Другие конструкции цитирования включают &lt;code&gt;function&lt;/code&gt; (см. &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Анонимные функции&lt;/a&gt; ), которая вызывает компиляцию анонимного лямбда-выражения, написанного на Лиспе, и '</target>
        </trans-unit>
        <trans-unit id="d862e1f98dfca98bea09cf7215fbefad08c4cef4" translate="yes" xml:space="preserve">
          <source>Other times, after careful consideration you may conclude that those conflicts are not serious and simply resolve them via the &lt;var&gt;resolvers&lt;/var&gt; argument of &lt;code&gt;smie-bnf-&amp;gt;prec2&lt;/code&gt;. Usually this is because the grammar is simply ambiguous: the conflict does not affect the set of programs described by the grammar, but only the way those programs are parsed. This is typically the case for separators and associative infix operators, where you want to add a resolver like &lt;code&gt;'((assoc &quot;|&quot;))&lt;/code&gt;. Another case where this can happen is for the classic &lt;em&gt;dangling else&lt;/em&gt; problem, where you will use &lt;code&gt;'((assoc
&quot;else&quot; &quot;then&quot;))&lt;/code&gt;. It can also happen for cases where the conflict is real and cannot really be resolved, but it is unlikely to pose a problem in practice.</source>
          <target state="translated">В других случаях после тщательного рассмотрения вы можете сделать вывод, что эти конфликты несерьезны, и просто разрешить их с помощью аргумента &lt;var&gt;resolvers&lt;/var&gt; в &lt;code&gt;smie-bnf-&amp;gt;prec2&lt;/code&gt; . Обычно это происходит потому, что грамматика просто неоднозначна: конфликт влияет не на набор программ, описываемых грамматикой, а только на способ анализа этих программ. Обычно это имеет место для разделителей и ассоциативных инфиксных операторов, когда вы хотите добавить преобразователь, например &lt;code&gt;'((assoc &quot;|&quot;))&lt;/code&gt; . Другой случай, когда это может произойти, - это классическая проблема с &lt;em&gt;зависанием else&lt;/em&gt; , где вы будете использовать &lt;code&gt;'((assoc &quot;else&quot; &quot;then&quot;))&lt;/code&gt; . Это также может произойти в тех случаях, когда конфликт реален и не может быть действительно разрешен, но вряд ли создаст проблему на практике.</target>
        </trans-unit>
        <trans-unit id="4957b132ab51bc30771f521b4940cb71793014c9" translate="yes" xml:space="preserve">
          <source>Other useful tools for debugging input and output problems are the dribble file (see &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;) and the &lt;code&gt;open-termscript&lt;/code&gt; function (see &lt;a href=&quot;terminal-output#Terminal-Output&quot;&gt;Terminal Output&lt;/a&gt;).</source>
          <target state="translated">Другими полезными инструментами для отладки проблем ввода и вывода являются файл &lt;code&gt;open-termscript&lt;/code&gt; (см. &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Терминальный ввод&lt;/a&gt; ) и функция open-termscript (см. &lt;a href=&quot;terminal-output#Terminal-Output&quot;&gt;Терминальный вывод&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a49240e9e249989689d2ce97e9d81c517eb880e2" translate="yes" xml:space="preserve">
          <source>Other value</source>
          <target state="translated">Другое значение</target>
        </trans-unit>
        <trans-unit id="f3fdcd50495da9607d64876c8b19f3585d001e97" translate="yes" xml:space="preserve">
          <source>Otherwise the function &lt;code&gt;call-process&lt;/code&gt; does no redisplay, and the results become visible on the screen only when Emacs redisplays that buffer in the normal course of events.</source>
          <target state="translated">В противном случае процесс &lt;code&gt;call-process&lt;/code&gt; функции не отображает повторно, и результаты становятся видимыми на экране только тогда, когда Emacs повторно отображает этот буфер в обычном ходе событий.</target>
        </trans-unit>
        <trans-unit id="e5cf2c68d7f5c24121fcd7006c95c362d16d9910" translate="yes" xml:space="preserve">
          <source>Otherwise the value should be an alist that specifies which fringe indicators to display and where. Each element of the alist should have the form &lt;code&gt;(&lt;var&gt;indicator&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;indicator&lt;/var&gt; is one of &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, and &lt;code&gt;t&lt;/code&gt; (which covers all the icons not yet specified), while &lt;var&gt;position&lt;/var&gt; is one of &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В противном случае значение должно быть списком, который указывает, какие индикаторы границ отображать и где. Каждый элемент списка должен иметь форму &lt;code&gt;(&lt;var&gt;indicator&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt; . Здесь &lt;var&gt;indicator&lt;/var&gt; является одним из &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;bottom&lt;/code&gt; , &lt;code&gt;up&lt;/code&gt; , &lt;code&gt;down&lt;/code&gt; , и &lt;code&gt;t&lt;/code&gt; (которая охватывает все значки еще не указал), в то время как &lt;var&gt;position&lt;/var&gt; является одним из &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; и &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd6099948cb8e952f2e06ed3844cf9915b36c22" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;var&gt;window&lt;/var&gt; was previously used for displaying other buffers (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;), the most recent buffer in that history will be displayed. In either case, if &lt;var&gt;window&lt;/var&gt; is not deleted, its &lt;code&gt;quit-restore&lt;/code&gt; parameter is reset to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В противном случае, если &lt;var&gt;window&lt;/var&gt; ранее использовалось для отображения других буферов (см. &lt;a href=&quot;window-history#Window-History&quot;&gt;История окон&lt;/a&gt; ), будет отображаться самый последний буфер в этой истории. В любом случае, если &lt;var&gt;window&lt;/var&gt; не удалено, его параметр &lt;code&gt;quit-restore&lt;/code&gt; сбрасывается до &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b22d99af3628f670cc53b3c236b49d8671be213f" translate="yes" xml:space="preserve">
          <source>Otherwise, if the indentation function in &lt;code&gt;indent-line-function&lt;/code&gt; is &lt;code&gt;indent-to-left-margin&lt;/code&gt; (a trivial command that inserts a tab character), or if the variable &lt;code&gt;tab-always-indent&lt;/code&gt; specifies that a tab character ought to be inserted (see below), then it inserts a tab character.</source>
          <target state="translated">В противном случае, если функция отступа в функции &lt;code&gt;indent-line-function&lt;/code&gt; - &lt;code&gt;indent-to-left-margin&lt;/code&gt; (тривиальная команда, которая вставляет символ табуляции), или если переменная &lt;code&gt;tab-always-indent&lt;/code&gt; указывает, что должен быть вставлен символ табуляции ( см. ниже), затем вставляется символ табуляции.</target>
        </trans-unit>
        <trans-unit id="4a70357a80ea185af667a6cf9db2f85e272ad161" translate="yes" xml:space="preserve">
          <source>Otherwise, it indents the current line; this is done by calling the function in &lt;code&gt;indent-line-function&lt;/code&gt;. If the line is already indented, and the value of &lt;code&gt;tab-always-indent&lt;/code&gt; is &lt;code&gt;complete&lt;/code&gt; (see below), it tries completing the text at point.</source>
          <target state="translated">В противном случае он делает отступ для текущей строки; это делается путем вызова функции в &lt;code&gt;indent-line-function&lt;/code&gt; . Если линия уже отступа, а значение &lt;code&gt;tab-always-indent&lt;/code&gt; является &lt;code&gt;complete&lt;/code&gt; (см ниже), он пытается завершить текст в точке.</target>
        </trans-unit>
        <trans-unit id="f0728e46990b904a5fc71835f81206fdedceb327" translate="yes" xml:space="preserve">
          <source>Otherwise, the base location should be a directory name. In this case, Emacs retrieves packages from this archive via ordinary file access. Such local archives are mainly useful for testing.</source>
          <target state="translated">В противном случае,базовым местоположением должно быть имя каталога.В этом случае Emacs получает пакеты из этого архива через обычный доступ к файлам.Такие локальные архивы в основном полезны для тестирования.</target>
        </trans-unit>
        <trans-unit id="45a47ab7c8110b367a5eb7d10e05ec778824df4d" translate="yes" xml:space="preserve">
          <source>Otherwise, the file modes of &lt;var&gt;newname&lt;/var&gt; are left unchanged if it is an existing file, and set to those of &lt;var&gt;oldname&lt;/var&gt;, masked by the default file permissions (see &lt;code&gt;set-default-file-modes&lt;/code&gt; below), if &lt;var&gt;newname&lt;/var&gt; is to be newly created. The Access Control List or SELinux context are not copied over in either case.</source>
          <target state="translated">В противном случае, режимы файла &lt;var&gt;newname&lt;/var&gt; остаются неизменными, если это существующий файл, и устанавливаются на &lt;var&gt;oldname&lt;/var&gt; , замаскированные разрешениями файла по умолчанию (см. Ниже &lt;code&gt;set-default-file-modes&lt;/code&gt; ), если &lt;var&gt;newname&lt;/var&gt; должно быть создано заново. Список управления доступом или контекст SELinux не копируются ни в одном случае.</target>
        </trans-unit>
        <trans-unit id="81d57dfe0afd7a0985d57a78533c79c5a914182c" translate="yes" xml:space="preserve">
          <source>Otherwise, the symbol should be a predicate. The predicate is called with the argument, and if the predicate returns &lt;code&gt;nil&lt;/code&gt;, the specification fails and the argument is not instrumented.</source>
          <target state="translated">В противном случае символ должен быть предикатом. Предикат вызывается с аргументом, и если предикат возвращает &lt;code&gt;nil&lt;/code&gt; , спецификация не выполняется и аргумент не инструментирован.</target>
        </trans-unit>
        <trans-unit id="763f06232ee2847cc0f578d2a2ffd866f636432a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value must be a list of regular expressions. Then a scalable font is enabled for use if its name matches any regular expression in the list. For example,</source>
          <target state="translated">В противном случае значение должно быть списком регулярных выражений.Тогда включается масштабируемый шрифт,если его имя совпадает с любым регулярным выражением в списке.Например,</target>
        </trans-unit>
        <trans-unit id="c8f0909271c68b7b8449d51302ffcf15bff72083" translate="yes" xml:space="preserve">
          <source>Otherwise, the value should be a function which returns a list of the above form when called with no arguments.</source>
          <target state="translated">В противном случае,значение должно быть функцией,которая возвращает список вышеуказанной формы при вызове без аргументов.</target>
        </trans-unit>
        <trans-unit id="14d051441dd1704941ec3ffbfe4f559120510bb1" translate="yes" xml:space="preserve">
          <source>Otherwise, this returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В противном случае возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="575a546ff3b142ba0fac4a6250e6ac440f035d5e" translate="yes" xml:space="preserve">
          <source>Our simple sample function, &lt;code&gt;(lambda (a b c) (+ a b c))&lt;/code&gt;, specifies three argument variables, so it must be called with three arguments: if you try to call it with only two arguments or four arguments, you get a &lt;code&gt;wrong-number-of-arguments&lt;/code&gt; error (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;).</source>
          <target state="translated">Наша простая примерная функция &lt;code&gt;(lambda (a b c) (+ a b c))&lt;/code&gt; задает три переменных аргумента, поэтому ее необходимо вызывать с тремя аргументами: если вы попытаетесь вызвать ее только с двумя аргументами или четырьмя аргументами, вы получите &lt;code&gt;wrong-number-of-arguments&lt;/code&gt; error (см. &lt;a href=&quot;errors#Errors&quot;&gt;Ошибки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a9852d0d719ff08733d222f566af473ea8319ac5" translate="yes" xml:space="preserve">
          <source>Outer Border</source>
          <target state="translated">Внешняя граница</target>
        </trans-unit>
        <trans-unit id="d03df9879e63c94d1ef1ef625db82f7c6086fd99" translate="yes" xml:space="preserve">
          <source>Outer Frame</source>
          <target state="translated">Внешняя рамка</target>
        </trans-unit>
        <trans-unit id="d25d9ab5e677c4a9d400b4025bd92a3b5bab6708" translate="yes" xml:space="preserve">
          <source>Outer borders are never shown on text terminal frames and on frames generated by GTK+ routines. On MS-Windows, the outer border is emulated with the help of a one pixel wide external border. Non-toolkit builds on X allow to change the color of the outer border by setting the &lt;code&gt;border-color&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;).</source>
          <target state="translated">Внешние границы никогда не отображаются на фреймах текстовых терминалов и фреймах, созданных процедурами GTK +. В MS-Windows внешняя граница эмулируется с помощью внешней границы шириной в один пиксель. Не-инструментальные сборки на X позволяют изменять цвет внешней границы, устанавливая параметр рамки &lt;code&gt;border-color&lt;/code&gt; (см. &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Параметры макета&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b23b7fca5f6573328ef2d805a7e0260cd5710efd" translate="yes" xml:space="preserve">
          <source>Output Functions</source>
          <target state="translated">Выходные функции</target>
        </trans-unit>
        <trans-unit id="9a91268a8670899c3fa6018e379c6499b8b7af3e" translate="yes" xml:space="preserve">
          <source>Output Streams</source>
          <target state="translated">Выходные потоки</target>
        </trans-unit>
        <trans-unit id="c32e9bc6a6bca97190de9cf86b1d5bfe5eb2f34a" translate="yes" xml:space="preserve">
          <source>Output from a subprocess can arrive only while Emacs is waiting: when reading terminal input (see the function &lt;code&gt;waiting-for-user-input-p&lt;/code&gt;), in &lt;code&gt;sit-for&lt;/code&gt; and &lt;code&gt;sleep-for&lt;/code&gt; (see &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;), in &lt;code&gt;accept-process-output&lt;/code&gt; (see &lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;Accepting Output&lt;/a&gt;), and in functions which send data to processes (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;). This minimizes the problem of timing errors that usually plague parallel programming. For example, you can safely create a process and only then specify its buffer or filter function; no output can arrive before you finish, if the code in between does not call any primitive that waits.</source>
          <target state="translated">Выход из подпроцесса может прийти только тогда , когда Emacs ожидает: при чтении терминала ввода (см функции &lt;code&gt;waiting-for-user-input-p&lt;/code&gt; ), в &lt;code&gt;sit-for&lt;/code&gt; и &lt;code&gt;sleep-for&lt;/code&gt; (см &lt;a href=&quot;waiting#Waiting&quot;&gt;Ожидания&lt;/a&gt; ), в &lt;code&gt;accept-process-output&lt;/code&gt; (см. &lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;Принятие вывода&lt;/a&gt; ) и в функциях, которые отправляют данные в процессы (см. &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Ввод для процессов&lt;/a&gt; ). Это сводит к минимуму проблему временных ошибок, которые обычно мешают параллельному программированию. Например, вы можете безопасно создать процесс и только затем указать его функцию буфера или фильтра; никакие выходные данные не могут поступить до того, как вы закончите, если код между ними не вызывает никаких ожидающих примитивов.</target>
        </trans-unit>
        <trans-unit id="21c758cdd849bd8a6c5c89059360afc09cd26de1" translate="yes" xml:space="preserve">
          <source>Output from asynchronous subprocesses normally arrives only while Emacs is waiting for some sort of external event, such as elapsed time or terminal input. Occasionally it is useful in a Lisp program to explicitly permit output to arrive at a specific point, or even to wait until output arrives from a process.</source>
          <target state="translated">Выходные данные из асинхронных подпроцессов обычно поступают только в то время,когда Emacs ждет какого-то внешнего события,например,прошедшего времени или терминального входа.Иногда в программе на языке Lisp полезно явно разрешить выводить данные в определенный момент или даже подождать,пока они не поступят из процесса.</target>
        </trans-unit>
        <trans-unit id="0b9ca3340cc6c5af5f85b890299ce5ced2b68445" translate="yes" xml:space="preserve">
          <source>Output of messages into the</source>
          <target state="translated">Вывод сообщений в</target>
        </trans-unit>
        <trans-unit id="8c784b59ac07f59605bca80bc6385a0c8abe5d2b" translate="yes" xml:space="preserve">
          <source>Output trace information on function calls and returns.</source>
          <target state="translated">Вывод информации о трассировке вызовов и возвратов функций.</target>
        </trans-unit>
        <trans-unit id="e4053b393b6a34936a44a25f539116ecb913583a" translate="yes" xml:space="preserve">
          <source>Outside Emacs, characters can be represented in many different encodings, such as ISO-8859-1, GB-2312, Big-5, etc. Emacs converts between these external encodings and its internal representation, as appropriate, when it reads text into a buffer or a string, or when it writes text to a disk file or passes it to some other process.</source>
          <target state="translated">За пределами Emacs символы могут быть представлены в различных кодировках,таких как ISO-8859-1,GB-2312,Big-5 и др.Emacs преобразует между этими внешними кодировками и их внутренним представлением,когда читает текст в буфер или строку,или когда он записывает текст в дисковый файл или передаёт его какому-то другому процессу.</target>
        </trans-unit>
        <trans-unit id="c0a2a08afab0fbd40ca04201e1206a333c99a403" translate="yes" xml:space="preserve">
          <source>Outside of Emacs, on systems with job control, the stop character (usually</source>
          <target state="translated">Вне Emacs,на системах с управлением заданиями,стоп-символ (обычно</target>
        </trans-unit>
        <trans-unit id="b22b6e787ba475871fd62e316803a0a0753ded2f" translate="yes" xml:space="preserve">
          <source>Over void parts of the window (parts that do not correspond to any of the buffer contents), the mouse pointer usually uses the &lt;code&gt;arrow&lt;/code&gt; style, but you can specify a different style (one of those above) by setting &lt;code&gt;void-text-area-pointer&lt;/code&gt;.</source>
          <target state="translated">Над пустыми частями окна (частями, которые не соответствуют какому-либо содержимому буфера) указатель мыши обычно использует стиль &lt;code&gt;arrow&lt;/code&gt; , но вы можете указать другой стиль (один из указанных выше), установив &lt;code&gt;void-text-area-pointer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fea430e693a45386a3c9636b829f4fd78379194" translate="yes" xml:space="preserve">
          <source>Overall, the key-value pairs passed to &lt;var&gt;function&lt;/var&gt; describe all the values stored in &lt;var&gt;char-table&lt;/var&gt;.</source>
          <target state="translated">В целом пары ключ-значение, переданные в &lt;var&gt;function&lt;/var&gt; описывают все значения, хранящиеся в &lt;var&gt;char-table&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c67eb8bae9c49b877d15564d28cb90029ac13ef6" translate="yes" xml:space="preserve">
          <source>Overlay Properties</source>
          <target state="translated">Свойства наложения</target>
        </trans-unit>
        <trans-unit id="7e2d14eedf83ae2cc686557be0c0dade27cbfcb8" translate="yes" xml:space="preserve">
          <source>Overlay Type</source>
          <target state="translated">Тип наложения</target>
        </trans-unit>
        <trans-unit id="4e8e813f097ac9fdf229d20b7105e0cc57cfc922" translate="yes" xml:space="preserve">
          <source>Overlay properties are like text properties in that the properties that alter how a character is displayed can come from either source. But in most respects they are different. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;, for comparison.</source>
          <target state="translated">Свойства наложения похожи на свойства текста в том смысле, что свойства, которые изменяют способ отображения символа, могут поступать из любого источника. Но во многом они разные. См. Для сравнения &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Свойства текста&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30f888d222b77006610001ff65a62036e76c8b9f" translate="yes" xml:space="preserve">
          <source>Overlays</source>
          <target state="translated">Overlays</target>
        </trans-unit>
        <trans-unit id="7436ded961ede3d7e72f8b002fd2f760f034b992" translate="yes" xml:space="preserve">
          <source>Overlays also support the &lt;code&gt;modification-hooks&lt;/code&gt; property, but the details are somewhat different (see &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;).</source>
          <target state="translated">Оверлеи также поддерживают свойство &lt;code&gt;modification-hooks&lt;/code&gt; , но детали несколько отличаются (см. &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Свойства наложения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="38346ff2dbbd0c10b491d604ab1d0f5bf067809c" translate="yes" xml:space="preserve">
          <source>Overriding syntax with text properties.</source>
          <target state="translated">Переопределяющий синтаксис со свойствами текста.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3b314bcbaf594e58e02b7f1ac94d0a07d164ad50" translate="yes" xml:space="preserve">
          <source>Overview of Markers</source>
          <target state="translated">Обзор маркеров</target>
        </trans-unit>
        <trans-unit id="e5dff67285e4f2b89cea9a5461f21bbf12d615e1" translate="yes" xml:space="preserve">
          <source>Overview of customizing Font Lock.</source>
          <target state="translated">Обзор настройки шрифтовой блокировки.</target>
        </trans-unit>
        <trans-unit id="48001e2fa21457daa7eb4268da77364c19623e16" translate="yes" xml:space="preserve">
          <source>Overview of mouse events.</source>
          <target state="translated">Обзор событий с помощью мыши.</target>
        </trans-unit>
        <trans-unit id="f42cdff5bec245ffb3bc5a0b0105f795984699c8" translate="yes" xml:space="preserve">
          <source>Overview of streams, reading and printing.</source>
          <target state="translated">Обзор потоков,чтение и печать.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="d613d88cb2d86f484f6f82d44ac1fc60722abe20" translate="yes" xml:space="preserve">
          <source>PDF</source>
          <target state="translated">PDF</target>
        </trans-unit>
        <trans-unit id="1d7fd5d567d57918b31b5a2025c0ead430339e0b" translate="yes" xml:space="preserve">
          <source>PF1</source>
          <target state="translated">PF1</target>
        </trans-unit>
        <trans-unit id="dde57e820d65c87a0777da46aba7cd35a0c8436a" translate="yes" xml:space="preserve">
          <source>PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="0c95dc6163ff0d09e82f44e7c50db7ad6b089bf3" translate="yes" xml:space="preserve">
          <source>PM</source>
          <target state="translated">PM</target>
        </trans-unit>
        <trans-unit id="70fe60b7dfe0837f2c69677bfef128c134937b16" translate="yes" xml:space="preserve">
          <source>PNG</source>
          <target state="translated">PNG</target>
        </trans-unit>
        <trans-unit id="74235b074241ce94a5e09f007b23a0ca401ea696" translate="yes" xml:space="preserve">
          <source>POSIX Regular Expression Searching</source>
          <target state="translated">Поиск с регулярными экспрессиями POSIX</target>
        </trans-unit>
        <trans-unit id="871ee878f58ebcf07fad71fd2bcebbda6088639b" translate="yes" xml:space="preserve">
          <source>POSIX specifies several environment variables that can affect how Emacs behaves. Any environment variable whose name consists entirely of uppercase ASCII letters, digits, and the underscore may affect the internal behavior of Emacs. Emacs uses several such variables, e.g., &lt;code&gt;EMACSLOADPATH&lt;/code&gt;. See &lt;a href=&quot;library-search#Library-Search&quot;&gt;Library Search&lt;/a&gt;. On some platforms some environment variables (e.g., &lt;code&gt;PATH&lt;/code&gt;, &lt;code&gt;POSIXLY_CORRECT&lt;/code&gt;, &lt;code&gt;SHELL&lt;/code&gt;, &lt;code&gt;TMPDIR&lt;/code&gt;) need to have properly-configured values in order to get standard behavior for any utility Emacs might invoke. Even seemingly-benign variables like &lt;code&gt;TZ&lt;/code&gt; may have security implications. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;.</source>
          <target state="translated">POSIX определяет несколько переменных среды, которые могут влиять на поведение Emacs. Любая переменная среды, имя которой полностью состоит из прописных букв ASCII, цифр и символа подчеркивания, может повлиять на внутреннее поведение Emacs. Emacs использует несколько таких переменных, например, &lt;code&gt;EMACSLOADPATH&lt;/code&gt; . См. &lt;a href=&quot;library-search#Library-Search&quot;&gt;Поиск в библиотеке&lt;/a&gt; . На некоторых платформах некоторые переменные среды (например, &lt;code&gt;PATH&lt;/code&gt; , &lt;code&gt;POSIXLY_CORRECT&lt;/code&gt; , &lt;code&gt;SHELL&lt;/code&gt; , &lt;code&gt;TMPDIR&lt;/code&gt; ) должны иметь правильно сконфигурированные значения, чтобы получить стандартное поведение для любой утилиты, которую может вызывать Emacs. Даже такие, казалось бы, безобидные переменные, как &lt;code&gt;TZ&lt;/code&gt; , могут иметь последствия для безопасности. См. &lt;a href=&quot;system-environment#System-Environment&quot;&gt;Системное окружение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31021705d55f66068349f6ead54a6f4f1f1f4e1c" translate="yes" xml:space="preserve">
          <source>Package-Requires</source>
          <target state="translated">Package-Requires</target>
        </trans-unit>
        <trans-unit id="400112f99c45dae97ae81ee287e883c5967448d7" translate="yes" xml:space="preserve">
          <source>Package-Version</source>
          <target state="translated">Package-Version</target>
        </trans-unit>
        <trans-unit id="c26ef24c1e9c01425e91a34b0caa85ab70d66bf6" translate="yes" xml:space="preserve">
          <source>Packages distributed as part of Emacs that use the &lt;code&gt;:package-version&lt;/code&gt; keyword must also update the &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; variable.</source>
          <target state="translated">Пакеты, распространяемые как часть Emacs, которые используют ключевое слово &lt;code&gt;:package-version&lt;/code&gt; , также должны обновлять переменную &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="42f9009cd9572c10d5a27ab040ba2ba3d71640ce" translate="yes" xml:space="preserve">
          <source>Packaging Basics</source>
          <target state="translated">Основы упаковки</target>
        </trans-unit>
        <trans-unit id="e0fb56429e1a2ef765c166a971fbafb2df17fb78" translate="yes" xml:space="preserve">
          <source>Packing and Unpacking Byte Arrays</source>
          <target state="translated">Упаковка и распаковка байтовых массивов</target>
        </trans-unit>
        <trans-unit id="7cba3e212dcc3d05c7ed8450a9553450544ee41d" translate="yes" xml:space="preserve">
          <source>PageDown</source>
          <target state="translated">PageDown</target>
        </trans-unit>
        <trans-unit id="2e2bbfe16d99367325be3ba50291408aefa81595" translate="yes" xml:space="preserve">
          <source>Paired delimiters: &amp;lsquo;</source>
          <target state="translated">Парные разделители: '</target>
        </trans-unit>
        <trans-unit id="d4c7c2e3ad59ecdbc81f52c2333acc0ab45fc3f5" translate="yes" xml:space="preserve">
          <source>Pairs of characters are compared according to their character codes. Keep in mind that lower case letters have higher numeric values in the</source>
          <target state="translated">Пары символов сравниваются в соответствии с их символьными кодами.Имейте в виду,что строчные буквы имеют более высокие числовые значения в</target>
        </trans-unit>
        <trans-unit id="2836a2cd0203ab3c4a413cfd2f0b910b3a2b2fef" translate="yes" xml:space="preserve">
          <source>Parameters common for all frames on terminal.</source>
          <target state="translated">Общие для всех кадров на терминале параметры.</target>
        </trans-unit>
        <trans-unit id="82045ada54eb55bca7be07c13568a28bcd4565bf" translate="yes" xml:space="preserve">
          <source>Parameters describing the X- and Y-offsets of a frame are always measured in pixels. For a normal, non-child frame they specify the frame&amp;rsquo;s outer position (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) relative to its display&amp;rsquo;s origin. For a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) they specify the frame&amp;rsquo;s outer position relative to the native position of the frame&amp;rsquo;s parent frame. (Note that none of these parameters is meaningful on TTY frames.)</source>
          <target state="translated">Параметры, описывающие смещение по оси X и Y кадра, всегда измеряются в пикселях. Для обычного, не дочернего фрейма они определяют внешнее положение &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;фрейма&lt;/a&gt; (см. Геометрия фрейма ) относительно его исходной точки отображения. Для дочернего фрейма (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ) они определяют внешнее положение фрейма относительно исходного положения родительского фрейма. (Обратите внимание, что ни один из этих параметров не имеет значения для кадров TTY.)</target>
        </trans-unit>
        <trans-unit id="6fe4da0442db9ec376fd1ebd0885e7871dd6c06a" translate="yes" xml:space="preserve">
          <source>Parameters for interacting with other frames.</source>
          <target state="translated">Параметры для взаимодействия с другими кадрами.</target>
        </trans-unit>
        <trans-unit id="187e29395efb81d6e368498d4c21b83faa4f6bac" translate="yes" xml:space="preserve">
          <source>Parameters for resizing and moving frames with the mouse.</source>
          <target state="translated">Параметры изменения размера и перемещения кадров с помощью мыши.</target>
        </trans-unit>
        <trans-unit id="3304283cc7ef5bd20c4b8b92ab9f7d659a1d933a" translate="yes" xml:space="preserve">
          <source>Parameters that affect parsing.</source>
          <target state="translated">Параметры,которые влияют на парсинг.</target>
        </trans-unit>
        <trans-unit id="662b563f3e8a80a489f1f7aa600b993494c4ca80" translate="yes" xml:space="preserve">
          <source>Parameters that are fundamental.</source>
          <target state="translated">Параметры,которые являются фундаментальными.</target>
        </trans-unit>
        <trans-unit id="71dcb10469ca71f255f80878d6bb08653414646f" translate="yes" xml:space="preserve">
          <source>Parameters to Control Parsing</source>
          <target state="translated">Параметры управления парсингом</target>
        </trans-unit>
        <trans-unit id="3a77d88b486083a5b1a286e032cc2eaf602cab89" translate="yes" xml:space="preserve">
          <source>Parent mode for buffers containing tabulated data.</source>
          <target state="translated">Родительский режим для буферов,содержащих табличные данные.</target>
        </trans-unit>
        <trans-unit id="00e169811424fee10d949efd728dc5985c0c3f1b" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">Родительский тип: &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc475e11afc91bfdb5091ef734af47c9e9ec4c73" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">Родительский тип: &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f98d45fa291377ce2d003ec40640eeb0e4c79445" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Родительский тип: &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="defc0b42f93cf65435dd3de8a8247bacb70982ad" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;sequence&lt;/code&gt;.</source>
          <target state="translated">Родительский тип: &lt;code&gt;sequence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b04c0c36b344236da631ede7b83372f26428b9" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;symbol&lt;/code&gt;</source>
          <target state="translated">Родительский тип: &lt;code&gt;symbol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a33d7f2f11c1fed9edd1a0648e4921a4b929017" translate="yes" xml:space="preserve">
          <source>Parent windows do not display buffers, and play little role in display except to shape their child windows. Emacs Lisp programs cannot directly manipulate parent windows; they operate on the windows at the leaves of the tree, which actually display buffers.</source>
          <target state="translated">Родительские окна не отображают буферы,и играют небольшую роль в отображении,кроме как в форме своих дочерних окон.Программы Emacs Lisp не могут напрямую манипулировать родительскими окнами;они работают с окнами на листьях дерева,которые на самом деле отображают буферы.</target>
        </trans-unit>
        <trans-unit id="a9a6581c08789385ed2a0f325a688a832347f188" translate="yes" xml:space="preserve">
          <source>Parser State</source>
          <target state="translated">Государство Парсер</target>
        </trans-unit>
        <trans-unit id="4526a4b5852177789cf8e9bfecfe9da2131c54cb" translate="yes" xml:space="preserve">
          <source>Parsing Expressions</source>
          <target state="translated">Размышления о выражениях</target>
        </trans-unit>
        <trans-unit id="e231765095ab882fb7fcf938cb7f6e8c8c4b17f6" translate="yes" xml:space="preserve">
          <source>Parsing HTML and XML</source>
          <target state="translated">Разбор HTML и XML</target>
        </trans-unit>
        <trans-unit id="fe6bf59025bd0e2925b6d89834e3acc681649e86" translate="yes" xml:space="preserve">
          <source>Parsing HTML and XML.</source>
          <target state="translated">Разбор HTML и XML.</target>
        </trans-unit>
        <trans-unit id="08eb2ab878002b2ff0551a7f614ba8a4ce7a1b19" translate="yes" xml:space="preserve">
          <source>Parsing across a specified region.</source>
          <target state="translated">Парсинг в определенном регионе.</target>
        </trans-unit>
        <trans-unit id="f40cea5e85407269571363df9bd9391ce3f4ad7b" translate="yes" xml:space="preserve">
          <source>Parsing and Formatting Times</source>
          <target state="translated">Время разбора и форматирования</target>
        </trans-unit>
        <trans-unit id="ac97cfccea0017cf98319b0ca0948a055efe585f" translate="yes" xml:space="preserve">
          <source>Parsing and generating JSON values</source>
          <target state="translated">Разбор и генерация значений JSON</target>
        </trans-unit>
        <trans-unit id="d9c9a717935cc6b02f547040191d6f2545e876ed" translate="yes" xml:space="preserve">
          <source>Parsing and generating JSON values.</source>
          <target state="translated">Разбор и генерация значений JSON.</target>
        </trans-unit>
        <trans-unit id="5217da08a22ae64804bc400d2407ec040403c3c7" translate="yes" xml:space="preserve">
          <source>Parsing balanced expressions using the syntax table.</source>
          <target state="translated">Разбор сбалансированных выражений с помощью таблицы синтаксиса.</target>
        </trans-unit>
        <trans-unit id="cfd676e977daa56fd9d54f7c8b9c4143d00aec36" translate="yes" xml:space="preserve">
          <source>Parsing geometry specifications.</source>
          <target state="translated">Разбор спецификаций геометрии.</target>
        </trans-unit>
        <trans-unit id="094f3d7cfff68518244aec1c04b390842b32aced" translate="yes" xml:space="preserve">
          <source>Particular properties with special meanings.</source>
          <target state="translated">Особые свойства с особыми значениями.</target>
        </trans-unit>
        <trans-unit id="7bdf4b7194fa08f8c2706fdc986660b700d98bb5" translate="yes" xml:space="preserve">
          <source>Parts of words in human languages. These are typically used in variable and command names in programs. All upper- and lower-case letters, and the digits, are typically word constituents.</source>
          <target state="translated">Части слов в человеческих языках.Они обычно используются в именах переменных и команд в программах.Все заглавные и строчные буквы,а также цифры,как правило,являются составными частями слов.</target>
        </trans-unit>
        <trans-unit id="3fe618d6f369040b19cdcd8393043d5b040f5577" translate="yes" xml:space="preserve">
          <source>Pattern-Matching Conditional</source>
          <target state="translated">Условие соответствия образца</target>
        </trans-unit>
        <trans-unit id="4849c1facbc8d17ea4d09ce55cc45604ad2f39f1" translate="yes" xml:space="preserve">
          <source>Pcase patterns not only express a condition on the form of the objects they can match, but they can also extract sub-fields of those objects. For example we can extract 2 elements from a list that is the value of the variable &lt;code&gt;my-list&lt;/code&gt; with the following code:</source>
          <target state="translated">Шаблоны Pcase не только выражают условие формы объектов, которые они могут сопоставить, но также могут извлекать подполя этих объектов. Например, мы можем извлечь 2 элемента из списка, который является значением переменной &lt;code&gt;my-list&lt;/code&gt; , с помощью следующего кода:</target>
        </trans-unit>
        <trans-unit id="f88d30015d65ab6f358329e5144fe34af976d4ca" translate="yes" xml:space="preserve">
          <source>People are sometimes tempted to create a variable whose value is a face name. In the vast majority of cases, this is not necessary; the usual procedure is to define a face with &lt;code&gt;defface&lt;/code&gt;, and then use its name directly.</source>
          <target state="translated">Иногда возникает соблазн создать переменную, значением которой является имя лица. В подавляющем большинстве случаев в этом нет необходимости; обычная процедура - определить лицо с помощью &lt;code&gt;defface&lt;/code&gt; , а затем напрямую использовать его имя.</target>
        </trans-unit>
        <trans-unit id="16d67645704093cc2992f9742e395e378a4a7842" translate="yes" xml:space="preserve">
          <source>People do not write byte-code; that job is left to the byte compiler. But we provide a disassembler to satisfy a cat-like curiosity. The disassembler converts the byte-compiled code into human-readable form.</source>
          <target state="translated">Люди не пишут байт-код,эта работа оставлена компилятору байтов.Но мы предоставляем дизассемблер для удовлетворения кошачьего любопытства.Дизассемблер преобразует байт-компилируемый код в читаемый человеком вид.</target>
        </trans-unit>
        <trans-unit id="d246b3473da94f1b94146151c91359171732e430" translate="yes" xml:space="preserve">
          <source>People often use &lt;code&gt;global-set-key&lt;/code&gt; in their init files (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) for simple customization. For example,</source>
          <target state="translated">Люди часто используют &lt;code&gt;global-set-key&lt;/code&gt; в своих файлах инициализации (см. &lt;a href=&quot;init-file#Init-File&quot;&gt;Файл&lt;/a&gt; инициализации ) для простой настройки. Например,</target>
        </trans-unit>
        <trans-unit id="26e74f2999a60551463cceee8a64dda32c66da77" translate="yes" xml:space="preserve">
          <source>Perform &lt;var&gt;action&lt;/var&gt; if the user clicks on a button.</source>
          <target state="translated">Выполнять &lt;var&gt;action&lt;/var&gt; если пользователь нажимает кнопку.</target>
        </trans-unit>
        <trans-unit id="6aa0734a37f43c716d45db437864376f51cf5a6d" translate="yes" xml:space="preserve">
          <source>Perform a quit right away. Only &lt;code&gt;y-or-n-p&lt;/code&gt; and related functions use this answer.</source>
          <target state="translated">Немедленно бросьте курить. Этот ответ используют только &lt;code&gt;y-or-n-p&lt;/code&gt; и связанные с ним функции.</target>
        </trans-unit>
        <trans-unit id="69869cd815dc383536f8d4d158ed0475269499de" translate="yes" xml:space="preserve">
          <source>Perform destructuring binding of variables according to &lt;var&gt;bindings&lt;/var&gt;, and then evaluate &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">Выполните деструктуризацию привязки переменных в соответствии с &lt;var&gt;bindings&lt;/var&gt; , а затем оцените &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c54c145e4d62a63d0c1782ba7e752fadb7b82eec" translate="yes" xml:space="preserve">
          <source>Perform the action specified by a button at location &lt;var&gt;pos&lt;/var&gt;. &lt;var&gt;pos&lt;/var&gt; may be either a buffer position or a mouse-event. If &lt;var&gt;use-mouse-action&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, or &lt;var&gt;pos&lt;/var&gt; is a mouse-event (see &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;), try to invoke the button&amp;rsquo;s &lt;code&gt;mouse-action&lt;/code&gt; property instead of &lt;code&gt;action&lt;/code&gt;; if the button has no &lt;code&gt;mouse-action&lt;/code&gt; property, use &lt;code&gt;action&lt;/code&gt; as normal. &lt;var&gt;pos&lt;/var&gt; defaults to point, except when &lt;code&gt;push-button&lt;/code&gt; is invoked interactively as the result of a mouse-event, in which case, the mouse event&amp;rsquo;s position is used. If there&amp;rsquo;s no button at &lt;var&gt;pos&lt;/var&gt;, do nothing and return &lt;code&gt;nil&lt;/code&gt;, otherwise return &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Выполните действие, указанное кнопкой в ​​позиции &lt;var&gt;pos&lt;/var&gt; . &lt;var&gt;pos&lt;/var&gt; может быть либо положением в буфере, либо событием мыши. Если &lt;var&gt;use-mouse-action&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; или &lt;var&gt;pos&lt;/var&gt; является событием мыши (см. &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;События мыши&lt;/a&gt; ), попробуйте вызвать свойство кнопки &lt;code&gt;mouse-action&lt;/code&gt; вместо &lt;code&gt;action&lt;/code&gt; ; если кнопка не имеет свойства &lt;code&gt;mouse-action&lt;/code&gt; , используйте &lt;code&gt;action&lt;/code&gt; как обычно. &lt;var&gt;pos&lt;/var&gt; умолчанию pos используется как точка, за исключением случаев, когда &lt;code&gt;push-button&lt;/code&gt; вызывается интерактивно в результате события мыши, и в этом случае используется позиция события мыши. Если на &lt;var&gt;pos&lt;/var&gt; нет кнопки, ничего не делать и вернуть &lt;code&gt;nil&lt;/code&gt; , иначе вернуть &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f225f76cbcb682ebabbd6df30985ed39beadca0" translate="yes" xml:space="preserve">
          <source>Perform the specified window scroll operation, then ask the same question again. Only &lt;code&gt;y-or-n-p&lt;/code&gt; and related functions use this answer.</source>
          <target state="translated">Выполните указанную операцию прокрутки окна, затем снова задайте тот же вопрос. Этот ответ используют только &lt;code&gt;y-or-n-p&lt;/code&gt; и связанные с ним функции.</target>
        </trans-unit>
        <trans-unit id="67a71f8eb164bf8cbebbd57b3abbfb3d805ffe84" translate="yes" xml:space="preserve">
          <source>Performance of Byte-Compiled Code</source>
          <target state="translated">Производительность Байт-компилированного кода</target>
        </trans-unit>
        <trans-unit id="6547e00c11db8db176592a59424033b3f90c9a4b" translate="yes" xml:space="preserve">
          <source>Piecemeal Specification</source>
          <target state="translated">Поэтапная спецификация</target>
        </trans-unit>
        <trans-unit id="8a2c6ee815e7a7247ddacfd3b50b4d7a7829a89f" translate="yes" xml:space="preserve">
          <source>Pixel Specification for Spaces</source>
          <target state="translated">Спецификация пикселей для пространств</target>
        </trans-unit>
        <trans-unit id="e342bbd9ca43541fd7f27aae1acd3394adc60779" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;font-lock-multiline&lt;/code&gt; property on the construct. This will rehighlight the whole construct if any part of it is changed. In some cases you can do this automatically by setting the &lt;code&gt;font-lock-multiline&lt;/code&gt; variable, which see.</source>
          <target state="translated">Поместите свойство &lt;code&gt;font-lock-multiline&lt;/code&gt; в конструкцию. Это повторно выделит всю конструкцию, если какая-либо ее часть будет изменена. В некоторых случаях вы можете сделать это автоматически, установив переменную &lt;code&gt;font-lock-multiline&lt;/code&gt; , см.</target>
        </trans-unit>
        <trans-unit id="c235c05182119ad368fe267076dee6d0dd6a6b9c" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;jit-lock-defer-multiline&lt;/code&gt; property on the construct. This works only if &lt;code&gt;jit-lock-contextually&lt;/code&gt; is used, and with the same delay before rehighlighting, but like &lt;code&gt;font-lock-multiline&lt;/code&gt;, it also handles the case where highlighting depends on subsequent lines.</source>
          <target state="translated">Поместите в конструкцию &lt;code&gt;jit-lock-defer-multiline&lt;/code&gt; . Это работает, только если используется &lt;code&gt;jit-lock-contextually&lt;/code&gt; и с той же задержкой перед повторным выделением, но, как и &lt;code&gt;font-lock-multiline&lt;/code&gt; , он также обрабатывает случай, когда выделение зависит от последующих строк.</target>
        </trans-unit>
        <trans-unit id="0892bc999ffda43cddb1e182b36617e30f0fe235" translate="yes" xml:space="preserve">
          <source>Playing sounds on the computer&amp;rsquo;s speaker.</source>
          <target state="translated">Воспроизведение звуков через динамик компьютера.</target>
        </trans-unit>
        <trans-unit id="061394dac9aea5d18455df9eaa1d0cd858c9f0b8" translate="yes" xml:space="preserve">
          <source>Please answer y or n.</source>
          <target state="translated">Пожалуйста,ответьте вам или нет.</target>
        </trans-unit>
        <trans-unit id="6a490ec11b9140306205d30629596595e9b6e94f" translate="yes" xml:space="preserve">
          <source>Please answer yes or no.</source>
          <target state="translated">Пожалуйста,ответьте &quot;да&quot; или &quot;нет&quot;.</target>
        </trans-unit>
        <trans-unit id="71ece59413670b96fc75ee700d7e27c649f7e924" translate="yes" xml:space="preserve">
          <source>Please send comments and corrections using</source>
          <target state="translated">Пожалуйста,присылайте комментарии и исправления,используя</target>
        </trans-unit>
        <trans-unit id="f79a28423ed1ae0232efb54ad41227d0955084f3" translate="yes" xml:space="preserve">
          <source>Point</source>
          <target state="translated">Point</target>
        </trans-unit>
        <trans-unit id="f5cc952a1d9de36117c7758546bd79fa0d592285" translate="yes" xml:space="preserve">
          <source>Point (2) implies that a &lt;code&gt;:weight black&lt;/code&gt; attribute will be satisfied by any display that can display bold, as will &lt;code&gt;:foreground &quot;yellow&quot;&lt;/code&gt; as long as some yellowish color can be displayed, but &lt;code&gt;:slant italic&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be satisfied by the tty display code&amp;rsquo;s automatic substitution of a dim face for italic.</source>
          <target state="translated">Точка (2) следует , что &lt;code&gt;:weight black&lt;/code&gt; атрибут будет удовлетворен любым дисплеем , который может отображать жирный шрифт, как будет &lt;code&gt;:foreground &quot;yellow&quot;&lt;/code&gt; до тех пор , как некоторые желтоватый цвет может отображаться, но &lt;code&gt;:slant italic&lt;/code&gt; будет &lt;em&gt;не&lt;/em&gt; быть удовлетворены TTY автоматическая замена тусклого начертания курсивом в коде отображения.</target>
        </trans-unit>
        <trans-unit id="396cf0edbfa0128fdb159e61630df3d416f1062f" translate="yes" xml:space="preserve">
          <source>Point and the mark, as two numeric arguments, smallest first. This is the only code letter that specifies two successive arguments rather than one. This will signal an error if the mark is not set in the buffer which is current when the command is invoked. No I/O.</source>
          <target state="translated">Точка и метка,как два числовых аргумента,наименьшая первая.Это единственная кодовая буква,которая указывает не один,а два последовательных аргумента.Это будет сигнализировать об ошибке,если метка не будет установлена в буфере,который является текущим при вызове команды.Нет ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="607e97203b9ceed3b508490569d375e75af49959" translate="yes" xml:space="preserve">
          <source>Pointer Shape</source>
          <target state="translated">Форма указателя</target>
        </trans-unit>
        <trans-unit id="952493c99caa2adef127c34f7eb386dd95d6f98f" translate="yes" xml:space="preserve">
          <source>Polymorphism, Emacs-style.</source>
          <target state="translated">Полиморфизм в стиле Эмакса.</target>
        </trans-unit>
        <trans-unit id="ed7450dfdd1d277c3cabc1ce06c43cba4a362b92" translate="yes" xml:space="preserve">
          <source>Pop-Up Menus</source>
          <target state="translated">Всплывающее меню</target>
        </trans-unit>
        <trans-unit id="5307f05e0199e2333e229d7e2d00200cc6d0db03" translate="yes" xml:space="preserve">
          <source>Popping up a new window will fail if there is not enough space on the selected frame. In an uncustomized Emacs it typically fails when there are already two windows on a frame. For example, if you now type</source>
          <target state="translated">Открытие нового окна будет неудачным,если на выбранном фрейме не хватит места.В непривычном Emacs он обычно терпит неудачу,когда на одном фрейме уже есть два окна.Например,если вы сейчас набираете</target>
        </trans-unit>
        <trans-unit id="a6a8cdd50e41aeb0ad1784d8f1195a61e89f7520" translate="yes" xml:space="preserve">
          <source>Position Parameters</source>
          <target state="translated">Положение Параметры</target>
        </trans-unit>
        <trans-unit id="fcd7e6b774c8f47ead8ead0ed8f33c8f9f736a14" translate="yes" xml:space="preserve">
          <source>Position of the top-left corner and size of the work area (usable space) in pixels as &amp;lsquo;</source>
          <target state="translated">Положение левого верхнего угла и размер рабочей области (полезного пространства) в пикселях как '</target>
        </trans-unit>
        <trans-unit id="e7f9862a7c40fe020b33ccbf1989aac5bbb93333" translate="yes" xml:space="preserve">
          <source>Position of the top-left corner of the monitor&amp;rsquo;s screen and its size, in pixels, as &amp;lsquo;</source>
          <target state="translated">Положение левого верхнего угла экрана монитора и его размер в пикселях, как '</target>
        </trans-unit>
        <trans-unit id="cd4683fadf7005eca07e4d6267ddbb19ebcb91fa" translate="yes" xml:space="preserve">
          <source>Positions</source>
          <target state="translated">Positions</target>
        </trans-unit>
        <trans-unit id="da11d4c9a25e9c8a4126db50b558133457b0ac80" translate="yes" xml:space="preserve">
          <source>Positions are usually represented as integers starting from 1, but can also be represented as &lt;em&gt;markers&lt;/em&gt;&amp;mdash;special objects that relocate automatically when text is inserted or deleted so they stay with the surrounding characters. Functions that expect an argument to be a position (an integer), but accept a marker as a substitute, normally ignore which buffer the marker points into; they convert the marker to an integer, and use that integer, exactly as if you had passed the integer as the argument, even if the marker points to the wrong buffer. A marker that points nowhere cannot convert to an integer; using it instead of an integer causes an error. See &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;.</source>
          <target state="translated">Позиции обычно представлены целыми числами, начиная с 1, но могут также быть представлены в виде &lt;em&gt;маркеров - специальных&lt;/em&gt; объектов, которые автоматически перемещаются при вставке или удалении текста, поэтому они остаются рядом с окружающими символами. Функции, которые ожидают, что аргумент будет позицией (целым числом), но принимают маркер в качестве замены, обычно игнорируют, в какой буфер указывает маркер; они преобразуют маркер в целое число и используют это целое число, как если бы вы передали целое число в качестве аргумента, даже если маркер указывает на неправильный буфер. Маркер, который никуда не указывает, не может быть преобразован в целое число; использование его вместо целого числа вызывает ошибку. См. &lt;a href=&quot;markers#Markers&quot;&gt;Маркеры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d57c1560194ed5b9740be5062e662f21bf258a8" translate="yes" xml:space="preserve">
          <source>Precalculated Fontification</source>
          <target state="translated">Предсчитанное укрепление</target>
        </trans-unit>
        <trans-unit id="bb31a3184fc540673e8536291743e02cc7cb150c" translate="yes" xml:space="preserve">
          <source>Precautions about loading a file twice.</source>
          <target state="translated">Меры предосторожности при загрузке файла дважды.</target>
        </trans-unit>
        <trans-unit id="566ae5a22bce2d820a88dbf4901446093188d136" translate="yes" xml:space="preserve">
          <source>Precedence conflicts can be resolved via &lt;var&gt;resolvers&lt;/var&gt;, which is a list of &lt;em&gt;precs&lt;/em&gt; tables (see &lt;code&gt;smie-precs-&amp;gt;prec2&lt;/code&gt;): for each precedence conflict, if those &lt;code&gt;precs&lt;/code&gt; tables specify a particular constraint, then the conflict is resolved by using this constraint instead, else a conflict is reported and one of the conflicting constraints is picked arbitrarily and the others are simply ignored.</source>
          <target state="translated">Конфликты приоритета могут быть разрешены с помощью &lt;var&gt;resolvers&lt;/var&gt; , которые представляют собой список таблиц &lt;em&gt;префиксов&lt;/em&gt; (см. &lt;code&gt;smie-precs-&amp;gt;prec2&lt;/code&gt; ): для каждого конфликта приоритета, если эти таблицы &lt;code&gt;precs&lt;/code&gt; определяют конкретное ограничение, то конфликт разрешается с использованием этого ограничения вместо этого, в противном случае сообщается о конфликте, и одно из конфликтующих ограничений выбирается произвольно, а другие просто игнорируются.</target>
        </trans-unit>
        <trans-unit id="964094642c54dd1cde6edca379d013120bbe6cdf" translate="yes" xml:space="preserve">
          <source>Precedence of Action Functions</source>
          <target state="translated">Приоритет действий Функции</target>
        </trans-unit>
        <trans-unit id="7f421f63196a5c9594ee21a2f12cf973d50a9e3c" translate="yes" xml:space="preserve">
          <source>Precisely what this function does depends on your operating system. The function is designed to work with the syntax of your system&amp;rsquo;s standard shell; if you use an unusual shell, you will need to redefine this function. See &lt;a href=&quot;security-considerations#Security-Considerations&quot;&gt;Security Considerations&lt;/a&gt;.</source>
          <target state="translated">Что именно делает эта функция, зависит от вашей операционной системы. Функция предназначена для работы с синтаксисом стандартной оболочки вашей системы; если вы используете необычную оболочку, вам нужно будет переопределить эту функцию. См. &lt;a href=&quot;security-considerations#Security-Considerations&quot;&gt;Соображения безопасности&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
