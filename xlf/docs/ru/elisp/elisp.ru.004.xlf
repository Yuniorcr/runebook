<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="b05656c08d7ab767fee43f538b3b9d8c2e174064" translate="yes" xml:space="preserve">
          <source>; because filenames can contain spaces. The function &lt;code&gt;read-file-name&lt;/code&gt; combines this keymap with either &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; or &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt;.</source>
          <target state="translated">; потому что имена файлов могут содержать пробелы. Функция &lt;code&gt;read-file-name&lt;/code&gt; объединяет эту раскладку клавиш либо с &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt; либо с картой -совпадением-локального-минибуфера .</target>
        </trans-unit>
        <trans-unit id="850c15f3fa85d86d20b68663e13efe43a1a41188" translate="yes" xml:space="preserve">
          <source>; but for keyboard input purposes, you can turn any character into a control character with &amp;lsquo;</source>
          <target state="translated">; но для ввода с клавиатуры вы можете превратить любой символ в управляющий с помощью '</target>
        </trans-unit>
        <trans-unit id="73ea0cea742a3db6ec3c431020f69339a5e3b558" translate="yes" xml:space="preserve">
          <source>; but they are evaluated in the context outside of Edebug.</source>
          <target state="translated">; но они оцениваются вне Edebug.</target>
        </trans-unit>
        <trans-unit id="dfd9d0ecb96384cfbf0c3941bf53363cec430cf8" translate="yes" xml:space="preserve">
          <source>; if neither file exists, Emacs will create</source>
          <target state="translated">; если ни один файл не существует, Emacs создаст</target>
        </trans-unit>
        <trans-unit id="60522d957b18879e8563e5360ed6913eb48199c8" translate="yes" xml:space="preserve">
          <source>; if such a buffer does not exist, it is first created.</source>
          <target state="translated">; если такой буфер не существует, он сначала создается.</target>
        </trans-unit>
        <trans-unit id="8c757a33edcb033f1030119f1cb438615b02bc52" translate="yes" xml:space="preserve">
          <source>; if the value is a number,</source>
          <target state="translated">; если значение - число,</target>
        </trans-unit>
        <trans-unit id="cece8767090f8fbec9bbca7b3c6458fcf1d69bc0" translate="yes" xml:space="preserve">
          <source>; in a nutshell, the first character in a paragraph that has an explicit directionality determines the base direction of the paragraph. However, sometimes a buffer may need to force a certain base direction for its paragraphs. For example, buffers containing program source code should force all paragraphs to be displayed left-to-right. You can use following variable to do this:</source>
          <target state="translated">; Короче говоря, первый символ абзаца, имеющий явную направленность, определяет базовое направление абзаца. Однако иногда буферу может потребоваться принудительно задать определенное базовое направление для его абзацев. Например, буферы, содержащие исходный код программы, должны заставлять все абзацы отображаться слева направо. Для этого вы можете использовать следующую переменную:</target>
        </trans-unit>
        <trans-unit id="a076f7afa562b44c53c4203c05631ef27627a9d1" translate="yes" xml:space="preserve">
          <source>; it is the functional equivalent of the &lt;code&gt;Lisp_Object&lt;/code&gt; type used in Emacs C primitives (see &lt;a href=&quot;writing-emacs-primitives#Writing-Emacs-Primitives&quot;&gt;Writing Emacs Primitives&lt;/a&gt;). This section describes the parts of the module</source>
          <target state="translated">; это функциональный эквивалент типа &lt;code&gt;Lisp_Object&lt;/code&gt; , используемого в примитивах Emacs C (см. &lt;a href=&quot;writing-emacs-primitives#Writing-Emacs-Primitives&quot;&gt;Написание примитивов Emacs&lt;/a&gt; ). В этом разделе описаны части модуля.</target>
        </trans-unit>
        <trans-unit id="c6261eb921e3e265e24a0f8ecaa56fe3c2a3322f" translate="yes" xml:space="preserve">
          <source>; they tell &lt;code&gt;make-docfile&lt;/code&gt; to put the documentation string in the</source>
          <target state="translated">; они говорят &lt;code&gt;make-docfile&lt;/code&gt; поместить строку документации в</target>
        </trans-unit>
        <trans-unit id="71af3a99d714ad2fe85d56e631bdea4cf4d950b6" translate="yes" xml:space="preserve">
          <source>;;; Commentary:</source>
          <target state="translated">;;; Комментарий:</target>
        </trans-unit>
        <trans-unit id="8f84e2b6e48f86dfa7bce8ca1ad38eb966945aae" translate="yes" xml:space="preserve">
          <source>;;;###autoload</source>
          <target state="translated">;;;###autoload</target>
        </trans-unit>
        <trans-unit id="eac858a1a2a92559fd14a2a67a2f33fba7b2b8d8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#FOOT10&quot; name=&quot;DOCF10&quot;&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt;. A file by that name in a directory causes Emacs to apply its settings to any file in that directory or any of its subdirectories (optionally, you can exclude subdirectories; see below). If some of the subdirectories have their own</source>
          <target state="translated">&lt;a href=&quot;#FOOT10&quot; name=&quot;DOCF10&quot;&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt; . Файл с таким именем в каталоге заставляет Emacs применять свои настройки к любому файлу в этом каталоге или в любом из его подкаталогов (необязательно, вы можете исключить подкаталоги; см. Ниже). Если в некоторых подкаталогах есть свои</target>
        </trans-unit>
        <trans-unit id="7d5c3733b2b97d204545bd541ceb9ba2260298b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; Common Lisp allows the function to specify what default value to use when an optional argument is omitted; Emacs Lisp always uses &lt;code&gt;nil&lt;/code&gt;. Emacs Lisp does not support &lt;code&gt;supplied-p&lt;/code&gt; variables that tell you whether an argument was explicitly passed.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp:&lt;/b&gt; Common Lisp позволяет функции указывать, какое значение по умолчанию использовать, когда необязательный аргумент опущен; Emacs Lisp всегда использует &lt;code&gt;nil&lt;/code&gt; . Emacs Lisp не поддерживает переменные &lt;code&gt;supplied-p&lt;/code&gt; которые говорят вам, был ли аргумент передан явно.</target>
        </trans-unit>
        <trans-unit id="6367857ee9e29c4473084381a801ec8349aeb22c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; Common Lisp defines another way to specify the &lt;code&gt;setf&lt;/code&gt; behavior of a function, namely &lt;code&gt;setf&lt;/code&gt; functions, whose names are lists &lt;code&gt;(setf &lt;var&gt;name&lt;/var&gt;)&lt;/code&gt; rather than symbols. For example, &lt;code&gt;(defun (setf foo) &amp;hellip;)&lt;/code&gt; defines the function that is used when &lt;code&gt;setf&lt;/code&gt; is applied to &lt;code&gt;foo&lt;/code&gt;. Emacs does not support this. It is a compile-time error to use &lt;code&gt;setf&lt;/code&gt; on a form that has not already had an appropriate expansion defined. In Common Lisp, this is not an error since the function &lt;code&gt;(setf
&lt;var&gt;func&lt;/var&gt;)&lt;/code&gt; might be defined later.</source>
          <target state="translated">&lt;b&gt;Common Lisp Примечание:&lt;/b&gt; Common Lisp определяет еще один способ указать &lt;code&gt;setf&lt;/code&gt; поведение функции, а именно &lt;code&gt;setf&lt;/code&gt; функций, чьи имена перечислены &lt;code&gt;(setf &lt;var&gt;name&lt;/var&gt;)&lt;/code&gt; , а не символов. Например, &lt;code&gt;(defun (setf foo) &amp;hellip;)&lt;/code&gt; определяет функцию, которая используется, когда &lt;code&gt;setf&lt;/code&gt; применяется к &lt;code&gt;foo&lt;/code&gt; . Emacs не поддерживает это. Использование &lt;code&gt;setf&lt;/code&gt; в форме, для которой еще не определено соответствующее расширение, является ошибкой времени компиляции . В Common Lisp это не ошибка, поскольку функция &lt;code&gt;(setf &lt;var&gt;func&lt;/var&gt;)&lt;/code&gt; может быть определена позже.</target>
        </trans-unit>
        <trans-unit id="b553724505c7b2ff9cd2dd0f6f26179f25ff53d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; Common Lisp has functions &lt;code&gt;union&lt;/code&gt; (which avoids duplicate elements) and &lt;code&gt;intersection&lt;/code&gt; for set operations. In Emacs Lisp, variants of these facilities are provided by the</source>
          <target state="translated">&lt;b&gt;Примечание Common Lisp:&lt;/b&gt; Common Lisp имеет &lt;code&gt;union&lt;/code&gt; функций (которое позволяет избежать дублирования элементов) и &lt;code&gt;intersection&lt;/code&gt; для операций над множеством. В Emacs Lisp варианты этих возможностей предоставляются</target>
        </trans-unit>
        <trans-unit id="22015162b0b6cf562a348be322a99274ab88223c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; Common Lisp uses functions &lt;code&gt;rplaca&lt;/code&gt; and &lt;code&gt;rplacd&lt;/code&gt; to alter list structure; they change structure the same way as &lt;code&gt;setcar&lt;/code&gt; and &lt;code&gt;setcdr&lt;/code&gt;, but the Common Lisp functions return the cons cell while &lt;code&gt;setcar&lt;/code&gt; and &lt;code&gt;setcdr&lt;/code&gt; return the new &lt;small&gt;CAR&lt;/small&gt; or &lt;small&gt;CDR&lt;/small&gt;.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp:&lt;/b&gt; Common Lisp использует функции &lt;code&gt;rplaca&lt;/code&gt; и &lt;code&gt;rplacd&lt;/code&gt; для изменения структуры списка; они меняют структуру так же, как &lt;code&gt;setcar&lt;/code&gt; и &lt;code&gt;setcdr&lt;/code&gt; , но функции Common Lisp возвращают cons-ячейку, а &lt;code&gt;setcar&lt;/code&gt; и &lt;code&gt;setcdr&lt;/code&gt; возвращают новый &lt;small&gt;CAR&lt;/small&gt; или &lt;small&gt;CDR&lt;/small&gt; .</target>
        </trans-unit>
        <trans-unit id="ebb79170f9f6008be3b36f4402d4c4ffd7c7d3eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; Emacs Lisp has nothing like the Common Lisp concept of continuable errors.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp:&lt;/b&gt; Emacs Lisp не имеет ничего общего с концепцией продолжаемых ошибок Common Lisp.</target>
        </trans-unit>
        <trans-unit id="e1c1987c8ae7965c8aeef374c399a5aba221a9db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; Here are some comparisons of special forms in GNU Emacs Lisp and Common Lisp. &lt;code&gt;setq&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;catch&lt;/code&gt; are special forms in both Emacs Lisp and Common Lisp. &lt;code&gt;save-excursion&lt;/code&gt; is a special form in Emacs Lisp, but doesn&amp;rsquo;t exist in Common Lisp. &lt;code&gt;throw&lt;/code&gt; is a special form in Common Lisp (because it must be able to throw multiple values), but it is a function in Emacs Lisp (which doesn&amp;rsquo;t have multiple values).</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp:&lt;/b&gt; Вот некоторые сравнения специальных форм в GNU Emacs Lisp и Common Lisp. &lt;code&gt;setq&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;catch&lt;/code&gt; являются специальными формами как в Emacs Lisp, так и в Common Lisp. &lt;code&gt;save-excursion&lt;/code&gt; - это особая форма в Emacs Lisp, но не существует в Common Lisp. &lt;code&gt;throw&lt;/code&gt; - это особая форма в Common Lisp (потому что она должна иметь возможность генерировать несколько значений), но это функция в Emacs Lisp (которая не имеет нескольких значений).</target>
        </trans-unit>
        <trans-unit id="461775aaf52be2a8f8b9da187f5469e279a12664" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; In Common Lisp a similar function is called &lt;code&gt;sxhash&lt;/code&gt;. Emacs provides this name as a compatibility alias for &lt;code&gt;sxhash-equal&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp:&lt;/b&gt; В Common Lisp аналогичная функция называется &lt;code&gt;sxhash&lt;/code&gt; . Emacs предоставляет это имя как псевдоним совместимости для &lt;code&gt;sxhash-equal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e6ce144f4e2ab72dfb3bf32261406e5ea16e7d1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; In Common Lisp, &lt;code&gt;clrhash&lt;/code&gt; returns the empty &lt;var&gt;table&lt;/var&gt;. In Emacs Lisp, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp:&lt;/b&gt; В Common Lisp &lt;code&gt;clrhash&lt;/code&gt; возвращает пустую &lt;var&gt;table&lt;/var&gt; . В Emacs Lisp он возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="883fddb1102b92cffd11c402a566a42b36bdc655" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; In Common Lisp, &lt;code&gt;remhash&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt; if it actually removed an association and &lt;code&gt;nil&lt;/code&gt; otherwise. In Emacs Lisp, &lt;code&gt;remhash&lt;/code&gt; always returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;Common Lisp Примечание:&lt;/b&gt; В Common Lisp, &lt;code&gt;remhash&lt;/code&gt; возвращает не- &lt;code&gt;nil&lt;/code&gt; , если он на самом деле удалили ассоциацию и &lt;code&gt;nil&lt;/code&gt; в противном случае. В Emacs Lisp &lt;code&gt;remhash&lt;/code&gt; всегда возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbcea5c9de01b724f73c8bdf1b9a568d2ece9b4d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; In Common Lisp, lower case letters are always folded to upper case, unless they are explicitly escaped. In Emacs Lisp, upper case and lower case letters are distinct.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp:&lt;/b&gt; В Common Lisp буквы нижнего регистра всегда переводятся в верхний регистр, если они явно не экранированы. В Emacs Lisp прописные и строчные буквы различны.</target>
        </trans-unit>
        <trans-unit id="4448631a5e3f6b8bdf37d289aa6b1dfc59dbc1a4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; In Common Lisp, you can intern an existing symbol in an obarray. In Emacs Lisp, you cannot do this, because the argument to &lt;code&gt;intern&lt;/code&gt; must be a string, not a symbol.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp:&lt;/b&gt; В Common Lisp вы можете вставить существующий символ в массив. В Emacs Lisp вы не можете этого сделать, потому что аргумент для &lt;code&gt;intern&lt;/code&gt; должен быть строкой, а не символом.</target>
        </trans-unit>
        <trans-unit id="35bdc599b057feab1fdbac7138b61708594fbf48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; Most other versions of Lisp, including Common Lisp, have several ways of transferring control nonsequentially: &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;return-from&lt;/code&gt;, and &lt;code&gt;go&lt;/code&gt;, for example. Emacs Lisp has only &lt;code&gt;throw&lt;/code&gt;. The</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp: в&lt;/b&gt; большинстве других версий Lisp, включая Common Lisp, есть несколько способов непоследовательной передачи управления: например, &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;return-from&lt;/code&gt; и &lt;code&gt;go&lt;/code&gt; . Emacs Lisp имеет только &lt;code&gt;throw&lt;/code&gt; . В</target>
        </trans-unit>
        <trans-unit id="0a28db1ab06daa4ba2de19e43209b90772c24bbf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; The functions &lt;code&gt;member&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; in GNU Emacs Lisp are derived from Maclisp, not Common Lisp. The Common Lisp versions do not use &lt;code&gt;equal&lt;/code&gt; to compare elements.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp:&lt;/b&gt; функции &lt;code&gt;member&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; и &lt;code&gt;remove&lt;/code&gt; в GNU Emacs Lisp являются производными от Maclisp, а не от Common Lisp. Версии Common Lisp не используют &lt;code&gt;equal&lt;/code&gt; элементы для сравнения.</target>
        </trans-unit>
        <trans-unit id="481b03630d7d1963a68afcb9aa760048b4e87a17" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; Unlike Common Lisp, Emacs Lisp does not provide for interning a single symbol in several obarrays.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp: в&lt;/b&gt; отличие от Common Lisp, Emacs Lisp не обеспечивает интернирование одного символа в нескольких obarrays.</target>
        </trans-unit>
        <trans-unit id="8bff408889e4337d00cf240d84d8156cfe8464c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Common Lisp note:&lt;/b&gt; Unlike other Lisps, GNU Emacs Lisp does not call the garbage collector when the free list is empty. Instead, it simply requests the operating system to allocate more storage, and processing continues until &lt;code&gt;gc-cons-threshold&lt;/code&gt; bytes have been used.</source>
          <target state="translated">&lt;b&gt;Замечание по Common Lisp: в&lt;/b&gt; отличие от других Lisp, GNU Emacs Lisp не вызывает сборщик мусора, когда свободный список пуст. Вместо этого он просто запрашивает у операционной системы выделение большего объема памяти, и обработка продолжается до тех пор, пока не будут использованы байты &lt;code&gt;gc-cons-threshold&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2777476ce485422646e2c57bff88f755808cde88" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Completion&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Completion&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="677fe5061c3339a3af7e2fcddfa71f830896e1f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Default&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Default&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="644966ccd81f72102c8b8359c223d687f6a87adf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Existing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Existing&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d6475c26f45a98f3c2a9c7476df7ac9e61a68fba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;No I/O&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Нет ввода / вывода&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="517425362cbb54fe23154f4b6072a55c40083eab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Prompt&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Prompt&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7bbc5663e059ef4b86f48f96a3cf6a6ccdee95f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Special&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Special&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3571d6eb92f7d98e1c4eda2402213efe0e7ab52a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;&lt;var&gt;signal-description&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt;. The &lt;var&gt;signal-description&lt;/var&gt; is a system-dependent textual description of a signal, e.g., &lt;code&gt;&quot;killed&quot;&lt;/code&gt; for &lt;code&gt;SIGKILL&lt;/code&gt;. The &amp;ldquo;core dumped&amp;rdquo; part is optional, and only appears if the process dumped core.</source>
          <target state="translated">&lt;code&gt;&quot;&lt;var&gt;signal-description&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt; . Описание &lt;var&gt;signal-description&lt;/var&gt; - это системно-зависимое текстовое описание сигнала, например &lt;code&gt;&quot;killed&quot;&lt;/code&gt; для &lt;code&gt;SIGKILL&lt;/code&gt; . Часть &amp;laquo;core dumped&amp;raquo; не является обязательной и появляется только в том случае, если процесс выгружает core.</target>
        </trans-unit>
        <trans-unit id="21510b6b5c7cbab2e1be067295358d4792e4d65e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;connection broken by remote peer\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;connection broken by remote peer\n&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9816d6ca400b6770ec7060208e3f151de8d707a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;deleted\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;deleted\n&quot;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="1c32b918f930d17e17d32954809a49631abaa8a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;exited abnormally with code &lt;var&gt;exitcode&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt;. The &amp;ldquo;core dumped&amp;rdquo; part is optional, and only appears if the process dumped core.</source>
          <target state="translated">&lt;code&gt;&quot;exited abnormally with code &lt;var&gt;exitcode&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt; . Часть &amp;laquo;core dumped&amp;raquo; не является обязательной и появляется только в том случае, если процесс выгружает core.</target>
        </trans-unit>
        <trans-unit id="0fd91ad9f72c086362a3597555e03163dbe8e5d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;failed with code &lt;var&gt;fail-code&lt;/var&gt;\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;failed with code &lt;var&gt;fail-code&lt;/var&gt;\n&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="452f3fbb5d5b06f71bcf670ee21189ba10aebe5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;finished\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;finished\n&quot;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="8ce5578b61523c780393dc21e82f5fd6d5f2f0fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;open from &lt;var&gt;host-name&lt;/var&gt;\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;open from &lt;var&gt;host-name&lt;/var&gt;\n&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaa2e8e855dbd08e0cfa22710f395245e053bd02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;open\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;open\n&quot;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="667e3d01a04fd5c5457e513a4050129a3a31ab13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :after &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;
'append)&lt;/code&gt; for normal hooks.</source>
          <target state="translated">&lt;code&gt;(add-function :after &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; для однофункциональных хуков сравнимо с &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 'append)&lt;/code&gt; для обычных хуков.</target>
        </trans-unit>
        <trans-unit id="e79f2e8727e321371b1128b55cf7222da89f4f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :after-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;
'append)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :after-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; для однофункциональных хуков сравнимо с &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 'append)&lt;/code&gt; когда &lt;var&gt;hookvar&lt;/var&gt; запускается через &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1ada1c40c2fc461e47b0536ab0b0d83798556ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :after-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;
'append)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :after-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; для однофункциональных хуков сравнимо с &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 'append)&lt;/code&gt; когда &lt;var&gt;hookvar&lt;/var&gt; запускается через &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77fd36076dd83bbf47f8b99d3020b0d1a3a0c601" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :before &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; for normal hooks.</source>
          <target state="translated">&lt;code&gt;(add-function :before &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; для однофункциональных хуков сравнимо с &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; для обычных хуков.</target>
        </trans-unit>
        <trans-unit id="30dada64dce8c2ce8801fc2baeb378ba25b722b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :before-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :before-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; для однофункциональных хуков сравнимо с &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; когда &lt;var&gt;hookvar&lt;/var&gt; запускается через &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22c99938a4d009a4111676d43f22995cb86610e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :before-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :before-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; для однофункциональных хуков сравнима с &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; когда &lt;var&gt;hookvar&lt;/var&gt; запускается через &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c6252a7ccf0c052151b4b73d200cde8cab47324" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(column . &lt;var&gt;column&lt;/var&gt;)&lt;/code&gt;: indent to column &lt;var&gt;column&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;(column . &lt;var&gt;column&lt;/var&gt;)&lt;/code&gt; : отступ до столбца &lt;var&gt;column&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="bd05cccba28e6261f59cbfbe25751f0d1d3ec26e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(zerop x)&lt;/code&gt; is equivalent to &lt;code&gt;(= x 0)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(zerop x)&lt;/code&gt; эквивалентно &lt;code&gt;(= x 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a39a0d34aa08d1f39b0ffda4c8edaa99d08f6ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; means operate on all visible or iconified frames.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; означает работу со всеми видимыми или иконизированными кадрами.</target>
        </trans-unit>
        <trans-unit id="4dc6a4b0544f7e10c0aac111768586f7e59a5bf1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2C-mode-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;2C-mode-map&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="ff17a4d55b54932f733d4df35f4351fe75f50056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:after&lt;/code&gt;, in which case &lt;var&gt;arg&lt;/var&gt; is a token and the function should return the &lt;var&gt;offset&lt;/var&gt; to use for indentation after &lt;var&gt;arg&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;:after&lt;/code&gt; , и в этом случае &lt;var&gt;arg&lt;/var&gt; является токеном, и функция должна возвращать &lt;var&gt;offset&lt;/var&gt; для использования для отступа после &lt;var&gt;arg&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="745c148e949b23754d925fc97e53ee25ac2e7fc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:backward-token&lt;/code&gt;&lt;var&gt;fun&lt;/var&gt;: Specify the backward lexer to use.</source>
          <target state="translated">&lt;code&gt;:backward-token&lt;/code&gt; &lt;var&gt;fun&lt;/var&gt; : укажите обратный лексический анализатор для использования.</target>
        </trans-unit>
        <trans-unit id="09bf88985b0025e5ce963894bae66add561883e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:before&lt;/code&gt;, in which case &lt;var&gt;arg&lt;/var&gt; is a token and the function should return the &lt;var&gt;offset&lt;/var&gt; to use to indent &lt;var&gt;arg&lt;/var&gt; itself.</source>
          <target state="translated">&lt;code&gt;:before&lt;/code&gt; , и в этом случае &lt;var&gt;arg&lt;/var&gt; является токеном, и функция должна возвращать &lt;var&gt;offset&lt;/var&gt; для использования для отступа самого &lt;var&gt;arg&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="4a6b6bc5821f2cf42d0e5e833804de89ab8123e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:elem&lt;/code&gt;, in which case the function should return either the offset to use to indent function arguments (if &lt;var&gt;arg&lt;/var&gt; is the symbol &lt;code&gt;arg&lt;/code&gt;) or the basic indentation step (if &lt;var&gt;arg&lt;/var&gt; is the symbol &lt;code&gt;basic&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;:elem&lt;/code&gt; , и в этом случае функция должна возвращать либо смещение, используемое для отступа аргументов функции (если &lt;var&gt;arg&lt;/var&gt; - это символ &lt;code&gt;arg&lt;/code&gt; ), либо базовый шаг отступа (если &lt;var&gt;arg&lt;/var&gt; является &lt;code&gt;basic&lt;/code&gt; символом ).</target>
        </trans-unit>
        <trans-unit id="66ff7dd6575d51f021e1583cc2aa0383d29e79db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:forward-token&lt;/code&gt;&lt;var&gt;fun&lt;/var&gt;: Specify the forward lexer to use.</source>
          <target state="translated">&lt;code&gt;:forward-token&lt;/code&gt; &lt;var&gt;fun&lt;/var&gt; : Укажите используемый лексер переадресации.</target>
        </trans-unit>
        <trans-unit id="60b5e4ffa4ea98bbfb035262b0942a24c34df7a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:list-intro&lt;/code&gt;, in which case &lt;var&gt;arg&lt;/var&gt; is a token and the function should return non-&lt;code&gt;nil&lt;/code&gt; if the token is followed by a list of expressions (not separated by any token) rather than an expression.</source>
          <target state="translated">&lt;code&gt;:list-intro&lt;/code&gt; , и в этом случае &lt;var&gt;arg&lt;/var&gt; является токеном, и функция должна возвращать &lt;code&gt;nil&lt;/code&gt; если за токеном следует список выражений (не разделенных никакими токенами), а не выражение.</target>
        </trans-unit>
        <trans-unit id="de4ff782e72efa54bfa512b55e8172fc1b21044d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:local&lt;/code&gt; and &lt;code&gt;:remote&lt;/code&gt; are included even if they were not specified explicitly in &lt;code&gt;make-network-process&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:local&lt;/code&gt; и &lt;code&gt;:remote&lt;/code&gt; включаются, даже если они не были явно указаны в &lt;code&gt;make-network-process&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93d4cc5172b5a539cd9385caf51a90816a586e54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tag&lt;/code&gt; is often used with &lt;code&gt;const&lt;/code&gt;, inside of &lt;code&gt;choice&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;:tag&lt;/code&gt; часто используется с &lt;code&gt;const&lt;/code&gt; по &lt;code&gt;choice&lt;/code&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="d8d5cc8815e0bd9596f7142348a8519bc72bc958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;access-file&lt;/code&gt;, &lt;code&gt;add-name-to-file&lt;/code&gt;, &lt;code&gt;byte-compiler-base-file-name&lt;/code&gt;, &lt;code&gt;copy-directory&lt;/code&gt;, &lt;code&gt;copy-file&lt;/code&gt;, &lt;code&gt;delete-directory&lt;/code&gt;, &lt;code&gt;delete-file&lt;/code&gt;, &lt;code&gt;diff-latest-backup-file&lt;/code&gt;, &lt;code&gt;directory-file-name&lt;/code&gt;, &lt;code&gt;directory-files&lt;/code&gt;, &lt;code&gt;directory-files-and-attributes&lt;/code&gt;, &lt;code&gt;dired-compress-file&lt;/code&gt;, &lt;code&gt;dired-uncache&lt;/code&gt;, &lt;code&gt;exec-path&lt;/code&gt;, &lt;code&gt;expand-file-name&lt;/code&gt;, &lt;code&gt;file-accessible-directory-p&lt;/code&gt;, &lt;code&gt;file-acl&lt;/code&gt;, &lt;code&gt;file-attributes&lt;/code&gt;, &lt;code&gt;file-directory-p&lt;/code&gt;, &lt;code&gt;file-equal-p&lt;/code&gt;, &lt;code&gt;file-executable-p&lt;/code&gt;, &lt;code&gt;file-exists-p&lt;/code&gt;, &lt;code&gt;file-in-directory-p&lt;/code&gt;, &lt;code&gt;file-local-copy&lt;/code&gt;, &lt;code&gt;file-modes&lt;/code&gt;, &lt;code&gt;file-name-all-completions&lt;/code&gt;, &lt;code&gt;file-name-as-directory&lt;/code&gt;, &lt;code&gt;file-name-case-insensitive-p&lt;/code&gt;, &lt;code&gt;file-name-completion&lt;/code&gt;, &lt;code&gt;file-name-directory&lt;/code&gt;, &lt;code&gt;file-name-nondirectory&lt;/code&gt;, &lt;code&gt;file-name-sans-versions&lt;/code&gt;, &lt;code&gt;file-newer-than-file-p&lt;/code&gt;, &lt;code&gt;file-notify-add-watch&lt;/code&gt;, &lt;code&gt;file-notify-rm-watch&lt;/code&gt;, &lt;code&gt;file-notify-valid-p&lt;/code&gt;, &lt;code&gt;file-ownership-preserved-p&lt;/code&gt;, &lt;code&gt;file-readable-p&lt;/code&gt;, &lt;code&gt;file-regular-p&lt;/code&gt;, &lt;code&gt;file-remote-p&lt;/code&gt;, &lt;code&gt;file-selinux-context&lt;/code&gt;, &lt;code&gt;file-symlink-p&lt;/code&gt;, &lt;code&gt;file-system-info&lt;/code&gt;, &lt;code&gt;file-truename&lt;/code&gt;, &lt;code&gt;file-writable-p&lt;/code&gt;, &lt;code&gt;find-backup-file-name&lt;/code&gt;, &lt;code&gt;get-file-buffer&lt;/code&gt;, &lt;code&gt;insert-directory&lt;/code&gt;, &lt;code&gt;insert-file-contents&lt;/code&gt;, &lt;code&gt;load&lt;/code&gt;, &lt;code&gt;make-auto-save-file-name&lt;/code&gt;, &lt;code&gt;make-directory&lt;/code&gt;, &lt;code&gt;make-directory-internal&lt;/code&gt;, &lt;code&gt;make-nearby-temp-file&lt;/code&gt;, &lt;code&gt;make-process&lt;/code&gt;, &lt;code&gt;make-symbolic-link&lt;/code&gt;, &lt;code&gt;process-file&lt;/code&gt;, &lt;code&gt;rename-file&lt;/code&gt;, &lt;code&gt;set-file-acl&lt;/code&gt;, &lt;code&gt;set-file-modes&lt;/code&gt;, &lt;code&gt;set-file-selinux-context&lt;/code&gt;, &lt;code&gt;set-file-times&lt;/code&gt;, &lt;code&gt;set-visited-file-modtime&lt;/code&gt;, &lt;code&gt;shell-command&lt;/code&gt;, &lt;code&gt;start-file-process&lt;/code&gt;, &lt;code&gt;substitute-in-file-name&lt;/code&gt;, &lt;code&gt;temporary-file-directory&lt;/code&gt;, &lt;code&gt;unhandled-file-name-directory&lt;/code&gt;, &lt;code&gt;vc-registered&lt;/code&gt;, &lt;code&gt;verify-visited-file-modtime&lt;/code&gt;, &lt;code&gt;write-region&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;access-file&lt;/code&gt; , &lt;code&gt;add-name-to-file&lt;/code&gt; , &lt;code&gt;byte-compiler-base-file-name&lt;/code&gt; , &lt;code&gt;copy-directory&lt;/code&gt; , &lt;code&gt;copy-file&lt;/code&gt; , &lt;code&gt;delete-directory&lt;/code&gt; , &lt;code&gt;delete-file&lt;/code&gt; , &lt;code&gt;diff-latest-backup-file&lt;/code&gt; , &lt;code&gt;directory-file-name&lt;/code&gt; , &lt;code&gt;directory-files&lt;/code&gt; , &lt;code&gt;directory-files-and-attributes&lt;/code&gt; , &lt;code&gt;dired-compress-file&lt;/code&gt; , &lt;code&gt;dired-uncache&lt;/code&gt; , &lt;code&gt;exec-path&lt;/code&gt; , &lt;code&gt;expand-file-name&lt;/code&gt; , &lt;code&gt;file-accessible-directory-p&lt;/code&gt; , &lt;code&gt;file-acl&lt;/code&gt; , &lt;code&gt;file-attributes&lt;/code&gt; , &lt;code&gt;file-directory-p&lt;/code&gt; , &lt;code&gt;file-equal-p&lt;/code&gt; , &lt;code&gt;file-executable-p&lt;/code&gt; , &lt;code&gt;file-exists-p&lt;/code&gt; , &lt;code&gt;file-in-directory-p&lt;/code&gt; , &lt;code&gt;file-local-copy&lt;/code&gt; , &lt;code&gt;file-modes&lt;/code&gt; , &lt;code&gt;file-name-all-completions&lt;/code&gt; , &lt;code&gt;file-name-as-directory&lt;/code&gt; , &lt;code&gt;file-name-case-insensitive-p&lt;/code&gt; , &lt;code&gt;file-name-completion&lt;/code&gt; , &lt;code&gt;file-name-directory&lt;/code&gt; , &lt;code&gt;file-name-nondirectory&lt;/code&gt; , &lt;code&gt;file-name-sans-versions&lt;/code&gt; , &lt;code&gt;file-newer-than-file-p&lt;/code&gt; , &lt;code&gt;file-notify-add-watch&lt;/code&gt; , &lt;code&gt;file-notify-rm-watch&lt;/code&gt; , &lt;code&gt;file-notify-valid-p&lt;/code&gt; , &lt;code&gt;file-ownership-preserved-p&lt;/code&gt; , &lt;code&gt;file-readable-p&lt;/code&gt; , &lt;code&gt;file-regular-p&lt;/code&gt; , &lt;code&gt;file-remote-p&lt;/code&gt; , &lt;code&gt;file-selinux-context&lt;/code&gt; , &lt;code&gt;file-symlink-p&lt;/code&gt; , &lt;code&gt;file-system-info&lt;/code&gt; , &lt;code&gt;file-truename&lt;/code&gt; , &lt;code&gt;file-writable-p&lt;/code&gt; writeable -p , &lt;code&gt;find-backup-file-name&lt;/code&gt; &lt;code&gt;get-file-buffer&lt;/code&gt; , получить-буфер-файла , &lt;code&gt;insert-directory&lt;/code&gt; , &lt;code&gt;insert-file-contents&lt;/code&gt; , &lt;code&gt;load&lt;/code&gt; , &lt;code&gt;make-auto-save-file-name&lt;/code&gt; , &lt;code&gt;make-directory&lt;/code&gt; , &lt;code&gt;make-directory-internal&lt;/code&gt; , &lt;code&gt;make-nearby-temp-file&lt;/code&gt; , &lt;code&gt;make-process&lt;/code&gt; , &lt;code&gt;make-symbolic-link&lt;/code&gt; , &lt;code&gt;process-file&lt;/code&gt; , &lt;code&gt;rename-file&lt;/code&gt; , &lt;code&gt;set-file-acl&lt;/code&gt; , &lt;code&gt;set-file-modes&lt;/code&gt; , &lt;code&gt;set-file-selinux-context&lt;/code&gt; , &lt;code&gt;set-file-times&lt;/code&gt; , &lt;code&gt;set-visited-file-modtime&lt;/code&gt; , &lt;code&gt;shell-command&lt;/code&gt; , &lt;code&gt;start-file-process&lt;/code&gt; , &lt;code&gt;substitute-in-file-name&lt;/code&gt; , &lt;code&gt;temporary-file-directory&lt;/code&gt; , &lt;code&gt;unhandled-file-name-directory&lt;/code&gt; , &lt;code&gt;vc-registered&lt;/code&gt; , &lt;code&gt;verify-visited-file-modtime&lt;/code&gt; , &lt;code&gt;write-region&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a910d2cabd88a287657c3675086df2e12c75bb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add-hook&lt;/code&gt; can handle the cases where &lt;var&gt;hook&lt;/var&gt; is void or its value is a single function; it sets or changes the value to a list of functions.</source>
          <target state="translated">&lt;code&gt;add-hook&lt;/code&gt; может обрабатывать случаи, когда &lt;var&gt;hook&lt;/var&gt; недействителен или его значение является одной функцией; он устанавливает или изменяет значение списка функций.</target>
        </trans-unit>
        <trans-unit id="e338fdebb37360438c44e0ef1f0938e510dc62c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;advice-add&lt;/code&gt; can be useful for altering the behavior of existing calls to an existing function without having to redefine the whole function. However, it can be a source of bugs, since existing callers to the function may assume the old behavior, and work incorrectly when the behavior is changed by advice. Advice can also cause confusion in debugging, if the person doing the debugging does not notice or remember that the function has been modified by advice.</source>
          <target state="translated">&lt;code&gt;advice-add&lt;/code&gt; может быть полезен для изменения поведения существующих вызовов существующей функции без необходимости переопределения всей функции. Однако это может быть источником ошибок, поскольку существующие вызывающие функции могут принимать старое поведение и работать некорректно, когда поведение изменяется с помощью совета. Совет также может вызвать путаницу при отладке, если лицо, выполняющее отладку, не замечает или не помнит, что функция была изменена по рекомендации.</target>
        </trans-unit>
        <trans-unit id="9b5bc6aebbe4d1ec5567b21d8b250c6288b5aa13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alnum&lt;/code&gt;, &lt;code&gt;alphanumeric&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;alphanumeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55e0ebe110df9b523af8588d07de74b48311387b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alpha&lt;/code&gt;, &lt;code&gt;alphabetic&lt;/code&gt;, &lt;code&gt;letter&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alphabetic&lt;/code&gt; , &lt;code&gt;letter&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="258b77970c969f1cf29cda319c3a2f76f3ca3d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt; expressions can also be written using either &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;cond&lt;/code&gt;. Here&amp;rsquo;s how:</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; выражения также могут быть записаны с использованием &lt;code&gt;if&lt;/code&gt; или &lt;code&gt;cond&lt;/code&gt; . Вот как:</target>
        </trans-unit>
        <trans-unit id="5c8ce8061acb49230ba8a01fbdf7ed67c9a03473" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, and friends.</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , и друзья.</target>
        </trans-unit>
        <trans-unit id="6cbffc1a87a05c66112554e09bc35c04c5fa36de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anychar&lt;/code&gt;, &lt;code&gt;anything&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;anychar&lt;/code&gt; , &lt;code&gt;anything&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee4e624b640721bf440e6348f13fadce71c3902a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; with &lt;var&gt;arguments&lt;/var&gt;, just like &lt;code&gt;funcall&lt;/code&gt; but with one difference: the last of &lt;var&gt;arguments&lt;/var&gt; is a list of objects, which are passed to &lt;var&gt;function&lt;/var&gt; as separate arguments, rather than a single list. We say that &lt;code&gt;apply&lt;/code&gt;&lt;em&gt;spreads&lt;/em&gt; this list so that each individual element becomes an argument.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; вызывает &lt;var&gt;function&lt;/var&gt; с &lt;var&gt;arguments&lt;/var&gt; , как и &lt;code&gt;funcall&lt;/code&gt; , но с одним отличием: последний из &lt;var&gt;arguments&lt;/var&gt; - это список объектов, которые передаются &lt;var&gt;function&lt;/var&gt; как отдельные аргументы, а не один список. Мы говорим, что &lt;code&gt;apply&lt;/code&gt; &lt;em&gt;расширяет&lt;/em&gt; этот список, так что каждый отдельный элемент становится аргументом.</target>
        </trans-unit>
        <trans-unit id="c9856e4d3686dbca6454b1252a811ab995dd7923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; returns the result of calling &lt;var&gt;function&lt;/var&gt;. As with &lt;code&gt;funcall&lt;/code&gt;, &lt;var&gt;function&lt;/var&gt; must either be a Lisp function or a primitive function; special forms and macros do not make sense in &lt;code&gt;apply&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; возвращает результат вызова &lt;var&gt;function&lt;/var&gt; . Как и в случае с &lt;code&gt;funcall&lt;/code&gt; , &lt;var&gt;function&lt;/var&gt; должна быть либо функцией Лиспа, либо примитивной функцией; специальные формы и макросы не имеют смысла в &lt;code&gt;apply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="543192ce173130f8e60f6356c2436ff81754276f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ash&lt;/code&gt; (&lt;em&gt;arithmetic shift&lt;/em&gt;) shifts the bits in &lt;var&gt;integer1&lt;/var&gt; to the left &lt;var&gt;count&lt;/var&gt; places, or to the right if &lt;var&gt;count&lt;/var&gt; is negative. Left shifts introduce zero bits on the right; right shifts discard the rightmost bits. Considered as an integer operation, &lt;code&gt;ash&lt;/code&gt; multiplies &lt;var&gt;integer1&lt;/var&gt; by 2**&lt;var&gt;count&lt;/var&gt;, and then converts the result to an integer by rounding downward, toward minus infinity.</source>
          <target state="translated">&lt;code&gt;ash&lt;/code&gt; ( &lt;em&gt;арифметический сдвиг&lt;/em&gt; ) сдвигает биты в &lt;var&gt;integer1&lt;/var&gt; влево на &lt;var&gt;count&lt;/var&gt; разряды или вправо, если &lt;var&gt;count&lt;/var&gt; отрицательный. Сдвиг влево вводит нулевые биты справа; сдвиг вправо отбрасывает крайние правые биты. Рассматриваемая как целочисленная операция, &lt;code&gt;ash&lt;/code&gt; умножает &lt;var&gt;integer1&lt;/var&gt; на 2 ** &lt;var&gt;count&lt;/var&gt; , а затем преобразует результат в целое число, округляя вниз до минус бесконечности.</target>
        </trans-unit>
        <trans-unit id="968029e28d94f9920ac5b9f8216de27a4a72f17e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; is also effectively &lt;code&gt;eval-and-compile&lt;/code&gt; too. It&amp;rsquo;s recognized when compiling, so uses of such a function don&amp;rsquo;t produce &amp;ldquo;not known to be defined&amp;rdquo; warnings.</source>
          <target state="translated">&lt;code&gt;autoload&lt;/code&gt; также эффективно выполняет &lt;code&gt;eval-and-compile&lt;/code&gt; . Это распознается при компиляции, поэтому использование такой функции не вызывает предупреждений &amp;laquo;не известно, что определено&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="915ee42daeea60e842ed1dda4a1dd9b72a50f128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backspace&lt;/code&gt;, &lt;code&gt;tab&lt;/code&gt;, &lt;code&gt;newline&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;backspace&lt;/code&gt; , &lt;code&gt;tab&lt;/code&gt; , &lt;code&gt;newline&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="946f496fb049245538cd4cc7ba5132c40e505caf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bottom-left-angle&lt;/code&gt;, &lt;code&gt;bottom-right-angle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;bottom-left-angle&lt;/code&gt; , &lt;code&gt;bottom-right-angle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4c30ff3b0a0eb9c8d6a6aa28cdb76515efbcb0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer-file-coding-system&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; affect sending text to a subprocess.</source>
          <target state="translated">&lt;code&gt;buffer-file-coding-system&lt;/code&gt; никак &lt;em&gt;не&lt;/em&gt; влияет на отправку текста в подпроцесс.</target>
        </trans-unit>
        <trans-unit id="107c725c617b4da70945aecf0c2954c9beb9b006" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; establishes a return point for the &lt;code&gt;throw&lt;/code&gt; function. The return point is distinguished from other such return points by &lt;var&gt;tag&lt;/var&gt;, which may be any Lisp object except &lt;code&gt;nil&lt;/code&gt;. The argument &lt;var&gt;tag&lt;/var&gt; is evaluated normally before the return point is established.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; устанавливает точку возврата для функции &lt;code&gt;throw&lt;/code&gt; . Точка возврата отличается от других подобных точек возврата &lt;var&gt;tag&lt;/var&gt; , который может быть любым объектом Lisp, кроме &lt;code&gt;nil&lt;/code&gt; . &lt;var&gt;tag&lt;/var&gt; аргумента обычно оценивается до установления точки возврата.</target>
        </trans-unit>
        <trans-unit id="156ce65ca7942c7ecfd976b8e12a4e9225a1417d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close-notification&lt;/code&gt; if the notification was closed by a call to &lt;code&gt;notifications-close-notification&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;close-notification&lt;/code&gt; , если уведомление было закрыто вызовом &lt;code&gt;notifications-close-notification&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="344540fc9932e2a7fe71c70a031687cce00941a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cntrl&lt;/code&gt;, &lt;code&gt;control&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;control&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3abbbe55e10afc6f9cf312b234ef5f28aa43d773" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compile-defun&lt;/code&gt; normally displays the result of evaluation in the echo area, but if &lt;var&gt;arg&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it inserts the result in the current buffer after the form it has compiled.</source>
          <target state="translated">&lt;code&gt;compile-defun&lt;/code&gt; обычно отображает результат вычисления в эхо-области, но если &lt;var&gt;arg&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , он вставляет результат в текущий буфер после формы, которую он скомпилировал.</target>
        </trans-unit>
        <trans-unit id="0f9e94627d25b926f591b1e1c255e6cd7722db03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completing-read&lt;/code&gt; uses this value as the local keymap when an exact match of one of the completions is not required. By default, this keymap makes the following bindings:</source>
          <target state="translated">&lt;code&gt;completing-read&lt;/code&gt; использует это значение как локальную таблицу ключей, когда точное совпадение одного из завершений не требуется. По умолчанию эта раскладка имеет следующие привязки:</target>
        </trans-unit>
        <trans-unit id="74ad6806c122f9cb293d13928c1c9f99fd4f37a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completing-read&lt;/code&gt; uses this value as the local keymap when an exact match of one of the completions is required. Therefore, no keys are bound to &lt;code&gt;exit-minibuffer&lt;/code&gt;, the command that exits the minibuffer unconditionally. By default, this keymap makes the following bindings:</source>
          <target state="translated">&lt;code&gt;completing-read&lt;/code&gt; использует это значение в качестве локальной раскладки клавиатуры, когда требуется точное совпадение одного из завершений. Следовательно, никакие ключи не привязаны к &lt;code&gt;exit-minibuffer&lt;/code&gt; , команде, которая безоговорочно выходит из минибуфера. По умолчанию эта раскладка имеет следующие привязки:</target>
        </trans-unit>
        <trans-unit id="c2ce8658f4068cd02c2cf6c073921a3359734353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond&lt;/code&gt; chooses among an arbitrary number of alternatives. Each &lt;var&gt;clause&lt;/var&gt; in the &lt;code&gt;cond&lt;/code&gt; must be a list. The &lt;small&gt;CAR&lt;/small&gt; of this list is the &lt;var&gt;condition&lt;/var&gt;; the remaining elements, if any, the &lt;var&gt;body-forms&lt;/var&gt;. Thus, a clause looks like this:</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; выбирает из произвольного числа альтернатив. Каждое &lt;var&gt;clause&lt;/var&gt; в &lt;code&gt;cond&lt;/code&gt; должно быть списком. &lt;small&gt;CAR&lt;/small&gt; этого списка является &lt;var&gt;condition&lt;/var&gt; ; остальные элементы, если есть, &lt;var&gt;body-forms&lt;/var&gt; . Таким образом, предложение выглядит так:</target>
        </trans-unit>
        <trans-unit id="d86b25e6a88950288688d5cde9d105628656c282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond&lt;/code&gt; tries the clauses in textual order, by evaluating the &lt;var&gt;condition&lt;/var&gt; of each clause. If the value of &lt;var&gt;condition&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the clause succeeds; then &lt;code&gt;cond&lt;/code&gt; evaluates its &lt;var&gt;body-forms&lt;/var&gt;, and returns the value of the last of &lt;var&gt;body-forms&lt;/var&gt;. Any remaining clauses are ignored.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; пробует предложения в текстовом порядке, оценивая &lt;var&gt;condition&lt;/var&gt; каждого предложения. Если значение &lt;var&gt;condition&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , предложение выполняется; затем &lt;code&gt;cond&lt;/code&gt; оценивает свои &lt;var&gt;body-forms&lt;/var&gt; и возвращает значение последней из &lt;var&gt;body-forms&lt;/var&gt; . Все остальные пункты игнорируются.</target>
        </trans-unit>
        <trans-unit id="fdb0af8dfd8be2e8ae3cbfe120787af9b87bf7b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition-case&lt;/code&gt; (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;condition-case&lt;/code&gt; (см. &lt;a href=&quot;errors#Errors&quot;&gt;Ошибки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a6580f4efb6d6c9f789a125e8465845469547a7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition-notify&lt;/code&gt; releases the associated mutex while waiting. This allows other threads to acquire the mutex in order to wait on the condition.</source>
          <target state="translated">&lt;code&gt;condition-notify&lt;/code&gt; освобождает связанный мьютекс во время ожидания. Это позволяет другим потокам получать мьютекс для ожидания выполнения условия.</target>
        </trans-unit>
        <trans-unit id="8437ca185db531b06367cb4346d8260607338a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition-wait&lt;/code&gt; releases the associated mutex while waiting. This allows other threads to acquire the mutex in order to notify the condition.</source>
          <target state="translated">&lt;code&gt;condition-wait&lt;/code&gt; освобождает связанный мьютекс во время ожидания. Это позволяет другим потокам получать мьютекс для уведомления об условии.</target>
        </trans-unit>
        <trans-unit id="ccd4e34801f17b7a3fc04d72bc18102aa79bedcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cons&lt;/code&gt; is often used to add a single element to the front of a list. This is called &lt;em&gt;consing the element onto the list&lt;/em&gt;. &lt;a href=&quot;#FOOT4&quot; name=&quot;DOCF4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; For example:</source>
          <target state="translated">&lt;code&gt;cons&lt;/code&gt; часто используется для добавления одного элемента в начало списка. Это называется &lt;em&gt;включением элемента в список&lt;/em&gt; . &lt;a href=&quot;#FOOT4&quot; name=&quot;DOCF4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; Например:</target>
        </trans-unit>
        <trans-unit id="b38a6ad2ed893ce1ea657ffbd022f9f0ab0a4705" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctl-x-4-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;ctl-x-4-map&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="036bac0feee09c67b7f81e2405656a5bd88c0a36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctl-x-5-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;ctl-x-5-map&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="645c950388b00cd4f5f82802b0b36167e7f5cab9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctl-x-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;ctl-x-map&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="bc2d1647b4cc96f41ed5000b4f82d722e0eedffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current-local-map&lt;/code&gt; returns a reference to the local keymap, not a copy of it; if you use &lt;code&gt;define-key&lt;/code&gt; or other functions on it you will alter local bindings.</source>
          <target state="translated">&lt;code&gt;current-local-map&lt;/code&gt; возвращает ссылку на локальную раскладку клавиатуры, а не ее копию; если вы используете на нем &lt;code&gt;define-key&lt;/code&gt; или другие функции, вы измените локальные привязки.</target>
        </trans-unit>
        <trans-unit id="51c9fd0ac637d6e499a4fa7b3f7d1d6a62ef6a86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cursor-in-echo-area&lt;/code&gt; is locally bound to &lt;code&gt;nil&lt;/code&gt; so that the cursor shows up in the window.</source>
          <target state="translated">&lt;code&gt;cursor-in-echo-area&lt;/code&gt; локально привязан к &lt;code&gt;nil&lt;/code&gt; так что курсор отображается в окне.</target>
        </trans-unit>
        <trans-unit id="dde4dbb3472d8335edeac01bd24bdb83e60b9415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data-directory&lt;/code&gt;/images</source>
          <target state="translated">&lt;code&gt;data-directory&lt;/code&gt;/images</target>
        </trans-unit>
        <trans-unit id="934a2252e658e61b0e8e140170bcdaf3db4fe9a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debug&lt;/code&gt; as first argument means &lt;code&gt;debug&lt;/code&gt; was called because of entry to a function that was set to debug on entry. The debugger displays the string &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; в качестве первого аргумента означает, что &lt;code&gt;debug&lt;/code&gt; была вызвана из-за входа в функцию, которая была настроена на отладку при входе. Отладчик отображает строку '</target>
        </trans-unit>
        <trans-unit id="5408ee3a5ae30f1b73e2236ceb15094b6b7e60de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declare&lt;/code&gt; is a special macro which can be used to add meta properties to a function or macro: for example, marking it as obsolete, or giving its forms a special</source>
          <target state="translated">&lt;code&gt;declare&lt;/code&gt; - это специальный макрос, который можно использовать для добавления мета-свойств к функции или макросу: например, пометить его как устаревший или придать его формам особый вид.</target>
        </trans-unit>
        <trans-unit id="e948495adb03f74ecb74007271523cddadcd35a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default-boundp&lt;/code&gt; is to &lt;code&gt;default-value&lt;/code&gt; as &lt;code&gt;boundp&lt;/code&gt; is to &lt;code&gt;symbol-value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default-boundp&lt;/code&gt; имеет &lt;code&gt;default-value&lt;/code&gt; по умолчанию, как &lt;code&gt;boundp&lt;/code&gt; - значение &lt;code&gt;symbol-value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f750ad0e57affc67c45a2f12853a28fd6ccb4c86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defconst&lt;/code&gt; always evaluates &lt;var&gt;value&lt;/var&gt;, and sets the value of &lt;var&gt;symbol&lt;/var&gt; to the result. If &lt;var&gt;symbol&lt;/var&gt; does have a buffer-local binding in the current buffer, &lt;code&gt;defconst&lt;/code&gt; sets the default value, not the buffer-local value. (But you should not be making buffer-local bindings for a symbol that is defined with &lt;code&gt;defconst&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;defconst&lt;/code&gt; всегда оценивает &lt;var&gt;value&lt;/var&gt; и устанавливает значение &lt;var&gt;symbol&lt;/var&gt; для результата. Если &lt;var&gt;symbol&lt;/var&gt; имеет привязку к локальному буферу в текущем буфере, &lt;code&gt;defconst&lt;/code&gt; устанавливает значение по умолчанию, а не значение локального буфера. (Но вы не должны делать привязки к локальному буферу для символа, определенного с помощью &lt;code&gt;defconst&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="12dee0792bdf9b486bfd740498d0eadb2c152801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defcustom&lt;/code&gt;, &lt;code&gt;defgroup&lt;/code&gt;, &lt;code&gt;defclass&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/index.html#Top&quot;&gt;EIEIO&lt;/a&gt; in</source>
          <target state="translated">&lt;code&gt;defcustom&lt;/code&gt; , &lt;code&gt;defgroup&lt;/code&gt; , &lt;code&gt;defclass&lt;/code&gt; (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/index.html#Top&quot;&gt;EIEIO&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="54bb1f50ab14a735a951d4b885d4c78dfb0a077b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defcustom&lt;/code&gt;, &lt;code&gt;defgroup&lt;/code&gt;, &lt;code&gt;defclass&lt;/code&gt; (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/eieio/index.html#Top&quot;&gt;EIEIO&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012f5d01fd0d5a5d01a85ae0f6957fec801c9a45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defimage&lt;/code&gt; tests each argument, one by one, to see if it is usable&amp;mdash;that is, if the type is supported and the file exists. The first usable argument is used to make an image descriptor which is stored in &lt;var&gt;symbol&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;defimage&lt;/code&gt; проверяет каждый аргумент один за другим, чтобы увидеть, можно ли его использовать - то есть, поддерживается ли тип и существует ли файл. Первый используемый аргумент используется для создания дескриптора изображения, который хранится в &lt;var&gt;symbol&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="65612ea68e9ef580a07b967a84376d66e7d1511f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;define-abbrev&lt;/code&gt; is the low-level basic function for defining an abbrev in an abbrev table.</source>
          <target state="translated">&lt;code&gt;define-abbrev&lt;/code&gt; - это базовая функция нижнего уровня для определения сокращения в таблице сокращений.</target>
        </trans-unit>
        <trans-unit id="f93257cd24b7904a7e36862707a2b00198231632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;define-minor-mode&lt;/code&gt;, &lt;code&gt;define-globalized-minor-mode&lt;/code&gt;, &lt;code&gt;define-generic-mode&lt;/code&gt;, &lt;code&gt;define-derived-mode&lt;/code&gt;, &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt;, &lt;code&gt;easy-mmode-define-global-mode&lt;/code&gt;, &lt;code&gt;define-compilation-mode&lt;/code&gt;, and &lt;code&gt;define-global-minor-mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;define-minor-mode&lt;/code&gt; , &lt;code&gt;define-globalized-minor-mode&lt;/code&gt; , &lt;code&gt;define-generic-mode&lt;/code&gt; , &lt;code&gt;define-derived-mode&lt;/code&gt; , &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt; , &lt;code&gt;easy-mmode-define-global-mode&lt;/code&gt; , &lt;code&gt;define-compilation-mode&lt;/code&gt; и &lt;code&gt;define-global-minor-mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ad858ca1737d12f8ddf97a19595ffe87722585d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defmacro&lt;/code&gt; defines a symbol as a macro. It creates a macro object and stores it in the function cell of the symbol. Note that a given symbol can be a macro or a function, but not both at once, because both macro and function definitions are kept in the function cell, and that cell can hold only one Lisp object at any given time. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defmacro&lt;/code&gt; определяет символ как макрос. Он создает макрообъект и сохраняет его в функциональной ячейке символа. Обратите внимание, что данный символ может быть макросом или функцией, но не обоими сразу, потому что и макроопределения, и определения функции хранятся в функциональной ячейке, и эта ячейка может содержать только один объект Lisp в любой момент времени. См. &lt;a href=&quot;macros#Macros&quot;&gt;Макросы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb8d765d8f8a2f740e70c10fe1ba95bc9a6f3810" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defmacro&lt;/code&gt; defines the symbol &lt;var&gt;name&lt;/var&gt; (which should not be quoted) as a macro that looks like this:</source>
          <target state="translated">&lt;code&gt;defmacro&lt;/code&gt; определяет &lt;var&gt;name&lt;/var&gt; символа (которое не следует заключать в кавычки) как макрос, который выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="01769f0bc967504ad48bb76fcab17f7c05016973" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; and &lt;code&gt;defmacro&lt;/code&gt;; also &lt;code&gt;cl-defun&lt;/code&gt; and &lt;code&gt;cl-defmacro&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Argument-Lists.html#Argument-Lists&quot;&gt;Argument Lists&lt;/a&gt; in</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; и &lt;code&gt;defmacro&lt;/code&gt; ; также &lt;code&gt;cl-defun&lt;/code&gt; и &lt;code&gt;cl-defmacro&lt;/code&gt; (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Argument-Lists.html#Argument-Lists&quot;&gt;Списки аргументов&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="fdeb0221bdad3aa7352167f421035f58d801147c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; and &lt;code&gt;defmacro&lt;/code&gt;; also &lt;code&gt;cl-defun&lt;/code&gt; and &lt;code&gt;cl-defmacro&lt;/code&gt; (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/cl/Argument-Lists.html#Argument-Lists&quot;&gt;Argument Lists&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b647875bc6007b6250b773099308720656737afa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; defines a symbol as a function, creating a lambda expression and storing it in the function cell of the symbol. This lambda expression thus becomes the function definition of the symbol. (The term &amp;ldquo;function definition&amp;rdquo;, meaning the contents of the function cell, is derived from the idea that &lt;code&gt;defun&lt;/code&gt; gives the symbol its definition as a function.) &lt;code&gt;defsubst&lt;/code&gt; and &lt;code&gt;defalias&lt;/code&gt; are two other ways of defining a function. See &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; определяет символ как функцию, создавая лямбда-выражение и сохраняя его в функциональной ячейке символа. Таким образом, это лямбда-выражение становится определением функции символа. (Термин &amp;laquo;определение функции&amp;raquo;, означающий содержимое ячейки функции, происходит от идеи, что &lt;code&gt;defun&lt;/code&gt; дает символу его определение как функцию.) &lt;code&gt;defsubst&lt;/code&gt; и &lt;code&gt;defalias&lt;/code&gt; - это два других способа определения функции. См. &lt;a href=&quot;functions#Functions&quot;&gt;Функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="152769b81ca9a1e399de93e4483e4b2b25d12e27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; is the usual way to define new Lisp functions. It defines the symbol &lt;var&gt;name&lt;/var&gt; as a function with argument list &lt;var&gt;args&lt;/var&gt; and body forms given by &lt;var&gt;body&lt;/var&gt;. Neither &lt;var&gt;name&lt;/var&gt; nor &lt;var&gt;args&lt;/var&gt; should be quoted.</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; - это обычный способ определения новых функций Lisp. Он определяет &lt;var&gt;name&lt;/var&gt; символа как функцию с аргументами списка &lt;var&gt;args&lt;/var&gt; и формами тела, заданными &lt;var&gt;body&lt;/var&gt; . Ни &lt;var&gt;name&lt;/var&gt; ни &lt;var&gt;args&lt;/var&gt; должны цитироваться.</target>
        </trans-unit>
        <trans-unit id="56917c3bbaff8b95c5489feaa298d6f87beca6dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defvar&lt;/code&gt; and &lt;code&gt;defconst&lt;/code&gt; are special forms that define a symbol as a &lt;em&gt;global variable&lt;/em&gt;&amp;mdash;a variable that can be accessed at any point in a Lisp program. See &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;, for details about variables. To define a customizable variable, use the &lt;code&gt;defcustom&lt;/code&gt; macro, which also calls &lt;code&gt;defvar&lt;/code&gt; as a subroutine (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;defvar&lt;/code&gt; и &lt;code&gt;defconst&lt;/code&gt; - это специальные формы, которые определяют символ как &lt;em&gt;глобальную переменную&lt;/em&gt; - переменную, к которой можно получить доступ в любой точке программы на Лиспе. См. &amp;laquo; &lt;a href=&quot;variables#Variables&quot;&gt;Переменные&amp;raquo;&lt;/a&gt; для получения подробной информации о переменных. Чтобы определить настраиваемую переменную, используйте макрос &lt;code&gt;defcustom&lt;/code&gt; , который также вызывает &lt;code&gt;defvar&lt;/code&gt; как подпрограмму (см. &lt;a href=&quot;customization#Customization&quot;&gt;Настройка&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3eb2267cae74dc899c4fbba26cfe21e3ea5b6517" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete-blank-lines&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delete-blank-lines&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f840984ec3795b6f839ea590accd0745c89aaf79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete-directory&lt;/code&gt; only follows symbolic links at the level of parent directories.</source>
          <target state="translated">&lt;code&gt;delete-directory&lt;/code&gt; следует только по символическим ссылкам на уровне родительских каталогов.</target>
        </trans-unit>
        <trans-unit id="8b4225e31b19638d22dc17fbb44550f51340cfd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;digit&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;num&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;num&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a908719f62b48c099dab98a459ed559d227965c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dismissed&lt;/code&gt; if the notification was dismissed by the user</source>
          <target state="translated">&lt;code&gt;dismissed&lt;/code&gt; если уведомление было отклонено пользователем</target>
        </trans-unit>
        <trans-unit id="e907d769ab6400ef158c183eb829b092f502e5ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer-alist&lt;/code&gt; and &lt;code&gt;display-buffer-base-action&lt;/code&gt; are user options&amp;mdash;Lisp programs must never set or rebind them. &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, on the other hand, is reserved for applications&amp;mdash;who seldom use that option and if they use it, then with utmost care.</source>
          <target state="translated">&lt;code&gt;display-buffer-alist&lt;/code&gt; и &lt;code&gt;display-buffer-base-action&lt;/code&gt; - это параметры пользователя - программы на Лиспе никогда не должны устанавливать или повторно связывать их. &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; , с другой стороны, зарезервирован для приложений, которые редко используют эту опцию, а если они используют ее, то с особой осторожностью.</target>
        </trans-unit>
        <trans-unit id="14d1ad1d34836cb877fe7eddc4cca15ca9bee5c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; calls the action functions specified by this list in turn, passing the buffer as the first argument and the combined action alist as the second argument, until one of the functions returns non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;Precedence of Action Functions&lt;/a&gt;, for examples how display actions specified by different sources are processed by &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; по очереди вызывает функции действий, указанные в этом списке, передавая буфер в качестве первого аргумента и объединенный список действий в качестве второго аргумента, пока одна из функций не вернет значение, отличное от &lt;code&gt;nil&lt;/code&gt; . См. &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;Приоритет функций действий&lt;/a&gt; , где приведены примеры того, как отображаемые действия, указанные из разных источников, обрабатываются &lt;code&gt;display-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee6044593bc3c007fee9246a9041dc268f757d82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; delegates the task of finding a suitable window to so-called action functions (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;). First, &lt;code&gt;display-buffer&lt;/code&gt; compiles a so-called action alist&amp;mdash;a special association list that action functions can use to fine-tune their behavior. Then it passes that alist on to each action function it calls (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; делегирует задачу поиска подходящего окна так называемым функциям действий (см. &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Функции действий отображения буфера&lt;/a&gt; ). Во-первых, &lt;code&gt;display-buffer&lt;/code&gt; составляет так называемый список действий - специальный список ассоциаций, который функции действий могут использовать для точной настройки своего поведения. Затем он передает этот список каждой &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;вызываемой им&lt;/a&gt; функции действия (см. Списки действий отображения буфера ).</target>
        </trans-unit>
        <trans-unit id="f227d53c9e56460fd790779757e8a90bd347614f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; is not overly well suited for displaying several buffers in sequence and making sure that all these buffers are shown orderly in the resulting window configuration. Again, the standard action functions &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; and &lt;code&gt;display-buffer-use-some-window&lt;/code&gt; are not very suited for this purpose due to their somewhat chaotic nature in more complex configurations.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; не слишком хорошо подходит для последовательного отображения нескольких буферов и проверки того, что все эти буферы отображаются упорядоченно в результирующей конфигурации окна. Опять же, стандартные функции действий &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; и &lt;code&gt;display-buffer-use-some-window&lt;/code&gt; не очень подходят для этой цели из-за их несколько хаотичной природы в более сложных конфигурациях.</target>
        </trans-unit>
        <trans-unit id="d64a554d77989581707b51f284c6e6248aa81ec2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; works by combining display actions from several sources, and calling the action functions in turn, until one of them manages to display the buffer and returns a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; работает, комбинируя действия отображения из нескольких источников и вызывая функции действий по очереди, пока одному из них не удастся отобразить буфер и не &lt;code&gt;nil&lt;/code&gt; значение, отличное от нуля .</target>
        </trans-unit>
        <trans-unit id="c1d4765f3824d06ce66d790e3171caf102615dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edebug-tracing&lt;/code&gt; and &lt;code&gt;edebug-trace&lt;/code&gt; insert lines in the trace buffer whenever they are called, even if Edebug is not active. Adding text to the trace buffer also scrolls its window to show the last lines inserted.</source>
          <target state="translated">&lt;code&gt;edebug-tracing&lt;/code&gt; и &lt;code&gt;edebug-trace&lt;/code&gt; вставляют строки в буфер трассировки всякий раз, когда они вызываются, даже если Edebug не активен. Добавление текста в буфер трассировки также прокручивает его окно, чтобы показать последние вставленные строки.</target>
        </trans-unit>
        <trans-unit id="a3f2415c34e4a3793e8232f202cffcf43789c5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt; works by calling &lt;code&gt;signal&lt;/code&gt; with two arguments: the error symbol &lt;code&gt;error&lt;/code&gt;, and a list containing the string returned by &lt;code&gt;format-message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; работает, вызывая &lt;code&gt;signal&lt;/code&gt; с двумя аргументами: ошибкой символа &lt;code&gt;error&lt;/code&gt; и списком, содержащим строку, возвращаемую &lt;code&gt;format-message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6880af6d200f2ca04ff4195004b0ab2299113fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esc-map&lt;/code&gt; is the global keymap for the</source>
          <target state="translated">&lt;code&gt;esc-map&lt;/code&gt; - это глобальная раскладка клавиатуры для</target>
        </trans-unit>
        <trans-unit id="7f8cd7311207af652cc522fd80e074dcb6e7e056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval-current-buffer&lt;/code&gt; is an alias for this command.</source>
          <target state="translated">&lt;code&gt;eval-current-buffer&lt;/code&gt; - это псевдоним для этой команды.</target>
        </trans-unit>
        <trans-unit id="56f57ab8e49b20109332e2ec24f457692e98e579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval-region&lt;/code&gt; does not move point. It always returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eval-region&lt;/code&gt; не перемещает точку. Он всегда возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ad1f65d94f09547d3da4083875674afe6e969a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exclamation-mark&lt;/code&gt;, &lt;code&gt;question-mark&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exclamation-mark&lt;/code&gt; , &lt;code&gt;question-mark&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40521d850dea7dce49a507b35bd302f3a54c8926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;execute-extended-command&lt;/code&gt; is the normal definition of</source>
          <target state="translated">&lt;code&gt;execute-extended-command&lt;/code&gt; - обычное определение</target>
        </trans-unit>
        <trans-unit id="6cf89b7da2a6174c3f8e679617a63de5d2e383ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand-file-name&lt;/code&gt; uses the default directory when its second argument is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expand-file-name&lt;/code&gt; использует каталог по умолчанию, когда его второй аргумент равен &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c9062e5a9494acbeb71a2172655b2ae069bc217" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expired&lt;/code&gt; if the notification has expired</source>
          <target state="translated">&lt;code&gt;expired&lt;/code&gt; если срок уведомления истек</target>
        </trans-unit>
        <trans-unit id="d53f261a510c119d203db947e2ce5638e5bea95c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;facemenu-keymap&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;facemenu-keymap&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="96b2d34869a0042346118c9a1c97c40bcab3a087" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file-name-completion&lt;/code&gt; usually ignores file names that end in any string in this list. It does not ignore them when all the possible completions end in one of these suffixes. This variable has no effect on &lt;code&gt;file-name-all-completions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file-name-completion&lt;/code&gt; файла обычно игнорирует имена файлов, которые заканчиваются любой строкой в ​​этом списке. Он не игнорирует их, когда все возможные варианты завершения заканчиваются одним из этих суффиксов. Эта переменная не влияет на &lt;code&gt;file-name-all-completions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3f4cf9c9f44781f17e7b70a6e9267aa8b348f35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filled-rectangle&lt;/code&gt;, &lt;code&gt;hollow-rectangle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;filled-rectangle&lt;/code&gt; , &lt;code&gt;hollow-rectangle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63b0bf27eaf099c7a2aba78987210d1f60b20dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filled-square&lt;/code&gt;, &lt;code&gt;hollow-square&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;filled-square&lt;/code&gt; , &lt;code&gt;hollow-square&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b151e0b46584e52a571005d89553b79e3782e2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt;: Emacs&amp;rsquo;s analogue of &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; : аналог &lt;code&gt;printf&lt;/code&gt; в Emacs .</target>
        </trans-unit>
        <trans-unit id="0319a37175b95184201be0902c9bbe3c803de352" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward-line&lt;/code&gt; returns the difference between &lt;var&gt;count&lt;/var&gt; and the number of lines actually moved. If you attempt to move down five lines from the beginning of a buffer that has only three lines, point stops at the end of the last line, and the value will be 2. As an explicit exception, if the last accessible line is non-empty, but has no newline (e.g., if the buffer ends without a newline), the function sets point to the end of that line, and the value returned by the function counts that line as one line successfully moved.</source>
          <target state="translated">&lt;code&gt;forward-line&lt;/code&gt; возвращает разницу между &lt;var&gt;count&lt;/var&gt; и количеством фактически перемещенных строк. Если вы попытаетесь переместиться на пять строк вниз от начала буфера, состоящего только из трех строк, точка остановится в конце последней строки, и значение будет равно 2. В качестве явного исключения, если последняя доступная строка не- пусто, но не имеет новой строки (например, если буфер заканчивается без новой строки), функция устанавливает точку в конец этой строки, а значение, возвращаемое функцией, считает эту строку одной успешно перемещенной.</target>
        </trans-unit>
        <trans-unit id="9fb006a1606ebf156dd571dfdde441e64a22ee51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;funcall&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; with &lt;var&gt;arguments&lt;/var&gt;, and returns whatever &lt;var&gt;function&lt;/var&gt; returns.</source>
          <target state="translated">&lt;code&gt;funcall&lt;/code&gt; вызывает &lt;var&gt;function&lt;/var&gt; с &lt;var&gt;arguments&lt;/var&gt; и возвращает то, что возвращает &lt;var&gt;function&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="5ee061b6998fb423f324fd8ff9a9a90f8bd371bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;garbage-collect&lt;/code&gt; returns a list with information on amount of space in use, where each entry has the form &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;garbage-collect&lt;/code&gt; возвращает список с информацией об объеме используемого пространства, где каждая запись имеет форму '</target>
        </trans-unit>
        <trans-unit id="e8f473f7afedf2216e2bb733f7d1ce2bfec20e81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goto-char&lt;/code&gt; returns &lt;var&gt;position&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;goto-char&lt;/code&gt; возвращает &lt;var&gt;position&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="66c22645f673d359bd032afd87fb1bda780e5783" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goto-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;goto-map&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="8eac353d9cbc652ce59f1d95e7cab268e9264776" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;graph&lt;/code&gt;, &lt;code&gt;graphic&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;graphic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc4b408f601dfd18211762a1f31289581f4d6d7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;help-map&lt;/code&gt; is the global keymap for the</source>
          <target state="translated">&lt;code&gt;help-map&lt;/code&gt; - это глобальная раскладка клавиатуры для</target>
        </trans-unit>
        <trans-unit id="d8a2acd22017b9816e7a1b9eb88b311cea6e2d74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; chooses between the &lt;var&gt;then-form&lt;/var&gt; and the &lt;var&gt;else-forms&lt;/var&gt; based on the value of &lt;var&gt;condition&lt;/var&gt;. If the evaluated &lt;var&gt;condition&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;then-form&lt;/var&gt; is evaluated and the result returned. Otherwise, the &lt;var&gt;else-forms&lt;/var&gt; are evaluated in textual order, and the value of the last one is returned. (The &lt;var&gt;else&lt;/var&gt; part of &lt;code&gt;if&lt;/code&gt; is an example of an implicit &lt;code&gt;progn&lt;/code&gt;. See &lt;a href=&quot;sequencing#Sequencing&quot;&gt;Sequencing&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; выбирает между &lt;var&gt;then-form&lt;/var&gt; и &lt;var&gt;else-forms&lt;/var&gt; на основе значения &lt;var&gt;condition&lt;/var&gt; . Если оцененное &lt;var&gt;condition&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;then-form&lt;/var&gt; вычисляется форма и возвращается результат. В противном случае &lt;var&gt;else-forms&lt;/var&gt; оцениваются в текстовом порядке, и возвращается значение последней. (Часть &lt;var&gt;else&lt;/var&gt; в &lt;code&gt;if&lt;/code&gt; является примером неявного &lt;code&gt;progn&lt;/code&gt; . См. &lt;a href=&quot;sequencing#Sequencing&quot;&gt;Последовательность&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a54485aa58de9cb2289aa67ac7fdf50fdb9aa0df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; is a special form because the branch that is not selected is never evaluated&amp;mdash;it is ignored. Thus, in this example, &lt;code&gt;true&lt;/code&gt; is not printed because &lt;code&gt;print&lt;/code&gt; is never called:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; - это особая форма, потому что невыбранная ветвь никогда не оценивается - она ​​игнорируется. Таким образом, в этом примере &lt;code&gt;true&lt;/code&gt; не печатается, потому что &lt;code&gt;print&lt;/code&gt; никогда не вызывается:</target>
        </trans-unit>
        <trans-unit id="6ef7e796b7e6b6881e2794286c19b66d90407fc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; , &lt;code&gt;cond&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56df690091e9e1e1d78c541ae39c8a9446bfb9c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indent-region&lt;/code&gt; with a non-&lt;code&gt;nil&lt;/code&gt; argument &lt;var&gt;to-column&lt;/var&gt; has a different meaning and does not use this variable.</source>
          <target state="translated">&lt;code&gt;indent-region&lt;/code&gt; с аргументом &lt;var&gt;to-column&lt;/var&gt; , отличным от &lt;code&gt;nil&lt;/code&gt; , имеет другое значение и не использует эту переменную.</target>
        </trans-unit>
        <trans-unit id="29940b6669ea18ccc514f7f5deaf6a35beb7ed92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inhibit-startup-message&lt;/code&gt; and &lt;code&gt;inhibit-splash-screen&lt;/code&gt; are aliases for this variable.</source>
          <target state="translated">&lt;code&gt;inhibit-startup-message&lt;/code&gt; и &lt;code&gt;inhibit-splash-screen&lt;/code&gt; - псевдонимы для этой переменной.</target>
        </trans-unit>
        <trans-unit id="29a11d8eb74550c13ad46f3f07785cf2e8353c3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert-file-contents&lt;/code&gt; and &lt;code&gt;write-region&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;insert-file-contents&lt;/code&gt; и &lt;code&gt;write-region&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc1819efabcf2c79e08931073dd0c99baeef175f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int-to-string&lt;/code&gt; is a semi-obsolete alias for this function.</source>
          <target state="translated">&lt;code&gt;int-to-string&lt;/code&gt; - это полу-устаревший псевдоним для этой функции.</target>
        </trans-unit>
        <trans-unit id="cb18fb2d174e74648ae14f7c5881fe0d47fa5e84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter-defun&lt;/code&gt; defines a generator function. A generator function has the same signature as a normal function, but works differently. Instead of executing &lt;var&gt;body&lt;/var&gt; when called, a generator function returns an iterator object. That iterator runs &lt;var&gt;body&lt;/var&gt; to generate values, emitting a value and pausing where &lt;code&gt;iter-yield&lt;/code&gt; or &lt;code&gt;iter-yield-from&lt;/code&gt; appears. When &lt;var&gt;body&lt;/var&gt; returns normally, &lt;code&gt;iter-next&lt;/code&gt; signals &lt;code&gt;iter-end-of-sequence&lt;/code&gt; with &lt;var&gt;body&lt;/var&gt;&amp;rsquo;s result as its condition data.</source>
          <target state="translated">&lt;code&gt;iter-defun&lt;/code&gt; определяет функцию генератора. Функция генератора имеет ту же сигнатуру, что и обычная функция, но работает иначе. Вместо выполнения &lt;var&gt;body&lt;/var&gt; при вызове функция генератора возвращает объект-итератор. Этот итератор запускает &lt;var&gt;body&lt;/var&gt; для генерации значений, генерируя значение и делая паузу там, где появляется &lt;code&gt;iter-yield&lt;/code&gt; или &lt;code&gt;iter-yield-from&lt;/code&gt; . Когда &lt;var&gt;body&lt;/var&gt; возвращается в обычном режиме, &lt;code&gt;iter-next&lt;/code&gt; сигнализирует &lt;code&gt;iter-end-of-sequence&lt;/code&gt; с результатом &lt;var&gt;body&lt;/var&gt; качестве данных состояния.</target>
        </trans-unit>
        <trans-unit id="4109e5aa6a1bfade7fb636b24ed135f433d38221" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter-lambda&lt;/code&gt; produces an unnamed generator function that works just like a generator function produced with &lt;code&gt;iter-defun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter-lambda&lt;/code&gt; создает безымянную функцию генератора, которая работает так же, как функция генератора, созданная с помощью &lt;code&gt;iter-defun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d98457ad8a543fbfb81705f5a8344cb739a07d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter-yield-from&lt;/code&gt; yields all the values that &lt;var&gt;iterator&lt;/var&gt; produces and evaluates to the value that &lt;var&gt;iterator&lt;/var&gt;&amp;rsquo;s generator function returns normally. While it has control, &lt;var&gt;iterator&lt;/var&gt; receives values sent to the iterator using &lt;code&gt;iter-next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter-yield-from&lt;/code&gt; выходов всех значений , которые &lt;var&gt;iterator&lt;/var&gt; производит и вычисляет значение , которое &lt;var&gt;iterator&lt;/var&gt; &amp;laquo;ы функция генератора возвращается нормально. Пока у него есть управление, &lt;var&gt;iterator&lt;/var&gt; получает значения, отправленные итератору с помощью &lt;code&gt;iter-next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76d4e792a718ab7a155f494cc528e3c2ff57d59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-all-local-variables&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kill-all-local-variables&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16db06500a347a02d731c188dee9c19d07a423c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-line&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; remapped to &lt;code&gt;my-other-kill-line&lt;/code&gt;. Instead, if an ordinary key binding specifies &lt;code&gt;kill-line&lt;/code&gt;, it is remapped to &lt;code&gt;my-kill-line&lt;/code&gt;; if an ordinary binding specifies &lt;code&gt;my-kill-line&lt;/code&gt;, it is remapped to &lt;code&gt;my-other-kill-line&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kill-line&lt;/code&gt; это &lt;em&gt;не&lt;/em&gt; переназначена к &lt;code&gt;my-other-kill-line&lt;/code&gt; . Вместо этого, если обычная привязка клавиш определяет &lt;code&gt;kill-line&lt;/code&gt; , она переназначается на &lt;code&gt;my-kill-line&lt;/code&gt; ; если обычная привязка указывает &lt;code&gt;my-kill-line&lt;/code&gt; , она переназначается на &lt;code&gt;my-other-kill-line&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ccd36137fe5b6a475fa203ddbbe785c93b64de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-local-variable&lt;/code&gt; returns &lt;var&gt;variable&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;kill-local-variable&lt;/code&gt; возвращает &lt;var&gt;variable&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ea41619b9bb6734de2a51b35884577b932079033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-region&lt;/code&gt; is the usual subroutine for killing text. Any command that calls this function is a kill command (and should probably have &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;kill-region&lt;/code&gt; - обычная подпрограмма для уничтожения текста. Любая команда, вызывающая эту функцию, является командой уничтожения (и, вероятно, должна иметь '</target>
        </trans-unit>
        <trans-unit id="ac6b1ea9968bed95795df33bf349e7fcfc89e356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-0&lt;/code&gt;, &lt;code&gt;kp-1&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">&lt;code&gt;kp-0&lt;/code&gt; , &lt;code&gt;kp-1&lt;/code&gt; ,&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="96bb856bea3cba200a8e8092b22bcd8017da69ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-add&lt;/code&gt;, &lt;code&gt;kp-decimal&lt;/code&gt;, &lt;code&gt;kp-divide&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">&lt;code&gt;kp-add&lt;/code&gt; , &lt;code&gt;kp-decimal&lt;/code&gt; , &lt;code&gt;kp-divide&lt;/code&gt; ,&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9273b099ca4265ff47245a822044a6a00d6b8dfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-f1&lt;/code&gt;, &lt;code&gt;kp-f2&lt;/code&gt;, &lt;code&gt;kp-f3&lt;/code&gt;, &lt;code&gt;kp-f4&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kp-f1&lt;/code&gt; , &lt;code&gt;kp-f2&lt;/code&gt; , &lt;code&gt;kp-f3&lt;/code&gt; , &lt;code&gt;kp-f4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a957618586d8ac88b947fe0630ce1faea33ea0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-home&lt;/code&gt;, &lt;code&gt;kp-left&lt;/code&gt;, &lt;code&gt;kp-up&lt;/code&gt;, &lt;code&gt;kp-right&lt;/code&gt;, &lt;code&gt;kp-down&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kp-home&lt;/code&gt; , &lt;code&gt;kp-left&lt;/code&gt; , &lt;code&gt;kp-up&lt;/code&gt; , &lt;code&gt;kp-right&lt;/code&gt; , &lt;code&gt;kp-down&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa2b1e7bd7417d3f65fd45ff405387192fa4977a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-prior&lt;/code&gt;, &lt;code&gt;kp-next&lt;/code&gt;, &lt;code&gt;kp-end&lt;/code&gt;, &lt;code&gt;kp-begin&lt;/code&gt;, &lt;code&gt;kp-insert&lt;/code&gt;, &lt;code&gt;kp-delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kp-prior&lt;/code&gt; , &lt;code&gt;kp-next&lt;/code&gt; , &lt;code&gt;kp-end&lt;/code&gt; , &lt;code&gt;kp-begin&lt;/code&gt; , &lt;code&gt;kp-insert&lt;/code&gt; , &lt;code&gt;kp-delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca103fc8145d768e4a992e1cce45d81cc0ae7ebd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left-arrow&lt;/code&gt;, &lt;code&gt;right-arrow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left-arrow&lt;/code&gt; , &lt;code&gt;right-arrow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="246c0a986c7218186285fca89160a22af3cd88a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left-bracket&lt;/code&gt;, &lt;code&gt;right-bracket&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left-bracket&lt;/code&gt; , &lt;code&gt;right-bracket&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="125c1fd5ca16053f27bdd1d5ed69ccb1e10adb33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left-curly-arrow&lt;/code&gt;, &lt;code&gt;right-curly-arrow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left-curly-arrow&lt;/code&gt; , &lt;code&gt;right-curly-arrow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de2aba66da4813f38b7fc7692996f3b46cfc61f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; , &lt;code&gt;up&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;down&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6a8951a0db72dc26037795669472890ed7d2db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line-end&lt;/code&gt;, &lt;code&gt;eol&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;line-end&lt;/code&gt; , &lt;code&gt;eol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba55e96a733989c354535f935f2201139db555e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line-start&lt;/code&gt;, &lt;code&gt;bol&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;line-start&lt;/code&gt; , &lt;code&gt;bol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d0081f74a3b4ebb64b86d12fa3478d75d41dad9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;load&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; if the file loads successfully.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; возвращает &lt;code&gt;t&lt;/code&gt; , если файл загружается успешно.</target>
        </trans-unit>
        <trans-unit id="249215aae3d1624114895ec3e31fcf94b2a1e635" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local-function-key-map&lt;/code&gt; inherits from &lt;code&gt;function-key-map&lt;/code&gt;. The latter should only be altered if you want the binding to apply in all terminals, so using the former is almost always preferred.</source>
          <target state="translated">&lt;code&gt;local-function-key-map&lt;/code&gt; наследуется от &lt;code&gt;function-key-map&lt;/code&gt; . Последнее следует изменять только в том случае, если вы хотите, чтобы привязка применялась ко всем терминалам, поэтому использование первого почти всегда предпочтительнее.</target>
        </trans-unit>
        <trans-unit id="1fff4afaded7fd7b964a1ba99587343fdf63a9b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;lower-case&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;lower-case&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea87c6e99c32b702626bc85185ff62fd8116cd88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lsh&lt;/code&gt;, which is an abbreviation for &lt;em&gt;logical shift&lt;/em&gt;, shifts the bits in &lt;var&gt;integer1&lt;/var&gt; to the left &lt;var&gt;count&lt;/var&gt; places, or to the right if &lt;var&gt;count&lt;/var&gt; is negative, bringing zeros into the vacated bits. If &lt;var&gt;count&lt;/var&gt; is negative, then &lt;var&gt;integer1&lt;/var&gt; must be either a fixnum or a positive bignum, and &lt;code&gt;lsh&lt;/code&gt; treats a negative fixnum as if it were unsigned by subtracting twice &lt;code&gt;most-negative-fixnum&lt;/code&gt; before shifting, producing a nonnegative result. This quirky behavior dates back to when Emacs supported only fixnums; nowadays &lt;code&gt;ash&lt;/code&gt; is a better choice.</source>
          <target state="translated">&lt;code&gt;lsh&lt;/code&gt; , который является сокращением для &lt;em&gt;логического сдвига&lt;/em&gt; , сдвигает биты в &lt;var&gt;integer1&lt;/var&gt; с левым &lt;var&gt;count&lt;/var&gt; мест, или вправо , если &lt;var&gt;count&lt;/var&gt; является отрицательным, в результате чего нулей в освобождаемых биты. Если &lt;var&gt;count&lt;/var&gt; отрицательный, тогда &lt;var&gt;integer1&lt;/var&gt; должен быть либо фиксированным числом, либо положительным bignum, а &lt;code&gt;lsh&lt;/code&gt; обрабатывает отрицательное фиксированное число, как если бы оно было беззнаковым, путем вычитания дважды &lt;code&gt;most-negative-fixnum&lt;/code&gt; перед сдвигом, давая неотрицательный результат. Это странное поведение восходит к тому времени, когда Emacs поддерживал только фиксированные числа; в настоящее время &lt;code&gt;ash&lt;/code&gt; - лучший выбор.</target>
        </trans-unit>
        <trans-unit id="17ad6217085ea5b5e0b013ad0875589ff8f45a11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macroexpand-all&lt;/code&gt; expands macros like &lt;code&gt;macroexpand&lt;/code&gt;, but will look for and expand all macros in &lt;var&gt;form&lt;/var&gt;, not just at the top-level. If no macros are expanded, the return value is &lt;code&gt;eq&lt;/code&gt; to &lt;var&gt;form&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;macroexpand-all&lt;/code&gt; расширяет макросы, как &lt;code&gt;macroexpand&lt;/code&gt; , но будет искать и раскрывать все макросы по &lt;var&gt;form&lt;/var&gt; , а не только на верхнем уровне. Если макросы не раскрываются, возвращается значение &lt;code&gt;eq&lt;/code&gt; to &lt;var&gt;form&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f6c4eb079c3a7e5f0aab351a5677f46fed73aea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapc&lt;/code&gt; is like &lt;code&gt;mapcar&lt;/code&gt; except that &lt;var&gt;function&lt;/var&gt; is used for side-effects only&amp;mdash;the values it returns are ignored, not collected into a list. &lt;code&gt;mapc&lt;/code&gt; always returns &lt;var&gt;sequence&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;mapc&lt;/code&gt; похож на &lt;code&gt;mapcar&lt;/code&gt; , за исключением того, что &lt;var&gt;function&lt;/var&gt; используется только для побочных эффектов - значения, которые она возвращает, игнорируются, а не собираются в список. &lt;code&gt;mapc&lt;/code&gt; всегда возвращает &lt;var&gt;sequence&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f17fefcdf6fb3bfcd7affd13ee8956dda2d2cc22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapcar&lt;/code&gt; applies &lt;var&gt;function&lt;/var&gt; to each element of &lt;var&gt;sequence&lt;/var&gt; in turn, and returns a list of the results.</source>
          <target state="translated">&lt;code&gt;mapcar&lt;/code&gt; применяет &lt;var&gt;function&lt;/var&gt; к каждому элементу &lt;var&gt;sequence&lt;/var&gt; по очереди и возвращает список результатов.</target>
        </trans-unit>
        <trans-unit id="c5bcbf90aecc6544db096dd87c06c5ca1e224508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapconcat&lt;/code&gt; applies &lt;var&gt;function&lt;/var&gt; to each element of &lt;var&gt;sequence&lt;/var&gt;; the results, which must be sequences of characters (strings, vectors, or lists), are concatenated into a single string return value. Between each pair of result sequences, &lt;code&gt;mapconcat&lt;/code&gt; inserts the characters from &lt;var&gt;separator&lt;/var&gt;, which also must be a string, or a vector or list of characters. See &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mapconcat&lt;/code&gt; применяет &lt;var&gt;function&lt;/var&gt; к каждому элементу &lt;var&gt;sequence&lt;/var&gt; ; результаты, которые должны быть последовательностями символов (строк, векторов или списков), объединяются в одно возвращаемое значение строки. Между каждой парой результирующих последовательностей &lt;code&gt;mapconcat&lt;/code&gt; вставляет символы из &lt;var&gt;separator&lt;/var&gt; , который также должен быть строкой, вектором или списком символов. См. &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Разделы &amp;laquo;Векторы массивов последовательностей&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d2693764e07f0cb804bb968f848fd6f5c17e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max-lisp-eval-depth&lt;/code&gt; (see &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;) and &lt;code&gt;max-specpdl-size&lt;/code&gt; (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;) are both increased to reduce Edebug&amp;rsquo;s impact on the stack. You could, however, still run out of stack space when using Edebug. You can also enlarge the value of &lt;code&gt;edebug-max-depth&lt;/code&gt; if Edebug reaches the limit of recursion depth instrumenting code that contains very large quoted lists.</source>
          <target state="translated">&lt;code&gt;max-lisp-eval-depth&lt;/code&gt; (см. &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt; ) и &lt;code&gt;max-specpdl-size&lt;/code&gt; (см. &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Локальные переменные&lt;/a&gt; ) увеличены, чтобы уменьшить влияние Edebug на стек. Однако при использовании Edebug у вас может не хватить места в стеке. Вы также можете увеличить значение &lt;code&gt;edebug-max-depth&lt;/code&gt; , если Edebug достигает предела инструментального кода глубины рекурсии, который содержит очень большие списки кавычек.</target>
        </trans-unit>
        <trans-unit id="4dcede8a74a74667f6d6baa9436ec3f1ac34d528" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max-specpdl-size&lt;/code&gt; provides another limit on nesting. See &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;Local Variables&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;max-specpdl-size&lt;/code&gt; предоставляет еще один предел вложенности. См. &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;Локальные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4283393c76101b7c75957e1aa804e3afd17b137b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maximum-scroll-margin&lt;/code&gt; itself has a maximum value of 0.5, which allows setting margins large to keep the cursor at the middle line of the window (or two middle lines if the window has an even number of lines). If it&amp;rsquo;s set to a larger value (or any value other than a float between 0.0 and 0.5) then the default value of 0.25 will be used instead.</source>
          <target state="translated">&lt;code&gt;maximum-scroll-margin&lt;/code&gt; Сама maximum-scroll-margin имеет максимальное значение 0,5, что позволяет устанавливать большие поля, чтобы курсор оставался в средней строке окна (или в двух средних строках, если в окне четное количество строк). Если для него установлено большее значение (или любое значение, отличное от числа с плавающей запятой между 0,0 и 0,5), то вместо него будет использоваться значение по умолчанию 0,25.</target>
        </trans-unit>
        <trans-unit id="0abfae913559cf6e54f47e4c7056eab492888b98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor-mode-alist&lt;/code&gt; itself is not buffer-local. Each variable mentioned in the alist should be buffer-local if its minor mode can be enabled separately in each buffer.</source>
          <target state="translated">&lt;code&gt;minor-mode-alist&lt;/code&gt; сам по себе не является локальным для буфера. Каждая переменная, упомянутая в списке, должна быть локальной для буфера, если ее второстепенный режим можно включить отдельно в каждом буфере.</target>
        </trans-unit>
        <trans-unit id="5c765a30c75d52af9ee570867780f3be534d6e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; is automatically buffer-local in all buffers.</source>
          <target state="translated">&lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; автоматически становится локальным для всех буферов.</target>
        </trans-unit>
        <trans-unit id="17ec7b27c2211f568583f150e109b60c029edde5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode-specific-map&lt;/code&gt; is the global keymap for the prefix key</source>
          <target state="translated">&lt;code&gt;mode-specific-map&lt;/code&gt; - это глобальная раскладка для префиксного ключа</target>
        </trans-unit>
        <trans-unit id="7890b9b8602eeddc0d995b6dc7c4ee21547818ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mule-keymap&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;mule-keymap&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="d2f6cca2ccdb0ab132f6b7baf5caa26313957731" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means consider only windows on the selected frame. (Actually, the last frame used that is not a minibuffer-only frame.)</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; означает, что рассматривать только окна в выбранном фрейме. (На самом деле, последний использованный кадр, который не является кадром только для минибуфера.)</target>
        </trans-unit>
        <trans-unit id="d0b9f6234ea8f44b037a824027a723100a30ef4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means operate on all frames.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; означает работать со всеми фреймами.</target>
        </trans-unit>
        <trans-unit id="819a422042048b76988497f308e14b5e715ceab5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means that the events used so far in the lookup form an undefined key. When a keymap fails to mention an event type at all, and has no default binding, that is equivalent to a binding of &lt;code&gt;nil&lt;/code&gt; for that event type.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; означает, что события, использованные до сих пор в поиске, образуют неопределенный ключ. Когда в раскладке клавиатуры вообще не упоминается тип события и нет привязки по умолчанию, это эквивалентно привязке &lt;code&gt;nil&lt;/code&gt; для этого типа события.</target>
        </trans-unit>
        <trans-unit id="afd72feaaa11fde848c1815c3b5a58b659297a44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means to consider windows on &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame. If the minibuffer window is considered (as specified by the &lt;var&gt;minibuf&lt;/var&gt; argument), then frames that share the minibuffer window are considered too.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; означает считать окна на раме &lt;var&gt;window&lt;/var&gt; . Если рассматривается окно минибуфера (как указано аргументом &lt;var&gt;minibuf&lt;/var&gt; ), то учитываются и кадры, совместно использующие окно минибуфера.</target>
        </trans-unit>
        <trans-unit id="7f9b163d3a6478ab15f71af56a99d5c9db6c481b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means to leave the height of the chosen window alone.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; означает оставить высоту выбранного окна без изменений.</target>
        </trans-unit>
        <trans-unit id="c2c1988a6a0d0d9e3ac37be3a0ca11cc3a3c9234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means to leave the width of the chosen window alone.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; означает оставить ширину выбранного окна без изменений.</target>
        </trans-unit>
        <trans-unit id="57cc7b3ade0670ca46365bd57aa0ed27d064ec81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; specified as an output stream means to use the value of &lt;code&gt;standard-output&lt;/code&gt; instead; that value is the &lt;em&gt;default output stream&lt;/em&gt;, and must not be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; , указанный как выходной поток, означает использование вместо этого значения &lt;code&gt;standard-output&lt;/code&gt; ; это значение является &lt;em&gt;потоком вывода&lt;/em&gt; по &lt;em&gt;умолчанию&lt;/em&gt; и не должно быть &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41ba9d1889a34528a7c6886cc43b66ce04b8fdce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; supplied as an input stream means to use the value of &lt;code&gt;standard-input&lt;/code&gt; instead; that value is the &lt;em&gt;default input stream&lt;/em&gt;, and must be a non-&lt;code&gt;nil&lt;/code&gt; input stream.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; , предоставленный в качестве входного потока, означает использование вместо него значения &lt;code&gt;standard-input&lt;/code&gt; ; это значение является &lt;em&gt;входным потоком&lt;/em&gt; по &lt;em&gt;умолчанию&lt;/em&gt; и не должно быть &lt;code&gt;nil&lt;/code&gt; входным потоком.</target>
        </trans-unit>
        <trans-unit id="0e057410ded4fee7473aed5c911a7c0479cd5a80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt;, meaning there is no prefix argument. Its numeric value is 1, but numerous commands make a distinction between &lt;code&gt;nil&lt;/code&gt; and the integer 1.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; , что означает отсутствие аргумента префикса. Его числовое значение равно 1, но многие команды проводят различие между &lt;code&gt;nil&lt;/code&gt; и целым числом 1.</target>
        </trans-unit>
        <trans-unit id="0d104d5ef48ee4b951b5d1860fbeed9512018d1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt;: use the default indentation rule.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; : использовать правило отступа по умолчанию.</target>
        </trans-unit>
        <trans-unit id="132ce6461764b770ab4320ac5096dea3d95d0c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no-conversion&lt;/code&gt; (and its alias &lt;code&gt;binary&lt;/code&gt;) is equivalent to &lt;code&gt;raw-text-unix&lt;/code&gt;: it specifies no conversion of either character codes or end-of-line.</source>
          <target state="translated">&lt;code&gt;no-conversion&lt;/code&gt; (и его &lt;code&gt;binary&lt;/code&gt; псевдоним ) эквивалентен &lt;code&gt;raw-text-unix&lt;/code&gt; : он не определяет преобразования ни кодов символов, ни конца строки.</target>
        </trans-unit>
        <trans-unit id="639f287af0a67f8ed92462a2183771add87f55ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normal-mode&lt;/code&gt; uses &lt;code&gt;condition-case&lt;/code&gt; around the call to the major mode command, so errors are caught and reported as a &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;normal-mode&lt;/code&gt; использует &lt;code&gt;condition-case&lt;/code&gt; вокруг вызова команды основного режима, поэтому ошибки выявляются и сообщаются как '</target>
        </trans-unit>
        <trans-unit id="f1d673027be7f0dc198c4e29d79f765eb0015789" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not-newline&lt;/code&gt;, &lt;code&gt;nonl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;not-newline&lt;/code&gt; &lt;code&gt;nonl&lt;/code&gt; , nonl</target>
        </trans-unit>
        <trans-unit id="3b477bde094dcd85ca9226e2b3dd79c674114393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;posn-at-point&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;pos&lt;/var&gt; is not visible in &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;posn-at-point&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; , если &lt;var&gt;pos&lt;/var&gt; не отображается в &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="914d11373ff4c8970d90e6703077a712573544e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primitive-undo&lt;/code&gt; adds elements to the buffer&amp;rsquo;s undo list when it changes the buffer. Undo commands avoid confusion by saving the undo list value at the beginning of a sequence of undo operations. Then the undo operations use and update the saved value. The new elements added by undoing are not part of this saved value, so they don&amp;rsquo;t interfere with continuing to undo.</source>
          <target state="translated">&lt;code&gt;primitive-undo&lt;/code&gt; добавляет элементы в список отмены буфера при изменении буфера. Команды отмены позволяют избежать путаницы, сохраняя значение списка отмены в начале последовательности операций отмены. Затем операции отмены используют и обновляют сохраненное значение. Новые элементы, добавленные при отмене, не являются частью этого сохраненного значения, поэтому они не мешают продолжению отмены.</target>
        </trans-unit>
        <trans-unit id="313c7f224d72ebc094061d7d24a663761e97b45b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; , &lt;code&gt;printing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec9eda81cf8008a97b1d863eb1be427f16a8f3b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; are an alternative to &lt;code&gt;autoload&lt;/code&gt; for loading files automatically. They work in terms of named &lt;em&gt;features&lt;/em&gt;. Autoloading is triggered by calling a specific function, but a feature is loaded the first time another program asks for it by name.</source>
          <target state="translated">&lt;code&gt;provide&lt;/code&gt; и &lt;code&gt;require&lt;/code&gt; - это альтернатива &lt;code&gt;autoload&lt;/code&gt; для автоматической загрузки файлов. Они работают с точки зрения названных &lt;em&gt;функций&lt;/em&gt; . Автозагрузка запускается при вызове определенной функции, но функция загружается в первый раз, когда другая программа запрашивает ее по имени.</target>
        </trans-unit>
        <trans-unit id="d70e77d38be89adf89d1b036b81076ba6e81cf61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;punct&lt;/code&gt;, &lt;code&gt;punctuation&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;punctuation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="084755a084b693739801d8d8edf38356f3c7cd80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;push-button&lt;/code&gt; is the command that a user uses to actually push a button, and is bound by default in the button itself to</source>
          <target state="translated">&lt;code&gt;push-button&lt;/code&gt; - это команда, которую пользователь использует для фактического нажатия кнопки, и по умолчанию в самой кнопке привязана к</target>
        </trans-unit>
        <trans-unit id="6ebf9fbf5d62647055c4ba6438a6901540013693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rassoc&lt;/code&gt; is like &lt;code&gt;assoc&lt;/code&gt; except that it compares the &lt;small&gt;CDR&lt;/small&gt; of each &lt;var&gt;alist&lt;/var&gt; association instead of the &lt;small&gt;CAR&lt;/small&gt;. You can think of this as reverse &lt;code&gt;assoc&lt;/code&gt;, finding the key for a given value.</source>
          <target state="translated">&lt;code&gt;rassoc&lt;/code&gt; похож на &lt;code&gt;assoc&lt;/code&gt; , за исключением того, что он сравнивает &lt;small&gt;CDR&lt;/small&gt; каждой ассоциации &lt;var&gt;alist&lt;/var&gt; вместо &lt;small&gt;CAR&lt;/small&gt; . Вы можете думать об этом как об обратном &lt;code&gt;assoc&lt;/code&gt; , поиске ключа для данного значения.</target>
        </trans-unit>
        <trans-unit id="5b28e51d950dde8e979a69abe72749c3a72a81b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rassq&lt;/code&gt; cannot search for a value stored in the &lt;small&gt;CAR&lt;/small&gt; of the &lt;small&gt;CDR&lt;/small&gt; of an element:</source>
          <target state="translated">&lt;code&gt;rassq&lt;/code&gt; не могут поиска значения , хранящегося в &lt;small&gt;CAR&lt;/small&gt; в &lt;small&gt;CDR&lt;/small&gt; элемента:</target>
        </trans-unit>
        <trans-unit id="e731698340710bd2ed27567345847db52d9ecc7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rassq&lt;/code&gt; is like &lt;code&gt;assq&lt;/code&gt; except that it compares the &lt;small&gt;CDR&lt;/small&gt; of each &lt;var&gt;alist&lt;/var&gt; association instead of the &lt;small&gt;CAR&lt;/small&gt;. You can think of this as reverse &lt;code&gt;assq&lt;/code&gt;, finding the key for a given value.</source>
          <target state="translated">&lt;code&gt;rassq&lt;/code&gt; похож на &lt;code&gt;assq&lt;/code&gt; , за исключением того, что он сравнивает &lt;small&gt;CDR&lt;/small&gt; каждой ассоциации &lt;var&gt;alist&lt;/var&gt; вместо &lt;small&gt;CAR&lt;/small&gt; . Вы можете думать об этом как обратный &lt;code&gt;assq&lt;/code&gt; , найти ключ для заданного значения.</target>
        </trans-unit>
        <trans-unit id="67994628b87e5a6fefaf54d031a115c17ae6ec51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read-file-name&lt;/code&gt; does not automatically expand the returned file name. You can call &lt;code&gt;expand-file-name&lt;/code&gt; yourself if an absolute file name is required.</source>
          <target state="translated">&lt;code&gt;read-file-name&lt;/code&gt; не расширяет автоматически возвращаемое имя файла. Вы можете вызвать &lt;code&gt;expand-file-name&lt;/code&gt; самостоятельно, если требуется абсолютное имя файла.</target>
        </trans-unit>
        <trans-unit id="a5bb534f341b26b90a134da77d2d54c776b85a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read-regexp&lt;/code&gt; now ensures that the result of processing &lt;var&gt;defaults&lt;/var&gt; is a list (i.e., if the value is &lt;code&gt;nil&lt;/code&gt; or a string, it converts it to a list of one element). To this list, &lt;code&gt;read-regexp&lt;/code&gt; then appends a few potentially useful candidates for input. These are:</source>
          <target state="translated">&lt;code&gt;read-regexp&lt;/code&gt; теперь гарантирует, что результатом обработки &lt;var&gt;defaults&lt;/var&gt; является список (т. е. если значение равно &lt;code&gt;nil&lt;/code&gt; или строке, оно преобразует его в список из одного элемента). Затем к этому списку &lt;code&gt;read-regexp&lt;/code&gt; добавляет несколько потенциально полезных кандидатов для ввода. Эти:</target>
        </trans-unit>
        <trans-unit id="d4c55533c2f01f1b7db258f38f07cb55c889d489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replace-buffer-contents&lt;/code&gt; returns t if a non-destructive replacement could be performed. Otherwise, i.e., if &lt;var&gt;max-secs&lt;/var&gt; was exceeded, it returns nil.</source>
          <target state="translated">&lt;code&gt;replace-buffer-contents&lt;/code&gt; возвращает t, если может быть выполнена неразрушающая замена. В противном случае, т. &lt;var&gt;max-secs&lt;/var&gt; было превышено максимальное количество секунд , возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="fc560a9efb7ad3b860b6ef11a703b3989d2a895b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;revert-buffer&lt;/code&gt; binds this variable to a non-&lt;code&gt;nil&lt;/code&gt; value while it is working.</source>
          <target state="translated">&lt;code&gt;revert-buffer&lt;/code&gt; связывает эту переменную с &lt;code&gt;nil&lt;/code&gt; значением, пока она работает.</target>
        </trans-unit>
        <trans-unit id="760a5fbe6045d8f7559904c18d6a2c56d1688252" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;revert-buffer&lt;/code&gt;, and how to customize what it does.</source>
          <target state="translated">&lt;code&gt;revert-buffer&lt;/code&gt; и как настроить то, что он делает.</target>
        </trans-unit>
        <trans-unit id="0d8aa86d0e2e4c279aa3d7ab23ba5404e9f3bb99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right-triangle&lt;/code&gt;, &lt;code&gt;left-triangle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;right-triangle&lt;/code&gt; , &lt;code&gt;left-triangle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea54e890fcbaf5ede0bc6e26303eaf3f9555144a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx-let&lt;/code&gt; can be used not only inside a function, but also at top level to include global variable and function definitions that need to share a common set of &lt;code&gt;rx&lt;/code&gt; forms. Since the names are local inside &lt;var&gt;body&lt;/var&gt;, there is no need for any package prefixes. Example:</source>
          <target state="translated">&lt;code&gt;rx-let&lt;/code&gt; может использоваться не только внутри функции, но и на верхнем уровне для включения глобальных переменных и определений функций, которые должны использовать общий набор форм &lt;code&gt;rx&lt;/code&gt; . Поскольку имена являются локальными внутри &lt;var&gt;body&lt;/var&gt; , нет необходимости в каких-либо префиксах пакетов. Пример:</target>
        </trans-unit>
        <trans-unit id="5b08879be5eaeb8caa4a6762910dd120cba71aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save-buffer&lt;/code&gt; is responsible for making backup files. Normally, &lt;var&gt;backup-option&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and &lt;code&gt;save-buffer&lt;/code&gt; makes a backup file only if this is the first save since visiting the file. Other values for &lt;var&gt;backup-option&lt;/var&gt; request the making of backup files in other circumstances:</source>
          <target state="translated">&lt;code&gt;save-buffer&lt;/code&gt; отвечает за создание файлов резервных копий. Обычно параметр &lt;var&gt;backup-option&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , и &lt;code&gt;save-buffer&lt;/code&gt; создает файл резервной копии только в том случае, если это первое сохранение с момента посещения файла. Другие значения для параметра &lt;var&gt;backup-option&lt;/var&gt; требуют создания файлов резервных копий в других обстоятельствах:</target>
        </trans-unit>
        <trans-unit id="a1e81cd0dbdcd543cf4536779a9160daa8d5b908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save-restriction&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; restore point; use &lt;code&gt;save-excursion&lt;/code&gt; for that. If you use both &lt;code&gt;save-restriction&lt;/code&gt; and &lt;code&gt;save-excursion&lt;/code&gt; together, &lt;code&gt;save-excursion&lt;/code&gt; should come first (on the outside). Otherwise, the old point value would be restored with temporary narrowing still in effect. If the old point value were outside the limits of the temporary narrowing, this would fail to restore it accurately.</source>
          <target state="translated">&lt;code&gt;save-restriction&lt;/code&gt; вовсе &lt;em&gt;не&lt;/em&gt; точка восстановления; используйте для этого &lt;code&gt;save-excursion&lt;/code&gt; . Если вы одновременно используете &lt;code&gt;save-restriction&lt;/code&gt; &lt;code&gt;save-excursion&lt;/code&gt; и save-excursion , сначала должно быть указано &lt;code&gt;save-excursion&lt;/code&gt; (снаружи). В противном случае будет восстановлено старое значение точки с сохранением временного сужения. Если бы старое значение точки выходило за пределы временного сужения, это не могло бы точно восстановить его.</target>
        </trans-unit>
        <trans-unit id="f681cec249f999acd57b8bf621e56d79bd04124b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;search-map&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="21f45bc2679fe0ce6666bb52f56d2a1f5b4f3917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seq-elt&lt;/code&gt; returns places settable using &lt;code&gt;setf&lt;/code&gt; (see &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;Setting Generalized Variables&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;seq-elt&lt;/code&gt; возвращает места, которые можно установить с помощью &lt;code&gt;setf&lt;/code&gt; (см. &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;Установка обобщенных переменных&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="412a741ecf02586a155f9800e1819ad1a59f7197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setenv&lt;/code&gt; returns the new value of &lt;var&gt;variable&lt;/var&gt;, or &lt;code&gt;nil&lt;/code&gt; if it removed &lt;var&gt;variable&lt;/var&gt; from the environment.</source>
          <target state="translated">&lt;code&gt;setenv&lt;/code&gt; возвращает новое значение &lt;var&gt;variable&lt;/var&gt; или &lt;code&gt;nil&lt;/code&gt; , если он удалил &lt;var&gt;variable&lt;/var&gt; из среды.</target>
        </trans-unit>
        <trans-unit id="b3298f6be0f65fb71cd9899fbda4f5d128e54411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setenv&lt;/code&gt; works by modifying &lt;code&gt;process-environment&lt;/code&gt;; binding that variable with &lt;code&gt;let&lt;/code&gt; is also reasonable practice.</source>
          <target state="translated">&lt;code&gt;setenv&lt;/code&gt; работает путем изменения &lt;code&gt;process-environment&lt;/code&gt; ; привязка этой переменной с помощью &lt;code&gt;let&lt;/code&gt; также является разумной практикой.</target>
        </trans-unit>
        <trans-unit id="1805264040f480fcfe5811e91adc07dd7107d291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setf&lt;/code&gt; signals an error if you pass a &lt;var&gt;place&lt;/var&gt; form that it does not know how to handle.</source>
          <target state="translated">&lt;code&gt;setf&lt;/code&gt; сигнализирует об ошибке, если вы передаете форму &lt;var&gt;place&lt;/var&gt; которую она не знает, как обрабатывать.</target>
        </trans-unit>
        <trans-unit id="a0b172aed0c367b6469c519892afd795f43421f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setq&lt;/code&gt; does not evaluate &lt;var&gt;symbol&lt;/var&gt;; it sets the symbol that you write. We say that this argument is &lt;em&gt;automatically quoted&lt;/em&gt;. The &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;setq&lt;/code&gt; не оценивает &lt;var&gt;symbol&lt;/var&gt; ; он устанавливает символ, который вы пишете. Мы говорим, что этот аргумент &lt;em&gt;цитируется автоматически&lt;/em&gt; . '</target>
        </trans-unit>
        <trans-unit id="84fb1128fe6ec1835607db7b74ec3623c9faaf3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;white&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; , &lt;code&gt;white&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3acebe1579627cb1ae8404add4a67e4deaffbb44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;standard-output&lt;/code&gt; and &lt;code&gt;standard-input&lt;/code&gt; are bound to &lt;code&gt;nil&lt;/code&gt; by the &lt;code&gt;recursive-edit&lt;/code&gt;, but Edebug temporarily restores them during evaluations.</source>
          <target state="translated">&lt;code&gt;standard-output&lt;/code&gt; и &lt;code&gt;standard-input&lt;/code&gt; связаны с &lt;code&gt;nil&lt;/code&gt; с помощью &lt;code&gt;recursive-edit&lt;/code&gt; , но Edebug временно восстанавливает их во время оценки.</target>
        </trans-unit>
        <trans-unit id="0a9ae84722969551ac034daec5e016ebd0c44e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;store-match-data&lt;/code&gt; is a semi-obsolete alias for &lt;code&gt;set-match-data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;store-match-data&lt;/code&gt; - это полу-устаревший псевдоним для &lt;code&gt;set-match-data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09664cb1c96e9185c9144ca00b932c6582599f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-end&lt;/code&gt;, &lt;code&gt;eos&lt;/code&gt;, &lt;code&gt;buffer-end&lt;/code&gt;, &lt;code&gt;eot&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string-end&lt;/code&gt; , &lt;code&gt;eos&lt;/code&gt; , &lt;code&gt;buffer-end&lt;/code&gt; , &lt;code&gt;eot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6440bc6219257786238ef571e25a78488969195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-equal&lt;/code&gt; is another name for &lt;code&gt;string=&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string-equal&lt;/code&gt; это другое имя для &lt;code&gt;string=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be651b6f67d7e458c50b3cf7fb671ab938eb0255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-lessp&lt;/code&gt; is another name for &lt;code&gt;string&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string-lessp&lt;/code&gt; - другое имя для &lt;code&gt;string&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b5a5dbc53a397eb7b8627403504ca468cdec06d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-start&lt;/code&gt;, &lt;code&gt;bos&lt;/code&gt;, &lt;code&gt;buffer-start&lt;/code&gt;, &lt;code&gt;bot&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string-start&lt;/code&gt; , &lt;code&gt;bos&lt;/code&gt; , &lt;code&gt;buffer-start&lt;/code&gt; , &lt;code&gt;bot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35766ce72fedccae73899ff72af9f02eba537d17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-to-int&lt;/code&gt; is an obsolete alias for this function.</source>
          <target state="translated">&lt;code&gt;string-to-int&lt;/code&gt; - устаревший псевдоним для этой функции.</target>
        </trans-unit>
        <trans-unit id="f7f7697af3e84322eec091c3c1c134ddc067b714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subst-char-in-region&lt;/code&gt; does not move point and returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;subst-char-in-region&lt;/code&gt; не перемещает точку и возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd8ca73079df3dd53ec8024a2bbc2995ca2223f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;substring&lt;/code&gt; also accepts a vector for the first argument. For example:</source>
          <target state="translated">&lt;code&gt;substring&lt;/code&gt; также принимает вектор в качестве первого аргумента. Например:</target>
        </trans-unit>
        <trans-unit id="7538a9062ef699c535de57d93e800e4b85bc83fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; (the default)</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; (по умолчанию)</target>
        </trans-unit>
        <trans-unit id="61a81a6cdbc4b7f9b8d52d68af382ec09ee04b6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; for a directory, a string for a symbolic link (the name linked to), or &lt;code&gt;nil&lt;/code&gt; for a text file (&lt;code&gt;file-attribute-type&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; для каталога, строка для символической ссылки (имя, на которое ссылается) или &lt;code&gt;nil&lt;/code&gt; для текстового файла ( &lt;code&gt;file-attribute-type&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d721e32bb95cdb8eeeb178c9e1375221de1d3779" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; if daylight saving time is effect, &lt;code&gt;nil&lt;/code&gt; if it is not in effect, and -1 if this information is not available.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; , если действует летнее время, &lt;code&gt;nil&lt;/code&gt; , если оно не действует, и -1, если эта информация недоступна.</target>
        </trans-unit>
        <trans-unit id="d7a0e85e56982169debe8d361bb05d3472094c1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; if inside a non-nestable comment (of any comment style; see &lt;a href=&quot;syntax-flags#Syntax-Flags&quot;&gt;Syntax Flags&lt;/a&gt;); or the comment nesting level if inside a comment that can be nested.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; , если внутри не вложенного комментария (любого стиля комментария; см. &lt;a href=&quot;syntax-flags#Syntax-Flags&quot;&gt;Флаги синтаксиса&lt;/a&gt; ); или уровень вложенности комментариев, если внутри комментария, который может быть вложен.</target>
        </trans-unit>
        <trans-unit id="cef1f4ed993c9f70d6394dbf0337c4865820f50f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; if the end point is just after a quote character.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; , если конечная точка находится сразу после символа кавычки.</target>
        </trans-unit>
        <trans-unit id="ca362524e068b7a0ec650b69f842377fea553dc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means consider windows on all existing frames.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; означает учитывать окна на всех существующих фреймах.</target>
        </trans-unit>
        <trans-unit id="d7d22e3999dd931ac69620324b6cb2afd00057de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means consider windows on all frames.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; означает учитывать окна во всех фреймах.</target>
        </trans-unit>
        <trans-unit id="86776f9a01ba5ba7ca2810476ff92a879defb5bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means do not switch to a buffer shown on any live frame.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; означает не переключаться на буфер, отображаемый в любом живом кадре.</target>
        </trans-unit>
        <trans-unit id="49bfc08b83a08210a4c227a7b4aff67853a73f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means operate on the selected frame.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; означает работу с выбранным кадром.</target>
        </trans-unit>
        <trans-unit id="400fda1edd4652607c56029e5840115a5c101a3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means to consider windows on all existing frames.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; означает учитывать окна на всех существующих фреймах.</target>
        </trans-unit>
        <trans-unit id="54a6a6c1c1513953b205df1e1454c11d8964fb78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; used as a stream means that the input is read from the minibuffer. In fact, the minibuffer is invoked once and the text given by the user is made into a string that is then used as the input stream. If Emacs is running in batch mode, standard input is used instead of the minibuffer. For example,</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; , используемый как поток, означает, что ввод считывается из минибуфера. Фактически, минибуфер вызывается один раз, и текст, предоставленный пользователем, преобразуется в строку, которая затем используется в качестве входного потока. Если Emacs работает в пакетном режиме, вместо минибуфера используется стандартный ввод. Например,</target>
        </trans-unit>
        <trans-unit id="ef9a8dbd2ad88f17735d99134022fcc0f0647ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tab-prefix-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;tab-prefix-map&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="35fa46cdfad9f57143883b7f4bf97917fce8f5fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; means do not switch to a buffer shown on the frame that hosts the window &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; is acting upon.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; означает, что не следует переключаться на буфер, показанный в кадре, в котором находится &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; окна на предыдущий .</target>
        </trans-unit>
        <trans-unit id="dc8c81c5704363757846f658896f4d2ab6fdd06a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thunk-let&lt;/code&gt; and &lt;code&gt;thunk-let*&lt;/code&gt; use thunks implicitly: their expansion creates helper symbols and binds them to thunks wrapping the binding expressions. All references to the original variables in the body &lt;var&gt;forms&lt;/var&gt; are then replaced by an expression that calls &lt;code&gt;thunk-force&lt;/code&gt; with the according helper variable as the argument. So, any code using &lt;code&gt;thunk-let&lt;/code&gt; or &lt;code&gt;thunk-let*&lt;/code&gt; could be rewritten to use thunks, but in many cases using these macros results in nicer code than using thunks explicitly.</source>
          <target state="translated">&lt;code&gt;thunk-let&lt;/code&gt; и &lt;code&gt;thunk-let*&lt;/code&gt; неявно используют преобразователи: их расширение создает вспомогательные символы и привязывает их к преобразователям, обертывающим выражения привязки. Все ссылки на исходные переменные в &lt;var&gt;forms&lt;/var&gt; тела затем заменяются выражением, которое вызывает &lt;code&gt;thunk-force&lt;/code&gt; с соответствующей вспомогательной переменной в качестве аргумента. Таким образом, любой код, использующий &lt;code&gt;thunk-let&lt;/code&gt; или &lt;code&gt;thunk-let*&lt;/code&gt; можно переписать для использования thunks, но во многих случаях использование этих макросов приводит к более приятному коду, чем использование thunks явно.</target>
        </trans-unit>
        <trans-unit id="1635457aaed54c29c183ca9ed092a80dc29e4d70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;time-to-seconds&lt;/code&gt; is an alias for this function.</source>
          <target state="translated">&lt;code&gt;time-to-seconds&lt;/code&gt; - это псевдоним для этой функции.</target>
        </trans-unit>
        <trans-unit id="26c106c1ab2f109ecd879a98213bfc8ac5a2d35a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;top-left-angle&lt;/code&gt;, &lt;code&gt;top-right-angle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;top-left-angle&lt;/code&gt; , &lt;code&gt;top-right-angle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdc662193077bc52c6a9cf20b8a1d930c0058986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncation&lt;/code&gt;, &lt;code&gt;continuation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;truncation&lt;/code&gt; , &lt;code&gt;continuation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c6ea0de9e9374af042b6bd3ef906b2af5702afb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try-completion&lt;/code&gt; compares &lt;var&gt;string&lt;/var&gt; against each of the permissible completions specified by the completion table. If no permissible completions match, it returns &lt;code&gt;nil&lt;/code&gt;. If there is just one matching completion, and the match is exact, it returns &lt;code&gt;t&lt;/code&gt;. Otherwise, it returns the longest initial sequence common to all possible matching completions.</source>
          <target state="translated">&lt;code&gt;try-completion&lt;/code&gt; сравнивает &lt;var&gt;string&lt;/var&gt; с каждым из допустимых завершений, указанных в таблице завершения. Если допустимых завершений не найдено, возвращается &lt;code&gt;nil&lt;/code&gt; . Если есть только одно завершение совпадения и совпадение точное, возвращается &lt;code&gt;t&lt;/code&gt; . В противном случае он возвращает самую длинную начальную последовательность, общую для всех возможных совпадений.</target>
        </trans-unit>
        <trans-unit id="742ccebb68329ec2fd3c50d040bcbe34bc9b1bb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; if the notification server hasn&amp;rsquo;t provided a reason</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; , если сервер уведомлений не указал причину</target>
        </trans-unit>
        <trans-unit id="c58195fc3f2a7a906b58840d6e73503af41f547a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; is used in local keymaps to override a global key binding and make the key undefined locally. A local binding of &lt;code&gt;nil&lt;/code&gt; would fail to do this because it would not override the global binding.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; используется в локальных таблицах ключей, чтобы переопределить привязку глобального ключа и сделать ключ неопределенным локально. Локальная привязка &lt;code&gt;nil&lt;/code&gt; не сможет этого сделать, потому что она не переопределит глобальную привязку.</target>
        </trans-unit>
        <trans-unit id="4abbd5612df0f57058f67cb30404ce3ad8bf4e37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unspecified&lt;/code&gt; is a relative value for all attributes. For &lt;code&gt;:height&lt;/code&gt;, floating point and function values are also relative.</source>
          <target state="translated">&lt;code&gt;unspecified&lt;/code&gt; - относительное значение для всех атрибутов. For &lt;code&gt;:height&lt;/code&gt; , с плавающей запятой и функции также являются относительными.</target>
        </trans-unit>
        <trans-unit id="124f3fdc8f42c34d14b0df2c0020eb474f4eee0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unwind-protect&lt;/code&gt; executes &lt;var&gt;body-form&lt;/var&gt; with a guarantee that the &lt;var&gt;cleanup-forms&lt;/var&gt; will be evaluated if control leaves &lt;var&gt;body-form&lt;/var&gt;, no matter how that happens. &lt;var&gt;body-form&lt;/var&gt; may complete normally, or execute a &lt;code&gt;throw&lt;/code&gt; out of the &lt;code&gt;unwind-protect&lt;/code&gt;, or cause an error; in all cases, the &lt;var&gt;cleanup-forms&lt;/var&gt; will be evaluated.</source>
          <target state="translated">&lt;code&gt;unwind-protect&lt;/code&gt; выполняет &lt;var&gt;body-form&lt;/var&gt; с гарантией, что &lt;var&gt;cleanup-forms&lt;/var&gt; будут оцениваться, если элемент управления покидает &lt;var&gt;body-form&lt;/var&gt; , независимо от того, как это происходит. &lt;var&gt;body-form&lt;/var&gt; может завершиться нормально, или выполнить &lt;code&gt;throw&lt;/code&gt; из защиты от &lt;code&gt;unwind-protect&lt;/code&gt; , или вызвать ошибку; во всех случаях будут оцениваться &lt;var&gt;cleanup-forms&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d81808bd6e7785579442de56a811c26e9936edbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up-arrow&lt;/code&gt;, &lt;code&gt;down-arrow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;up-arrow&lt;/code&gt; , &lt;code&gt;down-arrow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8935adeb062340d1e761af492c6eaa9b7433f232" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;top-bottom&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;up&lt;/code&gt; , &lt;code&gt;down&lt;/code&gt; , &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;bottom&lt;/code&gt; , &lt;code&gt;top-bottom&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47d330161b419cd92c499dffb7d1b14eb52cac0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;upper-case&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;upper-case&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="158a61e3891293cbbcf96cd60832d79e93f772f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vc-prefix-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;vc-prefix-map&lt;/code&gt; - это глобальная раскладка клавиатуры, используемая для</target>
        </trans-unit>
        <trans-unit id="825022a69b3f863708db90f5ed68a02a6a6cb129" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vertical-bar&lt;/code&gt;, &lt;code&gt;horizontal-bar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vertical-bar&lt;/code&gt; , &lt;code&gt;horizontal-bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3a138938711530a671959761d2f5b9f94df0a46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means consider windows on all visible frames.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; означает, что окна учитываются на всех видимых фреймах.</target>
        </trans-unit>
        <trans-unit id="77816e79409cf71a3ff6cf54ef6a99b6d9084ac1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means do not switch to a buffer shown on any visible frame.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; означает, что нельзя переключаться на буфер, показанный на любом видимом кадре.</target>
        </trans-unit>
        <trans-unit id="a627c5f703440f7243320f587bc60b331be36cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means operate on all visible frames.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; означает работу со всеми видимыми кадрами.</target>
        </trans-unit>
        <trans-unit id="0e452b8631dd9c74908f6235ce975031b73eab84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means to consider windows on all visible frames.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; означает рассматривать окна на всех видимых фреймах.</target>
        </trans-unit>
        <trans-unit id="6b417aa5a01b38f3953d2734846bd5504972f617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; first evaluates &lt;var&gt;condition&lt;/var&gt;. If the result is non-&lt;code&gt;nil&lt;/code&gt;, it evaluates &lt;var&gt;forms&lt;/var&gt; in textual order. Then it reevaluates &lt;var&gt;condition&lt;/var&gt;, and if the result is non-&lt;code&gt;nil&lt;/code&gt;, it evaluates &lt;var&gt;forms&lt;/var&gt; again. This process repeats until &lt;var&gt;condition&lt;/var&gt; evaluates to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; сначала оценивает &lt;var&gt;condition&lt;/var&gt; . Если результат не равен &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;forms&lt;/var&gt; оценивается в текстовом порядке. Затем он повторно оценивает &lt;var&gt;condition&lt;/var&gt; , и если результат не равен &lt;code&gt;nil&lt;/code&gt; , он снова оценивает &lt;var&gt;forms&lt;/var&gt; . Этот процесс повторяется до тех пор, пока &lt;var&gt;condition&lt;/var&gt; станет &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c28c2a35f9d17a3343930a2172690998bd7ed6a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; loops.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; петли.</target>
        </trans-unit>
        <trans-unit id="81be4f19137f9a61fb5ee70cfec51ee80bd453b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wholenump&lt;/code&gt; is a synonym for &lt;code&gt;natnump&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;wholenump&lt;/code&gt; - синоним слова &lt;code&gt;natnump&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c30e3ea56a8b52086eba86f23ff7faec339cb641" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window-preserve-size&lt;/code&gt; installs a window parameter (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) called &lt;code&gt;window-preserved-size&lt;/code&gt; which is consulted by the window resizing functions. This parameter will not prevent resizing the window when the window shows another buffer than the one when &lt;code&gt;window-preserve-size&lt;/code&gt; was invoked or if its size has changed since then.</source>
          <target state="translated">&lt;code&gt;window-preserve-size&lt;/code&gt; устанавливает параметр окна (см. &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Параметры окна&lt;/a&gt; ), называемый &lt;code&gt;window-preserved-size&lt;/code&gt; который используется функциями изменения размера окна. Этот параметр не предотвратит изменение размера окна, когда окно показывает другой буфер, чем тот, который был вызван при вызове &lt;code&gt;window-preserve-size&lt;/code&gt; или если его размер с тех пор изменился.</target>
        </trans-unit>
        <trans-unit id="dfa8c3025baa1619a1cb484a98d518b5cb3a4666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window-preserve-size&lt;/code&gt; is currently invoked by the following functions:</source>
          <target state="translated">&lt;code&gt;window-preserve-size&lt;/code&gt; в настоящее время вызывается следующими функциями:</target>
        </trans-unit>
        <trans-unit id="084ca655493b3ba8f35420163c15a65c888726c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window-text-pixel-size&lt;/code&gt; treats the text displayed in a window as a whole and does not care about the size of individual lines. The following function does.</source>
          <target state="translated">&lt;code&gt;window-text-pixel-size&lt;/code&gt; обрабатывает текст, отображаемый в окне, в целом и не заботится о размере отдельных строк. Следующая функция выполняет.</target>
        </trans-unit>
        <trans-unit id="c2e71a1180aa7a9a3d673745a9a8f4074202f2a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; binds &lt;code&gt;standard-output&lt;/code&gt; to the temporary buffer, then it evaluates the forms in &lt;var&gt;body&lt;/var&gt;. Output using the Lisp output functions within &lt;var&gt;body&lt;/var&gt; goes by default to that buffer (but screen display and messages in the echo area, although they are &amp;ldquo;output&amp;rdquo; in the general sense of the word, are not affected). See &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Output Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; связывает &lt;code&gt;standard-output&lt;/code&gt; с временным буфером, а затем оценивает формы в &lt;var&gt;body&lt;/var&gt; . Вывод с использованием функций вывода Лиспа в &lt;var&gt;body&lt;/var&gt; по умолчанию идет в этот буфер (но отображение экрана и сообщения в эхо-области, хотя они и являются &amp;laquo;выводом&amp;raquo; в общем смысле слова, не затрагиваются). См. &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Функции вывода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e84f2f07e30b4ea5b6c20826c999333168050c7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;word-end&lt;/code&gt;, &lt;code&gt;eow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;word-end&lt;/code&gt; , &lt;code&gt;eow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16546b833113bda25ce2e4419ca8eceff3c8b2e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;word-start&lt;/code&gt;, &lt;code&gt;bow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;word-start&lt;/code&gt; , &lt;code&gt;bow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="827f531e685c5586bab6272e4714cb1f0b74f54f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;word&lt;/code&gt;, &lt;code&gt;wordchar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;word&lt;/code&gt; , &lt;code&gt;wordchar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb2c2f7c4cb32494d97ed15a5af54c85a51810ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xdigit&lt;/code&gt;, &lt;code&gt;hex-digit&lt;/code&gt;, &lt;code&gt;hex&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;xdigit&lt;/code&gt; , &lt;code&gt;hex-digit&lt;/code&gt; , &lt;code&gt;hex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f40edd7b33461714aab3f00a1e35711dbe3ef1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yank&lt;/code&gt; does not alter the contents of the kill ring, unless it used text provided by another program, in which case it pushes that text onto the kill ring. However if &lt;var&gt;arg&lt;/var&gt; is an integer different from one, it rotates the kill ring to place the yanked string at the front.</source>
          <target state="translated">&lt;code&gt;yank&lt;/code&gt; не изменяет содержимое списка уничтожений, если только он не использует текст, предоставленный другой программой, и в этом случае он помещает этот текст в список уничтожений. Однако, если &lt;var&gt;arg&lt;/var&gt; - целое число, отличное от единицы, он поворачивает кольцо уничтожения, чтобы поместить извлеченную строку впереди.</target>
        </trans-unit>
        <trans-unit id="4126970d6a7ed13e2eda65cb72f08e67f0f64f18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yank&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;yank&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9e4d7d0310a3211cb2de0be80e8626f71d3e81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yes-or-no-p&lt;/code&gt; requires more work from the user than &lt;code&gt;y-or-n-p&lt;/code&gt; and is appropriate for more crucial decisions.</source>
          <target state="translated">&lt;code&gt;yes-or-no-p&lt;/code&gt; требует от пользователя больше работы, чем &lt;code&gt;y-or-n-p&lt;/code&gt; и подходит для более важных решений.</target>
        </trans-unit>
        <trans-unit id="4ef594a430773406e23fbc4cd92fa339e01285bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yes-or-no-p&lt;/code&gt; starts by displaying &lt;var&gt;prompt&lt;/var&gt; in the minibuffer, followed by &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;yes-or-no-p&lt;/code&gt; начинается с отображения &lt;var&gt;prompt&lt;/var&gt; в минибуфере, за которым следует '</target>
        </trans-unit>
        <trans-unit id="1bb5dae876438c6d89cc978517eaaf9a3cd5e088" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Backquote constructs&lt;/em&gt; allow you to quote a list, but selectively evaluate elements of that list. In the simplest case, it is identical to the special form &lt;code&gt;quote&lt;/code&gt; (described in the previous section; see &lt;a href=&quot;quoting#Quoting&quot;&gt;Quoting&lt;/a&gt;). For example, these two forms yield identical results:</source>
          <target state="translated">&lt;em&gt;Конструкции обратных кавычек&lt;/em&gt; позволяют цитировать список, но выборочно оценивать элементы этого списка. В простейшем случае он идентичен &lt;code&gt;quote&lt;/code&gt; специальной формы (описанной в предыдущем разделе; см. &lt;a href=&quot;quoting#Quoting&quot;&gt;Цитирование&lt;/a&gt; ). Например, эти две формы дают одинаковые результаты:</target>
        </trans-unit>
        <trans-unit id="52d398a3e39ccaa473ca45e376fe6cbb42cee86c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Base coding systems&lt;/em&gt; such as &lt;code&gt;latin-1&lt;/code&gt; leave the end-of-line conversion unspecified, to be chosen based on the data. &lt;em&gt;Variant coding systems&lt;/em&gt; such as &lt;code&gt;latin-1-unix&lt;/code&gt;, &lt;code&gt;latin-1-dos&lt;/code&gt; and &lt;code&gt;latin-1-mac&lt;/code&gt; specify the end-of-line conversion explicitly as well. Most base coding systems have three corresponding variants whose names are formed by adding &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;В системах базового кодирования,&lt;/em&gt; таких как &lt;code&gt;latin-1&lt;/code&gt; , преобразование конца строки не указывается, и его следует выбирать на основе данных. &lt;em&gt;Системы кодирования вариантов,&lt;/em&gt; такие как &lt;code&gt;latin-1-unix&lt;/code&gt; , &lt;code&gt;latin-1-dos&lt;/code&gt; и &lt;code&gt;latin-1-mac&lt;/code&gt; , также явно определяют преобразование конца строки. Большинство базовых систем кодирования имеют три соответствующих варианта, имена которых образованы добавлением '</target>
        </trans-unit>
        <trans-unit id="51b7d02da1d055c8be3f5ae434d97d9a260939bb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Byte-code function objects&lt;/em&gt; are produced by byte-compiling Lisp code (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;). Internally, a byte-code function object is much like a vector; however, the evaluator handles this data type specially when it appears in a function call. See &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Объекты функций&lt;/em&gt; с байтовым &lt;em&gt;кодом&lt;/em&gt; создаются путем байтовой компиляции кода Lisp (см. &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Байтовая компиляция&lt;/a&gt; ). Внутренне объект функции байт-кода очень похож на вектор; однако оценщик обрабатывает этот тип данных специально, когда он появляется в вызове функции. См. &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Объекты байтового кода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5dbbd81db1ec718403ad921765144545b1bbfac6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Categories&lt;/em&gt; provide an alternate way of classifying characters syntactically. You can define several categories as needed, then independently assign each character to one or more categories. Unlike syntax classes, categories are not mutually exclusive; it is normal for one character to belong to several categories.</source>
          <target state="translated">&lt;em&gt;Категории&lt;/em&gt; предоставляют альтернативный способ синтаксической классификации символов. При необходимости вы можете определить несколько категорий, а затем независимо назначить каждого символа в одну или несколько категорий. В отличие от классов синтаксиса, категории не исключают друг друга; один персонаж может принадлежать к нескольким категориям - это нормально.</target>
        </trans-unit>
        <trans-unit id="1558d6fbf1fe03911a5a03e621568b3d9a4ce168" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Character code conversion&lt;/em&gt; involves conversion between the internal representation of characters used inside Emacs and some other encoding. Emacs supports many different encodings, in that it can convert to and from them. For example, it can convert text to or from encodings such as Latin 1, Latin 2, Latin 3, Latin 4, Latin 5, and several variants of ISO 2022. In some cases, Emacs supports several alternative encodings for the same characters; for example, there are three coding systems for the Cyrillic (Russian) alphabet: ISO, Alternativnyj, and KOI8.</source>
          <target state="translated">&lt;em&gt;Преобразование кода символа&lt;/em&gt; включает преобразование между внутренним представлением символов, используемым внутри Emacs, и некоторой другой кодировкой. Emacs поддерживает множество различных кодировок в том смысле, что он может конвертировать в них и из них. Например, он может преобразовывать текст в такие кодировки, как Latin 1, Latin 2, Latin 3, Latin 4, Latin 5 и несколько вариантов ISO 2022. В некоторых случаях Emacs поддерживает несколько альтернативных кодировок для одних и тех же символов; Например, для кириллического (русского) алфавита существует три системы кодирования: ISO, Альтернативный и KOI8.</target>
        </trans-unit>
        <trans-unit id="2280765473a8763d5ed8fdb811b91a718fab2b2f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Clickable text&lt;/em&gt; is text that can be clicked, with either the mouse or via a keyboard command, to produce some result. Many major modes use clickable text to implement textual hyper-links, or &lt;em&gt;links&lt;/em&gt; for short.</source>
          <target state="translated">&lt;em&gt;Кликабельный текст&lt;/em&gt; - это текст, по которому можно щелкнуть мышью или с помощью клавиатуры для получения определенного результата. Во многих основных режимах используется интерактивный текст для реализации текстовых гиперссылок или для краткости &lt;em&gt;ссылок&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="896ce8b737ceaab656b74c1b4f5d586889200d2b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Completion&lt;/em&gt; is a feature that fills in the rest of a name starting from an abbreviation for it. Completion works by comparing the user&amp;rsquo;s input against a list of valid names and determining how much of the name is determined uniquely by what the user has typed. For example, when you type</source>
          <target state="translated">&lt;em&gt;Завершение&lt;/em&gt; - это функция, которая заполняет оставшуюся часть имени, начиная с его аббревиатуры. Завершение работает путем сравнения ввода пользователя со списком допустимых имен и определения того, какая часть имени определяется однозначно тем, что пользователь ввел. Например, когда вы вводите</target>
        </trans-unit>
        <trans-unit id="63d57554d3523ee752846b3da7ebbb9b7117ca1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Custom themes&lt;/em&gt; are collections of settings that can be enabled or disabled as a unit. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-Themes.html#Custom-Themes&quot;&gt;Custom Themes&lt;/a&gt; in</source>
          <target state="translated">&lt;em&gt;Пользовательские темы&lt;/em&gt; - это наборы настроек, которые можно включать или отключать как единое целое. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-Themes.html#Custom-Themes&quot;&gt;Пользовательские темы&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="270b50969936956a1956fa153a0f3a9a841d65a7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Custom themes&lt;/em&gt; are collections of settings that can be enabled or disabled as a unit. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-Themes.html#Custom-Themes&quot;&gt;Custom Themes&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c2468b329e81a15b4582afd13987bde009bc69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Customizable variables&lt;/em&gt;, also called &lt;em&gt;user options&lt;/em&gt;, are global Lisp variables whose values can be set through the Customize interface. Unlike other global variables, which are defined with &lt;code&gt;defvar&lt;/code&gt; (see &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;), customizable variables are defined using the &lt;code&gt;defcustom&lt;/code&gt; macro. In addition to calling &lt;code&gt;defvar&lt;/code&gt; as a subroutine, &lt;code&gt;defcustom&lt;/code&gt; states how the variable should be displayed in the Customize interface, the values it is allowed to take, etc.</source>
          <target state="translated">&lt;em&gt;Настраиваемые переменные&lt;/em&gt; , также называемые &lt;em&gt;пользовательскими параметрами&lt;/em&gt; , представляют собой глобальные переменные Лиспа, значения которых можно установить через интерфейс настройки. В отличие от других глобальных переменных, которые определяются с &lt;code&gt;defvar&lt;/code&gt; (см. &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Определение переменных&lt;/a&gt; ), настраиваемые переменные определяются с &lt;code&gt;defcustom&lt;/code&gt; макроса defcustom . Помимо вызова &lt;code&gt;defvar&lt;/code&gt; как подпрограммы, &lt;code&gt;defcustom&lt;/code&gt; определяет, как переменная должна отображаться в интерфейсе настройки , какие значения ей разрешено принимать и т. Д.</target>
        </trans-unit>
        <trans-unit id="d2cd1f82937a4eb7683a776100c85b39df7832c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deleting a process&lt;/em&gt; disconnects Emacs immediately from the subprocess. Processes are deleted automatically after they terminate, but not necessarily right away. You can delete a process explicitly at any time. If you explicitly delete a terminated process before it is deleted automatically, no harm results. Deleting a running process sends a signal to terminate it (and its child processes, if any), and calls the process sentinel. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Удаление процесса&lt;/em&gt; немедленно отключает Emacs от подпроцесса. Процессы удаляются автоматически после завершения, но не обязательно сразу. Вы можете в любой момент удалить процесс явно. Если вы явно удалите завершенный процесс до того, как он будет удален автоматически, вреда не будет. Удаление запущенного процесса отправляет сигнал для его завершения (и его дочерних процессов, если таковые имеются) и вызывает дозор процесса. Смотрите &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a04597d44103a66abcb00dff3bbf8451a6cde11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deleting&lt;/em&gt; a window removes it from the frame&amp;rsquo;s window tree. If the window is a live window, it disappears from the screen. If the window is an internal window, its child windows are deleted too.</source>
          <target state="translated">&lt;em&gt;При удалении&lt;/em&gt; окна оно удаляется из дерева окон фрейма. Если окно является живым окном, оно исчезает с экрана. Если окно является внутренним, его дочерние окна также удаляются.</target>
        </trans-unit>
        <trans-unit id="a81cd1d7c6f845c2f4389ced6d9de2027622091f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Desktop Save Mode&lt;/em&gt; is a feature to save the state of Emacs from one session to another. The user-level commands for using Desktop Save Mode are described in the GNU Emacs Manual (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html#Saving-Emacs-Sessions&quot;&gt;Saving Emacs Sessions&lt;/a&gt; in</source>
          <target state="translated">&lt;em&gt;Режим сохранения рабочего стола&lt;/em&gt; - это функция для сохранения состояния Emacs из одного сеанса в другой. Команды уровня пользователя для использования режима сохранения рабочего стола описаны в Руководстве по GNU Emacs (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html#Saving-Emacs-Sessions&quot;&gt;Сохранение сессий Emacs&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="8f3b84f60ad168f36f38e43e2903d9a38bee703c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Desktop Save Mode&lt;/em&gt; is a feature to save the state of Emacs from one session to another. The user-level commands for using Desktop Save Mode are described in the GNU Emacs Manual (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html#Saving-Emacs-Sessions&quot;&gt;Saving Emacs Sessions&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a98088cdd182559754e982a584f93bcf30a3813" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disabling a command&lt;/em&gt; marks the command as requiring user confirmation before it can be executed. Disabling is used for commands which might be confusing to beginning users, to prevent them from using the commands by accident.</source>
          <target state="translated">&lt;em&gt;Отключение команды&lt;/em&gt; помечает команду как требующую подтверждения пользователя перед ее выполнением. Отключение используется для команд, которые могут сбить с толку начинающих пользователей, чтобы предотвратить их случайное использование команд.</target>
        </trans-unit>
        <trans-unit id="eb0a8a9ea212b9db6c42c1e84c8e32063775f5a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Dotted pair notation&lt;/em&gt; is a general syntax for cons cells that represents the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; explicitly. In this syntax, &lt;code&gt;(&lt;var&gt;a&lt;/var&gt; . &lt;var&gt;b&lt;/var&gt;)&lt;/code&gt; stands for a cons cell whose &lt;small&gt;CAR&lt;/small&gt; is the object &lt;var&gt;a&lt;/var&gt; and whose &lt;small&gt;CDR&lt;/small&gt; is the object &lt;var&gt;b&lt;/var&gt;. Dotted pair notation is more general than list syntax because the &lt;small&gt;CDR&lt;/small&gt; does not have to be a list. However, it is more cumbersome in cases where list syntax would work. In dotted pair notation, the list &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Обозначение пунктирной пары&lt;/em&gt; - это общий синтаксис для cons-ячеек, который явно представляет &lt;small&gt;CAR&lt;/small&gt; и &lt;small&gt;CDR&lt;/small&gt; . В этом синтаксисе &lt;code&gt;(&lt;var&gt;a&lt;/var&gt; . &lt;var&gt;b&lt;/var&gt;)&lt;/code&gt; обозначает cons-ячейку, &lt;small&gt;CAR&lt;/small&gt; которой является объектом &lt;var&gt;a&lt;/var&gt; , а &lt;small&gt;CDR&lt;/small&gt; - объектом &lt;var&gt;b&lt;/var&gt; . Обозначение пунктирной пары является более общим, чем синтаксис списка, потому что &lt;small&gt;CDR&lt;/small&gt; не обязательно должен быть списком. Однако это более громоздко в тех случаях, когда синтаксис списка работает. В точечной парной нотации список '</target>
        </trans-unit>
        <trans-unit id="d05af30e83de96c74400c03d5c224bcd479e45b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;End of line conversion&lt;/em&gt; handles three different conventions used on various systems for representing end of line in files. The Unix convention, used on GNU and Unix systems, is to use the linefeed character (also called newline). The DOS convention, used on MS-Windows and MS-DOS systems, is to use a carriage return and a linefeed at the end of a line. The Mac convention is to use just carriage return. (This was the convention used in Classic Mac OS.)</source>
          <target state="translated">&lt;em&gt;Преобразование конца строки&lt;/em&gt; обрабатывает три различных соглашения, используемых в различных системах для представления конца строки в файлах. Соглашение Unix, используемое в системах GNU и Unix, заключается в использовании символа перевода строки (также называемого новой строкой). Соглашение DOS, используемое в системах MS-Windows и MS-DOS, заключается в использовании возврата каретки и перевода строки в конце строки. Соглашение Mac - использовать только возврат каретки. (Это соглашение использовалось в классической Mac OS.)</target>
        </trans-unit>
        <trans-unit id="7525ea7dc927a64f5dc8869487e40c6d636e3777" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Expanding&lt;/em&gt; a file name means converting a relative file name to an absolute one. Since this is done relative to a default directory, you must specify the default directory as well as the file name to be expanded. It also involves expanding abbreviations like</source>
          <target state="translated">&lt;em&gt;Расширение&lt;/em&gt; имени файла означает преобразование относительного имени файла в абсолютное. Поскольку это делается относительно каталога по умолчанию, вы должны указать каталог по умолчанию, а также имя файла, который нужно раскрыть. Это также включает расширение сокращений, таких как</target>
        </trans-unit>
        <trans-unit id="e238173aa0c8a6a07d4777f2af3642f8e79949df" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Experience shows that using dynamic function loading provides benefits that are hardly measurable, so this feature is deprecated since Emacs 27.1.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опыт показывает, что использование динамической загрузки функций дает преимущества, которые трудно измерить, поэтому эта функция устарела, начиная с Emacs 27.1.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d4acaa738d1bb5676446288b0e8540c4e231918" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Face attributes&lt;/em&gt; determine the visual appearance of a face. The following table lists all the face attributes, their possible values, and their effects.</source>
          <target state="translated">&lt;em&gt;Атрибуты лица&lt;/em&gt; определяют внешний вид лица. В следующей таблице перечислены все атрибуты лица, их возможные значения и их эффекты.</target>
        </trans-unit>
        <trans-unit id="012a0b361ae7bc306740626a022ce7edb06aed35" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Filling&lt;/em&gt; means adjusting the lengths of lines (by moving the line breaks) so that they are nearly (but no greater than) a specified maximum width. Additionally, lines can be &lt;em&gt;justified&lt;/em&gt;, which means inserting spaces to make the left and/or right margins line up precisely. The width is controlled by the variable &lt;code&gt;fill-column&lt;/code&gt;. For ease of reading, lines should be no longer than 70 or so columns.</source>
          <target state="translated">&lt;em&gt;Заполнение&lt;/em&gt; означает настройку длины строк (путем перемещения разрывов строк) так, чтобы они были почти (но не больше) указанной максимальной ширины. Кроме того, линии можно выравнивать по &lt;em&gt;ширине&lt;/em&gt; , что означает вставку пробелов для точного выравнивания левого и / или правого полей. Ширина регулируется переменной &lt;code&gt;fill-column&lt;/code&gt; . Для удобства чтения строки не должны быть длиннее 70 столбцов или около того.</target>
        </trans-unit>
        <trans-unit id="6be21549dd8cb0cb5b56d3378fa69c057f0887ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Font Lock mode&lt;/em&gt; is a buffer-local minor mode that automatically attaches &lt;code&gt;face&lt;/code&gt; properties to certain parts of the buffer based on their syntactic role. How it parses the buffer depends on the major mode; most major modes define syntactic criteria for which faces to use in which contexts. This section explains how to customize Font Lock for a particular major mode.</source>
          <target state="translated">&lt;em&gt;Режим Font Lock&lt;/em&gt; - это второстепенный локальный для буфера режим, который автоматически прикрепляет свойства &lt;code&gt;face&lt;/code&gt; к определенным частям буфера в зависимости от их синтаксической роли. Как он анализирует буфер, зависит от основного режима; большинство основных режимов определяют синтаксические критерии того, какие лица использовать в каком контексте. В этом разделе объясняется, как настроить блокировку шрифта для определенного основного режима.</target>
        </trans-unit>
        <trans-unit id="6ebc87bbb7e17bed3e9c29a0284f9bee1e5c5c1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Formatting&lt;/em&gt; means constructing a string by substituting computed values at various places in a constant string. This constant string controls how the other values are printed, as well as where they appear; it is called a &lt;em&gt;format string&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Форматирование&lt;/em&gt; означает построение строки путем замены вычисленных значений в различных местах постоянной строки. Эта постоянная строка контролирует, как печатаются другие значения, а также где они появляются; это называется &lt;em&gt;форматной строкой&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0e507faa00934023f42170624d268ab633490367" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Fringe indicators&lt;/em&gt; are tiny icons displayed in the window fringe to indicate truncated or continued lines, buffer boundaries, etc.</source>
          <target state="translated">&lt;em&gt;Индикаторы краев&lt;/em&gt; - это крошечные значки, отображаемые на краю окна для обозначения усеченных или продолжающихся линий, границ буфера и т. Д.</target>
        </trans-unit>
        <trans-unit id="c4a2bfc783163eddcde352fbc4dd6772b257ca00" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Generic modes&lt;/em&gt; are simple major modes with basic support for comment syntax and Font Lock mode. To define a generic mode, use the macro &lt;code&gt;define-generic-mode&lt;/code&gt;. See the file</source>
          <target state="translated">&lt;em&gt;Общие режимы&lt;/em&gt; - это простые основные режимы с базовой поддержкой синтаксиса комментариев и режима Font Lock. Чтобы определить общий режим, используйте макрос &lt;code&gt;define-generic-mode&lt;/code&gt; . Посмотреть файл</target>
        </trans-unit>
        <trans-unit id="112776f7781a51db193688bdbd2c5e934d7ba37b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Glyphless characters&lt;/em&gt; are characters which are displayed in a special way, e.g., as a box containing a hexadecimal code, instead of being displayed literally. These include characters which are explicitly defined to be glyphless, as well as characters for which there is no available font (on a graphical display), and characters which cannot be encoded by the terminal&amp;rsquo;s coding system (on a text terminal).</source>
          <target state="translated">&lt;em&gt;Символы без глифов&lt;/em&gt; - это символы, которые отображаются особым образом, например, как поле, содержащее шестнадцатеричный код, вместо того, чтобы отображаться буквально. К ним относятся символы, которые явно определены как не содержащие глифов, а также символы, для которых нет доступного шрифта (на графическом дисплее), и символы, которые не могут быть закодированы системой кодирования терминала (на текстовом терминале).</target>
        </trans-unit>
        <trans-unit id="4fcbce64e8b9f4d24225b3774ba8d80b3cad522d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Horizontal scrolling&lt;/em&gt; means shifting the image in the window left or right by a specified multiple of the normal character width. Each window has a &lt;em&gt;horizontal scroll position&lt;/em&gt;, which is a number, never less than zero. It specifies how far to shift the contents left. Shifting the window contents left generally makes all or part of some characters disappear off the left, and all or part of some other characters appear at the right. The usual value is zero.</source>
          <target state="translated">&lt;em&gt;Горизонтальная прокрутка&lt;/em&gt; означает сдвиг изображения в окне влево или вправо на заданную кратную ширину обычного символа. Каждое окно имеет &lt;em&gt;горизонтальную позицию прокрутки&lt;/em&gt; , которая представляет собой число, которое не может быть меньше нуля. Он указывает, как далеко сдвинуть содержимое влево. Сдвиг содержимого окна влево обычно приводит к тому, что некоторые символы полностью или частично исчезают слева, а некоторые другие символы полностью или частично появляются справа. Обычное значение равно нулю.</target>
        </trans-unit>
        <trans-unit id="93402787644d1d7eafe5bba491536d2c7912cfa7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Imenu&lt;/em&gt; is a feature that lets users select a definition or section in the buffer, from a menu which lists all of them, to go directly to that location in the buffer. Imenu works by constructing a buffer index which lists the names and buffer positions of the definitions, or other named portions of the buffer; then the user can choose one of them and move point to it. Major modes can add a menu bar item to use Imenu using &lt;code&gt;imenu-add-to-menubar&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Imenu&lt;/em&gt; - это функция, которая позволяет пользователям выбрать определение или раздел в буфере из меню, в котором перечислены все из них, чтобы перейти непосредственно к этому месту в буфере. Imenu работает путем создания индекса буфера, в котором перечислены имена и позиции определений или других именованных частей буфера; затем пользователь может выбрать один из них и переместить на него точку. В основных режимах можно добавить элемент строки меню для использования Imenu с помощью &lt;code&gt;imenu-add-to-menubar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d23fc3b6ee48861c0752ea1530c14e065028d3f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Input methods&lt;/em&gt; provide convenient ways of entering non-</source>
          <target state="translated">&lt;em&gt;Методы ввода&lt;/em&gt; предоставляют удобные способы ввода не-</target>
        </trans-unit>
        <trans-unit id="3ee20567a4dabe85bc7a2e8fd9c60352f47fec7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Insertion&lt;/em&gt; means adding new text to a buffer. The inserted text goes at point&amp;mdash;between the character before point and the character after point. Some insertion functions leave point before the inserted text, while other functions leave it after. We call the former insertion &lt;em&gt;after point&lt;/em&gt; and the latter insertion &lt;em&gt;before point&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Вставка&lt;/em&gt; означает добавление нового текста в буфер. Вставленный текст идет в точке - между символом перед точкой и символом после точки. Некоторые функции вставки оставляют точку перед вставленным текстом, в то время как другие функции оставляют ее после. Мы называем первую вставку &lt;em&gt;после точки,&lt;/em&gt; а вторую - &lt;em&gt;до точки&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="450e3407eb4f03adcc2aec7c838ee4624ba54573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Key lookup&lt;/em&gt; is the process of finding the binding of a key sequence from a given keymap. The execution or use of the binding is not part of key lookup.</source>
          <target state="translated">&lt;em&gt;Поиск ключей&lt;/em&gt; - это процесс поиска привязки последовательности ключей из заданной раскладки клавиатуры. Выполнение или использование привязки не является частью поиска ключа.</target>
        </trans-unit>
        <trans-unit id="8fa89626f95af4781c407f7abfa45810f2067b99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Kill functions&lt;/em&gt; delete text like the deletion functions, but save it so that the user can reinsert it by &lt;em&gt;yanking&lt;/em&gt;. Most of these functions have &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Функции&lt;/em&gt; удаления удаляют текст, как функции удаления, но сохраняют его, чтобы пользователь мог повторно вставить его, &lt;em&gt;дергая&lt;/em&gt; . Большинство этих функций имеют '</target>
        </trans-unit>
        <trans-unit id="e750f743a960078ed373cd9c29df128dfa4aef0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Killing a buffer&lt;/em&gt; makes its name unknown to Emacs and makes the memory space it occupied available for other use.</source>
          <target state="translated">&lt;em&gt;Удаление буфера&lt;/em&gt; делает его имя неизвестным Emacs и делает занимаемое им пространство памяти доступным для другого использования.</target>
        </trans-unit>
        <trans-unit id="d02ce601b5b10f3d058800e2800ad7f708907fbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Macros&lt;/em&gt; enable you to define new control constructs and other language features. A macro is defined much like a function, but instead of telling how to compute a value, it tells how to compute another Lisp expression which will in turn compute the value. We call this expression the &lt;em&gt;expansion&lt;/em&gt; of the macro.</source>
          <target state="translated">&lt;em&gt;Макросы&lt;/em&gt; позволяют определять новые управляющие конструкции и другие языковые функции. Макрос определяется во многом как функция, но вместо того, чтобы сообщать, как вычислить значение, он сообщает, как вычислить другое выражение Лиспа, которое, в свою очередь, вычислит значение. Мы называем это выражение &lt;em&gt;расширением&lt;/em&gt; макроса.</target>
        </trans-unit>
        <trans-unit id="b7f04fd1b052b638ef4bddfcc5d3e36d470f8ae2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Narrowing&lt;/em&gt; means limiting the text addressable by Emacs editing commands to a limited range of characters in a buffer. The text that remains addressable is called the &lt;em&gt;accessible portion&lt;/em&gt; of the buffer.</source>
          <target state="translated">&lt;em&gt;Сужение&lt;/em&gt; означает ограничение текста, адресуемого командами редактирования Emacs, ограниченным диапазоном символов в буфере. Текст, который остается адресуемым, называется &lt;em&gt;доступной частью&lt;/em&gt; буфера.</target>
        </trans-unit>
        <trans-unit id="f76cc0b3cbad8d2db0f2f0631879949e24049985" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Point&lt;/em&gt; is a special buffer position used by many editing commands, including the self-inserting typed characters and text insertion functions. Other commands move point through the text to allow editing and insertion at different places.</source>
          <target state="translated">&lt;em&gt;Точка&lt;/em&gt; - это специальная позиция в буфере, используемая многими командами редактирования, включая самовставляющиеся печатные символы и функции вставки текста. Другие команды перемещают точку по тексту, чтобы можно было редактировать и вставлять в разных местах.</target>
        </trans-unit>
        <trans-unit id="4f1d8b41be48e34b694c6ff7cfd0bf33a88ecdc2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Printing&lt;/em&gt; a Lisp object means producing text that represents that object&amp;mdash;converting the object to its &lt;em&gt;printed representation&lt;/em&gt; (see &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Printed Representation&lt;/a&gt;). Printing the cons cell described above produces the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Печать&lt;/em&gt; объекта Lisp означает создание текста, представляющего этот объект, - преобразование объекта в его &lt;em&gt;печатное представление&lt;/em&gt; (см. &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Печатное представление&lt;/a&gt; ). Печать cons-ячейки, описанной выше, дает текст '</target>
        </trans-unit>
        <trans-unit id="3486a4d997a0991471cc5bda965e32d990483810" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Printing&lt;/em&gt; and &lt;em&gt;reading&lt;/em&gt; are the operations of converting Lisp objects to textual form and vice versa. They use the printed representations and read syntax described in &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Печать&lt;/em&gt; и &lt;em&gt;чтение&lt;/em&gt; - это операции преобразования объектов Лиспа в текстовую форму и наоборот. Они используют печатные представления и синтаксис чтения, описанные в &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Типах данных Лиспа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f09674ebe8ae04d0dfaa08942261acf706c3808" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Radio buttons&lt;/em&gt; are a group of menu items, in which at any time one and only one is selected. There should be a variable whose value says which one is selected at any time. The &lt;var&gt;selected&lt;/var&gt; form for each radio button in the group should check whether the variable has the right value for selecting that button. Clicking on the button should set the variable so that the button you clicked on becomes selected.</source>
          <target state="translated">&lt;em&gt;Радиокнопки&lt;/em&gt; - это группа пунктов меню, в которых в любой момент может быть выбран один и только один. Должна быть переменная, значение которой указывает, какая из них выбирается в любой момент. &lt;var&gt;selected&lt;/var&gt; форма для каждой кнопки радио в группе должны проверить , имеет ли переменная правильное значение для выбора этой кнопки. Нажатие на кнопку должно установить переменную так, чтобы кнопка, на которую вы нажали, стала выбранной.</target>
        </trans-unit>
        <trans-unit id="ab34954a6344cc9f97aee9484c997887b7839fdc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Raw bytes&lt;/em&gt; are non-</source>
          <target state="translated">&lt;em&gt;Необработанные байты не&lt;/em&gt; являются</target>
        </trans-unit>
        <trans-unit id="ed4269883b3c79ca4adc800e4219a3f334e69fa5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reading&lt;/em&gt; a Lisp object means parsing a Lisp expression in textual form and producing a corresponding Lisp object. This is how Lisp programs get into Lisp from files of Lisp code. We call the text the &lt;em&gt;read syntax&lt;/em&gt; of the object. For example, the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Чтение&lt;/em&gt; объекта Лиспа означает анализ выражения Лиспа в текстовой форме и создание соответствующего объекта Лиспа. Вот как программы на Лиспе попадают в Лисп из файлов кода Лисп. Мы называем текст &lt;em&gt;синтаксисом чтения&lt;/em&gt; объекта. Например, текст '</target>
        </trans-unit>
        <trans-unit id="542ea923b04cc1dd1ce08b789da1b9d9a6edaf8f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SVG paths&lt;/em&gt; allow creation of complex images by combining lines, curves, arcs, and other basic shapes. The functions described below allow invoking SVG path commands from a Lisp program.</source>
          <target state="translated">&lt;em&gt;Пути SVG&lt;/em&gt; позволяют создавать сложные изображения, комбинируя линии, кривые, дуги и другие основные формы. Описанные ниже функции позволяют вызывать команды пути SVG из программы на Лиспе.</target>
        </trans-unit>
        <trans-unit id="73c188badc81bf3fc4092200e27bb45f1e16c9ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Selective display&lt;/em&gt; refers to a pair of related features for hiding certain lines on the screen.</source>
          <target state="translated">&lt;em&gt;Под выборочным отображением&lt;/em&gt; понимается пара связанных функций для скрытия определенных строк на экране.</target>
        </trans-unit>
        <trans-unit id="bf63ae9c067ac9de03cc843159e0246f28041dea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Sending a signal&lt;/em&gt; to a subprocess is a way of interrupting its activities. There are several different signals, each with its own meaning. The set of signals and their names is defined by the operating system. For example, the signal &lt;code&gt;SIGINT&lt;/code&gt; means that the user has typed</source>
          <target state="translated">&lt;em&gt;Отправка сигнала&lt;/em&gt; подпроцессу - это способ прервать его деятельность. Есть несколько разных сигналов, каждый из которых имеет свое значение. Набор сигналов и их названия определяются операционной системой. Например, сигнал &lt;code&gt;SIGINT&lt;/code&gt; означает, что пользователь набрал</target>
        </trans-unit>
        <trans-unit id="8517a23cb3410f1a9a7dbb62a23f1121a3f4bfb7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Signaling&lt;/em&gt; an error means beginning error processing. Error processing normally aborts all or part of the running program and returns to a point that is set up to handle the error (see &lt;a href=&quot;processing-of-errors#Processing-of-Errors&quot;&gt;Processing of Errors&lt;/a&gt;). Here we describe how to signal an error.</source>
          <target state="translated">&lt;em&gt;Сообщение&lt;/em&gt; об ошибке означает начало обработки ошибки. Обработка ошибок обычно прерывает всю или часть выполняющейся программы и возвращается к точке, настроенной для обработки ошибки (см. &lt;a href=&quot;processing-of-errors#Processing-of-Errors&quot;&gt;Обработка ошибок&lt;/a&gt; ). Здесь мы описываем, как сигнализировать об ошибке.</target>
        </trans-unit>
        <trans-unit id="4e9d8ee4cad5d0529cec696f38446bdf19fdb896" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Textual scrolling&lt;/em&gt; means moving the text up or down through a window. It works by changing the window&amp;rsquo;s display-start location. It may also change the value of &lt;code&gt;window-point&lt;/code&gt; to keep point on the screen (see &lt;a href=&quot;window-point#Window-Point&quot;&gt;Window Point&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Текстовая прокрутка&lt;/em&gt; означает перемещение текста вверх или вниз в окне. Он работает, изменяя положение начала отображения окна. Он также может изменить значение &lt;code&gt;window-point&lt;/code&gt; чтобы точка оставалась на экране (см. &lt;a href=&quot;window-point#Window-Point&quot;&gt;Точка окна&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9740e3157a8155d498bbc4297186350c293bbe46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Tooltips&lt;/em&gt; are special frames (see &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;) that are used to display helpful hints (a.k.a. &amp;ldquo;tips&amp;rdquo;) related to the current position of the mouse pointer. Emacs uses tooltips to display help strings about active portions of text (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;) and about various UI elements, such as menu items (see &lt;a href=&quot;extended-menu-items#Extended-Menu-Items&quot;&gt;Extended Menu Items&lt;/a&gt;) and tool-bar buttons (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Всплывающие подсказки&lt;/em&gt; - это специальные фреймы (см. &amp;laquo; &lt;a href=&quot;frames#Frames&quot;&gt;Фреймы&amp;raquo;&lt;/a&gt; ), которые используются для отображения полезных подсказок (так называемых &amp;laquo;подсказок&amp;raquo;), связанных с текущим положением указателя мыши. Emacs использует всплывающие подсказки для отображения строк справки об активных частях текста (см. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&lt;/a&gt; ) и о различных элементах пользовательского интерфейса, таких как пункты меню (см. &lt;a href=&quot;extended-menu-items#Extended-Menu-Items&quot;&gt;Расширенные элементы меню&lt;/a&gt; ) и кнопки панели инструментов (см. Панель &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;инструментов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f32db6bb4b57bc264e0f679447e2ae5d29a9ba1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Vertical fractional scrolling&lt;/em&gt; means shifting text in a window up or down by a specified multiple or fraction of a line. Emacs uses it, for example, on images and screen lines which are taller than the window. Each window has a &lt;em&gt;vertical scroll position&lt;/em&gt;, which is a number, never less than zero. It specifies how far to raise the contents of the window when displaying them. Raising the window contents generally makes all or part of some lines disappear off the top, and all or part of some other lines appear at the bottom. The usual value is zero.</source>
          <target state="translated">&lt;em&gt;Вертикальная дробная прокрутка&lt;/em&gt; означает сдвиг текста в окне вверх или вниз на указанное кратное или дробное значение строки. Emacs использует его, например, на изображениях и строках экрана, которые выше окна. Каждое окно имеет &lt;em&gt;позицию вертикальной прокрутки&lt;/em&gt; , которая представляет собой число, которое не может быть меньше нуля. Он указывает, насколько далеко поднимать содержимое окна при его отображении. Поднятие содержимого окна обычно приводит к тому, что некоторые строки полностью или частично исчезают сверху, а некоторые другие строки полностью или частично появляются внизу. Обычное значение равно нулю.</target>
        </trans-unit>
        <trans-unit id="bd79e7372baa17750e541bfbfffa6606962eb07f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning&lt;/em&gt;: Since the result is floating point, it may not be exact. Do not use this function if precise time stamps are required. For example, on typical systems &lt;code&gt;(float-time '(1 . 10))&lt;/code&gt; displays as &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Предупреждение&lt;/em&gt; : поскольку результат является плавающим, он может быть неточным. Не используйте эту функцию, если требуются точные отметки времени. Например, в типичных системах &lt;code&gt;(float-time '(1 . 10))&lt;/code&gt; отображается как'</target>
        </trans-unit>
        <trans-unit id="b7ead6f25bbfb241ae5a10952f368db3cd8e2925" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warnings&lt;/em&gt; are a facility for a program to inform the user of a possible problem, but continue running.</source>
          <target state="translated">&lt;em&gt;Предупреждения&lt;/em&gt; - это средство, с помощью которого программа сообщает пользователю о возможной проблеме, но продолжает работу.</target>
        </trans-unit>
        <trans-unit id="5800c704dda84085ba62504ba165321ee93d8e57" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;autoload object&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;объект автозагрузки&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8ae8f2277c5b62b3d53dc4d888c37dc29d4b795a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;byte-code function&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;функция байтового кода&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb6a46032363c9a7fc5a4b8a88bdcede5d9a80aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;closure&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;closure&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9be7baeb66ad7e95f9d0eded08808a28a890c19a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;command&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;command&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="661ff4cb9bee36474098da7a6f259f9a4407b987" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;lambda expression&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;лямбда-выражение&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed4a26bd2219a669612e9e3c2b7b5c6da73a19c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;macro&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;macro&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e5e68111703f0fb6a63a3104797560ce66e23edc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;primitive&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;primitive&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9022b2a3b0031d43e1cc771ebb9cb4bda490457" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;special form&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;особая форма&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd34485d7828eb7e27180a104aa1a4cd030fa4b5" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;ASCII&lt;/small&gt; control characters such as</source>
          <target state="translated">&lt;small&gt;&lt;/small&gt;Управляющие символы &lt;small&gt;ASCII,&lt;/small&gt; такие как</target>
        </trans-unit>
        <trans-unit id="70306c232df57307eafd76afbab83c839cc46f47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; it is easy to make a mistake when using the &lt;code&gt;save-restriction&lt;/code&gt; construct. Read the entire description here before you try it.</source>
          <target state="translated">&lt;strong&gt;Осторожно:&lt;/strong&gt; при использовании конструкции &lt;code&gt;save-restriction&lt;/code&gt; легко ошибиться . Прочтите полное описание здесь, прежде чем попробовать.</target>
        </trans-unit>
        <trans-unit id="fedd7bf18771ffbebe7137b31f6e3297e5df6d53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Common Lisp Note:&lt;/strong&gt; At top level, &lt;code&gt;eval-when-compile&lt;/code&gt; is analogous to the Common Lisp idiom &lt;code&gt;(eval-when (compile eval) &amp;hellip;)&lt;/code&gt;. Elsewhere, the Common Lisp &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;Замечание по Common Lisp:&lt;/strong&gt; На верхнем уровне &lt;code&gt;eval-when-compile&lt;/code&gt; аналогичен идиоме Common Lisp &lt;code&gt;(eval-when (compile eval) &amp;hellip;)&lt;/code&gt; . В другом месте Common Lisp '</target>
        </trans-unit>
        <trans-unit id="4e710f2d7f73f4a8fe8b17904699b0f862c6c885" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Common Lisp Note:&lt;/strong&gt; Common Lisp has different meanings for &lt;var&gt;dow&lt;/var&gt; and &lt;var&gt;utcoff&lt;/var&gt;, and its &lt;var&gt;second&lt;/var&gt; is an integer between 0 and 59 inclusive.</source>
          <target state="translated">&lt;strong&gt;Common Lisp Примечание:&lt;/strong&gt; Common Lisp имеет различные значения для &lt;var&gt;dow&lt;/var&gt; и &lt;var&gt;utcoff&lt;/var&gt; , а его &lt;var&gt;second&lt;/var&gt; представляет собой целое число от 0 до 59 включительно.</target>
        </trans-unit>
        <trans-unit id="40ee60ee9fcbc30da4bad494a245522e8219bb9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not try to put symbols in an obarray yourself.&lt;/strong&gt; This does not work&amp;mdash;only &lt;code&gt;intern&lt;/code&gt; can enter a symbol in an obarray properly.</source>
          <target state="translated">&lt;strong&gt;Не пытайтесь самостоятельно складывать символы в матрицу.&lt;/strong&gt; Это не работает - только &lt;code&gt;intern&lt;/code&gt; может правильно ввести символ в массив.</target>
        </trans-unit>
        <trans-unit id="38de59784bef692535056aa1a8f0e471c6f3a1f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MS-DOS note:&lt;/strong&gt; On MS-DOS, there is no such thing as an executable file mode bit. So &lt;code&gt;file-modes&lt;/code&gt; considers a file executable if its name ends in one of the standard executable extensions, such as</source>
          <target state="translated">&lt;strong&gt;Примечание для MS-DOS: в&lt;/strong&gt; MS-DOS нет такой вещи, как бит режима исполняемого файла. Таким образом, &lt;code&gt;file-modes&lt;/code&gt; считают файл исполняемым, если его имя заканчивается одним из стандартных исполняемых расширений, например</target>
        </trans-unit>
        <trans-unit id="6d4102b9a0d3b47cc4a8ba5dd78a2e9f73e6b1b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; Each &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;Обратите внимание:&lt;/strong&gt; каждый '</target>
        </trans-unit>
        <trans-unit id="6aae4a6180fd094fd06245c7fbdba28ea2ad76d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; For historical compatibility, special characters are treated as ordinary ones if they are in contexts where their special meanings make no sense. For example, &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;Обратите внимание:&lt;/strong&gt; для исторической совместимости специальные символы рассматриваются как обычные, если они находятся в контексте, в котором их особое значение не имеет смысла. Например, '</target>
        </trans-unit>
        <trans-unit id="e1c151cdbdbd417cac114e5aec12f7f9f9b66ea0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; The argument &lt;var&gt;program&lt;/var&gt; contains only the name of the program file; it may not contain any command-line arguments. You must use a separate argument, &lt;var&gt;args&lt;/var&gt;, to provide those, as described below.</source>
          <target state="translated">&lt;strong&gt;Обратите внимание:&lt;/strong&gt; аргумент &lt;var&gt;program&lt;/var&gt; содержит только имя файла программы; он не может содержать аргументов командной строки. Вы должны использовать отдельный аргумент &lt;var&gt;args&lt;/var&gt; для их предоставления, как описано ниже.</target>
        </trans-unit>
        <trans-unit id="3e5f3511148dd7847670eff73efe5ab3c4fa41c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; Use this function only if you want the user to see that the mark has moved, and you want the previous mark position to be lost. Normally, when a new mark is set, the old one should go on the &lt;code&gt;mark-ring&lt;/code&gt;. For this reason, most applications should use &lt;code&gt;push-mark&lt;/code&gt; and &lt;code&gt;pop-mark&lt;/code&gt;, not &lt;code&gt;set-mark&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Обратите внимание:&lt;/strong&gt; используйте эту функцию только в том случае, если вы хотите, чтобы пользователь увидел, что метка переместилась, и вы хотите, чтобы предыдущее положение метки было потеряно. Обычно, когда устанавливается новая отметка, старая должна помещаться на &lt;code&gt;mark-ring&lt;/code&gt; . По этой причине в большинстве приложений следует использовать &lt;code&gt;push-mark&lt;/code&gt; и &lt;code&gt;pop-mark&lt;/code&gt; , а не &lt;code&gt;set-mark&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5a80c4486e1ea38490953d74749fe3a3c8c080" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt;&lt;code&gt;create-file-buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; associate the new buffer with a file and does not select the buffer. It also does not use the default major mode.</source>
          <target state="translated">&lt;strong&gt;Пожалуйста , обратите внимание: &lt;/strong&gt; &lt;code&gt;create-file-buffer&lt;/code&gt; никак &lt;em&gt;не&lt;/em&gt; ассоциируется новый буфер с файлом и не выбирает буфер. Он также не использует основной режим по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a645ff0054371611b3b65b133b649ed3610b6564" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage note:&lt;/strong&gt; Don&amp;rsquo;t use &lt;code&gt;x-popup-menu&lt;/code&gt; to display a menu if you could do the job with a prefix key defined with a menu keymap. If you use a menu keymap to implement a menu,</source>
          <target state="translated">&lt;strong&gt;Примечание по использованию:&lt;/strong&gt; не используйте &lt;code&gt;x-popup-menu&lt;/code&gt; для отображения меню, если вы можете выполнить задание с помощью префиксной клавиши, определенной с помощью раскладки меню. Если вы используете раскладку меню для реализации меню,</target>
        </trans-unit>
        <trans-unit id="da6799279e920a1a3a23e11b28477a3c522ee7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Changing the string by substituting characters does change the name of the symbol, but fails to update the obarray, so don&amp;rsquo;t do it!</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; изменение строки путем замены символов меняет имя символа, но не обновляет массив, поэтому не делайте этого!</target>
        </trans-unit>
        <trans-unit id="f42b1c51152dd5561d6e32556f381fe792e7644d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Coding systems such as &lt;code&gt;undecided&lt;/code&gt;, which determine the coding system from the data, do not work entirely reliably with asynchronous subprocess output. This is because Emacs handles asynchronous subprocess output in batches, as it arrives. If the coding system leaves the character code conversion unspecified, or leaves the end-of-line conversion unspecified, Emacs must try to detect the proper conversion from one batch at a time, and this does not always work.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; системы кодирования, такие как &lt;code&gt;undecided&lt;/code&gt; , которые определяют систему кодирования по данным, не работают полностью надежно с асинхронным выводом подпроцесса. Это потому, что Emacs обрабатывает вывод асинхронного подпроцесса пакетами по мере его поступления. Если система кодирования оставляет неуказанное преобразование кода символа или оставляет неопределенным преобразование конца строки, Emacs должен попытаться определить правильное преобразование из одного пакета за раз, а это не всегда работает.</target>
        </trans-unit>
        <trans-unit id="d7a32311cb98f8982192a3a0cfb3fbd4012739fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Coding systems such as &lt;code&gt;undecided&lt;/code&gt;, which determine the coding system from the data, do not work entirely reliably with asynchronous subprocess output. This is because Emacs has to process asynchronous subprocess output in batches, as it arrives. Emacs must try to detect the proper coding system from one batch at a time, and this does not always work. Therefore, if at all possible, specify a coding system that determines both the character code conversion and the end of line conversion&amp;mdash;that is, one like &lt;code&gt;latin-1-unix&lt;/code&gt;, rather than &lt;code&gt;undecided&lt;/code&gt; or &lt;code&gt;latin-1&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; системы кодирования, такие как &lt;code&gt;undecided&lt;/code&gt; , которые определяют систему кодирования по данным, не работают полностью надежно с асинхронным выводом подпроцесса. Это потому, что Emacs должен обрабатывать вывод асинхронного подпроцесса пакетами по мере его поступления. Emacs должен пытаться определить правильную систему кодирования по одному пакету за раз, и это не всегда работает. Поэтому, если это вообще возможно, укажите систему кодирования, которая определяет как преобразование кода символа, так и преобразование конца строки, то есть такую, как &lt;code&gt;latin-1-unix&lt;/code&gt; , а не &lt;code&gt;undecided&lt;/code&gt; или &lt;code&gt;latin-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36f77abc0ee8492d9c84e64781a102965a17ca14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do not design an element of &lt;code&gt;font-lock-keywords&lt;/code&gt; to match text which spans lines; this does not work reliably. For details, see &lt;a href=&quot;multiline-font-lock#Multiline-Font-Lock&quot;&gt;Multiline Font Lock&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; не создавайте элемент &lt;code&gt;font-lock-keywords&lt;/code&gt; соответствующий тексту, который охватывает строки; это не работает надежно. Подробнее см. &lt;a href=&quot;multiline-font-lock#Multiline-Font-Lock&quot;&gt;Блокировка многострочного шрифта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85a74edcffc0a92c3e7b4d248d547a8ecec6f582" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Don&amp;rsquo;t assume that you should use &lt;code&gt;make-variable-buffer-local&lt;/code&gt; for user-option variables, simply because users &lt;em&gt;might&lt;/em&gt; want to customize them differently in different buffers. Users can make any variable local, when they wish to. It is better to leave the choice to them.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; не думайте, что вы должны использовать &lt;code&gt;make-variable-buffer-local&lt;/code&gt; для переменных-параметров пользователя просто потому, что пользователи &lt;em&gt;могут&lt;/em&gt; захотеть настроить их по-разному в разных буферах. Пользователи могут сделать любую переменную локальной, когда захотят. Лучше оставить выбор за ними.</target>
        </trans-unit>
        <trans-unit id="5c82827514f3c4432ba7da9ea921f90a74bde2b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Don&amp;rsquo;t use this function in Lisp programs!</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; не используйте эту функцию в программах на Лиспе!</target>
        </trans-unit>
        <trans-unit id="91b5bf064a888797b6873fc939ffb0b98c08f120" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the changes you combine occur in widely scattered parts of the buffer, this will still work, but it is not advisable, because it may lead to inefficient behavior for some change hook functions.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если изменения, которые вы объединяете, происходят в сильно разбросанных частях буфера, это все равно будет работать, но это не рекомендуется, потому что это может привести к неэффективному поведению некоторых функций ловушки изменений.</target>
        </trans-unit>
        <trans-unit id="45e9aba6be8fa67b5877a89186eb307eaa7e3eea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If this function is called from within a &lt;code&gt;save-excursion&lt;/code&gt; form, the current buffer will be set to &lt;var&gt;buffer&lt;/var&gt; upon leaving the form, since the marker used by &lt;code&gt;save-excursion&lt;/code&gt; to save the position and buffer will be swapped as well.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если эта функция вызывается из формы &lt;code&gt;save-excursion&lt;/code&gt; , текущий буфер будет установлен в &lt;var&gt;buffer&lt;/var&gt; при выходе из формы, так как маркер, используемый &lt;code&gt;save-excursion&lt;/code&gt; для сохранения положения и буфера, также будет заменен местами.</target>
        </trans-unit>
        <trans-unit id="2bbac455862d3d9d7a2292fdfceca6f3801d0b5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you use a &lt;code&gt;defconst&lt;/code&gt; or &lt;code&gt;defvar&lt;/code&gt; special form while the variable has a local binding (made with &lt;code&gt;let&lt;/code&gt;, or a function argument), it sets the local binding rather than the global binding. This is not what you usually want. To prevent this, use these special forms at top level in a file, where normally no local binding is in effect, and make sure to load the file before making a local binding for the variable.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если вы используете специальную форму &lt;code&gt;defconst&lt;/code&gt; или &lt;code&gt;defvar&lt;/code&gt; , когда переменная имеет локальную привязку (сделанную с помощью &lt;code&gt;let&lt;/code&gt; или аргумента функции), она устанавливает локальную привязку, а не глобальную привязку. Это не то, чего вы обычно хотите. Чтобы предотвратить это, используйте эти специальные формы на верхнем уровне в файле, где обычно не действует локальная привязка, и обязательно загрузите файл перед выполнением локальной привязки для переменной.</target>
        </trans-unit>
        <trans-unit id="05119ee0b2d49b617152ce6e37a3484e14f71a9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you want to use your own string as a message verbatim, don&amp;rsquo;t just write &lt;code&gt;(message &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;. If &lt;var&gt;string&lt;/var&gt; contains &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если вы хотите использовать свою собственную строку в качестве дословного сообщения, не пишите просто &lt;code&gt;(message &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; . Если &lt;var&gt;string&lt;/var&gt; содержит '</target>
        </trans-unit>
        <trans-unit id="33ecfae8a5840f6e86defbbccc38ab13acbfcf98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you want to use your own string as an error message verbatim, don&amp;rsquo;t just write &lt;code&gt;(error &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;. If &lt;var&gt;string&lt;/var&gt;&lt;var&gt;string&lt;/var&gt; contains &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; Если вы хотите использовать свою собственную строку в качестве дословного сообщения об ошибке, не просто пишите &lt;code&gt;(error &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; . Если &lt;var&gt;string&lt;/var&gt; &lt;var&gt;string&lt;/var&gt; содержит '</target>
        </trans-unit>
        <trans-unit id="064430ad9cf0c8b3dcd0d4417ee59ce9c6716cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; In most cases, you should not use this function; use &lt;code&gt;make-temp-file&lt;/code&gt; instead! This function is susceptible to a race condition, between the &lt;code&gt;make-temp-name&lt;/code&gt; call and the creation of the file, which in some cases may cause a security hole.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; в большинстве случаев вам не следует использовать эту функцию; используйте вместо этого &lt;code&gt;make-temp-file&lt;/code&gt; ! Эта функция восприимчива к состоянию гонки между вызовом &lt;code&gt;make-temp-name&lt;/code&gt; и созданием файла, что в некоторых случаях может вызвать брешь в безопасности.</target>
        </trans-unit>
        <trans-unit id="df977bf7983dca5df5b615b10e538a2c0edadc3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Major mode commands must not call &lt;code&gt;font-lock-add-keywords&lt;/code&gt; under any circumstances, either directly or indirectly, except through their mode hooks. (Doing so would lead to incorrect behavior for some minor modes.) They should set up their rules for search-based fontification by setting &lt;code&gt;font-lock-keywords&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; команды основного режима ни при каких обстоятельствах не должны вызывать &lt;code&gt;font-lock-add-keywords&lt;/code&gt; , прямо или косвенно, кроме как через их обработчики режима. (Это может привести к некорректному поведению некоторых второстепенных режимов.) Им следует установить свои правила для фонификации на основе поиска, задав &lt;code&gt;font-lock-keywords&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bb321756a7688c8a3f5e181b1d0cb5de59a639b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Nested repetition operators can run for an indefinitely long time, if they lead to ambiguous matching. For example, trying to match the regular expression &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; вложенные операторы повторения могут работать бесконечно долго, если они приводят к неоднозначному сопоставлению. Например, при попытке сопоставить регулярное выражение '</target>
        </trans-unit>
        <trans-unit id="23aa90d6d2217d7cb5e63a09251ea382a0ae7f51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Ordinary insertion of text adjacent to the saved point value relocates the saved value, just as it relocates all markers. More precisely, the saved value is a marker with insertion type &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;. Therefore, when the saved point value is restored, it normally comes before the inserted text.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; Обычная вставка текста рядом с сохраненным значением точки перемещает сохраненное значение так же, как перемещает все маркеры. Точнее, сохраненное значение представляет собой маркер с типом вставки &lt;code&gt;nil&lt;/code&gt; . См. &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Типы вставки маркеров&lt;/a&gt; . Поэтому, когда сохраненное значение точки восстанавливается, оно обычно появляется перед вставленным текстом.</target>
        </trans-unit>
        <trans-unit id="1e57b0c0a7f9166cb502f50cdef1217f6faa77be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Setting this variable to non-&lt;code&gt;nil&lt;/code&gt; may have annoying effects. Various parts of Emacs catch errors in the normal course of affairs, and you may not even realize that errors happen there. If you need to debug code wrapped in &lt;code&gt;condition-case&lt;/code&gt;, consider using &lt;code&gt;condition-case-unless-debug&lt;/code&gt; (see &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Handling Errors&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; установка для этой переменной значения, отличного от &lt;code&gt;nil&lt;/code&gt; , может иметь неприятные последствия. Различные части Emacs улавливают ошибки в ходе обычных дел, и вы можете даже не осознавать, что там ошибки случаются. Если вам нужно отладить код, заключенный в &lt;code&gt;condition-case&lt;/code&gt; , рассмотрите возможность использования &lt;code&gt;condition-case-unless-debug&lt;/code&gt; (см. &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Обработка ошибок&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="99398d90876bc60a8ea5c21dd040f9efdb83a5ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since receiving subprocess output sets this variable, it can change whenever Emacs waits; therefore, you should copy the value shortly after the function call that stores the value you are interested in.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; Поскольку получение вывода подпроцесса устанавливает эту переменную, она может изменяться всякий раз, когда Emacs ожидает; поэтому вы должны скопировать значение вскоре после вызова функции, в которой хранится интересующее вас значение.</target>
        </trans-unit>
        <trans-unit id="80b59cca73514532244288020d72ec71b0c54f97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When a variable has buffer-local bindings in one or more buffers, &lt;code&gt;let&lt;/code&gt; rebinds the binding that&amp;rsquo;s currently in effect. For instance, if the current buffer has a buffer-local value, &lt;code&gt;let&lt;/code&gt; temporarily rebinds that. If no buffer-local bindings are in effect, &lt;code&gt;let&lt;/code&gt; rebinds the default value. If inside the &lt;code&gt;let&lt;/code&gt; you then change to a different current buffer in which a different binding is in effect, you won&amp;rsquo;t see the &lt;code&gt;let&lt;/code&gt; binding any more. And if you exit the &lt;code&gt;let&lt;/code&gt; while still in the other buffer, you won&amp;rsquo;t see the unbinding occur (though it will occur properly). Here is an example to illustrate:</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если переменная имеет привязки к локальному буферу в одном или нескольких буферах, &lt;code&gt;let&lt;/code&gt; повторно привязать привязку, которая в настоящее время действует. Например, если текущий буфер имеет значение, локальное для буфера, &lt;code&gt;let&lt;/code&gt; временно его повторно связывает. Если никакие привязки к локальному буферу не действуют, &lt;code&gt;let&lt;/code&gt; повторно привязывает значение по умолчанию. Если внутри &lt;code&gt;let&lt;/code&gt; вы затем переключитесь на другой текущий буфер, в котором действует другая привязка, вы больше не увидите привязку &lt;code&gt;let&lt;/code&gt; . И если вы выйдете из &lt;code&gt;let&lt;/code&gt; , находясь в другом буфере, вы не увидите отмены привязки (хотя это произойдет правильно). Вот пример для иллюстрации:</target>
        </trans-unit>
        <trans-unit id="3ba7ea0fe9530c6fcf03322393469252b0a2972b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You must not alter the values of &lt;code&gt;after-change-functions&lt;/code&gt; within the body of a &lt;code&gt;combine-after-change-calls&lt;/code&gt; form.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; Вы не должны изменять значения функций &lt;code&gt;after-change-functions&lt;/code&gt; в теле формы &lt;code&gt;combine-after-change-calls&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07d2995fbb542cf0b4f59c7660f01041c61d2c74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You must not alter the values of &lt;code&gt;before-change-functions&lt;/code&gt; or &lt;code&gt;after-change-function&lt;/code&gt; within &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; вы не должны изменять значения функций &lt;code&gt;before-change-functions&lt;/code&gt; или &lt;code&gt;after-change-function&lt;/code&gt; в &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="35fd27e99b5c58482abb5d76202e99aa0a1953f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You must not make any buffer changes outside of the region specified by &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; вы не должны вносить какие-либо изменения в буфер за пределами области, указанной в параметрах &lt;var&gt;beg&lt;/var&gt; in и &lt;var&gt;end&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c24dc88e1e15e20222bea25a327387b74ae63e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; do not use &lt;code&gt;make-local-variable&lt;/code&gt; for a hook variable. The hook variables are automatically made buffer-local as needed if you use the &lt;var&gt;local&lt;/var&gt; argument to &lt;code&gt;add-hook&lt;/code&gt; or &lt;code&gt;remove-hook&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; не используйте &lt;code&gt;make-local-variable&lt;/code&gt; для переменной-ловушки. Переменные ловушки автоматически становятся локальными для буфера по мере необходимости, если вы используете &lt;var&gt;local&lt;/var&gt; аргумент для &lt;code&gt;add-hook&lt;/code&gt; или &lt;code&gt;remove-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09a5a9449bb11206b824d27af8eddf75c885f9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; don&amp;rsquo;t bind this variable with &lt;code&gt;let&lt;/code&gt;. It is often buffer-local, and if you bind it around reading input (which is exactly when you &lt;em&gt;would&lt;/em&gt; bind it), switching buffers asynchronously while Emacs is waiting will cause the value to be restored in the wrong buffer.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; не связывайте эту переменную с &lt;code&gt;let&lt;/code&gt; . Часто он является локальным для буфера, и если вы привяжете его к чтению ввода (а именно тогда, когда вы &lt;em&gt;его&lt;/em&gt; привязываете), асинхронное переключение буферов во время ожидания Emacs вызовет восстановление значения в неправильном буфере.</target>
        </trans-unit>
        <trans-unit id="2c808981ea7426dd8fb31718768bdfb9240b0d82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; don&amp;rsquo;t use the &lt;code&gt;font-lock-multiline&lt;/code&gt; property on large ranges of text, because that will make rehighlighting slow.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; не используйте свойство &lt;code&gt;font-lock-multiline&lt;/code&gt; для больших диапазонов текста, потому что это замедлит повторное выделение.</target>
        </trans-unit>
        <trans-unit id="05ceae8ad10f503f250029c7f5afe4600bba1cb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; don&amp;rsquo;t use this feature to alter the way the window is scrolled. It&amp;rsquo;s not designed for that, and such use probably won&amp;rsquo;t work.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; не используйте эту функцию для изменения способа прокрутки окна. Он не предназначен для этого, и такое использование, вероятно, не сработает.</target>
        </trans-unit>
        <trans-unit id="0206e6a7c67c64ebf9955d38fb60db7426e22736" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you change &lt;code&gt;file-name-coding-system&lt;/code&gt; (or the language environment) in the middle of an Emacs session, problems can result if you have already visited files whose names were encoded using the earlier coding system and are handled differently under the new coding system. If you try to save one of these buffers under the visited file name, saving may use the wrong file name, or it may get an error. If such a problem happens, use</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если вы измените &lt;code&gt;file-name-coding-system&lt;/code&gt; (или языковую среду) в середине сеанса Emacs, могут возникнуть проблемы, если вы уже посетили файлы, имена которых были закодированы с использованием более ранней системы кодирования и обрабатываются по-другому в рамках новая система кодирования. Если вы попытаетесь сохранить один из этих буферов под именем посещенного файла, при сохранении может использоваться неправильное имя файла или может возникнуть ошибка. Если возникает такая проблема, используйте</target>
        </trans-unit>
        <trans-unit id="0dcce5150d56b66b966d918e097e575a78318f08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use the display table to change the display of newline characters, the whole buffer will be displayed as one long line.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если вы используете таблицу отображения для изменения отображения символов новой строки, весь буфер будет отображаться как одна длинная строка.</target>
        </trans-unit>
        <trans-unit id="29632dff1239ce71ce3a6f2b24015c04aa685041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the argument values should not include any data types that can&amp;rsquo;t be printed and then read. Some facilities save &lt;code&gt;command-history&lt;/code&gt; in a file to be read in the subsequent sessions; if a command&amp;rsquo;s arguments contain a data type that prints using &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; значения аргументов не должны включать какие-либо типы данных, которые нельзя распечатать, а затем прочитать. Некоторые средства сохраняют &lt;code&gt;command-history&lt;/code&gt; в файл для чтения в последующих сеансах; если аргументы команды содержат тип данных, который печатается с использованием '</target>
        </trans-unit>
        <trans-unit id="bfc7d7757834b011b196dc085198902d4c7d8e65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Lisp macros and keyboard macros (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;) are entirely different things. When we use the word &amp;ldquo;macro&amp;rdquo; without qualification, we mean a Lisp macro, not a keyboard macro.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : макросы Lisp и макросы клавиатуры (см. &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Макросы клавиатуры&lt;/a&gt; ) - это совершенно разные вещи. Когда мы используем слово &amp;laquo;макрос&amp;raquo; без уточнения, мы имеем в виду макрос Lisp, а не клавиатурный макрос.</target>
        </trans-unit>
        <trans-unit id="fabe30e6344dd13a2d7e00055d41e03305ca2ba2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Note that the list in &lt;code&gt;nums&lt;/code&gt; no longer contains 0; this is the same cons cell that it was before, but it is no longer the first one in the list. Don&amp;rsquo;t assume a variable that formerly held the argument now holds the entire sorted list! Instead, save the result of &lt;code&gt;sort&lt;/code&gt; and use that. Most often we store the result back into the variable that held the original list:</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : обратите внимание, что список в &lt;code&gt;nums&lt;/code&gt; больше не содержит 0; это та же cons-ячейка, что и раньше, но уже не первая в списке. Не предполагайте, что переменная, которая раньше содержала аргумент, теперь содержит весь отсортированный список! Вместо этого сохраните результат &lt;code&gt;sort&lt;/code&gt; и используйте его. Чаще всего мы сохраняем результат обратно в переменную, которая содержала исходный список:</target>
        </trans-unit>
        <trans-unit id="ba718421b608b61cd6a2f215e2d8aa0c23151d9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We discourage use of a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;initial&lt;/var&gt;&lt;/strong&gt;, because initial input is an intrusive interface. History lists and default values provide a much more convenient method to offer useful default inputs to the user.</source>
          <target state="translated">&lt;strong&gt;Мы не рекомендуем использовать значение, отличное от &lt;code&gt;nil&lt;/code&gt; , для &lt;var&gt;initial&lt;/var&gt; &lt;/strong&gt; , потому что начальный ввод - это навязчивый интерфейс. Списки истории и значения по умолчанию предоставляют гораздо более удобный способ предложить пользователю полезные данные по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b1b9a3564d33e0fe386c96a11a997ce906bc8d2c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;*</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;*</target>
        </trans-unit>
        <trans-unit id="639372047fe8250a564cf1eb6b02b0b8d7e2adeb" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;*?</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;*?</target>
        </trans-unit>
        <trans-unit id="9bf26381ace5ddd45faed752347619c79ad9b0f2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;+</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;+</target>
        </trans-unit>
        <trans-unit id="1f4812366bcad6063b8bc30079ff6f730a73f239" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;+?</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;+?</target>
        </trans-unit>
        <trans-unit id="bc301264f66964afade4544f2549e9ecb0e4f516" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;&lt;var&gt;B&lt;/var&gt;&amp;hellip;</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;&lt;var&gt;B&lt;/var&gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0f0c348b2921825c505106ed1e5990044cd68713" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;?</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;?</target>
        </trans-unit>
        <trans-unit id="2308c8eb026e3ceb97214c64e9dd48f3241dcfb7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;??</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;??</target>
        </trans-unit>
        <trans-unit id="dc72642f871262e6b752597333df8d8e9dd51891" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,&lt;var&gt;m&lt;/var&gt;\}</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,&lt;var&gt;m&lt;/var&gt;\}</target>
        </trans-unit>
        <trans-unit id="072675b59fadf451e0a05fde271899b16f325fb1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,\}</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,\}</target>
        </trans-unit>
        <trans-unit id="47ef4b2187df56939010631d2add49667e8a8aca" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;\}</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;\}</target>
        </trans-unit>
        <trans-unit id="76e4e3a09ac81c5d948d7b54b04272d30706b4d1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\|&lt;var&gt;B&lt;/var&gt;\|&amp;hellip;</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\|&lt;var&gt;B&lt;/var&gt;\|&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="bc58f81cb092eedec2d6d8c884a9b82607fa7e3b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;activate-func&lt;/var&gt; is a function to call to activate this method. The &lt;var&gt;args&lt;/var&gt;, if any, are passed as arguments to &lt;var&gt;activate-func&lt;/var&gt;. All told, the arguments to &lt;var&gt;activate-func&lt;/var&gt; are &lt;var&gt;input-method&lt;/var&gt; and the &lt;var&gt;args&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;activate-func&lt;/var&gt; - это функция, вызываемая для активации этого метода. В &lt;var&gt;args&lt;/var&gt; , если таковые имеются, передаются в качестве аргументов &lt;var&gt;activate-func&lt;/var&gt; . В общем, аргументами &lt;var&gt;activate-func&lt;/var&gt; являются &lt;var&gt;input-method&lt;/var&gt; и &lt;var&gt;args&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fb0c583b9c9e9be9be62ec9f98c564288e7e889c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;aead_auth&lt;/var&gt; is only checked with AEAD ciphers, that is, ciphers whose plist has &lt;code&gt;:cipher-aead-capable t&lt;/code&gt;. Otherwise it&amp;rsquo;s ignored.</source>
          <target state="translated">&lt;var&gt;aead_auth&lt;/var&gt; проверяется только с помощью шифров AEAD, то есть шифров, в &lt;code&gt;:cipher-aead-capable t&lt;/code&gt; . В противном случае игнорируется.</target>
        </trans-unit>
        <trans-unit id="fe415e21b51794699e741f46ca2b74fca55619fa" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;alist&lt;/var&gt; is an association list of symbols and values as for &lt;code&gt;display-buffer&lt;/code&gt;. The following symbols in &lt;var&gt;alist&lt;/var&gt; are special for this function:</source>
          <target state="translated">&lt;var&gt;alist&lt;/var&gt; - это список ассоциаций символов и значений, как для &lt;code&gt;display-buffer&lt;/code&gt; . Следующие символы в &lt;var&gt;alist&lt;/var&gt; являются специальными для этой функции:</target>
        </trans-unit>
        <trans-unit id="eba413b4ed6d73161a8353916a5866a74e0565b9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;arglist&lt;/var&gt; may end in &lt;code&gt;&amp;amp;rest&lt;/code&gt; and one final argument name, denoting a rest parameter. The rest parameter will expand to all extra actual argument values not matched by any other parameter in &lt;var&gt;arglist&lt;/var&gt;, spliced into &lt;var&gt;rx-form&lt;/var&gt; where it occurs. Example:</source>
          <target state="translated">&lt;var&gt;arglist&lt;/var&gt; может заканчиваться &lt;code&gt;&amp;amp;rest&lt;/code&gt; и одним последним именем аргумента, обозначающим параметр rest. Остальной параметр будет расширен на все дополнительные фактические значения аргументов, не совпадающие ни с одним другим параметром в &lt;var&gt;arglist&lt;/var&gt; , сращенные в &lt;var&gt;rx-form&lt;/var&gt; там, где он встречается. Пример:</target>
        </trans-unit>
        <trans-unit id="d5bf91b60980cfbb14ffe935c92c37d495dc65c9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;background&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be a string specifying a color, which is used as the image&amp;rsquo;s background color if the image supports transparency. If the value is &lt;code&gt;nil&lt;/code&gt;, it defaults to the frame&amp;rsquo;s background color.</source>
          <target state="translated">&lt;var&gt;background&lt;/var&gt; , если не &lt;code&gt;nil&lt;/code&gt; , должен быть строкой, определяющей цвет, который используется в качестве цвета фона изображения, если изображение поддерживает прозрачность. Если значение равно &lt;code&gt;nil&lt;/code&gt; , по умолчанию используется цвет фона рамки.</target>
        </trans-unit>
        <trans-unit id="03bae4a0f67b53539e330b159bda6052780e7ba5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;base&lt;/var&gt;...&lt;var&gt;how-far&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;base&lt;/var&gt;...&lt;var&gt;how-far&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="ce7047ebe43595779bf964d11c2638b3ba54ec0b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;bindings&lt;/var&gt; is a list of bindings of the form &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt;
&lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;exp&lt;/var&gt; is an expression to evaluate and &lt;var&gt;pattern&lt;/var&gt; is a &lt;code&gt;pcase&lt;/code&gt; pattern. The variable bindings are produced by destructuring binding of elements of &lt;var&gt;pattern&lt;/var&gt; to the values of the corresponding elements of the evaluated &lt;var&gt;exp&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; - это список привязок формы &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt; &lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;exp&lt;/var&gt; - это выражение для оценки, а &lt;var&gt;pattern&lt;/var&gt; - это шаблон &lt;code&gt;pcase&lt;/code&gt; . Привязки переменных производятся путем деструктурирования привязки элементов &lt;var&gt;pattern&lt;/var&gt; к значениям соответствующих элементов оцениваемого &lt;var&gt;exp&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="1e4e93d29947e853fda98497930b3b20ac078622" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;bindings&lt;/var&gt; is a list of bindings of the form &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt;&amp;nbsp;&lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;exp&lt;/var&gt; is an expression to evaluate and &lt;var&gt;pattern&lt;/var&gt; is a &lt;code&gt;pcase&lt;/code&gt; pattern.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; - это список привязок формы &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt;&amp;nbsp;&lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;exp&lt;/var&gt; - это выражение для оценки, а &lt;var&gt;pattern&lt;/var&gt; - это шаблон &lt;code&gt;pcase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4209f1f9bb188e95924bdefb815300395d0fa4d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;bnf&lt;/var&gt; is a list of nonterminal definitions of the form &lt;code&gt;(&lt;var&gt;nonterm&lt;/var&gt; &lt;var&gt;rhs1&lt;/var&gt; &lt;var&gt;rhs2&lt;/var&gt; ...)&lt;/code&gt; where each &lt;var&gt;rhs&lt;/var&gt; is a (non-empty) list of terminals (aka tokens) or non-terminals.</source>
          <target state="translated">&lt;var&gt;bnf&lt;/var&gt; - это список нетерминальных определений в форме &lt;code&gt;(&lt;var&gt;nonterm&lt;/var&gt; &lt;var&gt;rhs1&lt;/var&gt; &lt;var&gt;rhs2&lt;/var&gt; ...)&lt;/code&gt; , где каждый &lt;var&gt;rhs&lt;/var&gt; является (непустым) списком терминалов (также известных как токены) или нетерминалов.</target>
        </trans-unit>
        <trans-unit id="c62c4cf5a34d62f4083055437ae2063f61f743fa" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;boolean-expression&lt;/var&gt; is evaluated:</source>
          <target state="translated">&lt;var&gt;boolean-expression&lt;/var&gt; вычисляется логическое выражение :</target>
        </trans-unit>
        <trans-unit id="897206fe1c279b99023a941cb036c2c9032a2c09" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;buffer-name&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the name of the buffer for logging the warning. By default, it is</source>
          <target state="translated">&lt;var&gt;buffer-name&lt;/var&gt; , если не &lt;code&gt;nil&lt;/code&gt; , указывает имя буфера для записи предупреждения. По умолчанию это</target>
        </trans-unit>
        <trans-unit id="3e97490488a20d8323027e17c1aa26733fbaf6d4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;buffer-or-name&lt;/var&gt; must be either a string or an existing buffer. If it is a string and a live buffer with that name already exists, &lt;code&gt;get-buffer-create&lt;/code&gt; returns that buffer. If no such buffer exists, it creates a new buffer. If &lt;var&gt;buffer-or-name&lt;/var&gt; is a buffer instead of a string, it is returned as given, even if it is dead.</source>
          <target state="translated">&lt;var&gt;buffer-or-name&lt;/var&gt; должен быть либо строкой, либо существующим буфером. Если это строка и активный буфер с таким именем уже существует, &lt;code&gt;get-buffer-create&lt;/code&gt; возвращает этот буфер. Если такого буфера не существует, создается новый буфер. Если &lt;var&gt;buffer-or-name&lt;/var&gt; буфера является буфером, а не строкой, он возвращается в том виде, в каком он был задан, даже если он мертв.</target>
        </trans-unit>
        <trans-unit id="8a0455ef45d72d81ce9684877db5cc07d5c8a84c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;buffer-or-name&lt;/var&gt; should be a buffer or the name of a buffer; if omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to the current buffer. The optional argument &lt;var&gt;all-frames&lt;/var&gt; specifies which windows to consider:</source>
          <target state="translated">&lt;var&gt;buffer-or-name&lt;/var&gt; должно быть буфером или именем буфера; если опущен или &lt;code&gt;nil&lt;/code&gt; , по умолчанию используется текущий буфер. Необязательный аргумент &lt;var&gt;all-frames&lt;/var&gt; указывает, какие окна следует учитывать:</target>
        </trans-unit>
        <trans-unit id="14dedd5200d621b6760f626d379fabf74a6e69ec" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;character&lt;/var&gt; may be &lt;code&gt;nil&lt;/code&gt;, which means to use &lt;var&gt;font-spec&lt;/var&gt; for any character which no font-spec is specified.</source>
          <target state="translated">&lt;var&gt;character&lt;/var&gt; может иметь значение &lt;code&gt;nil&lt;/code&gt; , что означает использование &lt;var&gt;font-spec&lt;/var&gt; для любого символа, для которого не указана спецификация шрифта.</target>
        </trans-unit>
        <trans-unit id="0c32dca097b381952f874c4d538bc6d57210dbbe" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;character&lt;/var&gt; may be a charset (see &lt;a href=&quot;character-sets#Character-Sets&quot;&gt;Character Sets&lt;/a&gt;). In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters in the charset.</source>
          <target state="translated">&lt;var&gt;character&lt;/var&gt; может быть кодировкой (см. &lt;a href=&quot;character-sets#Character-Sets&quot;&gt;Наборы символов&lt;/a&gt; ). В этом случае используйте &lt;var&gt;font-spec&lt;/var&gt; для всех символов в кодировке.</target>
        </trans-unit>
        <trans-unit id="49b46ba92d516a8eb20ffe7277a91cf8b50a2fc7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;character&lt;/var&gt; may be a script name (see &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;char-script-table&lt;/a&gt;). In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters belonging to the script.</source>
          <target state="translated">&lt;var&gt;character&lt;/var&gt; может быть именем скрипта (см. &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;char-script-table&lt;/a&gt; ). В этом случае используйте &lt;var&gt;font-spec&lt;/var&gt; для всех символов, принадлежащих скрипту.</target>
        </trans-unit>
        <trans-unit id="315b7c3e1a935f87a345ecedd5cae6998bb888a6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;charset&lt;/var&gt;:&lt;var&gt;font&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;charset&lt;/var&gt;:&lt;var&gt;font&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4b4d89a582c439acb0591d942dabf0428a352e0f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;choices&lt;/var&gt; is an alist where the first element in each entry is a character to be entered, the second element is a short name for the entry to be displayed while prompting (if there&amp;rsquo;s room, it might be shortened), and the third, optional entry is a longer explanation that will be displayed in a help buffer if the user requests more help.</source>
          <target state="translated">&lt;var&gt;choices&lt;/var&gt; - это список, где первый элемент в каждой записи - это символ, который нужно ввести, второй элемент - это короткое имя записи, которая будет отображаться при запросе (если есть место, оно может быть сокращено), а третья, необязательная запись - более подробное объяснение, которое будет отображаться в буфере справки, если пользователь запросит дополнительную помощь.</target>
        </trans-unit>
        <trans-unit id="48a1fa281d645561b8164abd8a41647240cfde22" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;col&lt;/var&gt;, &lt;var&gt;row&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;col&lt;/var&gt; , &lt;var&gt;row&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="25719d0480de36aa48958210c4694af307c0943b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;collection&lt;/var&gt; is called the &lt;em&gt;completion table&lt;/em&gt;. Its value must be a list of strings or cons cells, an obarray, a hash table, or a completion function.</source>
          <target state="translated">&lt;var&gt;collection&lt;/var&gt; называется &lt;em&gt;таблицей завершения&lt;/em&gt; . Его значение должно быть списком строк или cons-ячеек, obarray, хэш-таблицей или функцией завершения.</target>
        </trans-unit>
        <trans-unit id="95ac74539379f37ce12d859cdcecdd757d3861e3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;color&lt;/var&gt; is either a string, or the symbol &lt;code&gt;foreground-color&lt;/code&gt;, meaning the foreground color of the face. Omitting the attribute &lt;code&gt;:color&lt;/code&gt; means to use the foreground color of the face. &lt;var&gt;style&lt;/var&gt; should be a symbol &lt;code&gt;line&lt;/code&gt; or &lt;code&gt;wave&lt;/code&gt;, meaning to use a straight or wavy line. Omitting the attribute &lt;code&gt;:style&lt;/code&gt; means to use a straight line.</source>
          <target state="translated">&lt;var&gt;color&lt;/var&gt; - это либо строка, либо &lt;code&gt;foreground-color&lt;/code&gt; символа , означающий цвет переднего плана лица. Отсутствие атрибута &lt;code&gt;:color&lt;/code&gt; означает использование цвета переднего плана лица. &lt;var&gt;style&lt;/var&gt; должен быть &lt;code&gt;line&lt;/code&gt; символа или &lt;code&gt;wave&lt;/code&gt; , то есть использовать прямую или волнистую линию. Отсутствие атрибута &lt;code&gt;:style&lt;/code&gt; означает использование прямой линии.</target>
        </trans-unit>
        <trans-unit id="85506ad78941e763e80e1d83890c372391e36bd1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;condition&lt;/var&gt; can also be a list of error conditions.</source>
          <target state="translated">&lt;var&gt;condition&lt;/var&gt; также может быть списком условий ошибки.</target>
        </trans-unit>
        <trans-unit id="0e5f961b2b9d3d160b6161982913cce6cbabbb86" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;contents&lt;/var&gt; is a vector with the same number of elements as &lt;code&gt;tabulated-list-format&lt;/code&gt;. Each vector element is either a string, which is inserted into the buffer as-is, or a list &lt;code&gt;(&lt;var&gt;label&lt;/var&gt;
. &lt;var&gt;properties&lt;/var&gt;)&lt;/code&gt;, which means to insert a text button by calling &lt;code&gt;insert-text-button&lt;/code&gt; with &lt;var&gt;label&lt;/var&gt; and &lt;var&gt;properties&lt;/var&gt; as arguments (see &lt;a href=&quot;making-buttons#Making-Buttons&quot;&gt;Making Buttons&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;contents&lt;/var&gt; - это вектор с тем же количеством элементов, что и в &lt;code&gt;tabulated-list-format&lt;/code&gt; . Каждый векторный элемент представляет собой либо строку, которая вставляется в буфер как есть, либо список &lt;code&gt;(&lt;var&gt;label&lt;/var&gt; . &lt;var&gt;properties&lt;/var&gt;)&lt;/code&gt; , что означает вставку текстовой кнопки путем вызова &lt;code&gt;insert-text-button&lt;/code&gt; с &lt;var&gt;label&lt;/var&gt; и &lt;var&gt;properties&lt;/var&gt; качестве аргументов (см. &lt;a href=&quot;making-buttons#Making-Buttons&quot;&gt;Создание Кнопки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="059eb938a23f2d665b19373c768d7d7e5c49c2b3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;coordinates&lt;/var&gt; should be a cons cell of the form &lt;code&gt;(&lt;var&gt;x&lt;/var&gt;
. &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; are given in default character sizes (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;) relative to the native position of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;coordinates&lt;/var&gt; должны быть cons-ячейкой формы &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; . &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;x&lt;/var&gt; и &lt;var&gt;y&lt;/var&gt; даны в размерах символов по умолчанию (см. &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Шрифт фрейма&lt;/a&gt; ) относительно исходного положения фрейма &lt;var&gt;window&lt;/var&gt; (см. &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Геометрия фрейма&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="25f4d037ea3c1415b198231934180e02de1d9bd1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;default-coding-system&lt;/var&gt; can also be a list whose first element is &lt;code&gt;t&lt;/code&gt; and whose other elements are coding systems. Then, if no coding system in the list can handle the text, &lt;code&gt;select-safe-coding-system&lt;/code&gt; queries the user immediately, without trying any of the three alternatives described above. This is handy for checking only the coding systems in the list.</source>
          <target state="translated">&lt;var&gt;default-coding-system&lt;/var&gt; также может быть списком, первым элементом которого является &lt;code&gt;t&lt;/code&gt; , а другими элементами - системами кодирования. Затем, если никакая система кодирования в списке не может обработать текст, система &lt;code&gt;select-safe-coding-system&lt;/code&gt; немедленно запрашивает пользователя, не пробуя ни одну из трех альтернатив, описанных выше. Это удобно для проверки только систем кодирования в списке.</target>
        </trans-unit>
        <trans-unit id="d4740bdea7c58dc3cd47e4b528d9cddfd5ab846b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;descriptor&lt;/var&gt; is the same object as the one returned by this function. &lt;var&gt;action&lt;/var&gt; is the description of the event. It could be any one of the following symbols:</source>
          <target state="translated">&lt;var&gt;descriptor&lt;/var&gt; - это тот же объект, что и возвращаемый этой функцией. &lt;var&gt;action&lt;/var&gt; - это описание события. Это может быть любой из следующих символов:</target>
        </trans-unit>
        <trans-unit id="e8cbced6a8e5085804c5b909584c06f650eaf2a8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;display&lt;/var&gt; specifies a class of terminals (see below). &lt;var&gt;plist&lt;/var&gt; is a property list of face attributes and their values, specifying how the face appears on such terminals. For backward compatibility, you can also write an element as &lt;code&gt;(&lt;var&gt;display&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;display&lt;/var&gt; указывает класс терминалов (см. ниже). &lt;var&gt;plist&lt;/var&gt; - это список свойств атрибутов лица и их значений, определяющих, как лицо отображается на таких терминалах. Для обратной совместимости вы также можете написать элемент как &lt;code&gt;(&lt;var&gt;display&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3ad125e9fcc9d8ed043a029ffcfd9d1a4d42f6e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;doc&lt;/var&gt;, if present, should be a string specifying the function&amp;rsquo;s documentation string (see &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;). &lt;var&gt;declare&lt;/var&gt;, if present, should be a &lt;code&gt;declare&lt;/code&gt; form specifying function metadata (see &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;). &lt;var&gt;interactive&lt;/var&gt;, if present, should be an &lt;code&gt;interactive&lt;/code&gt; form specifying how the function is to be called interactively (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;doc&lt;/var&gt; , если он присутствует, должен быть строкой, определяющей строку документации функции (см. &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Документацию функции&lt;/a&gt; ). &lt;var&gt;declare&lt;/var&gt; , если он присутствует, должен быть формой &lt;code&gt;declare&lt;/code&gt; определяющей метаданные функции (см. &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;форму объявления&lt;/a&gt; ). &lt;var&gt;interactive&lt;/var&gt; , если присутствует, должна быть &lt;code&gt;interactive&lt;/code&gt; формой, определяющей, как функция должна вызываться в интерактивном режиме (см. &amp;laquo; &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Интерактивный вызов&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d7cbc1a74d03a0f78e34f4208bb2aee52517b47" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;doc&lt;/var&gt;, if present, should be a string specifying the macro&amp;rsquo;s documentation string. &lt;var&gt;declare&lt;/var&gt;, if present, should be a &lt;code&gt;declare&lt;/code&gt; form specifying metadata for the macro (see &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;). Note that macros cannot have interactive declarations, since they cannot be called interactively.</source>
          <target state="translated">&lt;var&gt;doc&lt;/var&gt; , если он присутствует, должен быть строкой, определяющей строку документации макроса. &lt;var&gt;declare&lt;/var&gt; , если он присутствует, должен быть формой &lt;code&gt;declare&lt;/code&gt; определяющей метаданные для макроса (см. &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;форму объявления&lt;/a&gt; ). Обратите внимание, что макросы не могут иметь интерактивных объявлений, поскольку их нельзя вызывать интерактивно.</target>
        </trans-unit>
        <trans-unit id="0ccc8ddd11dcc504c397e4a0a41030c2848cd67f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dx&lt;/var&gt;, &lt;var&gt;dy&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;dx&lt;/var&gt; , &lt;var&gt;dy&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="bfeb638334ed0ea3560b17a40e5f38c1328d1164" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;emacs-name&lt;/var&gt;.dmp</source>
          <target state="translated">&lt;var&gt;emacs-name&lt;/var&gt;.dmp</target>
        </trans-unit>
        <trans-unit id="f43bbd847569b4d0976a8c99d3ef58935b829e02" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;enable&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the item is make unselectable.. &lt;code&gt;:enable&lt;/code&gt; is an alias for &lt;code&gt;:active&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;enable&lt;/var&gt; - это выражение; если значение равно &lt;code&gt;nil&lt;/code&gt; , элемент становится недоступным для выбора .. &lt;code&gt;:enable&lt;/code&gt; - это псевдоним для &lt;code&gt;:active&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="026a4d4e36d46678bd210dd9c83988b282f1bbc3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;enable&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the menu is not selectable. &lt;code&gt;:enable&lt;/code&gt; is an alias for &lt;code&gt;:active&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;enable&lt;/var&gt; - это выражение; если оно равно &lt;code&gt;nil&lt;/code&gt; , меню нельзя выбрать. &lt;code&gt;:enable&lt;/code&gt; - это псевдоним для &lt;code&gt;:active&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24543b8028f1a35def94fb638729d3e0dc460d74" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;endkeyfun&lt;/var&gt; is called to move point from the start of the sort key to the end of the sort key. This argument is optional. If &lt;var&gt;startkeyfun&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt; and this argument is omitted (or &lt;code&gt;nil&lt;/code&gt;), then the sort key extends to the end of the record. There is no need for &lt;var&gt;endkeyfun&lt;/var&gt; if &lt;var&gt;startkeyfun&lt;/var&gt; returns a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">&lt;var&gt;endkeyfun&lt;/var&gt; вызывается для перемещения точки из начала ключа сортировки в конец ключа сортировки. Это необязательный аргумент. Если &lt;var&gt;startkeyfun&lt;/var&gt; возвращает &lt;code&gt;nil&lt;/code&gt; и этот аргумент опущен (или &lt;code&gt;nil&lt;/code&gt; ), то ключ сортировки распространяется до конца записи. Там нет необходимости для &lt;var&gt;endkeyfun&lt;/var&gt; если &lt;var&gt;startkeyfun&lt;/var&gt; возвращает значение не &lt;code&gt;nil&lt;/code&gt; значения.</target>
        </trans-unit>
        <trans-unit id="ae4587c6776baee695ab496cec1fcc993fbc9d28" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;endrecfun&lt;/var&gt; is called with point within a record. It moves point to the end of the record.</source>
          <target state="translated">&lt;var&gt;endrecfun&lt;/var&gt; вызывается с точкой внутри записи. Он перемещает точку в конец записи.</target>
        </trans-unit>
        <trans-unit id="07258c3d909b7d04fbc29283d3a6c004534672a9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;eol-type&lt;/var&gt; may also be 0, 1 or 2, standing for &lt;code&gt;unix&lt;/code&gt;, &lt;code&gt;dos&lt;/code&gt; and &lt;code&gt;mac&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;var&gt;eol-type&lt;/var&gt; также может быть 0, 1 или 2, что &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;dos&lt;/code&gt; и &lt;code&gt;mac&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="a679848f4f81da63a940e500185e5f4d31fb505d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;face&lt;/var&gt; is a face name (a symbol), and &lt;var&gt;spec&lt;/var&gt; is the customized face specification for that face (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;face&lt;/var&gt; - это имя лица (символ), а &lt;var&gt;spec&lt;/var&gt; - индивидуальная спецификация лица для этого лица (см. &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Определение лиц&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a673288deae0cf01bf7e0c37ea6455f2424f67ef" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;face&lt;/var&gt; is merged with the &lt;code&gt;fringe&lt;/code&gt; face, so normally &lt;var&gt;face&lt;/var&gt; should specify only the foreground color.</source>
          <target state="translated">&lt;var&gt;face&lt;/var&gt; объединяется с &lt;code&gt;fringe&lt;/code&gt; лица, поэтому обычно для &lt;var&gt;face&lt;/var&gt; следует указывать только цвет переднего плана.</target>
        </trans-unit>
        <trans-unit id="26d9a049372ef2db3d71a63355e838837e772504" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;family&lt;/var&gt; specifies the address (and protocol) family for communication. &lt;code&gt;nil&lt;/code&gt; means determine the proper address family automatically for the given &lt;var&gt;host&lt;/var&gt; and &lt;var&gt;service&lt;/var&gt;. &lt;code&gt;local&lt;/code&gt; specifies a Unix socket, in which case &lt;var&gt;host&lt;/var&gt; is ignored. &lt;code&gt;ipv4&lt;/code&gt; and &lt;code&gt;ipv6&lt;/code&gt; specify to use IPv4 and IPv6, respectively.</source>
          <target state="translated">&lt;var&gt;family&lt;/var&gt; определяет семейство адресов (и протоколов) для связи. &lt;code&gt;nil&lt;/code&gt; означает автоматическое определение правильного семейства адресов для данного &lt;var&gt;host&lt;/var&gt; и &lt;var&gt;service&lt;/var&gt; . &lt;code&gt;local&lt;/code&gt; указывает сокет Unix, и в этом случае &lt;var&gt;host&lt;/var&gt; игнорируется. &lt;code&gt;ipv4&lt;/code&gt; и &lt;code&gt;ipv6&lt;/code&gt; указывают на использование IPv4 и IPv6 соответственно.</target>
        </trans-unit>
        <trans-unit id="c439447a5739faaa36388e0fd0208ee5b5f20788" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; and &lt;var&gt;file1&lt;/var&gt; are the name of the file(s) whose event is being reported. For example:</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; и &lt;var&gt;file1&lt;/var&gt; - это имя файла (ов), о событии которого сообщается. Например:</target>
        </trans-unit>
        <trans-unit id="494dfd3e482f441bcf7349c4b35ed8257f3fcf33" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; has been renamed to &lt;var&gt;file1&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; был переименован в &lt;var&gt;file1&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="d0efe3807ad969de00033c63916e52295c7dc7db" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; was created</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; был создан</target>
        </trans-unit>
        <trans-unit id="ff9b4e58b863e2d9426f346e0b4e0bc3b5c5203e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; was deleted</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; был удален</target>
        </trans-unit>
        <trans-unit id="ceaae3594f636f9cdc34f5ebddb7ea2e6a63d442" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;&amp;rsquo;s contents has changed; with</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; содержимое файла изменилось; с участием</target>
        </trans-unit>
        <trans-unit id="c371da9511eda87a2212e3220f12941b56c97397" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;filename&lt;/var&gt;.&lt;var&gt;ext&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt;.&lt;var&gt;ext&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4e7cc819e121989dca24eab6e075d8cd141f4606" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;filename&lt;/var&gt;.el</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt;.el</target>
        </trans-unit>
        <trans-unit id="33e86703d5b2c9fe524e4c7367176bbb74f72f27" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;filename&lt;/var&gt;.elc</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt;.elc</target>
        </trans-unit>
        <trans-unit id="03c0f13fc536f6551c91f757809e50b3865faf3e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;firstchar&lt;/var&gt;..&lt;var&gt;lastchar&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;firstchar&lt;/var&gt;..&lt;var&gt;lastchar&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2f1c5588aa47061170d13d3fdbdf7eb212c134e7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;flags&lt;/var&gt; is a list of conditions to set what will be watched for. It can include the following symbols:</source>
          <target state="translated">&lt;var&gt;flags&lt;/var&gt; - это список условий, которые нужно установить для отслеживания. Он может включать следующие символы:</target>
        </trans-unit>
        <trans-unit id="cb3f01a3d3b221299cad46839d79ffbec32038e4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be &lt;code&gt;nil&lt;/code&gt;, which explicitly specifies that there&amp;rsquo;s no font for the specified &lt;var&gt;character&lt;/var&gt;. This is useful, for example, to avoid expensive system-wide search for fonts for characters that have no glyphs, like those from the Unicode Private Use Area (PUA).</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; может иметь значение &lt;code&gt;nil&lt;/code&gt; , что явно указывает на отсутствие шрифта для указанного &lt;var&gt;character&lt;/var&gt; . Это полезно, например, чтобы избежать дорогостоящего общесистемного поиска шрифтов для символов, не имеющих глифов, например, из области частного использования Unicode (PUA).</target>
        </trans-unit>
        <trans-unit id="87791ac35e559d82f0beba087e4f60504c73063c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be a cons; &lt;code&gt;(&lt;var&gt;family&lt;/var&gt; . &lt;var&gt;registry&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;family&lt;/var&gt; is a family name of a font (possibly including a foundry name at the head), &lt;var&gt;registry&lt;/var&gt; is a registry name of a font (possibly including an encoding name at the tail).</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; может быть недостатком; &lt;code&gt;(&lt;var&gt;family&lt;/var&gt; . &lt;var&gt;registry&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;family&lt;/var&gt; - это фамилия шрифта (возможно, включая название литейной в начале), &lt;var&gt;registry&lt;/var&gt; - это имя шрифта в реестре (возможно, включая имя кодировки в конце).</target>
        </trans-unit>
        <trans-unit id="c4d8e9b29420e5f894d3d4388135196d57737a2e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be a font name, a string.</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; может быть именем шрифта, строкой.</target>
        </trans-unit>
        <trans-unit id="759768b158ba114fe576f2c579a978fa9530def7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be a font-spec object created by the function &lt;code&gt;font-spec&lt;/code&gt; (see &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Low-Level Font&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; может быть объектом font-spec, созданным функцией &lt;code&gt;font-spec&lt;/code&gt; (см. &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Низкоуровневый шрифт&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="029bbc3c1e9a51615a423507e468eedf7d75d6f0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt;-theme.el</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt;-theme.el</target>
        </trans-unit>
        <trans-unit id="86da1189a32a4e33ef437641c2dc1ff3f09bc416" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;form&lt;/var&gt; is a Lisp expression evaluated at the moment the field is unpacked or packed. The result of the evaluation should be one of the above-listed type specifications.</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; - это выражение Лиспа, вычисляемое в момент распаковки или упаковки поля. Результатом оценки должна быть одна из перечисленных выше спецификаций типа.</target>
        </trans-unit>
        <trans-unit id="92c54291694533dc568fa1eb74e1ad40167195fd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;form&lt;/var&gt; is an expression that is dynamically evaluated and whose value is concatenated with the menu entry&amp;rsquo;s label.</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; - это выражение, которое вычисляется динамически и значение которого объединяется с меткой пункта меню.</target>
        </trans-unit>
        <trans-unit id="fb3bf40536e1a49665a57075be8eb3a300e2ec1a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;form&lt;/var&gt; is an expression that is evaluated to obtain a value which serves as the menu item&amp;rsquo;s label (the default is &lt;var&gt;name&lt;/var&gt;).</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; - это выражение, вычисляемое для получения значения, которое служит меткой пункта меню (по умолчанию используется &lt;var&gt;name&lt;/var&gt; ).</target>
        </trans-unit>
        <trans-unit id="f51c3cfdb2c95fd18d36a83c0a64f4afa1c8d6e0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fringe&lt;/var&gt; is either the symbol &lt;code&gt;left-fringe&lt;/code&gt; or &lt;code&gt;right-fringe&lt;/code&gt;. &lt;var&gt;bitmap&lt;/var&gt; is a symbol identifying the bitmap to display. The optional &lt;var&gt;face&lt;/var&gt; names a face whose foreground and background colors are to be used to display the bitmap, using the attributes of the &lt;code&gt;fringe&lt;/code&gt; face for colors that &lt;var&gt;face&lt;/var&gt; didn&amp;rsquo;t specify. If &lt;var&gt;face&lt;/var&gt; is omitted, that means to use the attributes of the &lt;code&gt;default&lt;/code&gt; face for the colors which the &lt;code&gt;fringe&lt;/code&gt; face didn&amp;rsquo;t specify. For predictable results that don&amp;rsquo;t depend on the attributes of the &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;fringe&lt;/code&gt; faces, we recommend you never omit &lt;var&gt;face&lt;/var&gt;, but always provide a specific face. In particular, if you want the bitmap to be always displayed in the &lt;code&gt;fringe&lt;/code&gt; face, use &lt;code&gt;fringe&lt;/code&gt; as &lt;var&gt;face&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;fringe&lt;/var&gt; - это символ &lt;code&gt;left-fringe&lt;/code&gt; или &lt;code&gt;right-fringe&lt;/code&gt; . &lt;var&gt;bitmap&lt;/var&gt; - это символ, определяющий отображаемое растровое изображение. Необязательное &lt;var&gt;face&lt;/var&gt; называет лицо, цвета переднего плана и фона которого должны использоваться для отображения растрового изображения, с использованием атрибутов грани &lt;code&gt;fringe&lt;/code&gt; для цветов, которые &lt;var&gt;face&lt;/var&gt; не указывало. Если &lt;var&gt;face&lt;/var&gt; опущено, это означает использование атрибутов лица по &lt;code&gt;default&lt;/code&gt; для цветов, которые не указаны для грани с &lt;code&gt;fringe&lt;/code&gt; . Для получения предсказуемых результатов, не зависящих от атрибутов лица по &lt;code&gt;default&lt;/code&gt; и &lt;code&gt;fringe&lt;/code&gt; , мы рекомендуем никогда не пропускать &lt;var&gt;face&lt;/var&gt; , но всегда указывайте конкретное лицо. В частности, если вы хотите, чтобы растровое изображение всегда отображалось на грани &lt;code&gt;fringe&lt;/code&gt; , используйте &lt;code&gt;fringe&lt;/code&gt; как &lt;var&gt;face&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="0e67933ea042f44af21af128920ef083d97dd3b1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; is called with four arguments: &lt;var&gt;evald&lt;/var&gt;, &lt;var&gt;func&lt;/var&gt;, &lt;var&gt;args&lt;/var&gt;, and &lt;var&gt;flags&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; вызывается с четырьмя аргументами: &lt;var&gt;evald&lt;/var&gt; , &lt;var&gt;func&lt;/var&gt; , &lt;var&gt;args&lt;/var&gt; и &lt;var&gt;flags&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="96a61bda6352a0a069ba29f13038afcd21b6e3cb" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; is compared with functions added to &lt;var&gt;place&lt;/var&gt; using &lt;code&gt;equal&lt;/code&gt;, to try and make it work also with lambda expressions. It is additionally compared also with the &lt;code&gt;name&lt;/code&gt; property of the functions added to &lt;var&gt;place&lt;/var&gt;, which can be more reliable than comparing lambda expressions using &lt;code&gt;equal&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; сравнивается с функциями, добавленными на &lt;var&gt;place&lt;/var&gt; с использованием &lt;code&gt;equal&lt;/code&gt; , чтобы попытаться заставить ее работать также с лямбда-выражениями. Кроме того, он сравнивается также со свойством &lt;code&gt;name&lt;/code&gt; функций, добавленных в &lt;var&gt;place&lt;/var&gt; , что может быть более надежным, чем сравнение лямбда-выражений с использованием &lt;code&gt;equal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5575fbb1388958318be1a3552e5c7c509f3c4fc2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; must be a function which, if called with one argument&amp;mdash;the list of the other menu items&amp;mdash;returns the actual items to be displayed in the menu.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; должна быть функцией, которая при вызове с одним аргументом - списком других пунктов меню - возвращает фактические элементы, отображаемые в меню.</target>
        </trans-unit>
        <trans-unit id="7521d4e1d834b0b0b2987dd83395e6b17b51ac26" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; should be a function used to initialize the variable when the &lt;code&gt;defcustom&lt;/code&gt; is evaluated. It should take two arguments, the option name (a symbol) and the value. Here are some predefined functions meant for use in this way:</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; должна быть функцией, используемой для инициализации переменной при оценке &lt;code&gt;defcustom&lt;/code&gt; . Он должен принимать два аргумента: имя параметра (символ) и значение. Вот несколько предопределенных функций, предназначенных для использования таким образом:</target>
        </trans-unit>
        <trans-unit id="f8f6f9d814feac7c8527f7543b641d0a69a818ed" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;getter&lt;/var&gt; will be bound to a copyable expression that returns the value of &lt;var&gt;place&lt;/var&gt;. &lt;var&gt;setter&lt;/var&gt; will be bound to a function that takes an expression &lt;var&gt;v&lt;/var&gt; and returns a new expression that sets &lt;var&gt;place&lt;/var&gt; to &lt;var&gt;v&lt;/var&gt;. &lt;var&gt;body&lt;/var&gt; should return a Emacs Lisp expression manipulating &lt;var&gt;place&lt;/var&gt; via &lt;var&gt;getter&lt;/var&gt; and &lt;var&gt;setter&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;getter&lt;/var&gt; будет привязан к копируемому выражению, которое возвращает значение &lt;var&gt;place&lt;/var&gt; . &lt;var&gt;setter&lt;/var&gt; будет привязан к функции, которая принимает выражение &lt;var&gt;v&lt;/var&gt; и возвращает новое выражение, которое устанавливает &lt;var&gt;place&lt;/var&gt; в &lt;var&gt;v&lt;/var&gt; . &lt;var&gt;body&lt;/var&gt; должно возвращать Emacs Lisp выражения манипул &lt;var&gt;place&lt;/var&gt; через &lt;var&gt;getter&lt;/var&gt; и &lt;var&gt;setter&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="4043993b61e9a42a8e9285bfdbfe54534c1e8638" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;group&lt;/var&gt; should be one of the following:</source>
          <target state="translated">&lt;var&gt;group&lt;/var&gt; должна быть одной из следующих:</target>
        </trans-unit>
        <trans-unit id="2d92881cdd8c4025ff540b733613ee07d9cfa4fc" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;handler&lt;/var&gt; describes how to unpack or pack the field and can be one of the following:</source>
          <target state="translated">&lt;var&gt;handler&lt;/var&gt; описывает, как распаковать или упаковать поле, и может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="14afc8802dd099dffd902090a0a69552b90aa24b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;height&lt;/var&gt; specifies the height of the horizontal scroll bar in pixels (&lt;code&gt;nil&lt;/code&gt; means use the height specified for the frame). &lt;var&gt;horizontal-type&lt;/var&gt; specifies whether to have a horizontal scroll bar. The possible values are &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, which means to use the frame&amp;rsquo;s default, and &lt;code&gt;nil&lt;/code&gt; for no horizontal scroll bar. Note that for a mini window the value &lt;code&gt;t&lt;/code&gt; has the same meaning as &lt;code&gt;nil&lt;/code&gt;, namely to not show a horizontal scroll bar. You have to explicitly specify &lt;code&gt;bottom&lt;/code&gt; in order to show a horizontal scroll bar in a mini window.</source>
          <target state="translated">&lt;var&gt;height&lt;/var&gt; указывает высоту горизонтальной полосы прокрутки в пикселях ( &lt;code&gt;nil&lt;/code&gt; означает использование высоты, указанной для кадра). &lt;var&gt;horizontal-type&lt;/var&gt; указывает, нужна ли горизонтальная полоса прокрутки. Возможные значения: &lt;code&gt;bottom&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; , что означает использование фрейма по умолчанию, и &lt;code&gt;nil&lt;/code&gt; ,если горизонтальная полоса прокрутки отсутствует. Обратите внимание, что для мини-окна значение &lt;code&gt;t&lt;/code&gt; имеет то же значение, что и &lt;code&gt;nil&lt;/code&gt; , а именно, чтобы не отображалась горизонтальная полоса прокрутки. Чтобы в мини-окне отображалась горизонтальная полоса прокрутки , необходимо явно указать &lt;code&gt;bottom&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd4abcdd0cf44425cf91cbe5f1f6af6363adce9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;help&lt;/var&gt; is a string describing the menu item.</source>
          <target state="translated">&lt;var&gt;help&lt;/var&gt; - это строка, описывающая пункт меню.</target>
        </trans-unit>
        <trans-unit id="96a4bc599371ca129df372931368e5d53c4c5189" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;help&lt;/var&gt; specifies a help-echo string to display while the mouse is on that item in the same way as &lt;code&gt;help-echo&lt;/code&gt; text properties (see &lt;a href=&quot;special-properties#Help-display&quot;&gt;Help display&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;help&lt;/var&gt; определяет строку help-echo, отображаемую, когда указатель мыши находится на этом элементе, так же, как свойства текста &lt;code&gt;help-echo&lt;/code&gt; (см. &lt;a href=&quot;special-properties#Help-display&quot;&gt;Отображение справки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b3a3fe3a0adcd58bec41606b7786fe808bb50fde" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;dpy&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;dpy&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="42b4994da7ef7bf80d71cd16fb9dc08946036693" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;server&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;server&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="0e3c28fae96e04daa9845a71c500ac2d21de32d1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;hostname&lt;/var&gt;:&lt;var&gt;displaynumber&lt;/var&gt;.&lt;var&gt;screennumber&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;hostname&lt;/var&gt;:&lt;var&gt;displaynumber&lt;/var&gt;.&lt;var&gt;screennumber&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="1c483a6a0980a0cf8c23d9ab62832084d98a30b1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;id&lt;/var&gt; is either &lt;code&gt;nil&lt;/code&gt;, or a Lisp object that identifies the entry. If the latter, the cursor stays on the same entry when re-sorting entries. Comparison is done with &lt;code&gt;equal&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;id&lt;/var&gt; либо &lt;code&gt;nil&lt;/code&gt; , либо объект Lisp, который идентифицирует запись. В последнем случае курсор остается на той же записи при повторной сортировке записей. Сравнение производится с &lt;code&gt;equal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31818ab23abac17f811cdac8cd47bac29ad5ea73" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;identification&lt;/var&gt; specifies which part of the identifier shall be returned as string. &lt;var&gt;identification&lt;/var&gt; can be the symbol &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;host&lt;/code&gt;; any other value is handled like &lt;code&gt;nil&lt;/code&gt; and means to return the complete identifier string. In the example above, the remote &lt;code&gt;user&lt;/code&gt; identifier string would be &lt;code&gt;root&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;identification&lt;/var&gt; определяет, какая часть идентификатора должна быть возвращена в виде строки. &lt;var&gt;identification&lt;/var&gt; может быть символьным &lt;code&gt;method&lt;/code&gt; , &lt;code&gt;user&lt;/code&gt; или &lt;code&gt;host&lt;/code&gt; ; любое другое значение обрабатывается как &lt;code&gt;nil&lt;/code&gt; и означает возврат полной строки идентификатора. В приведенном выше примере строка идентификатора удаленного &lt;code&gt;user&lt;/code&gt; будет &lt;code&gt;root&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86739b7293c7a619312c3904fbbaab23074b10ee" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;image&lt;/var&gt; is either a single image specification (see &lt;a href=&quot;images#Images&quot;&gt;Images&lt;/a&gt;) or a vector of four image specifications. If you use a vector of four, one of them is used, depending on circumstances:</source>
          <target state="translated">&lt;var&gt;image&lt;/var&gt; - это либо спецификация одного изображения (см. &lt;a href=&quot;images#Images&quot;&gt;Изображения&lt;/a&gt; ), либо вектор из четырех характеристик изображения. Если вы используете вектор из четырех, в зависимости от обстоятельств используется один из них:</target>
        </trans-unit>
        <trans-unit id="3054de9d7101f47ab193522932e03068882fe0a2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;include&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the item is made invisible. &lt;code&gt;:included&lt;/code&gt; is an alias for &lt;code&gt;:visible&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;include&lt;/var&gt; - это выражение; если оно равно &lt;code&gt;nil&lt;/code&gt; , элемент становится невидимым. &lt;code&gt;:included&lt;/code&gt; - это псевдоним для &lt;code&gt;:visible&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c4739c613e959e93e32b340d505b80d83477102" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;include&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the menu is made invisible. &lt;code&gt;:included&lt;/code&gt; is an alias for &lt;code&gt;:visible&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;include&lt;/var&gt; - это выражение; если значение равно &lt;code&gt;nil&lt;/code&gt; , меню становится невидимым. &lt;code&gt;:included&lt;/code&gt; - это псевдоним для &lt;code&gt;:visible&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6420fd3e3f459ab10132a472e9ecc278de5f7219" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;initial&lt;/var&gt; can also be a cons cell of the form &lt;code&gt;(&lt;var&gt;string&lt;/var&gt;
. &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt;. This means to insert &lt;var&gt;string&lt;/var&gt; in the minibuffer but put point at &lt;var&gt;position&lt;/var&gt; within the string&amp;rsquo;s text.</source>
          <target state="translated">&lt;var&gt;initial&lt;/var&gt; также может быть cons-ячейкой формы &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt; . Это означает вставить &lt;var&gt;string&lt;/var&gt; в минибуфер, но поставить точку на &lt;var&gt;position&lt;/var&gt; внутри текста строки.</target>
        </trans-unit>
        <trans-unit id="4b206e32ad38dde073c99970ff35c938f9f6fb77" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="718efbcd8e4b5b6b8e8b13b1459e1cc03479ab48" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;component&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;component&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4248e5e822e0f5d532af3eedf7c73be8341c3ad8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;keys&lt;/var&gt; is a hint indicating which key sequence to display as keyboard equivalent, in case the command is bound to several key sequences. It has no effect if &lt;var&gt;keys&lt;/var&gt; is not bound to same command as this menu item.</source>
          <target state="translated">&lt;var&gt;keys&lt;/var&gt; - это подсказка, указывающая, какую последовательность клавиш отображать как эквивалент клавиатуры в случае, если команда привязана к нескольким последовательностям клавиш. Это не действует, если &lt;var&gt;keys&lt;/var&gt; не привязаны к той же команде, что и этот пункт меню.</target>
        </trans-unit>
        <trans-unit id="62f6c891a1b05f30a58f0aeeed5e7c0f2822315d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;keys&lt;/var&gt; is a string to display as keyboard equivalent to the menu item. This is normally not needed, as keyboard equivalents are computed automatically. &lt;var&gt;keys&lt;/var&gt; is expanded with &lt;code&gt;substitute-command-keys&lt;/code&gt; before it is displayed (see &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;keys&lt;/var&gt; - это строка, отображаемая как клавиатура, эквивалентная пункту меню. Обычно это не требуется, поскольку эквиваленты клавиатуры вычисляются автоматически. &lt;var&gt;keys&lt;/var&gt; расширяется с помощью &lt;code&gt;substitute-command-keys&lt;/code&gt; перед отображением (см. &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Ключи в документации&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="596b2e28f20e0f7c98531ef608bc15ad4ac40bab" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;library&lt;/var&gt; can also be a feature (i.e., a symbol), in which case &lt;var&gt;body&lt;/var&gt; is evaluated at the end of any file where &lt;code&gt;(provide &lt;var&gt;library&lt;/var&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">&lt;var&gt;library&lt;/var&gt; также может быть функцией (т. е. символом), и в этом случае &lt;var&gt;body&lt;/var&gt; оценивается в конце любого файла , в котором вызывается &lt;code&gt;(provide &lt;var&gt;library&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3000b097be57636b873656a46f8475a5f1beb072" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;map&lt;/var&gt; must contain an appropriate keymap bound to &lt;code&gt;[menu-bar]&lt;/code&gt;. The remaining arguments &lt;var&gt;props&lt;/var&gt; are additional property list elements to add to the menu item specification.</source>
          <target state="translated">&lt;var&gt;map&lt;/var&gt; должна содержать соответствующую раскладку, привязанную к &lt;code&gt;[menu-bar]&lt;/code&gt; . Остальные аргументы &lt;var&gt;props&lt;/var&gt; - это дополнительные элементы списка свойств, которые нужно добавить в спецификацию пункта меню.</target>
        </trans-unit>
        <trans-unit id="a521da8968366f92cee94a02ace1fd6c8e079a13" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;max-costs&lt;/var&gt; defines the quality of the difference computation. If the actual costs exceed this limit, heuristics are used to provide a faster but suboptimal solution. The default value is 1000000.</source>
          <target state="translated">&lt;var&gt;max-costs&lt;/var&gt; определяет качество вычисления разницы. Если фактические затраты превышают этот предел, используются эвристики, чтобы предоставить более быстрое, но неоптимальное решение. Значение по умолчанию - 1000000.</target>
        </trans-unit>
        <trans-unit id="a763217bb3a14d4f74e940f501ce1a0a143c32e1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;max-secs&lt;/var&gt; defines a hard boundary in terms of seconds. If given and exceeded, it will fall back to &lt;code&gt;delete-region&lt;/code&gt; and &lt;code&gt;insert-buffer-substring&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;max-secs&lt;/var&gt; определяет жесткую границу в секундах. Если задано и превышено, он вернется к &lt;code&gt;delete-region&lt;/code&gt; и &lt;code&gt;insert-buffer-substring&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5c8a5efcfb5474cdb45133f3322fdc9ebc87680" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;method&lt;/var&gt; can be:</source>
          <target state="translated">&lt;var&gt;method&lt;/var&gt; может быть:</target>
        </trans-unit>
        <trans-unit id="27fa08ba53bae7468bfa10b0879a0af63b63c7ff" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;method&lt;/var&gt; should be the method name that was passed to &lt;code&gt;smie-rules-function&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;method&lt;/var&gt; должен быть именем метода, которое было передано в &lt;code&gt;smie-rules-function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50b807ebac2655b0d8a5c152f0862476091a5d62" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;modename&lt;/var&gt;-mode-hook</source>
          <target state="translated">&lt;var&gt;modename&lt;/var&gt;-mode-hook</target>
        </trans-unit>
        <trans-unit id="586b5298d2b503845edf7730bbc979076f5aeccd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt; can be supplied to give a name to the thread. The name is used for debugging and informational purposes only; it has no meaning to Emacs. If &lt;var&gt;name&lt;/var&gt; is provided, it must be a string.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; может быть поставлено , чтобы дать имя потока. Имя используется только для отладки и информационных целей; для Emacs это не имеет значения. Если указано &lt;var&gt;name&lt;/var&gt; , оно должно быть строкой.</target>
        </trans-unit>
        <trans-unit id="5eebb341ded2a927ba41d8e9885ef924c499a969" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt; is the column&amp;rsquo;s name (a string).</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; - имя столбца (строка).</target>
        </trans-unit>
        <trans-unit id="8bc34451416eb9bb94dc7e49d8604ec8fead239e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt; should be a string. The argument &lt;var&gt;expansion&lt;/var&gt; is normally the desired expansion (a string), or &lt;code&gt;nil&lt;/code&gt; to undefine the abbrev. If it is anything but a string or &lt;code&gt;nil&lt;/code&gt;, then the abbreviation expands solely by running &lt;var&gt;hook&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; должно быть строкой. Аргумент &lt;var&gt;expansion&lt;/var&gt; , как правило , искомое разложение (строка), или &lt;code&gt;nil&lt;/code&gt; , чтобы указаное сокращение. Если это что-то, кроме строки или &lt;code&gt;nil&lt;/code&gt; , тогда сокращение расширяется только с помощью команды &lt;var&gt;hook&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="30b5243fd966445dc45a08c73f83cb0da097f434" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="cf344c891bff62333dbba018c548d00aaff7e834" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;.tar</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;.tar</target>
        </trans-unit>
        <trans-unit id="216a58edd79a48074a5ad6617458bb495b2790c5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-autoloads.el</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-autoloads.el</target>
        </trans-unit>
        <trans-unit id="167bb5544e79104b156c0e1d7f1157bf42714410" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-pkg.el</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-pkg.el</target>
        </trans-unit>
        <trans-unit id="9e81faaecc9188da3158c2527f5a008ccce20eb6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;/../</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;/../</target>
        </trans-unit>
        <trans-unit id="ab97241a11e66b9d7122a5dccc133b2a7f1d73a4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;nextrecfun&lt;/var&gt; is called with point at the end of a record. This function moves point to the start of the next record. The first record is assumed to start at the position of point when &lt;code&gt;sort-subr&lt;/code&gt; is called. Therefore, you should usually move point to the beginning of the buffer before calling &lt;code&gt;sort-subr&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;nextrecfun&lt;/var&gt; вызывается с точкой в ​​конце записи. Эта функция перемещает точку в начало следующей записи. Предполагается, что первая запись начинается с позиции точки при вызове &lt;code&gt;sort-subr&lt;/code&gt; . Поэтому перед вызовом &lt;code&gt;sort-subr&lt;/code&gt; обычно следует переместить точку в начало буфера .</target>
        </trans-unit>
        <trans-unit id="cf466c1676191116404da7c893fc26c9b6a9eeb6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;number&lt;/var&gt;: offset by &lt;var&gt;number&lt;/var&gt;, relative to a base token which is the current token for &lt;code&gt;:after&lt;/code&gt; and its parent for &lt;code&gt;:before&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;number&lt;/var&gt; : смещение по &lt;var&gt;number&lt;/var&gt; относительно базового токена, который является текущим токеном для &lt;code&gt;:after&lt;/code&gt; и его родительским элементом для &lt;code&gt;:before&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b62a446c8e768cf79eea37dae884533e6c6dbd9c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;offset&lt;/var&gt; can be:</source>
          <target state="translated">&lt;var&gt;offset&lt;/var&gt; может быть:</target>
        </trans-unit>
        <trans-unit id="de3cf1331d6c45eb1d3caca8b7b2d4f52e3a4ef9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;order&lt;/var&gt; may also be omitted or &lt;code&gt;nil&lt;/code&gt;. Then the numeric order of &lt;var&gt;element&lt;/var&gt; stays unchanged if it already has one; otherwise, &lt;var&gt;element&lt;/var&gt; has no numeric order. Elements without a numeric list order are placed at the end of the list, in no particular order.</source>
          <target state="translated">&lt;var&gt;order&lt;/var&gt; также может быть опущен или равен &lt;code&gt;nil&lt;/code&gt; . Тогда числовой порядок &lt;var&gt;element&lt;/var&gt; остается неизменным, если он уже есть; в противном случае &lt;var&gt;element&lt;/var&gt; не имеет числового порядка. Элементы без числового порядка в списке помещаются в конец списка без определенного порядка.</target>
        </trans-unit>
        <trans-unit id="99c4d75e06c1981a99d6ec13897814fd98ced18d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;package&lt;/var&gt; should be the official name of the package, as a symbol (e.g., &lt;code&gt;MH-E&lt;/code&gt;). &lt;var&gt;version&lt;/var&gt; should be a string. If the package &lt;var&gt;package&lt;/var&gt; is released as part of Emacs, &lt;var&gt;package&lt;/var&gt; and &lt;var&gt;version&lt;/var&gt; should appear in the value of &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;package&lt;/var&gt; должно быть официальным названием пакета в виде символа (например, &lt;code&gt;MH-E&lt;/code&gt; ). &lt;var&gt;version&lt;/var&gt; должна быть строкой. Если пакет &lt;var&gt;package&lt;/var&gt; выпущен как часть Emacs, &lt;var&gt;package&lt;/var&gt; и &lt;var&gt;version&lt;/var&gt; должны появиться в значении &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6894fefccfb7ff6f9b8c6767f4eccbdc010b5930" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;pairs&lt;/var&gt; is a list of variable and value pairs. This macro creates a buffer-local binding in the current buffer for each of the variables, and gives them a buffer-local value. It is equivalent to calling &lt;code&gt;make-local-variable&lt;/code&gt; followed by &lt;code&gt;setq&lt;/code&gt; for each of the variables. The variables should be unquoted symbols.</source>
          <target state="translated">&lt;var&gt;pairs&lt;/var&gt; - это список пар переменных и значений. Этот макрос создает привязку локального буфера в текущем буфере для каждой из переменных и дает им локальное значение буфера. Это эквивалентно вызову &lt;code&gt;make-local-variable&lt;/code&gt; с последующим &lt;code&gt;setq&lt;/code&gt; для каждой из переменных. Переменные должны быть символами без кавычек.</target>
        </trans-unit>
        <trans-unit id="faac51bbe73b1a7baf50319796f7718c84360e1d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;position&lt;/var&gt; is a mouse position list (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), specifying the current position of the mouse cursor. As with the end-position of a drag event, this position list may represent a location outside the boundaries of the initially selected frame, in which case the list contains that frame in place of a window.</source>
          <target state="translated">&lt;var&gt;position&lt;/var&gt; - это список позиций мыши (см. &amp;laquo; &lt;a href=&quot;click-events#Click-Events&quot;&gt;События щелчка&amp;raquo;&lt;/a&gt; ), определяющий текущую позицию курсора мыши. Как и в случае с конечной позицией события перетаскивания, этот список позиций может представлять местоположение за пределами границ первоначально выбранного кадра, и в этом случае список содержит этот кадр вместо окна.</target>
        </trans-unit>
        <trans-unit id="f59e3c7c715366ed238889ef97ba31c569ce7eb7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;predicate&lt;/var&gt; can either be &lt;code&gt;t&lt;/code&gt; (which is a synonym for &lt;code&gt;equal&lt;/code&gt;), &lt;code&gt;nil&lt;/code&gt; (which means &amp;ldquo;not equal&amp;rdquo;), or a predicate that will be called with two parameters: The first is &lt;var&gt;value&lt;/var&gt;, and the second is the value of the text property we&amp;rsquo;re inspecting.</source>
          <target state="translated">&lt;var&gt;predicate&lt;/var&gt; может быть либо &lt;code&gt;t&lt;/code&gt; (синонимом &lt;code&gt;equal&lt;/code&gt; ), &lt;code&gt;nil&lt;/code&gt; (что означает &amp;laquo;не равно&amp;raquo;), либо предикатом, который будет вызываться с двумя параметрами: первый - это &lt;var&gt;value&lt;/var&gt; , а второй - значение свойства текста. мы проверяем.</target>
        </trans-unit>
        <trans-unit id="df5ae6820e0b025e86df03022536665959855d02" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;--&amp;hellip;</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;--&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="2701a0d0273e8b0469c3357e04df113afa7340aa" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;.el</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;.el</target>
        </trans-unit>
        <trans-unit id="415cc0168ff768c5644927069f207439cffdcaaf" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;question&lt;/var&gt;...&lt;var&gt;answer&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;question&lt;/var&gt;...&lt;var&gt;answer&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="b1a5e789f14de0932441acbb046bd1a8125964ba" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;radix&lt;/var&gt;r</source>
          <target state="translated">&lt;var&gt;radix&lt;/var&gt;r</target>
        </trans-unit>
        <trans-unit id="9490106685cc5ae114d3b5a517eee30cb47980e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;remapping&lt;/var&gt; may be any face spec suitable for a &lt;code&gt;face&lt;/code&gt; text property: either a face (i.e., a face name or a property list of attribute/value pairs), or a list of faces. For details, see the description of the &lt;code&gt;face&lt;/code&gt; text property in &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;. &lt;var&gt;remapping&lt;/var&gt; serves as the complete specification for the remapped face&amp;mdash;it replaces the normal definition of &lt;var&gt;face&lt;/var&gt;, instead of modifying it.</source>
          <target state="translated">&lt;var&gt;remapping&lt;/var&gt; может быть любой спецификацией лица, подходящей для свойства текста &lt;code&gt;face&lt;/code&gt; : либо лицо (т. е. имя лица или список свойств пар атрибут / значение), либо список лиц. Дополнительные сведения см. В описании свойства текста &lt;code&gt;face&lt;/code&gt; в разделе &amp;laquo; &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&amp;raquo;&lt;/a&gt; . &lt;var&gt;remapping&lt;/var&gt; служит полной спецификацией для переназначенного лица - оно заменяет обычное определение &lt;var&gt;face&lt;/var&gt; , а не изменяет его.</target>
        </trans-unit>
        <trans-unit id="7710cef71b2a55732fa034589d5a9648abf147de" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;repeated-args&lt;/var&gt;&amp;hellip;</source>
          <target state="translated">&lt;var&gt;repeated-args&lt;/var&gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="e4128ed07ab55fb2620ee23c8c4002a9d6d8a606" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reporter&lt;/var&gt; must be the result of a call to &lt;code&gt;make-progress-reporter&lt;/code&gt;. &lt;var&gt;value&lt;/var&gt; specifies the current state of your operation and must be between &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; (inclusive) as passed to &lt;code&gt;make-progress-reporter&lt;/code&gt;. For instance, if you scan a buffer, then &lt;var&gt;value&lt;/var&gt; should be the result of a call to &lt;code&gt;point&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;reporter&lt;/var&gt; должен быть результатом звонка &lt;code&gt;make-progress-reporter&lt;/code&gt; . &lt;var&gt;value&lt;/var&gt; указывает текущее состояние вашей операции и должно быть между &lt;var&gt;min-value&lt;/var&gt; и &lt;var&gt;max-value&lt;/var&gt; (включительно) значением, переданным в &lt;code&gt;make-progress-reporter&lt;/code&gt; . Например, если вы сканируете буфер, &lt;var&gt;value&lt;/var&gt; должно быть результатом вызова &lt;code&gt;point&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c7b8b66a17ec0d9e7d1c618f4047785138de257" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reporter&lt;/var&gt;, &lt;var&gt;value&lt;/var&gt;, and &lt;var&gt;suffix&lt;/var&gt; have the same meaning as for &lt;code&gt;progress-reporter-update&lt;/code&gt;. Optional &lt;var&gt;new-message&lt;/var&gt; allows you to change the message of the &lt;var&gt;reporter&lt;/var&gt;. Since this function always updates the echo area, such a change will be immediately presented to the user.</source>
          <target state="translated">&lt;var&gt;reporter&lt;/var&gt; , &lt;var&gt;value&lt;/var&gt; и &lt;var&gt;suffix&lt;/var&gt; имеют то же значение, что и для &lt;code&gt;progress-reporter-update&lt;/code&gt; . Дополнительное &lt;var&gt;new-message&lt;/var&gt; позволяет вам изменить сообщение &lt;var&gt;reporter&lt;/var&gt; . Поскольку эта функция всегда обновляет эхо-область, такое изменение будет немедленно представлено пользователю.</target>
        </trans-unit>
        <trans-unit id="d51fe7a021174666b578e4a21bdb3a618171cc76" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;requirements&lt;/var&gt; is a list of required packages and their versions. Each element in this list should have the form &lt;code&gt;(&lt;var&gt;dep-name&lt;/var&gt;
&lt;var&gt;dep-version&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;dep-name&lt;/var&gt; is a symbol whose name is the dependency&amp;rsquo;s package name, and &lt;var&gt;dep-version&lt;/var&gt; is the dependency&amp;rsquo;s version (a string).</source>
          <target state="translated">&lt;var&gt;requirements&lt;/var&gt; - это список необходимых пакетов и их версий. Каждый элемент в этом списке должен иметь форму &lt;code&gt;(&lt;var&gt;dep-name&lt;/var&gt; &lt;var&gt;dep-version&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;dep-name&lt;/var&gt; - это символ, имя которого является именем пакета зависимости, а &lt;var&gt;dep-version&lt;/var&gt; - версией зависимости (строка).</target>
        </trans-unit>
        <trans-unit id="e737d37d389d75f9cac6bb7ddb721d5c73f5fc03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;selected&lt;/var&gt; is an expression; the checkbox or radio button is selected whenever the expression&amp;rsquo;s value is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;selected&lt;/var&gt; - выражение; флажок или переключатель устанавливается, когда значение выражения не равно &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e76826cc6b334ade60730144fcdff6d3be4a681" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;service&lt;/var&gt; specifies a port number to connect to; or, for a server, the port number to listen on. It should be a service name like &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;service&lt;/var&gt; указывает номер порта для подключения; или, для сервера, номер порта для прослушивания. Это должно быть имя службы, например &quot;</target>
        </trans-unit>
        <trans-unit id="973adcc3dd59f5f52753edf51047c9f8e5fa5e46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sort&lt;/var&gt; specifies how to sort entries by the column. If &lt;code&gt;nil&lt;/code&gt;, the column cannot be used for sorting. If &lt;code&gt;t&lt;/code&gt;, the column is sorted by comparing string values. Otherwise, this should be a predicate function for &lt;code&gt;sort&lt;/code&gt; (see &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;Rearrangement&lt;/a&gt;), which accepts two arguments with the same form as the elements of &lt;code&gt;tabulated-list-entries&lt;/code&gt; (see below).</source>
          <target state="translated">&lt;var&gt;sort&lt;/var&gt; указывает, как сортировать записи по столбцу. Если &lt;code&gt;nil&lt;/code&gt; , столбец нельзя использовать для сортировки. Если &lt;code&gt;t&lt;/code&gt; , столбец сортируется путем сравнения строковых значений. В противном случае это должна быть функция-предикат для &lt;code&gt;sort&lt;/code&gt; (см. &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;Перестановка&lt;/a&gt; ), которая принимает два аргумента с той же формой, что и элементы &lt;code&gt;tabulated-list-entries&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="7d39073d4b8db9cde37f102e3b0b1b5f83406619" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;speed&lt;/var&gt; is the speed of the serial port in bits per second. 9600 is a common value. The buffer is in Term mode; see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html#Term-Mode&quot;&gt;Term Mode&lt;/a&gt; in</source>
          <target state="translated">&lt;var&gt;speed&lt;/var&gt; - это скорость последовательного порта в битах в секунду. 9600 - обычное значение. Буфер находится в режиме Term; см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html#Term-Mode&quot;&gt;Term Mode&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="6f1b89e546d7f9bc516d3a87661e90ef8ea569b5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;speed&lt;/var&gt; is the speed of the serial port in bits per second. 9600 is a common value. The buffer is in Term mode; see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html#Term-Mode&quot;&gt;Term Mode&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971f47e8670651577dc6a42bb689ff8bc62ca26d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; delimit the text to complete (which should enclose point). &lt;var&gt;collection&lt;/var&gt; is a completion table for completing that text, in a form suitable for passing as the second argument to &lt;code&gt;try-completion&lt;/code&gt; (see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;); completion alternatives will be generated from this completion table in the usual way, via the completion styles defined in &lt;code&gt;completion-styles&lt;/code&gt; (see &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;Completion Variables&lt;/a&gt;). &lt;var&gt;props&lt;/var&gt; is a property list for additional information; any of the properties in &lt;code&gt;completion-extra-properties&lt;/code&gt; are recognized (see &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;Completion Variables&lt;/a&gt;), as well as the following additional ones:</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; ограничивают текст до завершения (который должен заключать точку). &lt;var&gt;collection&lt;/var&gt; - это таблица завершения для завершения этого текста в форме, подходящей для передачи в качестве второго аргумента функции &lt;code&gt;try-completion&lt;/code&gt; &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Completion&lt;/a&gt; (см. &amp;laquo; Базовое завершение&amp;raquo; ); Альтернативы завершения будут сгенерированы из этой таблицы завершения обычным способом с помощью стилей завершения, определенных в &lt;code&gt;completion-styles&lt;/code&gt; (см. &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;Переменные завершения&lt;/a&gt; ). &lt;var&gt;props&lt;/var&gt; - это список свойств для дополнительной информации; распознаются любые свойства в &lt;code&gt;completion-extra-properties&lt;/code&gt; &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;завершения&lt;/a&gt; (см. Переменные завершения ), а также следующие дополнительные:</target>
        </trans-unit>
        <trans-unit id="9309574541180ffc910dcfe02cdda08d3749f086" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start&lt;/var&gt; may be a string, in which case &lt;var&gt;end&lt;/var&gt; is ignored and the returned value references string indices instead of buffer positions.</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; может быть строкой, и в этом случае &lt;var&gt;end&lt;/var&gt; игнорируется, а возвращаемое значение ссылается на строковые индексы, а не на позиции буфера.</target>
        </trans-unit>
        <trans-unit id="da4a280c768d1277e096e4c3e78a80bca4fe7713" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;startkeyfun&lt;/var&gt; is called to move point from the start of a record to the start of the sort key. This argument is optional; if it is omitted, the whole record is the sort key. If supplied, the function should either return a non-&lt;code&gt;nil&lt;/code&gt; value to be used as the sort key, or return &lt;code&gt;nil&lt;/code&gt; to indicate that the sort key is in the buffer starting at point. In the latter case, &lt;var&gt;endkeyfun&lt;/var&gt; is called to find the end of the sort key.</source>
          <target state="translated">&lt;var&gt;startkeyfun&lt;/var&gt; вызывается для перемещения точки из начала записи в начало ключа сортировки. Этот аргумент не является обязательным; если он опущен, вся запись является ключом сортировки. Если задано, функция должна либо вернуть значение, отличное от &lt;code&gt;nil&lt;/code&gt; , которое будет использоваться в качестве ключа сортировки, либо вернуть &lt;code&gt;nil&lt;/code&gt; , чтобы указать, что ключ сортировки находится в буфере, начиная с точки. В последнем случае &lt;var&gt;endkeyfun&lt;/var&gt; чтобы найти конец ключа сортировки.</target>
        </trans-unit>
        <trans-unit id="f73238806df0360ca7ee8bae497b6f974a669f33" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;style&lt;/var&gt; is a symbol describing the type of menu item; it should be &lt;code&gt;toggle&lt;/code&gt; (a checkbox), or &lt;code&gt;radio&lt;/code&gt; (a radio button), or anything else (meaning an ordinary menu item).</source>
          <target state="translated">&lt;var&gt;style&lt;/var&gt; - символ, описывающий тип пункта меню; он должен быть &lt;code&gt;toggle&lt;/code&gt; (флажок), или &lt;code&gt;radio&lt;/code&gt; (переключатель), или чем-то еще (имеется в виду обычный пункт меню).</target>
        </trans-unit>
        <trans-unit id="7e15045cd15efc60dcbadbf4a9bfc1c74a850b81" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;symbol&lt;/var&gt; should be a function name; that function is called to calculate the indentation of a line within this expression. The function receives two arguments:</source>
          <target state="translated">&lt;var&gt;symbol&lt;/var&gt; должен быть именем функции; эта функция вызывается для вычисления отступа строки в этом выражении. Функция получает два аргумента:</target>
        </trans-unit>
        <trans-unit id="b66f2812c276f2743d9f7dec6d2407921c4d0a73" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;tag&lt;/var&gt; matches if it is &lt;code&gt;equal&lt;/code&gt; to the value of &lt;var&gt;form&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;tag&lt;/var&gt; совпадает, если он &lt;code&gt;equal&lt;/code&gt; значению &lt;var&gt;form&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c11330b958f1facf64bc5c4a8eb2f52f8887ebe9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;tag&lt;/var&gt; matches unconditionally if it is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;tag&lt;/var&gt; совпадает безоговорочно, если это &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa74cd02b9eeaeaf01040683ef1ec0eda3535dae" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;time&lt;/var&gt; may specify an absolute or a relative time.</source>
          <target state="translated">&lt;var&gt;time&lt;/var&gt; может указывать абсолютное или относительное время.</target>
        </trans-unit>
        <trans-unit id="95feb66b937fd5d812ad2340ecbc42562d0ebd18" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;title&lt;/var&gt; is a string to display in the mode line while this method is active. &lt;var&gt;description&lt;/var&gt; is a string describing this method and what it is good for.</source>
          <target state="translated">&lt;var&gt;title&lt;/var&gt; - это строка для отображения в строке режима, пока этот метод активен. &lt;var&gt;description&lt;/var&gt; - это строка, описывающая этот метод и его назначение.</target>
        </trans-unit>
        <trans-unit id="a98d01c0ccac615cc082b2f95fdfe91a54d7a493" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;to-fn&lt;/var&gt; must not involve buffers or files other than the one being encoded, otherwise the internal buffer used for formatting might be overwritten.</source>
          <target state="translated">&lt;var&gt;to-fn&lt;/var&gt; не должен включать в себя буферы или файлы, отличные от кодируемого, иначе внутренний буфер, используемый для форматирования, может быть перезаписан.</target>
        </trans-unit>
        <trans-unit id="b832016f06701ddcb16ef3791cf3a3ce2a9399c1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;type&lt;/var&gt; should be a symbol; it is usually one of &lt;code&gt;PRIMARY&lt;/code&gt;, &lt;code&gt;SECONDARY&lt;/code&gt; or &lt;code&gt;CLIPBOARD&lt;/code&gt;. These are symbols with upper-case names, in accord with X Window System conventions. If &lt;var&gt;type&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that stands for &lt;code&gt;PRIMARY&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; должен быть символом; обычно это &lt;code&gt;PRIMARY&lt;/code&gt; , &lt;code&gt;SECONDARY&lt;/code&gt; или &lt;code&gt;CLIPBOARD&lt;/code&gt; . Это символы с именами в верхнем регистре в соответствии с соглашениями системы X Window. Если &lt;var&gt;type&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , это означает &lt;code&gt;PRIMARY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a342c7d2cce7402a90fc60df3bea3e251c92fd5d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;value&lt;/var&gt; is sent into the iterator and becomes the value to which &lt;code&gt;iter-yield&lt;/code&gt; evaluates. &lt;var&gt;value&lt;/var&gt; is ignored for the first &lt;code&gt;iter-next&lt;/code&gt; call to a given iterator, since at the start of &lt;var&gt;iterator&lt;/var&gt;&amp;rsquo;s generator function, the generator function is not evaluating any &lt;code&gt;iter-yield&lt;/code&gt; form.</source>
          <target state="translated">&lt;var&gt;value&lt;/var&gt; отправляется в итератор и становится значением, которое оценивает &lt;code&gt;iter-yield&lt;/code&gt; . &lt;var&gt;value&lt;/var&gt; игнорируется для первого вызова &lt;code&gt;iter-next&lt;/code&gt; данного итератора, поскольку в начале функции генератора &lt;var&gt;iterator&lt;/var&gt; функция генератора не оценивает какую &lt;code&gt;iter-yield&lt;/code&gt; либо форму iter-yield .</target>
        </trans-unit>
        <trans-unit id="82930ebb4abfe28d89aca586ee4550c2d7c57fee" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;var&lt;/var&gt; is a variable name (a symbol), and &lt;var&gt;expression&lt;/var&gt; is an expression which evaluates to the desired customized value.</source>
          <target state="translated">&lt;var&gt;var&lt;/var&gt; - это имя переменной (символ), а &lt;var&gt;expression&lt;/var&gt; - это выражение, вычисляющее желаемое настраиваемое значение.</target>
        </trans-unit>
        <trans-unit id="ad71f6f9e29b21a5a4b5ba0031c96e235018c497" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;watch-function&lt;/var&gt; will be called, just before changing the value of &lt;var&gt;symbol&lt;/var&gt;, with 4 arguments: &lt;var&gt;symbol&lt;/var&gt;, &lt;var&gt;newval&lt;/var&gt;, &lt;var&gt;operation&lt;/var&gt;, and &lt;var&gt;where&lt;/var&gt;. &lt;var&gt;symbol&lt;/var&gt; is the variable being changed. &lt;var&gt;newval&lt;/var&gt; is the value it will be changed to. (The old value is available to &lt;var&gt;watch-function&lt;/var&gt; as the value of &lt;var&gt;symbol&lt;/var&gt;, since it was not yet changed to &lt;var&gt;newval&lt;/var&gt;.) &lt;var&gt;operation&lt;/var&gt; is a symbol representing the kind of change, one of: &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;unlet&lt;/code&gt;, &lt;code&gt;makunbound&lt;/code&gt;, or &lt;code&gt;defvaralias&lt;/code&gt;. &lt;var&gt;where&lt;/var&gt; is a buffer if the buffer-local value of the variable is being changed, &lt;code&gt;nil&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;var&gt;watch-function&lt;/var&gt; будет вызываться непосредственно перед изменением значения &lt;var&gt;symbol&lt;/var&gt; с 4 аргументами: &lt;var&gt;symbol&lt;/var&gt; , &lt;var&gt;newval&lt;/var&gt; , &lt;var&gt;operation&lt;/var&gt; и &lt;var&gt;where&lt;/var&gt; . &lt;var&gt;symbol&lt;/var&gt; - это изменяемая переменная. &lt;var&gt;newval&lt;/var&gt; - это значение, на которое оно будет изменено. (Старое значение доступно для &lt;var&gt;watch-function&lt;/var&gt; как значение &lt;var&gt;symbol&lt;/var&gt; , поскольку оно еще не было изменено на &lt;var&gt;newval&lt;/var&gt; .) &lt;var&gt;operation&lt;/var&gt; - это символ, представляющий вид изменения, один из: &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;unlet&lt;/code&gt; , &lt;code&gt;makunbound&lt;/code&gt; или &lt;code&gt;defvaralias&lt;/code&gt; .. &lt;var&gt;where&lt;/var&gt; - буфер, если значение переменной, локальное в буфере, изменяется, в противном случае - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4052603b19bcf65791aed68e81734e46505fd1f7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;where&lt;/var&gt; determines how &lt;var&gt;function&lt;/var&gt; is composed with the existing function, e.g., whether &lt;var&gt;function&lt;/var&gt; should be called before, or after the original function. See &lt;a href=&quot;advice-combinators#Advice-Combinators&quot;&gt;Advice Combinators&lt;/a&gt;, for the list of available ways to compose the two functions.</source>
          <target state="translated">&lt;var&gt;where&lt;/var&gt; определяет, как &lt;var&gt;function&lt;/var&gt; составляется с существующей функцией, например, должна ли &lt;var&gt;function&lt;/var&gt; вызываться до или после исходной функции. См. В разделе &amp;laquo; &lt;a href=&quot;advice-combinators#Advice-Combinators&quot;&gt;Комбинаторы советов&amp;raquo;&lt;/a&gt; список доступных способов объединения двух функций.</target>
        </trans-unit>
        <trans-unit id="ca11e1531e4a8d8494d88f05f553a46919cfe550" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;width&lt;/var&gt; is the width to reserve for the column (an integer). This is meaningless for the last column, which runs to the end of each line.</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; - это ширина, зарезервированная для столбца (целое число). Это бессмысленно для последнего столбца, который продолжается до конца каждой строки.</target>
        </trans-unit>
        <trans-unit id="5627b0a3a3d443b1933453bb5cd20de0f0d26d5a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;width&lt;/var&gt; specifies the width of the vertical scroll bar in pixels (&lt;code&gt;nil&lt;/code&gt; means use the width specified for the frame). &lt;var&gt;vertical-type&lt;/var&gt; specifies whether to have a vertical scroll bar and, if so, where. The possible values are &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, which means to use the frame&amp;rsquo;s default, and &lt;code&gt;nil&lt;/code&gt; for no vertical scroll bar.</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; определяет ширину вертикальной полосы прокрутки в пикселях ( &lt;code&gt;nil&lt;/code&gt; означает использование ширины, указанной для рамки). &lt;var&gt;vertical-type&lt;/var&gt; указывает, нужна ли вертикальная полоса прокрутки, и если да, то где. Возможные значения: &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; , что означает использование фрейма по умолчанию, и &lt;code&gt;nil&lt;/code&gt; ,если вертикальная полоса прокрутки отсутствует.</target>
        </trans-unit>
        <trans-unit id="c547cbc5c2845f4e2577ba46634ae50d14551741" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;width&lt;/var&gt;, &lt;var&gt;height&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; , &lt;var&gt;height&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="a74d8ab3c01149182f1dc5ec8c690fdbb66475cb" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;window&lt;/var&gt; must be a live window and defaults to the selected window. &lt;var&gt;position&lt;/var&gt; defaults to the value of &lt;code&gt;window-point&lt;/code&gt; of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;window&lt;/var&gt; должно быть активным окном и по умолчанию используется выбранное окно. &lt;var&gt;position&lt;/var&gt; по умолчанию значения &lt;code&gt;window-point&lt;/code&gt; из &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="0dcdc549a8dcec6ec113ac1e899f074af9747242" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="13a189a749c2f5d122db857ceb450b488307174d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;width&lt;/var&gt;, and &lt;var&gt;height&lt;/var&gt; are integers. &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , &lt;var&gt;width&lt;/var&gt; и &lt;var&gt;height&lt;/var&gt; - целые числа. '</target>
        </trans-unit>
        <trans-unit id="f26d70e928cbdeb5062b11f0ae6f958bb78b21d4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;:/</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt;:/</target>
        </trans-unit>
        <trans-unit id="67327d2400403d993e67763cc63d3cf059b83c31" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="f31313bcbf9330da698e50ff142d0dd1d44b3b89" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="30a117ecb6ca07e6f0ab39ae1a00a801221ab69b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;AM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;AM</target>
        </trans-unit>
        <trans-unit id="0dc7a88310600ac2f33242840088cfa949ec5c00" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;PM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;PM</target>
        </trans-unit>
        <trans-unit id="c4c469fb34962159f38a8e5056a82948fa3189e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;am</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;am</target>
        </trans-unit>
        <trans-unit id="03562318cb6818e744ba723a24c875d69c2acd5e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;pm</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;pm</target>
        </trans-unit>
        <trans-unit id="7ef500418ff05008137b29635c42810a2ebca53e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;AM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;AM</target>
        </trans-unit>
        <trans-unit id="6c6955642e9352178bc5a205a340c2d1c58c2de1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;PM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;PM</target>
        </trans-unit>
        <trans-unit id="17736819552d9e273869f36b796435c4a2c74701" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;am</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;am</target>
        </trans-unit>
        <trans-unit id="2a964e36e106b1339a3db0d45ec183e349520142" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;pm</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;pm</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="f52815edb4bf4384e64b0256a58e2fe3b042d4cd" translate="yes" xml:space="preserve">
          <source>?A</source>
          <target state="translated">?A</target>
        </trans-unit>
        <trans-unit id="599203ebe43f2624eea570ebba0a49b67a1818e0" translate="yes" xml:space="preserve">
          <source>?B</source>
          <target state="translated">?B</target>
        </trans-unit>
        <trans-unit id="b5a94beeeb73f886a4d79af28858dcb3ab6b7b31" translate="yes" xml:space="preserve">
          <source>?C</source>
          <target state="translated">?C</target>
        </trans-unit>
        <trans-unit id="6b4d70182298a45eaa7031398daeb6ad2782ad12" translate="yes" xml:space="preserve">
          <source>?\(</source>
          <target state="translated">?\(</target>
        </trans-unit>
        <trans-unit id="cbdd61d5fc29c31fa4405792eff9e39190e4f4e5" translate="yes" xml:space="preserve">
          <source>?\+</source>
          <target state="translated">?\+</target>
        </trans-unit>
        <trans-unit id="bad2940ef87b0d17a7c5116349545f3d674e067b" translate="yes" xml:space="preserve">
          <source>?\001</source>
          <target state="translated">?\001</target>
        </trans-unit>
        <trans-unit id="b3502d529dc1d8854f93560dc98666d4c65a5d0b" translate="yes" xml:space="preserve">
          <source>?\101</source>
          <target state="translated">?\101</target>
        </trans-unit>
        <trans-unit id="9fce6b611deb45edf21130052b9ecd9841a07506" translate="yes" xml:space="preserve">
          <source>?\C-\M-b</source>
          <target state="translated">?\C-\M-b</target>
        </trans-unit>
        <trans-unit id="4b0228d76a0a6f7f54d81c734f2e43b1cc79e704" translate="yes" xml:space="preserve">
          <source>?\C-\S-O</source>
          <target state="translated">?\C-\S-O</target>
        </trans-unit>
        <trans-unit id="87d2660a051e41aff96738baba5c207e2368c747" translate="yes" xml:space="preserve">
          <source>?\C-\S-o</source>
          <target state="translated">?\C-\S-o</target>
        </trans-unit>
        <trans-unit id="47fab5f7d4ae0f140143069c934867ab789751be" translate="yes" xml:space="preserve">
          <source>?\C-i</source>
          <target state="translated">?\C-i</target>
        </trans-unit>
        <trans-unit id="f90e3407f2bff3255b57e2755039432462d135ce" translate="yes" xml:space="preserve">
          <source>?\H-\M-\A-x</source>
          <target state="translated">?\H-\M-\A-x</target>
        </trans-unit>
        <trans-unit id="fee07cee280ad5aba36e35ab3213cbf3c5b9533d" translate="yes" xml:space="preserve">
          <source>?\M-A</source>
          <target state="translated">?\M-A</target>
        </trans-unit>
        <trans-unit id="a1f5f591dc022e0992becc5c6b9f2e09e9c4b113" translate="yes" xml:space="preserve">
          <source>?\M-\002</source>
          <target state="translated">?\M-\002</target>
        </trans-unit>
        <trans-unit id="bafd36bf88f8103b9efc69193c226588e4c45387" translate="yes" xml:space="preserve">
          <source>?\M-\101</source>
          <target state="translated">?\M-\101</target>
        </trans-unit>
        <trans-unit id="e5909bdf46b00c73e8aeff9468823539310a55f0" translate="yes" xml:space="preserve">
          <source>?\M-\C-b</source>
          <target state="translated">?\M-\C-b</target>
        </trans-unit>
        <trans-unit id="1b208eb3a3549c10763461c273c87956d3e3bbd4" translate="yes" xml:space="preserve">
          <source>?\N{LATIN SMALL LETTER A WITH GRAVE}</source>
          <target state="translated">? \ N {СТРОЧНАЯ ЛАТИНСКАЯ БУКВА A С ТЯЖЕЛЫМ}</target>
        </trans-unit>
        <trans-unit id="69a1f2deba55a734a6250ac07cfbc6794b3933af" translate="yes" xml:space="preserve">
          <source>?\\</source>
          <target state="translated">?\\</target>
        </trans-unit>
        <trans-unit id="0cf3cb1faea919f3860f818b03bbfcc9243d8900" translate="yes" xml:space="preserve">
          <source>?\^I</source>
          <target state="translated">?\^I</target>
        </trans-unit>
        <trans-unit id="3a04971235dc052a903f8d075da18e8ac58afa8f" translate="yes" xml:space="preserve">
          <source>?\^i</source>
          <target state="translated">?\^i</target>
        </trans-unit>
        <trans-unit id="867b960f113a7a5c0779b8c58e84e28e2f75a966" translate="yes" xml:space="preserve">
          <source>?\a</source>
          <target state="translated">?\a</target>
        </trans-unit>
        <trans-unit id="c5fbfc44c04b0fd9df447c22156ee7e37b25953b" translate="yes" xml:space="preserve">
          <source>?\b</source>
          <target state="translated">?\b</target>
        </trans-unit>
        <trans-unit id="4a810b1bf40c42dd4a08f3aa3861012326b32b47" translate="yes" xml:space="preserve">
          <source>?\d</source>
          <target state="translated">?\d</target>
        </trans-unit>
        <trans-unit id="29b3719b09d80bc7811aa176d73698536daca42b" translate="yes" xml:space="preserve">
          <source>?\e</source>
          <target state="translated">?\e</target>
        </trans-unit>
        <trans-unit id="ae9f72aaf52a6d4ac9607293d42d29afbca0843b" translate="yes" xml:space="preserve">
          <source>?\f</source>
          <target state="translated">?\f</target>
        </trans-unit>
        <trans-unit id="bedb9d8a983c4ae4258638456f7c4f707b123023" translate="yes" xml:space="preserve">
          <source>?\n</source>
          <target state="translated">?\n</target>
        </trans-unit>
        <trans-unit id="f946c4dd6853b2a51d459def9d1ebc230990d4fa" translate="yes" xml:space="preserve">
          <source>?\r</source>
          <target state="translated">?\r</target>
        </trans-unit>
        <trans-unit id="17d0768830f0c94bc4faf17615c57d2000e33f61" translate="yes" xml:space="preserve">
          <source>?\s</source>
          <target state="translated">?\s</target>
        </trans-unit>
        <trans-unit id="88c16d23df60641aa21518113b70aa5b1fd9c6af" translate="yes" xml:space="preserve">
          <source>?\t</source>
          <target state="translated">?\t</target>
        </trans-unit>
        <trans-unit id="5001639220c7a661b719c767f92b87d61d334296" translate="yes" xml:space="preserve">
          <source>?\v</source>
          <target state="translated">?\v</target>
        </trans-unit>
        <trans-unit id="fe8951e791e6bfe2053499640fdae36ad6b9fddc" translate="yes" xml:space="preserve">
          <source>?\x1</source>
          <target state="translated">?\x1</target>
        </trans-unit>
        <trans-unit id="7bfc455b958ad97ebd11ba2a62f818761637ffae" translate="yes" xml:space="preserve">
          <source>?\x41</source>
          <target state="translated">?\x41</target>
        </trans-unit>
        <trans-unit id="dbb47e7dc891f20d38639d6ad3ad2e8c45fd9a4d" translate="yes" xml:space="preserve">
          <source>?a</source>
          <target state="translated">?a</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="7b25536642ada965a8ba70bb7e96b265170e1e74" translate="yes" xml:space="preserve">
          <source>A &amp;lsquo;</source>
          <target state="translated">А '</target>
        </trans-unit>
        <trans-unit id="8cdca21dea5e4a8264a4a0d19a1fee7e75441b25" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;let&lt;/code&gt; special form has a sequence of bindings and a body. Each of the bindings is either a symbol or a sublist with a symbol and optional expression. In the specification below, notice the &lt;code&gt;gate&lt;/code&gt; inside of the sublist to prevent backtracking once a sublist is found.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; специальная форма имеет последовательность связывания и тела. Каждая из привязок представляет собой символ или подсписок с символом и необязательным выражением. В приведенной ниже спецификации обратите внимание на &lt;code&gt;gate&lt;/code&gt; внутри подсписка, чтобы предотвратить поиск с возвратом после нахождения подсписка.</target>
        </trans-unit>
        <trans-unit id="135e6a2bf74be90fe3f773ee5fdeeae2bbbdd7ab" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;progn&lt;/code&gt; special form looks like this:</source>
          <target state="translated">А &lt;code&gt;progn&lt;/code&gt; особой формы выглядит следующим образом :</target>
        </trans-unit>
        <trans-unit id="c62e5da7301e854f814d079251caea61f86ba089" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct buffer_text&lt;/code&gt; structure that ordinarily holds the buffer contents. In indirect buffers, this field is not used.</source>
          <target state="translated">&lt;code&gt;struct buffer_text&lt;/code&gt; структура , которая обычно удерживает содержимое буфера. В косвенных буферах это поле не используется.</target>
        </trans-unit>
        <trans-unit id="0d79644c9f1e2b9d43b38945d21a85b8f41eceb5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;wrong-type-argument&lt;/code&gt; error is signaled if &lt;var&gt;start&lt;/var&gt; is not an integer or if &lt;var&gt;end&lt;/var&gt; is neither an integer nor &lt;code&gt;nil&lt;/code&gt;. An &lt;code&gt;args-out-of-range&lt;/code&gt; error is signaled if &lt;var&gt;start&lt;/var&gt; indicates a character following &lt;var&gt;end&lt;/var&gt;, or if either integer is out of range for &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">Ошибка &lt;code&gt;wrong-type-argument&lt;/code&gt; сигнализируется, если &lt;var&gt;start&lt;/var&gt; не является целым числом или если &lt;var&gt;end&lt;/var&gt; не является ни целым числом, ни &lt;code&gt;nil&lt;/code&gt; . &lt;code&gt;args-out-of-range&lt;/code&gt; сигнализируется ошибка , если &lt;var&gt;start&lt;/var&gt; указывает на символ , следующий &lt;var&gt;end&lt;/var&gt; , или , если либо целое число , находится вне допустимого диапазона для &lt;var&gt;string&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd1de607d4e86730b7914fe4c5cd9684285cc40" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Lisp macro&lt;/em&gt; is a user-defined construct that extends the Lisp language. It is represented as an object much like a function, but with different argument-passing semantics. A Lisp macro has the form of a list whose first element is the symbol &lt;code&gt;macro&lt;/code&gt; and whose &lt;small&gt;CDR&lt;/small&gt; is a Lisp function object, including the &lt;code&gt;lambda&lt;/code&gt; symbol.</source>
          <target state="translated">&lt;em&gt;Лисп макросы&lt;/em&gt; являются определенным пользователем конструкцией , которая расширяет язык Лиспа. Он представлен как объект, очень похожий на функцию, но с другой семантикой передачи аргументов. Макрос Лиспа имеет форму списка, первым элементом которого является &lt;code&gt;macro&lt;/code&gt; символа, а &lt;small&gt;CDR&lt;/small&gt; - объектом функции Лиспа, включая &lt;code&gt;lambda&lt;/code&gt; символ.</target>
        </trans-unit>
        <trans-unit id="7d0a1b483ba2d8b083551109a784f0c67ae64feb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;backup file&lt;/em&gt; is a copy of the old contents of a file you are editing. Emacs makes a backup file the first time you save a buffer into its visited file. Thus, normally, the backup file contains the contents of the file as it was before the current editing session. The contents of the backup file normally remain unchanged once it exists.</source>
          <target state="translated">&lt;em&gt;Резервный файл&lt;/em&gt; является копией старого содержимого редактируемого файла. Emacs создает файл резервной копии, когда вы в первый раз сохраняете буфер в посещенный файл. Таким образом, обычно файл резервной копии содержит содержимое файла, которое было до текущего сеанса редактирования. Содержимое файла резервной копии обычно остается неизменным после того, как он существует.</target>
        </trans-unit>
        <trans-unit id="3d929fdcc82b42627ef27e398a719ddbde6028a6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;bool-vector&lt;/em&gt; is a one-dimensional array whose elements must be &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;BOOL-вектор&lt;/em&gt; представляет собой одномерный массив, элементы которого должны быть &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="825376a8553269fb52ebcf7ffb4eb207689b12ed" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;buffer&lt;/em&gt; is a Lisp object containing text to be edited. Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files. Although several buffers normally exist, only one buffer is designated the &lt;em&gt;current buffer&lt;/em&gt; at any time. Most editing commands act on the contents of the current buffer. Each buffer, including the current buffer, may or may not be displayed in any windows.</source>
          <target state="translated">&lt;em&gt;Буфер&lt;/em&gt; представляет собой объект Лиспа , содержащий текст для редактирования. Буферы используются для хранения содержимого посещаемых файлов; также могут быть буферы, которые не обращаются к файлам. Хотя обычно существует несколько буферов, только один буфер назначается &lt;em&gt;текущим буфером&lt;/em&gt; в любое время. Большинство команд редактирования воздействуют на содержимое текущего буфера. Каждый буфер, включая текущий буфер, может отображаться или не отображаться в любых окнах.</target>
        </trans-unit>
        <trans-unit id="6f67a6c4f9bfcdbbe46b59e51fc8c393aeac5bb3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;buffer&lt;/em&gt; is a Lisp object containing text to be edited. Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files. While several buffers may exist at one time, only one buffer is designated the &lt;em&gt;current buffer&lt;/em&gt; at any time. Most editing commands act on the contents of the current buffer. Each buffer, including the current buffer, may or may not be displayed in any windows.</source>
          <target state="translated">&lt;em&gt;Буфер&lt;/em&gt; представляет собой объект Лиспа , содержащий текст для редактирования. Буферы используются для хранения содержимого посещаемых файлов; также могут быть буферы, которые не обращаются к файлам. В то время как несколько буферов могут существовать одновременно, только один буфер назначается &lt;em&gt;текущим буфером&lt;/em&gt; в любое время. Большинство команд редактирования воздействуют на содержимое текущего буфера. Каждый буфер, включая текущий буфер, может отображаться или не отображаться в любых окнах.</target>
        </trans-unit>
        <trans-unit id="52fb4ef66447b55a8ae80b672427c06354ee2e1d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;buffer&lt;/em&gt; is an object that holds text that can be edited (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). Most buffers hold the contents of a disk file (see &lt;a href=&quot;files#Files&quot;&gt;Files&lt;/a&gt;) so they can be edited, but some are used for other purposes. Most buffers are also meant to be seen by the user, and therefore displayed, at some time, in a window (see &lt;a href=&quot;windows#Windows&quot;&gt;Windows&lt;/a&gt;). But a buffer need not be displayed in any window. Each buffer has a designated position called &lt;em&gt;point&lt;/em&gt; (see &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;); most editing commands act on the contents of the current buffer in the neighborhood of point. At any time, one buffer is the &lt;em&gt;current buffer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Буфер&lt;/em&gt; представляет собой объект , который содержит текст , который можно редактировать (см &lt;a href=&quot;buffers#Buffers&quot;&gt;Буферов&lt;/a&gt; ). Большинство буферов содержат содержимое файла на диске (см. &amp;laquo; &lt;a href=&quot;files#Files&quot;&gt;Файлы&amp;raquo;&lt;/a&gt; ), поэтому их можно редактировать, но некоторые из них используются для других целей. Большинство буферов также предназначены для того, чтобы их видел пользователь и, следовательно, когда-нибудь отображаются в окне (см. &lt;a href=&quot;windows#Windows&quot;&gt;Windows&lt;/a&gt; ). Но буфер не нужно отображать ни в каком окне. У каждого буфера есть назначенная позиция, называемая &lt;em&gt;точкой&lt;/em&gt; (см. &lt;a href=&quot;positions#Positions&quot;&gt;Позиции&lt;/a&gt; ); большинство команд редактирования воздействуют на содержимое текущего буфера в окрестности точки. В любой момент &lt;em&gt;текущий буфер&lt;/em&gt; является одним &lt;em&gt;буфером&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="58e9f6a52a39d48be38551b57b93b51b37d8bbc8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;char-table&lt;/em&gt; is a one-dimensional array of elements of any type, indexed by character codes. Char-tables have certain extra features to make them more useful for many jobs that involve assigning information to character codes&amp;mdash;for example, a char-table can have a parent to inherit from, a default value, and a small number of extra slots to use for special purposes. A char-table can also specify a single value for a whole character set.</source>
          <target state="translated">&lt;em&gt;Символ-таблица&lt;/em&gt; представляет собой одномерный массив элементов любого типа, индексированный коды символов. Таблицы символов имеют определенные дополнительные функции, которые делают их более полезными для многих задач, связанных с присвоением информации кодам символов - например, таблица символов может иметь родительский элемент, от которого следует наследовать, значение по умолчанию и небольшое количество дополнительных слотов для использовать для специальных целей. Таблица символов также может указывать одно значение для всего набора символов.</target>
        </trans-unit>
        <trans-unit id="4d0930676c0654f8b70278e726ef587819be2392" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character property&lt;/em&gt; is a named attribute of a character that specifies how the character behaves and how it should be handled during text processing and display. Thus, character properties are an important part of specifying the character&amp;rsquo;s semantics.</source>
          <target state="translated">&lt;em&gt;Свойство характера&lt;/em&gt; именованный атрибут символа , который определяет , каким образом ведет себя характер и как он должен быть обработан в процессе обработки текста и отображения. Таким образом, свойства символа являются важной частью определения семантики символа.</target>
        </trans-unit>
        <trans-unit id="e3936c7a37167833ab4cfaa4fe7b776318fe87ee" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character&lt;/em&gt; in Emacs Lisp is nothing more than an integer. In other words, characters are represented by their character codes. For example, the character</source>
          <target state="translated">&lt;em&gt;Символов&lt;/em&gt; в Emacs Lisp является не более чем на целое число. Другими словами, символы представлены своими кодами символов. Например, персонаж</target>
        </trans-unit>
        <trans-unit id="988e76f4ba6424d00a22226b31c6bb6069712f52" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;command-line option&lt;/em&gt; is an argument on the command line, which has the form:</source>
          <target state="translated">Параметр &lt;em&gt;командной строки&lt;/em&gt; - это аргумент командной строки, имеющий форму:</target>
        </trans-unit>
        <trans-unit id="4e8a05b6c91ae7521b9158c75abe8973ce6b52be" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;comment&lt;/em&gt; is text that is written in a program only for the sake of humans that read the program, and that has no effect on the meaning of the program. In Lisp, an unescaped semicolon (&amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Комментарий&lt;/em&gt; является текст , который написан в программе только ради людей , которые читают эту программу, и это не имеет никакого влияния на смысл программы. В Лиспе неэкранированная точка с запятой ('</target>
        </trans-unit>
        <trans-unit id="0701bec604d6ebb4ee489eb99b493dc2af69d7c2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;condition variable&lt;/em&gt; is a device for a more complex thread synchronization than the one supported by a mutex. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.</source>
          <target state="translated">&lt;em&gt;Переменная состояния&lt;/em&gt; представляет собой устройство для более сложной синхронизации потоков , чем та , поддерживаемой взаимной блокировки. Поток может ждать переменной условия, чтобы быть разбуженным, когда какой-либо другой поток уведомит об условии.</target>
        </trans-unit>
        <trans-unit id="d2b1e319d48c52f8b9b1dc9edeed91b28bd7bcde" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;condition variable&lt;/em&gt; is a way for a thread to block until some event occurs. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.</source>
          <target state="translated">&lt;em&gt;Переменная состояния&lt;/em&gt; является способом для нити , чтобы блокировать , пока не произойдет какое - то событие. Поток может ждать переменной условия, чтобы быть разбуженным, когда какой-либо другой поток уведомит об условии.</target>
        </trans-unit>
        <trans-unit id="2e8c4291506499a1c34b2f7a3b465bd996ccfdf5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;conditional breakpoint&lt;/em&gt; tests a condition each time the program gets there. Any errors that occur as a result of evaluating the condition are ignored, as if the result were &lt;code&gt;nil&lt;/code&gt;. To set a conditional breakpoint, use</source>
          <target state="translated">&lt;em&gt;Условная точка останов&lt;/em&gt; проверяет условие каждый раз , когда программа получает там. Любые ошибки, возникающие в результате оценки условия, игнорируются, как если бы результат был &lt;code&gt;nil&lt;/code&gt; . Чтобы установить условную точку останова, используйте</target>
        </trans-unit>
        <trans-unit id="0f175283d77a4fd94b6fc26212092340b20a89a3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons cell&lt;/em&gt; is an object that consists of two slots, called the &lt;small&gt;CAR&lt;/small&gt; slot and the &lt;small&gt;CDR&lt;/small&gt; slot. Each slot can &lt;em&gt;hold&lt;/em&gt; any Lisp object. We also say that the &lt;small&gt;CAR&lt;/small&gt; of this cons cell is whatever object its &lt;small&gt;CAR&lt;/small&gt; slot currently holds, and likewise for the &lt;small&gt;CDR&lt;/small&gt;.</source>
          <target state="translated">&lt;em&gt;Против клеток&lt;/em&gt; является объектом , который состоит из двух пазов, называется &lt;small&gt;АВТОМОБИЛЬ&lt;/small&gt; слот и &lt;small&gt;CDR&lt;/small&gt; - слот. Каждый слот может &lt;em&gt;содержать&lt;/em&gt; любой объект Lisp. Мы также говорим, что &lt;small&gt;CAR&lt;/small&gt; этой cons-ячейки - это любой объект, который в настоящее время содержит ее слот &lt;small&gt;CAR&lt;/small&gt; , а также для &lt;small&gt;CDR&lt;/small&gt; .</target>
        </trans-unit>
        <trans-unit id="b422ee9e4026fd4e0cd35274610df0b46359f25a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;data element&lt;/em&gt;, a single Lisp object.</source>
          <target state="translated">&lt;em&gt;Элемент данных&lt;/em&gt; , один объект Лиспа.</target>
        </trans-unit>
        <trans-unit id="2fd5ff9853d86e2b5387329321415f00ec01c50e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;datagram&lt;/em&gt; connection communicates with individual packets rather than streams of data. Each call to &lt;code&gt;process-send&lt;/code&gt; sends one datagram packet (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;), and each datagram received results in one call to the filter function.</source>
          <target state="translated">Соединение &lt;em&gt;дейтаграммы&lt;/em&gt; взаимодействует с отдельными пакетами, а не с потоками данных. Каждый вызов &lt;code&gt;process-send&lt;/code&gt; отправляет один пакет дейтаграммы (см. &amp;laquo; &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Ввод в процессы&amp;raquo;&lt;/a&gt; ), и каждая полученная дейтаграмма приводит к одному вызову функции фильтрации.</target>
        </trans-unit>
        <trans-unit id="f72e9e8f55ba9b0d557af040b71fe45f88267513" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;definition&lt;/em&gt; is a special kind of Lisp expression that announces your intention to use a symbol in a particular way. It typically specifies a value or meaning for the symbol for one kind of use, plus documentation for its meaning when used in this way. Thus, when you define a symbol as a variable, you can supply an initial value for the variable, plus documentation for the variable.</source>
          <target state="translated">&lt;em&gt;Определение&lt;/em&gt; представляет собой особый вид выражения Lisp , который объявляет о своем намерении использовать символ определенным образом. Обычно он определяет значение или значение символа для одного вида использования, а также документацию о его значении при использовании таким образом. Таким образом, когда вы определяете символ как переменную, вы можете указать начальное значение для переменной, а также документацию по переменной.</target>
        </trans-unit>
        <trans-unit id="3be196257fddf44d2005a0a44f83cb229fa5908d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;directory name&lt;/em&gt; is a string that must name a directory if it names any file at all. A directory is actually a kind of file, and it has a file name (called the &lt;em&gt;directory file name&lt;/em&gt;, which is related to the directory name but is typically not identical. (This is not quite the same as the usual POSIX terminology.) These two names for the same entity are related by a syntactic transformation. On GNU and other POSIX-like systems, this is simple: to obtain a directory name, append a &amp;lsquo;</source>
          <target state="translated">Имя &lt;em&gt;каталога&lt;/em&gt; - это строка, которая должна называть каталог, если он вообще называет какой-либо файл. Каталог на самом деле является своего рода файлом, и у него есть имя файла (называемое &lt;em&gt;именем файла каталога&lt;/em&gt; , которое связано с именем каталога, но обычно не идентично (это не совсем то же самое, что и обычная терминология POSIX). два имени для одного и того же объекта связаны синтаксическим преобразованием. В GNU и других системах, подобных POSIX, это просто: чтобы получить имя каталога, добавьте '</target>
        </trans-unit>
        <trans-unit id="df1dde6d3983db88f8cc142a935e30fd2f3bd233" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dynamic Emacs module&lt;/em&gt; is a shared library that provides additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would.</source>
          <target state="translated">&lt;em&gt;Динамический Emacs модуль&lt;/em&gt; является разделяемая библиотека , которая предоставляет дополнительные функциональные возможности для использования в программах на Emacs Lisp, так же , как пакет написан в Emacs Lisp бы.</target>
        </trans-unit>
        <trans-unit id="5de98caf4399a9e93ce65d6deeb5b1cb3b08a098" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dynamically loaded library&lt;/em&gt; is a library that is loaded on demand, when its facilities are first needed. Emacs supports such on-demand loading of support libraries for some of its features.</source>
          <target state="translated">&lt;em&gt;Динамически загружаемая библиотека&lt;/em&gt; представляет собой библиотеку, которая загружается по требованию, когда его объекты первой необходимости. Emacs поддерживает такую ​​загрузку библиотек поддержки по запросу для некоторых своих функций.</target>
        </trans-unit>
        <trans-unit id="05b5a3be7d8b03b9d46f3e151dea5e13577ea7a8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;face alias&lt;/em&gt; provides an equivalent name for a face. You can define a face alias by giving the alias symbol the &lt;code&gt;face-alias&lt;/code&gt; property, with a value of the target face name. The following example makes &lt;code&gt;modeline&lt;/code&gt; an alias for the &lt;code&gt;mode-line&lt;/code&gt; face.</source>
          <target state="translated">&lt;em&gt;Лицо псевдоним&lt;/em&gt; обеспечивает эквивалентное имя для лица. Вы можете определить псевдоним лица, присвоив символу &lt;code&gt;face-alias&lt;/code&gt; свойство face-alias со значением имени целевого лица. В следующем примере &lt;code&gt;modeline&lt;/code&gt; &lt;code&gt;mode-line&lt;/code&gt; становится псевдонимом для грани строки режима .</target>
        </trans-unit>
        <trans-unit id="302cf515b4948fb8d82a2188371caddf7704019d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;face&lt;/em&gt; is a collection of graphical attributes for displaying text: font, foreground color, background color, optional underlining, etc. Faces control how Emacs displays text in buffers, as well as other parts of the frame such as the mode line.</source>
          <target state="translated">&lt;em&gt;Лицо&lt;/em&gt; представляет собой набор графических атрибутов для отображения текста: шрифта, цвета переднего плана, цвета фона, дополнительного подчеркивания и т.д. Лиц управления , как Emacs отображает текст в буферах, а также другие части кадра , такие как режим линия.</target>
        </trans-unit>
        <trans-unit id="231e0a86e11ce9343b5d5ac44eab6dbd7b32d896" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;finalizer object&lt;/em&gt; helps Lisp code clean up after objects that are no longer needed. A finalizer holds a Lisp function object. When a finalizer object becomes unreachable after a garbage collection pass, Emacs calls the finalizer&amp;rsquo;s associated function object. When deciding whether a finalizer is reachable, Emacs does not count references from finalizer objects themselves, allowing you to use finalizers without having to worry about accidentally capturing references to finalized objects themselves.</source>
          <target state="translated">Объект &lt;em&gt;финализатора&lt;/em&gt; помогает коду Lisp убирать объекты, которые больше не нужны. Финализатор содержит объект функции Lisp. Когда объект финализатора становится недоступным после этапа сборки мусора, Emacs вызывает связанный объект функции финализатора. Решая, доступен ли финализатор, Emacs не считает ссылки от самих финализаторов, что позволяет вам использовать финализаторы, не беспокоясь о случайном захвате ссылок на сами финализаторы.</target>
        </trans-unit>
        <trans-unit id="99b352b3839ee48b6a471f7ec46b92984bf71f47" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;font&lt;/em&gt; specifies how to display text on a graphical terminal. There are actually three separate font types&amp;mdash;&lt;em&gt;font objects&lt;/em&gt;, &lt;em&gt;font specs&lt;/em&gt;, and &lt;em&gt;font entities&lt;/em&gt;&amp;mdash;each of which has slightly different properties. None of them have a read syntax; their print syntax looks like &amp;lsquo;</source>
          <target state="translated">А &lt;em&gt;шрифт&lt;/em&gt; определяет , как отображать текст на графическом терминале. Есть на самом деле три отдельных шрифта types- &lt;em&gt;шрифта объектов&lt;/em&gt; , &lt;em&gt;шрифтов данные&lt;/em&gt; и &lt;em&gt;шрифтов лица&lt;/em&gt; -Каждый из которых имеет несколько различных свойств. Ни у одного из них нет синтаксиса чтения; их синтаксис печати выглядит как '</target>
        </trans-unit>
        <trans-unit id="cf495fc305171d785ac263bbb756e22d29649431" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;fontset&lt;/em&gt; is a list of fonts, each assigned to a range of character codes. An individual font cannot display the whole range of characters that Emacs supports, but a fontset can. Fontsets have names, just as fonts do, and you can use a fontset name in place of a font name when you specify the font for a frame or a face. Here is information about defining a fontset under Lisp program control.</source>
          <target state="translated">Набор &lt;em&gt;шрифтов&lt;/em&gt; - это список шрифтов, каждому из которых назначен диапазон кодов символов. Отдельный шрифт не может отображать весь диапазон символов, поддерживаемых Emacs, но набор шрифтов может. Наборы шрифтов имеют имена, как и шрифты, и вы можете использовать имя набора шрифтов вместо имени шрифта, когда вы указываете шрифт для рамки или лица. Вот информация об определении набора шрифтов под управлением программы Lisp.</target>
        </trans-unit>
        <trans-unit id="6e7ec63ccc23013db0bcf9c823a2170ba27b77ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame configuration&lt;/em&gt; records the current arrangement of frames, all their properties, and the window configuration of each one. (See &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;.)</source>
          <target state="translated">&lt;em&gt;Конфигурации кадра&lt;/em&gt; записывает текущее расположение кадров, все их свойства, а также конфигурацию окна каждого из них. (См. &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Конфигурации окон&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="bdb34f67e1e9ada804a26661b470461156464a32" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame configuration&lt;/em&gt; stores information about the positions, sizes, and contents of the windows in all frames. It is not a primitive type&amp;mdash;it is actually a list whose &lt;small&gt;CAR&lt;/small&gt; is &lt;code&gt;frame-configuration&lt;/code&gt; and whose &lt;small&gt;CDR&lt;/small&gt; is an alist. Each alist element describes one frame, which appears as the &lt;small&gt;CAR&lt;/small&gt; of that element.</source>
          <target state="translated">&lt;em&gt;Кадр конфигурации&lt;/em&gt; хранит информацию о позиции, размеров и содержимого окон во всех кадрах. Это не примитивный тип - это фактически список, &lt;small&gt;CAR&lt;/small&gt; которого является &lt;code&gt;frame-configuration&lt;/code&gt; а &lt;small&gt;CDR&lt;/small&gt; - списком. Каждый элемент alist описывает один фрейм, который появляется как &lt;small&gt;CAR&lt;/small&gt; этого элемента.</target>
        </trans-unit>
        <trans-unit id="5332e8873c75bb7ff6085b71dc2c97ddd4c56866" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame&lt;/em&gt; is a screen area that contains one or more Emacs windows; we also use the term &amp;ldquo;frame&amp;rdquo; to refer to the Lisp object that Emacs uses to refer to the screen area.</source>
          <target state="translated">&lt;em&gt;Кадр&lt;/em&gt; является область экрана , которая содержит один или несколько окон Emacs; мы также используем термин &amp;laquo;кадр&amp;raquo; для обозначения объекта Lisp, который Emacs использует для ссылки на область экрана.</target>
        </trans-unit>
        <trans-unit id="7005fbe65ff98f53ff5b531201eb323a6292f93a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame&lt;/em&gt; is a screen object that contains one or more Emacs windows (see &lt;a href=&quot;windows#Windows&quot;&gt;Windows&lt;/a&gt;). It is the kind of object called a &amp;ldquo;window&amp;rdquo; in the terminology of graphical environments; but we can&amp;rsquo;t call it a &amp;ldquo;window&amp;rdquo; here, because Emacs uses that word in a different way. In Emacs Lisp, a &lt;em&gt;frame object&lt;/em&gt; is a Lisp object that represents a frame on the screen. See &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;Frame Type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Кадр&lt;/em&gt; представляет собой экранный объект , который содержит один или несколько окон Emacs (см &lt;a href=&quot;windows#Windows&quot;&gt;Окна&lt;/a&gt; ). Это вид объекта, который в терминологии графической среды называется &amp;laquo;окном&amp;raquo;; но здесь мы не можем назвать это &amp;laquo;окном&amp;raquo;, потому что Emacs использует это слово по-другому. В Emacs Lisp &lt;em&gt;объект фрейма&lt;/em&gt; - это объект Lisp, представляющий фрейм на экране. См. &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;Тип кадра&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f88eec5b56af18f140f7d22807ca47874dd75224" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generalized variable&lt;/em&gt; or &lt;em&gt;place form&lt;/em&gt; is one of the many places in Lisp memory where values can be stored using the &lt;code&gt;setf&lt;/code&gt; macro (see &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;Setting Generalized Variables&lt;/a&gt;). The simplest place form is a regular Lisp variable. But the &lt;small&gt;CAR&lt;/small&gt;s and &lt;small&gt;CDR&lt;/small&gt;s of lists, elements of arrays, properties of symbols, and many other locations are also places where Lisp values get stored.</source>
          <target state="translated">&lt;em&gt;Обобщенная переменная&lt;/em&gt; или &lt;em&gt;место , форма&lt;/em&gt; является одним из многих мест в памяти лисповской , где значения может быть сохранены с помощью &lt;code&gt;setf&lt;/code&gt; макрокоманды (см &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;Установки обобщенных переменных&lt;/a&gt; ). Самая простая форма размещения - это обычная переменная Лиспа. Но &lt;small&gt;CAR&lt;/small&gt; и &lt;small&gt;CDR&lt;/small&gt; списков, элементов массивов, свойств символов и многих других мест также являются местами, где хранятся значения Lisp.</target>
        </trans-unit>
        <trans-unit id="2e00b950f26582a69a82bcfeb353306eb48c749f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generator&lt;/em&gt; is a function that produces a potentially-infinite stream of values. Each time the function produces a value, it suspends itself and waits for a caller to request the next value.</source>
          <target state="translated">&lt;em&gt;Генератор&lt;/em&gt; является функцией , которая создает потенциально бесконечный поток ценностей. Каждый раз, когда функция создает значение, она приостанавливает свою работу и ждет, пока вызывающий объект запросит следующее значение.</target>
        </trans-unit>
        <trans-unit id="9b2b0dd0e5a45f9158401409dcf1687cdf829136" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global break condition&lt;/em&gt; stops execution when a specified condition is satisfied, no matter where that may occur. Edebug evaluates the global break condition at every stop point; if it evaluates to a non-&lt;code&gt;nil&lt;/code&gt; value, then execution stops or pauses depending on the execution mode, as if a breakpoint had been hit. If evaluating the condition gets an error, execution does not stop.</source>
          <target state="translated">&lt;em&gt;Глобальное условие прерывания&lt;/em&gt; прекращает выполнение , если указанное условие выполнено, независимо от того , где это может произойти. Edebug оценивает глобальное условие прерывания в каждой точке остановки; если его результат не &lt;code&gt;nil&lt;/code&gt; , то выполнение останавливается или приостанавливается в зависимости от режима выполнения, как если бы была достигнута точка останова. Если при оценке условия возникает ошибка, выполнение не останавливается.</target>
        </trans-unit>
        <trans-unit id="8f1a3403d60a9a41e86b1033af245da071e2841d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;glyph&lt;/em&gt; is a graphical symbol which occupies a single character position on the screen. Each glyph is represented in Lisp as a &lt;em&gt;glyph code&lt;/em&gt;, which specifies a character and optionally a face to display it in (see &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;). The main use of glyph codes is as the entries of display tables (see &lt;a href=&quot;display-tables#Display-Tables&quot;&gt;Display Tables&lt;/a&gt;). The following functions are used to manipulate glyph codes:</source>
          <target state="translated">&lt;em&gt;Глиф&lt;/em&gt; представляет собой графический символ , который занимает единую позицию символа на экране. Каждый глиф представлен в Лиспе как &lt;em&gt;код глифа&lt;/em&gt; , который определяет символ и, возможно, лицо, на котором он отображается (см. &amp;laquo; &lt;a href=&quot;faces#Faces&quot;&gt;Грани&amp;raquo;&lt;/a&gt; ). В основном коды глифов используются в качестве записей в таблицах отображения (см. &lt;a href=&quot;display-tables#Display-Tables&quot;&gt;Таблицы отображения&lt;/a&gt; ). Следующие функции используются для управления кодами глифов:</target>
        </trans-unit>
        <trans-unit id="fc890b7a72b483efddff830ca6044d4db575c15e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hook&lt;/em&gt; is a variable where you can store a function or functions to be called on a particular occasion by an existing program. Emacs provides hooks for the sake of customization. Most often, hooks are set up in the init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;), but Lisp programs can set them also. See &lt;a href=&quot;standard-hooks#Standard-Hooks&quot;&gt;Standard Hooks&lt;/a&gt;, for a list of some standard hook variables.</source>
          <target state="translated">&lt;em&gt;Крючок&lt;/em&gt; является переменным , где вы можете хранить функции или функции должны быть вызваны в конкретном случае с помощью существующей программы. Emacs предоставляет перехватчики для настройки. Чаще всего ловушки устанавливаются в файле инициализации (см. &lt;a href=&quot;init-file#Init-File&quot;&gt;Файл&lt;/a&gt; инициализации ), но программы на Лиспе также могут их устанавливать. См. &lt;a href=&quot;standard-hooks#Standard-Hooks&quot;&gt;Стандартные&lt;/a&gt; ловушки для списка некоторых стандартных переменных ловушки.</target>
        </trans-unit>
        <trans-unit id="bffdbb4588347fb567343611aa24c24d8bc17385" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;key sequence&lt;/em&gt;, or &lt;em&gt;key&lt;/em&gt; for short, is a sequence of one or more input events that form a unit. Input events include characters, function keys, mouse actions, or system events external to Emacs, such as &lt;code&gt;iconify-frame&lt;/code&gt; (see &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;). The Emacs Lisp representation for a key sequence is a string or vector. Unless otherwise stated, any Emacs Lisp function that accepts a key sequence as an argument can handle both representations.</source>
          <target state="translated">Последовательность &lt;em&gt;клавиш&lt;/em&gt; или для краткости &lt;em&gt;клавиша&lt;/em&gt; - это последовательность одного или нескольких входных событий, которые образуют единое целое. События ввода включают символы, функциональные клавиши, действия мыши или системные события, внешние по отношению к Emacs, такие как &lt;code&gt;iconify-frame&lt;/code&gt; (см. &lt;a href=&quot;input-events#Input-Events&quot;&gt;События ввода&lt;/a&gt; ). Emacs Lisp представляет последовательность ключей в виде строки или вектора. Если не указано иное, любая функция Emacs Lisp, которая принимает последовательность ключей в качестве аргумента, может обрабатывать оба представления.</target>
        </trans-unit>
        <trans-unit id="b85988e0bf41dad4173ddd11ccf598cee7e5972e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;keyboard macro&lt;/em&gt; is a canned sequence of input events that can be considered a command and made the definition of a key. The Lisp representation of a keyboard macro is a string or vector containing the events. Don&amp;rsquo;t confuse keyboard macros with Lisp macros (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Макрос клавиатуры&lt;/em&gt; представляет собой консервированный последовательность входных событий , которые можно считать команду и из определения ключа. Лисп-представление макроса клавиатуры - это строка или вектор, содержащий события. Не путайте макросы клавиатуры с макросами Lisp (см. &lt;a href=&quot;macros#Macros&quot;&gt;Макросы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="26289a3b7ffc5e23d66eaad1d2458be5aefdcf24" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;keymap&lt;/em&gt; maps keys typed by the user to commands. This mapping controls how the user&amp;rsquo;s command input is executed. A keymap is actually a list whose &lt;small&gt;CAR&lt;/small&gt; is the symbol &lt;code&gt;keymap&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Раскладка&lt;/em&gt; карты ключи , вводимые пользователем команды. Это сопоставление управляет тем, как выполняется ввод команды пользователя. Раскладка клавиатуры - это фактически список, &lt;small&gt;CAR&lt;/small&gt; которого является &lt;code&gt;keymap&lt;/code&gt; символов .</target>
        </trans-unit>
        <trans-unit id="84844081aae365d9d0de9b26a33a808ddac23b71" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;list&lt;/em&gt; is a series of cons cells, linked together so that the &lt;small&gt;CDR&lt;/small&gt; slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;lists#Lists&quot;&gt;Lists&lt;/a&gt;, for details. Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Список&lt;/em&gt; представляет собой ряд минусов клеток, связан друг с другом , так что &lt;small&gt;CDR&lt;/small&gt; слот каждой ячейки конса имеет либо следующие минусы ячейки или пустой список. Пустой список - это фактически символ &lt;code&gt;nil&lt;/code&gt; . См. Подробности в &lt;a href=&quot;lists#Lists&quot;&gt;Списках&lt;/a&gt; . Поскольку большинство cons-ячеек используются как часть списков, мы называем любую структуру, состоящую из cons-ячеек, &lt;em&gt;структурой списка&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="af9d5be7310bdf986a613a593c3dd63f8b5a68a2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;list&lt;/em&gt; represents a sequence of zero or more elements (which may be any Lisp objects). The important difference between lists and vectors is that two or more lists can share part of their structure; in addition, you can insert or delete elements in a list without copying the whole list.</source>
          <target state="translated">&lt;em&gt;Список&lt;/em&gt; представляет собой последовательность из нуля или более элементов (которые могут быть любыми объектами лисповских). Важное различие между списками и векторами состоит в том, что два или более списка могут совместно использовать часть своей структуры; кроме того, вы можете вставлять или удалять элементы в списке, не копируя весь список.</target>
        </trans-unit>
        <trans-unit id="caf235f1847f4378a02cdfbd452659a1c4694aa0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;live frame&lt;/em&gt; is one that has not been deleted. When a frame is deleted, it is removed from its terminal display, although it may continue to exist as a Lisp object until there are no more references to it.</source>
          <target state="translated">&lt;em&gt;Живой кадр&lt;/em&gt; является тот , который не был удален. Когда фрейм удаляется, он удаляется со своего терминального дисплея, хотя он может продолжать существовать как объект Lisp до тех пор, пока на него не исчезнут ссылки.</target>
        </trans-unit>
        <trans-unit id="8066ef771ec62ca85e2f184cfbffda7ebe217837" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;live window&lt;/em&gt; is one that is actually displaying a buffer in a frame.</source>
          <target state="translated">&lt;em&gt;Живое окно&lt;/em&gt; одно , что на самом деле отображения буфера в кадре.</target>
        </trans-unit>
        <trans-unit id="27e69c5bbb12137e4e756c6d8a53777154a45869" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mapping function&lt;/em&gt; applies a given function (&lt;em&gt;not&lt;/em&gt; a special form or macro) to each element of a list or other collection. Emacs Lisp has several such functions; this section describes &lt;code&gt;mapcar&lt;/code&gt;, &lt;code&gt;mapc&lt;/code&gt;, &lt;code&gt;mapconcat&lt;/code&gt;, and &lt;code&gt;mapcan&lt;/code&gt;, which map over a list. See &lt;a href=&quot;creating-symbols#Definition-of-mapatoms&quot;&gt;Definition of mapatoms&lt;/a&gt;, for the function &lt;code&gt;mapatoms&lt;/code&gt; which maps over the symbols in an obarray. See &lt;a href=&quot;hash-access#Definition-of-maphash&quot;&gt;Definition of maphash&lt;/a&gt;, for the function &lt;code&gt;maphash&lt;/code&gt; which maps over key/value associations in a hash table.</source>
          <target state="translated">Функция &lt;em&gt;сопоставления&lt;/em&gt; применяет данную функцию ( &lt;em&gt;не&lt;/em&gt; специальную форму или макрос) к каждому элементу списка или другой коллекции. Emacs Lisp имеет несколько таких функций; в этом разделе описываются &lt;code&gt;mapcar&lt;/code&gt; , &lt;code&gt;mapc&lt;/code&gt; , &lt;code&gt;mapconcat&lt;/code&gt; и &lt;code&gt;mapcan&lt;/code&gt; , которые отображают список. См. &lt;a href=&quot;creating-symbols#Definition-of-mapatoms&quot;&gt;Определение мапатомов&lt;/a&gt; , где &lt;code&gt;mapatoms&lt;/code&gt; функций, которые сопоставляются с символами в массиве. См. &lt;a href=&quot;hash-access#Definition-of-maphash&quot;&gt;Определение maphash&lt;/a&gt; , чтобы узнать о функции &lt;code&gt;maphash&lt;/code&gt; , которая сопоставляет ассоциации ключ / значение в хэш-таблице.</target>
        </trans-unit>
        <trans-unit id="a9ae386e3e011cfcbc753bf66f2b7dc0fabd4c7d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;marker&lt;/em&gt; denotes a position in a specific buffer. Markers therefore have two components: one for the buffer, and one for the position. Changes in the buffer&amp;rsquo;s text automatically relocate the position value as necessary to ensure that the marker always points between the same two characters in the buffer.</source>
          <target state="translated">&lt;em&gt;Маркер&lt;/em&gt; обозначает положение в конкретном буфере. Таким образом, у маркеров есть два компонента: один для буфера и один для позиции. Изменения в тексте буфера автоматически перемещают значение позиции по мере необходимости, чтобы маркер всегда указывал между одними и теми же двумя символами в буфере.</target>
        </trans-unit>
        <trans-unit id="10866be02ee509421064f62cfd0967bae1b9827e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;marker&lt;/em&gt; is a Lisp object used to specify a position in a buffer relative to the surrounding text. A marker changes its offset from the beginning of the buffer automatically whenever text is inserted or deleted, so that it stays with the two characters on either side of it.</source>
          <target state="translated">&lt;em&gt;Маркер&lt;/em&gt; представляет собой объект Lisp используется для указания позиции в буфере относительно окружающего текста. Маркер автоматически изменяет свое смещение от начала буфера всякий раз, когда текст вставляется или удаляется, так что он остается с двумя символами по обе стороны от него.</target>
        </trans-unit>
        <trans-unit id="c40b04bfc88c42dd334dd169fa41966183de182f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;meta character&lt;/em&gt; is a character typed with the</source>
          <target state="translated">&lt;em&gt;Мета символ&lt;/em&gt; является введенный символ с</target>
        </trans-unit>
        <trans-unit id="23a7fef4af90e3b0c9cafbdf008ce03197ab4053" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;minibuffer history list&lt;/em&gt; records previous minibuffer inputs so the user can reuse them conveniently. It is a variable whose value is a list of strings (previous inputs), most recent first.</source>
          <target state="translated">Список &lt;em&gt;истории минибуфера&lt;/em&gt; записывает предыдущие входы минибуфера, чтобы пользователь мог повторно использовать их для удобства. Это переменная, значение которой представляет собой список строк (предыдущие входные данные), начиная с самых последних.</target>
        </trans-unit>
        <trans-unit id="a3c74914ae7bc9ba19ba505460ec3639d41b6d29" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;minibuffer&lt;/em&gt; is a special buffer that Emacs commands use to read arguments more complicated than the single numeric prefix argument. These arguments include file names, buffer names, and command names (as in</source>
          <target state="translated">&lt;em&gt;Минибуфер&lt;/em&gt; это специальный буфер, команды Emacs использовать для чтения аргументов более сложных , чем один числового префикса аргумента. Эти аргументы включают имена файлов, имена буферов и имена команд (как в</target>
        </trans-unit>
        <trans-unit id="095e352a513e7437f83cc3f2d00b1c1af9e83004" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;minor mode&lt;/em&gt; provides optional features that users may enable or disable independently of the choice of major mode. Minor modes can be enabled individually or in combination.</source>
          <target state="translated">Дополнительный &lt;em&gt;режим&lt;/em&gt; предоставляет дополнительные функции, которые пользователи могут включать или отключать независимо от выбора основного режима. Второстепенные режимы можно включать по отдельности или в комбинации.</target>
        </trans-unit>
        <trans-unit id="35acaca11349cdd41823945ec417fac0c53cf91f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mode&lt;/em&gt; is a set of definitions that customize Emacs behavior in useful ways. There are two varieties of modes: &lt;em&gt;minor modes&lt;/em&gt;, which provide features that users can turn on and off while editing; and &lt;em&gt;major modes&lt;/em&gt;, which are used for editing or interacting with a particular kind of text. Each buffer has exactly one &lt;em&gt;major mode&lt;/em&gt; at a time.</source>
          <target state="translated">&lt;em&gt;Режим&lt;/em&gt; представляет собой набор определений , которые настраивают поведение Emacs в удобном виде. Есть две разновидности режимов: &lt;em&gt;второстепенные режимы&lt;/em&gt; , которые предоставляют функции, которые пользователи могут включать и выключать во время редактирования; и &lt;em&gt;основные режимы&lt;/em&gt; , которые используются для редактирования или взаимодействия с определенным типом текста. Каждый буфер имеет ровно один &lt;em&gt;основной режим&lt;/em&gt; одновременно.</target>
        </trans-unit>
        <trans-unit id="37b921e8300edb8a842bf43a173edf00518feefd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutex&lt;/em&gt; is an exclusive lock that threads can own and disown, in order to synchronize between them. See &lt;a href=&quot;mutexes#Mutexes&quot;&gt;Mutexes&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Мьютекс&lt;/em&gt; является эксклюзивным замком , что потоки могут иметь и отречься, чтобы синхронизировать между ними. См. &lt;a href=&quot;mutexes#Mutexes&quot;&gt;Мьютексы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4830aeeb1a3770ba82e4cfc3244dd0ec52cad099" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutex&lt;/em&gt; is an exclusive lock. At any moment, zero or one threads may own a mutex. If a thread attempts to acquire a mutex, and the mutex is already owned by some other thread, then the acquiring thread will block until the mutex becomes available.</source>
          <target state="translated">&lt;em&gt;Мьютекс&lt;/em&gt; является эксклюзивным замок. В любой момент мьютекс может принадлежать нулю или одному потоку. Если поток пытается получить мьютекс, а мьютекс уже принадлежит некоторому другому потоку, то получающий поток блокируется, пока мьютекс не станет доступным.</target>
        </trans-unit>
        <trans-unit id="dc0c42a6c93823ee7b58dbe26d1a5b8cff167d34" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;nonlocal exit&lt;/em&gt; is a transfer of control from one point in a program to another remote point. Nonlocal exits can occur in Emacs Lisp as a result of errors; you can also use them under explicit control. Nonlocal exits unbind all variable bindings made by the constructs being exited.</source>
          <target state="translated">&lt;em&gt;Нелокальна выходом&lt;/em&gt; является передачей управления от одной точки в программе на другую удаленную точку. В Emacs Lisp нелокальные выходы могут возникать в результате ошибок; вы также можете использовать их под явным контролем. Нелокальные выходы отменяют все привязки переменных, сделанные выходящими конструкциями.</target>
        </trans-unit>
        <trans-unit id="5e377035dc909cd277170acf67398e48b68c8bcc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;parser state&lt;/em&gt; is a list of (currently) eleven elements describing the state of the syntactic parser, after it parses the text between a specified starting point and a specified end point in the buffer using &lt;code&gt;parse-partial-sexp&lt;/code&gt; (see &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;Low-Level Parsing&lt;/a&gt;). Parsing functions such as &lt;code&gt;syntax-ppss&lt;/code&gt; (see &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt;) also return a parser state as the value. &lt;code&gt;parse-partial-sexp&lt;/code&gt; can accept a parser state as an argument, for resuming parsing.</source>
          <target state="translated">&lt;em&gt;Состояние анализатора&lt;/em&gt; является списком ( в настоящее время) одиннадцать элементов , описывающих состояние синтаксического синтаксического анализатора, после того, как он анализирует текст между указанной начальной точкой и указанной конечной точкой в буфере с помощью &lt;code&gt;parse-partial-sexp&lt;/code&gt; (см &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;низкого уровня Синтаксического&lt;/a&gt; ). Функции &lt;code&gt;syntax-ppss&lt;/code&gt; анализа, такие как syntax-ppss (см. Анализ &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;положения&lt;/a&gt; ), также возвращают состояние синтаксического анализатора в качестве значения. &lt;code&gt;parse-partial-sexp&lt;/code&gt; может принимать состояние парсера в качестве аргумента для возобновления синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="99955a994ed6a1f18590cbdc73cecfc8216312e7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;position&lt;/em&gt; is the index of a character in the text of a buffer. More precisely, a position identifies the place between two characters (or before the first character, or after the last character), so we can speak of the character before or after a given position. However, we often speak of the character &amp;ldquo;at&amp;rdquo; a position, meaning the character after that position.</source>
          <target state="translated">&lt;em&gt;Позиция&lt;/em&gt; является индексом символа в тексте буфера. Точнее, позиция определяет место между двумя символами (или перед первым символом, или после последнего символа), поэтому мы можем говорить о символе до или после данной позиции. Однако мы часто говорим о персонаже &amp;laquo;на&amp;raquo; позиции, имея в виду символ после этой позиции.</target>
        </trans-unit>
        <trans-unit id="acbb40f52f0ff6871e2319c0abae324c32608028" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;prefix key&lt;/em&gt; is a key sequence whose binding is a keymap. The keymap defines what to do with key sequences that extend the prefix key. For example,</source>
          <target state="translated">&lt;em&gt;Ключ префикса&lt;/em&gt; является ключевой последовательностью связывание которого является раскладкой. Таблица клавиш определяет, что делать с последовательностями клавиш, расширяющими префиксный ключ. Например,</target>
        </trans-unit>
        <trans-unit id="a750851ed6b490138262266435560c5f1eb8ffec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pretty-printer&lt;/em&gt; function which is responsible for inserting the textual representation of a data element value into the current buffer.</source>
          <target state="translated">Функция &lt;em&gt;красивого принтера,&lt;/em&gt; которая отвечает за вставку текстового представления значения элемента данных в текущий буфер.</target>
        </trans-unit>
        <trans-unit id="ef7d6b5d68eeef2c9d56f4de3848bbbf8c671fb9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;primitive function&lt;/em&gt; is a function callable from Lisp but written in the C programming language. Primitive functions are also called &lt;em&gt;subrs&lt;/em&gt; or &lt;em&gt;built-in functions&lt;/em&gt;. (The word &amp;ldquo;subr&amp;rdquo; is derived from &amp;ldquo;subroutine&amp;rdquo;.) Most primitive functions evaluate all their arguments when they are called. A primitive function that does not evaluate all its arguments is called a &lt;em&gt;special form&lt;/em&gt; (see &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Special Forms&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Примитивная функция&lt;/em&gt; является функцией вызова из Lisp , но написано на языке программирования Си. Примитивные функции также называются &lt;em&gt;вспомогательными&lt;/em&gt; или &lt;em&gt;встроенными функциями&lt;/em&gt; . (Слово &amp;laquo;подпрограмма&amp;raquo; происходит от &amp;laquo;подпрограммы&amp;raquo;.) Большинство примитивных функций оценивают все свои аргументы при вызове. Примитивная функция, которая не оценивает все свои аргументы, называется &lt;em&gt;специальной формой&lt;/em&gt; (см. &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Специальные формы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="92dd79b41e8cbe4e517fdbda3429d77589653c7a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;process sentinel&lt;/em&gt; is a function that is called whenever the associated process changes status for any reason, including signals (whether sent by Emacs or caused by the process&amp;rsquo;s own actions) that terminate, stop, or continue the process. The process sentinel is also called if the process exits. The sentinel receives two arguments: the process for which the event occurred, and a string describing the type of event.</source>
          <target state="translated">Страж &lt;em&gt;процесса&lt;/em&gt; - это функция, которая вызывается всякий раз, когда связанный процесс меняет статус по любой причине, включая сигналы (отправленные Emacs или вызванные собственными действиями процесса), которые завершают, останавливают или продолжают процесс. Сторож процесса также вызывается, если процесс завершается. Дозор получает два аргумента: процесс, для которого произошло событие, и строку, описывающую тип события.</target>
        </trans-unit>
        <trans-unit id="12f51ef3151fa4e8e2f32edf93c5a003ab590ef1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;property list&lt;/em&gt; (&lt;em&gt;plist&lt;/em&gt; for short) is a list of paired elements. Each of the pairs associates a property name (usually a symbol) with a property or value. Here is an example of a property list:</source>
          <target state="translated">Список &lt;em&gt;свойств&lt;/em&gt; ( сокращенно &lt;em&gt;plist&lt;/em&gt; ) - это список парных элементов. Каждая из пар связывает имя свойства (обычно символ) со свойством или значением. Вот пример списка свойств:</target>
        </trans-unit>
        <trans-unit id="52b2b067c403f7f587744597ed1ab1d8466917e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;record&lt;/em&gt; is much like a &lt;code&gt;vector&lt;/code&gt;. However, the first element is used to hold its type as returned by &lt;code&gt;type-of&lt;/code&gt;. The purpose of records is to allow programmers to create objects with new types that are not built into Emacs.</source>
          <target state="translated">&lt;em&gt;Запись&lt;/em&gt; очень похожа на &lt;code&gt;vector&lt;/code&gt; . Однако первый элемент используется для хранения своего типа, возвращаемого функцией &lt;code&gt;type-of&lt;/code&gt; . Назначение записей - позволить программистам создавать объекты с новыми типами, которые не встроены в Emacs.</target>
        </trans-unit>
        <trans-unit id="ac904311c71c6650010f4b866dec5796be0375e1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;regular expression&lt;/em&gt;, or &lt;em&gt;regexp&lt;/em&gt; for short, is a pattern that denotes a (possibly infinite) set of strings. Searching for matches for a regexp is a very powerful operation. This section explains how to write regexps; the following section says how to search for them.</source>
          <target state="translated">&lt;em&gt;Регулярное выражение&lt;/em&gt; , или &lt;em&gt;регулярное выражение&lt;/em&gt; для краткости, это образец , который обозначает (возможно бесконечное) множество строк. Поиск совпадений для регулярного выражения - очень мощная операция. В этом разделе объясняется, как писать регулярные выражения; в следующем разделе рассказывается, как их искать.</target>
        </trans-unit>
        <trans-unit id="340faeff4ade281880a3cb6ca1e42a0487f388d4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;ring&lt;/em&gt; is a fixed-size data structure that supports insertion, deletion, rotation, and modulo-indexed reference and traversal. An efficient ring data structure is implemented by the &lt;code&gt;ring&lt;/code&gt; package. It provides the functions listed in this section.</source>
          <target state="translated">&lt;em&gt;Кольцо&lt;/em&gt; представляет собой структуру данных фиксированного размера , который поддерживает вставку, удаление, вращение, и по модулю проиндексирован справочный и обход. Эффективная кольцевая структура данных реализуется &lt;code&gt;ring&lt;/code&gt; пакетом. Он предоставляет функции, перечисленные в этом разделе.</target>
        </trans-unit>
        <trans-unit id="68107fbcb19dcf923ea627fb36416c892f961e00" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;self-evaluating form&lt;/em&gt; is any form that is not a list or symbol. Self-evaluating forms evaluate to themselves: the result of evaluation is the same object that was evaluated. Thus, the number 25 evaluates to 25, and the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; evaluates to the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;. Likewise, evaluating a vector does not cause evaluation of the elements of the vector&amp;mdash;it returns the same vector with its contents unchanged.</source>
          <target state="translated">&lt;em&gt;Самостоятельной оценки формы&lt;/em&gt; в любой форме , которая не является списком или символом. Формы самооценки оценивают сами себя: результатом оценки является тот же объект, который был оценен. Таким образом, число 25 оценивается как 25, а строка &lt;code&gt;&quot;foo&quot;&lt;/code&gt; оценивается как строка &lt;code&gt;&quot;foo&quot;&lt;/code&gt; . Точно так же оценка вектора не вызывает оценки элементов вектора - она ​​возвращает тот же вектор с неизменным содержимым.</target>
        </trans-unit>
        <trans-unit id="97affbde2ffa12c383f5a977599a31f30dc833c5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;sequence&lt;/em&gt; is a Lisp object that represents an ordered set of elements. There are two kinds of sequence in Emacs Lisp: &lt;em&gt;lists&lt;/em&gt; and &lt;em&gt;arrays&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Последовательность&lt;/em&gt; представляет собой объект Лиспа , который представляет собой упорядоченный набор элементов. В Emacs Lisp есть два вида последовательности: &lt;em&gt;списки&lt;/em&gt; и &lt;em&gt;массивы&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="568827dac526a47b39447d6b276556cfd23968d9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;sequencing pattern&lt;/em&gt; (also known as &lt;var&gt;seqpat&lt;/var&gt;) is a pattern that processes its sub-pattern arguments in sequence. There are two for &lt;code&gt;pcase&lt;/code&gt;: &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;. They behave in a similar manner to the special forms that share their name (see &lt;a href=&quot;combining-conditions#Combining-Conditions&quot;&gt;Combining Conditions&lt;/a&gt;), but instead of processing values, they process sub-patterns.</source>
          <target state="translated">&lt;em&gt;Шаблон последовательности&lt;/em&gt; (также известный как &lt;var&gt;seqpat&lt;/var&gt; ) представляет собой образец , который обрабатывает свои аргументы суб-шаблонов в последовательности. Для &lt;code&gt;pcase&lt;/code&gt; есть два : &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; . Они ведут себя аналогично специальным формам, которые имеют одно и то же имя (см. &lt;a href=&quot;combining-conditions#Combining-Conditions&quot;&gt;Условия объединения&lt;/a&gt; ), но вместо обработки значений они обрабатывают подшаблоны.</target>
        </trans-unit>
        <trans-unit id="44ce679751e6da1d1f8b12e72ba46761e9428d8c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;special form&lt;/em&gt; is a primitive function specially marked so that its arguments are not all evaluated. Most special forms define control structures or perform variable bindings&amp;mdash;things which functions cannot do.</source>
          <target state="translated">&lt;em&gt;Особая форма&lt;/em&gt; является примитивной функции помечены таким образом , что его аргументы не все оценили. Большинство специальных форм определяют управляющие структуры или выполняют привязку переменных - то, что функции не могут делать.</target>
        </trans-unit>
        <trans-unit id="b859c57965a012d5104743eca8f2d1fc761af942" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;specification list&lt;/em&gt; is required for an Edebug specification if some arguments of a macro call are evaluated while others are not. Some elements in a specification list match one or more arguments, but others modify the processing of all following elements. The latter, called &lt;em&gt;specification keywords&lt;/em&gt;, are symbols beginning with &amp;lsquo;</source>
          <target state="translated">Список &lt;em&gt;спецификаций&lt;/em&gt; необходим для спецификации Edebug, если одни аргументы вызова макроса оцениваются, а другие нет. Некоторые элементы в списке спецификации соответствуют одному или нескольким аргументам, но другие изменяют обработку всех следующих элементов. Последние, называемые &lt;em&gt;ключевыми словами спецификации&lt;/em&gt; , представляют собой символы, начинающиеся с '</target>
        </trans-unit>
        <trans-unit id="21fe5cc3e8db4633a353ec7b1907c0b1a22bd112" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;stream&lt;/em&gt; is an object that can be used as a source or sink for characters&amp;mdash;either to supply characters for input or to accept them as output. Many different types can be used this way: markers, buffers, strings, and functions. Most often, input streams (character sources) obtain characters from the keyboard, a buffer, or a file, and output streams (character sinks) send characters to a buffer, such as a</source>
          <target state="translated">&lt;em&gt;Поток&lt;/em&gt; является объектом , который может быть использован в качестве источника или раковины для символов символов-либо на поставку для ввода или принимать их в качестве выходного сигнала. Таким образом можно использовать множество различных типов: маркеры, буферы, строки и функции. Чаще всего потоки ввода (источники символов) получают символы с клавиатуры, буфера или файла, а потоки вывода (приемники символов) отправляют символы в буфер, такой как</target>
        </trans-unit>
        <trans-unit id="96f59884a848b92e2675f99c9b833d4b90e7cca7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is an array of characters. Strings are used for many purposes in Emacs, as can be expected in a text editor; for example, as the names of Lisp symbols, as messages for the user, and to represent text extracted from buffers. Strings in Lisp are constants: evaluation of a string returns the same string.</source>
          <target state="translated">&lt;em&gt;Строка&lt;/em&gt; представляет собой массив символов. Строки используются в Emacs для многих целей, как и следовало ожидать в текстовом редакторе; например, как имена символов Лиспа, как сообщения для пользователя и для представления текста, извлеченного из буферов. Строки в Лиспе - это константы: оценка строки возвращает ту же строку.</target>
        </trans-unit>
        <trans-unit id="0d072ef54b4cc522b35609148bc97bd4b7293a8a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;symbol&lt;/em&gt; in GNU Emacs Lisp is an object with a name. The symbol name serves as the printed representation of the symbol. In ordinary Lisp use, with one single obarray (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;), a symbol&amp;rsquo;s name is unique&amp;mdash;no two symbols have the same name.</source>
          <target state="translated">&lt;em&gt;Символ&lt;/em&gt; в GNU Emacs Lisp является объектом с именем. Имя символа служит его печатным изображением. При обычном использовании Лиспа с одним единственным массивом (см. &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Создание символов&lt;/a&gt; ) имя символа уникально - никакие два символа не имеют одинакового имени.</target>
        </trans-unit>
        <trans-unit id="5c76bc331660adccd694734fdd974e80b6b3ec0b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;symbol&lt;/em&gt; is an object with a unique name. This chapter describes symbols, their components, their property lists, and how they are created and interned. Separate chapters describe the use of symbols as variables and as function names; see &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;, and &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;. For the precise read syntax for symbols, see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Символ&lt;/em&gt; представляет собой объект с уникальным именем. В этой главе описаны символы, их компоненты, их списки свойств, а также способы их создания и интернирования. В отдельных главах описывается использование символов в качестве переменных и имен функций; см. &lt;a href=&quot;variables#Variables&quot;&gt;Переменные&lt;/a&gt; и &lt;a href=&quot;functions#Functions&quot;&gt;Функции&lt;/a&gt; . Точный синтаксис чтения символов см. В разделе &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Тип символа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b20ef7f5f1b7eef351ff780dde60d61921f5757e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;syntax descriptor&lt;/em&gt; is a Lisp string that describes the syntax class and other syntactic properties of a character. When you want to modify the syntax of a character, that is done by calling the function &lt;code&gt;modify-syntax-entry&lt;/code&gt; and passing a syntax descriptor as one of its arguments (see &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Дескриптор синтаксиса&lt;/em&gt; является строкой Lisp , которая описывает класс синтаксиса и другие синтаксические свойства характера. Если вы хотите изменить синтаксис символа, это делается путем вызова функции &lt;code&gt;modify-syntax-entry&lt;/code&gt; и передачи дескриптора синтаксиса в качестве одного из ее аргументов (см. &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Функции таблицы синтаксиса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3a870e4ec1d3cf44e7dab053db3f22b7cb521b55" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;syntax table&lt;/em&gt; specifies the syntactic role of each character in a buffer. It can be used to determine where words, symbols, and other syntactic constructs begin and end. This information is used by many Emacs facilities, including Font Lock mode (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;) and the various complex movement commands (see &lt;a href=&quot;motion#Motion&quot;&gt;Motion&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Таблица синтаксиса&lt;/em&gt; определяет синтаксическую роль каждого символа в буфере. Его можно использовать, чтобы определить, где начинаются и заканчиваются слова, символы и другие синтаксические конструкции. Эта информация используется многими средствами Emacs, включая режим Font Lock (см. &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Режим Font Lock&lt;/a&gt; ) и различные сложные команды перемещения (см. &lt;a href=&quot;motion#Motion&quot;&gt;Движение&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="99b87789bc8b75b81e830bdef55dad68ee43fcaa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;terminal&lt;/em&gt; is a device capable of displaying one or more Emacs frames (see &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;Frame Type&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Терминал&lt;/em&gt; представляет собой устройство , способное отображать один или несколько фреймов Emacs (см &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;типа кадра&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc674df13ab428b273ec26c0dd720fcddbf5cf41" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;terminal&lt;/em&gt; is a display device capable of displaying one or more Emacs frames. In Emacs Lisp, a &lt;em&gt;terminal object&lt;/em&gt; is a Lisp object that represents a terminal. See &lt;a href=&quot;terminal-type#Terminal-Type&quot;&gt;Terminal Type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Терминал&lt;/em&gt; представляет собой устройство дисплея , способный отображать один или несколько кадров Emacs. В Emacs Lisp &lt;em&gt;объект терминала&lt;/em&gt; - это объект Lisp, представляющий терминал. См. &lt;a href=&quot;terminal-type#Terminal-Type&quot;&gt;Тип терминала&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59e631708c8fbabe8339a1ca817ba7c237c89147" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread&lt;/em&gt; in Emacs represents a separate thread of Emacs Lisp execution. It runs its own Lisp program, has its own current buffer, and can have subprocesses locked to it, i.e. subprocesses whose output only this thread can accept. See &lt;a href=&quot;threads#Threads&quot;&gt;Threads&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Поток&lt;/em&gt; в Emacs представляет собой отдельный поток выполнения Emacs Lisp. Он запускает свою собственную программу на Лиспе, имеет свой собственный текущий буфер и может иметь заблокированные подпроцессы, то есть подпроцессы, вывод которых может принимать только этот поток. См. &lt;a href=&quot;threads#Threads&quot;&gt;Темы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c2cf5a995b49c827b5d22748c933ccd1cf7a468" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;toggle&lt;/em&gt; is a menu item which is labeled as either on or off according to the value of &lt;var&gt;selected&lt;/var&gt;. The command itself should toggle &lt;var&gt;selected&lt;/var&gt;, setting it to &lt;code&gt;t&lt;/code&gt; if it is &lt;code&gt;nil&lt;/code&gt;, and to &lt;code&gt;nil&lt;/code&gt; if it is &lt;code&gt;t&lt;/code&gt;. Here is how the menu item to toggle the &lt;code&gt;debug-on-error&lt;/code&gt; flag is defined:</source>
          <target state="translated">&lt;em&gt;Переключения&lt;/em&gt; является пункт меню , который помечен как включен или выключен в соответствии со значением &lt;var&gt;selected&lt;/var&gt; . Сама команда должна переключать &lt;var&gt;selected&lt;/var&gt; , установив его на &lt;code&gt;t&lt;/code&gt; , если это &lt;code&gt;nil&lt;/code&gt; , и &lt;code&gt;nil&lt;/code&gt; , если это &lt;code&gt;t&lt;/code&gt; . Вот как определяется пункт меню для переключения флага &lt;code&gt;debug-on-error&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fcd1859232eb3fd90a12024f85384e7d8dc9e40a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tool bar&lt;/em&gt; is a row of clickable icons at the top of a frame, just below the menu bar. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Tool Bars&lt;/a&gt; in</source>
          <target state="translated">&lt;em&gt;Панель инструментов&lt;/em&gt; находится ряд интерактивных иконок в верхней части кадра, просто под строкой меню. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Панели инструментов&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="74fd005234a644a2028fc9521ca2c883dad99109" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tool bar&lt;/em&gt; is a row of clickable icons at the top of a frame, just below the menu bar. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Tool Bars&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf23c2364e9a64ec7b2fbca8a8b877bcb33dd05" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;translation table&lt;/em&gt; is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;) that specifies a mapping of characters into characters. These tables are used in encoding and decoding, and for other purposes. Some coding systems specify their own particular translation tables; there are also default translation tables which apply to all other coding systems.</source>
          <target state="translated">&lt;em&gt;Таблица перевода&lt;/em&gt; является углеродно таблицей (см &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;углеродно таблицы&lt;/a&gt; ), задающее отображение символов в символы. Эти таблицы используются при кодировании и декодировании, а также для других целей. Некоторые системы кодирования определяют свои собственные таблицы перевода; существуют также таблицы перевода по умолчанию, которые применяются ко всем другим системам кодирования.</target>
        </trans-unit>
        <trans-unit id="4e4b7c57666cacb5044a47b639cb9e52a3cc5602" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type descriptor&lt;/em&gt; is a &lt;code&gt;record&lt;/code&gt; which holds information about a type. Slot 1 in the record must be a symbol naming the type, and &lt;code&gt;type-of&lt;/code&gt; relies on this to return the type of &lt;code&gt;record&lt;/code&gt; objects. No other type descriptor slot is used by Emacs; they are free for use by Lisp extensions.</source>
          <target state="translated">&lt;em&gt;Дескриптор типа&lt;/em&gt; представляет собой &lt;code&gt;record&lt;/code&gt; , которая содержит информацию о типе. Слот 1 в записи должен быть символом, обозначающим тип, и &lt;code&gt;type-of&lt;/code&gt; полагается на него для возврата типа объектов &lt;code&gt;record&lt;/code&gt; . Emacs не использует слот дескриптора другого типа; они бесплатны для использования расширениями Lisp.</target>
        </trans-unit>
        <trans-unit id="cf4c3266ea964fd1cade86b02fc7862eb97f6b90" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;valid window&lt;/em&gt; is one that is either live or internal. A valid window can be &lt;em&gt;deleted&lt;/em&gt;, i.e., removed from its frame (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;); then it is no longer valid, but the Lisp object representing it might be still referenced from other Lisp objects. A deleted window may be made valid again by restoring a saved window configuration (see &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Действует окно&lt;/em&gt; , что является одним либо живым или внутренним. Допустимое окно можно &lt;em&gt;удалить&lt;/em&gt; , т. Е. Удалить из его фрейма (см. &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Удаление окон&lt;/a&gt; ); тогда он больше не действителен, но на объект Lisp, представляющий его, все еще могут ссылаться другие объекты Lisp. Удаленное окно можно снова сделать действительным, восстановив сохраненную конфигурацию окна (см. &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Конфигурации окна&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ad4daa28cddc16fff21959bfa78979f977c6062" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable definition&lt;/em&gt; is a construct that announces your intention to use a symbol as a global variable. It uses the special forms &lt;code&gt;defvar&lt;/code&gt; or &lt;code&gt;defconst&lt;/code&gt;, which are documented below.</source>
          <target state="translated">Определение &lt;em&gt;переменной&lt;/em&gt; - это конструкция, которая объявляет о вашем намерении использовать символ в качестве глобальной переменной. Он использует специальные формы &lt;code&gt;defvar&lt;/code&gt; или &lt;code&gt;defconst&lt;/code&gt; , которые описаны ниже.</target>
        </trans-unit>
        <trans-unit id="a8c4d77d87118f0607591ffbfce0deb3dccc3cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a name that can be &lt;em&gt;bound&lt;/em&gt; (or &lt;em&gt;set&lt;/em&gt;) to an object. The object to which a variable is bound is called a &lt;em&gt;value&lt;/em&gt;; we say also that variable holds that value. Although nearly all variables can be set by the user, certain variables exist specifically so that users can change them; these are called &lt;em&gt;user options&lt;/em&gt;. Ordinary variables and user options are described using a format like that for functions, except that there are no arguments.</source>
          <target state="translated">&lt;em&gt;Переменная&lt;/em&gt; является имя , которое может быть &lt;em&gt;связан&lt;/em&gt; (или &lt;em&gt;установить&lt;/em&gt; ) к объекту. Объект, к которому привязана переменная, называется &lt;em&gt;значением&lt;/em&gt; ; мы также говорим, что переменная содержит это значение. Хотя почти все переменные могут быть установлены пользователем, некоторые переменные существуют специально, чтобы пользователи могли их изменять; они называются &lt;em&gt;пользовательскими опциями&lt;/em&gt; . Обычные переменные и параметры пользователя описываются в формате, аналогичном формату функций, за исключением того, что здесь нет аргументов.</target>
        </trans-unit>
        <trans-unit id="1156c4586d2d0883c8aca28ed3ce095b29909471" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a name used in a program to stand for a value. In Lisp, each variable is represented by a Lisp symbol (see &lt;a href=&quot;symbols#Symbols&quot;&gt;Symbols&lt;/a&gt;). The variable name is simply the symbol&amp;rsquo;s name, and the variable&amp;rsquo;s value is stored in the symbol&amp;rsquo;s value cell&lt;a href=&quot;#FOOT8&quot; name=&quot;DOCF8&quot;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;. In Emacs Lisp, the use of a symbol as a variable is independent of its use as a function name.</source>
          <target state="translated">&lt;em&gt;Переменный&lt;/em&gt; является именем , используемым в программе , чтобы стоять значение. В Лиспе каждая переменная представлена ​​символом Лиспа (см. &amp;laquo; &lt;a href=&quot;symbols#Symbols&quot;&gt;Символы&amp;raquo;&lt;/a&gt; ). Имя переменной - это просто имя символа, а значение переменной сохраняется в ячейке значения символа &lt;a href=&quot;#FOOT8&quot; name=&quot;DOCF8&quot;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt; . См. &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Компоненты символа&lt;/a&gt; . В Emacs Lisp использование символа в качестве переменной не зависит от его использования в качестве имени функции.</target>
        </trans-unit>
        <trans-unit id="cd6722509f8edba7d22e136508797e09752ed07c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; is a general-purpose array whose elements can be any Lisp objects. (By contrast, the elements of a string can only be characters. See &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Strings and Characters&lt;/a&gt;.) Vectors are used in Emacs for many purposes: as key sequences (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;), as symbol-lookup tables (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;), as part of the representation of a byte-compiled function (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;), and more.</source>
          <target state="translated">&lt;em&gt;Вектор&lt;/em&gt; представляет собой массив общего назначения , элементы которого могут быть любые объекты лисповские. (В отличие от этого, элементы строки могут быть только символами. См. &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Строки и символы&lt;/a&gt; .) Векторы используются в Emacs для многих целей: как последовательности ключей (см. &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Последовательности ключей&lt;/a&gt; ), как таблицы поиска &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;символов&lt;/a&gt; (см. Создание символов ), как часть представления скомпилированной байтом функции (см. &amp;laquo; &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Байтовая компиляция&amp;raquo;&lt;/a&gt; ) и многое другое.</target>
        </trans-unit>
        <trans-unit id="55c4773d043da91116a793da0f1846bba4760d2f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; is a one-dimensional array of elements of any type. It takes a constant amount of time to access any element of a vector. (In a list, the access time of an element is proportional to the distance of the element from the beginning of the list.)</source>
          <target state="translated">&lt;em&gt;Вектор&lt;/em&gt; представляет собой одномерный массив элементов любого типа. Для доступа к любому элементу вектора требуется постоянное количество времени. (В списке время доступа к элементу пропорционально расстоянию от элемента до начала списка.)</target>
        </trans-unit>
        <trans-unit id="ac5f70614b0372d4f8f82b846b8c000ce8f68ed3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window configuration&lt;/em&gt; records the entire layout of one frame&amp;mdash;all windows, their sizes, which buffers they contain, how those buffers are scrolled, and their value of point; also their fringes, margins, and scroll bar settings. It also includes the value of &lt;code&gt;minibuffer-scroll-window&lt;/code&gt;. As a special exception, the window configuration does not record the value of point in the selected window for the current buffer.</source>
          <target state="translated">&lt;em&gt;Конфигурации окна&lt;/em&gt; записывает всю компоновку один каркасных всех окон, их размеры, которые буферы , которые они содержат, как прокручиваются эти буферы, и их значения точки; также их бахрома, поля и настройки полосы прокрутки. Он также включает значение &lt;code&gt;minibuffer-scroll-window&lt;/code&gt; . В качестве особого исключения конфигурация окна не записывает значение точки в выбранном окне для текущего буфера.</target>
        </trans-unit>
        <trans-unit id="0d57455a82c850bc61f2d2aecdc1b09c8b42b9e8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window configuration&lt;/em&gt; stores information about the positions, sizes, and contents of the windows in a frame, so you can recreate the same arrangement of windows later.</source>
          <target state="translated">&lt;em&gt;Окно конфигурации&lt;/em&gt; хранит информацию о позиции, размеров и содержимого окна в кадре, так что вы можете воссоздать то же расположение окон позже.</target>
        </trans-unit>
        <trans-unit id="c00b85431c59b78e8f4e74a1925ee57f90bf7090" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window&lt;/em&gt; describes the portion of the terminal screen that Emacs uses to display a buffer. Every window has one associated buffer, whose contents appear in the window. By contrast, a given buffer may appear in one window, no window, or several windows.</source>
          <target state="translated">&lt;em&gt;Окно&lt;/em&gt; описывает часть экрана терминала , что Emacs использует для отображения буфера. С каждым окном связан один буфер, содержимое которого отображается в окне. Напротив, данный буфер может появляться в одном окне, без окна или в нескольких окнах.</target>
        </trans-unit>
        <trans-unit id="f5cca0cf4b997e339b41d33bd8f75be84d6ffeaa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window&lt;/em&gt; is an area of the screen that is used to display a buffer (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). In Emacs Lisp, windows are represented by a special Lisp object type.</source>
          <target state="translated">&lt;em&gt;Окно&lt;/em&gt; является областью экрана , который используется для отображения буфера (см &lt;a href=&quot;buffers#Buffers&quot;&gt;буферов&lt;/a&gt; ). В Emacs Lisp окна представлены особым типом объектов Lisp.</target>
        </trans-unit>
        <trans-unit id="3507a8b3b334275d08f16d7312604f9c5451dc34" translate="yes" xml:space="preserve">
          <source>A Custom theme file should be named</source>
          <target state="translated">Файл пользовательской темы должен быть назван</target>
        </trans-unit>
        <trans-unit id="97e76d477ef6ece585bf0e8e626dfbf9ff92f225" translate="yes" xml:space="preserve">
          <source>A GNU (glibc-based) system with a FreeBSD kernel.</source>
          <target state="translated">Система GNU (на основе glibc)с ядром FreeBSD.</target>
        </trans-unit>
        <trans-unit id="88a0c01d860cf991a4d23f7a207dd587f005e263" translate="yes" xml:space="preserve">
          <source>A GNU/Linux system&amp;mdash;that is, a variant GNU system, using the Linux kernel. (These systems are the ones people often call &amp;ldquo;Linux&amp;rdquo;, but actually Linux is just the kernel, not the whole system.)</source>
          <target state="translated">Система GNU / Linux, то есть вариант системы GNU, использующий ядро ​​Linux. (Эти системы люди часто называют &amp;laquo;Linux&amp;raquo;, но на самом деле Linux - это просто ядро, а не вся система.)</target>
        </trans-unit>
        <trans-unit id="739c3877cd46882f2bf1e29532388af125b773c3" translate="yes" xml:space="preserve">
          <source>A Lisp &lt;em&gt;object&lt;/em&gt; is a piece of data used and manipulated by Lisp programs. For our purposes, a &lt;em&gt;type&lt;/em&gt; or &lt;em&gt;data type&lt;/em&gt; is a set of possible objects.</source>
          <target state="translated">Шепелявость &lt;em&gt;объект&lt;/em&gt; представляет собой фрагмент данных , используемых и манипулируют программы Лиспа. Для наших целей &lt;em&gt;тип&lt;/em&gt; или &lt;em&gt;тип &lt;/em&gt;&lt;em&gt;данных&lt;/em&gt; - это набор возможных объектов.</target>
        </trans-unit>
        <trans-unit id="0ede65fe49eec2a820dcd37ce90bed61992a08df" translate="yes" xml:space="preserve">
          <source>A Lisp buffer object contains numerous pieces of information. Some of this information is directly accessible to the programmer through variables, while other information is accessible only through special-purpose functions. For example, the visited file name is directly accessible through a variable, while the value of point is accessible only through a primitive function.</source>
          <target state="translated">Объект буфера Lisp содержит большое количество информации.Часть этой информации напрямую доступна программисту через переменные,другая же информация доступна только через специальные функции.Например,имя посещаемого файла напрямую доступно через переменную,в то время как значение точки доступно только через примитивную функцию.</target>
        </trans-unit>
        <trans-unit id="0cb2ab52c23e67cc9d47f5aaa484af8daf209b86" translate="yes" xml:space="preserve">
          <source>A Lisp expression that you can evaluate is called a &lt;em&gt;form&lt;/em&gt;. Evaluating a form always produces a result, which is a Lisp object. In the examples in this manual, this is indicated with &amp;lsquo;</source>
          <target state="translated">Выражение Lisp, которое вы можете оценить, называется &lt;em&gt;формой&lt;/em&gt; . Оценка формы всегда дает результат, которым является объект Lisp. В примерах в этом руководстве это обозначено как '</target>
        </trans-unit>
        <trans-unit id="44b74e4a3fac58ee6b57c96a4dd7b2d0e1cbf309" translate="yes" xml:space="preserve">
          <source>A Lisp form&amp;rsquo;s value. &amp;lsquo;</source>
          <target state="translated">Значение формы Lisp. '</target>
        </trans-unit>
        <trans-unit id="636bf0c1ed1567a512c03ae0afbe1fe64b2f9b82" translate="yes" xml:space="preserve">
          <source>A Lisp function called whenever the state of the process changes.</source>
          <target state="translated">Функция Lisp вызывается всякий раз,когда меняется состояние процесса.</target>
        </trans-unit>
        <trans-unit id="7e57febc310f2002b2d190a0e3bcc2fe01e7ac4d" translate="yes" xml:space="preserve">
          <source>A Lisp function used to accept output from the process.</source>
          <target state="translated">Функция Lisp,используемая для приема выходных данных из процесса.</target>
        </trans-unit>
        <trans-unit id="4952821b0ad1ac9117ff033a72abb999f4aaedb8" translate="yes" xml:space="preserve">
          <source>A Lisp macro object is a list whose &lt;small&gt;CAR&lt;/small&gt; is &lt;code&gt;macro&lt;/code&gt;, and whose &lt;small&gt;CDR&lt;/small&gt; is a function. Expansion of the macro works by applying the function (with &lt;code&gt;apply&lt;/code&gt;) to the list of &lt;em&gt;unevaluated&lt;/em&gt; arguments from the macro call.</source>
          <target state="translated">Макрообъект Lisp - это список, в котором &lt;small&gt;CAR&lt;/small&gt; является &lt;code&gt;macro&lt;/code&gt; , а &lt;small&gt;CDR&lt;/small&gt; - функцией. Расширение макроса работает путем применения функции (с &lt;code&gt;apply&lt;/code&gt; ) к списку &lt;em&gt;неоцененных&lt;/em&gt; аргументов из вызова макроса.</target>
        </trans-unit>
        <trans-unit id="676c0d12c6662696653cb17b87b78c6a68f660fb" translate="yes" xml:space="preserve">
          <source>A Lisp object that is intended for evaluation is called a &lt;em&gt;form&lt;/em&gt; or &lt;em&gt;expression&lt;/em&gt;&lt;a href=&quot;#FOOT6&quot; name=&quot;DOCF6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;. The fact that forms are data objects and not merely text is one of the fundamental differences between Lisp-like languages and typical programming languages. Any object can be evaluated, but in practice only numbers, symbols, lists and strings are evaluated very often.</source>
          <target state="translated">Объект Lisp, предназначенный для оценки, называется &lt;em&gt;формой&lt;/em&gt; или &lt;em&gt;выражением &lt;/em&gt;&lt;a href=&quot;#FOOT6&quot; name=&quot;DOCF6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt; . Тот факт, что формы являются объектами данных, а не просто текстом, является одним из фундаментальных различий между Lisp-подобными языками и типичными языками программирования. Оценить можно любой объект, но на практике очень часто оцениваются только числа, символы, списки и строки.</target>
        </trans-unit>
        <trans-unit id="f33adea499465f70fa576e194f71f0ef7924e620" translate="yes" xml:space="preserve">
          <source>A Lisp object that is intended to be evaluated is called a &lt;em&gt;form&lt;/em&gt; (or an &lt;em&gt;expression&lt;/em&gt;). How Emacs evaluates a form depends on its data type. Emacs has three different kinds of form that are evaluated differently: symbols, lists, and all other types. This section describes all three kinds, one by one, starting with the other types, which are self-evaluating forms.</source>
          <target state="translated">Объект Lisp, предназначенный для оценки, называется &lt;em&gt;формой&lt;/em&gt; (или &lt;em&gt;выражением&lt;/em&gt; ). Как Emacs оценивает форму, зависит от ее типа данных. В Emacs есть три различных типа форм, которые оцениваются по-разному: символы, списки и все другие типы. В этом разделе описываются все три типа один за другим, начиная с других типов, которые представляют собой самооценочные формы.</target>
        </trans-unit>
        <trans-unit id="61232e4f0cd79d42e285f0ee5d7b7c9f443664ba" translate="yes" xml:space="preserve">
          <source>A Lisp object, specified with its read syntax, terminated with a</source>
          <target state="translated">Объект Lisp,указанный с прочитанным синтаксисом,завершается символом</target>
        </trans-unit>
        <trans-unit id="a7b12802b4f43521be72ce4a8abec084c2492675" translate="yes" xml:space="preserve">
          <source>A Lisp program can pop up a menu so that the user can choose an alternative with the mouse. On a text terminal, if the mouse is not available, the user can choose an alternative using the keyboard motion keys&amp;mdash;</source>
          <target state="translated">Программа на Лиспе может вызывать всплывающее меню, чтобы пользователь мог выбрать альтернативу с помощью мыши. В текстовом терминале, если мышь недоступна, пользователь может выбрать альтернативу, используя клавиши движения клавиатуры:</target>
        </trans-unit>
        <trans-unit id="7f6a3034ff2fce3c5efc4de7ca7afdcbe18b3a20" translate="yes" xml:space="preserve">
          <source>A Lisp program can specify to which thread a process is to be locked, or instruct Emacs to unlock a process, in which case its output can be processed by any thread. Only a single thread will wait for output from a given process at one time&amp;mdash;once one thread begins waiting for output, the process is temporarily locked until &lt;code&gt;accept-process-output&lt;/code&gt; or &lt;code&gt;sit-for&lt;/code&gt; returns.</source>
          <target state="translated">Программа на Лиспе может указать, для какого потока процесс должен быть заблокирован, или указать Emacs разблокировать процесс, и в этом случае ее вывод может быть обработан любым потоком. Только один поток будет ожидать вывода от данного процесса одновременно - как только один поток начинает ждать вывода, процесс временно блокируется до тех пор, пока не вернется &lt;code&gt;accept-process-output&lt;/code&gt; или &lt;code&gt;sit-for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bea1c4b3a46894d0953d9ddc50f1e289ea694d1" translate="yes" xml:space="preserve">
          <source>A Lisp program consists of a set of &lt;em&gt;expressions&lt;/em&gt;, or &lt;em&gt;forms&lt;/em&gt; (see &lt;a href=&quot;forms#Forms&quot;&gt;Forms&lt;/a&gt;). We control the order of execution of these forms by enclosing them in &lt;em&gt;control structures&lt;/em&gt;. Control structures are special forms which control when, whether, or how many times to execute the forms they contain.</source>
          <target state="translated">Программа на Лиспе состоит из набора &lt;em&gt;выражений&lt;/em&gt; или &lt;em&gt;форм&lt;/em&gt; (см. &lt;a href=&quot;forms#Forms&quot;&gt;Формы&lt;/a&gt; ). Мы контролируем порядок выполнения этих форм, заключая их в &lt;em&gt;управляющие структуры&lt;/em&gt; . Управляющие структуры - это специальные формы, которые определяют, когда, нужно ли и сколько раз выполнять содержащиеся в них формы.</target>
        </trans-unit>
        <trans-unit id="49b243589d051decd3fee204d71246c9c4049473" translate="yes" xml:space="preserve">
          <source>A Lisp program is composed mainly of Lisp functions. This chapter explains what functions are, how they accept arguments, and how to define them.</source>
          <target state="translated">Программа на языке Lisp в основном состоит из функций Lisp.Эта глава объясняет,что такое функции,как они принимают аргументы и как их определять.</target>
        </trans-unit>
        <trans-unit id="6f6b3875c43f74196130caa79a2aae800b9e504b" translate="yes" xml:space="preserve">
          <source>A Lisp string that names the buffer. It is guaranteed to be unique. See &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;. This and the following fields have their names in the C struct definition end in a &lt;code&gt;_&lt;/code&gt; to indicate that they should not be accessed directly, but via the &lt;code&gt;BVAR&lt;/code&gt; macro, like this:</source>
          <target state="translated">Строка Лиспа, которая называет буфер. Гарантия уникальности. См. &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Имена буферов&lt;/a&gt; . Это и следующие поля имеют имена в определении структуры C, заканчивающиеся &lt;code&gt;BVAR&lt;/code&gt; &lt;code&gt;_&lt;/code&gt; , чтобы указать, что к ним следует обращаться не напрямую, а через макрос BVAR , например:</target>
        </trans-unit>
        <trans-unit id="0dba94b2c27dc16f1ce1573a3fa87d12c74ef063" translate="yes" xml:space="preserve">
          <source>A Lisp string, the name of the process.</source>
          <target state="translated">Строка Lisp,название процесса.</target>
        </trans-unit>
        <trans-unit id="3830b5730347a3887344295754013d799c21d823" translate="yes" xml:space="preserve">
          <source>A Sample Function Description</source>
          <target state="translated">Образец функции Описание</target>
        </trans-unit>
        <trans-unit id="47688b6f0ccbc8ce6a610200f12d5466c7935f4e" translate="yes" xml:space="preserve">
          <source>A Sample Variable Description</source>
          <target state="translated">Образец Переменная Описание</target>
        </trans-unit>
        <trans-unit id="e5a96014bd90b149f5c06b869ab3dedf6896aa07" translate="yes" xml:space="preserve">
          <source>A Simple Example of a Macro</source>
          <target state="translated">Простой пример макро</target>
        </trans-unit>
        <trans-unit id="6c6aa1370f28727d54174b46840756ee4eca1fca" translate="yes" xml:space="preserve">
          <source>A Simple Lambda Expression Example</source>
          <target state="translated">Простой пример выражения лямбды</target>
        </trans-unit>
        <trans-unit id="fe1639cfe4a0a40f746ce0000ee16f6eaea5c41a" translate="yes" xml:space="preserve">
          <source>A backquote-style pattern has the form &lt;code&gt;`&lt;var&gt;qpat&lt;/var&gt;&lt;/code&gt; where &lt;var&gt;qpat&lt;/var&gt; can have the following forms:</source>
          <target state="translated">Шаблон в стиле &lt;code&gt;`&lt;var&gt;qpat&lt;/var&gt;&lt;/code&gt; &lt;var&gt;qpat&lt;/var&gt; имеет форму ` qpat, где qpat может иметь следующие формы:</target>
        </trans-unit>
        <trans-unit id="e09b92e1e2035037489b57b2cf5ea9ec97ecb050" translate="yes" xml:space="preserve">
          <source>A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, &amp;lsquo;</source>
          <target state="translated">Обратный слеш разрешен и безвреден, предшествующий любому символу без специального escape-значения; таким образом, '</target>
        </trans-unit>
        <trans-unit id="9fb9879aefa3149183ad26133a7129b3b1a9107e" translate="yes" xml:space="preserve">
          <source>A basic example.</source>
          <target state="translated">Основной пример.</target>
        </trans-unit>
        <trans-unit id="a9f489f58b662fe1c92a44259f90e291f9de6363" translate="yes" xml:space="preserve">
          <source>A blank line is defined as a line containing only tabs and spaces.</source>
          <target state="translated">Пустая строка определяется как строка,содержащая только закладки и пробелы.</target>
        </trans-unit>
        <trans-unit id="524e4a4511120df2884e060fd767b7b40a21308e" translate="yes" xml:space="preserve">
          <source>A bool-vector is much like a vector, except that it stores only the values &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;. If you try to store any non-&lt;code&gt;nil&lt;/code&gt; value into an element of the bool-vector, the effect is to store &lt;code&gt;t&lt;/code&gt; there. As with all arrays, bool-vector indices start from 0, and the length cannot be changed once the bool-vector is created. Bool-vectors are constants when evaluated.</source>
          <target state="translated">Bool-вектор очень похож на вектор, за исключением того, что он хранит только значения &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;nil&lt;/code&gt; . Если вы попытаетесь сохранить любое значение, отличное от &lt;code&gt;nil&lt;/code&gt; , в элементе вектора bool, то в результате будет сохранено &lt;code&gt;t&lt;/code&gt; там. Как и все массивы, индексы bool-vector начинаются с 0, и длина не может быть изменена после создания bool-вектора. Bool-векторы при вычислении являются константами.</target>
        </trans-unit>
        <trans-unit id="814538ef1618885380945f59cead64ad79435a60" translate="yes" xml:space="preserve">
          <source>A buffer can have blank areas called &lt;em&gt;display margins&lt;/em&gt; on the left and on the right. Ordinary text never appears in these areas, but you can put things into the display margins using the &lt;code&gt;display&lt;/code&gt; property. There is currently no way to make text or images in the margin mouse-sensitive.</source>
          <target state="translated">В буфере слева и справа могут быть пустые области, называемые &lt;em&gt;полями отображения&lt;/em&gt; . Обычный текст никогда не появляется в этих областях, но вы можете поместить элементы на поля отображения, используя свойство &lt;code&gt;display&lt;/code&gt; . В настоящее время нет возможности сделать текст или изображения на полях чувствительными к мыши.</target>
        </trans-unit>
        <trans-unit id="dffb10f2e97287560c7112dc2419ba6c8e6575dc" translate="yes" xml:space="preserve">
          <source>A buffer is &lt;em&gt;modified&lt;/em&gt; if it needs to be saved.</source>
          <target state="translated">Буфер &lt;em&gt;модифицируется,&lt;/em&gt; если его нужно сохранить.</target>
        </trans-unit>
        <trans-unit id="01af951dc229e9603e576b0ef91e681538e5dd80" translate="yes" xml:space="preserve">
          <source>A buffer may be &lt;em&gt;indirect&lt;/em&gt;, which means it shares the text of another buffer, but presents it differently. See &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;.</source>
          <target state="translated">Буфер может быть &lt;em&gt;косвенным&lt;/em&gt; , что означает, что он разделяет текст другого буфера, но представляет его по-другому. См. &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Непрямые буферы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d424b315e8ae166a8d74702d3afc5f437295bda" translate="yes" xml:space="preserve">
          <source>A buffer name. The buffer need not exist. By default, uses the name of a recently used buffer other than the current buffer. Completion, Default, Prompt.</source>
          <target state="translated">Буферное имя.Буфер не обязательно должен существовать.По умолчанию используется имя недавно использованного буфера,отличного от текущего.Завершение,по умолчанию,быстро.</target>
        </trans-unit>
        <trans-unit id="4eec8b38136453dbf281b73846ca4718f3fd5704" translate="yes" xml:space="preserve">
          <source>A buffer visiting a write-protected file is normally read-only.</source>
          <target state="translated">Буфер,посещающий защищенный от записи файл,обычно доступен только для чтения.</target>
        </trans-unit>
        <trans-unit id="b3bbdf90f180c663bc226ff02e52a4cdd65396f4" translate="yes" xml:space="preserve">
          <source>A buffer-local variable cannot be made terminal-local (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;).</source>
          <target state="translated">Переменную, локальную в буфере, нельзя сделать локальной для терминала (см. &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Несколько терминалов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ddf11dd51e081a083899b25a13468ba1a67d1221" translate="yes" xml:space="preserve">
          <source>A buffer-local variable has a buffer-local binding associated with a particular buffer. The binding is in effect when that buffer is current; otherwise, it is not in effect. If you set the variable while a buffer-local binding is in effect, the new value goes in that binding, so its other bindings are unchanged. This means that the change is visible only in the buffer where you made it.</source>
          <target state="translated">Буферно-локальная переменная имеет буферно-локальную привязку,связанную с конкретным буфером.Связка действует,когда этот буфер является текущим;в противном случае она не действует.Если вы устанавливаете переменную в то время,когда действует привязка по буферу,то новое значение попадает в эту привязку,поэтому остальные её привязки остаются неизменными.Это означает,что изменение видно только в том буфере,в котором вы его сделали.</target>
        </trans-unit>
        <trans-unit id="0ea3f6b24d8b103d0443c8cc30b8a2924a186913" translate="yes" xml:space="preserve">
          <source>A buffer-local variable is &lt;em&gt;permanent&lt;/em&gt; if the variable name (a symbol) has a &lt;code&gt;permanent-local&lt;/code&gt; property that is non-&lt;code&gt;nil&lt;/code&gt;. Such variables are unaffected by &lt;code&gt;kill-all-local-variables&lt;/code&gt;, and their local bindings are therefore not cleared by changing major modes. Permanent locals are appropriate for data pertaining to where the file came from or how to save it, rather than with how to edit the contents.</source>
          <target state="translated">Локальная в буфере переменная является &lt;em&gt;постоянной,&lt;/em&gt; если имя переменной (символ) имеет свойство &lt;code&gt;permanent-local&lt;/code&gt; , отличное от &lt;code&gt;nil&lt;/code&gt; . На такие переменные не влияет &lt;code&gt;kill-all-local-variables&lt;/code&gt; , и поэтому их локальные привязки не очищаются при изменении основных режимов. Постоянные локальные переменные подходят для данных, относящихся к тому, откуда пришел файл или как его сохранить, а не к тому, как редактировать содержимое.</target>
        </trans-unit>
        <trans-unit id="82e1d9061b15d192cfad42d3517641069e30a971" translate="yes" xml:space="preserve">
          <source>A button is essentially a set of text or overlay properties, attached to a stretch of text in a buffer. These properties are called &lt;em&gt;button properties&lt;/em&gt;. One of these properties, the &lt;em&gt;action property&lt;/em&gt;, specifies a function which is called when the user invokes the button using the keyboard or the mouse. The action function may examine the button and use its other properties as desired.</source>
          <target state="translated">По сути, кнопка - это набор свойств текста или наложения, прикрепленных к фрагменту текста в буфере. Эти свойства называются &lt;em&gt;свойствами кнопки&lt;/em&gt; . Одно из этих свойств, &lt;em&gt;свойство action&lt;/em&gt; , определяет функцию, которая вызывается, когда пользователь нажимает кнопку с помощью клавиатуры или мыши. Функция действия может исследовать кнопку и использовать другие ее свойства по желанию.</target>
        </trans-unit>
        <trans-unit id="a12cd4fc77bf2095be17614fa62ca6d977e907e0" translate="yes" xml:space="preserve">
          <source>A button was pushed and not yet released.</source>
          <target state="translated">Кнопка была нажата и еще не отпущена.</target>
        </trans-unit>
        <trans-unit id="e63588ea815dd6fb8cf0feb02e36a33cea09758c" translate="yes" xml:space="preserve">
          <source>A byte-compiled function is not as efficient as a primitive function written in C, but runs much faster than the version written in Lisp. Here is an example:</source>
          <target state="translated">Функция,скомпилированная в байт,не так эффективна,как примитивная функция,написанная на C,но работает намного быстрее,чем версия,написанная на Lisp.Приведем пример:</target>
        </trans-unit>
        <trans-unit id="15e5cdcc2c4c2bf479874e2a6a0a6720464a787a" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;clear-this-command-keys&lt;/code&gt; (see &lt;a href=&quot;command-loop-info#Command-Loop-Info&quot;&gt;Command Loop Info&lt;/a&gt;) causes this function to return an empty vector immediately afterward.</source>
          <target state="translated">Вызов &lt;code&gt;clear-this-command-keys&lt;/code&gt; (см. &lt;a href=&quot;command-loop-info#Command-Loop-Info&quot;&gt;Информация о цикле команд&lt;/a&gt; ) заставляет эту функцию сразу же после этого возвращать пустой вектор.</target>
        </trans-unit>
        <trans-unit id="07bdcc88f0557d24553af69e03106b6926fb38fe" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;libxml-parse-html-region&lt;/code&gt; returns this</source>
          <target state="translated">Вызов &lt;code&gt;libxml-parse-html-region&lt;/code&gt; возвращает это</target>
        </trans-unit>
        <trans-unit id="9ae4251fb7c25ebcbed3100b7db0002d95f465d8" translate="yes" xml:space="preserve">
          <source>A call to any of the following Emacs-specific functions:</source>
          <target state="translated">Вызов любой из следующих Emacs-специфических функций:</target>
        </trans-unit>
        <trans-unit id="3d83bc6e0965f055bd5764ea7054322f45bfafdd" translate="yes" xml:space="preserve">
          <source>A call to any of the following standard Lisp functions:</source>
          <target state="translated">Вызов любой из следующих стандартных функций Lisp:</target>
        </trans-unit>
        <trans-unit id="7635e7ab6b3b4e2b3b227dcbb99a41ebeab9c463" translate="yes" xml:space="preserve">
          <source>A call to the function requires one actual argument for each of the &lt;var&gt;required-vars&lt;/var&gt;. There may be actual arguments for zero or more of the &lt;var&gt;optional-vars&lt;/var&gt;, and there cannot be any actual arguments beyond that unless the lambda list uses &lt;code&gt;&amp;amp;rest&lt;/code&gt;. In that case, there may be any number of extra actual arguments.</source>
          <target state="translated">Для вызова функции требуется по одному фактическому аргументу для каждой из &lt;var&gt;required-vars&lt;/var&gt; . Могут быть фактические аргументы для нуля или более &lt;var&gt;optional-vars&lt;/var&gt; , и не может быть никаких фактических аргументов помимо этого, если в лямбда-списке не используется &lt;code&gt;&amp;amp;rest&lt;/code&gt; . В этом случае может быть любое количество дополнительных фактических аргументов.</target>
        </trans-unit>
        <trans-unit id="67fa1aeb6732d6bf7e24ec11ac66725cadaddf46" translate="yes" xml:space="preserve">
          <source>A case table is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;) whose subtype is &lt;code&gt;case-table&lt;/code&gt;. This char-table maps each character into the corresponding lower case character. It has three extra slots, which hold related tables:</source>
          <target state="translated">Таблица case - это таблица char (см. &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt; ), подтип которой - &lt;code&gt;case-table&lt;/code&gt; . Эта таблица символов отображает каждый символ в соответствующий символ нижнего регистра. Он имеет три дополнительных слота, в которых хранятся связанные таблицы:</target>
        </trans-unit>
        <trans-unit id="2b5b379014c462345470b8abd71e3a1735572b62" translate="yes" xml:space="preserve">
          <source>A certain amount of Common Lisp emulation is available via the</source>
          <target state="translated">Определенное количество эмуляции Common Lisp доступно через</target>
        </trans-unit>
        <trans-unit id="a4a5415d16ff7ebd6665d307ffdd64fbd966a291" translate="yes" xml:space="preserve">
          <source>A char table (see &lt;a href=&quot;char_002dtable-type#Char_002dTable-Type&quot;&gt;Char-Table Type&lt;/a&gt;).</source>
          <target state="translated">Таблица символов (см. &lt;a href=&quot;char_002dtable-type#Char_002dTable-Type&quot;&gt;Тип&lt;/a&gt; таблицы символов ).</target>
        </trans-unit>
        <trans-unit id="ecaf5c129d18b5a22edcf1fb273c1fdf8a52213c" translate="yes" xml:space="preserve">
          <source>A char table of characters which invoke &lt;code&gt;auto-fill-function&lt;/code&gt; when self-inserted&amp;mdash;space and newline in most language environments. They have an entry &lt;code&gt;t&lt;/code&gt; in the table.</source>
          <target state="translated">Таблица символов, которая вызывает &lt;code&gt;auto-fill-function&lt;/code&gt; при самостоятельной вставке - пробел и перевод строки в большинстве языковых сред. У них есть запись &lt;code&gt;t&lt;/code&gt; в таблице.</target>
        </trans-unit>
        <trans-unit id="a4331eab8b48d68401034877de0a7e395a6b7a91" translate="yes" xml:space="preserve">
          <source>A char-table can also have a &lt;em&gt;default value&lt;/em&gt;. If so, then &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; returns the default value whenever the char-table does not specify any other non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">Таблица символов также может иметь &lt;em&gt;значение по умолчанию&lt;/em&gt; . Если это так, то &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; возвращает значение по умолчанию всякий раз, когда char-table не определяет никакого другого значения, отличного от &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fb76fc397b52b86e435eb63aca61212ac723523" translate="yes" xml:space="preserve">
          <source>A char-table can have a &lt;em&gt;parent&lt;/em&gt;, which is another char-table. If it does, then whenever the char-table specifies &lt;code&gt;nil&lt;/code&gt; for a particular character &lt;var&gt;c&lt;/var&gt;, it inherits the value specified in the parent. In other words, &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; returns the value from the parent of &lt;var&gt;char-table&lt;/var&gt; if &lt;var&gt;char-table&lt;/var&gt; itself specifies &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Таблица символов может иметь &lt;em&gt;родителя&lt;/em&gt; , которым является другая таблица символов. Если это так, то всякий раз, когда таблица char указывает &lt;code&gt;nil&lt;/code&gt; для определенного символа &lt;var&gt;c&lt;/var&gt; , она наследует значение, указанное в родительском элементе. Другими словами, &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; возвращает значение из родительского элемента &lt;var&gt;char-table&lt;/var&gt; , если сама &lt;var&gt;char-table&lt;/var&gt; указывает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28812e862b6fe08ebd8034ca275ca9cc0b34ae20" translate="yes" xml:space="preserve">
          <source>A char-table can specify an element value for a single character code; it can also specify a value for an entire character set.</source>
          <target state="translated">Диаграмма может указывать значение элемента для одного символьного кода;она также может указывать значение для всего набора символов.</target>
        </trans-unit>
        <trans-unit id="7b405f04567fba4621b52257941c3540fa92759c" translate="yes" xml:space="preserve">
          <source>A char-table is much like a vector, except that it is indexed by character codes. Any valid character code, without modifiers, can be used as an index in a char-table. You can access a char-table&amp;rsquo;s elements with &lt;code&gt;aref&lt;/code&gt; and &lt;code&gt;aset&lt;/code&gt;, as with any array. In addition, a char-table can have &lt;em&gt;extra slots&lt;/em&gt; to hold additional data not associated with particular character codes. Like vectors, char-tables are constants when evaluated, and can hold elements of any type.</source>
          <target state="translated">Таблица символов очень похожа на вектор, за исключением того, что она индексируется кодами символов. Любой допустимый код символа без модификаторов может использоваться в качестве индекса в таблице символов. Вы можете получить доступ к элементам таблицы символов с помощью &lt;code&gt;aref&lt;/code&gt; и &lt;code&gt;aset&lt;/code&gt; , как и с любым массивом. Кроме того, таблица символов может иметь &lt;em&gt;дополнительные слоты&lt;/em&gt; для хранения дополнительных данных, не связанных с конкретными кодами символов. Как и векторы, таблицы символов при вычислении являются константами и могут содержать элементы любого типа.</target>
        </trans-unit>
        <trans-unit id="f9d00bdec6ad25e61b5900d9855da9f05fa84630" translate="yes" xml:space="preserve">
          <source>A character (see &lt;a href=&quot;basic-char-syntax#Basic-Char-Syntax&quot;&gt;Basic Char Syntax&lt;/a&gt;).</source>
          <target state="translated">Символ (см. &lt;a href=&quot;basic-char-syntax#Basic-Char-Syntax&quot;&gt;Базовый синтаксис&lt;/a&gt; символов ).</target>
        </trans-unit>
        <trans-unit id="5a9de7794a633ca12c84e901f3c32bafb6a9360d" translate="yes" xml:space="preserve">
          <source>A character alternative can also specify named character classes (see &lt;a href=&quot;char-classes#Char-Classes&quot;&gt;Char Classes&lt;/a&gt;). This is a POSIX feature. For example, &amp;lsquo;</source>
          <target state="translated">Альтернатива символов также может указывать именованные классы символов (см. &lt;a href=&quot;char-classes#Char-Classes&quot;&gt;Классы&lt;/a&gt; символов ). Это особенность POSIX. Например, '</target>
        </trans-unit>
        <trans-unit id="5852ab82906acd43fcce8f1e9319776366ed12e5" translate="yes" xml:space="preserve">
          <source>A character is a Lisp object which represents a single character of text. In Emacs Lisp, characters are simply integers; whether an integer is a character or not is determined only by how it is used. See &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;, for details about character representation in Emacs.</source>
          <target state="translated">Символ - это объект Лиспа, который представляет отдельный символ текста. В Emacs Lisp символы - это просто целые числа; является ли целое число символом или нет, определяется только тем, как оно используется. См. &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Коды символов&lt;/a&gt; для получения подробной информации о представлении символов в Emacs.</target>
        </trans-unit>
        <trans-unit id="9dfbff13dd844666d887c5ab6faa1df6fbe6ee51" translate="yes" xml:space="preserve">
          <source>A character is invisible if its &lt;code&gt;invisible&lt;/code&gt; property is non-&lt;code&gt;nil&lt;/code&gt;. This is the default.</source>
          <target state="translated">Символ невидим, если его &lt;code&gt;invisible&lt;/code&gt; свойство не равно &lt;code&gt;nil&lt;/code&gt; . Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="47f28363d88b6d425d64a18f02bda09273e7eca4" translate="yes" xml:space="preserve">
          <source>A character is invisible if its &lt;code&gt;invisible&lt;/code&gt; property value is &lt;var&gt;atom&lt;/var&gt; or if it is a list with &lt;var&gt;atom&lt;/var&gt; as a member; comparison is done with &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">Символ невидим, если значение его &lt;code&gt;invisible&lt;/code&gt; свойства - &lt;var&gt;atom&lt;/var&gt; или если это список с &lt;var&gt;atom&lt;/var&gt; в качестве члена; сравнение выполняется с &lt;code&gt;eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2caeed893ef6aef55ca838c3839fe9fc2a1038" translate="yes" xml:space="preserve">
          <source>A character is invisible if its &lt;code&gt;invisible&lt;/code&gt; property value is &lt;var&gt;atom&lt;/var&gt; or if it is a list with &lt;var&gt;atom&lt;/var&gt; as a member; comparison is done with &lt;code&gt;eq&lt;/code&gt;. Moreover, a sequence of such characters displays as an ellipsis.</source>
          <target state="translated">Символ невидим, если значение его &lt;code&gt;invisible&lt;/code&gt; свойства - &lt;var&gt;atom&lt;/var&gt; или если это список с &lt;var&gt;atom&lt;/var&gt; в качестве члена; сравнение выполняется с &lt;code&gt;eq&lt;/code&gt; . Более того, последовательность таких символов отображается в виде многоточия.</target>
        </trans-unit>
        <trans-unit id="b5cebcadf9e0f5094b601d80021f925480c3f78b" translate="yes" xml:space="preserve">
          <source>A character&amp;rsquo;s syntax controls how it changes the state of the parser, rather than describing the state itself. For example, a string delimiter character toggles the parser state between in-string and in-code, but the syntax of characters does not directly say whether they are inside a string. For example (note that 15 is the syntax code for generic string delimiters),</source>
          <target state="translated">Синтаксис символа управляет тем, как он изменяет состояние синтаксического анализатора, а не описывает само состояние. Например, символ-разделитель строк переключает состояние анализатора между строкой и кодом, но синтаксис символов напрямую не говорит, находятся ли они внутри строки. Например (обратите внимание, что 15 - это код синтаксиса для общих разделителей строк),</target>
        </trans-unit>
        <trans-unit id="995e1986dbee8019705c2c18b9dabf464763be2f" translate="yes" xml:space="preserve">
          <source>A character. The cursor does not move into the echo area. Prompt.</source>
          <target state="translated">Персонаж.Курсор не перемещается в область эха.Быстро.</target>
        </trans-unit>
        <trans-unit id="9af6e20f678a486779e8667c74ae3962238033bd" translate="yes" xml:space="preserve">
          <source>A circle is a cons &lt;code&gt;(circle . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . &lt;var&gt;r&lt;/var&gt;))&lt;/code&gt; which specifies the center and the radius of the circle; &lt;var&gt;r&lt;/var&gt; may be a float or integer.</source>
          <target state="translated">Окружность - это минус &lt;code&gt;(circle . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . &lt;var&gt;r&lt;/var&gt;))&lt;/code&gt; который определяет центр и радиус круга; &lt;var&gt;r&lt;/var&gt; может быть числом с плавающей запятой или целым числом.</target>
        </trans-unit>
        <trans-unit id="50c12ff3802dbf249cfca7012b5760bea0a96b84" translate="yes" xml:space="preserve">
          <source>A clause may also look like this:</source>
          <target state="translated">Пункт также может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="4a41891558abee07449b02af72c74eac4e6837f1" translate="yes" xml:space="preserve">
          <source>A closure is a function that also carries a record of the lexical environment that existed when the function was defined. When it is invoked, any lexical variable references within its definition use the retained lexical environment. In all other respects, closures behave much like ordinary functions; in particular, they can be called in the same way as ordinary functions.</source>
          <target state="translated">Закрытие-это функция,которая также содержит запись лексического окружения,существовавшего на момент определения функции.При ее вызове любая ссылка на лексическую переменную в рамках ее определения использует сохраненное лексическое окружение.Во всех остальных отношениях замыкания ведут себя так же,как и обычные функции;в частности,они могут вызываться так же,как и обычные функции.</target>
        </trans-unit>
        <trans-unit id="ce25d22da839fc3f074d57a6f7f3079b96e65780" translate="yes" xml:space="preserve">
          <source>A coding system name (a symbol)&amp;mdash;but only if this command has a prefix argument. With no prefix argument, &amp;lsquo;</source>
          <target state="translated">Название системы кодирования (символ) - но только если эта команда имеет аргумент префикса. Без аргумента префикса '</target>
        </trans-unit>
        <trans-unit id="32f193f6c59efaee4ac9718360d54b11c34fae18" translate="yes" xml:space="preserve">
          <source>A coding system name (a symbol). If the user enters null input, the argument value is &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;. Completion, Existing, Prompt.</source>
          <target state="translated">Название системы кодирования (символ). Если пользователь вводит нулевой ввод, значение аргумента равно &lt;code&gt;nil&lt;/code&gt; . См. &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Системы кодирования&lt;/a&gt; . Завершение, Существующее, Подсказка.</target>
        </trans-unit>
        <trans-unit id="7ae6346452476d84451bf83887065f34142fef82" translate="yes" xml:space="preserve">
          <source>A color name is text (usually in a string) that specifies a color. Symbolic names such as &amp;lsquo;</source>
          <target state="translated">Название цвета - это текст (обычно в строке), определяющий цвет. Символические имена, такие как '</target>
        </trans-unit>
        <trans-unit id="861c8320a472767fcebf0b85b88c1e68f51e31fe" translate="yes" xml:space="preserve">
          <source>A command can inhibit this feature by setting the variable &lt;code&gt;disable-point-adjustment&lt;/code&gt;:</source>
          <target state="translated">Команда может запретить эту функцию, установив переменную &lt;code&gt;disable-point-adjustment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a1feab560a446fec5a5847d8874376ebf879270" translate="yes" xml:space="preserve">
          <source>A command may be called from Lisp programs like any other function, but then the caller supplies the arguments and &lt;var&gt;arg-descriptor&lt;/var&gt; has no effect.</source>
          <target state="translated">Команду можно вызывать из программ на Лиспе, как и любую другую функцию, но тогда вызывающая сторона предоставляет аргументы, и &lt;var&gt;arg-descriptor&lt;/var&gt; не действует.</target>
        </trans-unit>
        <trans-unit id="3850fb8bc1d5cf519ee8cb5ce99fd65ff30af7c4" translate="yes" xml:space="preserve">
          <source>A command name (i.e., a symbol satisfying &lt;code&gt;commandp&lt;/code&gt;). Existing, Completion, Prompt.</source>
          <target state="translated">Имя команды (т. &lt;code&gt;commandp&lt;/code&gt; Символ, удовлетворяющий commandp ). Существующий, Завершение, Подсказка.</target>
        </trans-unit>
        <trans-unit id="dea75281854f153f67a07289a0bf70599fd97be6" translate="yes" xml:space="preserve">
          <source>A command that calls &lt;code&gt;read-event&lt;/code&gt;, &lt;code&gt;read-char-choice&lt;/code&gt;, or &lt;code&gt;read-char&lt;/code&gt; probably should bind &lt;code&gt;help-form&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; expression while it does input. (The time when you should not do this is when</source>
          <target state="translated">Команда, которая вызывает &lt;code&gt;read-event&lt;/code&gt; , &lt;code&gt;read-char-choice&lt;/code&gt; или &lt;code&gt;read-char&lt;/code&gt; , вероятно, должна связывать &lt;code&gt;help-form&lt;/code&gt; с выражением, отличным от &lt;code&gt;nil&lt;/code&gt; , во время ввода. (Не следует этого делать, когда</target>
        </trans-unit>
        <trans-unit id="786b45a633125186b705ed0d2a068df264c8c114" translate="yes" xml:space="preserve">
          <source>A common idiom is to write a pattern starting with &lt;code&gt;and&lt;/code&gt;, with one or more &lt;var&gt;symbol&lt;/var&gt; sub-patterns providing bindings to the sub-patterns that follow (as well as to the body forms). For example, the following pattern matches single-digit integers.</source>
          <target state="translated">Распространенной идиомой является написание шаблона, начинающегося с &lt;code&gt;and&lt;/code&gt; , с одним или несколькими суб-шаблонами &lt;var&gt;symbol&lt;/var&gt; , обеспечивающими привязку к последующим суб-шаблонам (а также к основным формам). Например, следующий шаблон соответствует однозначным целым числам.</target>
        </trans-unit>
        <trans-unit id="f07ac0baafe3f998e934789a564c3d4c6b97953a" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use a constant list as a non-last argument to &lt;code&gt;nconc&lt;/code&gt;. If you do this, the resulting behavior is undefined. It is possible that your program will change each time you run it! Here is what might happen (though this is not guaranteed to happen):</source>
          <target state="translated">Распространенная ошибка - использовать список констант в качестве не последнего аргумента &lt;code&gt;nconc&lt;/code&gt; . Если вы сделаете это, результат будет неопределенным. Возможно, ваша программа будет меняться каждый раз, когда вы ее запускаете! Вот что может произойти (хотя это не гарантируется):</target>
        </trans-unit>
        <trans-unit id="759143f2b89b63d556200183aad1e79402e78704" translate="yes" xml:space="preserve">
          <source>A common type of warning issued by the byte compiler is for functions and variables that were used but not defined. Such warnings report the line number for the end of the file, not the locations where the missing functions or variables were used; to find these, you must search the file manually.</source>
          <target state="translated">Распространенным типом предупреждения,выдаваемого компилятором байтов,являются предупреждения для функций и переменных,которые использовались,но не были определены.Такие предупреждения сообщают номер строки в конце файла,а не места,где были использованы отсутствующие функции или переменные;чтобы их найти,необходимо вручную выполнить поиск в файле.</target>
        </trans-unit>
        <trans-unit id="2a3d7f1b5d61b15dc9a45f1d4a60683c03b995b6" translate="yes" xml:space="preserve">
          <source>A common use of advice is for named functions and macros. You could just use &lt;code&gt;add-function&lt;/code&gt; as in:</source>
          <target state="translated">Совет обычно используется для именованных функций и макросов. Вы можете просто использовать &lt;code&gt;add-function&lt;/code&gt; как в:</target>
        </trans-unit>
        <trans-unit id="488edd78a5bd826f662b481ed78ba3fdff0e08c8" translate="yes" xml:space="preserve">
          <source>A complemented character alternative can match a newline, unless newline is mentioned as one of the characters not to match. This is in contrast to the handling of regexps in programs such as &lt;code&gt;grep&lt;/code&gt;.</source>
          <target state="translated">Альтернативный вариант дополненного символа может соответствовать новой строке, если новая строка не упоминается как один из символов, которые не соответствуют. Это отличается от обработки регулярных выражений в таких программах, как &lt;code&gt;grep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba456a01d8ae77fc51576a8cf54c1d1c946d7a68" translate="yes" xml:space="preserve">
          <source>A compromise is to set it to a positive number. This means that cached values are used for that amount of seconds since they were cached. If a remote file is checked regularly, it might be a good idea to let-bind this variable to a value less than the time period between consecutive checks. For example:</source>
          <target state="translated">Компромисс заключается в том,чтобы установить положительное число.Это означает,что кэшированные значения используются в течение такого количества секунд с момента их кэширования.Если удаленный файл проверяется регулярно,может быть хорошей идеей позволить привязать эту переменную к значению меньше,чем промежуток времени между последовательными проверками.Например:</target>
        </trans-unit>
        <trans-unit id="91e9b79d51b851733226729b9b7576c7c693a1aa" translate="yes" xml:space="preserve">
          <source>A condition variable is associated with a mutex and, conceptually, with some condition. For proper operation, the mutex must be acquired, and then a waiting thread must loop, testing the condition and waiting on the condition variable. For example:</source>
          <target state="translated">Переменная условия ассоциируется с мьютексом и,концептуально,с некоторым условием.Для правильной работы,мьютекс должен быть приобретен,а затем поток ожидания должен зациклиться,тестирование условия и ожидание на переменной состояния.Например:</target>
        </trans-unit>
        <trans-unit id="3650f8c5497d7228961bb8ca2c4d9289b5d66fe8" translate="yes" xml:space="preserve">
          <source>A cons cell of the form &lt;code&gt;(:filtered&amp;nbsp;&lt;var&gt;filter&lt;/var&gt;&amp;nbsp;&lt;var&gt;face-spec&lt;/var&gt;)&lt;/code&gt;, that specifies the face given by &lt;var&gt;face-spec&lt;/var&gt;, but only if &lt;var&gt;filter&lt;/var&gt; matches when the face is used for display. The &lt;var&gt;face-spec&lt;/var&gt; can use any of the forms mentioned above. The &lt;var&gt;filter&lt;/var&gt; should be of the form &lt;code&gt;(:window&amp;nbsp;&lt;var&gt;param&lt;/var&gt;&amp;nbsp;&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;, which matches for windows whose parameter &lt;var&gt;param&lt;/var&gt; is &lt;code&gt;eq&lt;/code&gt; to &lt;var&gt;value&lt;/var&gt;. If the variable &lt;code&gt;face-filters-always-match&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, all face filters are deemed to have matched.</source>
          <target state="translated">Консольная ячейка формы &lt;code&gt;(:filtered&amp;nbsp;&lt;var&gt;filter&lt;/var&gt;&amp;nbsp;&lt;var&gt;face-spec&lt;/var&gt;)&lt;/code&gt; , которая определяет лицо, указанное в &lt;var&gt;face-spec&lt;/var&gt; , но только если &lt;var&gt;filter&lt;/var&gt; соответствует, когда лицо используется для отображения. Спецификация &lt;var&gt;face-spec&lt;/var&gt; может использовать любую из форм, упомянутых выше. &lt;var&gt;filter&lt;/var&gt; должен иметь вид &lt;code&gt;(:window&amp;nbsp;&lt;var&gt;param&lt;/var&gt;&amp;nbsp;&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; , что соответствует для окон параметров , чьи &lt;var&gt;param&lt;/var&gt; являются &lt;code&gt;eq&lt;/code&gt; к &lt;var&gt;value&lt;/var&gt; . Если переменная &lt;code&gt;face-filters-always-match&lt;/code&gt; не равна &lt;code&gt;nil&lt;/code&gt; , все лицевые фильтры считаются совпадающими.</target>
        </trans-unit>
        <trans-unit id="d8271db68f51039072c221d4ef9ab0b74c409c21" translate="yes" xml:space="preserve">
          <source>A cons cell of the form &lt;code&gt;(foreground-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;(background-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt;. This specifies the foreground or background color, similar to &lt;code&gt;(:foreground
&lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;(:background &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt;. This form is supported for backward compatibility only, and should be avoided.</source>
          <target state="translated">Консольная ячейка формы &lt;code&gt;(foreground-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; или &lt;code&gt;(background-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; . Это определяет цвет переднего плана или фона, аналогично &lt;code&gt;(:foreground &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; или &lt;code&gt;(:background &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; . Эта форма поддерживается только для обратной совместимости, и ее следует избегать.</target>
        </trans-unit>
        <trans-unit id="d03a2fa230ce48add85f00959d667fc812d94873" translate="yes" xml:space="preserve">
          <source>A cons cell of this format is a raw syntax descriptor (see &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt;), which directly specifies a syntax class for the underlying text character.</source>
          <target state="translated">Консольная ячейка этого формата представляет собой необработанный дескриптор синтаксиса (см. &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Внутреннее устройство таблицы синтаксиса&lt;/a&gt; ), который непосредственно определяет класс синтаксиса для основного текстового символа.</target>
        </trans-unit>
        <trans-unit id="5238f872a1ac4dba38c3a3004ec3ed1655dc4fed" translate="yes" xml:space="preserve">
          <source>A cons cell refers to all the characters in the inclusive range &amp;lsquo;</source>
          <target state="translated">Консольная ячейка относится ко всем символам в включающем диапазоне '</target>
        </trans-unit>
        <trans-unit id="1ec89aacc5165a1fe6d3ad709f5d8ebc96163844" translate="yes" xml:space="preserve">
          <source>A cons of the horizontal and vertical width of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s external borders as supplied by the window manager. If the window manager doesn&amp;rsquo;t supply these values, Emacs will try to guess them from the coordinates of the outer and inner frame.</source>
          <target state="translated">Минусы горизонтальной и вертикальной ширины внешних границ &lt;var&gt;frame&lt;/var&gt; предоставленные оконным менеджером. Если оконный менеджер не предоставляет эти значения, Emacs попытается угадать их по координатам внешнего и внутреннего фрейма.</target>
        </trans-unit>
        <trans-unit id="0beb20967e7325f22b981dd3f01c49dfbca35c06" translate="yes" xml:space="preserve">
          <source>A cons of the outer width and height of &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">Из минусов внешняя ширина и высота &lt;var&gt;frame&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="79343f6085ac302ef9fa3a97ea5eeac739cb4772" translate="yes" xml:space="preserve">
          <source>A cons of the width and height of the menu bar of &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">Минусы ширины и высоты строки меню &lt;var&gt;frame&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="5f12a3cec98da0d7b3d27d5bc62141f964a4c280" translate="yes" xml:space="preserve">
          <source>A cons of the width and height of the title bar of &lt;var&gt;frame&lt;/var&gt; as supplied by the window manager or operating system. If both of them are zero, the frame has no title bar. If only the width is zero, Emacs was not able to retrieve the width information.</source>
          <target state="translated">Минусы ширины и высоты строки заголовка &lt;var&gt;frame&lt;/var&gt; предоставляемые оконным менеджером или операционной системой. Если оба они равны нулю, у фрейма нет строки заголовка. Если только ширина равна нулю, Emacs не смог получить информацию о ширине.</target>
        </trans-unit>
        <trans-unit id="c58e8cae6440fd807e647cdf99797dc30cefd036" translate="yes" xml:space="preserve">
          <source>A cons of the width and height of the tool bar of &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">Минусы ширины и высоты панели инструментов &lt;var&gt;frame&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f9033693e3f5a3c88a76aad01d35ab20eafc8a92" translate="yes" xml:space="preserve">
          <source>A cons representing the absolute position of the outer &lt;var&gt;frame&lt;/var&gt;, relative to the origin at position (0, 0) of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display.</source>
          <target state="translated">Минусы, представляющие абсолютное положение внешнего &lt;var&gt;frame&lt;/var&gt; относительно исходной точки в позиции (0, 0) отображения &lt;var&gt;frame&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="9b4eb54eabadc737377233ef8ded968fd41e2deb" translate="yes" xml:space="preserve">
          <source>A construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression which is to be evaluated instead of the original expression. Macros enable Lisp programmers to do the sorts of things that special forms can do. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;.</source>
          <target state="translated">Конструкция, определенная в Лиспе, которая отличается от функции тем, что она переводит выражение Лиспа в другое выражение, которое должно быть вычислено, вместо исходного выражения. Макросы позволяют программистам на Лиспе делать то, что могут делать специальные формы. См. &lt;a href=&quot;macros#Macros&quot;&gt;Макросы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25f94db633d9470e92b721c0609e1574933b7102" translate="yes" xml:space="preserve">
          <source>A convenience macro for making menus.</source>
          <target state="translated">Удобный макрос для составления меню.</target>
        </trans-unit>
        <trans-unit id="3fafa14ddeeaf20f1b4ad6912b65d2d19616adec" translate="yes" xml:space="preserve">
          <source>A convenient facility for defining minor modes.</source>
          <target state="translated">Удобное средство для определения второстепенных режимов.</target>
        </trans-unit>
        <trans-unit id="297d6bae1b885556c226c6d00dbbeb28f22842b0" translate="yes" xml:space="preserve">
          <source>A convenient way to set up and update a package archive is via the &lt;code&gt;package-x&lt;/code&gt; library. This is included with Emacs, but not loaded by default; type</source>
          <target state="translated">Удобный способ настроить и обновить архив пакетов - использовать библиотеку &lt;code&gt;package-x&lt;/code&gt; . Это включено в Emacs, но не загружается по умолчанию; тип</target>
        </trans-unit>
        <trans-unit id="2e0cc653b247cb03dc9702d2d54a86897be33e6a" translate="yes" xml:space="preserve">
          <source>A convention for use of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; is that a major mode should use the mode&amp;rsquo;s own name as an element of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; and as the value of the &lt;code&gt;invisible&lt;/code&gt; property:</source>
          <target state="translated">Соглашение об использовании &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; заключается в том, что основной режим должен использовать собственное имя режима как элемент &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; и как значение свойства &lt;code&gt;invisible&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0095e662bacaddef74e80e8571b0f884034dde11" translate="yes" xml:space="preserve">
          <source>A debugger for the Emacs Lisp evaluator.</source>
          <target state="translated">Отладчик для вычислителя Emacs Lisp.</target>
        </trans-unit>
        <trans-unit id="c27aa099ef5cc29a5bab61fb80b9be59f07e143f" translate="yes" xml:space="preserve">
          <source>A declare form, as described in &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;.</source>
          <target state="translated">Форма объявления, как описано в &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;форме объявления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1be6fff32246cce77eab4434395816c475968954" translate="yes" xml:space="preserve">
          <source>A default value of some sort is used if the user enters no text in the minibuffer. The default depends on the code character.</source>
          <target state="translated">Значение по умолчанию используется,если пользователь не вводит текст в минибуфер.Значение по умолчанию зависит от символа кода.</target>
        </trans-unit>
        <trans-unit id="3c9c4af7e022e7df38dd0e315a210ed85a2953a6" translate="yes" xml:space="preserve">
          <source>A defining form is not required to have a name field; and it may have multiple name fields.</source>
          <target state="translated">Определяющая форма не обязана иметь поле имени;она может иметь несколько полей имени.</target>
        </trans-unit>
        <trans-unit id="5177ad8b95e4d0810b23a049c7d8aa0b5c5cdcd6" translate="yes" xml:space="preserve">
          <source>A definition says a symbol is used as a variable.</source>
          <target state="translated">Определение гласит,что в качестве переменной используется символ.</target>
        </trans-unit>
        <trans-unit id="de08378d88f315c9fa8938316807fbbd8ff34ed7" translate="yes" xml:space="preserve">
          <source>A definition says how a symbol will be used.</source>
          <target state="translated">Определение говорит о том,как будет использоваться символ.</target>
        </trans-unit>
        <trans-unit id="4364a7b67be2475f663e63107ec953eb81d8fcc0" translate="yes" xml:space="preserve">
          <source>A deleted overlay is not permanently disconnected. You can give it a position in a buffer again by calling &lt;code&gt;move-overlay&lt;/code&gt;.</source>
          <target state="translated">Удаленный оверлей не отключается навсегда. Вы можете снова присвоить ему позицию в буфере, вызвав &lt;code&gt;move-overlay&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58b8939e754501ca7ffac5e754a5203fd8bccd0b" translate="yes" xml:space="preserve">
          <source>A description of an imaginary function, &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Описание воображаемой функции &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11aa25b3cc19f2ea9549c34581688b4bf0ea0136" translate="yes" xml:space="preserve">
          <source>A description of an imaginary variable, &lt;code&gt;electric-future-map&lt;/code&gt;.</source>
          <target state="translated">Описание воображаемой переменной, &lt;code&gt;electric-future-map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f73f21e9e7cf5032ba1e7628c65d4b74eb715d3" translate="yes" xml:space="preserve">
          <source>A detailed explanation of ACLs and SELinux is beyond the scope of this manual. For our purposes, each file can be associated with an &lt;em&gt;ACL&lt;/em&gt;, which specifies its properties under an ACL-based file control system, and/or an &lt;em&gt;SELinux context&lt;/em&gt;, which specifies its properties under the SELinux system.</source>
          <target state="translated">Подробное объяснение ACL и SELinux выходит за рамки этого руководства. Для наших целей каждый файл может быть связан с &lt;em&gt;ACL&lt;/em&gt; , который определяет его свойства в системе управления файлами на основе ACL, и / или &lt;em&gt;контекстом SELinux&lt;/em&gt; , который определяет его свойства в системе SELinux.</target>
        </trans-unit>
        <trans-unit id="e1955b79f8229f08318c426ea757222c4442b725" translate="yes" xml:space="preserve">
          <source>A deterministic computer program cannot generate true random numbers. For most purposes, &lt;em&gt;pseudo-random numbers&lt;/em&gt; suffice. A series of pseudo-random numbers is generated in a deterministic fashion. The numbers are not truly random, but they have certain properties that mimic a random series. For example, all possible values occur equally often in a pseudo-random series.</source>
          <target state="translated">Детерминированная компьютерная программа не может генерировать истинные случайные числа. Для большинства целей достаточно &lt;em&gt;псевдослучайных чисел&lt;/em&gt; . Детерминированным образом генерируется серия псевдослучайных чисел. Числа не являются действительно случайными, но у них есть определенные свойства, имитирующие случайный ряд. Например, все возможные значения одинаково часто встречаются в псевдослучайном ряду.</target>
        </trans-unit>
        <trans-unit id="43e7ef970f24cac5d7645fe4b91714542c027a79" translate="yes" xml:space="preserve">
          <source>A dialog box is a variant of a pop-up menu&amp;mdash;it looks a little different, it always appears in the center of a frame, and it has just one level and one or more buttons. The main use of dialog boxes is for asking questions that the user can answer with &amp;ldquo;yes&amp;rdquo;, &amp;ldquo;no&amp;rdquo;, and a few other alternatives. With a single button, they can also force the user to acknowledge important information. The functions &lt;code&gt;y-or-n-p&lt;/code&gt; and &lt;code&gt;yes-or-no-p&lt;/code&gt; use dialog boxes instead of the keyboard, when called from commands invoked by mouse clicks.</source>
          <target state="translated">Диалоговое окно - это вариант всплывающего меню - оно выглядит немного по-другому, всегда отображается в центре кадра и имеет только один уровень и одну или несколько кнопок. В основном диалоговые окна используются для того, чтобы задавать вопросы, на которые пользователь может ответить &amp;laquo;да&amp;raquo;, &amp;laquo;нет&amp;raquo; и некоторыми другими альтернативами. С помощью одной кнопки они также могут заставить пользователя подтвердить важную информацию. Функции &lt;code&gt;y-or-n-p&lt;/code&gt; и &lt;code&gt;yes-or-no-p&lt;/code&gt; используют диалоговые окна вместо клавиатуры при вызове из команд, вызываемых щелчком мыши.</target>
        </trans-unit>
        <trans-unit id="06e671a1ddbd1bf37d315d97dcc27b3ed2c2dee1" translate="yes" xml:space="preserve">
          <source>A different type of local variable binding.</source>
          <target state="translated">Другой тип привязки локальных переменных.</target>
        </trans-unit>
        <trans-unit id="0091e52ca1a33dbd15c5a00528bef096a86ddc65" translate="yes" xml:space="preserve">
          <source>A different way to remove the instrumentation from a definition is to use the &lt;code&gt;edebug-remove-instrumentation&lt;/code&gt; command. It also allows removing the instrumentation from everything that has been instrumented.</source>
          <target state="translated">Другой способ удалить инструментарий из определения - использовать команду &lt;code&gt;edebug-remove-instrumentation&lt;/code&gt; . Это также позволяет снимать инструменты со всего, что было оснащено инструментами.</target>
        </trans-unit>
        <trans-unit id="1e5fced30518a6cc177c6f9f8661843eb09981dd" translate="yes" xml:space="preserve">
          <source>A directory can specify local variable values common to all files in that directory; Emacs uses these to create buffer-local bindings for those variables in buffers visiting any file in that directory. This is useful when the files in the directory belong to some &lt;em&gt;project&lt;/em&gt; and therefore share the same local variables.</source>
          <target state="translated">Каталог может указывать значения локальных переменных, общие для всех файлов в этом каталоге; Emacs использует их для создания локальных привязок к буферу для этих переменных в буферах, обращающихся к любому файлу в этом каталоге. Это полезно, когда файлы в каталоге принадлежат какому-либо &lt;em&gt;проекту&lt;/em&gt; и поэтому используют одни и те же локальные переменные.</target>
        </trans-unit>
        <trans-unit id="48d989c612224004f5b20619066f4e6b19f37178" translate="yes" xml:space="preserve">
          <source>A directory is a kind of file that contains other files entered under various names. Directories are a feature of the file system.</source>
          <target state="translated">Каталог-это разновидность файла,которая содержит другие файлы,введенные под разными именами.Директории являются особенностью файловой системы.</target>
        </trans-unit>
        <trans-unit id="4ec31203fbb74e0088be167ac30971d85d3c047f" translate="yes" xml:space="preserve">
          <source>A directory&amp;rsquo;s name as a directory is different from its name as a file.</source>
          <target state="translated">Имя каталога как каталога отличается от его имени как файла.</target>
        </trans-unit>
        <trans-unit id="a2d4ede6ec1806c95321d5345fff475d6f0aebcd" translate="yes" xml:space="preserve">
          <source>A directory. The default is the current default directory of the current buffer, &lt;code&gt;default-directory&lt;/code&gt; (see &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;File Name Expansion&lt;/a&gt;). Existing, Completion, Default, Prompt.</source>
          <target state="translated">Каталог. По умолчанию это текущий каталог по умолчанию для текущего буфера, &lt;code&gt;default-directory&lt;/code&gt; (см. &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;Расширение имени файла&lt;/a&gt; ). Существующий, Завершение, По умолчанию, Запрос.</target>
        </trans-unit>
        <trans-unit id="aebf276f3f9ef6b6d78e048e8f10f2d90ee89099" translate="yes" xml:space="preserve">
          <source>A display specification of this form means to display &lt;var&gt;string&lt;/var&gt; instead of the text that has the display specification, at the same position as that text. It is equivalent to using just &lt;var&gt;string&lt;/var&gt;, but it is done as a special case of marginal display (see &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;).</source>
          <target state="translated">Спецификация отображения этой формы означает отображение &lt;var&gt;string&lt;/var&gt; вместо текста, который имеет спецификацию отображения, в той же позиции, что и этот текст. Это эквивалентно использованию простой &lt;var&gt;string&lt;/var&gt; , но это особый случай &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;отображения на полях&lt;/a&gt; (см. Поля отображения ).</target>
        </trans-unit>
        <trans-unit id="9161760d8a3ca941a9db98a283106b4f587110f2" translate="yes" xml:space="preserve">
          <source>A display table is a special-purpose char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;), with &lt;code&gt;display-table&lt;/code&gt; as its subtype, which is used to override the usual character display conventions. This section describes how to make, inspect, and assign elements to a display table object.</source>
          <target state="translated">Таблица отображения - это специальная таблица символов (см. &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Таблицы&lt;/a&gt; символов ) с &lt;code&gt;display-table&lt;/code&gt; качестве подтипа, которая используется для переопределения обычных соглашений об отображении символов. В этом разделе описывается, как создавать, проверять и назначать элементы объекту экранной таблицы.</target>
        </trans-unit>
        <trans-unit id="52695f4559e95ed4fd291753560c2fbe430d0669" translate="yes" xml:space="preserve">
          <source>A documentation string for the format.</source>
          <target state="translated">Строка документации для формата.</target>
        </trans-unit>
        <trans-unit id="6763620e7fdbc8305a10cc9edc12970524216315" translate="yes" xml:space="preserve">
          <source>A documentation string is written using the Lisp syntax for strings, with double-quote characters surrounding the text. It is, in fact, an actual Lisp string. When the string appears in the proper place in a function or variable definition, it serves as the function&amp;rsquo;s or variable&amp;rsquo;s documentation.</source>
          <target state="translated">Строка документации пишется с использованием синтаксиса Lisp для строк с символами двойных кавычек, окружающими текст. Фактически, это настоящая строка Лиспа. Когда строка появляется в нужном месте в определении функции или переменной, она служит документацией функции или переменной.</target>
        </trans-unit>
        <trans-unit id="14c8ca9284b667313f9526899ae4f3c60147c600" translate="yes" xml:space="preserve">
          <source>A double dashed line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">Двойная пунктирная линия в цвете переднего плана меню.</target>
        </trans-unit>
        <trans-unit id="813cbcdafcb879f3a5a1bf64906fb09751530f37" translate="yes" xml:space="preserve">
          <source>A double line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">Двойная линия в цвете переднего плана меню.</target>
        </trans-unit>
        <trans-unit id="d311dc731460b00910cb74c5f2364a3a8671a3b6" translate="yes" xml:space="preserve">
          <source>A doubly-linked chain of &lt;em&gt;nodes&lt;/em&gt;, each of which contains:</source>
          <target state="translated">Двусвязная цепочка &lt;em&gt;узлов&lt;/em&gt; , каждая из которых содержит:</target>
        </trans-unit>
        <trans-unit id="670af85a0c88c05fba929b7f913f66bc95166bf6" translate="yes" xml:space="preserve">
          <source>A face defines a graphics style for text characters: font, colors, etc.</source>
          <target state="translated">Лицо определяет графический стиль для текстовых символов:шрифт,цвета и т.д.</target>
        </trans-unit>
        <trans-unit id="726bfb1c0aec1ad9ae708b0d3d1b5d85a1cfcd7c" translate="yes" xml:space="preserve">
          <source>A face name (a symbol or string).</source>
          <target state="translated">Имя лица (символ или строка).</target>
        </trans-unit>
        <trans-unit id="4514d72359a84b597e6e68ca7f1afce732ca5d0d" translate="yes" xml:space="preserve">
          <source>A feature name is a symbol that stands for a collection of functions, variables, etc. The file that defines them should &lt;em&gt;provide&lt;/em&gt; the feature. Another program that uses them may ensure they are defined by &lt;em&gt;requiring&lt;/em&gt; the feature. This loads the file of definitions if it hasn&amp;rsquo;t been loaded already.</source>
          <target state="translated">Имя функции - это символ, обозначающий набор функций, переменных и т. Д. Файл, определяющий их, должен &lt;em&gt;предоставлять&lt;/em&gt; эту функцию. Другая программа, которая их использует, может гарантировать, что они определены, &lt;em&gt;требуя&lt;/em&gt; эту функцию. Это загружает файл определений, если он еще не был загружен.</target>
        </trans-unit>
        <trans-unit id="99c5746bfcdeb35c064b9bea4ccd10d38344ce46" translate="yes" xml:space="preserve">
          <source>A few Lisp variables are &lt;em&gt;terminal-local&lt;/em&gt;; that is, they have a separate binding for each terminal. The binding in effect at any time is the one for the terminal that the currently selected frame belongs to. These variables include &lt;code&gt;default-minibuffer-frame&lt;/code&gt;, &lt;code&gt;defining-kbd-macro&lt;/code&gt;, &lt;code&gt;last-kbd-macro&lt;/code&gt;, and &lt;code&gt;system-key-alist&lt;/code&gt;. They are always terminal-local, and can never be buffer-local (see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;).</source>
          <target state="translated">Несколько переменных Lisp являются &lt;em&gt;локальными для терминала&lt;/em&gt; ; то есть у них есть отдельная привязка для каждого терминала. В любое время действует привязка для терминала, которому принадлежит текущий выбранный кадр. Эти переменные включают &lt;code&gt;default-minibuffer-frame&lt;/code&gt; , &lt;code&gt;defining-kbd-macro&lt;/code&gt; , &lt;code&gt;last-kbd-macro&lt;/code&gt; и &lt;code&gt;system-key-alist&lt;/code&gt; . Они всегда являются локальными для терминала и никогда не могут быть локальными для буфера (см. &amp;laquo; &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Локальные переменные буфера&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ef5e8cbc36482886f084f025163f8eb73160f6da" translate="yes" xml:space="preserve">
          <source>A few fundamental object types are built into Emacs. These, from which all other types are constructed, are called &lt;em&gt;primitive types&lt;/em&gt;. Each object belongs to one and only one primitive type. These types include &lt;em&gt;integer&lt;/em&gt;, &lt;em&gt;float&lt;/em&gt;, &lt;em&gt;cons&lt;/em&gt;, &lt;em&gt;symbol&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;vector&lt;/em&gt;, &lt;em&gt;hash-table&lt;/em&gt;, &lt;em&gt;subr&lt;/em&gt;, &lt;em&gt;byte-code function&lt;/em&gt;, and &lt;em&gt;record&lt;/em&gt;, plus several special types, such as &lt;em&gt;buffer&lt;/em&gt;, that are related to editing. (See &lt;a href=&quot;editing-types#Editing-Types&quot;&gt;Editing Types&lt;/a&gt;.)</source>
          <target state="translated">В Emacs встроено несколько основных типов объектов. Они, из которых состоят все остальные типы, называются &lt;em&gt;примитивными типами&lt;/em&gt; . Каждый объект принадлежит к одному и только одному примитивному типу. Эти типы включают &lt;em&gt;целое число&lt;/em&gt; , &lt;em&gt;число с &lt;/em&gt;&lt;em&gt;плавающей запятой&lt;/em&gt; , &lt;em&gt;cons&lt;/em&gt; , &lt;em&gt;символ&lt;/em&gt; , &lt;em&gt;строку&lt;/em&gt; , &lt;em&gt;вектор&lt;/em&gt; , &lt;em&gt;хэш-таблицу&lt;/em&gt; , &lt;em&gt;subr&lt;/em&gt; , &lt;em&gt;функцию байтового кода&lt;/em&gt; и &lt;em&gt;запись&lt;/em&gt; , а также несколько специальных типов, таких как &lt;em&gt;буфер&lt;/em&gt; , которые связаны с редактированием. (См. &lt;a href=&quot;editing-types#Editing-Types&quot;&gt;Типы редактирования&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="2109a9b0cfa4198eb2ea0694b1fee3a782f0b966" translate="yes" xml:space="preserve">
          <source>A few other event types represent occurrences within the system.</source>
          <target state="translated">Несколько других типов событий представляют собой события внутри системы.</target>
        </trans-unit>
        <trans-unit id="1ff9d92dab390c666f58e186968e826c0b79fcf0" translate="yes" xml:space="preserve">
          <source>A few things to note:</source>
          <target state="translated">Отметим кое-что:</target>
        </trans-unit>
        <trans-unit id="86b66daa5d856aaa51ac94ff6f958584a9ddc1e1" translate="yes" xml:space="preserve">
          <source>A field is a range of consecutive characters in the buffer that are identified by having the same value (comparing with &lt;code&gt;eq&lt;/code&gt;) of the &lt;code&gt;field&lt;/code&gt; property (either a text-property or an overlay property). This section describes special functions that are available for operating on fields.</source>
          <target state="translated">Поле - это диапазон последовательных символов в буфере, которые идентифицируются по тому же значению (по сравнению с &lt;code&gt;eq&lt;/code&gt; ) свойства &lt;code&gt;field&lt;/code&gt; (либо свойства текста, либо свойства наложения). В этом разделе описаны специальные функции, доступные для работы с полями.</target>
        </trans-unit>
        <trans-unit id="2edac8714c37f5d4697daa8ef9c7fbc14208533e" translate="yes" xml:space="preserve">
          <source>A field specification generally has the form &lt;code&gt;([&lt;var&gt;name&lt;/var&gt;]
&lt;var&gt;handler&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;name&lt;/var&gt; is optional. Don&amp;rsquo;t use names that are symbols meaningful as type specifications (above) or handler specifications (below), since that would be ambiguous. &lt;var&gt;name&lt;/var&gt; can be a symbol or an expression &lt;code&gt;(eval &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt;, in which case &lt;var&gt;form&lt;/var&gt; should evaluate to a symbol.</source>
          <target state="translated">Спецификация поля обычно имеет форму &lt;code&gt;([&lt;var&gt;name&lt;/var&gt;] &lt;var&gt;handler&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;name&lt;/var&gt; является обязательным. Не используйте имена, которые являются символами, значимыми в качестве спецификаций типа (выше) или спецификаций обработчиков (ниже), поскольку это будет неоднозначно. &lt;var&gt;name&lt;/var&gt; может быть символом или выражением &lt;code&gt;(eval &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt; , и в этом случае &lt;var&gt;form&lt;/var&gt; должна оцениваться как символ.</target>
        </trans-unit>
        <trans-unit id="66e349966ac46496fe078cf6419a73b28e3d4fe7" translate="yes" xml:space="preserve">
          <source>A field&amp;rsquo;s &lt;em&gt;type&lt;/em&gt; describes the size (in bytes) of the object that the field represents and, in the case of multibyte fields, how the bytes are ordered within the field. The two possible orderings are &lt;em&gt;big endian&lt;/em&gt; (also known as &amp;ldquo;network byte ordering&amp;rdquo;) and &lt;em&gt;little endian&lt;/em&gt;. For instance, the number &lt;code&gt;#x23cd&lt;/code&gt; (decimal 9165) in big endian would be the two bytes &lt;code&gt;#x23&lt;/code&gt;&lt;code&gt;#xcd&lt;/code&gt;; and in little endian, &lt;code&gt;#xcd&lt;/code&gt;&lt;code&gt;#x23&lt;/code&gt;. Here are the possible type values:</source>
          <target state="translated">Поле в &lt;em&gt;типе&lt;/em&gt; описывает размер (в байтах) объект , что поле представляет и, в случае многобайтовых полей, как байты упорядочены в пределах поля. Двумя возможными порядками являются &lt;em&gt;прямой порядок байтов&lt;/em&gt; (также известный как &amp;laquo;сетевой порядок байтов&amp;raquo;) и &lt;em&gt;прямой порядок байтов&lt;/em&gt; . Например, число &lt;code&gt;#x23cd&lt;/code&gt; (десятичное 9165) в обратном порядке байтов будет двумя байтами &lt;code&gt;#x23&lt;/code&gt; &lt;code&gt;#xcd&lt;/code&gt; ; и с &lt;code&gt;#xcd&lt;/code&gt; байтов, #xcd &lt;code&gt;#x23&lt;/code&gt; . Вот возможные значения типов:</target>
        </trans-unit>
        <trans-unit id="580694942b3d2554858d2f62daeabff74c0c3401" translate="yes" xml:space="preserve">
          <source>A file and a buffer are two different things. A file is information recorded permanently in the computer (unless you delete it). A buffer, on the other hand, is information inside of Emacs that will vanish at the end of the editing session (or when you kill the buffer). When a buffer is visiting a file, it contains information copied from the file. The copy in the buffer is what you modify with editing commands. Changes to the buffer do not change the file; to make the changes permanent, you must &lt;em&gt;save&lt;/em&gt; the buffer, which means copying the altered buffer contents back into the file.</source>
          <target state="translated">Файл и буфер - это разные вещи. Файл - это информация, постоянно записанная на компьютере (если вы не удалите его). С другой стороны, буфер - это информация внутри Emacs, которая исчезнет в конце сеанса редактирования (или когда вы уничтожите буфер). Когда буфер обращается к файлу, он содержит информацию, скопированную из файла. Копия в буфере - это то, что вы изменяете с помощью команд редактирования. Изменения в буфере не изменяют файл; чтобы сделать изменения постоянными, вы должны &lt;em&gt;сохранить&lt;/em&gt; буфер, что означает копирование измененного содержимого буфера обратно в файл.</target>
        </trans-unit>
        <trans-unit id="b6520ff9ddc77c2a9c18bbbb20d48bf4fa9f59b0" translate="yes" xml:space="preserve">
          <source>A file can specify local variable values; Emacs uses these to create buffer-local bindings for those variables in the buffer visiting that file. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Variables.html#File-Variables&quot;&gt;Local Variables in Files&lt;/a&gt; in</source>
          <target state="translated">Файл может указывать значения локальных переменных; Emacs использует их для создания локальных привязок буфера для этих переменных в буфере, обращающемся к этому файлу. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Variables.html#File-Variables&quot;&gt;Локальные переменные в файлах&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="21698fcfb1a04898a93dfafbf4890ef6debb4d28" translate="yes" xml:space="preserve">
          <source>A file can specify local variable values; Emacs uses these to create buffer-local bindings for those variables in the buffer visiting that file. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/File-Variables.html#File-Variables&quot;&gt;Local Variables in Files&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d614f30d1cecac0c2819f4acd5ac1120709f5e0" translate="yes" xml:space="preserve">
          <source>A file name handler can have an &lt;code&gt;operations&lt;/code&gt; property to declare which operations it handles in a nontrivial way. If this property has a non-&lt;code&gt;nil&lt;/code&gt; value, it should be a list of operations; then only those operations will call the handler. This avoids inefficiency, but its main purpose is for autoloaded handler functions, so that they won&amp;rsquo;t be loaded except when they have real work to do.</source>
          <target state="translated">Обработчик имени файла может иметь свойство &lt;code&gt;operations&lt;/code&gt; чтобы объявлять, какие операции он обрабатывает нетривиальным способом. Если это свойство имеет &lt;code&gt;nil&lt;/code&gt; значение, это должен быть список операций; тогда только эти операции вызовут обработчик. Это позволяет избежать неэффективности, но его основная цель - для функций-обработчиков с автозагрузкой, так что они не будут загружаться, кроме случаев, когда у них есть реальная работа.</target>
        </trans-unit>
        <trans-unit id="1088e5bc43c1b7e8706e14f51cbd3a0578264ad7" translate="yes" xml:space="preserve">
          <source>A file name of an existing file (see &lt;a href=&quot;file-names#File-Names&quot;&gt;File Names&lt;/a&gt;). The default directory is &lt;code&gt;default-directory&lt;/code&gt;. Existing, Completion, Default, Prompt.</source>
          <target state="translated">Имя существующего файла (см. &lt;a href=&quot;file-names#File-Names&quot;&gt;Имена файлов&lt;/a&gt; ). Каталог по &lt;code&gt;default-directory&lt;/code&gt; - default-directory . Существующий, Завершение, По умолчанию, Запрос.</target>
        </trans-unit>
        <trans-unit id="990b2e19e09d588c791c9ad42c0a10ebbf4a1858" translate="yes" xml:space="preserve">
          <source>A file name. The file need not exist. Completion, Default, Prompt.</source>
          <target state="translated">Имя файла.Файл не обязательно должен существовать.Завершение,по умолчанию,быстро.</target>
        </trans-unit>
        <trans-unit id="03b87a98b8d63d5ce31e62636e7feac61dc6a158" translate="yes" xml:space="preserve">
          <source>A file name. The file need not exist. If the user enters just a directory name, then the value is just that directory name, with no file name within the directory added. Completion, Default, Prompt.</source>
          <target state="translated">Имя файла.Файл не обязательно должен существовать.Если пользователь вводит только имя каталога,то значением является только имя этого каталога,в который не добавляется имя файла.Завершение,по умолчанию,быстро.</target>
        </trans-unit>
        <trans-unit id="f353c7943be8119125e4593f00061ea9a8b8c13d" translate="yes" xml:space="preserve">
          <source>A file of saved abbrev definitions is actually a file of Lisp code. The abbrevs are saved in the form of a Lisp program to define the same abbrev tables with the same contents. Therefore, you can load the file with &lt;code&gt;load&lt;/code&gt; (see &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;How Programs Do Loading&lt;/a&gt;). However, the function &lt;code&gt;quietly-read-abbrev-file&lt;/code&gt; is provided as a more convenient interface. Emacs automatically calls this function at startup.</source>
          <target state="translated">Файл сохраненных определений сокращений на самом деле является файлом кода Лиспа. Сокращения сохраняются в форме программы на Лиспе для определения тех же таблиц сокращений с одинаковым содержанием. Следовательно, вы можете загрузить файл с помощью &lt;code&gt;load&lt;/code&gt; (см. &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;Как программы &lt;/a&gt;загружаются ). Однако функция &lt;code&gt;quietly-read-abbrev-file&lt;/code&gt; предусмотрена в качестве более удобного интерфейса. Emacs автоматически вызывает эту функцию при запуске.</target>
        </trans-unit>
        <trans-unit id="dbf75453e1d8ee103bca7101c95d3ea1b66bfa1e" translate="yes" xml:space="preserve">
          <source>A file that Emacs visits can contain variable settings that affect the buffer visiting that file; See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;. Similarly, a directory can specify local variable values common to all files in that directory; see &lt;a href=&quot;directory-local-variables#Directory-Local-Variables&quot;&gt;Directory Local Variables&lt;/a&gt;. Although Emacs takes some effort to protect against misuse of these variables, a security hole can be created merely by a package setting &lt;code&gt;safe-local-variable&lt;/code&gt; too optimistically, a problem that is all too common. To disable this feature for both files and directories, set &lt;code&gt;enable-local-variables&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Файл, который посещает Emacs, может содержать настройки переменных, которые влияют на буфер, посещающий этот файл; См. Раздел &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;Локальные переменные файла&lt;/a&gt; . Точно так же каталог может указывать значения локальных переменных, общие для всех файлов в этом каталоге; см. &lt;a href=&quot;directory-local-variables#Directory-Local-Variables&quot;&gt;Локальные переменные каталога&lt;/a&gt; . Хотя Emacs прилагает некоторые усилия для защиты от неправильного использования этих переменных, дыра в безопасности может быть создана просто из-за того, что пакет слишком оптимистично устанавливает &lt;code&gt;safe-local-variable&lt;/code&gt; , что является очень распространенной проблемой. Чтобы отключить эту функцию и для файлов, и для каталогов, установите для параметра &lt;code&gt;enable-local-variables&lt;/code&gt; значение &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3266b8d29b93dc1eee17b5d16810b5e1424e98d5" translate="yes" xml:space="preserve">
          <source>A filter function must accept two arguments: the associated process and a string, which is output just received from it. The function is then free to do whatever it chooses with the output.</source>
          <target state="translated">Функция фильтрации должна принимать два аргумента:ассоциированный процесс и строку,которая только что получена от него.Затем функция может делать с выводом все,что захочет.</target>
        </trans-unit>
        <trans-unit id="0e7a297c1c489e864c66d0212903cca52a20067e" translate="yes" xml:space="preserve">
          <source>A first argument of &lt;code&gt;lambda&lt;/code&gt; means &lt;code&gt;debug&lt;/code&gt; was called because of entry to a function when &lt;code&gt;debug-on-next-call&lt;/code&gt; was non-&lt;code&gt;nil&lt;/code&gt;. The debugger displays &amp;lsquo;</source>
          <target state="translated">Первый аргумент &lt;code&gt;lambda&lt;/code&gt; означает, что &lt;code&gt;debug&lt;/code&gt; была вызвана из-за входа в функцию, когда &lt;code&gt;debug-on-next-call&lt;/code&gt; не был равен &lt;code&gt;nil&lt;/code&gt; . Отладчик отображает '</target>
        </trans-unit>
        <trans-unit id="e8ddb397b9ffeb8426670eadecdce6f5c08372fe" translate="yes" xml:space="preserve">
          <source>A five-element vector &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; represents an IPv4 address &lt;var&gt;a&lt;/var&gt;.&lt;var&gt;b&lt;/var&gt;.&lt;var&gt;c&lt;/var&gt;.&lt;var&gt;d&lt;/var&gt; and port number &lt;var&gt;p&lt;/var&gt;. &lt;code&gt;format-network-address&lt;/code&gt; converts that to the string &lt;code&gt;&quot;&lt;var&gt;a&lt;/var&gt;.&lt;var&gt;b&lt;/var&gt;.&lt;var&gt;c&lt;/var&gt;.&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Пятиэлементный вектор &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; представляет IPv4-адрес &lt;var&gt;a&lt;/var&gt; . &lt;var&gt;b&lt;/var&gt; . &lt;var&gt;c&lt;/var&gt; . &lt;var&gt;d&lt;/var&gt; и номер порта &lt;var&gt;p&lt;/var&gt; . &lt;code&gt;format-network-address&lt;/code&gt; преобразует это в строку &lt;code&gt;&quot;&lt;var&gt;a&lt;/var&gt;.&lt;var&gt;b&lt;/var&gt;.&lt;var&gt;c&lt;/var&gt;.&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="294aaabae5d3488734428644aba3718cfd7199de" translate="yes" xml:space="preserve">
          <source>A flag specifying the type of completion operation to perform; see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;, for the details of those operations. This flag may be one of the following values.</source>
          <target state="translated">Флаг, определяющий тип выполняемой операции завершения; см. &amp;laquo; &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Базовое завершение&amp;raquo;&lt;/a&gt; для получения подробной информации об этих операциях. Этот флаг может иметь одно из следующих значений.</target>
        </trans-unit>
        <trans-unit id="85c834e95015be4c5179423bef79b80cc4828fe4" translate="yes" xml:space="preserve">
          <source>A flag, &lt;code&gt;t&lt;/code&gt; if &lt;code&gt;format-write-file&lt;/code&gt; should not remove this format from &lt;code&gt;buffer-file-format&lt;/code&gt;.</source>
          <target state="translated">Флаг, &lt;code&gt;t&lt;/code&gt; , если &lt;code&gt;format-write-file&lt;/code&gt; не должен удалять этот формат из &lt;code&gt;buffer-file-format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0b2bfadb17694a552c0239a8fd611c0d489e7e" translate="yes" xml:space="preserve">
          <source>A flag, &lt;code&gt;t&lt;/code&gt; if the encoding function modifies the buffer, and &lt;code&gt;nil&lt;/code&gt; if it works by returning a list of annotations.</source>
          <target state="translated">Флаг, &lt;code&gt;t&lt;/code&gt; , если функция кодирования изменяет буфер, и &lt;code&gt;nil&lt;/code&gt; , если он работает, возвращая список аннотаций.</target>
        </trans-unit>
        <trans-unit id="19d7f1cfc631bf26b90fef20742acf5f863fc6f4" translate="yes" xml:space="preserve">
          <source>A flag, &lt;code&gt;t&lt;/code&gt; if this is really a child process. For a network or serial connection, it is a plist based on the arguments to &lt;code&gt;make-network-process&lt;/code&gt; or &lt;code&gt;make-serial-process&lt;/code&gt;.</source>
          <target state="translated">Флаг, &lt;code&gt;t&lt;/code&gt; , если это действительно дочерний процесс. Для сетевого или последовательного подключения это список, основанный на аргументах &lt;code&gt;make-network-process&lt;/code&gt; или &lt;code&gt;make-serial-process&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d522ef7e7a7eea406919509b9022d018c559d736" translate="yes" xml:space="preserve">
          <source>A floating-point number between 0.0 and 1.0 can be used to specify the width of a frame via its &lt;em&gt;width ratio&lt;/em&gt;&amp;mdash;the ratio of its outer width (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) to the width of the frame&amp;rsquo;s workarea (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or its parent frame&amp;rsquo;s (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) native frame. Thus, a value of 0.5 makes the frame occupy half of the width of its workarea or parent frame, a value of 1.0 the full width. Similarly, the &lt;em&gt;height ratio&lt;/em&gt; of a frame is the ratio of its outer height to the height of its workarea or its parent&amp;rsquo;s native frame.</source>
          <target state="translated">Число с плавающей запятой от 0,0 до 1,0 можно использовать для указания ширины фрейма через его &lt;em&gt;отношение ширины&lt;/em&gt; - отношение его внешней ширины (см. &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Геометрия фрейма&lt;/a&gt; ) к ширине рабочей области фрейма (см. &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Несколько терминалов&lt;/a&gt; ) или его родительского элемента. собственный фрейм frame (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ). Таким образом, значение 0,5 заставляет фрейм занимать половину ширины своей рабочей области или родительского фрейма, а значение 1,0 - полной ширины. Точно так же отношение &lt;em&gt;высоты&lt;/em&gt; фрейма - это отношение его внешней высоты к высоте его рабочей области или собственного фрейма его родителя.</target>
        </trans-unit>
        <trans-unit id="40f779f8938b4859342b30f78c216850c870ebc3" translate="yes" xml:space="preserve">
          <source>A floating-point number specifies the fraction of the chosen window&amp;rsquo;s desired total height with respect to the total height of its frame&amp;rsquo;s root window.</source>
          <target state="translated">Число с плавающей запятой определяет долю желаемой общей высоты выбранного окна по отношению к общей высоте корневого окна его фрейма.</target>
        </trans-unit>
        <trans-unit id="7b2c9b14e103c32f399869f8f372059ff0758de1" translate="yes" xml:space="preserve">
          <source>A floating-point number specifies the fraction of the chosen window&amp;rsquo;s desired total width with respect to the total width of the frame&amp;rsquo;s root window.</source>
          <target state="translated">Число с плавающей запятой указывает долю желаемой общей ширины выбранного окна по отношению к общей ширине корневого окна фрейма.</target>
        </trans-unit>
        <trans-unit id="859a186fe1d162639532b367f483e64bb540ab2b" translate="yes" xml:space="preserve">
          <source>A floating-point value in the range 0.0 to 1.0 specifies the left edge&amp;rsquo;s offset via the &lt;em&gt;left position ratio&lt;/em&gt; of the frame&amp;mdash;the ratio of the left edge of its outer frame to the width of the frame&amp;rsquo;s workarea (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or its parent&amp;rsquo;s native frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) minus the width of the outer frame. Thus, a left position ratio of 0.0 flushes a frame to the left, a ratio of 0.5 centers it and a ratio of 1.0 flushes it to the right of its display or parent frame. Similarly, the &lt;em&gt;top position ratio&lt;/em&gt; of a frame is the ratio of the frame&amp;rsquo;s top position to the height of its workarea or parent frame minus the height of the frame.</source>
          <target state="translated">Значение с плавающей запятой в диапазоне от 0,0 до 1,0 определяет смещение левого края через &lt;em&gt;соотношение левого положения&lt;/em&gt; кадра - отношение левого края его внешнего кадра к ширине рабочей области кадра (см. &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Несколько терминалов&lt;/a&gt; ) или его родительской области. собственный фрейм (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ) за вычетом ширины внешнего фрейма. Таким образом, коэффициент левого положения 0,0 смещает кадр влево, коэффициент 0,5 выравнивает его по центру, а коэффициент 1,0 сбрасывает его вправо от его дисплея или родительского кадра. Точно так же отношение &lt;em&gt;верхнего положения&lt;/em&gt; кадра - это отношение верхнего положения кадра к высоте его рабочей области или родительского кадра за вычетом высоты кадра.</target>
        </trans-unit>
        <trans-unit id="17ea726a541eca726a5fb0cd7e030f18bf5f479f" translate="yes" xml:space="preserve">
          <source>A focus event in the middle of a key sequence would garble the sequence. So Emacs never generates a focus event in the middle of a key sequence. If the user changes focus in the middle of a key sequence&amp;mdash;that is, after a prefix key&amp;mdash;then Emacs reorders the events so that the focus event comes either before or after the multi-event key sequence, and not within it.</source>
          <target state="translated">Событие фокуса в середине ключевой последовательности искажает последовательность. Таким образом, Emacs никогда не генерирует событие фокуса в середине ключевой последовательности. Если пользователь меняет фокус в середине ключевой последовательности, то есть после префиксного ключа, то Emacs переупорядочивает события так, чтобы событие фокуса происходило либо до, либо после многособытийной ключевой последовательности, а не внутри нее.</target>
        </trans-unit>
        <trans-unit id="f412cfc73d389d8e515cd608573b4a6a5a02234e" translate="yes" xml:space="preserve">
          <source>A font entity is a reference to a font that need not be open. Its properties are intermediate between a font object and a font spec: like a font object, and unlike a font spec, it refers to a single, specific font. Unlike a font object, creating a font entity does not load the contents of that font into computer memory. Emacs may open multiple font objects of different sizes from a single font entity referring to a scalable font.</source>
          <target state="translated">Сущность шрифта-это ссылка на шрифт,который не обязательно должен быть открыт.Его свойства являются промежуточными между объектом шрифта и спецификацией шрифта:подобно объекту шрифта,и в отличие от спецификации шрифта,он ссылается на один,специфический шрифт.В отличие от объекта шрифта,создание объекта шрифта не загружает содержимое этого шрифта в память компьютера.Emacs может открыть несколько объектов шрифтов разного размера из одного объекта шрифта со ссылкой на масштабируемый шрифт.</target>
        </trans-unit>
        <trans-unit id="8d5b0425b5a94a9e9802d46b457503ba1cbe0cfe" translate="yes" xml:space="preserve">
          <source>A font object is a Lisp object that represents a font that Emacs has &lt;em&gt;opened&lt;/em&gt;. Font objects cannot be modified in Lisp, but they can be inspected.</source>
          <target state="translated">Объект шрифта - это объект Lisp, представляющий шрифт, &lt;em&gt;открытый&lt;/em&gt; Emacs . Объекты шрифта нельзя изменить в Лиспе, но их можно проверить.</target>
        </trans-unit>
        <trans-unit id="515cc00d7f4cb95d05c8cecf8f1e5c3622cbf2f8" translate="yes" xml:space="preserve">
          <source>A font spec is a Lisp object that contains a set of specifications that can be used to find a font. More than one font may match the specifications in a font spec.</source>
          <target state="translated">Спецификация шрифта-это объект Lisp,содержащий набор спецификаций,которые могут быть использованы для поиска шрифта.Более одного шрифта может соответствовать спецификации в спецификации шрифта.</target>
        </trans-unit>
        <trans-unit id="fbb519c5d7bda3b24f3aefb7d9c3e252c108c2df" translate="yes" xml:space="preserve">
          <source>A fontset is a collection of fonts that handle a range of character sets.</source>
          <target state="translated">Шрифт-это коллекция шрифтов,которые обрабатывают различные наборы символов.</target>
        </trans-unit>
        <trans-unit id="b1d4702f683ffb2a5355d8008fca5fe3ad8ec6be" translate="yes" xml:space="preserve">
          <source>A form that is a nonempty list is either a function call, a macro call, or a special form, according to its first element. These three kinds of forms are evaluated in different ways, described below. The remaining list elements constitute the &lt;em&gt;arguments&lt;/em&gt; for the function, macro, or special form.</source>
          <target state="translated">Форма, которая является непустым списком, является либо вызовом функции, либо вызовом макроса, либо специальной формой в соответствии с ее первым элементом. Эти три вида форм оцениваются разными способами, описанными ниже. Остальные элементы списка представляют собой &lt;em&gt;аргументы&lt;/em&gt; для функции, макроса или специальной формы.</target>
        </trans-unit>
        <trans-unit id="a12bc97651e58ff453885efcc98152a3b21b8d9d" translate="yes" xml:space="preserve">
          <source>A format specification can have a &lt;em&gt;field number&lt;/em&gt;, which is a decimal number immediately after the initial &amp;lsquo;</source>
          <target state="translated">В спецификации формата может быть номер &lt;em&gt;поля&lt;/em&gt; , который является десятичным числом сразу после начального '</target>
        </trans-unit>
        <trans-unit id="c8844cc8b244f02d7287631d0e9e57e8bd2d710d" translate="yes" xml:space="preserve">
          <source>A format specification can include any number of the following flag characters immediately after the &amp;lsquo;</source>
          <target state="translated">Спецификация формата может включать любое количество следующих символов флага сразу после '</target>
        </trans-unit>
        <trans-unit id="33f8eb1db79183d4a02ee42a34f4def26f563ba0" translate="yes" xml:space="preserve">
          <source>A format specification is a sequence of characters beginning with a &amp;lsquo;</source>
          <target state="translated">Спецификация формата - это последовательность символов, начинающаяся с символа '</target>
        </trans-unit>
        <trans-unit id="087e2b9c7736fb58cedc9236190680cf120fd098" translate="yes" xml:space="preserve">
          <source>A frame has many parameters that control its appearance and behavior. Just what parameters a frame has depends on what display mechanism it uses.</source>
          <target state="translated">У кадра есть много параметров,которые контролируют его внешний вид и поведение.Только то,какие параметры имеет кадр,зависит от того,какой механизм отображения он использует.</target>
        </trans-unit>
        <trans-unit id="8bed1cbe065649aba77e0f7bf1ff4e6629da4bbb" translate="yes" xml:space="preserve">
          <source>A frame initially contains a single main window and/or a minibuffer window; you can subdivide the main window vertically or horizontally into smaller windows. See &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;.</source>
          <target state="translated">Фрейм изначально содержит одно главное окно и / или окно минибуфера; вы можете разделить главное окно по вертикали или горизонтали на меньшие окна. См. &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Разделение окон&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="593d0194673ec750d2ada7934d7770635b502d64" translate="yes" xml:space="preserve">
          <source>A frame is &lt;em&gt;dominated&lt;/em&gt; by a physical monitor when either the largest area of the frame resides in that monitor, or (if the frame does not intersect any physical monitors) that monitor is the closest to the frame. Every (non-tooltip) frame (whether visible or not) in a graphical display is dominated by exactly one physical monitor at a time, though the frame can span multiple (or no) physical monitors.</source>
          <target state="translated">В кадре &lt;em&gt;преобладает&lt;/em&gt; физический монитор, когда либо на этом мониторе находится самая большая область кадра, либо (если кадр не пересекается с какими-либо физическими мониторами) тот монитор является ближайшим к кадру. Каждый (не всплывающий) кадр (видимый или нет) на графическом дисплее определяется одновременно только одним физическим монитором, хотя кадр может охватывать несколько (или не включать) физических мониторов.</target>
        </trans-unit>
        <trans-unit id="93e41b196f539a42aa80f80a422bd9a7138a3f5f" translate="yes" xml:space="preserve">
          <source>A frame means consider windows on that frame only.</source>
          <target state="translated">Рамка означает рассматривать окна только на этой раме.</target>
        </trans-unit>
        <trans-unit id="0ac0546e4fcf2e06468d2e59e1b006fdfd50ee70" translate="yes" xml:space="preserve">
          <source>A frame means operate on that frame.</source>
          <target state="translated">Рамка означает работу на этой раме.</target>
        </trans-unit>
        <trans-unit id="56626d51f944fb36b16d03134023ca4666a8b106" translate="yes" xml:space="preserve">
          <source>A frame means to consider windows on that specific frame.</source>
          <target state="translated">Рамка означает учитывать окна на этой конкретной раме.</target>
        </trans-unit>
        <trans-unit id="68b2b2ef5f1170f2f9547a6799c6765e7406978b" translate="yes" xml:space="preserve">
          <source>A frame on a graphical display may be &lt;em&gt;visible&lt;/em&gt;, &lt;em&gt;invisible&lt;/em&gt;, or &lt;em&gt;iconified&lt;/em&gt;. If it is visible, its contents are displayed in the usual manner. If it is iconified, its contents are not displayed, but there is a little icon somewhere to bring the frame back into view (some window managers refer to this state as &lt;em&gt;minimized&lt;/em&gt; rather than &lt;em&gt;iconified&lt;/em&gt;, but from Emacs&amp;rsquo; point of view they are the same thing). If a frame is invisible, it is not displayed at all.</source>
          <target state="translated">Рамка на графическом дисплее может быть &lt;em&gt;видимой&lt;/em&gt; , &lt;em&gt;невидимой&lt;/em&gt; или &lt;em&gt;отображаемой в виде значков&lt;/em&gt; . Если он виден, его содержимое отображается обычным образом. Если он обозначен значком, его содержимое не отображается, но где-то есть маленький значок, чтобы вернуть фрейм в поле зрения (некоторые оконные менеджеры называют это состояние &lt;em&gt;свернутым,&lt;/em&gt; а не &lt;em&gt;значком&lt;/em&gt; , но с точки зрения Emacs они такие же предмет). Если фрейм невидим, он вообще не отображается.</target>
        </trans-unit>
        <trans-unit id="ae91a9bb638c7946c6a95ecd4004f1135f49e80a" translate="yes" xml:space="preserve">
          <source>A frame that is moved with the mouse will &amp;ldquo;snap&amp;rdquo; at the border(s) of the display or its parent frame whenever it is dragged as near to such an edge as the number of pixels specified by this parameter.</source>
          <target state="translated">Кадр, который перемещается с помощью мыши, будет &amp;laquo;защелкиваться&amp;raquo; на границе (ах) дисплея или его родительского кадра всякий раз, когда его перетаскивают так близко к такому краю, как количество пикселей, указанное этим параметром.</target>
        </trans-unit>
        <trans-unit id="670133cb3dcebb82274414d4049e8b018c47f4e1" translate="yes" xml:space="preserve">
          <source>A full explanation of these matters is outside the scope of this manual. For more information on cryptographic keys and signing, see &lt;a href=&quot;http://www.gnupg.org/documentation/manuals/gnupg/index.html#Top&quot;&gt;GnuPG&lt;/a&gt; in</source>
          <target state="translated">Полное объяснение этих вопросов выходит за рамки данного руководства. Для получения дополнительной информации о криптографических ключах и подписи см. &lt;a href=&quot;http://www.gnupg.org/documentation/manuals/gnupg/index.html#Top&quot;&gt;GnuPG&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="c3c28c82ddfdaeda8235f4e0fc4a57244d0db1be" translate="yes" xml:space="preserve">
          <source>A full explanation of these matters is outside the scope of this manual. For more information on cryptographic keys and signing, see &lt;a href=&quot;https://www.gnupg.org/documentation/manuals/gnupg/index.html#Top&quot;&gt;GnuPG&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59af6565c9508dfc20c12f2304360ecea3059d7" translate="yes" xml:space="preserve">
          <source>A full keymap for</source>
          <target state="translated">Полная карта-клавиатура для</target>
        </trans-unit>
        <trans-unit id="5e8dd76e935bb817d46b7e5de1c0f84394fd67d9" translate="yes" xml:space="preserve">
          <source>A full keymap is more efficient than a sparse keymap when it holds lots of bindings; for just a few, the sparse keymap is better.</source>
          <target state="translated">Полная раскладка более эффективна,чем разреженная раскладка,когда она содержит большое количество связок;для некоторых из них разреженная раскладка лучше.</target>
        </trans-unit>
        <trans-unit id="49a156dad931da06b08d870486bd7a2b697afdab" translate="yes" xml:space="preserve">
          <source>A full keymap used by the help utility package. It has the same keymap in its value cell and in its function cell.</source>
          <target state="translated">Полная клавиатурная карта,используемая в пакете справочной утилиты.В ячейке значений и в ячейке функций она имеет одну и ту же раскладку.</target>
        </trans-unit>
        <trans-unit id="6509b7476dce0a2a745fa522309b5b12d6ec47f5" translate="yes" xml:space="preserve">
          <source>A full keymap used in the minibuffer when it is not active. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-Edit.html#Minibuffer-Edit&quot;&gt;Editing in the Minibuffer&lt;/a&gt; in</source>
          <target state="translated">Полная раскладка клавиатуры, используемая в минибуфере, когда он не активен. См. Раздел &amp;laquo; &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-Edit.html#Minibuffer-Edit&quot;&gt;Редактирование в минибуфере&amp;raquo;&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="7fc67dd75c99b27d5bd0cadb6710ef0dc2139f83" translate="yes" xml:space="preserve">
          <source>A full keymap used in the minibuffer when it is not active. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-Edit.html#Minibuffer-Edit&quot;&gt;Editing in the Minibuffer&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbb4ffda897b3f130c2ffc336b839e6d176be06" translate="yes" xml:space="preserve">
          <source>A function (in the strict sense, i.e., a function object) which is written in Lisp. These are described in the following section. See &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;.</source>
          <target state="translated">Функция (в строгом смысле, т.е. объект функции), написанная на Лиспе. Они описаны в следующем разделе. См. &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Лямбда-выражения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67975cc366b5448faeb9a64ea486c485cf194102" translate="yes" xml:space="preserve">
          <source>A function form: either a quoted function symbol, a quoted lambda expression, or a form (that should evaluate to a function symbol or lambda expression). This is useful when an argument that&amp;rsquo;s a lambda expression might be quoted with &lt;code&gt;quote&lt;/code&gt; rather than &lt;code&gt;function&lt;/code&gt;, since it instruments the body of the lambda expression either way.</source>
          <target state="translated">Функциональная форма: либо цитируемый функциональный символ, цитируемое лямбда-выражение, либо форма (которая должна оцениваться как функциональный символ или лямбда-выражение). Это полезно, когда аргумент, являющийся лямбда-выражением, может быть заключен в &lt;code&gt;quote&lt;/code&gt; а не &lt;code&gt;function&lt;/code&gt; , поскольку он в любом случае инструментирует тело лямбда-выражения.</target>
        </trans-unit>
        <trans-unit id="74cc8825cac1c75201b5a72537a42bcaa095f7bf" translate="yes" xml:space="preserve">
          <source>A function in &lt;code&gt;completion-at-point-functions&lt;/code&gt; may also return a function instead of a list as described above. In that case, that returned function is called, with no argument, and it is entirely responsible for performing the completion. We discourage this usage; it is only intended to help convert old code to using &lt;code&gt;completion-at-point&lt;/code&gt;.</source>
          <target state="translated">Функция в функциях &lt;code&gt;completion-at-point-functions&lt;/code&gt; может также возвращать функцию вместо списка, как описано выше. В этом случае эта возвращенная функция вызывается без аргументов, и она полностью отвечает за выполнение завершения. Мы не приветствуем такое использование; он предназначен только для того, чтобы помочь преобразовать старый код для использования функции &lt;code&gt;completion-at-point&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3967a503993e60af7034808c468508aae1885fb4" translate="yes" xml:space="preserve">
          <source>A function is a Lisp program that can be invoked from other functions.</source>
          <target state="translated">Функция-это программа на языке Lisp,которая может быть вызвана из других функций.</target>
        </trans-unit>
        <trans-unit id="88717033307ab176f0284b52276d93ae668d8d38" translate="yes" xml:space="preserve">
          <source>A function is never considered to be called interactively if it was called via Lisp evaluation (or with &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;funcall&lt;/code&gt;).</source>
          <target state="translated">Функция никогда не считается вызываемой в интерактивном режиме, если она была вызвана посредством вычисления Lisp (или с помощью &lt;code&gt;apply&lt;/code&gt; или &lt;code&gt;funcall&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="45f7858322522afa6344fc4aadc6540f15152ac3" translate="yes" xml:space="preserve">
          <source>A function name (i.e., a symbol satisfying &lt;code&gt;fboundp&lt;/code&gt;). Existing, Completion, Prompt.</source>
          <target state="translated">Имя функции (то есть символ, удовлетворяющий &lt;code&gt;fboundp&lt;/code&gt; ). Существующий, Завершение, Подсказка.</target>
        </trans-unit>
        <trans-unit id="6604e0025d3d7acaa51d09313c30002d7a8a0abd" translate="yes" xml:space="preserve">
          <source>A function need not have a unique name. A given function object &lt;em&gt;usually&lt;/em&gt; appears in the function cell of only one symbol, but this is just a convention. It is easy to store it in several symbols using &lt;code&gt;fset&lt;/code&gt;; then each of the symbols is a valid name for the same function.</source>
          <target state="translated">Функция не обязательно должна иметь уникальное имя. Данный функциональный объект &lt;em&gt;обычно&lt;/em&gt; появляется в функциональной ячейке только одного символа, но это всего лишь соглашение. Его легко сохранить в нескольких символах с помощью &lt;code&gt;fset&lt;/code&gt; ; тогда каждый из символов является допустимым именем для одной и той же функции.</target>
        </trans-unit>
        <trans-unit id="8cefa34de359ec87bedfc8878b6eeae0d47b4baa" translate="yes" xml:space="preserve">
          <source>A function object that is much like a lambda expression, except that it also encloses an environment of lexical variable bindings. See &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;.</source>
          <target state="translated">Функциональный объект, который очень похож на лямбда-выражение, за исключением того, что он также включает в себя среду привязок лексических переменных. См. &lt;a href=&quot;closures#Closures&quot;&gt;Замыкания&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f48b6522b5235b501de8a062f2f445bd67cb08a" translate="yes" xml:space="preserve">
          <source>A function run by Edebug after it wraps the body of a definition or closure. After Edebug has initialized its own data, this function is called with one argument, the symbol associated with the definition, which may be the actual symbol defined or one generated by Edebug. This function may be used to set the &lt;code&gt;edebug-behavior&lt;/code&gt; symbol property of each definition instrumented by Edebug.</source>
          <target state="translated">Функция, запускаемая Edebug после того, как она обертывает тело определения или замыкания. После того, как Edebug инициализировал свои собственные данные, эта функция вызывается с одним аргументом, символом, связанным с определением, который может быть фактическим символом, определенным или созданным Edebug. Эта функция может использоваться для установки &lt;code&gt;edebug-behavior&lt;/code&gt; символа edebug-behavior для каждого определения, инструментированного Edebug.</target>
        </trans-unit>
        <trans-unit id="c7a8cbef03050f5100566a91d08438e778fff88b" translate="yes" xml:space="preserve">
          <source>A function run just before redisplay. It is called with one argument, the set of windows to be redisplayed. The set can be &lt;code&gt;nil&lt;/code&gt;, meaning only the selected window, or &lt;code&gt;t&lt;/code&gt;, meaning all the windows.</source>
          <target state="translated">Функция запускается непосредственно перед повторным отображением. Он вызывается с одним аргументом - набором окон, которые необходимо повторно отобразить. Набор может быть равен &lt;code&gt;nil&lt;/code&gt; , что означает только выбранное окно, или &lt;code&gt;t&lt;/code&gt; , что означает все окна.</target>
        </trans-unit>
        <trans-unit id="2170a7820bb4235d6aaed2f87dfc349064f9aeed" translate="yes" xml:space="preserve">
          <source>A function that has been compiled by the byte compiler. See &lt;a href=&quot;byte_002dcode-type#Byte_002dCode-Type&quot;&gt;Byte-Code Type&lt;/a&gt;.</source>
          <target state="translated">Функция, скомпилированная байтовым компилятором. См. &lt;a href=&quot;byte_002dcode-type#Byte_002dCode-Type&quot;&gt;Тип байтового кода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="514106b81c0fc955cf778a8f7e3aa693d74773cb" translate="yes" xml:space="preserve">
          <source>A function that takes three arguments&amp;mdash;the &lt;var&gt;window&lt;/var&gt; argument of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;, a buffer &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; intends to switch to and the &lt;var&gt;bury-or-kill&lt;/var&gt; argument of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;. If that function returns non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; will refrain from switching to the buffer specified by the second argument.</source>
          <target state="translated">Функция, которая принимает три аргумента: аргумент &lt;var&gt;window&lt;/var&gt; для &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; , буфер &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; ,на который намеревается переключиться, и аргумент &lt;var&gt;bury-or-kill&lt;/var&gt; для &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; . Если эта функция возвращает &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; будет воздерживаться от переключения на буфер, указанный вторым аргументом.</target>
        </trans-unit>
        <trans-unit id="19663365a712443cf17b0462d9e95ba641121528" translate="yes" xml:space="preserve">
          <source>A function which is callable from Lisp but is actually written in C. Primitives are also called &lt;em&gt;built-in functions&lt;/em&gt;, or &lt;em&gt;subrs&lt;/em&gt;. Examples include functions like &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;append&lt;/code&gt;. In addition, all special forms (see below) are also considered primitives.</source>
          <target state="translated">Функция, которая вызывается из Лиспа, но на самом деле написана на C. Примитивы также называются &lt;em&gt;встроенными функциями&lt;/em&gt; или &lt;em&gt;подпрограммами&lt;/em&gt; . Примеры включают такие функции, как &lt;code&gt;car&lt;/code&gt; и &lt;code&gt;append&lt;/code&gt; . Кроме того, все специальные формы (см. Ниже) также считаются примитивами.</target>
        </trans-unit>
        <trans-unit id="1b46c595245dc0dbb005afc3ecbbdd47644569b0" translate="yes" xml:space="preserve">
          <source>A function written in C, callable from Lisp.</source>
          <target state="translated">Функция,написанная на C,вызываемая из Lisp.</target>
        </trans-unit>
        <trans-unit id="de877f0e31d6955ec95f1fb5f2fd10d5638c9689" translate="yes" xml:space="preserve">
          <source>A function written in Lisp, then compiled.</source>
          <target state="translated">Функция,написанная на языке Лисп,затем скомпилированная.</target>
        </trans-unit>
        <trans-unit id="c9d8c9cc7681ee2ca63be007d65e384b9608592a" translate="yes" xml:space="preserve">
          <source>A general syntax for cons cells.</source>
          <target state="translated">Общий синтаксис для конс-клеток.</target>
        </trans-unit>
        <trans-unit id="137d4bfab02523c448bc31f5a48ba6b6d8486e12" translate="yes" xml:space="preserve">
          <source>A generalized variable. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">Обобщенная переменная. См. &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Обобщенные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ebf8b963e8ef8255cbf815c795b5ed45d06bb96" translate="yes" xml:space="preserve">
          <source>A generic function specifies an abstract operation, by defining its name and list of arguments, but (usually) no implementation. The actual implementation for several specific classes of arguments is provided by &lt;em&gt;methods&lt;/em&gt;, which should be defined separately. Each method that implements a generic function has the same name as the generic function, but the method&amp;rsquo;s definition indicates what kinds of arguments it can handle by &lt;em&gt;specializing&lt;/em&gt; the arguments defined by the generic function. These &lt;em&gt;argument specializers&lt;/em&gt; can be more or less specific; for example, a &lt;code&gt;string&lt;/code&gt; type is more specific than a more general type, such as &lt;code&gt;sequence&lt;/code&gt;.</source>
          <target state="translated">Универсальная функция определяет абстрактную операцию, определяя ее имя и список аргументов, но (обычно) без реализации. Фактическая реализация для нескольких конкретных классов аргументов обеспечивается &lt;em&gt;методами&lt;/em&gt; , которые следует определять отдельно. Каждый метод, реализующий универсальную функцию, имеет то же имя, что и универсальная функция, но определение метода указывает, какие типы аргументов он может обрабатывать, &lt;em&gt;специализируя&lt;/em&gt; аргументы, определенные универсальной функцией. Эти &lt;em&gt;специализаторы аргументов&lt;/em&gt; могут быть более или менее конкретными; например, &lt;code&gt;string&lt;/code&gt; тип более конкретен, чем более общий тип, такой как &lt;code&gt;sequence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce1f0389bfeda46a5ea7bd2acc7f288b0381d8d8" translate="yes" xml:space="preserve">
          <source>A good indentation function will usually need to actually parse the text, according to the syntax of the language. Luckily, it is not necessary to parse the text in as much detail as would be needed for a compiler, but on the other hand, the parser embedded in the indentation code will want to be somewhat friendly to syntactically incorrect code.</source>
          <target state="translated">Хорошая функция отступов обычно требует фактического разбора текста в соответствии с синтаксисом языка.К счастью,нет необходимости разбирать текст так подробно,как это было бы необходимо компилятору,но,с другой стороны,парсер,встроенный в код с отступом,захочет быть несколько дружелюбным к синтаксически некорректному коду.</target>
        </trans-unit>
        <trans-unit id="3411c17220662ceffaaf0e39a2c3512afe57639f" translate="yes" xml:space="preserve">
          <source>A hash table (see &lt;a href=&quot;hash-table-type#Hash-Table-Type&quot;&gt;Hash Table Type&lt;/a&gt;).</source>
          <target state="translated">Хеш-таблица (см. &lt;a href=&quot;hash-table-type#Hash-Table-Type&quot;&gt;Тип хеш-таблицы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cb7e4bf96a133b1dfdd48a75ed263d4f15112488" translate="yes" xml:space="preserve">
          <source>A hash table is a very fast kind of lookup table, somewhat like an alist (see &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Association Lists&lt;/a&gt;) in that it maps keys to corresponding values. It differs from an alist in these ways:</source>
          <target state="translated">Хеш-таблица - это очень быстрый вид таблицы поиска, чем-то похожий на список (см. &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Списки ассоциаций&lt;/a&gt; ), в котором ключи сопоставляются с соответствующими значениями. Он отличается от алиста следующим образом:</target>
        </trans-unit>
        <trans-unit id="5f8d7c7212fe9badba0bb89235cd56e06f21bd8a" translate="yes" xml:space="preserve">
          <source>A hash table is a very fast kind of lookup table, somewhat like an alist in that it maps keys to corresponding values, but much faster. The printed representation of a hash table specifies its properties and contents, like this:</source>
          <target state="translated">Хэш-таблица-это очень быстрый вид таблицы поиска,немного похожий на алист в том,что он сопоставляет ключи к соответствующим значениям,но гораздо быстрее.Печатное представление хэш-таблицы задает ее свойства и содержимое,подобно этому:</target>
        </trans-unit>
        <trans-unit id="d6be75f4157848f03320b85454c8ed3e94f490ce" translate="yes" xml:space="preserve">
          <source>A header of type &lt;code&gt;union vectorlike_header&lt;/code&gt; is common to all vectorlike objects.</source>
          <target state="translated">Заголовок типа &lt;code&gt;union vectorlike_header&lt;/code&gt; является общим для всех векторных объектов.</target>
        </trans-unit>
        <trans-unit id="bc19b5ecba8524e89dd4b02718fefc5d6d8c187a" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are Lisp expressions to evaluate.</source>
          <target state="translated">Список истории для аргументов,которые являются выражениями Lisp для оценки.</target>
        </trans-unit>
        <trans-unit id="d29cbee4e05656304ef83f82b3f1d36d6c40950e" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are faces.</source>
          <target state="translated">Исторический список аргументов,которые являются лицами.</target>
        </trans-unit>
        <trans-unit id="a95052be4b299ec23859e52b4286287e5de16378" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are names of extended commands.</source>
          <target state="translated">Список истории для аргументов,которые являются именами расширенных команд.</target>
        </trans-unit>
        <trans-unit id="8ba9f20cccf9a22f825a093b59843fd157992039" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are shell commands.</source>
          <target state="translated">Список истории для аргументов,которые являются командами оболочки.</target>
        </trans-unit>
        <trans-unit id="bc1844518b7d6ff2a94eb6a74170941282cc242b" translate="yes" xml:space="preserve">
          <source>A history list for arguments to &lt;code&gt;query-replace&lt;/code&gt; (and similar arguments to other commands).</source>
          <target state="translated">Список истории аргументов для &lt;code&gt;query-replace&lt;/code&gt; (и аналогичных аргументов для других команд).</target>
        </trans-unit>
        <trans-unit id="a0f67257cfb467394ba7cf271bab3d6d12bfdd65" translate="yes" xml:space="preserve">
          <source>A history list for buffer-name arguments.</source>
          <target state="translated">Список истории для аргументов имен буферов.</target>
        </trans-unit>
        <trans-unit id="7429cd9053f94b9269173955b75a832e95aa59b8" translate="yes" xml:space="preserve">
          <source>A history list for file-name arguments.</source>
          <target state="translated">Список истории для аргументов имен файлов.</target>
        </trans-unit>
        <trans-unit id="01f40f095da40e7f61a66ab4604f84f69a4b3806" translate="yes" xml:space="preserve">
          <source>A history list for regular expression arguments.</source>
          <target state="translated">Список истории для аргументов регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="d9187f2c4893298bd5d2b8b6870e09edb2df8d32" translate="yes" xml:space="preserve">
          <source>A history list for variable-name arguments read by &lt;code&gt;read-variable&lt;/code&gt;.</source>
          <target state="translated">Список истории для аргументов имени переменной, &lt;code&gt;read-variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88d88490f2e0ece21ea2232720e8c994b48b45c0" translate="yes" xml:space="preserve">
          <source>A inheritance interface for building JSONRPC transport implementations</source>
          <target state="translated">Интерфейс наследования для построения транспортных реализаций JSONRPC</target>
        </trans-unit>
        <trans-unit id="9693681111fd400f0e66f9a76c03ef258c7b1a8e" translate="yes" xml:space="preserve">
          <source>A key sequence (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;). This keeps reading events until a command (or undefined command) is found in the current key maps. The key sequence argument is represented as a string or vector. The cursor does not move into the echo area. Prompt.</source>
          <target state="translated">Последовательность клавиш (см. &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Последовательности клавиш&lt;/a&gt; ). Это продолжает считывать события, пока команда (или неопределенная команда) не будет найдена в текущих картах клавиш. Аргумент ключевой последовательности представлен в виде строки или вектора. Курсор не перемещается в эхо-область. Незамедлительный.</target>
        </trans-unit>
        <trans-unit id="0546250cda7c79f089fec5f11f6cebe8b610ed3c" translate="yes" xml:space="preserve">
          <source>A key sequence or &lt;code&gt;nil&lt;/code&gt;. Can be used after a &amp;lsquo;</source>
          <target state="translated">Ключевая последовательность или &lt;code&gt;nil&lt;/code&gt; . Может использоваться после '</target>
        </trans-unit>
        <trans-unit id="cfce53279f617e80eaa73917517fd51b517c5eca" translate="yes" xml:space="preserve">
          <source>A key sequence that starts with a mouse event is read using the keymaps of the buffer in the window that the mouse was in, not the current buffer. This does not imply that clicking in a window selects that window or its buffer&amp;mdash;that is entirely under the control of the command binding of the key sequence.</source>
          <target state="translated">Последовательность клавиш, которая начинается с события мыши, считывается с использованием раскладок клавиш буфера в окне, в котором находилась мышь, а не текущего буфера. Это не означает, что щелчок в окне выбирает это окно или его буфер - это полностью находится под контролем связывания команды последовательности клавиш.</target>
        </trans-unit>
        <trans-unit id="e2dad76fedc5a5f74f4a3326932c54e1522b3afb" translate="yes" xml:space="preserve">
          <source>A key sequence, whose definition you intend to change. This works like &amp;lsquo;</source>
          <target state="translated">Ключевая последовательность, определение которой вы собираетесь изменить. Это работает как '</target>
        </trans-unit>
        <trans-unit id="a4774465bd436b77f7c7df254153ca64b8821cf1" translate="yes" xml:space="preserve">
          <source>A keymap acts as a menu if it has an &lt;em&gt;overall prompt string&lt;/em&gt;, which is a string that appears as an element of the keymap. (See &lt;a href=&quot;format-of-keymaps#Format-of-Keymaps&quot;&gt;Format of Keymaps&lt;/a&gt;.) The string should describe the purpose of the menu&amp;rsquo;s commands. Emacs displays the overall prompt string as the menu title in some cases, depending on the toolkit (if any) used for displaying menus.&lt;a href=&quot;#FOOT14&quot; name=&quot;DOCF14&quot;&gt;&lt;sup&gt;14&lt;/sup&gt;&lt;/a&gt; Keyboard menus also display the overall prompt string.</source>
          <target state="translated">Раскладка клавиатуры действует как меню, если у нее есть &lt;em&gt;общая строка приглашения&lt;/em&gt; , которая представляет собой строку, которая появляется как элемент раскладки клавиатуры. (См. &lt;a href=&quot;format-of-keymaps#Format-of-Keymaps&quot;&gt;Формат раскладки клавиатуры&lt;/a&gt; .) Строка должна описывать назначение команд меню. Emacs отображает общую строку приглашения как заголовок меню в некоторых случаях, в зависимости от инструментария (если есть), используемого для отображения меню. &lt;a href=&quot;#FOOT14&quot; name=&quot;DOCF14&quot;&gt;&lt;sup&gt;14&lt;/sup&gt;&lt;/a&gt; Меню клавиатуры также отображают общую строку подсказок.</target>
        </trans-unit>
        <trans-unit id="83f54a39819605edababa45c4847dfff5aca04d6" translate="yes" xml:space="preserve">
          <source>A keymap can inherit the bindings of another keymap, which we call the &lt;em&gt;parent keymap&lt;/em&gt;. Such a keymap looks like this:</source>
          <target state="translated">Раскладка клавиатуры может наследовать привязки другой раскладки клавиатуры, которую мы называем &lt;em&gt;родительской раскладкой&lt;/em&gt; . Такая раскладка выглядит так:</target>
        </trans-unit>
        <trans-unit id="adbbaeca7dea252f489449be95d1ffed4f071473" translate="yes" xml:space="preserve">
          <source>A keymap can operate as a menu as well as defining bindings for keyboard keys and mouse buttons. Menus are usually actuated with the mouse, but they can function with the keyboard also. If a menu keymap is active for the next input event, that activates the keyboard menu feature.</source>
          <target state="translated">Клавишная карта может работать как с меню,так и с определением привязки клавиш клавиатуры и кнопок мыши.Меню обычно управляется с помощью мыши,но они могут функционировать и с помощью клавиатуры.Если раскладка меню активна для следующего события ввода,то это активирует функцию меню клавиатуры.</target>
        </trans-unit>
        <trans-unit id="5e8f2aa8d2594c1c94ef9f4765f642084bdc5c9e" translate="yes" xml:space="preserve">
          <source>A keymap can translate one command to another.</source>
          <target state="translated">Клавишная карта может переводить одну команду на другую.</target>
        </trans-unit>
        <trans-unit id="ca5493874569cc11a4db914940648e6dd2feebb3" translate="yes" xml:space="preserve">
          <source>A keymap for translating keys. This one overrides ordinary key bindings, unlike &lt;code&gt;local-function-key-map&lt;/code&gt;. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">Раскладка для перевода ключей. Это переопределяет обычные привязки клавиш, в отличие от &lt;code&gt;local-function-key-map&lt;/code&gt; . См. &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Раздел Раскладки перевода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80a14f3ed730352665ac8497ab20c8aab1ead0c1" translate="yes" xml:space="preserve">
          <source>A keymap is a Lisp data structure that specifies &lt;em&gt;key bindings&lt;/em&gt; for various key sequences.</source>
          <target state="translated">Таблица &lt;em&gt;клавиш&lt;/em&gt; - это структура данных Лиспа, которая определяет &lt;em&gt;привязки клавиш&lt;/em&gt; для различных последовательностей клавиш.</target>
        </trans-unit>
        <trans-unit id="e581df6f5d87ba129d52ded580910d5a01f546b3" translate="yes" xml:space="preserve">
          <source>A lambda expression is a function object written in Lisp. Here is an example:</source>
          <target state="translated">Выражение лямбда-это функциональный объект,написанный на языке Lisp.Приведем пример:</target>
        </trans-unit>
        <trans-unit id="f7a2c28e4460e8f858bc67f5e6523cad3aaaf449" translate="yes" xml:space="preserve">
          <source>A lambda expression is a list that looks like this:</source>
          <target state="translated">Выражение лямбда-это список,который выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="b747ce530e646e9a380c84908496cdbfc9864e4b" translate="yes" xml:space="preserve">
          <source>A lambda expression may optionally have a &lt;em&gt;documentation string&lt;/em&gt; just after the lambda list. This string does not affect execution of the function; it is a kind of comment, but a systematized comment which actually appears inside the Lisp world and can be used by the Emacs help facilities. See &lt;a href=&quot;documentation#Documentation&quot;&gt;Documentation&lt;/a&gt;, for how the documentation string is accessed.</source>
          <target state="translated">Лямбда-выражение может дополнительно содержать &lt;em&gt;строку документации&lt;/em&gt; сразу после лямбда-списка. Эта строка не влияет на выполнение функции; это своего рода комментарий, но систематизированный комментарий, который фактически появляется в мире Lisp и может использоваться средствами справки Emacs. См. &lt;a href=&quot;documentation#Documentation&quot;&gt;Документацию&lt;/a&gt; , чтобы узнать, как получить доступ к строке документации.</target>
        </trans-unit>
        <trans-unit id="3b292d4cfd4f00850f90b2cafdf8eb012fcc7887" translate="yes" xml:space="preserve">
          <source>A lambda expression with no quoting.</source>
          <target state="translated">Выражение лямбда без цитирования.</target>
        </trans-unit>
        <trans-unit id="d44cec50b78191f5728f5dfe284c3f5d18297979" translate="yes" xml:space="preserve">
          <source>A lambda expression, by itself, has no name; it is an &lt;em&gt;anonymous function&lt;/em&gt;. Although lambda expressions can be used this way (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), they are more commonly associated with symbols to make &lt;em&gt;named functions&lt;/em&gt; (see &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;). Before going into these details, the following subsections describe the components of a lambda expression and what they do.</source>
          <target state="translated">Лямбда-выражение само по себе не имеет имени; это &lt;em&gt;анонимная функция&lt;/em&gt; . Хотя лямбда-выражения можно использовать таким образом (см. &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Анонимные функции&lt;/a&gt; ), они чаще связаны с символами для создания &lt;em&gt;именованных функций&lt;/em&gt; (см. &lt;a href=&quot;function-names#Function-Names&quot;&gt;Имена функций&lt;/a&gt; ). Прежде чем вдаваться в подробности, в следующих подразделах описываются компоненты лямбда-выражения и то, что они делают.</target>
        </trans-unit>
        <trans-unit id="79901fc9ba461cbaf1a28d28ff8d5bb8913b104c" translate="yes" xml:space="preserve">
          <source>A lexically-bound variable has &lt;em&gt;lexical scope&lt;/em&gt;, meaning that any reference to the variable must be located textually within the binding construct. Here is an example (see &lt;a href=&quot;using-lexical-binding#Using-Lexical-Binding&quot;&gt;Using Lexical Binding&lt;/a&gt;, for how to actually enable lexical binding):</source>
          <target state="translated">Переменная с &lt;em&gt;лексической&lt;/em&gt; привязкой имеет &lt;em&gt;лексическую область видимости&lt;/em&gt; , что означает, что любая ссылка на переменную должна располагаться в текстовой форме внутри конструкции привязки. Вот пример (см. &lt;a href=&quot;using-lexical-binding#Using-Lexical-Binding&quot;&gt;Использование лексического связывания&lt;/a&gt; , чтобы узнать, как на самом деле включить лексическое связывание):</target>
        </trans-unit>
        <trans-unit id="533bed4887f5fb41a2062d1ceb8b2882d359589f" translate="yes" xml:space="preserve">
          <source>A line prefix may also be specified for regions of text using the &lt;code&gt;line-prefix&lt;/code&gt; text or overlay property. This takes precedence over the &lt;code&gt;line-prefix&lt;/code&gt; variable. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">Префикс строки также может быть указан для областей текста с помощью свойства &lt;code&gt;line-prefix&lt;/code&gt; text или overlay. Это имеет приоритет перед переменной &lt;code&gt;line-prefix&lt;/code&gt; . См. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Особые свойства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d5d522b996bc3a1dbbe7104db24a53d4976ad85" translate="yes" xml:space="preserve">
          <source>A line-prefix may also be specified for an entire buffer using the &lt;code&gt;line-prefix&lt;/code&gt; buffer-local variable (however, a &lt;code&gt;line-prefix&lt;/code&gt; text-property takes precedence over the value of the &lt;code&gt;line-prefix&lt;/code&gt; variable). See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">Префикс строки также может быть указан для всего буфера, используя локальную переменную буфера &lt;code&gt;line-prefix&lt;/code&gt; (однако свойство текста &lt;code&gt;line-prefix&lt;/code&gt; имеет приоритет над значением переменной &lt;code&gt;line-prefix&lt;/code&gt; ). См. &lt;a href=&quot;truncation#Truncation&quot;&gt;Усечение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1bcc030a8bc8877cd9b9cae08c99cc625688c45" translate="yes" xml:space="preserve">
          <source>A list can be illustrated by a diagram in which the cons cells are shown as pairs of boxes, like dominoes. (The Lisp reader cannot read such an illustration; unlike the textual notation, which can be understood by both humans and computers, the box illustrations can be understood only by humans.) This picture represents the three-element list &lt;code&gt;(rose violet buttercup)&lt;/code&gt;:</source>
          <target state="translated">Список можно проиллюстрировать диаграммой, на которой cons-ячейки показаны в виде пар ящиков, как домино. (Читатель Лиспа не может прочесть такую ​​иллюстрацию; в отличие от текстовой нотации, которая может быть понятна как людям, так и компьютерам, рамочные иллюстрации могут быть поняты только людьми.) Эта картинка представляет собой список из трех элементов &lt;code&gt;(rose violet buttercup)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="18f1e02aad43b9d2e925fec42e48b5173603ed8e" translate="yes" xml:space="preserve">
          <source>A list can represent a finite mathematical set.</source>
          <target state="translated">Список может представлять собой конечный математический набор.</target>
        </trans-unit>
        <trans-unit id="99dc99207530f20a557f325ad2ddf35b0334c2e1" translate="yes" xml:space="preserve">
          <source>A list can represent a finite relation or mapping.</source>
          <target state="translated">Список может представлять собой конечное отношение или отображение.</target>
        </trans-unit>
        <trans-unit id="ac710751e4b90ec9bd82d44f9428b1100cf29626" translate="yes" xml:space="preserve">
          <source>A list can represent an unordered mathematical set&amp;mdash;simply consider a value an element of a set if it appears in the list, and ignore the order of the list. To form the union of two sets, use &lt;code&gt;append&lt;/code&gt; (as long as you don&amp;rsquo;t mind having duplicate elements). You can remove &lt;code&gt;equal&lt;/code&gt; duplicates using &lt;code&gt;delete-dups&lt;/code&gt;. Other useful functions for sets include &lt;code&gt;memq&lt;/code&gt; and &lt;code&gt;delq&lt;/code&gt;, and their &lt;code&gt;equal&lt;/code&gt; versions, &lt;code&gt;member&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">Список может представлять собой неупорядоченный математический набор - просто считайте значение элементом набора, если оно появляется в списке, и игнорируйте порядок в списке. Чтобы сформировать объединение двух наборов, используйте &lt;code&gt;append&lt;/code&gt; (при условии, что вы не против дублирования элементов). Вы можете удалить &lt;code&gt;equal&lt;/code&gt; дубликаты с помощью &lt;code&gt;delete-dups&lt;/code&gt; . Другие полезные функции для наборов включают &lt;code&gt;memq&lt;/code&gt; и &lt;code&gt;delq&lt;/code&gt; , а также их &lt;code&gt;equal&lt;/code&gt; версии, &lt;code&gt;member&lt;/code&gt; и &lt;code&gt;delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec3b92eaabe91cf1801f07fdb6f671a3685b6b4e" translate="yes" xml:space="preserve">
          <source>A list containing the command arguments that were used to start this process. For a network or serial process, it is &lt;code&gt;nil&lt;/code&gt; if the process is running or &lt;code&gt;t&lt;/code&gt; if the process is stopped.</source>
          <target state="translated">Список, содержащий аргументы команды, которые использовались для запуска этого процесса. Для сетевого или последовательного процесса это &lt;code&gt;nil&lt;/code&gt; если процесс выполняется, или &lt;code&gt;t&lt;/code&gt; , если процесс остановлен.</target>
        </trans-unit>
        <trans-unit id="03cd1740db820619af89ab8e9d8be24952c71154" translate="yes" xml:space="preserve">
          <source>A list is a sequence of elements, but it is not a single primitive object; it is made of cons cells, one cell per element. Finding the &lt;var&gt;n&lt;/var&gt;th element requires looking through &lt;var&gt;n&lt;/var&gt; cons cells, so elements farther from the beginning of the list take longer to access. But it is possible to add elements to the list, or remove elements.</source>
          <target state="translated">Список - это последовательность элементов, но не отдельный примитивный объект; он состоит из cons-ячеек, по одной ячейке на элемент. Чтобы найти &lt;var&gt;n&lt;/var&gt; - й элемент, нужно просмотреть &lt;var&gt;n&lt;/var&gt; cons-ячеек, поэтому доступ к элементам дальше от начала списка занимает больше времени. Но можно добавлять элементы в список или удалять элементы.</target>
        </trans-unit>
        <trans-unit id="79a7cbc441d380e14b5ac8933034a90bcc47cf66" translate="yes" xml:space="preserve">
          <source>A list is a series of cons cells chained together, so that each cell refers to the next one. There is one cons cell for each element of the list. By convention, the &lt;small&gt;CAR&lt;/small&gt;s of the cons cells hold the elements of the list, and the &lt;small&gt;CDR&lt;/small&gt;s are used to chain the list (this asymmetry between &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; is entirely a matter of convention; at the level of cons cells, the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; slots have similar properties). Hence, the &lt;small&gt;CDR&lt;/small&gt; slot of each cons cell in a list refers to the following cons cell.</source>
          <target state="translated">Список представляет собой серию cons-ячеек, связанных вместе, так что каждая ячейка ссылается на следующую. Для каждого элемента списка есть одна cons-ячейка. По соглашению, &lt;small&gt;CAR&lt;/small&gt; в cons-ячейках содержат элементы списка, а &lt;small&gt;CDR&lt;/small&gt; используются для создания цепочки списка (эта асимметрия между &lt;small&gt;CAR&lt;/small&gt; и &lt;small&gt;CDR&lt;/small&gt; полностью условна; на уровне cons-ячеек &lt;small&gt;CAR&lt;/small&gt; и слоты &lt;small&gt;CDR&lt;/small&gt; имеют аналогичные свойства). Следовательно, слот &lt;small&gt;CDR&lt;/small&gt; каждой cons-ячейки в списке относится к следующей cons-ячейке.</target>
        </trans-unit>
        <trans-unit id="eb5ad8cefc6fdf97ba909694a797fc46cf77bfea" translate="yes" xml:space="preserve">
          <source>A list of actions to be applied. &lt;var&gt;key&lt;/var&gt; and &lt;var&gt;title&lt;/var&gt; are both strings. The default action (usually invoked by clicking the notification) should have a key named &amp;lsquo;</source>
          <target state="translated">Список действий, которые нужно применить. &lt;var&gt;key&lt;/var&gt; и &lt;var&gt;title&lt;/var&gt; являются строками. Действие по умолчанию (обычно вызываемое щелчком по уведомлению) должно иметь ключ с именем '</target>
        </trans-unit>
        <trans-unit id="cb3dbbae0a50b4c6a0443b8163ae2bd799d39f32" translate="yes" xml:space="preserve">
          <source>A list of buffers that have been selected in this frame, ordered most-recently-selected first.</source>
          <target state="translated">Список буферов,которые были выбраны в этом кадре,упорядоченных наиболее свежевыбранных в первую очередь.</target>
        </trans-unit>
        <trans-unit id="9e4afc49af957f8ee7b00bb9c5101181b23c3178" translate="yes" xml:space="preserve">
          <source>A list of faces. Each list element should be either a face name or an anonymous face. This specifies a face which is an aggregate of the attributes of each of the listed faces. Faces occurring earlier in the list have higher priority.</source>
          <target state="translated">Список лиц.Каждый элемент списка должен быть либо именем лица,либо анонимным лицом.При этом указывается лицо,представляющее собой совокупность атрибутов каждого из перечисленных лиц.Лица,встречающиеся в списке ранее,имеют более высокий приоритет.</target>
        </trans-unit>
        <trans-unit id="cd93b8f785e569c20a9a3b200dddb7784d87994f" translate="yes" xml:space="preserve">
          <source>A list of four integers &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt;
&lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt;, where 0&amp;le;&lt;var&gt;low&lt;/var&gt;&amp;lt;65536, 0&amp;le;&lt;var&gt;micro&lt;/var&gt;&amp;lt;1000000, and 0&amp;le;&lt;var&gt;pico&lt;/var&gt;&amp;lt;1000000. This represents the number of seconds using the formula: &lt;var&gt;high&lt;/var&gt; * 2**16 + &lt;var&gt;low&lt;/var&gt; + &lt;var&gt;micro&lt;/var&gt; * 10**-6 + &lt;var&gt;pico&lt;/var&gt; * 10**-12. In some cases, functions may default to returning two- or three-element lists, with omitted &lt;var&gt;micro&lt;/var&gt; and &lt;var&gt;pico&lt;/var&gt; components defaulting to zero. On all current machines &lt;var&gt;pico&lt;/var&gt; is a multiple of 1000, but this may change as higher-resolution clocks become available.</source>
          <target state="translated">Список из четырех целых чисел &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt; &lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt; , где 0&amp;le; &lt;var&gt;low&lt;/var&gt; &amp;lt;65536, 0&amp;le; &lt;var&gt;micro&lt;/var&gt; &amp;lt;1000000 и 0&amp;le; &lt;var&gt;pico&lt;/var&gt; &amp;lt;1000000. Это количество секунд по формуле: &lt;var&gt;high&lt;/var&gt; * 2 ** 16 + &lt;var&gt;low&lt;/var&gt; + &lt;var&gt;micro&lt;/var&gt; * 10 ** - 6 + &lt;var&gt;pico&lt;/var&gt; * 10 ** - 12. В некоторых случаях функции могут по умолчанию возвращать двух- или трехэлементные списки, при этом пропущенные компоненты &lt;var&gt;micro&lt;/var&gt; и &lt;var&gt;pico&lt;/var&gt; по умолчанию равны нулю. На всех современных машинах &lt;var&gt;pico&lt;/var&gt; кратно 1000, но это может измениться по мере появления часов с более высоким разрешением.</target>
        </trans-unit>
        <trans-unit id="64f061c5f8cefbf5c98fc8804458fac9b42c2790" translate="yes" xml:space="preserve">
          <source>A list of functions for &lt;code&gt;write-region&lt;/code&gt; to call. Each function in the list is called with two arguments: the start and end of the region to be written. These functions should not alter the contents of the buffer. Instead, they should return annotations.</source>
          <target state="translated">Список функций для &lt;code&gt;write-region&lt;/code&gt; до вызова. Каждая функция в списке вызывается с двумя аргументами: началом и концом записываемой области. Эти функции не должны изменять содержимое буфера. Вместо этого они должны возвращать аннотации.</target>
        </trans-unit>
        <trans-unit id="ad430a2aa751ead60d08bdf9430d36b7f4df318c" translate="yes" xml:space="preserve">
          <source>A list of functions to be called before playing a sound. Each function is called with one argument, a property list that describes the sound.</source>
          <target state="translated">Список функций,которые необходимо вызвать перед воспроизведением звука.Каждая функция вызывается с одним аргументом-списком свойств,описывающих звук.</target>
        </trans-unit>
        <trans-unit id="9762c2a4058c3add2cfe39ddf8d9dd6bdb44523b" translate="yes" xml:space="preserve">
          <source>A list of one element, which is an integer. This form of prefix argument results from one or a succession of</source>
          <target state="translated">Список одного элемента,который является целым числом.Такая форма префиксного аргумента получается из одного или последовательности аргументов</target>
        </trans-unit>
        <trans-unit id="f5b0c0c7f5caee2f5c38fd7fde9aec68fd7f4efb" translate="yes" xml:space="preserve">
          <source>A list of other packages (possibly including minimal acceptable version numbers) on which this package depends. The list may be empty, meaning this package has no dependencies. Otherwise, installing this package also automatically installs its dependencies, recursively; if any dependency cannot be found, the package cannot be installed.</source>
          <target state="translated">Список других пакетов (возможно,с указанием минимально допустимых номеров версий),от которых зависит данный пакет.Список может быть пустым,что означает,что данный пакет не имеет зависимостей.В противном случае,установка данного пакета также автоматически устанавливает свои зависимости,рекурсивно;если какая-либо зависимость не может быть найдена,пакет не может быть установлен.</target>
        </trans-unit>
        <trans-unit id="5b66488132bcde1f299fe22c7b2b1810b9065678" translate="yes" xml:space="preserve">
          <source>A list of paired elements.</source>
          <target state="translated">Список парных элементов.</target>
        </trans-unit>
        <trans-unit id="a6fc5f224bd5c8d275550865575a986e426c96bf" translate="yes" xml:space="preserve">
          <source>A list of symbols, specifying the &lt;em&gt;font backends&lt;/em&gt; to use for drawing characters on the frame, in order of priority. In Emacs built without Cairo drawing on X, there are currently three potentially available font backends: &lt;code&gt;x&lt;/code&gt; (the X core font driver), &lt;code&gt;xft&lt;/code&gt; (the Xft font driver), and &lt;code&gt;xfthb&lt;/code&gt; (the Xft font driver with HarfBuzz text shaping). If built with Cairo drawing, there are also three potentially available font backends on X: &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;ftcr&lt;/code&gt; (the FreeType font driver on Cairo), and &lt;code&gt;ftcrhb&lt;/code&gt; (the FreeType font driver on Cairo with HarfBuzz text shaping). When Emacs is built with HarfBuzz, the default font driver is &lt;code&gt;ftcrhb&lt;/code&gt;, although use of the &lt;code&gt;ftcr&lt;/code&gt; driver is still possible, but not recommended. On MS-Windows, there are currently three available font backends: &lt;code&gt;gdi&lt;/code&gt; (the core MS-Windows font driver), &lt;code&gt;uniscribe&lt;/code&gt; (font driver for OTF and TTF fonts with text shaping by the Uniscribe engine), and &lt;code&gt;harfbuzz&lt;/code&gt; (font driver for OTF and TTF fonts with HarfBuzz text shaping) (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Fonts.html#Windows-Fonts&quot;&gt;Windows Fonts&lt;/a&gt; in</source>
          <target state="translated">Список символов, определяющий &lt;em&gt;серверные части шрифта, которые&lt;/em&gt; будут использоваться для рисования символов на фрейме, в порядке приоритета. В Emacs, созданном без отрисовки Cairo на X, в настоящее время есть три потенциально доступных бэкэнда шрифтов: &lt;code&gt;x&lt;/code&gt; (основной драйвер шрифта X), &lt;code&gt;xft&lt;/code&gt; (драйвер шрифта Xft) и &lt;code&gt;xfthb&lt;/code&gt; (драйвер шрифта Xft с формированием текста HarfBuzz). Если построено с использованием рисунка Cairo, есть также три потенциально доступных серверных модуля шрифтов в X: &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;ftcr&lt;/code&gt; (драйвер шрифта FreeType в Cairo) и &lt;code&gt;ftcrhb&lt;/code&gt; (драйвер шрифта FreeType в Cairo с формированием текста HarfBuzz). Когда Emacs собран с HarfBuzz, драйвер шрифта по умолчанию - &lt;code&gt;ftcrhb&lt;/code&gt; , хотя используется &lt;code&gt;ftcr&lt;/code&gt; Драйвер ftcr все еще возможен, но не рекомендуется. В MS-Windows в настоящее время доступно три серверных &lt;code&gt;gdi&lt;/code&gt; шрифтов: gdi (основной драйвер шрифтов MS-Windows), &lt;code&gt;uniscribe&lt;/code&gt; (драйвер шрифтов для шрифтов OTF и TTF с формированием текста с помощью механизма Uniscribe) и &lt;code&gt;harfbuzz&lt;/code&gt; (драйвер шрифтов для OTF и Шрифты TTF с формированием текста HarfBuzz) (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Fonts.html#Windows-Fonts&quot;&gt;Шрифты Windows&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="bd9aaeffdeefe23136c0b4104c9bac72201a0bb1" translate="yes" xml:space="preserve">
          <source>A list of symbols, specifying the &lt;em&gt;font backends&lt;/em&gt; to use for drawing characters on the frame, in order of priority. In Emacs built without Cairo drawing on X, there are currently three potentially available font backends: &lt;code&gt;x&lt;/code&gt; (the X core font driver), &lt;code&gt;xft&lt;/code&gt; (the Xft font driver), and &lt;code&gt;xfthb&lt;/code&gt; (the Xft font driver with HarfBuzz text shaping). If built with Cairo drawing, there are also three potentially available font backends on X: &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;ftcr&lt;/code&gt; (the FreeType font driver on Cairo), and &lt;code&gt;ftcrhb&lt;/code&gt; (the FreeType font driver on Cairo with HarfBuzz text shaping). When Emacs is built with HarfBuzz, the default font driver is &lt;code&gt;ftcrhb&lt;/code&gt;, although use of the &lt;code&gt;ftcr&lt;/code&gt; driver is still possible, but not recommended. On MS-Windows, there are currently three available font backends: &lt;code&gt;gdi&lt;/code&gt; (the core MS-Windows font driver), &lt;code&gt;uniscribe&lt;/code&gt; (font driver for OTF and TTF fonts with text shaping by the Uniscribe engine), and &lt;code&gt;harfbuzz&lt;/code&gt; (font driver for OTF and TTF fonts with HarfBuzz text shaping) (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Fonts.html#Windows-Fonts&quot;&gt;Windows Fonts&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889ce2ae30cbe0ed4180a7fd8f0ae655444bf1e7" translate="yes" xml:space="preserve">
          <source>A list of terminal parameters. See &lt;a href=&quot;terminal-parameters#Terminal-Parameters&quot;&gt;Terminal Parameters&lt;/a&gt;.</source>
          <target state="translated">Список параметров терминала. См. &lt;a href=&quot;terminal-parameters#Terminal-Parameters&quot;&gt;Параметры терминала&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="486df487a5b36966765d7fa430db38ceca9357e2" translate="yes" xml:space="preserve">
          <source>A list whose first element is a string or list means to process all the elements recursively and concatenate the results. This is the most common form of mode line construct.</source>
          <target state="translated">Список,первым элементом которого является строка или список,означает обрабатывать все элементы рекурсивно и объединять результаты.Это наиболее распространенная форма построения строки режима.</target>
        </trans-unit>
        <trans-unit id="537d031a677ca36fa6b9cad5a659d5374622bf7d" translate="yes" xml:space="preserve">
          <source>A list whose first element is a symbol representing the font type, one of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;opentype&lt;/code&gt;, &lt;code&gt;truetype&lt;/code&gt;, &lt;code&gt;type1&lt;/code&gt;, &lt;code&gt;pcf&lt;/code&gt;, or &lt;code&gt;bdf&lt;/code&gt;. For OpenType fonts, the list includes 2 additional elements describing the &lt;small&gt;GSUB&lt;/small&gt; and &lt;small&gt;GPOS&lt;/small&gt; features supported by the font. Each of these elements is a list of the form &lt;code&gt;((&lt;var&gt;script&lt;/var&gt; (&lt;var&gt;langsys&lt;/var&gt; &lt;var&gt;feature&lt;/var&gt; &amp;hellip;) &amp;hellip;)
&amp;hellip;)&lt;/code&gt;, where &lt;var&gt;script&lt;/var&gt; is a symbol representing an OpenType script tag, &lt;var&gt;langsys&lt;/var&gt; is a symbol representing an OpenType langsys tag (or &lt;code&gt;nil&lt;/code&gt;, which stands for the default langsys), and each &lt;var&gt;feature&lt;/var&gt; is a symbol representing an OpenType feature tag.</source>
          <target state="translated">Список, первым элементом которого является символ, представляющий тип шрифта, один из &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;opentype&lt;/code&gt; , &lt;code&gt;truetype&lt;/code&gt; , &lt;code&gt;type1&lt;/code&gt; , &lt;code&gt;pcf&lt;/code&gt; или &lt;code&gt;bdf&lt;/code&gt; . Для шрифтов OpenType список включает 2 дополнительных элемента, описывающих функции &lt;small&gt;GSUB&lt;/small&gt; и &lt;small&gt;GPOS,&lt;/small&gt; поддерживаемые шрифтом. Каждый из этих элементов представляет собой список формы &lt;code&gt;((&lt;var&gt;script&lt;/var&gt; (&lt;var&gt;langsys&lt;/var&gt; &lt;var&gt;feature&lt;/var&gt; &amp;hellip;) &amp;hellip;) &amp;hellip;)&lt;/code&gt; , где &lt;var&gt;script&lt;/var&gt; - это символ, представляющий тег сценария OpenType, &lt;var&gt;langsys&lt;/var&gt; - это символ, представляющий тег OpenType langsys (или &lt;code&gt;nil&lt;/code&gt; , что означает langsys по умолчанию), и каждая &lt;var&gt;feature&lt;/var&gt; представляет собой символ, представляющий тег функции OpenType.</target>
        </trans-unit>
        <trans-unit id="0ce46748c8e3407b9e05ae90432a1d1f6fcfef35" translate="yes" xml:space="preserve">
          <source>A list whose first element is a symbol that is not a keyword specifies a conditional. Its meaning depends on the value of &lt;var&gt;symbol&lt;/var&gt;. If &lt;var&gt;symbol&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt; value, the second element, &lt;var&gt;then&lt;/var&gt;, is processed recursively as a mode line construct. Otherwise, the third element, &lt;var&gt;else&lt;/var&gt;, is processed recursively. You may omit &lt;var&gt;else&lt;/var&gt;; then the mode line construct displays nothing if the value of &lt;var&gt;symbol&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or void.</source>
          <target state="translated">Список, первым элементом которого является символ, не являющийся ключевым словом, задает условное выражение. Его значение зависит от значения &lt;var&gt;symbol&lt;/var&gt; . Если &lt;var&gt;symbol&lt;/var&gt; имеет не- &lt;code&gt;nil&lt;/code&gt; ценность, второй элемент, а &lt;var&gt;then&lt;/var&gt; , обрабатывается рекурсивно как конструкт режим линии. В противном случае рекурсивно обрабатывается третий элемент &lt;var&gt;else&lt;/var&gt; . Вы можете опустить &lt;var&gt;else&lt;/var&gt; ; тогда конструкция строки режима ничего не отображает, если значение &lt;var&gt;symbol&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; или недействительно.</target>
        </trans-unit>
        <trans-unit id="53b4d74e824eb5439ef4ec98237a2b8623aea845" translate="yes" xml:space="preserve">
          <source>A list whose first element is an integer specifies truncation or padding of the results of &lt;var&gt;rest&lt;/var&gt;. The remaining elements &lt;var&gt;rest&lt;/var&gt; are processed recursively as mode line constructs and concatenated together. When &lt;var&gt;width&lt;/var&gt; is positive, the result is space filled on the right if its width is less than &lt;var&gt;width&lt;/var&gt;. When &lt;var&gt;width&lt;/var&gt; is negative, the result is truncated on the right to -&lt;var&gt;width&lt;/var&gt; columns if its width exceeds -&lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">Список, первым элементом которого является целое число, определяет усечение или дополнение результатов &lt;var&gt;rest&lt;/var&gt; . Остальные элементы &lt;var&gt;rest&lt;/var&gt; рекурсивно обрабатываются как конструкции строки режима и объединяются вместе. Если &lt;var&gt;width&lt;/var&gt; положительна, результатом будет заполненное пространство справа, если его ширина меньше &lt;var&gt;width&lt;/var&gt; . Когда &lt;var&gt;width&lt;/var&gt; отрицательна, результат обрезается справа до столбцов - &lt;var&gt;width&lt;/var&gt; , если его ширина превышает - &lt;var&gt;width&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="200a1fdf699f4365c5108897a4f0ff20723ba395" translate="yes" xml:space="preserve">
          <source>A list whose first element is the symbol &lt;code&gt;:eval&lt;/code&gt; says to evaluate &lt;var&gt;form&lt;/var&gt;, and use the result as a string to display. Make sure this evaluation cannot load any files, as doing so could cause infinite recursion.</source>
          <target state="translated">Список, первым элементом которого является символ &lt;code&gt;:eval&lt;/code&gt; говорит оценить &lt;var&gt;form&lt;/var&gt; и использовать результат как строку для отображения. Убедитесь, что эта оценка не может загрузить какие-либо файлы, так как это может вызвать бесконечную рекурсию.</target>
        </trans-unit>
        <trans-unit id="1a68e385750b6b6bb2e3e3b921b8caab43897c33" translate="yes" xml:space="preserve">
          <source>A list whose first element is the symbol &lt;code&gt;:propertize&lt;/code&gt; says to process the mode line construct &lt;var&gt;elt&lt;/var&gt; recursively, then add the text properties specified by &lt;var&gt;props&lt;/var&gt; to the result. The argument &lt;var&gt;props&lt;/var&gt; should consist of zero or more pairs &lt;var&gt;text-property&lt;/var&gt;&lt;var&gt;value&lt;/var&gt;. If &lt;var&gt;elt&lt;/var&gt; is or produces a string with text properties, all the characters of that string should have the same properties, or else some of them might be removed by &lt;code&gt;:propertize&lt;/code&gt;.</source>
          <target state="translated">Список, первым элементом которого является символ &lt;code&gt;:propertize&lt;/code&gt; говорит, что нужно рекурсивно обработать конструкцию строки режима &lt;var&gt;elt&lt;/var&gt; , а затем добавить к результату текстовые свойства, указанные в &lt;var&gt;props&lt;/var&gt; . Аргумент &lt;var&gt;props&lt;/var&gt; должен состоять из нуля или более пара &lt;var&gt;text-property&lt;/var&gt; &lt;var&gt;value&lt;/var&gt; . Если &lt;var&gt;elt&lt;/var&gt; является строкой с текстовыми свойствами или производит ее, все символы этой строки должны иметь одинаковые свойства, иначе некоторые из них могут быть удалены с помощью &lt;code&gt;:propertize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99145ab59880d8f2b7e6b9be7771bce95706ef5a" translate="yes" xml:space="preserve">
          <source>A list with no elements in it is the &lt;em&gt;empty list&lt;/em&gt;; it is identical to the symbol &lt;code&gt;nil&lt;/code&gt;. In other words, &lt;code&gt;nil&lt;/code&gt; is both a symbol and a list.</source>
          <target state="translated">Список без элементов - это &lt;em&gt;пустой список&lt;/em&gt; ; он идентичен символу &lt;code&gt;nil&lt;/code&gt; . Другими словами, &lt;code&gt;nil&lt;/code&gt; - это и символ, и список.</target>
        </trans-unit>
        <trans-unit id="8d5b45234e07684855dcd49734c72caa44271737" translate="yes" xml:space="preserve">
          <source>A local keymap can cancel a menu bar item made by the global keymap by rebinding the same fake function key with &lt;code&gt;undefined&lt;/code&gt; as the binding. For example, this is how Dired suppresses the &amp;lsquo;</source>
          <target state="translated">Локальная раскладка клавиатуры может отменить элемент строки меню, созданный глобальной раскладкой, путем повторной привязки той же фальшивой функциональной клавиши с &lt;code&gt;undefined&lt;/code&gt; в качестве привязки. Например, вот так Dired подавляет '</target>
        </trans-unit>
        <trans-unit id="7c4cffa2e30c2997d566ee8758396b533735bf09" translate="yes" xml:space="preserve">
          <source>A loop that scans the buffer forwards, creating overlays, can run faster if you do &lt;code&gt;(overlay-recenter (point-max))&lt;/code&gt; first.</source>
          <target state="translated">Цикл, который просматривает буфер вперед, создавая наложения, может работать быстрее, если вы &lt;code&gt;(overlay-recenter (point-max))&lt;/code&gt; сделаете (overlay-correnter (point-max)) .</target>
        </trans-unit>
        <trans-unit id="a7efdb49985c362b0ca4c8aa6d3088d6718cc09a" translate="yes" xml:space="preserve">
          <source>A lot of code uses the old &lt;code&gt;defadvice&lt;/code&gt; mechanism, which is largely made obsolete by the new &lt;code&gt;advice-add&lt;/code&gt;, whose implementation and semantics is significantly simpler.</source>
          <target state="translated">Во многих кодах используется старый механизм &lt;code&gt;defadvice&lt;/code&gt; , который в значительной степени устарел из-за нового &lt;code&gt;advice-add&lt;/code&gt; , реализация и семантика которого значительно проще.</target>
        </trans-unit>
        <trans-unit id="0ae5e6660e603f36f91418d149ae3a32b329069b" translate="yes" xml:space="preserve">
          <source>A lower-level function for standardizing file names, which &lt;code&gt;locate-user-emacs-file&lt;/code&gt; uses as a subroutine, is &lt;code&gt;convert-standard-filename&lt;/code&gt;.</source>
          <target state="translated">Функция нижнего уровня для стандартизации имен файлов, которую &lt;code&gt;locate-user-emacs-file&lt;/code&gt; использует в качестве подпрограммы, называется &lt;code&gt;convert-standard-filename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="204dc77e267dd20b6bd5f085404e9de55232cab4" translate="yes" xml:space="preserve">
          <source>A macro (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;) can also be marked obsolete with &lt;code&gt;make-obsolete&lt;/code&gt;; this has the same effects as for a function. An alias for a function or macro can also be marked as obsolete; this makes the alias itself obsolete, not the function or macro which it resolves to.</source>
          <target state="translated">Макрос (см. &lt;a href=&quot;macros#Macros&quot;&gt;Макросы&lt;/a&gt; ) также можно пометить как устаревший с помощью &lt;code&gt;make-obsolete&lt;/code&gt; ; это имеет тот же эффект, что и для функции. Псевдоним для функции или макроса также может быть помечен как устаревший; это делает устаревшим сам псевдоним, а не функцию или макрос, в которые он разрешается.</target>
        </trans-unit>
        <trans-unit id="bb6a5825df107e5229f7ac1f45fb39d09577f95a" translate="yes" xml:space="preserve">
          <source>A macro call looks just like a function call in that it is a list which starts with the name of the macro. The rest of the elements of the list are the arguments of the macro.</source>
          <target state="translated">Вызов макроса выглядит так же,как вызов функции,в том смысле,что это список,который начинается с имени макроса.Остальные элементы списка являются аргументами макроса.</target>
        </trans-unit>
        <trans-unit id="c88b5640d4554aef41be1be878e9894c1dc41ba1" translate="yes" xml:space="preserve">
          <source>A magic autoload comment (often called an &lt;em&gt;autoload cookie&lt;/em&gt;) consists of &amp;lsquo;</source>
          <target state="translated">Магический комментарий автозагрузки (часто называемый &lt;em&gt;файлом cookie автозагрузки&lt;/em&gt; ) состоит из '</target>
        </trans-unit>
        <trans-unit id="bdf7d7f38bdc264583d1a0710beb7e25f8ed382e" translate="yes" xml:space="preserve">
          <source>A major client of this is &lt;code&gt;display-buffer-reuse-window&lt;/code&gt;, but all other action functions that try to reuse a window are affected as well. &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; consults it when searching for a window that previously displayed the buffer on another frame.</source>
          <target state="translated">Основным клиентом этого является &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; , но все другие функции действий, которые пытаются повторно использовать окно, также затронуты. &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; обращается к нему при поиске окна, которое ранее отображало буфер в другом кадре.</target>
        </trans-unit>
        <trans-unit id="45f557d688272099786e68e616898e0f800432d9" translate="yes" xml:space="preserve">
          <source>A major mode can also rebind the keys</source>
          <target state="translated">Основной режим также может переплетать клавиши</target>
        </trans-unit>
        <trans-unit id="781c3e7a06dbadfac8818dd119ef44b70073b8cd" translate="yes" xml:space="preserve">
          <source>A margin display specification looks like &lt;code&gt;((margin
right-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;((margin left-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;spec&lt;/var&gt; is another display specification that says what to display in the margin. Typically it is a string of text to display, or an image descriptor.</source>
          <target state="translated">Спецификация отображения полей выглядит как &lt;code&gt;((margin right-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt; или &lt;code&gt;((margin left-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt; . Здесь &lt;var&gt;spec&lt;/var&gt; - это еще одна спецификация дисплея, в которой указано, что отображать на полях. Обычно это строка текста для отображения или дескриптор изображения.</target>
        </trans-unit>
        <trans-unit id="e70b47c889fabc845b90767aef6efcf0cf0a1107" translate="yes" xml:space="preserve">
          <source>A marker has three attributes: the marker position, the marker buffer, and the insertion type. The marker position is an integer that is equivalent (at a given time) to the marker as a position in that buffer. But the marker&amp;rsquo;s position value can change during the life of the marker, and often does. Insertion and deletion of text in the buffer relocate the marker. The idea is that a marker positioned between two characters remains between those two characters despite insertion and deletion elsewhere in the buffer. Relocation changes the integer equivalent of the marker.</source>
          <target state="translated">Маркер имеет три атрибута: положение маркера, буфер маркера и тип вставки. Позиция маркера - это целое число, эквивалентное (в данный момент) позиции маркера в этом буфере. Но значение положения маркера может меняться в течение срока службы маркера, и часто это происходит. Вставка и удаление текста в буфере перемещают маркер. Идея состоит в том, что маркер, расположенный между двумя символами, остается между этими двумя символами, несмотря на вставку и удаление в другом месте буфера. Перемещение изменяет целочисленный эквивалент маркера.</target>
        </trans-unit>
        <trans-unit id="466a2e8e4ddd1269a8d20d90952cb9d2e8d1b556" translate="yes" xml:space="preserve">
          <source>A marker indicating the position of the end of the last output from this process inserted into the buffer. This is often but not always the end of the buffer.</source>
          <target state="translated">Маркер,указывающий на положение конца последнего вывода этого процесса,вставленного в буфер.Часто,но не всегда,это конец буфера.</target>
        </trans-unit>
        <trans-unit id="2d9513ddb58517694c738e7fbe081843e380b82c" translate="yes" xml:space="preserve">
          <source>A marker pointing to the position in the buffer that is the first character (in the logical order, see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;) displayed in the window.</source>
          <target state="translated">Маркер, указывающий на позицию в буфере, которая является первым символом (в логическом порядке, см. &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Двунаправленное отображение&lt;/a&gt; ), отображаемым в окне.</target>
        </trans-unit>
        <trans-unit id="09e41168573d8c2d601b252f527ba1cf4c63c69d" translate="yes" xml:space="preserve">
          <source>A marker represents a buffer position to jump to.</source>
          <target state="translated">Маркер представляет собой буферную позицию,в которую нужно перепрыгнуть.</target>
        </trans-unit>
        <trans-unit id="704ed7dde36adbdca349302504f832854db5ca66" translate="yes" xml:space="preserve">
          <source>A marker specifies a buffer and a position in that buffer. A marker can be used to represent a position in functions that require one, just as an integer could be used. In that case, the marker&amp;rsquo;s buffer is normally ignored. Of course, a marker used in this way usually points to a position in the buffer that the function operates on, but that is entirely the programmer&amp;rsquo;s responsibility. See &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;, for a complete description of positions.</source>
          <target state="translated">Маркер указывает буфер и позицию в этом буфере. Маркер может использоваться для представления позиции в функциях, которые требуют его, так же, как можно использовать целое число. В этом случае буфер маркера обычно игнорируется. Конечно, используемый таким образом маркер обычно указывает на позицию в буфере, с которой работает функция, но это полностью ответственность программиста. См. &lt;a href=&quot;positions#Positions&quot;&gt;Позиции&lt;/a&gt; для полного описания позиций.</target>
        </trans-unit>
        <trans-unit id="0bc36f974eb0baf86a8ea0fb18f4b0a30f0045d5" translate="yes" xml:space="preserve">
          <source>A menu item can be a vector of three elements, &lt;code&gt;[&lt;var&gt;name&lt;/var&gt;
&lt;var&gt;callback&lt;/var&gt; &lt;var&gt;enable&lt;/var&gt;]&lt;/code&gt;. &lt;var&gt;name&lt;/var&gt; is the menu item name (a string). &lt;var&gt;callback&lt;/var&gt; is a command to run, or an expression to evaluate, when the item is chosen. &lt;var&gt;enable&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the item is disabled for selection.</source>
          <target state="translated">Пункт меню может быть вектором из трех элементов, &lt;code&gt;[&lt;var&gt;name&lt;/var&gt; &lt;var&gt;callback&lt;/var&gt; &lt;var&gt;enable&lt;/var&gt;]&lt;/code&gt; . &lt;var&gt;name&lt;/var&gt; - название пункта меню (строка). &lt;var&gt;callback&lt;/var&gt; - это команда для выполнения или выражение для оценки при выборе элемента. &lt;var&gt;enable&lt;/var&gt; - это выражение; если оно равно &lt;code&gt;nil&lt;/code&gt; , элемент недоступен для выбора.</target>
        </trans-unit>
        <trans-unit id="6783cd5380d1ff982a022350fe9ec3e438f07ed2" translate="yes" xml:space="preserve">
          <source>A menu separator is a kind of menu item that doesn&amp;rsquo;t display any text&amp;mdash;instead, it divides the menu into subparts with a horizontal line. A separator looks like this in the menu keymap:</source>
          <target state="translated">Разделитель меню - это своего рода элемент меню, в котором не отображается никакой текст - вместо этого он разделяет меню на части горизонтальной линией. В раскладке меню разделитель выглядит так:</target>
        </trans-unit>
        <trans-unit id="454923c998127cc9f1ebbf5e81d874369316f380" translate="yes" xml:space="preserve">
          <source>A method of expanding an expression into another expression, more fundamental but less pretty.</source>
          <target state="translated">Метод расширения выражения в другое,более фундаментальное,но менее красивое.</target>
        </trans-unit>
        <trans-unit id="e1ebe68a6967a16e6180516760ceccb03b9f1d21" translate="yes" xml:space="preserve">
          <source>A minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;) that is not alone on its frame does not have a parent window, so it strictly speaking is not part of its frame&amp;rsquo;s window tree. Nonetheless, it is a sibling window of the frame&amp;rsquo;s root window, and thus can be reached via &lt;code&gt;window-next-sibling&lt;/code&gt;. Also, the function &lt;code&gt;window-tree&lt;/code&gt; described at the end of this section lists the minibuffer window alongside the actual window tree.</source>
          <target state="translated">Окно минибуфера (см. &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Окна минибуфера&lt;/a&gt; ), которое находится не только в своем фрейме, не имеет родительского окна, поэтому, строго говоря, оно не является частью дерева окон своего фрейма. Тем не менее, это одноуровневое окно корневого окна фрейма, и, таким образом, к нему можно получить доступ через &lt;code&gt;window-next-sibling&lt;/code&gt; . Кроме того, &lt;code&gt;window-tree&lt;/code&gt; функций, описанное в конце этого раздела, перечисляет окно минибуфера вместе с фактическим деревом окон.</target>
        </trans-unit>
        <trans-unit id="89c2b888618beed3c117f354a901a70cc356f1d6" translate="yes" xml:space="preserve">
          <source>A minibuffer window is never a candidate. A dedicated window (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;) is never a candidate unless the optional argument &lt;var&gt;dedicated&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. The selected window is not a candidate if the optional argument &lt;var&gt;not-selected&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. If the optional argument &lt;var&gt;not-selected&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and the selected window is the only candidate, this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Окно минибуфера никогда не является кандидатом. Выделенное окно (см. &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Выделенные окна&lt;/a&gt; ) никогда не является кандидатом, если необязательный аргумент &lt;var&gt;dedicated&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; . Выбранное окно не является кандидатом, если необязательный аргумент &lt;var&gt;not-selected&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; . Если необязательный аргумент &lt;var&gt;not-selected&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; и выбранное окно является единственным кандидатом, эта функция возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b599a674f06dd65226c7bca41859f38c441875f7" translate="yes" xml:space="preserve">
          <source>A minor limitation of this feature, again because it targets symbols, is that only variables of dynamic scope may be watched. This poses little difficulty, since modifications to lexical variables can be discovered easily by inspecting the code within the scope of the variable (unlike dynamic variables, which can be modified by any code at all, see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;).</source>
          <target state="translated">Незначительное ограничение этой функции, опять же из-за того, что она нацелена на символы, состоит в том, что можно наблюдать только переменные динамического диапазона. Это не представляет особых трудностей, поскольку модификации лексических переменных можно легко обнаружить, проверив код в пределах области видимости переменной (в отличие от динамических переменных, которые могут быть изменены любым кодом, см. Область видимости &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;переменных&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d236ab570a4289eb003477e38186061d1fde0262" translate="yes" xml:space="preserve">
          <source>A minor-mode function to call after visiting a file converted from this format. The function is called with one argument, the integer 1; that tells a minor-mode function to enable the mode.</source>
          <target state="translated">Функция второстепенного режима для вызова после посещения файла,преобразованного из этого формата.Функция вызывается с одним аргументом-целым числом 1,которое сообщает второстепенной функции о включении режима.</target>
        </trans-unit>
        <trans-unit id="c276708ad05da4fad726f0a5b45a06849defae13" translate="yes" xml:space="preserve">
          <source>A mode line construct may be as simple as a fixed string of text, but it usually specifies how to combine fixed strings with variables&amp;rsquo; values to construct the text. Many of these variables are themselves defined to have mode line constructs as their values.</source>
          <target state="translated">Конструкция строки режима может быть такой же простой, как фиксированная строка текста, но обычно она определяет, как объединить фиксированные строки со значениями переменных для создания текста. Многие из этих переменных сами по себе имеют конструкции строки режима в качестве значений.</target>
        </trans-unit>
        <trans-unit id="8afb42d8de6cea8a8b63620c9e3383e0c0f0f509" translate="yes" xml:space="preserve">
          <source>A module can verify that the Emacs executable which loads the module is compatible with the module, by comparing the &lt;code&gt;size&lt;/code&gt; member of the &lt;var&gt;runtime&lt;/var&gt; structure with the value compiled into the module:</source>
          <target state="translated">Модуль может проверить, что исполняемый файл Emacs, который загружает модуль, совместим с модулем, сравнив член &lt;code&gt;size&lt;/code&gt; структуры &lt;var&gt;runtime&lt;/var&gt; со значением, скомпилированным в модуль:</target>
        </trans-unit>
        <trans-unit id="348aed7380113f95130d713670b2f7bc22c14981" translate="yes" xml:space="preserve">
          <source>A module function always returns a value. If the function returns normally, the Lisp code which called it will see the Lisp object corresponding to the &lt;code&gt;emacs_value&lt;/code&gt; value the function returned. However, if the user typed</source>
          <target state="translated">Функция модуля всегда возвращает значение. Если функция вернется нормально, код Lisp, который ее вызвал, увидит объект Lisp, соответствующий значению &lt;code&gt;emacs_value&lt;/code&gt; ,которое вернула функция. Однако, если пользователь ввел</target>
        </trans-unit>
        <trans-unit id="eb0109953f2a0b65f8f6c1374782995296dbdec9" translate="yes" xml:space="preserve">
          <source>A module function has the following general form and signature:</source>
          <target state="translated">Функция модуля имеет следующую общую форму и подпись:</target>
        </trans-unit>
        <trans-unit id="9940368a099b58ff18b341d077c7d872ecd6531e" translate="yes" xml:space="preserve">
          <source>A more advanced example would be to trace the calls to the process filter of a process &lt;var&gt;proc&lt;/var&gt;:</source>
          <target state="translated">Более сложный пример будет отслеживать вызовы процесса фильтра в процессе &lt;var&gt;proc&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="f7dfdb4b11e543f8cc270a0d51db8591bd156e62" translate="yes" xml:space="preserve">
          <source>A more convenient format string for such cases would be something like &lt;code&gt;&quot;%f&amp;nbsp;%l&amp;nbsp;&amp;lt;%e&amp;gt;&quot;&lt;/code&gt;, where each specification character carries more semantic information and can easily be rearranged relative to other specification characters, making such format strings more easily customizable by the user.</source>
          <target state="translated">Более удобной строкой формата для таких случаев будет что-то вроде &lt;code&gt;&quot;%f&amp;nbsp;%l&amp;nbsp;&amp;lt;%e&amp;gt;&quot;&lt;/code&gt; , где каждый символ спецификации несет больше семантической информации и может быть легко перегруппирован относительно других символов спецификации, что упрощает настройку таких строк формата с помощью Пользователь.</target>
        </trans-unit>
        <trans-unit id="5a3d7f1ea620bc2801ba23e243907150a812ed06" translate="yes" xml:space="preserve">
          <source>A more powerful function is &lt;code&gt;store-substring&lt;/code&gt;:</source>
          <target state="translated">Более мощная функция - &lt;code&gt;store-substring&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0e8d8f144404b38e8eb77a264fc3e628792a87cf" translate="yes" xml:space="preserve">
          <source>A more powerful operation is to mark the variable as &lt;em&gt;automatically buffer-local&lt;/em&gt; by calling &lt;code&gt;make-variable-buffer-local&lt;/code&gt;. You can think of this as making the variable local in all buffers, even those yet to be created. More precisely, the effect is that setting the variable automatically makes the variable local to the current buffer if it is not already so. All buffers start out by sharing the default value of the variable as usual, but setting the variable creates a buffer-local binding for the current buffer. The new value is stored in the buffer-local binding, leaving the default binding untouched. This means that the default value cannot be changed with &lt;code&gt;setq&lt;/code&gt; in any buffer; the only way to change it is with &lt;code&gt;setq-default&lt;/code&gt;.</source>
          <target state="translated">Более мощная операция - пометить переменную как &lt;em&gt;автоматически локальную в буфере&lt;/em&gt; , вызвав &lt;code&gt;make-variable-buffer-local&lt;/code&gt; . Вы можете думать об этом как о том, чтобы сделать переменную локальной во всех буферах, даже в тех, которые еще предстоит создать. Точнее, эффект состоит в том, что установка переменной автоматически делает переменную локальной для текущего буфера, если это еще не так. Все буферы начинаются с совместного использования значения переменной по умолчанию, как обычно, но установка переменной создает привязку к локальному буферу для текущего буфера. Новое значение сохраняется в привязке локального буфера, оставляя привязку по умолчанию нетронутой. Это означает, что значение по умолчанию нельзя изменить с помощью &lt;code&gt;setq&lt;/code&gt; в любом буфере; единственный способ изменить это с помощью &lt;code&gt;setq-default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd57642f42b5205af6e02818c9a3f1fe9a885aae" translate="yes" xml:space="preserve">
          <source>A multi-file package is less convenient to create than a single-file package, but it offers more features: it can include multiple Emacs Lisp files, an Info manual, and other file types (such as images).</source>
          <target state="translated">Многофайловый пакет менее удобен в создании,чем однофайловый,но имеет больше возможностей:он может включать в себя несколько файлов Emacs Lisp,руководство Info и другие типы файлов (например,изображения).</target>
        </trans-unit>
        <trans-unit id="fc6654118704a5566d1ff1cdbb86919396f3250f" translate="yes" xml:space="preserve">
          <source>A multi-frame image has a property &lt;code&gt;:index&lt;/code&gt;, whose value is an integer (counting from 0) that specifies which frame is being displayed.</source>
          <target state="translated">Многокадровое изображение имеет свойство &lt;code&gt;:index&lt;/code&gt; , значение которого является целым числом (считая от 0), указывающим, какой кадр отображается.</target>
        </trans-unit>
        <trans-unit id="b4d504d5e42e9c61bf870243dcef604603b80aa9" translate="yes" xml:space="preserve">
          <source>A multi-use object that refers to a function, variable, or property list, and has a unique identity.</source>
          <target state="translated">Многоцелевой объект,который ссылается на функцию,переменную или список свойств,и имеет уникальную идентичность.</target>
        </trans-unit>
        <trans-unit id="6d71bbf0c51fcb0696b8faf36cf9fec0e3aa991a" translate="yes" xml:space="preserve">
          <source>A mutable object stops being mutable if it is part of an expression that is evaluated. For example:</source>
          <target state="translated">Мутируемый объект перестает быть мутируемым,если он является частью выражения,которое оценивается.Например:</target>
        </trans-unit>
        <trans-unit id="6888a521ac5206883d93875783df2620806f55a5" translate="yes" xml:space="preserve">
          <source>A negative number</source>
          <target state="translated">отрицательное число</target>
        </trans-unit>
        <trans-unit id="e9f4501d43e4d90ee2f96cf1abe12d4d05922e4e" translate="yes" xml:space="preserve">
          <source>A negative number counts from the end of the string, so that -1 signifies the index of the last character of the string. For example:</source>
          <target state="translated">Отрицательное число отсчитывается от конца строки,так что -1 означает индекс последнего символа строки.Например:</target>
        </trans-unit>
        <trans-unit id="2e25842cb9b14194506db7c6020a25184de4be86" translate="yes" xml:space="preserve">
          <source>A negative number has a similar effect as a positive number, but selects the window under the mouse pointer only after the mouse pointer has remained in it for the entire duration of the absolute value of that number and in addition has stopped moving.</source>
          <target state="translated">Отрицательное число имеет тот же эффект,что и положительное число,но выбирает окно под указателем мыши только после того,как указатель мыши остался в нем на все время абсолютного значения этого числа и,кроме того,перестал двигаться.</target>
        </trans-unit>
        <trans-unit id="da4adefdf857b6336231abc20b5b558c2ad6342c" translate="yes" xml:space="preserve">
          <source>A nested sub-alist element looks like this:</source>
          <target state="translated">Вложенный субалистический элемент выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="a12a25db6b08bb0eb9d657dfc01a94bb05fe63fe" translate="yes" xml:space="preserve">
          <source>A new internal window &lt;var&gt;W5&lt;/var&gt; has been created; its children are &lt;var&gt;W2&lt;/var&gt; and the new live window &lt;var&gt;W4&lt;/var&gt;. Now, &lt;var&gt;W2&lt;/var&gt; is the only sibling of &lt;var&gt;W4&lt;/var&gt;, so enlarging &lt;var&gt;W4&lt;/var&gt; will try to shrink &lt;var&gt;W2&lt;/var&gt;, leaving &lt;var&gt;W3&lt;/var&gt; unaffected. Observe that &lt;var&gt;W5&lt;/var&gt; represents a vertical combination of two windows embedded in the vertical combination &lt;var&gt;W1&lt;/var&gt;.</source>
          <target state="translated">Создано новое внутреннее окно &lt;var&gt;W5&lt;/var&gt; ; его дочерние элементы - это &lt;var&gt;W2&lt;/var&gt; , а новое окно реального времени - &lt;var&gt;W4&lt;/var&gt; . Теперь &lt;var&gt;W2&lt;/var&gt; - единственный брат &lt;var&gt;W4&lt;/var&gt; , поэтому увеличение &lt;var&gt;W4&lt;/var&gt; будет пытаться сжать &lt;var&gt;W2&lt;/var&gt; , не затрагивая &lt;var&gt;W3&lt;/var&gt; . Обратите внимание, что &lt;var&gt;W5&lt;/var&gt; представляет собой вертикальную комбинацию двух окон, встроенных в вертикальную комбинацию &lt;var&gt;W1&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="8e90e2d8579d4e6fb87c1c41547020d8e134911b" translate="yes" xml:space="preserve">
          <source>A new live window &lt;var&gt;W2&lt;/var&gt; is created, to the left of the internal window &lt;var&gt;W3&lt;/var&gt;. A new internal window &lt;var&gt;W1&lt;/var&gt; is created, becoming the new root window.</source>
          <target state="translated">Слева от внутреннего окна &lt;var&gt;W3&lt;/var&gt; создается новое окно реального времени &lt;var&gt;W2&lt;/var&gt; . Создается новое внутреннее окно &lt;var&gt;W1&lt;/var&gt; , которое становится новым корневым окном.</target>
        </trans-unit>
        <trans-unit id="e0f54cfb880806196378b4a34cf642931e193eb7" translate="yes" xml:space="preserve">
          <source>A new window, however, will be created by splitting the reference window such that the chosen window will share the opposite edge with the reference window. In our example, a new root window would be created with a new live window and the reference window as its children. The chosen window&amp;rsquo;s right edge coordinate would then equal the left edge coordinate of the reference window. Its left edge coordinate would equal the left edge coordinate of the frame&amp;rsquo;s new root window.</source>
          <target state="translated">Однако новое окно будет создано путем разделения контрольного окна таким образом, чтобы выбранное окно делило противоположный край с контрольным окном. В нашем примере будет создано новое корневое окно с новым живым окном и опорным окном в качестве его дочерних элементов. правый край выбранного окна координата будет тогда равняться левый край координаты опорного окна. Координата его левого края будет равна координате левого края нового корневого окна фрейма.</target>
        </trans-unit>
        <trans-unit id="e78fb6263a1080feaf13664527cc8aee4aa494cc" translate="yes" xml:space="preserve">
          <source>A newline can have a &lt;code&gt;line-height&lt;/code&gt; text or overlay property that controls the total height of the display line ending in that newline.</source>
          <target state="translated">Новая &lt;code&gt;line-height&lt;/code&gt; может иметь текст высотой строки или свойство наложения, которое управляет общей высотой отображаемой строки, заканчивающейся этой новой строкой.</target>
        </trans-unit>
        <trans-unit id="9d4a406b984bf68d93883ae0aaacc2f86b270542" translate="yes" xml:space="preserve">
          <source>A newline can have a &lt;code&gt;line-height&lt;/code&gt; text or overlay property that controls the total height of the display line ending in that newline. See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;.</source>
          <target state="translated">Новая &lt;code&gt;line-height&lt;/code&gt; может иметь текст высотой строки или свойство наложения, которое управляет общей высотой отображаемой строки, заканчивающейся этой новой строкой. См. &lt;a href=&quot;line-height#Line-Height&quot;&gt;Высоту линии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c8bf6a760bbc674a4774ccb47c86778b816aa24" translate="yes" xml:space="preserve">
          <source>A newline can have a &lt;code&gt;line-spacing&lt;/code&gt; text or overlay property that controls the height of the display line ending with that newline. The property value overrides the default frame line spacing and the buffer local &lt;code&gt;line-spacing&lt;/code&gt; variable. See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;.</source>
          <target state="translated">Новая &lt;code&gt;line-spacing&lt;/code&gt; может иметь текстовый интервал или свойство наложения, которое управляет высотой отображаемой строки, заканчивающейся этой новой строкой. Значение свойства переопределяет межстрочный интервал между кадрами по умолчанию и локальную переменную &lt;code&gt;line-spacing&lt;/code&gt; буфера . См. &lt;a href=&quot;line-height#Line-Height&quot;&gt;Высоту линии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11021806fd752c764a129675338bc40ee3fdba04" translate="yes" xml:space="preserve">
          <source>A nine-element vector &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;e&lt;/var&gt;
&lt;var&gt;f&lt;/var&gt; &lt;var&gt;g&lt;/var&gt; &lt;var&gt;h&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; represents an IPv6 address along with a port number. &lt;code&gt;format-network-address&lt;/code&gt; converts that to the string &lt;code&gt;&quot;[&lt;var&gt;a&lt;/var&gt;:&lt;var&gt;b&lt;/var&gt;:&lt;var&gt;c&lt;/var&gt;:&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;e&lt;/var&gt;:&lt;var&gt;f&lt;/var&gt;:&lt;var&gt;g&lt;/var&gt;:&lt;var&gt;h&lt;/var&gt;]:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Вектор из девяти элементов &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;e&lt;/var&gt; &lt;var&gt;f&lt;/var&gt; &lt;var&gt;g&lt;/var&gt; &lt;var&gt;h&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; представляет IPv6-адрес вместе с номером порта. &lt;code&gt;format-network-address&lt;/code&gt; преобразует это в строку &lt;code&gt;&quot;[&lt;var&gt;a&lt;/var&gt;:&lt;var&gt;b&lt;/var&gt;:&lt;var&gt;c&lt;/var&gt;:&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;e&lt;/var&gt;:&lt;var&gt;f&lt;/var&gt;:&lt;var&gt;g&lt;/var&gt;:&lt;var&gt;h&lt;/var&gt;]:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="257aa05b7eddcf8d0df8b79a44b34b5bae0010cd" translate="yes" xml:space="preserve">
          <source>A node &lt;em&gt;encapsulates&lt;/em&gt; a data element much the way a variable holds a value. Normally, encapsulation occurs as a part of adding a node to the ewoc. You can retrieve the data element value and place a new value in its place, like so:</source>
          <target state="translated">Узел &lt;em&gt;инкапсулирует&lt;/em&gt; элемент данных во многом так же, как переменная хранит значение. Обычно инкапсуляция происходит как часть добавления узла в ewoc. Вы можете получить значение элемента данных и поместить на его место новое значение, например:</target>
        </trans-unit>
        <trans-unit id="538490c91b8e54e71e0f8ac6a28516d887289f24" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value also means that when &lt;code&gt;display-buffer&lt;/code&gt; is looking for a window already displaying &lt;var&gt;buffer-or-name&lt;/var&gt;, it can search any visible or iconified frame, not just the selected frame.</source>
          <target state="translated">Не- &lt;code&gt;nil&lt;/code&gt; значение также означает , что , когда &lt;code&gt;display-buffer&lt;/code&gt; ищет окна уже отображается &lt;var&gt;buffer-or-name&lt;/var&gt; , он может искать какой - либо видимый или свернутый кадр, а не только выбранный кадр.</target>
        </trans-unit>
        <trans-unit id="0546509f02b872fbaf2e962a3d60dc4ba6951208" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value for &lt;code&gt;save-abbrevs&lt;/code&gt; means that Emacs should offer to save abbrevs (if any have changed) when files are saved. If the value is &lt;code&gt;silently&lt;/code&gt;, Emacs saves the abbrevs without asking the user. &lt;code&gt;abbrev-file-name&lt;/code&gt; specifies the file to save the abbrevs in. The default value is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Не- &lt;code&gt;nil&lt;/code&gt; значение для &lt;code&gt;save-abbrevs&lt;/code&gt; означает , что Emacs должен предложить сохранить сокращения , (если изменились) , когда файлы будут сохранены. Если значение задано &lt;code&gt;silently&lt;/code&gt; , Emacs сохраняет сокращения, не спрашивая пользователя. &lt;code&gt;abbrev-file-name&lt;/code&gt; указывает файл, в котором будут сохранены сокращения. Значение по умолчанию - &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b743dba1b96b6f3a754be1bd1d208ff3d9b301ed" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value indicates that the named function is free of side effects (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;), so the byte compiler may ignore a call whose value is unused. If the property&amp;rsquo;s value is &lt;code&gt;error-free&lt;/code&gt;, the byte compiler may even delete such unused calls. In addition to byte compiler optimizations, this property is also used for determining function safety (see &lt;a href=&quot;function-safety#Function-Safety&quot;&gt;Function Safety&lt;/a&gt;).</source>
          <target state="translated">Не- &lt;code&gt;nil&lt;/code&gt; значением указывает на то, что названная функция свободна от побочных эффектов (см &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;Что такое функция&lt;/a&gt; ), поэтому байт компилятор может игнорировать вызов, значение которого используется. Если значение свойства не содержит &lt;code&gt;error-free&lt;/code&gt; , байтовый компилятор может даже удалить такие неиспользуемые вызовы. В дополнение к оптимизации компилятора байтов, это свойство также используется для определения безопасности функции (см. &lt;a href=&quot;function-safety#Function-Safety&quot;&gt;Безопасность функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="68d8637c2c063f5d516fcb409cb0bfe1e6ec8eb6" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value prevents another frame from being raised or selected, if the window chosen by &lt;code&gt;display-buffer&lt;/code&gt; is displayed there. Primarily affected by this are &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt; and &lt;code&gt;display-buffer-reuse-window&lt;/code&gt;. &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; should be affected as well, but there is no guarantee that the window manager will comply.</source>
          <target state="translated">Значение, отличное от &lt;code&gt;nil&lt;/code&gt; , предотвращает появление или выбор другого кадра, если там &lt;code&gt;display-buffer&lt;/code&gt; окно, выбранное display-buffer . В первую очередь это касается &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt; и &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; . &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; также должны быть затронуты, но нет гарантии, что оконный менеджер будет соответствовать.</target>
        </trans-unit>
        <trans-unit id="f7b66ab735a6729f6954795dc552d7446c33c1da" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;invisible&lt;/code&gt; property can make a character invisible on the screen. See &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;, for details.</source>
          <target state="translated">Свойство &lt;code&gt;invisible&lt;/code&gt; , отличное от &lt;code&gt;nil&lt;/code&gt; , может сделать персонаж невидимым на экране. См. &amp;laquo; &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Невидимый текст&amp;raquo;&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="2242bd96c0d6345a1c62e452fe3a19f8f5f50094" translate="yes" xml:space="preserve">
          <source>A non-sparse keymap can have a parent too, but this is not very useful. A non-sparse keymap always specifies something as the binding for every numeric character code without modifier bits, even if it is &lt;code&gt;nil&lt;/code&gt;, so these character&amp;rsquo;s bindings are never inherited from the parent keymap.</source>
          <target state="translated">Не разреженная раскладка клавиатуры тоже может иметь родителя, но это не очень полезно. Неразрезанная раскладка всегда указывает что-то в качестве привязки для каждого числового кода символа без битов модификатора, даже если она равна &lt;code&gt;nil&lt;/code&gt; , поэтому привязки этих символов никогда не наследуются от родительской раскладки.</target>
        </trans-unit>
        <trans-unit id="96fdb38fb061323696d5e6da2be26efebae2b6ce" translate="yes" xml:space="preserve">
          <source>A non-zero value means the fringes outside the display margins; othersize they are between the margin and the text.</source>
          <target state="translated">Ненулевое значение означает бахрому за пределами полей дисплея;другой размер-между полями и текстом.</target>
        </trans-unit>
        <trans-unit id="1e856f1217fd9e054bd7c26d7ccd34fcad9679df" translate="yes" xml:space="preserve">
          <source>A non-zero value means the window&amp;rsquo;s buffer was modified when the window was last updated.</source>
          <target state="translated">Ненулевое значение означает, что буфер окна был изменен при последнем обновлении окна.</target>
        </trans-unit>
        <trans-unit id="f4ced26d5ee072b933c88766864abe951040432f" translate="yes" xml:space="preserve">
          <source>A normal hook run by &lt;code&gt;make-frame&lt;/code&gt; before it creates the frame.</source>
          <target state="translated">Обычный обработчик, запускаемый &lt;code&gt;make-frame&lt;/code&gt; до создания кадра.</target>
        </trans-unit>
        <trans-unit id="e085a7032b28a27db16c87868f46e839741bf52e" translate="yes" xml:space="preserve">
          <source>A normal hook run when the Emacs server creates a client frame. When this hook is called, the created frame is the selected one. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; in</source>
          <target state="translated">Обычная ловушка запускается, когда сервер Emacs создает клиентский фрейм. Когда этот хук вызывается, созданный фрейм становится выбранным. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="b62cb052fd5ad4290656350fa794c8ea089c6d5c" translate="yes" xml:space="preserve">
          <source>A normal hook run when the Emacs server creates a client frame. When this hook is called, the created frame is the selected one. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b2704fab7bbe92fe40d18eb3d4fc4767c355fa" translate="yes" xml:space="preserve">
          <source>A note to C programmers: a Lisp list thus works as a &lt;em&gt;linked list&lt;/em&gt; built up of cons cells. Because pointers in Lisp are implicit, we do not distinguish between a cons cell slot holding a value versus pointing to the value.</source>
          <target state="translated">Примечание для программистов на C: список Lisp, таким образом, работает как &lt;em&gt;связанный список,&lt;/em&gt; состоящий из cons-ячеек. Поскольку указатели в Лиспе неявны, мы не делаем различия между слотом cons-ячейки, содержащим значение, и указателем на значение.</target>
        </trans-unit>
        <trans-unit id="8bf2ac93cadbf3bbb911da1d57b28b3c7ca4f30c" translate="yes" xml:space="preserve">
          <source>A number stands for itself. If &lt;code&gt;insert-register&lt;/code&gt; finds a number in the register, it converts the number to decimal.</source>
          <target state="translated">Число означает само себя. Если &lt;code&gt;insert-register&lt;/code&gt; находит число в регистре, он преобразует это число в десятичное.</target>
        </trans-unit>
        <trans-unit id="fbb60e0d4701e93358add5c45d04ef4a9d9e341e" translate="yes" xml:space="preserve">
          <source>A number, &lt;var&gt;factor&lt;/var&gt;, means to use a font that is &lt;var&gt;factor&lt;/var&gt; times as tall as the default font.</source>
          <target state="translated">Число, &lt;var&gt;factor&lt;/var&gt; , означает использование шрифта, который в несколько &lt;var&gt;factor&lt;/var&gt; превышает высоту шрифта по умолчанию.</target>
        </trans-unit>
        <trans-unit id="12ed92f05eab35deca7fec65e22fd2ef456204a0" translate="yes" xml:space="preserve">
          <source>A number, read with the minibuffer. If the input is not a number, the user has to try again. &amp;lsquo;</source>
          <target state="translated">Число, считываемое с помощью минибуфера. Если введено не число, пользователь должен повторить попытку. '</target>
        </trans-unit>
        <trans-unit id="b18f7887ca8513454d55a4d747d8dd6eecba2669" translate="yes" xml:space="preserve">
          <source>A package archive is simply a directory in which the package files, and associated files, are stored. If you want the archive to be reachable via HTTP, this directory must be accessible to a web server; See &lt;a href=&quot;archive-web-server#Archive-Web-Server&quot;&gt;Archive Web Server&lt;/a&gt;.</source>
          <target state="translated">Архив пакетов - это просто каталог, в котором хранятся файлы пакетов и связанные файлы. Если вы хотите, чтобы архив был доступен через HTTP, этот каталог должен быть доступен веб-серверу; См. &lt;a href=&quot;archive-web-server#Archive-Web-Server&quot;&gt;Архивный веб-сервер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8bca31273aea629d01827e859940f97c7f10f48" translate="yes" xml:space="preserve">
          <source>A package is either a &lt;em&gt;simple package&lt;/em&gt; or a &lt;em&gt;multi-file package&lt;/em&gt;. A simple package is stored in a package archive as a single Emacs Lisp file, while a multi-file package is stored as a tar file (containing multiple Lisp files, and possibly non-Lisp files such as a manual).</source>
          <target state="translated">Пакет - это &lt;em&gt;простой&lt;/em&gt; или &lt;em&gt;многофайловый пакет&lt;/em&gt; . Простой пакет хранится в архиве пакетов как один файл Emacs Lisp, тогда как многофайловый пакет хранится как файл tar (содержащий несколько файлов Lisp и, возможно, файлы, не относящиеся к Lisp, такие как руководство).</target>
        </trans-unit>
        <trans-unit id="e856d8db6bbaad896bdc3b1232335f7c837149d7" translate="yes" xml:space="preserve">
          <source>A pair of integers &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt; . &lt;var&gt;hz&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;hz&lt;/var&gt; is positive. This represents &lt;var&gt;ticks&lt;/var&gt;/&lt;var&gt;hz&lt;/var&gt; seconds, which is the same time as plain &lt;var&gt;ticks&lt;/var&gt; if &lt;var&gt;hz&lt;/var&gt; is 1. A common value for &lt;var&gt;hz&lt;/var&gt; is 1000000000, for a nanosecond-resolution clock.&lt;a href=&quot;#FOOT24&quot; name=&quot;DOCF24&quot;&gt;&lt;sup&gt;24&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">Пара целых чисел &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt; . &lt;var&gt;hz&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;hz&lt;/var&gt; положительно. Он представляет &lt;var&gt;ticks&lt;/var&gt; / &lt;var&gt;hz&lt;/var&gt; секунд, что является тем же временем, что и обычные &lt;var&gt;ticks&lt;/var&gt; если &lt;var&gt;hz&lt;/var&gt; равно 1. Обычное значение для &lt;var&gt;hz&lt;/var&gt; - 1000000000 для часов с разрешением наносекунды. &lt;a href=&quot;#FOOT24&quot; name=&quot;DOCF24&quot;&gt;&lt;sup&gt;24&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef07d2e6711012f848d582415b0eef1559c6b894" translate="yes" xml:space="preserve">
          <source>A peculiar wrinkle of this feature is that binding the variable (with &lt;code&gt;let&lt;/code&gt; or other binding constructs) does not create a buffer-local binding for it. Only setting the variable (with &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;setq&lt;/code&gt;), while the variable does not have a &lt;code&gt;let&lt;/code&gt;-style binding that was made in the current buffer, does so.</source>
          <target state="translated">Особенностью этой функции является то, что привязка переменной (с &lt;code&gt;let&lt;/code&gt; или другими связующими конструкциями) не создает для нее локальной привязки к буферу. Только установка переменной (с помощью &lt;code&gt;set&lt;/code&gt; или &lt;code&gt;setq&lt;/code&gt; ), пока переменная не имеет привязки &lt;code&gt;let&lt;/code&gt; -style, которая была сделана в текущем буфере, делает это.</target>
        </trans-unit>
        <trans-unit id="65536651f3f1ec2171ac27cb6241d27ce7c4b3bb" translate="yes" xml:space="preserve">
          <source>A piece of executable code you can call from elsewhere.</source>
          <target state="translated">Кусок исполняемого кода,который можно вызвать из другого места.</target>
        </trans-unit>
        <trans-unit id="016d0dc9545552ea2f3842743d3079ba4d84de5b" translate="yes" xml:space="preserve">
          <source>A place-holder for a real function. If the autoload object is called, Emacs loads the file containing the definition of the real function, and then calls the real function. See &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;.</source>
          <target state="translated">Заполнитель для реальной функции. Если вызывается объект автозагрузки, Emacs загружает файл, содержащий определение реальной функции, а затем вызывает настоящую функцию. См. &lt;a href=&quot;autoload#Autoload&quot;&gt;Автозагрузка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a22f28df4d8c16ca0f7b01c3698b6f622a0739c" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;buffer_text&lt;/code&gt; structure for this buffer. In an ordinary buffer, this is the &lt;code&gt;own_text&lt;/code&gt; field above. In an indirect buffer, this is the &lt;code&gt;own_text&lt;/code&gt; field of the base buffer.</source>
          <target state="translated">Указатель на структуру &lt;code&gt;buffer_text&lt;/code&gt; для этого буфера. В обычном буфере это поле &lt;code&gt;own_text&lt;/code&gt; выше. В косвенном буфере это поле &lt;code&gt;own_text&lt;/code&gt; базового буфера.</target>
        </trans-unit>
        <trans-unit id="570f25dd8cbde7553399581a7984cd58caf0d35b" translate="yes" xml:space="preserve">
          <source>A pointer to the next buffer, in the chain of all buffers, including killed buffers. This chain is used only for allocation and garbage collection, in order to collect killed buffers properly.</source>
          <target state="translated">Указатель на следующий буфер,в цепочке всех буферов,включая убитые.Эта цепочка используется только для распределения и сбора мусора,чтобы правильно собрать убитые буферы.</target>
        </trans-unit>
        <trans-unit id="57379d0a3548b0207ddf3db6f5db3f7110d0b085" translate="yes" xml:space="preserve">
          <source>A polygon is a cons &lt;code&gt;(poly . [&lt;var&gt;x0&lt;/var&gt; &lt;var&gt;y0&lt;/var&gt; &lt;var&gt;x1&lt;/var&gt; &lt;var&gt;y1&lt;/var&gt; ...])&lt;/code&gt; where each pair in the vector describes one corner in the polygon.</source>
          <target state="translated">Многоугольник - это минус &lt;code&gt;(poly . [&lt;var&gt;x0&lt;/var&gt; &lt;var&gt;y0&lt;/var&gt; &lt;var&gt;x1&lt;/var&gt; &lt;var&gt;y1&lt;/var&gt; ...])&lt;/code&gt; где каждая пара в векторе описывает один угол в многоугольнике.</target>
        </trans-unit>
        <trans-unit id="6d184f39a07a100cdc18527abf48e77c7d525171" translate="yes" xml:space="preserve">
          <source>A position in a buffer.</source>
          <target state="translated">Позиция в буфере.</target>
        </trans-unit>
        <trans-unit id="2e300e61cf6c874347a9d67084477385216e6483" translate="yes" xml:space="preserve">
          <source>A positive &lt;var&gt;delta&lt;/var&gt; moves the edge downwards or to the right; a negative &lt;var&gt;delta&lt;/var&gt; moves it upwards or to the left. If the edge cannot be moved as far as specified by &lt;var&gt;delta&lt;/var&gt;, this function moves it as far as possible but does not signal an error.</source>
          <target state="translated">Положительная &lt;var&gt;delta&lt;/var&gt; перемещает край вниз или вправо; отрицательная &lt;var&gt;delta&lt;/var&gt; перемещает его вверх или влево. Если край не может быть перемещен так далеко, как указано &lt;var&gt;delta&lt;/var&gt; , эта функция перемещает его как можно дальше, но не сигнализирует об ошибке.</target>
        </trans-unit>
        <trans-unit id="00aee430f7407880b2ed8ae8e14a657999cb9fc2" translate="yes" xml:space="preserve">
          <source>A positive integer always relates the left edge of the frame to the left edge of its display or parent frame. A negative integer relates the right frame edge to the right edge of the display or parent frame.</source>
          <target state="translated">Положительное целое число всегда связывает левый край кадра с левым краем его отображения или родительского кадра.Отрицательное целое число связывает правый край кадра с правым краем дисплея или родительского кадра.</target>
        </trans-unit>
        <trans-unit id="b5ffcdb1646a361febcec1ea23f34bdb7945e518" translate="yes" xml:space="preserve">
          <source>A positive integer specifies the width of the frame&amp;rsquo;s text area (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) in characters.</source>
          <target state="translated">Положительное целое число определяет ширину текстовой области &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;фрейма&lt;/a&gt; (см. Геометрия фрейма ) в символах.</target>
        </trans-unit>
        <trans-unit id="ca19f2cd0cc62d23b3cfa1a1fcdc05db8c699a78" translate="yes" xml:space="preserve">
          <source>A positive number</source>
          <target state="translated">положительное число</target>
        </trans-unit>
        <trans-unit id="90c812fcb50800a70596785c5c0f3157cdfad686" translate="yes" xml:space="preserve">
          <source>A positive value of &lt;var&gt;delta&lt;/var&gt; means to check whether the window can be enlarged by that number of lines or columns; a negative value of &lt;var&gt;delta&lt;/var&gt; means to check whether the window can be shrunk by that many lines or columns. If &lt;var&gt;delta&lt;/var&gt; is non-zero, a return value of 0 means that the window cannot be resized.</source>
          <target state="translated">Положительное значение &lt;var&gt;delta&lt;/var&gt; означает проверку, можно ли увеличить окно на это количество строк или столбцов; отрицательное значение &lt;var&gt;delta&lt;/var&gt; означает проверку, можно ли уменьшить окно на такое количество строк или столбцов. Если &lt;var&gt;delta&lt;/var&gt; не равна нулю, возвращаемое значение 0 означает, что размер окна изменить нельзя.</target>
        </trans-unit>
        <trans-unit id="faaf39aa6748e84922a13fdbf38017d24158baa6" translate="yes" xml:space="preserve">
          <source>A predicate function with which to filter possible matches, or &lt;code&gt;nil&lt;/code&gt; if none. The function should call the predicate for each possible match, and ignore the match if the predicate returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Функция-предикат, с помощью которой можно фильтровать возможные совпадения или &lt;code&gt;nil&lt;/code&gt; , если их нет. Функция должна вызывать предикат для каждого возможного совпадения и игнорировать совпадение, если предикат возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f75a5fa3a933e8bb3e9c6cbfd95d79808fdc8fe4" translate="yes" xml:space="preserve">
          <source>A predicate&amp;mdash;that is, a function of one argument that returns either &lt;code&gt;nil&lt;/code&gt; or non-&lt;code&gt;nil&lt;/code&gt; according to the argument. Using a predicate in the list says that objects for which the predicate returns non-&lt;code&gt;nil&lt;/code&gt; are acceptable.</source>
          <target state="translated">Предикат, то есть функция одного аргумента, которая возвращает либо &lt;code&gt;nil&lt;/code&gt; либо &lt;code&gt;nil&lt;/code&gt; зависимости от аргумента. Использование предиката в списке означает, что допустимы объекты, для которых предикат возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b10591c3a6de57d65c5089bf32dbdfd76eeb6cd9" translate="yes" xml:space="preserve">
          <source>A primitive that is like a function but does not evaluate all of its arguments in the usual way. It may evaluate only some of the arguments, or may evaluate them in an unusual order, or several times. Examples include &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, and &lt;code&gt;while&lt;/code&gt;. See &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Special Forms&lt;/a&gt;.</source>
          <target state="translated">Примитив, который похож на функцию, но не оценивает все свои аргументы обычным образом. Он может оценивать только некоторые из аргументов, а может оценивать их в необычном порядке или несколько раз. Примеры включают &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , и &lt;code&gt;while&lt;/code&gt; . См. &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Специальные формы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b579867d6cd890e864414d728157548f1b508fd1" translate="yes" xml:space="preserve">
          <source>A problem that will seriously impair Emacs operation soon if you do not attend to it promptly.</source>
          <target state="translated">Проблема,которая в скором времени серьезно ухудшит работу Emacs,если вы не займетесь ей в ближайшее время.</target>
        </trans-unit>
        <trans-unit id="618f1e47e98772bcc8e7d133445246d27c02428e" translate="yes" xml:space="preserve">
          <source>A process &lt;em&gt;filter function&lt;/em&gt; is a function that receives the standard output from the associated process. &lt;em&gt;All&lt;/em&gt; output from that process is passed to the filter. The default filter simply outputs directly to the process buffer.</source>
          <target state="translated">Функция &lt;em&gt;фильтрации&lt;/em&gt; процесса - это функция, которая получает стандартный вывод от связанного процесса. &lt;em&gt;Все&lt;/em&gt; выходные данные этого процесса передаются фильтру. Фильтр по умолчанию просто выводит данные непосредственно в буфер процесса.</target>
        </trans-unit>
        <trans-unit id="42b4112adc62fa10e873c69e88cadab9c30de1e8" translate="yes" xml:space="preserve">
          <source>A process can (and usually does) have an &lt;em&gt;associated buffer&lt;/em&gt;, which is an ordinary Emacs buffer that is used for two purposes: storing the output from the process, and deciding when to kill the process. You can also use the buffer to identify a process to operate on, since in normal practice only one process is associated with any given buffer. Many applications of processes also use the buffer for editing input to be sent to the process, but this is not built into Emacs Lisp.</source>
          <target state="translated">Процесс может (и обычно имеет) &lt;em&gt;связанный буфер&lt;/em&gt; , который является обычным буфером Emacs, который используется для двух целей: для хранения выходных данных процесса и принятия решения о том, когда завершить процесс. Вы также можете использовать буфер для идентификации процесса, над которым нужно работать, поскольку в обычной практике с любым заданным буфером связан только один процесс. Многие приложения процессов также используют буфер для редактирования ввода, отправляемого процессу, но он не встроен в Emacs Lisp.</target>
        </trans-unit>
        <trans-unit id="b9529b352bcf05c67171a60f84faa1cb5c0b72d2" translate="yes" xml:space="preserve">
          <source>A prompt immediately follows the code character. The prompt ends either with the end of the string or with a newline.</source>
          <target state="translated">Подсказка сразу же следует за кодовым символом.Подсказка заканчивается либо концом строки,либо новой строкой.</target>
        </trans-unit>
        <trans-unit id="5c8c3454642c57a58973a211104a3e9fe7826baf" translate="yes" xml:space="preserve">
          <source>A pseudo-Lisp summary of searching active maps.</source>
          <target state="translated">Псевдо-список о поиске активных карт.</target>
        </trans-unit>
        <trans-unit id="3cad1be83cf5d8d04672aa32ebef05f6a9b2fc4d" translate="yes" xml:space="preserve">
          <source>A question followed by an answer has two messages like the ones produced by &lt;code&gt;y-or-n-p&lt;/code&gt;: the first is &amp;lsquo;</source>
          <target state="translated">Вопрос, за которым следует ответ, содержит два сообщения, подобных тем, которые были созданы &lt;code&gt;y-or-n-p&lt;/code&gt; : первое - '</target>
        </trans-unit>
        <trans-unit id="8ea502c0ed6ef5dfe4f9ef1e23c5f6d04605cf5f" translate="yes" xml:space="preserve">
          <source>A quoted constant&amp;mdash;that is, &lt;code&gt;'&lt;var&gt;object&lt;/var&gt;&lt;/code&gt;. This sort of element in the list says that &lt;var&gt;object&lt;/var&gt; itself is an acceptable value.</source>
          <target state="translated">В кавычках постоянной , то есть &lt;code&gt;'&lt;var&gt;object&lt;/var&gt;&lt;/code&gt; . Такой элемент в списке говорит о том, что сам &lt;var&gt;object&lt;/var&gt; является приемлемым значением.</target>
        </trans-unit>
        <trans-unit id="242ca05185b3294d6a0d632822a42b3a5da80025" translate="yes" xml:space="preserve">
          <source>A range is not affected by the locale&amp;rsquo;s collation sequence: it always represents the set of characters with codepoints ranging between those of its bounds, so that &amp;lsquo;</source>
          <target state="translated">На диапазон не влияет последовательность сопоставления языкового стандарта: он всегда представляет собой набор символов с кодовыми точками, находящимися между его границами, так что '</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
