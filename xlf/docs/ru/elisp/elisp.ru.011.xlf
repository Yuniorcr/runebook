<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="9b260f60b0da661c6386e4a8c57481caca5f924e" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt; and the initial minibuffer contents are empty, the user may have to explicitly fetch the next history element to access a default value. If the variable is non-&lt;code&gt;nil&lt;/code&gt;, the initial minibuffer contents are always non-empty and the user can always request a default value by immediately typing</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;nil&lt;/code&gt; и начальное содержимое минибуфера пусто, пользователю, возможно, придется явно выбрать следующий элемент истории, чтобы получить доступ к значению по умолчанию. Если переменная не равна &lt;code&gt;nil&lt;/code&gt; , начальное содержимое минибуфера всегда непусто, и пользователь всегда может запросить значение по умолчанию, немедленно набрав</target>
        </trans-unit>
        <trans-unit id="4a377c85d375a1d05f2bc24d6a94706665f459b2" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;split-window&lt;/code&gt; can only split a window (denoted by &lt;var&gt;window&lt;/var&gt;) if &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s screen area is large enough to accommodate both itself and the new window.</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;split-window&lt;/code&gt; может разделить окно (обозначается &lt;var&gt;window&lt;/var&gt; ) только в том случае, если область экрана &lt;var&gt;window&lt;/var&gt; достаточно велика, чтобы разместить как само окно, так и новое окно.</target>
        </trans-unit>
        <trans-unit id="e5efa0bdf46c1cfda3ed747418a3db73ea898921" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;switch-to-buffer&lt;/code&gt; displays the buffer specified by &lt;var&gt;buffer-or-name&lt;/var&gt; at the position of that buffer&amp;rsquo;s &lt;code&gt;point&lt;/code&gt;. If this variable is &lt;code&gt;already-displayed&lt;/code&gt;, it tries to display the buffer at its previous position in the selected window, provided the buffer is currently displayed in some other window on any visible or iconified frame. If this variable is &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;switch-to-buffer&lt;/code&gt; unconditionally tries to display the buffer at its previous position in the selected window.</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;nil&lt;/code&gt; , при &lt;code&gt;switch-to-buffer&lt;/code&gt; отображается буфер, указанный параметром &lt;var&gt;buffer-or-name&lt;/var&gt; , в позиции &lt;code&gt;point&lt;/code&gt; этого буфера . Если эта переменная &lt;code&gt;already-displayed&lt;/code&gt; , она пытается отобразить буфер в его предыдущей позиции в выбранном окне, при условии, что буфер в настоящее время отображается в каком-либо другом окне в любом видимом или отображаемом фрейме. Если эта переменная равна &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;switch-to-buffer&lt;/code&gt; безоговорочно пытается отобразить буфер в его предыдущей позиции в выбранном окне.</target>
        </trans-unit>
        <trans-unit id="21114982217e29f559b82573a3eccc2b154e4432" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; may switch to any buffer, including those already shown in other windows.</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; может переключиться на любой буфер, включая те, которые уже показаны в других окнах.</target>
        </trans-unit>
        <trans-unit id="d8a3d004b6873a2a169b03d65608121fffb72f67" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt;, Emacs does not lock files.</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;nil&lt;/code&gt; , Emacs не блокирует файлы.</target>
        </trans-unit>
        <trans-unit id="89623922f044cdd08657525c28b20ee10211a651" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;blink-matching-open&lt;/code&gt; does nothing.</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;nil&lt;/code&gt; , то &lt;code&gt;blink-matching-open&lt;/code&gt; ничего не делает.</target>
        </trans-unit>
        <trans-unit id="2cfb381e21594551805791d32d6d3364b07223cd" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;read-from-minibuffer&lt;/code&gt; and &lt;code&gt;read-string&lt;/code&gt; strip all text properties from the minibuffer input before returning it. However, &lt;code&gt;read-no-blanks-input&lt;/code&gt; (see below), as well as &lt;code&gt;read-minibuffer&lt;/code&gt; and related functions (see &lt;a href=&quot;object-from-minibuffer#Object-from-Minibuffer&quot;&gt;Reading Lisp Objects With the Minibuffer&lt;/a&gt;), and all functions that do minibuffer input with completion, discard text properties unconditionally, regardless of the value of this variable.</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;nil&lt;/code&gt; , то &lt;code&gt;read-from-minibuffer&lt;/code&gt; и &lt;code&gt;read-string&lt;/code&gt; удаляют все текстовые свойства из ввода минибуфера перед его возвратом. Однако, &lt;code&gt;read-no-blanks-input&lt;/code&gt; (см. Ниже), а также &lt;code&gt;read-minibuffer&lt;/code&gt; и связанные функции (см. &lt;a href=&quot;object-from-minibuffer#Object-from-Minibuffer&quot;&gt;Чтение объектов Lisp с помощью минибуфера&lt;/a&gt; ) и все функции, которые выполняют ввод минибуфера с завершением, безоговорочно отбрасывают свойства текста, независимо от значение этой переменной.</target>
        </trans-unit>
        <trans-unit id="b1d0a7e3669bd5769ff2e4ddd7ec40d799965cf0" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt;, this does not necessarily mean that any window showing the buffer can be resized in the desired direction. To determine that, use the function &lt;code&gt;window-resizable&lt;/code&gt;. See &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;.</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;nil&lt;/code&gt; , это не обязательно означает, что любое окно, показывающее буфер, может быть изменено в желаемом направлении. Чтобы определить это, используйте функцию изменения &lt;code&gt;window-resizable&lt;/code&gt; . См. Раздел &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Изменение размера Windows&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a14af0d500a6d6203f4039a676d4516a111cf6ae" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt;, you cannot invoke minibuffer commands when the minibuffer is active, not even if you switch to another window to do it.</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;nil&lt;/code&gt; , вы не можете вызывать команды минибуфера, когда минибуфер активен, даже если для этого вы переключитесь в другое окно.</target>
        </trans-unit>
        <trans-unit id="594867f6c30f7651767ce9e8c5f29e2d63c57c0c" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;split-window&lt;/code&gt; tries to resize all windows that are part of the same combination as &lt;var&gt;window&lt;/var&gt;, in order to accommodate the new window. In particular, this may allow &lt;code&gt;split-window&lt;/code&gt; to succeed even if &lt;var&gt;window&lt;/var&gt; is a fixed-size window or too small to ordinarily split. Furthermore, subsequently resizing or deleting &lt;var&gt;window&lt;/var&gt; may resize all other windows in its combination.</source>
          <target state="translated">Если эта переменная равна &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;split-window&lt;/code&gt; пытается изменить размер всех окон, которые являются частью той же комбинации, что и &lt;var&gt;window&lt;/var&gt; , чтобы приспособить новое окно. В частности, это может обеспечить &lt;code&gt;split-window&lt;/code&gt; даже если &lt;var&gt;window&lt;/var&gt; является окном фиксированного размера или слишком маленьким для обычного разделения. Кроме того, последующее изменение размера или удаление &lt;var&gt;window&lt;/var&gt; может изменить размер всех других окон в его комбинации.</target>
        </trans-unit>
        <trans-unit id="d1240ec35ce1119433c9ff4d706e7e07c1704aa2" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;t&lt;/code&gt;, then saving a file deletes excess backup versions silently. If it is &lt;code&gt;nil&lt;/code&gt;, that means to ask for confirmation before deleting excess backups. Otherwise, they are not deleted at all.</source>
          <target state="translated">Если эта переменная &lt;code&gt;t&lt;/code&gt; , то при сохранении файла лишние версии резервной копии автоматически удаляются. Если он равен &lt;code&gt;nil&lt;/code&gt; , это означает, что перед удалением лишних резервных копий требуется запросить подтверждение. В противном случае они вообще не удаляются.</target>
        </trans-unit>
        <trans-unit id="20cf7005f85044b4fe10e90fbd2922b7f7fb99a9" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt; (the default), Emacs makes backups by copying in cases where renaming would change either the owner or the group of the file.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; (по умолчанию), Emacs создает резервные копии путем копирования в тех случаях, когда переименование изменило бы владельца или группу файла.</target>
        </trans-unit>
        <trans-unit id="6ac994bc716560b0f970621acd4b471ce55be78a" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt; when a command returns to the command loop, then the command loop does not check for those text properties, and does not move point out of sequences that have them.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; когда команда возвращается в командный цикл, то командный цикл не проверяет эти текстовые свойства и не перемещает точку из последовательностей, в которых они есть.</target>
        </trans-unit>
        <trans-unit id="bace1650d13777be92f95887dd4d32eecfa88f81" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt; and related functions call it with no arguments when their argument message is &lt;code&gt;nil&lt;/code&gt; or the empty string.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;message&lt;/code&gt; и связанные функции вызывают ее без аргументов, если их аргумент message равен &lt;code&gt;nil&lt;/code&gt; или пустой строке.</target>
        </trans-unit>
        <trans-unit id="c1f25dcc5e8473bcf19e57671b5e742689784221" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;read-buffer&lt;/code&gt; ignores case when performing completion while reading the buffer name.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;read-buffer&lt;/code&gt; игнорирует регистр при выполнении завершения при чтении имени буфера.</target>
        </trans-unit>
        <trans-unit id="bbc01c87c2c736a01297e40708d9bc2eea75308d" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;read-file-name&lt;/code&gt; ignores case when performing completion.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;read-file-name&lt;/code&gt; игнорирует регистр при выполнении завершения.</target>
        </trans-unit>
        <trans-unit id="e1af2e516e1731ec5691914fe684ea6870a2bd9b" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;scan-sexps&lt;/code&gt; treats all non-</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;scan-sexps&lt;/code&gt; обрабатывает все не-</target>
        </trans-unit>
        <trans-unit id="2806dadd88bb70627d555c7ccdb2df2e87d6e884" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;sort-subr&lt;/code&gt; and the other buffer sorting functions ignore case when comparing strings.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;sort-subr&lt;/code&gt; и другие функции сортировки буфера игнорируют регистр при сравнении строк.</target>
        </trans-unit>
        <trans-unit id="6c25756dd86611671f3153436090287d38ed5950" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;switch-to-buffer&lt;/code&gt; respects display actions specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, &lt;code&gt;display-buffer-alist&lt;/code&gt; and other display related variables.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , при &lt;code&gt;switch-to-buffer&lt;/code&gt; учитываются действия отображения, указанные в &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; , &lt;code&gt;display-buffer-alist&lt;/code&gt; и других переменных, связанных с отображением.</target>
        </trans-unit>
        <trans-unit id="2d9323d5a2f41b361036ddb3df85eeaea1baaabe" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; will refrain from switching to certain buffers. The following values can be used:</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; будет воздерживаться от переключения на определенные буферы. Могут использоваться следующие значения:</target>
        </trans-unit>
        <trans-unit id="6f8b633c15af3635e4d6fb6a6c0f5084235f704f" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; calls it as a function to do the job of displaying a help buffer. The function gets one argument, which is the buffer it should display.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; вызывает ее как функцию, выполняющую работу по отображению буфера справки. Функция получает один аргумент - буфер, который она должна отображать.</target>
        </trans-unit>
        <trans-unit id="b45139ff1fb7adc7b74e6d5409a3a5983efc470b" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, Emacs always makes backup files by copying. The default is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , Emacs всегда создает резервные копии файлов путем копирования. По умолчанию - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d51063434f8bbb63a99074f83c5e64c82816980" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, Emacs auto-saves buffers in the files they are visiting. That is, the auto-save is done in the same file that you are editing. Normally, this variable is &lt;code&gt;nil&lt;/code&gt;, so auto-save files have distinct names that are created by &lt;code&gt;make-auto-save-file-name&lt;/code&gt;.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , Emacs автоматически сохраняет буферы в файлах, которые они посещают. То есть автосохранение выполняется в том же файле, который вы редактируете. Обычно эта переменная равна &lt;code&gt;nil&lt;/code&gt; , поэтому файлы автосохранения имеют разные имена, которые создаются командой &lt;code&gt;make-auto-save-file-name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="834c09bab1aa496311263cf0de3e2ca620518527" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, Emacs displays a message at the beginning and end of garbage collection. The default value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , Emacs отображает сообщение в начале и в конце сборки мусора. Значение по умолчанию - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3633f89136bf7feadfc976095b51e28ac6f62fd" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, Emacs does not look up X resources, and X resources do not have any effect when creating new frames.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , Emacs не ищет ресурсы X, а ресурсы X не имеют никакого эффекта при создании новых кадров.</target>
        </trans-unit>
        <trans-unit id="207397c1e70879d418a5aeb0b3721f4a98bea246" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, Emacs makes backups by copying for files with multiple names (hard links). The default is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , Emacs создает резервные копии, копируя файлы с несколькими именами (жесткие ссылки). По умолчанию - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4133361e941fb85b4b5864cbd4b84b18bec370a2" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, Emacs will try to automatically select the window under the mouse pointer. The following values are meaningful:</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , Emacs попытается автоматически выбрать окно под указателем мыши. Значимы следующие значения:</target>
        </trans-unit>
        <trans-unit id="3f388d3d4bc61aef5a9232085d49b686ff163ff7" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, a period followed by just one space does not count as the end of a sentence, and the filling functions avoid breaking the line at such a place.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , точка, за которой следует только один пробел, не считается концом предложения, и функции заполнения избегают разрыва строки в таком месте.</target>
        </trans-unit>
        <trans-unit id="950d5268ecb65fd2680e60c1d248cc988f2f3806" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, a sentence can end without a period. This is used for languages like Thai, where sentences end with a double space but without a period.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , предложение может заканчиваться без точки. Это используется для таких языков, как тайский, где предложения заканчиваются двойным пробелом, но без точки.</target>
        </trans-unit>
        <trans-unit id="d3d32a32adfb3aeef6215fd4bfb85130c2a123e8" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, all of the change hooks are disabled; none of them run. This affects all the hook variables described above in this section, as well as the hooks attached to certain special text properties (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;) and overlay properties (see &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;).</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , все перехватчики изменений отключены; никто из них не убегает. Это влияет на все переменные ловушки, описанные выше в этом разделе, а также ловушки, прикрепленные к определенным специальным свойствам текста (см. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&lt;/a&gt; ) и свойствам наложения (см. &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Свойства наложения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ffc9890d3b90ef1f3080654443150dd4bbab62b" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, backups are inhibited. It records the result of testing &lt;code&gt;backup-enable-predicate&lt;/code&gt; on the visited file name. It can also coherently be used by other mechanisms that inhibit backups based on which file is visited. For example, VC sets this variable non-&lt;code&gt;nil&lt;/code&gt; to prevent making backups for files managed with a version control system.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , резервное копирование запрещено. Он записывает результат тестирования &lt;code&gt;backup-enable-predicate&lt;/code&gt; для имени посещенного файла. Он также может согласованно использоваться другими механизмами, которые запрещают резервное копирование в зависимости от того, какой файл посещается. Например, VC устанавливает для этой переменной значение отличное от &lt;code&gt;nil&lt;/code&gt; чтобы предотвратить резервное копирование файлов, управляемых системой контроля версий.</target>
        </trans-unit>
        <trans-unit id="dbec36e38f19eeb11c146f8269324b7fdf70520f" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, buffers that are visiting files have auto-saving enabled by default. Otherwise, they do not.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , для буферов, обращающихся к файлам, по умолчанию включено автосохранение. В противном случае - нет.</target>
        </trans-unit>
        <trans-unit id="025314b7262d14c39abfca6e9831f30272667c3e" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, calling &lt;code&gt;recenter&lt;/code&gt; with a &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;count&lt;/var&gt; argument and non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;redisplay&lt;/var&gt; argument redraws the frame. The default value is &lt;code&gt;tty&lt;/code&gt;, which means only redraw the frame if it is a tty frame.</source>
          <target state="translated">Если этот переменный не - &lt;code&gt;nil&lt;/code&gt; , вызывая &lt;code&gt;recenter&lt;/code&gt; с &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;count&lt;/var&gt; аргументом и не- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;redisplay&lt;/var&gt; аргументом перерисовывает фрейм. Значение по умолчанию - &lt;code&gt;tty&lt;/code&gt; , что означает перерисовку кадра только в том случае, если это кадр tty.</target>
        </trans-unit>
        <trans-unit id="3494024f21dd122ec5225998d1cc7fc1f54d85a6" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, certain motion functions including &lt;code&gt;forward-word&lt;/code&gt;, &lt;code&gt;forward-sentence&lt;/code&gt;, and &lt;code&gt;forward-paragraph&lt;/code&gt; ignore field boundaries.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , некоторые функции перемещения, включая &lt;code&gt;forward-word&lt;/code&gt; , &lt;code&gt;forward-sentence&lt;/code&gt; и &lt;code&gt;forward-paragraph&lt;/code&gt; , игнорируют границы полей.</target>
        </trans-unit>
        <trans-unit id="bd0f3e86b9ecff032bd540684c751ffd8dd5b909" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, commands defined with &lt;code&gt;make-help-screen&lt;/code&gt; display their &lt;var&gt;help-line&lt;/var&gt; strings in the echo area at first, and display the longer &lt;var&gt;help-text&lt;/var&gt; strings only if the user types the help character again.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , команды, определенные с &lt;code&gt;make-help-screen&lt;/code&gt; сначала отображают свои &lt;var&gt;help-line&lt;/var&gt; в эхо-области и отображают более длинные строки &lt;var&gt;help-text&lt;/var&gt; только в том случае, если пользователь снова набирает символ справки.</target>
        </trans-unit>
        <trans-unit id="9750f1edf74db0b608b6fccefea113c32bd8ce2e" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, control characters in strings are printed as backslash sequences by the print functions &lt;code&gt;prin1&lt;/code&gt; and &lt;code&gt;print&lt;/code&gt; that print with quoting. If this variable and &lt;code&gt;print-escape-newlines&lt;/code&gt; are both non-&lt;code&gt;nil&lt;/code&gt;, the latter takes precedences for newlines and formfeeds.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , управляющие символы в строках печатаются как последовательности обратной косой черты функциями печати &lt;code&gt;prin1&lt;/code&gt; и &lt;code&gt;print&lt;/code&gt; эту печать с заключением в кавычки . Если и эта переменная, и &lt;code&gt;print-escape-newlines&lt;/code&gt; не равны &lt;code&gt;nil&lt;/code&gt; , последний имеет приоритет для новых строк и форм.</target>
        </trans-unit>
        <trans-unit id="0ebcf8ab557e661172fe9de6982d3f1cecc78d63" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, every stack frame of the backtrace is displayed as a list. This aims at improving the backtrace readability at the cost of special forms no longer being visually different from regular function calls.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , каждый кадр стека обратной трассировки отображается в виде списка. Это нацелено на улучшение читаемости обратной трассировки за счет того, что специальные формы больше не будут визуально отличаться от обычных вызовов функций.</target>
        </trans-unit>
        <trans-unit id="825abb330d17f730939fccaedf4a9b54362af1aa" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, face filters that specify attributes applied only when certain conditions are met will be deemed to match always.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , фильтры лиц, которые определяют атрибуты, применяемые только при соблюдении определенных условий, будут считаться соответствующими всегда.</target>
        </trans-unit>
        <trans-unit id="73b99057e876adfddae006656294be7fad80418d" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, indentation functions can insert tabs as well as spaces. Otherwise, they insert only spaces. Setting this variable automatically makes it buffer-local in the current buffer.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , функции отступа могут вставлять как табуляцию, так и пробелы. В противном случае они вставляют только пробелы. Установка этой переменной автоматически делает ее локальным в текущем буфере.</target>
        </trans-unit>
        <trans-unit id="e475f46321e795ba81086b40cd4690ce691cace1" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it is used instead of &lt;code&gt;system-name&lt;/code&gt; for purposes of generating email addresses. For example, it is used when constructing the default value of &lt;code&gt;user-mail-address&lt;/code&gt;. See &lt;a href=&quot;user-identification#User-Identification&quot;&gt;User Identification&lt;/a&gt;.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , она используется вместо имени &lt;code&gt;system-name&lt;/code&gt; для создания адресов электронной почты. Например, он используется при построении значения по умолчанию для &lt;code&gt;user-mail-address&lt;/code&gt; . См. &lt;a href=&quot;user-identification#User-Identification&quot;&gt;Идентификация пользователя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a72e135e2602c7ab3b2c6d5205e6df8a8c1f366" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it means that the user plans to use global abbrevs only. This tells the commands that define mode-specific abbrevs to define global ones instead. This variable does not alter the behavior of the functions in this section; it is examined by their callers.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , это означает, что пользователь планирует использовать только глобальные сокращения. Это указывает командам, определяющим сокращения для конкретного режима, вместо этого определять глобальные. Эта переменная не меняет поведения функций в этом разделе; это проверяется их абонентами.</target>
        </trans-unit>
        <trans-unit id="28a614e5388ec41951b4289105842e28d7c742aa" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it prevents Emacs from loading the default initialization library file. The default value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , это предотвращает загрузку Emacs файла библиотеки инициализации по умолчанию. Значение по умолчанию - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01405602d1f9c9c7910f4c21fb957b674e7f4e15" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it says to call the debugger before the next &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;funcall&lt;/code&gt;. Entering the debugger sets &lt;code&gt;debug-on-next-call&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , она говорит, что нужно вызвать отладчик перед следующим &lt;code&gt;eval&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; или &lt;code&gt;funcall&lt;/code&gt; . Ввод отладчика устанавливает &lt;code&gt;debug-on-next-call&lt;/code&gt; к &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="530af39356cdaa6611678480707bf74e936dfaf2" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function of one argument, the text of a message to display in the echo area. This function will be called by &lt;code&gt;message&lt;/code&gt; and related functions. If the function returns &lt;code&gt;nil&lt;/code&gt;, the message is displayed in the echo area as usual. If this function returns a string, that string is displayed in the echo area instead of the original one. If this function returns other non-&lt;code&gt;nil&lt;/code&gt; values, that means the message was already handled, so &lt;code&gt;message&lt;/code&gt; will not display anything in the echo area. See also &lt;code&gt;clear-message-function&lt;/code&gt; that can be used to clear the message displayed by this function.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , она должна быть функцией одного аргумента - текста сообщения, отображаемого в эхо-области. Эта функция будет вызываться &lt;code&gt;message&lt;/code&gt; и связанными функциями. Если функция возвращает &lt;code&gt;nil&lt;/code&gt; , сообщение отображается в эхо-области как обычно. Если эта функция возвращает строку, эта строка отображается в эхо-области вместо исходной. Если эта функция возвращает другие значения, отличные от &lt;code&gt;nil&lt;/code&gt; , это означает, что сообщение уже было обработано, поэтому &lt;code&gt;message&lt;/code&gt; ничего не будет отображать в эхо-области. См. Также &lt;code&gt;clear-message-function&lt;/code&gt; которую можно использовать для очистки сообщения, отображаемого этой функцией.</target>
        </trans-unit>
        <trans-unit id="e2ad2623c2c20ffd237a9f8ff4f6b25a14cd11ae" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function that is called with no arguments, to choose an enclosing range of text for refontification for the command</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , это должна быть функция, которая вызывается без аргументов, чтобы выбрать охватывающий диапазон текста для повторной настройки для команды.</target>
        </trans-unit>
        <trans-unit id="5e34de40cdee34dbcbae19ce1c28736a9aabb232" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function to determine which face to use for a given syntactic element (a string or a comment).</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , это должна быть функция, определяющая, какое лицо использовать для данного синтаксического элемента (строки или комментария).</target>
        </trans-unit>
        <trans-unit id="736539861dd446a2363faa03b08be25dfdb36758" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it should be a regular expression that says how to search for whitespace. In that case, any group of spaces in a regular expression being searched for stands for use of this regular expression. However, spaces inside of constructs such as &amp;lsquo;</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , это должно быть регулярное выражение, указывающее, как искать пробелы. В этом случае любая группа пробелов в регулярном выражении, в котором выполняется поиск, означает использование этого регулярного выражения. Однако пробелы внутри таких конструкций, как '</target>
        </trans-unit>
        <trans-unit id="94da8319895436b58271d8d72a7d99fdf5bd1757" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it should be a string of characters that can end a sentence without following spaces.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , это должна быть строка символов, которые могут завершать предложение без следующих пробелов.</target>
        </trans-unit>
        <trans-unit id="9e8a33451a4e0e6e7f790a3cc598efe8a089d8fa" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it specifies a function called to display help strings. These may be &lt;code&gt;help-echo&lt;/code&gt; properties, menu help strings (see &lt;a href=&quot;simple-menu-items#Simple-Menu-Items&quot;&gt;Simple Menu Items&lt;/a&gt;, see &lt;a href=&quot;extended-menu-items#Extended-Menu-Items&quot;&gt;Extended Menu Items&lt;/a&gt;), or tool bar help strings (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;). The specified function is called with one argument, the help string to display, which is passed through &lt;code&gt;substitute-command-keys&lt;/code&gt; before being given to the function, unless the help string has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;help-echo-inhibit-substitution&lt;/code&gt; property on its first character; see &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;. See the code of Tooltip mode (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;Tooltips&lt;/a&gt; in</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , она определяет функцию, вызываемую для отображения строк справки. Это могут быть свойства &lt;code&gt;help-echo&lt;/code&gt; справки, строки справки меню (см. &lt;a href=&quot;simple-menu-items#Simple-Menu-Items&quot;&gt;Простые элементы меню&lt;/a&gt; , см. &lt;a href=&quot;extended-menu-items#Extended-Menu-Items&quot;&gt;Расширенные элементы меню&lt;/a&gt; ) или строки справки панели инструментов (см. Панель &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;инструментов&lt;/a&gt; ). Указанная функция вызываются с одним аргументом, справочной строкой на дисплей, который передается через &lt;code&gt;substitute-command-keys&lt;/code&gt; перед тем , как дана функцией, если помощь строка не имеет не- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;help-echo-inhibit-substitution&lt;/code&gt; собственности на своем первый персонаж; см. &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Ключи в документации&lt;/a&gt; . См. Код режима всплывающих подсказок (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;Всплывающие подсказки&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="dcb566f1203fe4f1a711162b1c493c55ac39469d" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it specifies a function called to display help strings. These may be &lt;code&gt;help-echo&lt;/code&gt; properties, menu help strings (see &lt;a href=&quot;simple-menu-items#Simple-Menu-Items&quot;&gt;Simple Menu Items&lt;/a&gt;, see &lt;a href=&quot;extended-menu-items#Extended-Menu-Items&quot;&gt;Extended Menu Items&lt;/a&gt;), or tool bar help strings (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;). The specified function is called with one argument, the help string to display, which is passed through &lt;code&gt;substitute-command-keys&lt;/code&gt; before being given to the function, unless the help string has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;help-echo-inhibit-substitution&lt;/code&gt; property on its first character; see &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;. See the code of Tooltip mode (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;Tooltips&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4287285430bf7978ba440dfcc104a76072b43a35" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it specifies the coding system to use for reading a file, or for input from a synchronous subprocess.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , она указывает систему кодирования, используемую для чтения файла или для ввода из синхронного подпроцесса.</target>
        </trans-unit>
        <trans-unit id="3c10b413e9e836ba3f5eb5e379ef529e4a062a92" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it specifies the initial execution mode for Edebug when it is first activated. Possible values are &lt;code&gt;step&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;go&lt;/code&gt;, &lt;code&gt;Go-nonstop&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;Trace-fast&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, and &lt;code&gt;Continue-fast&lt;/code&gt;.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , она указывает начальный режим выполнения для Edebug при его первой активации. Возможные значения: &lt;code&gt;step&lt;/code&gt; , &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;go&lt;/code&gt; , &lt;code&gt;Go-nonstop&lt;/code&gt; , &lt;code&gt;trace&lt;/code&gt; , &lt;code&gt;Trace-fast&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; и &lt;code&gt;Continue-fast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="940530d5bdee4613d57b898314fac2eba6763217" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, it tells &lt;code&gt;scroll-other-window&lt;/code&gt; which buffer&amp;rsquo;s window to scroll.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , она сообщает &lt;code&gt;scroll-other-window&lt;/code&gt; , какое окно буфера нужно прокручивать.</target>
        </trans-unit>
        <trans-unit id="796d64fb0f974a198f156df00380fe8b383a4f59" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, its value is a form to evaluate whenever the character &lt;code&gt;help-char&lt;/code&gt; is read. If evaluating the form produces a string, that string is displayed.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , ее значение представляет собой форму для оценки при чтении символа &lt;code&gt;help-char&lt;/code&gt; . Если при вычислении формы получается строка, эта строка отображается.</target>
        </trans-unit>
        <trans-unit id="4cd924a70c5a5420e03b4274b724474270d013cd" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, its value should be a function that finds the next definition to put in the buffer index, scanning backward in the buffer from point. It should return &lt;code&gt;nil&lt;/code&gt; if it doesn&amp;rsquo;t find another definition before point. Otherwise it should leave point at the place it finds a definition and return any non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , ее значением должна быть функция, которая находит следующее определение для размещения в индексе буфера, просматривая буфер назад от точки. Он должен вернуть &lt;code&gt;nil&lt;/code&gt; , если не найдет другого определения перед точкой. В противном случае он должен оставить точку в том месте, где находит определение, и вернуть любое &lt;code&gt;nil&lt;/code&gt; значение.</target>
        </trans-unit>
        <trans-unit id="5966261c0c16f735efd5e99361f20e922539db62" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, its value should be a function to return the name for a definition, assuming point is in that definition as the &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; function would leave it.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , ее значением должна быть функция, возвращающая имя для определения, при условии, что точка находится в этом определении, поскольку &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; оставит его.</target>
        </trans-unit>
        <trans-unit id="1f013b1f0ed05ce1ab2df32aa0fef5d09e538287" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, some standard functions do not process window parameters. The functions currently affected by this are &lt;code&gt;split-window&lt;/code&gt;, &lt;code&gt;delete-window&lt;/code&gt;, &lt;code&gt;delete-other-windows&lt;/code&gt;, and &lt;code&gt;other-window&lt;/code&gt;.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , некоторые стандартные функции не обрабатывают параметры окна. В настоящее время это затрагивает следующие функции: &lt;code&gt;split-window&lt;/code&gt; , &lt;code&gt;delete-window&lt;/code&gt; , &lt;code&gt;delete-other-windows&lt;/code&gt; и &lt;code&gt;other-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03c7c4d79ccb4d42f80c3d18e6c04a8e755e29f2" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, the &lt;code&gt;line-move&lt;/code&gt;, &lt;code&gt;scroll-up&lt;/code&gt;, and &lt;code&gt;scroll-down&lt;/code&gt; functions will automatically modify the vertical scroll position to scroll through display rows that are taller than the height of the window, for example in the presence of large images.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , функции &lt;code&gt;line-move&lt;/code&gt; , &lt;code&gt;scroll-up&lt;/code&gt; и &lt;code&gt;scroll-down&lt;/code&gt; автоматически изменят положение вертикальной прокрутки для прокрутки отображаемых строк, которые выше, чем высота окна, например, при наличии большие изображения.</target>
        </trans-unit>
        <trans-unit id="5f51c12f5aa3e060488bafd691e3268772c08c8b" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, the completion commands automatically display a list of possible completions whenever nothing can be completed because the next character is not uniquely determined.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , команды завершения автоматически отображают список возможных завершений всякий раз, когда ничего не может быть завершено, потому что следующий символ не определен однозначно.</target>
        </trans-unit>
        <trans-unit id="21443464bd01045a5e435e1de5bf762da34a42e1" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, the filling functions do not delete newlines that have the &lt;code&gt;hard&lt;/code&gt; text property. These hard newlines act as paragraph separators. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Hard-and-Soft-Newlines.html#Hard-and-Soft-Newlines&quot;&gt;Hard and Soft Newlines&lt;/a&gt; in</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , функции заполнения не удаляют символы новой строки, имеющие свойство &lt;code&gt;hard&lt;/code&gt; текста. Эти жесткие символы новой строки действуют как разделители абзацев. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Hard-and-Soft-Newlines.html#Hard-and-Soft-Newlines&quot;&gt;Жесткие и мягкие символы новой строки&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="d2cb63ff6316fffcb34e2eb9f3690b9a97b93193" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, the filling functions do not delete newlines that have the &lt;code&gt;hard&lt;/code&gt; text property. These hard newlines act as paragraph separators. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Hard-and-Soft-Newlines.html#Hard-and-Soft-Newlines&quot;&gt;Hard and Soft Newlines&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679fbd7d9ffa305c2784992adda94271941edb90" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, the function &lt;code&gt;yank-pop&lt;/code&gt; uses its value instead of &lt;code&gt;delete-region&lt;/code&gt; to delete the text inserted by the previous &lt;code&gt;yank&lt;/code&gt; or &lt;code&gt;yank-pop&lt;/code&gt; command. The value must be a function of two arguments, the start and end of the current region.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , функция &lt;code&gt;yank-pop&lt;/code&gt; использует свое значение вместо &lt;code&gt;delete-region&lt;/code&gt; для удаления текста, вставленного предыдущей командой &lt;code&gt;yank&lt;/code&gt; или &lt;code&gt;yank-pop&lt;/code&gt; . Значение должно быть функцией двух аргументов, начала и конца текущей области.</target>
        </trans-unit>
        <trans-unit id="93a2434654ec45e739de56657a18ff8876d78ad0" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, the prefixes specified by a group&amp;rsquo;s &lt;code&gt;:prefix&lt;/code&gt; keyword are omitted from tag names, whenever the user customizes the group.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , префиксы, заданные ключевым словом group &lt;code&gt;:prefix&lt;/code&gt; , опускаются из имен тегов всякий раз, когда пользователь настраивает группу.</target>
        </trans-unit>
        <trans-unit id="e5d159208606e32b48fc2d1b9aded69f5b4066fd" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, the tool bar automatically resizes to show all defined tool bar items&amp;mdash;but not larger than a quarter of the frame&amp;rsquo;s height.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , панель инструментов автоматически изменяет размер, чтобы отобразить все определенные элементы панели инструментов, но не более четверти высоты фрейма.</target>
        </trans-unit>
        <trans-unit id="13e280ca7f80fc8854be1c34c381f58c33201e02" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, the value of &lt;code&gt;overriding-local-map&lt;/code&gt; or &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; can affect the display of the menu bar. The default value is &lt;code&gt;nil&lt;/code&gt;, so those map variables have no effect on the menu bar.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , значение &lt;code&gt;overriding-local-map&lt;/code&gt; или &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; может повлиять на отображение строки меню. Значение по умолчанию - &lt;code&gt;nil&lt;/code&gt; , поэтому эти переменные карты не влияют на строку меню.</target>
        </trans-unit>
        <trans-unit id="4124d763334c8a7421ef5e7e0065624fb83c8f7c" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;save-buffer&lt;/code&gt; protects against I/O errors while saving by writing the new file to a temporary name instead of the name it is supposed to have, and then renaming it to the intended name after it is clear there are no errors. This procedure prevents problems such as a lack of disk space from resulting in an invalid file.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , то &lt;code&gt;save-buffer&lt;/code&gt; защищает от ошибок ввода-вывода при сохранении, записывая новый файл во временное имя вместо имени, которое он должен иметь, а затем переименовывает его в предполагаемое имя после того, как оно будет понятно, ошибок нет. Эта процедура предотвращает возникновение таких проблем, как нехватка места на диске, в результате чего файл окажется недействительным.</target>
        </trans-unit>
        <trans-unit id="af993b034155d780baaff868c13c3f78dad09007" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, then Emacs quits immediately, unless &lt;code&gt;inhibit-quit&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. Typing</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , то Emacs немедленно завершает работу, если только &lt;code&gt;inhibit-quit&lt;/code&gt; равно &lt;code&gt;nil&lt;/code&gt; . Печатать</target>
        </trans-unit>
        <trans-unit id="76218ba9f2ed8739a1159ea14cb27b16675a7947" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, then multibyte non-</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , то многобайтовые не-</target>
        </trans-unit>
        <trans-unit id="347e0ea47aafb7add84c5d8c171d6c7c19355bd0" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, then newline characters in strings are printed as &amp;lsquo;</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , то символы новой строки в строках печатаются как '</target>
        </trans-unit>
        <trans-unit id="6c347410c56038a6f8cb71013d4d57ee168183fc" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, then read-only buffers and, depending on the actual value, some or all read-only characters may be modified. Read-only characters in a buffer are those that have a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;read-only&lt;/code&gt; text property. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;, for more information about text properties.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , тогда буферы только для чтения и, в зависимости от фактического значения, могут быть изменены некоторые или все символы только для чтения. Доступные только для чтения символы в буфере - это те, которые имеют свойство текста, доступное только для &lt;code&gt;read-only&lt;/code&gt; отличное от &lt;code&gt;nil&lt;/code&gt; . См. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&lt;/a&gt; для получения дополнительной информации о свойствах текста.</target>
        </trans-unit>
        <trans-unit id="0b2ed4fbebaf5d95d00f7d374e99d6b6f8a364f2" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, then the various &lt;code&gt;find-file&lt;/code&gt; commands check for wildcard characters and visit all the files that match them (when invoked interactively or when their &lt;var&gt;wildcards&lt;/var&gt; argument is non-&lt;code&gt;nil&lt;/code&gt;). If this option is &lt;code&gt;nil&lt;/code&gt;, then the &lt;code&gt;find-file&lt;/code&gt; commands ignore their &lt;var&gt;wildcards&lt;/var&gt; argument and never treat wildcard characters specially.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , то различные команды &lt;code&gt;find-file&lt;/code&gt; проверяют наличие подстановочных знаков и обращаются ко всем файлам, которые им соответствуют (при интерактивном вызове или когда их аргумент &lt;var&gt;wildcards&lt;/var&gt; отличен от &lt;code&gt;nil&lt;/code&gt; ). Если эта опция равна &lt;code&gt;nil&lt;/code&gt; , то команды &lt;code&gt;find-file&lt;/code&gt; игнорируют свой аргумент &lt;var&gt;wildcards&lt;/var&gt; и никогда не обрабатывают подстановочные знаки специально.</target>
        </trans-unit>
        <trans-unit id="c78c42547923adcce6905297eaf8af608611acc0" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, then unibyte non-</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , то unibyte non-</target>
        </trans-unit>
        <trans-unit id="6647182cae9f951d8aeda46add5a82e6ede0ce3e" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, tool bar items display in raised form when the mouse moves over them.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , элементы панели инструментов отображаются в выпуклой форме при наведении на них мыши.</target>
        </trans-unit>
        <trans-unit id="8dfab937b0b83165d5343abdad293917abfa1c29" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, two words of different kind (e.g., English and CJK) will be separated with a space when concatenating one that is in the end of a line and the other that is in the beginning of the next line for filling.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , два слова разного типа (например, English и CJK) будут разделены пробелом при объединении одного, которое находится в конце строки, и другого, которое находится в начале следующей строки для начинка.</target>
        </trans-unit>
        <trans-unit id="fa1c4b04a8d4d70822b089390ffdf01fa17e5734" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, when the undo info exceeds &lt;code&gt;undo-outer-limit&lt;/code&gt;, Emacs asks in the echo area whether to discard the info. The default value is &lt;code&gt;nil&lt;/code&gt;, which means to discard it automatically.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , когда информация об отмене превышает &lt;code&gt;undo-outer-limit&lt;/code&gt; , Emacs спрашивает в эхо-области, следует ли отбросить информацию. Значение по умолчанию - &lt;code&gt;nil&lt;/code&gt; , что означает его автоматическое отклонение.</target>
        </trans-unit>
        <trans-unit id="fa5ff03c3e322d8d21fa31e2c5f3c569a8fff9a1" translate="yes" xml:space="preserve">
          <source>If this variable is non-&lt;code&gt;nil&lt;/code&gt;, you can invoke commands (such as &lt;code&gt;find-file&lt;/code&gt;) that use minibuffers even while the minibuffer is active. Such invocation produces a recursive editing level for a new minibuffer. The outer-level minibuffer is invisible while you are editing the inner one.</source>
          <target state="translated">Если эта переменная не равна &lt;code&gt;nil&lt;/code&gt; , вы можете вызывать команды (например, &lt;code&gt;find-file&lt;/code&gt; ), которые используют минибуфер, даже когда минибуфер активен. Такой вызов создает рекурсивный уровень редактирования для нового минибуфера. Минибуфер внешнего уровня невидим, пока вы редактируете внутренний.</target>
        </trans-unit>
        <trans-unit id="7987f4ed83976384243a666b286c2798956277e4" translate="yes" xml:space="preserve">
          <source>If this variable&amp;rsquo;s value is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;write-region&lt;/code&gt; uses the &lt;code&gt;fsync&lt;/code&gt; system call after writing a file. Although this slows Emacs down, it lessens the risk of data loss after power failure. If the value is &lt;code&gt;t&lt;/code&gt;, Emacs does not use &lt;code&gt;fsync&lt;/code&gt;. The default value is &lt;code&gt;nil&lt;/code&gt; when Emacs is interactive, and &lt;code&gt;t&lt;/code&gt; when Emacs runs in batch mode. See &lt;a href=&quot;files-and-storage#Files-and-Storage&quot;&gt;Files and Storage&lt;/a&gt;.</source>
          <target state="translated">Если значение этой переменной равно &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;write-region&lt;/code&gt; использует системный вызов &lt;code&gt;fsync&lt;/code&gt; после записи файла. Хотя это замедляет работу Emacs, это снижает риск потери данных после сбоя питания. Если значение равно &lt;code&gt;t&lt;/code&gt; , Emacs не использует &lt;code&gt;fsync&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;nil&lt;/code&gt; , когда Emacs является интерактивным, и &lt;code&gt;t&lt;/code&gt; , когда Emacs работает в пакетном режиме. См. &lt;a href=&quot;files-and-storage#Files-and-Storage&quot;&gt;Файлы и хранилище&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8c9dc8dcf95bb83031625a9f5835f26578f929b" translate="yes" xml:space="preserve">
          <source>If this variable&amp;rsquo;s value is non-&lt;code&gt;nil&lt;/code&gt;, an open parenthesis in column 0 is considered to be the start of a defun. If it is &lt;code&gt;nil&lt;/code&gt;, an open parenthesis in column 0 has no special meaning. The default is &lt;code&gt;t&lt;/code&gt;. If a string literal happens to have a parenthesis in column 0, escape it with a backslash to avoid a false positive.</source>
          <target state="translated">Если значение этой переменной не равно &lt;code&gt;nil&lt;/code&gt; , открытая скобка в столбце 0 считается началом функции defun. Если он равен &lt;code&gt;nil&lt;/code&gt; , открывающая скобка в столбце 0 не имеет особого значения. По умолчанию &lt;code&gt;t&lt;/code&gt; . Если у строкового литерала есть скобка в столбце 0, закройте его обратной косой чертой, чтобы избежать ложного срабатывания.</target>
        </trans-unit>
        <trans-unit id="6ac036b8d1c1ea2354a0438f84ad30f9852d9133" translate="yes" xml:space="preserve">
          <source>If this variable&amp;rsquo;s value is non-&lt;code&gt;nil&lt;/code&gt;, it is a symbol which is used as a text property name. A non-&lt;code&gt;nil&lt;/code&gt; value for that text property means the other text properties for this character have already been computed.</source>
          <target state="translated">Если значение этой переменной не равно &lt;code&gt;nil&lt;/code&gt; , это символ, который используется в качестве имени текстового свойства. Не- &lt;code&gt;nil&lt;/code&gt; значения для этого текстового свойства означает , что другие свойства текста для этого символа уже вычислены.</target>
        </trans-unit>
        <trans-unit id="8e2bb8ec07b4bc794a3673b2e73ca58eb14b1ba1" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eq&lt;/code&gt;, then &lt;code&gt;(sxhash-eq &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eq &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">Если два объекта &lt;var&gt;obj1&lt;/var&gt; и &lt;var&gt;obj2&lt;/var&gt; являются &lt;code&gt;eq&lt;/code&gt; , то &lt;code&gt;(sxhash-eq &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; и &lt;code&gt;(sxhash-eq &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; являются одним и тем же целым числом.</target>
        </trans-unit>
        <trans-unit id="44ade2ddab356cb60d73286f7dd807880759d4c2" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eql&lt;/code&gt;, then &lt;code&gt;(sxhash-eql &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eql &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">Если два объекта &lt;var&gt;obj1&lt;/var&gt; и &lt;var&gt;obj2&lt;/var&gt; являются &lt;code&gt;eql&lt;/code&gt; , тогда &lt;code&gt;(sxhash-eql &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; и &lt;code&gt;(sxhash-eql &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; являются одним и тем же целым числом.</target>
        </trans-unit>
        <trans-unit id="faa2ecf2925aadfa7df8d5d6017d1a43d6a4fbf6" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;equal&lt;/code&gt;, then &lt;code&gt;(sxhash-equal &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-equal &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">Если два объекта &lt;var&gt;obj1&lt;/var&gt; и &lt;var&gt;obj2&lt;/var&gt; являются &lt;code&gt;equal&lt;/code&gt; , а затем &lt;code&gt;(sxhash-equal &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; и &lt;code&gt;(sxhash-equal &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; являются такими же , целое число.</target>
        </trans-unit>
        <trans-unit id="c4a957c6ab4394732423e757c73b91fce71b8325" translate="yes" xml:space="preserve">
          <source>If user input represents an octal number, this function returns that number. If it is a complete symbolic specification of mode bits, as in &lt;code&gt;&quot;u=rwx&quot;&lt;/code&gt;, the function converts it to the equivalent numeric value using &lt;code&gt;file-modes-symbolic-to-number&lt;/code&gt; and returns the result. If the specification is relative, as in &lt;code&gt;&quot;o+g&quot;&lt;/code&gt;, then the permissions on which the specification is based are taken from the mode bits of &lt;var&gt;base-file&lt;/var&gt;. If &lt;var&gt;base-file&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the function uses &lt;code&gt;0&lt;/code&gt; as the base mode bits. The complete and relative specifications can be combined, as in &lt;code&gt;&quot;u+r,g+rx,o+r,g-w&quot;&lt;/code&gt;. See &lt;a href=&quot;http://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions&quot;&gt;File permissions&lt;/a&gt; in</source>
          <target state="translated">Если пользовательский ввод представляет собой восьмеричное число, эта функция возвращает это число. Если это полная символьная спецификация битов режима, как в &lt;code&gt;&quot;u=rwx&quot;&lt;/code&gt; , функция преобразует его в эквивалентное числовое значение, используя &lt;code&gt;file-modes-symbolic-to-number&lt;/code&gt; и возвращает результат. Если спецификация относительна, как в &lt;code&gt;&quot;o+g&quot;&lt;/code&gt; , то права, на которых основана спецификация, берутся из бит режима &lt;var&gt;base-file&lt;/var&gt; . Если &lt;var&gt;base-file&lt;/var&gt; опущен или равен &lt;code&gt;nil&lt;/code&gt; , функция использует &lt;code&gt;0&lt;/code&gt; в качестве битов базового режима. Полные и относительные спецификации могут быть объединены, как в &lt;code&gt;&quot;u+r,g+rx,o+r,g-w&quot;&lt;/code&gt; . См. &lt;a href=&quot;http://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions&quot;&gt;Права доступа к файлам&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="2c9f8efcda8b3da6bafadbf4e57b708641ed35c7" translate="yes" xml:space="preserve">
          <source>If user input represents an octal number, this function returns that number. If it is a complete symbolic specification of mode bits, as in &lt;code&gt;&quot;u=rwx&quot;&lt;/code&gt;, the function converts it to the equivalent numeric value using &lt;code&gt;file-modes-symbolic-to-number&lt;/code&gt; and returns the result. If the specification is relative, as in &lt;code&gt;&quot;o+g&quot;&lt;/code&gt;, then the permissions on which the specification is based are taken from the mode bits of &lt;var&gt;base-file&lt;/var&gt;. If &lt;var&gt;base-file&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the function uses &lt;code&gt;0&lt;/code&gt; as the base mode bits. The complete and relative specifications can be combined, as in &lt;code&gt;&quot;u+r,g+rx,o+r,g-w&quot;&lt;/code&gt;. See &lt;a href=&quot;https://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions&quot;&gt;File permissions&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab20dbc7190aa4c17064de5aae79eae25a6f3ca2" translate="yes" xml:space="preserve">
          <source>If we know that the &lt;code&gt;&quot;else&quot;&lt;/code&gt; is always aligned with its &lt;code&gt;&quot;if&quot;&lt;/code&gt; and is always at the beginning of a line, we can use a more efficient rule:</source>
          <target state="translated">Если мы знаем, что &lt;code&gt;&quot;else&quot;&lt;/code&gt; всегда выровнено с &lt;code&gt;&quot;if&quot;&lt;/code&gt; и всегда находится в начале строки, мы можем использовать более эффективное правило:</target>
        </trans-unit>
        <trans-unit id="b94e278e89af3d9639830ebb8509d74bc9218c33" translate="yes" xml:space="preserve">
          <source>If you add a new primitive to a file that already has Lisp primitives defined in it, find the function (near the end of the file) named &lt;code&gt;syms_of_&lt;var&gt;something&lt;/var&gt;&lt;/code&gt;, and add the call to &lt;code&gt;defsubr&lt;/code&gt; there. If the file doesn&amp;rsquo;t have this function, or if you create a new file, add to it a &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; (e.g., &lt;code&gt;syms_of_myfile&lt;/code&gt;). Then find the spot in</source>
          <target state="translated">Если вы добавляете новый примитив в файл, в котором уже определены примитивы Лиспа, найдите функцию (в конце файла) с именем &lt;code&gt;syms_of_&lt;var&gt;something&lt;/var&gt;&lt;/code&gt; и добавьте туда вызов &lt;code&gt;defsubr&lt;/code&gt; . Если файл не имеет этой функции или если вы создаете новый файл, добавьте к нему &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; (например, &lt;code&gt;syms_of_myfile&lt;/code&gt; ). Тогда найдите место в</target>
        </trans-unit>
        <trans-unit id="8e51eed80e79b2bcea4605ee7ff46c46550e45f1" translate="yes" xml:space="preserve">
          <source>If you alter the compiled file (such as by compiling a new version), then trying to load any function not already loaded will usually yield nonsense results.</source>
          <target state="translated">Если вы измените скомпилированный файл (например,скомпилировав новую версию),то попытка загрузить любую функцию,которая еще не загружена,как правило,приводит к бессмысленным результатам.</target>
        </trans-unit>
        <trans-unit id="0eb0fd19eca276d41267eb825a3b2aa624892e92" translate="yes" xml:space="preserve">
          <source>If you are careful not to exceed the ring size, you can use the ring as a first-in-first-out queue. For example:</source>
          <target state="translated">Если вы будете осторожны,чтобы не превысить размер кольца,вы можете использовать кольцо в качестве первой очереди.Например:</target>
        </trans-unit>
        <trans-unit id="fc8d2ca20908496286a727bd09248d8bc43a541e" translate="yes" xml:space="preserve">
          <source>If you are running across a network, and different parts of the network work at different baud rates, the value returned by Emacs may be different from the value used by your local terminal. Some network protocols communicate the local terminal speed to the remote machine, so that Emacs and other programs can get the proper value, but others do not. If Emacs has the wrong value, it makes decisions that are less than optimal. To fix the problem, set &lt;code&gt;baud-rate&lt;/code&gt;.</source>
          <target state="translated">Если вы работаете в сети, и разные части сети работают с разной скоростью передачи, значение, возвращаемое Emacs, может отличаться от значения, используемого вашим локальным терминалом. Некоторые сетевые протоколы сообщают скорость локального терминала удаленному компьютеру, чтобы Emacs и другие программы могли получить правильное значение, а другие - нет. Если Emacs имеет неправильное значение, он принимает менее чем оптимальные решения. Чтобы решить эту проблему, установите &lt;code&gt;baud-rate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0072664fa49d446301646082567e540da686bac7" translate="yes" xml:space="preserve">
          <source>If you are sure that a warning message about a missing function or variable is unjustified, there are several ways to suppress it:</source>
          <target state="translated">Если вы уверены,что предупреждающее сообщение о пропущенной функции или переменной является неоправданным,существует несколько способов его подавления:</target>
        </trans-unit>
        <trans-unit id="f22a0f306b8db09319cdd2bfdcd0eed8dd5fd3d7" translate="yes" xml:space="preserve">
          <source>If you are using a macro to do something an ordinary function could do, just for the sake of speed, consider using an inline function instead. See &lt;a href=&quot;inline-functions#Inline-Functions&quot;&gt;Inline Functions&lt;/a&gt;.</source>
          <target state="translated">Если вы используете макрос, чтобы делать что-то, что могла бы сделать обычная функция, просто ради скорости рассмотрите возможность использования вместо этого встроенной функции. См. &lt;a href=&quot;inline-functions#Inline-Functions&quot;&gt;Встроенные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d39bc44a789b7cd31c5d8a478076105fab4e1cea" translate="yes" xml:space="preserve">
          <source>If you are using a mode whose indentation is provided by SMIE, you can customize the indentation to suit your preferences. You can do this on a per-mode basis (using the option &lt;code&gt;smie-config&lt;/code&gt;), or a per-file basis (using the function &lt;code&gt;smie-config-local&lt;/code&gt; in a file-local variable specification).</source>
          <target state="translated">Если вы используете режим, в котором отступ предоставляется SMIE, вы можете настроить отступ в соответствии со своими предпочтениями. Вы можете сделать это для каждого режима (используя параметр &lt;code&gt;smie-config&lt;/code&gt; ) или для каждого файла (используя функцию &lt;code&gt;smie-config-local&lt;/code&gt; в спецификации локальной переменной файла).</target>
        </trans-unit>
        <trans-unit id="af4a68bcde30998a536e42773304bc15d422df91" translate="yes" xml:space="preserve">
          <source>If you are writing code for release, for others to use, try to avoid including advice in it. If the function you want to advise has no hook to do the job, please talk with the Emacs developers about adding a suitable hook. Especially, Emacs&amp;rsquo;s own source files should not put advice on functions in Emacs. (There are currently a few exceptions to this convention, but we aim to correct them.) It is generally cleaner to create a new hook in &lt;code&gt;foo&lt;/code&gt;, and make &lt;code&gt;bar&lt;/code&gt; use the hook, than to have &lt;code&gt;bar&lt;/code&gt; put advice in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Если вы пишете код для выпуска, чтобы его могли использовать другие, старайтесь не включать в него советы. Если функция, которую вы хотите посоветовать, не имеет ловушки для выполнения этой работы, поговорите с разработчиками Emacs о добавлении подходящей ловушки. В частности, собственные исходные файлы Emacs не должны содержать рекомендаций по функциям в Emacs. (В настоящее время есть несколько исключений из этого соглашения, но мы стремимся их исправить.) Обычно проще создать новый перехватчик в &lt;code&gt;foo&lt;/code&gt; и заставить &lt;code&gt;bar&lt;/code&gt; использовать его, чем помещать совет &lt;code&gt;bar&lt;/code&gt; в &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bda02007617357daadbad5daa64711e089b1fa98" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;set-face-attribute&lt;/code&gt; and pass a font spec, font entity, or font name string as the value of the &lt;code&gt;:font&lt;/code&gt; attribute, Emacs opens the best matching font that is available for display. It then stores the corresponding font object as the actual value of the &lt;code&gt;:font&lt;/code&gt; attribute for that face.</source>
          <target state="translated">Если вы вызываете &lt;code&gt;set-face-attribute&lt;/code&gt; и передаете спецификацию шрифта, объект шрифта или строку имени шрифта в качестве значения атрибута &lt;code&gt;:font&lt;/code&gt; , Emacs откроет наиболее подходящий шрифт, доступный для отображения. Затем он сохраняет соответствующий объект шрифта как фактическое значение атрибута &lt;code&gt;:font&lt;/code&gt; для этого лица.</target>
        </trans-unit>
        <trans-unit id="69c55f2e5f8ed1abaffbeb201babe6c0b3098a84" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;sort-regexp-fields&lt;/code&gt; interactively, it prompts for &lt;var&gt;record-regexp&lt;/var&gt; and &lt;var&gt;key-regexp&lt;/var&gt; in the minibuffer.</source>
          <target state="translated">Если вы вызываете &lt;code&gt;sort-regexp-fields&lt;/code&gt; в интерактивном режиме, он запрашивает &lt;var&gt;record-regexp&lt;/var&gt; и &lt;var&gt;key-regexp&lt;/var&gt; в минибуфере.</target>
        </trans-unit>
        <trans-unit id="19b20fbcaed19267c0ae5233685511404c8fe13b" translate="yes" xml:space="preserve">
          <source>If you can read &lt;var&gt;filename&lt;/var&gt; this function returns &lt;code&gt;nil&lt;/code&gt;; otherwise it signals an error using &lt;var&gt;string&lt;/var&gt; as the error message text.</source>
          <target state="translated">Если вы можете прочитать &lt;var&gt;filename&lt;/var&gt; эта функция вернет &lt;code&gt;nil&lt;/code&gt; ; в противном случае он сигнализирует об ошибке, используя &lt;var&gt;string&lt;/var&gt; в качестве текста сообщения об ошибке.</target>
        </trans-unit>
        <trans-unit id="ec646b6002abc5e60335d6f3ab6e9548f2ac3d2c" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;debug-on-error&lt;/code&gt; or &lt;code&gt;debug-on-quit&lt;/code&gt; while Edebug is active, these changes will be forgotten when Edebug becomes inactive. Furthermore, during Edebug&amp;rsquo;s recursive edit, these variables are bound to the values they had outside of Edebug.</source>
          <target state="translated">Если вы измените &lt;code&gt;debug-on-error&lt;/code&gt; или &lt;code&gt;debug-on-quit&lt;/code&gt; когда Edebug активен, эти изменения будут забыты, когда Edebug станет неактивным. Более того, во время рекурсивного редактирования Edebug эти переменные привязываются к значениям, которые у них были вне Edebug.</target>
        </trans-unit>
        <trans-unit id="82e1d7f6837d7e1fd79a005ee98861790c6bed8a" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;debug-on-signal&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value, the debugger gets the first chance at every error, regardless of the presence of &lt;code&gt;condition-case&lt;/code&gt;. (To invoke the debugger, the error must still fulfill the criteria specified by &lt;code&gt;debug-on-error&lt;/code&gt; and &lt;code&gt;debug-ignored-errors&lt;/code&gt;.)</source>
          <target state="translated">Если вы измените значение &lt;code&gt;debug-on-signal&lt;/code&gt; на значение, отличное от &lt;code&gt;nil&lt;/code&gt; , отладчик получит первую возможность при каждой ошибке, независимо от наличия &lt;code&gt;condition-case&lt;/code&gt; . (Чтобы вызвать отладчик, ошибка должна соответствовать критериям, указанным в параметрах &lt;code&gt;debug-on-error&lt;/code&gt; и &lt;code&gt;debug-ignored-errors&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a032c6d2c26bc9a17573480803a0fc6e92740213" translate="yes" xml:space="preserve">
          <source>If you change the bindings in &lt;var&gt;parent-keymap&lt;/var&gt; using &lt;code&gt;define-key&lt;/code&gt; or other key-binding functions, these changed bindings are visible in the inheriting keymap, unless shadowed by the bindings made by &lt;var&gt;elements&lt;/var&gt;. The converse is not true: if you use &lt;code&gt;define-key&lt;/code&gt; to change bindings in the inheriting keymap, these changes are recorded in &lt;var&gt;elements&lt;/var&gt;, but have no effect on &lt;var&gt;parent-keymap&lt;/var&gt;.</source>
          <target state="translated">Если вы изменяете привязки в &lt;var&gt;parent-keymap&lt;/var&gt; клавиш с помощью &lt;code&gt;define-key&lt;/code&gt; или других функций привязки клавиш, эти измененные привязки видны в наследующей раскладке клавиш, если они не затенены привязками, сделанными &lt;var&gt;elements&lt;/var&gt; . Обратное неверно: если вы используете команду &lt;code&gt;define-key&lt;/code&gt; для изменения привязок в наследующей раскладке клавиатуры, эти изменения записываются в &lt;var&gt;elements&lt;/var&gt; , но не влияют на &lt;var&gt;parent-keymap&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="9cb1eba86e3ba5c0e1663be951356c7fd19739f3" translate="yes" xml:space="preserve">
          <source>If you change the values of &lt;code&gt;edebug-on-error&lt;/code&gt; or &lt;code&gt;edebug-on-quit&lt;/code&gt; while Edebug is active, their values won&amp;rsquo;t be used until the &lt;em&gt;next&lt;/em&gt; time Edebug is invoked via a new command.</source>
          <target state="translated">Если вы измените значения &lt;code&gt;edebug-on-error&lt;/code&gt; или &lt;code&gt;edebug-on-quit&lt;/code&gt; , когда Edebug активен, их значения не будут использоваться до &lt;em&gt;следующего&lt;/em&gt; вызова Edebug с помощью новой команды.</target>
        </trans-unit>
        <trans-unit id="b5ecdaab829d09620b381ec99a472542b3bed464" translate="yes" xml:space="preserve">
          <source>If you click a button three or more times and then press it again, the events for the presses beyond the third are all triple events. Emacs does not have separate event types for quadruple, quintuple, etc. events. However, you can look at the event list to find out precisely how many times the button was pressed.</source>
          <target state="translated">Если Вы нажмете на кнопку три или более раз,а затем снова нажмете на нее,то все события для нажатий,выходящих за рамки третьего,будут тройными.В Emacs нет отдельных типов событий для четырех,пяти и т.д.событий.Однако,вы можете посмотреть список событий,чтобы узнать точно,сколько раз была нажата кнопка.</target>
        </trans-unit>
        <trans-unit id="97f76d136a54a91f5ce09fa28d033744e2b18618" translate="yes" xml:space="preserve">
          <source>If you click a button twice and then press it again, all in quick succession, Emacs generates a &lt;em&gt;triple-down&lt;/em&gt; event, followed by either a &lt;em&gt;triple-click&lt;/em&gt; or a &lt;em&gt;triple-drag&lt;/em&gt;. The event types of these events contain &amp;lsquo;</source>
          <target state="translated">Если вы дважды щелкнете кнопку, а затем снова нажмете ее быстро, Emacs сгенерирует событие &lt;em&gt;тройного снижения&lt;/em&gt; , за которым следует либо &lt;em&gt;тройной щелчок,&lt;/em&gt; либо &lt;em&gt;тройное перетаскивание&lt;/em&gt; . Типы событий этих событий содержат '</target>
        </trans-unit>
        <trans-unit id="babf73f5ef063cd1ca16de5c46e1c4b38d2d236a" translate="yes" xml:space="preserve">
          <source>If you click a button, then press it down again and start moving the mouse with the button held down, then you get a &lt;em&gt;double-drag&lt;/em&gt; event when you ultimately release the button. Its event type contains &amp;lsquo;</source>
          <target state="translated">Если вы нажмете кнопку, затем снова нажмете ее и начнете перемещать мышь, удерживая нажатой кнопку, вы получите событие &lt;em&gt;двойного перетаскивания,&lt;/em&gt; когда вы в конечном итоге отпустите кнопку. Его тип события содержит '</target>
        </trans-unit>
        <trans-unit id="c5fb3a0c87cdbd7c9d430fccee88612b713587b6" translate="yes" xml:space="preserve">
          <source>If you compile the above code, the anonymous function is also compiled. This would not happen if, say, you had constructed the anonymous function by quoting it as a list:</source>
          <target state="translated">Если вы скомпилируете приведенный выше код,то также будет скомпилирована анонимная функция.Этого бы не случилось,если бы,скажем,вы скомпилировали анонимную функцию,процитировав ее как список:</target>
        </trans-unit>
        <trans-unit id="3585ff0dc0e69eb3875d3c21881701fbf12049b6" translate="yes" xml:space="preserve">
          <source>If you define a function which is side-effect free or pure, give it a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;side-effect-free&lt;/code&gt; or &lt;code&gt;pure&lt;/code&gt; property, respectively (see &lt;a href=&quot;standard-properties#Standard-Properties&quot;&gt;Standard Properties&lt;/a&gt;).</source>
          <target state="translated">Если вы определяете функцию, свободную от побочных эффектов или чистую, присвойте ей &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;side-effect-free&lt;/code&gt; или &lt;code&gt;pure&lt;/code&gt; свойство соответственно (см. &lt;a href=&quot;standard-properties#Standard-Properties&quot;&gt;Стандартные свойства&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d356c50a344f26b7b7e0c2e2a88f2a9d47c5035" translate="yes" xml:space="preserve">
          <source>If you delete or move the compiled file after loading it, Emacs can no longer load the remaining function definitions not already loaded.</source>
          <target state="translated">Если вы удалите или переместите скомпилированный файл после его загрузки,Emacs больше не сможет загружать оставшиеся определения функций,которые еще не загружены.</target>
        </trans-unit>
        <trans-unit id="832ed8c18f70d41abab32f7213d1a98c3b93e0e3" translate="yes" xml:space="preserve">
          <source>If you did the last search in a buffer, you should omit the &lt;var&gt;string&lt;/var&gt; argument or specify &lt;code&gt;nil&lt;/code&gt; for it, and make sure that the current buffer is the one in which you performed the last search. Then this function edits the buffer, replacing the matched text with &lt;var&gt;replacement&lt;/var&gt;. It leaves point at the end of the replacement text.</source>
          <target state="translated">Если вы выполняли последний поиск в буфере, вы должны опустить &lt;var&gt;string&lt;/var&gt; аргумент или указать для него &lt;code&gt;nil&lt;/code&gt; и убедиться, что текущий буфер - это тот, в котором вы выполняли последний поиск. Затем эта функция редактирует буфер, заменяя совпавший текст на &lt;var&gt;replacement&lt;/var&gt; . Он оставляет точку в конце текста замены.</target>
        </trans-unit>
        <trans-unit id="5752e1504ebf2064bf0d5937ac79557053162460" translate="yes" xml:space="preserve">
          <source>If you directly define a file-scope C variable of type &lt;code&gt;Lisp_Object&lt;/code&gt;, you must protect it from garbage-collection by calling &lt;code&gt;staticpro&lt;/code&gt; in &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt;, like this:</source>
          <target state="translated">Если вы напрямую определяете переменную C в области &lt;code&gt;Lisp_Object&lt;/code&gt; типа типа Lisp_Object , вы должны защитить ее от сборки мусора, вызвав &lt;code&gt;staticpro&lt;/code&gt; в &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="a799552f0c440dd51dc850366b3de6e02e55511d" translate="yes" xml:space="preserve">
          <source>If you divide an integer by the integer 0, Emacs signals an &lt;code&gt;arith-error&lt;/code&gt; error (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;). Floating-point division of a nonzero number by zero yields either positive or negative infinity (see &lt;a href=&quot;float-basics#Float-Basics&quot;&gt;Float Basics&lt;/a&gt;).</source>
          <target state="translated">Если вы разделите целое число на целое число 0, Emacs сигнализирует &lt;code&gt;arith-error&lt;/code&gt; ошибке арифметической ошибки (см. &lt;a href=&quot;errors#Errors&quot;&gt;Ошибки&lt;/a&gt; ). Деление ненулевого числа с плавающей запятой на ноль дает либо положительную, либо отрицательную бесконечность (см. &lt;a href=&quot;float-basics#Float-Basics&quot;&gt;Основы&lt;/a&gt; операций с плавающей запятой ).</target>
        </trans-unit>
        <trans-unit id="c48948f392e624e52dbc1aa826b6d5945fcc5647" translate="yes" xml:space="preserve">
          <source>If you do alter &lt;code&gt;mode-line-format&lt;/code&gt; itself, the new value should use the same variables that appear in the default value (see &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Mode Line Variables&lt;/a&gt;), rather than duplicating their contents or displaying the information in another fashion. This way, customizations made by the user or by Lisp programs (such as &lt;code&gt;display-time&lt;/code&gt; and major modes) via changes to those variables remain effective.</source>
          <target state="translated">Если вы изменяете сам &lt;code&gt;mode-line-format&lt;/code&gt; , новое значение должно использовать те же переменные, которые появляются в значении по умолчанию (см. &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Переменные строки режима&lt;/a&gt; ), а не дублировать их содержимое или отображать информацию другим способом. Таким образом, настройки, сделанные пользователем или программами Lisp (например, время &lt;code&gt;display-time&lt;/code&gt; и основные режимы) посредством изменений этих переменных, остаются в силе.</target>
        </trans-unit>
        <trans-unit id="919e7db85c8f5ee11bd70bb4cc9d84095b916140" translate="yes" xml:space="preserve">
          <source>If you do not specify a window&amp;rsquo;s scroll bar settings via &lt;code&gt;set-window-scroll-bars&lt;/code&gt;, the buffer-local variables &lt;code&gt;vertical-scroll-bar&lt;/code&gt;, &lt;code&gt;horizontal-scroll-bar&lt;/code&gt;, &lt;code&gt;scroll-bar-width&lt;/code&gt; and &lt;code&gt;scroll-bar-height&lt;/code&gt; in the buffer being displayed control the window&amp;rsquo;s scroll bars. The function &lt;code&gt;set-window-buffer&lt;/code&gt; examines these variables. If you change them in a buffer that is already visible in a window, you can make the window take note of the new values by calling &lt;code&gt;set-window-buffer&lt;/code&gt; specifying the same buffer that is already displayed.</source>
          <target state="translated">Если вы не указываете настройки полосы прокрутки окна с помощью &lt;code&gt;set-window-scroll-bars&lt;/code&gt; , локальные переменные буфера &lt;code&gt;vertical-scroll-bar&lt;/code&gt; , &lt;code&gt;horizontal-scroll-bar&lt;/code&gt; , &lt;code&gt;scroll-bar-width&lt;/code&gt; и &lt;code&gt;scroll-bar-height&lt;/code&gt; в буфере отображаемые управляют полосами прокрутки окна. Эти переменные проверяет функция &lt;code&gt;set-window-buffer&lt;/code&gt; . Если вы измените их в буфере, который уже виден в окне, вы можете заставить окно принимать к сведению новые значения, вызывая &lt;code&gt;set-window-buffer&lt;/code&gt; , указав тот же буфер, который уже отображается.</target>
        </trans-unit>
        <trans-unit id="7d5478635f2aa0a1b8f06759d112fc9a81bb9ae9" translate="yes" xml:space="preserve">
          <source>If you do not want a Lisp file to be compiled, ever, put a file-local variable binding for &lt;code&gt;no-byte-compile&lt;/code&gt; into it, like this:</source>
          <target state="translated">Если вы никогда не хотите, чтобы файл Lisp компилировался, поместите в него привязку локальной переменной файла для &lt;code&gt;no-byte-compile&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="bd9289930e0af37b6580f5f7e82b4908b4ac925e" translate="yes" xml:space="preserve">
          <source>If you do not want a particular command to be recognized as the previous command in the case where it got an error, you must code that command to prevent this. One way is to set &lt;code&gt;this-command&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; at the beginning of the command, and set &lt;code&gt;this-command&lt;/code&gt; back to its proper value at the end, like this:</source>
          <target state="translated">Если вы не хотите, чтобы определенная команда распознавалась как предыдущая в случае ошибки, вы должны закодировать эту команду, чтобы предотвратить это. Один из способов - установить &lt;code&gt;this-command&lt;/code&gt; в &lt;code&gt;t&lt;/code&gt; в начале команды и вернуть &lt;code&gt;this-command&lt;/code&gt; обратно в правильное значение в конце, например:</target>
        </trans-unit>
        <trans-unit id="5611162597f8b6ec87950a669e8a5984dfaa42e0" translate="yes" xml:space="preserve">
          <source>If you do not want this feature, set the variable &lt;code&gt;case-fold-search&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;. Then all letters must match exactly, including case. This is a buffer-local variable; altering the variable affects only the current buffer. (See &lt;a href=&quot;intro-to-buffer_002dlocal#Intro-to-Buffer_002dLocal&quot;&gt;Intro to Buffer-Local&lt;/a&gt;.) Alternatively, you may change the default value. In Lisp code, you will more typically use &lt;code&gt;let&lt;/code&gt; to bind &lt;code&gt;case-fold-search&lt;/code&gt; to the desired value.</source>
          <target state="translated">Если вам не нужна эта функция, установите для переменной &lt;code&gt;case-fold-search&lt;/code&gt; значение &lt;code&gt;nil&lt;/code&gt; . Тогда все буквы должны точно совпадать, включая регистр. Это переменная локального буфера; изменение переменной влияет только на текущий буфер. (См. &lt;a href=&quot;intro-to-buffer_002dlocal#Intro-to-Buffer_002dLocal&quot;&gt;Введение в Buffer-Local&lt;/a&gt; .) Кроме того, вы можете изменить значение по умолчанию. В коде Lisp вы чаще будете использовать &lt;code&gt;let&lt;/code&gt; для привязки &lt;code&gt;case-fold-search&lt;/code&gt; к желаемому значению.</target>
        </trans-unit>
        <trans-unit id="f866fd286c45411a67dbb50a84fea3f20ae8d82b" translate="yes" xml:space="preserve">
          <source>If you do set the same variable again, the new value replaces the old one:</source>
          <target state="translated">Если вы установите ту же самую переменную снова,то новое значение заменит старую:</target>
        </trans-unit>
        <trans-unit id="3402ff5b14ba5a8ea18eb9cb2a7a34434be535f3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know exactly where in the source code you want to put the debug statement, but you want to display a backtrace when a certain message is displayed, you can set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression matching the desired message.</source>
          <target state="translated">Если вы не знаете точно, где в исходном коде вы хотите поместить оператор отладки, но хотите отображать обратную трассировку при отображении определенного сообщения, вы можете установить &lt;code&gt;debug-on-message&lt;/code&gt; для регулярного выражения, соответствующего желаемому сообщению .</target>
        </trans-unit>
        <trans-unit id="1411d7398cdf316f7a761acc6232531b6f93aa6f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t see a problem at that point, the next thing to do is to type</source>
          <target state="translated">Если на этом этапе вы не видите проблемы, следующее, что вам нужно сделать, это ввести</target>
        </trans-unit>
        <trans-unit id="c777867a4fcf3b6790ba4a3f6676ab8e8eb5e7ea" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify &lt;var&gt;help&lt;/var&gt;, the default is &lt;code&gt;(&quot;object&quot;
&quot;objects&quot; &quot;act on&quot;)&lt;/code&gt;.</source>
          <target state="translated">Если вы не укажете &lt;var&gt;help&lt;/var&gt; , по умолчанию используется &lt;code&gt;(&quot;object&quot; &quot;objects&quot; &quot;act on&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73fcecbc1356991b98581a800856e4e2763a1b17" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify &lt;var&gt;history&lt;/var&gt;, then the default history list &lt;code&gt;minibuffer-history&lt;/code&gt; is used. For other standard history lists, see below. You can also create your own history list variable; just initialize it to &lt;code&gt;nil&lt;/code&gt; before the first use. If the variable is buffer local, then each buffer will have its own input history list.</source>
          <target state="translated">Если вы не укажете &lt;var&gt;history&lt;/var&gt; , то будет использоваться список истории по умолчанию &lt;code&gt;minibuffer-history&lt;/code&gt; . Для других стандартных списков истории см. Ниже. Вы также можете создать свою собственную переменную списка истории; просто инициализируйте его до &lt;code&gt;nil&lt;/code&gt; перед первым использованием. Если переменная является локальной буфером, то каждый буфер будет иметь свой собственный список истории ввода.</target>
        </trans-unit>
        <trans-unit id="3b45979ffc14a7465f0296ae53f5338e35b87473" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify the &lt;code&gt;line-height&lt;/code&gt; property, the line&amp;rsquo;s height consists of the contents&amp;rsquo; height plus the line spacing. There are several ways to specify the line spacing for different parts of Emacs text.</source>
          <target state="translated">Если вы не укажете свойство &lt;code&gt;line-height&lt;/code&gt; , высота строки будет складываться из высоты содержимого плюс межстрочный интервал. Есть несколько способов указать межстрочный интервал для разных частей текста Emacs.</target>
        </trans-unit>
        <trans-unit id="b6743c06f00234ad9062a2a3a2ea7fc17e673ef8" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify this keyword at all, the default is to determine the coding systems from the data.</source>
          <target state="translated">Если вы вообще не укажете это ключевое слово, по умолчанию будет определяться система кодирования из данных.</target>
        </trans-unit>
        <trans-unit id="04bef473929ac543401da8285cfb9a7eb0c1717c" translate="yes" xml:space="preserve">
          <source>If you get a warning that</source>
          <target state="translated">Если вы получите предупреждение,что</target>
        </trans-unit>
        <trans-unit id="e767fb6147ef9fb326b46a3482c4c2ceedb2b93a" translate="yes" xml:space="preserve">
          <source>If you have a constant that needs some calculation to produce, &lt;code&gt;eval-when-compile&lt;/code&gt; can do that at compile-time. For example,</source>
          <target state="translated">Если у вас есть константа, для получения которой требуется вычисление, &lt;code&gt;eval-when-compile&lt;/code&gt; может сделать это во время компиляции. Например,</target>
        </trans-unit>
        <trans-unit id="3f37032d6c165b2681c4b1c8b2c526ae79d7f709" translate="yes" xml:space="preserve">
          <source>If you have a frame that displays only one window, you can fit that frame to its buffer using the command &lt;code&gt;fit-frame-to-buffer&lt;/code&gt;.</source>
          <target state="translated">Если у вас есть фрейм, который отображает только одно окно, вы можете уместить этот фрейм в его буфер, используя команду &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33faad871265de71a9510766889514f64259bfd3" translate="yes" xml:space="preserve">
          <source>If you have made extensive changes to a file and then change your mind about them, you can get rid of them by reading in the previous version of the file with the &lt;code&gt;revert-buffer&lt;/code&gt; command. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html#Reverting&quot;&gt;Reverting a Buffer&lt;/a&gt; in</source>
          <target state="translated">Если вы внесли значительные изменения в файл, а затем передумали, вы можете избавиться от них, прочитав предыдущую версию файла с помощью команды &lt;code&gt;revert-buffer&lt;/code&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html#Reverting&quot;&gt;Восстановление буфера&amp;raquo;&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="836de1182d58bd84cc84aa30faed5853ecd60d34" translate="yes" xml:space="preserve">
          <source>If you have made extensive changes to a file and then change your mind about them, you can get rid of them by reading in the previous version of the file with the &lt;code&gt;revert-buffer&lt;/code&gt; command. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html#Reverting&quot;&gt;Reverting a Buffer&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3114430b909452db4a0ad15c4686bf655a82d1b5" translate="yes" xml:space="preserve">
          <source>If you have never given a symbol any function definition, we say that that symbol&amp;rsquo;s function cell is &lt;em&gt;void&lt;/em&gt;. In other words, the function cell does not have any Lisp object in it. If you try to call the symbol as a function, Emacs signals a &lt;code&gt;void-function&lt;/code&gt; error.</source>
          <target state="translated">Если вы никогда не давали символу какое-либо определение функции, мы говорим, что функциональная ячейка этого символа &lt;em&gt;недействительна&lt;/em&gt; . Другими словами, в функциональной ячейке нет никаких объектов Лиспа. Если вы попытаетесь вызвать символ как функцию, Emacs сигнализирует об ошибке &lt;code&gt;void-function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1adb1c551e5096149203b778dae4aca140133316" translate="yes" xml:space="preserve">
          <source>If you have passed a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;stderr&lt;/var&gt; to &lt;code&gt;make-process&lt;/code&gt;, it will have a standard error process. See &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Asynchronous Processes&lt;/a&gt;. In that case, waiting for process output from the main process doesn&amp;rsquo;t wait for output from the standard error process. To make sure you have received both all of standard output and all of standard error from a process, use the following code:</source>
          <target state="translated">Если вы прошли не- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;stderr&lt;/var&gt; , чтобы &lt;code&gt;make-process&lt;/code&gt; , он будет иметь стандартный процесс ошибки. См. &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Асинхронные процессы&lt;/a&gt; . В этом случае ожидание вывода процесса от основного процесса не ожидает вывода от стандартного процесса ошибки. Чтобы убедиться, что вы получили как весь стандартный вывод, так и все стандартные ошибки процесса, используйте следующий код:</target>
        </trans-unit>
        <trans-unit id="ef54783b26bd82dc91fad381aa3579ce041cbe4e" translate="yes" xml:space="preserve">
          <source>If you instrument the &lt;code&gt;test&lt;/code&gt; macro and step through it, then by default the result of the &lt;code&gt;symbol-function&lt;/code&gt; call has numerous &lt;code&gt;edebug-after&lt;/code&gt; and &lt;code&gt;edebug-before&lt;/code&gt; forms, which can make it difficult to see the actual result. If &lt;code&gt;edebug-unwrap-results&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, Edebug tries to remove these forms from the result.</source>
          <target state="translated">Если вы инструментируете &lt;code&gt;test&lt;/code&gt; макрос и проходите через него, то по умолчанию результат вызова &lt;code&gt;symbol-function&lt;/code&gt; имеет множество &lt;code&gt;edebug-after&lt;/code&gt; и &lt;code&gt;edebug-before&lt;/code&gt; , что может затруднить просмотр фактического результата. Если &lt;code&gt;edebug-unwrap-results&lt;/code&gt; не равно &lt;code&gt;nil&lt;/code&gt; , Edebug пытается удалить эти формы из результата.</target>
        </trans-unit>
        <trans-unit id="33abc94ec53362e4d866e3e4d48d4aa529da00b3" translate="yes" xml:space="preserve">
          <source>If you instrument the definition of &lt;code&gt;fac&lt;/code&gt; (shown below) and then execute &lt;code&gt;(fac 3)&lt;/code&gt;, here is what you would normally see. Point is at the open-parenthesis before &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">Если вы инструментируете определение &lt;code&gt;fac&lt;/code&gt; (показано ниже), а затем выполняете &lt;code&gt;(fac 3)&lt;/code&gt; , вот что вы обычно увидите. Точка стоит в скобках перед &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30df8677ae4d4b292044bc3da5da7b6491d7a906" translate="yes" xml:space="preserve">
          <source>If you invoke Emacs with command-line options that specify frame appearance, those options take effect by adding elements to either &lt;code&gt;initial-frame-alist&lt;/code&gt; or &lt;code&gt;default-frame-alist&lt;/code&gt;. Options which affect just the initial frame, such as &amp;lsquo;</source>
          <target state="translated">Если вы вызываете Emacs с параметрами командной строки, которые определяют внешний вид фрейма, эти параметры вступают в силу путем добавления элементов либо в &lt;code&gt;initial-frame-alist&lt;/code&gt; , либо в &lt;code&gt;default-frame-alist&lt;/code&gt; . Параметры, влияющие только на начальный кадр, например '</target>
        </trans-unit>
        <trans-unit id="4f8ed670902a9aad525f057b6320f5c8058a1c22" translate="yes" xml:space="preserve">
          <source>If you just want to automatically auto-revert every &lt;code&gt;auto-revert-interval&lt;/code&gt; seconds (like the Buffer Menu), use:</source>
          <target state="translated">Если вы просто хотите автоматически возвращаться через каждые секунды &lt;code&gt;auto-revert-interval&lt;/code&gt; (например, в меню буфера), используйте:</target>
        </trans-unit>
        <trans-unit id="71a2adf65a17fe610efe228b45e1cb903d7bc113" translate="yes" xml:space="preserve">
          <source>If you kill a buffer that is current or displayed in a window, Emacs automatically selects or displays some other buffer instead. This means that killing a buffer can change the current buffer. Therefore, when you kill a buffer, you should also take the precautions associated with changing the current buffer (unless you happen to know that the buffer being killed isn&amp;rsquo;t current). See &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;.</source>
          <target state="translated">Если вы уничтожаете текущий или отображаемый в окне буфер, Emacs автоматически выбирает или отображает вместо него какой-нибудь другой буфер. Это означает, что уничтожение буфера может изменить текущий буфер. Следовательно, когда вы уничтожаете буфер, вы также должны принять меры предосторожности, связанные с изменением текущего буфера (если только вы не знаете, что уничтожаемый буфер не является текущим). См. &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Текущий буфер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2706b518d3512c99807786ca5940e248dfba9276" translate="yes" xml:space="preserve">
          <source>If you kill a buffer that is the base buffer of one or more indirect buffers (see &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;), the indirect buffers are automatically killed as well.</source>
          <target state="translated">Если вы уничтожаете буфер, который является базовым буфером одного или нескольких косвенных буферов (см. &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Косвенные буферы&lt;/a&gt; ), косвенные буферы также автоматически уничтожаются.</target>
        </trans-unit>
        <trans-unit id="939512f98de951d77e46c1fff3ddbca96952464a" translate="yes" xml:space="preserve">
          <source>If you kill the buffer-local binding of a variable that automatically becomes buffer-local when set, this makes the default value visible in the current buffer. However, if you set the variable again, that will once again create a buffer-local binding for it.</source>
          <target state="translated">Если вы убьете привязку переменной,которая автоматически становится локальной в буфере при установке,это сделает значение по умолчанию видимым в текущем буфере.Однако,если вы установите переменную снова,то это снова создаст для нее привязку по буферу.</target>
        </trans-unit>
        <trans-unit id="0bd6b02038337f2a12bac9ed44de58bac548a3a1" translate="yes" xml:space="preserve">
          <source>If you make local bindings (with &lt;code&gt;let&lt;/code&gt; or function arguments) for a variable that may also have buffer-local bindings, make sure that the same buffer is current at the beginning and at the end of the local binding&amp;rsquo;s scope. Otherwise you might bind it in one buffer and unbind it in another!</source>
          <target state="translated">Если вы выполняете локальные привязки (с &lt;code&gt;let&lt;/code&gt; или аргументами функции) для переменной, которая также может иметь привязки к локальному буферу, убедитесь, что тот же буфер является текущим в начале и в конце области локальной привязки. В противном случае вы можете привязать его к одному буферу и отвязать в другом!</target>
        </trans-unit>
        <trans-unit id="0b3744efd19539e84c69f0918b4efca1435c71f7" translate="yes" xml:space="preserve">
          <source>If you may need to follow symbolic links preceding &amp;lsquo;</source>
          <target state="translated">Если вам может потребоваться перейти по символическим ссылкам перед '</target>
        </trans-unit>
        <trans-unit id="b461f9a1f06af80679d7c10a422deb5335205d1b" translate="yes" xml:space="preserve">
          <source>If you modify any of these two variables, you should normally modify both, to make sure they describe paragraphs consistently. For example, to have each new line start a new paragraph for bidi-reordering purposes, set both variables to &lt;code&gt;&quot;^&quot;&lt;/code&gt;.</source>
          <target state="translated">Если вы изменяете любую из этих двух переменных, вам обычно следует изменять обе, чтобы обеспечить единообразное описание абзацев. Например, чтобы каждая новая строка начинала новый абзац с целью переупорядочения двунаправленного текста, установите для обеих переменных значение &lt;code&gt;&quot;^&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb55a4c1fcd6f3dc2ebf9fd160259311b33e11d" translate="yes" xml:space="preserve">
          <source>If you need a function to read a character using the minibuffer, use &lt;code&gt;read-char-from-minibuffer&lt;/code&gt; (see &lt;a href=&quot;multiple-queries#Multiple-Queries&quot;&gt;Multiple Queries&lt;/a&gt;).</source>
          <target state="translated">Если вам нужна функция для чтения символа с помощью минибуфера, используйте &lt;code&gt;read-char-from-minibuffer&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;multiple-queries#Multiple-Queries&quot;&gt;Множественные запросы&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2229e5dcc64890b68f42258b57c852775ec25771" translate="yes" xml:space="preserve">
          <source>If you need full backtracking capability to handle multiple uses of &amp;lsquo;</source>
          <target state="translated">Если вам нужна возможность полного обратного отслеживания для многократного использования '</target>
        </trans-unit>
        <trans-unit id="7165f313d61fb790c146d795e82a0805252bf947" translate="yes" xml:space="preserve">
          <source>If you need something more sophisticated, such as to make changes in various buffers constitute one atomic group, you must directly call lower-level functions that &lt;code&gt;atomic-change-group&lt;/code&gt; uses.</source>
          <target state="translated">Если вам нужно что-то более сложное, например, чтобы изменения в различных буферах составляли одну атомарную группу, вы должны напрямую вызывать функции нижнего уровня, которые использует &lt;code&gt;atomic-change-group&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11ad821a0f4118843537a5c201be2e1b6fea9371" translate="yes" xml:space="preserve">
          <source>If you need to ask the user a question that might have more than just 2 answers, use &lt;code&gt;read-answer&lt;/code&gt;.</source>
          <target state="translated">Если вам нужно задать пользователю вопрос, на который может быть более двух ответов, используйте &lt;code&gt;read-answer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb6836f3fc908033ed970b99b5923dc6160e9d7e" translate="yes" xml:space="preserve">
          <source>If you need to compute the width of a string on display, you should use &lt;code&gt;string-width&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;), not &lt;code&gt;length&lt;/code&gt;, since &lt;code&gt;length&lt;/code&gt; only counts the number of characters, but does not account for the display width of each character.</source>
          <target state="translated">Если вам нужно вычислить ширину отображаемой строки, вы должны использовать &lt;code&gt;string-width&lt;/code&gt; (см. &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Размер отображаемого текста&lt;/a&gt; ), а не &lt;code&gt;length&lt;/code&gt; , поскольку &lt;code&gt;length&lt;/code&gt; учитывает только количество символов, но не учитывает ширину отображения каждого символа. .</target>
        </trans-unit>
        <trans-unit id="70e7694409075c9777e7eff046635c9af505c810" translate="yes" xml:space="preserve">
          <source>If you need to deal with time values that are not representable by &lt;code&gt;struct timespec&lt;/code&gt;, or if you want higher precision, call the Lisp function &lt;code&gt;encode-time&lt;/code&gt; and work with its return value. See &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно иметь дело со значениями времени, которые не могут быть представлены &lt;code&gt;struct timespec&lt;/code&gt; , или если вам нужна более высокая точность, вызовите функцию Lisp &lt;code&gt;encode-time&lt;/code&gt; и работайте с ее возвращаемым значением. См. &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Преобразование времени&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b147bdeb91ba4529c7e7a0d87287ac0e0835ba" translate="yes" xml:space="preserve">
          <source>If you need to display in a single buffer several very different types of text, consider using an alternative facility described in &lt;a href=&quot;swapping-text#Swapping-Text&quot;&gt;Swapping Text&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно отобразить в одном буфере несколько очень разных типов текста, рассмотрите возможность использования альтернативного средства, описанного в &lt;a href=&quot;swapping-text#Swapping-Text&quot;&gt;разделе &amp;laquo;Замена текста&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eeed25719a7b61a09bb3ff7fc01192b5bf607932" translate="yes" xml:space="preserve">
          <source>If you need to make sure the resulting string, when copied to a different location, will not change its visual appearance due to reordering of bidirectional text, use the &lt;code&gt;buffer-substring-with-bidi-context&lt;/code&gt; function (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;buffer-substring-with-bidi-context&lt;/a&gt;).</source>
          <target state="translated">Если вам нужно убедиться, что результирующая строка при копировании в другое место не изменит свой внешний вид из-за переупорядочения двунаправленного текста, используйте функцию &lt;code&gt;buffer-substring-with-bidi-context&lt;/code&gt; (см. &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Buffer-substring-with- биди-контекст&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6b2d2f05788f0a22eaa0bceb4193d2292e14cac" translate="yes" xml:space="preserve">
          <source>If you need to split a string into a list of individual command-line arguments suitable for &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, see &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;split-string-and-unquote&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно разбить строку на список отдельных аргументов командной строки, подходящих для &lt;code&gt;call-process&lt;/code&gt; или &lt;code&gt;start-process&lt;/code&gt; , см. &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;Раздел split-string-and-unquote&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af860e5b717926ca034b7f46b6b08bfccf91b51e" translate="yes" xml:space="preserve">
          <source>If you need to use &lt;code&gt;funcall&lt;/code&gt; to call a command and make it behave as if invoked interactively, use &lt;code&gt;funcall-interactively&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">Если вам нужно использовать &lt;code&gt;funcall&lt;/code&gt; для вызова команды и заставить ее вести себя так, как если бы она вызывалась в интерактивном режиме, используйте &lt;code&gt;funcall-interactively&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Интерактивный вызов&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d21db95cbdcf54c25ebb2a8e577371ca4dde72ec" translate="yes" xml:space="preserve">
          <source>If you need to use binary I/O in batch mode, e.g., use the functions described in this section to write out arbitrary binary data or avoid conversion of newlines on non-POSIX hosts, see &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;set-binary-mode&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно использовать двоичный ввод-вывод в пакетном режиме, например, используйте функции, описанные в этом разделе, для записи произвольных двоичных данных или избегайте преобразования новой строки на хостах, отличных от POSIX, см. &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Set-binary-mode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b65293e7558904871088857519e372b129e02eab" translate="yes" xml:space="preserve">
          <source>If you only need to save and restore the identity of the current buffer, use &lt;code&gt;save-current-buffer&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt; instead (see &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;). If you need to save or restore window configurations, see the forms described in &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt; and in &lt;a href=&quot;frame-configurations#Frame-Configurations&quot;&gt;Frame Configurations&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно только сохранить и восстановить идентичность текущего буфера, используйте вместо этого &lt;code&gt;save-current-buffer&lt;/code&gt; или &lt;code&gt;with-current-buffer&lt;/code&gt; (см. &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Текущий буфер&lt;/a&gt; ). Если вам необходимо сохранить или восстановить конфигурации окон, см. Формы, описанные в &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;разделах &amp;laquo;Конфигурации окон&amp;raquo;&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;frame-configurations#Frame-Configurations&quot;&gt;Конфигурации фреймов&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9083fbc2d21158149a1bc8ac3c7f2844e3ff216f" translate="yes" xml:space="preserve">
          <source>If you performed the last search on a string, pass the same string as &lt;var&gt;string&lt;/var&gt;. Then this function returns a new string, in which the matched text is replaced by &lt;var&gt;replacement&lt;/var&gt;.</source>
          <target state="translated">Если вы выполнили последний поиск в строке, передайте ту же строку как &lt;var&gt;string&lt;/var&gt; . Затем эта функция возвращает новую строку, в которой совпавший текст заменяется &lt;var&gt;replacement&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd25781d637473670d3becc584d66487e91046b" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;read&lt;/code&gt; later on the formatted string to retrieve a copy of the formatted value, use a specification that lets &lt;code&gt;read&lt;/code&gt; reconstruct the value. To format numbers in this reversible way you can use &amp;lsquo;</source>
          <target state="translated">Если вы планируете использовать &lt;code&gt;read&lt;/code&gt; позже для форматированной строки, чтобы получить копию форматированного значения, используйте спецификацию, которая позволяет &lt;code&gt;read&lt;/code&gt; реконструировать значение. Для форматирования чисел таким обратимым способом вы можете использовать '</target>
        </trans-unit>
        <trans-unit id="6a33cd11cdd6f251eb76fe12ca6c4e85092aa642" translate="yes" xml:space="preserve">
          <source>If you press the same mouse button more than once in quick succession without moving the mouse, Emacs generates special &lt;em&gt;repeat&lt;/em&gt; mouse events for the second and subsequent presses.</source>
          <target state="translated">Если вы нажмете одну и ту же кнопку мыши более одного раза в быстрой последовательности без перемещения мыши, Emacs сгенерирует специальные &lt;em&gt;повторяющиеся&lt;/em&gt; события мыши для второго и последующих нажатий.</target>
        </trans-unit>
        <trans-unit id="6e651e37e48dc0de984abd21d2f50cbabd101a42" translate="yes" xml:space="preserve">
          <source>If you provide a string instead of a symbol as &lt;var&gt;symbol&lt;/var&gt;, it stands for a symbol name. Then &lt;code&gt;unintern&lt;/code&gt; deletes the symbol (if any) in the obarray which has that name. If there is no such symbol, &lt;code&gt;unintern&lt;/code&gt; does nothing.</source>
          <target state="translated">Если вы предоставляете строку вместо символа в качестве &lt;var&gt;symbol&lt;/var&gt; , это означает имя символа. Затем &lt;code&gt;unintern&lt;/code&gt; удаляет символ (если есть) в массиве с таким именем. Если такого символа нет, &lt;code&gt;unintern&lt;/code&gt; ничего не делает.</target>
        </trans-unit>
        <trans-unit id="97d5739d107f56aa611048ed083389faa16f7c11" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;defcustom&lt;/code&gt; in a pre-loaded Emacs Lisp file (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), the standard value installed at dump time might be incorrect, e.g., because another variable that it depends on has not been assigned the right value yet. In that case, use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt;, described below, to re-evaluate the standard value after Emacs starts up.</source>
          <target state="translated">Если вы поместите &lt;code&gt;defcustom&lt;/code&gt; в предварительно загруженный файл Emacs Lisp (см. &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Сборка Emacs&lt;/a&gt; ), стандартное значение, установленное во время дампа, может быть неправильным, например, потому что другой переменной, от которой он зависит, еще не было присвоено правильное значение. В этом случае используйте &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; , описанный ниже, чтобы повторно оценить стандартное значение после запуска Emacs.</target>
        </trans-unit>
        <trans-unit id="6c382b520db08e679ebb946a10d148108b4e2829" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;yank-handler&lt;/code&gt; text property on all or part of a string, that alters how &lt;code&gt;insert-for-yank&lt;/code&gt; inserts the string. If different parts of the string have different &lt;code&gt;yank-handler&lt;/code&gt; values (comparison being done with &lt;code&gt;eq&lt;/code&gt;), each substring is handled separately. The property value must be a list of one to four elements, with the following format (where elements after the first may be omitted):</source>
          <target state="translated">Если вы поместите свойство текста &lt;code&gt;yank-handler&lt;/code&gt; восстановления на всю строку или ее часть, это изменит способ &lt;code&gt;insert-for-yank&lt;/code&gt; строки при вставке для восстановления. Если разные части строки имеют разные значения &lt;code&gt;yank-handler&lt;/code&gt; восстановления (сравнение выполняется с помощью &lt;code&gt;eq&lt;/code&gt; ), каждая подстрока обрабатывается отдельно. Значение свойства должно быть списком от одного до четырех элементов в следующем формате (где элементы после первого могут быть опущены):</target>
        </trans-unit>
        <trans-unit id="20d9b4533ab2bc9736806c58622cd4bf44e87f4c" translate="yes" xml:space="preserve">
          <source>If you redump Emacs by calling &lt;code&gt;dump-emacs&lt;/code&gt; (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), you may wish to set this variable to &lt;code&gt;nil&lt;/code&gt; first in order to cause the new dumped Emacs to process its new command-line arguments.</source>
          <target state="translated">Если вы перенаправляете Emacs, вызывая &lt;code&gt;dump-emacs&lt;/code&gt; (см. &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Сборка Emacs&lt;/a&gt; ), вы можете сначала установить для этой переменной значение &lt;code&gt;nil&lt;/code&gt; , чтобы новый выгруженный Emacs обработал свои новые аргументы командной строки.</target>
        </trans-unit>
        <trans-unit id="085a188ee0ae3f10744759afa9f5b7baf461b132" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;normal-mode&lt;/code&gt; interactively, the argument &lt;var&gt;find-file&lt;/var&gt; is normally &lt;code&gt;nil&lt;/code&gt;. In this case, &lt;code&gt;normal-mode&lt;/code&gt; unconditionally processes any file local variables.</source>
          <target state="translated">Если вы запускаете &lt;code&gt;normal-mode&lt;/code&gt; интерактивном режиме , аргумент &lt;var&gt;find-file&lt;/var&gt; обычно равен &lt;code&gt;nil&lt;/code&gt; . В этом случае в &lt;code&gt;normal-mode&lt;/code&gt; безоговорочно обрабатываются любые локальные переменные файла.</target>
        </trans-unit>
        <trans-unit id="69bd4b2952384a0a33ef5b0366f425ff27273401" translate="yes" xml:space="preserve">
          <source>If you run Emacs from the directory where it was built&amp;mdash;that is, an executable that has not been formally installed&amp;mdash;Emacs instead initializes &lt;code&gt;load-path&lt;/code&gt; using the</source>
          <target state="translated">Если вы запускаете Emacs из каталога, в котором он был собран, то есть из исполняемого файла, который не был официально установлен, Emacs вместо этого инициализирует &lt;code&gt;load-path&lt;/code&gt; используя</target>
        </trans-unit>
        <trans-unit id="33df89859e8bd5153172b40f655f9725c87eaa23" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;debug-on-event&lt;/code&gt; to a special event (see &lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;), Emacs will try to enter the debugger as soon as it receives this event, bypassing &lt;code&gt;special-event-map&lt;/code&gt;. At present, the only supported values correspond to the signals &lt;code&gt;SIGUSR1&lt;/code&gt; and &lt;code&gt;SIGUSR2&lt;/code&gt; (this is the default). This can be helpful when &lt;code&gt;inhibit-quit&lt;/code&gt; is set and Emacs is not otherwise responding.</source>
          <target state="translated">Если вы установите для &lt;code&gt;debug-on-event&lt;/code&gt; особое событие (см. &lt;a href=&quot;special-events#Special-Events&quot;&gt;Специальные события&lt;/a&gt; ), Emacs попытается войти в отладчик, как только получит это событие, минуя &lt;code&gt;special-event-map&lt;/code&gt; . В настоящее время единственные поддерживаемые значения соответствуют сигналам &lt;code&gt;SIGUSR1&lt;/code&gt; и &lt;code&gt;SIGUSR2&lt;/code&gt; (это значение по умолчанию). Это может быть полезно, когда установлен параметр &amp;laquo; &lt;code&gt;inhibit-quit&lt;/code&gt; а Emacs не отвечает иначе.</target>
        </trans-unit>
        <trans-unit id="9c694c02ac2532f5fe2abe237714159362002a21" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression, Emacs will enter the debugger if it displays a matching message in the echo area. For example, this can be useful when trying to find the cause of a particular message.</source>
          <target state="translated">Если вы установите для параметра &lt;code&gt;debug-on-message&lt;/code&gt; регулярное выражение, Emacs войдет в отладчик, если он отобразит соответствующее сообщение в эхо-области. Например, это может быть полезно при попытке найти причину того или иного сообщения.</target>
        </trans-unit>
        <trans-unit id="690f685efae0cb9f9d5902d7605b6ee4e66d6dce" translate="yes" xml:space="preserve">
          <source>If you set this hook locally in a buffer, it is assumed to be associated with the file or the way the contents of the buffer were obtained. Thus the variable is marked as a permanent local, so that changing the major mode does not alter a buffer-local value. On the other hand, calling &lt;code&gt;set-visited-file-name&lt;/code&gt; will reset it. If this is not what you want, you might like to use &lt;code&gt;write-contents-functions&lt;/code&gt; instead.</source>
          <target state="translated">Если вы устанавливаете эту ловушку локально в буфере, предполагается, что она связана с файлом или способом получения содержимого буфера. Таким образом, переменная помечается как постоянная локальная, так что изменение основного режима не приводит к изменению локального значения буфера. С другой стороны, вызов &lt;code&gt;set-visited-file-name&lt;/code&gt; сбросит его. Если это не то, что вы хотите, вы можете вместо этого использовать функции &lt;code&gt;write-contents-functions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfc7987161a9303dafc2b33573d2e5f10008802a" translate="yes" xml:space="preserve">
          <source>If you set this variable to &lt;code&gt;nil&lt;/code&gt; in a buffer, that buffer does not have a mode line. (A window that is just one line tall also does not display a mode line.)</source>
          <target state="translated">Если вы установите для этой переменной значение &lt;code&gt;nil&lt;/code&gt; в буфере, этот буфер не будет иметь строки режима. (Окно высотой всего в одну строку также не отображает строку режима.)</target>
        </trans-unit>
        <trans-unit id="9d66da1552d51dd81ff05a3b900a0329bf52436f" translate="yes" xml:space="preserve">
          <source>If you set this variable to a non-&lt;code&gt;nil&lt;/code&gt; value, the feature of moving point out of these sequences is completely turned off.</source>
          <target state="translated">Если вы установите для этой переменной значение, отличное от &lt;code&gt;nil&lt;/code&gt; , функция перемещения точки из этих последовательностей полностью отключится.</target>
        </trans-unit>
        <trans-unit id="ca8a3595d33e58a00ada25426e1b2f96b61be780" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;initial&lt;/var&gt;, that is an initial file name to insert in the buffer (after &lt;var&gt;directory&lt;/var&gt;, if that is inserted). In this case, point goes at the beginning of &lt;var&gt;initial&lt;/var&gt;. The default for &lt;var&gt;initial&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;&amp;mdash;don&amp;rsquo;t insert any file name. To see what &lt;var&gt;initial&lt;/var&gt; does, try the command</source>
          <target state="translated">Если вы указываете &lt;var&gt;initial&lt;/var&gt; , это начальное имя файла для вставки в буфер (после &lt;var&gt;directory&lt;/var&gt; , если он вставлен). В этом случае точка ставится в начале &lt;var&gt;initial&lt;/var&gt; . По умолчанию &lt;var&gt;initial&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; - имя файла не вставляется. Чтобы узнать, что делает &lt;var&gt;initial&lt;/var&gt; , попробуйте команду</target>
        </trans-unit>
        <trans-unit id="5c87b5e9500f1aecb01a1e2b9e8cf60f70697916" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;prompt&lt;/var&gt;, that becomes the overall prompt string for the keymap. You should specify this only for menu keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;). A keymap with an overall prompt string will always present a mouse menu or a keyboard menu if it is active for looking up the next input event. Don&amp;rsquo;t specify an overall prompt string for the main map of a major or minor mode, because that would cause the command loop to present a keyboard menu every time.</source>
          <target state="translated">Если вы укажете &lt;var&gt;prompt&lt;/var&gt; , она станет общей строкой подсказки для раскладки клавиатуры. Вы должны указать это только для раскладок меню (см. &amp;laquo; &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Определение меню&amp;raquo;&lt;/a&gt; ). Раскладка клавиатуры с общей строкой подсказки всегда будет представлять меню мыши или меню клавиатуры, если она активна для поиска следующего события ввода. Не указывайте общую строку приглашения для основной карты основного или второстепенного режима, потому что это заставит цикл команд каждый раз отображать меню клавиатуры.</target>
        </trans-unit>
        <trans-unit id="5edea50f7657db34bc2bc85d01daa7f7adc96609" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;uid&lt;/var&gt; (a number), the result is the user name that corresponds to &lt;var&gt;uid&lt;/var&gt;, or &lt;code&gt;nil&lt;/code&gt; if there is no such user.</source>
          <target state="translated">Если вы укажете &lt;var&gt;uid&lt;/var&gt; (число), результатом будет имя пользователя, соответствующее &lt;var&gt;uid&lt;/var&gt; , или &lt;code&gt;nil&lt;/code&gt; , если такого пользователя нет.</target>
        </trans-unit>
        <trans-unit id="f97e6393b96bab93a2f54c0164447ab04caf4a1b" translate="yes" xml:space="preserve">
          <source>If you specify a buffer, &lt;var&gt;buffer&lt;/var&gt;, then the value is the size of &lt;var&gt;buffer&lt;/var&gt;.</source>
          <target state="translated">Если вы укажете буфер, &lt;var&gt;buffer&lt;/var&gt; , тогда значением будет размер &lt;var&gt;buffer&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f505374ea489ecb94c5a8340e207775e38c3e1b5" translate="yes" xml:space="preserve">
          <source>If you specify a number for &lt;var&gt;limit&lt;/var&gt;, then after chasing through that many links, the function just returns what it has even if that is still a symbolic link.</source>
          <target state="translated">Если вы укажете число для &lt;var&gt;limit&lt;/var&gt; , то после прохождения этого количества ссылок функция просто вернет то, что у нее есть, даже если это все еще символическая ссылка.</target>
        </trans-unit>
        <trans-unit id="375bd3746fef25d0232e18d73f21e041e0753b43" translate="yes" xml:space="preserve">
          <source>If you specify an XBM image using data within Emacs instead of an external file, use the following three properties:</source>
          <target state="translated">Если вы указываете XBM-изображение,используя данные внутри Emacs вместо внешнего файла,используйте следующие три свойства:</target>
        </trans-unit>
        <trans-unit id="fde2a383a2451f6ddbde3c6482877a98961e5cf2" translate="yes" xml:space="preserve">
          <source>If you specify the frame name explicitly when you create the frame, the name is also used (instead of the name of the Emacs executable) when looking up X resources for the frame.</source>
          <target state="translated">Если вы указываете имя фрейма явно при создании фрейма,то это имя также используется (вместо имени исполняемого файла Emacs)при поиске X ресурсов для фрейма.</target>
        </trans-unit>
        <trans-unit id="f6ca207d06cc2c68a4c2828df92b77209025123f" translate="yes" xml:space="preserve">
          <source>If you specify the same slot on the same side for two or more different buffers, the buffer displayed last is shown in the corresponding window. Hence, slots can be used for sharing the same side window between buffers.</source>
          <target state="translated">Если вы укажете один и тот же слот на одной и той же стороне для двух и более различных буферов,буфер,отображаемый последним,будет показан в соответствующем окне.Следовательно,слоты могут быть использованы для разделения одного бокового окна между буферами.</target>
        </trans-unit>
        <trans-unit id="05d28610a19e0f56bd2c76d43cd9274215e3fa7d" translate="yes" xml:space="preserve">
          <source>If you specify this keyword, the variable&amp;rsquo;s documentation string should describe how to do the same job in hand-written Lisp code.</source>
          <target state="translated">Если вы укажете это ключевое слово, строка документации переменной должна описывать, как выполнить ту же работу в написанном от руки коде Lisp.</target>
        </trans-unit>
        <trans-unit id="716618ddbeabe19866aadf7f17b67b04057ebcef" translate="yes" xml:space="preserve">
          <source>If you store a completion alist in a variable, you should mark the variable as risky by giving it a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;risky-local-variable&lt;/code&gt; property. See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;.</source>
          <target state="translated">Если вы храните список завершения в переменной, вы должны пометить эту переменную как опасную, присвоив ей свойство, отличное от &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;risky-local-variable&lt;/code&gt; . См. Раздел &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;Локальные переменные файла&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40a77c6103e436345187dd30831cc5254ef479b8" translate="yes" xml:space="preserve">
          <source>If you try this, you will notice that repeated attempts to display</source>
          <target state="translated">Если вы попробуете это сделать,вы заметите,что повторяющиеся попытки отображения</target>
        </trans-unit>
        <trans-unit id="6a67eecb62315ce39f790ce6ffad7fa4e38d4eb8" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;buffer-swap-text&lt;/code&gt; on a file-visiting buffer, you should set up a hook to save the buffer&amp;rsquo;s original text rather than what it was swapped with. &lt;code&gt;write-region-annotate-functions&lt;/code&gt; works for this purpose. You should probably set &lt;code&gt;buffer-saved-size&lt;/code&gt; to -2 in the buffer, so that changes in the text it is swapped with will not interfere with auto-saving.</source>
          <target state="translated">Если вы используете &lt;code&gt;buffer-swap-text&lt;/code&gt; в буфере обращения к файлу, вы должны настроить ловушку для сохранения исходного текста буфера, а не того, с чем он был заменен. &lt;code&gt;write-region-annotate-functions&lt;/code&gt; работает для этой цели. Вам, вероятно, следует установить в &lt;code&gt;buffer-saved-size&lt;/code&gt; равным -2, чтобы изменения в тексте, которым он заменяется, не мешали автосохранению.</target>
        </trans-unit>
        <trans-unit id="d6907391755fb47bb50b18a1d24adc63588140ea" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;regexp-opt&lt;/code&gt; to produce the regular expression &lt;var&gt;matcher&lt;/var&gt;, you can use &lt;code&gt;regexp-opt-depth&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) to calculate the value for &lt;var&gt;subexp&lt;/var&gt;.</source>
          <target state="translated">Если вы используете &lt;code&gt;regexp-opt&lt;/code&gt; для создания &lt;var&gt;matcher&lt;/var&gt; регулярных выражений , вы можете использовать &lt;code&gt;regexp-opt-depth&lt;/code&gt; (см. &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Функции Regexp&lt;/a&gt; ) для вычисления значения для &lt;var&gt;subexp&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fd48732c105c46f30a8758370472e5d61da524f5" translate="yes" xml:space="preserve">
          <source>If you use a minibuffer-only frame, you might want that frame to raise when you enter the minibuffer. If so, set the variable &lt;code&gt;minibuffer-auto-raise&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Raising and Lowering&lt;/a&gt;.</source>
          <target state="translated">Если вы используете фрейм только для минибуфера, вы можете захотеть, чтобы этот фрейм поднимался при входе в минибуфер. Если это так, установите для переменной &lt;code&gt;minibuffer-auto-raise&lt;/code&gt; значение &lt;code&gt;t&lt;/code&gt; . См. &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Подъем и опускание&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa0c1227e66ae4b44f79049d6018702a84803396" translate="yes" xml:space="preserve">
          <source>If you use any Unicode-style escape sequence &amp;lsquo;</source>
          <target state="translated">Если вы используете любую escape-последовательность в стиле Unicode '</target>
        </trans-unit>
        <trans-unit id="0b2b537fa713937b15520eb5e6b8621ddcd5294c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;define-derived-mode&lt;/code&gt; macro, it will take care of many of these conventions automatically. See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;. Note also that Fundamental mode is an exception to many of these conventions, because it represents the default state of Emacs.</source>
          <target state="translated">Если вы используете макрос &lt;code&gt;define-derived-mode&lt;/code&gt; , он автоматически позаботится о многих из этих соглашений. См. &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Производные режимы&lt;/a&gt; . Также обратите внимание, что режим Fundamental является исключением из многих из этих соглашений, поскольку он представляет состояние Emacs по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ebbd02981d2d6e160b2592d755148aa81cf87d75" translate="yes" xml:space="preserve">
          <source>If you use this command in a different window displaying the same buffer, that window will be used instead to display the current definition in the future.</source>
          <target state="translated">Если вы используете эту команду в другом окне,отображающем один и тот же буфер,то в будущем это окно будет использоваться для отображения текущего определения.</target>
        </trans-unit>
        <trans-unit id="afdbef8990f56e48b4ad3c9668d8bcdb3999729f" translate="yes" xml:space="preserve">
          <source>If you use this for a type that appears as an alternative inside of &lt;code&gt;choice&lt;/code&gt;; it specifies the default value to use, at first, if and when the user selects this alternative with the menu in the customization buffer.</source>
          <target state="translated">Если вы используете это для типа, который появляется в качестве альтернативы внутри &lt;code&gt;choice&lt;/code&gt; ; он определяет значение по умолчанию, которое будет использоваться сначала, если и когда пользователь выберет эту альтернативу в меню в буфере настройки.</target>
        </trans-unit>
        <trans-unit id="629ad44964d5895c3d594065b4e7da091b6bb932" translate="yes" xml:space="preserve">
          <source>If you use this keyword more than once, you can put a single item into more than one group. Displaying any of those groups will show this item. Please don&amp;rsquo;t overdo this, since the result would be annoying.</source>
          <target state="translated">Если вы используете это ключевое слово более одного раза, вы можете поместить один элемент в несколько групп. Отображение любой из этих групп покажет этот элемент. Пожалуйста, не переусердствуйте, иначе результат будет раздражающим.</target>
        </trans-unit>
        <trans-unit id="49e3ca07657354c28816ff97da5c7582b8256ace" translate="yes" xml:space="preserve">
          <source>If you want a menu bar submenu to have contents that vary, you should still use a menu keymap to implement it. To make the contents vary, add a hook function to &lt;code&gt;menu-bar-update-hook&lt;/code&gt; to update the contents of the menu keymap as necessary.</source>
          <target state="translated">Если вы хотите, чтобы подменю строки меню содержало разное содержимое, вы все равно должны использовать раскладку меню для его реализации. Чтобы содержимое изменялось, добавьте функцию перехвата в &lt;code&gt;menu-bar-update-hook&lt;/code&gt; для обновления содержимого раскладки меню по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="3be39a84378c1d3ff63b94f456da0a9da8540136" translate="yes" xml:space="preserve">
          <source>If you want code to be executed when a &lt;em&gt;particular&lt;/em&gt; library is loaded, use the macro &lt;code&gt;with-eval-after-load&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите, чтобы код выполнялся при загрузке &lt;em&gt;определенной&lt;/em&gt; библиотеки, используйте макрос &lt;code&gt;with-eval-after-load&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c9e263b344abbe33fc08169dcaf2cad9b660996f" translate="yes" xml:space="preserve">
          <source>If you want to be able to debug errors that are caught by a &lt;code&gt;condition-case&lt;/code&gt;, set the variable &lt;code&gt;debug-on-signal&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. You can also specify that a particular handler should let the debugger run first, by writing &lt;code&gt;debug&lt;/code&gt; among the conditions, like this:</source>
          <target state="translated">Если вы хотите иметь возможность отлаживать ошибки, которые обнаруживаются в &lt;code&gt;condition-case&lt;/code&gt; , установите для переменной &lt;code&gt;debug-on-signal&lt;/code&gt; значение, отличное от &lt;code&gt;nil&lt;/code&gt; . Вы также можете указать, что конкретный обработчик должен разрешить запуск отладчику первым, написав &lt;code&gt;debug&lt;/code&gt; среди условий, например:</target>
        </trans-unit>
        <trans-unit id="59bdec6558d0121a21861b3648de710d60579fcc" translate="yes" xml:space="preserve">
          <source>If you want to be able to distinguish all possible values computed by &lt;var&gt;body&lt;/var&gt; from both kinds of abort conditions, write the code like this:</source>
          <target state="translated">Если вы хотите иметь возможность отличать все возможные значения, вычисленные &lt;var&gt;body&lt;/var&gt; от обоих типов условий прерывания, напишите такой код:</target>
        </trans-unit>
        <trans-unit id="c7c6338ea698e54cbd61c931fd1eb115534a9075" translate="yes" xml:space="preserve">
          <source>If you want to change the way Emacs handles drop of different types or add a new type, customize &lt;code&gt;x-dnd-types-alist&lt;/code&gt;. This requires detailed knowledge of what types other applications use for drag and drop.</source>
          <target state="translated">Если вы хотите изменить способ обработки Emacs сброса различных типов или добавить новый тип, настройте &lt;code&gt;x-dnd-types-alist&lt;/code&gt; . Для этого требуется детальное знание того, какие типы других приложений используют для перетаскивания.</target>
        </trans-unit>
        <trans-unit id="9962c78c83f1c13605cf8ba722facf4943be5aa3" translate="yes" xml:space="preserve">
          <source>If you want to define &lt;code&gt;safe-local-variable&lt;/code&gt; properties for variables defined in C source code, add the names and the properties of those variables to the list in the &amp;ldquo;Safe local variables&amp;rdquo; section of</source>
          <target state="translated">Если вы хотите определить свойства &lt;code&gt;safe-local-variable&lt;/code&gt; для переменных, определенных в исходном коде C, добавьте имена и свойства этих переменных в список в разделе &amp;laquo;Безопасные локальные переменные&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="a63fb633f610fcf7b569e1e58f5a8bedb9ec6204" translate="yes" xml:space="preserve">
          <source>If you want to delete elements that are &lt;code&gt;equal&lt;/code&gt; to a given value, use &lt;code&gt;delete&lt;/code&gt; (see below).</source>
          <target state="translated">Если вы хотите удалить элементы, &lt;code&gt;equal&lt;/code&gt; заданному значению, используйте &lt;code&gt;delete&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="a770c467b911a60af82d90717d058d45481ec026" translate="yes" xml:space="preserve">
          <source>If you want to find all matches for a regexp in part of the buffer, and replace them, the best way is to write an explicit loop using &lt;code&gt;re-search-forward&lt;/code&gt; and &lt;code&gt;replace-match&lt;/code&gt;, like this:</source>
          <target state="translated">Если вы хотите найти все совпадения для регулярного выражения в части буфера и заменить их, лучший способ - написать явный цикл с использованием &lt;code&gt;re-search-forward&lt;/code&gt; и &lt;code&gt;replace-match&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="e07043ea04e2ff5e4af20b9e5042e3dbc7fb1ab7" translate="yes" xml:space="preserve">
          <source>If you want to increment the variable, you must use &lt;code&gt;setq&lt;/code&gt;, like this:</source>
          <target state="translated">Если вы хотите увеличить переменную, вы должны использовать &lt;code&gt;setq&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="c38bee5b246e44204c9311862ab52b37815b5e96" translate="yes" xml:space="preserve">
          <source>If you want to make a Lisp variable that is defined in C behave like one declared with &lt;code&gt;defcustom&lt;/code&gt;, add an appropriate entry to</source>
          <target state="translated">Если вы хотите, чтобы переменная Lisp, определенная в C, &lt;code&gt;defcustom&lt;/code&gt; себя как переменная, объявленная с помощью defcustom , добавьте соответствующую запись в</target>
        </trans-unit>
        <trans-unit id="c89381f0269c1ad13f9db33500586f3038ca5d1c" translate="yes" xml:space="preserve">
          <source>If you want to make the new mode the default for files with certain recognizable names, add an element to &lt;code&gt;auto-mode-alist&lt;/code&gt; to select the mode for those file names (see &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;). If you define the mode command to autoload, you should add this element in the same file that calls &lt;code&gt;autoload&lt;/code&gt;. If you use an autoload cookie for the mode command, you can also use an autoload cookie for the form that adds the element (see &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;). If you do not autoload the mode command, it is sufficient to add the element in the file that contains the mode definition.</source>
          <target state="translated">Если вы хотите сделать новый режим по умолчанию для файлов с определенными узнаваемыми именами, добавьте элемент в &lt;code&gt;auto-mode-alist&lt;/code&gt; , чтобы выбрать режим для этих имен файлов (см. &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Автоматический основной режим&lt;/a&gt; ). Если вы определяете команду режима для автозагрузки, вы должны добавить этот элемент в тот же файл, который вызывает &lt;code&gt;autoload&lt;/code&gt; . Если вы используете cookie автозагрузки для команды режима, вы также можете использовать cookie автозагрузки для формы, которая добавляет элемент (см. &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;Cookie автозагрузки&lt;/a&gt; ). Если вы не загружаете команду режима автоматически, достаточно добавить элемент в файл, содержащий определение режима.</target>
        </trans-unit>
        <trans-unit id="b6bd9286bc367e97ce4540abf13e066ac7ad9d72" translate="yes" xml:space="preserve">
          <source>If you want to pass a file name to another process so that another program can read the file, use the function &lt;code&gt;file-local-copy&lt;/code&gt;; see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите передать имя файла другому процессу, чтобы другая программа могла его прочитать, используйте функцию &lt;code&gt;file-local-copy&lt;/code&gt; ; см. &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Волшебные имена файлов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="252c3f2a6736d1faced75b5183751f3b39035b6e" translate="yes" xml:space="preserve">
          <source>If you want to preload function or variable definitions, there are three ways you can do this and make their documentation strings accessible when you subsequently run Emacs:</source>
          <target state="translated">Если вы хотите предварительно загрузить определения функций или переменных,есть три способа сделать это и сделать их документацию доступной при последующем запуске Emacs:</target>
        </trans-unit>
        <trans-unit id="2cee666fd30a296699a4e8f28dd2fdfe14c7228f" translate="yes" xml:space="preserve">
          <source>If you want to specify group members through &lt;var&gt;members&lt;/var&gt;, each element should have the form &lt;code&gt;(&lt;var&gt;name&lt;/var&gt; &lt;var&gt;widget&lt;/var&gt;)&lt;/code&gt;. Here &lt;var&gt;name&lt;/var&gt; is a symbol, and &lt;var&gt;widget&lt;/var&gt; is a widget type for editing that symbol. Useful widgets are &lt;code&gt;custom-variable&lt;/code&gt; for a variable, &lt;code&gt;custom-face&lt;/code&gt; for a face, and &lt;code&gt;custom-group&lt;/code&gt; for a group.</source>
          <target state="translated">Если вы хотите указать членов группы через &lt;var&gt;members&lt;/var&gt; , каждый элемент должен иметь форму &lt;code&gt;(&lt;var&gt;name&lt;/var&gt; &lt;var&gt;widget&lt;/var&gt;)&lt;/code&gt; . Здесь &lt;var&gt;name&lt;/var&gt; - это символ, а &lt;var&gt;widget&lt;/var&gt; - это тип виджета для редактирования этого символа. Полезные виджеты - это &lt;code&gt;custom-variable&lt;/code&gt; для переменной, &lt;code&gt;custom-face&lt;/code&gt; для лица и &lt;code&gt;custom-group&lt;/code&gt; для группы.</target>
        </trans-unit>
        <trans-unit id="8e10bdc9c026c4aa399e4b42ba23f64d06212059" translate="yes" xml:space="preserve">
          <source>If you want to take action as soon as a button is pressed, you need to handle &lt;em&gt;button-down&lt;/em&gt; events.&lt;a href=&quot;#FOOT13&quot; name=&quot;DOCF13&quot;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt; These occur as soon as a button is pressed. They are represented by lists that look exactly like click events (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), except that the &lt;var&gt;event-type&lt;/var&gt; symbol name contains the prefix &amp;lsquo;</source>
          <target state="translated">Если вы хотите предпринять действия сразу после нажатия кнопки, вам необходимо обработать события &lt;em&gt;нажатия кнопки&lt;/em&gt; . &lt;a href=&quot;#FOOT13&quot; name=&quot;DOCF13&quot;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt; Это происходит при нажатии кнопки. Они представлены списками, которые выглядят точно так же, как события щелчка (см. &lt;a href=&quot;click-events#Click-Events&quot;&gt;События щелчка&lt;/a&gt; ), за исключением того, что имя символа &lt;var&gt;event-type&lt;/var&gt; содержит префикс '</target>
        </trans-unit>
        <trans-unit id="1a0489351d0c73d72b0fca1ef67e3467436c6466" translate="yes" xml:space="preserve">
          <source>If you want to use a directory file name in making such a combination, you must first convert it to a directory name using &lt;code&gt;file-name-as-directory&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите использовать имя файла каталога при создании такой комбинации, вы должны сначала преобразовать его в имя каталога с помощью &lt;code&gt;file-name-as-directory&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="27743c56b5d0dd9981b65d5ea4209829501380cb" translate="yes" xml:space="preserve">
          <source>If you want to use this function in an Emacs that was already dumped, you must run Emacs with the &amp;lsquo;</source>
          <target state="translated">Если вы хотите использовать эту функцию в Emacs, который уже был выгружен, вы должны запустить Emacs с '</target>
        </trans-unit>
        <trans-unit id="9bff8e6a47b35cd45f5d8552d3e143fb633c4b1c" translate="yes" xml:space="preserve">
          <source>If you want to write a command along the lines of &lt;code&gt;query-replace&lt;/code&gt;, you can use &lt;code&gt;perform-replace&lt;/code&gt; to do the work.</source>
          <target state="translated">Если вы хотите написать команду в духе &lt;code&gt;query-replace&lt;/code&gt; , вы можете использовать &lt;code&gt;perform-replace&lt;/code&gt; для выполнения этой работы.</target>
        </trans-unit>
        <trans-unit id="353f48c9646e1a608529d6b8bd599dd5f82d0944" translate="yes" xml:space="preserve">
          <source>If you want to write a temporary file which is likely to be small, you should compute the directory like this:</source>
          <target state="translated">Если вы хотите записать временный файл,который,скорее всего,будет небольшим,вы должны вычислить директорию таким образом:</target>
        </trans-unit>
        <trans-unit id="1def4c97f647247a5c5ff48230af3b2e0d31bcc6" translate="yes" xml:space="preserve">
          <source>If you want your program to handle different types differently, you must do explicit type checking. The most common way to check the type of an object is to call a &lt;em&gt;type predicate&lt;/em&gt; function. Emacs has a type predicate for each type, as well as some predicates for combinations of types.</source>
          <target state="translated">Если вы хотите, чтобы ваша программа по-разному обрабатывала разные типы, вы должны выполнить явную проверку типов. Самый распространенный способ проверить тип объекта - вызвать функцию &lt;em&gt;предиката типа&lt;/em&gt; . Emacs имеет предикат типа для каждого типа, а также некоторые предикаты для комбинаций типов.</target>
        </trans-unit>
        <trans-unit id="7f232d7dc078880a275acb49812461edd0ce860d" translate="yes" xml:space="preserve">
          <source>If you wanted to attach the same replace menu to a mouse click, you can do it this way:</source>
          <target state="translated">Если вы хотите прикрепить к щелчку мыши такое же меню замены,вы можете сделать это таким образом:</target>
        </trans-unit>
        <trans-unit id="28b8c0ff1e6b7f40141852b8f78ad49d083249f7" translate="yes" xml:space="preserve">
          <source>If you wish to add text properties to a buffer or remove them without marking the buffer as modified, you can wrap the calls above in the &lt;code&gt;with-silent-modifications&lt;/code&gt; macro. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите добавить текстовые свойства в буфер или удалить их, не отмечая буфер как измененный, вы можете заключить приведенные выше вызовы в макрос &lt;code&gt;with-silent-modifications&lt;/code&gt; -izations. См. &amp;laquo; &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Модификация буфера&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9314fb2dc1ec806dadc29d80680d276f22ec3691" translate="yes" xml:space="preserve">
          <source>If you wish to verify the conformance of a module to the Emacs dynamic module</source>
          <target state="translated">Если вы хотите проверить соответствие модуля динамическому модулю Emacs</target>
        </trans-unit>
        <trans-unit id="ca331c2a227354c196a20ee4c8b853bb299d3e61" translate="yes" xml:space="preserve">
          <source>If you wish, you can replace the &lt;code&gt;ask-user-about-lock&lt;/code&gt; function with your own version that makes the decision in another way.</source>
          <target state="translated">При желании вы можете заменить функцию &lt;code&gt;ask-user-about-lock&lt;/code&gt; своей собственной версией, которая принимает решение другим способом.</target>
        </trans-unit>
        <trans-unit id="4d662283da0f2958a60954e2e27370bba9903a41" translate="yes" xml:space="preserve">
          <source>If you would like to see Edebug&amp;rsquo;s functions in the backtrace, use</source>
          <target state="translated">Если вы хотите видеть функции Edebug в трассировке, используйте</target>
        </trans-unit>
        <trans-unit id="0e7b1af4801797b08feab3ca25fd99f927f534a2" translate="yes" xml:space="preserve">
          <source>If you write a function definition with an unusual macro that is not one of the known and recognized function definition methods, use of an ordinary magic autoload comment would copy the whole definition into &lt;code&gt;loaddefs.el&lt;/code&gt;. That is not desirable. You can put the desired &lt;code&gt;autoload&lt;/code&gt; call into &lt;code&gt;loaddefs.el&lt;/code&gt; instead by writing this:</source>
          <target state="translated">Если вы пишете определение функции с необычным макросом, который не является одним из известных и признанных методов определения функции, использование обычного магического комментария автозагрузки скопирует все определение в &lt;code&gt;loaddefs.el&lt;/code&gt; . Это не желательно. &lt;code&gt;loaddefs.el&lt;/code&gt; этого вы можете поместить желаемый вызов &lt;code&gt;autoload&lt;/code&gt; в loaddefs.el , написав следующее:</target>
        </trans-unit>
        <trans-unit id="d233d041f222a6f0703355568126be43236fb134" translate="yes" xml:space="preserve">
          <source>If you write your own function to be put on the &lt;code&gt;tooltip-functions&lt;/code&gt; list, you may need to know the buffer of the mouse event that triggered the tooltip display. The following function provides that information.</source>
          <target state="translated">Если вы пишете свою собственную функцию для включения в список &lt;code&gt;tooltip-functions&lt;/code&gt; , вам может потребоваться знать буфер события мыши, вызвавшего отображение всплывающей подсказки. Эту информацию предоставляет следующая функция.</target>
        </trans-unit>
        <trans-unit id="5f651282e9deb511f780af54aec3d7ab9890404b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up an asynchronous TLS connection, you have to also provide the &lt;code&gt;:tls-parameters&lt;/code&gt; parameter (see below).</source>
          <target state="translated">Если вы настраиваете асинхронное соединение TLS, вам также необходимо предоставить параметр &lt;code&gt;:tls-parameters&lt;/code&gt; parameters (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="d70f5aea9c1d350e01a6eceee76a9e7dbb533230" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using another package, but only need macros from it (the byte compiler will expand those), then &lt;code&gt;eval-when-compile&lt;/code&gt; can be used to load it for compiling, but not executing. For example,</source>
          <target state="translated">Если вы используете другой пакет, но вам нужны только макросы из него (байтовый компилятор расширит их), то &lt;code&gt;eval-when-compile&lt;/code&gt; можно использовать для загрузки его для компиляции, но не для выполнения. Например,</target>
        </trans-unit>
        <trans-unit id="2d45e994d3ba3dcb17fc10bf4fc110fdce2e5f3f" translate="yes" xml:space="preserve">
          <source>If your Emacs Lisp program needs to assign some faces to text, it is often a good idea to use certain existing faces or inherit from them, rather than defining entirely new faces. This way, if other users have customized the basic faces to give Emacs a certain look, your program will fit in without additional customization.</source>
          <target state="translated">Если вашей программе Emacs Lisp необходимо присвоить несколько граней тексту,то часто лучше использовать определённые существующие грани или наследовать от них,чем определять совершенно новые грани.Таким образом,если другие пользователи настроили основные лица для придания Emacs определённого вида,ваша программа подойдёт без дополнительных настроек.</target>
        </trans-unit>
        <trans-unit id="5c8bded4be6d6694860d7eb8600eff32119af59a" translate="yes" xml:space="preserve">
          <source>If your Emacs build has ImageMagick support, you can use the ImageMagick library to load many image formats (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Conveniences.html#File-Conveniences&quot;&gt;File Conveniences&lt;/a&gt; in</source>
          <target state="translated">Если ваша сборка Emacs поддерживает ImageMagick, вы можете использовать библиотеку ImageMagick для загрузки многих форматов изображений (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Conveniences.html#File-Conveniences&quot;&gt;Удобства работы с файлами&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="f78ce0d464d2e4a15ac9486269bdbf51a6d4123b" translate="yes" xml:space="preserve">
          <source>If your Emacs build has ImageMagick support, you can use the ImageMagick library to load many image formats (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/File-Conveniences.html#File-Conveniences&quot;&gt;File Conveniences&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79aae3290a46dbcf7b36398be7497460dba8720d" translate="yes" xml:space="preserve">
          <source>If your Lisp program needs to make layout decisions, you will find the following function useful:</source>
          <target state="translated">Если вашей программе на языке Lisp необходимо принять решение о компоновке,то вам будет полезна следующая функция:</target>
        </trans-unit>
        <trans-unit id="5fc6e331da7d896db05ebf47e4b7c4b10ed997b9" translate="yes" xml:space="preserve">
          <source>If your function happens to read input, a character you type intending to interrupt execution may be read by the function instead. You can avoid such unintended results by paying attention to when your program wants input.</source>
          <target state="translated">Если ваша функция случайно прочитает ввод,то вместо него может быть прочитан символ,который вы вводите,намереваясь прервать выполнение.Вы можете избежать таких непреднамеренных результатов,обратив внимание на то,когда Ваша программа хочет ввести данные.</target>
        </trans-unit>
        <trans-unit id="1ba170033e789539342f30492cc68db1c80633aa" translate="yes" xml:space="preserve">
          <source>If your mode fontifies text explicitly by adding &lt;code&gt;font-lock-face&lt;/code&gt; properties, it can specify &lt;code&gt;(nil t)&lt;/code&gt; for &lt;code&gt;font-lock-defaults&lt;/code&gt; to turn off all automatic fontification. However, this is not required; it is possible to fontify some things using &lt;code&gt;font-lock-face&lt;/code&gt; properties and set up automatic fontification for other parts of the text.</source>
          <target state="translated">Если ваш режим явно выделяет текст, добавляя свойства &lt;code&gt;font-lock-face&lt;/code&gt; , он может указать &lt;code&gt;(nil t)&lt;/code&gt; для &lt;code&gt;font-lock-defaults&lt;/code&gt; , чтобы отключить автоматическое фонирование. Однако этого не требуется; можно фонировать некоторые вещи с помощью свойств &lt;code&gt;font-lock-face&lt;/code&gt; и настроить автоматическое фонирование для других частей текста.</target>
        </trans-unit>
        <trans-unit id="6c52d9cb365da1adebc29d4657b8bbaede4dc551" translate="yes" xml:space="preserve">
          <source>If your module includes potentially long-running code, it is a good idea to check from time to time in that code whether the user wants to quit, e.g., by typing</source>
          <target state="translated">Если ваш модуль включает в себя потенциально долгосрочный код,то полезно время от времени проверять в этом коде,не хочет ли пользователь выйти из модуля,например,набрав</target>
        </trans-unit>
        <trans-unit id="89267be88e244d3cd9cb4a0ac81d5a54135d6b2b" translate="yes" xml:space="preserve">
          <source>If your monitor displays colors too light, you should specify a &lt;code&gt;screen-gamma&lt;/code&gt; value smaller than 2.2. This requests correction that makes colors darker. A screen gamma value of 1.5 may give good results for LCD color displays.</source>
          <target state="translated">Если ваш монитор отображает слишком светлые цвета, вам следует указать значение &lt;code&gt;screen-gamma&lt;/code&gt; меньше 2,2. Это требует коррекции, которая делает цвета темнее. Значение гаммы экрана 1,5 может дать хорошие результаты для цветных ЖК-дисплеев.</target>
        </trans-unit>
        <trans-unit id="dd935a1aca6ebbfdcc9a67b41e3b53df100359c7" translate="yes" xml:space="preserve">
          <source>If your package uses a fixed file name, how to handle various operating systems simply.</source>
          <target state="translated">Если ваш пакет использует фиксированное имя файла,то как работать с различными операционными системами просто.</target>
        </trans-unit>
        <trans-unit id="1193689cd9a0ac4f92f059d1dc0a2088ab488de5" translate="yes" xml:space="preserve">
          <source>If your program is working correctly, but not fast enough, and you want to make it run more quickly or efficiently, the first thing to do is &lt;em&gt;profile&lt;/em&gt; your code so that you know where it spends most of the execution time. If you find that one particular function is responsible for a significant portion of the execution time, you can start looking for ways to optimize that piece.</source>
          <target state="translated">Если ваша программа работает правильно, но недостаточно быстро, и вы хотите, чтобы она выполнялась быстрее или эффективнее, первое, что нужно сделать, - это &lt;em&gt;профилировать&lt;/em&gt; свой код, чтобы вы знали, на что он тратит большую часть времени выполнения. Если вы обнаружите, что одна конкретная функция отвечает за значительную часть времени выполнения, вы можете начать искать способы оптимизации этой части.</target>
        </trans-unit>
        <trans-unit id="b1e042424d49662dae08a1bf6462ad5f5721c1d9" translate="yes" xml:space="preserve">
          <source>If your system does not support a locale environment, this function behaves like &lt;code&gt;string-equal&lt;/code&gt;.</source>
          <target state="translated">Если ваша система не поддерживает среду локали, эта функция ведет себя как &lt;code&gt;string-equal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b2ec9e1ced6426f29862d927943724a180f4f37" translate="yes" xml:space="preserve">
          <source>If your system does not support a locale environment, this function behaves like &lt;code&gt;string-lessp&lt;/code&gt;.</source>
          <target state="translated">Если ваша система не поддерживает среду локали, эта функция ведет себя как &lt;code&gt;string-lessp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2a7f8c74638fa05ec98f6bc846b8e0afbd1dcfa" translate="yes" xml:space="preserve">
          <source>If, as a consequence of this variable&amp;rsquo;s setting, &lt;code&gt;split-window&lt;/code&gt; makes a new parent window, it also calls &lt;code&gt;set-window-combination-limit&lt;/code&gt; (see below) on the newly-created internal window. This affects how the window tree is rearranged when the child windows are deleted (see below).</source>
          <target state="translated">Если, как следствие установки этой переменной, &lt;code&gt;split-window&lt;/code&gt; создает новое родительское окно, он также вызывает &lt;code&gt;set-window-combination-limit&lt;/code&gt; (см. Ниже) для вновь созданного внутреннего окна. Это влияет на то, как дерево окон перестраивается при удалении дочерних окон (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="451b00a18210e489817e33a2f75ab13a9719ab44" translate="yes" xml:space="preserve">
          <source>If, for instance, you have a function with the following signature:</source>
          <target state="translated">Если,например,у вас есть функция со следующей подписью:</target>
        </trans-unit>
        <trans-unit id="2abf7c3ec223f2095009c55b2f242e5df196b064" translate="yes" xml:space="preserve">
          <source>If, in the configuration shown at the beginning of this section, the combination limit of &lt;var&gt;W4&lt;/var&gt; (the parent window of &lt;var&gt;W6&lt;/var&gt; and &lt;var&gt;W7&lt;/var&gt;) is &lt;code&gt;t&lt;/code&gt;, deleting &lt;var&gt;W5&lt;/var&gt; will not implicitly delete &lt;var&gt;W4&lt;/var&gt; too.</source>
          <target state="translated">Если в конфигурации, показанной в начале этого раздела, предел комбинации &lt;var&gt;W4&lt;/var&gt; (родительского окна &lt;var&gt;W6&lt;/var&gt; и &lt;var&gt;W7&lt;/var&gt; ) равен &lt;code&gt;t&lt;/code&gt; , удаление &lt;var&gt;W5&lt;/var&gt; не приведет к неявному удалению и &lt;var&gt;W4&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="78ffec08f0afea5009a9e4f31e999a7aef7bb8b2" translate="yes" xml:space="preserve">
          <source>Illustrates regular expression syntax.</source>
          <target state="translated">Иллюстрирует синтаксис регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="6d6a2e3a1d75ffca319bbe002e550450309d7c59" translate="yes" xml:space="preserve">
          <source>Image Cache</source>
          <target state="translated">Кэш изображений</target>
        </trans-unit>
        <trans-unit id="48b5c8b5116be341240880cddc06c139bf112214" translate="yes" xml:space="preserve">
          <source>Image Descriptors</source>
          <target state="translated">Описатели изображений</target>
        </trans-unit>
        <trans-unit id="c8f6654a5156a1080fb81d03686a08b3810bb836" translate="yes" xml:space="preserve">
          <source>Image Formats</source>
          <target state="translated">форматы изображений</target>
        </trans-unit>
        <trans-unit id="aeaae8093342d2fd0a43876f35175087f3fc1c56" translate="yes" xml:space="preserve">
          <source>Image rotation is supported by &lt;var&gt;frame&lt;/var&gt; if the rotation angle is an integral multiple of 90 degrees.</source>
          <target state="translated">Поворот изображения поддерживается &lt;var&gt;frame&lt;/var&gt; если угол поворота кратен 90 градусам.</target>
        </trans-unit>
        <trans-unit id="22a44b07be718b7665f80244ca7dfeffb2cef34a" translate="yes" xml:space="preserve">
          <source>Image scaling is supported by &lt;var&gt;frame&lt;/var&gt; via the &lt;code&gt;:scale&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:max-width&lt;/code&gt;, and &lt;code&gt;:max-height&lt;/code&gt; properties.</source>
          <target state="translated">Масштабирование изображения поддерживается &lt;var&gt;frame&lt;/var&gt; через &lt;code&gt;:scale&lt;/code&gt; , &lt;code&gt;:width&lt;/code&gt; , &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:max-width&lt;/code&gt; , и &lt;code&gt;:max-height&lt;/code&gt; свойства.</target>
        </trans-unit>
        <trans-unit id="1d1d6e296cb1c073ca88d9a58e07068eb51b05b3" translate="yes" xml:space="preserve">
          <source>Image support on some platforms uses this facility. Here&amp;rsquo;s an example of setting this variable for supporting images on MS-Windows:</source>
          <target state="translated">Поддержка изображений на некоторых платформах использует эту возможность. Вот пример установки этой переменной для поддержки изображений в MS-Windows:</target>
        </trans-unit>
        <trans-unit id="ba6aa59bf89de0d7431e45a8f58836f3a0d84eff" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;gif&lt;/code&gt;. Supports the &lt;code&gt;:index&lt;/code&gt; property. See &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Multi-Frame Images&lt;/a&gt;.</source>
          <target state="translated">Тип изображения &lt;code&gt;gif&lt;/code&gt; . Поддерживает свойство &lt;code&gt;:index&lt;/code&gt; . См. &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Многокадровые изображения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6b807cfc6c4926cd04ef1e64755f11a7ed890ee" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;jpeg&lt;/code&gt;.</source>
          <target state="translated">Тип изображения &lt;code&gt;jpeg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bff299fe7917d8e01d672a807ac7ad596bd1fa0a" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;png&lt;/code&gt;.</source>
          <target state="translated">Тип изображения &lt;code&gt;png&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d259c4b3f9f796b005c99eb224c7f8328e811db" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;tiff&lt;/code&gt;. Supports the &lt;code&gt;:index&lt;/code&gt; property. See &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Multi-Frame Images&lt;/a&gt;.</source>
          <target state="translated">Тип изображения &lt;code&gt;tiff&lt;/code&gt; . Поддерживает свойство &lt;code&gt;:index&lt;/code&gt; . См. &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Многокадровые изображения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f82696e58684223314f34c1e138cf5a09eed1ec1" translate="yes" xml:space="preserve">
          <source>ImageMagick Images</source>
          <target state="translated">Изображения ImageMagick</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="b10522704faf5fb14671202d20d0113707920769" translate="yes" xml:space="preserve">
          <source>Images are automatically scaled when created based on the &lt;code&gt;image-scaling-factor&lt;/code&gt; variable. The value is either a floating point number (where numbers higher than 1 means to increase the size and lower means to shrink the size), or the symbol &lt;code&gt;auto&lt;/code&gt;, which will compute a scaling factor based on the font pixel size.</source>
          <target state="translated">Изображения автоматически масштабируются при создании на основе переменной &lt;code&gt;image-scaling-factor&lt;/code&gt; . Значение представляет собой либо число с плавающей запятой (где числа больше 1 означают увеличение размера, а меньшее - уменьшение размера), либо символ &lt;code&gt;auto&lt;/code&gt; , который вычисляет коэффициент масштабирования на основе размера пикселя шрифта.</target>
        </trans-unit>
        <trans-unit id="bffbf50340be5bd8849e7bdae58afca1242ae52f" translate="yes" xml:space="preserve">
          <source>Images inserted with the insertion functions above also get a local keymap installed in the text properties (or overlays) that span the displayed image. This keymap defines the following commands:</source>
          <target state="translated">Изображения,вставленные с помощью функций вставки выше,также получают локальную клавиатурную карту,установленную в текстовых свойствах (или наложениях),которые охватывают отображаемое изображение.Эта карта-манипулятор определяет следующие команды:</target>
        </trans-unit>
        <trans-unit id="2577d1937dba79f175ee8cc8dd563700f7a20a83" translate="yes" xml:space="preserve">
          <source>Images loaded with ImageMagick support the following additional image descriptor properties:</source>
          <target state="translated">Изображения,загруженные с помощью ImageMagick,поддерживают следующие дополнительные свойства дескрипторов изображений:</target>
        </trans-unit>
        <trans-unit id="ae0df5967aaeb367560d887978e6697e8445e507" translate="yes" xml:space="preserve">
          <source>Images, margins, text size, etc.</source>
          <target state="translated">Изображения,поля,размер текста и т.д.</target>
        </trans-unit>
        <trans-unit id="582d79238d4c996206b1d9fcda2bd858616fc5e0" translate="yes" xml:space="preserve">
          <source>Imenu</source>
          <target state="translated">Imenu</target>
        </trans-unit>
        <trans-unit id="9b3ebff6f4733ad352d5af8ef98a92252e56d9f9" translate="yes" xml:space="preserve">
          <source>Implementing a link involves three separate steps: (1) indicating clickability when the mouse moves over the link; (2) making</source>
          <target state="translated">Реализация связи включает в себя три отдельных этапа:(1)указание на щелчок,когда курсор мыши перемещается по ссылке;(2)создание</target>
        </trans-unit>
        <trans-unit id="ba709de5d7a6443728b0e7d903b67e7e463a3df8" translate="yes" xml:space="preserve">
          <source>Implied Frame Resizing</source>
          <target state="translated">Подразумеваемая резервация рамы</target>
        </trans-unit>
        <trans-unit id="6be920774eab706a9a6e9e109fe21af9fbbf76a5" translate="yes" xml:space="preserve">
          <source>Implied resizing of frames and how to prevent it.</source>
          <target state="translated">Подразумевается изменение размеров кадров и как это предотвратить.</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="8fe04c542be958393c3da42ee6384a7d0cac600e" translate="yes" xml:space="preserve">
          <source>In Adaptive Fill mode, this command calls &lt;code&gt;fill-context-prefix&lt;/code&gt; to choose a fill prefix by default. See &lt;a href=&quot;adaptive-fill#Adaptive-Fill&quot;&gt;Adaptive Fill&lt;/a&gt;.</source>
          <target state="translated">В режиме адаптивного &lt;code&gt;fill-context-prefix&lt;/code&gt; эта команда вызывает префикс-контекста заполнения, чтобы выбрать префикс заполнения по умолчанию. См. &lt;a href=&quot;adaptive-fill#Adaptive-Fill&quot;&gt;Адаптивная заливка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45a0c5d90449be73929ea5cf30f6e7c34dd2845f" translate="yes" xml:space="preserve">
          <source>In C the corresponding code uses &lt;code&gt;Fmake_variable_buffer_local&lt;/code&gt; in combination with &lt;code&gt;DEFSYM&lt;/code&gt;, i.e.</source>
          <target state="translated">В C соответствующий код использует &lt;code&gt;Fmake_variable_buffer_local&lt;/code&gt; в сочетании с &lt;code&gt;DEFSYM&lt;/code&gt; , т.е.</target>
        </trans-unit>
        <trans-unit id="e18ad52ed484e26dd1d95b7bed4a6e310f733e51" translate="yes" xml:space="preserve">
          <source>In C, the tagged pointer is an object of type &lt;code&gt;Lisp_Object&lt;/code&gt;. Any initialized variable of such a type always holds the value of one of the following basic data types: integer, symbol, string, cons cell, float, or vectorlike object. Each of these data types has the corresponding tag value. All tags are enumerated by &lt;code&gt;enum Lisp_Type&lt;/code&gt; and placed into a 3-bit bitfield of the &lt;code&gt;Lisp_Object&lt;/code&gt;. The rest of the bits is the value itself. Integers are immediate, i.e., directly represented by those &lt;em&gt;value bits&lt;/em&gt;, and all other objects are represented by the C pointers to a corresponding object allocated from the heap. Width of the &lt;code&gt;Lisp_Object&lt;/code&gt; is platform- and configuration-dependent: usually it&amp;rsquo;s equal to the width of an underlying platform pointer (i.e., 32-bit on a 32-bit machine and 64-bit on a 64-bit one), but also there is a special configuration where &lt;code&gt;Lisp_Object&lt;/code&gt; is 64-bit but all pointers are 32-bit. The latter trick was designed to overcome the limited range of values for Lisp integers on a 32-bit system by using 64-bit &lt;code&gt;long long&lt;/code&gt; type for &lt;code&gt;Lisp_Object&lt;/code&gt;.</source>
          <target state="translated">В C помеченный указатель - это объект типа &lt;code&gt;Lisp_Object&lt;/code&gt; . Любая инициализированная переменная такого типа всегда содержит значение одного из следующих основных типов данных: целое число, символ, строка, cons-ячейка, float или векторный объект. Каждый из этих типов данных имеет соответствующее значение тега. Все теги пронумерованы &lt;code&gt;enum Lisp_Type&lt;/code&gt; и помещены в 3-битное битовое поле &lt;code&gt;Lisp_Object&lt;/code&gt; . Остальные биты - это само значение. Целые числа являются немедленными, т. Е. Непосредственно представлены этими &lt;em&gt;битами значений&lt;/em&gt; , а все другие объекты представлены указателями C на соответствующий объект, выделенный из кучи. Ширина &lt;code&gt;Lisp_Object&lt;/code&gt; зависит от платформы и конфигурации: обычно он равен ширине указателя базовой платформы (т.е. 32-разрядный на 32-разрядной машине и 64-разрядный на 64-разрядной), но также существует специальная конфигурация где &lt;code&gt;Lisp_Object&lt;/code&gt; - 64-битный, но все указатели - 32-битные. Последний прием был разработан для преодоления ограниченного диапазона значений целых чисел Lisp в 32-битной системе с использованием 64-битного типа &lt;code&gt;long long&lt;/code&gt; для &lt;code&gt;Lisp_Object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74391ea991c057a25805bcc7f35913579f56dca9" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; are special symbols that always evaluate to themselves. This is so that you do not need to quote them to use them as constants in a program. An attempt to change their values results in a &lt;code&gt;setting-constant&lt;/code&gt; error. See &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;.</source>
          <target state="translated">В Emacs Lisp &lt;code&gt;nil&lt;/code&gt; и &lt;code&gt;t&lt;/code&gt; - специальные символы, которые всегда вычисляются сами по себе. Это сделано для того, чтобы вам не нужно было заключать их в кавычки, чтобы использовать их в качестве констант в программе. Попытка изменить их значения приводит к ошибке &lt;code&gt;setting-constant&lt;/code&gt; . См. &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Постоянные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ad4e15232bab0e5d73751f02a46989f735b0d79" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, an obarray is actually a vector. Each element of the vector is a bucket; its value is either an interned symbol whose name hashes to that bucket, or 0 if the bucket is empty. Each interned symbol has an internal link (invisible to the user) to the next symbol in the bucket. Because these links are invisible, there is no way to find all the symbols in an obarray except using &lt;code&gt;mapatoms&lt;/code&gt; (below). The order of symbols in a bucket is not significant.</source>
          <target state="translated">В Emacs Lisp obarray на самом деле является вектором. Каждый элемент вектора представляет собой ведро; его значение - либо интернированный символ, имя которого хешируется в эту корзину, либо 0, если корзина пуста. Каждый интернированный символ имеет внутреннюю ссылку (невидимую для пользователя) на следующий символ в корзине. Поскольку эти ссылки невидимы, невозможно найти все символы в массиве, кроме как с помощью &lt;code&gt;mapatoms&lt;/code&gt; (см. Ниже). Порядок символов в ведре не имеет значения.</target>
        </trans-unit>
        <trans-unit id="167a75f8cc60d70b238473b34e2d15e825f2b4a7" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, certain symbols normally evaluate to themselves. These include &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, as well as any symbol whose name starts with &amp;lsquo;</source>
          <target state="translated">В Emacs Lisp некоторые символы обычно оцениваются сами по себе. К ним относятся &lt;code&gt;nil&lt;/code&gt; и &lt;code&gt;t&lt;/code&gt; , а также любой символ, имя которого начинается с '</target>
        </trans-unit>
        <trans-unit id="d3d82148ca2384cc8ee1ed3664e9a838b9558bde" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, fonts are represented using three different Lisp object types: &lt;em&gt;font objects&lt;/em&gt;, &lt;em&gt;font specs&lt;/em&gt;, and &lt;em&gt;font entities&lt;/em&gt;.</source>
          <target state="translated">В Emacs Lisp, шрифты представлены с использованием трех различных Лиспа типов объектов: &lt;em&gt;объекты шрифтов&lt;/em&gt; , &lt;em&gt;шрифтов данные&lt;/em&gt; и &lt;em&gt;шрифтов Entities&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0c7667a4c5fb417ea75b3519174ba5e3b8596c" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, if two fixnums are numerically equal, they are the same Lisp object. That is, &lt;code&gt;eq&lt;/code&gt; is equivalent to &lt;code&gt;=&lt;/code&gt; on fixnums. It is sometimes convenient to use &lt;code&gt;eq&lt;/code&gt; for comparing an unknown value with a fixnum, because &lt;code&gt;eq&lt;/code&gt; does not report an error if the unknown value is not a number&amp;mdash;it accepts arguments of any type. By contrast, &lt;code&gt;=&lt;/code&gt; signals an error if the arguments are not numbers or markers. However, it is better programming practice to use &lt;code&gt;=&lt;/code&gt; if you can, even for comparing integers.</source>
          <target state="translated">В Emacs Lisp, если два фиксированных числа численно равны, они являются одним и тем же объектом Lisp. То есть &lt;code&gt;eq&lt;/code&gt; эквивалентно &lt;code&gt;=&lt;/code&gt; для фиксированных чисел. Иногда удобно использовать &lt;code&gt;eq&lt;/code&gt; для сравнения неизвестного значения с fixnum, потому что &lt;code&gt;eq&lt;/code&gt; не сообщает об ошибке, если неизвестное значение не является числом - он принимает аргументы любого типа. Напротив, &lt;code&gt;=&lt;/code&gt; сигнализирует об ошибке, если аргументы не являются числами или маркерами. Однако лучше использовать &lt;code&gt;=&lt;/code&gt; , если можно, даже для сравнения целых чисел.</target>
        </trans-unit>
        <trans-unit id="056b909cc3695df5e93a61166399585cdef0425e" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, it is &lt;em&gt;not&lt;/em&gt; an error if an element of an association list is not a cons cell. The alist search functions simply ignore such elements. Many other versions of Lisp signal errors in such cases.</source>
          <target state="translated">В Emacs Lisp это &lt;em&gt;не&lt;/em&gt; ошибка, если элемент списка ассоциаций не является cons-ячейкой. Функции поиска по списку просто игнорируют такие элементы. Многие другие версии Lisp сигнализируют об ошибках в таких случаях.</target>
        </trans-unit>
        <trans-unit id="0ba583440567b18d5b81ae15d30046dcd5919135" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, such a list is a valid expression which evaluates to a function object.</source>
          <target state="translated">В Emacs Lisp такой список является корректным выражением,которое вычисляется объекту функции.</target>
        </trans-unit>
        <trans-unit id="79e9cb90d8f1ed44a5daae3726bf1118952bd6eb" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, text characters are represented by integers. Any integer between zero and the value of &lt;code&gt;(max-char)&lt;/code&gt;, inclusive, is considered to be valid as a character. See &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;.</source>
          <target state="translated">В Emacs Lisp текстовые символы представлены целыми числами. Любое целое число от нуля до значения &lt;code&gt;(max-char)&lt;/code&gt; включительно считается допустимым в качестве символа. См. &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Коды символов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc557095ff4ddb838d7231fc59eb5902f756d5f5" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, the symbol &lt;code&gt;nil&lt;/code&gt; has three separate meanings: it is a symbol with the name &amp;lsquo;</source>
          <target state="translated">В Emacs Lisp символ &lt;code&gt;nil&lt;/code&gt; имеет три разных значения: это символ с именем '</target>
        </trans-unit>
        <trans-unit id="4bdd0ad62ddb48a82f579e9d7b8435a64c33dc3b" translate="yes" xml:space="preserve">
          <source>In Emacs&amp;rsquo;s current implementation, each graphical terminal possesses an image cache, which is shared by all the frames on that terminal (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;). Thus, refreshing an image in one frame also refreshes it in all other frames on the same terminal.</source>
          <target state="translated">В текущей реализации Emacs каждый графический терминал имеет кэш изображений, который используется всеми фреймами на этом терминале (см. &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Несколько терминалов&lt;/a&gt; ). Таким образом, обновление изображения в одном кадре также обновляет его во всех других кадрах на том же терминале.</target>
        </trans-unit>
        <trans-unit id="2cfd6914c188d4937ed552a12d7ad4fd0e04dbfb" translate="yes" xml:space="preserve">
          <source>In Emacs, each property has a name, which is a symbol, and a set of possible values, whose types depend on the property; if a character does not have a certain property, the value is &lt;code&gt;nil&lt;/code&gt;. As a general rule, the names of character properties in Emacs are produced from the corresponding Unicode properties by downcasing them and replacing each &amp;lsquo;</source>
          <target state="translated">В Emacs каждое свойство имеет имя, которое является символом, и набор возможных значений, типы которых зависят от свойства; если у персонажа нет определенного свойства, значение равно &lt;code&gt;nil&lt;/code&gt; . Как правило, имена свойств символов в Emacs создаются из соответствующих свойств Unicode путем их перевода в нижний регистр и замены каждого символа '</target>
        </trans-unit>
        <trans-unit id="30d7d9e3884c83ac05ed06549fc0bda540ce471f" translate="yes" xml:space="preserve">
          <source>In Emacs, processing user input takes priority over redisplay. If you call these functions when input is available, they don&amp;rsquo;t redisplay immediately, but the requested redisplay does happen eventually&amp;mdash;after all the input has been processed.</source>
          <target state="translated">В Emacs обработка пользовательского ввода имеет приоритет над повторным отображением. Если вы вызываете эти функции, когда ввод доступен, они не воспроизводятся немедленно, но запрошенное повторное отображение в конечном итоге происходит - после того, как весь ввод был обработан.</target>
        </trans-unit>
        <trans-unit id="495b0af8742c1362f3b43e3c05d5f67cbd311b61" translate="yes" xml:space="preserve">
          <source>In GNU Emacs, you can search for the next match for a regular expression (see &lt;a href=&quot;syntax-of-regexps#Syntax-of-Regexps&quot;&gt;Syntax of Regexps&lt;/a&gt;) either incrementally or not. For incremental search commands, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search&quot;&gt;Regular Expression Search&lt;/a&gt; in</source>
          <target state="translated">В GNU Emacs вы можете искать следующее совпадение для регулярного выражения (см. &lt;a href=&quot;syntax-of-regexps#Syntax-of-Regexps&quot;&gt;Синтаксис&lt;/a&gt; регулярных выражений ) либо постепенно, либо нет. Информацию о командах инкрементального поиска см. В разделе &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search&quot;&gt;Поиск&lt;/a&gt; по регулярным выражениям в</target>
        </trans-unit>
        <trans-unit id="be6e3549a4078150b879793b52cb93ecd65e1abb" translate="yes" xml:space="preserve">
          <source>In GNU Emacs, you can search for the next match for a regular expression (see &lt;a href=&quot;syntax-of-regexps#Syntax-of-Regexps&quot;&gt;Syntax of Regexps&lt;/a&gt;) either incrementally or not. For incremental search commands, see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search&quot;&gt;Regular Expression Search&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6bf702e875e738b66a4d81962fcc97a8fc8a9b" translate="yes" xml:space="preserve">
          <source>In Lisp symbols sometimes need to be quoted, to achieve the same effect in C you again use the corresponding constant symbol &lt;code&gt;Qmy_lisp_variable&lt;/code&gt;. For example, when creating a buffer-local variable (see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;) in Lisp you would write:</source>
          <target state="translated">В Лиспе символы иногда нужно заключать в кавычки, чтобы добиться того же эффекта в Си, вы снова используете соответствующий постоянный символ &lt;code&gt;Qmy_lisp_variable&lt;/code&gt; . Например, при создании локальной переменной в буфере (см. &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Локальные переменные&lt;/a&gt; в буфере ) в Лиспе вы должны написать:</target>
        </trans-unit>
        <trans-unit id="1a54f569b2a1104466db435e6a994296e8a10203" translate="yes" xml:space="preserve">
          <source>In POSIX, locales control which language to use in language-related features. These Emacs variables control how Emacs interacts with these features.</source>
          <target state="translated">В POSIX локали контролируют,какой язык использовать в функциях,связанных с языком.Эти переменные Emacs управляют тем,как Emacs взаимодействует с этими функциями.</target>
        </trans-unit>
        <trans-unit id="cb60a2c08b3d7d91de1154d61b87b4cbb7d768d9" translate="yes" xml:space="preserve">
          <source>In a Lisp program, if you want to look at the contents of a file but not alter it, the fastest way is to use &lt;code&gt;insert-file-contents&lt;/code&gt; in a temporary buffer. Visiting the file is not necessary and takes longer. See &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;.</source>
          <target state="translated">В программе на Лиспе, если вы хотите просматривать содержимое файла, но не изменять его, самый быстрый способ - использовать &lt;code&gt;insert-file-contents&lt;/code&gt; во временном буфере. Посещение файла не требуется и занимает больше времени. См. &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Чтение из файлов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1edf8916db656c7d77716fc20e2c864d77eff0a1" translate="yes" xml:space="preserve">
          <source>In a backtrace you can specify a stack frame by moving point to a line describing that frame. The frame whose line point is on is considered the &lt;em&gt;current frame&lt;/em&gt;.</source>
          <target state="translated">В обратной трассировке вы можете указать кадр стека, переместив точку на строку, описывающую этот кадр. Кадр, на линии которого стоит точка, считается &lt;em&gt;текущим кадром&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d321617bc2957edda9f7299aaed744d6b62dfa9f" translate="yes" xml:space="preserve">
          <source>In a buffer, the buffer-local value of the variable &lt;code&gt;enable-multibyte-characters&lt;/code&gt; specifies the representation used. The representation for a string is determined and recorded in the string when the string is constructed.</source>
          <target state="translated">В буфере локальное в буфере значение переменной &lt;code&gt;enable-multibyte-characters&lt;/code&gt; определяет используемое представление. Представление строки определяется и записывается в строке при построении строки.</target>
        </trans-unit>
        <trans-unit id="d5b3c2f60eb9de03c344c19458f75ded0f988032" translate="yes" xml:space="preserve">
          <source>In a computer, an integer is represented as a binary number, a sequence of &lt;em&gt;bits&lt;/em&gt; (digits which are either zero or one). Conceptually the bit sequence is infinite on the left, with the most-significant bits being all zeros or all ones. A bitwise operation acts on the individual bits of such a sequence. For example, &lt;em&gt;shifting&lt;/em&gt; moves the whole sequence left or right one or more places, reproducing the same pattern moved over.</source>
          <target state="translated">В компьютере целое число представляется как двоичное число, последовательность &lt;em&gt;битов&lt;/em&gt; (цифр, равных нулю или единице). Концептуально последовательность битов слева бесконечна, причем самые старшие биты - это все нули или все единицы. Поразрядная операция воздействует на отдельные биты такой последовательности. Например, &lt;em&gt;сдвиг&lt;/em&gt; перемещает всю последовательность влево или вправо на одно или несколько мест, воспроизводя один и тот же перемещенный узор.</target>
        </trans-unit>
        <trans-unit id="fb58dc1bd5b5a462384b2bd580dc601ea418376c" translate="yes" xml:space="preserve">
          <source>In a connection, the address in internal format of the remote peer.</source>
          <target state="translated">При подключении,адрес во внутреннем формате удаленного пэра.</target>
        </trans-unit>
        <trans-unit id="937afbfd1c954fb42bb11db790d91eaf0406154d" translate="yes" xml:space="preserve">
          <source>In a customization of &lt;code&gt;display-buffer-alist&lt;/code&gt; it would be used as follows:</source>
          <target state="translated">При настройке &lt;code&gt;display-buffer-alist&lt;/code&gt; он будет использоваться следующим образом:</target>
        </trans-unit>
        <trans-unit id="02df984c3529f76c9a4015001b01d209da05e6aa" translate="yes" xml:space="preserve">
          <source>In a function definition (a &lt;code&gt;lambda&lt;/code&gt; or &lt;code&gt;defun&lt;/code&gt; form), the documentation string is specified after the argument list, and is normally stored directly in the function object. See &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;. You can also put function documentation in the &lt;code&gt;function-documentation&lt;/code&gt; property of a function name (see &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;Accessing Documentation&lt;/a&gt;).</source>
          <target state="translated">В определении функции ( &lt;code&gt;lambda&lt;/code&gt; форма или форма &lt;code&gt;defun&lt;/code&gt; ) строка документации указывается после списка аргументов и обычно сохраняется непосредственно в объекте функции. См. &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Документацию по функциям&lt;/a&gt; . Вы также можете поместить документацию по &lt;code&gt;function-documentation&lt;/code&gt; свойство документации по функциям имени функции (см. &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;Доступ к документации&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9eea6a2ed4dafd38340b45092920794b871b7be2" translate="yes" xml:space="preserve">
          <source>In a function description, the name of the function being described appears first. It is followed on the same line by a list of argument names. These names are also used in the body of the description, to stand for the values of the arguments.</source>
          <target state="translated">В описании функции сначала появляется название описываемой функции.За ним в той же строке следует список имен аргументов.Эти имена также используются в теле описания,чтобы обозначить значения аргументов.</target>
        </trans-unit>
        <trans-unit id="f265fc98d3924e1abaf704d23613cfbac37962c6" translate="yes" xml:space="preserve">
          <source>In a general sense, a function is a rule for carrying out a computation given input values called &lt;em&gt;arguments&lt;/em&gt;. The result of the computation is called the &lt;em&gt;value&lt;/em&gt; or &lt;em&gt;return value&lt;/em&gt; of the function. The computation can also have side effects, such as lasting changes in the values of variables or the contents of data structures (see &lt;a href=&quot;intro-eval#Definition-of-side-effect&quot;&gt;Definition of side effect&lt;/a&gt;). A &lt;em&gt;pure function&lt;/em&gt; is a function which, in addition to having no side effects, always returns the same value for the same combination of arguments, regardless of external factors such as machine type or system state.</source>
          <target state="translated">В общем смысле функция - это правило для выполнения вычисления при заданных входных значениях, называемых &lt;em&gt;аргументами&lt;/em&gt; . Результат вычисления называется &lt;em&gt;значением&lt;/em&gt; или &lt;em&gt;возвращаемым значением&lt;/em&gt; функции. Вычисление также может иметь побочные эффекты, такие как длительные изменения значений переменных или содержимого структур данных (см. &lt;a href=&quot;intro-eval#Definition-of-side-effect&quot;&gt;Определение побочного эффекта&lt;/a&gt; ). &lt;em&gt;Чистая функция&lt;/em&gt; является функцией , которая, в дополнение к не имеющей каких - либо побочных эффектов, всегда возвращает то же значение для одной и той же комбинации аргументов, независимо от внешних факторов , таких как тип машины или состояния системы.</target>
        </trans-unit>
        <trans-unit id="96c3f228f301c5161e3eb0673e109763dc8f02e1" translate="yes" xml:space="preserve">
          <source>In a major mode for editing some kind of structured text, such as a programming language, indentation of text according to structure is probably useful. So the mode should set &lt;code&gt;indent-line-function&lt;/code&gt; to a suitable function, and probably customize other variables for indentation. See &lt;a href=&quot;auto_002dindentation#Auto_002dIndentation&quot;&gt;Auto-Indentation&lt;/a&gt;.</source>
          <target state="translated">В основном режиме для редактирования какого-либо структурированного текста, такого как язык программирования, возможно, будет полезен отступ текста в соответствии со структурой. Таким образом, режим должен установить &lt;code&gt;indent-line-function&lt;/code&gt; на подходящую функцию и, возможно, настроить другие переменные для отступа. См. &lt;a href=&quot;auto_002dindentation#Auto_002dIndentation&quot;&gt;Автоотступ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1010cadba3e3eb9ca7bca39cbf0064b7fa6a1d87" translate="yes" xml:space="preserve">
          <source>In a package that can be preloaded, it is sometimes necessary (or useful) to delay certain evaluations until Emacs subsequently starts up. The vast majority of such cases relate to the values of customizable variables. For example, &lt;code&gt;tutorial-directory&lt;/code&gt; is a variable defined in</source>
          <target state="translated">В пакете, который может быть предварительно загружен, иногда необходимо (или полезно) отложить выполнение определенных вычислений до последующего запуска Emacs. Подавляющее большинство таких случаев связано со значениями настраиваемых переменных. Например, &lt;code&gt;tutorial-directory&lt;/code&gt; - это переменная, определенная в</target>
        </trans-unit>
        <trans-unit id="0c9ab0563187085f470a4162ca64c920ef8f3780" translate="yes" xml:space="preserve">
          <source>In a server, if you specified &lt;code&gt;t&lt;/code&gt; for &lt;var&gt;service&lt;/var&gt;, this value is the actual port number.</source>
          <target state="translated">На сервере, если вы указали &lt;code&gt;t&lt;/code&gt; для &lt;var&gt;service&lt;/var&gt; , это значение будет фактическим номером порта.</target>
        </trans-unit>
        <trans-unit id="38330f228367727c246a23aacc922e71762f491b" translate="yes" xml:space="preserve">
          <source>In a string, the 2**7 bit attached to an</source>
          <target state="translated">В строке,2**7 бит,прикрепленный к</target>
        </trans-unit>
        <trans-unit id="cb764f5b1cd69acb27303028c22d0c8d6831d1ea" translate="yes" xml:space="preserve">
          <source>In a variable definition (a &lt;code&gt;defvar&lt;/code&gt; form), the documentation string is specified after the initial value. See &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;. The string is stored in the variable&amp;rsquo;s &lt;code&gt;variable-documentation&lt;/code&gt; property.</source>
          <target state="translated">В определении переменной ( форма &lt;code&gt;defvar&lt;/code&gt; ) строка документации указывается после начального значения. См. &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Определение переменных&lt;/a&gt; . Строка хранится в свойстве &lt;code&gt;variable-documentation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="529ec901908473f00f0f48571f9c0e29f851ad5f" translate="yes" xml:space="preserve">
          <source>In addition an optional &lt;var&gt;coding-system&lt;/var&gt; can be specified if needed.</source>
          <target state="translated">Кроме того, при необходимости может быть указана дополнительная система &lt;var&gt;coding-system&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="525f83380ee1265a6947c7040c2a3e7d21c25884" translate="yes" xml:space="preserve">
          <source>In addition to accessing and manipulating processes that are subprocesses of the current Emacs session, Emacs Lisp programs can also access other processes running on the same machine. We call these &lt;em&gt;system processes&lt;/em&gt;, to distinguish them from Emacs subprocesses.</source>
          <target state="translated">Помимо доступа к процессам, которые являются подпроцессами текущего сеанса Emacs, и управления ими, программы Emacs Lisp могут также обращаться к другим процессам, запущенным на той же машине. Мы называем эти &lt;em&gt;системные процессы&lt;/em&gt; , чтобы отличить их от подпроцессов Emacs.</target>
        </trans-unit>
        <trans-unit id="7bdb7f13163d532b7e614f0668a6458aa5f29adb" translate="yes" xml:space="preserve">
          <source>In addition to its parents, the error symbol has a &lt;var&gt;message&lt;/var&gt; which is a string to be printed when that error is signaled but not handled. If that message is not valid, the error message &amp;lsquo;</source>
          <target state="translated">В дополнение к своим родительским символам, у символа ошибки есть &lt;var&gt;message&lt;/var&gt; которое представляет собой строку, которая должна быть напечатана, когда об ошибке сообщается, но не обрабатывается. Если это сообщение недействительно, появится сообщение об ошибке '</target>
        </trans-unit>
        <trans-unit id="c353f4ffe1e4f69045cda4cc05340d97bd69840b" translate="yes" xml:space="preserve">
          <source>In addition to operating on files themselves, Emacs Lisp programs often need to operate on file names; i.e., to take them apart and to use part of a name to construct related file names. This section describes how to manipulate file names.</source>
          <target state="translated">Помимо работы с самими файлами,программам Emacs Lisp часто приходится работать с именами файлов,т.е.разбирать их на части и использовать часть имени для построения связанных имён файлов.В этом разделе описывается,как манипулировать именами файлов.</target>
        </trans-unit>
        <trans-unit id="387b3f59848f82250f4a8ce567df30121ef1d27b" translate="yes" xml:space="preserve">
          <source>In addition to processes that run programs, Lisp programs can open connections of several types to devices or processes running on the same machine or on other machines. The supported connection types are: TCP and UDP network connections, serial port connections, and pipe connections. Each such connection is also represented by a process object.</source>
          <target state="translated">В дополнение к процессам,выполняющим программы,программы на языке Lisp могут открывать соединения нескольких типов с устройствами или процессами,запущенными на одной машине или на других машинах.Поддерживаются следующие типы соединений:Сетевые соединения TCP и UDP,соединения через последовательный порт и трубные соединения.Каждое такое соединение также представлено объектом процесса.</target>
        </trans-unit>
        <trans-unit id="3c5b86e3b4354c4c1fa9c08ccbf5b49528a15320" translate="yes" xml:space="preserve">
          <source>In addition to specifying a single codepoint, &lt;var&gt;character&lt;/var&gt; may be a cons &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are character codepoints. In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters in the range &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; (inclusive).</source>
          <target state="translated">Помимо указания единственной кодовой точки, &lt;var&gt;character&lt;/var&gt; может быть минусом &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;from&lt;/var&gt; и &lt;var&gt;to&lt;/var&gt; - это кодовые точки символа. В этом случае используйте &lt;var&gt;font-spec&lt;/var&gt; для всех символов в диапазоне &lt;var&gt;from&lt;/var&gt; и &lt;var&gt;to&lt;/var&gt; (включительно).</target>
        </trans-unit>
        <trans-unit id="41d3cfcccd9ef5616b8769d3619cf8d518b74e63" translate="yes" xml:space="preserve">
          <source>In addition to subprocesses of the current Emacs session, you can also access other processes running on your machine. See &lt;a href=&quot;system-processes#System-Processes&quot;&gt;System Processes&lt;/a&gt;.</source>
          <target state="translated">Помимо подпроцессов текущего сеанса Emacs, вы также можете получить доступ к другим процессам, запущенным на вашем компьютере. См. &lt;a href=&quot;system-processes#System-Processes&quot;&gt;Системные процессы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7064fdb6b5bca7cd74df3a9cfd9570247d7d390" translate="yes" xml:space="preserve">
          <source>In addition to the above, 24 additional compositions of &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are defined as &lt;code&gt;c&lt;var&gt;xxx&lt;/var&gt;r&lt;/code&gt; and &lt;code&gt;c&lt;var&gt;xxxx&lt;/var&gt;r&lt;/code&gt;, where each &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; is either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;cadr&lt;/code&gt;, &lt;code&gt;caddr&lt;/code&gt;, and &lt;code&gt;cadddr&lt;/code&gt; pick out the second, third or fourth elements of a list, respectively.</source>
          <target state="translated">В дополнение к вышесказанному, 24 дополнительных состава &lt;code&gt;car&lt;/code&gt; и &lt;code&gt;cdr&lt;/code&gt; определены как &lt;code&gt;c&lt;var&gt;xxx&lt;/var&gt;r&lt;/code&gt; и &lt;code&gt;c&lt;var&gt;xxxx&lt;/var&gt;r&lt;/code&gt; , где каждый &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; является либо &lt;code&gt;a&lt;/code&gt; , либо &lt;code&gt;d&lt;/code&gt; . &lt;code&gt;cadr&lt;/code&gt; , &lt;code&gt;caddr&lt;/code&gt; и &lt;code&gt;cadddr&lt;/code&gt; выбирают второй, третий или четвертый элементы списка соответственно.</target>
        </trans-unit>
        <trans-unit id="5ea747ccb6525f229be3767e03769ebe3fd13bdb" translate="yes" xml:space="preserve">
          <source>In addition to the classes, entries for characters in a syntax table can specify flags. There are eight possible flags, represented by the characters &amp;lsquo;</source>
          <target state="translated">Помимо классов записи для символов в таблице синтаксиса могут указывать флаги. Есть восемь возможных флагов, представленных символами '</target>
        </trans-unit>
        <trans-unit id="fa8b8b78067e8a2d0074c7fc569ed6a4aef4b677" translate="yes" xml:space="preserve">
          <source>In addition to the common keywords (see &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;), you can also use this keyword in &lt;code&gt;defgroup&lt;/code&gt;:</source>
          <target state="translated">В дополнение к общим ключевым словам (см. &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Общие ключевые слова&lt;/a&gt; ) вы также можете использовать это ключевое слово в &lt;code&gt;defgroup&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="29283b097ca518b11209ca1cc5e62af08088092e" translate="yes" xml:space="preserve">
          <source>In addition to the fundamental buffer list just described, Emacs maintains a local buffer list for each frame, in which the buffers that have been displayed (or had their windows selected) in that frame come first. (This order is recorded in the frame&amp;rsquo;s &lt;code&gt;buffer-list&lt;/code&gt; frame parameter; see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;.) Buffers never displayed in that frame come afterward, ordered according to the fundamental buffer list.</source>
          <target state="translated">В дополнение к только что описанному фундаментальному списку буферов Emacs поддерживает список локальных буферов для каждого кадра, в котором буферы, которые были отображены (или были выбраны их окна) в этом кадре, идут первыми. (Этот порядок записывается в параметре кадра &lt;code&gt;buffer-list&lt;/code&gt; ; см. &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Параметры буфера&lt;/a&gt; .) Буферы, никогда не отображаемые в этом кадре, поступают позже, упорядоченные в соответствии с основным списком буферов.</target>
        </trans-unit>
        <trans-unit id="70589b40fe71188d55af613ff5caa55411dd7c27" translate="yes" xml:space="preserve">
          <source>In addition to the keywords listed in &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;, this macro accepts the following keywords:</source>
          <target state="translated">В дополнение к ключевым словам, перечисленным в &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Общих&lt;/a&gt; ключевых словах , этот макрос принимает следующие ключевые слова:</target>
        </trans-unit>
        <trans-unit id="14751632f3fa92d651d6de24660d939a484e328f" translate="yes" xml:space="preserve">
          <source>In addition to the mark, each buffer has a &lt;em&gt;mark ring&lt;/em&gt; which is a list of markers containing previous values of the mark. When editing commands change the mark, they should normally save the old value of the mark on the mark ring. The variable &lt;code&gt;mark-ring-max&lt;/code&gt; specifies the maximum number of entries in the mark ring; once the list becomes this long, adding a new element deletes the last element.</source>
          <target state="translated">В дополнение к метке каждый буфер имеет &lt;em&gt;кольцо меток,&lt;/em&gt; которое представляет собой список маркеров, содержащих предыдущие значения метки. Когда команды редактирования изменяют метку, они обычно должны сохранять старое значение метки в кольце меток. Переменная &lt;code&gt;mark-ring-max&lt;/code&gt; определяет максимальное количество записей в кольце отметок; как только список становится таким длинным, добавление нового элемента удаляет последний элемент.</target>
        </trans-unit>
        <trans-unit id="c174d1d04f5ead445f6e0ecd4196859599f8b7e5" translate="yes" xml:space="preserve">
          <source>In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-</source>
          <target state="translated">В дополнение к специальным экранирующим последовательностям для специальных важных управляющих символов,Emacs предоставляет несколько типов синтаксиса экранирования,которые вы можете использовать для указания не-</target>
        </trans-unit>
        <trans-unit id="806eb0827f5ad53c91dfa2917aa1276e03487d08" translate="yes" xml:space="preserve">
          <source>In addition to the stack, byte-code functions can use, bind, and set ordinary Lisp variables, by transferring values between variables and the stack.</source>
          <target state="translated">Кроме стека,байт-кодовые функции могут использовать,связывать и устанавливать обычные переменные Lisp,передавая значения между переменными и стеком.</target>
        </trans-unit>
        <trans-unit id="e8fb33822f9f0ddadebc4c17ae82c36a969b63dc" translate="yes" xml:space="preserve">
          <source>In addition to the usual &lt;code&gt;rx&lt;/code&gt; syntax, &lt;var&gt;rx-expr&lt;/var&gt;&amp;hellip; can contain the following constructs:</source>
          <target state="translated">В дополнение к обычному синтаксису &lt;code&gt;rx&lt;/code&gt; , &lt;var&gt;rx-expr&lt;/var&gt; &amp;hellip; может содержать следующие конструкции:</target>
        </trans-unit>
        <trans-unit id="861619441bdc3073f9cfaef71fbacdcaa751184b" translate="yes" xml:space="preserve">
          <source>In addition, Emacs defines the following common mathematical constants:</source>
          <target state="translated">Кроме того,Emacs определяет следующие общие математические константы:</target>
        </trans-unit>
        <trans-unit id="a618d5cb4304df670c9f4fb6aed2d8570eaa1d4d" translate="yes" xml:space="preserve">
          <source>In addition, a module can verify the compatibility of the module</source>
          <target state="translated">Кроме того,модуль может проверять совместимость модуля</target>
        </trans-unit>
        <trans-unit id="6138054406fb00c76442b8e0e427c64e19964717" translate="yes" xml:space="preserve">
          <source>In addition, certain &lt;em&gt;magic&lt;/em&gt; file names are handled specially. For example, when a remote file name is specified, Emacs accesses the file over the network via an appropriate protocol. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">Кроме того, определенные &lt;em&gt;магические&lt;/em&gt; имена файлов обрабатываются особым образом. Например, когда указано имя удаленного файла, Emacs обращается к файлу по сети через соответствующий протокол. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Удаленные файлы&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="9c9ccb769098431e98fe5fa4365599cac43c3c52" translate="yes" xml:space="preserve">
          <source>In addition, certain &lt;em&gt;magic&lt;/em&gt; file names are handled specially. For example, when a remote file name is specified, Emacs accesses the file over the network via an appropriate protocol. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a5c4503f8397d7e06f3cb0730d58989841f459" translate="yes" xml:space="preserve">
          <source>In addition, each window maintains a list of &lt;em&gt;next buffers&lt;/em&gt;, which is a list of buffers re-shown by &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (see below). This list is mainly used by &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; for choosing buffers to switch to.</source>
          <target state="translated">Кроме того, каждое окно поддерживает список &lt;em&gt;следующих буферов&lt;/em&gt; , который представляет собой список буферов, повторно отображаемых &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (см. Ниже). Этот список в основном используется командами &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; и &lt;code&gt;switch-to-next-buffer&lt;/code&gt; для выбора буферов для переключения.</target>
        </trans-unit>
        <trans-unit id="40fe5e071e4d8814ba46d10ce4d3d2ba5eb89d1b" translate="yes" xml:space="preserve">
          <source>In addition, it doesn&amp;rsquo;t alter a line if &lt;var&gt;nochange-regexp&lt;/var&gt; matches at the beginning of the line (if &lt;var&gt;nochange-regexp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">Кроме того, он не изменяет строку, если &lt;var&gt;nochange-regexp&lt;/var&gt; совпадает с началом строки (если &lt;var&gt;nochange-regexp&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="634b56dedb74cfcfcc2b4c23398c78b873b18883" translate="yes" xml:space="preserve">
          <source>In addition, modes for buffers of tabulated data can inherit from Tabulated List mode, which is in turn derived from Special mode. See &lt;a href=&quot;tabulated-list-mode#Tabulated-List-Mode&quot;&gt;Tabulated List Mode&lt;/a&gt;.</source>
          <target state="translated">Кроме того, режимы для буферов табличных данных могут наследовать от режима табличного списка, который, в свою очередь, является производным от специального режима. См. &lt;a href=&quot;tabulated-list-mode#Tabulated-List-Mode&quot;&gt;Режим табличного списка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8458f97247e5805c182989af41d45c53eb115262" translate="yes" xml:space="preserve">
          <source>In addition, several major mode conventions (see &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;) apply to minor modes as well: those regarding the names of global symbols, the use of a hook at the end of the initialization function, and the use of keymaps and other tables.</source>
          <target state="translated">Кроме того, к второстепенным режимам применимы несколько соглашений об основных режимах (см. &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Соглашения о&lt;/a&gt; главных режимах): те, которые касаются имен глобальных символов, использования ловушки в конце функции инициализации, а также использования раскладок клавиш и других таблиц.</target>
        </trans-unit>
        <trans-unit id="4e10e520f9a6c6683a99c59aceede71aae7f0066" translate="yes" xml:space="preserve">
          <source>In addition, the keyword argument &lt;code&gt;:supertype&lt;/code&gt; may be used to specify a button-type from which &lt;var&gt;name&lt;/var&gt; inherits its default property values. Note that this inheritance happens only when &lt;var&gt;name&lt;/var&gt; is defined; subsequent changes to a supertype are not reflected in its subtypes.</source>
          <target state="translated">Кроме того, ключевое слово arguments &lt;code&gt;:supertype&lt;/code&gt; может использоваться для указания типа кнопки, &lt;var&gt;name&lt;/var&gt; которого наследует значения свойств по умолчанию. Обратите внимание, что это наследование происходит только тогда, когда &lt;var&gt;name&lt;/var&gt; определено; последующие изменения супертипа не отражаются на его подтипах.</target>
        </trans-unit>
        <trans-unit id="85ff8817dbd0f29156e32c5107069061c8afdaa3" translate="yes" xml:space="preserve">
          <source>In addition, this function by default also tells the display engine to update the display of &lt;var&gt;window&lt;/var&gt; when its frame gets redisplayed the next time. If &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, such updates are usually not performed. If, however, &lt;var&gt;norecord&lt;/var&gt; equals the special symbol &lt;code&gt;mark-for-redisplay&lt;/code&gt;, the additional actions mentioned above are omitted but &lt;var&gt;window&lt;/var&gt; will be nevertheless updated.</source>
          <target state="translated">Кроме того, эта функция по умолчанию также сообщает механизму отображения обновлять отображение &lt;var&gt;window&lt;/var&gt; когда его фрейм будет повторно отображен в следующий раз. Если &lt;var&gt;norecord&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , такие обновления обычно не выполняются. Если, однако, &lt;var&gt;norecord&lt;/var&gt; равно метке специального символа &lt;code&gt;mark-for-redisplay&lt;/code&gt; , дополнительные действия, упомянутые выше, опускаются, но &lt;var&gt;window&lt;/var&gt; , тем не менее, обновляется.</target>
        </trans-unit>
        <trans-unit id="5bf884b3fb47f2ce4634851fb114d20b6bd6d338" translate="yes" xml:space="preserve">
          <source>In addition, to be acceptable, a completion must also match all the regular expressions in &lt;code&gt;completion-regexp-list&lt;/code&gt;. (Unless &lt;var&gt;collection&lt;/var&gt; is a function, in which case that function has to handle &lt;code&gt;completion-regexp-list&lt;/code&gt; itself.)</source>
          <target state="translated">Кроме того, чтобы быть приемлемым, завершение также должно соответствовать всем регулярным выражениям в &lt;code&gt;completion-regexp-list&lt;/code&gt; . (Если &lt;var&gt;collection&lt;/var&gt; является функцией, и в этом случае эта функция должна сама обрабатывать &lt;code&gt;completion-regexp-list&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="7cc2fc189c0b1e344fb740a24d867c950e0a2e21" translate="yes" xml:space="preserve">
          <source>In addition, when several consecutive fields are wildcards, Emacs collapses them into a single wildcard. This is to prevent use of auto-scaled fonts. Fonts made by scaling larger fonts are not usable for editing, and scaling a smaller font is not useful because it is better to use the smaller font in its own size, which Emacs does.</source>
          <target state="translated">Кроме того,когда несколько последовательных полей являются подстановочными знаками,Emacs складывает их в один спецсимвол.Это делается для того,чтобы предотвратить использование автоматических шрифтов.Шрифты,выполненные путем масштабирования больших шрифтов,не пригодны для редактирования,а масштабирование меньшего шрифта нецелесообразно,так как лучше использовать меньший шрифт по своему размеру,что и делает Emacs.</target>
        </trans-unit>
        <trans-unit id="dcc0b00855e4755365a0cf1f09ff7bdbd4bc0266" translate="yes" xml:space="preserve">
          <source>In addition, you can mark a particular calling convention for a function as obsolete:</source>
          <target state="translated">Кроме того,вы можете пометить определенное соглашение о вызове для функции как устаревшую:</target>
        </trans-unit>
        <trans-unit id="abd2410956fae4848b0fe5a8e212d2a9cb21e007" translate="yes" xml:space="preserve">
          <source>In addition, you can specify how to override other aspects of &lt;var&gt;parent&lt;/var&gt; with &lt;var&gt;body&lt;/var&gt;. The command &lt;var&gt;variant&lt;/var&gt; evaluates the forms in &lt;var&gt;body&lt;/var&gt; after setting up all its usual overrides, just before running the mode hooks.</source>
          <target state="translated">Кроме того, вы можете указать, как переопределить другие аспекты &lt;var&gt;parent&lt;/var&gt; элемента с помощью &lt;var&gt;body&lt;/var&gt; . Команда &lt;var&gt;variant&lt;/var&gt; оценивает форму в &lt;var&gt;body&lt;/var&gt; после установки всего своего обычного переопределения, только перед запуском крюков режима.</target>
        </trans-unit>
        <trans-unit id="02d36c3daefb75afe381d792395f9b544a5ec4c1" translate="yes" xml:space="preserve">
          <source>In addition, you can use &lt;code&gt;jit-lock-register&lt;/code&gt; to register a Font Lock fontification function, which will be called whenever parts of a buffer are (re)fontified because a window was scrolled or its size changed. See &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">Кроме того, вы можете использовать &lt;code&gt;jit-lock-register&lt;/code&gt; для регистрации функции фонетирования Font Lock, которая будет вызываться всякий раз, когда части буфера (повторно) фонируются из-за прокрутки окна или изменения его размера. См. &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Другие переменные блокировки шрифта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5705334ff8d1c82c84ad44b35b05007f2fa086a6" translate="yes" xml:space="preserve">
          <source>In addition, you should use the &lt;code&gt;:image&lt;/code&gt; property; this is how you specify the image to display in the tool bar:</source>
          <target state="translated">Кроме того, вы должны использовать свойство &lt;code&gt;:image&lt;/code&gt; ; вот как вы указываете изображение для отображения на панели инструментов:</target>
        </trans-unit>
        <trans-unit id="ef0d186686b9c18697ab294b6e70ae5ec8c76b45" translate="yes" xml:space="preserve">
          <source>In all cases, the functions specify the program to be run. An error is signaled if the file is not found or cannot be executed. If the file name is relative, the variable &lt;code&gt;exec-path&lt;/code&gt; contains a list of directories to search. Emacs initializes &lt;code&gt;exec-path&lt;/code&gt; when it starts up, based on the value of the environment variable &lt;code&gt;PATH&lt;/code&gt;. The standard file name constructs, &amp;lsquo;</source>
          <target state="translated">Во всех случаях функции определяют программу, которую нужно запустить. Об ошибке сообщается, если файл не найден или не может быть выполнен. Если имя файла относительное, переменная &lt;code&gt;exec-path&lt;/code&gt; содержит список каталогов для поиска. Emacs инициализирует &lt;code&gt;exec-path&lt;/code&gt; при запуске на основе значения переменной окружения &lt;code&gt;PATH&lt;/code&gt; . Стандартные конструкции имени файла: '</target>
        </trans-unit>
        <trans-unit id="b115e6222ce380955a9d138aca170aa8e2fc234f" translate="yes" xml:space="preserve">
          <source>In all of these functions, if &lt;var&gt;pos&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the value of point is used by default. If narrowing is in effect, then &lt;var&gt;pos&lt;/var&gt; should fall within the accessible portion. See &lt;a href=&quot;narrowing#Narrowing&quot;&gt;Narrowing&lt;/a&gt;.</source>
          <target state="translated">Во всех этих функциях, если &lt;var&gt;pos&lt;/var&gt; опущено или &lt;code&gt;nil&lt;/code&gt; , значение point используется по умолчанию. Если сужение действительно, то &lt;var&gt;pos&lt;/var&gt; Должно попадать в доступную часть. См. &lt;a href=&quot;narrowing#Narrowing&quot;&gt;Сужение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf682436e64696838034960370c404ea0fb339cf" translate="yes" xml:space="preserve">
          <source>In all other cases (i.e., if a backup was made by copying or if no backup was made), this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Во всех остальных случаях (т. Е. Если резервная копия была сделана путем копирования или если резервная копия не была сделана), эта функция возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70cd7827f4bb42c08e11727b0f1fc468af4e5623" translate="yes" xml:space="preserve">
          <source>In all other respects, the indirect buffer and its base buffer are completely separate. They have different names, independent values of point, independent narrowing, independent markers and overlays (though inserting or deleting text in either buffer relocates the markers and overlays for both), independent major modes, and independent buffer-local variable bindings.</source>
          <target state="translated">Во всех остальных отношениях косвенный буфер и его базовый буфер полностью отделены друг от друга.Они имеют различные имена,независимые значения точки,независимое сужение,независимые маркеры и оверлеи (хотя вставка или удаление текста в любом из буферов перемещает маркеры и оверлеи для обоих),независимые мажорные режимы,а также независимые буферно-локальные привязки переменных.</target>
        </trans-unit>
        <trans-unit id="e9323836e208f0f82945b28702f7866a57f8574f" translate="yes" xml:space="preserve">
          <source>In an empty obarray, every element is 0, so you can create an obarray with &lt;code&gt;(make-vector &lt;var&gt;length&lt;/var&gt; 0)&lt;/code&gt;. &lt;strong&gt;This is the only valid way to create an obarray.&lt;/strong&gt; Prime numbers as lengths tend to result in good hashing; lengths one less than a power of two are also good.</source>
          <target state="translated">В пустом obarray каждый элемент равен 0, поэтому вы можете создать obarray с &lt;code&gt;(make-vector &lt;var&gt;length&lt;/var&gt; 0)&lt;/code&gt; . &lt;strong&gt;Это единственный допустимый способ создать массив. &lt;/strong&gt;Простые числа как длины обычно приводят к хорошему хешированию; длины на единицу меньше степени двойки также хороши.</target>
        </trans-unit>
        <trans-unit id="c76083d7ada2b44cfdf97bab16a99c1032df0a60" translate="yes" xml:space="preserve">
          <source>In an indirect buffer, this points to the base buffer. In an ordinary buffer, it is null.</source>
          <target state="translated">В косвенном буфере это указывает на базовый буфер.В обычном буфере он равен нулю.</target>
        </trans-unit>
        <trans-unit id="be6a5b6e0ca7ae36339c26b567db393e85f17f36" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;buffer-or-name&lt;/var&gt; is the current buffer. You cannot specify any other buffer.</source>
          <target state="translated">В интерактивном вызове &lt;var&gt;buffer-or-name&lt;/var&gt; - это текущий буфер. Вы не можете указать какой-либо другой буфер.</target>
        </trans-unit>
        <trans-unit id="c4012945ab51c1de7ae7e0feebb4d0048885f32d" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;count&lt;/var&gt; is the numeric prefix argument, and &lt;var&gt;killp&lt;/var&gt; is the unprocessed prefix argument. Therefore, if a prefix argument is supplied, the text is saved in the kill ring. If no prefix argument is supplied, then one character is deleted, but not saved in the kill ring.</source>
          <target state="translated">В интерактивном вызове &lt;var&gt;count&lt;/var&gt; - это числовой префиксный аргумент, а &lt;var&gt;killp&lt;/var&gt; - это необработанный префиксный аргумент. Следовательно, если предоставляется аргумент префикса, текст сохраняется в списке уничтожений. Если аргумент префикса не указан, то один символ удаляется, но не сохраняется в списке уничтожений.</target>
        </trans-unit>
        <trans-unit id="704c56b79c4ed2cb4dfd912f6f7d4ba1689e5220" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;count&lt;/var&gt; is the numeric prefix argument.</source>
          <target state="translated">В интерактивном вызове &lt;var&gt;count&lt;/var&gt; - это числовой префиксный аргумент.</target>
        </trans-unit>
        <trans-unit id="9c353c383e13b0c1f20602b8bc3d920d9ce5a372" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;join-following-p&lt;/var&gt; is the prefix argument, and &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are, respectively, the start and end of the region if it is active, else &lt;code&gt;nil&lt;/code&gt;. The function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В интерактивном вызове &lt;var&gt;join-following-p&lt;/var&gt; является аргументом префикса, а &lt;var&gt;beg&lt;/var&gt; in и &lt;var&gt;end&lt;/var&gt; являются, соответственно, началом и концом области, если она активна, иначе &lt;code&gt;nil&lt;/code&gt; . Функция возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd9c47e572e1c96e3e5511e4f902232b871741f5" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;move-count&lt;/var&gt; is set to the numeric prefix argument.</source>
          <target state="translated">В интерактивном вызове &lt;var&gt;move-count&lt;/var&gt; устанавливается на числовой префикс аргумента.</target>
        </trans-unit>
        <trans-unit id="877a7452b2cb77873327a9d65a9bc81a3bc68b87" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;n&lt;/var&gt; is the numeric prefix argument, if provided; otherwise &lt;var&gt;n&lt;/var&gt; defaults to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В интерактивном вызове &lt;var&gt;n&lt;/var&gt; - это числовой аргумент префикса, если он указан; в противном случае &lt;var&gt;n&lt;/var&gt; по умолчанию &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d388d1baf8cc5dc2fc6fa147be58325965385ef6" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are point and the mark, and &lt;var&gt;region&lt;/var&gt; is always non-&lt;code&gt;nil&lt;/code&gt;, so the command always kills the text in the current region.</source>
          <target state="translated">В интерактивном вызове &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; являются точкой и меткой, а &lt;var&gt;region&lt;/var&gt; всегда не равен &lt;code&gt;nil&lt;/code&gt; , поэтому команда всегда уничтожает текст в текущей области.</target>
        </trans-unit>
        <trans-unit id="a6cb6ba8c7fe3535c2d651a8267a7942776259f0" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are point and the mark, and &lt;var&gt;region&lt;/var&gt; is always non-&lt;code&gt;nil&lt;/code&gt;, so the command always saves the text in the current region.</source>
          <target state="translated">В интерактивном вызове &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; являются точкой и меткой, а &lt;var&gt;region&lt;/var&gt; всегда не равен &lt;code&gt;nil&lt;/code&gt; , поэтому команда всегда сохраняет текст в текущей области.</target>
        </trans-unit>
        <trans-unit id="726b5ea42fc92cd6827c86a199c5d5ff92d13493" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are set to the bounds of the current region (point and the mark, with the smallest first).</source>
          <target state="translated">В интерактивном вызове &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; устанавливаются на границах текущего региона (точка и метка , начиная с наименьшей).</target>
        </trans-unit>
        <trans-unit id="909035f0fed973896fe39afc8da0584d4b089bed" translate="yes" xml:space="preserve">
          <source>In an interactive call, BUFFER-OR-NAME is the current buffer. You cannot specify any other buffer. This function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В интерактивном вызове BUFFER-OR-NAME является текущим буфером. Вы не можете указать какой-либо другой буфер. Эта функция возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6eeae93f2da1e1eebbead60ee6180c03e34ee17" translate="yes" xml:space="preserve">
          <source>In any alternative for which &lt;code&gt;nil&lt;/code&gt; is not a valid value, other than a &lt;code&gt;const&lt;/code&gt;, you should specify a valid default for that alternative using the &lt;code&gt;:value&lt;/code&gt; keyword. See &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Type Keywords&lt;/a&gt;.</source>
          <target state="translated">В любой альтернативе, для которой &lt;code&gt;nil&lt;/code&gt; не является допустимым значением, кроме &lt;code&gt;const&lt;/code&gt; , вы должны указать допустимое значение по умолчанию для этой альтернативы, используя ключевое слово &lt;code&gt;:value&lt;/code&gt; . См. &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Ключевые слова типа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f1ff89d869dfc333b47133aae85f8c337add69" translate="yes" xml:space="preserve">
          <source>In any construct except &amp;lsquo;</source>
          <target state="translated">В любой конструкции, кроме '</target>
        </trans-unit>
        <trans-unit id="23f12bc9401d6ef353dd5c55264d43d354d02967" translate="yes" xml:space="preserve">
          <source>In backtraces, the tails of long lists and the ends of long strings, vectors or structures, as well as objects which are deeply nested, will be printed as underlined &amp;ldquo;...&amp;rdquo;. You can click with the mouse on a &amp;ldquo;...&amp;rdquo;, or type</source>
          <target state="translated">В обратных трассировках хвосты длинных списков и концы длинных строк, векторов или структур, а также объекты, которые глубоко вложены, будут напечатаны как подчеркнутые &amp;laquo;...&amp;raquo;. Вы можете щелкнуть мышью по &amp;laquo;...&amp;raquo; или ввести</target>
        </trans-unit>
        <trans-unit id="c4a2e0b355083bd4e6d42b1e97e7d50e0326670d" translate="yes" xml:space="preserve">
          <source>In batch mode (see &lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;Batch Mode&lt;/a&gt;), &lt;code&gt;sit-for&lt;/code&gt; cannot be interrupted, even by input from the standard input descriptor. It is thus equivalent to &lt;code&gt;sleep-for&lt;/code&gt;, which is described below.</source>
          <target state="translated">В пакетном режиме (см. &lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;Пакетный режим&lt;/a&gt; ) &lt;code&gt;sit-for&lt;/code&gt; не может быть прервана даже вводом из стандартного дескриптора ввода. Таким образом, это эквивалентно &lt;code&gt;sleep-for&lt;/code&gt; , описанному ниже.</target>
        </trans-unit>
        <trans-unit id="9752b056c39ff21442a1ef5d86a1fc2649afb383" translate="yes" xml:space="preserve">
          <source>In batch mode, the message is printed to the standard error stream, followed by a newline.</source>
          <target state="translated">В пакетном режиме сообщение выводится в стандартный поток ошибок,за которым следует новая строка.</target>
        </trans-unit>
        <trans-unit id="8f907e0c0c1a2381a3d4d498c2ada7dd4f978099" translate="yes" xml:space="preserve">
          <source>In between &lt;code&gt;deftheme&lt;/code&gt; and &lt;code&gt;provide-theme&lt;/code&gt; are Lisp forms specifying the theme settings: usually a call to &lt;code&gt;custom-theme-set-variables&lt;/code&gt; and/or a call to &lt;code&gt;custom-theme-set-faces&lt;/code&gt;.</source>
          <target state="translated">Между &lt;code&gt;deftheme&lt;/code&gt; и &lt;code&gt;provide-theme&lt;/code&gt; находятся формы Lisp, определяющие настройки темы: обычно это вызов &lt;code&gt;custom-theme-set-variables&lt;/code&gt; и / или вызов &lt;code&gt;custom-theme-set-faces&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3186dd1c1a48267fc6d25c2e34e690dda868c78a" translate="yes" xml:space="preserve">
          <source>In binary, the decimal integer 5 looks like this:</source>
          <target state="translated">В двоичной системе десятичное целое число 5 выглядит так:</target>
        </trans-unit>
        <trans-unit id="d7ecff436b6d92bbc3770178067cf6d70a3b3360" translate="yes" xml:space="preserve">
          <source>In bitfields, prefer &lt;code&gt;unsigned int&lt;/code&gt; or &lt;code&gt;signed int&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;, as &lt;code&gt;int&lt;/code&gt; is less portable: it might be signed, and might not be. Single-bit bit fields should be &lt;code&gt;unsigned int&lt;/code&gt; or &lt;code&gt;bool_bf&lt;/code&gt; so that their values are 0 or 1.</source>
          <target state="translated">В битовых полей, предпочитают &lt;code&gt;unsigned int&lt;/code&gt; или &lt;code&gt;signed int&lt;/code&gt; в &lt;code&gt;int&lt;/code&gt; как &lt;code&gt;int&lt;/code&gt; является менее переносимым: оно может быть подписано, и не может быть. &lt;code&gt;bool_bf&lt;/code&gt; поля должны быть &lt;code&gt;unsigned int&lt;/code&gt; или bool_bf, чтобы их значения были 0 или 1.</target>
        </trans-unit>
        <trans-unit id="675393a13b41d56ffdbbbad71f7b6ec5ff7928e6" translate="yes" xml:space="preserve">
          <source>In case a process status changes need to be passed to several sentinels, you can use &lt;code&gt;add-function&lt;/code&gt; to combine an existing sentinel with a new one. See &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;.</source>
          <target state="translated">В случае, если изменения статуса процесса необходимо передать нескольким дозорным, вы можете использовать &lt;code&gt;add-function&lt;/code&gt; для объединения существующего дозорного с новым. См. Раздел &amp;laquo; &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Консультирующие функции&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0977f1472f3a5da1475ae4011d1503a4798e4640" translate="yes" xml:space="preserve">
          <source>In case the process&amp;rsquo;s output needs to be passed to several filters, you can use &lt;code&gt;add-function&lt;/code&gt; to combine an existing filter with a new one. See &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;.</source>
          <target state="translated">Если вывод процесса необходимо передать нескольким фильтрам, вы можете использовать &lt;code&gt;add-function&lt;/code&gt; чтобы объединить существующий фильтр с новым. См. Раздел &amp;laquo; &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Консультирующие функции&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="415e1a1cd6e77875c4b4a2bc134b390be6d8c82b" translate="yes" xml:space="preserve">
          <source>In complicated programs, simple termination may not be what you want. For example, the program may have made temporary changes in data structures, or created temporary buffers that should be deleted before the program is finished. In such cases, you would use &lt;code&gt;unwind-protect&lt;/code&gt; to establish &lt;em&gt;cleanup expressions&lt;/em&gt; to be evaluated in case of error. (See &lt;a href=&quot;cleanups#Cleanups&quot;&gt;Cleanups&lt;/a&gt;.) Occasionally, you may wish the program to continue execution despite an error in a subroutine. In these cases, you would use &lt;code&gt;condition-case&lt;/code&gt; to establish &lt;em&gt;error handlers&lt;/em&gt; to recover control in case of error.</source>
          <target state="translated">В сложных программах простое завершение может оказаться не тем, что вам нужно. Например, программа могла внести временные изменения в структуры данных или создать временные буферы, которые следует удалить до завершения программы. В таких случаях вы должны использовать &lt;code&gt;unwind-protect&lt;/code&gt; чтобы установить &lt;em&gt;выражения очистки,&lt;/em&gt; которые будут оцениваться в случае ошибки. (См. &lt;a href=&quot;cleanups#Cleanups&quot;&gt;Очистка&lt;/a&gt; .) Иногда вы можете захотеть , чтобы программа продолжала выполнение, несмотря на ошибку в подпрограмме. В этих случаях вы должны использовать &lt;code&gt;condition-case&lt;/code&gt; для установки &lt;em&gt;обработчиков ошибок&lt;/em&gt; для восстановления управления в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="60f0d105f0d0cf77e2c002371b610ecf30fd644e" translate="yes" xml:space="preserve">
          <source>In contexts where a truth value is expected, any non-&lt;code&gt;nil&lt;/code&gt; value is considered to be &lt;var&gt;true&lt;/var&gt;. However, &lt;code&gt;t&lt;/code&gt; is the preferred way to represent the truth value &lt;var&gt;true&lt;/var&gt;. When you need to choose a value that represents &lt;var&gt;true&lt;/var&gt;, and there is no other basis for choosing, use &lt;code&gt;t&lt;/code&gt;. The symbol &lt;code&gt;t&lt;/code&gt; always has the value &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">В контекстах, где ожидается значение истинности, любое значение , отличное от &lt;code&gt;nil&lt;/code&gt; считается &lt;var&gt;true&lt;/var&gt; . Однако &lt;code&gt;t&lt;/code&gt; - предпочтительный способ представить истинное значение &lt;var&gt;true&lt;/var&gt; . Если вам нужно выбрать значение, представляющее &lt;var&gt;true&lt;/var&gt; , и нет другого основания для выбора, используйте &lt;code&gt;t&lt;/code&gt; . Символ &lt;code&gt;t&lt;/code&gt; всегда имеет значение &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8eba9b310f9d565eff25ab947d11a5a1f613377b" translate="yes" xml:space="preserve">
          <source>In contrast to the round-trip specification described in the previous subsection (see &lt;a href=&quot;format-conversion-round_002dtrip#Format-Conversion-Round_002dTrip&quot;&gt;Format Conversion Round-Trip&lt;/a&gt;), you can use the variables &lt;code&gt;after-insert-file-functions&lt;/code&gt; and &lt;code&gt;write-region-annotate-functions&lt;/code&gt; to separately control the respective reading and writing conversions.</source>
          <target state="translated">В отличие от спецификации кругового обхода, описанной в предыдущем подразделе (см. &lt;a href=&quot;format-conversion-round_002dtrip#Format-Conversion-Round_002dTrip&quot;&gt;Круговой&lt;/a&gt; путь преобразования формата ), вы можете использовать переменные &lt;code&gt;after-insert-file-functions&lt;/code&gt; и &lt;code&gt;write-region-annotate-functions&lt;/code&gt; для отдельного управления соответствующим чтением и записью. конверсии.</target>
        </trans-unit>
        <trans-unit id="0a3bf2d74aea58d6ea8bffb1137530a1210d0d12" translate="yes" xml:space="preserve">
          <source>In contrast, when reading, the annotations intermixed with the text are handled immediately. &lt;code&gt;insert-file-contents&lt;/code&gt; sets point to the beginning of some text to be converted, then calls the conversion functions with the length of that text. These functions should always return with point at the beginning of the inserted text. This approach makes sense for reading because annotations removed by the first converter can&amp;rsquo;t be mistakenly processed by a later converter. Each conversion function should scan for the annotations it recognizes, remove the annotation, modify the buffer text (to set a text property, for example), and return the updated length of the text, as it stands after those changes. The value returned by one function becomes the argument to the next function.</source>
          <target state="translated">Напротив, при чтении аннотации, смешанные с текстом, обрабатываются немедленно. &lt;code&gt;insert-file-contents&lt;/code&gt; устанавливает указатель на начало некоторого текста, который нужно преобразовать, а затем вызывает функции преобразования с длиной этого текста. Эти функции всегда должны возвращаться с точкой в ​​начале вставленного текста. Этот подход имеет смысл для чтения, поскольку аннотации, удаленные первым преобразователем, не могут быть ошибочно обработаны последующим преобразователем. Каждая функция преобразования должна сканировать аннотации, которые она распознает, удалить аннотацию, изменить текст буфера (например, для установки свойства текста) и вернуть обновленную длину текста в том виде, в каком она была после этих изменений. Значение, возвращаемое одной функцией, становится аргументом для следующей функции.</target>
        </trans-unit>
        <trans-unit id="45f849363c53b5551262a12f44a838fe59d9dfff" translate="yes" xml:space="preserve">
          <source>In conventional string syntax, it would be written</source>
          <target state="translated">В обычном синтаксисе строк,это будет написано</target>
        </trans-unit>
        <trans-unit id="6763f8895253c23b2bfde0810fbb36d480f05759" translate="yes" xml:space="preserve">
          <source>In database terminology, an &lt;em&gt;atomic&lt;/em&gt; change is an indivisible change&amp;mdash;it can succeed entirely or it can fail entirely, but it cannot partly succeed. A Lisp program can make a series of changes to one or several buffers as an &lt;em&gt;atomic change group&lt;/em&gt;, meaning that either the entire series of changes will be installed in their buffers or, in case of an error, none of them will be.</source>
          <target state="translated">В терминологии базы данных &lt;em&gt;атомарное&lt;/em&gt; изменение - это неделимое изменение: оно может быть полностью успешным или может полностью потерпеть неудачу, но не может быть частично успешным. Программа на Лиспе может вносить серию изменений в один или несколько буферов как &lt;em&gt;атомарную группу изменений&lt;/em&gt; , что означает, что либо вся серия изменений будет установлена ​​в их буферы, либо, в случае ошибки, ни одно из них не будет.</target>
        </trans-unit>
        <trans-unit id="24fde5297de2cdf3f7cddc429425532a566bab63" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;fill-context-prefix&lt;/code&gt; does this:</source>
          <target state="translated">В деталях, &lt;code&gt;fill-context-prefix&lt;/code&gt; делает это:</target>
        </trans-unit>
        <trans-unit id="6c73b882a6269a46b3da224791afd0c995e3640a" translate="yes" xml:space="preserve">
          <source>In each frame, at any time, exactly one Emacs window is designated as &lt;em&gt;selected within the frame&lt;/em&gt;. For the selected frame, that window is called the &lt;em&gt;selected window&lt;/em&gt;&amp;mdash;the one in which most editing takes place, and in which the cursor for selected windows appears (see &lt;a href=&quot;cursor-parameters#Cursor-Parameters&quot;&gt;Cursor Parameters&lt;/a&gt;). Keyboard input that inserts or deletes text is also normally directed to this window. The selected window&amp;rsquo;s buffer is usually also the current buffer, except when &lt;code&gt;set-buffer&lt;/code&gt; has been used (see &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;). As for non-selected frames, the window selected within the frame becomes the selected window if the frame is ever selected. See &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Selecting Windows&lt;/a&gt;.</source>
          <target state="translated">В каждом кадре, в любой момент времени, только одно окно Emacs обозначается как &lt;em&gt;выбранное в кадре&lt;/em&gt; . Для выбранного фрейма это окно называется &lt;em&gt;выбранным окном&lt;/em&gt; - тем, в котором происходит большая часть редактирования и в котором появляется курсор для выбранных окон (см. &lt;a href=&quot;cursor-parameters#Cursor-Parameters&quot;&gt;Параметры курсора&lt;/a&gt; ). В это окно также обычно направляется ввод с клавиатуры, который вставляет или удаляет текст. Буфер выбранного окна обычно также является текущим буфером, за исключением случаев, когда использовался &lt;code&gt;set-buffer&lt;/code&gt; (см. &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Текущий буфер&lt;/a&gt; ). Что касается невыбранных фреймов, окно, выбранное в фрейме, становится выбранным окном, если фрейм когда-либо был выбран. См. &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Выбор Windows&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad35cfb21fd35d93c29df7f5ad4a4bed0b1b3107" translate="yes" xml:space="preserve">
          <source>In either case, evaluating the new form a second time should reuse the window already showing</source>
          <target state="translated">В любом случае,оценивая новую форму во второй раз,следует повторно использовать окно,уже показывающее</target>
        </trans-unit>
        <trans-unit id="ee27d0c4d0b49c83179819de6b9ff1ee23a49d86" translate="yes" xml:space="preserve">
          <source>In either case, if the buffer appended to happens to be displayed in some window, the next redisplay will show how its text has changed. If it is not displayed in any window, you will not see the change immediately on the screen. The command causes the buffer to become current temporarily, but does not cause it to be displayed.</source>
          <target state="translated">В любом случае,если буфер,к которому приложен,случайно отобразится в каком-нибудь окне,то следующий повторный показ покажет,как изменился его текст.Если он не отображается ни в одном из окон,вы не увидите изменения сразу на экране.Команда приводит к тому,что буфер временно становится текущим,но не вызывает его отображения.</target>
        </trans-unit>
        <trans-unit id="ef78bac5868bf004212c473e8f88981c10bea61b" translate="yes" xml:space="preserve">
          <source>In either case, the mouse pointer must enter the text area of a window in order to trigger its selection. Dragging the scroll bar slider or the mode line of a window conceptually should not cause its auto-selection.</source>
          <target state="translated">В любом случае,указатель мыши должен войти в текстовую область окна,чтобы вызвать его выделение.Перетаскивание ползунка прокрутки или линии режима окна концептуально не должно приводить к его автовыделению.</target>
        </trans-unit>
        <trans-unit id="bb020b581d31901fa99b6df9f62296593685946f" translate="yes" xml:space="preserve">
          <source>In execution, this is equivalent to &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt;, but the compiler does not issue warnings for anything that occurs inside &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">При выполнении это эквивалентно &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt; , но компилятор не выдает предупреждений обо всем, что происходит внутри &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f9f3178064d3634e45314cc92aa2cf96eef93d" translate="yes" xml:space="preserve">
          <source>In execution, this is equivalent to &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt;, but the compiler does not issue warnings for the specified conditions in &lt;var&gt;body&lt;/var&gt;. &lt;var&gt;warnings&lt;/var&gt; is an associative list of warning symbols and function/variable symbols they apply to. For instance, if you wish to call an obsolete function called &lt;code&gt;foo&lt;/code&gt;, but want to suppress the compilation warning, say:</source>
          <target state="translated">При выполнении это эквивалентно &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt; , но компилятор не выдает предупреждений для указанных условий в &lt;var&gt;body&lt;/var&gt; . &lt;var&gt;warnings&lt;/var&gt; - это ассоциативный список предупреждающих символов и символов функций / переменных, к которым они применяются. Например, если вы хотите вызвать устаревшую функцию с именем &lt;code&gt;foo&lt;/code&gt; , но хотите подавить предупреждение компиляции, скажите:</target>
        </trans-unit>
        <trans-unit id="e7a73c00dd55be6828ec1b5b1eeb3d24e621b2d1" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;shell-mode&lt;/code&gt; is used only in a function that executes &lt;code&gt;(require 'shell)&lt;/code&gt; before calling &lt;code&gt;shell-mode&lt;/code&gt;, so &lt;code&gt;shell-mode&lt;/code&gt; will be defined properly at run-time. When you know that such a warning does not indicate a real problem, it is good to suppress the warning. That makes new warnings which might mean real problems more visible. You do that with &lt;code&gt;declare-function&lt;/code&gt;.</source>
          <target state="translated">Фактически, &lt;code&gt;shell-mode&lt;/code&gt; используется только в функции, которая выполняется &lt;code&gt;(require 'shell)&lt;/code&gt; перед вызовом &lt;code&gt;shell-mode&lt;/code&gt; &lt;code&gt;shell-mode&lt;/code&gt; , поэтому режим оболочки будет правильно определен во время выполнения. Если вы знаете, что такое предупреждение не указывает на настоящую проблему, лучше его отключить. Это делает новые предупреждения, которые могут означать реальные проблемы, более заметными. Вы делаете это с помощью &lt;code&gt;declare-function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702499afeb8537fae4516a820a217b87dce96b8a" translate="yes" xml:space="preserve">
          <source>In general, a coding system doesn&amp;rsquo;t guarantee roundtrip identity: decoding a byte sequence using a coding system, then encoding the resulting text in the same coding system, can produce a different byte sequence. But some coding systems do guarantee that the byte sequence will be the same as what you originally decoded. Here are a few examples:</source>
          <target state="translated">В общем, система кодирования не гарантирует двусторонней идентичности: декодирование последовательности байтов с использованием системы кодирования с последующим кодированием результирующего текста в той же системе кодирования может дать другую последовательность байтов. Но некоторые системы кодирования действительно гарантируют, что последовательность байтов будет такой же, как та, которую вы изначально декодировали. Вот несколько примеров:</target>
        </trans-unit>
        <trans-unit id="ed8140bd46b47c404332052d91ca4300f382ef67" translate="yes" xml:space="preserve">
          <source>In general, a customization type is a list whose first element is a symbol, one of the customization type names defined in the following sections. After this symbol come a number of arguments, depending on the symbol. Between the type symbol and its arguments, you can optionally write keyword-value pairs (see &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Type Keywords&lt;/a&gt;).</source>
          <target state="translated">Как правило, тип настройки - это список, первым элементом которого является символ, одно из имен типов настройки, определенных в следующих разделах. После этого символа идет ряд аргументов в зависимости от символа. Между символом типа и его аргументами вы можете при желании написать пары ключевое слово-значение (см. &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Ключевые слова типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1b2ad17401a7d60fe385624a77f3d12df552ad7a" translate="yes" xml:space="preserve">
          <source>In general, any version of Emacs can run byte-compiled code produced by recent earlier versions of Emacs, but the reverse is not true.</source>
          <target state="translated">В общем,любая версия Emacs может запускать байт-компилированный код,созданный последними ранними версиями Emacs,но обратное не верно.</target>
        </trans-unit>
        <trans-unit id="483c66ee5a6826168e53ee4c3c9f71f1f0eb14bb" translate="yes" xml:space="preserve">
          <source>In general, it is not a good idea to position a frame relative to the right or bottom edge of its display. Positioning the initial or a new frame is either not accurate (because the size of the outer frame is not yet fully known before the frame has been made visible) or will cause additional flicker (if the frame has to be repositioned after becoming visible).</source>
          <target state="translated">В целом,не стоит позиционировать кадр относительно правого или нижнего края его дисплея.Позиционирование исходной или новой рамки либо неточно (поскольку размер внешней рамки еще не полностью известен до того,как она станет видимой),либо вызовет дополнительное мерцание (если рамку нужно будет переместить после того,как она станет видимой).</target>
        </trans-unit>
        <trans-unit id="034a86c69916fca88f1f01a8bd4d6e2f2b480dfb" translate="yes" xml:space="preserve">
          <source>In general, the execution modes earlier in the above list run the program more slowly or stop sooner than the modes later in the list.</source>
          <target state="translated">В целом,режимы исполнения раньше в приведенном списке запускают программу медленнее или останавливают ее раньше,чем режимы позднее в списке.</target>
        </trans-unit>
        <trans-unit id="62c782f036549cb7ac5bcdfa7098ab39e8230d14" translate="yes" xml:space="preserve">
          <source>In general, you should never use &lt;code&gt;select-frame&lt;/code&gt; in a way that could switch to a different terminal without switching back when you&amp;rsquo;re done.</source>
          <target state="translated">В общем, вы никогда не должны использовать &lt;code&gt;select-frame&lt;/code&gt; таким образом, чтобы можно было переключиться на другой терминал без переключения обратно, когда вы закончите.</target>
        </trans-unit>
        <trans-unit id="000defc205f6d714529fe32278af5b38a4bfd5bc" translate="yes" xml:space="preserve">
          <source>In hexadecimal and octal escape sequences, the escaped character code may contain a variable number of digits, so the first subsequent character which is not a valid hexadecimal or octal digit terminates the escape sequence. If the next character in a string could be interpreted as a hexadecimal or octal digit, write &amp;lsquo;</source>
          <target state="translated">В шестнадцатеричных и восьмеричных escape-последовательностях код экранированного символа может содержать переменное количество цифр, поэтому первый последующий символ, который не является допустимой шестнадцатеричной или восьмеричной цифрой, завершает escape-последовательность. Если следующий символ в строке можно интерпретировать как шестнадцатеричную или восьмеричную цифру, напишите '</target>
        </trans-unit>
        <trans-unit id="0836c04769a43db17a7b5ef05b200c3203b6be46" translate="yes" xml:space="preserve">
          <source>In human languages, and in C code, the parenthesis pairs are &amp;lsquo;</source>
          <target state="translated">В человеческих языках и в коде C пары скобок:</target>
        </trans-unit>
        <trans-unit id="c6f32a0eb2283df62480c957c724fa4fc47bd02c" translate="yes" xml:space="preserve">
          <source>In its most simplistic form, a frame accommodates always one single window that can be used for displaying a buffer. As a consequence, it is always the latest call of &lt;code&gt;display-buffer&lt;/code&gt; that will have succeeded in placing its buffer there.</source>
          <target state="translated">В наиболее упрощенной форме фрейм всегда включает в себя одно окно, которое можно использовать для отображения буфера. Как следствие, всегда последний вызов &lt;code&gt;display-buffer&lt;/code&gt; успешно помещает туда свой буфер.</target>
        </trans-unit>
        <trans-unit id="517dd96030f3f996fb1f45cc621a39517562983b" translate="yes" xml:space="preserve">
          <source>In many</source>
          <target state="translated">Во многих случаях</target>
        </trans-unit>
        <trans-unit id="8dcd7ed16971de04e98f26c126a4533e71094f7f" translate="yes" xml:space="preserve">
          <source>In many cases, you can avoid the need to track the mouse by using the &lt;code&gt;mouse-face&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;). That works at a much lower level and runs more smoothly than Lisp-level mouse tracking.</source>
          <target state="translated">Во многих случаях вы можете избежать необходимости отслеживать мышь, используя текстовое свойство &lt;code&gt;mouse-face&lt;/code&gt; (см. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&lt;/a&gt; ). Это работает на гораздо более низком уровне и работает более плавно, чем отслеживание мыши на уровне Lisp.</target>
        </trans-unit>
        <trans-unit id="49101488ffc937e3b7893c385b89b2d974310c1a" translate="yes" xml:space="preserve">
          <source>In most Emacs Lisp programs, the fact that non-</source>
          <target state="translated">В большинстве программ Emacs Lisp,тот факт,что не</target>
        </trans-unit>
        <trans-unit id="3d37db503d5ae63228a732b670e52af7077b5d2f" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;var&gt;repeat&lt;/var&gt; has no effect on when &lt;em&gt;first&lt;/em&gt; call takes place&amp;mdash;&lt;var&gt;time&lt;/var&gt; alone specifies that. There is one exception: if &lt;var&gt;time&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, then the timer runs whenever the time is a multiple of &lt;var&gt;repeat&lt;/var&gt; seconds after the epoch. This is useful for functions like &lt;code&gt;display-time&lt;/code&gt;.</source>
          <target state="translated">В большинстве случаев &lt;var&gt;repeat&lt;/var&gt; не влияет на момент &lt;em&gt;первого&lt;/em&gt; звонка - это указывает только &lt;var&gt;time&lt;/var&gt; . Существует одно исключение: если &lt;var&gt;time&lt;/var&gt; является &lt;code&gt;t&lt;/code&gt; , то запускается таймер , когда время кратно &lt;var&gt;repeat&lt;/var&gt; секунд после эпохи. Это полезно для таких функций, как &lt;code&gt;display-time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2168d3ba9383968f4154392a9504604af5704a81" translate="yes" xml:space="preserve">
          <source>In most cases, an object&amp;rsquo;s printed representation is also a read syntax for the object. However, some types have no read syntax, since it does not make sense to enter objects of these types as constants in a Lisp program. These objects are printed in &lt;em&gt;hash notation&lt;/em&gt;, which consists of the characters &amp;lsquo;</source>
          <target state="translated">В большинстве случаев печатное представление объекта также является синтаксисом чтения для объекта. Однако у некоторых типов нет синтаксиса чтения, поскольку нет смысла вводить объекты этих типов как константы в программе на Лиспе. Эти объекты печатаются в &lt;em&gt;хэш-нотации&lt;/em&gt; , состоящей из символов</target>
        </trans-unit>
        <trans-unit id="c750c78aabaa316f26f23fc17657b3720fc57df7" translate="yes" xml:space="preserve">
          <source>In most cases, this is the same as &lt;code&gt;data-directory&lt;/code&gt;. They may be different when you run Emacs from the directory where you built it, without actually installing it. See &lt;a href=&quot;help-functions#Definition-of-data_002ddirectory&quot;&gt;Definition of data-directory&lt;/a&gt;.</source>
          <target state="translated">В большинстве случаев это то же самое, что и &lt;code&gt;data-directory&lt;/code&gt; . Они могут отличаться, когда вы запускаете Emacs из каталога, в котором вы его создали, без фактической установки. См. &lt;a href=&quot;help-functions#Definition-of-data_002ddirectory&quot;&gt;Определение каталога данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f11478c160dcd0584465efccbf9e4064e017f8a" translate="yes" xml:space="preserve">
          <source>In most cases, you should not call minibuffer input functions in the middle of a Lisp function. Instead, do all minibuffer input as part of reading the arguments for a command, in the &lt;code&gt;interactive&lt;/code&gt; specification. See &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;.</source>
          <target state="translated">В большинстве случаев вам не следует вызывать функции ввода минибуфера в середине функции Лиспа. Вместо этого выполняйте весь ввод минибуфера как часть чтения аргументов команды в &lt;code&gt;interactive&lt;/code&gt; спецификации. См. &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Определение команд&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4c2bc2c76de37d53e0710c100619151cccb7b2e" translate="yes" xml:space="preserve">
          <source>In most cases, you should not call these functions in the middle of a Lisp function. When possible, do all minibuffer input as part of reading the arguments for a command, in the &lt;code&gt;interactive&lt;/code&gt; specification. See &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;.</source>
          <target state="translated">В большинстве случаев вы не должны вызывать эти функции в середине функции Lisp. По возможности делайте весь ввод минибуфера как часть чтения аргументов команды в &lt;code&gt;interactive&lt;/code&gt; спецификации. См. &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Определение команд&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d28787cdfc551ad73cc6007bcd96f89f863e52c" translate="yes" xml:space="preserve">
          <source>In most cases, you should not need to call &lt;code&gt;package-activate-all&lt;/code&gt;, as this is done automatically during startup. Simply make sure to put any code that should run before &lt;code&gt;package-activate-all&lt;/code&gt; in the early init file, and any code that should run after it in the primary init file (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File&quot;&gt;Init File&lt;/a&gt; in</source>
          <target state="translated">В большинстве случаев вам не нужно вызывать &lt;code&gt;package-activate-all&lt;/code&gt; , так как это делается автоматически во время запуска. Просто убедитесь , чтобы поместить любой код , который должен работать , прежде чем &lt;code&gt;package-activate-all&lt;/code&gt; в начале файла инициализации, и любой код , который должен работать после этого в файле первичной инициализации (см &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File&quot;&gt;Файл инициализации&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="52edda6cecd2fb58fc90992ae0ad15afe4d996ec" translate="yes" xml:space="preserve">
          <source>In most cases, you should not need to call &lt;code&gt;package-activate-all&lt;/code&gt;, as this is done automatically during startup. Simply make sure to put any code that should run before &lt;code&gt;package-activate-all&lt;/code&gt; in the early init file, and any code that should run after it in the primary init file (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File&quot;&gt;Init File&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574e81c2ebf0fb53e6b7a82f512213500a53d2b7" translate="yes" xml:space="preserve">
          <source>In most clean Lisp code, this difference won&amp;rsquo;t matter. It can matter only if you perform side-effects on the objects constructed by the macro definition. Thus, to avoid trouble, &lt;strong&gt;avoid side effects on objects constructed by macro definitions&lt;/strong&gt;. Here is an example of how such side effects can get you into trouble:</source>
          <target state="translated">В самом чистом коде Lisp эта разница не имеет значения. Это может иметь значение, только если вы выполняете побочные эффекты для объектов, созданных определением макроса. Таким образом, чтобы избежать проблем, &lt;strong&gt;избегайте побочных эффектов для объектов, созданных с помощью определений макросов&lt;/strong&gt; . Вот пример того, как такие побочные эффекты могут доставить вам неприятности:</target>
        </trans-unit>
        <trans-unit id="0b16687a5ada91a83610070c6aab00214708b230" translate="yes" xml:space="preserve">
          <source>In most computer languages, every function has a name. But in Lisp, a function in the strictest sense has no name: it is an object which can &lt;em&gt;optionally&lt;/em&gt; be associated with a symbol (e.g., &lt;code&gt;car&lt;/code&gt;) that serves as the function name. See &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;. When a function has been given a name, we usually also refer to that symbol as a &amp;ldquo;function&amp;rdquo; (e.g., we refer to &amp;ldquo;the function &lt;code&gt;car&lt;/code&gt;&amp;rdquo;). In this manual, the distinction between a function name and the function object itself is usually unimportant, but we will take note wherever it is relevant.</source>
          <target state="translated">На большинстве компьютерных языков у каждой функции есть имя. Но в Лиспе функция в самом строгом смысле слова не имеет имени: это объект, который при &lt;em&gt;желании&lt;/em&gt; может быть связан с символом (например, &lt;code&gt;car&lt;/code&gt; ), который служит именем функции. См. &lt;a href=&quot;function-names#Function-Names&quot;&gt;Имена функций&lt;/a&gt; . Когда функции присвоено имя, мы обычно также называем этот символ &amp;laquo;функцией&amp;raquo; (например, мы ссылаемся на &amp;laquo;функциональную &lt;code&gt;car&lt;/code&gt; &amp;raquo;). В этом руководстве различие между именем функции и самим объектом функции обычно не имеет значения, но мы будем принимать к сведению везде, где это необходимо.</target>
        </trans-unit>
        <trans-unit id="0783cd0cb68b0d9a782edd9f6662166db1491334" translate="yes" xml:space="preserve">
          <source>In most languages, the programmer must declare the data type of each variable, and the type is known by the compiler but not represented in the data. Such type declarations do not exist in Emacs Lisp. A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all. (Actually, a small number of Emacs Lisp variables can only take on values of a certain type. See &lt;a href=&quot;variables-with-restricted-values#Variables-with-Restricted-Values&quot;&gt;Variables with Restricted Values&lt;/a&gt;.)</source>
          <target state="translated">В большинстве языков программист должен объявить тип данных каждой переменной, и этот тип известен компилятору, но не представлен в данных. Такие объявления типов не существуют в Emacs Lisp. Переменная Lisp может иметь любой тип значения, и она запоминает любое значение, которое вы в ней храните, тип и все остальное. (Фактически, небольшое количество переменных Emacs Lisp может принимать значения только определенного типа. См. &lt;a href=&quot;variables-with-restricted-values#Variables-with-Restricted-Values&quot;&gt;Переменные с ограниченными значениями&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="48532c1621002093d77ee956f1e52d70bc16b5b2" translate="yes" xml:space="preserve">
          <source>In most of the places where strings are used, we conceptualize the string as containing text characters&amp;mdash;the same kind of characters found in buffers or files. Occasionally Lisp programs use strings that conceptually contain keyboard characters; for example, they may be key sequences or keyboard macro definitions. However, storing keyboard characters in a string is a complex matter, for reasons of historical compatibility, and it is not always possible.</source>
          <target state="translated">В большинстве случаев, когда используются строки, мы концептуализируем строку как содержащую текстовые символы - символы того же типа, что и в буферах или файлах. Иногда программы на Лиспе используют строки, которые концептуально содержат символы клавиатуры; например, это могут быть последовательности клавиш или определения макросов клавиатуры. Однако сохранение символов клавиатуры в строке - сложный вопрос по причинам исторической совместимости, и это не всегда возможно.</target>
        </trans-unit>
        <trans-unit id="5f4144091cc9aca1cd2f8e02b0fccbdf93c70e06" translate="yes" xml:space="preserve">
          <source>In most programming languages, it is impossible to have a function without a name. In Lisp, a function has no intrinsic name. A lambda expression can be called as a function even though it has no name; to emphasize this, we also call it an &lt;em&gt;anonymous function&lt;/em&gt; (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;). A named function in Lisp is just a symbol with a valid function in its function cell (see &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;).</source>
          <target state="translated">В большинстве языков программирования невозможно иметь функцию без имени. В Лиспе функция не имеет собственного имени. Лямбда-выражение может быть вызвано как функция, даже если у него нет имени; чтобы подчеркнуть это, мы также называем ее &lt;em&gt;анонимной функцией&lt;/em&gt; (см. &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Анонимные функции&lt;/a&gt; ). Именованная функция в Лиспе - это просто символ с допустимой функцией в его функциональной ячейке (см. &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Определение функций&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="717022d1f6adfca4a3a7968227e86d9f8fd9f6f0" translate="yes" xml:space="preserve">
          <source>In most ways, a minibuffer is a normal Emacs buffer. Most operations &lt;em&gt;within&lt;/em&gt; a buffer, such as editing commands, work normally in a minibuffer. However, many operations for managing buffers do not apply to minibuffers. The name of a minibuffer always has the form &amp;lsquo;</source>
          <target state="translated">В большинстве случаев минибуфер - это обычный буфер Emacs. Большинство операций &lt;em&gt;в&lt;/em&gt; буфере, таких как команды редактирования, обычно работают в минибуфере. Однако многие операции по управлению буферами не относятся к минибуферам. Имя минибуфера всегда имеет вид '</target>
        </trans-unit>
        <trans-unit id="2561cd793393aff7d27fa03dc11a09e0ffcec475" translate="yes" xml:space="preserve">
          <source>In one special case, &lt;var&gt;pos-or-area&lt;/var&gt; is a list containing a symbol (one of the symbols listed above) instead of just the symbol. This happens after the imaginary prefix keys for the event are registered by Emacs. See &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;.</source>
          <target state="translated">В одном особом случае &lt;var&gt;pos-or-area&lt;/var&gt; - это список, содержащий символ (один из символов, перечисленных выше), а не только символ. Это происходит после того, как Emacs регистрирует воображаемые префиксные ключи для события. См. &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Ввод последовательности клавиш&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40058b1b79d94d51db03317b307ab30a9e089207" translate="yes" xml:space="preserve">
          <source>In order for a symbol to be an error symbol, it must be defined with &lt;code&gt;define-error&lt;/code&gt; which takes a parent condition (defaults to &lt;code&gt;error&lt;/code&gt;). This parent defines the conditions that this kind of error belongs to. The transitive set of parents always includes the error symbol itself, and the symbol &lt;code&gt;error&lt;/code&gt;. Because quitting is not considered an error, the set of parents of &lt;code&gt;quit&lt;/code&gt; is just &lt;code&gt;(quit)&lt;/code&gt;.</source>
          <target state="translated">Чтобы символ был символом ошибки, он должен быть определен с помощью &lt;code&gt;define-error&lt;/code&gt; , которая принимает родительское условие (по умолчанию &lt;code&gt;error&lt;/code&gt; ). Этот родитель определяет условия, которым принадлежит этот вид ошибки. Переходный набор родителей всегда включает в себя сам символ &lt;code&gt;error&lt;/code&gt; и символ ошибки . Поскольку выход не считается ошибкой, набор родительских элементов для &lt;code&gt;quit&lt;/code&gt; - это просто &lt;code&gt;(quit)&lt;/code&gt; выход ) .</target>
        </trans-unit>
        <trans-unit id="42862e17fb0b9045574c0488aeeff987c7b035ab" translate="yes" xml:space="preserve">
          <source>In order for compilation of macro calls to work, the macros must already be defined in Lisp when the calls to them are compiled. The compiler has a special feature to help you do this: if a file being compiled contains a &lt;code&gt;defmacro&lt;/code&gt; form, the macro is defined temporarily for the rest of the compilation of that file.</source>
          <target state="translated">Чтобы компиляция вызовов макросов работала, макросы уже должны быть определены в Lisp, когда вызовы к ним компилируются. У компилятора есть специальная функция, которая поможет вам в этом: если компилируемый файл содержит форму &lt;code&gt;defmacro&lt;/code&gt; , макрос определяется временно для остальной части компиляции этого файла.</target>
        </trans-unit>
        <trans-unit id="007cc651440219a61408c3deac9dfe41920a80bf" translate="yes" xml:space="preserve">
          <source>In order to extract the local part of the file&amp;rsquo;s name of a temporary file, use &lt;code&gt;file-local-name&lt;/code&gt; (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;).</source>
          <target state="translated">Чтобы извлечь локальную часть имени временного файла, используйте &lt;code&gt;file-local-name&lt;/code&gt; (см. &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Волшебные имена файлов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="02b3ec04225a3187705865de19dd49a2f10d82cd" translate="yes" xml:space="preserve">
          <source>In order to find out which window or frame was selected the last time window change functions were run, the following functions can be used:</source>
          <target state="translated">Для того чтобы узнать,какое окно или кадр был выбран при последнем запуске функций смены окна,можно воспользоваться следующими функциями:</target>
        </trans-unit>
        <trans-unit id="4aa759b30fc1bac4367e22f29f78fa95acabc797" translate="yes" xml:space="preserve">
          <source>In order to give a child frame a draggable header or mode line, the window parameters &lt;code&gt;mode-line-format&lt;/code&gt; and &lt;code&gt;header-line-format&lt;/code&gt; are handy (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;). These allow to remove an unwanted mode line (when &lt;code&gt;drag-with-header-line&lt;/code&gt; is chosen) and to remove mouse-sensitive areas which might interfere with frame dragging.</source>
          <target state="translated">Чтобы дать дочернему фрейму перетаскиваемый заголовок или строку режима, удобны параметры окна &lt;code&gt;mode-line-format&lt;/code&gt; и &lt;code&gt;header-line-format&lt;/code&gt; (см. &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Параметры окна&lt;/a&gt; ). Это позволяет удалить нежелательную строку режима (когда выбрано &lt;code&gt;drag-with-header-line&lt;/code&gt; ) и удалить чувствительные к мыши области, которые могут мешать перетаскиванию кадра.</target>
        </trans-unit>
        <trans-unit id="3a1da75035de559e954ff07f12d67704d95cfb68" translate="yes" xml:space="preserve">
          <source>In order to prevent the hook functions from being called more than once for the same part of the buffer, you can use the variable &lt;code&gt;buffer-access-fontified-property&lt;/code&gt;.</source>
          <target state="translated">Чтобы предотвратить &lt;code&gt;buffer-access-fontified-property&lt;/code&gt; функций ловушки для одной и той же части буфера, вы можете использовать переменную buffer-access-fontified-property .</target>
        </trans-unit>
        <trans-unit id="ce8866ba225f4a0e162725c09d5505ceaec41ba9" translate="yes" xml:space="preserve">
          <source>In order to see how this new, modified form works, delete any frame showing</source>
          <target state="translated">Чтобы посмотреть,как работает эта новая,измененная форма,удалите любой кадр,показывающий</target>
        </trans-unit>
        <trans-unit id="25d21175a564e227d0d2be93a38559526ba4e991" translate="yes" xml:space="preserve">
          <source>In order to use Edebug to debug Lisp code, you must first &lt;em&gt;instrument&lt;/em&gt; the code. Instrumenting code inserts additional code into it, to invoke Edebug at the proper places.</source>
          <target state="translated">Чтобы использовать Edebug для отладки кода Lisp, вы должны сначала &lt;em&gt;инструментировать&lt;/em&gt; код. Инструментальный код вставляет в него дополнительный код для вызова Edebug в нужных местах.</target>
        </trans-unit>
        <trans-unit id="fe0db91a5b392657a0aca17c10f50da256d748a3" translate="yes" xml:space="preserve">
          <source>In ordinary usage, the difference between simple packages and multi-file packages is relatively unimportant; the Package Menu interface makes no distinction between them. However, the procedure for creating them differs, as explained in the following sections.</source>
          <target state="translated">При обычном использовании разница между простыми пакетами и многофайловыми пакетами относительно несущественна;интерфейс меню пакетов не делает различий между ними.Однако,процедура их создания отличается,как это объясняется в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="4049b50b43320603134b658569956160c5b33eec" translate="yes" xml:space="preserve">
          <source>In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object&amp;rsquo;s read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.</source>
          <target state="translated">В других языках выражение - это текст; у него нет другой формы. В Лиспе выражение - это в первую очередь объект Лисп и только во вторую очередь текст, являющийся синтаксисом чтения объекта. Часто нет необходимости подчеркивать это различие, но вы должны помнить об этом, иначе вы иногда будете сильно сбиты с толку.</target>
        </trans-unit>
        <trans-unit id="b28e79f39397b0edb42bffc1a990b7fa7d5f45bc" translate="yes" xml:space="preserve">
          <source>In other words, after the end of a group, the matcher remembers the beginning and end of the text matched by that group. Later on in the regular expression you can use &amp;lsquo;</source>
          <target state="translated">Другими словами, после окончания группы сопоставитель запоминает начало и конец текста, сопоставленного этой группой. Позже в регулярном выражении вы можете использовать '</target>
        </trans-unit>
        <trans-unit id="73dca98bad9f727764c940e829d2b4567f5194c0" translate="yes" xml:space="preserve">
          <source>In other words, the string character with the &lt;code&gt;cursor&lt;/code&gt; property of any non-&lt;code&gt;nil&lt;/code&gt; value is the character where to display the cursor. The value of the property says for which buffer positions to display the cursor there. If the value is an integer &lt;var&gt;n&lt;/var&gt;, the cursor is displayed there when point is anywhere between the beginning of the overlay or &lt;code&gt;display&lt;/code&gt; property and &lt;var&gt;n&lt;/var&gt; positions after that. If the value is anything else and non-&lt;code&gt;nil&lt;/code&gt;, the cursor is displayed there only when point is at the beginning of the &lt;code&gt;display&lt;/code&gt; property or at &lt;code&gt;overlay-start&lt;/code&gt;.</source>
          <target state="translated">Другими словами, строковый символ со свойством &lt;code&gt;cursor&lt;/code&gt; любого &lt;code&gt;nil&lt;/code&gt; значения является символом, на котором отображается курсор. Значение свойства говорит, в каких положениях буфера нужно отображать курсор. Если значение является целым числом &lt;var&gt;n&lt;/var&gt; , курсор отображается там, когда точка находится в любом месте между началом наложения или свойства &lt;code&gt;display&lt;/code&gt; и &lt;var&gt;n&lt;/var&gt; позициями после этого. Если значением является любое другое значение, отличное от &lt;code&gt;nil&lt;/code&gt; , курсор отображается там только тогда, когда точка находится в начале свойства &lt;code&gt;display&lt;/code&gt; или в &lt;code&gt;overlay-start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="342b05b7073d64e941e7a9180ce0ab73ce5d1977" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;delete-windows-on&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) handles case (2) by deleting the associated frame and case (3) by showing another buffer in that frame&amp;rsquo;s only window. The function &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; (see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;) which is called when a buffer gets killed, deletes the window in case (1) and behaves like &lt;code&gt;delete-windows-on&lt;/code&gt; otherwise.</source>
          <target state="translated">В частности, &lt;code&gt;delete-windows-on&lt;/code&gt; (см. &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Удаление Windows&lt;/a&gt; ) обрабатывает case (2), удаляя связанный фрейм, и case (3), показывая другой буфер в единственном окне этого фрейма. Функция &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; (см. &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Буферы и Windows&lt;/a&gt; ), которая вызывается, когда буфер уничтожается, удаляет окно в случае (1) и &lt;code&gt;delete-windows-on&lt;/code&gt; противном случае ведет себя как delete-windows-on .</target>
        </trans-unit>
        <trans-unit id="ae990d311270dc72ee6facabe1f2c786eb8e3f14" translate="yes" xml:space="preserve">
          <source>In particular, mutating the returned value may inadvertently change another string, alter a constant string in the program, or even raise an error. To obtain a string that you can safely mutate, use &lt;code&gt;copy-sequence&lt;/code&gt; on the result.</source>
          <target state="translated">В частности, изменение возвращаемого значения может непреднамеренно изменить другую строку, изменить постоянную строку в программе или даже вызвать ошибку. Чтобы получить строку, которую можно безопасно изменить, используйте &lt;code&gt;copy-sequence&lt;/code&gt; для результата.</target>
        </trans-unit>
        <trans-unit id="d8c72f894595d295da4116cddb04e4987b994ba0" translate="yes" xml:space="preserve">
          <source>In particular, under X (but not when building with GTK+), the frame&amp;rsquo;s outer border can be used. On MS-Windows, specifying a non-zero outer border width will show a one-pixel wide external border. Under all window-systems, the internal border can be used. In either case, it&amp;rsquo;s advisable to disable a child frame&amp;rsquo;s window manager decorations with the &lt;code&gt;undecorated&lt;/code&gt; frame parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">В частности, под X (но не при построении с помощью GTK +) может использоваться внешняя граница фрейма. В MS-Windows при указании ненулевой ширины внешней границы будет отображаться внешняя граница шириной в один пиксель. Под все оконные системы можно использовать внутреннюю рамку. В любом случае рекомендуется отключить оформление оконного менеджера дочернего фрейма с помощью параметра кадра &lt;code&gt;undecorated&lt;/code&gt; (см. &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Параметры управления&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="785c848b7a9c76188153b98dc766e9eee3d7f299" translate="yes" xml:space="preserve">
          <source>In practice not all of the areas shown in the drawing will or may be present. The meaning of these areas is described below.</source>
          <target state="translated">На практике не все области,показанные на рисунке,будут или могут присутствовать.Значение этих областей описано ниже.</target>
        </trans-unit>
        <trans-unit id="1a24ae50708083315e6e5d71edf56c47415c18d3" translate="yes" xml:space="preserve">
          <source>In practice this means that &lt;code&gt;display-buffer&lt;/code&gt; builds a list of all action functions specified by these display actions. The first element of this list is the first action function specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, if any. Its last element is &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt;&amp;mdash;the last action function specified by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;. Duplicates are not removed from this list&amp;mdash;hence one and the same action function may be called multiple times during one call of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">На практике это означает, что &lt;code&gt;display-buffer&lt;/code&gt; строит список всех функций действий, определенных этими действиями display. Первый элемент этого списка - первая функция действия, заданная параметром &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; , если таковой имеется. Его последний элемент - &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; - последняя функция действия, заданная параметром &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; . Дубликаты не удаляются из этого списка - следовательно, одна и та же функция действия может быть вызвана несколько раз за один вызов &lt;code&gt;display-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="069dde31ed88efd7662427ed0d83c24aecd85cef" translate="yes" xml:space="preserve">
          <source>In practice, most &amp;lsquo;</source>
          <target state="translated">На практике большинство</target>
        </trans-unit>
        <trans-unit id="dff22f2148342d55185406b93857c7cd707282f3" translate="yes" xml:space="preserve">
          <source>In practice, nearly all functions have names, and are referred to by their names. You can create a named Lisp function by defining a lambda expression and putting it in a function cell (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;). However, it is more common to use the &lt;code&gt;defun&lt;/code&gt; special form, described in the next section. See &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;.</source>
          <target state="translated">На практике почти все функции имеют имена и называются по их именам. Вы можете создать именованную функцию Lisp, определив лямбда-выражение и поместив его в ячейку функции (см. &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Ячейки функции&lt;/a&gt; ). Однако чаще используется специальная форма &lt;code&gt;defun&lt;/code&gt; , описанная в следующем разделе. См. &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Определение функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2ec4dd56177cba6f1cdca6d305d727013f82bc9" translate="yes" xml:space="preserve">
          <source>In practice, you can usually use the text property search functions in place of explicit interval boundaries. You can think of them as finding the boundaries of intervals, assuming that intervals are always coalesced whenever possible. See &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;.</source>
          <target state="translated">На практике вы обычно можете использовать функции поиска текстовых свойств вместо явных границ интервала. Вы можете думать о них как о нахождении границ интервалов, предполагая, что интервалы всегда объединяются, когда это возможно. См. &lt;a href=&quot;property-search#Property-Search&quot;&gt;Поиск недвижимости&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="595414a18f0f6814ac8aec499699ba0cadf3010e" translate="yes" xml:space="preserve">
          <source>In principle, if you want an array of text characters, you could use either a string or a vector. In practice, we always choose strings for such applications, for four reasons:</source>
          <target state="translated">В принципе,если Вам нужен массив текстовых символов,Вы можете использовать как строку,так и вектор.На практике мы всегда выбираем строки для таких приложений по четырем причинам:</target>
        </trans-unit>
        <trans-unit id="952a69bffe57014633d87ea51d91051b5c23b497" translate="yes" xml:space="preserve">
          <source>In principle, you can assign a variable value to any symbol with &lt;code&gt;setq&lt;/code&gt;, whether or not it has first been defined as a variable. However, you ought to write a variable definition for each global variable that you want to use; otherwise, your Lisp program may not act correctly if it is evaluated with lexical scoping enabled (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;).</source>
          <target state="translated">В принципе, вы можете присвоить значение переменной любому символу с помощью &lt;code&gt;setq&lt;/code&gt; , независимо от того, был ли он сначала определен как переменная. Однако вам следует написать определение переменной для каждой глобальной переменной, которую вы хотите использовать; в противном случае ваша программа на Лиспе может работать некорректно, если она оценивается с включенной лексической областью видимости (см. &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Определение&lt;/a&gt; области видимости переменной ).</target>
        </trans-unit>
        <trans-unit id="59a81a18a5d27bbbef59498c3ff3190989d0d540" translate="yes" xml:space="preserve">
          <source>In short, a keymap entry may be a keymap, a command, a keyboard macro, a symbol that leads to one of them, or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Короче говоря, запись раскладки клавиатуры может быть раскладкой клавиатуры, командой, макросом клавиатуры, символом, который ведет к одному из них, или &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64a6416d90974dbdcf9b5cf8181346f0fcaef6ea" translate="yes" xml:space="preserve">
          <source>In simple cases, all you need to specify is the mapping to lower-case; the three related tables will be calculated automatically from that one.</source>
          <target state="translated">В простых случаях все,что вам нужно указать,это привязка к нижнему регистру;три связанные с ним таблицы будут вычислены автоматически из этой таблицы.</target>
        </trans-unit>
        <trans-unit id="ca3f716cf86956eff115da7250837a9a9ae0da62" translate="yes" xml:space="preserve">
          <source>In some cases, a leading &amp;lsquo;</source>
          <target state="translated">В некоторых случаях ведущий '</target>
        </trans-unit>
        <trans-unit id="51c6be916769f1ca362110d817b3845ee05a7c40" translate="yes" xml:space="preserve">
          <source>In some cases, it is important to control the relative ordering of functions on the hook. The optional argument &lt;var&gt;depth&lt;/var&gt; lets you indicate where the function should be inserted in the list: it should then be a number between -100 and 100 where the higher the value, the closer to the end of the list the function should go. The &lt;var&gt;depth&lt;/var&gt; defaults to 0 and for backward compatibility when &lt;var&gt;depth&lt;/var&gt; is a non-nil symbol it is interpreted as a depth of 90. Furthermore, when &lt;var&gt;depth&lt;/var&gt; is strictly greater than 0 the function is added &lt;em&gt;after&lt;/em&gt; rather than before functions of the same depth. One should never use a depth of 100 (or -100), because one can never be sure that no other function will ever need to come before (or after) us.</source>
          <target state="translated">В некоторых случаях важно контролировать относительный порядок функций на хуке. Необязательный аргумент &lt;var&gt;depth&lt;/var&gt; позволяет указать, где функция должна быть вставлена ​​в список: тогда это должно быть число от -100 до 100, где чем выше значение, тем ближе к концу списка должна идти функция. В &lt;var&gt;depth&lt;/var&gt; по умолчанию 0 и для обратной совместимости , когда &lt;var&gt;depth&lt;/var&gt; не является нулевым символом он интерпретируется как глубина 90. Кроме того, когда &lt;var&gt;depth&lt;/var&gt; строго больше , чем 0 , то функция добавляется &lt;em&gt;после&lt;/em&gt; , а не до того функций одной и той же глубины. Никогда не следует использовать глубину 100 (или -100), потому что никогда нельзя быть уверенным, что никакая другая функция никогда не будет выполняться до (или после) нас.</target>
        </trans-unit>
        <trans-unit id="65dfdc7d279aaa17d921d1528c2b2fe56c2c0a4d" translate="yes" xml:space="preserve">
          <source>In some cases, text lines are truncated on the screen rather than continued onto additional screen lines. In these cases, &lt;code&gt;vertical-motion&lt;/code&gt; moves point much like &lt;code&gt;forward-line&lt;/code&gt;. See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">В некоторых случаях текстовые строки обрезаются на экране, а не продолжаются на дополнительных строках экрана. В этих случаях &lt;code&gt;vertical-motion&lt;/code&gt; перемещает точку так же, как &lt;code&gt;forward-line&lt;/code&gt; . См. &lt;a href=&quot;truncation#Truncation&quot;&gt;Усечение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4582e0d4f2cc8e2368ad7a2f683a1a7484ac075b" translate="yes" xml:space="preserve">
          <source>In some cases, the option is followed in the command line by an argument. In these cases, the &lt;var&gt;handler-function&lt;/var&gt; can find all the remaining command-line arguments in the variable &lt;code&gt;command-line-args-left&lt;/code&gt; (see below). (The entire list of command-line arguments is in &lt;code&gt;command-line-args&lt;/code&gt;.)</source>
          <target state="translated">В некоторых случаях за параметром в командной строке следует аргумент. В этих случаях &lt;var&gt;handler-function&lt;/var&gt; может найти все оставшиеся аргументы командной строки в переменной &lt;code&gt;command-line-args-left&lt;/code&gt; (см. Ниже). (Полный список аргументов командной строки находится в &lt;code&gt;command-line-args&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="878c8864da92eab3f1063c3c626126be65624841" translate="yes" xml:space="preserve">
          <source>In some configurations, Emacs cannot display a real dialog box; so instead it displays the same items in a pop-up menu in the center of the frame.</source>
          <target state="translated">В некоторых конфигурациях Emacs не может отобразить реальное диалоговое окно,поэтому вместо этого он отображает те же самые элементы во всплывающем меню в центре кадра.</target>
        </trans-unit>
        <trans-unit id="4e6989e3c48ebc292a0fb0be926a8320dfd01322" translate="yes" xml:space="preserve">
          <source>In some functions (such as &lt;code&gt;read-quoted-char&lt;/code&gt;),</source>
          <target state="translated">В некоторых функциях (например, &lt;code&gt;read-quoted-char&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="623f15e33a88f6fded6d8865aae03ac806476d9f" translate="yes" xml:space="preserve">
          <source>In some ways, the Button package duplicates the functionality in the Widget package. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</source>
          <target state="translated">В некотором смысле пакет Button дублирует функциональность пакета Widget. См. &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Введение&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="56e23b6ebee018ae84e4594f62dc43eca78b4394" translate="yes" xml:space="preserve">
          <source>In strings and buffers, the only control characters allowed are those that exist in</source>
          <target state="translated">В строках и буферах разрешены только те управляющие символы,которые существуют в</target>
        </trans-unit>
        <trans-unit id="0183eea7f0857fe25abe600463b2305c9ae8752b" translate="yes" xml:space="preserve">
          <source>In subsequent sections, we will describe the details of what evaluation means for each kind of form.</source>
          <target state="translated">В последующих разделах мы подробно опишем,что означает оценка для каждого вида формы.</target>
        </trans-unit>
        <trans-unit id="a57836ad148b9af16d39bd5e1f715466141037f4" translate="yes" xml:space="preserve">
          <source>In that case, the anonymous function is kept as a lambda expression in the compiled code. The byte-compiler cannot assume this list is a function, even though it looks like one, since it does not know that &lt;code&gt;change-property&lt;/code&gt; intends to use it as a function.</source>
          <target state="translated">В этом случае анонимная функция сохраняется как лямбда-выражение в скомпилированном коде. Байт-компилятор не может предположить, что этот список является функцией, даже если он выглядит как таковая, поскольку он не знает, что &lt;code&gt;change-property&lt;/code&gt; намеревается использовать его как функцию.</target>
        </trans-unit>
        <trans-unit id="b6abefb0ebc02351d5d08f8505d9c39811bfa807" translate="yes" xml:space="preserve">
          <source>In the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc52d935c1f29304f640ff4f787b205caeb68ac4" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;rx&lt;/code&gt; notation (see &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt;), the regexp could be written</source>
          <target state="translated">В обозначении &lt;code&gt;rx&lt;/code&gt; (см. &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Обозначение Rx&lt;/a&gt; ) регулярное выражение можно было бы записать</target>
        </trans-unit>
        <trans-unit id="edf58eb540efa82d8a13378501011be853119a74" translate="yes" xml:space="preserve">
          <source>In the above example, the index for &amp;lsquo;</source>
          <target state="translated">В приведенном выше примере индекс для '</target>
        </trans-unit>
        <trans-unit id="e3f6d7d410589a0987a82033d6841e21fcb99c48" translate="yes" xml:space="preserve">
          <source>In the above pseudo-code, if a key sequence starts with a mouse event (see &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;), that event&amp;rsquo;s position is used instead of point, and the event&amp;rsquo;s buffer is used instead of the current buffer. In particular, this affects how the &lt;code&gt;keymap&lt;/code&gt; and &lt;code&gt;local-map&lt;/code&gt; properties are looked up. If a mouse event occurs on a string embedded with a &lt;code&gt;display&lt;/code&gt;, &lt;code&gt;before-string&lt;/code&gt;, or &lt;code&gt;after-string&lt;/code&gt; property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;), and the string has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;keymap&lt;/code&gt; or &lt;code&gt;local-map&lt;/code&gt; property, that overrides the corresponding property in the underlying buffer text (i.e., the property specified by the underlying text is ignored).</source>
          <target state="translated">В приведенном выше псевдокоде, если последовательность клавиш начинается с события мыши (см. &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;События мыши&lt;/a&gt; ), позиция этого события используется вместо точки, а буфер события используется вместо текущего буфера. В частности, это влияет на то, как &lt;code&gt;keymap&lt;/code&gt; свойства раскладки клавиатуры и &lt;code&gt;local-map&lt;/code&gt; . Если событие мыши происходит в строке, встроенной со свойством &lt;code&gt;display&lt;/code&gt; , &lt;code&gt;before-string&lt;/code&gt; или &lt;code&gt;after-string&lt;/code&gt; (см. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&lt;/a&gt; ), и строка имеет &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;keymap&lt;/code&gt; или &lt;code&gt;local-map&lt;/code&gt; свойство, которое переопределяет соответствующее свойство в тексте базового буфера (т. е. свойство, указанное в базовом тексте, игнорируется).</target>
        </trans-unit>
        <trans-unit id="27631bf78c7ae4e923152b090765e541b19e5a80" translate="yes" xml:space="preserve">
          <source>In the case of lexical bindings (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;), a closure is an object like any other in Emacs Lisp, and bindings in a closure are shared by any threads invoking the closure.</source>
          <target state="translated">В случае лексических привязок (см. &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Область видимости переменных&lt;/a&gt; ) замыкание - это такой же объект, как и любой другой в Emacs Lisp, и привязки в замыкании используются всеми потоками, вызывающими замыкание.</target>
        </trans-unit>
        <trans-unit id="59e0cecfabf4546ad2f48ca811a7e72617ebf6dd" translate="yes" xml:space="preserve">
          <source>In the customization buffer, each element is displayed and edited separately, according to the type specified for it.</source>
          <target state="translated">В буфере настроек каждый элемент отображается и редактируется отдельно,в соответствии с указанным для него типом.</target>
        </trans-unit>
        <trans-unit id="b31bdf79753cfe29ec8e26d6c3395cd18ae6e0a8" translate="yes" xml:space="preserve">
          <source>In the customization buffer, the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; are displayed and edited separately, each according to their specified type.</source>
          <target state="translated">В буфере настройки &lt;small&gt;CAR&lt;/small&gt; и &lt;small&gt;CDR&lt;/small&gt; отображаются и редактируются отдельно, каждый в соответствии с их указанным типом.</target>
        </trans-unit>
        <trans-unit id="794a81a94829a19492d4fef3897a2f66fd03bedc" translate="yes" xml:space="preserve">
          <source>In the customization buffer, the user selects an alternative using a menu, and can then edit the value in the usual way for that alternative.</source>
          <target state="translated">В буфере настроек пользователь выбирает альтернативу с помощью меню,а затем может редактировать значение обычным для этой альтернативы способом.</target>
        </trans-unit>
        <trans-unit id="77d73a55a4ef46351e5ba12b487904babc3187bd" translate="yes" xml:space="preserve">
          <source>In the documentation string of an autoloaded command (see &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;), these key-substitution sequences have an additional special effect: they cause</source>
          <target state="translated">В строке документации автоматически загружаемой команды (см. &lt;a href=&quot;autoload#Autoload&quot;&gt;Автозагрузка&lt;/a&gt; ) эти последовательности подстановки ключей имеют дополнительный специальный эффект: они вызывают</target>
        </trans-unit>
        <trans-unit id="a60a213b91a605f64eb22b1f3ba89d0650b4a400" translate="yes" xml:space="preserve">
          <source>In the early days of Lisp, &lt;code&gt;progn&lt;/code&gt; was the only way to execute two or more forms in succession and use the value of the last of them. But programmers found they often needed to use a &lt;code&gt;progn&lt;/code&gt; in the body of a function, where (at that time) only one form was allowed. So the body of a function was made into an implicit &lt;code&gt;progn&lt;/code&gt;: several forms are allowed just as in the body of an actual &lt;code&gt;progn&lt;/code&gt;. Many other control structures likewise contain an implicit &lt;code&gt;progn&lt;/code&gt;. As a result, &lt;code&gt;progn&lt;/code&gt; is not used as much as it was many years ago. It is needed now most often inside an &lt;code&gt;unwind-protect&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, or in the &lt;var&gt;then&lt;/var&gt;-part of an &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">На &lt;code&gt;progn&lt;/code&gt; Лиспа progn был единственным способом выполнить две или более форм подряд и использовать значение последней из них. Но программисты обнаружили, что им часто нужно использовать &lt;code&gt;progn&lt;/code&gt; в теле функции, где (в то время) была разрешена только одна форма. Таким образом, тело функции было превращено в неявный &lt;code&gt;progn&lt;/code&gt; : разрешены несколько форм, как и в теле реального &lt;code&gt;progn&lt;/code&gt; . Многие другие управляющие структуры также содержат неявный &lt;code&gt;progn&lt;/code&gt; . В результате &lt;code&gt;progn&lt;/code&gt; не используется так часто, как это было много лет назад. Он нужен сейчас чаще всего внутри &lt;code&gt;unwind-protect&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , или в &lt;var&gt;then&lt;/var&gt; -часть &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7158787e9fd5c853d586cfa0e51a5ed11d6bcd94" translate="yes" xml:space="preserve">
          <source>In the example below,</source>
          <target state="translated">В примере ниже,</target>
        </trans-unit>
        <trans-unit id="6ae41878d5c3d4986d366e49c3e9a986cae7e077" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;fixup-whitespace&lt;/code&gt; is called the first time with point before the word &amp;lsquo;</source>
          <target state="translated">В приведенном ниже примере &lt;code&gt;fixup-whitespace&lt;/code&gt; вызывается в первый раз с точкой перед словом '</target>
        </trans-unit>
        <trans-unit id="1159bcac76d9d797434640f0fdc5e48f8f16f786" translate="yes" xml:space="preserve">
          <source>In the example below, point is located on the line starting &amp;lsquo;</source>
          <target state="translated">В примере ниже точка находится на линии, начинающейся '</target>
        </trans-unit>
        <trans-unit id="41e79dffa91b26c5c432c03364763e538453a3a0" translate="yes" xml:space="preserve">
          <source>In the example below, the Lisp program reads the character</source>
          <target state="translated">В примере ниже программа Lisp читает символ</target>
        </trans-unit>
        <trans-unit id="6c6b370e3f7d29753468f7d7c39505a6457cb137" translate="yes" xml:space="preserve">
          <source>In the example below, the first process is started and runs (rather, sleeps) for 100 seconds (the output buffer &amp;lsquo;</source>
          <target state="translated">В приведенном ниже примере первый процесс запускается и работает (скорее, спит) в течение 100 секунд (выходной буфер '</target>
        </trans-unit>
        <trans-unit id="2cbe7de5e5f4171a8b0909e3ea37d9411601b61f" translate="yes" xml:space="preserve">
          <source>In the example below, the returned alist indicates that the key</source>
          <target state="translated">В примере,приведенном ниже,возвращаемый список указывает на то,что ключ</target>
        </trans-unit>
        <trans-unit id="21f639f7916c0989e45d99b6f8d95bb479e2a7dc" translate="yes" xml:space="preserve">
          <source>In the examples below, imagine that you&amp;rsquo;re in a buffer that looks like this:</source>
          <target state="translated">В приведенных ниже примерах представьте, что вы находитесь в буфере, который выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="45cdf70211c7a85bbbe2f457d2d568784938c5c8" translate="yes" xml:space="preserve">
          <source>In the examples below, the buffer &amp;lsquo;</source>
          <target state="translated">В приведенных ниже примерах буфер '</target>
        </trans-unit>
        <trans-unit id="50c103b8760cb1abed49a28229f31f25093e7fe2" translate="yes" xml:space="preserve">
          <source>In the examples below, we show the &lt;em&gt;display appearance&lt;/em&gt; of the buffer &lt;code&gt;foo&lt;/code&gt;, which changes with the value of &lt;code&gt;selective-display&lt;/code&gt;. The &lt;em&gt;contents&lt;/em&gt; of the buffer do not change.</source>
          <target state="translated">В примерах ниже мы показываем &lt;em&gt;внешний вид отображения&lt;/em&gt; буфера &lt;code&gt;foo&lt;/code&gt; , который изменяется в зависимости от значения &lt;code&gt;selective-display&lt;/code&gt; . В &lt;em&gt;содержимом&lt;/em&gt; буфере не изменятся.</target>
        </trans-unit>
        <trans-unit id="8d8e5189aaefce12f30329357296c95e61a38bdb" translate="yes" xml:space="preserve">
          <source>In the first example below, the user types the character</source>
          <target state="translated">В первом примере ниже пользователь вводит символ</target>
        </trans-unit>
        <trans-unit id="1bcb5b6f5d8b3ef6f45f427e9e77f07309f79243" translate="yes" xml:space="preserve">
          <source>In the first of the following examples, the string &amp;lsquo;</source>
          <target state="translated">В первом из следующих примеров строка '</target>
        </trans-unit>
        <trans-unit id="8d216f0c7f12baf6cd4ed80a6b27ab324e470109" translate="yes" xml:space="preserve">
          <source>In the first part of the following example, we list two files,</source>
          <target state="translated">В первой части следующего примера мы перечислили два файла,</target>
        </trans-unit>
        <trans-unit id="acff65f1c9d9496c4b122331f3a702dc9fa85418" translate="yes" xml:space="preserve">
          <source>In the following documentation, &lt;var&gt;spec&lt;/var&gt; refers to a data layout specification, &lt;code&gt;bindat-raw&lt;/code&gt; to a byte array, and &lt;var&gt;struct&lt;/var&gt; to an alist representing unpacked field data.</source>
          <target state="translated">В следующей документации &lt;var&gt;spec&lt;/var&gt; относится к спецификации компоновки данных, &lt;code&gt;bindat-raw&lt;/code&gt; - к байтовому массиву, а &lt;var&gt;struct&lt;/var&gt; - к списку, представляющему распакованные данные поля.</target>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="translated">В следующем примере,</target>
        </trans-unit>
        <trans-unit id="e2316694a9af81a8f03d3bab0408009a0c338429" translate="yes" xml:space="preserve">
          <source>In the following example, Emacs displays the prompt &amp;lsquo;</source>
          <target state="translated">В следующем примере Emacs отображает приглашение '</target>
        </trans-unit>
        <trans-unit id="4a721fdb8420736a6ae7cc10bb2e34400e9c7e6d" translate="yes" xml:space="preserve">
          <source>In the following example, a Lisp expression calls &lt;code&gt;backtrace&lt;/code&gt; explicitly. This prints the backtrace to the stream &lt;code&gt;standard-output&lt;/code&gt;, which, in this case, is the buffer &amp;lsquo;</source>
          <target state="translated">В следующем примере выражение на Лиспе явно вызывает &lt;code&gt;backtrace&lt;/code&gt; . Это печатает обратную трассировку в поток &lt;code&gt;standard-output&lt;/code&gt; , который в данном случае является буфером '</target>
        </trans-unit>
        <trans-unit id="95ec3b70ec2b6de3a44a863ec7979700ca8528bc" translate="yes" xml:space="preserve">
          <source>In the following example, assume that the file</source>
          <target state="translated">В следующем примере предположим,что файл</target>
        </trans-unit>
        <trans-unit id="d4d9cd6735838e19fca58cfa4e5f227b1e63a68a" translate="yes" xml:space="preserve">
          <source>In the following example, assume that the first character in the buffer is &amp;lsquo;</source>
          <target state="translated">В следующем примере предположим, что первый символ в буфере - '</target>
        </trans-unit>
        <trans-unit id="cbbae18ed437d3d1b7cd3f29fa619c133fefd3c5" translate="yes" xml:space="preserve">
          <source>In the following example, numerous symbols begin with the characters &amp;lsquo;</source>
          <target state="translated">В следующем примере многочисленные символы начинаются с символов '</target>
        </trans-unit>
        <trans-unit id="1d8315041ff8cb6c06515b158189a3073ed152cc" translate="yes" xml:space="preserve">
          <source>In the following example, point is at the beginning of the second line:</source>
          <target state="translated">В следующем примере точка находится в начале второй линии:</target>
        </trans-unit>
        <trans-unit id="42ecbf1ba17019105911ffebbbf6edf40624a688" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially at the beginning of the line. Then &lt;code&gt;(search-forward &quot;fox&quot;)&lt;/code&gt; moves point after the last letter of &amp;lsquo;</source>
          <target state="translated">В следующем примере точка изначально находится в начале строки. Затем &lt;code&gt;(search-forward &quot;fox&quot;)&lt;/code&gt; перемещает точку после последней буквы '</target>
        </trans-unit>
        <trans-unit id="4e4648a8ef8c97faf71ce36a2f1da992a66ce66a" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially before the &amp;lsquo;</source>
          <target state="translated">В следующем примере точка изначально стоит перед '</target>
        </trans-unit>
        <trans-unit id="998eebc83fc288fc771f6a8b8a1d104df394fe25" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially located directly before the &amp;lsquo;</source>
          <target state="translated">В следующем примере точка изначально расположена непосредственно перед символом '</target>
        </trans-unit>
        <trans-unit id="222a580e4261f699fc64318a04a2725d2450a74c" translate="yes" xml:space="preserve">
          <source>In the following example, suppose that</source>
          <target state="translated">В следующем примере предположим,что</target>
        </trans-unit>
        <trans-unit id="c4a412b551b194333428c49302d54e094323961e" translate="yes" xml:space="preserve">
          <source>In the following example, suppose that the current default directory has five files whose names begin with &amp;lsquo;</source>
          <target state="translated">В следующем примере предположим, что в текущем каталоге по умолчанию есть пять файлов, имена которых начинаются с '</target>
        </trans-unit>
        <trans-unit id="5723aa0ef8724a536d5900f5c59be1d86438116d" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;(list 4)&lt;/code&gt; that &lt;code&gt;delq&lt;/code&gt; attempts to match and the &lt;code&gt;(4)&lt;/code&gt; in the &lt;code&gt;sample-list&lt;/code&gt; are &lt;code&gt;equal&lt;/code&gt; but not &lt;code&gt;eq&lt;/code&gt;:</source>
          <target state="translated">В следующем примере &lt;code&gt;(list 4)&lt;/code&gt; , что &lt;code&gt;delq&lt;/code&gt; попытки соответствовать и &lt;code&gt;(4)&lt;/code&gt; в &lt;code&gt;sample-list&lt;/code&gt; являются &lt;code&gt;equal&lt;/code&gt; , но не &lt;code&gt;eq&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="49c3d7898ccead7f82ec14a83d5c284abbacaed2" translate="yes" xml:space="preserve">
          <source>In the following example, the function &lt;code&gt;simple-rec&lt;/code&gt; first advances point one word, then enters a recursive edit, printing out a message in the echo area. The user can then do any editing desired, and then type</source>
          <target state="translated">В следующем примере функция &lt;code&gt;simple-rec&lt;/code&gt; сначала продвигает точку на одно слово, затем входит в рекурсивное редактирование, распечатывая сообщение в эхо-области. Затем пользователь может выполнить любое желаемое редактирование, а затем ввести</target>
        </trans-unit>
        <trans-unit id="bdd55f89db54776fce5243ffc69b1e9e59acdf44" translate="yes" xml:space="preserve">
          <source>In the following example, the user enters &amp;lsquo;</source>
          <target state="translated">В следующем примере пользователь вводит &quot;</target>
        </trans-unit>
        <trans-unit id="7407d41abc6236fc89ae0cd2ce1bcece190e1422" translate="yes" xml:space="preserve">
          <source>In the following example, the user may type a number of characters right after starting the evaluation of the form. After the &lt;code&gt;sleep-for&lt;/code&gt; finishes sleeping, &lt;code&gt;discard-input&lt;/code&gt; discards any characters typed during the sleep.</source>
          <target state="translated">В следующем примере пользователь может ввести некоторое количество символов сразу после начала оценки формы. После того, как &lt;code&gt;sleep-for&lt;/code&gt; завершает засыпание , &lt;code&gt;discard-input&lt;/code&gt; отбрасывает все символы, введенные во время сна.</target>
        </trans-unit>
        <trans-unit id="f7696bfce1413c1620baa40974e9b096f97b1062" translate="yes" xml:space="preserve">
          <source>In the following example, the user types in the octal number 177 (which is 127 in decimal).</source>
          <target state="translated">В следующем примере пользователь вводит восьмеричное число 177 (127 в десятичной дроби).</target>
        </trans-unit>
        <trans-unit id="90031aaefbae5ba18088f25e005afdff8b8be5df" translate="yes" xml:space="preserve">
          <source>In the following example, we define a &lt;code&gt;change-property&lt;/code&gt; function that takes a function as its third argument, followed by a &lt;code&gt;double-property&lt;/code&gt; function that makes use of &lt;code&gt;change-property&lt;/code&gt; by passing it an anonymous function:</source>
          <target state="translated">В следующем примере мы определяем функцию &lt;code&gt;change-property&lt;/code&gt; которая принимает функцию в качестве третьего аргумента, за которой следует функция с &lt;code&gt;double-property&lt;/code&gt; которая использует &lt;code&gt;change-property&lt;/code&gt; , передавая ей анонимную функцию:</target>
        </trans-unit>
        <trans-unit id="9a1fd088e9ae4b7e83b043fac095f41e72df8bbd" translate="yes" xml:space="preserve">
          <source>In the following example, we make</source>
          <target state="translated">В следующем примере мы делаем</target>
        </trans-unit>
        <trans-unit id="f9648cfc2ef9e1392db8901e3933f175d8a84fca" translate="yes" xml:space="preserve">
          <source>In the following example, we offer the user an expression with initial text that is already a valid form:</source>
          <target state="translated">В следующем примере мы предлагаем пользователю выражение с исходным текстом,которое уже является действительной формой:</target>
        </trans-unit>
        <trans-unit id="2e3e4218ff460b22a5180b17ddb295a8da5eceae" translate="yes" xml:space="preserve">
          <source>In the following example, we set the value of a symbol with &lt;code&gt;setq&lt;/code&gt;. Then we evaluate the symbol, and get back the value that &lt;code&gt;setq&lt;/code&gt; stored.</source>
          <target state="translated">В следующем примере мы устанавливаем значение символа с помощью &lt;code&gt;setq&lt;/code&gt; . Затем мы оцениваем символ и возвращаем значение, сохраненное в &lt;code&gt;setq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f311afb8bd19dedc75d6adda2a147ef509e3a73e" translate="yes" xml:space="preserve">
          <source>In the following example, we use &lt;code&gt;call-process-region&lt;/code&gt; to run the &lt;code&gt;cat&lt;/code&gt; utility, with standard input being the first five characters in buffer &amp;lsquo;</source>
          <target state="translated">В следующем примере мы используем &lt;code&gt;call-process-region&lt;/code&gt; для запуска утилиты &lt;code&gt;cat&lt;/code&gt; , при этом стандартный ввод - это первые пять символов в буфере '</target>
        </trans-unit>
        <trans-unit id="2ed30191890b49ad905f6c690d281609333d59e9" translate="yes" xml:space="preserve">
          <source>In the following examples, we call &lt;code&gt;delete-horizontal-space&lt;/code&gt; four times, once on each line, with point between the second and third characters on the line each time.</source>
          <target state="translated">В следующих примерах мы вызываем &lt;code&gt;delete-horizontal-space&lt;/code&gt; четыре раза, по одному в каждой строке, каждый раз ставя точку между вторым и третьим символами в строке.</target>
        </trans-unit>
        <trans-unit id="d73b2eb7e108f2274f2167b405818a1a4e5e8de9" translate="yes" xml:space="preserve">
          <source>In the following four functions, &amp;ldquo;beginning&amp;rdquo; or &amp;ldquo;end&amp;rdquo; of buffer refers to the beginning or end of the accessible portion.</source>
          <target state="translated">В следующих четырех функциях &amp;laquo;начало&amp;raquo; или &amp;laquo;конец&amp;raquo; буфера относятся к началу или концу доступной части.</target>
        </trans-unit>
        <trans-unit id="b77941da969f1ea78534b72b05e1f2ecd1399269" translate="yes" xml:space="preserve">
          <source>In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an input stream (see the previous section). If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-input&lt;/code&gt;.</source>
          <target state="translated">В приведенных ниже функциях &lt;var&gt;stream&lt;/var&gt; означает входной поток (см. Предыдущий раздел). Если &lt;var&gt;stream&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; или опущен, по умолчанию используется значение &lt;code&gt;standard-input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e02f70d33a63dec1a218a9f9fe21d0936515a768" translate="yes" xml:space="preserve">
          <source>In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an output stream. (See the previous section for a description of output streams. Also See &lt;a href=&quot;output-streams#external_002ddebugging_002doutput&quot;&gt;external-debugging-output&lt;/a&gt;, a useful stream value for debugging.) If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-output&lt;/code&gt;.</source>
          <target state="translated">В приведенных ниже функциях &lt;var&gt;stream&lt;/var&gt; означает выходной поток. (См. Описание выходных потоков в предыдущем разделе. Также см. &lt;a href=&quot;output-streams#external_002ddebugging_002doutput&quot;&gt;External-debugging-output&lt;/a&gt; , полезное значение потока для отладки.) Если &lt;var&gt;stream&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; или опущен, по умолчанию используется значение &lt;code&gt;standard-output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="842ff05e729e0c493fb0e3ce6cf4160def60f98a" translate="yes" xml:space="preserve">
          <source>In the functions that have an argument &lt;var&gt;newname&lt;/var&gt;, if a file by the name of &lt;var&gt;newname&lt;/var&gt; already exists, the actions taken depend on the value of the argument &lt;var&gt;ok-if-already-exists&lt;/var&gt;:</source>
          <target state="translated">В функциях с аргументом &lt;var&gt;newname&lt;/var&gt; , если файл с именем &lt;var&gt;newname&lt;/var&gt; уже существует, предпринимаемые действия зависят от значения аргумента &lt;var&gt;ok-if-already-exists&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="b9986edbcc327565facd71c28fb47353a1513f05" translate="yes" xml:space="preserve">
          <source>In the functions that have an argument &lt;var&gt;newname&lt;/var&gt;, if this argument is a directory name it is treated as if the nondirectory part of the source name were appended. Typically, a directory name is one that ends in &amp;lsquo;</source>
          <target state="translated">В функциях, которые имеют аргумент &lt;var&gt;newname&lt;/var&gt; , если этот аргумент является именем каталога, он обрабатывается так, как если бы была добавлена ​​не относящаяся к каталогу часть имени источника. Обычно имя каталога заканчивается на '</target>
        </trans-unit>
        <trans-unit id="3ff38bdd102a36bf5dad69f0bd3a4c48bcbb2f33" translate="yes" xml:space="preserve">
          <source>In the minibuffer,</source>
          <target state="translated">В минибуфере,</target>
        </trans-unit>
        <trans-unit id="95d42950506f5e85d9c00b2291550dcad572692d" translate="yes" xml:space="preserve">
          <source>In the new syntax table, all characters are initially given the &amp;ldquo;inherit&amp;rdquo; (&amp;lsquo;</source>
          <target state="translated">В новой таблице синтаксиса всем символам изначально присваивается &amp;laquo;наследование&amp;raquo; ('</target>
        </trans-unit>
        <trans-unit id="654197206043d5aa17cba42455172c4d80bf915c" translate="yes" xml:space="preserve">
          <source>In the output, tab and newline appear as themselves.</source>
          <target state="translated">В выводе вкладка и новая строка появляются как сами по себе.</target>
        </trans-unit>
        <trans-unit id="f0a865aff1bbfb0c542ac415212a86fda6d690da" translate="yes" xml:space="preserve">
          <source>In the parse tree, each HTML node is represented by a list in which the first element is a symbol representing the node name, the second element is an alist of node attributes, and the remaining elements are the subnodes.</source>
          <target state="translated">В дереве разбора каждый HTML-узел представлен списком,в котором первый элемент является символом,представляющим имя узла,второй-списком атрибутов узла,а остальные элементы-под-узлами.</target>
        </trans-unit>
        <trans-unit id="a6aa826dba60e33cee2ff73324e1dfc071fd99de" translate="yes" xml:space="preserve">
          <source>In the previous section, the definition of &lt;code&gt;for&lt;/code&gt; was fixed as follows to make the expansion evaluate the macro arguments the proper number of times:</source>
          <target state="translated">В предыдущем разделе определение &lt;code&gt;for&lt;/code&gt; было исправлено следующим образом, чтобы расширение оценивало аргументы макроса нужное количество раз:</target>
        </trans-unit>
        <trans-unit id="d94acc49f6466170529c5b4de675f17843e1d018" translate="yes" xml:space="preserve">
          <source>In the previous sections we have described how to construct elaborate type specifications for &lt;code&gt;defcustom&lt;/code&gt;. In some cases you may want to give such a type specification a name. The obvious case is when you are using the same type for many user options: rather than repeat the specification for each option, you can give the type specification a name, and use that name each &lt;code&gt;defcustom&lt;/code&gt;. The other case is when a user option&amp;rsquo;s value is a recursive data structure. To make it possible for a datatype to refer to itself, it needs to have a name.</source>
          <target state="translated">В предыдущих разделах мы описали, как создавать сложные спецификации типов для &lt;code&gt;defcustom&lt;/code&gt; . В некоторых случаях вы можете захотеть дать такой спецификации типа имя. Очевидный случай - это когда вы используете один и тот же тип для многих пользовательских опций: вместо того, чтобы повторять спецификацию для каждой опции, вы можете дать спецификации типа имя и использовать это имя для каждого &lt;code&gt;defcustom&lt;/code&gt; . Другой случай - когда значение пользовательской опции представляет собой рекурсивную структуру данных. Чтобы тип данных мог ссылаться на самого себя, у него должно быть имя.</target>
        </trans-unit>
        <trans-unit id="e1fe76b2ce299aa2f258889220086dc41caa10db" translate="yes" xml:space="preserve">
          <source>In the previous subsection we have described in detail how individual action functions interpret the action alist entries they care about. Here we give a reference list of all known action alist entries according to their symbols, together with their values and action functions (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) that recognize them. Throughout this list, the terms &amp;ldquo;buffer&amp;rdquo; will refer to the buffer &lt;code&gt;display-buffer&lt;/code&gt; is supposed to display, and &amp;ldquo;value&amp;rdquo; refers to the entry&amp;rsquo;s value.</source>
          <target state="translated">В предыдущем подразделе мы подробно описали, как отдельные функции действий интерпретируют записи списка действий, которые им важны. Здесь мы даем справочный список всех известных записей списков действий в соответствии с их символами, вместе с их значениями и функциями действий (см. &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Функции действий отображения буфера&lt;/a&gt; ), которые их распознают. В этом списке термин &amp;laquo;буфер&amp;raquo; будет относиться к буферу, который должен &lt;code&gt;display-buffer&lt;/code&gt; , а &amp;laquo;значение&amp;raquo; относится к значению записи.</target>
        </trans-unit>
        <trans-unit id="70305cb871bf1fadf003b84d92f8f772b2e037ea" translate="yes" xml:space="preserve">
          <source>In the return value, &lt;var&gt;function&lt;/var&gt; is whatever was supplied as the &lt;small&gt;CAR&lt;/small&gt; of the evaluated list, or a &lt;code&gt;lambda&lt;/code&gt; expression in the case of a macro call. If the function has a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, that is represented as the tail of the list &lt;var&gt;arg-values&lt;/var&gt;.</source>
          <target state="translated">В возвращаемом значении &lt;var&gt;function&lt;/var&gt; - это то, что было предоставлено как &lt;small&gt;CAR&lt;/small&gt; оцененного списка, или &lt;code&gt;lambda&lt;/code&gt; выражение в случае вызова макроса. Если функция имеет аргумент &lt;code&gt;&amp;amp;rest&lt;/code&gt; , он представлен как конец списка &lt;var&gt;arg-values&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a43342cb008eceb0301dec01749bcef5885ffad6" translate="yes" xml:space="preserve">
          <source>In the second expression, the local binding of &lt;code&gt;print-escape-newlines&lt;/code&gt; is in effect during the call to &lt;code&gt;prin1&lt;/code&gt;, but not during the printing of the result.</source>
          <target state="translated">Во втором выражении локальная привязка &lt;code&gt;print-escape-newlines&lt;/code&gt; действует во время вызова &lt;code&gt;prin1&lt;/code&gt; , но не во время печати результата.</target>
        </trans-unit>
        <trans-unit id="780bba30b6e90faed0e2ade0fdd2f1da2fdca85f" translate="yes" xml:space="preserve">
          <source>In the second variant, the choice of lines to hide is made automatically based on indentation. This variant is designed to be a user-level feature.</source>
          <target state="translated">Во втором варианте выбор линий для скрытия производится автоматически на основе отступов.Этот вариант разработан на уровне пользователя.</target>
        </trans-unit>
        <trans-unit id="bffc354f8e26188db7e818c849dff5db0c9e8f32" translate="yes" xml:space="preserve">
          <source>In the simplest case, &lt;var&gt;listname&lt;/var&gt; is an unquoted symbol naming a list; in that case, this macro is equivalent to &lt;code&gt;(prog1&amp;nbsp;(car&amp;nbsp;listname)&amp;nbsp;(setq&amp;nbsp;listname&amp;nbsp;(cdr&amp;nbsp;listname)))&lt;/code&gt;.</source>
          <target state="translated">В простейшем случае &lt;var&gt;listname&lt;/var&gt; - это символ без кавычек , обозначающий список; в этом случае этот макрос эквивалентен &lt;code&gt;(prog1&amp;nbsp;(car&amp;nbsp;listname)&amp;nbsp;(setq&amp;nbsp;listname&amp;nbsp;(cdr&amp;nbsp;listname)))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6677923bd341b8f53bd4e45ad643c994637a35f0" translate="yes" xml:space="preserve">
          <source>In the simplest case, &lt;var&gt;separator-type&lt;/var&gt; consists of only dashes. That specifies the default kind of separator. (For compatibility, &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; also count as separators.)</source>
          <target state="translated">В простейшем случае &lt;var&gt;separator-type&lt;/var&gt; состоит только из тире. Это определяет тип разделителя по умолчанию. (Для совместимости &lt;code&gt;&quot;&quot;&lt;/code&gt; и &lt;code&gt;-&lt;/code&gt; также считаются разделителями.)</target>
        </trans-unit>
        <trans-unit id="4ac8ea59e19025468a89992b0f2dbc087cbc7d49" translate="yes" xml:space="preserve">
          <source>In the simplest case, any non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;invisible&lt;/code&gt; property makes a character invisible. This is the default case&amp;mdash;if you don&amp;rsquo;t alter the default value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt;, this is how the &lt;code&gt;invisible&lt;/code&gt; property works. You should normally use &lt;code&gt;t&lt;/code&gt; as the value of the &lt;code&gt;invisible&lt;/code&gt; property if you don&amp;rsquo;t plan to set &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; yourself.</source>
          <target state="translated">В простейшем случае любое свойство &lt;code&gt;invisible&lt;/code&gt; , отличное от &lt;code&gt;nil&lt;/code&gt; , делает символ невидимым. Это случай по умолчанию - если вы не измените значение по умолчанию для &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; , именно так работает свойство &lt;code&gt;invisible&lt;/code&gt; . Обычно вы должны использовать &lt;code&gt;t&lt;/code&gt; как значение свойства &lt;code&gt;invisible&lt;/code&gt; , если вы не планируете самостоятельно устанавливать &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b654a675313cc501deccb72dafb7cf632e0a67de" translate="yes" xml:space="preserve">
          <source>In the string representation, alphanumeric characters ordinarily stand for themselves; for example, &lt;code&gt;&quot;a&quot;&lt;/code&gt; represents</source>
          <target state="translated">В строковом представлении буквенно-цифровые символы обычно обозначают сами себя; например, &lt;code&gt;&quot;a&quot;&lt;/code&gt; представляет</target>
        </trans-unit>
        <trans-unit id="68ea687212db99586a26415019a5a3e01bea5f4c" translate="yes" xml:space="preserve">
          <source>In the terminology of operating systems, a &lt;em&gt;process&lt;/em&gt; is a space in which a program can execute. Emacs runs in a process. Emacs Lisp programs can invoke other programs in processes of their own. These are called &lt;em&gt;subprocesses&lt;/em&gt; or &lt;em&gt;child processes&lt;/em&gt; of the Emacs process, which is their &lt;em&gt;parent process&lt;/em&gt;.</source>
          <target state="translated">В терминологии операционных систем &lt;em&gt;процесс&lt;/em&gt; - это пространство, в котором может выполняться программа. Emacs работает в процессе. Программы Emacs Lisp могут вызывать другие программы в собственных процессах. Они называются &lt;em&gt;подпроцессами&lt;/em&gt; или &lt;em&gt;дочерними процессами процесса&lt;/em&gt; Emacs, который является их &lt;em&gt;родительским процессом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="20d433bd64cf194bf3401eb20026d1e5a072b7d8" translate="yes" xml:space="preserve">
          <source>In the unlikely event that you need a more general functionality than &lt;code&gt;custom-initialize-delay&lt;/code&gt; provides, you can use &lt;code&gt;before-init-hook&lt;/code&gt; (see &lt;a href=&quot;startup-summary#Startup-Summary&quot;&gt;Startup Summary&lt;/a&gt;).</source>
          <target state="translated">В том маловероятном случае, когда вам понадобится более общая функциональность, чем предоставляет &lt;code&gt;custom-initialize-delay&lt;/code&gt; , вы можете использовать &lt;code&gt;before-init-hook&lt;/code&gt; (см. &lt;a href=&quot;startup-summary#Startup-Summary&quot;&gt;Сводка запуска&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="653d17f655aa9bc207c0340a07989c300bfc7174" translate="yes" xml:space="preserve">
          <source>In the vector representation, each element of the vector represents an input event, in its Lisp form. See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. For example, the vector &lt;code&gt;[?\C-x ?l]&lt;/code&gt; represents the key sequence</source>
          <target state="translated">В векторном представлении каждый элемент вектора представляет входное событие в его Лисп-форме. См. &lt;a href=&quot;input-events#Input-Events&quot;&gt;Входные события&lt;/a&gt; . Например, вектор &lt;code&gt;[?\C-x ?l]&lt;/code&gt; представляет ключевую последовательность</target>
        </trans-unit>
        <trans-unit id="37545e5ede88b47c3c895f58d985de6aa2297176" translate="yes" xml:space="preserve">
          <source>In their most simple form of use, side windows allow to display specific buffers always in the same area of a frame. Hence they can be regarded as a generalization of the concept provided by &lt;code&gt;display-buffer-at-bottom&lt;/code&gt; (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) to the remaining sides of a frame. With suitable customizations, however, side windows can be also used to provide frame layouts similar to those found in so-called integrated development environments (IDEs).</source>
          <target state="translated">В самом простом виде боковые окна позволяют всегда отображать определенные буферы в одной и той же области кадра. Следовательно, их можно рассматривать как обобщение концепции, предоставляемой &lt;code&gt;display-buffer-at-bottom&lt;/code&gt; (см. &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Функции действия отображения буфера&lt;/a&gt; ) для остальных сторон кадра. Однако с соответствующими настройками боковые окна могут также использоваться для предоставления макетов фреймов, аналогичных тем, которые используются в так называемых интегрированных средах разработки (IDE).</target>
        </trans-unit>
        <trans-unit id="4da8e1cd8146f3a0b7e768a0095492966a0a3fcb" translate="yes" xml:space="preserve">
          <source>In theory, a theme file can also contain other Lisp forms, which would be evaluated when loading the theme, but that is bad form. To protect against loading themes containing malicious code, Emacs displays the source file and asks for confirmation from the user before loading any non-built-in theme for the first time. As such, themes are not ordinarily byte-compiled, and source files always take precedence when Emacs is looking for a theme to load.</source>
          <target state="translated">Теоретически,файл темы может содержать и другие формы Lisp,которые будут оцениваться при загрузке темы,но это плохая форма.Для защиты от загрузки тем,содержащих вредоносный код,Emacs выводит исходный файл и запрашивает подтверждение от пользователя перед загрузкой любой не встроенной темы в первый раз.Таким образом,темы обычно не компилируются в байтах,а исходные файлы всегда имеют приоритет,когда Emacs ищет загружаемую тему.</target>
        </trans-unit>
        <trans-unit id="bdc0c811869c12153b361b16802c27840ea05add" translate="yes" xml:space="preserve">
          <source>In these functions, the &lt;var&gt;process&lt;/var&gt; argument can be a process or the name of a process, or a buffer or buffer name (which stands for a process via &lt;code&gt;get-buffer-process&lt;/code&gt;). &lt;code&gt;nil&lt;/code&gt; means the current buffer&amp;rsquo;s process.</source>
          <target state="translated">В этих функциях аргумент &lt;var&gt;process&lt;/var&gt; может быть процессом или именем процесса, или буфером, или именем буфера (что означает процесс через &lt;code&gt;get-buffer-process&lt;/code&gt; ). &lt;code&gt;nil&lt;/code&gt; означает текущий процесс буфера.</target>
        </trans-unit>
        <trans-unit id="7889cf29aeb64d8679d013ba57b97d89a395974a" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;with-temp-buffer-window&lt;/code&gt; always makes a new parent window when it splits an existing window (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;). Otherwise, window splitting behaves as for &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В этом случае &lt;code&gt;with-temp-buffer-window&lt;/code&gt; всегда создает новое родительское окно, когда оно разделяет существующее окно (см. &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Временные дисплеи&lt;/a&gt; ). В противном случае разделение окна ведет себя как для &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4aad296f13c9498890681b6eab23e4731825c14d" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;with-temp-buffer-window&lt;/code&gt; makes a new parent window when it splits a window and &lt;code&gt;temp-buffer-resize-mode&lt;/code&gt; is enabled (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;). Otherwise, window splitting behaves as for &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В этом случае &lt;code&gt;with-temp-buffer-window&lt;/code&gt; создает новое родительское окно, когда оно разбивает окно и включен &lt;code&gt;temp-buffer-resize-mode&lt;/code&gt; (см. &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Временные дисплеи&lt;/a&gt; ). В противном случае разделение окна ведет себя как для &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f92ba4ac4b99574f776831ff1c5804087ad33c57" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;inhibit-same-window&lt;/code&gt; alist entry will successfully invalidate the &lt;code&gt;display-buffer-same-window&lt;/code&gt; specification from &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; and &lt;code&gt;display-buffer&lt;/code&gt; will show</source>
          <target state="translated">В этом случае запись в списке запрета &lt;code&gt;inhibit-same-window&lt;/code&gt; успешно аннулирует спецификацию &lt;code&gt;display-buffer-same-window&lt;/code&gt; из действия &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; , и &lt;code&gt;display-buffer&lt;/code&gt; покажет</target>
        </trans-unit>
        <trans-unit id="04b2213a63614ac8251b3c7bc455f4e8850855b5" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&quot;prolog&quot;&lt;/code&gt; is the name of the file to load, 169681 refers to the documentation string in the</source>
          <target state="translated">В этом случае &lt;code&gt;&quot;prolog&quot;&lt;/code&gt; - это имя файла для загрузки, 169681 относится к строке документации в</target>
        </trans-unit>
        <trans-unit id="8e648e458f3c001b5d685c0aaee6c84fe234be3f" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;small&gt;CDR&lt;/small&gt; of the association &lt;code&gt;(lily white)&lt;/code&gt; is not the symbol &lt;code&gt;white&lt;/code&gt;, but rather the list &lt;code&gt;(white)&lt;/code&gt;. This becomes clearer if the association is written in dotted pair notation:</source>
          <target state="translated">В этом случае &lt;small&gt;CDR&lt;/small&gt; ассоциации &lt;code&gt;(lily white)&lt;/code&gt; - это не &lt;code&gt;white&lt;/code&gt; символ , а скорее список &lt;code&gt;(white)&lt;/code&gt; . Это становится более ясным, если ассоциация записана в виде пары точек:</target>
        </trans-unit>
        <trans-unit id="5c978b1007a3cfab25727c041633a410661259c5" translate="yes" xml:space="preserve">
          <source>In this case, the process is not truly synchronous, since it can run in parallel with Emacs; but you can think of it as synchronous in that Emacs is essentially finished with the subprocess as soon as this function returns.</source>
          <target state="translated">В данном случае процесс не является по-настоящему синхронным,так как может работать параллельно с Emacs;но можно считать,что он синхронный,так как Emacs,по сути,закончит работу с подпроцессом,как только эта функция вернётся.</target>
        </trans-unit>
        <trans-unit id="3fc1a62b1e8add3600030a618eb06b7554d262e1" translate="yes" xml:space="preserve">
          <source>In this diagram, each box represents a slot that can hold or refer to any Lisp object. Each pair of boxes represents a cons cell. Each arrow represents a reference to a Lisp object, either an atom or another cons cell.</source>
          <target state="translated">В этой диаграмме каждый блок представляет собой слот,который может содержать или ссылаться на любой объект Lisp.Каждая пара боксов представляет собой ячейку &quot;против&quot;.Каждая стрелка представляет собой ссылку на объект Lisp,атом или другую консольную ячейку.</target>
        </trans-unit>
        <trans-unit id="5189ea2c15eedb2e76964428691f1c5cd904bd9e" translate="yes" xml:space="preserve">
          <source>In this example, point is between the &amp;lsquo;</source>
          <target state="translated">В этом примере точка находится между '</target>
        </trans-unit>
        <trans-unit id="f7926c062dd5a0ff5ef38fa8e29790f6b8333d0b" translate="yes" xml:space="preserve">
          <source>In this example, point is initially at the beginning of the buffer; the search leaves it between the &amp;lsquo;</source>
          <target state="translated">В этом примере точка изначально находится в начале буфера; поиск оставляет его между '</target>
        </trans-unit>
        <trans-unit id="8a9cce26338257a7f7f918d357295fda94e21a00" translate="yes" xml:space="preserve">
          <source>In this example, point is initially located at the beginning of the second line:</source>
          <target state="translated">В данном примере точка изначально расположена в начале второй линии:</target>
        </trans-unit>
        <trans-unit id="9c8ac6b39fdaea7c1429c01fa50b5a383964f56c" translate="yes" xml:space="preserve">
          <source>In this example, point is located directly before the &amp;lsquo;</source>
          <target state="translated">В этом примере точка расположена непосредственно перед символом '</target>
        </trans-unit>
        <trans-unit id="3576b093aaf2ac699eaa7e91d03edb88bd5e4be3" translate="yes" xml:space="preserve">
          <source>In this example, the first box, which holds the &lt;small&gt;CAR&lt;/small&gt; of the first cons cell, refers to or holds &lt;code&gt;rose&lt;/code&gt; (a symbol). The second box, holding the &lt;small&gt;CDR&lt;/small&gt; of the first cons cell, refers to the next pair of boxes, the second cons cell. The &lt;small&gt;CAR&lt;/small&gt; of the second cons cell is &lt;code&gt;violet&lt;/code&gt;, and its &lt;small&gt;CDR&lt;/small&gt; is the third cons cell. The &lt;small&gt;CDR&lt;/small&gt; of the third (and last) cons cell is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В этом примере первое поле, которое содержит &lt;small&gt;CAR&lt;/small&gt; первой cons-ячейки, относится к &lt;code&gt;rose&lt;/code&gt; (символ) или содержит ее. Второй прямоугольник, содержащий &lt;small&gt;CDR&lt;/small&gt; первой cons-ячейки, относится к следующей паре полей, второй cons-ячейке. &lt;small&gt;АВТОМОБИЛЬ&lt;/small&gt; второго конса клетки &lt;code&gt;violet&lt;/code&gt; , и его &lt;small&gt;CDR&lt;/small&gt; , является третьими против клеток. &lt;small&gt;CDR&lt;/small&gt; третьей (и последней) ячейка конса является &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73de656109b1553b872ecb7b04fd7edf5fcf976d" translate="yes" xml:space="preserve">
          <source>In this example, the form is executed with buffer &amp;lsquo;</source>
          <target state="translated">В этом примере форма выполняется с буфером '</target>
        </trans-unit>
        <trans-unit id="4b9029e7a66aa0c9f8ca4c799ed66e0cfbb79118" translate="yes" xml:space="preserve">
          <source>In this example, the index for &amp;lsquo;</source>
          <target state="translated">В этом примере индекс для '</target>
        </trans-unit>
        <trans-unit id="764b384a226e6ab33f5227fab6776af37eb99b70" translate="yes" xml:space="preserve">
          <source>In this example, the interpreted code required 10 seconds to run, whereas the byte-compiled code required less than 4 seconds. These results are representative, but actual results may vary.</source>
          <target state="translated">В данном примере на выполнение интерпретированного кода потребовалось 10 секунд,в то время как на выполнение байт-компилированного кода-менее 4 секунд.Эти результаты являются репрезентативными,но реальные результаты могут варьироваться.</target>
        </trans-unit>
        <trans-unit id="6c60d69a652292ccff830c67c8d2351ad5e5e0b6" translate="yes" xml:space="preserve">
          <source>In this example, the value says that</source>
          <target state="translated">В данном примере значение говорит о том,что</target>
        </trans-unit>
        <trans-unit id="bf4b9ec25e056b797f6607ca8b59766a3a808319" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;anchored-highlighter&lt;/var&gt; specifies how to highlight text that follows a match found by &lt;var&gt;matcher&lt;/var&gt;. So a match found by &lt;var&gt;matcher&lt;/var&gt; acts as the anchor for further searches specified by &lt;var&gt;anchored-highlighter&lt;/var&gt;. &lt;var&gt;anchored-highlighter&lt;/var&gt; is a list of the following form:</source>
          <target state="translated">В этом типе элемента &lt;var&gt;anchored-highlighter&lt;/var&gt; указывает, как выделить текст, который следует за совпадением, найденным &lt;var&gt;matcher&lt;/var&gt; . Таким образом, совпадение, найденное &lt;var&gt;matcher&lt;/var&gt; , действует как якорь для дальнейших поисков, указанных &lt;var&gt;anchored-highlighter&lt;/var&gt; . &lt;var&gt;anchored-highlighter&lt;/var&gt; - это список следующего вида:</target>
        </trans-unit>
        <trans-unit id="8f400ef8e587e9e01e8f55ffe8f0804f11bd1102" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;facespec&lt;/var&gt; is an expression whose value specifies the face to use for highlighting. In the simplest case, &lt;var&gt;facespec&lt;/var&gt; is a Lisp variable (a symbol) whose value is a face name.</source>
          <target state="translated">В этом типе элемента &lt;var&gt;facespec&lt;/var&gt; - это выражение, значение которого определяет лицо, которое будет использоваться для выделения. В простейшем случае &lt;var&gt;facespec&lt;/var&gt; - это переменная Lisp (символ), значением которой является имя лица.</target>
        </trans-unit>
        <trans-unit id="d0f3cf4781874539fca8b12ffa575360a97062a3" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;matcher&lt;/var&gt; is either a regular expression or a function, as described above. The &lt;small&gt;CDR&lt;/small&gt;, &lt;var&gt;subexp&lt;/var&gt;, specifies which subexpression of &lt;var&gt;matcher&lt;/var&gt; should be highlighted (instead of the entire text that &lt;var&gt;matcher&lt;/var&gt; matched).</source>
          <target state="translated">В этом типе элемента &lt;var&gt;matcher&lt;/var&gt; является либо регулярным выражением, либо функцией, как описано выше. В &lt;small&gt;CDR&lt;/small&gt; , &lt;var&gt;subexp&lt;/var&gt; , определяет , какое подвыражение &lt;var&gt;matcher&lt;/var&gt; должно быть выделено (а не весь текст , который &lt;var&gt;matcher&lt;/var&gt; соответствует).</target>
        </trans-unit>
        <trans-unit id="d4c92f44f29e6a508a88862991fc4849cfa01b75" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;subexp-highlighter&lt;/var&gt; is a list which specifies how to highlight matches found by &lt;var&gt;matcher&lt;/var&gt;. It has the form:</source>
          <target state="translated">В этом типе элемента &lt;var&gt;subexp-highlighter&lt;/var&gt; - это список, который указывает, как выделять совпадения, найденные &lt;var&gt;matcher&lt;/var&gt; . Он имеет вид:</target>
        </trans-unit>
        <trans-unit id="65868b57f4589aab73c360fb6e9e308010443437" translate="yes" xml:space="preserve">
          <source>In this manual, we write &lt;code&gt;()&lt;/code&gt; when we wish to emphasize that it means the empty list, and we write &lt;code&gt;nil&lt;/code&gt; when we wish to emphasize that it means the truth value &lt;var&gt;false&lt;/var&gt;. That is a good convention to use in Lisp programs also.</source>
          <target state="translated">В этом руководстве мы пишем &lt;code&gt;()&lt;/code&gt; , когда хотим подчеркнуть, что это означает пустой список, и мы пишем &lt;code&gt;nil&lt;/code&gt; , когда хотим подчеркнуть, что это означает истинное значение &lt;var&gt;false&lt;/var&gt; . Это хорошее соглашение также для использования в программах на Лиспе.</target>
        </trans-unit>
        <trans-unit id="af20502ec39925ff9d9d9c1f4f7cbd4800bb2ffe" translate="yes" xml:space="preserve">
          <source>In this next example, point is between the &amp;lsquo;</source>
          <target state="translated">В следующем примере точка находится между символом '</target>
        </trans-unit>
        <trans-unit id="5b3dc1e84019e82e89cd0988c8c5c64866bf8ed9" translate="yes" xml:space="preserve">
          <source>In this scenario, &lt;code&gt;jsonrpc-connection&lt;/code&gt; is subclassed to implement a different underlying transport strategy (for details on how to subclass, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance&quot;&gt;(eieio)Inheritance&lt;/a&gt;.). Users of the application-building interface can then instantiate objects of this concrete class (using the &lt;code&gt;make-instance&lt;/code&gt; function) and connect to JSONRPC endpoints using that strategy.</source>
          <target state="translated">В этом сценарии &lt;code&gt;jsonrpc-connection&lt;/code&gt; разделен на подклассы для реализации другой базовой транспортной стратегии (подробности о том, как &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance&quot;&gt;создать&lt;/a&gt; подкласс, см. (Eieio) Наследование .). Затем пользователи интерфейса для создания приложений могут создавать экземпляры объектов этого конкретного класса (с помощью функции &lt;code&gt;make-instance&lt;/code&gt; ) и подключаться к конечным точкам JSONRPC, используя эту стратегию.</target>
        </trans-unit>
        <trans-unit id="4d1bdfebfd1fd098fb5c5e69cd62378829390e37" translate="yes" xml:space="preserve">
          <source>In this scenario, &lt;code&gt;jsonrpc-connection&lt;/code&gt; is subclassed to implement a different underlying transport strategy (for details on how to subclass, see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance&quot;&gt;(eieio)Inheritance&lt;/a&gt;.). Users of the application-building interface can then instantiate objects of this concrete class (using the &lt;code&gt;make-instance&lt;/code&gt; function) and connect to JSONRPC endpoints using that strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e4e7371206d35dcfc5989991b4a959d04ae518" translate="yes" xml:space="preserve">
          <source>In this scenario, the JSONRPC application selects a concrete subclass of &lt;code&gt;jsonrpc-connection&lt;/code&gt;, and proceeds to create objects of that subclass using &lt;code&gt;make-instance&lt;/code&gt;. To initiate a contact to the remote endpoint, the JSONRPC application passes this object to the functions &lt;code&gt;jsonrpc-notify&lt;/code&gt;, &lt;code&gt;jsonrpc-request&lt;/code&gt;, and/or &lt;code&gt;jsonrpc-async-request&lt;/code&gt;. For handling remotely initiated contacts, which generally come in asynchronously, the instantiation should include &lt;code&gt;:request-dispatcher&lt;/code&gt; and &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs, which are both functions of 3 arguments: the connection object; a symbol naming the JSONRPC method invoked remotely; and a JSONRPC &lt;code&gt;params&lt;/code&gt; object.</source>
          <target state="translated">В этом сценарии приложение JSONRPC выбирает конкретный подкласс &lt;code&gt;jsonrpc-connection&lt;/code&gt; и приступает к созданию объектов этого подкласса с помощью &lt;code&gt;make-instance&lt;/code&gt; . Чтобы инициировать контакт с удаленной конечной точкой, приложение JSONRPC передает этот объект функциям &lt;code&gt;jsonrpc-notify&lt;/code&gt; &lt;code&gt;jsonrpc-request&lt;/code&gt; , jsonrpc-request и / или &lt;code&gt;jsonrpc-async-request&lt;/code&gt; . Для обработки дистанционно инициируемых контактов, которые обычно поступают асинхронно, создание экземпляра должно включать в себя &lt;code&gt;:request-dispatcher&lt;/code&gt; инициализации request-dispatcher и &lt;code&gt;:notification-dispatcher&lt;/code&gt; , которые являются функциями трех аргументов: объекта соединения; символ, обозначающий удаленно вызываемый метод JSONRPC; и &lt;code&gt;params&lt;/code&gt; JSONRPC объект.</target>
        </trans-unit>
        <trans-unit id="1af82129d6d32c9e06217b885c8dd8bf6f60a0e9" translate="yes" xml:space="preserve">
          <source>In this section we describe functions for creating, accessing and altering syntax tables.</source>
          <target state="translated">В данном разделе мы опишем функции для создания,доступа и изменения синтаксических таблиц.</target>
        </trans-unit>
        <trans-unit id="7456e6359dd2969245d309399580bcce1506a625" translate="yes" xml:space="preserve">
          <source>In this section we list some of the more general keymaps. Many of these exist when Emacs is first started, but some are loaded only when the respective feature is accessed.</source>
          <target state="translated">В этом разделе мы перечислим некоторые из более общих ключевых карт.Многие из них существуют при первом запуске Emacs,но некоторые загружаются только при обращении к соответствующей функции.</target>
        </trans-unit>
        <trans-unit id="75c4faa5a87500b689faf740289921e94ba4648d" translate="yes" xml:space="preserve">
          <source>In this section, we describe how to create an &lt;em&gt;asynchronous process&lt;/em&gt;. After an asynchronous process is created, it runs in parallel with Emacs, and Emacs can communicate with it using the functions described in the following sections (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;, and see &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Output from Processes&lt;/a&gt;). Note that process communication is only partially asynchronous: Emacs sends and receives data to and from a process only when those functions are called.</source>
          <target state="translated">В этом разделе мы описываем, как создать &lt;em&gt;асинхронный процесс&lt;/em&gt; . После создания асинхронного процесса он запускается параллельно с Emacs, и Emacs может связываться с ним, используя функции, описанные в следующих разделах (см. &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Ввод в процессы&lt;/a&gt; и см. &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Выход из процессов&lt;/a&gt; ). Обратите внимание, что обмен данными между процессами является лишь частично асинхронным: Emacs отправляет и получает данные в процесс и из процесса только тогда, когда эти функции вызываются.</target>
        </trans-unit>
        <trans-unit id="c9b298dd66b005623af56bf6c6bc09c1e5f67332" translate="yes" xml:space="preserve">
          <source>In this section, we describe the functions that accept all types of arrays.</source>
          <target state="translated">В этом разделе мы опишем функции,которые принимают все типы массивов.</target>
        </trans-unit>
        <trans-unit id="abf73e32c756c256563a8daa580c451693687fe9" translate="yes" xml:space="preserve">
          <source>In this section, we document the &lt;code&gt;run-hooks&lt;/code&gt; function, which is used to run a normal hook. We also document the functions for running various kinds of abnormal hooks.</source>
          <target state="translated">В этом разделе мы документируем функцию &lt;code&gt;run-hooks&lt;/code&gt; , которая используется для запуска обычной ловушки. Мы также документируем функции для запуска различных видов аномальных ловушек.</target>
        </trans-unit>
        <trans-unit id="cc308cdcd27e50a8464c2fb8c2b137680f8aa92d" translate="yes" xml:space="preserve">
          <source>In this special form, the arguments &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are optional, but must both be present or both absent. If they are present, &lt;var&gt;inc&lt;/var&gt; may optionally be specified as well. These arguments are grouped with the argument &lt;var&gt;var&lt;/var&gt; into a list, to distinguish them from &lt;var&gt;body&lt;/var&gt;, which includes all remaining elements of the form.</source>
          <target state="translated">В этой специальной форме аргументы &lt;var&gt;from&lt;/var&gt; и &lt;var&gt;to&lt;/var&gt; необязательны, но должны присутствовать оба или оба отсутствовать. Если они присутствуют, при желании также может быть указано &lt;var&gt;inc&lt;/var&gt; . Эти аргументы сгруппированы с аргументом &lt;var&gt;var&lt;/var&gt; в список, чтобы отличить их от &lt;var&gt;body&lt;/var&gt; , которое включает в себя все остальные элементы формы.</target>
        </trans-unit>
        <trans-unit id="9191121a266e1613654b74c183e9b81e80959c1f" translate="yes" xml:space="preserve">
          <source>In this subsection, &lt;var&gt;ewoc&lt;/var&gt; and &lt;var&gt;node&lt;/var&gt; stand for the structures described above (see &lt;a href=&quot;abstract-display#Abstract-Display&quot;&gt;Abstract Display&lt;/a&gt;), while &lt;var&gt;data&lt;/var&gt; stands for an arbitrary Lisp object used as a data element.</source>
          <target state="translated">В этом подразделе &lt;var&gt;ewoc&lt;/var&gt; и &lt;var&gt;node&lt;/var&gt; обозначают структуры, описанные выше (см. &lt;a href=&quot;abstract-display#Abstract-Display&quot;&gt;Абстрактный дисплей&lt;/a&gt; ), а &lt;var&gt;data&lt;/var&gt; обозначает произвольный объект Lisp, используемый в качестве элемента данных.</target>
        </trans-unit>
        <trans-unit id="b7695c1c385c781384681e043cf75498c33095e8" translate="yes" xml:space="preserve">
          <source>In typical use of text properties, most of the time several or many consecutive characters have the same value for a property. Rather than writing your programs to examine characters one by one, it is much faster to process chunks of text that have the same property value.</source>
          <target state="translated">При типичном использовании текстовых свойств,в большинстве случаев несколько или несколько последовательных символов имеют одно и то же значение для свойства.Вместо того,чтобы писать свои программы для изучения символов один за другим,гораздо быстрее обрабатывать куски текста,которые имеют одинаковое значение свойства.</target>
        </trans-unit>
        <trans-unit id="398759523f553da3a04d5632b9ae89f03ca6ebe6" translate="yes" xml:space="preserve">
          <source>In unusual circumstances, there can be more than one buffer visiting the same file name. In such cases, this function returns the first such buffer in the buffer list.</source>
          <target state="translated">В необычных обстоятельствах может быть более одного буфера,посещающего одно и то же имя файла.В таких случаях эта функция возвращает первый такой буфер в списке буферов.</target>
        </trans-unit>
        <trans-unit id="6bc522c712bd045ae610c3ffdfe588e290263853" translate="yes" xml:space="preserve">
          <source>In window systems, such as X, data can be transferred between different applications by means of &lt;em&gt;selections&lt;/em&gt;. X defines an arbitrary number of &lt;em&gt;selection types&lt;/em&gt;, each of which can store its own data; however, only three are commonly used: the &lt;em&gt;clipboard&lt;/em&gt;, &lt;em&gt;primary selection&lt;/em&gt;, and &lt;em&gt;secondary selection&lt;/em&gt;. Other window systems support only the clipboard. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Cut-and-Paste.html#Cut-and-Paste&quot;&gt;Cut and Paste&lt;/a&gt; in</source>
          <target state="translated">В оконных системах, таких как X, данные могут передаваться между различными приложениями посредством &lt;em&gt;выбора&lt;/em&gt; . X определяет произвольное количество &lt;em&gt;типов выбора&lt;/em&gt; , каждый из которых может хранить свои собственные данные; однако обычно используются только три: &lt;em&gt;буфер обмена&lt;/em&gt; , &lt;em&gt;первичный выбор&lt;/em&gt; и &lt;em&gt;вторичный выбор&lt;/em&gt; . Другие оконные системы поддерживают только буфер обмена. См &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Cut-and-Paste.html#Cut-and-Paste&quot;&gt;Вырезать и Вставить&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="8885d39a5d58dfc4e7b550a427bcd4ecec67d95d" translate="yes" xml:space="preserve">
          <source>In window systems, such as X, data can be transferred between different applications by means of &lt;em&gt;selections&lt;/em&gt;. X defines an arbitrary number of &lt;em&gt;selection types&lt;/em&gt;, each of which can store its own data; however, only three are commonly used: the &lt;em&gt;clipboard&lt;/em&gt;, &lt;em&gt;primary selection&lt;/em&gt;, and &lt;em&gt;secondary selection&lt;/em&gt;. Other window systems support only the clipboard. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Cut-and-Paste.html#Cut-and-Paste&quot;&gt;Cut and Paste&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4f96711902573479785d359bea6010a237cdfb" translate="yes" xml:space="preserve">
          <source>In writing the key sequence to rebind, it is good to use the special escape sequences for control and meta characters (see &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;). The syntax &amp;lsquo;</source>
          <target state="translated">При написании ключевой последовательности для повторной привязки хорошо использовать специальные escape-последовательности для управляющих и метасимволов (см. &lt;a href=&quot;string-type#String-Type&quot;&gt;Тип строки&lt;/a&gt; ). Синтаксис '</target>
        </trans-unit>
        <trans-unit id="5c699af66d7cc4077f86d1419c1e341294245528" translate="yes" xml:space="preserve">
          <source>Include an external link after the documentation string for this item. This is a sentence containing a button that references some other documentation.</source>
          <target state="translated">Включите внешнюю ссылку после строки документации для этого элемента.Это предложение,содержащее кнопку со ссылкой на другую документацию.</target>
        </trans-unit>
        <trans-unit id="76775cb67de1d16719f132aea62e321213b81dcb" translate="yes" xml:space="preserve">
          <source>Includes examples and caveats.</source>
          <target state="translated">Включает примеры и предостережения.</target>
        </trans-unit>
        <trans-unit id="abb42b558c56ceb21cca2f6daadd7a31514411ab" translate="yes" xml:space="preserve">
          <source>Increase the image size (&lt;code&gt;image-increase-size&lt;/code&gt;). A prefix value of &amp;lsquo;</source>
          <target state="translated">Увеличьте размер изображения ( &lt;code&gt;image-increase-size&lt;/code&gt; ). Префиксное значение '</target>
        </trans-unit>
        <trans-unit id="9229257425378cb0ebb48e0365ae97d30b8cbd09" translate="yes" xml:space="preserve">
          <source>Incremental search can make invisible overlays visible temporarily and/or permanently when a match includes invisible text. To enable this, the overlay should have a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;isearch-open-invisible&lt;/code&gt; property. The property value should be a function to be called with the overlay as an argument. This function should make the overlay visible permanently; it is used when the match overlaps the overlay on exit from the search.</source>
          <target state="translated">Пошаговый поиск может сделать невидимые оверлеи видимыми временно и / или постоянно, если совпадение включает невидимый текст. Для этого оверлей должен иметь свойство &lt;code&gt;isearch-open-invisible&lt;/code&gt; ,отличное от &lt;code&gt;nil&lt;/code&gt; . Значением свойства должна быть функция, которая должна вызываться с наложением в качестве аргумента. Эта функция должна постоянно делать наложение видимым; он используется, когда совпадение перекрывает оверлей при выходе из поиска.</target>
        </trans-unit>
        <trans-unit id="e6d579c6cc398fe7db545dd582fc67de8b2d582c" translate="yes" xml:space="preserve">
          <source>Indent all the lines in a region.</source>
          <target state="translated">Сделайте отступы от всех линий в регионе.</target>
        </trans-unit>
        <trans-unit id="42c518bd88aefe4faecc452be3932f9e029498cb" translate="yes" xml:space="preserve">
          <source>Indent calls to this function or macro according to &lt;var&gt;indent-spec&lt;/var&gt;. This is typically used for macros, though it works for functions too. See &lt;a href=&quot;indenting-macros#Indenting-Macros&quot;&gt;Indenting Macros&lt;/a&gt;.</source>
          <target state="translated">Выполните отступы для вызовов этой функции или макроса в соответствии со &lt;var&gt;indent-spec&lt;/var&gt; . Обычно это используется для макросов, но работает и для функций. См. &lt;a href=&quot;indenting-macros#Indenting-Macros&quot;&gt;Макросы с отступом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27176cfb7708a018b06cd9d8ea7336b632a76f0d" translate="yes" xml:space="preserve">
          <source>Indent current token as a &lt;em&gt;separator&lt;/em&gt;.</source>
          <target state="translated">Сделать отступ для текущего токена как &lt;em&gt;разделителя&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="66b7ce43ce4a7ca89f6dad39cb0198725d35356c" translate="yes" xml:space="preserve">
          <source>Indent the current line based on previous lines.</source>
          <target state="translated">Отбросьте текущую строку на основании предыдущих строк.</target>
        </trans-unit>
        <trans-unit id="c9ec7fcf0ce1c005cbdd2ae9ab39e1773e6bf368" translate="yes" xml:space="preserve">
          <source>Indentation</source>
          <target state="translated">Indentation</target>
        </trans-unit>
        <trans-unit id="511f4889f97fada7d908032cc1464f2aa35c8004" translate="yes" xml:space="preserve">
          <source>Indentation Controlled by Major Mode</source>
          <target state="translated">Индентация контролируется основным режимом</target>
        </trans-unit>
        <trans-unit id="fdac28e1c2199ac39cc5e09f4dd786cd625bd4a4" translate="yes" xml:space="preserve">
          <source>Indentation Primitives</source>
          <target state="translated">Отражение Примитивы</target>
        </trans-unit>
        <trans-unit id="5b82b1b833300c0e6e5e24537ad294a6d135f9fa" translate="yes" xml:space="preserve">
          <source>Indentation Relative to Previous Lines</source>
          <target state="translated">Отражение относительно предыдущих линий</target>
        </trans-unit>
        <trans-unit id="2af2ccd8b84225bf2c735da91f1184265c730f6a" translate="yes" xml:space="preserve">
          <source>Indentation-Based Motion Commands</source>
          <target state="translated">Команды движения,основанные на индентации</target>
        </trans-unit>
        <trans-unit id="1bb77083feeb12d0ebb47ef46a39b5078cd5cb2d" translate="yes" xml:space="preserve">
          <source>Indenting Macros</source>
          <target state="translated">Отдаленные макросы</target>
        </trans-unit>
        <trans-unit id="30f00ddc559ee66f1e7768bbbc4d7eee4d538190" translate="yes" xml:space="preserve">
          <source>Indenting an Entire Region</source>
          <target state="translated">Указание целой области</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="8f868c1e82b2154aed66be4aaa7e76b45121fbff" translate="yes" xml:space="preserve">
          <source>Index including concepts, functions, variables, and other terms.</source>
          <target state="translated">Индекс,включающий понятия,функции,переменные и другие термины.</target>
        </trans-unit>
        <trans-unit id="d52c4a56e9e6d6db73917b478317c4b1d432ad1f" translate="yes" xml:space="preserve">
          <source>Indicates that the specification is for a defining form. Edebug&amp;rsquo;s definition of a defining form is a form containing one or more code forms which are saved and executed later, after the execution of the defining form.</source>
          <target state="translated">Указывает, что спецификация предназначена для определения формы. Определение Edebug определяющей формы - это форма, содержащая одну или несколько кодовых форм, которые сохраняются и выполняются позже, после выполнения определяющей формы.</target>
        </trans-unit>
        <trans-unit id="1112b756bb004fe882859143d87adf31c2f5d050" translate="yes" xml:space="preserve">
          <source>Indirect Buffers</source>
          <target state="translated">Косвенные буферы</target>
        </trans-unit>
        <trans-unit id="938b66bd8c62095908b57d694e88050ca1007edd" translate="yes" xml:space="preserve">
          <source>Individual characters are used occasionally in programs, but it is more common to work with &lt;em&gt;strings&lt;/em&gt;, which are sequences composed of characters. See &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;.</source>
          <target state="translated">В программах иногда используются отдельные символы, но чаще всего работают со &lt;em&gt;строками&lt;/em&gt; , которые представляют собой последовательности, состоящие из символов. См. &lt;a href=&quot;string-type#String-Type&quot;&gt;Тип строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="ad474c9deee501ca52324eb72953350dc14402c1" translate="yes" xml:space="preserve">
          <source>Info about total size of Lisp objects made so far.</source>
          <target state="translated">Информация об общем размере объектов Lisp,сделанных до сих пор.</target>
        </trans-unit>
        <trans-unit id="e73d741db9df809634f2d60fc44dc32e7f4bc7e7" translate="yes" xml:space="preserve">
          <source>Info for users downgrading to Emacs 26.</source>
          <target state="translated">Информация для пользователей,понижающих свой рейтинг до Emacs 26.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="8247fbb975f100a6b13b56c054fa3613a36b297b" translate="yes" xml:space="preserve">
          <source>Information about Files</source>
          <target state="translated">Информация о Файлах</target>
        </trans-unit>
        <trans-unit id="df29a9e6a31bec3e8b780a960759047a5bd6a25f" translate="yes" xml:space="preserve">
          <source>Information from Markers</source>
          <target state="translated">Информация с Маркеров</target>
        </trans-unit>
        <trans-unit id="3ef56c865ee91dd66ebad0347cc1f0de75602bc3" translate="yes" xml:space="preserve">
          <source>Information from the Command Loop</source>
          <target state="translated">Информация из командного шлейфа</target>
        </trans-unit>
        <trans-unit id="18c79d206ba3bf95c4d3ca95be49d37877182f30" translate="yes" xml:space="preserve">
          <source>Informing user about progress of a long operation.</source>
          <target state="translated">Информирование пользователя о ходе длительной операции.</target>
        </trans-unit>
        <trans-unit id="d8a1fba394d47f17007b00e6ef12b9c86a3c6414" translate="yes" xml:space="preserve">
          <source>Inherit standard syntax: &amp;lsquo;</source>
          <target state="translated">Наследовать стандартный синтаксис: '</target>
        </trans-unit>
        <trans-unit id="15e80c1c18978164d737579b198c39c73404e4e1" translate="yes" xml:space="preserve">
          <source>Inheritance and Keymaps</source>
          <target state="translated">Наследство и карты памяти</target>
        </trans-unit>
        <trans-unit id="fb691787cc7690e0df61a80ff9e0643eb7d0d6da" translate="yes" xml:space="preserve">
          <source>Initial Frame Parameters</source>
          <target state="translated">Параметры начального кадра</target>
        </trans-unit>
        <trans-unit id="89a2bccb3e4d6523cbe25ad5db3ff715866a115e" translate="yes" xml:space="preserve">
          <source>Initial Input</source>
          <target state="translated">Начальный вход</target>
        </trans-unit>
        <trans-unit id="eb607b40a369ea5599a4b2f0220d4f687f78016b" translate="yes" xml:space="preserve">
          <source>Initialize the log function of a server process to &lt;var&gt;log&lt;/var&gt;. The log function is called each time the server accepts a network connection from a client. The arguments passed to the log function are &lt;var&gt;server&lt;/var&gt;, &lt;var&gt;connection&lt;/var&gt;, and &lt;var&gt;message&lt;/var&gt;; where &lt;var&gt;server&lt;/var&gt; is the server process, &lt;var&gt;connection&lt;/var&gt; is the new process for the connection, and &lt;var&gt;message&lt;/var&gt; is a string describing what has happened.</source>
          <target state="translated">Инициализируйте функцию журнала серверного процесса для ведения &lt;var&gt;log&lt;/var&gt; . Функция журнала вызывается каждый раз, когда сервер принимает сетевое соединение от клиента. В функцию журнала передаются следующие аргументы: &lt;var&gt;server&lt;/var&gt; , &lt;var&gt;connection&lt;/var&gt; и &lt;var&gt;message&lt;/var&gt; ; где &lt;var&gt;server&lt;/var&gt; - это серверный процесс, &lt;var&gt;connection&lt;/var&gt; - это новый процесс для подключения, а &lt;var&gt;message&lt;/var&gt; - это строка, описывающая, что произошло.</target>
        </trans-unit>
        <trans-unit id="f894ea5a16cfcad8d7176dad8de92207ba46e301" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;.</source>
          <target state="translated">Инициализируйте фильтр процесса для &lt;var&gt;filter&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="4bdcb3b64e7635d1c8dde72370f13421e348ea64" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;. If not specified, a default filter will be provided, which can be changed later. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">Инициализируйте фильтр процесса для &lt;var&gt;filter&lt;/var&gt; . Если не указан, будет предоставлен фильтр по умолчанию, который можно будет изменить позже. См. &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Функции фильтра&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88aa27fccdee463394440c83004deae351722113" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;. If not specified, a default filter will be provided, which can be overridden later. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">Инициализируйте фильтр процесса для &lt;var&gt;filter&lt;/var&gt; . Если не указан, будет предоставлен фильтр по умолчанию, который можно изменить позже. См. &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Функции фильтра&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="978fecd8f603fe8d25457aa9a55a2791886af74d" translate="yes" xml:space="preserve">
          <source>Initialize the process plist to &lt;var&gt;plist&lt;/var&gt;.</source>
          <target state="translated">Инициализируйте процесс plist до &lt;var&gt;plist&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c97165454b295da9973e4e05e4127a6851e7f5bd" translate="yes" xml:space="preserve">
          <source>Initialize the process query flag to &lt;var&gt;query-flag&lt;/var&gt;. See &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;.</source>
          <target state="translated">Инициализируйте флаг &lt;var&gt;query-flag&lt;/var&gt; процесса на флаг запроса . См. &amp;laquo; &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Запрос перед выходом&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1296ca254782c4485a383df44dbf7f61ee7b4bc5" translate="yes" xml:space="preserve">
          <source>Initialize the process query flag to &lt;var&gt;query-flag&lt;/var&gt;. See &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;. The flags defaults to &lt;code&gt;nil&lt;/code&gt; if unspecified.</source>
          <target state="translated">Инициализируйте флаг &lt;var&gt;query-flag&lt;/var&gt; процесса на флаг запроса . См. &amp;laquo; &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Запрос перед выходом&amp;raquo;&lt;/a&gt; . Если не указано &lt;code&gt;nil&lt;/code&gt; флаги по умолчанию равны нулю .</target>
        </trans-unit>
        <trans-unit id="7423f99e44e5c0fe954c4b5fbab30632bfd77607" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;.</source>
          <target state="translated">Инициализировать дозорный процесс для &lt;var&gt;sentinel&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="9db86c8bfdd16aec885a8fb101a51297ca90199b" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;. If not specified, a default sentinel will be used, which can be changed later. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">Инициализировать дозорный процесс для &lt;var&gt;sentinel&lt;/var&gt; . Если не указано иное, будет использоваться дозорный по умолчанию, который можно изменить позже. Смотрите &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="438b44ac9a269df0c942362a3b40baff51fec529" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;. If not specified, a default sentinel will be used, which can be overridden later. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">Инициализировать дозорный процесс для &lt;var&gt;sentinel&lt;/var&gt; . Если не указано иное, будет использоваться дозорный по умолчанию, который можно изменить позже. Смотрите &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc3466ae2da1d30465b2916d783d7d5e733df96c" translate="yes" xml:space="preserve">
          <source>Initialize the type of device used to communicate with the subprocess. Possible values are &lt;code&gt;pty&lt;/code&gt; to use a pty, &lt;code&gt;pipe&lt;/code&gt; to use a pipe, or &lt;code&gt;nil&lt;/code&gt; to use the default derived from the value of the &lt;code&gt;process-connection-type&lt;/code&gt; variable. This parameter and the value of &lt;code&gt;process-connection-type&lt;/code&gt; are ignored if a non-&lt;code&gt;nil&lt;/code&gt; value is specified for the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, the type will always be &lt;code&gt;pipe&lt;/code&gt;. On systems where ptys are not available (MS-Windows), this parameter is likewise ignored, and pipes are used unconditionally.</source>
          <target state="translated">Инициализировать тип устройства, используемого для связи с подпроцессом. Возможные значения: &lt;code&gt;pty&lt;/code&gt; , чтобы использовать pty, &lt;code&gt;pipe&lt;/code&gt; , чтобы использовать pipe, или &lt;code&gt;nil&lt;/code&gt; , чтобы использовать значение по умолчанию, полученное из значения переменной &lt;code&gt;process-connection-type&lt;/code&gt; . Этот параметр и значение типа &lt;code&gt;process-connection-type&lt;/code&gt; игнорируются, если для параметра &lt;code&gt;:stderr&lt;/code&gt; указано значение, отличное от &lt;code&gt;nil&lt;/code&gt; ; в этом случае тип всегда будет &lt;code&gt;pipe&lt;/code&gt; . В системах, где ptys недоступны (MS-Windows), этот параметр также игнорируется, и каналы используются безоговорочно.</target>
        </trans-unit>
        <trans-unit id="75ba3477c577bc61f2782c6fbd5d3918d3d93888" translate="yes" xml:space="preserve">
          <source>Inline (&lt;code&gt;defsubst&lt;/code&gt;) functions are less troublesome; if you compile a call to such a function before its definition is known, the call will still work right, it will just run slower.</source>
          <target state="translated">Встроенные функции ( &lt;code&gt;defsubst&lt;/code&gt; ) вызывают меньше хлопот; если вы скомпилируете вызов такой функции до того, как станет известно ее определение, вызов все равно будет работать правильно, просто он будет работать медленнее.</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">Онлайн-функции</target>
        </trans-unit>
        <trans-unit id="023bd002a35d8328e1b84deea2b2fbe846651660" translate="yes" xml:space="preserve">
          <source>Inner Frame</source>
          <target state="translated">Внутренняя рамка</target>
        </trans-unit>
        <trans-unit id="1ff7c24cdc862e41c4384103afd571ff8024a31c" translate="yes" xml:space="preserve">
          <source>Input Events</source>
          <target state="translated">Входные события</target>
        </trans-unit>
        <trans-unit id="68e31416a1a24dd5f2a79386c7cd5ebc7d038f16" translate="yes" xml:space="preserve">
          <source>Input Focus</source>
          <target state="translated">Входной фокус</target>
        </trans-unit>
        <trans-unit id="88198074ced9d4479d4b7e9aafe153884a14b789" translate="yes" xml:space="preserve">
          <source>Input Functions</source>
          <target state="translated">Входные функции</target>
        </trans-unit>
        <trans-unit id="c968ad8768affe487c292b6adc7616df4a013a6b" translate="yes" xml:space="preserve">
          <source>Input Methods</source>
          <target state="translated">Входные методы</target>
        </trans-unit>
        <trans-unit id="a821e6c8419f780e8743b7bf306490cddd9913c4" translate="yes" xml:space="preserve">
          <source>Input Modes</source>
          <target state="translated">Режимы ввода</target>
        </trans-unit>
        <trans-unit id="eed11d0bb1de0f449227ff92bf6d2ad650126f01" translate="yes" xml:space="preserve">
          <source>Input Streams</source>
          <target state="translated">Входные потоки</target>
        </trans-unit>
        <trans-unit id="3b3948df9e555ca646262a35e33cb7cf68613dc1" translate="yes" xml:space="preserve">
          <source>Input methods allow users to enter various non-ASCII characters without special keyboards.</source>
          <target state="translated">Способы ввода позволяют пользователям вводить различные не-ASCII-символы без использования специальных клавиатур.</target>
        </trans-unit>
        <trans-unit id="bf60d2635214ca206c57f12fa87775f6b4f038df" translate="yes" xml:space="preserve">
          <source>Insert the output in a buffer with that name, before point.</source>
          <target state="translated">Вставить вывод в буфер с таким именем,перед точкой.</target>
        </trans-unit>
        <trans-unit id="3aa29461af0f56c0dd73083f79d4a003b7af3788" translate="yes" xml:space="preserve">
          <source>Insert the output in that buffer, before point. This includes both the standard output stream and the standard error stream of the process.</source>
          <target state="translated">Вставьте выход в этот буфер,перед точкой.Это включает в себя как стандартный поток вывода,так и стандартный поток ошибок процесса.</target>
        </trans-unit>
        <trans-unit id="1c64a3bbdde10f3ebb444ccc0c14466f3d048a31" translate="yes" xml:space="preserve">
          <source>Insert the output in the current buffer, before point.</source>
          <target state="translated">Вставить выход в токовый буфер,перед точкой.</target>
        </trans-unit>
        <trans-unit id="0d849e555da7ae1ee48fec0567933a06f27173ff" translate="yes" xml:space="preserve">
          <source>Insert the strings &lt;var&gt;strings&lt;/var&gt;, just like the function &lt;code&gt;insert-before-markers&lt;/code&gt;, but inherit any sticky properties from the adjoining text.</source>
          <target state="translated">Вставьте строки &lt;var&gt;strings&lt;/var&gt; точно так же, как функция &lt;code&gt;insert-before-markers&lt;/code&gt; , но унаследуйте любые липкие свойства от смежного текста.</target>
        </trans-unit>
        <trans-unit id="90ef3b52113b2290b776d5edcbf7341e258eb075" translate="yes" xml:space="preserve">
          <source>Insert the strings &lt;var&gt;strings&lt;/var&gt;, just like the function &lt;code&gt;insert&lt;/code&gt;, but inherit any sticky properties from the adjoining text.</source>
          <target state="translated">Вставьте строки &lt;var&gt;strings&lt;/var&gt; точно так же, как &lt;code&gt;insert&lt;/code&gt; функции , но унаследуйте любые липкие свойства от смежного текста.</target>
        </trans-unit>
        <trans-unit id="d4b10e59d8cd180c5c4c38922e8312024dcd937c" translate="yes" xml:space="preserve">
          <source>Inserting Text</source>
          <target state="translated">Вставка текста</target>
        </trans-unit>
        <trans-unit id="f62a121c8905d9b70d56a62824bb530abbb240fe" translate="yes" xml:space="preserve">
          <source>Insertion and deletion in a buffer must check all the markers and relocate them if necessary. This slows processing in a buffer with a large number of markers. For this reason, it is a good idea to make a marker point nowhere if you are sure you don&amp;rsquo;t need it any more. Markers that can no longer be accessed are eventually removed (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;).</source>
          <target state="translated">Вставка и удаление в буфере должны проверять все маркеры и при необходимости перемещать их. Это замедляет обработку в буфере с большим количеством маркеров. По этой причине рекомендуется нигде не устанавливать маркер, если вы уверены, что он вам больше не нужен. Маркеры, к которым больше нельзя получить доступ, в конечном итоге удаляются (см. &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Сборка мусора&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="17ee0ff6e39b0d949eba112fc3626357b3a22a32" translate="yes" xml:space="preserve">
          <source>Insertion functions signal an error if the current buffer is read-only (see &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;) or if they insert within read-only text (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;).</source>
          <target state="translated">Функции вставки сигнализируют об ошибке, если текущий буфер доступен только для чтения (см. &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Буферы только для чтения&lt;/a&gt; ) или если они вставляются в текст, доступный только для чтения (см. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5434f633b863c5453f6112150b15fbd13f9dde5c" translate="yes" xml:space="preserve">
          <source>Insertion moves markers located at positions after the insertion point, so that they stay with the surrounding text (see &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;). When a marker points at the place of insertion, insertion may or may not relocate the marker, depending on the marker&amp;rsquo;s insertion type (see &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;). Certain special functions such as &lt;code&gt;insert-before-markers&lt;/code&gt; relocate all such markers to point after the inserted text, regardless of the markers&amp;rsquo; insertion type.</source>
          <target state="translated">При вставке маркеры, расположенные после точки вставки, перемещаются так, чтобы они оставались рядом с окружающим текстом (см. &lt;a href=&quot;markers#Markers&quot;&gt;Маркеры&lt;/a&gt; ). Когда маркер указывает на место вставки, вставка может перемещать или не перемещать маркер в зависимости от типа вставки маркера (см. &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Типы вставки маркера&lt;/a&gt; ). Некоторые специальные функции, такие как &lt;code&gt;insert-before-markers&lt;/code&gt; перемещают все такие маркеры так, чтобы они указывали после вставленного текста, независимо от типа вставки маркеров.</target>
        </trans-unit>
        <trans-unit id="bd95261b13119729b7f21abc1b22f07a4f3b895c" translate="yes" xml:space="preserve">
          <source>Insertion next to a read-only character is an error if inserting ordinary text there would inherit the &lt;code&gt;read-only&lt;/code&gt; property due to stickiness. Thus, you can control permission to insert next to read-only text by controlling the stickiness. See &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Sticky Properties&lt;/a&gt;.</source>
          <target state="translated">Вставка рядом с символом только для чтения является ошибкой, если вставка обычного текста туда унаследует свойство &lt;code&gt;read-only&lt;/code&gt; из-за липкости. Таким образом, вы можете контролировать разрешение на вставку рядом с текстом, доступным только для чтения, контролируя закрепление. См. &amp;laquo; &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Липкие свойства&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0021bd63930267acc7e983ae1c2b95215f4a5f19" translate="yes" xml:space="preserve">
          <source>Insertion of text at the border between intervals also raises questions that have no satisfactory answer.</source>
          <target state="translated">Вставка текста на границе между интервалами также вызывает вопросы,на которые нет удовлетворительного ответа.</target>
        </trans-unit>
        <trans-unit id="a632b0d51711f298bce3fb60664237d20718b891" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;repeat&lt;/code&gt; block, these contain the maximum number of repetitions (as specified by the &lt;var&gt;count&lt;/var&gt; parameter), and the current repetition number (counting from 0). Setting &lt;code&gt;count&lt;/code&gt; to zero will terminate the inner-most repeat block after the current repetition has completed.</source>
          <target state="translated">Внутри блока &lt;code&gt;repeat&lt;/code&gt; они содержат максимальное количество повторений (как указано параметром &lt;var&gt;count&lt;/var&gt; ) и текущее количество повторений (считая от 0). Установка &lt;code&gt;count&lt;/code&gt; в ноль завершит самый внутренний блок повторения после завершения текущего повторения.</target>
        </trans-unit>
        <trans-unit id="bbecdb627416247ff6d11ce653cbc5c864a55b32" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;filter&lt;/var&gt; as the process filter.</source>
          <target state="translated">Установите &lt;var&gt;filter&lt;/var&gt; в качестве технологического фильтра.</target>
        </trans-unit>
        <trans-unit id="44e7cf106d78a4e14ed20efc7a4b48dce495ecdb" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;plist&lt;/var&gt; as the initial plist of the process.</source>
          <target state="translated">Установите &lt;var&gt;plist&lt;/var&gt; в качестве начального списка процесса.</target>
        </trans-unit>
        <trans-unit id="f8052583c9ddb4adcb58b5e1d5c25c1b544fa693" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;sentinel&lt;/var&gt; as the process sentinel.</source>
          <target state="translated">Установите &lt;var&gt;sentinel&lt;/var&gt; в качестве дозорного процесса.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="16d39f83c12d88464b887e1ce49fd00973ec280c" translate="yes" xml:space="preserve">
          <source>Installing a package, either via the command &lt;code&gt;package-install-file&lt;/code&gt;, or via the Package Menu, creates a subdirectory of &lt;code&gt;package-user-dir&lt;/code&gt; named</source>
          <target state="translated">При установке пакета с помощью команды &lt;code&gt;package-install-file&lt;/code&gt; или через меню Package создается подкаталог &lt;code&gt;package-user-dir&lt;/code&gt; с именем</target>
        </trans-unit>
        <trans-unit id="44bbd8cdd2a2c9792cd51329260082dfa8dcec4d" translate="yes" xml:space="preserve">
          <source>Installing several buffer changes atomically.</source>
          <target state="translated">Установка нескольких буферов изменяется атоматически.</target>
        </trans-unit>
        <trans-unit id="0b8fb4bde942015c31c40daedf4c7212f24d5f6e" translate="yes" xml:space="preserve">
          <source>Instead of a string, &lt;var&gt;rep&lt;/var&gt; can be a function. In that case, &lt;code&gt;replace-regexp-in-string&lt;/code&gt; calls &lt;var&gt;rep&lt;/var&gt; for each match, passing the text of the match as its sole argument. It collects the value &lt;var&gt;rep&lt;/var&gt; returns and passes that to &lt;code&gt;replace-match&lt;/code&gt; as the replacement string. The match data at this point are the result of matching &lt;var&gt;regexp&lt;/var&gt; against a substring of &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">Вместо строки &lt;var&gt;rep&lt;/var&gt; может быть функцией. В этом случае &lt;code&gt;replace-regexp-in-string&lt;/code&gt; вызывает &lt;var&gt;rep&lt;/var&gt; для каждого совпадения, передавая текст совпадения в качестве единственного аргумента. Он собирает значение, возвращаемое &lt;var&gt;rep&lt;/var&gt; , и передает его для &lt;code&gt;replace-match&lt;/code&gt; в качестве строки замены. Данные соответствия в этой точке являются результатом сопоставления &lt;var&gt;regexp&lt;/var&gt; с подстрокой &lt;var&gt;string&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3f1753669c714a1d7e578072aa4ed5c9dba79dc2" translate="yes" xml:space="preserve">
          <source>Instead of adding a buffer name or a regular expression to one of these options use a &lt;code&gt;display-buffer-alist&lt;/code&gt; entry for that buffer specifying the action function &lt;code&gt;display-buffer-same-window&lt;/code&gt;.</source>
          <target state="translated">Вместо добавления имени буфера или регулярного выражения к одному из этих параметров используйте запись &lt;code&gt;display-buffer-alist&lt;/code&gt; для этого буфера, определяющую функцию действия &lt;code&gt;display-buffer-same-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a6282c7355fde001d90d645305cae7bf3bf7cc" translate="yes" xml:space="preserve">
          <source>Instead of binding the mouse command in a major mode keymap, you can bind it within the link text, using the &lt;code&gt;keymap&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;). For instance:</source>
          <target state="translated">Вместо привязки команды мыши к раскладке клавиатуры основного режима ее можно привязать к тексту ссылки, используя свойство текста &lt;code&gt;keymap&lt;/code&gt; (см. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&lt;/a&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="2670142fd5a30e583bc4b4555d7ebad06b38986e" translate="yes" xml:space="preserve">
          <source>Instead of computing text properties for all the text in the buffer, you can arrange to compute the text properties for parts of the text when and if something depends on them.</source>
          <target state="translated">Вместо того,чтобы вычислять свойства текста для всего текста в буфере,можно организовать вычисление свойств текста для частей текста,когда и если от них что-то зависит.</target>
        </trans-unit>
        <trans-unit id="e0c382c2cc436ecc3057d41eae8562719a5d21f3" translate="yes" xml:space="preserve">
          <source>Instead of customizing this variable to &lt;code&gt;t&lt;/code&gt;, customize &lt;code&gt;display-buffer-base-action&lt;/code&gt;, for example, as follows:</source>
          <target state="translated">Вместо настройки этой переменной на &lt;code&gt;t&lt;/code&gt; , настройте &lt;code&gt;display-buffer-base-action&lt;/code&gt; , например, следующим образом:</target>
        </trans-unit>
        <trans-unit id="f48c49102d6b6fcfa99d56a07826d258451b4f42" translate="yes" xml:space="preserve">
          <source>Instead of the &amp;lsquo;</source>
          <target state="translated">Вместо '</target>
        </trans-unit>
        <trans-unit id="27778412a3ebd3d11dbf8545f85798fd64a1f13a" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;region-beginning&lt;/code&gt; and &lt;code&gt;region-end&lt;/code&gt;, a command designed to operate on a region should normally use &lt;code&gt;interactive&lt;/code&gt; with the &amp;lsquo;</source>
          <target state="translated">Вместо того чтобы использовать &lt;code&gt;region-beginning&lt;/code&gt; и &lt;code&gt;region-end&lt;/code&gt; , команды , предназначенные для работы на области должны обычно использовать &lt;code&gt;interactive&lt;/code&gt; с '</target>
        </trans-unit>
        <trans-unit id="aaf2819d27bf1d28940bd55fb19452da2f766bc0" translate="yes" xml:space="preserve">
          <source>Instead of using this variable, it is cleaner to use another, newer feature: to pass the function as the &lt;var&gt;read-function&lt;/var&gt; argument to &lt;code&gt;eval-region&lt;/code&gt;. See &lt;a href=&quot;eval#Definition-of-eval_002dregion&quot;&gt;Eval&lt;/a&gt;.</source>
          <target state="translated">Вместо использования этой переменной проще использовать другую, более новую функцию: передать функцию в качестве аргумента &lt;var&gt;read-function&lt;/var&gt; в &lt;code&gt;eval-region&lt;/code&gt; . См. &lt;a href=&quot;eval#Definition-of-eval_002dregion&quot;&gt;Eval&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d2c7cb2dbf87e9087cb37f404447063050738e9" translate="yes" xml:space="preserve">
          <source>Instead of writing a character literally into a multibyte string, you can write it as its character code using an escape sequence. See &lt;a href=&quot;general-escape-syntax#General-Escape-Syntax&quot;&gt;General Escape Syntax&lt;/a&gt;, for details about escape sequences.</source>
          <target state="translated">Вместо того, чтобы писать символ буквально в многобайтовой строке, вы можете записать его как код символа, используя escape-последовательность. См. &amp;laquo; &lt;a href=&quot;general-escape-syntax#General-Escape-Syntax&quot;&gt;Общий синтаксис&lt;/a&gt; экранирования&amp;raquo; для получения подробной информации о управляющих последовательностях.</target>
        </trans-unit>
        <trans-unit id="8e0e5c167c46a9a94a4405deed528806c20888f6" translate="yes" xml:space="preserve">
          <source>Instrumenting Macro Calls</source>
          <target state="translated">Инструментальные макрозвонки</target>
        </trans-unit>
        <trans-unit id="01d3a83d4f8979d33eb587942de6ed97b7aa1bf4" translate="yes" xml:space="preserve">
          <source>Instrumenting for Edebug</source>
          <target state="translated">Инструментарий для Edebug</target>
        </trans-unit>
        <trans-unit id="08303d355edd3eb94e9dada9e860f7f9d4221540" translate="yes" xml:space="preserve">
          <source>Integer Basics</source>
          <target state="translated">Целостные основы</target>
        </trans-unit>
        <trans-unit id="5944fda631d99e7fe1c28748c40fccba38502e8a" translate="yes" xml:space="preserve">
          <source>Integer Type</source>
          <target state="translated">Целочисленный тип</target>
        </trans-unit>
        <trans-unit id="0392f509cf780dcebf79ba10d500e70f3c35a232" translate="yes" xml:space="preserve">
          <source>Integers in Emacs Lisp are not limited to the machine word size. Under the hood, though, there are two kinds of integers: smaller ones, called &lt;em&gt;fixnums&lt;/em&gt;, and larger ones, called &lt;em&gt;bignums&lt;/em&gt;. Although Emacs Lisp code ordinarily should not depend on whether an integer is a fixnum or a bignum, older Emacs versions support only fixnums, some functions in Emacs still accept only fixnums, and older Emacs Lisp code may have trouble when given bignums. For example, while older Emacs Lisp code could safely compare integers for numeric equality with &lt;code&gt;eq&lt;/code&gt;, the presence of bignums means that equality predicates like &lt;code&gt;eql&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; should now be used to compare integers.</source>
          <target state="translated">Целые числа в Emacs Lisp не ограничены размером машинного слова. Однако под капотом есть два вида целых чисел: меньшие, называемые &lt;em&gt;фиксированными числами&lt;/em&gt; , и более крупные, называемые &lt;em&gt;бигнумами&lt;/em&gt; . Хотя код Emacs Lisp обычно не должен зависеть от того, является ли целое число фиксированным или большим числом, старые версии Emacs поддерживают только фиксированные числа, некоторые функции в Emacs по-прежнему принимают только фиксированные числа, а старый код Emacs Lisp может иметь проблемы при задании больших чисел. Например, в то время как более старый код Emacs Lisp мог безопасно сравнивать целые числа на числовое равенство с &lt;code&gt;eq&lt;/code&gt; , наличие bignums означает, что теперь для сравнения целых чисел следует использовать предикаты равенства, такие как &lt;code&gt;eql&lt;/code&gt; и &lt;code&gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdaff6a8856112e0bedf086bd56487ab63649d1a" translate="yes" xml:space="preserve">
          <source>Inter-thread events.</source>
          <target state="translated">Межпотоковые события.</target>
        </trans-unit>
        <trans-unit id="6c3d2212a9f9c32cfe9d9e6085463de2a793ed69" translate="yes" xml:space="preserve">
          <source>Interacting with the POSIX locale.</source>
          <target state="translated">Взаимодействие с локалью POSIX.</target>
        </trans-unit>
        <trans-unit id="a8f3404ff9a3b9a61cebb71bc3145a7e8268e559" translate="yes" xml:space="preserve">
          <source>Interaction with normal keymaps</source>
          <target state="translated">Взаимодействие с обычными клавиатурными картами</target>
        </trans-unit>
        <trans-unit id="3a4d181036b390bfd4c90ee0f787d10de7dd1557" translate="yes" xml:space="preserve">
          <source>Interactive Call</source>
          <target state="translated">Интерактивный звонок</target>
        </trans-unit>
        <trans-unit id="8c112c62a1db80a1fd6eb4c52dbbd37b94063133" translate="yes" xml:space="preserve">
          <source>Interactive interfaces for redefining keys.</source>
          <target state="translated">Интерактивные интерфейсы для переопределения клавиш.</target>
        </trans-unit>
        <trans-unit id="bb426c56195b2ae94b49e74ad823d065b0153c08" translate="yes" xml:space="preserve">
          <source>Interactively, &lt;code&gt;byte-recompile-directory&lt;/code&gt; prompts for &lt;var&gt;directory&lt;/var&gt; and &lt;var&gt;flag&lt;/var&gt; is the prefix argument.</source>
          <target state="translated">В интерактивном режиме команда &lt;code&gt;byte-recompile-directory&lt;/code&gt; запрашивает &lt;var&gt;directory&lt;/var&gt; а &lt;var&gt;flag&lt;/var&gt; является аргументом префикса.</target>
        </trans-unit>
        <trans-unit id="89db943b3ea009e2eeb342d7b413658ef1beb7e7" translate="yes" xml:space="preserve">
          <source>Interactively, &lt;var&gt;mode&lt;/var&gt; is read from the minibuffer using &lt;code&gt;read-file-modes&lt;/code&gt; (see below), which lets the user type in either an integer or a string representing the permissions symbolically.</source>
          <target state="translated">В интерактивном &lt;var&gt;mode&lt;/var&gt; считывается из минибуфера с использованием &lt;code&gt;read-file-modes&lt;/code&gt; (см. Ниже), что позволяет пользователю вводить либо целое число, либо строку, символически представляющую разрешения.</target>
        </trans-unit>
        <trans-unit id="1ac1b597f72189ba2ae56769e0cdd444c02533a2" translate="yes" xml:space="preserve">
          <source>Interactively, or when &lt;var&gt;display&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the return value is also displayed in the echo area.</source>
          <target state="translated">В интерактивном режиме или когда &lt;var&gt;display&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , возвращаемое значение также отображается в эхо-области.</target>
        </trans-unit>
        <trans-unit id="b6a1797fff7a6f70ada887bad92631a8a9bf2bb1" translate="yes" xml:space="preserve">
          <source>Interfacing to an archive web server</source>
          <target state="translated">Взаимодействие с архивным веб-сервером</target>
        </trans-unit>
        <trans-unit id="6fd6296201ee71e0d25d2f3b29fb410be639536c" translate="yes" xml:space="preserve">
          <source>Interfacing to an archive web server.</source>
          <target state="translated">Взаимодействие с архивным веб-сервером.</target>
        </trans-unit>
        <trans-unit id="b88993e0e807666740f1e6e7487891d4221c3508" translate="yes" xml:space="preserve">
          <source>Internal Border</source>
          <target state="translated">Внутренняя граница</target>
        </trans-unit>
        <trans-unit id="1f6f7ba7cb7b347a96d1107fab7991d51090ae38" translate="yes" xml:space="preserve">
          <source>Internal mechanisms of image display.</source>
          <target state="translated">Внутренние механизмы отображения изображений.</target>
        </trans-unit>
        <trans-unit id="aae2d2f7d4d44e63ffbe3d64c1331e1f4a7499c4" translate="yes" xml:space="preserve">
          <source>Internal size of a buffer, i.e., &lt;code&gt;sizeof (struct buffer)&lt;/code&gt;. (Do not confuse with the value returned by &lt;code&gt;buffer-size&lt;/code&gt; function.)</source>
          <target state="translated">Внутренний размер буфера, то есть &lt;code&gt;sizeof (struct buffer)&lt;/code&gt; . (Не путайте со значением, возвращаемым функцией &lt;code&gt;buffer-size&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="5a032235c1121bf9c1e0179ca7ff43c3f2ac2220" translate="yes" xml:space="preserve">
          <source>Internal size of a cons cell, i.e., &lt;code&gt;sizeof (struct Lisp_Cons)&lt;/code&gt;.</source>
          <target state="translated">Внутренний размер cons-ячейки, то есть &lt;code&gt;sizeof (struct Lisp_Cons)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b01e7eab827250f987c16a7e503e6a91dd12d67d" translate="yes" xml:space="preserve">
          <source>Internal size of a float object, i.e., &lt;code&gt;sizeof (struct Lisp_Float)&lt;/code&gt;. (Do not confuse it with the native platform &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.)</source>
          <target state="translated">Внутренний размер объекта с плавающей запятой, то есть &lt;code&gt;sizeof (struct Lisp_Float)&lt;/code&gt; . (Не путайте его с родной платформой &lt;code&gt;float&lt;/code&gt; или &lt;code&gt;double&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="1837980aa62b1a62e48654b616a2e12c11db3594" translate="yes" xml:space="preserve">
          <source>Internal size of a string header, i.e., &lt;code&gt;sizeof (struct Lisp_String)&lt;/code&gt;.</source>
          <target state="translated">Внутренний размер заголовка строки, то есть &lt;code&gt;sizeof (struct Lisp_String)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="674373e621338f8918b9cf85fce5944b7e0a8d86" translate="yes" xml:space="preserve">
          <source>Internal size of a symbol, i.e., &lt;code&gt;sizeof (struct Lisp_Symbol)&lt;/code&gt;.</source>
          <target state="translated">Внутренний размер символа, то есть &lt;code&gt;sizeof (struct Lisp_Symbol)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4e2cb2dd48ef88f7cd7e24e4c124a254fe9f746" translate="yes" xml:space="preserve">
          <source>Internal size of a vector slot, always equal to &lt;code&gt;sizeof (Lisp_Object)&lt;/code&gt;.</source>
          <target state="translated">Внутренний размер векторного слота, всегда равен &lt;code&gt;sizeof (Lisp_Object)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee27812d3f05af328dcd6e592fdf426cab58207" translate="yes" xml:space="preserve">
          <source>Internal size of an interval object, i.e., &lt;code&gt;sizeof (struct interval)&lt;/code&gt;.</source>
          <target state="translated">Внутренний размер объекта интервала, то есть &lt;code&gt;sizeof (struct interval)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c24069c6a8e1694d80a391c18f10c673381b44" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;defalias&lt;/code&gt; normally uses &lt;code&gt;fset&lt;/code&gt; to set the definition. If &lt;var&gt;name&lt;/var&gt; has a &lt;code&gt;defalias-fset-function&lt;/code&gt; property, however, the associated value is used as a function to call in place of &lt;code&gt;fset&lt;/code&gt;.</source>
          <target state="translated">Внутренне &lt;code&gt;defalias&lt;/code&gt; обычно использует &lt;code&gt;fset&lt;/code&gt; для установки определения. Однако, если &lt;var&gt;name&lt;/var&gt; имеет &lt;code&gt;defalias-fset-function&lt;/code&gt; , связанное значение используется как функция для вызова вместо &lt;code&gt;fset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="068796783fad3a87ca900b7c710e4916ea8b3bc6" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;defcustom&lt;/code&gt; uses the symbol property &lt;code&gt;standard-value&lt;/code&gt; to record the expression for the standard value, &lt;code&gt;saved-value&lt;/code&gt; to record the value saved by the user with the customization buffer, and &lt;code&gt;customized-value&lt;/code&gt; to record the value set by the user with the customization buffer, but not saved. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;. In addition, there&amp;rsquo;s &lt;code&gt;themed-value&lt;/code&gt;, which is used to record the value set by a theme (see &lt;a href=&quot;custom-themes#Custom-Themes&quot;&gt;Custom Themes&lt;/a&gt;). These properties are lists, the car of which is an expression that evaluates to the value.</source>
          <target state="translated">Внутренне &lt;code&gt;defcustom&lt;/code&gt; использует &lt;code&gt;standard-value&lt;/code&gt; свойства символа для записи выражения для стандартного значения, &lt;code&gt;saved-value&lt;/code&gt; для записи значения, сохраненного пользователем с помощью буфера настройки, и &lt;code&gt;customized-value&lt;/code&gt; для записи значения, установленного пользователем с настройкой. буфер, но не сохраняется. См. &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Свойства символа&lt;/a&gt; . Кроме того, существует &lt;code&gt;themed-value&lt;/code&gt; , которое используется для записи значения, установленного темой (см. &lt;a href=&quot;custom-themes#Custom-Themes&quot;&gt;Пользовательские темы&lt;/a&gt; ). Эти свойства представляют собой списки, автомобиль которых является выражением, оценивающим значение.</target>
        </trans-unit>
        <trans-unit id="d530007eafdd82a256c358d7298bdbec30d8cfb6" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;make-serial-process&lt;/code&gt; calls &lt;code&gt;serial-process-configure&lt;/code&gt; for the initial configuration of the serial port.</source>
          <target state="translated">Внутренне &lt;code&gt;make-serial-process&lt;/code&gt; вызывает &lt;code&gt;serial-process-configure&lt;/code&gt; для начальной настройки последовательного порта.</target>
        </trans-unit>
        <trans-unit id="793925a115b236f980464335670b39f399baa2cd" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;word-search-forward&lt;/code&gt; and related functions use the function &lt;code&gt;word-search-regexp&lt;/code&gt; to convert &lt;var&gt;string&lt;/var&gt; to a regular expression that ignores punctuation.</source>
          <target state="translated">Внутри функции &lt;code&gt;word-search-forward&lt;/code&gt; и связанные функции используют функцию &lt;code&gt;word-search-regexp&lt;/code&gt; для преобразования &lt;var&gt;string&lt;/var&gt; в регулярное выражение, которое игнорирует знаки препинания.</target>
        </trans-unit>
        <trans-unit id="975cc38153f45730f641194a328f88d442fb0adf" translate="yes" xml:space="preserve">
          <source>Internally, Emacs arranges windows in a tree; each group of siblings has a parent window whose area includes all the siblings. This field points to the window&amp;rsquo;s parent in that tree, as a Lisp object. For the root window of the tree and a minibuffer window this is always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Внутри Emacs выстраивает окна в виде дерева; у каждой группы братьев и сестер есть родительское окно, область которого включает всех братьев и сестер. Это поле указывает на родителя окна в этом дереве как на объект Lisp. Для корневого окна дерева и окна минибуфера это всегда &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9a16f1135c9a066d602dd303b59514a13358f60" translate="yes" xml:space="preserve">
          <source>Internally, Emacs stores each face&amp;rsquo;s default spec in its &lt;code&gt;face-defface-spec&lt;/code&gt; symbol property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;). The &lt;code&gt;saved-face&lt;/code&gt; property stores any face spec saved by the user using the customization buffer; the &lt;code&gt;customized-face&lt;/code&gt; property stores the face spec customized for the current session, but not saved; and the &lt;code&gt;theme-face&lt;/code&gt; property stores an alist associating the active customization settings and Custom themes with the face specs for that face. The face&amp;rsquo;s documentation string is stored in the &lt;code&gt;face-documentation&lt;/code&gt; property.</source>
          <target state="translated">Внутри Emacs хранит спецификацию каждой грани по умолчанию в &lt;code&gt;face-defface-spec&lt;/code&gt; символа face-defface-spec (см. &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Свойства символа&lt;/a&gt; ). Свойство &lt;code&gt;saved-face&lt;/code&gt; хранит любую спецификацию лица, сохраненную пользователем с помощью буфера настройки; на &lt;code&gt;customized-face&lt;/code&gt; собственность сохраняет лицо спецификации настроена для текущей сессии, но не сохраняются; а свойство &lt;code&gt;theme-face&lt;/code&gt; хранит список, связывающий активные параметры настройки и пользовательские темы со спецификациями лица для этого лица. Строка документации лица хранится в свойстве &lt;code&gt;face-documentation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="890345b36f6729af8e091b77ec37233f091c4268" translate="yes" xml:space="preserve">
          <source>Internally, a byte-code function object is much like a vector; its elements can be accessed using &lt;code&gt;aref&lt;/code&gt;. Its printed representation is like that for a vector, with an additional &amp;lsquo;</source>
          <target state="translated">Внутренне объект функции байт-кода очень похож на вектор; к его элементам можно получить доступ с помощью &lt;code&gt;aref&lt;/code&gt; . Его печатное представление похоже на представление вектора с дополнительным символом '</target>
        </trans-unit>
        <trans-unit id="c255d867bde58e3eaa0e52e4d12a66d31afbc458" translate="yes" xml:space="preserve">
          <source>Internally, a record object is much like a vector; its slots can be accessed using &lt;code&gt;aref&lt;/code&gt; and it can be copied using &lt;code&gt;copy-sequence&lt;/code&gt;. However, the first slot is used to hold its type as returned by &lt;code&gt;type-of&lt;/code&gt;. Also, in the current implementation records can have at most 4096 slots, whereas vectors can be much larger. Like arrays, records use zero-origin indexing: the first slot has index 0.</source>
          <target state="translated">Внутренне объект записи очень похож на вектор; доступ к его слотам можно получить с помощью &lt;code&gt;aref&lt;/code&gt; , а его можно скопировать с помощью &lt;code&gt;copy-sequence&lt;/code&gt; . Однако первый слот используется для хранения своего типа, возвращаемого функцией &lt;code&gt;type-of&lt;/code&gt; . Кроме того, в текущей реализации записи могут иметь не более 4096 слотов, тогда как векторы могут быть намного больше. Как и массивы, записи используют индексацию с нулевым происхождением: первый слот имеет индекс 0.</target>
        </trans-unit>
        <trans-unit id="10ce65f3f55d9a82d5a4e5b0c5a3b5dfc8acdf3d" translate="yes" xml:space="preserve">
          <source>Internally, a syntax table is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;). The element at index &lt;var&gt;c&lt;/var&gt; describes the character with code &lt;var&gt;c&lt;/var&gt;; its value is a cons cell which specifies the syntax of the character in question. See &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt;, for details. However, instead of using &lt;code&gt;aset&lt;/code&gt; and &lt;code&gt;aref&lt;/code&gt; to modify and inspect syntax table contents, you should usually use the higher-level functions &lt;code&gt;char-syntax&lt;/code&gt; and &lt;code&gt;modify-syntax-entry&lt;/code&gt;, which are described in &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;.</source>
          <target state="translated">Внутренне таблица синтаксиса представляет собой таблицу символов (см. &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Таблицы&lt;/a&gt; символов ). Элемент с индексом &lt;var&gt;c&lt;/var&gt; описывает символ с кодом &lt;var&gt;c&lt;/var&gt; ; его значение - это cons-ячейка, которая определяет синтаксис рассматриваемого символа. См. Подробности в разделе &amp;laquo; &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Внутреннее устройство таблицы синтаксиса&amp;raquo;&lt;/a&gt; . Однако вместо использования &lt;code&gt;aset&lt;/code&gt; и &lt;code&gt;aref&lt;/code&gt; для изменения и проверки содержимого таблицы синтаксиса обычно следует использовать функции более высокого уровня &lt;code&gt;char-syntax&lt;/code&gt; и &lt;code&gt;modify-syntax-entry&lt;/code&gt; , которые описаны в &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;разделе Функции таблицы синтаксиса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6dcb624548f874717d593593cde5ae43f61956" translate="yes" xml:space="preserve">
          <source>Internally, the dynamic loading of documentation strings is accomplished by writing compiled files with a special Lisp reader construct, &amp;lsquo;</source>
          <target state="translated">Внутри себя динамическая загрузка строк документации выполняется путем записи скомпилированных файлов с помощью специальной конструкции чтения Лиспа, '</target>
        </trans-unit>
        <trans-unit id="6c7d074b02409a43b3c3691b8e3eff070049c70c" translate="yes" xml:space="preserve">
          <source>Internally, the set of parents is stored in the &lt;code&gt;error-conditions&lt;/code&gt; property of the error symbol and the message is stored in the &lt;code&gt;error-message&lt;/code&gt; property of the error symbol.</source>
          <target state="translated">Внутри набор родительских элементов сохраняется в свойстве &lt;code&gt;error-conditions&lt;/code&gt; символа ошибки, а сообщение сохраняется в свойстве &lt;code&gt;error-message&lt;/code&gt; символа ошибки.</target>
        </trans-unit>
        <trans-unit id="5b6293020ceb499ae9005377abda5b9d10b853fe" translate="yes" xml:space="preserve">
          <source>Internally, this function creates an overlay, and gives it a &lt;code&gt;before-string&lt;/code&gt; property containing text that has a &lt;code&gt;display&lt;/code&gt; property whose value is the image. (Whew!)</source>
          <target state="translated">Внутри эта функция создает наложение и предоставляет ему свойство &lt;code&gt;before-string&lt;/code&gt; содержащее текст, имеющий свойство &lt;code&gt;display&lt;/code&gt; , значением которого является изображение. (Уф!)</target>
        </trans-unit>
        <trans-unit id="ad027260c034e64a0aed9ec0c21434a870d67bde" translate="yes" xml:space="preserve">
          <source>Internally, this function inserts &lt;var&gt;string&lt;/var&gt; in the buffer, and gives it a &lt;code&gt;display&lt;/code&gt; property which specifies &lt;var&gt;image&lt;/var&gt;. See &lt;a href=&quot;display-property#Display-Property&quot;&gt;Display Property&lt;/a&gt;.</source>
          <target state="translated">Внутренне эта функция вставляет &lt;var&gt;string&lt;/var&gt; в буфер и дает ей свойство &lt;code&gt;display&lt;/code&gt; которое определяет &lt;var&gt;image&lt;/var&gt; . См. Раздел &lt;a href=&quot;display-property#Display-Property&quot;&gt;Свойство отображения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d82805e46a43054034aa8dbdc3072940853963ca" translate="yes" xml:space="preserve">
          <source>Internals of Drag-and-Drop implementation.</source>
          <target state="translated">Интерналы внедрения Drag-and-Drop.</target>
        </trans-unit>
        <trans-unit id="0878947a69e042d32e6c0e5b544cd467d1e941d1" translate="yes" xml:space="preserve">
          <source>Internals of the Debugger</source>
          <target state="translated">Интерналы отладчика</target>
        </trans-unit>
        <trans-unit id="f059416759860bf53ccffccb3662c0ac1c504a36" translate="yes" xml:space="preserve">
          <source>Internals of the Kill Ring</source>
          <target state="translated">Интерналы Убийственного Кольца</target>
        </trans-unit>
        <trans-unit id="c8a6d283f50874c1f273c7066e8f6024a632ca2a" translate="yes" xml:space="preserve">
          <source>International characters in strings.</source>
          <target state="translated">Международные символы в строках.</target>
        </trans-unit>
        <trans-unit id="2a55fdbcbc93e7871a3735ecdecb37fb80ceb461" translate="yes" xml:space="preserve">
          <source>Interning ensures that each obarray has just one symbol with any particular name. Other like-named symbols may exist, but not in the same obarray. Thus, the reader gets the same symbols for the same names, as long as you keep reading with the same obarray.</source>
          <target state="translated">Интернэшнл гарантирует,что каждый обаррей имеет только один символ с определенным именем.Другие подобные символы могут существовать,но не в том же самом оберрае.Таким образом,читатель получает одни и те же символы для одних и тех же имен,если вы продолжаете читать с одним и тем же obarray.</target>
        </trans-unit>
        <trans-unit id="a82f77a8f55334d8bb59e260c5127cc00a4536b2" translate="yes" xml:space="preserve">
          <source>Interning usually happens automatically in the reader, but sometimes other programs need to do it. For example, after the</source>
          <target state="translated">Интеграция обычно происходит автоматически в читающем устройстве,но иногда это приходится делать другим программам.Например,после</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="8ed8ee7e55170bcbcc50e6f4ddad4940be31b3b2" translate="yes" xml:space="preserve">
          <source>Introduction and concepts.</source>
          <target state="translated">Введение и понятия.</target>
        </trans-unit>
        <trans-unit id="f63dc883116ea7e854aa44d7f9ec4421e0ce2395" translate="yes" xml:space="preserve">
          <source>Introduction and conventions used.</source>
          <target state="translated">Введение и использованные конвенции.</target>
        </trans-unit>
        <trans-unit id="b8caf81bc82bf9149f7f4f8ca46a4d2df8d59d59" translate="yes" xml:space="preserve">
          <source>Introduction to Buffer-Local Variables</source>
          <target state="translated">Введение в буферно-локальные переменные</target>
        </trans-unit>
        <trans-unit id="ca959ab108e8c4b82e06c2cd8e7df1402c2fdca1" translate="yes" xml:space="preserve">
          <source>Introduction to Evaluation</source>
          <target state="translated">Введение в оценку</target>
        </trans-unit>
        <trans-unit id="424b5352ecd6aed0c4787a5e67cf7822394d4180" translate="yes" xml:space="preserve">
          <source>Introduction to Minibuffers</source>
          <target state="translated">Введение в минибуфера</target>
        </trans-unit>
        <trans-unit id="08f3e034c9cceb45ce8ecb8f79ad7b810051e748" translate="yes" xml:space="preserve">
          <source>Introduction to Reading and Printing</source>
          <target state="translated">Введение в чтение и печать</target>
        </trans-unit>
        <trans-unit id="97ad18054b9569eed06f9ecf25bb01ba9f0544fc" translate="yes" xml:space="preserve">
          <source>Introduction to use of Edebug.</source>
          <target state="translated">Введение в использование Edebug.</target>
        </trans-unit>
        <trans-unit id="fb00fd291ed8bdc1da78f75b2dfea4fe96a9552c" translate="yes" xml:space="preserve">
          <source>Invalid coding system</source>
          <target state="translated">Недействительная система кодирования</target>
        </trans-unit>
        <trans-unit id="f4da90dedff4144a88b3f5641db5e04aea389b0e" translate="yes" xml:space="preserve">
          <source>Invalid format operation</source>
          <target state="translated">Операция недействительного формата</target>
        </trans-unit>
        <trans-unit id="05b9e32cfa1dec4a8735af4f154c5c0b16324e49" translate="yes" xml:space="preserve">
          <source>Invalid function</source>
          <target state="translated">Недействительная функция</target>
        </trans-unit>
        <trans-unit id="21f66391b38e2d6c5385ca6d73c08b6046139bff" translate="yes" xml:space="preserve">
          <source>Invalid read syntax</source>
          <target state="translated">Неправильный синтаксис чтения</target>
        </trans-unit>
        <trans-unit id="39af5982d90c7c046f2c0e30d3c43a0d69f7c511" translate="yes" xml:space="preserve">
          <source>Invalid read syntax: &quot;)&quot;</source>
          <target state="translated">Недействительный синтаксис чтения:&quot;)&quot;</target>
        </trans-unit>
        <trans-unit id="1f526a95f220fa3e397793791a95103a25349fa5" translate="yes" xml:space="preserve">
          <source>Invalid regexp</source>
          <target state="translated">Недействительный регэкспресс</target>
        </trans-unit>
        <trans-unit id="c28782659524c74728d4791e47ac0768f2d2a2fa" translate="yes" xml:space="preserve">
          <source>Invisible Text</source>
          <target state="translated">Невидимый текст</target>
        </trans-unit>
        <trans-unit id="1ba45e6efe9b69076beb81f22754c2276b515f29" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;pop-to-buffer&lt;/code&gt; to proceed.</source>
          <target state="translated">Для продолжения вызывает &lt;code&gt;pop-to-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6f179c44acf946ea87d5fd9a67e79980a7bf28" translate="yes" xml:space="preserve">
          <source>Invoking the Debugger</source>
          <target state="translated">Вызов отладчика</target>
        </trans-unit>
        <trans-unit id="3b5c7ed80b795c31ca809c1980f8e9b7ef9b7cb4" translate="yes" xml:space="preserve">
          <source>Invoking the Input Method</source>
          <target state="translated">Вызов метода ввода</target>
        </trans-unit>
        <trans-unit id="f95535be202c390af54850aaa2b9814ce9f60024" translate="yes" xml:space="preserve">
          <source>Invoking the minibuffer with completion.</source>
          <target state="translated">Ссылка на мини-буфер с завершением.</target>
        </trans-unit>
        <trans-unit id="d82cb1a6affac049d5e0a64e8bc2eabc7098b52a" translate="yes" xml:space="preserve">
          <source>Is a given file readable? Writable?</source>
          <target state="translated">Можно ли прочитать данный файл? Письменный?</target>
        </trans-unit>
        <trans-unit id="cc345fde3dff917a2877747ac2b2a0a59a508cad" translate="yes" xml:space="preserve">
          <source>Is it a directory? A symbolic link?</source>
          <target state="translated">Это каталог? Символическая ссылка?</target>
        </trans-unit>
        <trans-unit id="ce731c05fc64ab5b57ee9d5ba394e0ea5eb6be0b" translate="yes" xml:space="preserve">
          <source>Is this object a list? Comparing two lists.</source>
          <target state="translated">Этот объект-список? Сравниваем два списка.</target>
        </trans-unit>
        <trans-unit id="faf1e5134b7192f681808c3c7a3dcf14d24adcce" translate="yes" xml:space="preserve">
          <source>It adds subdirectories to &lt;code&gt;load-path&lt;/code&gt;, by running the file named</source>
          <target state="translated">Он добавляет подкаталоги к &lt;code&gt;load-path&lt;/code&gt; , запустив файл с именем</target>
        </trans-unit>
        <trans-unit id="26ebe0ae609401a2ad28c4f3ef880f902fb57804" translate="yes" xml:space="preserve">
          <source>It also affects decisions about whether to scroll part of the screen or repaint on text terminals. See &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;Forcing Redisplay&lt;/a&gt;, for the corresponding functionality on graphical terminals.</source>
          <target state="translated">Это также влияет на решения о том, прокручивать ли часть экрана или перерисовывать текстовые терминалы. См. &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;Раздел &amp;laquo;Принудительное повторное отображение&amp;raquo;&lt;/a&gt; для получения информации о соответствующих функциях графических терминалов.</target>
        </trans-unit>
        <trans-unit id="a4141f73f90581e1ab9aa132384bbf4e5ae08ded" translate="yes" xml:space="preserve">
          <source>It also applies to any asynchronous subprocess or network stream, but in a different way: the value of &lt;code&gt;coding-system-for-read&lt;/code&gt; when you start the subprocess or open the network stream specifies the input decoding method for that subprocess or network stream. It remains in use for that subprocess or network stream unless and until overridden.</source>
          <target state="translated">Это также применимо к любому асинхронному подпроцессу или сетевому потоку, но по-другому: значение &lt;code&gt;coding-system-for-read&lt;/code&gt; , когда вы запускаете подпроцесс или открываете сетевой поток, указывает метод декодирования входных данных для этого подпроцесса или сетевого потока. Он остается в использовании для этого подпроцесса или сетевого потока до тех пор, пока не будет переопределен.</target>
        </trans-unit>
        <trans-unit id="aace0e7e04bb1701d0b33950723bc535b0281f25" translate="yes" xml:space="preserve">
          <source>It also displays the symbols in a buffer named</source>
          <target state="translated">Он также отображает символы в буфере с именем</target>
        </trans-unit>
        <trans-unit id="10f4c6d92e33b4069ea7366cc5044b10b6555757" translate="yes" xml:space="preserve">
          <source>It always returns &lt;code&gt;t&lt;/code&gt; for buffers that are not visiting a file, even if &lt;code&gt;visited-file-modtime&lt;/code&gt; returns a non-zero value. For instance, it always returns &lt;code&gt;t&lt;/code&gt; for dired buffers. It returns &lt;code&gt;t&lt;/code&gt; for buffers that are visiting a file that does not exist and never existed, but &lt;code&gt;nil&lt;/code&gt; for file-visiting buffers whose file has been deleted.</source>
          <target state="translated">Он всегда возвращает &lt;code&gt;t&lt;/code&gt; для буферов, которые не &lt;code&gt;visited-file-modtime&lt;/code&gt; к файлу, даже если visit-file-modtime возвращает ненулевое значение. Например, он всегда возвращает &lt;code&gt;t&lt;/code&gt; для dired буферов. Он возвращает &lt;code&gt;t&lt;/code&gt; для буферов, обращающихся к файлу, который не существует и никогда не существовал, но &lt;code&gt;nil&lt;/code&gt; для буферов обращения к файлам, файл которых был удален.</target>
        </trans-unit>
        <trans-unit id="36679f079089d8681a01f756abfb5ab13128d005" translate="yes" xml:space="preserve">
          <source>It always sets the file modes of the copied files to match the corresponding original file.</source>
          <target state="translated">Он всегда устанавливает режимы копирования файлов в соответствии с соответствующим исходным файлом.</target>
        </trans-unit>
        <trans-unit id="68c121eadb6645154879627e1f8f4d91b9159e0d" translate="yes" xml:space="preserve">
          <source>It blocks out all process output (since Emacs accepts process output only while waiting).</source>
          <target state="translated">Он блокирует весь вывод процесса (так как Emacs принимает вывод процесса только в ожидании).</target>
        </trans-unit>
        <trans-unit id="db1622f7113638a1b6cf00fc1d147d1151f5939d" translate="yes" xml:space="preserve">
          <source>It blocks out any idle timers that ought to run during that time.</source>
          <target state="translated">Он блокирует любые простаивающие таймеры,которые должны работать в это время.</target>
        </trans-unit>
        <trans-unit id="500a99712580a0fd93b02db9ad0f50b8dfd5061d" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;frame-notice-user-settings&lt;/code&gt;, which modifies the parameters of the selected frame according to whatever the init files specify.</source>
          <target state="translated">Он вызывает &lt;code&gt;frame-notice-user-settings&lt;/code&gt; , который изменяет параметры выбранного кадра в соответствии с тем, что указано в файлах инициализации.</target>
        </trans-unit>
        <trans-unit id="08316562225e169cff224da3eaa939766d93f6e4" translate="yes" xml:space="preserve">
          <source>It calls the function &lt;code&gt;package-activate-all&lt;/code&gt; to activate any optional Emacs Lisp package that has been installed. See &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;Packaging Basics&lt;/a&gt;. However, Emacs doesn&amp;rsquo;t activate the packages when &lt;code&gt;package-enable-at-startup&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; or when it&amp;rsquo;s started with one of the options &amp;lsquo;</source>
          <target state="translated">Он вызывает функцию &lt;code&gt;package-activate-all&lt;/code&gt; , чтобы активировать любой дополнительный пакет Emacs Lisp, который был установлен. См. &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;Основы упаковки&lt;/a&gt; . Однако Emacs не активирует пакеты, если &lt;code&gt;package-enable-at-startup&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; или когда он запускается с одной из опций '</target>
        </trans-unit>
        <trans-unit id="0136b0ca24d16b01a291e47bd7153f4f2fba2a73" translate="yes" xml:space="preserve">
          <source>It creates the submenu &lt;var&gt;menu-title&lt;/var&gt; specified by &lt;var&gt;sub-alist&lt;/var&gt;.</source>
          <target state="translated">Он создает &lt;var&gt;menu-title&lt;/var&gt; подменю, указанный &lt;var&gt;sub-alist&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="69c1303d35db5ea0aad7fd95fc917c9a224ef2f1" translate="yes" xml:space="preserve">
          <source>It displays the &lt;em&gt;startup screen&lt;/em&gt;, which is a special buffer that contains information about copyleft and basic Emacs usage. This is not done if &lt;code&gt;inhibit-startup-screen&lt;/code&gt; or &lt;code&gt;initial-buffer-choice&lt;/code&gt; are non-&lt;code&gt;nil&lt;/code&gt;, or if the &amp;lsquo;</source>
          <target state="translated">Он отображает &lt;em&gt;экран запуска&lt;/em&gt; , который представляет собой специальный буфер, содержащий информацию об авторском леве и базовом использовании Emacs. Это не выполняется, если &lt;code&gt;inhibit-startup-screen&lt;/code&gt; или &lt;code&gt;initial-buffer-choice&lt;/code&gt; отличны от &lt;code&gt;nil&lt;/code&gt; , или если '</target>
        </trans-unit>
        <trans-unit id="26297586b2674d5e45392b02c3a4a0a6b4471608" translate="yes" xml:space="preserve">
          <source>It displays the initial echo area message, unless you have suppressed that with &lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt;.</source>
          <target state="translated">Он отображает начальное сообщение эхо-области, если вы не подавили его с помощью &lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="deb0e9c99bf58c06b6f38c7c256f96f0b734089a" translate="yes" xml:space="preserve">
          <source>It does not matter to the caller of a function whether the function is primitive. However, this does matter if you try to redefine a primitive with a function written in Lisp. The reason is that the primitive function may be called directly from C code. Calls to the redefined function from Lisp will use the new definition, but calls from C code may still use the built-in definition. Therefore, &lt;strong&gt;we discourage redefinition of primitive functions&lt;/strong&gt;.</source>
          <target state="translated">Для вызывающей функции не имеет значения, является ли функция примитивной. Однако это имеет значение, если вы пытаетесь переопределить примитив с помощью функции, написанной на Лиспе. Причина в том, что примитивная функция может быть вызвана непосредственно из кода C. Вызов переопределенной функции из Lisp будет использовать новое определение, но вызовы из кода C могут по-прежнему использовать встроенное определение. Поэтому &lt;strong&gt;мы не рекомендуем переопределять примитивные функции&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dc2cfa8003c37f1bb7b6976cb93df4aaf5e867c7" translate="yes" xml:space="preserve">
          <source>It does some basic parsing of the command-line arguments.</source>
          <target state="translated">Он выполняет некоторый базовый разбор аргументов командной строки.</target>
        </trans-unit>
        <trans-unit id="780d4f9cb3c97b4270953a6df1b1b787aacbefcb" translate="yes" xml:space="preserve">
          <source>It first deletes any child frame of &lt;var&gt;frame&lt;/var&gt; (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and any frame whose &lt;code&gt;delete-before&lt;/code&gt; frame parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;) specifies &lt;var&gt;frame&lt;/var&gt;. All such deletions are performed recursively; so this step makes sure that no other frames with &lt;var&gt;frame&lt;/var&gt; as their ancestor will exist. Then, unless &lt;var&gt;frame&lt;/var&gt; specifies a tooltip, this function runs the hook &lt;code&gt;delete-frame-functions&lt;/code&gt; (each function getting one argument, &lt;var&gt;frame&lt;/var&gt;) before actually killing the frame. After actually killing the frame and removing the frame from the frame list, &lt;code&gt;delete-frame&lt;/code&gt; runs &lt;code&gt;after-delete-frame-functions&lt;/code&gt;.</source>
          <target state="translated">Сначала он удаляет любой дочерний фрейм &lt;var&gt;frame&lt;/var&gt; (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ) и любой фрейм, чей параметр &lt;code&gt;delete-before&lt;/code&gt; фреймом (см. &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Параметры взаимодействия &lt;/a&gt; &lt;var&gt;frame&lt;/var&gt; ) определяет фрейм . Все такие удаления выполняются рекурсивно; поэтому этот шаг гарантирует, что никаких других фреймов с &lt;var&gt;frame&lt;/var&gt; качестве предка не будет. Затем, если &lt;var&gt;frame&lt;/var&gt; указывает всплывающую подсказку, эта функция запускает ловушки &lt;code&gt;delete-frame-functions&lt;/code&gt; (каждая функция получает один аргумент, &lt;var&gt;frame&lt;/var&gt; ) перед фактическим уничтожением фрейма. После фактического уничтожения кадра и удаления кадра из списка &lt;code&gt;delete-frame&lt;/code&gt; выполняется команда delete-frame &lt;code&gt;after-delete-frame-functions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65b6824863bde18952e797a108d59972b5cd7ca4" translate="yes" xml:space="preserve">
          <source>It follows the cyclic ordering of windows. The optional arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; specify the set of windows included; these have the same arguments as in &lt;code&gt;next-window&lt;/code&gt;. If &lt;var&gt;all-frames&lt;/var&gt; specifies a frame, the first window walked is the first window on that frame (the one returned by &lt;code&gt;frame-first-window&lt;/code&gt;), not necessarily the selected window.</source>
          <target state="translated">Это следует за циклическим порядком окон. Необязательные аргументы &lt;var&gt;minibuf&lt;/var&gt; и &lt;var&gt;all-frames&lt;/var&gt; определяют набор включаемых окон; они имеют те же аргументы, что и в &lt;code&gt;next-window&lt;/code&gt; . Если &lt;var&gt;all-frames&lt;/var&gt; определяет фрейм, первое пройденное окно является первым окном в этом фрейме (тем, которое возвращается &lt;code&gt;frame-first-window&lt;/code&gt; ), не обязательно выбранным окном.</target>
        </trans-unit>
        <trans-unit id="d6d1323f650d9889c77490ede806efe0a1b71711" translate="yes" xml:space="preserve">
          <source>It initializes the initial frame&amp;rsquo;s faces, and sets up the menu bar and tool bar if needed. If graphical frames are supported, it sets up the tool bar even if the current frame is not a graphical one, since a graphical frame may be created later on.</source>
          <target state="translated">Он инициализирует начальные грани фрейма и при необходимости настраивает строку меню и панель инструментов. Если графические фреймы поддерживаются, он устанавливает панель инструментов, даже если текущий фрейм не является графическим, поскольку графический фрейм может быть создан позже.</target>
        </trans-unit>
        <trans-unit id="4dd46431e678931fbcb6b6537b9da5f2a07769f6" translate="yes" xml:space="preserve">
          <source>It inserts frequency counts as comment lines after each line of code. You can undo all insertions with one &lt;code&gt;undo&lt;/code&gt; command. The counts appear under the &amp;lsquo;</source>
          <target state="translated">Он вставляет счетчики частоты в виде строк комментариев после каждой строки кода. Вы можете отменить все вставки с помощью одной команды &lt;code&gt;undo&lt;/code&gt; . Счетчики отображаются под значком '</target>
        </trans-unit>
        <trans-unit id="3173cca5c8e25be905c421498d74ebe861b45fb4" translate="yes" xml:space="preserve">
          <source>It is a good idea for this function to run &lt;code&gt;temp-buffer-show-hook&lt;/code&gt; just as &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; normally would, inside of &lt;code&gt;save-selected-window&lt;/code&gt; and with the chosen window and buffer selected.</source>
          <target state="translated">Для этой функции рекомендуется запускать &lt;code&gt;temp-buffer-show-hook&lt;/code&gt; так же, как обычно &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; , внутри &lt;code&gt;save-selected-window&lt;/code&gt; и с выбранным окном и выбранным буфером.</target>
        </trans-unit>
        <trans-unit id="12a15b18bad26a84d1b400ed140fae6294485d46" translate="yes" xml:space="preserve">
          <source>It is a good idea to provide documentation strings for all the functions in your program, even those that are called only from within your program. Documentation strings are like comments, except that they are easier to access.</source>
          <target state="translated">Хорошей идеей является предоставление строк документации для всех функций в вашей программе,даже тех,которые вызываются только изнутри вашей программы.Строки документации подобны комментариям,за исключением того,что к ним легче получить доступ.</target>
        </trans-unit>
        <trans-unit id="f01ee6ca8bab6f5d9577b6a2063514f28c09839e" translate="yes" xml:space="preserve">
          <source>It is also legitimate for a major mode to rebind a standard key sequence whose standard meaning is rarely useful in that mode. For instance, minibuffer modes rebind</source>
          <target state="translated">Для основного режима также оправдано перепривязывание стандартной последовательности ключей,стандартное значение которой редко бывает полезным в этом режиме.Например,ребрендинг в минибуферных режимах</target>
        </trans-unit>
        <trans-unit id="2b57f5bccf3ef0816a9be0839152c423c58bb643" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;sit-for&lt;/code&gt; with three arguments, as &lt;code&gt;(sit-for &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; &lt;var&gt;nodisp&lt;/var&gt;)&lt;/code&gt;, but that is considered obsolete.</source>
          <target state="translated">Также можно вызвать &lt;code&gt;sit-for&lt;/code&gt; &lt;code&gt;(sit-for &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; &lt;var&gt;nodisp&lt;/var&gt;)&lt;/code&gt; с тремя аргументами, как (сидеть за &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; ) , но это считается устаревшим.</target>
        </trans-unit>
        <trans-unit id="baad5ec4e1257ce583e2c8021e1913799f72c849" translate="yes" xml:space="preserve">
          <source>It is also possible to find out how many arguments an arbitrary function expects:</source>
          <target state="translated">Также можно узнать,сколько аргументов ожидает произвольная функция:</target>
        </trans-unit>
        <trans-unit id="a6c145fead22c2d038d5449b927625f21786cd2b" translate="yes" xml:space="preserve">
          <source>It is also possible to watch filesystems on remote machines, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">Также возможно наблюдать за файловыми системами на удаленных машинах, см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Удаленные файлы&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="814384a844fbcda3c015b1e97f89a956ae872c9d" translate="yes" xml:space="preserve">
          <source>It is also possible to watch filesystems on remote machines, see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e621862bcf1c790b5d037616916bbe2c538d4f7" translate="yes" xml:space="preserve">
          <source>It is an error to call &lt;code&gt;condition-wait&lt;/code&gt; without holding the condition&amp;rsquo;s associated mutex.</source>
          <target state="translated">Ошибка вызова &lt;code&gt;condition-wait&lt;/code&gt; без удержания мьютекса, связанного с условием.</target>
        </trans-unit>
        <trans-unit id="a7b086934bad52d2aec76907ca52328c3844b39e" translate="yes" xml:space="preserve">
          <source>It is an error to make a constant or a read-only variable buffer-local. See &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;.</source>
          <target state="translated">Ошибочно делать константу или переменную, доступную только для чтения, локальной в буфере. См. &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Постоянные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72843249d94cfc895b70ea2d9791255b690c126e" translate="yes" xml:space="preserve">
          <source>It is assumed that when a caller of &lt;code&gt;display-buffer&lt;/code&gt; specifies a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;allow-no-window&lt;/code&gt; entry, it is also able to handle a &lt;code&gt;nil&lt;/code&gt; return value.</source>
          <target state="translated">Предполагается , что , когда вызывающий &lt;code&gt;display-buffer&lt;/code&gt; Специфицирует не- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;allow-no-window&lt;/code&gt; входа, она также может обрабатывать &lt;code&gt;nil&lt;/code&gt; возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="3f80f1cfd1cf04e4bc17393008731d354dfb2372" translate="yes" xml:space="preserve">
          <source>It is best to avoid mentioning specific bit numbers in your program. To test the modifier bits of a character, use the function &lt;code&gt;event-modifiers&lt;/code&gt; (see &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;Classifying Events&lt;/a&gt;). When making key bindings, you can use the read syntax for characters with modifier bits (&amp;lsquo;</source>
          <target state="translated">Лучше избегать упоминания конкретных номеров битов в вашей программе. Чтобы проверить биты модификаторов символа, используйте функцию &lt;code&gt;event-modifiers&lt;/code&gt; (см. &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;Классификация событий&lt;/a&gt; ). При привязке клавиш вы можете использовать синтаксис чтения для символов с битами модификатора ('</target>
        </trans-unit>
        <trans-unit id="0d52a1fb8bf86f61e2abf981d0b44f7de8aa8b26" translate="yes" xml:space="preserve">
          <source>It is common for Lisp functions to accept functions as arguments or find them in data structures (especially in hook variables and property lists) and call them using &lt;code&gt;funcall&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt;. Functions that accept function arguments are often called &lt;em&gt;functionals&lt;/em&gt;.</source>
          <target state="translated">Функции Lisp обычно принимают функции в качестве аргументов или находят их в структурах данных (особенно в переменных- &lt;code&gt;funcall&lt;/code&gt; и списках свойств) и вызывают их с помощью funcall или &lt;code&gt;apply&lt;/code&gt; . Функции, которые принимают аргументы функций, часто называют &lt;em&gt;функционалами&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f754947b959e216056814f1e32b8d9283beb7a0" translate="yes" xml:space="preserve">
          <source>It is common to add code to one&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) to add one or more directories to &lt;code&gt;load-path&lt;/code&gt;. For example:</source>
          <target state="translated">Обычно в файл инициализации добавляют код (см. &lt;a href=&quot;init-file#Init-File&quot;&gt;Файл&lt;/a&gt; инициализации ), чтобы добавить один или несколько каталогов в &lt;code&gt;load-path&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b83625c7041cfe9ad97f496a0522d9523b3b8dc4" translate="yes" xml:space="preserve">
          <source>It is common to write numbers, characters, strings, and even vectors in Lisp code, taking advantage of the fact that they self-evaluate. However, it is quite unusual to do this for types that lack a read syntax, because there&amp;rsquo;s no way to write them textually. It is possible to construct Lisp expressions containing these types by means of a Lisp program. Here is an example:</source>
          <target state="translated">В коде Lisp часто пишут числа, символы, строки и даже векторы, используя тот факт, что они самооценки. Однако это довольно необычно для типов, у которых отсутствует синтаксис чтения, потому что нет возможности записать их в текстовом виде. Выражения на Лиспе, содержащие эти типы, можно создавать с помощью программ на Лиспе. Вот пример:</target>
        </trans-unit>
        <trans-unit id="6c4f2df1721f4ac95ab46d4cfe55ed881a7d9df2" translate="yes" xml:space="preserve">
          <source>It is equally easy to insert a new element by changing &lt;small&gt;CDR&lt;/small&gt;s:</source>
          <target state="translated">Столь же легко вставить новый элемент, изменив &lt;small&gt;CDR&lt;/small&gt; :</target>
        </trans-unit>
        <trans-unit id="66640a1037abec141a287214c7037d4b09466e4e" translate="yes" xml:space="preserve">
          <source>It is generally cleaner and more flexible to store a function in a data structure, and call it with &lt;code&gt;funcall&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt;, than to store an expression in the data structure and evaluate it. Using functions provides the ability to pass information to them as arguments.</source>
          <target state="translated">Как правило, проще и гибче хранить функцию в структуре данных и вызывать ее с помощью &lt;code&gt;funcall&lt;/code&gt; или &lt;code&gt;apply&lt;/code&gt; , чем сохранять выражение в структуре данных и оценивать его. Использование функций дает возможность передавать им информацию в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="7224f1903528385d0d899a0e49ee687a6aa9d558" translate="yes" xml:space="preserve">
          <source>It is generally impossible to read the same sequence twice, since sequences are always created anew upon reading. If you read the read syntax for a sequence twice, you get two sequences with equal contents. There is one exception: the empty list &lt;code&gt;()&lt;/code&gt; always stands for the same object, &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Обычно невозможно прочитать одну и ту же последовательность дважды, так как последовательности всегда создаются заново при чтении. Если вы дважды прочитаете синтаксис чтения для последовательности, вы получите две последовательности с одинаковым содержанием. Есть одно исключение: пустой список &lt;code&gt;()&lt;/code&gt; всегда означает один и тот же объект, &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e4677a7491341a5525f2d613fb39d09d0efa30" translate="yes" xml:space="preserve">
          <source>It is implemented using the watchpoint mechanism, so it inherits the same characteristics and limitations: all aliases of &lt;var&gt;variable&lt;/var&gt; will be watched together, only dynamic variables can be watched, and changes to the objects referenced by variables are not detected. For details, see &lt;a href=&quot;watching-variables#Watching-Variables&quot;&gt;Watching Variables&lt;/a&gt;.</source>
          <target state="translated">Он реализован с использованием механизма точки наблюдения, поэтому он наследует те же характеристики и ограничения: все псевдонимы &lt;var&gt;variable&lt;/var&gt; будут отслеживаться вместе, могут наблюдаться только динамические переменные, и изменения в объектах, на которые ссылаются переменные, не обнаруживаются. Подробнее см. &lt;a href=&quot;watching-variables#Watching-Variables&quot;&gt;Просмотр переменных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8bb7af09e2683dd1d43399c262cc53e7f80c18fb" translate="yes" xml:space="preserve">
          <source>It is important to assure that point does not continuously jump around as a consequence of auto-reverting. Of course, moving point might be inevitable if the buffer radically changes.</source>
          <target state="translated">Важно убедиться,что точка не прыгает непрерывно,как следствие автореверсирования.Конечно,движение точки может быть неизбежным,если буфер радикально изменится.</target>
        </trans-unit>
        <trans-unit id="3eede72b9dece35e34101793a2f333f89d89a4f4" translate="yes" xml:space="preserve">
          <source>It is invoked via a mouse command.</source>
          <target state="translated">Он вызывается командой мыши.</target>
        </trans-unit>
        <trans-unit id="b5639d37fabd83f8e595d9ba42541031771e2456" translate="yes" xml:space="preserve">
          <source>It is legitimate for a major mode to rebind a standard key sequence if it provides a command that does the same job in a way better suited to the text this mode is used for. For example, a major mode for editing a programming language might redefine</source>
          <target state="translated">Для основного режима правомерно перепривязывать стандартную последовательность ключей,если он предоставляет команду,которая делает ту же самую работу так,чтобы она лучше соответствовала тексту,для которого используется этот режим.Например,основной режим для редактирования языка программирования может переопределять</target>
        </trans-unit>
        <trans-unit id="eae810ab4df9e8a364d85ae8c7b547bd3e8d8937" translate="yes" xml:space="preserve">
          <source>It is normal practice to change the bindings in the global keymap, but you should not assign this variable any value other than the keymap it starts out with.</source>
          <target state="translated">Изменение привязки в глобальной ключевой карте является нормальной практикой,но вы не должны присваивать этой переменной никакого значения,кроме ключевой карты,с которой она начинается.</target>
        </trans-unit>
        <trans-unit id="c7f2848da15c9bd47e2aa08dc291366d9534c8a8" translate="yes" xml:space="preserve">
          <source>It is not advisable to put anything in</source>
          <target state="translated">Не рекомендуется ничего вкладывать</target>
        </trans-unit>
        <trans-unit id="2bbf03bc73d7ef3e252d6245e26ed80331379d73" translate="yes" xml:space="preserve">
          <source>It is not crucial to exclude from the alist the keysyms of other X servers; those do no harm, as long as they don&amp;rsquo;t conflict with the ones used by the X server actually in use.</source>
          <target state="translated">Не обязательно исключать из списка ключевые слова других X-серверов; они не причиняют вреда до тех пор, пока не конфликтуют с теми, которые фактически используются X-сервером.</target>
        </trans-unit>
        <trans-unit id="6c9d03ef366e0475e733b12fb4ac0e9991b62830" translate="yes" xml:space="preserve">
          <source>It is not sufficient to determine whether a given window shows the currently active minibuffer by comparing it with the result of &lt;code&gt;(minibuffer-window)&lt;/code&gt;, because there can be more than one minibuffer window if there is more than one frame.</source>
          <target state="translated">Недостаточно определить, показывает ли данное окно текущий активный минибуфер, сравнивая его с результатом &lt;code&gt;(minibuffer-window)&lt;/code&gt; , потому что может быть более одного окна минибуфера, если имеется более одного кадра.</target>
        </trans-unit>
        <trans-unit id="0e93812a73d2bc561240927bd0add1fb2b57b9cb" translate="yes" xml:space="preserve">
          <source>It is often convenient to write a function that allows certain arguments to be omitted. For example, the function &lt;code&gt;substring&lt;/code&gt; accepts three arguments&amp;mdash;a string, the start index and the end index&amp;mdash;but the third argument defaults to the &lt;var&gt;length&lt;/var&gt; of the string if you omit it. It is also convenient for certain functions to accept an indefinite number of arguments, as the functions &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; do.</source>
          <target state="translated">Часто бывает удобно написать функцию, которая позволяет опускать определенные аргументы. Например, &lt;code&gt;substring&lt;/code&gt; функции принимает три аргумента - строку, начальный индекс и конечный индекс, - но третий аргумент по умолчанию равен &lt;var&gt;length&lt;/var&gt; строки, если вы его опустите. Некоторым функциям также удобно принимать неопределенное количество аргументов, как это делают &lt;code&gt;list&lt;/code&gt; функций и &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d267166b6e7f4643511ccbc7ed7e8692e1af1ee" translate="yes" xml:space="preserve">
          <source>It is often useful to move point temporarily within a localized portion of the program. This is called an &lt;em&gt;excursion&lt;/em&gt;, and it is done with the &lt;code&gt;save-excursion&lt;/code&gt; special form. This construct remembers the initial identity of the current buffer, and its value of point, and restores them after the excursion completes. It is the standard way to move point within one part of a program and avoid affecting the rest of the program, and is used thousands of times in the Lisp sources of Emacs.</source>
          <target state="translated">Часто бывает полезно временно переместить точку в пределах локализованной части программы. Это называется &lt;em&gt;экскурсией&lt;/em&gt; , и это делается с помощью специальной формы &lt;code&gt;save-excursion&lt;/code&gt; . Эта конструкция запоминает исходный идентификатор текущего буфера и его значение point и восстанавливает их после завершения экскурсии. Это стандартный способ перемещения точки в пределах одной части программы и избегания воздействия на остальную часть программы, который тысячи раз используется в исходных текстах Lisp Emacs.</target>
        </trans-unit>
        <trans-unit id="4a9a518d3c351efa42f91492c1d3d264dda80369" translate="yes" xml:space="preserve">
          <source>It is ok for a mode to use &lt;code&gt;font-lock-face&lt;/code&gt; for some text and also use the normal Font Lock machinery. But if the mode does not use the normal Font Lock machinery, it should not set the variable &lt;code&gt;font-lock-defaults&lt;/code&gt;. In this case the &lt;code&gt;face&lt;/code&gt; property will not be overriden, so using the &lt;code&gt;face&lt;/code&gt; property could work too. However, using &lt;code&gt;font-lock-face&lt;/code&gt; is generally preferable as it allows the user to control the fontification by toggling &lt;code&gt;font-lock-mode&lt;/code&gt;, and lets the code work regardless of whether the mode uses Font Lock machinery or not.</source>
          <target state="translated">Это нормально для режима использовать &lt;code&gt;font-lock-face&lt;/code&gt; для некоторого текста, а также использовать обычный механизм Font Lock. Но если режим не использует обычный механизм Font Lock, он не должен устанавливать переменную &lt;code&gt;font-lock-defaults&lt;/code&gt; . В этом случае свойство &lt;code&gt;face&lt;/code&gt; не будет переопределено, поэтому использование свойства &lt;code&gt;face&lt;/code&gt; также может работать. Однако использование &lt;code&gt;font-lock-face&lt;/code&gt; , как правило, предпочтительнее, так как оно позволяет пользователю управлять фонтификацией, переключая &lt;code&gt;font-lock-mode&lt;/code&gt; , и позволяет коду работать независимо от того, использует ли режим механизм Font Lock или нет.</target>
        </trans-unit>
        <trans-unit id="c3d2ba074f26ffb62a211357cea324dbc4b2f4ea" translate="yes" xml:space="preserve">
          <source>It is possible to advise a primitive (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;), but one should typically &lt;em&gt;not&lt;/em&gt; do so, for two reasons. Firstly, some primitives are used by the advice mechanism, and advising them could cause an infinite recursion. Secondly, many primitives are called directly from C, and such calls ignore advice; hence, one ends up in a confusing situation where some calls (occurring from Lisp code) obey the advice and other calls (from C code) do not.</source>
          <target state="translated">Можно посоветовать примитив (см. &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;Что такое функция&lt;/a&gt; ), но обычно этого &lt;em&gt;не&lt;/em&gt; следует делать по двум причинам. Во-первых, некоторые примитивы используются механизмом рекомендаций, и их совет может вызвать бесконечную рекурсию. Во-вторых, многие примитивы вызываются непосредственно из C, и такие вызовы игнорируют advice; следовательно, вы попадаете в запутанную ситуацию, когда некоторые вызовы (происходящие из кода Lisp) подчиняются совету, а другие вызовы (из кода C) нет.</target>
        </trans-unit>
        <trans-unit id="158ec131ed80fbe1245b2dbcf3882b001d0a335c" translate="yes" xml:space="preserve">
          <source>It is possible to avoid implicit resizing of a specific window when there are one or more other resizable windows on the same frame. For this purpose, Emacs must be advised to &lt;em&gt;preserve&lt;/em&gt; the size of that window. There are two basic ways to do that.</source>
          <target state="translated">Можно избежать неявного изменения размера конкретного окна, если в том же фрейме есть одно или несколько других окон с изменяемым размером. Для этой цели Emacs следует посоветовать &lt;em&gt;сохранить&lt;/em&gt; размер этого окна. Есть два основных способа сделать это.</target>
        </trans-unit>
        <trans-unit id="5059d1ca2b3130d76d02552f9db1a53062d38b02" translate="yes" xml:space="preserve">
          <source>It is possible to read a special file (such as a FIFO or an I/O device) with &lt;code&gt;insert-file-contents&lt;/code&gt;, as long as &lt;var&gt;replace&lt;/var&gt; and &lt;var&gt;visit&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Можно читать специальный файл (например, FIFO или устройство ввода-вывода) с помощью &lt;code&gt;insert-file-contents&lt;/code&gt; , если &lt;var&gt;replace&lt;/var&gt; и &lt;var&gt;visit&lt;/var&gt; равны &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="206fcc689764ad9025a7ae9e9481deb9e1a87744" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;char-after&lt;/code&gt; to examine characters at various buffer positions without moving point to those positions. Only an actual change in the value of point runs these hook functions.</source>
          <target state="translated">Можно использовать &lt;code&gt;char-after&lt;/code&gt; для проверки символов в различных позициях буфера, не перемещая точку в эти позиции. Эти функции-перехватчики запускаются только при фактическом изменении значения точки.</target>
        </trans-unit>
        <trans-unit id="ea9002dbd9b169e39f06dc37297bb765ac7c9c2f" translate="yes" xml:space="preserve">
          <source>It is possible to use an anonymous Lisp macro just like an anonymous function, but this is never done, because it does not make sense to pass an anonymous macro to functionals such as &lt;code&gt;mapcar&lt;/code&gt;. In practice, all Lisp macros have names, and they are almost always defined with the &lt;code&gt;defmacro&lt;/code&gt; macro.</source>
          <target state="translated">Можно использовать анонимный макрос Лиспа точно так же, как анонимную функцию, но это никогда не делается, потому что не имеет смысла передавать анонимный макрос таким функционалам, как &lt;code&gt;mapcar&lt;/code&gt; . На практике у всех макросов Lisp есть имена, и они почти всегда определяются с &lt;code&gt;defmacro&lt;/code&gt; макроса defmacro .</target>
        </trans-unit>
        <trans-unit id="91987bc01ce4e25960e8f7c77d19903b336be8fa" translate="yes" xml:space="preserve">
          <source>It is probably a good idea for the functions to do nothing if the character after &lt;var&gt;pos&lt;/var&gt; already has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;fontified&lt;/code&gt; property, but this is not required. If one function overrides the assignments made by a previous one, the properties after the last function finishes are the ones that really matter.</source>
          <target state="translated">Вероятно, это хорошая идея, чтобы функции ничего не делали, если символ после &lt;var&gt;pos&lt;/var&gt; уже имеет свойство &lt;code&gt;fontified&lt;/code&gt; , отличное от &lt;code&gt;nil&lt;/code&gt; , но это не требуется. Если одна функция переопределяет назначения, сделанные предыдущей, свойства после завершения последней функции - это те, которые действительно имеют значение.</target>
        </trans-unit>
        <trans-unit id="8c50e007c4847dde92fe8e165d1a24f7fbca3071" translate="yes" xml:space="preserve">
          <source>It is quite common to use some storage for a while, then release it by (for example) killing a buffer or deleting the last pointer to an object. Emacs provides a &lt;em&gt;garbage collector&lt;/em&gt; to reclaim this abandoned storage. The garbage collector operates by finding and marking all Lisp objects that are still accessible to Lisp programs. To begin with, it assumes all the symbols, their values and associated function definitions, and any data presently on the stack, are accessible. Any objects that can be reached indirectly through other accessible objects are also accessible.</source>
          <target state="translated">Довольно распространено использовать какое-то хранилище на некоторое время, а затем освободить его, (например) уничтожив буфер или удалив последний указатель на объект. Emacs предоставляет &lt;em&gt;сборщик мусора&lt;/em&gt; для восстановления этого заброшенного хранилища. Сборщик мусора работает, находя и маркируя все объекты Lisp, которые все еще доступны для программ Lisp. Для начала предполагается, что все символы, их значения и соответствующие определения функций, а также любые данные, находящиеся в стеке, доступны. Также доступны любые объекты, которые могут быть достигнуты косвенно через другие доступные объекты.</target>
        </trans-unit>
        <trans-unit id="9f81f2fefce2410ae1512655349098e0d74c8ad5" translate="yes" xml:space="preserve">
          <source>It is risky to change this variable&amp;rsquo;s value without doing various other things. Normally it is better to use &lt;code&gt;set-visited-file-name&lt;/code&gt; (see below); some of the things done there, such as changing the buffer name, are not strictly necessary, but others are essential to avoid confusing Emacs.</source>
          <target state="translated">Рискованно изменять значение этой переменной, не выполняя других действий. Обычно лучше использовать &lt;code&gt;set-visited-file-name&lt;/code&gt; (см. Ниже); некоторые из вещей, которые там выполняются, например, изменение имени буфера, не являются строго необходимыми, но другие необходимы, чтобы не запутать Emacs.</target>
        </trans-unit>
        <trans-unit id="81c490de37e7452de0a620a005a47606bd70b349" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to make two variables synonyms, so that both variables always have the same value, and changing either one also changes the other. Whenever you change the name of a variable&amp;mdash;either because you realize its old name was not well chosen, or because its meaning has partly changed&amp;mdash;it can be useful to keep the old name as an &lt;em&gt;alias&lt;/em&gt; of the new one for compatibility. You can do this with &lt;code&gt;defvaralias&lt;/code&gt;.</source>
          <target state="translated">Иногда бывает полезно сделать две переменные синонимами, чтобы обе переменные всегда имели одно и то же значение, и изменение одной из них приводит к изменению другой. Каждый раз, когда вы меняете имя переменной - либо потому, что вы понимаете, что ее старое имя было выбрано неправильно, либо потому, что его значение частично изменилось, - может быть полезно сохранить старое имя в качестве &lt;em&gt;псевдонима&lt;/em&gt; нового для совместимости. Вы можете сделать это с помощью &lt;code&gt;defvaralias&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2a84b8c48d3b060fcc06470427ce26c8399bf6f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to take some action when a variable changes its value. The &lt;em&gt;variable watchpoint&lt;/em&gt; facility provides the means to do so. Some possible uses for this feature include keeping display in sync with variable settings, and invoking the debugger to track down unexpected changes to variables (see &lt;a href=&quot;variable-debugging#Variable-Debugging&quot;&gt;Variable Debugging&lt;/a&gt;).</source>
          <target state="translated">Иногда бывает полезно предпринять какие-либо действия, когда переменная меняет свое значение. Средство &lt;em&gt;переменной точки наблюдения&lt;/em&gt; предоставляет средства для этого. Некоторые возможные варианты использования этой функции включают синхронизацию отображения с параметрами переменных и вызов отладчика для отслеживания неожиданных изменений переменных (см. &lt;a href=&quot;variable-debugging#Variable-Debugging&quot;&gt;Отладка переменных&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f4f9ca54d322d9dfa0b17bef44fd7e71b5662a0" translate="yes" xml:space="preserve">
          <source>It is useful to specify the &lt;code&gt;:require&lt;/code&gt; keyword for an option that turns on a certain feature. This causes Emacs to load the feature, if it is not already loaded, whenever the option is set. See &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;. Here is an example:</source>
          <target state="translated">Полезно указать ключевое слово &lt;code&gt;:require&lt;/code&gt; для параметра, который включает определенную функцию. Это заставляет Emacs загружать функцию, если она еще не загружена, всякий раз, когда установлена ​​опция. См. &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Общие ключевые слова&lt;/a&gt; . Вот пример:</target>
        </trans-unit>
        <trans-unit id="1084186213269f2884b66a5901a0fe109856708d" translate="yes" xml:space="preserve">
          <source>It is usually a bad idea for timer functions to alter buffer contents. When they do, they usually should call &lt;code&gt;undo-boundary&lt;/code&gt; both before and after changing the buffer, to separate the timer&amp;rsquo;s changes from user commands&amp;rsquo; changes and prevent a single undo entry from growing to be quite large.</source>
          <target state="translated">Обычно изменение содержимого буфера для функций таймера - плохая идея. Когда они это делают, они обычно должны вызывать &lt;code&gt;undo-boundary&lt;/code&gt; как до, так и после изменения буфера, чтобы отделить изменения таймера от изменений пользовательских команд и предотвратить рост одной записи отмены до довольно большого размера.</target>
        </trans-unit>
        <trans-unit id="51bfeb221e33f8fd00e57f4226da961d1d317a23" translate="yes" xml:space="preserve">
          <source>It is usually a bad idea to have more than one process associated with the same buffer.</source>
          <target state="translated">Обычно плохая идея иметь несколько процессов,связанных с одним и тем же буфером.</target>
        </trans-unit>
        <trans-unit id="341cb9738d8f2bcab2233c96dc993a86f9598f86" translate="yes" xml:space="preserve">
          <source>It is very common to read a Lisp form and then evaluate the form, but reading and evaluation are separate activities, and either can be performed alone. Reading per se does not evaluate anything; it converts the printed representation of a Lisp object to the object itself. It is up to the caller of &lt;code&gt;read&lt;/code&gt; to specify whether this object is a form to be evaluated, or serves some entirely different purpose. See &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;.</source>
          <target state="translated">Очень часто читать форму Lisp, а затем оценивать форму, но чтение и оценка - это отдельные действия, и любой из них может выполняться отдельно. Само по себе чтение ничего не оценивает; он преобразует печатное представление объекта Lisp в сам объект. Вызывающий &lt;code&gt;read&lt;/code&gt; должен указать, является ли этот объект формой, подлежащей оценке, или служит какой-то совершенно иной цели. См. &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Функции ввода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="545d22f4c3da6e907a054b17ba6817a718596224" translate="yes" xml:space="preserve">
          <source>It is very unusual to change the global keymap.</source>
          <target state="translated">Очень необычно менять глобальную ключевую карту.</target>
        </trans-unit>
        <trans-unit id="96139028099a0bfa0975054c4ed4730a63010934" translate="yes" xml:space="preserve">
          <source>It loads any</source>
          <target state="translated">Он загружает любой</target>
        </trans-unit>
        <trans-unit id="ce4af309e8e71369b6c603cca0cfd8e3be09a193" translate="yes" xml:space="preserve">
          <source>It loads the library</source>
          <target state="translated">Он загружает библиотеку</target>
        </trans-unit>
        <trans-unit id="f58887fd3294e17aa3e3e1af45b67849abc46e36" translate="yes" xml:space="preserve">
          <source>It loads your abbrevs from the file specified by &lt;code&gt;abbrev-file-name&lt;/code&gt;, if that file exists and can be read (see &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;abbrev-file-name&lt;/a&gt;). This is not done if the option &amp;lsquo;</source>
          <target state="translated">Он загружает ваши сокращения из файла, указанного в &lt;code&gt;abbrev-file-name&lt;/code&gt; , если этот файл существует и может быть прочитан (см. &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;Abbrev-file-name&lt;/a&gt; ). Это не делается, если опция '</target>
        </trans-unit>
        <trans-unit id="dea39a1a58b57ed5c242a688a8b16e364190e632" translate="yes" xml:space="preserve">
          <source>It loads your early init file (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html#Early-Init-File&quot;&gt;Early Init File&lt;/a&gt; in</source>
          <target state="translated">Он загружает ваш ранний файл инициализации (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html#Early-Init-File&quot;&gt;Файл&lt;/a&gt; ранней инициализации в</target>
        </trans-unit>
        <trans-unit id="ca68cd27742d7783c851c1b631c106e07cc802cb" translate="yes" xml:space="preserve">
          <source>It loads your early init file (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html#Early-Init-File&quot;&gt;Early Init File&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b670a2bbddceb4c5ab7bd11a55ab2796be2d98" translate="yes" xml:space="preserve">
          <source>It loads your init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;). This is not done if the options &amp;lsquo;</source>
          <target state="translated">Он загружает ваш файл инициализации (см. &lt;a href=&quot;init-file#Init-File&quot;&gt;Файл&lt;/a&gt; инициализации ). Этого не делать, если варианты '</target>
        </trans-unit>
        <trans-unit id="26dc9b8940f0ed8395f81364b4d2c60b19096a69" translate="yes" xml:space="preserve">
          <source>It makes a difference whether the user&amp;rsquo;s variable is named &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;a&lt;/code&gt; conflicts with the macro argument variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Имеет значение, будет ли переменная пользователя названа &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;x&lt;/code&gt; , поскольку &lt;code&gt;a&lt;/code&gt; конфликтует с переменной аргумента макроса &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f588db542d569932c817bd6b5fdaa9a4f1bd05c" translate="yes" xml:space="preserve">
          <source>It may be a Lisp expression that is not a string; then it should be a form that is evaluated to get a list of arguments to pass to the command. Usually this form will call various functions to read input from the user, most often through the minibuffer (see &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Minibuffers&lt;/a&gt;) or directly from the keyboard (see &lt;a href=&quot;reading-input#Reading-Input&quot;&gt;Reading Input&lt;/a&gt;).</source>
          <target state="translated">Это может быть выражение Лиспа, которое не является строкой; тогда это должна быть форма, которая оценивается, чтобы получить список аргументов для передачи команде. Обычно эта форма вызывает различные функции для чтения ввода от пользователя, чаще всего через минибуфер (см. &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Минибуферы&lt;/a&gt; ) или непосредственно с клавиатуры (см. &lt;a href=&quot;reading-input#Reading-Input&quot;&gt;Чтение ввода&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e657a7f0ef3da4440c9a172406d4c83cc7a6c0ec" translate="yes" xml:space="preserve">
          <source>It may be a string; its contents are a sequence of elements separated by newlines, one for each argument&lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;. Each element consists of a code character (see &lt;a href=&quot;interactive-codes#Interactive-Codes&quot;&gt;Interactive Codes&lt;/a&gt;) optionally followed by a prompt (which some code characters use and some ignore). Here is an example:</source>
          <target state="translated">Это может быть строка; его содержимое представляет собой последовательность элементов, разделенных символами новой строки, по одному для каждого аргумента &lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt; . Каждый элемент состоит из символа кода (см. &amp;laquo; &lt;a href=&quot;interactive-codes#Interactive-Codes&quot;&gt;Интерактивные коды&amp;raquo;&lt;/a&gt; ), за которым может следовать запрос (который некоторые символы кода используют, а некоторые игнорируют). Вот пример:</target>
        </trans-unit>
        <trans-unit id="270207470e73c1b4f20ceeca5a4e07a1e861134d" translate="yes" xml:space="preserve">
          <source>It may be easier to understand Edebug specifications by studying the examples provided here.</source>
          <target state="translated">Возможно,будет проще понять спецификации Edebug,изучив примеры,представленные здесь.</target>
        </trans-unit>
        <trans-unit id="29ae132e6f7b39d1f5c10685d3a9d808a04b0a94" translate="yes" xml:space="preserve">
          <source>It may be omitted or &lt;code&gt;nil&lt;/code&gt;; then the command is called with no arguments. This leads quickly to an error if the command requires one or more arguments.</source>
          <target state="translated">Может быть опущено или равно &lt;code&gt;nil&lt;/code&gt; ; тогда команда вызывается без аргументов. Это быстро приводит к ошибке, если команде требуется один или несколько аргументов.</target>
        </trans-unit>
        <trans-unit id="a7ae8f4f5163ffdad3ac600dbfe8890ee50679f5" translate="yes" xml:space="preserve">
          <source>It might be illustrative to look at the list of action functions &lt;code&gt;display-buffer&lt;/code&gt; would have tried to display</source>
          <target state="translated">Было бы показательно посмотреть на список функций действий, которые &lt;code&gt;display-buffer&lt;/code&gt; пытался отобразить.</target>
        </trans-unit>
        <trans-unit id="f613bf2f4a5a85329f026a11071df7c6baaf0a91" translate="yes" xml:space="preserve">
          <source>It now exits if the option &lt;code&gt;--batch&lt;/code&gt; was specified.</source>
          <target state="translated">Теперь он &lt;code&gt;--batch&lt;/code&gt; была указана опция --batch .</target>
        </trans-unit>
        <trans-unit id="b223a189ae751119c33b80a020770286ea64a0a6" translate="yes" xml:space="preserve">
          <source>It processes any command-line options that were not handled earlier.</source>
          <target state="translated">Он обрабатывает любые опции командной строки,которые не были обработаны ранее.</target>
        </trans-unit>
        <trans-unit id="f719eab01b127d2177bbaf5f862883e5485e8eae" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;nil&lt;/code&gt; if the frame is known not to be focused, &lt;code&gt;t&lt;/code&gt; if the frame is known to be focused, or &lt;code&gt;unknown&lt;/code&gt; if Emacs does not know the focus state of the frame. (You may see this last state in TTY frames running on terminals that do not support explicit focus notifications.)</source>
          <target state="translated">Он возвращает &lt;code&gt;nil&lt;/code&gt; , если известно, что кадр не сфокусирован, &lt;code&gt;t&lt;/code&gt; если известно, что кадр сфокусирован, или &lt;code&gt;unknown&lt;/code&gt; , если Emacs не знает состояние фокуса кадра. (Вы можете увидеть это последнее состояние в кадрах TTY, запущенных на терминалах, которые не поддерживают явные уведомления о фокусе.)</target>
        </trans-unit>
        <trans-unit id="f6127be12a81ec3143b75ff723db16b07ec57fc0" translate="yes" xml:space="preserve">
          <source>It returns a list &lt;code&gt;(&lt;var&gt;id&lt;/var&gt; &lt;var&gt;cols&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;id&lt;/var&gt; is the ID of the deleted entry and &lt;var&gt;cols&lt;/var&gt; is a vector of its column descriptors. It moves point to the beginning of the current line. It returns &lt;code&gt;nil&lt;/code&gt; if there is no entry at point.</source>
          <target state="translated">Он возвращает список &lt;code&gt;(&lt;var&gt;id&lt;/var&gt; &lt;var&gt;cols&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;id&lt;/var&gt; - это идентификатор удаленной записи, а &lt;var&gt;cols&lt;/var&gt; - это вектор ее дескрипторов столбца. Он перемещает точку в начало текущей строки. Он возвращает &lt;code&gt;nil&lt;/code&gt; , если в точке нет входа.</target>
        </trans-unit>
        <trans-unit id="13687604dddd27521e079b6548d3c35983b18d78" translate="yes" xml:space="preserve">
          <source>It runs &lt;code&gt;emacs-startup-hook&lt;/code&gt;.</source>
          <target state="translated">Он запускает &lt;code&gt;emacs-startup-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57d130dea79514478748a7450914f1fdf423cfbf" translate="yes" xml:space="preserve">
          <source>It runs &lt;code&gt;window-setup-hook&lt;/code&gt;. The only difference between this hook and &lt;code&gt;emacs-startup-hook&lt;/code&gt; is that this one runs after the previously mentioned modifications to the frame parameters.</source>
          <target state="translated">Он запускает &lt;code&gt;window-setup-hook&lt;/code&gt; . Единственная разница между этой ловушкой и &lt;code&gt;emacs-startup-hook&lt;/code&gt; заключается в том, что она запускается после ранее упомянутых изменений параметров фрейма.</target>
        </trans-unit>
        <trans-unit id="b4284000b9f4273ed298f7b9c6acbae8ad8a70fd" translate="yes" xml:space="preserve">
          <source>It runs the normal hook &lt;code&gt;after-init-hook&lt;/code&gt;.</source>
          <target state="translated">Он запускает обычную ловушку &lt;code&gt;after-init-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65ed86a0349bcbc41775fe86552a371004ac385f" translate="yes" xml:space="preserve">
          <source>It runs the normal hook &lt;code&gt;before-init-hook&lt;/code&gt;.</source>
          <target state="translated">Он запускает обычную ловушку &lt;code&gt;before-init-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a06c9ffa5dcf00d29d69c9797dd7e0da6832d589" translate="yes" xml:space="preserve">
          <source>It sets the language environment and the terminal coding system, if requested by environment variables such as &lt;code&gt;LANG&lt;/code&gt;.</source>
          <target state="translated">Он устанавливает языковую среду и систему кодирования терминала, если этого требуют переменные среды, такие как &lt;code&gt;LANG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4923a2b121bc6bb59693b11c6a7750a08e3930eb" translate="yes" xml:space="preserve">
          <source>It sets the variable &lt;code&gt;after-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt;. This variable was set to &lt;code&gt;nil&lt;/code&gt; earlier; setting it to the current time signals that the initialization phase is over, and, together with &lt;code&gt;before-init-time&lt;/code&gt;, provides the measurement of how long it took.</source>
          <target state="translated">Он устанавливает для переменной &lt;code&gt;after-init-time&lt;/code&gt; значение &lt;code&gt;current-time&lt;/code&gt; . Ранее эта переменная была установлена ​​в &lt;code&gt;nil&lt;/code&gt; ; установка его на текущее время сигнализирует о завершении фазы инициализации и вместе с параметром &lt;code&gt;before-init-time&lt;/code&gt; обеспечивает измерение того, сколько времени это заняло.</target>
        </trans-unit>
        <trans-unit id="5daee93c148acf992b6fea81eb74da11887f6178" translate="yes" xml:space="preserve">
          <source>It sets the variable &lt;code&gt;before-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt; (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;). It also sets &lt;code&gt;after-init-time&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;, which signals to Lisp programs that Emacs is being initialized.</source>
          <target state="translated">Он устанавливает для переменной &lt;code&gt;before-init-time&lt;/code&gt; значение &lt;code&gt;current-time&lt;/code&gt; (см. &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Время суток&lt;/a&gt; ). Он также устанавливает для параметра &lt;code&gt;after-init-time&lt;/code&gt; значение &lt;code&gt;nil&lt;/code&gt; , что сигнализирует программам Lisp о том, что Emacs инициализируется.</target>
        </trans-unit>
        <trans-unit id="5e3e48641edd97a87cf2a4c0fb33b8851ec59b76" translate="yes" xml:space="preserve">
          <source>It should return either a number, which is the number of columns of indentation for that line, or a list whose car is such a number. The difference between returning a number and returning a list is that a number says that all following lines at the same nesting level should be indented just like this one; a list says that following lines might call for different indentations. This makes a difference when the indentation is being computed by</source>
          <target state="translated">Она должна возвращать либо номер,который является числом столбцов отступов для этой строки,либо список,чей автомобиль является таким номером.Разница между возвращением числа и возвращением списка состоит в том,что число говорит о том,что все последующие строки на одном и том же уровне вложенности должны быть отпечатаны точно так же,как и этот;список говорит о том,что следующие строки могут потребовать различных отступов.Это имеет значение,когда отступ вычисляется по формуле</target>
        </trans-unit>
        <trans-unit id="99280a67fd3ac6e66ec565182a43a4b5d4ec95df" translate="yes" xml:space="preserve">
          <source>It specifies the numbers of pixels to be left free on the left, above, the right, and below a frame that shall be fit. The default specifies &lt;code&gt;nil&lt;/code&gt; for each which means to use no margins. The value specified here can be overridden for a specific frame by that frame&amp;rsquo;s &lt;code&gt;fit-frame-to-buffer-margins&lt;/code&gt; parameter, if present.</source>
          <target state="translated">Он определяет количество пикселей, которые должны быть оставлены свободными слева, сверху, справа и снизу кадра, который должен соответствовать. По умолчанию для каждого указано значение &lt;code&gt;nil&lt;/code&gt; , что означает отсутствие полей. Указанное здесь значение может быть переопределено для определенного кадра параметром &lt;code&gt;fit-frame-to-buffer-margins&lt;/code&gt; этого кадра , если он присутствует.</target>
        </trans-unit>
        <trans-unit id="28ce94806e6158d5cc7c2d469c858c1b7c53e2dd" translate="yes" xml:space="preserve">
          <source>It takes a candidate for the fill prefix from the first line&amp;mdash;it tries first the function in &lt;code&gt;adaptive-fill-function&lt;/code&gt; (if any), then the regular expression &lt;code&gt;adaptive-fill-regexp&lt;/code&gt; (see below). The first non-&lt;code&gt;nil&lt;/code&gt; result of these, or the empty string if they&amp;rsquo;re both &lt;code&gt;nil&lt;/code&gt;, becomes the first line&amp;rsquo;s candidate.</source>
          <target state="translated">Он берет кандидата на префикс заполнения из первой строки - сначала он пробует функцию в &lt;code&gt;adaptive-fill-function&lt;/code&gt; (если есть), затем регулярное выражение &lt;code&gt;adaptive-fill-regexp&lt;/code&gt; (см. Ниже). Первый результат, не &lt;code&gt;nil&lt;/code&gt; , или пустая строка, если оба они равны &lt;code&gt;nil&lt;/code&gt; , становится кандидатом на первую строку.</target>
        </trans-unit>
        <trans-unit id="f89e2f8e456314ee623854cef9dd8ebd8d7735d3" translate="yes" xml:space="preserve">
          <source>It use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; to re-initialize the members of the list &lt;code&gt;custom-delayed-init-variables&lt;/code&gt;. These are any pre-loaded user options whose default value depends on the run-time, rather than build-time, context. See &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;custom-initialize-delay&lt;/a&gt;.</source>
          <target state="translated">Он использует &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; для повторной инициализации членов списка &lt;code&gt;custom-delayed-init-variables&lt;/code&gt; . Это любые предварительно загруженные пользовательские параметры, значение которых по умолчанию зависит от контекста времени выполнения, а не времени сборки. См. &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Custom-initialize-delay&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44cd2108881f01dd8c596bbd91d07233b73cb9b2" translate="yes" xml:space="preserve">
          <source>It works to put a &lt;code&gt;lambda&lt;/code&gt;-expression function on a hook, but we recommend avoiding this because it can lead to confusion. If you add the same &lt;code&gt;lambda&lt;/code&gt;-expression a second time but write it slightly differently, you will get two equivalent but distinct functions on the hook. If you then remove one of them, the other will still be on it.</source>
          <target state="translated">Он работает, чтобы поставить на крючок функцию &lt;code&gt;lambda&lt;/code&gt; выражения, но мы рекомендуем избегать этого, потому что это может привести к путанице. Если вы добавите одно и то же &lt;code&gt;lambda&lt;/code&gt; выражение во второй раз, но напишете его немного по-другому, вы получите две эквивалентные, но разные функции на крючке. Если вы удалите один из них, другой останется на нем.</target>
        </trans-unit>
        <trans-unit id="80fdf17dcc7b4f396ac917a2a9e0157cd87886a5" translate="yes" xml:space="preserve">
          <source>It you wish to use &lt;code&gt;fset&lt;/code&gt; to make an alternate name for a function, consider using &lt;code&gt;defalias&lt;/code&gt; instead. See &lt;a href=&quot;defining-functions#Definition-of-defalias&quot;&gt;Definition of defalias&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите использовать &lt;code&gt;fset&lt;/code&gt; для создания альтернативного имени функции, рассмотрите возможность использования вместо этого &lt;code&gt;defalias&lt;/code&gt; . См. &lt;a href=&quot;defining-functions#Definition-of-defalias&quot;&gt;Определение дефалий&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12c3787085fed9c7ac2a19edc5f190b93b7fcd00" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that generator function bodies only execute inside calls to &lt;code&gt;iter-next&lt;/code&gt;. A call to a function defined with &lt;code&gt;iter-defun&lt;/code&gt; produces an iterator; you must drive this iterator with &lt;code&gt;iter-next&lt;/code&gt; for anything interesting to happen. Each call to a generator function produces a &lt;em&gt;different&lt;/em&gt; iterator, each with its own state.</source>
          <target state="translated">Важно отметить, что тела функций генератора выполняются только внутри вызовов &lt;code&gt;iter-next&lt;/code&gt; . Вызов функции, определенной с помощью &lt;code&gt;iter-defun&lt;/code&gt; , создает итератор; вы должны управлять этим итератором с помощью &lt;code&gt;iter-next&lt;/code&gt; , чтобы произошло что-нибудь интересное. Каждый вызов функции генератора создает &lt;em&gt;разные&lt;/em&gt; итераторы, каждый со своим состоянием.</target>
        </trans-unit>
        <trans-unit id="729165fc7a05eb589cbb1af78d5106f307b47f0e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often best to use a button-down event to trigger the menu. Then the user can select a menu item by releasing the button.</source>
          <target state="translated">Часто для запуска меню лучше всего использовать событие нажатия кнопки. Затем пользователь может выбрать пункт меню, отпустив кнопку.</target>
        </trans-unit>
        <trans-unit id="0c08d58a77f22a792633779a50d013f737ce9483" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to use &lt;code&gt;defmacro&lt;/code&gt; to define a macro to expand into the same code that an inline function would execute (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;). But the macro would be limited to direct use in expressions&amp;mdash;a macro cannot be called with &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;mapcar&lt;/code&gt; and so on. Also, it takes some work to convert an ordinary function into a macro. To convert it into an inline function is easy; just replace &lt;code&gt;defun&lt;/code&gt; with &lt;code&gt;defsubst&lt;/code&gt;. Since each argument of an inline function is evaluated exactly once, you needn&amp;rsquo;t worry about how many times the body uses the arguments, as you do for macros.</source>
          <target state="translated">Можно использовать &lt;code&gt;defmacro&lt;/code&gt; для определения макроса, который будет разворачиваться в тот же код, который будет выполнять встроенная функция (см. &lt;a href=&quot;macros#Macros&quot;&gt;Макросы&lt;/a&gt; ). Но макрос будет ограничен прямым использованием в выражениях - макрос не может быть вызван с помощью &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;mapcar&lt;/code&gt; и т. Д. Кроме того, для преобразования обычной функции в макрос требуется определенная работа. Преобразовать его во встроенную функцию легко; просто замените &lt;code&gt;defun&lt;/code&gt; на &lt;code&gt;defsubst&lt;/code&gt; . Поскольку каждый аргумент встроенной функции оценивается ровно один раз, вам не нужно беспокоиться о том, сколько раз тело использует аргументы, как вы это делаете для макросов.</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="f4d74e5132bdad11a69b68ebde992bf491707cbc" translate="yes" xml:space="preserve">
          <source>Iteration means executing part of a program repetitively. For example, you might want to repeat some computation once for each element of a list, or once for each integer from 0 to &lt;var&gt;n&lt;/var&gt;. You can do this in Emacs Lisp with the special form &lt;code&gt;while&lt;/code&gt;:</source>
          <target state="translated">Итерация означает повторное выполнение части программы. Например, вы можете захотеть повторить какое-то вычисление один раз для каждого элемента списка или один раз для каждого целого числа от 0 до &lt;var&gt;n&lt;/var&gt; . Вы можете сделать это в Emacs Lisp с помощью специальной формы, &lt;code&gt;while&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2fb2f2a0c2e32e4191a12be240b63fedbe73b154" translate="yes" xml:space="preserve">
          <source>Its default value is a list of two functions:</source>
          <target state="translated">Его значение по умолчанию представляет собой список из двух функций:</target>
        </trans-unit>
        <trans-unit id="49589a66a4ed1e537405d93b509f6624692ac859" translate="yes" xml:space="preserve">
          <source>Its limitations are two-fold:</source>
          <target state="translated">Его ограничения двояки:</target>
        </trans-unit>
        <trans-unit id="007b93ab24ba9d1da7373772173fe2a52b7889ac" translate="yes" xml:space="preserve">
          <source>Its value is a cons cell whose &lt;small&gt;CAR&lt;/small&gt; is the property value, the same value &lt;code&gt;get-char-property&lt;/code&gt; would return with the same arguments. Its &lt;small&gt;CDR&lt;/small&gt; is the overlay in which the property was found, or &lt;code&gt;nil&lt;/code&gt;, if it was found as a text property or not found at all.</source>
          <target state="translated">Его значение - это cons-ячейка, &lt;small&gt;CAR&lt;/small&gt; которой является значением свойства, то же значение &lt;code&gt;get-char-property&lt;/code&gt; вернет с теми же аргументами. Его &lt;small&gt;CDR&lt;/small&gt; - это оверлей, в котором свойство было найдено, или &lt;code&gt;nil&lt;/code&gt; , если оно было найдено как текстовое свойство или не найдено вообще.</target>
        </trans-unit>
        <trans-unit id="6b878b75e01a9b65a11b6b767fc6064f2ed8e1c3" translate="yes" xml:space="preserve">
          <source>Its value should be an alist of elements &lt;code&gt;(&lt;var&gt;group&lt;/var&gt;
. &lt;var&gt;method&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;group&lt;/var&gt; is a symbol specifying a group of characters, and &lt;var&gt;method&lt;/var&gt; is a symbol specifying how to display them.</source>
          <target state="translated">Его значение должно быть списком элементов &lt;code&gt;(&lt;var&gt;group&lt;/var&gt; . &lt;var&gt;method&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;group&lt;/var&gt; - это символ, определяющий группу символов, а &lt;var&gt;method&lt;/var&gt; - это символ, определяющий, как их отображать.</target>
        </trans-unit>
        <trans-unit id="a45885aac538290762a4f7f3317abf411bb16059" translate="yes" xml:space="preserve">
          <source>JPEG</source>
          <target state="translated">JPEG</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="6f0b2b618684c092a8066c4d2b87cf92b25d0ab7" translate="yes" xml:space="preserve">
          <source>JSON Remote Procedure Call protocol</source>
          <target state="translated">Протокол вызова удаленной процедуры JSON</target>
        </trans-unit>
        <trans-unit id="5f40c53af62eb7b5ee0a65ed1e7c8f365f43b1f1" translate="yes" xml:space="preserve">
          <source>JSON has only one map type, the object. JSON objects are represented using Lisp hashtables, alists or plists. When an alist or plist contains several elements with the same key, Emacs uses only the first element for serialization, in accordance with the behavior of &lt;code&gt;assq&lt;/code&gt;.</source>
          <target state="translated">JSON имеет только один тип карты - объект. Объекты JSON представлены с помощью хэш-таблиц, списков или списков Lisp. Когда список или список содержит несколько элементов с одним и тем же ключом, Emacs использует только первый элемент для сериализации в соответствии с поведением &lt;code&gt;assq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4027009299142689327089033c66ce6d8204c015" translate="yes" xml:space="preserve">
          <source>JSON has only one sequence type, the array. JSON arrays are represented using Lisp vectors.</source>
          <target state="translated">JSON имеет только один тип последовательности-массив.Массивы JSON представлены с помощью векторов Lisp.</target>
        </trans-unit>
        <trans-unit id="89330272dcad769514c364e424832f313f1167c0" translate="yes" xml:space="preserve">
          <source>JSON only has floating-point numbers. They can represent both Lisp integers and Lisp floating-point numbers.</source>
          <target state="translated">В JSON есть только числа с плавающей точкой.Они могут представлять как целые числа на языке Lisp,так и числа с плавающей точкой на языке Lisp.</target>
        </trans-unit>
        <trans-unit id="18c0817b7de8ce2fe86bde8704950b2eeeb0640d" translate="yes" xml:space="preserve">
          <source>JSON strings are always Unicode strings encoded in UTF-8. Lisp strings can contain non-Unicode characters.</source>
          <target state="translated">Строки JSON всегда являются строками Unicode в кодировке UTF-8.Строки Lisp могут содержать символы,не относящиеся к юникоду.</target>
        </trans-unit>
        <trans-unit id="604769fe0494c1a23dd3dbf7fcb493bb82074409" translate="yes" xml:space="preserve">
          <source>JSON uses three keywords: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;true&lt;/code&gt; is represented by the symbol &lt;code&gt;t&lt;/code&gt;. By default, the remaining two are represented, respectively, by the symbols &lt;code&gt;:null&lt;/code&gt; and &lt;code&gt;:false&lt;/code&gt;.</source>
          <target state="translated">JSON использует три ключевых слова: &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;true&lt;/code&gt; представлена ​​символом &lt;code&gt;t&lt;/code&gt; . По умолчанию оставшиеся два представлены соответственно символами &lt;code&gt;:null&lt;/code&gt; и &lt;code&gt;:false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffacdf205c7b613f126d350a3416adc2ea7f7d90" translate="yes" xml:space="preserve">
          <source>JSONRPC</source>
          <target state="translated">JSONRPC</target>
        </trans-unit>
        <trans-unit id="023904df01b91caca2efa0a6f39bbded6afa2411" translate="yes" xml:space="preserve">
          <source>JSONRPC JSON object format</source>
          <target state="translated">Формат объекта JSONRPC JSON</target>
        </trans-unit>
        <trans-unit id="8cb256262920f81ff7c10fc10bd2e49e81c8137a" translate="yes" xml:space="preserve">
          <source>JSONRPC JSON objects are exchanged as Lisp plists (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): JSON-compatible plists are handed to the dispatcher functions and, likewise, JSON-compatible plists should be given to &lt;code&gt;jsonrpc-notify&lt;/code&gt;, &lt;code&gt;jsonrpc-request&lt;/code&gt;, and &lt;code&gt;jsonrpc-async-request&lt;/code&gt;.</source>
          <target state="translated">JSONRPC Объекты JSON обмениваются как листы Lisp (см. &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Списки свойств&lt;/a&gt; ): JSON-совместимые списки передаются функциям диспетчера, и аналогично JSON-совместимые списки должны передаваться в &lt;code&gt;jsonrpc-notify&lt;/code&gt; &lt;code&gt;jsonrpc-request&lt;/code&gt; , jsonrpc-request и &lt;code&gt;jsonrpc-async-request&lt;/code&gt; . .</target>
        </trans-unit>
        <trans-unit id="a9068fb4f18e456442cb8e3b2ddc33c5d4e5641e" translate="yes" xml:space="preserve">
          <source>JSONRPC communication</source>
          <target state="translated">связь СЖОНРПК</target>
        </trans-unit>
        <trans-unit id="bb9246b17bfdff9790f8c3e72422d7b7db8ccff0" translate="yes" xml:space="preserve">
          <source>Jumping</source>
          <target state="translated">Jumping</target>
        </trans-unit>
        <trans-unit id="a20aab26c7084f09b487ca4a8ecb0f67c7f41eca" translate="yes" xml:space="preserve">
          <source>Jumping out of a sequence.</source>
          <target state="translated">Выпрыгивает из последовательности.</target>
        </trans-unit>
        <trans-unit id="2d4e7474c74be192828a058c6fbfa5e4ed48ebd6" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;input-decode-map&lt;/code&gt;, but unlike &lt;code&gt;local-function-key-map&lt;/code&gt;, this keymap is applied regardless of whether the input key-sequence has a normal binding. Note however that actual key bindings can have an effect on &lt;code&gt;key-translation-map&lt;/code&gt;, even though they are overridden by it. Indeed, actual key bindings override &lt;code&gt;local-function-key-map&lt;/code&gt; and thus may alter the key sequence that &lt;code&gt;key-translation-map&lt;/code&gt; receives. Clearly, it is better to avoid this type of situation.</source>
          <target state="translated">Так же, как &lt;code&gt;input-decode-map&lt;/code&gt; , но в отличие от &lt;code&gt;local-function-key-map&lt;/code&gt; , эта раскладка применяется независимо от того, имеет ли входная последовательность клавиш нормальную привязку. Обратите внимание, однако, что фактические привязки клавиш могут повлиять на &lt;code&gt;key-translation-map&lt;/code&gt; , даже если она им переопределена. Действительно, фактические привязки клавиш переопределяют &lt;code&gt;local-function-key-map&lt;/code&gt; и, таким образом, могут изменять последовательность &lt;code&gt;key-translation-map&lt;/code&gt; получает карта трансляции клавиш . Ясно, что лучше избегать подобных ситуаций.</target>
        </trans-unit>
        <trans-unit id="77d80675faa0379a05b630d16d127cfd2e69de8d" translate="yes" xml:space="preserve">
          <source>Just moving the mouse, not pushing a button.</source>
          <target state="translated">Просто перемещаю мышь,а не нажимаю кнопку.</target>
        </trans-unit>
        <trans-unit id="17d7aa6336e0d7068a94ced38ef5d747f79474ef" translate="yes" xml:space="preserve">
          <source>Just what parameters a frame has depends on what display mechanism it uses. This section describes the parameters that have special meanings on some or all kinds of terminals. Of these, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;buffer-list&lt;/code&gt; and &lt;code&gt;buffer-predicate&lt;/code&gt; provide meaningful information in terminal frames, and &lt;code&gt;tty-color-mode&lt;/code&gt; is meaningful only for frames on text terminals.</source>
          <target state="translated">Какие параметры имеет фрейм, зависит от того, какой механизм отображения он использует. В этом разделе описаны параметры, которые имеют особое значение для некоторых или всех типов терминалов. Из них &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;title&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;buffer-list&lt;/code&gt; и &lt;code&gt;buffer-predicate&lt;/code&gt; предоставляют значимую информацию в терминальных фреймах, а &lt;code&gt;tty-color-mode&lt;/code&gt; имеет смысл только для фреймов на текстовых терминалах.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b4003201894d55fb52e96919b5492ae84d3e20c6" translate="yes" xml:space="preserve">
          <source>Keep the standard output stream separate from the standard error stream; deal with the ordinary output as specified by &lt;var&gt;real-destination&lt;/var&gt;, and dispose of the error output according to &lt;var&gt;error-destination&lt;/var&gt;. If &lt;var&gt;error-destination&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means to discard the error output, &lt;code&gt;t&lt;/code&gt; means mix it with the ordinary output, and a string specifies a file name to redirect error output into.</source>
          <target state="translated">Держите стандартный поток вывода отдельно от стандартного потока ошибок; обрабатывать обычный вывод, как указано в &lt;var&gt;real-destination&lt;/var&gt; , и избавляться от вывода ошибок в соответствии с &lt;var&gt;error-destination&lt;/var&gt; . Если значение &lt;var&gt;error-destination&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , это означает, что вывод ошибки следует отбросить, &lt;code&gt;t&lt;/code&gt; означает смешать его с обычным выводом, а строка указывает имя файла, в который будет перенаправлен вывод ошибки.</target>
        </trans-unit>
        <trans-unit id="2313f6a862f0a5a7b23c0ccfb3f009b7d62043d3" translate="yes" xml:space="preserve">
          <source>Keeping multiple backups for each source file.</source>
          <target state="translated">Сохранение нескольких резервных копий для каждого исходного файла.</target>
        </trans-unit>
        <trans-unit id="8d474fa62c5cf5a6da4cbae82ab10a2815da666e" translate="yes" xml:space="preserve">
          <source>Key Lookup</source>
          <target state="translated">Поиск по ключам</target>
        </trans-unit>
        <trans-unit id="cb77a254d48a5f705e632277b08072b03c096a05" translate="yes" xml:space="preserve">
          <source>Key Sequence Input</source>
          <target state="translated">Вход последовательности клавиш</target>
        </trans-unit>
        <trans-unit id="7a7b2425d6daf70b349c0a7d7d7ea874344f67e9" translate="yes" xml:space="preserve">
          <source>Key Sequences</source>
          <target state="translated">Ключевые последовательности</target>
        </trans-unit>
        <trans-unit id="0b515ab1a9fb6a3fcee02f1f50e5a2f26e18e821" translate="yes" xml:space="preserve">
          <source>Key lookup uses just the event type of each event in the key sequence; the rest of the event is ignored. In fact, a key sequence used for key lookup may designate a mouse event with just its types (a symbol) instead of the entire event (a list). See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. Such a key sequence is insufficient for &lt;code&gt;command-execute&lt;/code&gt; to run, but it is sufficient for looking up or rebinding a key.</source>
          <target state="translated">Поиск ключа использует только тип события каждого события в ключевой последовательности; остальная часть события игнорируется. Фактически, последовательность клавиш, используемая для поиска клавиш, может обозначать событие мыши только с его типами (символ), а не со всем событием (списком). См. &lt;a href=&quot;input-events#Input-Events&quot;&gt;Входные события&lt;/a&gt; . Такой последовательности клавиш недостаточно для &lt;code&gt;command-execute&lt;/code&gt; для выполнения, но ее достаточно для поиска или повторного связывания ключа.</target>
        </trans-unit>
        <trans-unit id="00ac667fea005ecd115f4ed149f2f13d0cf004c7" translate="yes" xml:space="preserve">
          <source>Key sequences as Lisp objects.</source>
          <target state="translated">Ключевые последовательности как объекты Lisp.</target>
        </trans-unit>
        <trans-unit id="e6f5765563fe2bf147f6daa60b670109e680de3f" translate="yes" xml:space="preserve">
          <source>Key sequences containing function keys, mouse button events, system events, or non-</source>
          <target state="translated">Последовательности клавиш,содержащие функциональные клавиши,события кнопок мыши,системные события или не относящиеся к ним.</target>
        </trans-unit>
        <trans-unit id="3961da9502b1e99387aff089f5c83ca94c5c588d" translate="yes" xml:space="preserve">
          <source>Keyboard Events</source>
          <target state="translated">События на клавиатуре</target>
        </trans-unit>
        <trans-unit id="cc4837611e356bedd08fd92c8bd27ef9a22790ca" translate="yes" xml:space="preserve">
          <source>Keyboard Macros</source>
          <target state="translated">Клавиатурные макросы</target>
        </trans-unit>
        <trans-unit id="8b6bd7b83a0711a97c1d29c9f645fc934a4cbc3d" translate="yes" xml:space="preserve">
          <source>Keyboard macros (strings and vectors) are commands also, even though they are not functions. See &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;. We say that a symbol is a command if its function cell contains a command (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;); such a &lt;em&gt;named command&lt;/em&gt; can be invoked with</source>
          <target state="translated">Макросы клавиатуры (строки и векторы) также являются командами, хотя они и не являются функциями. См. &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Макросы клавиатуры&lt;/a&gt; . Мы говорим, что символ является командой, если его функциональная ячейка содержит команду (см. &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Компоненты символа&lt;/a&gt; ); такую &lt;em&gt;именованную команду&lt;/em&gt; можно вызвать с помощью</target>
        </trans-unit>
        <trans-unit id="57d8ce809f6aac6dc1bf827bb30233a06fa72cbe" translate="yes" xml:space="preserve">
          <source>Keyboard macros containing the commands in this section do not completely work: exiting from Edebug, to resume the program, loses track of the keyboard macro. This is not easy to fix. Also, defining or executing a keyboard macro outside of Edebug does not affect commands inside Edebug. This is usually an advantage. See also the &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; option in &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;.</source>
          <target state="translated">Макросы клавиатуры, содержащие команды из этого раздела, не работают полностью: при выходе из Edebug для возобновления работы программы макрос клавиатуры теряется. Исправить это непросто. Кроме того, определение или выполнение макроса клавиатуры вне Edebug не влияет на команды внутри Edebug. Обычно это преимущество. См. Также параметр &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; в параметрах &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3894811d2bb2e8a0e70a43023f6e533fc04aa5f" translate="yes" xml:space="preserve">
          <source>Keymap Basics</source>
          <target state="translated">Основы ключевых карт</target>
        </trans-unit>
        <trans-unit id="7e1e2cf42b1a47ad6de7151c248a098ee3773208" translate="yes" xml:space="preserve">
          <source>Keymap Type</source>
          <target state="translated">Тип схемы</target>
        </trans-unit>
        <trans-unit id="d76a6428ca9ac90ba70592739416e9b19c454e19" translate="yes" xml:space="preserve">
          <source>Keymaps</source>
          <target state="translated">Keymaps</target>
        </trans-unit>
        <trans-unit id="68c5dc6cf88794930ca2d061c030b64676e40cee" translate="yes" xml:space="preserve">
          <source>Keymaps and Minor Modes</source>
          <target state="translated">Клавиатуры и минорные режимы</target>
        </trans-unit>
        <trans-unit id="3093db83b00c2f7e5b19934739a3fc63828ae6d8" translate="yes" xml:space="preserve">
          <source>Keymaps do not directly record bindings for the meta characters. Instead, meta characters are regarded for purposes of key lookup as sequences of two characters, the first of which is</source>
          <target state="translated">Клавишные карты не записывают непосредственно привязки для мета-символов.Вместо этого,мета-символы рассматриваются для целей поиска ключа как последовательности двух символов,первый из которых -</target>
        </trans-unit>
        <trans-unit id="3117df544bce8c92b99c739e69838cf2a9859a28" translate="yes" xml:space="preserve">
          <source>Keymaps for Translating Sequences of Events</source>
          <target state="translated">Клавиатуры для перевода последовательностей событий</target>
        </trans-unit>
        <trans-unit id="89b194f61c3768b6f1d5626d1fe4d243fd85ddb1" translate="yes" xml:space="preserve">
          <source>Keymaps for translating sequences of events.</source>
          <target state="translated">Клавиатуры для перевода последовательностей событий.</target>
        </trans-unit>
        <trans-unit id="fe40ad8ac52f1e3452189e07dae6c5efcaaf2ae3" translate="yes" xml:space="preserve">
          <source>Keypad PF keys.</source>
          <target state="translated">Клавиши PF клавиатуры.</target>
        </trans-unit>
        <trans-unit id="7ff53782c834404cf3524a8597174b2cf0076736" translate="yes" xml:space="preserve">
          <source>Keypad arrow keys. Emacs normally translates these into the corresponding non-keypad keys &lt;code&gt;home&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">Клавиши со стрелками на клавиатуре. Emacs обычно переводит их в соответствующие клавиши без клавиатуры &lt;code&gt;home&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; ,&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="b5eb0d39876e431709d140c2c21d82c8238a6c99" translate="yes" xml:space="preserve">
          <source>Keypad keys (to the right of the regular keyboard).</source>
          <target state="translated">Клавиши клавиатуры (справа от обычной клавиатуры).</target>
        </trans-unit>
        <trans-unit id="eef968747a417ebd5b41ada36d96e9a593e3dde7" translate="yes" xml:space="preserve">
          <source>Keypad keys with digits.</source>
          <target state="translated">Клавиши клавиатуры с цифрами.</target>
        </trans-unit>
        <trans-unit id="dd3107ada3563f5762a1c77c6d042feef96965e8" translate="yes" xml:space="preserve">
          <source>Keys which are numbers are the same if they are &lt;code&gt;equal&lt;/code&gt;, that is, if they are equal in value and either both are integers or both are floating point; otherwise, two distinct objects are never the same.</source>
          <target state="translated">Ключи, которые являются числами, являются одинаковыми, если они &lt;code&gt;equal&lt;/code&gt; , то есть если они равны по значению и либо оба являются целыми числами, либо оба являются числами с плавающей запятой; в противном случае два разных объекта никогда не будут одинаковыми.</target>
        </trans-unit>
        <trans-unit id="0a96287d882fd3ff1fe974dd3e8fb389c5f972f8" translate="yes" xml:space="preserve">
          <source>Keyword-argument pairs in a customization type.</source>
          <target state="translated">Пары ключей-пары памятников в виде настроек.</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="99d76e74c509d75e4d702035d810e89f93c7d6d9" translate="yes" xml:space="preserve">
          <source>Kill Ring Concepts</source>
          <target state="translated">Концепции убийственного кольца</target>
        </trans-unit>
        <trans-unit id="0793494cd99ab42f2fd7a7de2f60c1b1f50d20a1" translate="yes" xml:space="preserve">
          <source>Killed text is saved for later yanking in the &lt;em&gt;kill ring&lt;/em&gt;. This is a list that holds a number of recent kills, not just the last text kill. We call this a &amp;ldquo;ring&amp;rdquo; because yanking treats it as having elements in a cyclic order. The list is kept in the variable &lt;code&gt;kill-ring&lt;/code&gt;, and can be operated on with the usual functions for lists; there are also specialized functions, described in this section, that treat it as a ring.</source>
          <target state="translated">Убитый текст сохраняется для последующего восстановления в списке &lt;em&gt;уничтожений&lt;/em&gt; . Это список, содержащий количество недавних убийств, а не только последнее текстовое убийство. Мы называем это &amp;laquo;кольцом&amp;raquo;, потому что при восстановлении оно рассматривается как имеющее элементы в циклическом порядке. Список хранится в переменной &lt;code&gt;kill-ring&lt;/code&gt; , и с ним можно работать с обычными функциями для списков; есть также специализированные функции, описанные в этом разделе, которые обрабатывают его как кольцо.</target>
        </trans-unit>
        <trans-unit id="3af8708ad522d3a5f4a8a381debab1e57b5755ab" translate="yes" xml:space="preserve">
          <source>Killing Buffers</source>
          <target state="translated">Убийственные буферы</target>
        </trans-unit>
        <trans-unit id="905a28f726d10a308adc3a62e9e389be2995327d" translate="yes" xml:space="preserve">
          <source>Killing Emacs</source>
          <target state="translated">Убийство Имака</target>
        </trans-unit>
        <trans-unit id="e96de96c4cb696f64784e596daa37e7385985b37" translate="yes" xml:space="preserve">
          <source>Killing Emacs means ending the execution of the Emacs process. If you started Emacs from a terminal, the parent process normally resumes control. The low-level primitive for killing Emacs is &lt;code&gt;kill-emacs&lt;/code&gt;.</source>
          <target state="translated">Завершение работы Emacs означает прекращение выполнения процесса Emacs. Если вы запустили Emacs с терминала, родительский процесс обычно возобновляет управление. Низкоуровневым примитивом для уничтожения Emacs является &lt;code&gt;kill-emacs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32c52ea2582689ab686f39c40e2513b971ea8ebe" translate="yes" xml:space="preserve">
          <source>Killing a buffer that is already dead has no effect.</source>
          <target state="translated">Убийство уже мертвого буфера не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="6077b76b5702831c966267012f0fbf3e43b7d854" translate="yes" xml:space="preserve">
          <source>Killing an indirect buffer has no effect on its base buffer. Killing the base buffer effectively kills the indirect buffer in that it cannot ever again be the current buffer.</source>
          <target state="translated">Убийство косвенного буфера не влияет на его базовый буфер.Убийство базового буфера эффективно убивает косвенный буфер в том смысле,что он больше не может быть текущим буфером.</target>
        </trans-unit>
        <trans-unit id="6e673387e3bdf070063073a3f9e5be789f453c2e" translate="yes" xml:space="preserve">
          <source>Killing the associated buffer of a process also kills the process. Emacs asks for confirmation first, if the process&amp;rsquo;s &lt;code&gt;process-query-on-exit-flag&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;). This confirmation is done by the function &lt;code&gt;process-kill-buffer-query-function&lt;/code&gt;, which is run from &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; (see &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Killing Buffers&lt;/a&gt;).</source>
          <target state="translated">Удаление связанного буфера процесса также приводит к уничтожению процесса. Emacs сначала запрашивает подтверждение, если &lt;code&gt;process-query-on-exit-flag&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; (см. &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Запрос перед выходом&lt;/a&gt; ). Это подтверждение выполняется функцией &lt;code&gt;process-kill-buffer-query-function&lt;/code&gt; , которая запускается из &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; (см. &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Удаление буферов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3bdff83a09d5676c78e5c2c430a0e721e8015f53" translate="yes" xml:space="preserve">
          <source>Killing the process&amp;rsquo;s buffer deletes the process, which kills the subprocess with a &lt;code&gt;SIGHUP&lt;/code&gt; signal (see &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Signals to Processes&lt;/a&gt;).</source>
          <target state="translated">Удаление буфера процесса удаляет процесс, который завершает подпроцесс сигналом &lt;code&gt;SIGHUP&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Сигналы к процессам&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f4b3ead218699344f23be9d2cfa8db0a8b21cce" translate="yes" xml:space="preserve">
          <source>Kinds of Forms</source>
          <target state="translated">Виды форм</target>
        </trans-unit>
        <trans-unit id="64d2ffb3f2887641adb1066e515d59980846cd8f" translate="yes" xml:space="preserve">
          <source>Kludge to make preloaded Lisp functions shareable.</source>
          <target state="translated">Kludge,чтобы сделать предварительно загруженные функции Lisp совместно используемыми.</target>
        </trans-unit>
        <trans-unit id="9f99b3ffcb996071b995db44be3acebff40b85cd" translate="yes" xml:space="preserve">
          <source>Knowing the outer size of a frame is useful for fitting a frame into the working area of its display (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or for placing two frames adjacent to each other on the screen. Usually, the outer size of a frame is available only after the frame has been mapped (made visible, see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;) at least once. For the initial frame or a frame that has not been created yet, the outer size can be only estimated or must be calculated from the window-system&amp;rsquo;s or window manager&amp;rsquo;s defaults. One workaround is to obtain the differences of the outer and native (see below) sizes of a mapped frame and use them for calculating the outer size of the new frame.</source>
          <target state="translated">Знание внешнего размера рамки полезно для размещения рамки в рабочей области ее дисплея (см. &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Раздел &amp;laquo;Несколько терминалов&amp;raquo;&lt;/a&gt; ) или для размещения двух рамок рядом друг с другом на экране. Обычно внешний размер кадра доступен только после того, как кадр был сопоставлен (сделан видимым, см. &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Видимость кадров&lt;/a&gt; ) хотя бы один раз. Для начального фрейма или фрейма, который еще не был создан, внешний размер может быть только оценен или должен быть рассчитан из значений по умолчанию оконной системы или оконного менеджера. Один из способов решения этой проблемы - получить различия внешнего и собственного (см. Ниже) размеров сопоставленного кадра и использовать их для вычисления внешнего размера нового кадра.</target>
        </trans-unit>
        <trans-unit id="cbd787f29ba8f2730cc87a999b5ba33499aa964b" translate="yes" xml:space="preserve">
          <source>Kochi Gothic</source>
          <target state="translated">готика Коччи</target>
        </trans-unit>
        <trans-unit id="dbe210e5d6e8e316f7fec4291dc590c38590425d" translate="yes" xml:space="preserve">
          <source>LRM</source>
          <target state="translated">LRM</target>
        </trans-unit>
        <trans-unit id="93888d709ed769c070b132d596bc80ec625d98c7" translate="yes" xml:space="preserve">
          <source>LRO</source>
          <target state="translated">LRO</target>
        </trans-unit>
        <trans-unit id="0d6d942b0d775bd54e421837f661227031916cc3" translate="yes" xml:space="preserve">
          <source>Lambda Expressions</source>
          <target state="translated">Выражения Лямбды</target>
        </trans-unit>
        <trans-unit id="08e9d75b80cfeb0adf69e90498297bc377db4e87" translate="yes" xml:space="preserve">
          <source>Lambda expressions are functions with no names.</source>
          <target state="translated">Выражения лямбда-это функции без имен.</target>
        </trans-unit>
        <trans-unit id="91690fadbf640ee6fddae4125d1ea25d075b5bc6" translate="yes" xml:space="preserve">
          <source>Laplace edge-detection currently uses a matrix of</source>
          <target state="translated">Обнаружение краев Лапласа в настоящее время использует матрицу из</target>
        </trans-unit>
        <trans-unit id="c26bd272e8dcb1ad4f38240d83c90fe2b2da1de1" translate="yes" xml:space="preserve">
          <source>Lastly (in this series of &lt;code&gt;and&lt;/code&gt; sub-patterns), &lt;code&gt;app&lt;/code&gt; evaluates &lt;code&gt;(match-string&amp;nbsp;1&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; (line 6) to get a temporary value &lt;var&gt;tmp&lt;/var&gt; (i.e., the &amp;ldquo;NUMBER&amp;rdquo; substring) and tries to match &lt;var&gt;tmp&lt;/var&gt; against pattern &lt;code&gt;val&lt;/code&gt; (line 7). Since that is a &lt;var&gt;symbol&lt;/var&gt; pattern, it matches unconditionally and additionally binds &lt;code&gt;val&lt;/code&gt; to &lt;var&gt;tmp&lt;/var&gt;.</source>
          <target state="translated">Наконец (в этой серии &lt;code&gt;and&lt;/code&gt; суб-моделей), &lt;code&gt;app&lt;/code&gt; Равняется &lt;code&gt;(match-string&amp;nbsp;1&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; (строка 6) , чтобы получить временное значение &lt;var&gt;tmp&lt;/var&gt; (то есть, &amp;laquo;ЧИСЛО&amp;raquo; подстроки) и пытается соответствовать &lt;var&gt;tmp&lt;/var&gt; против шаблона &lt;code&gt;val&lt;/code&gt; (строка 7). Поскольку это шаблон &lt;var&gt;symbol&lt;/var&gt; , он безусловно соответствует и дополнительно связывает &lt;code&gt;val&lt;/code&gt; с &lt;var&gt;tmp&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3c447261c5172f1f0b697d9d9c7e4f3be584769f" translate="yes" xml:space="preserve">
          <source>Layout Parameters</source>
          <target state="translated">Параметры макета</target>
        </trans-unit>
        <trans-unit id="dd7dcc546a0d472e7c791aa18106a1ac7f735332" translate="yes" xml:space="preserve">
          <source>Lazy Computation of Text Properties</source>
          <target state="translated">Ленивые вычисления текстовых свойств</target>
        </trans-unit>
        <trans-unit id="51a6c8e8ab483e67fa01f4eb903d9c6360351fa8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assume you did not type</source>
          <target state="translated">Предположим, вы не набрали</target>
        </trans-unit>
        <trans-unit id="6c75a6f87f325302da0b7e4c39c4c865071152a7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a user who, as a rule, prefers to display buffers on another frame. Such a user might provide the following customization:</source>
          <target state="translated">Рассмотрим пользователя, который, как правило, предпочитает отображать буферы на другом кадре. Такой пользователь может предоставить следующие настройки:</target>
        </trans-unit>
        <trans-unit id="b0ffbdb0406b9b3b41b822f0911fd341803419cd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider the situation where &lt;code&gt;obj&lt;/code&gt; is not a string, or it is a string but has the wrong form. In this case, one of the &lt;code&gt;pred&lt;/code&gt; (lines 3-5) fails to match, thus &lt;code&gt;and&lt;/code&gt; (line 2) fails to match, thus &lt;code&gt;or&lt;/code&gt; (line 1) proceeds to try sub-pattern &lt;code&gt;let&lt;/code&gt; (line 8).</source>
          <target state="translated">Давайте рассмотрим ситуацию, когда &lt;code&gt;obj&lt;/code&gt; не является строкой или это строка, но имеет неправильную форму. В этом случае один из &lt;code&gt;pred&lt;/code&gt; (строки 3-5) не соответствует, следовательно, &lt;code&gt;and&lt;/code&gt; (строка 2) не соответствует, таким образом, &lt;code&gt;or&lt;/code&gt; (строка 1) продолжает пробовать подшаблон &lt;code&gt;let&lt;/code&gt; (строка 8).</target>
        </trans-unit>
        <trans-unit id="f464f3d20ed12cd11f243e1c955b67ff512e7c56" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a precise explanation of the arguments to the &lt;code&gt;DEFUN&lt;/code&gt; macro. Here is a template for them:</source>
          <target state="translated">Начнем с точного объяснения аргументов макроса &lt;code&gt;DEFUN&lt;/code&gt; . Вот шаблон для них:</target>
        </trans-unit>
        <trans-unit id="41d77d8b522c0e48c0a6671a0d4abc1bf8cb3bb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use the term &lt;em&gt;keymap entry&lt;/em&gt; to describe the value found by looking up an event type in a keymap. (This doesn&amp;rsquo;t include the item string and other extra elements in a keymap element for a menu item, because &lt;code&gt;lookup-key&lt;/code&gt; and other key lookup functions don&amp;rsquo;t include them in the returned value.) While any Lisp object may be stored in a keymap as a keymap entry, not all make sense for key lookup. Here is a table of the meaningful types of keymap entries:</source>
          <target state="translated">Давайте использовать термин &lt;em&gt;запись&lt;/em&gt; в &lt;em&gt;таблице клавиш&lt;/em&gt; для описания значения, найденного при поиске типа события в таблице клавиш. (Это не включает строку элемента и другие дополнительные элементы в элементе таблицы &lt;code&gt;lookup-key&lt;/code&gt; для пункта меню, потому что ключ поиска и другие функции поиска ключа не включают их в возвращаемое значение.) Хотя любой объект Lisp может храниться в раскладка клавиатуры как запись раскладки клавиатуры, не все имеет смысл для поиска ключа. Вот таблица значимых типов записей раскладки клавиатуры:</target>
        </trans-unit>
        <trans-unit id="8bbb0c0a5273b41486ac35de13cae2a081554aba" translate="yes" xml:space="preserve">
          <source>Letter-case of the strings is significant for the computed distance, but their text properties are ignored. If the optional argument &lt;var&gt;bytecompare&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function calculates the distance in terms of bytes instead of characters. The byte-wise comparison uses the internal Emacs representation of characters, so it will produce inaccurate results for multibyte strings that include raw bytes (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;); make the strings unibyte by encoding them (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;) if you need accurate results with raw bytes.</source>
          <target state="translated">Регистр букв в строках важен для вычисленного расстояния, но их текстовые свойства игнорируются. Если необязательный аргумент &lt;var&gt;bytecompare&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , функция вычисляет расстояние в байтах, а не в символах. Побайтовое сравнение использует внутреннее представление символов Emacs, поэтому оно будет давать неточные результаты для многобайтовых строк, содержащих необработанные байты (см. &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Текстовые представления&lt;/a&gt; ); сделайте строки однобайтовыми, закодировав их (см. &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Явное кодирование&lt;/a&gt; ), если вам нужны точные результаты с необработанными байтами.</target>
        </trans-unit>
        <trans-unit id="24275f318d0094becb9bb3da3aed51320878e090" translate="yes" xml:space="preserve">
          <source>Level 1: highlight function declarations, file directives (such as include or import directives), strings and comments. The idea is speed, so only the most important and top-level components are fontified.</source>
          <target state="translated">Уровень 1:выделите функциональные декларации,директивы файла (например,директивы включения или импорта),строки и комментарии.Идея заключается в скорости,поэтому шрифтифицируются только самые важные и компоненты верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="2117c8f73cb61424d16255425c9131034d1c287e" translate="yes" xml:space="preserve">
          <source>Level 2: in addition to level 1, highlight all language keywords, including type names that act like keywords, as well as named constant values. The idea is that all keywords (either syntactic or semantic) should be fontified appropriately.</source>
          <target state="translated">Уровень 2:в дополнение к уровню 1 выделите все ключевые слова языка,включая имена типов,которые действуют как ключевые слова,а также именованные постоянные значения.Идея состоит в том,что все ключевые слова (синтаксические или семантические)должны быть соответствующим образом шрифтовыми.</target>
        </trans-unit>
        <trans-unit id="660378d0e3ca367794af05e686894a24e39fd862" translate="yes" xml:space="preserve">
          <source>Level 3: in addition to level 2, highlight the symbols being defined in function and variable declarations, and all builtin function names, wherever they appear.</source>
          <target state="translated">Уровень 3:в дополнение к уровню 2,выделите символы,определяемые в объявлениях функций и переменных,и все встроенные имена функций,где бы они ни появлялись.</target>
        </trans-unit>
        <trans-unit id="87fb603e415154744259577d7102e0b2b0b1e8f1" translate="yes" xml:space="preserve">
          <source>Levels of Font Lock</source>
          <target state="translated">Уровни шрифтового замка</target>
        </trans-unit>
        <trans-unit id="845c80fcc7da2e284fb9f14c14e06bfedafb8705" translate="yes" xml:space="preserve">
          <source>Lexical Binding</source>
          <target state="translated">Лексический переплёт</target>
        </trans-unit>
        <trans-unit id="03c426c0276e9e8faf0018b87a45220aece313e0" translate="yes" xml:space="preserve">
          <source>Lexical binding is also enabled in Lisp Interaction and IELM mode, used in the</source>
          <target state="translated">Лексическая привязка также включена в режиме Lisp Interaction и IELM,используемом в</target>
        </trans-unit>
        <trans-unit id="8f85fbb6468aabdaf187bcf592914af6cc0d70ab" translate="yes" xml:space="preserve">
          <source>Lexical binding was introduced to Emacs, as an optional feature, in version 24.1. We expect its importance to increase with time. Lexical binding opens up many more opportunities for optimization, so programs using it are likely to run faster in future Emacs versions. Lexical binding is also more compatible with concurrency, which was added to Emacs in version 26.1.</source>
          <target state="translated">Лексическая привязка была введена в Emacs,как дополнительная функция,в версии 24.1.Мы ожидаем,что со временем его значение будет возрастать.Лексическое связывание открывает гораздо больше возможностей для оптимизации,поэтому программы,использующие его,скорее всего,будут работать быстрее в будущих версиях Emacs.Лексическое связывание также более совместимо с параллелизмом,который был добавлен в Emacs в версии 26.1.</target>
        </trans-unit>
        <trans-unit id="88636ad7d4af3bb35c12874b15e249f93c783680" translate="yes" xml:space="preserve">
          <source>Lexical bindings have indefinite extent. Even after a binding construct has finished executing, its lexical environment can be &amp;ldquo;kept around&amp;rdquo; in Lisp objects called &lt;em&gt;closures&lt;/em&gt;. A closure is created when you define a named or anonymous function with lexical binding enabled. See &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;, for details.</source>
          <target state="translated">Лексические привязки неограниченны. Даже после того, как конструкция привязки завершила выполнение, ее лексическое окружение можно &amp;laquo;сохранить&amp;raquo; в объектах Lisp, называемых &lt;em&gt;замыканиями&lt;/em&gt; . Замыкание создается, когда вы определяете именованную или анонимную функцию с включенной лексической привязкой. Подробнее см. &lt;a href=&quot;closures#Closures&quot;&gt;Замыкания&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58d773a50406916324eae7c7bdd22604efe3ac76" translate="yes" xml:space="preserve">
          <source>Library Search</source>
          <target state="translated">Поиск в библиотеке</target>
        </trans-unit>
        <trans-unit id="9b66d8e56a509c424a23ad7b016d16d59e2f1039" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU GPL license.</source>
          <target state="translated">Лицензия GNU GPL.</target>
        </trans-unit>
        <trans-unit id="c7e02c95fe85052fcadf9745a5f1d0358088d936" translate="yes" xml:space="preserve">
          <source>Like</source>
          <target state="translated">Like</target>
        </trans-unit>
        <trans-unit id="1b251709afeae3912bdd27abd462e3a66e4fd821" translate="yes" xml:space="preserve">
          <source>Like &amp;lsquo;</source>
          <target state="translated">Подобно '</target>
        </trans-unit>
        <trans-unit id="18854c1917f4c8ae7ba5b12ef46faa8c310417a3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;base64-encode-string&lt;/code&gt;, but generates the URL variant of base 64, and doesn&amp;rsquo;t insert newline characters into the encoded text, so the result is just one long line.</source>
          <target state="translated">Подобно &lt;code&gt;base64-encode-string&lt;/code&gt; , но генерирует вариант URL для base 64 и не вставляет символы новой строки в закодированный текст, поэтому в результате получается всего одна длинная строка.</target>
        </trans-unit>
        <trans-unit id="cf864cb9871ee5f0fed0c2f4c9ed40a911dc24fb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;const&lt;/code&gt;, but used for values which are functions. This displays the documentation string as well as the function name. The documentation string is either the one you specify with &lt;code&gt;:doc&lt;/code&gt;, or &lt;var&gt;function&lt;/var&gt;&amp;rsquo;s own documentation string.</source>
          <target state="translated">Подобно &lt;code&gt;const&lt;/code&gt; , но используется для значений, которые являются функциями. Здесь отображается строка документации, а также имя функции. Строка документации либо один заданный с &lt;code&gt;:doc&lt;/code&gt; , или &lt;var&gt;function&lt;/var&gt; &amp;laquo;s собственная строка документации.</target>
        </trans-unit>
        <trans-unit id="35528820d5e979720b5f6b9b2860031f57025852" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;const&lt;/code&gt;, but used for values which are variable names. This displays the documentation string as well as the variable name. The documentation string is either the one you specify with &lt;code&gt;:doc&lt;/code&gt;, or &lt;var&gt;variable&lt;/var&gt;&amp;rsquo;s own documentation string.</source>
          <target state="translated">Подобно &lt;code&gt;const&lt;/code&gt; , но используется для значений, которые являются именами переменных. Это отображает строку документации, а также имя переменной. Строка документации - это либо та, которую вы указываете с помощью &lt;code&gt;:doc&lt;/code&gt; , либо собственная строка документации &lt;var&gt;variable&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="511f05b3538b8f4e5096f874143c83d71d91d631" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;custom-initialize-set&lt;/code&gt;, but use the function &lt;code&gt;set-default&lt;/code&gt; to set the variable, instead of the variable&amp;rsquo;s &lt;code&gt;:set&lt;/code&gt; function. This is the usual choice for a variable whose &lt;code&gt;:set&lt;/code&gt; function enables or disables a minor mode; with this choice, defining the variable will not call the minor mode function, but customizing the variable will do so.</source>
          <target state="translated">Подобно &lt;code&gt;custom-initialize-set&lt;/code&gt; , но для установки переменной используйте функцию &lt;code&gt;set-default&lt;/code&gt; вместо функции переменной &lt;code&gt;:set&lt;/code&gt; . Это обычный выбор для переменной, функция &lt;code&gt;:set&lt;/code&gt; включает или отключает второстепенный режим; с этим выбором определение переменной не вызовет функцию второстепенного режима, но настройка переменной сделает это.</target>
        </trans-unit>
        <trans-unit id="204b186d3bb6599421d53e05eadb77e0ad88c08e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;custom-manual&lt;/code&gt; except that the link appears in the customization buffer with the Info node name.</source>
          <target state="translated">Как &lt;code&gt;custom-manual&lt;/code&gt; , за исключением того, что ссылка появляется в буфере настройки с именем узла Info.</target>
        </trans-unit>
        <trans-unit id="ce9088de4b6dd7133bd35b95efda2d37cb731128" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;defmacro&lt;/code&gt;, a function inlined with &lt;code&gt;define-inline&lt;/code&gt; inherits the scoping rules, either dynamic or lexical, from the call site. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">Как и &lt;code&gt;defmacro&lt;/code&gt; , функция, встроенная в &lt;code&gt;define-inline&lt;/code&gt; , наследует правила области видимости, динамические или лексические, от сайта вызова. См. Раздел &amp;laquo; &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Переменная область видимости&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="054b1abbf6ea76431660ba137b3df462a1771437" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;defvar&lt;/code&gt;, this macro marks &lt;code&gt;option&lt;/code&gt; as a special variable, meaning that it should always be dynamically bound. If &lt;var&gt;option&lt;/var&gt; is already lexically bound, that lexical binding remains in effect until the binding construct exits. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">Как и &lt;code&gt;defvar&lt;/code&gt; , этот макрос отмечает &lt;code&gt;option&lt;/code&gt; как специальную переменную, что означает, что он всегда должен быть динамически привязан. Если &lt;var&gt;option&lt;/var&gt; уже лексически привязан, это лексическое связывание остается в силе до выхода из конструкции связывания. См. Раздел &amp;laquo; &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Переменная область видимости&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f505d65b09cd1366a862e42a8e4a2919c0a4c57d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;exit&lt;/code&gt;, but add the key that was pressed to &lt;code&gt;unread-command-events&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; , что и exit , но добавьте нажатую клавишу к &lt;code&gt;unread-command-events&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Ввод событий&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ea9c4bf2fcaba7d1996da05f9b1b988c94d94fff" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;group&lt;/code&gt;, but explicitly assign the group number &lt;var&gt;n&lt;/var&gt;. &lt;var&gt;n&lt;/var&gt; must be positive. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Подобно &lt;code&gt;group&lt;/code&gt; , но явно присвоить группе номер &lt;var&gt;n&lt;/var&gt; . &lt;var&gt;n&lt;/var&gt; должно быть положительным. Соответствующее строковое регулярное выражение: '</target>
        </trans-unit>
        <trans-unit id="4add0eb468b070e1db0603abb32c078a15300385" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;list&lt;/code&gt; except that the value must be a vector instead of a list. The elements work the same as in &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;code&gt;list&lt;/code&gt; за исключением того, что значение должно быть вектором, а не списком. Элементы работают так же, как в &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e9ef9ed8d9cfadaf1437987621cbd1046a68178" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;minflt&lt;/code&gt; and &lt;code&gt;majflt&lt;/code&gt;, but include the number of page faults for all the child processes of the given process.</source>
          <target state="translated">Подобно &lt;code&gt;minflt&lt;/code&gt; и &lt;code&gt;majflt&lt;/code&gt; , но включает количество ошибок страниц для всех дочерних процессов данного процесса.</target>
        </trans-unit>
        <trans-unit id="9dec2e247bfc6d918dc0518cecb0337e87b44e0a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;next-frame&lt;/code&gt;, but cycles through all frames in the opposite direction.</source>
          <target state="translated">Подобно &lt;code&gt;next-frame&lt;/code&gt; , но циклически проходит через все кадры в противоположном направлении.</target>
        </trans-unit>
        <trans-unit id="1c35e817ce01d7a752f2915ea0e7c93f0517b8ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plist-get&lt;/code&gt; except that it compares properties using &lt;code&gt;equal&lt;/code&gt; instead of &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;code&gt;plist-get&lt;/code&gt; , за исключением того, что он сравнивает свойства, используя &lt;code&gt;equal&lt;/code&gt; вместо &lt;code&gt;eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8a06b48a7b978de0c0d0d182fbd613f4474d842" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plist-put&lt;/code&gt; except that it compares properties using &lt;code&gt;equal&lt;/code&gt; instead of &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;code&gt;plist-put&lt;/code&gt; , за исключением того, что он сравнивает свойства, используя &lt;code&gt;equal&lt;/code&gt; вместо &lt;code&gt;eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e02ab76a9a240ef8de0ab7231efecfe7c29c24c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;remove-text-properties&lt;/code&gt; except that &lt;var&gt;list-of-properties&lt;/var&gt; is a list of property names only, not an alternating list of property names and values.</source>
          <target state="translated">Как и &lt;code&gt;remove-text-properties&lt;/code&gt; , за исключением того, что &lt;var&gt;list-of-properties&lt;/var&gt; - это только список имен свойств, а не чередующийся список имен и значений свойств.</target>
        </trans-unit>
        <trans-unit id="84e3993015f242ac6ae5f8797efb186174cfc8b8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;set-buffer-modified-p&lt;/code&gt;, but does not force redisplay of mode lines.</source>
          <target state="translated">Подобно &lt;code&gt;set-buffer-modified-p&lt;/code&gt; , но не вызывает повторного отображения строк режима.</target>
        </trans-unit>
        <trans-unit id="9a6e79e4e3bd95966166ddf0bb5d7b010896c5bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;signal&lt;/code&gt; (see &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;), but the signal is delivered in the thread &lt;var&gt;thread&lt;/var&gt;. If &lt;var&gt;thread&lt;/var&gt; is the current thread, then this just calls &lt;code&gt;signal&lt;/code&gt; immediately. Otherwise, &lt;var&gt;thread&lt;/var&gt; will receive the signal as soon as it becomes current. If &lt;var&gt;thread&lt;/var&gt; was blocked by a call to &lt;code&gt;mutex-lock&lt;/code&gt;, &lt;code&gt;condition-wait&lt;/code&gt;, or &lt;code&gt;thread-join&lt;/code&gt;; &lt;code&gt;thread-signal&lt;/code&gt; will unblock it.</source>
          <target state="translated">Подобно &lt;code&gt;signal&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Ошибки сигнализации&amp;raquo;&lt;/a&gt; ), но сигнал доставляется в потоке &lt;var&gt;thread&lt;/var&gt; . Если &lt;var&gt;thread&lt;/var&gt; является текущим потоком, тогда это просто вызывает &lt;code&gt;signal&lt;/code&gt; немедленно. В противном случае &lt;var&gt;thread&lt;/var&gt; получит сигнал, как только он станет текущим. Если &lt;var&gt;thread&lt;/var&gt; был заблокирован вызовом &lt;code&gt;mutex-lock&lt;/code&gt; , &lt;code&gt;condition-wait&lt;/code&gt; или соединения &lt;code&gt;thread-join&lt;/code&gt; ; &lt;code&gt;thread-signal&lt;/code&gt; разблокирует его.</target>
        </trans-unit>
        <trans-unit id="70f44fcb4db769ebd3aa02784e1dfae20cbb9cec" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;start-process&lt;/code&gt;, this function starts a new asynchronous subprocess running &lt;var&gt;program&lt;/var&gt; in it, and returns its process object.</source>
          <target state="translated">Как и &lt;code&gt;start-process&lt;/code&gt; , эта функция запускает новую &lt;var&gt;program&lt;/var&gt; выполняющую асинхронный подпроцесс , и возвращает свой объект процесса.</target>
        </trans-unit>
        <trans-unit id="1768be4d2bcedb1b2e7b51f71b8b22c88b6d6932" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;string&lt;/code&gt; except that the string must be a valid regular expression.</source>
          <target state="translated">Подобно &lt;code&gt;string&lt;/code&gt; за исключением того, что строка должна быть действительным регулярным выражением.</target>
        </trans-unit>
        <trans-unit id="f979121e411bd20dfdc3630fc906f2e77d6bac00" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;switch-to-buffer&lt;/code&gt;, this function updates the buffer list unless &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;code&gt;switch-to-buffer&lt;/code&gt; , эта функция обновляет список буферов, если &lt;var&gt;norecord&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41318cc8f100d4675dfe14fffade93d0c7208044" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt;, but used for text-mode frames.</source>
          <target state="translated">Подобно &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt; , но используется для фреймов текстового режима.</target>
        </trans-unit>
        <trans-unit id="e26f9bf4e17c8b8a9b3a88b07dbaf00921a8ff2b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt;, but used when the column is sorted in the descending order.</source>
          <target state="translated">Подобно &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt; , но используется, когда столбец сортируется в порядке убывания.</target>
        </trans-unit>
        <trans-unit id="ac75f39d714deb46e7cfbb9da2b8004c0b4dd120" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-tty-sort-indicator-asc&lt;/code&gt;, but used when the column is sorted in the descending order.</source>
          <target state="translated">Подобно &lt;code&gt;tabulated-list-tty-sort-indicator-asc&lt;/code&gt; , но используется, когда столбец сортируется в порядке убывания.</target>
        </trans-unit>
        <trans-unit id="83baebd26ca9a920629b6b8881f71882e191e292" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;this-command-keys&lt;/code&gt;, except that it always returns the events in a vector, so you don&amp;rsquo;t need to deal with the complexities of storing input events in a string (see &lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;Strings of Events&lt;/a&gt;).</source>
          <target state="translated">Как &lt;code&gt;this-command-keys&lt;/code&gt; , за исключением того, что он всегда возвращает события в векторе, поэтому вам не нужно иметь дело со сложностями хранения входных событий в строке (см. &lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;Строки событий&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a77e33ddaa024bcb7e1de6d16b70822ff2b74e0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;utime&lt;/code&gt;, &lt;code&gt;stime&lt;/code&gt;, and &lt;code&gt;time&lt;/code&gt;, but include the times of all the child processes of the given process.</source>
          <target state="translated">Подобно &lt;code&gt;utime&lt;/code&gt; , &lt;code&gt;stime&lt;/code&gt; и &lt;code&gt;time&lt;/code&gt; , но включает время всех дочерних процессов данного процесса.</target>
        </trans-unit>
        <trans-unit id="264fb3dd5c5a9c6df032cdd8b67cc032c5141d77" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;vertical-motion&lt;/code&gt;, &lt;code&gt;count-screen-lines&lt;/code&gt; always uses the current buffer, regardless of which buffer is displayed in &lt;var&gt;window&lt;/var&gt;. This makes possible to use &lt;code&gt;count-screen-lines&lt;/code&gt; in any buffer, whether or not it is currently displayed in some window.</source>
          <target state="translated">Подобно &lt;code&gt;vertical-motion&lt;/code&gt; , &lt;code&gt;count-screen-lines&lt;/code&gt; всегда использует текущий буфер, независимо от того, какой буфер отображается в &lt;var&gt;window&lt;/var&gt; . Это позволяет использовать &lt;code&gt;count-screen-lines&lt;/code&gt; в любом буфере, независимо от того, отображается он в данный момент в каком-либо окне.</target>
        </trans-unit>
        <trans-unit id="1d2cce2deecdcf8cf23c34bb65bc484d84587588" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;y-or-n-p&lt;/code&gt;, except that if the user fails to answer within &lt;var&gt;seconds&lt;/var&gt; seconds, this function stops waiting and returns &lt;var&gt;default&lt;/var&gt;. It works by setting up a timer; see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;. The argument &lt;var&gt;seconds&lt;/var&gt; should be a number.</source>
          <target state="translated">Подобно &lt;code&gt;y-or-n-p&lt;/code&gt; , за исключением того, что если пользователь не отвечает в течение &lt;var&gt;seconds&lt;/var&gt; секунд, эта функция прекращает ожидание и возвращает &lt;var&gt;default&lt;/var&gt; . Он работает путем установки таймера; см. &lt;a href=&quot;timers#Timers&quot;&gt;Таймеры&lt;/a&gt; . Аргумент &lt;var&gt;seconds&lt;/var&gt; должен быть числом.</target>
        </trans-unit>
        <trans-unit id="42d3bb0dd219a8f3377a5d7dfc35b9c093371501" translate="yes" xml:space="preserve">
          <source>Like a buffer, a string can contain text properties for the characters in it, as well as the characters themselves. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;. All the Lisp primitives that copy text from strings to buffers or other strings also copy the properties of the characters being copied.</source>
          <target state="translated">Подобно буферу, строка может содержать текстовые свойства для символов в ней, а также самих символов. См. &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Свойства текста&lt;/a&gt; . Все примитивы Lisp, копирующие текст из строк в буферы или другие строки, также копируют свойства копируемых символов.</target>
        </trans-unit>
        <trans-unit id="a8a6416bd2f6413e3de422a7bab6e772fb8419cd" translate="yes" xml:space="preserve">
          <source>Like a mode line, but at the top.</source>
          <target state="translated">Как строка режима,но сверху.</target>
        </trans-unit>
        <trans-unit id="ea6efe0718530791d43dbe7d53bb5a14e1b67ed8" translate="yes" xml:space="preserve">
          <source>Like abbrevs, abbrev tables have properties, some of which influence the way they work. You can provide them as arguments to &lt;code&gt;define-abbrev-table&lt;/code&gt;, and manipulate them with the functions:</source>
          <target state="translated">Как и сокращения, таблицы сокращений имеют свойства, некоторые из которых влияют на способ их работы. Вы можете предоставить их в качестве аргументов для &lt;code&gt;define-abbrev-table&lt;/code&gt; и управлять ими с помощью функций:</target>
        </trans-unit>
        <trans-unit id="44ec097d5bc177ce9f85e7d020e50ae88d2f91c4" translate="yes" xml:space="preserve">
          <source>Like any application, Emacs can be run in a secure environment, where the operating system enforces rules about access and the like. With some care, Emacs-based applications can also be part of a security perimeter that checks such rules. Although the default settings for Emacs work well for a typical software development environment, they may require adjustment in environments containing untrusted users that may include attackers. Here is a compendium of security issues that may be helpful if you are developing such applications. It is by no means complete; it is intended to give you an idea of the security issues involved, rather than to be a security checklist.</source>
          <target state="translated">Как и любое другое приложение,Emacs можно запускать в безопасной среде,где операционная система применяет правила доступа и тому подобное.С некоторой осторожностью приложения на базе Emacs также могут быть частью периметра безопасности,который проверяет такие правила.Хотя настройки по умолчанию для Emacs хорошо работают для типичной среды разработки программного обеспечения,они могут потребовать настройки в средах,содержащих недоверенных пользователей,которые могут включать в себя злоумышленников.Вот список проблем безопасности,которые могут быть полезны,если вы разрабатываете такие приложения.Он ни в коем случае не является полным;он предназначен для того,чтобы дать вам представление о связанных с безопасностью проблемах,а не для того,чтобы быть контрольным списком безопасности.</target>
        </trans-unit>
        <trans-unit id="64697998797f77574ca5b12fc923c577aecf3e58" translate="yes" xml:space="preserve">
          <source>Like any marker, this marker can be set to point at any buffer you like. If you make it point at any buffer other than the one of which it is the mark, it will yield perfectly consistent, but rather odd, results. We recommend that you not do it!</source>
          <target state="translated">Как и любой маркер,этот маркер может быть установлен на любой понравившийся буфер.Если вы установите его на любой буфер,отличный от того,которым он является маркером,то это даст вполне последовательный,но довольно странный результат.Мы не рекомендуем этого делать!</target>
        </trans-unit>
        <trans-unit id="1e30ff33c9d97dd95ea9111da199e049a900cc43" translate="yes" xml:space="preserve">
          <source>Like other arrays, vectors use zero-origin indexing: the first element has index 0.</source>
          <target state="translated">Как и другие массивы,векторы используют нулевую индексацию:первый элемент имеет индекс 0.</target>
        </trans-unit>
        <trans-unit id="bd4fbae429af14d7410a0be5944198b140179fb1" translate="yes" xml:space="preserve">
          <source>Like other buffers, a minibuffer uses a local keymap (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;) to specify special key bindings. The function that invokes the minibuffer also sets up its local map according to the job to be done. See &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Text from Minibuffer&lt;/a&gt;, for the non-completion minibuffer local maps. See &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Completion Commands&lt;/a&gt;, for the minibuffer local maps for completion.</source>
          <target state="translated">Как и другие буферы, минибуфер использует локальную &lt;a href=&quot;keymaps#Keymaps&quot;&gt;таблицу ключей&lt;/a&gt; (см. Карты ключей ) для определения специальных привязок клавиш. Функция, вызывающая минибуфер, также настраивает свою локальную карту в соответствии с выполняемой работой. См. &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Текст из минибуфера&lt;/a&gt; , где указаны незавершенные локальные карты минибуфера. См. &amp;laquo; &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Команды завершения&amp;raquo;&lt;/a&gt; , чтобы узнать о локальных картах минибуфера.</target>
        </trans-unit>
        <trans-unit id="b2ee97c7efba6f620110611b5db71717d51e8ddb" translate="yes" xml:space="preserve">
          <source>Like other positions, point designates a place between two characters (or before the first character, or after the last character), rather than a particular character. Usually terminals display the cursor over the character that immediately follows point; point is actually before the character on which the cursor sits.</source>
          <target state="translated">Как и другие позиции,точка обозначает место между двумя символами (или перед первым символом,или после последнего символа),а не конкретный символ.Обычно терминалы отображают курсор над символом,который следует непосредственно за точкой;точка на самом деле находится перед символом,на котором находится курсор.</target>
        </trans-unit>
        <trans-unit id="8da9a43aec4137b9ff967ca13c1bd7372e6ad639" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;and&lt;/code&gt; construct, &lt;code&gt;or&lt;/code&gt; can be written in terms of &lt;code&gt;cond&lt;/code&gt;. For example:</source>
          <target state="translated">Подобно конструкции &lt;code&gt;and&lt;/code&gt; &lt;code&gt;or&lt;/code&gt; может быть записано в терминах &lt;code&gt;cond&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="a93ae83163cf6a8ddec90d055956fb5025562919" translate="yes" xml:space="preserve">
          <source>Like the menu bar, the tool bar (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;) can be either internal (drawn by Emacs itself) or external (drawn by a toolkit). The GTK+ and NS builds have the tool bar drawn by the toolkit. The remaining builds use internal tool bars. With GTK+ the tool bar can be located on either side of the frame, immediately outside the internal border, see below. Tool bars are usually not shown for child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;). Display of the tool bar can be suppressed by setting the &lt;code&gt;tool-bar-lines&lt;/code&gt; parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;) to zero.</source>
          <target state="translated">Как и строка меню, панель инструментов (см. Панель &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;инструментов&lt;/a&gt; ) может быть внутренней (нарисованной самим Emacs) или внешней (нарисованной набором инструментов). В сборках GTK + и NS панель инструментов нарисована набором инструментов. В остальных сборках используются внутренние панели инструментов. С GTK + панель инструментов может быть расположена с любой стороны кадра, сразу за внутренней границей, см. Ниже. Панели инструментов для дочерних фреймов обычно не отображаются (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ). Отображение панели инструментов можно подавить, установив параметр &lt;code&gt;tool-bar-lines&lt;/code&gt; (см. &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Параметры макета&lt;/a&gt; ) в ноль.</target>
        </trans-unit>
        <trans-unit id="fda771ab560862777893dc0b295d979a9763ad74" translate="yes" xml:space="preserve">
          <source>Like the menu bar, the tool bar can display separators (see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;). Tool bar separators are vertical rather than horizontal, though, and only a single style is supported. They are represented in the tool bar keymap by &lt;code&gt;(menu-item &quot;--&quot;)&lt;/code&gt; entries; properties like &lt;code&gt;:visible&lt;/code&gt; are not supported for tool bar separators. Separators are rendered natively in GTK+ and Nextstep tool bars; in the other cases, they are rendered using an image of a vertical line.</source>
          <target state="translated">Как и строка меню, панель инструментов может отображать разделители (см. &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Разделители меню&lt;/a&gt; ). Однако разделители панели инструментов являются вертикальными, а не горизонтальными, и поддерживается только один стиль. Они представлены в раскладке панели инструментов пунктами &lt;code&gt;(menu-item &quot;--&quot;)&lt;/code&gt; ; такие свойства, как &lt;code&gt;:visible&lt;/code&gt; , не поддерживаются для разделителей панели инструментов. Разделители изначально отображаются на панелях инструментов GTK + и Nextstep; в остальных случаях они визуализируются с использованием изображения вертикальной линии.</target>
        </trans-unit>
        <trans-unit id="9df33e5d8f7b38be89f4b568592a838f25636c81" translate="yes" xml:space="preserve">
          <source>Like the standard &lt;code&gt;backref&lt;/code&gt; construct, but &lt;var&gt;ref&lt;/var&gt; can here also be a name introduced by a previous &lt;code&gt;(let &lt;var&gt;ref&lt;/var&gt; &amp;hellip;)&lt;/code&gt; construct.</source>
          <target state="translated">Подобно стандартной конструкции &lt;code&gt;backref&lt;/code&gt; , но &lt;var&gt;ref&lt;/var&gt; здесь также может быть именем, введенным предыдущей конструкцией &lt;code&gt;(let &lt;var&gt;ref&lt;/var&gt; &amp;hellip;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6121daf0fb6ccba2fa0baef96baeb4b4791c43e3" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;save-excursion&lt;/code&gt; does not restore window-buffer correspondences altered by functions such as &lt;code&gt;switch-to-buffer&lt;/code&gt;.</source>
          <target state="translated">Точно так же &lt;code&gt;save-excursion&lt;/code&gt; не восстанавливает соответствия окно-буфер, измененные такими функциями, как &lt;code&gt;switch-to-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ef385a59e33cf483e8dded5ef79cc70f792473" translate="yes" xml:space="preserve">
          <source>Likewise, for handling the three types of remote contacts (requests, notifications, and responses to local requests), the transport implementation must arrange for the function &lt;code&gt;jsonrpc-connection-receive&lt;/code&gt; to be called after noticing a new JSONRPC message on the wire (whatever that &quot;wire&quot; may be).</source>
          <target state="translated">Аналогичным образом, для обработки трех типов удаленных контактов (запросов, уведомлений и ответов на локальные запросы) реализация транспорта должна организовать &lt;code&gt;jsonrpc-connection-receive&lt;/code&gt; функции jsonrpc-connection-receive после обнаружения нового сообщения JSONRPC в сети (что бы это ни было &quot;проволока&quot; может быть).</target>
        </trans-unit>
        <trans-unit id="0f76d8acf641d878dd8f95ce0cf81e2a38f35161" translate="yes" xml:space="preserve">
          <source>Likewise, for scrolling up. The value, &lt;var&gt;f&lt;/var&gt;, specifies how far point should be placed from the bottom of the window; thus, as with &lt;code&gt;scroll-down-aggressively&lt;/code&gt;, a larger value scrolls more aggressively.</source>
          <target state="translated">Аналогично для прокрутки вверх. Значение &lt;var&gt;f&lt;/var&gt; указывает, как далеко точка должна быть размещена от нижней части окна; таким образом, как и в случае с &lt;code&gt;scroll-down-aggressively&lt;/code&gt; , большее значение прокручивается более агрессивно.</target>
        </trans-unit>
        <trans-unit id="9173a7576ab9406f8159ed0ad696d18cf5a5de55" translate="yes" xml:space="preserve">
          <source>Likewise, to move to the end of the buffer, use:</source>
          <target state="translated">Точно так же,чтобы перейти в конец буфера,используйте:</target>
        </trans-unit>
        <trans-unit id="607bc37fe36f1db5f0eedea396370eb624c4e6e9" translate="yes" xml:space="preserve">
          <source>Likewise, you can suppress the warning for a specific use of a variable &lt;var&gt;variable&lt;/var&gt; by conditionalizing it on a &lt;code&gt;boundp&lt;/code&gt; test:</source>
          <target state="translated">Точно так же вы можете подавить предупреждение о конкретном использовании переменной- &lt;var&gt;variable&lt;/var&gt; , &lt;code&gt;boundp&lt;/code&gt; его условием в граничном тесте:</target>
        </trans-unit>
        <trans-unit id="6c62e4ab3dbe05f042adec9ffbc82e4cfec79087" translate="yes" xml:space="preserve">
          <source>Likewise, you can tell the compiler that a variable is defined using &lt;code&gt;defvar&lt;/code&gt; with no initial value. (Note that this marks the variable as special, i.e. dynamically bound, but only within the current lexical scope, or file if at top-level.) See &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;.</source>
          <target state="translated">Точно так же вы можете сообщить компилятору, что переменная определяется с помощью &lt;code&gt;defvar&lt;/code&gt; без начального значения. (Обратите внимание, что это помечает переменную как специальную, то есть динамически связанную, но только в пределах текущей лексической области, или файл, если он находится на верхнем уровне.) См. &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Определение переменных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="4b7070c9a5c61e5ad4b904c57e944895659357fd" translate="yes" xml:space="preserve">
          <source>Line 1 &amp;ldquo;factors out&amp;rdquo; the &lt;var&gt;expval&lt;/var&gt; binding with &lt;code&gt;and&lt;/code&gt; and &lt;var&gt;symbol&lt;/var&gt; (in this case, &lt;code&gt;num&lt;/code&gt;). On line 2, &lt;code&gt;or&lt;/code&gt; begins in the same way as before, but instead of binding different symbols, uses &lt;code&gt;let&lt;/code&gt; twice (lines 3-4) to bind the same symbol &lt;code&gt;spin&lt;/code&gt; in both sub-patterns. The value of &lt;code&gt;spin&lt;/code&gt; distinguishes the sub-patterns. The body form references both symbols (line 5).</source>
          <target state="translated">Строка 1 &amp;laquo; &lt;var&gt;expval&lt;/var&gt; привязку expval с помощью &lt;var&gt;symbol&lt;/var&gt; &lt;code&gt;and&lt;/code&gt; и (в данном случае &lt;code&gt;num&lt;/code&gt; ). В строке 2 &lt;code&gt;or&lt;/code&gt; начинается так же, как и раньше, но вместо привязки разных символов, используется &lt;code&gt;let&lt;/code&gt; дважды (строки 3-4) для привязки одного и того же &lt;code&gt;spin&lt;/code&gt; символа в обоих подшаблонах. Значение &lt;code&gt;spin&lt;/code&gt; отличает суб-паттерны. Форма тела ссылается на оба символа (строка 5).</target>
        </trans-unit>
        <trans-unit id="ac3292c1d1364f8eb7cb1cb73de1b6c6819f007a" translate="yes" xml:space="preserve">
          <source>Line Height</source>
          <target state="translated">Высота линии</target>
        </trans-unit>
        <trans-unit id="d19fdad54534f671523b6ba91167c0a2af1211e8" translate="yes" xml:space="preserve">
          <source>Link to a file; &lt;var&gt;file&lt;/var&gt; is a string which specifies the name of the file to visit with &lt;code&gt;find-file&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">Ссылка на файл; &lt;var&gt;file&lt;/var&gt; - это строка, которая указывает имя файла, который нужно посетить с помощью &lt;code&gt;find-file&lt;/code&gt; , когда пользователь вызывает эту ссылку.</target>
        </trans-unit>
        <trans-unit id="22480f8e64b100d948600dc541fbe87fd12cf0ad" translate="yes" xml:space="preserve">
          <source>Link to a web page; &lt;var&gt;url&lt;/var&gt; is a string which specifies the</source>
          <target state="translated">Ссылка на веб-страницу; &lt;var&gt;url&lt;/var&gt; - это строка, определяющая</target>
        </trans-unit>
        <trans-unit id="6196a47a6fade23ecdb0cf7553070cfc1f4b67e9" translate="yes" xml:space="preserve">
          <source>Link to an Emacs Lisp library file; &lt;var&gt;library&lt;/var&gt; is a string which specifies the library name.</source>
          <target state="translated">Ссылка на файл библиотеки Emacs Lisp; &lt;var&gt;library&lt;/var&gt; - это строка, определяющая имя библиотеки.</target>
        </trans-unit>
        <trans-unit id="bf66ba2266e555d89a7551e84cff8291754f5ac7" translate="yes" xml:space="preserve">
          <source>Link to an Info node; &lt;var&gt;info-node&lt;/var&gt; is a string which specifies the node name, as in &lt;code&gt;&quot;(emacs)Top&quot;&lt;/code&gt;. The link appears as &amp;lsquo;</source>
          <target state="translated">Ссылка на информационный узел; &lt;var&gt;info-node&lt;/var&gt; - это строка, определяющая имя узла, как в &lt;code&gt;&quot;(emacs)Top&quot;&lt;/code&gt; . Ссылка отображается как &quot;</target>
        </trans-unit>
        <trans-unit id="0d9e752b2010ff1455dafc24361a10db156301e1" translate="yes" xml:space="preserve">
          <source>Link to another customization group. Invoking it creates a new customization buffer for &lt;var&gt;group&lt;/var&gt;.</source>
          <target state="translated">Ссылка на другую группу настройки. При его вызове создается новый буфер настройки для &lt;var&gt;group&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="8c73b95e12ba7b48400412835847598d2b4297a9" translate="yes" xml:space="preserve">
          <source>Link to the commentary section of a library; &lt;var&gt;library&lt;/var&gt; is a string which specifies the library name. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;Library Headers&lt;/a&gt;.</source>
          <target state="translated">Ссылка на раздел комментариев библиотеки; &lt;var&gt;library&lt;/var&gt; - это строка, определяющая имя библиотеки. См. &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;Заголовки библиотеки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0af47038ac7d2a137e5fb0843704c0a217bb19fe" translate="yes" xml:space="preserve">
          <source>Link to the documentation of a function; &lt;var&gt;function&lt;/var&gt; is a string which specifies the name of the function to describe with &lt;code&gt;describe-function&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">Ссылка на документацию по функции; &lt;var&gt;function&lt;/var&gt; - это строка, которая определяет имя функции, которую нужно описать с помощью &lt;code&gt;describe-function&lt;/code&gt; , когда пользователь вызывает эту ссылку.</target>
        </trans-unit>
        <trans-unit id="6004ab0c17b773b21124a13a049a164c20095e5e" translate="yes" xml:space="preserve">
          <source>Link to the documentation of a variable; &lt;var&gt;variable&lt;/var&gt; is a string which specifies the name of the variable to describe with &lt;code&gt;describe-variable&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">Ссылка на документацию переменной; &lt;var&gt;variable&lt;/var&gt; - это строка, которая определяет имя переменной, которую нужно описать с помощью &lt;code&gt;describe-variable&lt;/code&gt; когда пользователь вызывает эту ссылку.</target>
        </trans-unit>
        <trans-unit id="11b92badcf27d4b637951157332f5903e3a51659" translate="yes" xml:space="preserve">
          <source>Links to the preceding and following nodes in the chain.</source>
          <target state="translated">Ссылки на предыдущие и последующие узлы цепи.</target>
        </trans-unit>
        <trans-unit id="a7518b7d8d9c8b8ab73ff878b6f9268c622af85d" translate="yes" xml:space="preserve">
          <source>Lisp (LISt Processing language) was first developed in the late 1950s at the Massachusetts Institute of Technology for research in artificial intelligence. The great power of the Lisp language makes it ideal for other purposes as well, such as writing editing commands.</source>
          <target state="translated">Lisp (LISt Processing language)был впервые разработан в конце 1950-х годов в Массачусетском технологическом институте для исследований в области искусственного интеллекта.Огромная мощь языка Lisp делает его идеальным и для других целей,например,для написания команд редактирования.</target>
        </trans-unit>
        <trans-unit id="093033f3ad1baf1e960c639480ab203cf9eefb80" translate="yes" xml:space="preserve">
          <source>Lisp Data Types</source>
          <target state="translated">Типы данных Lisp</target>
        </trans-unit>
        <trans-unit id="070300a2d38e695ab5e6b29fde3619a0ca2a902e" translate="yes" xml:space="preserve">
          <source>Lisp History</source>
          <target state="translated">история болезни Лисы</target>
        </trans-unit>
        <trans-unit id="a95ae648eeb012f8070dcb15c34e598757cc1931" translate="yes" xml:space="preserve">
          <source>Lisp Macro Evaluation</source>
          <target state="translated">Макрооценка Лиспа</target>
        </trans-unit>
        <trans-unit id="0e410e687183103929a8880a76ed05ea40533c7d" translate="yes" xml:space="preserve">
          <source>Lisp code should use this function instead of &lt;code&gt;buffer-substring&lt;/code&gt;, &lt;code&gt;buffer-substring-no-properties&lt;/code&gt;, or &lt;code&gt;delete-and-extract-region&lt;/code&gt; when copying into user-accessible data structures such as the kill-ring, X clipboard, and registers. Major and minor modes can modify &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; to alter such text as it is copied out of the buffer.</source>
          <target state="translated">Код на Лиспе должен использовать эту функцию вместо &lt;code&gt;buffer-substring&lt;/code&gt; , &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; или &lt;code&gt;delete-and-extract-region&lt;/code&gt; при копировании в доступные пользователю структуры данных, такие как kill-ring, X-буфер обмена и регистры. Основной и второстепенный режимы могут модифицировать &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; чтобы изменять такой текст, когда он копируется из буфера.</target>
        </trans-unit>
        <trans-unit id="8fc5a9e95ef7885a0b7599ee4ecbaf851f92a696" translate="yes" xml:space="preserve">
          <source>Lisp expression:</source>
          <target state="translated">Выражение лица:</target>
        </trans-unit>
        <trans-unit id="9a49e6726f59e36c724f79f5510e315b850a89a9" translate="yes" xml:space="preserve">
          <source>Lisp expressions for defining functions.</source>
          <target state="translated">Выражения на языке Lisp для определения функций.</target>
        </trans-unit>
        <trans-unit id="04c1aa53f54116c8c2b6559a2f7db15e028716fc" translate="yes" xml:space="preserve">
          <source>Lisp functions are executable code, just like functions in other programming languages. In Lisp, unlike most languages, functions are also Lisp objects. A non-compiled function in Lisp is a lambda expression: that is, a list whose first element is the symbol &lt;code&gt;lambda&lt;/code&gt; (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;).</source>
          <target state="translated">Функции Lisp - это исполняемый код, как и функции в других языках программирования. В Лиспе, в отличие от большинства языков, функции также являются объектами Лиспа. Некомпилированная функция в Лиспе - это лямбда-выражение: то есть список, первым элементом которого является &lt;code&gt;lambda&lt;/code&gt; символ (см. &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Лямбда-выражения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="48b47c25285835ef4229cdb4249b0b97f8b61318" translate="yes" xml:space="preserve">
          <source>Lisp functions vs. primitives; terminology.</source>
          <target state="translated">Функции лиспада против примитивов;терминология.</target>
        </trans-unit>
        <trans-unit id="b7f5a1d65c1925ee62d77c064437066c7e060879" translate="yes" xml:space="preserve">
          <source>Lisp is unlike many other languages in that its objects are &lt;em&gt;self-typing&lt;/em&gt;: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.</source>
          <target state="translated">Lisp отличается от многих других языков тем, что его объекты являются &lt;em&gt;самотипируемыми&lt;/em&gt; : примитивный тип каждого объекта неявен в самом объекте. Например, если объект является вектором, ничто не может рассматривать его как число; Лисп знает, что это вектор, а не число.</target>
        </trans-unit>
        <trans-unit id="c1a44c55700efa37938155d19ec6cee2495bb14b" translate="yes" xml:space="preserve">
          <source>Lisp macro objects are usually defined with the built-in &lt;code&gt;defmacro&lt;/code&gt; macro, but any list that begins with &lt;code&gt;macro&lt;/code&gt; is a macro as far as Emacs is concerned. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;, for an explanation of how to write a macro.</source>
          <target state="translated">&lt;code&gt;defmacro&lt;/code&gt; Lisp обычно определяются с помощью встроенного макроса defmacro , но любой список, который начинается с &lt;code&gt;macro&lt;/code&gt; является макросом для Emacs. См. &lt;a href=&quot;macros#Macros&quot;&gt;Макросы&lt;/a&gt; , чтобы узнать, как писать макрос.</target>
        </trans-unit>
        <trans-unit id="d9a34bc15715c9484c3c6d58e0cfbe37f7e5fc6d" translate="yes" xml:space="preserve">
          <source>Lisp objects can refer to themselves. Printing a self-referential object in the normal way would require an infinite amount of text, and the attempt could cause infinite recursion. Emacs detects such recursion and prints &amp;lsquo;</source>
          <target state="translated">Объекты Lisp могут ссылаться на себя. Обычная печать самореферентного объекта потребовала бы бесконечного количества текста, а попытка могла вызвать бесконечную рекурсию. Emacs обнаруживает такую ​​рекурсию и печатает '</target>
        </trans-unit>
        <trans-unit id="38cb61435a14d84b4e828f9b902cd652a45bb04e" translate="yes" xml:space="preserve">
          <source>Lisp packages that load files of customizations, or any other sort of user profile, should obey this variable in deciding where to find it. They should load the profile of the user name found in this variable. If &lt;code&gt;init-file-user&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, meaning that the &amp;lsquo;</source>
          <target state="translated">Пакеты Lisp, которые загружают файлы настроек или любой другой тип профиля пользователя, должны подчиняться этой переменной при принятии решения, где ее найти. Они должны загрузить профиль имени пользователя, найденный в этой переменной. Если &lt;code&gt;init-file-user&lt;/code&gt; равно &lt;code&gt;nil&lt;/code&gt; , это означает, что '</target>
        </trans-unit>
        <trans-unit id="d96f39c620264ffeb78deb4cecb038146b82aebf" translate="yes" xml:space="preserve">
          <source>Lisp primitives are Lisp functions implemented in C. The details of interfacing the C function so that Lisp can call it are handled by a few C macros. The only way to really understand how to write new C code is to read the source, but we can explain some things here.</source>
          <target state="translated">Примитивами Lisp являются функции Lisp,реализованные на C.Подробности взаимодействия функции C таким образом,чтобы Lisp мог ее вызывать,обрабатываются несколькими макросами на Си.Единственный способ по-настоящему понять,как писать новый код на Си-это прочитать исходные тексты,но кое-что можно объяснить здесь.</target>
        </trans-unit>
        <trans-unit id="a7c856d0fff164a7f1d6af49754ec372f5744350" translate="yes" xml:space="preserve">
          <source>Lisp programs can also directly display a bitmap in the left or right fringe, by using a &lt;code&gt;display&lt;/code&gt; property for one of the characters appearing in the line (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;). Such a display specification has the form</source>
          <target state="translated">Программы на Лиспе также могут напрямую отображать растровое изображение в левой или правой части, используя свойство &lt;code&gt;display&lt;/code&gt; для одного из символов, появляющихся в строке (см. &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Другие спецификации дисплея&lt;/a&gt; ). Такая спецификация дисплея имеет вид</target>
        </trans-unit>
        <trans-unit id="70a68430b5ee6f5c63e455e63af6968f951de310" translate="yes" xml:space="preserve">
          <source>Lisp programs can listen for connections by creating network servers. A network server is also represented by a kind of process object, but unlike a network connection, the network server never transfers data itself. When it receives a connection request, it creates a new network connection to represent the connection just made. (The network connection inherits certain information, including the process plist, from the server.) The network server then goes back to listening for more connection requests.</source>
          <target state="translated">Программы на языке Lisp могут прослушивать соединения,создавая сетевые серверы.Сетевой сервер также представлен своего рода объектом процесса,но в отличие от сетевого соединения,сетевой сервер никогда не передает данные сам по себе.Когда он получает запрос на соединение,он создает новое сетевое соединение,чтобы представить только что созданное соединение.(Сетевое соединение наследует от сервера определенную информацию,в том числе описание процесса).Затем сетевой сервер возвращается к прослушиванию большего количества запросов на соединение.</target>
        </trans-unit>
        <trans-unit id="eb25bc2c53938daa0a10ceee8670460ef857ca05" translate="yes" xml:space="preserve">
          <source>Lisp programs can set &lt;code&gt;transient-mark-mode&lt;/code&gt; to non-&lt;code&gt;nil&lt;/code&gt;, non-&lt;code&gt;t&lt;/code&gt; values to enable Transient Mark mode temporarily. If the value is &lt;code&gt;lambda&lt;/code&gt;, Transient Mark mode is automatically turned off after any action, such as buffer modification, that would normally deactivate the mark. If the value is &lt;code&gt;(only&amp;nbsp;.&amp;nbsp;&lt;var&gt;oldval&lt;/var&gt;)&lt;/code&gt;, then &lt;code&gt;transient-mark-mode&lt;/code&gt; is set to the value &lt;var&gt;oldval&lt;/var&gt; after any subsequent command that moves point and is not shift-translated (see &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;shift-translation&lt;/a&gt;), or after any other action that would normally deactivate the mark.</source>
          <target state="translated">Программы на Лиспе могут устанавливать &lt;code&gt;transient-mark-mode&lt;/code&gt; в значения, отличные от &lt;code&gt;nil&lt;/code&gt; , non- &lt;code&gt;t&lt;/code&gt; , чтобы временно включить режим Transient Mark. Если значение - &lt;code&gt;lambda&lt;/code&gt; , режим Transient Mark автоматически отключается после любого действия, такого как изменение буфера, которое обычно деактивирует метку. Если значение равно &lt;code&gt;(only&amp;nbsp;.&amp;nbsp;&lt;var&gt;oldval&lt;/var&gt;)&lt;/code&gt; , тогда &lt;code&gt;transient-mark-mode&lt;/code&gt; устанавливается в значение &lt;var&gt;oldval&lt;/var&gt; после любой последующей команды, которая перемещает точку и не переводится &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;сдвигом&lt;/a&gt; (см. Shift-translation ), или после любого другого действия, которое обычно отключить отметку.</target>
        </trans-unit>
        <trans-unit id="3aa64bd9d4a4db969c3909de23bb8e7a8d6e781d" translate="yes" xml:space="preserve">
          <source>Lisp programs can switch frames temporarily by calling the function &lt;code&gt;select-frame&lt;/code&gt;. This does not alter the window system&amp;rsquo;s concept of focus; rather, it escapes from the window manager&amp;rsquo;s control until that control is somehow reasserted.</source>
          <target state="translated">Программы на Лиспе могут временно переключать фреймы, вызывая функцию &lt;code&gt;select-frame&lt;/code&gt; . Это не меняет концепции фокуса оконной системы; скорее, он ускользает из-под управления оконного менеджера до тех пор, пока это управление каким-либо образом не будет подтверждено.</target>
        </trans-unit>
        <trans-unit id="e6266b236aa3407b98b48107324e801de224e6ad" translate="yes" xml:space="preserve">
          <source>Lisp programs must be prepared that user customizations may cause buffers to get displayed in an unexpected way. They should never assume in their subsequent behavior, that the buffer has been shown precisely the way they asked for in the &lt;var&gt;action&lt;/var&gt; argument of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">Программы на Лиспе должны быть готовы к тому, что пользовательские настройки могут привести к неожиданному отображению буферов. Они никогда не должны предполагать их последующее поведение, что буфер был показан именно так , как они просили в &lt;var&gt;action&lt;/var&gt; аргумента &lt;code&gt;display-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6612695190dbf10d24bd3737b61d06d8dee5099f" translate="yes" xml:space="preserve">
          <source>Lisp programs should &lt;em&gt;not&lt;/em&gt; rely on hash codes being preserved between Emacs sessions, as the implementation of the hash functions uses some details of the object storage that can change between sessions and between different architectures.</source>
          <target state="translated">Программы на Лиспе &lt;em&gt;не&lt;/em&gt; должны полагаться на хэш-коды, сохраняемые между сеансами Emacs, поскольку реализация хеш-функций использует некоторые детали хранилища объектов, которые могут изменяться между сеансами и между различными архитектурами.</target>
        </trans-unit>
        <trans-unit id="430b9fa1fd5ba568a813aa706678d439215cf675" translate="yes" xml:space="preserve">
          <source>Lisp programs sometimes need to run a shell and give it a command that contains file names that were specified by the user. These programs ought to be able to support any valid file name. But the shell gives special treatment to certain characters, and if these characters occur in the file name, they will confuse the shell. To handle these characters, use the function &lt;code&gt;shell-quote-argument&lt;/code&gt;:</source>
          <target state="translated">Программам на Лиспе иногда требуется запустить оболочку и дать ей команду, содержащую имена файлов, указанные пользователем. Эти программы должны поддерживать любое допустимое имя файла. Но оболочка уделяет особое внимание определенным символам, и если эти символы встречаются в имени файла, они запутают оболочку. Для обработки этих символов используйте &lt;code&gt;shell-quote-argument&lt;/code&gt; функции :</target>
        </trans-unit>
        <trans-unit id="cfca57d0cb6702725bd47fe954b2d8aad7ece85e" translate="yes" xml:space="preserve">
          <source>Lisp representation for character display fonts.</source>
          <target state="translated">Представление листа для шрифтов отображения символов.</target>
        </trans-unit>
        <trans-unit id="b7904939c664c0654e4069d00a64b5fe14da5051" translate="yes" xml:space="preserve">
          <source>List contains a loop</source>
          <target state="translated">Список содержит петлю</target>
        </trans-unit>
        <trans-unit id="3e55737f21b8d4e744eb6aa465bb3fe3e505747a" translate="yes" xml:space="preserve">
          <source>List of frame parameters for window systems.</source>
          <target state="translated">Список параметров рам для оконных систем.</target>
        </trans-unit>
        <trans-unit id="c1aa03bb883bbb60cce2d139f90d3fdb47174dc3" translate="yes" xml:space="preserve">
          <source>List of frames that this physical monitor dominates (see below).</source>
          <target state="translated">Список кадров,доминирующих над этим физическим монитором (см.ниже).</target>
        </trans-unit>
        <trans-unit id="5255158e8775a2ebbae84ae901ff359ddfa1d8dd" translate="yes" xml:space="preserve">
          <source>List of set bits in &lt;var&gt;len&lt;/var&gt; bytes. The bytes are taken in big endian order and the bits are numbered starting with &lt;code&gt;8 *
&lt;var&gt;len&lt;/var&gt; - 1&lt;/code&gt; and ending with zero. For example: &lt;code&gt;bits
2&lt;/code&gt; unpacks &lt;code&gt;#x28&lt;/code&gt;&lt;code&gt;#x1c&lt;/code&gt; to &lt;code&gt;(2 3 4 11 13)&lt;/code&gt; and &lt;code&gt;#x1c&lt;/code&gt;&lt;code&gt;#x28&lt;/code&gt; to &lt;code&gt;(3 5 10 11 12)&lt;/code&gt;.</source>
          <target state="translated">Список установленных битов в &lt;var&gt;len&lt;/var&gt; байтах. Байты берутся в порядке прямого байта, а биты нумеруются, начиная с &lt;code&gt;8 * &lt;var&gt;len&lt;/var&gt; - 1&lt;/code&gt; и заканчивая нулем. Например: &lt;code&gt;bits 2&lt;/code&gt; распаковывает &lt;code&gt;#x28&lt;/code&gt; &lt;code&gt;#x1c&lt;/code&gt; в &lt;code&gt;(2 3 4 11 13)&lt;/code&gt; и &lt;code&gt;#x1c&lt;/code&gt; &lt;code&gt;#x28&lt;/code&gt; в &lt;code&gt;(3 5 10 11 12)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9849ac255593e53a8f74892aeb3c6148e2227ef" translate="yes" xml:space="preserve">
          <source>List of some standard error symbols.</source>
          <target state="translated">Список некоторых стандартных символов ошибок.</target>
        </trans-unit>
        <trans-unit id="dd46ad2b3ec4905179728f23e75392d7cd255398" translate="yes" xml:space="preserve">
          <source>List of some standard hook variables.</source>
          <target state="translated">Список некоторых стандартных переменных с крючком.</target>
        </trans-unit>
        <trans-unit id="684686c9485926fd7bb605cb2b4b6557c3c1c8f3" translate="yes" xml:space="preserve">
          <source>List of some standard keymaps.</source>
          <target state="translated">Список некоторых стандартных ключевых карт.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="20dd55e92ceb2d7f29cba2ee3c74cacc30b7d09c" translate="yes" xml:space="preserve">
          <source>Lists and Cons Cells</source>
          <target state="translated">Списки и потребительские клетки</target>
        </trans-unit>
        <trans-unit id="95e6ae4511e2076e5ec8acc94916a3a73b48a317" translate="yes" xml:space="preserve">
          <source>Lists are the most commonly-used sequences. A list can hold elements of any type, and its length can be easily changed by adding or removing elements. See the next subsection for more about lists.</source>
          <target state="translated">Списки являются наиболее часто используемыми последовательностями.Список может содержать элементы любого типа,а его длина может быть легко изменена путем добавления или удаления элементов.Подробнее о списках см.в следующем подразделе.</target>
        </trans-unit>
        <trans-unit id="0deb648df977bd4b3bf1acb18dcca54edca072ea" translate="yes" xml:space="preserve">
          <source>Lists in Lisp are not a primitive data type; they are built up from &lt;em&gt;cons cells&lt;/em&gt; (see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;). A cons cell is a data object that represents an ordered pair. That is, it has two slots, and each slot &lt;em&gt;holds&lt;/em&gt;, or &lt;em&gt;refers to&lt;/em&gt;, some Lisp object. One slot is known as the &lt;small&gt;CAR&lt;/small&gt;, and the other is known as the &lt;small&gt;CDR&lt;/small&gt;. (These names are traditional; see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;.) &lt;small&gt;CDR&lt;/small&gt; is pronounced &amp;ldquo;could-er&amp;rdquo;.</source>
          <target state="translated">Списки в Лиспе не являются примитивным типом данных; они построены из &lt;em&gt;cons-ячеек&lt;/em&gt; (см. &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt; ). Консольная ячейка - это объект данных, представляющий упорядоченную пару. То есть он имеет два слота, и каждый слот &lt;em&gt;содержит&lt;/em&gt; или &lt;em&gt;ссылается на&lt;/em&gt; какой-либо объект Lisp. Один слот известен как &lt;small&gt;CAR&lt;/small&gt; , а другой - как &lt;small&gt;CDR&lt;/small&gt; . (Эти имена являются традиционными; см. &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt; .) &lt;small&gt;CDR&lt;/small&gt; произносится как &amp;laquo;could-er&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9099e49f5a4614e80a7fbc32b3b32e0c649d2edd" translate="yes" xml:space="preserve">
          <source>Lists, cons cells, and related functions.</source>
          <target state="translated">Списки,минусовые клетки и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="9e7aaaa88e5ccb737ed89b621f362caa5d1c2f65" translate="yes" xml:space="preserve">
          <source>Lists, strings and the other array types also share important similarities. For example, all have a length &lt;var&gt;l&lt;/var&gt;, and all have elements which can be indexed from zero to &lt;var&gt;l&lt;/var&gt; minus one. Several functions, called sequence functions, accept any kind of sequence. For example, the function &lt;code&gt;length&lt;/code&gt; reports the length of any kind of sequence. See &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;.</source>
          <target state="translated">Списки, строки и другие типы массивов также имеют важное сходство. Например, все они имеют длину &lt;var&gt;l&lt;/var&gt; , и у всех есть элементы, которые можно индексировать от нуля до &lt;var&gt;l&lt;/var&gt; минус один. Некоторые функции, называемые функциями последовательности, принимают любой вид последовательности. Например, функция &lt;code&gt;length&lt;/code&gt; сообщает длину любого вида последовательности. См. &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Разделы &amp;laquo;Векторы массивов последовательностей&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9ce88cec200da5730917cabea833810578d4d60" translate="yes" xml:space="preserve">
          <source>Lists, strings and vectors are called sequences. Certain functions act on any kind of sequence. The description of vectors is here as well.</source>
          <target state="translated">Списки,строки и векторы называются последовательностями.Определенные функции действуют на любой вид последовательности.Описание векторов также находится здесь.</target>
        </trans-unit>
        <trans-unit id="44705636b815ace7e561a7446a758c35f2dedad2" translate="yes" xml:space="preserve">
          <source>Literal text</source>
          <target state="translated">Буквальный текст</target>
        </trans-unit>
        <trans-unit id="7561f82ae5b90f8428d596aba3af87144f94e678" translate="yes" xml:space="preserve">
          <source>Literal unprintable characters in strings.</source>
          <target state="translated">Буквальные непечатаемые символы в строках.</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="bc6cc4663c2f684119734fdc2abb9c21336632c5" translate="yes" xml:space="preserve">
          <source>Living With a Weak Parser</source>
          <target state="translated">Жить со слабым парсером</target>
        </trans-unit>
        <trans-unit id="7a611ffe36f69e8659eea0f180752be7e04730b8" translate="yes" xml:space="preserve">
          <source>Load Suffixes</source>
          <target state="translated">Загрузочные суффиксы</target>
        </trans-unit>
        <trans-unit id="f9ad7c8d6bf23f4bd156133162b128490e0c6198" translate="yes" xml:space="preserve">
          <source>Load file &lt;var&gt;file&lt;/var&gt; (a string) before displaying this customization item (see &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;). Loading is done with &lt;code&gt;load&lt;/code&gt;, and only if the file is not already loaded.</source>
          <target state="translated">Загрузите файл &lt;var&gt;file&lt;/var&gt; (строку) перед отображением этого элемента настройки (см. &lt;a href=&quot;loading#Loading&quot;&gt;Загрузка&lt;/a&gt; ). Загрузка выполняется с помощью &lt;code&gt;load&lt;/code&gt; , и только если файл еще не загружен.</target>
        </trans-unit>
        <trans-unit id="1bd4cd17a8147cc5cd6d3f97fd6644f944793104" translate="yes" xml:space="preserve">
          <source>Load the files with</source>
          <target state="translated">Загрузите файлы с помощью</target>
        </trans-unit>
        <trans-unit id="883657b0663d05cb81a7f624698cafeec52f6b73" translate="yes" xml:space="preserve">
          <source>Loadable modules in Emacs are enabled by using the</source>
          <target state="translated">Загрузка модулей в Emacs включается с помощью параметра</target>
        </trans-unit>
        <trans-unit id="8f26c6520d61588a9757bc182157c4497628e871" translate="yes" xml:space="preserve">
          <source>Loading</source>
          <target state="translated">Loading</target>
        </trans-unit>
        <trans-unit id="0f84e4833a47ae5b5d6c641ba5839ef1259c6482" translate="yes" xml:space="preserve">
          <source>Loading Non-ASCII Characters</source>
          <target state="translated">Загрузка не-ASCII символов</target>
        </trans-unit>
        <trans-unit id="a881ef8a5e395de040b2cde053e1fa0f6d614659" translate="yes" xml:space="preserve">
          <source>Loading a file of Lisp code means bringing its contents into the Lisp environment in the form of Lisp objects. Emacs finds and opens the file, reads the text, evaluates each form, and then closes the file. Such a file is also called a &lt;em&gt;Lisp library&lt;/em&gt;.</source>
          <target state="translated">Загрузка файла с кодом Lisp означает перенос его содержимого в среду Lisp в виде объектов Lisp. Emacs находит и открывает файл, читает текст, оценивает каждую форму и затем закрывает файл. Такой файл также называется &lt;em&gt;библиотекой Lisp&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="904a9f782b30e1a58668b2173bc0b744a768d9fa" translate="yes" xml:space="preserve">
          <source>Loading a library if it isn&amp;rsquo;t already loaded.</source>
          <target state="translated">Загрузка библиотеки, если она еще не загружена.</target>
        </trans-unit>
        <trans-unit id="963c158ee7d6cc3ddeaacac290e282697c29cc98" translate="yes" xml:space="preserve">
          <source>Loading foo...</source>
          <target state="translated">Погрузка фу...</target>
        </trans-unit>
        <trans-unit id="90227054d0c4071b95dc470817610b24dd4cae6b" translate="yes" xml:space="preserve">
          <source>Loading foo...done</source>
          <target state="translated">Загрузка фу...сделана</target>
        </trans-unit>
        <trans-unit id="ff5148d6cff2251fbb44fa24ac71e87831f6949a" translate="yes" xml:space="preserve">
          <source>Local Variables</source>
          <target state="translated">Локальные переменные</target>
        </trans-unit>
        <trans-unit id="1c80e104177d7b78185bb1b8711d3cbd2a0da9a4" translate="yes" xml:space="preserve">
          <source>Local Variables in Macro Expansions</source>
          <target state="translated">Локальные переменные в макрорасширениях</target>
        </trans-unit>
        <trans-unit id="81e25eae5238b0d1e80b489db0e70db5d36fa19f" translate="yes" xml:space="preserve">
          <source>Local variable bindings in the expansion require special care.</source>
          <target state="translated">Локальные переменные крепления в расширении требуют особого ухода.</target>
        </trans-unit>
        <trans-unit id="779b54ae3ad4227df0c4817bd5cf967d7971b9a8" translate="yes" xml:space="preserve">
          <source>Local variables common for remote connections.</source>
          <target state="translated">Локальные переменные,общие для удаленных подключений.</target>
        </trans-unit>
        <trans-unit id="7f188a87ee03e71d60616a4c96885d1c0b74f9c8" translate="yes" xml:space="preserve">
          <source>Local variables common to all files in a directory.</source>
          <target state="translated">Локальные переменные,общие для всех файлов в каталоге.</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="c40c47188d80c7c01d1f14ab9115e42654014c62" translate="yes" xml:space="preserve">
          <source>Locating Files in Standard Places</source>
          <target state="translated">Расположение файлов в стандартных местах</target>
        </trans-unit>
        <trans-unit id="ca96bd07c69909b5097860baf11cb9da67a0b932" translate="yes" xml:space="preserve">
          <source>Locking and unlocking files, to prevent simultaneous editing by two people.</source>
          <target state="translated">Блокировка и разблокировка файлов,чтобы предотвратить одновременное редактирование двумя людьми.</target>
        </trans-unit>
        <trans-unit id="19b48b850743ec74aaf2ba7f74397470f9322fb8" translate="yes" xml:space="preserve">
          <source>Logging Messages in *Messages*</source>
          <target state="translated">Сообщения для ведения журнала в *сообщениях*</target>
        </trans-unit>
        <trans-unit id="f992fcdf326b78d500b906f947284b63f7afb915" translate="yes" xml:space="preserve">
          <source>Logical and, or, not, shifting.</source>
          <target state="translated">Логично и,или нет,сдвинуто.</target>
        </trans-unit>
        <trans-unit id="5d5f34745d0c565923c156fa463ee88aafc88956" translate="yes" xml:space="preserve">
          <source>Long description</source>
          <target state="translated">Длинное описание</target>
        </trans-unit>
        <trans-unit id="1601ce5c57967aca4f1582458112c97ae2082434" translate="yes" xml:space="preserve">
          <source>Looking Up Fonts</source>
          <target state="translated">Искать шрифты</target>
        </trans-unit>
        <trans-unit id="d63629c4a0bb6a63de031bf229ac03c609809d09" translate="yes" xml:space="preserve">
          <source>Looking Up and Expanding Abbreviations</source>
          <target state="translated">Искать и расширять Сокращения</target>
        </trans-unit>
        <trans-unit id="bc0e6625c124c4eb5bd0fcd56ac755373c3fb4f2" translate="yes" xml:space="preserve">
          <source>Looking at the properties of one character.</source>
          <target state="translated">Глядя на свойства одного персонажа.</target>
        </trans-unit>
        <trans-unit id="178121740f45b5d6e7facf9d96018d909c21354f" translate="yes" xml:space="preserve">
          <source>Looking through all keymaps, for printing help.</source>
          <target state="translated">Просмотр всех ключевых карт,помощь в печати.</target>
        </trans-unit>
        <trans-unit id="851bbb5519ca80dce271e99e2231072e5a4a3479" translate="yes" xml:space="preserve">
          <source>Looking up the names of available fonts and information about them.</source>
          <target state="translated">Просмотр названий доступных шрифтов и информации о них.</target>
        </trans-unit>
        <trans-unit id="68ff0bd1cbaecfae7d37b0d97386effbf3fba27d" translate="yes" xml:space="preserve">
          <source>Lookup in a hash table is extremely fast for large tables&amp;mdash;in fact, the time required is essentially &lt;em&gt;independent&lt;/em&gt; of how many elements are stored in the table. For smaller tables (a few tens of elements) alists may still be faster because hash tables have a more-or-less constant overhead.</source>
          <target state="translated">Поиск в хэш-таблице для больших таблиц выполняется очень быстро - фактически, необходимое время практически не &lt;em&gt;зависит&lt;/em&gt; от того, сколько элементов хранится в таблице. Для небольших таблиц (несколько десятков элементов) списки могут быть быстрее, потому что хеш-таблицы имеют более или менее постоянные накладные расходы.</target>
        </trans-unit>
        <trans-unit id="f5253ec82559052e87ceaff557957647ac4e6a68" translate="yes" xml:space="preserve">
          <source>Low-Level Font Representation</source>
          <target state="translated">Представление шрифта низкого уровня</target>
        </trans-unit>
        <trans-unit id="323f212d3828fcc314985cd1386476951f05a2ee" translate="yes" xml:space="preserve">
          <source>Low-Level Kill Ring</source>
          <target state="translated">Низкоуровневое убийственное кольцо</target>
        </trans-unit>
        <trans-unit id="cd3b0d6e2fa4c08068b3e57e488ba7e247c660c5" translate="yes" xml:space="preserve">
          <source>Low-Level Network Access</source>
          <target state="translated">Низкоуровневый доступ к сети</target>
        </trans-unit>
        <trans-unit id="cbddb05b874ab89fa507c4d8957fdf31bf1114b7" translate="yes" xml:space="preserve">
          <source>Low-Level Parsing</source>
          <target state="translated">Низкоуровневый парсинг</target>
        </trans-unit>
        <trans-unit id="4259b3253a806353d7c8d6ae41622a4465d4b63c" translate="yes" xml:space="preserve">
          <source>Low-level functions for completing strings.</source>
          <target state="translated">Низкоуровневые функции для заполнения строк.</target>
        </trans-unit>
        <trans-unit id="e3fc395679fd313e5a3b121bd0f61b1e24d51f49" translate="yes" xml:space="preserve">
          <source>Lower-level but more general function to create connections and servers.</source>
          <target state="translated">Нижнеуровневая,но более общая функция для создания соединений и серверов.</target>
        </trans-unit>
        <trans-unit id="412965d373e39e0acf2e9d34874530d49b3e8f45" translate="yes" xml:space="preserve">
          <source>Lower-level subroutines that they use.</source>
          <target state="translated">Подпрограммы нижнего уровня,которые они используют.</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1380c1040fe5f22f86cfa0fff612c7bb977dc760" translate="yes" xml:space="preserve">
          <source>M-</source>
          <target state="translated">M-</target>
        </trans-unit>
        <trans-unit id="37a5c39dff07a52dd3087c214ce1f8d1b29f0a8c" translate="yes" xml:space="preserve">
          <source>M-&amp;lt;</source>
          <target state="translated">M-&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f56099d279d3bbbe13433ab2b41f59ecda17c1b5" translate="yes" xml:space="preserve">
          <source>M--</source>
          <target state="translated">M--</target>
        </trans-unit>
        <trans-unit id="3c8556ad1d538e0b24776b2eb4aadd97384f92be" translate="yes" xml:space="preserve">
          <source>M-.</source>
          <target state="translated">M-.</target>
        </trans-unit>
        <trans-unit id="195ce7fc591804e0719a61c0fa3a7301aae4a144" translate="yes" xml:space="preserve">
          <source>M-:</source>
          <target state="translated">M-:</target>
        </trans-unit>
        <trans-unit id="d63f0fe93faad24b66a76a47ccdc11cdad6f0669" translate="yes" xml:space="preserve">
          <source>M-: &lt;var&gt;exp&lt;/var&gt;RET</source>
          <target state="translated">M-: &lt;var&gt;exp&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="306f4c5a0e32d8e206ce9f2acecfdbbd30b93ebd" translate="yes" xml:space="preserve">
          <source>M-A</source>
          <target state="translated">M-A</target>
        </trans-unit>
        <trans-unit id="6951aed8ad5e7255f081050661207da69a62bceb" translate="yes" xml:space="preserve">
          <source>M-F1</source>
          <target state="translated">M-F1</target>
        </trans-unit>
        <trans-unit id="d5deac9a11e75cdf2221fc4ccab2ecbdf3ce7f5e" translate="yes" xml:space="preserve">
          <source>M-O</source>
          <target state="translated">M-O</target>
        </trans-unit>
        <trans-unit id="582c231510f999e4090021d4c4d24dd9d1083ddc" translate="yes" xml:space="preserve">
          <source>M-TAB</source>
          <target state="translated">M-TAB</target>
        </trans-unit>
        <trans-unit id="6e83342732a657a8dfe6c872ef3fa40bd7ab6c1d" translate="yes" xml:space="preserve">
          <source>M-[</source>
          <target state="translated">M-[</target>
        </trans-unit>
        <trans-unit id="c32ec53effd66388f8d3ebba5bbdc052dda00483" translate="yes" xml:space="preserve">
          <source>M-a</source>
          <target state="translated">M-a</target>
        </trans-unit>
        <trans-unit id="dfec75d824ab931885b10c2deb8b602ddf385540" translate="yes" xml:space="preserve">
          <source>M-b</source>
          <target state="translated">M-b</target>
        </trans-unit>
        <trans-unit id="92eda3bf541ac9f8576ded598bec375af4abc3bd" translate="yes" xml:space="preserve">
          <source>M-end</source>
          <target state="translated">M-end</target>
        </trans-unit>
        <trans-unit id="980a6233a9b06694b777bb282affe943e0afc2da" translate="yes" xml:space="preserve">
          <source>M-g</source>
          <target state="translated">M-g</target>
        </trans-unit>
        <trans-unit id="52706036e0d1667ecb93c7d036d3d039cba1682a" translate="yes" xml:space="preserve">
          <source>M-n</source>
          <target state="translated">M-n</target>
        </trans-unit>
        <trans-unit id="c7cf6ebaeff525a4a38321125032420c3882f5a3" translate="yes" xml:space="preserve">
          <source>M-o</source>
          <target state="translated">M-o</target>
        </trans-unit>
        <trans-unit id="15f62577eedb593ecdad3ec32390144de3a4748e" translate="yes" xml:space="preserve">
          <source>M-o M-o</source>
          <target state="translated">М-о М-о</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
