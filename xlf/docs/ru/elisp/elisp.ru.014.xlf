<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="cd969dae78e04fd8c37f6b3cfb39c7d32c4a3daa" translate="yes" xml:space="preserve">
          <source>Syntax Tables</source>
          <target state="translated">Таблицы синтаксиса</target>
        </trans-unit>
        <trans-unit id="7a8491486c1dd1e36fecef6fb025b6d953ee6bce" translate="yes" xml:space="preserve">
          <source>Syntax character</source>
          <target state="translated">Синтаксический персонаж</target>
        </trans-unit>
        <trans-unit id="3a75a3c003ea56dc72367919450cb68e784c15a4" translate="yes" xml:space="preserve">
          <source>Syntax flags are encoded in higher order bits, starting 16 bits from the least significant bit. This table gives the power of two which corresponds to each syntax flag.</source>
          <target state="translated">Синтаксические флаги кодируются в битах более высокого порядка,начиная с 16 бит от наименее значащего бита.В этой таблице приведена сила двойки,которая соответствует каждому флагу синтаксиса.</target>
        </trans-unit>
        <trans-unit id="69c9b8582ee05373bdfc0abb499365f98dd04862" translate="yes" xml:space="preserve">
          <source>Syntax for Strings</source>
          <target state="translated">Синтаксис для струн</target>
        </trans-unit>
        <trans-unit id="8cb3a281e588cc742b01e3740c59ad1d56db3c93" translate="yes" xml:space="preserve">
          <source>Syntax for control characters.</source>
          <target state="translated">Синтаксис для управляющих символов.</target>
        </trans-unit>
        <trans-unit id="183c7ba87286e0fe725dee087dc513f1f2559a37" translate="yes" xml:space="preserve">
          <source>Syntax for hyper-, super-, and alt-characters.</source>
          <target state="translated">Синтаксис для гипер-,супер-и альт-символов.</target>
        </trans-unit>
        <trans-unit id="81b87087386ebffcaa2df63aa5ab7fab58d228b0" translate="yes" xml:space="preserve">
          <source>Syntax for meta-characters.</source>
          <target state="translated">Синтаксис для мета-символов.</target>
        </trans-unit>
        <trans-unit id="f7eaf1748919ec8b360cee2686b8fa7780d6554c" translate="yes" xml:space="preserve">
          <source>Syntax for regular characters.</source>
          <target state="translated">Синтаксис для обычных персонажей.</target>
        </trans-unit>
        <trans-unit id="e284594ea5fa7caa24811e20fa73e2b5dff45cd4" translate="yes" xml:space="preserve">
          <source>Syntax name</source>
          <target state="translated">Имя синтаксиса</target>
        </trans-unit>
        <trans-unit id="8d26d1dba3b7aae7767b0e849b6989ede03494bf" translate="yes" xml:space="preserve">
          <source>Syntax of Regular Expressions</source>
          <target state="translated">Синтаксис регулярных выражений</target>
        </trans-unit>
        <trans-unit id="d8464bf58345d9a6b7e29aa70e89a5dbda979411" translate="yes" xml:space="preserve">
          <source>Syntax tables (see &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;).</source>
          <target state="translated">Таблицы синтаксиса (см. &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Таблицы синтаксиса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="131aa9c3aaea2e49816523d4aa4b0c24a9b447db" translate="yes" xml:space="preserve">
          <source>Syntax tables are implemented as char-tables (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;), but most Lisp programs don&amp;rsquo;t work directly with their elements. Syntax tables do not store syntax data as syntax descriptors (see &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;Syntax Descriptors&lt;/a&gt;); they use an internal format, which is documented in this section. This internal format can also be assigned as syntax properties (see &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Syntax Properties&lt;/a&gt;).</source>
          <target state="translated">Таблицы синтаксиса реализованы как таблицы символов (см. &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Таблицы&lt;/a&gt; символов ), но большинство программ на Лиспе не работают напрямую со своими элементами. Таблицы синтаксиса не хранят данные синтаксиса как дескрипторы синтаксиса (см. &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;Дескрипторы синтаксиса&lt;/a&gt; ); они используют внутренний формат, который задокументирован в этом разделе. Этот внутренний формат также может быть назначен как свойства синтаксиса (см. &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Свойства синтаксиса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d59285289ccc6dfb4ed5e5485160fccc3f7588b" translate="yes" xml:space="preserve">
          <source>Syntax tables are not used by the Emacs Lisp reader, which has its own built-in syntactic rules which cannot be changed. (Some Lisp systems provide ways to redefine the read syntax, but we decided to leave this feature out of Emacs Lisp for simplicity.)</source>
          <target state="translated">Синтаксические таблицы не используются читателем Emacs Lisp,который имеет собственные встроенные синтаксические правила,которые не могут быть изменены.(Некоторые системы на Лисп предлагают способы переопределения синтаксиса прочитанного,но мы решили оставить эту возможность в Emacs Lisp для простоты).</target>
        </trans-unit>
        <trans-unit id="3335c043a5759be5adb0f7a04ab0ccf5c5aa2d46" translate="yes" xml:space="preserve">
          <source>System Interface</source>
          <target state="translated">системный интерфейс</target>
        </trans-unit>
        <trans-unit id="b5076ad981f290c37270bb2a148ea3bb144fbfe8" translate="yes" xml:space="preserve">
          <source>Systems that don&amp;rsquo;t use the X window system, such as MS-Windows, don&amp;rsquo;t support the notion of X displays, and have only one display on each host. The display name on these systems doesn&amp;rsquo;t follow the above 3-part format; for example, the display name on MS-Windows systems is a constant string &amp;lsquo;</source>
          <target state="translated">Системы, в которых не используется X-оконная система, например MS-Windows, не поддерживают понятие X-дисплеев и имеют только один дисплей на каждом хосте. Отображаемое имя в этих системах не соответствует указанному выше формату из трех частей; например, отображаемое имя в системах MS-Windows представляет собой постоянную строку '</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="38d4aa698a701e2288a153e115d12aab45de5940" translate="yes" xml:space="preserve">
          <source>TAB</source>
          <target state="translated">TAB</target>
        </trans-unit>
        <trans-unit id="a775b64f2cd6a88a198986d46d44e0a021785125" translate="yes" xml:space="preserve">
          <source>TIFF</source>
          <target state="translated">TIFF</target>
        </trans-unit>
        <trans-unit id="d91e1888f2dc09f11a876e25966a6fbd32b9cd87" translate="yes" xml:space="preserve">
          <source>TLS</source>
          <target state="translated">TLS</target>
        </trans-unit>
        <trans-unit id="20c82d216d6c9ffeb3659bcf801fce1cd3ffc885" translate="yes" xml:space="preserve">
          <source>TOOL-BAR</source>
          <target state="translated">TOOL-BAR</target>
        </trans-unit>
        <trans-unit id="ba122ed060e172cdd2f88709faf4e9bdd7194f9a" translate="yes" xml:space="preserve">
          <source>Table of Syntax Classes</source>
          <target state="translated">Таблица синтаксических классов</target>
        </trans-unit>
        <trans-unit id="2d8d1919ef262467c56883c41a879af2fee55b4e" translate="yes" xml:space="preserve">
          <source>Table of syntax classes.</source>
          <target state="translated">Таблица синтаксических классов.</target>
        </trans-unit>
        <trans-unit id="a8a2a45aa44b8d88ed7a93657b0370ab7c1b47d3" translate="yes" xml:space="preserve">
          <source>Tabulated List mode</source>
          <target state="translated">Режим табличного списка</target>
        </trans-unit>
        <trans-unit id="52c8bfd56e2fda412e0ed96bacdbda1556965513" translate="yes" xml:space="preserve">
          <source>Tabulated List mode is a major mode for displaying tabulated data, i.e., data consisting of &lt;em&gt;entries&lt;/em&gt;, each entry occupying one row of text with its contents divided into columns. Tabulated List mode provides facilities for pretty-printing rows and columns, and sorting the rows according to the values in each column. It is derived from Special mode (see &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;).</source>
          <target state="translated">Режим табличного списка является основным режимом отображения табличных данных, т. Е. Данных, состоящих из &lt;em&gt;записей&lt;/em&gt; , каждая запись занимает одну строку текста, а ее содержимое разделено на столбцы. Режим табличного списка предоставляет возможности для удобной печати строк и столбцов и сортировки строк в соответствии со значениями в каждом столбце. Это происходит из специального режима (см. &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Основные основные режимы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="498560170e6db33d7983c6d161bdd46436b34341" translate="yes" xml:space="preserve">
          <source>Tabulated List mode is intended to be used as a parent mode by a more specialized major mode. Examples include Process Menu mode (see &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;) and Package Menu mode (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html#Package-Menu&quot;&gt;Package Menu&lt;/a&gt; in</source>
          <target state="translated">Режим табличного списка предназначен для использования в качестве родительского режима более специализированным основным режимом. Примеры включают режим меню процесса (см. &lt;a href=&quot;process-information#Process-Information&quot;&gt;Информацию о процессе&lt;/a&gt; ) и режим меню пакета (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html#Package-Menu&quot;&gt;Меню пакета&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="c8f684048b11741d27f33f2d7764ece4796a5527" translate="yes" xml:space="preserve">
          <source>Take care to ensure that the specifications are known to Edebug when you instrument code. If you are instrumenting a function which uses a macro defined in another file, you may first need to either evaluate the &lt;code&gt;require&lt;/code&gt; forms in the file containing your function, or explicitly load the file containing the macro. If the definition of a macro is wrapped by &lt;code&gt;eval-when-compile&lt;/code&gt;, you may need to evaluate it.</source>
          <target state="translated">Позаботьтесь о том, чтобы спецификации были известны Edebug при инструментальном коде. Если вы инструментирование функции , которая использует макрос , определенный в другом файл, то сначала необходимо либо оценить &lt;code&gt;require&lt;/code&gt; форм в файле , содержащие ваши функции, или явно загрузить файл , содержащий макрос. Если определение макроса заключено в оболочку &lt;code&gt;eval-when-compile&lt;/code&gt; , вам может потребоваться его оценка.</target>
        </trans-unit>
        <trans-unit id="0f97cd8471dd801f12b6230920fd1f2d023c055a" translate="yes" xml:space="preserve">
          <source>Technically, a right divider belongs to the window on its left, which means that its width contributes to the total width of that window. A bottom divider belongs to the window above it, which means that its width contributes to the total height of that window. See &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;. When a window has both, a right and a bottom divider, the bottom divider prevails. This means that a bottom divider is drawn over the full total width of its window while the right divider ends above the bottom divider.</source>
          <target state="translated">Технически правый разделитель принадлежит окну слева, а это означает, что его ширина составляет общую ширину этого окна. Нижний разделитель принадлежит окну над ним, а это означает, что его ширина составляет общую высоту этого окна. См. &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Размеры окон&lt;/a&gt; . Когда в окне есть и правый, и нижний разделители, преобладает нижний разделитель. Это означает, что нижний разделитель рисуется по всей ширине своего окна, а правый разделитель заканчивается над нижним разделителем.</target>
        </trans-unit>
        <trans-unit id="703bed112f2bdff3a214f69e179b0387e0f27ed9" translate="yes" xml:space="preserve">
          <source>Technically, this function may be thought of as an atomic action performed in two steps: The first step removes &lt;var&gt;frame1&lt;/var&gt;&amp;rsquo;s window-system window from the display. The second step reinserts &lt;var&gt;frame1&lt;/var&gt;&amp;rsquo;s window into the display below (above if &lt;var&gt;above&lt;/var&gt; is true) that of &lt;var&gt;frame2&lt;/var&gt;. Hence the position of &lt;var&gt;frame2&lt;/var&gt; in its display&amp;rsquo;s Z (stacking) order relative to all other frames excluding &lt;var&gt;frame1&lt;/var&gt; remains unaltered.</source>
          <target state="translated">Технически эту функцию можно рассматривать как элементарное действие, выполняемое в два этапа: Первый шаг удаляет окно оконной системы &lt;var&gt;frame1&lt;/var&gt; с дисплея. На втором шаге окно &lt;var&gt;frame1&lt;/var&gt; повторно вставляется в отображение ниже (вверху, если &lt;var&gt;above&lt;/var&gt; если истинно), что на дисплее &lt;var&gt;frame2&lt;/var&gt; . Поэтому позиция &lt;var&gt;frame2&lt;/var&gt; в ее дисплее Z (штабелирования) порядка относительно всех других кадров , за исключением &lt;var&gt;frame1&lt;/var&gt; остается неизменной.</target>
        </trans-unit>
        <trans-unit id="5834d97093438086bf86a5d34542961bd2778fb2" translate="yes" xml:space="preserve">
          <source>Tell &lt;var&gt;process&lt;/var&gt; that its logical window size has dimensions &lt;var&gt;width&lt;/var&gt; by &lt;var&gt;height&lt;/var&gt;, in character units. If this function succeeds in communicating this information to the process, it returns &lt;code&gt;t&lt;/code&gt;; otherwise it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Сообщите &lt;var&gt;process&lt;/var&gt; что размер его логического окна имеет размеры &lt;var&gt;width&lt;/var&gt; по &lt;var&gt;height&lt;/var&gt; в символьных единицах. Если этой функции удается передать эту информацию процессу, она возвращает &lt;code&gt;t&lt;/code&gt; ; в противном случае возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c12bc156c5db862b3ba4e07551778ad339e33f61" translate="yes" xml:space="preserve">
          <source>Tell the byte compiler to assume that &lt;var&gt;function&lt;/var&gt; is defined in the file &lt;var&gt;file&lt;/var&gt;. The optional third argument &lt;var&gt;arglist&lt;/var&gt; is either &lt;code&gt;t&lt;/code&gt;, meaning the argument list is unspecified, or a list of formal parameters in the same style as &lt;code&gt;defun&lt;/code&gt;. An omitted &lt;var&gt;arglist&lt;/var&gt; defaults to &lt;code&gt;t&lt;/code&gt;, not &lt;code&gt;nil&lt;/code&gt;; this is atypical behavior for omitted arguments, and it means that to supply a fourth but not third argument one must specify &lt;code&gt;t&lt;/code&gt; for the third-argument placeholder instead of the usual &lt;code&gt;nil&lt;/code&gt;. The optional fourth argument &lt;var&gt;fileonly&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means check only that &lt;var&gt;file&lt;/var&gt; exists, not that it actually defines &lt;var&gt;function&lt;/var&gt;.</source>
          <target state="translated">Скажите байтовому компилятору, чтобы он предполагал, что &lt;var&gt;function&lt;/var&gt; определена в файловом &lt;var&gt;file&lt;/var&gt; . Необязательный третий аргумент &lt;var&gt;arglist&lt;/var&gt; - это либо &lt;code&gt;t&lt;/code&gt; , что означает, что список аргументов не указан , либо список формальных параметров в том же стиле, что и &lt;code&gt;defun&lt;/code&gt; . Пропущенной &lt;var&gt;arglist&lt;/var&gt; по умолчанию &lt;code&gt;t&lt;/code&gt; , не &lt;code&gt;nil&lt;/code&gt; ; это нетипичное поведение для пропущенных аргументов, и это означает, что для предоставления четвертого, но не третьего аргумента необходимо указать &lt;code&gt;t&lt;/code&gt; для заполнителя третьего аргумента вместо обычного &lt;code&gt;nil&lt;/code&gt; . Необязательный четвертый аргумент &lt;var&gt;fileonly&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; означает проверку только того, что &lt;var&gt;file&lt;/var&gt; существует, а не то, что он фактически определяет &lt;var&gt;function&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="5df56b1b343eb8daedec867960cd9bb06bd6b999" translate="yes" xml:space="preserve">
          <source>Telling the Compiler that a Function is Defined</source>
          <target state="translated">Сообщение компилятору о том,что функция определена.</target>
        </trans-unit>
        <trans-unit id="de1d117584d30c59a72af26003e0d0a855151dc5" translate="yes" xml:space="preserve">
          <source>Telling the compiler that a function is defined.</source>
          <target state="translated">Сообщение компилятору,что функция определена.</target>
        </trans-unit>
        <trans-unit id="3c79631699bb3023f4d474dc6291a1b94cff5905" translate="yes" xml:space="preserve">
          <source>Temporarily dedicating windows to their buffers (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;) avoids using a window for displaying a different buffer. A non-dedicated window will be used instead.</source>
          <target state="translated">Временное выделение окон для их буферов (см. &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Выделенные окна&lt;/a&gt; ) позволяет избежать использования окна для отображения другого буфера. Вместо этого будет использоваться неспециализированное окно.</target>
        </trans-unit>
        <trans-unit id="112d19493096b154fc9ad3a3ab3ba206e50684df" translate="yes" xml:space="preserve">
          <source>Temporarily display the outside current buffer with point at its outside position (&lt;code&gt;edebug-bounce-point&lt;/code&gt;), pausing for one second before returning to Edebug. With a prefix argument &lt;var&gt;n&lt;/var&gt;, pause for &lt;var&gt;n&lt;/var&gt; seconds instead.</source>
          <target state="translated">Временно отобразить внешний текущий буфер с точкой в ​​его внешней позиции ( &lt;code&gt;edebug-bounce-point&lt;/code&gt; ), сделав паузу на одну секунду перед возвратом в Edebug. С аргументом префикса &lt;var&gt;n&lt;/var&gt; сделайте паузу на &lt;var&gt;n&lt;/var&gt; секунд.</target>
        </trans-unit>
        <trans-unit id="204bf73fadce843ac40f4d284ffae49d63cf6cdb" translate="yes" xml:space="preserve">
          <source>Temporary Displays</source>
          <target state="translated">Временные дисплеи</target>
        </trans-unit>
        <trans-unit id="885e345267ec6790ab06207f2febf07060307ad4" translate="yes" xml:space="preserve">
          <source>Temporary conses and strings on C stack.</source>
          <target state="translated">Временные конфеты и струны на стеке С.</target>
        </trans-unit>
        <trans-unit id="638a660125130110a8ff9f3b688f9ab733656cf5" translate="yes" xml:space="preserve">
          <source>Temporary displays are used by Lisp programs to put output into a buffer and then present it to the user for perusal rather than for editing. Many help commands use this feature.</source>
          <target state="translated">Временные отображения используются программами на языке Lisp,чтобы поместить вывод в буфер и затем представить его пользователю для прочтения,а не для редактирования.Многие команды справки используют эту возможность.</target>
        </trans-unit>
        <trans-unit id="a8fbdc5c349b4448bfd30149ad8c0322c6319430" translate="yes" xml:space="preserve">
          <source>Temporary motion and buffer changes.</source>
          <target state="translated">Временное движение и изменение буфера.</target>
        </trans-unit>
        <trans-unit id="8c4b4dd44090443b75c719146f69039a4de8291e" translate="yes" xml:space="preserve">
          <source>Terminal I/O Encoding</source>
          <target state="translated">Кодирование терминальных входов/выходов</target>
        </trans-unit>
        <trans-unit id="e518d15cadbf25f6701100c9e664ae69e7991eac" translate="yes" xml:space="preserve">
          <source>Terminal Input</source>
          <target state="translated">Клеммный вход</target>
        </trans-unit>
        <trans-unit id="11bcad1f9e713086d9e16b8089d00a33ed64d247" translate="yes" xml:space="preserve">
          <source>Terminal Output</source>
          <target state="translated">Терминальный выход</target>
        </trans-unit>
        <trans-unit id="59f006175b8fe7e3164de6d9ad0fd6f00418fe75" translate="yes" xml:space="preserve">
          <source>Terminal Parameters</source>
          <target state="translated">Параметры терминала</target>
        </trans-unit>
        <trans-unit id="b779b73affbf24fad613fe28b563d45c5ff37645" translate="yes" xml:space="preserve">
          <source>Terminal Type</source>
          <target state="translated">Тип терминала</target>
        </trans-unit>
        <trans-unit id="3b6ffae10c84baf737fa6441cfeed7605132aebb" translate="yes" xml:space="preserve">
          <source>Terminal-Specific Initialization</source>
          <target state="translated">Терминал-специфическая инициализация</target>
        </trans-unit>
        <trans-unit id="7896da4078fb49476e0b8958441644e36b86ac99" translate="yes" xml:space="preserve">
          <source>Terminals have no read syntax. They print in hash notation giving the terminal&amp;rsquo;s ordinal number and its TTY device file name.</source>
          <target state="translated">Терминалы не имеют синтаксиса чтения. Они печатаются в хеш-нотации с указанием порядкового номера терминала и имени файла устройства TTY.</target>
        </trans-unit>
        <trans-unit id="88ffd1abfd18a3b86bf88447a1b5a3e97e14d62d" translate="yes" xml:space="preserve">
          <source>Terminate the program being debugged; return to top-level Emacs command execution.</source>
          <target state="translated">Прекратить отлаживаемую программу;вернуться к выполнению команды верхнего уровня Emacs.</target>
        </trans-unit>
        <trans-unit id="a89b0dbcd302d4f9ba9ec7aca5a0f8a1ccc06a1a" translate="yes" xml:space="preserve">
          <source>Test Coverage</source>
          <target state="translated">Покрытие испытаний</target>
        </trans-unit>
        <trans-unit id="03751596a5fb1a6a9c8670a0a29a5b074902945a" translate="yes" xml:space="preserve">
          <source>Testing Accessibility</source>
          <target state="translated">Доступность тестирования</target>
        </trans-unit>
        <trans-unit id="da8948ee42cc0425d8ae2fab4e1fb0099dc30642" translate="yes" xml:space="preserve">
          <source>Testing Availability of Network Features</source>
          <target state="translated">Тестирование Доступность сетевых функций</target>
        </trans-unit>
        <trans-unit id="d8d4dbd1a23f08fe554bc1a36408ea01da82c375" translate="yes" xml:space="preserve">
          <source>Testing existence, accessibility, size of files.</source>
          <target state="translated">Тестирование существования,доступности,размера файлов.</target>
        </trans-unit>
        <trans-unit id="5eef48dce3886f67bf29572279a1d8c01513dd7e" translate="yes" xml:space="preserve">
          <source>Testing for numbers.</source>
          <target state="translated">Тестирование на цифры.</target>
        </trans-unit>
        <trans-unit id="69e02e42d50ebc840818a24261a4c38b29c09cd4" translate="yes" xml:space="preserve">
          <source>Testing whether an object is a marker.</source>
          <target state="translated">Тестирование того,является ли объект маркером.</target>
        </trans-unit>
        <trans-unit id="1af17a7f62df0b849a55bd3092c5d244b3f00a14" translate="yes" xml:space="preserve">
          <source>Testing whether an object is a string or char.</source>
          <target state="translated">Тестирование того,является ли объект строкой или символом.</target>
        </trans-unit>
        <trans-unit id="a2ed0523781be8c76de933cdc16fb68427dc7f9f" translate="yes" xml:space="preserve">
          <source>Tests of equality between any two objects.</source>
          <target state="translated">Испытания на равенство между любыми двумя объектами.</target>
        </trans-unit>
        <trans-unit id="6e3d8ffc0e534d8e43ad86a7d530e868b23593b6" translate="yes" xml:space="preserve">
          <source>Tests related to types.</source>
          <target state="translated">Тесты,связанные с типами.</target>
        </trans-unit>
        <trans-unit id="f45b4f0fb4f2822335c780c335891ff82850deb9" translate="yes" xml:space="preserve">
          <source>Texinfo</source>
          <target state="translated">Texinfo</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="87a0562fa90309b524364e483951efe8af5cf185" translate="yes" xml:space="preserve">
          <source>Text Area</source>
          <target state="translated">Текстовая область</target>
        </trans-unit>
        <trans-unit id="cab6f246e70a36aae141ac1b47f69051720f2342" translate="yes" xml:space="preserve">
          <source>Text Properties</source>
          <target state="translated">Текстовые свойства</target>
        </trans-unit>
        <trans-unit id="b2b6482ac0db1130facf9df3d33260d44db222c6" translate="yes" xml:space="preserve">
          <source>Text Properties in Strings</source>
          <target state="translated">Текстовые свойства в строках</target>
        </trans-unit>
        <trans-unit id="0203d97471cea7f0f9e87edf9c61812f9ed352fe" translate="yes" xml:space="preserve">
          <source>Text Property Search Functions</source>
          <target state="translated">Текстовые функции поиска свойств</target>
        </trans-unit>
        <trans-unit id="e2a1fdf371ef3e66e34eae2fac3b0b1a33d7c25e" translate="yes" xml:space="preserve">
          <source>Text Quoting Style</source>
          <target state="translated">Стиль цитирования текста</target>
        </trans-unit>
        <trans-unit id="8ad1a0374eb3bf2b5f56dc4ed7649f748c78347b" translate="yes" xml:space="preserve">
          <source>Text Representations</source>
          <target state="translated">Текстовые изображения</target>
        </trans-unit>
        <trans-unit id="382c95e23dc844e5ef1273fcbaec3dfb1687c262" translate="yes" xml:space="preserve">
          <source>Text Terminal Colors</source>
          <target state="translated">Цвета текстовых терминалов</target>
        </trans-unit>
        <trans-unit id="015b197bbe54de5242507dc93ed1884dafc41845" translate="yes" xml:space="preserve">
          <source>Text covered by &lt;code&gt;display&lt;/code&gt; text properties, by overlays with &lt;code&gt;display&lt;/code&gt; properties whose value is a string, and by any other properties that replace buffer text, is treated as a single unit when it is reordered for display. That is, the entire chunk of text covered by these properties is reordered together. Moreover, the bidirectional properties of the characters in such a chunk of text are ignored, and Emacs reorders them as if they were replaced with a single character &lt;code&gt;U+FFFC&lt;/code&gt;, known as the &lt;em&gt;Object Replacement Character&lt;/em&gt;. This means that placing a display property over a portion of text may change the way that the surrounding text is reordered for display. To prevent this unexpected effect, always place such properties on text whose directionality is identical with text that surrounds it.</source>
          <target state="translated">Текст, покрытый свойствами &lt;code&gt;display&lt;/code&gt; текста, наложениями с &lt;code&gt;display&lt;/code&gt; свойствами, значение которых является строкой, и любыми другими свойствами, заменяющими текст буфера, обрабатывается как единый блок, когда он переупорядочивается для отображения. То есть весь фрагмент текста, охватываемый этими свойствами, переупорядочивается вместе. Более того, двунаправленные свойства символов в таком фрагменте текста игнорируются, и Emacs переупорядочивает их, как если бы они были заменены одним символом &lt;code&gt;U+FFFC&lt;/code&gt; , известным как &lt;em&gt;символ замены объекта.&lt;/em&gt;. Это означает, что размещение свойства отображения над частью текста может изменить способ переупорядочивания окружающего текста для отображения. Чтобы предотвратить этот неожиданный эффект, всегда помещайте такие свойства в текст, направленность которого идентична тексту, который его окружает.</target>
        </trans-unit>
        <trans-unit id="1ad9759337a6a9038a2e7770ed58fa8870c7e97c" translate="yes" xml:space="preserve">
          <source>Text is read-only</source>
          <target state="translated">Текст доступен только для чтения</target>
        </trans-unit>
        <trans-unit id="9a6eb4a9bf5716c42c83626704dad83699495ba5" translate="yes" xml:space="preserve">
          <source>Text is stored in Emacs buffers and strings in &lt;em&gt;logical&lt;/em&gt; (or &lt;em&gt;reading&lt;/em&gt;) order, i.e., the order in which a human would read each character. In right-to-left and bidirectional text, the order in which characters are displayed on the screen (called &lt;em&gt;visual order&lt;/em&gt;) is not the same as logical order; the characters&amp;rsquo; screen positions do not increase monotonically with string or buffer position. In performing this &lt;em&gt;bidirectional reordering&lt;/em&gt;, Emacs follows the Unicode Bidirectional Algorithm (a.k.a.</source>
          <target state="translated">Текст хранится в буферах и строках Emacs в &lt;em&gt;логическом&lt;/em&gt; (или &lt;em&gt;читаемом&lt;/em&gt; ) порядке, т. Е. В том порядке, в котором человек прочитал бы каждый символ. В тексте с письмом справа налево и в двунаправленном тексте порядок, в котором символы отображаются на экране (называемый &lt;em&gt;визуальным порядком&lt;/em&gt; ), не совпадает с логическим порядком; положение символов на экране не увеличивается монотонно с положением строки или буфера. Выполняя это &lt;em&gt;двунаправленное переупорядочение&lt;/em&gt; , Emacs следует &lt;em&gt;двунаправленному&lt;/em&gt; алгоритму Unicode (также известному как</target>
        </trans-unit>
        <trans-unit id="cc87b41df7acde763452d7cdb5ae6ca0354ef8ae" translate="yes" xml:space="preserve">
          <source>Text lines are portions of the buffer delimited by newline characters, which are regarded as part of the previous line. The first text line begins at the beginning of the buffer, and the last text line ends at the end of the buffer whether or not the last character is a newline. The division of the buffer into text lines is not affected by the width of the window, by line continuation in display, or by how tabs and control characters are displayed.</source>
          <target state="translated">Текстовые строки-это части буфера,разделенные символами новой строки,которые рассматриваются как часть предыдущей строки.Первая строка текста начинается в начале буфера,а последняя строка текста заканчивается в конце буфера,независимо от того,является ли последний символ новой строкой или нет.На разделение буфера на текстовые строки не влияет ни ширина окна,ни продолжение строки при отображении,ни способ отображения табуляций и управляющих символов.</target>
        </trans-unit>
        <trans-unit id="c6f3ab88d6206b25d3f1bd4b23a42dfc4e2125ac" translate="yes" xml:space="preserve">
          <source>Text mode and Lisp modes.</source>
          <target state="translated">Текстовый и Лисповый режимы.</target>
        </trans-unit>
        <trans-unit id="d4dee9134d8f17e940ea640096421469faf682b3" translate="yes" xml:space="preserve">
          <source>Text mode is a major mode for editing human languages. It defines the &amp;lsquo;</source>
          <target state="translated">Текстовый режим - это основной режим редактирования человеческих языков. Он определяет '</target>
        </trans-unit>
        <trans-unit id="dfd75aa64722dfbe6f81a4a1dd09e0e0bd805010" translate="yes" xml:space="preserve">
          <source>Text mode is perhaps the simplest mode besides Fundamental mode. Here are excerpts from</source>
          <target state="translated">Текстовый режим является,пожалуй,самым простым режимом кроме Фундаментального.Вот выдержки из</target>
        </trans-unit>
        <trans-unit id="e542f92e46dea1aaed3020c3fc9ad84772b03042" translate="yes" xml:space="preserve">
          <source>Text properties also support the &lt;code&gt;modification-hooks&lt;/code&gt; property, but the details are somewhat different (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;).</source>
          <target state="translated">Текстовые свойства также поддерживают свойство &lt;code&gt;modification-hooks&lt;/code&gt; , но детали несколько отличаются (см. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d0a9b467cc2388cf3c12708c4d04ff0102f37d9" translate="yes" xml:space="preserve">
          <source>Text properties are also potential loopholes, since their values could include functions to call. So Emacs discards all text properties from string values specified for file-local variables.</source>
          <target state="translated">Текстовые свойства также являются потенциальными лазейками,так как их значения могут включать функции для вызова.Поэтому Emacs отбрасывает все текстовые свойства из строковых значений,указанных для файловых локальных переменных.</target>
        </trans-unit>
        <trans-unit id="9d6234ac8ad7e0e9762eab32a2e86e6b1e823934" translate="yes" xml:space="preserve">
          <source>Text properties are considered a part of the text; overlays and their properties are specifically considered not to be part of the text. Thus, copying text between various buffers and strings preserves text properties, but does not try to preserve overlays. Changing a buffer&amp;rsquo;s text properties marks the buffer as modified, while moving an overlay or changing its properties does not. Unlike text property changes, overlay property changes are not recorded in the buffer&amp;rsquo;s undo list.</source>
          <target state="translated">Свойства текста считаются частью текста; оверлеи и их свойства не считаются частью текста. Таким образом, копирование текста между различными буферами и строками сохраняет свойства текста, но не пытается сохранить наложения. Изменение свойств текста буфера отмечает его как измененный, в то время как перемещение наложения или изменение его свойств - нет. В отличие от изменений свойств текста, изменения свойств наложения не записываются в список отмены буфера.</target>
        </trans-unit>
        <trans-unit id="6f74c7cc06988da062ed2b24126fb9eddd682788" translate="yes" xml:space="preserve">
          <source>Text terminals usually support only a small number of colors, and the computer uses small integers to select colors on the terminal. This means that the computer cannot reliably tell what the selected color looks like; instead, you have to inform your application which small integers correspond to which colors. However, Emacs does know the standard set of colors and will try to use them automatically.</source>
          <target state="translated">Текстовые терминалы обычно поддерживают лишь небольшое количество цветов,и компьютер использует небольшие целые числа для выбора цветов на терминале.Это означает,что компьютер не может достоверно сказать,как выглядит выбранный цвет;вместо этого вы должны сообщить вашему приложению,каким маленьким целым числам какой цвет соответствует.Однако Emacs знает стандартный набор цветов и попытается использовать их автоматически.</target>
        </trans-unit>
        <trans-unit id="ff12dc73eb86a83b96f6fd94cd3a8c784b8cfb98" translate="yes" xml:space="preserve">
          <source>Textual Scrolling</source>
          <target state="translated">Прокрутка текста</target>
        </trans-unit>
        <trans-unit id="8a741234fa57cb0334cb69e5c77a86c370043e5c" translate="yes" xml:space="preserve">
          <source>Textual scrolling functions (aside from &lt;code&gt;scroll-other-window&lt;/code&gt;) have unpredictable results if the current buffer is not the one displayed in the selected window. See &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;.</source>
          <target state="translated">Функции текстовой прокрутки (кроме &lt;code&gt;scroll-other-window&lt;/code&gt; ) дают непредсказуемые результаты, если текущий буфер не тот, который отображается в выбранном окне. См. &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Текущий буфер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b0e7fb130776cf6ea8a938fc9ede74c81c65d4" translate="yes" xml:space="preserve">
          <source>That is, the &amp;ldquo;bold&amp;rdquo; words are the &lt;code&gt;bold&lt;/code&gt; face, and the &amp;ldquo;italic&amp;rdquo; word is in the &lt;code&gt;italic&lt;/code&gt; face.</source>
          <target state="translated">То есть &amp;laquo;жирные&amp;raquo; слова &lt;code&gt;bold&lt;/code&gt; , а слово &amp;laquo;курсивное&amp;raquo; выделено &lt;code&gt;italic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7430a06da8c38762d75fab964293afaabef9af91" translate="yes" xml:space="preserve">
          <source>That last form can be used as &lt;var&gt;action&lt;/var&gt; argument of &lt;code&gt;display-buffer&lt;/code&gt; in the following way:</source>
          <target state="translated">Эта последняя форма может быть использована в качестве &lt;var&gt;action&lt;/var&gt; аргумента &lt;code&gt;display-buffer&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="4c876d6e3a4a2df4b2e97076c563bcbda17e6f74" translate="yes" xml:space="preserve">
          <source>That lets the user specify a height value optionally and a width value optionally.</source>
          <target state="translated">Это позволяет пользователю указывать значение высоты (опционально)и ширины (опционально).</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="5ff30588f2ea9f6154e9ab9ac554867c70e9717f" translate="yes" xml:space="preserve">
          <source>The 2**22 bit in the character event code indicates a character typed with the alt key held down. (The key labeled</source>
          <target state="translated">Бит 2**22 в коде события символа указывает на символ,набранный нажатой клавишей alt.(Клавиша помечена</target>
        </trans-unit>
        <trans-unit id="38975ff8c63f29a11434d9ffa76a663862efe213" translate="yes" xml:space="preserve">
          <source>The 2**23 bit in the character event code indicates a character typed with the super key held down.</source>
          <target state="translated">Бит 2**23 в коде события символов указывает на символ,набранный при удерживании суперключа.</target>
        </trans-unit>
        <trans-unit id="a46377d522c8c3976b822282db080ff137867c82" translate="yes" xml:space="preserve">
          <source>The 2**24 bit in the character event code indicates a character typed with the hyper key held down.</source>
          <target state="translated">Бит 2**24 в коде события символа указывает на символ,набранный при нажатой гиперключевой клавише.</target>
        </trans-unit>
        <trans-unit id="cb443747876c5a79973dac02d3a7cd79f8cba32c" translate="yes" xml:space="preserve">
          <source>The 2**25 bit (the 26th bit) in the character event code indicates an</source>
          <target state="translated">2**25 бит (26-й бит)в коде события символов указывает на то,что</target>
        </trans-unit>
        <trans-unit id="d84cc0fb922803f23690da8e9b0d5a8328dc7acb" translate="yes" xml:space="preserve">
          <source>The 2**26 bit in the character code indicates a non-</source>
          <target state="translated">2**26 бит в символьном коде указывает на не</target>
        </trans-unit>
        <trans-unit id="a0f9cc26fb8eabe38b036b9be91a04cbf27fc5a6" translate="yes" xml:space="preserve">
          <source>The 2**27 bit in the character code indicates a character typed with the meta key held down.</source>
          <target state="translated">Бит 2**27 в коде символа обозначает символ,набранный при нажатой мета-клавише.</target>
        </trans-unit>
        <trans-unit id="24ee70c53e17015b7f27a3b207abd795d4f0cc63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(&quot;(&quot; exps &quot;)&quot;)&lt;/code&gt; rule was not needed to pair up parens, since SMIE will pair up any characters that are marked as having paren syntax in the syntax table. What this rule does instead (together with the definition of &lt;code&gt;exps&lt;/code&gt;) is to make it clear that &lt;code&gt;&quot;,&quot;&lt;/code&gt; should not appear outside of parentheses.</source>
          <target state="translated">&lt;code&gt;(&quot;(&quot; exps &quot;)&quot;)&lt;/code&gt; правило не нужно паре скобки, так как SMIE будет парой любых символов, которые помечены как имеющий PAREN синтаксиса в таблице синтаксиса. Вместо этого это правило (вместе с определением &lt;code&gt;exps&lt;/code&gt; ) разъясняет, что &lt;code&gt;&quot;,&quot;&lt;/code&gt; не должно появляться вне скобок.</target>
        </trans-unit>
        <trans-unit id="7d3eb0602e766d794ddd5a23c3f8b6d078da78b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; function serves two purposes: negation and subtraction. When &lt;code&gt;-&lt;/code&gt; has a single argument, the value is the negative of the argument. When there are multiple arguments, &lt;code&gt;-&lt;/code&gt; subtracts each of the &lt;var&gt;more-numbers-or-markers&lt;/var&gt; from &lt;var&gt;number-or-marker&lt;/var&gt;, cumulatively. If there are no arguments, the result is 0.</source>
          <target state="translated">Функция &lt;code&gt;-&lt;/code&gt; служит двум целям: отрицание и вычитание. Когда &lt;code&gt;-&lt;/code&gt; имеет единственный аргумент, значение - отрицательное значение аргумента. При наличии нескольких аргументов &lt;code&gt;-&lt;/code&gt; вычитает каждое из &lt;var&gt;more-numbers-or-markers&lt;/var&gt; из &lt;var&gt;number-or-marker&lt;/var&gt; кумулятивно. Если аргументов нет, результатом будет 0.</target>
        </trans-unit>
        <trans-unit id="dee3a47909b932498958ccca8e33a6ead189f5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:advertised-binding&lt;/code&gt; property also affects the binding shown in menu items (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;). The property is ignored if it specifies a key binding that the command does not actually have.</source>
          <target state="translated">Свойство &lt;code&gt;:advertised-binding&lt;/code&gt; также влияет на привязку, отображаемую в пунктах меню (см. &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Строку меню&lt;/a&gt; ). Свойство игнорируется, если оно указывает привязку клавиш, которой фактически нет у команды.</target>
        </trans-unit>
        <trans-unit id="1882ca53c4043e647ef4b5684792d2bf1128e1a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:deferred&lt;/code&gt; keyword argument to &lt;code&gt;jsonrpc-request&lt;/code&gt; and &lt;code&gt;jsonrpc-async-request&lt;/code&gt; is designed to let the caller indicate that the specific request needs synchronization and its actual issuance may be delayed to the future, until some condition is satisfied. Specifying &lt;code&gt;:deferred&lt;/code&gt; for a request doesn&amp;rsquo;t mean it &lt;em&gt;will&lt;/em&gt; be delayed, only that it &lt;em&gt;can&lt;/em&gt; be. If the request isn&amp;rsquo;t sent immediately, &lt;code&gt;jsonrpc&lt;/code&gt; will make renewed efforts to send it at certain key times during communication, such as when receiving or sending other messages to the endpoint.</source>
          <target state="translated">&lt;code&gt;:deferred&lt;/code&gt; ключевое слово аргумент &lt;code&gt;jsonrpc-request&lt;/code&gt; и &lt;code&gt;jsonrpc-async-request&lt;/code&gt; предназначен , чтобы абонент указывает , что запрос конкретных потребностей синхронизации и его фактический выпуск может быть отложено на будущее, пока некоторое условие не удовлетворяется. Указание &lt;code&gt;:deferred&lt;/code&gt; для запроса не означает, что он &lt;em&gt;будет&lt;/em&gt; отложен, только то, что это &lt;em&gt;может&lt;/em&gt; быть. Если запрос не отправлен немедленно, &lt;code&gt;jsonrpc&lt;/code&gt; приложит новые усилия для его отправки в определенные ключевые моменты времени во время связи, например, при получении или отправке других сообщений на конечную точку.</target>
        </trans-unit>
        <trans-unit id="9d39209831baabc8b831f50e0409fe8adb0807e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:help&lt;/code&gt; property specifies a help-echo string to display while the mouse is on that item. This is displayed in the same way as &lt;code&gt;help-echo&lt;/code&gt; text properties (see &lt;a href=&quot;special-properties#Help-display&quot;&gt;Help display&lt;/a&gt;).</source>
          <target state="translated">Свойство &lt;code&gt;:help&lt;/code&gt; указывает строку справки-эха, отображаемую, когда указатель мыши находится на этом элементе. Это отображается так же, как свойства текста &lt;code&gt;help-echo&lt;/code&gt; (см. &lt;a href=&quot;special-properties#Help-display&quot;&gt;Отображение справки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d3dade1abb3b9c8790fadfc96040530f91f00991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:inline&lt;/code&gt; feature lets you splice a variable number of elements into the middle of a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; customization type. You use it by adding &lt;code&gt;:inline t&lt;/code&gt; to a type specification which is contained in a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; specification.</source>
          <target state="translated">Функция &lt;code&gt;:inline&lt;/code&gt; позволяет вставлять переменное количество элементов в середину &lt;code&gt;list&lt;/code&gt; или типа настройки &lt;code&gt;vector&lt;/code&gt; . Вы используете его, добавляя &lt;code&gt;:inline t&lt;/code&gt; к спецификации типа, которая содержится в спецификации &lt;code&gt;list&lt;/code&gt; или &lt;code&gt;vector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfc189fd6a2dcae80441078e4b002d4e31ccd61f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:max-width&lt;/code&gt; and &lt;code&gt;:max-height&lt;/code&gt; keywords are used for scaling if the size of the image exceeds these values. If &lt;code&gt;:width&lt;/code&gt; is set, it will have precedence over &lt;code&gt;max-width&lt;/code&gt;, and if &lt;code&gt;:height&lt;/code&gt; is set, it will have precedence over &lt;code&gt;max-height&lt;/code&gt;, but you can otherwise mix these keywords as you wish.</source>
          <target state="translated">&lt;code&gt;:max-width&lt;/code&gt; и &lt;code&gt;:max-height&lt;/code&gt; ключевые слова используются для масштабирования , если размер изображения превышает эти значения. Если &lt;code&gt;:width&lt;/code&gt; установлено, он будет иметь приоритет над &lt;code&gt;max-width&lt;/code&gt; , а если &lt;code&gt;:height&lt;/code&gt; установлен, он будет иметь приоритет над &lt;code&gt;max-height&lt;/code&gt; , но в противном случае вы можете смешивать эти ключевые слова по своему усмотрению.</target>
        </trans-unit>
        <trans-unit id="f9b06cb01b0dc998d981d7869a904792bbe31f03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:rtl&lt;/code&gt; property specifies an alternative image to use for right-to-left languages. Only the GTK+ version of Emacs supports this at present.</source>
          <target state="translated">Свойство &lt;code&gt;:rtl&lt;/code&gt; указывает альтернативное изображение для языков с письмом справа налево. В настоящее время это поддерживается только версией Emacs GTK +.</target>
        </trans-unit>
        <trans-unit id="c169ab5cd21a44a39207c218cf98e3315f8f1bc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:align-to&lt;/code&gt; properties are supported on non-graphic terminals, but the other space properties in this section are not.</source>
          <target state="translated">&lt;code&gt;:width&lt;/code&gt; и &lt;code&gt;:align-to&lt;/code&gt; свойствам поддерживается на не-графических терминалах, но и другие космические объекты в этом разделе не являются.</target>
        </trans-unit>
        <trans-unit id="1b3a5aeae5cf6e988d703b1a5e7837aeb615f5a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:height&lt;/code&gt; keywords are used for scaling the image. If only one of them is specified, the other one will be calculated so as to preserve the aspect ratio. If both are specified, aspect ratio may not be preserved.</source>
          <target state="translated">&lt;code&gt;:width&lt;/code&gt; и &lt;code&gt;:height&lt;/code&gt; ключевые слова используются для масштабирования изображения. Если указан только один из них, другой будет рассчитан с сохранением соотношения сторон. Если указаны оба параметра, соотношение сторон может не сохраниться.</target>
        </trans-unit>
        <trans-unit id="98439a61b5465911aa8bc125062739f9432a86eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add-face-text-property&lt;/code&gt; function provides a convenient way to set this text property. See &lt;a href=&quot;changing-properties#Changing-Properties&quot;&gt;Changing Properties&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;add-face-text-property&lt;/code&gt; предоставляет удобный способ установить это свойство текста. См. &lt;a href=&quot;changing-properties#Changing-Properties&quot;&gt;Изменение свойств&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd4e2e754506706afd7c9e246beb160bb480f467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alpha&lt;/code&gt; frame parameter can also be a cons cell &lt;code&gt;(&lt;var&gt;active&lt;/var&gt; . &lt;var&gt;inactive&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;active&lt;/var&gt; is the opacity of the frame when it is selected, and &lt;var&gt;inactive&lt;/var&gt; is the opacity when it is not selected.</source>
          <target state="translated">Параметр &lt;code&gt;alpha&lt;/code&gt; кадра также может быть cons-ячейкой &lt;code&gt;(&lt;var&gt;active&lt;/var&gt; . &lt;var&gt;inactive&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;active&lt;/var&gt; - это непрозрачность кадра, когда он выбран, а &lt;var&gt;inactive&lt;/var&gt; - это непрозрачность, когда он не выбран.</target>
        </trans-unit>
        <trans-unit id="3cb3daaa7062a39e07e8493532e6ecf57d731436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;and&lt;/code&gt; special form tests whether all the &lt;var&gt;conditions&lt;/var&gt; are true. It works by evaluating the &lt;var&gt;conditions&lt;/var&gt; one by one in the order written.</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; специальные тесты , образуют ли все &lt;var&gt;conditions&lt;/var&gt; истинны. Он работает, оценивая &lt;var&gt;conditions&lt;/var&gt; одно за другим в записанном порядке.</target>
        </trans-unit>
        <trans-unit id="19ff15c393043a9219761a4b88424de8e7fcd4d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;append&lt;/code&gt; function also provides a way to convert a vector into a list with the same elements:</source>
          <target state="translated">Функция &lt;code&gt;append&lt;/code&gt; также позволяет преобразовать вектор в список с такими же элементами:</target>
        </trans-unit>
        <trans-unit id="ec4feeecd8f21172cf3ce375cb9b4b75af9ca6c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buffer-name&lt;/code&gt; of a buffer is &lt;code&gt;nil&lt;/code&gt; if, and only if, the buffer is killed. A buffer that has not been killed is called a &lt;em&gt;live&lt;/em&gt; buffer. To test whether a buffer is live or killed, use the function &lt;code&gt;buffer-live-p&lt;/code&gt; (see below).</source>
          <target state="translated">Имя- &lt;code&gt;buffer-name&lt;/code&gt; буфера равно &lt;code&gt;nil&lt;/code&gt; если и только если буфер уничтожен. Буфер, который не был уничтожен, называется &lt;em&gt;активным&lt;/em&gt; буфером. Чтобы проверить, активен ли буфер или убит, используйте функцию &lt;code&gt;buffer-live-p&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="1bf11efbba3f5b738c403068ce4165ac4eda8d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cl-case&lt;/code&gt; macro chooses among alternatives by evaluating the equality of its first argument against a set of specific values.</source>
          <target state="translated">&lt;code&gt;cl-case&lt;/code&gt; макро выбирает среди альтернатив по оценке равенства первого аргумента против набора конкретных значений.</target>
        </trans-unit>
        <trans-unit id="26f0cd6f24bb7ebd0d3d8ca59b36aac1c1707035" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;completing-read&lt;/code&gt; function binds variables to pass information to the commands that actually do completion. They are described in the following section.</source>
          <target state="translated">Функция &lt;code&gt;completing-read&lt;/code&gt; связывает переменные для передачи информации командам, которые фактически выполняют завершение. Они описаны в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="c44c9a88addda9d5f8cbe1e09d1ef3e5332b9502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond&lt;/code&gt; form chooses among alternatives by evaluating the predicate &lt;var&gt;condition&lt;/var&gt; of each of its clauses (see &lt;a href=&quot;conditionals#Conditionals&quot;&gt;Conditionals&lt;/a&gt;). The primary limitation is that variables let-bound in &lt;var&gt;condition&lt;/var&gt; are not available to the clause&amp;rsquo;s &lt;var&gt;body-forms&lt;/var&gt;.</source>
          <target state="translated">Форма &lt;code&gt;cond&lt;/code&gt; выбирает среди альтернатив, оценивая &lt;var&gt;condition&lt;/var&gt; предиката каждого из своих предложений (см. &lt;a href=&quot;conditionals#Conditionals&quot;&gt;Условные&lt;/a&gt; выражения ). Основное ограничение заключается в том, что переменные let-bound in &lt;var&gt;condition&lt;/var&gt; недоступны для &lt;var&gt;body-forms&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b6393d60a04e97f2116a36bf3d96d9009bda8c39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition-case&lt;/code&gt; construct is often used to trap errors that are predictable, such as failure to open a file in a call to &lt;code&gt;insert-file-contents&lt;/code&gt;. It is also used to trap errors that are totally unpredictable, such as when the program evaluates an expression read from the user.</source>
          <target state="translated">Конструкция &lt;code&gt;condition-case&lt;/code&gt; часто используется для перехвата предсказуемых ошибок, таких как отказ открыть файл при вызове &lt;code&gt;insert-file-contents&lt;/code&gt; . Он также используется для перехвата совершенно непредсказуемых ошибок, например, когда программа оценивает выражение, прочитанное пользователем.</target>
        </trans-unit>
        <trans-unit id="4e29405e0f1f6c37ab826a1f70ab932f0440abc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;current-input-mode&lt;/code&gt; function returns the input mode settings Emacs is currently using.</source>
          <target state="translated">Функция &lt;code&gt;current-input-mode&lt;/code&gt; возвращает настройки режима ввода, которые Emacs использует в данный момент.</target>
        </trans-unit>
        <trans-unit id="c234a92b19642441da1c2050b96be5c7305c6b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cursor-type&lt;/code&gt; frame parameter may be overridden by the variables &lt;code&gt;cursor-type&lt;/code&gt; and &lt;code&gt;cursor-in-non-selected-windows&lt;/code&gt;:</source>
          <target state="translated">Параметр рамки &lt;code&gt;cursor-type&lt;/code&gt; может быть переопределен переменными &lt;code&gt;cursor-type&lt;/code&gt; и &lt;code&gt;cursor-in-non-selected-windows&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="abe114d18cfa0ebfe62ff688cbe3eb7244ed6f72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defconst&lt;/code&gt; form, like &lt;code&gt;defvar&lt;/code&gt;, marks the variable as &lt;em&gt;special&lt;/em&gt;, meaning that it should always be dynamically bound (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;). In addition, it marks the variable as risky (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;).</source>
          <target state="translated">Форма &lt;code&gt;defconst&lt;/code&gt; , как и &lt;code&gt;defvar&lt;/code&gt; , помечает переменную как &lt;em&gt;специальную&lt;/em&gt; , что означает, что она всегда должна быть динамически привязана (см. &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Область действия переменной&lt;/a&gt; ). Кроме того, он отмечает переменную как опасную (см. &amp;laquo; &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;Локальные переменные файла&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="64e40c8d2d701d73f72f1726b04f6361773a945c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defcustom&lt;/code&gt; shows how the new widget can be used as an ordinary customization type.</source>
          <target state="translated">В &lt;code&gt;defcustom&lt;/code&gt; показывает , как новый виджет может быть использован в качестве обычного типа настройки.</target>
        </trans-unit>
        <trans-unit id="c71b39c3926065d439068fcf1de8b785d9704dac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;define-derived-mode&lt;/code&gt; macro automatically marks the derived mode as special if the parent mode is special. Special mode is a convenient parent for such modes to inherit from; See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;define-derived-mode&lt;/code&gt; макро автоматически помечает производный режим в качестве специального , если родительский режим является особенным. Специальный режим является удобным родительским элементом для наследования таких режимов; См. &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Основные основные режимы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e11839d47e0b0ae68558951b5e41000c1afea76c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defvar&lt;/code&gt; form returns &lt;var&gt;symbol&lt;/var&gt;, but it is normally used at top level in a file where its value does not matter.</source>
          <target state="translated">Форма &lt;code&gt;defvar&lt;/code&gt; возвращает &lt;var&gt;symbol&lt;/var&gt; , но обычно используется на верхнем уровне в файле, где его значение не имеет значения.</target>
        </trans-unit>
        <trans-unit id="f2a831eac710a97efa9bd72520d60c444307b0c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delq&lt;/code&gt; function deletes elements from the front of the list by simply advancing down the list, and returning a sublist that starts after those elements. For example:</source>
          <target state="translated">Функция &lt;code&gt;delq&lt;/code&gt; удаляет элементы из начала списка, просто продвигаясь вниз по списку и возвращая подсписок, который начинается после этих элементов. Например:</target>
        </trans-unit>
        <trans-unit id="3ddb538774d53998062db4dcb38e5ca6d446b2f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;describe-mode&lt;/code&gt; function provides information about major modes. It is normally bound to</source>
          <target state="translated">Функция &lt;code&gt;describe-mode&lt;/code&gt; предоставляет информацию об основных режимах. Обычно это связано с</target>
        </trans-unit>
        <trans-unit id="420dbb7acb7058c3164d9b155e31d95bf6b40fdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;describe-symbols&lt;/code&gt; function works like &lt;code&gt;apropos&lt;/code&gt;, but provides more information.</source>
          <target state="translated">Функция &lt;code&gt;describe-symbols&lt;/code&gt; работает как &lt;code&gt;apropos&lt;/code&gt; , но предоставляет дополнительную информацию.</target>
        </trans-unit>
        <trans-unit id="d698b4556987ba6e891cbfa0189cb35f00181f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display&lt;/code&gt; text property (or overlay property) is used to insert images into text, and to control other aspects of how text displays. The value of the &lt;code&gt;display&lt;/code&gt; property should be a display specification, or a list or vector containing several display specifications. Display specifications in the same &lt;code&gt;display&lt;/code&gt; property value generally apply in parallel to the text they cover.</source>
          <target state="translated">Свойство &lt;code&gt;display&lt;/code&gt; текста (или свойство наложения) используется для вставки изображений в текст и для управления другими аспектами отображения текста. Значение свойства &lt;code&gt;display&lt;/code&gt; должно быть спецификацией отображения, списком или вектором, содержащим несколько спецификаций отображения. Спецификации отображения в одном и том же значении свойства &lt;code&gt;display&lt;/code&gt; обычно применяются параллельно с охватываемым ими текстом.</target>
        </trans-unit>
        <trans-unit id="2146c9591b8794278316c3a07921a6d986eec90e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;documentation&lt;/code&gt; function signals a &lt;code&gt;void-function&lt;/code&gt; error if &lt;var&gt;function&lt;/var&gt; has no function definition. However, it is OK if the function definition has no documentation string. In that case, &lt;code&gt;documentation&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;documentation&lt;/code&gt; сигнализирует об ошибке &lt;code&gt;void-function&lt;/code&gt; , если &lt;var&gt;function&lt;/var&gt; не имеет определения функции. Однако это нормально, если в определении функции нет строки документации. В этом случае &lt;code&gt;documentation&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5946c5a7fe3388e239c56c7c95a52e422b36084" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dolist&lt;/code&gt; and &lt;code&gt;dotimes&lt;/code&gt; macros provide convenient ways to write two common kinds of loops.</source>
          <target state="translated">В &lt;code&gt;dolist&lt;/code&gt; и &lt;code&gt;dotimes&lt;/code&gt; макросы обеспечивают удобные способы , чтобы написать два общих вида петель.</target>
        </trans-unit>
        <trans-unit id="5cd619e63bb900a8b2dd3e53b8d42ac7bccfddfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emacs_env&lt;/code&gt; pointer will usually come from the first argument to the module function, or from the call to &lt;code&gt;get_environment&lt;/code&gt; if you need the environment in the module initialization function.</source>
          <target state="translated">&lt;code&gt;emacs_env&lt;/code&gt; указатель обычно приходит из первого аргумента функции модуля, или от вызова &lt;code&gt;get_environment&lt;/code&gt; если вам нужна среда в функции инициализации модуля.</target>
        </trans-unit>
        <trans-unit id="7ad2f8242022f8fdd9f0ca14ddd9059e3039f1a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode-time&lt;/code&gt; function acts as a rough inverse to &lt;code&gt;decode-time&lt;/code&gt;. For example, you can pass the output of the latter to the former as follows:</source>
          <target state="translated">Функция времени &lt;code&gt;encode-time&lt;/code&gt; действует как грубая инверсия времени &lt;code&gt;decode-time&lt;/code&gt; . Например, вы можете передать вывод последнего первому следующим образом:</target>
        </trans-unit>
        <trans-unit id="f5e051708617b016d8c30904d9f5633ae38b3813" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;face&lt;/code&gt; property controls the appearance of the character (see &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;). The value of the property can be the following:</source>
          <target state="translated">Свойство &lt;code&gt;face&lt;/code&gt; контролирует внешний вид персонажа (см. &lt;a href=&quot;faces#Faces&quot;&gt;Лица&lt;/a&gt; ). Стоимость недвижимости может быть следующей:</target>
        </trans-unit>
        <trans-unit id="601594d3c15ba0ab5790f6701cbf7bd2686bf7a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;field&lt;/code&gt; property defines fields within the buffer.</source>
          <target state="translated">Свойство &lt;code&gt;field&lt;/code&gt; определяет поля в буфере.</target>
        </trans-unit>
        <trans-unit id="91d87e0abd3197dd0c588023b97f64cbfcd2c19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find-file-noselect&lt;/code&gt; function normally calls &lt;code&gt;after-find-file&lt;/code&gt; after reading the file (see &lt;a href=&quot;subroutines-of-visiting#Subroutines-of-Visiting&quot;&gt;Subroutines of Visiting&lt;/a&gt;). That function sets the buffer major mode, parses local variables, warns the user if there exists an auto-save file more recent than the file just visited, and finishes by running the functions in &lt;code&gt;find-file-hook&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;find-file-noselect&lt;/code&gt; обычно вызывает &lt;code&gt;after-find-file&lt;/code&gt; после чтения файла (см. &lt;a href=&quot;subroutines-of-visiting#Subroutines-of-Visiting&quot;&gt;Подпрограммы посещения&lt;/a&gt; ). Эта функция устанавливает основной режим буфера, анализирует локальные переменные, предупреждает пользователя, если существует файл автосохранения более поздний, чем только что посещенный файл, и завершает выполнение функций в &lt;code&gt;find-file-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b8dc94f0401068ad923a287f4722f89053e9822" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find-file-noselect&lt;/code&gt; function uses two important subroutines which are sometimes useful in user Lisp code: &lt;code&gt;create-file-buffer&lt;/code&gt; and &lt;code&gt;after-find-file&lt;/code&gt;. This section explains how to use them.</source>
          <target state="translated">Функция &lt;code&gt;find-file-noselect&lt;/code&gt; использует две важные подпрограммы, которые иногда полезны в пользовательском коде Lisp: &lt;code&gt;create-file-buffer&lt;/code&gt; и &lt;code&gt;after-find-file&lt;/code&gt; . В этом разделе объясняется, как их использовать.</target>
        </trans-unit>
        <trans-unit id="433399969927d5b1796b197fef7a6e76457e8540" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find-file-noselect&lt;/code&gt; function usually returns the buffer that is visiting the file &lt;var&gt;filename&lt;/var&gt;. But, if wildcards are actually used and expanded, it returns a list of buffers that are visiting the various files.</source>
          <target state="translated">Функция &lt;code&gt;find-file-noselect&lt;/code&gt; обычно возвращает буфер, который обращается к файлу &lt;var&gt;filename&lt;/var&gt; . Но если подстановочные знаки действительно используются и расширяются, он возвращает список буферов, которые обращаются к различным файлам.</target>
        </trans-unit>
        <trans-unit id="a464addeb7232688689a59ac447a545f6c93c736" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;follow-link&lt;/code&gt; property, defining how a</source>
          <target state="translated">Свойство &lt;code&gt;follow-link&lt;/code&gt; , определяющее, как</target>
        </trans-unit>
        <trans-unit id="444a5499ee66a56312fc2965164aa8d072d4a9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;font-lock-multiline&lt;/code&gt; property is meant to ensure proper refontification; it does not automatically identify new multiline constructs. Identifying them requires that Font Lock mode operate on large enough chunks at a time. This will happen by accident on many cases, which may give the impression that multiline constructs magically work. If you set the &lt;code&gt;font-lock-multiline&lt;/code&gt; variable non-&lt;code&gt;nil&lt;/code&gt;, this impression will be even stronger, since the highlighting of those constructs which are found will be properly updated from then on. But that does not work reliably.</source>
          <target state="translated">Свойство &lt;code&gt;font-lock-multiline&lt;/code&gt; предназначено для обеспечения правильной рефонтификации; он не определяет автоматически новые многострочные конструкции. Для их идентификации необходимо, чтобы режим Font Lock работал с достаточно большими фрагментами одновременно. Во многих случаях это происходит случайно, что может создать впечатление, будто многострочные конструкции работают волшебным образом. Если вы установите для переменной &lt;code&gt;font-lock-multiline&lt;/code&gt; значение non- &lt;code&gt;nil&lt;/code&gt; , это впечатление будет еще сильнее, поскольку с этого момента выделение тех конструкций, которые были найдены, будет правильно обновляться. Но это не работает надежно.</target>
        </trans-unit>
        <trans-unit id="47be97b3e1f5347c54244ef417be3e1f2a83bb62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;group&lt;/code&gt; widget is used here instead of &lt;code&gt;list&lt;/code&gt; only because the formatting is better suited for the purpose.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; виджета используется здесь вместо &lt;code&gt;list&lt;/code&gt; только потому , что форматирование лучше подходит для этой цели.</target>
        </trans-unit>
        <trans-unit id="8fa064dc83f7cd8e73706942b3d3bf88b2f393fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;imenu-generic-expression&lt;/code&gt; regular expressions can then use &amp;lsquo;</source>
          <target state="translated">В &lt;code&gt;imenu-generic-expression&lt;/code&gt; регулярные выражения могут использовать '</target>
        </trans-unit>
        <trans-unit id="95cfa710dcb0d358ddec70e647ab0d09459da980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;mm&lt;/code&gt;, and &lt;code&gt;cm&lt;/code&gt; units specify the number of pixels per inch, millimeter, and centimeter, respectively. The &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; units correspond to the default width and height of the current face. An image specification of the form &lt;code&gt;(image&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; (see &lt;a href=&quot;image-descriptors#Image-Descriptors&quot;&gt;Image Descriptors&lt;/a&gt;) corresponds to the width or height of the specified image. Similarly, an xwidget specification of the form &lt;code&gt;(xwidget&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; stands for the width or height of the specified xwidget. See &lt;a href=&quot;xwidgets#Xwidgets&quot;&gt;Xwidgets&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;mm&lt;/code&gt; , и &lt;code&gt;cm&lt;/code&gt; единиц указать количество пикселей на дюйм, миллиметр и сантиметр, соответственно. В &lt;code&gt;width&lt;/code&gt; и &lt;code&gt;height&lt;/code&gt; единицы соответствуют ширине по умолчанию и высоты текущего лица. Спецификация изображения формы &lt;code&gt;(image&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; (см. &lt;a href=&quot;image-descriptors#Image-Descriptors&quot;&gt;Дескрипторы изображения&lt;/a&gt; ) соответствует ширине или высоте указанного изображения. Аналогичным образом , xwidget спецификация формы &lt;code&gt;(xwidget&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; обозначает ширину или высоту указанного xwidget. См. &lt;a href=&quot;xwidgets#Xwidgets&quot;&gt;Xwidgets&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1fa85ed58bc9efcbe16dc5d44ca81dd39c29afc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intangible&lt;/code&gt; property on an overlay works just like the &lt;code&gt;intangible&lt;/code&gt; text property. It is obsolete. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;, for details.</source>
          <target state="translated">&lt;code&gt;intangible&lt;/code&gt; имущество на оверлей работает точно так же , как &lt;code&gt;intangible&lt;/code&gt; текст собственности. Это устарело. См. Подробности в разделе &amp;laquo; &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Особые свойства&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c74f8c0156232d28e603141c4cc1ee2352b2c427" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interactive&lt;/code&gt; form must be located at top-level in the function body, or in the function symbol&amp;rsquo;s &lt;code&gt;interactive-form&lt;/code&gt; property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;). It has its effect because the command loop looks for it before calling the function (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;). Once the function is called, all its body forms are executed; at this time, if the &lt;code&gt;interactive&lt;/code&gt; form occurs within the body, the form simply returns &lt;code&gt;nil&lt;/code&gt; without even evaluating its argument.</source>
          <target state="translated">&lt;code&gt;interactive&lt;/code&gt; форма должна быть расположена на верхнем уровне в теле функции, или в функции символа &lt;code&gt;interactive-form&lt;/code&gt; собственности (см &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt; ). Это имеет свой эффект, потому что командный цикл ищет его перед вызовом функции (см. &amp;laquo; &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Интерактивный вызов&amp;raquo;&lt;/a&gt; ). После вызова функции выполняются все ее формы тела; в это время, если &lt;code&gt;interactive&lt;/code&gt; форма встречается в теле, форма просто возвращает &lt;code&gt;nil&lt;/code&gt; , даже не оценивая свой аргумент.</target>
        </trans-unit>
        <trans-unit id="f846208cf69e148316b2a5e801ec368e4897cade" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;invisible&lt;/code&gt; property can make the text in the overlay invisible, which means that it does not appear on the screen. See &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;, for details.</source>
          <target state="translated">Свойство &lt;code&gt;invisible&lt;/code&gt; может сделать текст в наложении невидимым, что означает, что он не отображается на экране. См. &amp;laquo; &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Невидимый текст&amp;raquo;&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="bae7cf08edd92266cd91450bcbdcde42f958861e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonrpc&lt;/code&gt; library implements the</source>
          <target state="translated">Библиотека &lt;code&gt;jsonrpc&lt;/code&gt; реализует</target>
        </trans-unit>
        <trans-unit id="cea28c2d7fc3fcf0178f1c3323d9e331934d7db9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keymap&lt;/code&gt; and &lt;code&gt;local-map&lt;/code&gt; properties do not affect a string displayed by the &lt;code&gt;before-string&lt;/code&gt;, &lt;code&gt;after-string&lt;/code&gt;, or &lt;code&gt;display&lt;/code&gt; properties. This is only relevant for mouse clicks and other mouse events that fall on the string, since point is never on the string. To bind special mouse events for the string, assign it a &lt;code&gt;keymap&lt;/code&gt; or &lt;code&gt;local-map&lt;/code&gt; text property. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;keymap&lt;/code&gt; и &lt;code&gt;local-map&lt;/code&gt; свойство не влияет на строку , отображенную &lt;code&gt;before-string&lt;/code&gt; , &lt;code&gt;after-string&lt;/code&gt; или &lt;code&gt;display&lt;/code&gt; свойств. Это актуально только для щелчков мышью и других событий мыши, которые попадают в строку, поскольку точка никогда не находится в строке. Чтобы связать специальные события мыши для строки, назначьте ей свойство текста &lt;code&gt;keymap&lt;/code&gt; или &lt;code&gt;local-map&lt;/code&gt; . См. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Особые свойства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c80a5ff57952dcdf069923f6c4148ca2b519f38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keymap&lt;/code&gt; property specifies an additional keymap for commands. When this keymap applies, it is used for key lookup before the minor mode keymaps and before the buffer&amp;rsquo;s local map. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;. If the property value is a symbol, the symbol&amp;rsquo;s function definition is used as the keymap.</source>
          <target state="translated">Свойство &lt;code&gt;keymap&lt;/code&gt; определяет дополнительную раскладку для команд. Когда применяется эта раскладка, она используется для поиска ключей перед раскладками вспомогательного режима и перед локальной картой буфера. См. &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Активные таблицы ключей&lt;/a&gt; . Если значением свойства является символ, определение функции символа используется в качестве раскладки клавиатуры.</target>
        </trans-unit>
        <trans-unit id="d3dd9b04eaf9d8f1503fdd7493d3e02d22d27e88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill-emacs&lt;/code&gt; function is normally called via the higher-level command</source>
          <target state="translated">Функция &lt;code&gt;kill-emacs&lt;/code&gt; обычно вызывается через команду более высокого уровня</target>
        </trans-unit>
        <trans-unit id="c92e19a6bbfd6a262fe1a00d8884e70099e8c2b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; variable points to a link in the kill ring list, whose &lt;small&gt;CAR&lt;/small&gt; is the text to yank next. We say it identifies the front of the ring. Moving &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; to a different link is called &lt;em&gt;rotating the kill ring&lt;/em&gt;. We call the kill ring a &amp;ldquo;ring&amp;rdquo; because the functions that move the yank pointer wrap around from the end of the list to the beginning, or vice-versa. Rotation of the kill ring is virtual; it does not change the value of &lt;code&gt;kill-ring&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; точки переменной на ссылку в списке уничтожений, чей &lt;small&gt;CAR&lt;/small&gt; текст дергать дальше. Мы говорим, что он идентифицирует переднюю часть кольца. Перемещение &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; на другую ссылку называется &lt;em&gt;вращением kill-ring&lt;/em&gt; . Мы называем кольцо уничтожения &amp;laquo;кольцом&amp;raquo;, потому что функции, которые перемещают указатель восстановления, перемещаются от конца списка к началу или наоборот. Вращение кольца уничтожения виртуальное; он не меняет значение &lt;code&gt;kill-ring&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="300fdeb58fe0177e7e1b352ab7be30fbfbfd4c57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lambda&lt;/code&gt; form has one other effect: it tells the Emacs evaluator and byte-compiler that its argument is a function, by using &lt;code&gt;function&lt;/code&gt; as a subroutine (see below).</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; - форма имеет один эффект: он говорит оценщик Emacs и байт-компилятор , что ее аргумент является функцией, с помощью &lt;code&gt;function&lt;/code&gt; в качестве подпрограммы (смотри ниже).</target>
        </trans-unit>
        <trans-unit id="a2aafafa00230d541923e3ade40d481ca37d93c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt; positions can be used with &lt;code&gt;:align-to&lt;/code&gt; to specify a position relative to the left edge, center, or right edge of the text area. When the window displays line numbers, the &lt;code&gt;left&lt;/code&gt; and the &lt;code&gt;center&lt;/code&gt; positions are offset to account for the screen space taken by the line-number display.</source>
          <target state="translated">Положение &lt;code&gt;left&lt;/code&gt; , по &lt;code&gt;center&lt;/code&gt; и &lt;code&gt;right&lt;/code&gt; можно использовать с &lt;code&gt;:align-to&lt;/code&gt; , чтобы указать положение относительно левого, центрального или правого края текстовой области. Когда в окне отображаются номера строк, &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;center&lt;/code&gt; позиции смещаются, чтобы учесть пространство экрана, занимаемое отображением номера строки.</target>
        </trans-unit>
        <trans-unit id="0400cb4c69cbe2da905584673b0c879713b9c76e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; binding defines a lexical environment in which the variable &lt;code&gt;x&lt;/code&gt; is locally bound to 0. Within this binding construct, we define a lambda expression which increments &lt;code&gt;x&lt;/code&gt; by one and returns the incremented value. This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the &lt;code&gt;let&lt;/code&gt; binding construct has exited. Each time we evaluate the closure, it increments &lt;code&gt;x&lt;/code&gt;, using the binding of &lt;code&gt;x&lt;/code&gt; in that lexical environment.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; связывание определяет лексическую среду , в которой переменная &lt;code&gt;x&lt;/code&gt; локально привязан к 0. В этой конструкции связывания, определим лямбда - выражение , которое приращения &lt;code&gt;x&lt;/code&gt; на единицу и возвращает измененное значение. Это лямбда-выражение автоматически превращается в замыкание, в котором лексическая среда продолжает существовать даже после выхода из конструкции связывания &lt;code&gt;let&lt;/code&gt; . Каждый раз, когда мы оцениваем замыкание, оно увеличивает &lt;code&gt;x&lt;/code&gt; , используя привязку &lt;code&gt;x&lt;/code&gt; в этой лексической среде.</target>
        </trans-unit>
        <trans-unit id="13495fafa6f5ab5c87807a5b63a3af0706d7817e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list-threads&lt;/code&gt; command lists all the currently alive threads. In the resulting buffer, each thread is identified either by the name passed to &lt;code&gt;make-thread&lt;/code&gt; (see &lt;a href=&quot;basic-thread-functions#Basic-Thread-Functions&quot;&gt;Basic Thread Functions&lt;/a&gt;), or by its unique internal identifier if it was not created with a name. The status of each thread at the time of the creation or last update of the buffer is shown, in addition to the object the thread was blocked on at the time, if it was blocked.</source>
          <target state="translated">Команда &lt;code&gt;list-threads&lt;/code&gt; выводит список всех активных в данный момент потоков. В результирующем буфере каждый поток идентифицируется либо именем, переданным в &lt;code&gt;make-thread&lt;/code&gt; (см. &lt;a href=&quot;basic-thread-functions#Basic-Thread-Functions&quot;&gt;Основные функции потоков&lt;/a&gt; ), либо своим уникальным внутренним идентификатором, если он не был создан с именем. Отображается состояние каждого потока на момент создания или последнего обновления буфера, в дополнение к объекту, на котором поток был заблокирован в то время, если он был заблокирован.</target>
        </trans-unit>
        <trans-unit id="0913489aeb9c330c64bb079b1c5f7c7b0fe21837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list-timers&lt;/code&gt; command lists all the currently active timers. There&amp;rsquo;s only one command available in the buffer displayed:</source>
          <target state="translated">Команда &lt;code&gt;list-timers&lt;/code&gt; выводит список всех активных в данный момент таймеров. В отображаемом буфере доступна только одна команда:</target>
        </trans-unit>
        <trans-unit id="2001adc7401e23d02f00869110aad55b1044900c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;load&lt;/code&gt; function and others.</source>
          <target state="translated">Функция &lt;code&gt;load&lt;/code&gt; и другие.</target>
        </trans-unit>
        <trans-unit id="60b597e3a1575b6fda9337a82325c5e944998909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local-map&lt;/code&gt; property is similar to &lt;code&gt;keymap&lt;/code&gt; but replaces the buffer&amp;rsquo;s local map rather than augmenting existing keymaps. This also means it has lower precedence than minor mode keymaps.</source>
          <target state="translated">Свойство &lt;code&gt;local-map&lt;/code&gt; похоже на &lt;code&gt;keymap&lt;/code&gt; но заменяет локальную карту буфера, а не увеличивает существующие раскладки клавиатуры. Это также означает, что он имеет более низкий приоритет, чем раскладки дополнительных режимов.</target>
        </trans-unit>
        <trans-unit id="5c9fa7882799c21b778d554910cdcdfb2d432b8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make-symbol&lt;/code&gt; function returns an uninterned symbol, distinct from the symbol that is used if you write the name in a Lisp expression. Distinct symbols with the same name are not &lt;code&gt;eq&lt;/code&gt;. See &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;make-symbol&lt;/code&gt; возвращает неорганизованный символ, отличный от символа, который используется, если вы записываете имя в выражении Лиспа. Отчетливые символы с одинаковыми именами не &lt;code&gt;eq&lt;/code&gt; . См. &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Создание символов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39c002469150bf19e61aa64b21029ed51696a1ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modiff&lt;/code&gt; field of the window&amp;rsquo;s buffer, as of the last time a redisplay completed in this window.</source>
          <target state="translated">Поле &lt;code&gt;modiff&lt;/code&gt; буфера окна на момент последнего завершения повторного отображения в этом окне.</target>
        </trans-unit>
        <trans-unit id="8792ad0df49661320c71bdaa90f1c322ed577276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or&lt;/code&gt; special form tests whether at least one of the &lt;var&gt;conditions&lt;/var&gt; is true. It works by evaluating all the &lt;var&gt;conditions&lt;/var&gt; one by one in the order written.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; специальные тесты образуют ли , по крайней мере один из &lt;var&gt;conditions&lt;/var&gt; является истинным. Он работает, оценивая все &lt;var&gt;conditions&lt;/var&gt; одно за другим в записанном порядке.</target>
        </trans-unit>
        <trans-unit id="54cf985900734756973b5e6c1038f7a5bb008475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay_modiff&lt;/code&gt; field of the window&amp;rsquo;s buffer, as of the last time a redisplay completed in this window.</source>
          <target state="translated">Поле &lt;code&gt;overlay_modiff&lt;/code&gt; буфера окна на момент последнего завершения повторного отображения в этом окне.</target>
        </trans-unit>
        <trans-unit id="37eaec0c1b4099d02a0ae66595ebff4846d95b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent-frame&lt;/code&gt; parameter can be changed at any time. Setting it to another frame &lt;em&gt;reparents&lt;/em&gt; the child frame. Setting it to another child frame makes the frame a &lt;em&gt;nested&lt;/em&gt; child frame. Setting it to &lt;code&gt;nil&lt;/code&gt; restores the frame&amp;rsquo;s status as a top-level frame&amp;mdash;a frame whose window-system window is a child of its display&amp;rsquo;s root window.</source>
          <target state="translated">Параметр &lt;code&gt;parent-frame&lt;/code&gt; можно изменить в любое время. Установка его на другой фрейм &lt;em&gt;воспроизводит&lt;/em&gt; дочерний фрейм. Установка другого дочернего фрейма делает фрейм &lt;em&gt;вложенным&lt;/em&gt; дочерним фреймом. Установка его в &lt;code&gt;nil&lt;/code&gt; восстанавливает статус фрейма как фрейма верхнего уровня - фрейма, окно оконной системы которого является дочерним по отношению к корневому окну его дисплея.</target>
        </trans-unit>
        <trans-unit id="2cbabe60c124238bf2333a137807d3133e30e0c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcase&lt;/code&gt; macro can use &lt;code&gt;rx&lt;/code&gt; expressions as patterns directly; see &lt;a href=&quot;pcase-macro#rx-in-pcase&quot;&gt;rx in pcase&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pcase&lt;/code&gt; макрос можно использовать &lt;code&gt;rx&lt;/code&gt; выражение как шаблоны непосредственно; см. &lt;a href=&quot;pcase-macro#rx-in-pcase&quot;&gt;rx в pcase&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad2b03edf0503d884029350321e8227580f971a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcase&lt;/code&gt; macro supports several kinds of patterns (see &lt;a href=&quot;pattern_002dmatching-conditional#Pattern_002dMatching-Conditional&quot;&gt;Pattern-Matching Conditional&lt;/a&gt;). You can add support for other kinds of patterns using the &lt;code&gt;pcase-defmacro&lt;/code&gt; macro.</source>
          <target state="translated">В &lt;code&gt;pcase&lt;/code&gt; макро поддерживает несколько видов шаблонов (см &lt;a href=&quot;pattern_002dmatching-conditional#Pattern_002dMatching-Conditional&quot;&gt;Узор-подстановка условного&lt;/a&gt; ). Вы можете добавить поддержку других типов шаблонов с помощью &lt;code&gt;pcase-defmacro&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b3d5823b8631faa4d412a2d00c614d255559941" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcase&lt;/code&gt; patterns provide an alternative facility for destructuring binding, see &lt;a href=&quot;destructuring-with-pcase-patterns#Destructuring-with-pcase-Patterns&quot;&gt;Destructuring with pcase Patterns&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;pcase&lt;/code&gt; модели обеспечивают альтернативный объект для связывания уничтожения того , см &lt;a href=&quot;destructuring-with-pcase-patterns#Destructuring-with-pcase-Patterns&quot;&gt;Уничтожение того, с pcase шаблонами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4f5f41a3aef3458c44d5db29ce9dfc422046f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print&lt;/code&gt; function is a convenient way of printing. It outputs the printed representation of &lt;var&gt;object&lt;/var&gt; to &lt;var&gt;stream&lt;/var&gt;, printing in addition one newline before &lt;var&gt;object&lt;/var&gt; and another after it. Quoting characters are used. &lt;code&gt;print&lt;/code&gt; returns &lt;var&gt;object&lt;/var&gt;. For example:</source>
          <target state="translated">Функция &lt;code&gt;print&lt;/code&gt; - это удобный способ печати. Он выводит напечатанное представление &lt;var&gt;object&lt;/var&gt; в &lt;var&gt;stream&lt;/var&gt; , дополнительно печатая одну новую строку перед &lt;var&gt;object&lt;/var&gt; и еще одну после него. Используются кавычки. &lt;code&gt;print&lt;/code&gt; возвращает &lt;var&gt;object&lt;/var&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="ccc61565cace17508e3d5f3f87acbb4cc610269f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;process-status&lt;/code&gt; function returns &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;closed&lt;/code&gt;, &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, or &lt;code&gt;failed&lt;/code&gt; for network connections. For a network server, the status is always &lt;code&gt;listen&lt;/code&gt;. Except for &lt;code&gt;stop&lt;/code&gt;, none of those values is possible for a real subprocess. See &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;process-status&lt;/code&gt; возвращает &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;closed&lt;/code&gt; , &lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; или &lt;code&gt;failed&lt;/code&gt; для сетевых подключений. Для сетевого сервера статус всегда &lt;code&gt;listen&lt;/code&gt; . За исключением &lt;code&gt;stop&lt;/code&gt; , ни одно из этих значений невозможно для реального подпроцесса. См. &lt;a href=&quot;process-information#Process-Information&quot;&gt;Информацию о процессе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de088b6f64f19c2025fcc7d39d6e8d69dd77d6e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prop-match&lt;/code&gt; structure has the following accessors: &lt;code&gt;prop-match-beginning&lt;/code&gt; (the start of the match), &lt;code&gt;prop-match-end&lt;/code&gt; (the end of the match), and &lt;code&gt;prop-match-value&lt;/code&gt; (the value of &lt;var&gt;property&lt;/var&gt; at the start of the match).</source>
          <target state="translated">Структура &lt;code&gt;prop-match&lt;/code&gt; имеет следующие аксессоры: &lt;code&gt;prop-match-beginning&lt;/code&gt; (начало совпадения), &lt;code&gt;prop-match-end&lt;/code&gt; (конец совпадения) и &lt;code&gt;prop-match-value&lt;/code&gt; (значение &lt;var&gt;property&lt;/var&gt; в начале матча).</target>
        </trans-unit>
        <trans-unit id="598373f29709110698650f08e484fa46a6f764f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read-command&lt;/code&gt; function is a simplified interface to &lt;code&gt;completing-read&lt;/code&gt;. It uses the variable &lt;code&gt;obarray&lt;/code&gt; so as to complete in the set of extant Lisp symbols, and it uses the &lt;code&gt;commandp&lt;/code&gt; predicate so as to accept only command names:</source>
          <target state="translated">Функция команды &lt;code&gt;read-command&lt;/code&gt; - это упрощенный интерфейс для &lt;code&gt;completing-read&lt;/code&gt; . Он использует переменную &lt;code&gt;obarray&lt;/code&gt; , чтобы завершить набор существующих символов Lisp, и он использует предикат &lt;code&gt;commandp&lt;/code&gt; , чтобы принимать только имена команд:</target>
        </trans-unit>
        <trans-unit id="2a8b0f78b4fb6dd443231846e3503cfc2ae4faa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read-multiple-choice-face&lt;/code&gt; face is used to highlight the matching characters in the name string on graphical terminals.</source>
          <target state="translated">&lt;code&gt;read-multiple-choice-face&lt;/code&gt; начертание используется для выделения символов , соответствующих в имени строка на графических терминалах.</target>
        </trans-unit>
        <trans-unit id="200780fa627bf54ef45ca3b42f1020c5fa31731b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rear-nonsticky&lt;/code&gt; property works the opposite way. Most properties are rear-sticky by default, so the &lt;code&gt;rear-nonsticky&lt;/code&gt; property says which properties are &lt;em&gt;not&lt;/em&gt; rear-sticky. If a character&amp;rsquo;s &lt;code&gt;rear-nonsticky&lt;/code&gt; property is &lt;code&gt;t&lt;/code&gt;, then none of its properties are rear-sticky. If the &lt;code&gt;rear-nonsticky&lt;/code&gt; property is a list, properties are rear-sticky &lt;em&gt;unless&lt;/em&gt; their names are in the list.</source>
          <target state="translated">Свойство &amp;laquo;не &lt;code&gt;rear-nonsticky&lt;/code&gt; работает наоборот. Большинство свойств являются задними липкими по умолчанию, так что &lt;code&gt;rear-nonsticky&lt;/code&gt; свойство говорит , какие свойства &lt;em&gt;не&lt;/em&gt; задние липкие. Если персонаж &lt;code&gt;rear-nonsticky&lt;/code&gt; свойство &lt;code&gt;t&lt;/code&gt; , то ни одно из его свойств не являются задними липким. Если &lt;code&gt;rear-nonsticky&lt;/code&gt; свойство является списком, свойства задние-липкие, &lt;em&gt;если&lt;/em&gt; их имена не находятся в списке.</target>
        </trans-unit>
        <trans-unit id="21b5243fd9928f00ce2770b484cc6cb21e26829f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rx&lt;/code&gt; notation can be extended by defining new symbols and parameterized forms in terms of other &lt;code&gt;rx&lt;/code&gt; expressions. This is handy for sharing parts between several regexps, and for making complex ones easier to build and understand by putting them together from smaller pieces.</source>
          <target state="translated">&lt;code&gt;rx&lt;/code&gt; обозначения могут быть расширены путем определения новых символов и параметризованные форм с точки зрения других &lt;code&gt;rx&lt;/code&gt; выражений. Это удобно для разделения частей между несколькими регулярными выражениями, а также для упрощения построения и понимания сложных регулярных выражений путем объединения их из более мелких частей.</target>
        </trans-unit>
        <trans-unit id="d35c64be484f1d1e41d1cf10785e16404529be6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rx&lt;/code&gt; notation is mainly useful in Lisp code; it cannot be used in most interactive situations where a regexp is requested, such as when running &lt;code&gt;query-replace-regexp&lt;/code&gt; or in variable customization.</source>
          <target state="translated">&lt;code&gt;rx&lt;/code&gt; обозначение в основном полезно в коде Lisp; его нельзя использовать в большинстве интерактивных ситуаций, когда запрашивается регулярное выражение, например, при запуске &lt;code&gt;query-replace-regexp&lt;/code&gt; или при настройке переменных.</target>
        </trans-unit>
        <trans-unit id="53551c07d10f3f216837e0f26f28d397fcb2ed21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;save-current-buffer&lt;/code&gt; special form saves the identity of the current buffer, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores that buffer as current. The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. The current buffer is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;save-current-buffer&lt;/code&gt; особая форма сохраняет идентичность текущего буфера, оценивает &lt;var&gt;body&lt;/var&gt; формы, и , наконец , восстанавливает этот буфер , как ток. Возвращаемое значение - это значение последней формы в &lt;var&gt;body&lt;/var&gt; . Текущий буфер восстанавливается даже в случае аварийного выхода из-за &lt;code&gt;throw&lt;/code&gt; или ошибки (см. &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Нелокальные выходы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="02fe48ac684709f11ba9e8bf659b5046cd711774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setf&lt;/code&gt; macro is the most basic way to operate on generalized variables. The &lt;code&gt;setf&lt;/code&gt; form is like &lt;code&gt;setq&lt;/code&gt;, except that it accepts arbitrary place forms on the left side rather than just symbols. For example, &lt;code&gt;(setf (car a) b)&lt;/code&gt; sets the car of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;, doing the same operation as &lt;code&gt;(setcar a b)&lt;/code&gt;, but without you having to use two separate functions for setting and accessing this type of place.</source>
          <target state="translated">&lt;code&gt;setf&lt;/code&gt; макрос является самым основным способом работать на обобщенных переменных. Форма &lt;code&gt;setf&lt;/code&gt; похожа на &lt;code&gt;setq&lt;/code&gt; , за исключением того, что она принимает произвольные формы мест с левой стороны, а не только символы. Например, &lt;code&gt;(setf (car a) b)&lt;/code&gt; устанавливает автомобиль в &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;b&lt;/code&gt; , выполняя ту же операцию, что и &lt;code&gt;(setcar a b)&lt;/code&gt; , но без необходимости использовать две отдельные функции для настройки и доступа к этому типу места.</target>
        </trans-unit>
        <trans-unit id="519db98ccdce7a0ac9a46f7b701fd15fc85de13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setf&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;setf&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="aa53c63a9abb045c39925931519d6a1ad749f396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;silly-loop&lt;/code&gt; function is somewhat more complex:</source>
          <target state="translated">Функция &lt;code&gt;silly-loop&lt;/code&gt; несколько сложнее:</target>
        </trans-unit>
        <trans-unit id="c7a98fc9f98f8ed0409fa02d84cfaa200eb97ed0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sort-paragraphs&lt;/code&gt; function is very much the same, except that its &lt;code&gt;sort-subr&lt;/code&gt; call looks like this:</source>
          <target state="translated">Функция &lt;code&gt;sort-paragraphs&lt;/code&gt; очень похожа , за исключением того, что ее вызов &lt;code&gt;sort-subr&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="695d17039e6c523d0970c6a178f2b0f1e4914ac6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;split-window&lt;/code&gt; call has created a new live window, denoted by &lt;var&gt;W5&lt;/var&gt;. It has also created a new internal window, denoted by &lt;var&gt;W3&lt;/var&gt;, which becomes the root window and the parent of both &lt;var&gt;W4&lt;/var&gt; and &lt;var&gt;W5&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;split-window&lt;/code&gt; вызов создал новое окно живых, обозначаемый &lt;var&gt;W5&lt;/var&gt; . Он также создал новое внутреннее окно, обозначенное &lt;var&gt;W3&lt;/var&gt; , которое становится корневым окном и родительским окном для &lt;var&gt;W4&lt;/var&gt; и &lt;var&gt;W5&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b2e5b8192b36bed82b233ac7ff740de7b4a505e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stopped&lt;/code&gt; event reports, that watching the file has been stopped. This could be because &lt;code&gt;file-notify-rm-watch&lt;/code&gt; was called (see below), or because the file being watched was deleted, or due to another error reported from the underlying library.</source>
          <target state="translated">В &lt;code&gt;stopped&lt;/code&gt; отчеты о событиях, которые смотрят файл был остановлен. Это могло произойти из &lt;code&gt;file-notify-rm-watch&lt;/code&gt; был вызван file-notify-rm-watch (см. Ниже), или из-за того, что наблюдаемый файл был удален, или из-за другой ошибки, полученной из базовой библиотеки.</target>
        </trans-unit>
        <trans-unit id="08a33b6bbd7b79c1bd61398e4080d80acb78db3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suppress-keymap&lt;/code&gt; function does not make it impossible to modify a buffer, as it does not suppress commands such as &lt;code&gt;yank&lt;/code&gt; and &lt;code&gt;quoted-insert&lt;/code&gt;. To prevent any modification of a buffer, make it read-only (see &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;).</source>
          <target state="translated">Функция &lt;code&gt;suppress-keymap&lt;/code&gt; не делает невозможным изменение буфера, поскольку не подавляет такие команды, как &lt;code&gt;yank&lt;/code&gt; и &lt;code&gt;quoted-insert&lt;/code&gt; . Чтобы предотвратить любую модификацию буфера, сделайте его доступным только для чтения (см. &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Буферы только для чтения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="347f633203d82e1fb528295569b12e1c05eae812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syntax-table&lt;/code&gt; property overrides what the syntax table says about this particular character. See &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Syntax Properties&lt;/a&gt;.</source>
          <target state="translated">Свойство &lt;code&gt;syntax-table&lt;/code&gt; отменяет то, что таблица синтаксиса говорит об этом конкретном символе. См. &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Свойства синтаксиса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92bcd0f9acc582211cd5c8c795c82abd36469aa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thin-space&lt;/code&gt;, &lt;code&gt;empty-box&lt;/code&gt;, &lt;code&gt;hex-code&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;thin-space&lt;/code&gt; , &lt;code&gt;empty-box&lt;/code&gt; , &lt;code&gt;hex-code&lt;/code&gt; , и</target>
        </trans-unit>
        <trans-unit id="59f05476c96f428731172a18b457adc61f7b26e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;throw&lt;/code&gt; form, if executed, transfers control straight back to the corresponding &lt;code&gt;catch&lt;/code&gt;, which returns immediately. The code following the &lt;code&gt;throw&lt;/code&gt; is not executed. The second argument of &lt;code&gt;throw&lt;/code&gt; is used as the return value of the &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">Форма &lt;code&gt;throw&lt;/code&gt; , если выполняется, передает управление прямо обратно соответствующему &lt;code&gt;catch&lt;/code&gt; , который немедленно возвращается. Код после &lt;code&gt;throw&lt;/code&gt; не выполняется. Второй аргумент &lt;code&gt;throw&lt;/code&gt; используется как возвращаемое значение &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0202856c38d3263072f8da9b700d02ede351a72a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;throw&lt;/code&gt; need not appear lexically within the &lt;code&gt;catch&lt;/code&gt; that it jumps to. It can equally well be called from another function called within the &lt;code&gt;catch&lt;/code&gt;. As long as the &lt;code&gt;throw&lt;/code&gt; takes place chronologically after entry to the &lt;code&gt;catch&lt;/code&gt;, and chronologically before exit from it, it has access to that &lt;code&gt;catch&lt;/code&gt;. This is why &lt;code&gt;throw&lt;/code&gt; can be used in commands such as &lt;code&gt;exit-recursive-edit&lt;/code&gt; that throw back to the editor command loop (see &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; не должен появиться лексически в &lt;code&gt;catch&lt;/code&gt; , что он подскакивает к. Его также можно вызвать из другой функции, вызываемой внутри &lt;code&gt;catch&lt;/code&gt; . Пока &lt;code&gt;throw&lt;/code&gt; происходит в хронологическом порядке после входа в &lt;code&gt;catch&lt;/code&gt; и в хронологическом порядке перед выходом из него, он имеет доступ к этому &lt;code&gt;catch&lt;/code&gt; . Вот почему &lt;code&gt;throw&lt;/code&gt; можно использовать в таких командах, как &lt;code&gt;exit-recursive-edit&lt;/code&gt; , которые возвращаются в цикл команд редактора (см. &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Рекурсивное редактирование&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a74decb60f69c5be5ea94172409090ba9d08975e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tooltip&lt;/code&gt; face determines the appearance of text shown in tooltips. It should generally use a variable-pitch font of size that is preferably smaller than the default frame font.</source>
          <target state="translated">&lt;code&gt;tooltip&lt;/code&gt; лицо определяет внешний вид текста , показанный в подсказках. Обычно следует использовать шрифт с переменным шагом, размер которого предпочтительно меньше, чем шрифт кадра по умолчанию.</target>
        </trans-unit>
        <trans-unit id="60eb5861f5cbed8659df08572852903a05d250cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;top-visible&lt;/code&gt; parameter specifies the number of pixels at the top of the frame that always remain visible within the parent&amp;rsquo;s native frame during dragging and should be set when specifying a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;drag-with-header-line&lt;/code&gt; parameter. The &lt;code&gt;bottom-visible&lt;/code&gt; parameter specifies the number of pixels at the bottom of the frame that always remain visible within the parent&amp;rsquo;s native frame during dragging and should be preferred when specifying a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;drag-with-mode-line&lt;/code&gt; parameter.</source>
          <target state="translated">Параметр &lt;code&gt;top-visible&lt;/code&gt; указывает количество пикселей в верхней части кадра, которые всегда остаются видимыми в собственном кадре родителя во время перетаскивания, и должен быть установлен при указании параметра &lt;code&gt;drag-with-header-line&lt;/code&gt; , отличного от &lt;code&gt;nil&lt;/code&gt; . Параметр &lt;code&gt;bottom-visible&lt;/code&gt; указывает количество пикселей в нижней части кадра, которые всегда остаются видимыми в собственном кадре родителя во время перетаскивания, и его следует использовать при указании параметра &lt;code&gt;drag-with-mode-line&lt;/code&gt; , отличного от &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e012f9c53fc17471a7a19403b675f18036df7992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track-mouse&lt;/code&gt; form causes Emacs to generate mouse motion events by binding the variable &lt;code&gt;track-mouse&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. If that variable has the special value &lt;code&gt;dragging&lt;/code&gt;, it additionally instructs the display engine to refrain from changing the shape of the mouse pointer. This is desirable in Lisp programs that require mouse dragging across large portions of Emacs display, which might otherwise cause the mouse pointer to change its shape according to the display portion it hovers on (see &lt;a href=&quot;pointer-shape#Pointer-Shape&quot;&gt;Pointer Shape&lt;/a&gt;). Therefore, Lisp programs that need the mouse pointer to retain its original shape during dragging should bind &lt;code&gt;track-mouse&lt;/code&gt; to the value &lt;code&gt;dragging&lt;/code&gt; at the beginning of their &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">Форма &lt;code&gt;track-mouse&lt;/code&gt; заставляет Emacs генерировать события движения мыши путем привязки переменной &lt;code&gt;track-mouse&lt;/code&gt; к &lt;code&gt;nil&lt;/code&gt; значению. Если эта переменная имеет специальное значение &lt;code&gt;dragging&lt;/code&gt; , она дополнительно указывает механизму отображения воздерживаться от изменения формы указателя мыши. Это желательно в программах на Лиспе, которые требуют перетаскивания мышью через большие части дисплея Emacs, что в противном случае могло бы вызвать изменение формы указателя мыши в соответствии с частью дисплея, на которой он наведен (см. &lt;a href=&quot;pointer-shape#Pointer-Shape&quot;&gt;Форма указателя&lt;/a&gt; ). Поэтому программы на Лиспе, которым требуется, чтобы указатель мыши сохранял свою исходную форму во время перетаскивания, должны привязать &lt;code&gt;track-mouse&lt;/code&gt; к значению &lt;code&gt;dragging&lt;/code&gt; в начале их &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b19edd674347d83642c768bcde88b949ac9815cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try-completion&lt;/code&gt; function is the basic primitive for completion: it returns the longest determined completion of a given initial string, with a given set of strings to match against.</source>
          <target state="translated">Функция &lt;code&gt;try-completion&lt;/code&gt; является основным примитивом для завершения: она возвращает наиболее длинное определенное завершение данной начальной строки с заданным набором строк для сопоставления.</target>
        </trans-unit>
        <trans-unit id="2f4b6ab7ad75f50c3944d9f90023bc41fff2a2c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unload-feature&lt;/code&gt; function is written in Lisp; its actions are based on the variable &lt;code&gt;load-history&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;unload-feature&lt;/code&gt; написана на Лиспе; его действия основаны на переменной &lt;code&gt;load-history&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7b26bfe3a503536b3db21d80937ae70a63a3b4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind-protect&lt;/code&gt; construct is essential whenever you temporarily put a data structure in an inconsistent state; it permits you to make the data consistent again in the event of an error or throw. (Another more specific cleanup construct that is used only for changes in buffer contents is the atomic change group; &lt;a href=&quot;atomic-changes#Atomic-Changes&quot;&gt;Atomic Changes&lt;/a&gt;.)</source>
          <target state="translated">Конструкция &lt;code&gt;unwind-protect&lt;/code&gt; важна всякий раз, когда вы временно переводите структуру данных в несогласованное состояние; это позволяет вам снова сделать данные согласованными в случае ошибки или сбоя. (Другая более конкретная конструкция очистки, которая используется только для изменений в содержимом буфера, - это группа атомарных изменений; &lt;a href=&quot;atomic-changes#Atomic-Changes&quot;&gt;атомарные изменения&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="2f49acd9789b7b2eeac22d067a11cc480fc012ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vconcat&lt;/code&gt; function also allows byte-code function objects as arguments. This is a special feature to make it easy to access the entire contents of a byte-code function object. See &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;vconcat&lt;/code&gt; также позволяет использовать объекты функции с байтовым кодом в качестве аргументов. Это специальная функция, упрощающая доступ ко всему содержимому объекта функции байт-кода. См. &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Объекты байтового кода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74475dab8b3d8a3c528caed3c11e831ed50eb48d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;window-start&lt;/code&gt; position in the buffer as of the last time the buffer was displayed in a window.</source>
          <target state="translated">&lt;code&gt;window-start&lt;/code&gt; положение в буфере , как в последний раз буфер отображается в окне.</target>
        </trans-unit>
        <trans-unit id="1c8c8bc7c8ca1829e5170cf2b088a497d991bd1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-case-table&lt;/code&gt; macro saves the current case table, makes &lt;var&gt;table&lt;/var&gt; the current case table, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores the case table. The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. The case table is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;with-case-table&lt;/code&gt; макро сохраняет текущую таблицу случая, делает &lt;var&gt;table&lt;/var&gt; текущей таблицу дела, оценивает &lt;var&gt;body&lt;/var&gt; формы, и , наконец , восстанавливает таблицу случая. Возвращаемое значение - это значение последней формы в &lt;var&gt;body&lt;/var&gt; . Таблица вариантов восстанавливается даже в случае аварийного выхода из-за &lt;code&gt;throw&lt;/code&gt; или ошибки (см. &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Нелокальные выходы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e3555312fd01da7949ec5e51b8d950b8aeb3bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-current-buffer&lt;/code&gt; macro saves the identity of the current buffer, makes &lt;var&gt;buffer-or-name&lt;/var&gt; current, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores the current buffer. &lt;var&gt;buffer-or-name&lt;/var&gt; must specify an existing buffer or the name of an existing buffer.</source>
          <target state="translated">&lt;code&gt;with-current-buffer&lt;/code&gt; макро сохраняет идентичность текущего буфера, делает &lt;var&gt;buffer-or-name&lt;/var&gt; ток, оценивает &lt;var&gt;body&lt;/var&gt; формы, и , наконец , восстанавливает текущий буфер. &lt;var&gt;buffer-or-name&lt;/var&gt; должен указывать существующий буфер или имя существующего буфера.</target>
        </trans-unit>
        <trans-unit id="6be74ef0912f083c42a192cd4080659f8c01b40c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-temp-buffer&lt;/code&gt; macro evaluates the &lt;var&gt;body&lt;/var&gt; forms with a temporary buffer as the current buffer. It saves the identity of the current buffer, creates a temporary buffer and makes it current, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores the previous current buffer while killing the temporary buffer. By default, undo information (see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;) is not recorded in the buffer created by this macro (but &lt;var&gt;body&lt;/var&gt; can enable that, if needed).</source>
          <target state="translated">&lt;code&gt;with-temp-buffer&lt;/code&gt; Макрокоманда оценивает &lt;var&gt;body&lt;/var&gt; формы с временным буфером в качестве текущего буфера. Он сохраняет идентификатор текущего буфера, создает временный буфер и делает его текущим, оценивает формы &lt;var&gt;body&lt;/var&gt; и, наконец, восстанавливает предыдущий текущий буфер, уничтожая временный буфер. По умолчанию информация об отмене (см. &lt;a href=&quot;undo#Undo&quot;&gt;Отмена&lt;/a&gt; ) не записывается в буфер, созданный этим макросом (но &lt;var&gt;body&lt;/var&gt; может включить это, если необходимо).</target>
        </trans-unit>
        <trans-unit id="85d2333f7e1dc8910f83232e2a64715d76356c35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-temp-file&lt;/code&gt; macro evaluates the &lt;var&gt;body&lt;/var&gt; forms with a temporary buffer as the current buffer; then, at the end, it writes the buffer contents into file &lt;var&gt;file&lt;/var&gt;. It kills the temporary buffer when finished, restoring the buffer that was current before the &lt;code&gt;with-temp-file&lt;/code&gt; form. Then it returns the value of the last form in &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;with-temp-file&lt;/code&gt; макро оценивает &lt;var&gt;body&lt;/var&gt; формы с временным буфером в качестве текущего буфера; затем, в конце, он записывает содержимое буфера в файл &lt;var&gt;file&lt;/var&gt; . По завершении он уничтожает временный буфер, восстанавливая буфер, который был текущим до формы &lt;code&gt;with-temp-file&lt;/code&gt; . Затем он возвращает значение последней формы в &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="75f491c1d7a86fd552f0176600f4381bb8cc0388" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;absolute position&lt;/em&gt; of a frame is given as a pair (X, Y) of horizontal and vertical pixel offsets relative to an origin (0, 0) of the frame&amp;rsquo;s display. Correspondingly, the &lt;em&gt;absolute edges&lt;/em&gt; of a frame are given as pixel offsets from that origin.</source>
          <target state="translated">&lt;em&gt;Абсолютное положение&lt;/em&gt; кадра задается в виде пары (X, Y) горизонтальных и вертикальных пикселей смещений относительно начала координат (0, 0) отображения кадра. Соответственно, &lt;em&gt;абсолютные края&lt;/em&gt; кадра задаются как пиксельные смещения от этого источника.</target>
        </trans-unit>
        <trans-unit id="9076db1171c8c8a5ca5175d7dfede3c98233cff3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;advice&lt;/em&gt; feature lets you add to the existing definition of a function, by &lt;em&gt;advising the function&lt;/em&gt;. This is a cleaner method than redefining the whole function.</source>
          <target state="translated">Функция &lt;em&gt;совета&lt;/em&gt; позволяет вам добавить к существующему определению функции, &lt;em&gt;рекомендуя функцию&lt;/em&gt; . Это более чистый метод, чем переопределение всей функции.</target>
        </trans-unit>
        <trans-unit id="904d222802ad2663ace2ad3097bbf68979ad4806" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;autoload&lt;/em&gt; facility lets you register the existence of a function or macro, but put off loading the file that defines it. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along. Autoloading can also be triggered by looking up the documentation of the function or macro (see &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;Documentation Basics&lt;/a&gt;), and completion of variable and function names (see &lt;a href=&quot;autoload-by-prefix#Autoload-by-Prefix&quot;&gt;Autoload by Prefix&lt;/a&gt; below).</source>
          <target state="translated">Средство &lt;em&gt;автозагрузки&lt;/em&gt; позволяет вам регистрировать существование функции или макроса, но откладывать загрузку файла, который их определяет. Первый вызов функции автоматически загружает соответствующую библиотеку, чтобы установить реальное определение и другой связанный код, а затем запускает реальное определение, как если бы оно было загружено все время. Автозагрузку также можно запустить, просмотрев документацию по функции или макросу (см. &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;Основы документации&lt;/a&gt; ) и завершив имена переменных и функций (см. &amp;laquo; &lt;a href=&quot;autoload-by-prefix#Autoload-by-Prefix&quot;&gt;Автозагрузка по префиксу&amp;raquo;&lt;/a&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="92e5c483eda768ffc040b45483dc57544c8342d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;autoload&lt;/em&gt; feature allows you to call a function or macro whose function definition has not yet been loaded into Emacs. It specifies which file contains the definition. When an autoload object appears as a symbol&amp;rsquo;s function definition, calling that symbol as a function automatically loads the specified file; then it calls the real definition loaded from that file. The way to arrange for an autoload object to appear as a symbol&amp;rsquo;s function definition is described in &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;em&gt;автозагрузки&lt;/em&gt; позволяет вам вызывать функцию или макрос, определение функции которых еще не было загружено в Emacs. Он указывает, какой файл содержит определение. Когда объект автозагрузки появляется как определение функции символа, вызов этого символа как функции автоматически загружает указанный файл; затем он вызывает настоящее определение, загруженное из этого файла. Способ организации отображения объекта автозагрузки в качестве определения функции символа описан в &lt;a href=&quot;autoload#Autoload&quot;&gt;разделе Автозагрузка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db7e415ee146c05de6c08823c26d0684fe6dbf60" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;body height&lt;/em&gt; of a window is the height of its text area, which does not include a mode or header line, a horizontal scroll bar, or a bottom divider.</source>
          <target state="translated">Высота &lt;em&gt;основного&lt;/em&gt; окна окна - это высота его текстовой области, которая не включает режим или строку заголовка, горизонтальную полосу прокрутки или нижний разделитель.</target>
        </trans-unit>
        <trans-unit id="217d247606dfc265df3143a5a2e96b2fb55c37ec" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;body width&lt;/em&gt; of a window is the width of its text area, which does not include the scroll bar, fringes, margins or a right divider. Note that when one or both fringes are removed (by setting their width to zero), the display engine reserves two character cells, one on each side of the window, for displaying the continuation and truncation glyphs, which leaves 2 columns less for text display. (The function &lt;code&gt;window-max-chars-per-line&lt;/code&gt;, described below, takes this peculiarity into account.)</source>
          <target state="translated">&lt;em&gt;Ширина тела&lt;/em&gt; окна ширина его текстовой области, которая не включает в себя полосу прокрутки, полосы, поля или правый делитель. Обратите внимание, что при удалении одной или обеих полос (путем установки их ширины на ноль) механизм отображения резервирует две символьные ячейки, по одной с каждой стороны окна, для отображения глифов продолжения и усечения, что оставляет на 2 столбца меньше для отображения текста. . (Функция &lt;code&gt;window-max-chars-per-line&lt;/code&gt; , описанная ниже, учитывает эту особенность.)</target>
        </trans-unit>
        <trans-unit id="5097ffd7cf46ae9c24a40f48668d84137f1efbad" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;buffer file name&lt;/em&gt; is the name of the file that is visited in that buffer. When a buffer is not visiting a file, its buffer file name is &lt;code&gt;nil&lt;/code&gt;. Most of the time, the buffer name is the same as the nondirectory part of the buffer file name, but the buffer file name and the buffer name are distinct and can be set independently. See &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Visiting Files&lt;/a&gt;.</source>
          <target state="translated">Имя &lt;em&gt;файла буфера&lt;/em&gt; - это имя файла, который посещается в этом буфере. Когда буфер не обращается к файлу, его имя файла буфера равно &lt;code&gt;nil&lt;/code&gt; . В большинстве случаев имя буфера совпадает с не относящейся к каталогу частью имени файла буфера, но имя файла буфера и имя буфера различны и могут быть установлены независимо. См. &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Посещение файлов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9edbfee6ba6e0df8bcbbec78b92592c29e802ba7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;buffer list&lt;/em&gt; is a list of all live buffers. The order of the buffers in this list is based primarily on how recently each buffer has been displayed in a window. Several functions, notably &lt;code&gt;other-buffer&lt;/code&gt;, use this ordering. A buffer list displayed for the user also follows this order.</source>
          <target state="translated">Список &lt;em&gt;буферов&lt;/em&gt; - это список всех активных буферов. Порядок буферов в этом списке в первую очередь зависит от того, как давно каждый буфер отображался в окне. Некоторые функции, в частности &lt;code&gt;other-buffer&lt;/code&gt; , используют этот порядок. Список буферов, отображаемый для пользователя, также следует в этом порядке.</target>
        </trans-unit>
        <trans-unit id="28c38d051cd80da945d60773cba7daf700f65577" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;corresponding element&lt;/em&gt; is the portion of &lt;var&gt;expval&lt;/var&gt; that is in the same structural position as the structural position of &lt;var&gt;qpat&lt;/var&gt; in the backquote-style pattern. (In the example above, the corresponding element of &lt;code&gt;second-elem&lt;/code&gt; is the second element of &lt;var&gt;expval&lt;/var&gt;.)</source>
          <target state="translated">&lt;em&gt;, Соответствующий элемент&lt;/em&gt; представляет собой часть &lt;var&gt;expval&lt;/var&gt; , что находится в том же положении, что и структурном структурная позиции &lt;var&gt;qpat&lt;/var&gt; в шаблоне стиля кавычки. (В приведенном выше примере соответствующий элемент &lt;code&gt;second-elem&lt;/code&gt; является вторым элементом &lt;var&gt;expval&lt;/var&gt; .)</target>
        </trans-unit>
        <trans-unit id="e246a752a97b0685bf65ee14255ff2c4d2e678d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;echo area&lt;/em&gt; is used for displaying error messages (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;), for messages made with the &lt;code&gt;message&lt;/code&gt; primitive, and for echoing keystrokes. It is not the same as the minibuffer, despite the fact that the minibuffer appears (when active) in the same place on the screen as the echo area. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer.html#Minibuffer&quot;&gt;The Minibuffer&lt;/a&gt; in</source>
          <target state="translated">&lt;em&gt;Область эха&lt;/em&gt; используется для отображения сообщений об ошибках (см &lt;a href=&quot;errors#Errors&quot;&gt;ошибки&lt;/a&gt; ), для сообщений , сделанных с &lt;code&gt;message&lt;/code&gt; примитивным, и вторя нажатия клавиш. Это не то же самое, что минибуфер, несмотря на то, что минибуфер появляется (когда он активен) в том же месте на экране, что и эхо-область. См &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer.html#Minibuffer&quot;&gt;. Минибуфер&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="f3ea9e34e06d750f6249582c09adfb2b14c104be" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;evaluation&lt;/em&gt; of expressions in Emacs Lisp is performed by the &lt;em&gt;Lisp interpreter&lt;/em&gt;&amp;mdash;a program that receives a Lisp object as input and computes its &lt;em&gt;value as an expression&lt;/em&gt;. How it does this depends on the data type of the object, according to rules described in this chapter. The interpreter runs automatically to evaluate portions of your program, but can also be called explicitly via the Lisp primitive function &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Оценка&lt;/em&gt; выражений в Emacs Lisp выполняется &lt;em&gt;интерпретатором Лисп&lt;/em&gt; -a программы , которая получает объект лисповского в качестве входных данных и вычисляет его &lt;em&gt;значение как выражение&lt;/em&gt; . Как это происходит, зависит от типа данных объекта в соответствии с правилами, описанными в этой главе. Интерпретатор запускается автоматически для оценки частей вашей программы, но также может вызываться явно через примитивную функцию Лиспа &lt;code&gt;eval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4c54835a8ed7b0637b2955ac97e3f976fc948b0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;external border&lt;/em&gt; is part of the decorations supplied by the window manager. It is typically used for resizing the frame with the mouse and is therefore not shown on &amp;ldquo;fullboth&amp;rdquo; and maximized frames (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;). Its width is determined by the window manager and cannot be changed by Emacs&amp;rsquo; functions.</source>
          <target state="translated">&lt;em&gt;Внешняя граница&lt;/em&gt; является частью декораций , поставляемых менеджером окон. Обычно он используется для изменения размера кадра с помощью мыши и поэтому не отображается на &amp;laquo;полных&amp;raquo; и развернутых кадрах (см. &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Параметры размера&lt;/a&gt; ). Его ширина определяется оконным менеджером и не может быть изменена функциями Emacs.</target>
        </trans-unit>
        <trans-unit id="f2d8bed44c2c20c17f4bf773118cf6698d61845b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fringe bitmaps&lt;/em&gt; are the actual bitmaps which represent the logical fringe indicators for truncated or continued lines, buffer boundaries, overlay arrows, etc. Each bitmap is represented by a symbol. These symbols are referred to by the variable &lt;code&gt;fringe-indicator-alist&lt;/code&gt;, which maps fringe indicators to bitmaps (see &lt;a href=&quot;fringe-indicators#Fringe-Indicators&quot;&gt;Fringe Indicators&lt;/a&gt;), and the variable &lt;code&gt;fringe-cursor-alist&lt;/code&gt;, which maps fringe cursors to bitmaps (see &lt;a href=&quot;fringe-cursors#Fringe-Cursors&quot;&gt;Fringe Cursors&lt;/a&gt;).</source>
          <target state="translated">В &lt;em&gt;бахрома растровых изображениями&lt;/em&gt; являются фактическими растровыми изображениями , которые представляют собой логические показатели бахромы для усеченных или непрерывных линий, буфер границы, наложенные стрелки и т.д. Каждый точечный рисунок представлен символом. На эти символы ссылаются переменная &lt;code&gt;fringe-indicator-alist&lt;/code&gt; , которая отображает индикаторы краев на растровые изображения (см. &lt;a href=&quot;fringe-indicators#Fringe-Indicators&quot;&gt;Индикаторы краев&lt;/a&gt; ), и переменная &lt;code&gt;fringe-cursor-alist&lt;/code&gt; , которая отображает курсоры краев в растровые изображения (см. &lt;a href=&quot;fringe-cursors#Fringe-Cursors&quot;&gt;Курсоры краев&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3217775f22c68286c9e9e2ce3e64e15e557ece9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;function definition&lt;/em&gt; of a symbol is the object stored in the function cell of the symbol. The functions described here access, test, and set the function cell of symbols.</source>
          <target state="translated">Определение &lt;em&gt;функции&lt;/em&gt; символа - это объект, хранящийся в функциональной ячейке символа. Описанные здесь функции осуществляют доступ, тестируют и задают функциональную ячейку символов.</target>
        </trans-unit>
        <trans-unit id="e263e404107701ba2e2127c05d30319797f11c39" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;inner frame&lt;/em&gt; is the rectangle reserved for the frame&amp;rsquo;s windows. It&amp;rsquo;s enclosed by the internal border which, however, is not part of the inner frame. Its edges are called the &lt;em&gt;inner edges&lt;/em&gt; of the frame. The &lt;em&gt;inner width&lt;/em&gt; and &lt;em&gt;inner height&lt;/em&gt; specify the &lt;em&gt;inner size&lt;/em&gt; of the rectangle. The inner frame is sometimes also referred to as the &lt;em&gt;display area&lt;/em&gt; of the frame.</source>
          <target state="translated">&lt;em&gt;Внутренний каркас&lt;/em&gt; представляет собой прямоугольник , зарезервированный для окон фрейма. Он заключен во внутреннюю рамку, которая, однако, не является частью внутренней рамки. Его края называются &lt;em&gt;внутренними краями&lt;/em&gt; рамы. &lt;em&gt;Внутренняя ширина&lt;/em&gt; и &lt;em&gt;внутренняя высота&lt;/em&gt; указать &lt;em&gt;внутренний размер&lt;/em&gt; прямоугольника. Внутренний фрейм иногда также называют &lt;em&gt;областью отображения&lt;/em&gt; фрейма.</target>
        </trans-unit>
        <trans-unit id="5a74065a844b2999c1d678863c486ee2bfa66178" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;native frame&lt;/em&gt; is a rectangle located entirely within the outer frame. It excludes the areas occupied by an external or outer border, the title bar and any external menu or tool bar. The edges of the native frame are called the &lt;em&gt;native edges&lt;/em&gt; of the frame. Together, the &lt;em&gt;native width&lt;/em&gt; and &lt;em&gt;native height&lt;/em&gt; of a frame specify the &lt;em&gt;native size&lt;/em&gt; of the frame.</source>
          <target state="translated">Собственная &lt;em&gt;рамка&lt;/em&gt; представляет собой прямоугольник, полностью расположенный внутри внешней рамки. Он исключает области, занятые внешней или внешней границей, строкой заголовка и любым внешним меню или панелью инструментов. Края собственной рамки называются &lt;em&gt;собственными краями&lt;/em&gt; рамки. Вместе &lt;em&gt;собственная ширина&lt;/em&gt; и &lt;em&gt;собственная высота&lt;/em&gt; фрейма определяют &lt;em&gt;собственный размер&lt;/em&gt; фрейма.</target>
        </trans-unit>
        <trans-unit id="ae4cf0b922d8647c81dfc51bc033d154bb0b9c1e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nice value&lt;/em&gt; of the process, a number. (Processes with smaller nice values get scheduled more favorably.)</source>
          <target state="translated">&lt;em&gt;Хорошее значение&lt;/em&gt; процесса, число. (Процессы с меньшими значениями nice планируются более благоприятно.)</target>
        </trans-unit>
        <trans-unit id="2c09e0fcd64a13f02c8fe447c36039473c0ce853" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;outer border&lt;/em&gt; is a separate border whose width can be specified with the &lt;code&gt;border-width&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). In practice, either the external or the outer border of a frame are displayed but never both at the same time. Usually, the outer border is shown only for special frames that are not (fully) controlled by the window manager like tooltip frames (see &lt;a href=&quot;tooltips#Tooltips&quot;&gt;Tooltips&lt;/a&gt;), child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and &lt;code&gt;undecorated&lt;/code&gt; or &lt;code&gt;override-redirect&lt;/code&gt; frames (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Внешняя граница&lt;/em&gt; представляет собой отдельную границу, ширина которой может быть задана с &lt;code&gt;border-width&lt;/code&gt; параметра кадра (см &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout параметров&lt;/a&gt; ). На практике отображается либо внешняя, либо внешняя граница фрейма, но никогда обе одновременно. Обычно внешняя граница отображается только для специальных фреймов, которые (полностью) не контролируются оконным менеджером, например фреймы всплывающих подсказок (см. &lt;a href=&quot;tooltips#Tooltips&quot;&gt;Всплывающие подсказки&lt;/a&gt; ), дочерние фреймы (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ) и фреймы &lt;code&gt;undecorated&lt;/code&gt; или &lt;code&gt;override-redirect&lt;/code&gt; (см. &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Параметры управления&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a16135456343ff9bfb76f420c809a82672446af" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;outer frame&lt;/em&gt; is a rectangle comprising all areas shown in the drawing. The edges of that rectangle are called the &lt;em&gt;outer edges&lt;/em&gt; of the frame. Together, the &lt;em&gt;outer width&lt;/em&gt; and &lt;em&gt;outer height&lt;/em&gt; of the frame specify the &lt;em&gt;outer size&lt;/em&gt; of that rectangle.</source>
          <target state="translated">&lt;em&gt;Внешняя рама&lt;/em&gt; представляет собой прямоугольник , содержащий все области , показанные на чертеже. Края этого прямоугольника называются &lt;em&gt;внешними краями&lt;/em&gt; кадра. Вместе &lt;em&gt;внешняя ширина&lt;/em&gt; и &lt;em&gt;внешняя высота&lt;/em&gt; рамки определяют &lt;em&gt;внешний размер&lt;/em&gt; этого прямоугольника.</target>
        </trans-unit>
        <trans-unit id="63a8b7096512c8aa2271f3f9850a19c72d70184b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;overlay arrow&lt;/em&gt; is useful for directing the user&amp;rsquo;s attention to a particular line in a buffer. For example, in the modes used for interface to debuggers, the overlay arrow indicates the line of code about to be executed. This feature has nothing to do with &lt;em&gt;overlays&lt;/em&gt; (see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Наложения стрелка&lt;/em&gt; полезна для направления внимания пользователя к конкретной строке в буфере. Например, в режимах, используемых для взаимодействия с отладчиками, стрелка наложения указывает строку кода, которая должна быть выполнена. Эта функция не имеет ничего общего с &lt;em&gt;наложениями&lt;/em&gt; (см. &lt;a href=&quot;overlays#Overlays&quot;&gt;Оверлеи&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d788001216c640953c68e8a1fd972cb556924b6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;printable &lt;acronym&gt;ASCII&lt;/acronym&gt; characters&lt;/em&gt;, character codes 32 through 126 (consisting of numerals, English letters, and symbols like &amp;lsquo;</source>
          <target state="translated">В &lt;em&gt;печатаемые &lt;acronym&gt;ASCII&lt;/acronym&gt; символы&lt;/em&gt; , коды символов 32 через 126 (состоящий из цифр, латинских букв и символов , как &quot;</target>
        </trans-unit>
        <trans-unit id="ee5f0d9d7366f64e692b08bd6bdd53cffd9ff956" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;printed representation&lt;/em&gt; of an object is the format of the output generated by the Lisp printer (the function &lt;code&gt;prin1&lt;/code&gt;) for that object. Every data type has a unique printed representation. The &lt;em&gt;read syntax&lt;/em&gt; of an object is the format of the input accepted by the Lisp reader (the function &lt;code&gt;read&lt;/code&gt;) for that object. This is not necessarily unique; many kinds of object have more than one syntax. See &lt;a href=&quot;read-and-print#Read-and-Print&quot;&gt;Read and Print&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Выводимое представление&lt;/em&gt; объекта является форматом выходного сигнала , генерируемого принтером лисповского (функция &lt;code&gt;prin1&lt;/code&gt; ) для этого объекта. Каждый тип данных имеет уникальное печатное представление. &lt;em&gt;Синтаксис для чтения&lt;/em&gt; объекта является форматом ввода , принятого читателем лисповского (функция &lt;code&gt;read&lt;/code&gt; ) для этого объекта. Это не обязательно уникально; многие типы объектов имеют более одного синтаксиса. См. &lt;a href=&quot;read-and-print#Read-and-Print&quot;&gt;Чтение и печать&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16283fc66bc938541ae5f94a57f5db7f82024d76" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sequence&lt;/em&gt; type is the union of two other Lisp types: lists and arrays. In other words, any list is a sequence, and any array is a sequence. The common property that all sequences have is that each is an ordered collection of elements.</source>
          <target state="translated">Тип &lt;em&gt;последовательности&lt;/em&gt; - это объединение двух других типов Лиспа: списков и массивов. Другими словами, любой список - это последовательность, а любой массив - это последовательность. Общим свойством всех последовательностей является то, что каждая из них представляет собой упорядоченный набор элементов.</target>
        </trans-unit>
        <trans-unit id="26bbe6f8407610c43aa3bfb4d0e5236a34a2cd8d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;syntax class&lt;/em&gt; of a character describes its syntactic role. Each syntax table specifies the syntax class of each character. There is no necessary relationship between the class of a character in one syntax table and its class in any other table.</source>
          <target state="translated">Класс &lt;em&gt;синтаксиса&lt;/em&gt; символа описывает его синтаксическую роль. Каждая таблица синтаксиса определяет класс синтаксиса каждого символа. Нет обязательной связи между классом символа в одной таблице синтаксиса и его классом в любой другой таблице.</target>
        </trans-unit>
        <trans-unit id="926a41bf96866251570aab9ee4f7d77e1444ba77" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;text area&lt;/em&gt; of a frame is a somewhat fictitious area that can be embedded in the native frame. Its position is unspecified. Its width can be obtained by removing from that of the native width the widths of the internal border, one vertical scroll bar, and one left and one right fringe if they are specified for this frame, see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;. Its height can be obtained by removing from that of the native height the widths of the internal border and the heights of the frame&amp;rsquo;s internal menu and tool bars and one horizontal scroll bar if specified for this frame.</source>
          <target state="translated">&lt;em&gt;Текстовая область&lt;/em&gt; кадра является несколько фиктивной областью , которая может быть встроена в родной раме. Его положение не указано. Его ширину можно получить, удалив из исходной ширины ширину внутренней границы, одной вертикальной полосы прокрутки, а также одной левой и одной правой кромок, если они указаны для этого кадра, см. &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Параметры макета&lt;/a&gt; . Его высоту можно получить, удалив из исходной высоты ширину внутренней границы и высоту внутреннего меню и панелей инструментов фрейма, а также одну горизонтальную полосу прокрутки, если она указана для этого фрейма.</target>
        </trans-unit>
        <trans-unit id="cc567aa0f13044eee99b9583effa6fce58743091" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;title bar&lt;/em&gt;, a.k.a. &lt;em&gt;caption bar&lt;/em&gt;, is also part of the window manager&amp;rsquo;s decorations and typically displays the title of the frame (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;) as well as buttons for minimizing, maximizing and deleting the frame. It can be also used for dragging the frame with the mouse. The title bar is usually not displayed for fullboth (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;), tooltip (see &lt;a href=&quot;tooltips#Tooltips&quot;&gt;Tooltips&lt;/a&gt;) and child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and doesn&amp;rsquo;t exist for terminal frames. Display of the title bar can be suppressed by setting the &lt;code&gt;override-redirect&lt;/code&gt; or the &lt;code&gt;undecorated&lt;/code&gt; frame parameters (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Строка заголовка&lt;/em&gt; , иначе &lt;em&gt;заголовок бар&lt;/em&gt; , также является частью украшения оконного менеджера и , как правило , отображает заголовок кадра (см &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;заголовков фреймов&lt;/a&gt; ), а также кнопки для минимизации, максимизации и удаления кадра. Его также можно использовать для перетаскивания рамки мышью. Строка заголовка обычно не отображается для обоих (см. &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Параметры размера&lt;/a&gt; ), всплывающей подсказки (см. &lt;a href=&quot;tooltips#Tooltips&quot;&gt;Всплывающие подсказки&lt;/a&gt; ) и дочерних фреймов (см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; ) и не существует для оконечных фреймов. Отображение строки заголовка можно подавить, установив параметры &lt;code&gt;override-redirect&lt;/code&gt; или параметры кадра &lt;code&gt;undecorated&lt;/code&gt; (см. &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Параметры управления&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf5061df863bf4d7e25945860733704a7f478bc7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;total height&lt;/em&gt; of a window is the number of lines comprising the window&amp;rsquo;s body, the header line, the horizontal scroll bar, the mode line and the bottom divider (if any).</source>
          <target state="translated">&lt;em&gt;Общая высота&lt;/em&gt; окна есть число строк , содержащих тело окна, строку заголовка, горизонтальную полосу прокрутки, режим линии и нижний разделитель (если таковые имеются).</target>
        </trans-unit>
        <trans-unit id="df7776a34012721e685782936a52e8dfef11825e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;total width&lt;/em&gt; of a window is the number of lines comprising the window&amp;rsquo;s body, its margins, fringes, scroll bars and a right divider (if any).</source>
          <target state="translated">&lt;em&gt;Общая ширина&lt;/em&gt; окна есть число строк , содержащих тело окна, его поля, полосы, полосы прокрутки и правый делитель (если таковые имеются).</target>
        </trans-unit>
        <trans-unit id="0a4f1e482e03cd1786491328f05f6a3a541b8f00" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;truename&lt;/em&gt; of a file is the name that you get by following symbolic links at all levels until none remain, then simplifying away &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;TRUENAME&lt;/em&gt; файла это имя , которое вы получите, следуя символические ссылки на всех уровнях , пока никто не останется, то упрощая прочь '</target>
        </trans-unit>
        <trans-unit id="5a368df5a1b8c9ef35e252db40eaf9e6300e7992" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;use time&lt;/em&gt; of a window is not really a time value, but an integer that does increase monotonically with each call of &lt;code&gt;select-window&lt;/code&gt; with a &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;norecord&lt;/var&gt; argument. The window with the lowest use time is usually called the least recently used window while the window with the highest use time is called the most recently used one (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">Время &lt;em&gt;использования&lt;/em&gt; окна на самом деле не является значением времени, а целым числом, которое монотонно увеличивается с каждым вызовом &lt;code&gt;select-window&lt;/code&gt; с аргументом &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;norecord&lt;/var&gt; . Окно с наименьшим временем использования обычно называется окном с наименьшим временем использования, а окно с наибольшим временем использования называется окном, которое использовалось последним (см. &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Циклический порядок окон&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5970313ec78081de0b5e6fa3c17cbcb799a07f06" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;window state change flag&lt;/em&gt; of a frame, if set, will cause the default values of &lt;code&gt;window-state-change-functions&lt;/code&gt; (for that frame) and &lt;code&gt;window-state-change-hook&lt;/code&gt; to be run during next redisplay regardless of whether a window state change actually occurred for that frame or not. After running any functions on these hooks, the flag is reset for each frame. Applications can set that flag and inspect its value using the following functions.</source>
          <target state="translated">&lt;em&gt;Флаг изменения состояния окна&lt;/em&gt; кадра, если установлены, будет вызывать значения по умолчанию &lt;code&gt;window-state-change-functions&lt;/code&gt; (для этого кадра) и &lt;code&gt;window-state-change-hook&lt;/code&gt; будет работать в течение следующей перерисовки независимо от состояния окна изменение действительно произошло для этого кадра или нет. После запуска любых функций на этих хуках флаг сбрасывается для каждого кадра. Приложения могут установить этот флаг и проверить его значение с помощью следующих функций.</target>
        </trans-unit>
        <trans-unit id="4d16338fb95ab07992fcf2621cd0fa8dac537741" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt; of each entry of this alist is a symbol specifying the parameter. The &lt;small&gt;CDR&lt;/small&gt; should be one of the following:</source>
          <target state="translated">&lt;small&gt;CAR&lt;/small&gt; каждой записи этого ALIST является символом указания параметра. &lt;small&gt;CDR&lt;/small&gt; должен быть один из следующих:</target>
        </trans-unit>
        <trans-unit id="e49ce88f5cd8792ee1a6675c8d5cc998d7f16094" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;characters&lt;/var&gt;, can be either a character or a string. The element says to give that character or characters the syntax specified by &lt;var&gt;syntax-description&lt;/var&gt;, which is passed to &lt;code&gt;modify-syntax-entry&lt;/code&gt; (see &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;).</source>
          <target state="translated">&lt;small&gt;CAR&lt;/small&gt; , &lt;var&gt;characters&lt;/var&gt; могут быть либо символ или строку. В элементе говорится, что этому символу или символам нужно присвоить синтаксис, указанный в &lt;var&gt;syntax-description&lt;/var&gt; , который передается в команду &lt;code&gt;modify-syntax-entry&lt;/code&gt; (см. &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Функции таблицы синтаксиса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="080c3e614f7fb18227cc5998f98d3b818d3afa14" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;item-string&lt;/var&gt;, is the string to be displayed in the menu. It should be short&amp;mdash;preferably one to three words. It should describe the action of the command it corresponds to. Note that not all graphical toolkits can display non-</source>
          <target state="translated">&lt;small&gt;CAR&lt;/small&gt; , &lt;var&gt;item-string&lt;/var&gt; , это строка , которая будет отображаться в меню. Оно должно быть коротким - желательно от одного до трех слов. Он должен описывать действие команды, которой он соответствует. Обратите внимание, что не все графические инструменты могут отображать не-</target>
        </trans-unit>
        <trans-unit id="e0a23dd8d612c78e404d710bcf5dfd6ed67ae9dd" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;option&lt;/var&gt;, is a string, the name of a command-line option (including the initial hyphen). The &lt;var&gt;handler-function&lt;/var&gt; is called to handle &lt;var&gt;option&lt;/var&gt;, and receives the option name as its sole argument.</source>
          <target state="translated">&lt;small&gt;CAR&lt;/small&gt; , &lt;var&gt;option&lt;/var&gt; , это строка, имя параметра командной строки (включая начальный дефис). Функция- &lt;var&gt;handler-function&lt;/var&gt; вызывается для обработки &lt;var&gt;option&lt;/var&gt; и получает имя параметра в качестве единственного аргумента.</target>
        </trans-unit>
        <trans-unit id="a7747b7d0b978aa494fc040c28ed49005a49fbd7" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;subexp&lt;/var&gt;, is an integer specifying which subexpression of the match to fontify (0 means the entire matching text). The second subelement, &lt;var&gt;facespec&lt;/var&gt;, is an expression whose value specifies the face, as described above.</source>
          <target state="translated">&lt;small&gt;АВТОМОБИЛЯ&lt;/small&gt; , &lt;var&gt;subexp&lt;/var&gt; , представляет собой целое число , указывающее какой Подвыражение матча с раскрасить (0 означает , что весь соответствующий текст). Второй подэлемент, &lt;var&gt;facespec&lt;/var&gt; , - это выражение, значение которого определяет лицо, как описано выше.</target>
        </trans-unit>
        <trans-unit id="fbe99fb685d5b20fe0da1df63eb118ad684010c5" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CDR&lt;/small&gt; of the element, &lt;var&gt;coding&lt;/var&gt;, should be either a coding system, a cons cell containing two coding systems, or a function name (a symbol with a function definition). If &lt;var&gt;coding&lt;/var&gt; is a coding system, that coding system is used for both reading the file and writing it. If &lt;var&gt;coding&lt;/var&gt; is a cons cell containing two coding systems, its &lt;small&gt;CAR&lt;/small&gt; specifies the coding system for decoding, and its &lt;small&gt;CDR&lt;/small&gt; specifies the coding system for encoding.</source>
          <target state="translated">&lt;small&gt;CDR&lt;/small&gt; элемента, &lt;var&gt;coding&lt;/var&gt; , должен быть либо система кодирования, ячейка , содержащая две минусы системы кодирования, или имя функции (символ с определением функции). Если &lt;var&gt;coding&lt;/var&gt; - это система кодирования, эта система кодирования используется как для чтения файла, так и для его записи. Если &lt;var&gt;coding&lt;/var&gt; - это cons-ячейка, содержащая две системы кодирования, ее &lt;small&gt;CAR&lt;/small&gt; определяет систему кодирования для декодирования, а ее &lt;small&gt;CDR&lt;/small&gt; определяет систему кодирования для кодирования.</target>
        </trans-unit>
        <trans-unit id="eadcb8d9ac867b4bc1c3959f1bb9e74b5fc964c3" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;GNU&lt;/small&gt;&lt;code&gt;Coreutils&lt;/code&gt; Manual</source>
          <target state="translated">&lt;small&gt;GNU &lt;/small&gt; &lt;code&gt;Coreutils&lt;/code&gt; Руководство</target>
        </trans-unit>
        <trans-unit id="8b3d5cecab4d963718b0a6b6d47d896d90a339da" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;action&lt;/var&gt; argument.</source>
          <target state="translated">&lt;var&gt;action&lt;/var&gt; аргумент.</target>
        </trans-unit>
        <trans-unit id="4bcf2fda42e12989ef3ca0c11552c2b31eccd611" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;align&lt;/var&gt; argument may also be a list &lt;code&gt;(&lt;var&gt;align&lt;/var&gt;
&lt;var&gt;periodic&lt;/var&gt;)&lt;/code&gt; where &lt;var&gt;align&lt;/var&gt; is interpreted as described above. If &lt;var&gt;periodic&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it specifies that the rows in &lt;code&gt;bits&lt;/code&gt; should be repeated enough times to reach the specified height.</source>
          <target state="translated">&lt;var&gt;align&lt;/var&gt; аргумент может также быть списком &lt;code&gt;(&lt;var&gt;align&lt;/var&gt; &lt;var&gt;periodic&lt;/var&gt;)&lt;/code&gt; , где &lt;var&gt;align&lt;/var&gt; интерпретируется как описано выше. Если &lt;var&gt;periodic&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , он указывает, что строки в &lt;code&gt;bits&lt;/code&gt; должны повторяться достаточно раз, чтобы достичь указанной высоты.</target>
        </trans-unit>
        <trans-unit id="b05c56c38c737d0175513c9a788605ea9cfba32d" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;array&lt;/var&gt; should be mutable. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;array&lt;/var&gt; должен быть изменяемым. См. &quot; &lt;a href=&quot;mutability#Mutability&quot;&gt;Изменчивость&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2eff832af67f0f23474068445f337e5f973d50b5" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;body&lt;/var&gt; forms should not use the minibuffer more than once. If the minibuffer is re-entered recursively, &lt;var&gt;function&lt;/var&gt; will only be called once, for the outermost use of the minibuffer.</source>
          <target state="translated">В &lt;var&gt;body&lt;/var&gt; форма не должен использовать минибуфер более чем один раз. Если рекурсивно повторно войти в минибуфер, &lt;var&gt;function&lt;/var&gt; будет вызываться только один раз для самого внешнего использования минибуфера.</target>
        </trans-unit>
        <trans-unit id="25d40a90977bab6a7277cfccfa36bab3a91341d9" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;body&lt;/var&gt; is inspected at compilation time, and only the symbols that appear in &lt;var&gt;body&lt;/var&gt; with a &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; проверяются во время компиляции, а только символы , которые появляются в &lt;var&gt;body&lt;/var&gt; с &quot;</target>
        </trans-unit>
        <trans-unit id="cd761e030f558aabcde6ca15db330bae7e53acff" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;buffer-or-name&lt;/var&gt; and &lt;var&gt;norecord&lt;/var&gt; arguments have the same meanings as in &lt;code&gt;switch-to-buffer&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;buffer-or-name&lt;/var&gt; и &lt;var&gt;norecord&lt;/var&gt; аргументы имеют то же значение , как в &lt;code&gt;switch-to-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88e2285bcf064744d6763e2dc89f7fc8ba369a0d" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;buffer&lt;/var&gt; argument is the buffer to associate with the connection. Output from the connection is inserted in the buffer, unless you specify your own filter function to handle the output. If &lt;var&gt;buffer&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it means that the connection is not associated with any buffer.</source>
          <target state="translated">&lt;var&gt;buffer&lt;/var&gt; аргумент является буфером для связывания с соединением. Вывод из соединения вставляется в буфер, если вы не укажете собственную функцию фильтра для обработки вывода. Если &lt;var&gt;buffer&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , это означает, что соединение не связано ни с каким буфером.</target>
        </trans-unit>
        <trans-unit id="19573e4fe6e8797ca8d2698b89b9d56ef0deda57" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;cipher&lt;/var&gt; can be the whole plist from &lt;code&gt;gnutls-ciphers&lt;/code&gt;, or just the symbol key, or a string with the name of that symbol.</source>
          <target state="translated">&lt;var&gt;cipher&lt;/var&gt; может быть вся PLIST от &lt;code&gt;gnutls-ciphers&lt;/code&gt; , или просто символ ключа, или строка с именем этого символа.</target>
        </trans-unit>
        <trans-unit id="9358734f2ec35fb2f2572d67721cdbdbe0a84b23" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;contents&lt;/var&gt; of a register can have several possible types:</source>
          <target state="translated">В &lt;var&gt;contents&lt;/var&gt; из регистра может иметь несколько возможных типов:</target>
        </trans-unit>
        <trans-unit id="6901063123b348019b3ef01026e7a9347a9f0aad" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;count&lt;/var&gt; argument can be a cons cell, &lt;code&gt;(&lt;var&gt;cols&lt;/var&gt;
. &lt;var&gt;lines&lt;/var&gt;)&lt;/code&gt;, instead of an integer. Then the function moves by &lt;var&gt;lines&lt;/var&gt; screen lines, and puts point &lt;var&gt;cols&lt;/var&gt; columns from the visual start of that screen line. Note that &lt;var&gt;cols&lt;/var&gt; are counted from the &lt;em&gt;visual&lt;/em&gt; start of the line; if the window is scrolled horizontally (see &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;Horizontal Scrolling&lt;/a&gt;), the column on which point will end is in addition to the number of columns by which the text is scrolled.</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; аргумент может быть против клеток, &lt;code&gt;(&lt;var&gt;cols&lt;/var&gt; . &lt;var&gt;lines&lt;/var&gt;)&lt;/code&gt; , а не целое число. Тогда функция перемещается по &lt;var&gt;lines&lt;/var&gt; строк экрана, и ставит точку &lt;var&gt;cols&lt;/var&gt; столбцы из визуального начала этого экрана линии. Обратите внимание, что &lt;var&gt;cols&lt;/var&gt; отсчитываются от &lt;em&gt;визуального&lt;/em&gt; начала строки; если окно прокручивается по горизонтали (см. &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;Горизонтальная прокрутка&lt;/a&gt; ), столбец, на котором заканчивается точка, добавляется к количеству столбцов, по которым прокручивается текст.</target>
        </trans-unit>
        <trans-unit id="f2ad21d8232e7c9573096d6fec09010bbae18135" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;data-type&lt;/var&gt; argument specifies the form of data conversion to use, to convert the raw data obtained from another program into Lisp data. Meaningful values include &lt;code&gt;TEXT&lt;/code&gt;, &lt;code&gt;STRING&lt;/code&gt;, &lt;code&gt;UTF8_STRING&lt;/code&gt;, &lt;code&gt;TARGETS&lt;/code&gt;, &lt;code&gt;LENGTH&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;FILE_NAME&lt;/code&gt;, &lt;code&gt;CHARACTER_POSITION&lt;/code&gt;, &lt;code&gt;NAME&lt;/code&gt;, &lt;code&gt;LINE_NUMBER&lt;/code&gt;, &lt;code&gt;COLUMN_NUMBER&lt;/code&gt;, &lt;code&gt;OWNER_OS&lt;/code&gt;, &lt;code&gt;HOST_NAME&lt;/code&gt;, &lt;code&gt;USER&lt;/code&gt;, &lt;code&gt;CLASS&lt;/code&gt;, &lt;code&gt;ATOM&lt;/code&gt;, and &lt;code&gt;INTEGER&lt;/code&gt;. (These are symbols with upper-case names in accord with X conventions.) The default for &lt;var&gt;data-type&lt;/var&gt; is &lt;code&gt;STRING&lt;/code&gt;. Window systems other than X usually support only a small subset of these types, in addition to &lt;code&gt;STRING&lt;/code&gt;.</source>
          <target state="translated">Эти &lt;var&gt;data-type&lt;/var&gt; аргумент определяет форму преобразования данных для использования, чтобы преобразовать необработанные данные , полученные из другой программы в данные Лиспа. Значимые значения включают &lt;code&gt;TEXT&lt;/code&gt; , &lt;code&gt;STRING&lt;/code&gt; , &lt;code&gt;UTF8_STRING&lt;/code&gt; , &lt;code&gt;TARGETS&lt;/code&gt; , &lt;code&gt;LENGTH&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;FILE_NAME&lt;/code&gt; , &lt;code&gt;CHARACTER_POSITION&lt;/code&gt; , &lt;code&gt;NAME&lt;/code&gt; , &lt;code&gt;LINE_NUMBER&lt;/code&gt; , &lt;code&gt;COLUMN_NUMBER&lt;/code&gt; , &lt;code&gt;OWNER_OS&lt;/code&gt; , &lt;code&gt;HOST_NAME&lt;/code&gt; , &lt;code&gt;USER&lt;/code&gt; , &lt;code&gt;CLASS&lt;/code&gt; , &lt;code&gt;ATOM&lt;/code&gt; и &lt;code&gt;INTEGER&lt;/code&gt; . (Это символы с именами в верхнем регистре в соответствии с соглашениями X.) Тип &lt;var&gt;data-type&lt;/var&gt; умолчанию - &lt;code&gt;STRING&lt;/code&gt; . Оконные системы, отличные от X, обычно поддерживают только небольшое подмножество этих типов в дополнение к &lt;code&gt;STRING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a7e1832ebe58d63879484df2925b4e83ba7f55" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;digest-method&lt;/var&gt; can be the whole plist from &lt;code&gt;gnutls-digests&lt;/code&gt;, or just the symbol key, or a string with the name of that symbol.</source>
          <target state="translated">&lt;var&gt;digest-method&lt;/var&gt; может быть вся PLIST из &lt;code&gt;gnutls-digests&lt;/code&gt; , или просто символ ключ, или строка с именем этого символа.</target>
        </trans-unit>
        <trans-unit id="935a0eaf2fbd230fea04adaaa1082e4cc3a672c1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;directory&lt;/var&gt; argument, described below, does not specify a remote file. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">&lt;var&gt;directory&lt;/var&gt; аргумент, описанный ниже, не указывает удаленный файл. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Удаленные файлы&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="5542f9599795f05b8099573e3d57536d54dac1a9" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;display&lt;/var&gt; part of an element of &lt;var&gt;spec&lt;/var&gt; determines which terminals the element matches. If more than one element of &lt;var&gt;spec&lt;/var&gt; matches a given terminal, the first element that matches is the one used for that terminal. There are three possibilities for &lt;var&gt;display&lt;/var&gt;:</source>
          <target state="translated">&lt;var&gt;display&lt;/var&gt; часть элемента &lt;var&gt;spec&lt;/var&gt; определяет , какие терминалы элемента спички. Если более одного элемента &lt;var&gt;spec&lt;/var&gt; соответствует данному терминалу, первый соответствующий элемент - это тот, который используется для этого терминала. Есть три возможности для &lt;var&gt;display&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="c9bda405d6d41a6743c07817af4eb4d0e700fb41" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;env&lt;/var&gt; argument provides a pointer to the</source>
          <target state="translated">&lt;var&gt;env&lt;/var&gt; аргумент содержит указатель на</target>
        </trans-unit>
        <trans-unit id="08e2ed661c4652900c4d2a493699f6dfd70d222b" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;factor&lt;/var&gt; must be a number, which is interpreted as a multiple of the height of the affected text. If it is positive, that means to display the characters raised. If it is negative, that means to display them lower down.</source>
          <target state="translated">&lt;var&gt;factor&lt;/var&gt; должен быть числом, которое интерпретируется как кратное высоты пораженного текста. Если он положительный, это означает отображение поднятых символов. Если он отрицательный, это означает, что они будут отображаться ниже.</target>
        </trans-unit>
        <trans-unit id="9fcc21f91bf906917402c028c06a30dae7160f1b" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;form&lt;/var&gt; argument controls the form of the returned &lt;var&gt;seconds&lt;/var&gt; element, as described below. The return value is a list of nine elements, as follows:</source>
          <target state="translated">В &lt;var&gt;form&lt;/var&gt; управляет аргумент формы возвращаемых &lt;var&gt;seconds&lt;/var&gt; элемента, как описано ниже. Возвращаемое значение - это список из девяти элементов, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="fbc01069be7d09c7d3a3a41b0f35d9961db204d7" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;handler&lt;/var&gt; then needs to figure out whether to handle &lt;var&gt;filename&lt;/var&gt; or &lt;var&gt;dirname&lt;/var&gt;.</source>
          <target state="translated">Затем &lt;var&gt;handler&lt;/var&gt; должен выяснить, следует ли обрабатывать &lt;var&gt;filename&lt;/var&gt; или имя &lt;var&gt;dirname&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="6cf3ab9b3b26be9707eddf18a92b9c71e8357257" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;hash-method&lt;/var&gt; can be the whole plist from &lt;code&gt;gnutls-macs&lt;/code&gt;, or just the symbol key, or a string with the name of that symbol.</source>
          <target state="translated">&lt;var&gt;hash-method&lt;/var&gt; может быть вся PLIST из &lt;code&gt;gnutls-macs&lt;/code&gt; , или просто символ ключа, или строка с именем этого символа.</target>
        </trans-unit>
        <trans-unit id="99af7f395067de5484dbd0bd18d306d12c0c9b03" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;input&lt;/var&gt; can be specified as a buffer or string or in other ways (see &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Format of GnuTLS Cryptography Inputs&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;input&lt;/var&gt; может быть указан в качестве буфера или строки , или другими способами (см &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Формат GnuTLS криптографические входов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="56e73e2ce780242f8e4988661d4b9746a25edb2f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;iv&lt;/var&gt; and &lt;var&gt;input&lt;/var&gt; and the optional &lt;var&gt;aead_auth&lt;/var&gt; can be specified as a buffer or string or in other ways (see &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Format of GnuTLS Cryptography Inputs&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;iv&lt;/var&gt; и &lt;var&gt;input&lt;/var&gt; и дополнительный &lt;var&gt;aead_auth&lt;/var&gt; может быть указан в качестве буфера или строки , или другими способами (см &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Формат GnuTLS криптографические входов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e01e83278249866df827f81cce4dae86e59aa92" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;keep-pred&lt;/var&gt; argument can also be a function. In that case, the function is called with no arguments, prior to running each command, while &lt;var&gt;keymap&lt;/var&gt; is active; it should return non-&lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;keymap&lt;/var&gt; should stay active.</source>
          <target state="translated">&lt;var&gt;keep-pred&lt;/var&gt; аргумент также может быть функцией. В этом случае функция вызывается без аргументов перед запуском каждой команды, когда &lt;var&gt;keymap&lt;/var&gt; активна; он должен возвращать &lt;code&gt;nil&lt;/code&gt; если &lt;var&gt;keymap&lt;/var&gt; должна оставаться активной.</target>
        </trans-unit>
        <trans-unit id="cbdbfab6e83937e27f501cc05397b6ce3086f4a1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;key-regexp&lt;/var&gt; argument can refer to the text matched by a subexpression of &lt;var&gt;record-regexp&lt;/var&gt;, or it can be a regular expression on its own.</source>
          <target state="translated">&lt;var&gt;key-regexp&lt;/var&gt; аргумент может ссылаться на текст , совпавший по подвыражению &lt;var&gt;record-regexp&lt;/var&gt; , или это может быть регулярным выражением самих по себе.</target>
        </trans-unit>
        <trans-unit id="1492573ae0239681a6f0caf30565cd718bdad9de" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;key&lt;/var&gt; can be specified as a buffer or string or in other ways (see &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Format of GnuTLS Cryptography Inputs&lt;/a&gt;). The &lt;var&gt;key&lt;/var&gt; will be wiped after use if it&amp;rsquo;s a string.</source>
          <target state="translated">&lt;var&gt;key&lt;/var&gt; может быть указан в качестве буфера или строки или другими способами (см &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Формат GnuTLS криптографические входов&lt;/a&gt; ). После использования &lt;var&gt;key&lt;/var&gt; будет очищен, если это строка.</target>
        </trans-unit>
        <trans-unit id="62a36f43d3ae1d147429ed8ea40e22e275d19322" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;keymap&lt;/var&gt; argument can also be a list of keymaps.</source>
          <target state="translated">&lt;var&gt;keymap&lt;/var&gt; аргумент может быть также список раскладок.</target>
        </trans-unit>
        <trans-unit id="183078d8ef81556e2619f842ffd518df0177a7d6" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;keyword-args&lt;/var&gt; are pairs of keywords and values. The values, except for &lt;code&gt;:after-hook&lt;/code&gt;&amp;rsquo;s, are evaluated. The following keywords are currently supported:</source>
          <target state="translated">В &lt;var&gt;keyword-args&lt;/var&gt; являются пары ключевых слов и значений. Значения, кроме &lt;code&gt;:after-hook&lt;/code&gt; , оцениваются. В настоящее время поддерживаются следующие ключевые слова:</target>
        </trans-unit>
        <trans-unit id="d9a9d314d3829c1d47b53b6d2cc5c9f93e1f95cd" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;macro&lt;/var&gt; argument can actually be any symbol, not just a macro name.</source>
          <target state="translated">&lt;var&gt;macro&lt;/var&gt; аргумент может быть на самом деле любой символ, а не только имя макроса.</target>
        </trans-unit>
        <trans-unit id="478187ccf5afebe445a949310656331eb0c33123" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;method&lt;/var&gt; symbol should be one of &lt;code&gt;zero-width&lt;/code&gt;, &lt;code&gt;thin-space&lt;/code&gt;, &lt;code&gt;empty-box&lt;/code&gt;, or &lt;code&gt;hex-code&lt;/code&gt;. These have the same meanings as in &lt;code&gt;glyphless-char-display&lt;/code&gt;, above.</source>
          <target state="translated">Символ &lt;var&gt;method&lt;/var&gt; должен быть &lt;code&gt;zero-width&lt;/code&gt; , &lt;code&gt;thin-space&lt;/code&gt; , &lt;code&gt;empty-box&lt;/code&gt; или &lt;code&gt;hex-code&lt;/code&gt; . Они имеют то же значение, что и в приведенном выше &lt;code&gt;glyphless-char-display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9aa33ebf3a782ebb64d24c0ca92f2745ce316273" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;name&lt;/var&gt; argument specifies the name for the process object. It is modified as necessary to make it unique.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; аргумент задает имя объекта процесса. Он изменяется по мере необходимости, чтобы сделать его уникальным.</target>
        </trans-unit>
        <trans-unit id="231e9e8ad59606a784462ddf1fc5a1c3ee071528" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;now&lt;/var&gt; and &lt;var&gt;comment&lt;/var&gt; entries are for internal use only, and may be omitted. &lt;var&gt;now&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to install the face specification now, even if the &lt;code&gt;defface&lt;/code&gt; form has not been evaluated. &lt;var&gt;comment&lt;/var&gt; is a string describing the customization.</source>
          <target state="translated">В &lt;var&gt;now&lt;/var&gt; и &lt;var&gt;comment&lt;/var&gt; запись предназначена только для внутреннего использования, и может быть опущена. &lt;var&gt;now&lt;/var&gt; , если не &lt;code&gt;nil&lt;/code&gt; , означает установить спецификацию лица сейчас, даже если форма &lt;code&gt;defface&lt;/code&gt; не была оценена. &lt;var&gt;comment&lt;/var&gt; - это строка, описывающая настройку.</target>
        </trans-unit>
        <trans-unit id="0988033c8bfd11489dbc605759fe15110dbf7750" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;now&lt;/var&gt;, &lt;var&gt;request&lt;/var&gt;, and &lt;var&gt;comment&lt;/var&gt; entries are for internal use only, and may be omitted. &lt;var&gt;now&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to set the variable&amp;rsquo;s value now, even if the variable&amp;rsquo;s &lt;code&gt;defcustom&lt;/code&gt; form has not been evaluated. &lt;var&gt;request&lt;/var&gt; is a list of features to be loaded immediately (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). &lt;var&gt;comment&lt;/var&gt; is a string describing the customization.</source>
          <target state="translated">&lt;var&gt;now&lt;/var&gt; , &lt;var&gt;request&lt;/var&gt; и &lt;var&gt;comment&lt;/var&gt; запись предназначена только для внутреннего использования, и может быть опущена. &lt;var&gt;now&lt;/var&gt; , если не &lt;code&gt;nil&lt;/code&gt; , означает установить значение переменной сейчас, даже если &lt;code&gt;defcustom&lt;/code&gt; форма переменной не была оценена. &lt;var&gt;request&lt;/var&gt; - это список функций, которые нужно загрузить немедленно (см. &lt;a href=&quot;named-features#Named-Features&quot;&gt;Именованные функции&lt;/a&gt; ). &lt;var&gt;comment&lt;/var&gt; - это строка, описывающая настройку.</target>
        </trans-unit>
        <trans-unit id="bfd48d1c6ff687e2f1df6dd6dad4acb172c7b66e" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;order&lt;/var&gt; is typically a number (integer or float), and the elements of the list are sorted in non-decreasing numerical order.</source>
          <target state="translated">&lt;var&gt;order&lt;/var&gt; обычно представляет собой число (целое или с плавающей точкой), и элементы списка отсортированы в неубывающей порядке.</target>
        </trans-unit>
        <trans-unit id="730dc6e5be96fa3e4dc3d63a62d43cd867c25f03" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;parameters&lt;/var&gt; argument is an alist that specifies frame parameters for the new frame. See &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;Frame Parameters&lt;/a&gt;. If you specify the &lt;code&gt;terminal&lt;/code&gt; parameter in &lt;var&gt;parameters&lt;/var&gt;, the new frame is created on that terminal. Otherwise, if you specify the &lt;code&gt;window-system&lt;/code&gt; frame parameter in &lt;var&gt;parameters&lt;/var&gt;, that determines whether the frame should be displayed on a text terminal or a graphical terminal. See &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;Window Systems&lt;/a&gt;. If neither is specified, the new frame is created in the same terminal as the selected frame.</source>
          <target state="translated">&lt;var&gt;parameters&lt;/var&gt; аргумент ассоциативный список , который определяет параметры кадров для нового кадра. См. &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;Параметры кадра&lt;/a&gt; . Если вы укажете параметр &lt;code&gt;terminal&lt;/code&gt; в &lt;var&gt;parameters&lt;/var&gt; , новый фрейм будет создан на этом терминале. В противном случае, если вы укажете параметр фрейма &lt;code&gt;window-system&lt;/code&gt; в &lt;var&gt;parameters&lt;/var&gt; , он определяет, должен ли фрейм отображаться на текстовом или графическом терминале. См. &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;Оконные системы&lt;/a&gt; . Если ни один из них не указан, новый фрейм создается в том же терминале, что и выбранный фрейм.</target>
        </trans-unit>
        <trans-unit id="afc7d9a60aa3b751ef05acfcffc9377a3cf63789" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;process&lt;/var&gt; argument can be a system process</source>
          <target state="translated">&lt;var&gt;process&lt;/var&gt; аргумент может быть системный процесс</target>
        </trans-unit>
        <trans-unit id="b8e361047f1404d82466da0618267cd2f934e8f3" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;seconds&lt;/var&gt; element is a Lisp timestamp that is nonnegative and less than 61; it is less than 60 except during positive leap seconds (assuming the operating system supports leap seconds). If the optional &lt;var&gt;form&lt;/var&gt; argument is &lt;code&gt;t&lt;/code&gt;, &lt;var&gt;seconds&lt;/var&gt; uses the same precision as &lt;var&gt;time&lt;/var&gt;; if &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;integer&lt;/code&gt;, &lt;var&gt;seconds&lt;/var&gt; is truncated to an integer. For example, if &lt;var&gt;time&lt;/var&gt; is the timestamp &lt;code&gt;(1566009571321 . 1000)&lt;/code&gt;, which represents 2019-08-17 02:39:31.321 UTC on typical systems that lack leap seconds, then &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t t)&lt;/code&gt; returns &lt;code&gt;((31321 . 1000)
39 2 17 8 2019 6 nil 0)&lt;/code&gt;, whereas &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t
'integer)&lt;/code&gt; returns &lt;code&gt;(31 39 2 17 8 2019 6 nil 0)&lt;/code&gt;. If &lt;var&gt;form&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it currently defaults to &lt;code&gt;integer&lt;/code&gt; but this default may change in future Emacs releases, so callers requiring a particular form should specify &lt;var&gt;form&lt;/var&gt;.</source>
          <target state="translated">Элемент &lt;var&gt;seconds&lt;/var&gt; - это неотрицательная временная метка Лиспа, меньшая 61; оно меньше 60, за исключением положительных дополнительных секунд (при условии, что операционная система поддерживает дополнительные секунды). Если необязательный аргумент &lt;var&gt;form&lt;/var&gt; равен &lt;code&gt;t&lt;/code&gt; , &lt;var&gt;seconds&lt;/var&gt; используют ту же точность, что и &lt;var&gt;time&lt;/var&gt; ; если &lt;var&gt;form&lt;/var&gt; является &lt;code&gt;integer&lt;/code&gt; , &lt;var&gt;seconds&lt;/var&gt; усекается до целого числа. Например, если &lt;var&gt;time&lt;/var&gt; является отметкой времени &lt;code&gt;(1566009571321 . 1000)&lt;/code&gt; , Который представляет собой 2019-08-17 02: 39: 31.321 UTC на типичных системах , которые не имеют високосные секунды, затем &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t t)&lt;/code&gt; возвращают &lt;code&gt;((31321 . 1000) 39 2 17 8 2019 6 nil 0)&lt;/code&gt; , тогда как &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t 'integer)&lt;/code&gt; возвращается &lt;code&gt;(31 39 2 17 8 2019 6 nil 0)&lt;/code&gt; . Если &lt;var&gt;form&lt;/var&gt; опущена или равна &lt;code&gt;nil&lt;/code&gt; , в настоящее время по умолчанию используется &lt;code&gt;integer&lt;/code&gt; но это значение по умолчанию может измениться в будущих выпусках Emacs, поэтому вызывающие программы, которым требуется конкретная форма, должны указать &lt;var&gt;form&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b3501ce0f22c5a460c2284b5b67304c4ec40866f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;spec&lt;/var&gt; argument is a &lt;em&gt;face spec&lt;/em&gt;, which states how the face should appear on different kinds of terminals. It should be an alist whose elements each have the form</source>
          <target state="translated">&lt;var&gt;spec&lt;/var&gt; аргумент является &lt;em&gt;лицо спецификации&lt;/em&gt; , в которой говорится , как лицо должно появиться на различных терминалах. Это должен быть список, каждый из элементов которого имеет вид</target>
        </trans-unit>
        <trans-unit id="c06e3e6329485a46088e33ab0a58763a6add9987" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;try-completion&lt;/var&gt; and &lt;var&gt;all-completions&lt;/var&gt; functions should each accept four arguments: &lt;var&gt;string&lt;/var&gt;, &lt;var&gt;collection&lt;/var&gt;, &lt;var&gt;predicate&lt;/var&gt;, and &lt;var&gt;point&lt;/var&gt;. The &lt;var&gt;string&lt;/var&gt;, &lt;var&gt;collection&lt;/var&gt;, and &lt;var&gt;predicate&lt;/var&gt; arguments have the same meanings as in &lt;code&gt;try-completion&lt;/code&gt; (see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;), and the &lt;var&gt;point&lt;/var&gt; argument is the position of point within &lt;var&gt;string&lt;/var&gt;. Each function should return a non-&lt;code&gt;nil&lt;/code&gt; value if it performed its job, and &lt;code&gt;nil&lt;/code&gt; if it did not (e.g., if there is no way to complete &lt;var&gt;string&lt;/var&gt; according to the completion style).</source>
          <target state="translated">&lt;var&gt;try-completion&lt;/var&gt; и &lt;var&gt;all-completions&lt;/var&gt; функция должна каждый принимает четыре аргумента: &lt;var&gt;string&lt;/var&gt; , &lt;var&gt;collection&lt;/var&gt; , &lt;var&gt;predicate&lt;/var&gt; и &lt;var&gt;point&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt; , &lt;var&gt;collection&lt;/var&gt; и &lt;var&gt;predicate&lt;/var&gt; аргументы имеют то же значение , как в &lt;code&gt;try-completion&lt;/code&gt; (см &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Базового комплекта&lt;/a&gt; ), а &lt;var&gt;point&lt;/var&gt; аргумент является положением точки в &lt;var&gt;string&lt;/var&gt; . Каждая функция должна возвращать значение, отличное от &lt;code&gt;nil&lt;/code&gt; , если она выполнила свою работу, и &lt;code&gt;nil&lt;/code&gt; , если нет (например, если нет возможности завершить &lt;var&gt;string&lt;/var&gt; по стилю завершения).</target>
        </trans-unit>
        <trans-unit id="0335ff665c252c34bc8af3595631a385d6bec903" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;var-sequence&lt;/var&gt; sequence can also include the &lt;code&gt;&amp;amp;rest&lt;/code&gt; marker followed by a variable name to be bound to the rest of &lt;var&gt;val-sequence&lt;/var&gt;.</source>
          <target state="translated">Последовательность &lt;var&gt;var-sequence&lt;/var&gt; может также включать маркер &lt;code&gt;&amp;amp;rest&lt;/code&gt; за которым следует имя переменной, которая будет связана с остальной частью &lt;var&gt;val-sequence&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="48c44bcaee3aecba4fd3386d2632d16003a6a097" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; arguments specify the widget size in pixels, and &lt;var&gt;title&lt;/var&gt;, a string, specifies its title.</source>
          <target state="translated">В &lt;var&gt;width&lt;/var&gt; и &lt;var&gt;height&lt;/var&gt; аргументы задают виджета размер в пикселях, и &lt;var&gt;title&lt;/var&gt; , строку, определяет ее название.</target>
        </trans-unit>
        <trans-unit id="042fa4319f83303549e9163cc74bb7a75739f113" translate="yes" xml:space="preserve">
          <source>The Buffer Gap</source>
          <target state="translated">Буферная щель</target>
        </trans-unit>
        <trans-unit id="88db08fc40ec31b574f716946b51aacded45fd94" translate="yes" xml:space="preserve">
          <source>The Buffer List</source>
          <target state="translated">Буферная карта</target>
        </trans-unit>
        <trans-unit id="c1b161f427b1f734326373d819a11018ebc6afec" translate="yes" xml:space="preserve">
          <source>The Button package defines functions for inserting and manipulating &lt;em&gt;buttons&lt;/em&gt; that can be activated with the mouse or via keyboard commands. These buttons are typically used for various kinds of hyperlinks.</source>
          <target state="translated">Пакет Button определяет функции для вставки и управления &lt;em&gt;кнопками,&lt;/em&gt; которые можно активировать с помощью мыши или с помощью команд клавиатуры. Эти кнопки обычно используются для различных типов гиперссылок.</target>
        </trans-unit>
        <trans-unit id="ed389ad7628fa8d3021e70d30f1da8af14a2e91e" translate="yes" xml:space="preserve">
          <source>The C functions &lt;code&gt;call0&lt;/code&gt;, &lt;code&gt;call1&lt;/code&gt;, &lt;code&gt;call2&lt;/code&gt;, and so on, provide handy ways to call a Lisp function conveniently with a fixed number of arguments. They work by calling &lt;code&gt;Ffuncall&lt;/code&gt;.</source>
          <target state="translated">Функции C &lt;code&gt;call0&lt;/code&gt; , &lt;code&gt;call1&lt;/code&gt; , &lt;code&gt;call2&lt;/code&gt; и т. Д. Предоставляют удобные способы вызова функции Lisp с фиксированным числом аргументов. Они работают, вызывая &lt;code&gt;Ffuncall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8b73b7861af4aafe3f06ecc14faf1d3eea057a5" translate="yes" xml:space="preserve">
          <source>The C part of Emacs is portable to C99 or later: C11-specific features such as &amp;lsquo;</source>
          <target state="translated">Часть C Emacs переносима на C99 или новее: специфичные для C11 функции, такие как '</target>
        </trans-unit>
        <trans-unit id="de35110382ab3d228e2b097a0fd8120a8e5e7818" translate="yes" xml:space="preserve">
          <source>The Case Table</source>
          <target state="translated">Кейс-таблица</target>
        </trans-unit>
        <trans-unit id="1f400cc4a2f5b022649bc110a1d58fe7aba52a53" translate="yes" xml:space="preserve">
          <source>The Common Lisp loop facility also contains features for working with iterators. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility&quot;&gt;Loop Facility&lt;/a&gt; in</source>
          <target state="translated">Средство цикла Common Lisp также содержит функции для работы с итераторами. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility&quot;&gt;Loop Facility&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="b959eb0c15ee6787dc31ccfba3386e533a6ed0de" translate="yes" xml:space="preserve">
          <source>The Current Buffer</source>
          <target state="translated">Текущий буфер</target>
        </trans-unit>
        <trans-unit id="3eeba2f256fb33046d7a21ae5a30d974e72989bf" translate="yes" xml:space="preserve">
          <source>The D-Bus bus. This argument is needed only if a bus other than &lt;code&gt;:session&lt;/code&gt; shall be used.</source>
          <target state="translated">Автобус D-Bus. Этот аргумент необходим только в том случае, если должна использоваться шина, отличная от &lt;code&gt;:session&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d943856e8a1ab46910a0a060d4b4a8bc05b6d2d7" translate="yes" xml:space="preserve">
          <source>The Data Structure of the Mode Line</source>
          <target state="translated">Структура данных линии режима</target>
        </trans-unit>
        <trans-unit id="6845dcf7b293a7f410b480283184f4343e62c6bc" translate="yes" xml:space="preserve">
          <source>The Debugger mode</source>
          <target state="translated">Режим отладчика</target>
        </trans-unit>
        <trans-unit id="d50f479d67b7ffd944ff37303a4fcf2b32a43c84" translate="yes" xml:space="preserve">
          <source>The Default Value of a Buffer-Local Variable</source>
          <target state="translated">Значение по умолчанию буферно-локальной переменной</target>
        </trans-unit>
        <trans-unit id="1af63431f4b48d26e4f383b32edfc24d505f479c" translate="yes" xml:space="preserve">
          <source>The Echo Area</source>
          <target state="translated">Зона Эко</target>
        </trans-unit>
        <trans-unit id="d3ecd4c390bc66755238340e318147394eb63696" translate="yes" xml:space="preserve">
          <source>The Edebug specification says which parts of a call to the macro are forms to be evaluated. For simple macros, the specification often looks very similar to the formal argument list of the macro definition, but specifications are much more general than macro arguments. See &lt;a href=&quot;defining-macros#Defining-Macros&quot;&gt;Defining Macros&lt;/a&gt;, for more explanation of the &lt;code&gt;declare&lt;/code&gt; form.</source>
          <target state="translated">В спецификации Edebug указано, какие части вызова макроса являются формами для оценки. Для простых макросов спецификация часто очень похожа на формальный список аргументов определения макроса, но спецификации гораздо более общие, чем аргументы макроса. См. Раздел &amp;laquo; &lt;a href=&quot;defining-macros#Defining-Macros&quot;&gt;Определение макросов&amp;raquo;&lt;/a&gt; для получения дополнительных сведений &lt;code&gt;declare&lt;/code&gt; форме объявления .</target>
        </trans-unit>
        <trans-unit id="9e84da412291b7634158164e0c4c2be118e4000c" translate="yes" xml:space="preserve">
          <source>The Emacs Lisp byte compiler may collapse identical literal objects, such as literal strings, into references to the same object, with the effect that the byte-compiled code will compare such objects as &lt;code&gt;eq&lt;/code&gt;, while the interpreted version of the same code will not. Therefore, your code should never rely on objects with the same literal contents being either &lt;code&gt;eq&lt;/code&gt; or not &lt;code&gt;eq&lt;/code&gt;, it should instead use functions that compare object contents such as &lt;code&gt;equal&lt;/code&gt;, described below. Similarly, your code should not modify literal objects (e.g., put text properties on literal strings), since doing that might affect other literal objects of the same contents, if the byte compiler collapses them.</source>
          <target state="translated">Байт-компилятор Emacs Lisp может свернуть идентичные литеральные объекты, такие как литеральные строки, в ссылки на один и тот же объект, в результате чего код, скомпилированный в байтах, будет сравнивать такие объекты, как &lt;code&gt;eq&lt;/code&gt; , а интерпретируемая версия того же кода - нет. Следовательно, ваш код никогда не должен полагаться на объекты с одинаковым буквальным содержанием, являющиеся либо &lt;code&gt;eq&lt;/code&gt; , либо не &lt;code&gt;eq&lt;/code&gt; , вместо этого он должен использовать функции, сравнивающие содержимое объектов, например, &lt;code&gt;equal&lt;/code&gt; , описанные ниже. Точно так же ваш код не должен изменять литеральные объекты (например, помещать текстовые свойства в литеральные строки), поскольку это может повлиять на другие литеральные объекты того же содержимого, если байтовый компилятор свернет их.</target>
        </trans-unit>
        <trans-unit id="310426987bb1554a93b5fd738cbd277c007e71d9" translate="yes" xml:space="preserve">
          <source>The Emacs Lisp interpreter itself does not perform type checking on the actual arguments passed to functions when they are called. It could not do so, since function arguments in Lisp do not have declared data types, as they do in other programming languages. It is therefore up to the individual function to test whether each actual argument belongs to a type that the function can use.</source>
          <target state="translated">Сам интерпретатор Emacs Lisp не выполняет проверку типов фактических аргументов,передаваемых в функции при их вызове.Он не может этого сделать,так как аргументы функций в Lisp не имеют объявленных типов данных,как это делается в других языках программирования.Следовательно,проверка того,принадлежит ли каждый фактический аргумент к тому или иному типу,является прерогативой отдельной функции.</target>
        </trans-unit>
        <trans-unit id="9b5ed2bacaf122b157d132153caf1a6c76e1e216" translate="yes" xml:space="preserve">
          <source>The Emacs Manual</source>
          <target state="translated">Руководство Emacs</target>
        </trans-unit>
        <trans-unit id="ed9c188a636545890d0306bb79a70700989914ce" translate="yes" xml:space="preserve">
          <source>The Emacs Web Wowser Manual</source>
          <target state="translated">Руководство Веб-Ваузера Emacs</target>
        </trans-unit>
        <trans-unit id="c5f97d9b01c47621a8f1576c10266887562eaba8" translate="yes" xml:space="preserve">
          <source>The Emacs Widget Library</source>
          <target state="translated">Библиотека виджетов Эмака</target>
        </trans-unit>
        <trans-unit id="cf1a28f1f55db75a34f2ee21a67962dda3683be4" translate="yes" xml:space="preserve">
          <source>The Emacs command loop is entered automatically when Emacs starts up. This top-level invocation of the command loop never exits; it keeps running as long as Emacs does. Lisp programs can also invoke the command loop. Since this makes more than one activation of the command loop, we call it &lt;em&gt;recursive editing&lt;/em&gt;. A recursive editing level has the effect of suspending whatever command invoked it and permitting the user to do arbitrary editing before resuming that command.</source>
          <target state="translated">Командный цикл Emacs запускается автоматически при запуске Emacs. Этот вызов командного цикла верхнего уровня никогда не завершается; он продолжает работать, пока работает Emacs. Программы на Лиспе также могут вызывать командный цикл. Поскольку при этом происходит более одной активации командного цикла, мы называем это &lt;em&gt;рекурсивным редактированием&lt;/em&gt; . Уровень рекурсивного редактирования приостанавливает выполнение любой вызвавшей его команды и позволяет пользователю выполнять произвольное редактирование перед возобновлением этой команды.</target>
        </trans-unit>
        <trans-unit id="8d2757b8581c35fe6423fa5de538de963ebfee3a" translate="yes" xml:space="preserve">
          <source>The Emacs command loop reads a sequence of &lt;em&gt;input events&lt;/em&gt; that represent keyboard or mouse activity, or system events sent to Emacs. The events for keyboard activity are characters or symbols; other events are always lists. This section describes the representation and meaning of input events in detail.</source>
          <target state="translated">Цикл команд Emacs считывает последовательность &lt;em&gt;событий ввода,&lt;/em&gt; которые представляют действия клавиатуры или мыши, или системные события, отправленные в Emacs. Событиями для активности клавиатуры являются символы или символы; другие события всегда являются списками. В этом разделе подробно описывается представление и значение входных событий.</target>
        </trans-unit>
        <trans-unit id="824a7c8d972dbc9f0918b1d2dd36bd16830fd203" translate="yes" xml:space="preserve">
          <source>The Emacs-GnuTLS manual</source>
          <target state="translated">Руководство Emacs-GnuTLS.</target>
        </trans-unit>
        <trans-unit id="48abe72f85ec259728635bab36a8349e8fee558c" translate="yes" xml:space="preserve">
          <source>The Ewoc package constructs buffer text that represents a structure of Lisp objects, and updates the text to follow changes in that structure. This is like the &amp;ldquo;view&amp;rdquo; component in the &amp;ldquo;model&amp;ndash;view&amp;ndash;controller&amp;rdquo; design paradigm. Ewoc means &amp;ldquo;Emacs&amp;rsquo;s Widget for Object Collections&amp;rdquo;.</source>
          <target state="translated">Пакет Ewoc создает текст буфера, который представляет структуру объектов Lisp, и обновляет текст, чтобы следовать изменениям в этой структуре. Это похоже на компонент &amp;laquo;представление&amp;raquo; в парадигме проектирования &amp;laquo;модель &amp;ndash; представление &amp;ndash; контроллер&amp;raquo;. Ewoc означает &amp;laquo;Виджет Emacs для коллекций объектов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b090490c607ee3ae40053556e3bd1bc26e7b84ef" translate="yes" xml:space="preserve">
          <source>The Font Lock functionality is based on several basic functions. Each of these calls the function specified by the corresponding variable. This indirection allows major and minor modes to modify the way fontification works in the buffers of that mode, and even use the Font Lock mechanisms for features that have nothing to do with fontification. (This is why the description below says &amp;ldquo;should&amp;rdquo; when it describes what the functions do: the mode can customize the values of the corresponding variables to do something entirely different.) The variables mentioned below are described in &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">Функциональность Font Lock основана на нескольких основных функциях. Каждый из них вызывает функцию, указанную соответствующей переменной. Это косвенное обращение позволяет основным и второстепенным режимам изменять способ работы фонтификации в буферах этого режима и даже использовать механизмы блокировки шрифта для функций, которые не имеют ничего общего с фонтификацией. (Вот почему в приведенном ниже описании говорится &amp;laquo;следует&amp;raquo;, когда в нем описывается, что делают функции: режим может настраивать значения соответствующих переменных, чтобы делать что-то совершенно иное.) Переменные, упомянутые ниже, описаны в &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;разделе &amp;laquo;Другие переменные блокировки шрифта&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffe1e1010931294e4ff432189f143dba8ad3d52c" translate="yes" xml:space="preserve">
          <source>The GNU C Library Reference Manual</source>
          <target state="translated">Справочное руководство по библиотеке Си GNU</target>
        </trans-unit>
        <trans-unit id="f510bd36e1c0e21b92eb72e77742b390298c8296" translate="yes" xml:space="preserve">
          <source>The GNU Emacs Manual</source>
          <target state="translated">Руководство GNU Emacs Manual</target>
        </trans-unit>
        <trans-unit id="be8e8d5a20ebc8f402b76cd53e568b1f3714e9b8" translate="yes" xml:space="preserve">
          <source>The GNU Libc Manual</source>
          <target state="translated">Руководство по Libc GNU</target>
        </trans-unit>
        <trans-unit id="97d4e4584e3d965d515d24f39f1ba0fb87608737" translate="yes" xml:space="preserve">
          <source>The GNU Privacy Guard Manual</source>
          <target state="translated">Руководство GNU по защите конфиденциальности</target>
        </trans-unit>
        <trans-unit id="46ff57e09cd2f765d85462c770ad0d94e1fb2d96" translate="yes" xml:space="preserve">
          <source>The GNU system (using the GNU kernel, which consists of the HURD and Mach).</source>
          <target state="translated">Система GNU (с использованием ядра GNU,которое состоит из HURD и Mach).</target>
        </trans-unit>
        <trans-unit id="d45b5a5dd9f2e4c7ca56bba45693e77c91e54851" translate="yes" xml:space="preserve">
          <source>The GTK+ and NS versions of Emacs ignores items 1 to 3, because disabled and/or deselected images are autocomputed from item 0.</source>
          <target state="translated">GTK+и NS версии Emacs игнорируют пункты с 1 по 3,потому что отключенные и/или отмененные изображения автоматически вычисляются из пункта 0.</target>
        </trans-unit>
        <trans-unit id="fff10c181322ecc664c42dfda8fefedaf1847850" translate="yes" xml:space="preserve">
          <source>The ID number of the outermost window-system window in which the frame exists. As with &lt;code&gt;window-id&lt;/code&gt;, changing this parameter has no actual effect.</source>
          <target state="translated">Идентификационный номер самого внешнего окна оконной системы, в котором существует фрейм. Как и в случае с &lt;code&gt;window-id&lt;/code&gt; , изменение этого параметра не имеет фактического эффекта.</target>
        </trans-unit>
        <trans-unit id="4d63d6de0303f72672f86fee4a5f29964456f058" translate="yes" xml:space="preserve">
          <source>The ID number which the graphical display uses for this frame. Emacs assigns this parameter when the frame is created; changing the parameter has no effect on the actual ID number.</source>
          <target state="translated">Идентификационный номер,который графический дисплей использует для этого кадра.Emacs назначает этот параметр при создании кадра;изменение этого параметра не влияет на действительный ID номер.</target>
        </trans-unit>
        <trans-unit id="b7c31f5b358bfa18cfdf049d5e081a95b7c9c0ea" translate="yes" xml:space="preserve">
          <source>The Init File</source>
          <target state="translated">Инит-файл</target>
        </trans-unit>
        <trans-unit id="cbab447af0083f2d9278c7461d6eaff464619006" translate="yes" xml:space="preserve">
          <source>The Internet protocol address.</source>
          <target state="translated">Адрес интернет-протокола.</target>
        </trans-unit>
        <trans-unit id="aba4cfd77de5ccd0c7c2dc2fb4bf06e5c623205b" translate="yes" xml:space="preserve">
          <source>The Kill Ring</source>
          <target state="translated">Кольцо убийства</target>
        </trans-unit>
        <trans-unit id="82814d081d76842dd03cfad63480273e62e1f98e" translate="yes" xml:space="preserve">
          <source>The Lisp Debugger</source>
          <target state="translated">Отладчик Лиспа</target>
        </trans-unit>
        <trans-unit id="c8d28bedb49ac3761246585ddcb49c12087f68df" translate="yes" xml:space="preserve">
          <source>The Lisp interpreter, or evaluator, is the part of Emacs that computes the value of an expression that is given to it. When a function written in Lisp is called, the evaluator computes the value of the function by evaluating the expressions in the function body. Thus, running any Lisp program really means running the Lisp interpreter.</source>
          <target state="translated">Интерпретатор Lisp,или вычислитель,является частью Emacs,которая вычисляет значение даваемого ему выражения.При вызове функции,написанной на языке Lisp,вычислитель вычисляет значение функции,вычисляя выражения в теле функции.Таким образом,запуск любой программы на языке Lisp на самом деле означает запуск интерпретатора Lisp.</target>
        </trans-unit>
        <trans-unit id="67096f218be8637118f0e140ce449a73a3aa3d19" translate="yes" xml:space="preserve">
          <source>The Lisp macros below provide different ways of binding names to definitions. Common to all of them are the following rules:</source>
          <target state="translated">Приведенные ниже макросы Lisp обеспечивают различные способы привязки имен к определениям.Общими для всех них являются следующие правила:</target>
        </trans-unit>
        <trans-unit id="b92835e656ef8b33221e27f7efc472160affd9c6" translate="yes" xml:space="preserve">
          <source>The Lisp modes have two string quote characters: double-quote (&amp;lsquo;</source>
          <target state="translated">В режимах Lisp есть два символа строковых кавычек: двойные кавычки ('</target>
        </trans-unit>
        <trans-unit id="00a189f320831f6a7cbe46d5d1c34bc9f301c86a" translate="yes" xml:space="preserve">
          <source>The Lisp package which goes with your module could then load the module using the &lt;code&gt;load&lt;/code&gt; primitive (see &lt;a href=&quot;dynamic-modules#Dynamic-Modules&quot;&gt;Dynamic Modules&lt;/a&gt;) when the package is loaded into Emacs.</source>
          <target state="translated">Пакет Lisp, который идет с вашим модулем, может затем загрузить модуль с помощью примитива &lt;code&gt;load&lt;/code&gt; (см. &lt;a href=&quot;dynamic-modules#Dynamic-Modules&quot;&gt;Динамические модули&lt;/a&gt; ), когда пакет загружается в Emacs.</target>
        </trans-unit>
        <trans-unit id="a10dde5e9f797bafad7f9b20fb8272a90e00c8e1" translate="yes" xml:space="preserve">
          <source>The Lisp printer can produce this syntax to record circular and shared structure in a Lisp object, if you bind the variable &lt;code&gt;print-circle&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">Принтер Lisp может создать этот синтаксис для записи циклической и разделяемой структуры в объекте Lisp, если вы привяжете переменную &lt;code&gt;print-circle&lt;/code&gt; к &lt;code&gt;nil&lt;/code&gt; значению. См. &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Выходные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eae52bdc2047fd6ec677f1f8ee8f1932da4d37e9" translate="yes" xml:space="preserve">
          <source>The Lisp reader reads an integer as a nonempty sequence of decimal digits with optional initial sign and optional final period.</source>
          <target state="translated">Считыватель Lisp читает целое число как непустую последовательность десятичных цифр с необязательным начальным знаком и необязательным конечным периодом.</target>
        </trans-unit>
        <trans-unit id="2a586c1cf0727731b69b8375a90b4485bdf10c07" translate="yes" xml:space="preserve">
          <source>The Lisp reader reports invalid syntax, but cannot say where the real problem is. For example, the error &amp;lsquo;</source>
          <target state="translated">Программа чтения Лиспа сообщает о неверном синтаксисе, но не может сказать, в чем настоящая проблема. Например, ошибка '</target>
        </trans-unit>
        <trans-unit id="fcecede5703df29c00b9f51550de12dc7dfbae92" translate="yes" xml:space="preserve">
          <source>The Mark</source>
          <target state="translated">Знак</target>
        </trans-unit>
        <trans-unit id="f37b90308c8ea9bb361394a84649d9067c3b3b87" translate="yes" xml:space="preserve">
          <source>The Match Data</source>
          <target state="translated">Сопоставительные данные</target>
        </trans-unit>
        <trans-unit id="e12f3f3cbde4367f4806f21a6ef69e7d82fb3756" translate="yes" xml:space="preserve">
          <source>The Menu Bar</source>
          <target state="translated">Меню-бар</target>
        </trans-unit>
        <trans-unit id="f476ae6da532e421223f60de7495c64fa2d57aaa" translate="yes" xml:space="preserve">
          <source>The Outside Context</source>
          <target state="translated">Внешний контекст</target>
        </trans-unit>
        <trans-unit id="452e09252ab77548d7926d100d076b5a89f76615" translate="yes" xml:space="preserve">
          <source>The Overlay Arrow</source>
          <target state="translated">Стрелка наложения</target>
        </trans-unit>
        <trans-unit id="2749af725670d68e7c9f29455577d15f1aa89399" translate="yes" xml:space="preserve">
          <source>The POSIX search and match functions do not properly support the non-greedy repetition operators (see &lt;a href=&quot;regexp-special#Regexp-Special&quot;&gt;non-greedy&lt;/a&gt;). This is because POSIX backtracking conflicts with the semantics of non-greedy repetition.</source>
          <target state="translated">Функции поиска и сопоставления POSIX не поддерживают должным образом нежадные операторы повторения (см. &amp;laquo; &lt;a href=&quot;regexp-special#Regexp-Special&quot;&gt;Нежадный&amp;raquo;&lt;/a&gt; ). Это связано с тем, что обратное отслеживание POSIX конфликтует с семантикой нежадного повторения.</target>
        </trans-unit>
        <trans-unit id="975c0dbec8418cefac1c26cea47400958485a24f" translate="yes" xml:space="preserve">
          <source>The Region</source>
          <target state="translated">Регион</target>
        </trans-unit>
        <trans-unit id="7f0920ea8dce344ced982af555e68f1fcc8fb02c" translate="yes" xml:space="preserve">
          <source>The Thread List</source>
          <target state="translated">Список нитей</target>
        </trans-unit>
        <trans-unit id="0b3b10e0747a616770fcc68ce9c42692021f69c3" translate="yes" xml:space="preserve">
          <source>The Top Level of Mode Line Control</source>
          <target state="translated">Верхний уровень управления линией режима</target>
        </trans-unit>
        <trans-unit id="0f9f110896a8003386b884af9710262024fcd3bd" translate="yes" xml:space="preserve">
          <source>The Tramp Manual</source>
          <target state="translated">Руководство для бродяг</target>
        </trans-unit>
        <trans-unit id="3d449198e0052c8b8dae47f7157c82ee61e7dd1a" translate="yes" xml:space="preserve">
          <source>The WebKit component.</source>
          <target state="translated">Компонент WebKit.</target>
        </trans-unit>
        <trans-unit id="c97106172cf0fee2d4e25fbcc7b9b6c23c939797" translate="yes" xml:space="preserve">
          <source>The Window Start and End Positions</source>
          <target state="translated">Начальное и конечное положение окна</target>
        </trans-unit>
        <trans-unit id="00312f9c47a904c7e40141a60dd85f937febefae" translate="yes" xml:space="preserve">
          <source>The X Window System defines three other modifier bits that can be set in a character: &lt;em&gt;hyper&lt;/em&gt;, &lt;em&gt;super&lt;/em&gt; and &lt;em&gt;alt&lt;/em&gt;. The syntaxes for these bits are &amp;lsquo;</source>
          <target state="translated">Система X Window определяет три других бита модификатора, которые могут быть установлены в символе: &lt;em&gt;hyper&lt;/em&gt; , &lt;em&gt;super&lt;/em&gt; и &lt;em&gt;alt&lt;/em&gt; . Синтаксис этих битов:</target>
        </trans-unit>
        <trans-unit id="239e6f6db120d4b7497121d69c34a71f64242413" translate="yes" xml:space="preserve">
          <source>The Zen of Buffer Display</source>
          <target state="translated">Дзен дисплея буфера</target>
        </trans-unit>
        <trans-unit id="d1c7be134e2b1ac53a747c65f17468ae85a6e82a" translate="yes" xml:space="preserve">
          <source>The abnormal hook &lt;code&gt;window-size-change-functions&lt;/code&gt; (see &lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;Window Hooks&lt;/a&gt;) tracks all changes of the inner size of a frame including those induced by request of the window-system or window manager. To rule out false positives that might occur when changing only the sizes of a frame&amp;rsquo;s windows without actually changing the size of the inner frame, use the following function.</source>
          <target state="translated">Аномальная ловушка &lt;code&gt;window-size-change-functions&lt;/code&gt; (см. &lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;Оконные ловушки&lt;/a&gt; ) отслеживает все изменения внутреннего размера фрейма, включая те, которые вызваны запросом оконной системы или оконного менеджера. Чтобы исключить ложные срабатывания, которые могут возникнуть при изменении только размеров окон фрейма без фактического изменения размера внутреннего фрейма, используйте следующую функцию.</target>
        </trans-unit>
        <trans-unit id="acb5f2e3b961983ad080c933704bf1921460d37a" translate="yes" xml:space="preserve">
          <source>The above commands use the function &lt;code&gt;pop-to-buffer&lt;/code&gt;, which flexibly displays a buffer in some window and selects that window for editing. In turn, &lt;code&gt;pop-to-buffer&lt;/code&gt; uses &lt;code&gt;display-buffer&lt;/code&gt; for displaying the buffer. Hence, all the variables affecting &lt;code&gt;display-buffer&lt;/code&gt; will affect it as well. See &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;, for the documentation of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">Вышеупомянутые команды используют функцию &lt;code&gt;pop-to-buffer&lt;/code&gt; , которая гибко отображает буфер в каком-либо окне и выбирает это окно для редактирования. В свою очередь, &lt;code&gt;pop-to-buffer&lt;/code&gt; использует &lt;code&gt;display-buffer&lt;/code&gt; для отображения буфера. Следовательно, все переменные, влияющие на &lt;code&gt;display-buffer&lt;/code&gt; ,также будут влиять на него. См. Раздел &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Выбор окна&lt;/a&gt; для документации &lt;code&gt;display-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd813c20f1c6269cd7421cd80bccde0cf42a41bb" translate="yes" xml:space="preserve">
          <source>The above display conventions apply even when there is a display table, for any character whose entry in the active display table is &lt;code&gt;nil&lt;/code&gt;. Thus, when you set up a display table, you need only specify the characters for which you want special behavior.</source>
          <target state="translated">Вышеупомянутые соглашения об отображении применяются даже при наличии таблицы отображения для любого символа, запись которого в активной таблице отображения равна &lt;code&gt;nil&lt;/code&gt; . Таким образом, когда вы настраиваете таблицу отображения, вам нужно только указать символы, для которых вы хотите особое поведение.</target>
        </trans-unit>
        <trans-unit id="1790de9a4c228ec0f7e88481efc2c65fd587eb7a" translate="yes" xml:space="preserve">
          <source>The above example would allow the conclusion that users customize &lt;code&gt;display-buffer-alist&lt;/code&gt; for the sole purpose to overrule the &lt;var&gt;action&lt;/var&gt; argument chosen by applications. Such a conclusion would be incorrect. &lt;code&gt;display-buffer-alist&lt;/code&gt; is the standard option for users to direct the course of display of specific buffers in a preferred way regardless of whether the display is also guided by an &lt;var&gt;action&lt;/var&gt; argument.</source>
          <target state="translated">Приведенный выше пример позволяет сделать вывод, что пользователи настраивают &lt;code&gt;display-buffer-alist&lt;/code&gt; с единственной целью - переопределить аргумент &lt;var&gt;action&lt;/var&gt; выбранный приложениями. Такой вывод был бы неверным. &lt;code&gt;display-buffer-alist&lt;/code&gt; - это стандартный параметр, позволяющий пользователям направлять ход отображения определенных буферов предпочтительным образом независимо от того, руководствуется ли отображение также аргументом &lt;var&gt;action&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="aeb0dafcf8103ae88a77afae29bde5756ca7c094" translate="yes" xml:space="preserve">
          <source>The above feature works by calling an external executable (e.g., &lt;code&gt;gzip&lt;/code&gt;). Emacs can also be compiled with support for built-in decompression using the zlib library, which is faster than calling an external program.</source>
          <target state="translated">Вышеупомянутая функция работает путем вызова внешнего исполняемого файла (например, &lt;code&gt;gzip&lt;/code&gt; ). Emacs также может быть скомпилирован с поддержкой встроенной декомпрессии с использованием библиотеки zlib, что быстрее, чем вызов внешней программы.</target>
        </trans-unit>
        <trans-unit id="387f04e2a1f6936573fe28b42d630e5f93dc27a4" translate="yes" xml:space="preserve">
          <source>The above grammar does not explicitly mention the syntax of function calls: SMIE will automatically allow any sequence of sexps, such as identifiers, balanced parentheses, or &lt;code&gt;begin ... end&lt;/code&gt; blocks to appear anywhere anyway.</source>
          <target state="translated">В приведенной выше грамматике явно не упоминается синтаксис вызовов функций: SMIE автоматически разрешает любую последовательность символов, таких как идентификаторы, сбалансированные круглые скобки или блоки &lt;code&gt;begin ... end&lt;/code&gt; в любом случае.</target>
        </trans-unit>
        <trans-unit id="deec33282919bd446ca8d3ce98c567ff797c98f6" translate="yes" xml:space="preserve">
          <source>The above method with the additional argument is usually best, because it allows callers to say &amp;ldquo;treat this call as interactive&amp;rdquo;. But you can also do the job by testing &lt;code&gt;called-interactively-p&lt;/code&gt;.</source>
          <target state="translated">Вышеупомянутый метод с дополнительным аргументом обычно является лучшим, поскольку он позволяет вызывающим абонентам сказать &amp;laquo;рассматривать этот вызов как интерактивный&amp;raquo;. Но вы также можете выполнить эту работу, протестировав &lt;code&gt;called-interactively-p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54cfffd5c06cc33525dd38f3e201f1461707ae99" translate="yes" xml:space="preserve">
          <source>The above three arguments &lt;var&gt;init-value&lt;/var&gt;, &lt;var&gt;lighter&lt;/var&gt;, and &lt;var&gt;keymap&lt;/var&gt; can be (partially) omitted when &lt;var&gt;keyword-args&lt;/var&gt; are used. The &lt;var&gt;keyword-args&lt;/var&gt; consist of keywords followed by corresponding values. A few keywords have special meanings:</source>
          <target state="translated">Вышеупомянутые три аргумента &lt;var&gt;init-value&lt;/var&gt; , &lt;var&gt;lighter&lt;/var&gt; и &lt;var&gt;keymap&lt;/var&gt; могут быть (частично) опущены при использовании &lt;var&gt;keyword-args&lt;/var&gt; . В &lt;var&gt;keyword-args&lt;/var&gt; состоят из ключевых слов , после чего соответствующие значения. Некоторые ключевые слова имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="912c11980ecb67df3dcc61f5360f26f85c672e6b" translate="yes" xml:space="preserve">
          <source>The above variables actually take effect via the function &lt;code&gt;set-window-buffer&lt;/code&gt; (see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;), which calls &lt;code&gt;set-window-fringes&lt;/code&gt; as a subroutine. If you change one of these variables, the fringe display is not updated in existing windows showing the buffer, unless you call &lt;code&gt;set-window-buffer&lt;/code&gt; again in each affected window. You can also use &lt;code&gt;set-window-fringes&lt;/code&gt; to control the fringe display in individual windows.</source>
          <target state="translated">Вышеупомянутые переменные фактически вступают в силу через функцию &lt;code&gt;set-window-buffer&lt;/code&gt; (см. &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Буферы и Windows&lt;/a&gt; ), которая вызывает &lt;code&gt;set-window-fringes&lt;/code&gt; как подпрограмму. Если вы измените одну из этих переменных, отображение бахромы не будет обновлено в существующих окнах, показывающих буфер, если вы не вызовете &lt;code&gt;set-window-buffer&lt;/code&gt; снова в каждом затронутом окне. Вы также можете использовать &lt;code&gt;set-window-fringes&lt;/code&gt; для управления отображением бахромы в отдельных окнах.</target>
        </trans-unit>
        <trans-unit id="ca188b29b3bb57f7bcf3fb693861f1370085a8bf" translate="yes" xml:space="preserve">
          <source>The accepted &lt;var&gt;keyword&lt;/var&gt; values are &lt;code&gt;:bindtodevice&lt;/code&gt;, etc. For the complete list, see &lt;a href=&quot;network-options#Network-Options&quot;&gt;Network Options&lt;/a&gt;. This form returns non-&lt;code&gt;nil&lt;/code&gt; if that particular network option is supported by &lt;code&gt;make-network-process&lt;/code&gt; (or &lt;code&gt;set-network-process-option&lt;/code&gt;).</source>
          <target state="translated">Принятое &lt;var&gt;keyword&lt;/var&gt; значения &lt;code&gt;:bindtodevice&lt;/code&gt; и т.д. Для полного списка, см &lt;a href=&quot;network-options#Network-Options&quot;&gt;Сетевых параметры&lt;/a&gt; . Эта форма возвращает &lt;code&gt;nil&lt;/code&gt; если эта конкретная сетевая опция поддерживается &lt;code&gt;make-network-process&lt;/code&gt; (или &lt;code&gt;set-network-process-option&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc9760775537207d1cf5d5aa94d98184e1eb1a24" translate="yes" xml:space="preserve">
          <source>The action alist passed in each function call is:</source>
          <target state="translated">Алист действия,передаваемый при каждом вызове функции:</target>
        </trans-unit>
        <trans-unit id="4c1e9cf149ace88e3f3737c4a06b35438f05f558" translate="yes" xml:space="preserve">
          <source>The action code tells</source>
          <target state="translated">В коде действия сказано.</target>
        </trans-unit>
        <trans-unit id="20f7f463b94870cfb1b047961088cae0d326ca22" translate="yes" xml:space="preserve">
          <source>The actual completion is done by passing the completion table &lt;var&gt;collection&lt;/var&gt; and the completion predicate &lt;var&gt;predicate&lt;/var&gt; to the function &lt;code&gt;try-completion&lt;/code&gt; (see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;). This happens in certain commands bound in the local keymaps used for completion. Some of these commands also call &lt;code&gt;test-completion&lt;/code&gt;. Thus, if &lt;var&gt;predicate&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be compatible with &lt;var&gt;collection&lt;/var&gt; and &lt;code&gt;completion-ignore-case&lt;/code&gt;. See &lt;a href=&quot;basic-completion#Definition-of-test_002dcompletion&quot;&gt;Definition of test-completion&lt;/a&gt;.</source>
          <target state="translated">Фактическое завершение выполняется путем передачи &lt;var&gt;collection&lt;/var&gt; таблицы завершения и предиката &lt;var&gt;predicate&lt;/var&gt; завершения функции &lt;code&gt;try-completion&lt;/code&gt; (см. &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Базовое завершение&lt;/a&gt; ). Это происходит в некоторых командах, привязанных к локальным таблицам клавиш, используемым для завершения. Некоторые из этих команд также вызывают &lt;code&gt;test-completion&lt;/code&gt; . Таким образом, если &lt;var&gt;predicate&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , он должен быть совместим со &lt;var&gt;collection&lt;/var&gt; и &lt;code&gt;completion-ignore-case&lt;/code&gt; . См. &lt;a href=&quot;basic-completion#Definition-of-test_002dcompletion&quot;&gt;Определение завершения теста&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1af2bc35ffe0c2bc3b64bd633b7094bc586529d" translate="yes" xml:space="preserve">
          <source>The actual vertical scroll position must always correspond to an integral number of pixels, so the value you specify is rounded accordingly.</source>
          <target state="translated">Действительное положение вертикальной прокрутки должно всегда соответствовать интегральному числу пикселей,поэтому заданное вами значение соответственно округляется.</target>
        </trans-unit>
        <trans-unit id="ff765a1d0b1ea170510397b3d6bdae6f65de5184" translate="yes" xml:space="preserve">
          <source>The address of the buffer contents. The buffer contents is a linear C array of &lt;code&gt;char&lt;/code&gt;, with the gap somewhere in its midst.</source>
          <target state="translated">Адрес содержимого буфера. Содержимое буфера - это линейный массив &lt;code&gt;char&lt;/code&gt; C с пробелом где-то посередине.</target>
        </trans-unit>
        <trans-unit id="b3c2ee5327a92dfc5bf111a48a9aefa1920eaf43" translate="yes" xml:space="preserve">
          <source>The advantage of dynamic function loading is that loading the file should become faster. This is a good thing for a file which contains many separate user-callable functions, if using one of them does not imply you will probably also use the rest. A specialized mode which provides many keyboard commands often has that usage pattern: a user may invoke the mode, but use only a few of the commands it provides.</source>
          <target state="translated">Преимущество динамической загрузки функций состоит в том,что загрузка файла должна происходить быстрее.Это хорошо для файла,который содержит множество отдельных вызываемых пользователем функций,если использование одной из них не подразумевает,что вы,вероятно,будете использовать и остальные.Специализированный режим,предоставляющий множество клавиатурных команд,часто имеет такую схему использования:пользователь может вызвать режим,но использовать только несколько команд,которые он предоставляет.</target>
        </trans-unit>
        <trans-unit id="d5619eed72157c4d0bdb07860d63c48de2da3d98" translate="yes" xml:space="preserve">
          <source>The advantage of this formulation is that it reuses the indentation of the previous &lt;code&gt;&quot;else&quot;&lt;/code&gt;, rather than going all the way back to the first &lt;code&gt;&quot;if&quot;&lt;/code&gt; of the sequence.</source>
          <target state="translated">Преимущество этой формулировки состоит в том, что она повторно использует отступ предыдущего &lt;code&gt;&quot;else&quot;&lt;/code&gt; , а не полностью возвращается к первому &lt;code&gt;&quot;if&quot;&lt;/code&gt; в последовательности.</target>
        </trans-unit>
        <trans-unit id="3a50be9f4a1773d19c2822e2848993b6a2da815f" translate="yes" xml:space="preserve">
          <source>The advantage of using this variable rather than an ordinary global variable is that the data will never carry over to a subsequent command invocation.</source>
          <target state="translated">Преимущество использования этой переменной,а не обычной глобальной переменной,заключается в том,что данные никогда не будут перенесены на последующий вызов команды.</target>
        </trans-unit>
        <trans-unit id="1596d1cec331c0a1119dda271b5137a09454b0dd" translate="yes" xml:space="preserve">
          <source>The alist containing the structured data that have been unpacked so far, or the entire structure being packed. You can use &lt;code&gt;bindat-get-field&lt;/code&gt; to access specific fields of this structure.</source>
          <target state="translated">Список, содержащий структурированные данные, которые уже были распакованы, или всю упаковываемую структуру. Вы можете использовать &lt;code&gt;bindat-get-field&lt;/code&gt; для доступа к определенным полям этой структуры.</target>
        </trans-unit>
        <trans-unit id="16a4156fb321a63923ec85058a36944c0a91c6f3" translate="yes" xml:space="preserve">
          <source>The alist describes which parameters were specified in &lt;var&gt;geom&lt;/var&gt;, and gives the values specified for them. Each element looks like &lt;code&gt;(&lt;var&gt;parameter&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;. The possible &lt;var&gt;parameter&lt;/var&gt; values are &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt;.</source>
          <target state="translated">Список описывает, какие параметры были указаны в &lt;var&gt;geom&lt;/var&gt; , и дает значения, указанные для них. Каждый элемент имеет вид &lt;code&gt;(&lt;var&gt;parameter&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; . Возможные значения &lt;var&gt;parameter&lt;/var&gt; : &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; и &lt;code&gt;height&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c733f98486863c87c8afe728430d26b6647157fa" translate="yes" xml:space="preserve">
          <source>The alist of this window&amp;rsquo;s parameters.</source>
          <target state="translated">Список параметров этого окна.</target>
        </trans-unit>
        <trans-unit id="4de99a71510486f7e37d746816616f03fc75f487" translate="yes" xml:space="preserve">
          <source>The alt modifier.</source>
          <target state="translated">Изменение модификатора.</target>
        </trans-unit>
        <trans-unit id="c9957faf6d8ce383f9b22bb3d1e72f7bd208cd8d" translate="yes" xml:space="preserve">
          <source>The angle in degrees by which the x-axis of the ellipse is rotated relative to the x-axis of the current coordinate system.</source>
          <target state="translated">Угол в градусах,на который поворачивается ось х эллипса относительно оси х текущей системы координат.</target>
        </trans-unit>
        <trans-unit id="6140640f4032f19682107247228755508d75322e" translate="yes" xml:space="preserve">
          <source>The answers and their meanings, even &amp;lsquo;</source>
          <target state="translated">Ответы и их значение, даже '</target>
        </trans-unit>
        <trans-unit id="eb1ac55dfe1608150149494f5a53ac6108d010b5" translate="yes" xml:space="preserve">
          <source>The appearance of child frames is largely dependent on the parameters provided via &lt;var&gt;alist&lt;/var&gt;. It is advisable to use at least ratios to specify the size (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) and the position (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) of the child frame, and to add a &lt;code&gt;keep-ratio&lt;/code&gt; parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;), in order to make sure that the child frame remains visible. For other parameters that should be considered see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;.</source>
          <target state="translated">Внешний вид дочерних фреймов во многом зависит от параметров, предоставленных через &lt;var&gt;alist&lt;/var&gt; . Рекомендуется использовать как минимум отношения, чтобы указать размер (см. &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Параметры размера&lt;/a&gt; ) и положение (см. &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Параметры положения&lt;/a&gt; ) дочернего фрейма, а также добавить параметр &lt;code&gt;keep-ratio&lt;/code&gt; (см. &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Параметры взаимодействия с кадрами&lt;/a&gt; ), чтобы убедиться, что что дочерний фрейм остается видимым. Для других параметров, которые следует учитывать, см. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Дочерние фреймы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="298a0fa20ea50d72583add29a3d5ae410ddedeac" translate="yes" xml:space="preserve">
          <source>The appearance of the keyword &lt;code&gt;&amp;amp;optional&lt;/code&gt; in the argument list indicates that the subsequent arguments may be omitted (omitted arguments default to &lt;code&gt;nil&lt;/code&gt;). Do not write &lt;code&gt;&amp;amp;optional&lt;/code&gt; when you call the function.</source>
          <target state="translated">Появление ключевого слова &lt;code&gt;&amp;amp;optional&lt;/code&gt; в списке аргументов указывает на то, что последующие аргументы могут быть опущены (опущенные аргументы по умолчанию &lt;code&gt;nil&lt;/code&gt; ). Не пишите &lt;code&gt;&amp;amp;optional&lt;/code&gt; при вызове функции.</target>
        </trans-unit>
        <trans-unit id="3f5c7ba81da02c1e205b368aaea8e197ad50a24b" translate="yes" xml:space="preserve">
          <source>The applicable methods are sorted into the order in which they will be combined. The method whose left-most argument specializer is the most specific one will come first in the order. (Specifying &lt;code&gt;:argument-precedence-order&lt;/code&gt; as part of &lt;code&gt;cl-defmethod&lt;/code&gt; overrides that, as described above.) If the method body calls &lt;code&gt;cl-call-next-method&lt;/code&gt;, the next most-specific method will run. If there are applicable &lt;code&gt;:around&lt;/code&gt; methods, the most-specific of them will run first; it should call &lt;code&gt;cl-call-next-method&lt;/code&gt; to run any of the less specific &lt;code&gt;:around&lt;/code&gt; methods. Next, the &lt;code&gt;:before&lt;/code&gt; methods run in the order of their specificity, followed by the primary method, and lastly the &lt;code&gt;:after&lt;/code&gt; methods in the reverse order of their specificity.</source>
          <target state="translated">Применимые методы отсортированы в том порядке, в котором они будут объединены. Метод, у которого крайний левый специализатор аргументов является наиболее конкретным, будет первым в порядке. (Указание &lt;code&gt;:argument-precedence-order&lt;/code&gt; как часть &lt;code&gt;cl-defmethod&lt;/code&gt; переопределяет это, как описано выше.) Если тело метода вызывает &lt;code&gt;cl-call-next-method&lt;/code&gt; , будет запущен следующий наиболее специфичный метод. Если есть подходящие методы &lt;code&gt;:around&lt;/code&gt; , сначала будут выполняться наиболее специфичные из них; он должен вызвать &lt;code&gt;cl-call-next-method&lt;/code&gt; для запуска любого из менее специфичных методов &lt;code&gt;:around&lt;/code&gt; . Затем методы &lt;code&gt;:before&lt;/code&gt; выполняются в порядке их специфичности, за ними следует основной метод и, наконец, &lt;code&gt;:after&lt;/code&gt; в порядке, обратном их специфичности.</target>
        </trans-unit>
        <trans-unit id="c76f854944de42c1326dc55d5c64da71693c76d4" translate="yes" xml:space="preserve">
          <source>The appropriate comment syntax settings for C++ can be as follows:</source>
          <target state="translated">Соответствующие настройки синтаксиса комментариев для C++могут быть следующими:</target>
        </trans-unit>
        <trans-unit id="7af380f8e979eb018fdd3697719035381131cdb4" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;name&lt;/code&gt; can also be a predicate function. The predicate is called for every directory examined by the function, starting from &lt;var&gt;file&lt;/var&gt; (even if &lt;var&gt;file&lt;/var&gt; is not a directory). It is called with one argument (the file or directory) and should return non-&lt;code&gt;nil&lt;/code&gt; if that directory is the one it is looking for.</source>
          <target state="translated">Аргумент &lt;code&gt;name&lt;/code&gt; может быть также предикат функции. Предикат вызывается для каждого каталога, проверяемого функцией, начиная с &lt;var&gt;file&lt;/var&gt; (даже если &lt;var&gt;file&lt;/var&gt; не является каталогом). Он вызывается с одним аргументом (файл или каталог) и должен возвращать &lt;code&gt;nil&lt;/code&gt; если это тот каталог, который он ищет.</target>
        </trans-unit>
        <trans-unit id="3ca220a7d203286861c22592355a8976c8e1dc15" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;accept-defaults&lt;/var&gt; controls checking for default bindings, as in &lt;code&gt;lookup-key&lt;/code&gt; (above).</source>
          <target state="translated">Аргумент &lt;var&gt;accept-defaults&lt;/var&gt; управляет проверкой привязок по умолчанию, как в &lt;code&gt;lookup-key&lt;/code&gt; (выше).</target>
        </trans-unit>
        <trans-unit id="7bd635c6abdd8e152863881cdc6fa5ff15a5ff9d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;accept-defaults&lt;/var&gt; controls checking for default bindings, as in &lt;code&gt;lookup-key&lt;/code&gt; (see &lt;a href=&quot;functions-for-key-lookup#Functions-for-Key-Lookup&quot;&gt;Functions for Key Lookup&lt;/a&gt;).</source>
          <target state="translated">Аргумент &lt;var&gt;accept-defaults&lt;/var&gt; управляет проверкой привязок по умолчанию, как в &lt;code&gt;lookup-key&lt;/code&gt; (см. &lt;a href=&quot;functions-for-key-lookup#Functions-for-Key-Lookup&quot;&gt;Функции для поиска по ключу&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d29509ca5aacfab823a57d08757922aaad71cdd0" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;action&lt;/var&gt; can also have a non-&lt;code&gt;nil&lt;/code&gt;, non-list value. This has the special meaning that the buffer should be displayed in a window other than the selected one, even if the selected window is already displaying it. If called interactively with a prefix argument, &lt;var&gt;action&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;. Lisp programs should always supply a list value.</source>
          <target state="translated">Аргумент &lt;var&gt;action&lt;/var&gt; может также иметь не- &lt;code&gt;nil&lt;/code&gt; , без списка значения. Это имеет особое значение, что буфер должен отображаться в окне, отличном от выбранного, даже если выбранное окно уже отображает его. Если вызывается интерактивно с аргументом префикса, &lt;var&gt;action&lt;/var&gt; - &lt;code&gt;t&lt;/code&gt; . Программы на Лиспе всегда должны предоставлять значение списка.</target>
        </trans-unit>
        <trans-unit id="1beb69cfa7b071babf9978632af37dd09371bacd" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;actor&lt;/var&gt; says how to act on the answers that the user gives. It should be a function of one argument, and it is called with each object that the user says yes for. Its argument is always an object obtained from &lt;var&gt;list&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;actor&lt;/var&gt; аргумента говорит, как действовать в соответствии с ответами, которые дает пользователь. Это должна быть функция одного аргумента, и она вызывается для каждого объекта, для которого пользователь соглашается. Его аргумент всегда является объектом, полученным из &lt;var&gt;list&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ee17f20b9e88dfb3aa41595d461a73079a3e5d43" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;align&lt;/var&gt; specifies the positioning of the bitmap relative to the range of rows where it is used; the default is to center the bitmap. The allowed values are &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, or &lt;code&gt;bottom&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;align&lt;/var&gt; указывает расположение растрового изображения относительно диапазона строк, в котором оно используется; по умолчанию растровое изображение центрируется. Допустимые значения: &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;center&lt;/code&gt; или &lt;code&gt;bottom&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7753c98dbb86ce3ef5fdc83ef2b7a29620966442" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;area&lt;/var&gt; specifies whether to put the image in a margin. If it is &lt;code&gt;left-margin&lt;/code&gt;, the image appears in the left margin; &lt;code&gt;right-margin&lt;/code&gt; specifies the right margin. If &lt;var&gt;area&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, the image is displayed at point within the buffer&amp;rsquo;s text.</source>
          <target state="translated">Аргумент &lt;var&gt;area&lt;/var&gt; указывает , следует ли поместить изображение в полях. Если это &lt;code&gt;left-margin&lt;/code&gt; , изображение появляется в левом поле; &lt;code&gt;right-margin&lt;/code&gt; определяет правое поле. Если &lt;var&gt;area&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; или опущено, изображение отображается в точке внутри текста буфера.</target>
        </trans-unit>
        <trans-unit id="d364497680dc1a96c19f79375cbd6751df8d0fba" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;args&lt;/var&gt; is a list of keyword/argument pairs. The following keywords are accepted:</source>
          <target state="translated">Аргумент &lt;var&gt;args&lt;/var&gt; - это список пар ключевое слово / аргумент. Допускаются следующие ключевые слова:</target>
        </trans-unit>
        <trans-unit id="edb4e5ef6ed5ceb13b27dd15b0d01fa920d79d9f" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;auto-mode-list&lt;/var&gt; is a list of regular expressions to add to the variable &lt;code&gt;auto-mode-alist&lt;/code&gt;. They are added by the execution of the &lt;code&gt;define-generic-mode&lt;/code&gt; form, not by expanding the macro call.</source>
          <target state="translated">Аргумент &lt;var&gt;auto-mode-list&lt;/var&gt; - это список регулярных выражений, которые нужно добавить к переменной &lt;code&gt;auto-mode-alist&lt;/code&gt; . Они добавляются при выполнении формы &lt;code&gt;define-generic-mode&lt;/code&gt; , а не при расширении вызова макроса.</target>
        </trans-unit>
        <trans-unit id="9ee6a087463d0ff4f764f5b9d27cda3abf523b0f" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;bits&lt;/var&gt; specifies the image to use. It should be either a string or a vector of integers, where each element (an integer) corresponds to one row of the bitmap. Each bit of an integer corresponds to one pixel of the bitmap, where the low bit corresponds to the rightmost pixel of the bitmap. (Note that this order of bits is opposite of the order in XBM images; see &lt;a href=&quot;xbm-images#XBM-Images&quot;&gt;XBM Images&lt;/a&gt;.)</source>
          <target state="translated">Аргумент &lt;var&gt;bits&lt;/var&gt; указывает изображение для использования. Это должна быть строка или вектор целых чисел, где каждый элемент (целое число) соответствует одной строке растрового изображения. Каждый бит целого числа соответствует одному пикселю растрового изображения, где младший бит соответствует крайнему правому пикселю растрового изображения. (Обратите внимание, что этот порядок битов противоположен порядку в изображениях XBM; см. &lt;a href=&quot;xbm-images#XBM-Images&quot;&gt;Изображения XBM&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="9b233061a24b93e6081107b51828a209e52ef880" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;buf&lt;/var&gt; can be a &lt;code&gt;NULL&lt;/code&gt; pointer, in which case the function stores in &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; the number of bytes required for storing the contents of &lt;var&gt;arg&lt;/var&gt;, and returns &lt;code&gt;true&lt;/code&gt;. This is how you can determine the size of &lt;var&gt;buf&lt;/var&gt; needed to store a particular string: first call &lt;code&gt;copy_string_contents&lt;/code&gt; with &lt;code&gt;NULL&lt;/code&gt; as &lt;var&gt;buf&lt;/var&gt;, then allocate enough memory to hold the number of bytes stored by the function in &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt;, and call the function again with non-&lt;code&gt;NULL&lt;/code&gt;&lt;var&gt;buf&lt;/var&gt; to actually perform the text copying.</source>
          <target state="translated">Аргумент &lt;var&gt;buf&lt;/var&gt; может быть указателем &lt;code&gt;NULL&lt;/code&gt; , и в этом случае функция сохраняет в &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; количество байтов, необходимое для хранения содержимого &lt;var&gt;arg&lt;/var&gt; , и возвращает &lt;code&gt;true&lt;/code&gt; . Вот как вы можете определить размер &lt;var&gt;buf&lt;/var&gt; , необходимый для хранения конкретной строки: сначала вызовите &lt;code&gt;copy_string_contents&lt;/code&gt; с &lt;code&gt;NULL&lt;/code&gt; как &lt;var&gt;buf&lt;/var&gt; , затем выделите достаточно памяти для хранения количества байтов, сохраненных функцией в &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; , и снова вызовите функцию с не - &lt;code&gt;NULL&lt;/code&gt; &lt;var&gt;buf&lt;/var&gt; для фактического копирования текста.</target>
        </trans-unit>
        <trans-unit id="c62f796ca367437edd9bbfec13b2cb245b68f3a0" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;buffer-or-name&lt;/var&gt; specifies the temporary buffer. It can be either a buffer, which must already exist, or a string, in which case a buffer of that name is created, if necessary. The buffer is marked as unmodified and read-only when &lt;code&gt;with-temp-buffer-window&lt;/code&gt; exits.</source>
          <target state="translated">Аргумент &lt;var&gt;buffer-or-name&lt;/var&gt; указывает временный буфер. Это может быть либо буфер, который уже должен существовать, либо строка, и в этом случае при необходимости создается буфер с таким именем. Буфер помечается как немодифицированный и доступный только для чтения при выходе из &lt;code&gt;with-temp-buffer-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1c5d94728b5d5501baf9d04c247ab6731f26635" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;character-set&lt;/var&gt; is a string, like the inside of a &amp;lsquo;</source>
          <target state="translated">Набор &lt;var&gt;character-set&lt;/var&gt; аргумента - это строка, как внутри символа '</target>
        </trans-unit>
        <trans-unit id="454b60cd7a8b9522c076db2ecfb6a4f1bed5da38" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;color&lt;/var&gt; must be a valid color name.</source>
          <target state="translated">&lt;var&gt;color&lt;/var&gt; аргумента должен быть допустимым именем цвета.</target>
        </trans-unit>
        <trans-unit id="18f7ad6dac6cb9de707886ec8955eea2d280c1e3" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;command-loop&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that this key sequence is being read by something that will read commands one after another. It should be &lt;code&gt;nil&lt;/code&gt; if the caller will read just one key sequence.</source>
          <target state="translated">Аргумент &lt;var&gt;command-loop&lt;/var&gt; , если не равен &lt;code&gt;nil&lt;/code&gt; , означает, что эта последовательность клавиш читается чем-то, что будет читать команды одну за другой. Он должен быть равен &lt;code&gt;nil&lt;/code&gt; если вызывающий будет читать только одну последовательность клавиш.</target>
        </trans-unit>
        <trans-unit id="73cd856bd4485d69fb41a49bb978b8e54f955de7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;command&lt;/var&gt; can be any object; it is compared with all keymap entries using &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;command&lt;/var&gt; может быть любым объектом; он сравнивается со всеми записями раскладки клавиатуры с помощью &lt;code&gt;eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c292ebda07b62fafda1bd9dcde58aac39ae09123" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;comment-list&lt;/var&gt; is a list in which each element is either a character, a string of one or two characters, or a cons cell. A character or a string is set up in the mode&amp;rsquo;s syntax table as a comment starter. If the entry is a cons cell, the &lt;small&gt;CAR&lt;/small&gt; is set up as a comment starter and the &lt;small&gt;CDR&lt;/small&gt; as a comment ender. (Use &lt;code&gt;nil&lt;/code&gt; for the latter if you want comments to end at the end of the line.) Note that the syntax table mechanism has limitations about what comment starters and enders are actually possible. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;.</source>
          <target state="translated">Список- &lt;var&gt;comment-list&lt;/var&gt; аргумента - это список, в котором каждый элемент представляет собой символ, строку из одного или двух символов или cons-ячейку. Символ или строка задаются в таблице синтаксиса режима как начало комментария. Если запись является cons-ячейкой, &lt;small&gt;CAR&lt;/small&gt; настраивается как средство запуска комментария, а &lt;small&gt;CDR&lt;/small&gt; как средство завершения комментария. (Используйте &lt;code&gt;nil&lt;/code&gt; для последнего, если вы хотите, чтобы комментарии заканчивались в конце строки.) Обратите внимание, что механизм таблицы синтаксиса имеет ограничения на то, какие начальные и конечные элементы комментариев фактически возможны. См. &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Таблицы синтаксиса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00acfc829089029b9f202f10adf5992c457658f8" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;count&lt;/var&gt; is a repeat count; &lt;var&gt;kbdmacro&lt;/var&gt; is executed that many times. If &lt;var&gt;count&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;kbdmacro&lt;/var&gt; is executed once. If it is 0, &lt;var&gt;kbdmacro&lt;/var&gt; is executed over and over until it encounters an error or a failing search.</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; аргументов - это количество повторов; &lt;var&gt;kbdmacro&lt;/var&gt; выполняется много раз. Если &lt;var&gt;count&lt;/var&gt; опущен или &lt;var&gt;kbdmacro&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; , kbdmacro выполняется один раз. Если он равен 0, &lt;var&gt;kbdmacro&lt;/var&gt; выполняется снова и снова, пока не обнаружит ошибку или неудачный поиск.</target>
        </trans-unit>
        <trans-unit id="8c7ff309333d395240c83333e112d50cc4709c16" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;current-group&lt;/var&gt; is a flag that makes a difference when you are running a job-control shell as an Emacs subprocess. If it is non-&lt;code&gt;nil&lt;/code&gt;, then the signal is sent to the current process-group of the terminal that Emacs uses to communicate with the subprocess. If the process is a job-control shell, this means the shell&amp;rsquo;s current subjob. If &lt;var&gt;current-group&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the signal is sent to the process group of the immediate subprocess of Emacs. If the subprocess is a job-control shell, this is the shell itself. If &lt;var&gt;current-group&lt;/var&gt; is &lt;code&gt;lambda&lt;/code&gt;, the signal is sent to the process-group that owns the terminal, but only if it is not the shell itself.</source>
          <target state="translated">Аргумент &lt;var&gt;current-group&lt;/var&gt; - это флаг, который имеет значение, когда вы запускаете оболочку управления заданиями как подпроцесс Emacs. Если оно не равно &lt;code&gt;nil&lt;/code&gt; , то сигнал посылается в текущую группу процессов терминала, которую Emacs использует для связи с подпроцессом. Если процесс является оболочкой управления заданием, это означает текущую подзадание оболочки. Если &lt;var&gt;current-group&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , сигнал посылается группе процессов непосредственного подпроцесса Emacs. Если подпроцесс является оболочкой управления заданиями, это сама оболочка. Если &lt;var&gt;current-group&lt;/var&gt; - &lt;code&gt;lambda&lt;/code&gt; , сигнал отправляется группе процессов, которой принадлежит терминал, но только если это не сама оболочка.</target>
        </trans-unit>
        <trans-unit id="d3941ef4572aafabe4d82a914cd588f566cf28f8" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;data&lt;/var&gt; is a way to arrange for arbitrary additional data to be passed to &lt;var&gt;func&lt;/var&gt; when it is called. Whatever pointer is passed to &lt;code&gt;make_function&lt;/code&gt; will be passed unaltered to &lt;var&gt;func&lt;/var&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;data&lt;/var&gt; является способ организовать для произвольных дополнительных данных , которые должны быть переданы &lt;var&gt;func&lt;/var&gt; , когда она вызывается. Любой указатель, переданный в &lt;code&gt;make_function&lt;/code&gt; , будет передан в &lt;var&gt;func&lt;/var&gt; без изменений .</target>
        </trans-unit>
        <trans-unit id="b7de2b6cb91524eff278a8127fa1412f99cec41e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;default&lt;/var&gt; specifies default values to make available through the history commands. It should be a string, a list of strings, or &lt;code&gt;nil&lt;/code&gt;. The string or strings become the minibuffer&amp;rsquo;s &amp;ldquo;future history&amp;rdquo;, available to the user with</source>
          <target state="translated">Аргумент &lt;var&gt;default&lt;/var&gt; определяет значения по умолчанию, которые будут доступны через команды истории. Это должна быть строка, список строк или &lt;code&gt;nil&lt;/code&gt; . Строка или строки становятся &amp;laquo;будущей историей&amp;raquo; минибуфера, доступной пользователю с</target>
        </trans-unit>
        <trans-unit id="0fd8a73b42de8615825093fdcc1004c92eed7544" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;default&lt;/var&gt; specifies what to return if the user enters null input. It can be a symbol, a string or a list of strings. If it is a string, &lt;code&gt;read-command&lt;/code&gt; interns it before returning it. If it is a list, &lt;code&gt;read-command&lt;/code&gt; interns the first element of this list. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means no default has been specified; then if the user enters null input, the return value is &lt;code&gt;(intern &quot;&quot;)&lt;/code&gt;, that is, a symbol whose name is an empty string, and whose printed representation is &lt;code&gt;##&lt;/code&gt; (see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;).</source>
          <target state="translated">Аргумент по &lt;var&gt;default&lt;/var&gt; указывает, что возвращать, если пользователь вводит нулевой ввод. Это может быть символ, строка или список строк. Если это строка, &lt;code&gt;read-command&lt;/code&gt; обрабатывает ее перед возвратом. Если это список, &lt;code&gt;read-command&lt;/code&gt; обрабатывает первый элемент этого списка. Если &lt;var&gt;default&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , это означает, что значение по умолчанию не задано; затем, если пользователь вводит нулевой ввод, возвращаемое значение - &lt;code&gt;(intern &quot;&quot;)&lt;/code&gt; , то есть символ, имя которого является пустой строкой, и чье печатное представление - &lt;code&gt;##&lt;/code&gt; (см. &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Тип символа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4c97f0e8be6d0008a7faafdfd445d05e4a3215d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;directory&lt;/var&gt; specifies the directory to use for completing relative file names. It should be an absolute directory name. If the variable &lt;code&gt;insert-default-directory&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;directory&lt;/var&gt; is also inserted in the minibuffer as initial input. It defaults to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;directory&lt;/var&gt; указывает каталог, используемый для завершения относительных имен файлов. Это должно быть абсолютное имя каталога. Если переменная &lt;code&gt;insert-default-directory&lt;/code&gt; не равна &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;directory&lt;/var&gt; также вставляется в минибуфер в качестве начального ввода. По умолчанию используется значение текущего буфера &lt;code&gt;default-directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eac6e77f50cc69887c03e5e7a9a7a83098c352ec" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;doc&lt;/var&gt; specifies the documentation string for the variable.</source>
          <target state="translated">Аргумент &lt;var&gt;doc&lt;/var&gt; указывает строку документации для переменной.</target>
        </trans-unit>
        <trans-unit id="7781b509373191b675fad7c943463743a5b15403" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;docstring&lt;/var&gt; is the documentation string for the function. Specifying the documentation string in the call to &lt;code&gt;autoload&lt;/code&gt; makes it possible to look at the documentation without loading the function&amp;rsquo;s real definition. Normally, this should be identical to the documentation string in the function definition itself. If it isn&amp;rsquo;t, the function definition&amp;rsquo;s documentation string takes effect when it is loaded.</source>
          <target state="translated">Аргумент &lt;var&gt;docstring&lt;/var&gt; - это строка документации для функции. Указание строки документации при вызове &lt;code&gt;autoload&lt;/code&gt; позволяет просматривать документацию без загрузки реального определения функции. Обычно это должно быть идентично строке документации в самом определении функции. Если это не так, строка документации определения функции вступает в силу после ее загрузки.</target>
        </trans-unit>
        <trans-unit id="04e091f63b7fbae98fa99c0bac21a5a178106ee2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;docstring&lt;/var&gt; specifies the documentation string for the function. It should be either an</source>
          <target state="translated">Аргумент &lt;var&gt;docstring&lt;/var&gt; указывает строку документации для функции. Это должно быть либо</target>
        </trans-unit>
        <trans-unit id="bd17ab1ce2a49502882ba295a450f07a837d7a99" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;docstring&lt;/var&gt; specifies the documentation string for the new mode. &lt;code&gt;define-derived-mode&lt;/code&gt; adds some general information about the mode&amp;rsquo;s hook, followed by the mode&amp;rsquo;s keymap, at the end of this documentation string. If you omit &lt;var&gt;docstring&lt;/var&gt;, &lt;code&gt;define-derived-mode&lt;/code&gt; generates a documentation string.</source>
          <target state="translated">Аргумент &lt;var&gt;docstring&lt;/var&gt; указывает строку документации для нового режима. &lt;code&gt;define-derived-mode&lt;/code&gt; добавляет некоторую общую информацию о ловушке режима, за которой следует раскладка клавиатуры режима, в конце этой строки документации. Если вы опускаете &lt;var&gt;docstring&lt;/var&gt; , &lt;code&gt;define-derived-mode&lt;/code&gt; генерирует строку документации.</target>
        </trans-unit>
        <trans-unit id="8b2f3e02d30ef15fdb865417c6bf4e751f67ad61" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;error-symbol&lt;/var&gt; must be an &lt;em&gt;error symbol&lt;/em&gt;&amp;mdash;a symbol defined with &lt;code&gt;define-error&lt;/code&gt;. This is how Emacs Lisp classifies different sorts of errors. See &lt;a href=&quot;error-symbols#Error-Symbols&quot;&gt;Error Symbols&lt;/a&gt;, for a description of error symbols, error conditions and condition names.</source>
          <target state="translated">Аргумент &lt;var&gt;error-symbol&lt;/var&gt; должен быть &lt;em&gt;символом ошибки&lt;/em&gt; - символом, определенным с помощью &lt;code&gt;define-error&lt;/code&gt; . Именно так Emacs Lisp классифицирует различные типы ошибок. См. В &lt;a href=&quot;error-symbols#Error-Symbols&quot;&gt;разделе &amp;laquo;Символы ошибок&amp;raquo;&lt;/a&gt; описание символов ошибок, состояний ошибок и названий условий.</target>
        </trans-unit>
        <trans-unit id="bc63a3477a188838da943b9200d27c84d6d19f56" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;event&lt;/var&gt; may be an entire event object, or just an event type. If &lt;var&gt;event&lt;/var&gt; is a symbol that has never been used in an event that has been read as input in the current Emacs session, then &lt;code&gt;event-modifiers&lt;/code&gt; can return &lt;code&gt;nil&lt;/code&gt;, even when &lt;var&gt;event&lt;/var&gt; actually has modifiers.</source>
          <target state="translated">&lt;var&gt;event&lt;/var&gt; аргумента может быть целым объектом события или только типом события. Если &lt;var&gt;event&lt;/var&gt; - это символ, который никогда не использовался в событии, которое считывалось как ввод в текущем сеансе Emacs, тогда &lt;code&gt;event-modifiers&lt;/code&gt; могут возвращать &lt;code&gt;nil&lt;/code&gt; , даже если &lt;var&gt;event&lt;/var&gt; действительно имеет модификаторы.</target>
        </trans-unit>
        <trans-unit id="7904c0efac8eb6a309359bc0c8d1556bb612c4b3" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;file&lt;/var&gt; may be either a directory or a file specification including wildcard characters. If &lt;var&gt;wildcard&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means treat &lt;var&gt;file&lt;/var&gt; as a file specification with wildcards.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; аргументов может быть каталогом или спецификацией файла, включая подстановочные знаки. Если &lt;var&gt;wildcard&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , это означает, что &lt;var&gt;file&lt;/var&gt; рассматривать как спецификацию файла с подстановочными знаками.</target>
        </trans-unit>
        <trans-unit id="9371be3ca14b7d72d73c5ede9be6979d9d6d0623" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;force&lt;/var&gt; also has an effect if the line isn&amp;rsquo;t long enough to reach column &lt;var&gt;column&lt;/var&gt;; if it is &lt;code&gt;t&lt;/code&gt;, that means to add whitespace at the end of the line to reach that column.</source>
          <target state="translated">Аргумент &lt;var&gt;force&lt;/var&gt; также действует, если длина строки недостаточна для достижения столбца &lt;var&gt;column&lt;/var&gt; ; если это &lt;code&gt;t&lt;/code&gt; , это означает добавление пробела в конце строки для достижения этого столбца.</target>
        </trans-unit>
        <trans-unit id="12147a609851b483f1ee7c1184f437efbf04c5a7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;format&lt;/var&gt; is a list of format names. If &lt;var&gt;format&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, no conversion takes place. Interactively, typing just</source>
          <target state="translated">Аргумент &lt;var&gt;format&lt;/var&gt; представляет собой список имен форматов. Если &lt;var&gt;format&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , преобразование не происходит. В интерактивном режиме, просто печатая</target>
        </trans-unit>
        <trans-unit id="4e552f392e638ae5e1cc465f462059be7ffc7762" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;function&lt;/var&gt; must be a function that can take one argument and returns a sequence of characters: a string, a vector, or a list. The argument &lt;var&gt;sequence&lt;/var&gt; can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string.</source>
          <target state="translated">Аргумент &lt;var&gt;function&lt;/var&gt; должна быть функцией , которая может принимать один аргумент и возвращают последовательность символов: строка, вектор или список. Аргумент &lt;var&gt;sequence&lt;/var&gt; может быть любой вид последовательности , кроме полукокса-таблицы; то есть список, вектор, логический вектор или строка.</target>
        </trans-unit>
        <trans-unit id="ddc30685dfa4ed9158a6234aef7cfe1c4019a601" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;function&lt;/var&gt; must be either a Lisp function or a primitive function. Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions. &lt;code&gt;funcall&lt;/code&gt; cannot provide these because, as we saw above, it never knows them in the first place.</source>
          <target state="translated">Аргумент &lt;var&gt;function&lt;/var&gt; должна быть либо функции Lisp или примитивная функция. Специальные формы и макросы не разрешены, потому что они имеют смысл только при задании неоцененных выражений аргументов. &lt;code&gt;funcall&lt;/code&gt; не может их предоставить, потому что, как мы видели выше, он никогда их не знает.</target>
        </trans-unit>
        <trans-unit id="2e30324ca741e84e486f486ca93672bb66bab46e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;help-line&lt;/var&gt; should be a single-line summary of the alternatives in &lt;var&gt;help-map&lt;/var&gt;. In the current version of Emacs, this argument is used only if you set the option &lt;code&gt;three-step-help&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;help-line&lt;/var&gt; аргумента должна быть однострочным резюме альтернатив в &lt;var&gt;help-map&lt;/var&gt; . В текущей версии Emacs этот аргумент используется только в том случае, если вы установите для опции &lt;code&gt;three-step-help&lt;/code&gt; значение &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="127d393be33d3a8d95a8598319f7563453a6009e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;history&lt;/var&gt; specifies a history list variable to use for saving the input and for history commands used in the minibuffer. It defaults to &lt;code&gt;minibuffer-history&lt;/code&gt;. You can optionally specify a starting position in the history list as well. See &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;history&lt;/var&gt; определяет переменную списка истории, используемую для сохранения ввода и для команд истории, используемых в минибуфере. По умолчанию используется &lt;code&gt;minibuffer-history&lt;/code&gt; . При желании вы также можете указать начальную позицию в списке истории. См. &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Историю минибуфера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3573ac7d09f3cbe3a9ed7cb1b453c6e5b9ae6a98" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;history&lt;/var&gt; specifies which history list variable to use for saving the input and for minibuffer history commands. It defaults to &lt;code&gt;minibuffer-history&lt;/code&gt;. See &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;history&lt;/var&gt; указывает, какую переменную списка истории использовать для сохранения ввода и для команд истории минибуфера. По умолчанию используется &lt;code&gt;minibuffer-history&lt;/code&gt; . См. &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Историю минибуфера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="337728b68989d9c2d290c7b3166cd39cbd7d6a6f" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;hook&lt;/var&gt; is a function or &lt;code&gt;nil&lt;/code&gt;. If &lt;var&gt;hook&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it is called with no arguments after the abbrev is replaced with &lt;var&gt;expansion&lt;/var&gt;; point is located at the end of &lt;var&gt;expansion&lt;/var&gt; when &lt;var&gt;hook&lt;/var&gt; is called.</source>
          <target state="translated">&lt;var&gt;hook&lt;/var&gt; аргумента - это функция или &lt;code&gt;nil&lt;/code&gt; . Если &lt;var&gt;hook&lt;/var&gt; равна &lt;code&gt;nil&lt;/code&gt; , то она вызывается без аргументов после замены сокращения на &lt;var&gt;expansion&lt;/var&gt; ; точка находится в конце &lt;var&gt;expansion&lt;/var&gt; при вызове &lt;var&gt;hook&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5778b8ef92c13549c1f7ef7e69e42a33280d37" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;how&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt; specifies explicitly the style of justification. It can be &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt;. If it is &lt;code&gt;t&lt;/code&gt;, that means to follow specified justification style (see &lt;code&gt;current-justification&lt;/code&gt;, below). &lt;code&gt;nil&lt;/code&gt; means to do full justification.</source>
          <target state="translated">Аргумент &lt;var&gt;how&lt;/var&gt; , if non- &lt;code&gt;nil&lt;/code&gt; явно указывает стиль выравнивания. Он может быть &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; , &lt;code&gt;center&lt;/code&gt; или &lt;code&gt;none&lt;/code&gt; . Если это &lt;code&gt;t&lt;/code&gt; , это означает следовать указанному стилю выравнивания (см. &lt;code&gt;current-justification&lt;/code&gt; ниже). &lt;code&gt;nil&lt;/code&gt; означает полное оправдание.</target>
        </trans-unit>
        <trans-unit id="1842f1cad7ab3b7c140d1cfe864326f7e3619df2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;image&lt;/var&gt; must be an image descriptor, perhaps returned by &lt;code&gt;create-image&lt;/code&gt; or stored by &lt;code&gt;defimage&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;image&lt;/var&gt; должен быть дескриптором изображения, возможно, возвращенным &lt;code&gt;create-image&lt;/code&gt; или сохраненным &lt;code&gt;defimage&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96f968277564af4a88d9fe134d19c7c4704c5a69" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;initial&lt;/var&gt; is mostly deprecated; we recommend using a non-&lt;code&gt;nil&lt;/code&gt; value only in conjunction with specifying a cons cell for &lt;var&gt;history&lt;/var&gt;. See &lt;a href=&quot;initial-input#Initial-Input&quot;&gt;Initial Input&lt;/a&gt;. For default input, use &lt;var&gt;default&lt;/var&gt; instead.</source>
          <target state="translated">&lt;var&gt;initial&lt;/var&gt; аргумент в большинстве случаев не рекомендуется; мы рекомендуем использовать &lt;code&gt;nil&lt;/code&gt; значение только в сочетании с указанием cons-ячейки для &lt;var&gt;history&lt;/var&gt; . См. &lt;a href=&quot;initial-input#Initial-Input&quot;&gt;Начальный ввод&lt;/a&gt; . Для ввода по &lt;var&gt;default&lt;/var&gt; используйте вместо этого default .</target>
        </trans-unit>
        <trans-unit id="974d3227bd589119d939e9661c5cc12b79770e53" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;keys&lt;/var&gt;, if given, should be a vector which specifies the sequence of events to supply if the command inquires which events were used to invoke it. If &lt;var&gt;keys&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the default is the return value of &lt;code&gt;this-command-keys-vector&lt;/code&gt;. See &lt;a href=&quot;command-loop-info#Definition-of-this_002dcommand_002dkeys_002dvector&quot;&gt;Definition of this-command-keys-vector&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;keys&lt;/var&gt; аргументов , если они заданы, должны быть вектором, который указывает последовательность событий, которые необходимо предоставить, если команда запрашивает, какие события использовались для ее вызова. Если &lt;var&gt;keys&lt;/var&gt; опущены или &lt;code&gt;nil&lt;/code&gt; , по умолчанию используется возвращаемое значение &lt;code&gt;this-command-keys-vector&lt;/code&gt; . См. &lt;a href=&quot;command-loop-info#Definition-of-this_002dcommand_002dkeys_002dvector&quot;&gt;Определение вектора this-command-keys-vector&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c4bb39cda803046ad86dff926b35116869dcc4" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;keyword-list&lt;/var&gt; is a list of keywords to highlight with &lt;code&gt;font-lock-keyword-face&lt;/code&gt;. Each keyword should be a string. Meanwhile, &lt;var&gt;font-lock-list&lt;/var&gt; is a list of additional expressions to highlight. Each element of this list should have the same form as an element of &lt;code&gt;font-lock-keywords&lt;/code&gt;. See &lt;a href=&quot;search_002dbased-fontification#Search_002dbased-Fontification&quot;&gt;Search-based Fontification&lt;/a&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;keyword-list&lt;/var&gt; - это список ключевых слов, которые нужно выделить с помощью &lt;code&gt;font-lock-keyword-face&lt;/code&gt; . Каждое ключевое слово должно быть строкой. Между тем, &lt;var&gt;font-lock-list&lt;/var&gt; - это список дополнительных выражений, которые нужно выделить. Каждый элемент этого списка должен иметь ту же форму, что и элемент &lt;code&gt;font-lock-keywords&lt;/code&gt; . См. &lt;a href=&quot;search_002dbased-fontification#Search_002dbased-Fontification&quot;&gt;Раздел &amp;laquo;Фонирование на основе поиска&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25d82b58f4ee522411cbc631410a35fdf23c3431" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;kind&lt;/var&gt; should be either the symbol &lt;code&gt;interactive&lt;/code&gt; or the symbol &lt;code&gt;any&lt;/code&gt;. If it is &lt;code&gt;interactive&lt;/code&gt;, then &lt;code&gt;called-interactively-p&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; only if the call was made directly by the user&amp;mdash;e.g., if the user typed a key sequence bound to the calling function, but &lt;em&gt;not&lt;/em&gt; if the user ran a keyboard macro that called the function (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;). If &lt;var&gt;kind&lt;/var&gt; is &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;called-interactively-p&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; for any kind of interactive call, including keyboard macros.</source>
          <target state="translated">Аргумент &lt;var&gt;kind&lt;/var&gt; должен быть либо символ &lt;code&gt;interactive&lt;/code&gt; или символ &lt;code&gt;any&lt;/code&gt; . Если он &lt;code&gt;interactive&lt;/code&gt; , то &lt;code&gt;called-interactively-p&lt;/code&gt; возвращает &lt;code&gt;t&lt;/code&gt; только в том случае, если вызов был сделан пользователем напрямую - например, если пользователь ввел последовательность клавиш, привязанную к вызывающей функции, но &lt;em&gt;не&lt;/em&gt; если пользователь запустил макрос клавиатуры, который вызвал функцию (см. &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Макросы клавиатуры&lt;/a&gt; ). Если &lt;var&gt;kind&lt;/var&gt; имеет значение &lt;code&gt;any&lt;/code&gt; , &lt;code&gt;called-interactively-p&lt;/code&gt; возвращает &lt;code&gt;t&lt;/code&gt; для любого интерактивного вызова, включая макросы клавиатуры.</target>
        </trans-unit>
        <trans-unit id="196be81f6b9a392e133455b5fb487c8f96ab960c" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;left&lt;/var&gt; specifies the width in pixels of the left fringe, and likewise &lt;var&gt;right&lt;/var&gt; for the right fringe. A value of &lt;code&gt;nil&lt;/code&gt; for either one stands for the default width. If &lt;var&gt;outside-margins&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that specifies that fringes should appear outside of the display margins.</source>
          <target state="translated">Аргумент &lt;var&gt;left&lt;/var&gt; определяет ширину в пикселях левой полосы, а также &lt;var&gt;right&lt;/var&gt; для правой полосы. Значение &lt;code&gt;nil&lt;/code&gt; для любого из них означает ширину по умолчанию. Если &lt;var&gt;outside-margins&lt;/var&gt; отличен от &lt;code&gt;nil&lt;/code&gt; , это указывает, что края должны появляться за пределами полей дисплея.</target>
        </trans-unit>
        <trans-unit id="9d27ba0b5af1380567016503ffb0e2b8f7cc8071" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;lexical&lt;/var&gt; specifies the scoping rule for local variables (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;). If it is omitted or &lt;code&gt;nil&lt;/code&gt;, that means to evaluate &lt;var&gt;form&lt;/var&gt; using the default dynamic scoping rule. If it is &lt;code&gt;t&lt;/code&gt;, that means to use the lexical scoping rule. The value of &lt;var&gt;lexical&lt;/var&gt; can also be a non-empty alist specifying a particular &lt;em&gt;lexical environment&lt;/em&gt; for lexical bindings; however, this feature is only useful for specialized purposes, such as in Emacs Lisp debuggers. See &lt;a href=&quot;lexical-binding#Lexical-Binding&quot;&gt;Lexical Binding&lt;/a&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;lexical&lt;/var&gt; определяет правило области действия для локальных переменных (см. &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Область действия переменной&lt;/a&gt; ). Если он опущен или равен &lt;code&gt;nil&lt;/code&gt; , это означает, что &lt;var&gt;form&lt;/var&gt; оценивается с использованием правила динамической области по умолчанию. Если это &lt;code&gt;t&lt;/code&gt; , это означает использование правила лексической области видимости. Значение &lt;var&gt;lexical&lt;/var&gt; также может быть непустым списком, определяющим конкретную &lt;em&gt;лексическую среду&lt;/em&gt; для лексических привязок; однако эта функция полезна только для специальных целей, например, в отладчиках Emacs Lisp. См. Раздел &amp;laquo; &lt;a href=&quot;lexical-binding#Lexical-Binding&quot;&gt;Лексическая привязка&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c17f6e31c66c06841db5748f38c43cbe2e85ecb7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;limit&lt;/var&gt; specifies the bound to the search, and should be a position in the current buffer. No match extending after that position is accepted. If &lt;var&gt;limit&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to the end of the accessible portion of the buffer.</source>
          <target state="translated">&lt;var&gt;limit&lt;/var&gt; аргумента определяет привязку к поиску и должен быть позицией в текущем буфере. Никакие совпадения после этой позиции не принимаются. Если &lt;var&gt;limit&lt;/var&gt; опущен или равен &lt;code&gt;nil&lt;/code&gt; , по умолчанию используется конец доступной части буфера.</target>
        </trans-unit>
        <trans-unit id="dd040b041a862b040024285cd7f4c2ae445161d8" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;members&lt;/var&gt; is a list specifying an initial set of customization items to be members of the group. However, most often &lt;var&gt;members&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and you specify the group&amp;rsquo;s members by using the &lt;code&gt;:group&lt;/code&gt; keyword when defining those members.</source>
          <target state="translated">Аргумент &lt;var&gt;members&lt;/var&gt; - это список, определяющий начальный набор элементов настройки, которые будут членами группы. Тем не менее, чаще всего &lt;var&gt;members&lt;/var&gt; в &lt;code&gt;nil&lt;/code&gt; , и указать участник группы с помощью &lt;code&gt;:group&lt;/code&gt; ключевого слова при определении тех членов.</target>
        </trans-unit>
        <trans-unit id="0408e94f530ce550a379720f8c833ca4bc4fc95a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;menu&lt;/var&gt; says what to display in the menu. It can be a keymap or a list of keymaps (see &lt;a href=&quot;menu-keymaps#Menu-Keymaps&quot;&gt;Menu Keymaps&lt;/a&gt;). In this case, the return value is the list of events corresponding to the user&amp;rsquo;s choice. This list has more than one element if the choice occurred in a submenu. (Note that &lt;code&gt;x-popup-menu&lt;/code&gt; does not actually execute the command bound to that sequence of events.) On text terminals and toolkits that support menu titles, the title is taken from the prompt string of &lt;var&gt;menu&lt;/var&gt; if &lt;var&gt;menu&lt;/var&gt; is a keymap, or from the prompt string of the first keymap in &lt;var&gt;menu&lt;/var&gt; if it is a list of keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;menu&lt;/var&gt; аргументов говорит, что отображать в меню. Это может быть &lt;a href=&quot;menu-keymaps#Menu-Keymaps&quot;&gt;раскладка&lt;/a&gt; клавиатуры или список раскладок (см. Раскладки меню ). В этом случае возвращаемое значение - это список событий, соответствующих выбору пользователя. В этом списке может быть более одного элемента, если выбор произошел в подменю. (Обратите внимание, что &lt;code&gt;x-popup-menu&lt;/code&gt; на самом деле не выполняет команду, привязанную к этой последовательности событий.) В текстовых терминалах и инструментах, которые поддерживают заголовки меню, заголовок берется из строки подсказки &lt;var&gt;menu&lt;/var&gt; если &lt;var&gt;menu&lt;/var&gt; является раскладкой, или из строка подсказки первой раскладки клавиатуры в &lt;var&gt;menu&lt;/var&gt; если это список раскладок (см. &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Определение меню&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="88747b097449b29e56bc00712a63362c30691cd1" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;meta&lt;/var&gt; controls support for input character codes above 127. If &lt;var&gt;meta&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, Emacs converts characters with the 8th bit set into Meta characters. If &lt;var&gt;meta&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, Emacs disregards the 8th bit; this is necessary when the terminal uses it as a parity bit. If &lt;var&gt;meta&lt;/var&gt; is neither &lt;code&gt;t&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;, Emacs uses all 8 bits of input unchanged. This is good for terminals that use 8-bit character sets.</source>
          <target state="translated">Аргумент &lt;var&gt;meta&lt;/var&gt; контролирует поддержку кодов входных символов выше 127. Если &lt;var&gt;meta&lt;/var&gt; равен &lt;code&gt;t&lt;/code&gt; , Emacs преобразует символы с 8-м битом в Meta-символы. Если &lt;var&gt;meta&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , Emacs игнорирует 8-й бит; это необходимо, когда терминал использует его как бит четности. Если &lt;var&gt;meta&lt;/var&gt; не равен ни &lt;code&gt;t&lt;/code&gt; , ни &lt;code&gt;nil&lt;/code&gt; , Emacs использует все 8 битов ввода без изменений. Это хорошо для терминалов, использующих 8-битные наборы символов.</target>
        </trans-unit>
        <trans-unit id="7b69f27c31d0a41c9c347845fd11bdd63da029d5" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;millisec&lt;/var&gt; is obsolete (and should not be used), because &lt;var&gt;seconds&lt;/var&gt; can be floating point to specify waiting a fractional number of seconds. If &lt;var&gt;seconds&lt;/var&gt; is 0, the function accepts whatever output is pending but does not wait.</source>
          <target state="translated">Аргумент &lt;var&gt;millisec&lt;/var&gt; устарел (и не должен использоваться), потому что &lt;var&gt;seconds&lt;/var&gt; могут быть числами с плавающей запятой, чтобы указать время ожидания дробное количество секунд. Если &lt;var&gt;seconds&lt;/var&gt; равны 0, функция принимает любой ожидающий вывод, но не ждет.</target>
        </trans-unit>
        <trans-unit id="0cf53f56ad140e70514995e9d0814aa3d76c0e8e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;mode&lt;/var&gt; should be an integer which specifies the permissions, similar to &lt;code&gt;set-file-modes&lt;/code&gt; above. Only the lowest 9 bits are meaningful.</source>
          <target state="translated">Аргумент &lt;var&gt;mode&lt;/var&gt; должен быть целым числом, определяющим разрешения, аналогично &lt;code&gt;set-file-modes&lt;/code&gt; mode выше. Имеют значение только самые младшие 9 бит.</target>
        </trans-unit>
        <trans-unit id="a16d7cf6dfa227347abb2403a6e7c2be2b2591f2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;name&lt;/var&gt; may also be a symbol; in that case, the function returns &lt;var&gt;name&lt;/var&gt; if &lt;var&gt;name&lt;/var&gt; is interned in the specified obarray, and otherwise &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;name&lt;/var&gt; может также быть символом; в этом случае функция возвращает &lt;var&gt;name&lt;/var&gt; если &lt;var&gt;name&lt;/var&gt; интернировано в указанном массиве, в противном случае - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69fc1cc6b623ffbdee12e31cc3480d92239d6a8b" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;noerror&lt;/var&gt; only affects valid searches which fail to find a match. Invalid arguments cause errors regardless of &lt;var&gt;noerror&lt;/var&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;noerror&lt;/var&gt; влияет только на допустимые поиски, которые не могут найти совпадения. Недействительные аргументы вызывают ошибки независимо от их &lt;var&gt;noerror&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="8d81e59db92b382d9e224aeb68da9946a0652004" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;object&lt;/var&gt; can be a function name, a lambda expression (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;), or a byte-code object (see &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;). If it is a lambda expression, &lt;code&gt;disassemble&lt;/code&gt; compiles it and disassembles the resulting compiled code.</source>
          <target state="translated">Аргумент &lt;var&gt;object&lt;/var&gt; может быть именем функции, лямбда - выражение (см &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;лямбда - выражений&lt;/a&gt; ), или объект байт-код (см &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;байт-код объектов&lt;/a&gt; ). Если это лямбда-выражение, &lt;code&gt;disassemble&lt;/code&gt; компилирует его и дизассемблирует полученный скомпилированный код.</target>
        </trans-unit>
        <trans-unit id="dad6e03a1386425d5769205e122d50e6a21178f7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;object&lt;/var&gt; may be a string, a buffer, or a window. If it is a window, then the buffer displayed in that window is used for text properties and overlays, but only the overlays active for that window are considered. If &lt;var&gt;object&lt;/var&gt; is a buffer, then overlays in that buffer are considered first, in order of decreasing priority, followed by the text properties. If &lt;var&gt;object&lt;/var&gt; is a string, only text properties are considered, since strings never have overlays.</source>
          <target state="translated">Аргумент &lt;var&gt;object&lt;/var&gt; может быть строкой, буфер, или окно. Если это окно, то буфер, отображаемый в этом окне, используется для свойств текста и наложений, но учитываются только наложения, активные для этого окна. Если &lt;var&gt;object&lt;/var&gt; является буфером, то сначала рассматриваются наложения в этом буфере в порядке уменьшения приоритета, а затем свойства текста. Если &lt;var&gt;object&lt;/var&gt; является строкой, учитываются только текстовые свойства, поскольку строки никогда не имеют наложений.</target>
        </trans-unit>
        <trans-unit id="001fe7686d2c31dc753172d3f9a15f72fd251e2a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;offsets&lt;/var&gt; is either &lt;code&gt;nil&lt;/code&gt; or a cons cell of the form &lt;code&gt;(&lt;var&gt;hscroll&lt;/var&gt; . &lt;var&gt;tab-offset&lt;/var&gt;)&lt;/code&gt;. Here &lt;var&gt;hscroll&lt;/var&gt; is the number of columns not being displayed at the left margin; most callers get this by calling &lt;code&gt;window-hscroll&lt;/code&gt;. Meanwhile, &lt;var&gt;tab-offset&lt;/var&gt; is the offset between column numbers on the screen and column numbers in the buffer. This can be nonzero in a continuation line, when the previous screen lines&amp;rsquo; widths do not add up to a multiple of &lt;code&gt;tab-width&lt;/code&gt;. It is always zero in a non-continuation line.</source>
          <target state="translated">Аргумент &lt;var&gt;offsets&lt;/var&gt; является либо &lt;code&gt;nil&lt;/code&gt; или против клеток вида &lt;code&gt;(&lt;var&gt;hscroll&lt;/var&gt; . &lt;var&gt;tab-offset&lt;/var&gt;)&lt;/code&gt; . Здесь &lt;var&gt;hscroll&lt;/var&gt; - количество столбцов, не отображаемых на левом поле; большинство абонентов получают это, вызывая &lt;code&gt;window-hscroll&lt;/code&gt; . Между тем, &lt;var&gt;tab-offset&lt;/var&gt; - это смещение между номерами столбцов на экране и номерами столбцов в буфере. Это может быть ненулевое значение в строке продолжения, если ширина предыдущих строк экрана не кратна &lt;code&gt;tab-width&lt;/code&gt; . В непродолжительной строке он всегда равен нулю.</target>
        </trans-unit>
        <trans-unit id="bd432b621bc1d2381c02fe76deeee1b9cd6e2aa5" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;operation&lt;/var&gt; is a symbol; it should be one of &lt;code&gt;write-region&lt;/code&gt;, &lt;code&gt;start-process&lt;/code&gt;, &lt;code&gt;call-process&lt;/code&gt;, &lt;code&gt;call-process-region&lt;/code&gt;, &lt;code&gt;insert-file-contents&lt;/code&gt;, or &lt;code&gt;open-network-stream&lt;/code&gt;. These are the names of the Emacs I/O primitives that can do character code and eol conversion.</source>
          <target state="translated">Аргумент &lt;var&gt;operation&lt;/var&gt; является символом; это должно быть одно из следующих значений: &lt;code&gt;write-region&lt;/code&gt; , &lt;code&gt;start-process&lt;/code&gt; , &lt;code&gt;call-process&lt;/code&gt; , &lt;code&gt;call-process-region&lt;/code&gt; , &lt;code&gt;insert-file-contents&lt;/code&gt; или &lt;code&gt;open-network-stream&lt;/code&gt; . Это имена примитивов ввода-вывода Emacs, которые могут выполнять преобразование символьного кода и eol.</target>
        </trans-unit>
        <trans-unit id="b5c495570323a121506457028c43ca0430313d78" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;partial-filename&lt;/var&gt; must be a file name containing no directory part and no slash (or backslash on some systems). The current buffer&amp;rsquo;s default directory is prepended to &lt;var&gt;directory&lt;/var&gt;, if &lt;var&gt;directory&lt;/var&gt; is not absolute.</source>
          <target state="translated">Аргумент &lt;var&gt;partial-filename&lt;/var&gt; должен быть именем файла, не содержащим части каталога и косой черты (или обратной косой черты в некоторых системах). Каталог по умолчанию текущего буфера добавляется к &lt;var&gt;directory&lt;/var&gt; , если &lt;var&gt;directory&lt;/var&gt; не является абсолютным.</target>
        </trans-unit>
        <trans-unit id="b48f922752b498de38261334e1913b2bb02b6d0d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;position&lt;/var&gt; specifies where on the screen to put the top left corner of the menu. It can be either a mouse button event (which says to put the menu where the user actuated the button) or a list of this form:</source>
          <target state="translated">&lt;var&gt;position&lt;/var&gt; аргумента указывает, где на экране разместить левый верхний угол меню. Это может быть либо событие кнопки мыши (которое говорит о том, чтобы поместить меню, в которое пользователь нажал кнопку), либо список этой формы:</target>
        </trans-unit>
        <trans-unit id="d8afa9b503d1608b12cdededd886534cc2bc5427" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;predicate&lt;/var&gt; is the function to use to compare keys. It is called with two arguments, the keys to compare, and should return non-&lt;code&gt;nil&lt;/code&gt; if the first key should come before the second in the sorting order. What exactly are the key arguments depends on what &lt;var&gt;startkeyfun&lt;/var&gt; and &lt;var&gt;endkeyfun&lt;/var&gt; return. If &lt;var&gt;predicate&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to &lt;code&gt;&amp;lt;&lt;/code&gt; if the keys are numbers, to &lt;code&gt;compare-buffer-substrings&lt;/code&gt; if the keys are cons cells (whose &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are start and end buffer positions of the key), and to &lt;code&gt;string&amp;lt;&lt;/code&gt; otherwise (with keys assumed to be strings).</source>
          <target state="translated">&lt;var&gt;predicate&lt;/var&gt; аргумента - это функция, которая используется для сравнения ключей. Он вызывается с двумя аргументами, ключами для сравнения, и должен возвращать &lt;code&gt;nil&lt;/code&gt; если первый ключ должен стоять перед вторым в порядке сортировки. Каковы именно ключевые аргументы, зависит от того, что &lt;var&gt;startkeyfun&lt;/var&gt; и &lt;var&gt;endkeyfun&lt;/var&gt; . Если &lt;var&gt;predicate&lt;/var&gt; опущен или равен &lt;code&gt;nil&lt;/code&gt; , по умолчанию используется &lt;code&gt;&amp;lt;&lt;/code&gt; , если ключи являются числами, для &lt;code&gt;compare-buffer-substrings&lt;/code&gt; , если ключи являются cons-ячейками (чьи &lt;code&gt;car&lt;/code&gt; и &lt;code&gt;cdr&lt;/code&gt; являются начальной и конечной позициями буфера ключа), и &lt;code&gt;string&amp;lt;&lt;/code&gt; противном случае (предполагается, что ключи являются строками).</target>
        </trans-unit>
        <trans-unit id="a855a735accf62e1134dc780be542253eb20ba2e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;predicate&lt;/var&gt; must be a function that accepts two arguments. It is called with two elements of &lt;var&gt;sequence&lt;/var&gt;. To get an increasing order sort, the &lt;var&gt;predicate&lt;/var&gt; should return non-&lt;code&gt;nil&lt;/code&gt; if the first element is &amp;ldquo;less&amp;rdquo; than the second, or &lt;code&gt;nil&lt;/code&gt; if not.</source>
          <target state="translated">&lt;var&gt;predicate&lt;/var&gt; аргумента должен быть функцией, которая принимает два аргумента. Он вызывается с двумя элементами &lt;var&gt;sequence&lt;/var&gt; . Чтобы получить сортировку в возрастающем порядке, &lt;var&gt;predicate&lt;/var&gt; должен возвращать &lt;code&gt;nil&lt;/code&gt; если первый элемент &amp;laquo;меньше&amp;raquo; второго, или &lt;code&gt;nil&lt;/code&gt; если нет.</target>
        </trans-unit>
        <trans-unit id="d1251fac003853896e745f0298e2aa9d94692f65" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;process&lt;/var&gt; must be either a process, a process name, a buffer, a buffer name, or &lt;code&gt;nil&lt;/code&gt;. A buffer or buffer name stands for a process through &lt;code&gt;get-buffer-process&lt;/code&gt;. &lt;code&gt;nil&lt;/code&gt; stands for the process associated with the current buffer. Except with &lt;code&gt;stop-process&lt;/code&gt; and &lt;code&gt;continue-process&lt;/code&gt;, an error is signaled if &lt;var&gt;process&lt;/var&gt; does not identify an active process, or if it represents a network, serial, or pipe connection.</source>
          <target state="translated">Аргумент &lt;var&gt;process&lt;/var&gt; должен быть либо процессом, либо именем процесса, либо буфером, либо именем буфера, либо &lt;code&gt;nil&lt;/code&gt; . Имя буфера или буфера обозначает процесс через &lt;code&gt;get-buffer-process&lt;/code&gt; . &lt;code&gt;nil&lt;/code&gt; обозначает процесс, связанный с текущим буфером. За исключением &lt;code&gt;stop-process&lt;/code&gt; и &lt;code&gt;continue-process&lt;/code&gt; , сообщение об ошибке выдается, если &lt;var&gt;process&lt;/var&gt; не идентифицирует активный процесс или представляет сетевое, последовательное или трубное соединение.</target>
        </trans-unit>
        <trans-unit id="af5bf7e34455acf7be31e9bc5d6f866fc302930e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompt&lt;/var&gt; is either a string to be displayed in the echo area as a prompt, or &lt;code&gt;nil&lt;/code&gt;, meaning not to display a prompt.</source>
          <target state="translated">&lt;var&gt;prompt&lt;/var&gt; аргумента - это либо строка, которая должна отображаться в эхо-области как подсказка, либо &lt;code&gt;nil&lt;/code&gt; , что означает, что подсказка не отображается.</target>
        </trans-unit>
        <trans-unit id="70512a26fcee3aeb8a3425f6dc51d96e107b4faf" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompt&lt;/var&gt; is either a string to be displayed in the echo area as a prompt, or &lt;code&gt;nil&lt;/code&gt;, meaning not to display a prompt. The argument &lt;var&gt;continue-echo&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to echo this key as a continuation of the previous key.</source>
          <target state="translated">&lt;var&gt;prompt&lt;/var&gt; аргумента - это либо строка, которая должна отображаться в эхо-области как подсказка, либо &lt;code&gt;nil&lt;/code&gt; , что означает, что подсказка не отображается. Аргумент &lt;var&gt;continue-echo&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , означает повторение этого ключа как продолжения предыдущего ключа.</target>
        </trans-unit>
        <trans-unit id="872e597e29d6ed7b7a8c180508178c91f1565bab" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompt&lt;/var&gt; should be a string ending with a colon and a space. If &lt;var&gt;default&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function inserts it in &lt;var&gt;prompt&lt;/var&gt; before the colon to follow the convention for reading from the minibuffer with a default value (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Programming-Tips.html#Programming-Tips&quot;&gt;Programming Tips&lt;/a&gt;).</source>
          <target state="translated">Аргумент &lt;var&gt;prompt&lt;/var&gt; должна быть строка заканчивается двоеточием и пробелом. Если &lt;var&gt;default&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , функция вставляет его в &lt;var&gt;prompt&lt;/var&gt; перед двоеточием, чтобы следовать соглашению о чтении из минибуфера со значением по умолчанию (см. &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Programming-Tips.html#Programming-Tips&quot;&gt;Советы по программированию&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5608256bb905bdbb1eff90b08fadc105facf372d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompter&lt;/var&gt; specifies how to ask each question. If &lt;var&gt;prompter&lt;/var&gt; is a string, the question text is computed like this:</source>
          <target state="translated">&lt;var&gt;prompter&lt;/var&gt; аргументов указывает, как задать каждый вопрос. Если &lt;var&gt;prompter&lt;/var&gt; является строкой, текст вопроса вычисляется следующим образом:</target>
        </trans-unit>
        <trans-unit id="eed1350308760f73cd3d24fa91bd9205b37cd744" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;props&lt;/var&gt; is the new property list. It should be a list whose elements are property names alternating with corresponding values.</source>
          <target state="translated">Аргумент &lt;var&gt;props&lt;/var&gt; - это новый список свойств. Это должен быть список, элементами которого являются имена свойств, чередующиеся с соответствующими значениями.</target>
        </trans-unit>
        <trans-unit id="5bbc2fd92fa2dd281ae56f30f0b8f43f4acc8a92" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;props&lt;/var&gt; specifies which properties to add. It should have the form of a property list (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): a list whose elements include the property names followed alternately by the corresponding values.</source>
          <target state="translated">Аргумент &lt;var&gt;props&lt;/var&gt; указывает, какие свойства нужно добавить. Он должен иметь форму списка свойств (см. &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Списки свойств&lt;/a&gt; ): список, элементы которого включают имена свойств, за которыми поочередно следуют соответствующие значения.</target>
        </trans-unit>
        <trans-unit id="9cc67a41c7e64481d999b8a504d6065516bede3a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;props&lt;/var&gt; specifies which properties to delete. It should have the form of a property list (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): a list whose elements are property names alternating with corresponding values. But only the names matter&amp;mdash;the values that accompany them are ignored. For example, here&amp;rsquo;s how to remove the &lt;code&gt;face&lt;/code&gt; property.</source>
          <target state="translated">Аргумент &lt;var&gt;props&lt;/var&gt; указывает, какие свойства нужно удалить. Он должен иметь форму списка свойств (см. &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Списки свойств&lt;/a&gt; ): список, элементы которого являются именами свойств, чередующимися с соответствующими значениями. Но имеют значение только имена - значения, которые им сопутствуют, игнорируются. Например, вот как удалить свойство &lt;code&gt;face&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69f2c50ecf74da021b0e7c46691093ec14c66784" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;question&lt;/var&gt; is the outgoing message that starts the transaction. The argument &lt;var&gt;fn&lt;/var&gt; is the function to call when the corresponding answer comes back; it is called with two arguments: &lt;var&gt;closure&lt;/var&gt;, and the answer received.</source>
          <target state="translated">Аргумент &lt;var&gt;question&lt;/var&gt; является исходящим сообщением , которое запускает транзакцию. Аргумент &lt;var&gt;fn&lt;/var&gt; - это функция, вызываемая при получении соответствующего ответа; он вызывается с двумя аргументами: &lt;var&gt;closure&lt;/var&gt; и полученным ответом.</target>
        </trans-unit>
        <trans-unit id="d815e5eb2953e57ddfdc5993729a096fec8bc0cb" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;regexp&lt;/var&gt; is a regular expression that should match text at the end of the entire answer, but nothing before; that&amp;rsquo;s how &lt;code&gt;tq-enqueue&lt;/code&gt; determines where the answer ends.</source>
          <target state="translated">Аргумент &lt;var&gt;regexp&lt;/var&gt; - это регулярное выражение, которое должно соответствовать тексту в конце всего ответа, но не до него; так &lt;code&gt;tq-enqueue&lt;/code&gt; определяет, где заканчивается ответ.</target>
        </trans-unit>
        <trans-unit id="5b5f44f3d22c5a5049bd7ccd1b39ed76340c19cb" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;replacements&lt;/var&gt; specifies what to replace occurrences with. If it is a string, that string is used. It can also be a list of strings, to be used in cyclic order.</source>
          <target state="translated">Аргумент &lt;var&gt;replacements&lt;/var&gt; указывает , что для замены вхождений с. Если это строка, используется эта строка. Это также может быть список строк, используемых в циклическом порядке.</target>
        </trans-unit>
        <trans-unit id="211392b7efa5b598b944102aa71b19e31292e6a4" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;runtime&lt;/var&gt; is a pointer to a C &lt;code&gt;struct&lt;/code&gt; that includes 2 public fields: &lt;code&gt;size&lt;/code&gt;, which provides the size of the structure in bytes; and &lt;code&gt;get_environment&lt;/code&gt;, which provides a pointer to a function that allows the module initialization function access to the Emacs environment object and its interfaces.</source>
          <target state="translated">Время &lt;var&gt;runtime&lt;/var&gt; аргумента - это указатель на &lt;code&gt;struct&lt;/code&gt; C, которая включает 2 общедоступных поля: &lt;code&gt;size&lt;/code&gt; , который предоставляет размер структуры в байтах; и &lt;code&gt;get_environment&lt;/code&gt; , который предоставляет указатель на функцию, которая позволяет функции инициализации модуля получить доступ к объекту среды Emacs и его интерфейсам.</target>
        </trans-unit>
        <trans-unit id="b0e7e0b91ad298260b1816cbd65796b68a0bd82d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;seconds&lt;/var&gt; need not be an integer. If it is floating point, &lt;code&gt;sit-for&lt;/code&gt; waits for a fractional number of seconds. Some systems support only a whole number of seconds; on these systems, &lt;var&gt;seconds&lt;/var&gt; is rounded down.</source>
          <target state="translated">Аргумент &lt;var&gt;seconds&lt;/var&gt; не обязательно должен быть целым числом. Если с плавающей точкой, &lt;code&gt;sit-for&lt;/code&gt; ждет дробного числа секунд. Некоторые системы поддерживают только целое количество секунд; в этих системах &lt;var&gt;seconds&lt;/var&gt; округляются в меньшую сторону.</target>
        </trans-unit>
        <trans-unit id="1a269d46174e2be95bd3636d0d8a3ec1968953df" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;seconds&lt;/var&gt; need not be an integer. If it is floating point, &lt;code&gt;sleep-for&lt;/code&gt; waits for a fractional number of seconds. Some systems support only a whole number of seconds; on these systems, &lt;var&gt;seconds&lt;/var&gt; is rounded down.</source>
          <target state="translated">Аргумент &lt;var&gt;seconds&lt;/var&gt; не обязательно должен быть целым числом. Если с плавающей точкой, &lt;code&gt;sleep-for&lt;/code&gt; жду дробного числа секунд. Некоторые системы поддерживают только целое количество секунд; в этих системах &lt;var&gt;seconds&lt;/var&gt; округляются в меньшую сторону.</target>
        </trans-unit>
        <trans-unit id="c189f7ca8290602de13d50f2372250cb9f720a2d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;sequence&lt;/var&gt; can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string. The result is always a list. The length of the result is the same as the length of &lt;var&gt;sequence&lt;/var&gt;. For example:</source>
          <target state="translated">Аргумент &lt;var&gt;sequence&lt;/var&gt; может быть любой вид последовательности , кроме полукокса-таблицы; то есть список, вектор, логический вектор или строка. Результатом всегда является список. Длина результата такая же, как длина &lt;var&gt;sequence&lt;/var&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b45bd09aa0d91bbfc69fc9a445440572bd4cf5d2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;slice&lt;/var&gt; specifies a slice of the image to insert. If &lt;var&gt;slice&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted the whole image is inserted. Otherwise, &lt;var&gt;slice&lt;/var&gt; is a list &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt; &lt;var&gt;width&lt;/var&gt;
&lt;var&gt;height&lt;/var&gt;)&lt;/code&gt; which specifies the &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; positions and &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; of the image area to insert. Integer values are in units of pixels. A floating-point number in the range 0.0&amp;ndash;1.0 stands for that fraction of the width or height of the entire image.</source>
          <target state="translated">Аргумент &lt;var&gt;slice&lt;/var&gt; указывает фрагмент изображения для вставки. Если &lt;var&gt;slice&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; или опущен, вставляется все изображение. В противном случае &lt;var&gt;slice&lt;/var&gt; - это список &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt; &lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt;)&lt;/code&gt; который определяет позиции &lt;var&gt;x&lt;/var&gt; и &lt;var&gt;y&lt;/var&gt; , а также &lt;var&gt;width&lt;/var&gt; и &lt;var&gt;height&lt;/var&gt; области изображения для вставки. Целочисленные значения выражаются в пикселях. Число с плавающей запятой в диапазоне 0,0&amp;ndash;1,0 обозначает часть ширины или высоты всего изображения.</target>
        </trans-unit>
        <trans-unit id="e99474cc32a24e7c4f609644dcecc5ca6a4477e1" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;special&lt;/var&gt;, if given, means to ignore the prefix argument and not clear it. This is used for executing special events (see &lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;).</source>
          <target state="translated">Аргумент &lt;var&gt;special&lt;/var&gt; , если он задан, означает игнорировать аргумент префикса и не очищать его. Это используется для выполнения особых событий (см. &lt;a href=&quot;special-events#Special-Events&quot;&gt;Особые события&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e130557ecc7dad6914c0d468f71414349355f143" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;standard&lt;/var&gt; is an expression that specifies the standard value for &lt;var&gt;option&lt;/var&gt;. Evaluating the &lt;code&gt;defcustom&lt;/code&gt; form evaluates &lt;var&gt;standard&lt;/var&gt;, but does not necessarily bind the option to that value. If &lt;var&gt;option&lt;/var&gt; already has a default value, it is left unchanged. If the user has already saved a customization for &lt;var&gt;option&lt;/var&gt;, the user&amp;rsquo;s customized value is installed as the default value. Otherwise, the result of evaluating &lt;var&gt;standard&lt;/var&gt; is installed as the default value.</source>
          <target state="translated">Аргумент &lt;var&gt;standard&lt;/var&gt; представляет собой выражение , которое задает стандартное значение для &lt;var&gt;option&lt;/var&gt; . Оценка формы &lt;code&gt;defcustom&lt;/code&gt; оценивает &lt;var&gt;standard&lt;/var&gt; , но не обязательно связывает параметр с этим значением. Если для &lt;var&gt;option&lt;/var&gt; уже задано значение по умолчанию, оно остается неизменным. Если пользователь уже сохранил настройку для &lt;var&gt;option&lt;/var&gt; , пользовательское значение устанавливается как значение по умолчанию. В противном случае результат оценки &lt;var&gt;standard&lt;/var&gt; устанавливается как значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a41b9cd7c5304ae1483b63947c8ae36bea193179" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;switch-frame-ok&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that this function should process a &lt;code&gt;switch-frame&lt;/code&gt; event if the user switches frames before typing anything. If the user switches frames in the middle of a key sequence, or at the start of the sequence but &lt;var&gt;switch-frame-ok&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then the event will be put off until after the current key sequence.</source>
          <target state="translated">Аргумент &lt;var&gt;switch-frame-ok&lt;/var&gt; , если он не &lt;code&gt;nil&lt;/code&gt; , означает, что эта функция должна обрабатывать событие &lt;code&gt;switch-frame&lt;/code&gt; , если пользователь переключает кадры перед тем, как что-либо печатать. Если пользователь переключает кадры в середине последовательности клавиш или в начале последовательности, но параметр &lt;var&gt;switch-frame-ok&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , то событие будет отложено до окончания текущей последовательности клавиш.</target>
        </trans-unit>
        <trans-unit id="e18bbe26e7a2b0de4caab7675f413155a70f8050" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;symbol&lt;/var&gt; is not implicitly quoted; &lt;code&gt;add-to-list&lt;/code&gt; is an ordinary function, like &lt;code&gt;set&lt;/code&gt; and unlike &lt;code&gt;setq&lt;/code&gt;. Quote the argument yourself if that is what you want.</source>
          <target state="translated">Аргумент &lt;var&gt;symbol&lt;/var&gt; не неявно кавычки; &lt;code&gt;add-to-list&lt;/code&gt; - это обычная функция, такая же как &lt;code&gt;set&lt;/code&gt; и в отличие от &lt;code&gt;setq&lt;/code&gt; . Приведите аргумент сами, если вы этого хотите.</target>
        </trans-unit>
        <trans-unit id="ca7c32d401bf914b6464aff472c84af0a66020cf" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;symbol&lt;/var&gt; is not implicitly quoted; &lt;code&gt;add-to-ordered-list&lt;/code&gt; is an ordinary function, like &lt;code&gt;set&lt;/code&gt; and unlike &lt;code&gt;setq&lt;/code&gt;. Quote the argument yourself if necessary.</source>
          <target state="translated">Аргумент &lt;var&gt;symbol&lt;/var&gt; не неявно кавычки; &lt;code&gt;add-to-ordered-list&lt;/code&gt; - это обычная функция, такая же как &lt;code&gt;set&lt;/code&gt; и в отличие от &lt;code&gt;setq&lt;/code&gt; . При необходимости цитируйте аргумент.</target>
        </trans-unit>
        <trans-unit id="e08b6b7aae0045521f8c5b5cfa5fa2ed408551ff" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;syntax-descriptor&lt;/var&gt; is a syntax descriptor, i.e., a string whose first character is a syntax class designator and whose second and subsequent characters optionally specify a matching character and syntax flags. See &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;Syntax Descriptors&lt;/a&gt;. An error is signaled if &lt;var&gt;syntax-descriptor&lt;/var&gt; is not a valid syntax descriptor.</source>
          <target state="translated">Аргумент &lt;var&gt;syntax-descriptor&lt;/var&gt; - это дескриптор синтаксиса, т. Е. Строка, первый символ которой является указателем класса синтаксиса, а второй и последующие символы, необязательно, определяют совпадающий символ и флаги синтаксиса. См. &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;Дескрипторы синтаксиса&lt;/a&gt; . Об ошибке сообщается, если &lt;var&gt;syntax-descriptor&lt;/var&gt; не является допустимым синтаксическим дескриптором.</target>
        </trans-unit>
        <trans-unit id="98c04eb36732c1f9acd376bb1b7e8f2093b46e58" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;thing&lt;/var&gt; is a symbol which specifies a kind of syntactic entity. Possibilities include &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;sexp&lt;/code&gt;, &lt;code&gt;defun&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, &lt;code&gt;url&lt;/code&gt;, &lt;code&gt;word&lt;/code&gt;, &lt;code&gt;sentence&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, and others.</source>
          <target state="translated">Аргумент &lt;var&gt;thing&lt;/var&gt; - это символ, который определяет вид синтаксической сущности. Возможные варианты: &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;sexp&lt;/code&gt; , &lt;code&gt;defun&lt;/code&gt; , &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;url&lt;/code&gt; , &lt;code&gt;word&lt;/code&gt; , &lt;code&gt;sentence&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; , &lt;code&gt;page&lt;/code&gt; и другие.</target>
        </trans-unit>
        <trans-unit id="70061b1cc9d0665934fc07564012818e3ed00551" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;time&lt;/var&gt;, if given, specifies a time to format, instead of the current time. The optional argument &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule. See &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Time Zone Rules&lt;/a&gt;. The operating system limits the range of time and zone values.</source>
          <target state="translated">Аргумент &lt;var&gt;time&lt;/var&gt; , если он задан, указывает время форматирования вместо текущего времени. Необязательный аргумент &lt;var&gt;zone&lt;/var&gt; по умолчанию соответствует правилу текущего часового пояса. См. &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Правила часовых поясов&lt;/a&gt; . Операционная система ограничивает диапазон значений времени и пояса.</target>
        </trans-unit>
        <trans-unit id="67093ca62609112dce25a039485acdd340da0cbb" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;time&lt;/var&gt;, if given, specifies a time value to analyze instead of the current time. The optional argument &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule. The operating system limits the range of time and zone values.</source>
          <target state="translated">Аргумент &lt;var&gt;time&lt;/var&gt; , если он указан, указывает значение времени для анализа вместо текущего времени. Необязательный аргумент &lt;var&gt;zone&lt;/var&gt; по умолчанию соответствует правилу текущего часового пояса. Операционная система ограничивает диапазон значений времени и пояса.</target>
        </trans-unit>
        <trans-unit id="a166fde7744586ad3de5035db801908eb626de30" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;value&lt;/var&gt; is used as the value to return from that &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;var&gt;value&lt;/var&gt; используется в качестве значения для возврата из этого &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="476196cad18d685889ec67ed735c3184bfb0b98c" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;var&lt;/var&gt; is a variable. &lt;code&gt;condition-case&lt;/code&gt; does not bind this variable when executing the &lt;var&gt;protected-form&lt;/var&gt;, only when it handles an error. At that time, it binds &lt;var&gt;var&lt;/var&gt; locally to an &lt;em&gt;error description&lt;/em&gt;, which is a list giving the particulars of the error. The error description has the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt;
. &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt;. The handler can refer to this list to decide what to do. For example, if the error is for failure opening a file, the file name is the second element of &lt;var&gt;data&lt;/var&gt;&amp;mdash;the third element of the error description.</source>
          <target state="translated">Аргумент &lt;var&gt;var&lt;/var&gt; - это переменная. &lt;code&gt;condition-case&lt;/code&gt; не связывает эту переменную при выполнении &lt;var&gt;protected-form&lt;/var&gt; , только когда она обрабатывает ошибку. В это время он связывает &lt;var&gt;var&lt;/var&gt; локально с &lt;em&gt;описанием ошибки&lt;/em&gt; , которое представляет собой список, содержащий &lt;em&gt;подробные&lt;/em&gt; сведения об ошибке. Описание ошибки имеет вид &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; . &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; . Обработчик может обратиться к этому списку, чтобы решить, что делать. Например, если ошибка связана с неудачным открытием файла, имя файла - это второй элемент &lt;var&gt;data&lt;/var&gt; - третий элемент описания ошибки.</target>
        </trans-unit>
        <trans-unit id="e0fe210e6f1d01348600177fc40d83de22fa4e2e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;visible-ok&lt;/var&gt; is handled as with &lt;code&gt;other-buffer&lt;/code&gt;, see above. If no suitable buffer can be found, the buffer</source>
          <target state="translated">Аргумент &lt;var&gt;visible-ok&lt;/var&gt; обрабатывается так же, как и &lt;code&gt;other-buffer&lt;/code&gt; , см. Выше. Если подходящий буфер не может быть найден, буфер</target>
        </trans-unit>
        <trans-unit id="72848c5e5c01bccb49e9d85b256bded1595df4a4" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;when&lt;/var&gt; should be a string indicating when the function was first made obsolete&amp;mdash;for example, a date or a release number.</source>
          <target state="translated">Аргумент &lt;var&gt;when&lt;/var&gt; должен быть строкой, указывающей, когда функция впервые была сделана устаревшей, например, дата или номер выпуска.</target>
        </trans-unit>
        <trans-unit id="981c67516263983386e948611e806a1396a3f68a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;width&lt;/var&gt; is the number of columns available to display text; this affects handling of continuation lines. &lt;code&gt;nil&lt;/code&gt; means the actual number of usable text columns in the window, which is equivalent to the value returned by &lt;code&gt;(window-width window)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; аргумента - это количество столбцов, доступных для отображения текста; это влияет на обработку строк продолжения. &lt;code&gt;nil&lt;/code&gt; означает фактическое количество используемых текстовых столбцов в окне, которое эквивалентно значению, возвращаемому &lt;code&gt;(window-width window)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a911ba7619afc0fecdef0edde89f01cbdc7950a1" translate="yes" xml:space="preserve">
          <source>The argument is a single, highest-level form in a definition. This is like &lt;code&gt;def-body&lt;/code&gt;, except it is used to match a single form rather than a list of forms. As a special case, &lt;code&gt;def-form&lt;/code&gt; also means that tracing information is not output when the form is executed. See the &lt;code&gt;interactive&lt;/code&gt; example.</source>
          <target state="translated">Аргумент - это единственная форма высшего уровня в определении. Это похоже на &lt;code&gt;def-body&lt;/code&gt; , за исключением того, что он используется для сопоставления одной формы, а не списка форм. В качестве особого случая &lt;code&gt;def-form&lt;/code&gt; также означает, что информация трассировки не выводится при выполнении формы. См. &lt;code&gt;interactive&lt;/code&gt; пример.</target>
        </trans-unit>
        <trans-unit id="7dda82e624c89291ddeeb7176faeb74ec8ff9fc4" translate="yes" xml:space="preserve">
          <source>The argument is the body of code in a definition. This is like &lt;code&gt;body&lt;/code&gt;, described above, but a definition body must be instrumented with a different Edebug call that looks up information associated with the definition. Use &lt;code&gt;def-body&lt;/code&gt; for the highest level list of forms within the definition.</source>
          <target state="translated">Аргумент - это основная часть кода в определении. Это похоже на &lt;code&gt;body&lt;/code&gt; , описанное выше, но тело определения должно быть оснащено другим вызовом Edebug, который ищет информацию, связанную с определением. Используйте &lt;code&gt;def-body&lt;/code&gt; для списка форм высшего уровня в определении.</target>
        </trans-unit>
        <trans-unit id="7fc1b12a3b1d895f282732e4c2ebfaebd02311cb" translate="yes" xml:space="preserve">
          <source>The argument must be a cons cell whose &lt;code&gt;car&lt;/code&gt; is &lt;code&gt;eql&lt;/code&gt; to &lt;var&gt;object&lt;/var&gt;.</source>
          <target state="translated">Аргумент должен быть клеткой против которого &lt;code&gt;car&lt;/code&gt; является &lt;code&gt;eql&lt;/code&gt; к &lt;var&gt;object&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd03bfcc4c0687119a09e247b34a10daf413382" translate="yes" xml:space="preserve">
          <source>The argument must be an instance of a class named &lt;var&gt;struct-type&lt;/var&gt; defined with &lt;code&gt;cl-defstruct&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html#Structures&quot;&gt;Structures&lt;/a&gt; in</source>
          <target state="translated">Аргумент должен быть экземпляром класса с именем &lt;var&gt;struct-type&lt;/var&gt; , определенного с помощью &lt;code&gt;cl-defstruct&lt;/code&gt; (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html#Structures&quot;&gt;Структуры&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="6a016fb8d81e2ab32819f60e0f432fb6a3d9fce9" translate="yes" xml:space="preserve">
          <source>The argument should be a symbol named &lt;var&gt;string&lt;/var&gt;. This specification is equivalent to the quoted symbol, &lt;code&gt;'&lt;var&gt;symbol&lt;/var&gt;&lt;/code&gt;, where the name of &lt;var&gt;symbol&lt;/var&gt; is the &lt;var&gt;string&lt;/var&gt;, but the string form is preferred.</source>
          <target state="translated">Аргументом должен быть символ с именем &lt;var&gt;string&lt;/var&gt; . Эта спецификация эквивалентна заключенному в кавычки символу &lt;code&gt;'&lt;var&gt;symbol&lt;/var&gt;&lt;/code&gt; , где имя &lt;var&gt;symbol&lt;/var&gt; представляет собой &lt;var&gt;string&lt;/var&gt; , но строковая форма является предпочтительной.</target>
        </trans-unit>
        <trans-unit id="6d235a75502a298491d0f8f47584c491581700a2" translate="yes" xml:space="preserve">
          <source>The argument should be a vector whose elements must match the &lt;var&gt;elements&lt;/var&gt; in the specification. See the backquote example.</source>
          <target state="translated">Аргумент должен быть вектором, элементы которого должны соответствовать &lt;var&gt;elements&lt;/var&gt; в спецификации. См. Пример обратной цитаты.</target>
        </trans-unit>
        <trans-unit id="bac3fcdc65f408fcb049e05f8e1cc77394dd852a" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;byte-compile&lt;/code&gt; can also be a &lt;code&gt;lambda&lt;/code&gt; expression. In that case, the function returns the corresponding compiled code but does not store it anywhere.</source>
          <target state="translated">Аргументом для &lt;code&gt;byte-compile&lt;/code&gt; также может быть &lt;code&gt;lambda&lt;/code&gt; выражение. В этом случае функция возвращает соответствующий скомпилированный код, но нигде его не сохраняет.</target>
        </trans-unit>
        <trans-unit id="65872c371b9193c99790a2d59431ec0002cb765f" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;:options&lt;/code&gt; keywords should be a list of specifications for reasonable keys in the alist. Ordinarily, they are simply atoms, which stand for themselves. For example:</source>
          <target state="translated">Аргументом ключевых слов &lt;code&gt;:options&lt;/code&gt; должен быть список спецификаций разумных ключей в списке. Обычно это просто атомы, которые обозначают сами себя. Например:</target>
        </trans-unit>
        <trans-unit id="39a320a7e7ff203aa87f177be24c8afee00608cf" translate="yes" xml:space="preserve">
          <source>The argument, a symbol, is the name of an argument of the defining form. However, lambda-list keywords (symbols starting with &amp;lsquo;</source>
          <target state="translated">Аргумент, символ - это имя аргумента определяющей формы. Однако ключевые слова лямбда-списка (символы, начинающиеся с '</target>
        </trans-unit>
        <trans-unit id="04bfbbc1720d1306603968788629498a7b7b6c73" translate="yes" xml:space="preserve">
          <source>The argument, a symbol, is the name of the defining form.</source>
          <target state="translated">Аргументом,символом,является название определяющей формы.</target>
        </trans-unit>
        <trans-unit id="a1265c068f2d370b4c89f1bdd6a871f3831d14cc" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:around&lt;/code&gt; used in the above examples specify how the two functions are composed, since there are many different ways to do it. The added function is also called a piece of &lt;em&gt;advice&lt;/em&gt;.</source>
          <target state="translated">Аргументы &lt;code&gt;:before&lt;/code&gt; и &lt;code&gt;:around&lt;/code&gt; , используемые в приведенных выше примерах, определяют, как составлены две функции, поскольку есть много разных способов сделать это. Добавленная функция также называется &lt;em&gt;советом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e775df69264dec0b29fe83b2750522c9ef3d6768" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;do&lt;/code&gt; in this macro are syntactic sugar; they are entirely ignored. The idea is that you will write noise words (such as &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;do&lt;/code&gt;) in those positions in the macro call.</source>
          <target state="translated">Аргументы &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; и &lt;code&gt;do&lt;/code&gt; в этом макросе являются синтаксическим сахаром; они полностью игнорируются. Идея состоит в том, что вы будете писать шумовые слова (такие как &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; и &lt;code&gt;do&lt;/code&gt; ) в этих позициях в вызове макроса.</target>
        </trans-unit>
        <trans-unit id="ab831da1503b01e34a6cae5b52e070de7ee3e57d" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;args&lt;/var&gt; are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Аргументы &lt;var&gt;args&lt;/var&gt; - это список пар ключевое слово / аргумент. Пропуск ключевого слова всегда эквивалентен его указанию со значением &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af5eede62c1d9440db74aefa6774703b63dee39b" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;args&lt;/var&gt; are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value &lt;code&gt;nil&lt;/code&gt;. Here are the meaningful keywords:</source>
          <target state="translated">Аргументы &lt;var&gt;args&lt;/var&gt; - это список пар ключевое слово / аргумент. Пропуск ключевого слова всегда эквивалентен его указанию со значением &lt;code&gt;nil&lt;/code&gt; . Вот значимые ключевые слова:</target>
        </trans-unit>
        <trans-unit id="7d2a621488d57b7f6ddca20e096977bc70d24abb" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;destination&lt;/var&gt; and &lt;var&gt;display&lt;/var&gt; control what to do with the output from the subprocess, and whether to update the display as it comes in. For details, see the description of &lt;code&gt;call-process&lt;/code&gt;, above. If &lt;var&gt;destination&lt;/var&gt; is the integer 0, &lt;code&gt;call-process-region&lt;/code&gt; discards the output and returns &lt;code&gt;nil&lt;/code&gt; immediately, without waiting for the subprocess to finish (this only works if asynchronous subprocesses are supported; i.e., not on MS-DOS).</source>
          <target state="translated">Аргументы &lt;var&gt;destination&lt;/var&gt; и &lt;var&gt;display&lt;/var&gt; управляют тем, что делать с выводом из подпроцесса и обновлять ли отображение по мере его поступления. Подробнее см. Описание &lt;code&gt;call-process&lt;/code&gt; выше. Если &lt;var&gt;destination&lt;/var&gt; является целое число 0, &lt;code&gt;call-process-region&lt;/code&gt; отбрасывает вывод и немедленно возвращает &lt;code&gt;nil&lt;/code&gt; , не дожидаясь завершения подпроцесса (это работает, только если поддерживаются асинхронные подпроцессы, то есть не в MS-DOS).</target>
        </trans-unit>
        <trans-unit id="64da8840c3ed49a60f1595d4cb5d5e86fba3d26e" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;front-advance&lt;/var&gt; and &lt;var&gt;rear-advance&lt;/var&gt; specify the marker insertion type for the start of the overlay and for the end of the overlay, respectively. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;. If they are both &lt;code&gt;nil&lt;/code&gt;, the default, then the overlay extends to include any text inserted at the beginning, but not text inserted at the end. If &lt;var&gt;front-advance&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, text inserted at the beginning of the overlay is excluded from the overlay. If &lt;var&gt;rear-advance&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, text inserted at the end of the overlay is included in the overlay.</source>
          <target state="translated">Аргументы &lt;var&gt;front-advance&lt;/var&gt; и &lt;var&gt;rear-advance&lt;/var&gt; указывают тип вставки маркера для начала наложения и для конца наложения соответственно. См. &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Типы вставки маркеров&lt;/a&gt; . Если оба они равны &lt;code&gt;nil&lt;/code&gt; (по умолчанию), то наложение расширяется, чтобы включить любой текст, вставленный в начале, но не текст, вставленный в конце. Если &lt;var&gt;front-advance&lt;/var&gt; не равен &lt;code&gt;nil&lt;/code&gt; , текст, вставленный в начале оверлея, исключается из оверлея. Если &lt;var&gt;rear-advance&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; , текст, вставленный в конце оверлея, включается в оверлей.</target>
        </trans-unit>
        <trans-unit id="97c844f62d367d7173221f3f8a509a2c63cee23c" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;host&lt;/var&gt; and &lt;var&gt;service&lt;/var&gt; specify where to connect to; &lt;var&gt;host&lt;/var&gt; is the host name (a string), and &lt;var&gt;service&lt;/var&gt; is the name of a defined network service (a string) or a port number (an integer like &lt;code&gt;80&lt;/code&gt; or an integer string like &lt;code&gt;&quot;80&quot;&lt;/code&gt;).</source>
          <target state="translated">Аргументы &lt;var&gt;host&lt;/var&gt; и &lt;var&gt;service&lt;/var&gt; указывают, к чему подключаться; &lt;var&gt;host&lt;/var&gt; - это имя хоста (строка), а &lt;var&gt;service&lt;/var&gt; - это имя определенной сетевой службы (строка) или номер порта (целое число, например &lt;code&gt;80&lt;/code&gt; , или целочисленная строка, например &lt;code&gt;&quot;80&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="34cdb521004558de19416e08fc21cef4475e568a" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; should be numbers standing for the starting and final states of the operation. For instance, an operation that scans a buffer should set these to the results of &lt;code&gt;point-min&lt;/code&gt; and &lt;code&gt;point-max&lt;/code&gt; correspondingly. &lt;var&gt;max-value&lt;/var&gt; should be greater than &lt;var&gt;min-value&lt;/var&gt;.</source>
          <target state="translated">Аргументы &lt;var&gt;min-value&lt;/var&gt; и &lt;var&gt;max-value&lt;/var&gt; должны быть числами, обозначающими начальное и конечное состояния операции. Например, операция, которая сканирует буфер, должна установить для них результаты &lt;code&gt;point-min&lt;/code&gt; и &lt;code&gt;point-max&lt;/code&gt; соответственно. &lt;var&gt;max-value&lt;/var&gt; должно быть больше &lt;var&gt;min-value&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="cff38d80b42f070246735699a0bac4bf679938b6" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; have the same meanings as in the function &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Note that the &lt;var&gt;all-frames&lt;/var&gt; argument does &lt;em&gt;not&lt;/em&gt; behave exactly like in &lt;code&gt;get-buffer-window&lt;/code&gt;.</source>
          <target state="translated">Аргументы &lt;var&gt;minibuf&lt;/var&gt; и &lt;var&gt;all-frames&lt;/var&gt; имеют то же значение, что и в функции &lt;code&gt;next-window&lt;/code&gt; (см. &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Циклический порядок окон&lt;/a&gt; ). Обратите внимание, что аргумент &lt;var&gt;all-frames&lt;/var&gt; ведет себя &lt;em&gt;не&lt;/em&gt; так, как в &lt;code&gt;get-buffer-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01d6b84175f7364145c82b076d43d4cd73606a88" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;params&lt;/var&gt; are specified as keyword/value pairs. All the parameters are optional, but if no parameters are specified, the function will do nothing and return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Аргументы &lt;var&gt;params&lt;/var&gt; указан в виде пара ключевого слова / значения. Все параметры необязательны, но если параметры не указаны, функция ничего не сделает и вернет &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc7481fa7deb6b4399c57ef9a83c397322635635" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;seconds&lt;/var&gt; and &lt;var&gt;millisec&lt;/var&gt; let you specify timeout periods. The former specifies a period measured in seconds and the latter specifies one measured in milliseconds. The two time periods thus specified are added together, and &lt;code&gt;accept-process-output&lt;/code&gt; returns after that much time, even if there is no subprocess output.</source>
          <target state="translated">Аргументы &lt;var&gt;seconds&lt;/var&gt; и &lt;var&gt;millisec&lt;/var&gt; позволяют указать периоды ожидания. Первый указывает период, измеряемый в секундах, а второй - период в миллисекундах. Два указанных таким образом периода времени складываются, и &lt;code&gt;accept-process-output&lt;/code&gt; возвращается по истечении этого времени, даже если нет вывода подпроцесса.</target>
        </trans-unit>
        <trans-unit id="40b8cf91d8ad0d522899259a939f943a2be85226" translate="yes" xml:space="preserve">
          <source>The arguments after the protected form are handlers. Each handler lists one or more &lt;em&gt;condition names&lt;/em&gt; (which are symbols) to specify which errors it will handle. The error symbol specified when an error is signaled also defines a list of condition names. A handler applies to an error if they have any condition names in common. In the example above, there is one handler, and it specifies one condition name, &lt;code&gt;error&lt;/code&gt;, which covers all errors.</source>
          <target state="translated">Аргументы после защищенной формы являются обработчиками. Каждый обработчик перечисляет одно или несколько &lt;em&gt;имен условий&lt;/em&gt; (которые являются символами), чтобы указать, какие ошибки он будет обрабатывать. Символ ошибки, указываемый при сообщении об ошибке, также определяет список имен условий. Обработчик применяется к ошибке, если у них есть общие имена условий. В приведенном выше примере есть один обработчик, и он указывает одно имя условия, &lt;code&gt;error&lt;/code&gt; , которое охватывает все ошибки.</target>
        </trans-unit>
        <trans-unit id="9212152c0a1d54415d1a64052fa71d9a41f7a676" translate="yes" xml:space="preserve">
          <source>The arguments and the forms in each argument are processed in order, and if a previous form already translates &lt;var&gt;to&lt;/var&gt; to some other character, say &lt;var&gt;to-alt&lt;/var&gt;, &lt;var&gt;from&lt;/var&gt; is also translated to &lt;var&gt;to-alt&lt;/var&gt;.</source>
          <target state="translated">Аргументы и форма в каждом аргументе обрабатываются в порядке, и если предыдущая форма уже переводится &lt;var&gt;to&lt;/var&gt; какой - то другой символ, скажем , &lt;var&gt;to-alt&lt;/var&gt; , &lt;var&gt;from&lt;/var&gt; также переведены на &lt;var&gt;to-alt&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="814b87943ef37ce98ee6242e77f736c9eb2fb447" translate="yes" xml:space="preserve">
          <source>The arguments are handled in almost the same way as for &lt;code&gt;call-process&lt;/code&gt;, with the following differences:</source>
          <target state="translated">Аргументы обрабатываются почти так же, как для &lt;code&gt;call-process&lt;/code&gt; , со следующими отличиями:</target>
        </trans-unit>
        <trans-unit id="fcce85c9773f3a972b86865cc6636258080a75e9" translate="yes" xml:space="preserve">
          <source>The array (either a string or a vector) is a keyboard macro. The events used so far in the lookup form a complete key, and the array is its binding. See &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;, for more information.</source>
          <target state="translated">Массив (строка или вектор) - это макрос клавиатуры. События, использованные до сих пор в поиске, образуют полный ключ, а массив является его привязкой. См. Дополнительные сведения в разделе &amp;laquo; &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Макросы клавиатуры&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="963886fcccc037b6f38c2a2596d1c5be6615d83d" translate="yes" xml:space="preserve">
          <source>The array type is a subset of the sequence type, and contains the string type, the vector type, the bool-vector type, and the char-table type.</source>
          <target state="translated">Тип массива является подмножеством типа последовательности и содержит строковый тип,векторный тип,тип bool-vector и тип char-table.</target>
        </trans-unit>
        <trans-unit id="0f5f28eb8e784010e8d3a08cf4b1d401f6ae42af" translate="yes" xml:space="preserve">
          <source>The ascent and descent of this font. The sum of these two numbers gives the font height.</source>
          <target state="translated">Восхождение и спуск этого шрифта.Сумма этих двух чисел дает высоту шрифта.</target>
        </trans-unit>
        <trans-unit id="7e216dedda9faf32fa78cf8ce88437f4d994fd23" translate="yes" xml:space="preserve">
          <source>The ascent and descent of this font. The sum of these two numbers should be equal to the value of &lt;var&gt;height&lt;/var&gt; above.</source>
          <target state="translated">Подъем и спуск этого шрифта. Сумма этих двух чисел должна быть равна значению &lt;var&gt;height&lt;/var&gt; выше.</target>
        </trans-unit>
        <trans-unit id="d2192054ba53475e5b125700aa3f3380335e17a2" translate="yes" xml:space="preserve">
          <source>The associated buffer of the process.</source>
          <target state="translated">Соответствующий буфер процесса.</target>
        </trans-unit>
        <trans-unit id="4e9bf1b1a4172ecf859689db8cd8cd68a80b729f" translate="yes" xml:space="preserve">
          <source>The associated value is the process buffer.</source>
          <target state="translated">Сопутствующим значением является буфер процесса.</target>
        </trans-unit>
        <trans-unit id="a2b38e01be3ffa82581d5a54dfe09f0aeda1f048" translate="yes" xml:space="preserve">
          <source>The associated value is the process filter function. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">Связанное значение - это функция фильтрации процесса. См. &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Функции фильтра&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48d7a92d54184811d7707356f98484aee137939d" translate="yes" xml:space="preserve">
          <source>The associated value is the process sentinel function. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">Связанное значение - это функция дозорного процесса. Смотрите &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95db3e2086e53bdd69e52a5a8427bb4c66aa1f51" translate="yes" xml:space="preserve">
          <source>The association list describing the buffer-local variable bindings of this buffer, not including the built-in buffer-local bindings that have special slots in the buffer object. (Those slots are omitted from this table.) See &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</source>
          <target state="translated">Список ассоциаций, описывающий привязки локальных переменных этого буфера, не включая встроенные привязки локальных буферов, которые имеют специальные слоты в объекте буфера. (Эти слоты не указаны в этой таблице.) См. &amp;laquo; &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Локальные переменные буфера&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7184822d397bb6098b38e6c59e1389ef5652a4" translate="yes" xml:space="preserve">
          <source>The attributes &lt;code&gt;:weight&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; have symbolic values in a range centered around &lt;code&gt;normal&lt;/code&gt;. Matches that are more extreme (farther from &lt;code&gt;normal&lt;/code&gt;) are somewhat preferred to matches that are less extreme (closer to &lt;code&gt;normal&lt;/code&gt;); this is designed to ensure that non-normal faces contrast with normal ones, whenever possible.</source>
          <target state="translated">Атрибуты &lt;code&gt;:weight&lt;/code&gt; и &lt;code&gt;:width&lt;/code&gt; имеют символические значения в диапазоне от &lt;code&gt;normal&lt;/code&gt; . Более экстремальные совпадения (более далекие от &lt;code&gt;normal&lt;/code&gt; ) в некоторой степени предпочтительнее менее экстремальных (более близких к &lt;code&gt;normal&lt;/code&gt; ); это сделано для того, чтобы нестандартные лица контрастировали с нормальными, когда это возможно.</target>
        </trans-unit>
        <trans-unit id="0abb4a0617aec66a698231d1cbca2e1c3a48e616" translate="yes" xml:space="preserve">
          <source>The attributes of remote files can be cached for better performance. If they are changed outside of Emacs&amp;rsquo;s control, the cached values become invalid, and must be reread.</source>
          <target state="translated">Атрибуты удаленных файлов можно кэшировать для повышения производительности. Если они изменяются вне контроля Emacs, кешированные значения становятся недействительными и должны быть перечитаны.</target>
        </trans-unit>
        <trans-unit id="23608b582d3ca9bf4c877cee9d51711a0c0a0644" translate="yes" xml:space="preserve">
          <source>The autoloaded file usually contains other definitions and may require or provide one or more features. If the file is not completely loaded (due to an error in the evaluation of its contents), any function definitions or &lt;code&gt;provide&lt;/code&gt; calls that occurred during the load are undone. This is to ensure that the next attempt to call any function autoloading from this file will try again to load the file. If not for this, then some of the functions in the file might be defined by the aborted load, but fail to work properly for the lack of certain subroutines not loaded successfully because they come later in the file.</source>
          <target state="translated">Автозагружаемый файл обычно содержит другие определения и может требовать или предоставлять одну или несколько функций. Если файл не был полностью загружен (из - за ошибки в оценке ее содержимого), любые определения функций или &lt;code&gt;provide&lt;/code&gt; вызовы , которые имели место во время загрузки отменяются. Это необходимо для того, чтобы при следующей попытке вызвать какую-либо функцию автозагрузки из этого файла мы снова попытаемся загрузить файл. Если бы не это, то некоторые функции в файле могли бы быть определены прерванной загрузкой, но не могли работать должным образом из-за отсутствия определенных подпрограмм, которые не были загружены успешно, потому что они появляются позже в файле.</target>
        </trans-unit>
        <trans-unit id="3c1146df3835709f3489eed6acaaa81381b10221" translate="yes" xml:space="preserve">
          <source>The average width of the font characters. If this is zero, Emacs uses the value of &lt;var&gt;space-width&lt;/var&gt; instead, when it calculates text layout on display.</source>
          <target state="translated">Средняя ширина символов шрифта. Если это ноль, Emacs вместо этого использует значение &lt;var&gt;space-width&lt;/var&gt; при вычислении макета текста на дисплее.</target>
        </trans-unit>
        <trans-unit id="704160cb67753b1d63800eb641605e7fceeb4095" translate="yes" xml:space="preserve">
          <source>The background stipple, a bitmap.</source>
          <target state="translated">Фоновая шпилька,немного картинки.</target>
        </trans-unit>
        <trans-unit id="4dfd0f8fb905e11c58077fc23caa09ad33e261d1" translate="yes" xml:space="preserve">
          <source>The backquote-style pattern is more concise, resembles the structure of &lt;var&gt;expval&lt;/var&gt;, and avoids binding &lt;code&gt;ls&lt;/code&gt;.</source>
          <target state="translated">Шаблон в стиле &lt;var&gt;expval&lt;/var&gt; более лаконичен , напоминает структуру expval и позволяет избежать привязки &lt;code&gt;ls&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f62846ef32f37cfacd61a3173063b8365ba096" translate="yes" xml:space="preserve">
          <source>The backslash and newline immediately following the double-quote are a convention used only in the preloaded uncompiled Lisp files such as</source>
          <target state="translated">Обратная косая черта и новая строка,следующая сразу за двойной кавычкой,-это соглашение,используемое только в предварительно загруженных некомпилированных Lisp-файлах,таких как</target>
        </trans-unit>
        <trans-unit id="de1dd4b617fb02852473458167ad4aff4326193a" translate="yes" xml:space="preserve">
          <source>The backtrace buffer is killed automatically when you continue execution.</source>
          <target state="translated">Буфер обратной связи автоматически уничтожается при продолжении выполнения.</target>
        </trans-unit>
        <trans-unit id="ddf6b6a15b9c301145e71531518322c635178411" translate="yes" xml:space="preserve">
          <source>The backtrace buffer is read-only and uses a special major mode, Debugger mode, in which letters are defined as debugger commands. The usual Emacs editing commands are available; thus, you can switch windows to examine the buffer that was being edited at the time of the error, switch buffers, visit files, or do any other sort of editing. However, the debugger is a recursive editing level (see &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;) and it is wise to go back to the backtrace buffer and exit the debugger (with the</source>
          <target state="translated">Буфер обратной трассировки доступен только для чтения и использует специальный основной режим, режим отладчика, в котором буквы определяются как команды отладчика. Доступны обычные команды редактирования Emacs; таким образом, вы можете переключать окна, чтобы исследовать буфер, который редактировался во время ошибки, переключать буферы, посещать файлы или выполнять любые другие виды редактирования. Однако отладчик - это уровень рекурсивного редактирования (см. &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Рекурсивное редактирование&lt;/a&gt; ), и разумно вернуться в буфер обратной трассировки и выйти из отладчика (с</target>
        </trans-unit>
        <trans-unit id="23b99814c4ea22e4979913b8fb0652d765957bab" translate="yes" xml:space="preserve">
          <source>The backtrace buffer shows you the functions that are executing and their argument values. When a backtrace buffer is created, it shows each stack frame on one, possibly very long, line. (A stack frame is the place where the Lisp interpreter records information about a particular invocation of a function.) The most recently called function will be at the top.</source>
          <target state="translated">Буфер обратной связи показывает выполняемые функции и их значения аргументов.Когда буфер обратной связи создаётся,он показывает каждый кадр стека на одной,возможно,очень длинной линии.(Стековый кадр-это место,где интерпретатор Lisp записывает информацию о конкретном вызове функции).Самая последняя вызываемая функция будет находиться вверху.</target>
        </trans-unit>
        <trans-unit id="8595c07de42c7db906c6a77faaf01296ee5350c3" translate="yes" xml:space="preserve">
          <source>The basic Emacs command for clicking on links is</source>
          <target state="translated">Основная команда Emacs для клика по ссылкам это</target>
        </trans-unit>
        <trans-unit id="23904938ca5f99404695e7880a93c552b6870965" translate="yes" xml:space="preserve">
          <source>The basic concepts of Emacs Lisp packages.</source>
          <target state="translated">Основные концепции пакетов Emacs Lisp.</target>
        </trans-unit>
        <trans-unit id="dd326d0a3d35091e15c16c7f337b0ac66431cc24" translate="yes" xml:space="preserve">
          <source>The basic function for creating network connections and network servers is &lt;code&gt;make-network-process&lt;/code&gt;. It can do either of those jobs, depending on the arguments you give it.</source>
          <target state="translated">Основная функция для создания сетевых подключений и сетевых серверов - &lt;code&gt;make-network-process&lt;/code&gt; . Он может выполнять любую из этих задач, в зависимости от аргументов, которые вы ему приводите.</target>
        </trans-unit>
        <trans-unit id="d950bb62899f50881bf10776ee448a653788f392" translate="yes" xml:space="preserve">
          <source>The basic object of editing.</source>
          <target state="translated">Основной объект редактирования.</target>
        </trans-unit>
        <trans-unit id="f5a66fbf4e523bf88c788fc3850d6087dd15ab3a" translate="yes" xml:space="preserve">
          <source>The basic problem.</source>
          <target state="translated">Основная проблема.</target>
        </trans-unit>
        <trans-unit id="181c1d01d991db4a55dd6d74f5a790be57e3b4e0" translate="yes" xml:space="preserve">
          <source>The basic textual scrolling functions are &lt;code&gt;scroll-up&lt;/code&gt; (which scrolls forward) and &lt;code&gt;scroll-down&lt;/code&gt; (which scrolls backward). In these function names, &amp;ldquo;up&amp;rdquo; and &amp;ldquo;down&amp;rdquo; refer to the direction of motion of the buffer text relative to the window. Imagine that the text is written on a long roll of paper and that the scrolling commands move the paper up and down. Thus, if you are looking at the middle of a buffer and repeatedly call &lt;code&gt;scroll-down&lt;/code&gt;, you will eventually see the beginning of the buffer.</source>
          <target state="translated">Основные функции прокрутки текста - это &lt;code&gt;scroll-up&lt;/code&gt; ( прокрутка вперед) и &lt;code&gt;scroll-down&lt;/code&gt; ( прокрутка назад). В этих именах функций &amp;laquo;вверх&amp;raquo; и &amp;laquo;вниз&amp;raquo; относятся к направлению движения текста буфера относительно окна. Представьте, что текст написан на длинном рулоне бумаги и что команды прокрутки перемещают бумагу вверх и вниз. Таким образом, если вы смотрите на середину буфера и многократно вызываете &lt;code&gt;scroll-down&lt;/code&gt; , вы в конечном итоге увидите начало буфера.</target>
        </trans-unit>
        <trans-unit id="d4701282aa39cd5d0eb4d386c2b17738d17c6095" translate="yes" xml:space="preserve">
          <source>The basis for &lt;code&gt;symbol-file&lt;/code&gt; is the data in the variable &lt;code&gt;load-history&lt;/code&gt;.</source>
          <target state="translated">Основой для &lt;code&gt;symbol-file&lt;/code&gt; являются данные в переменной &lt;code&gt;load-history&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a5348bdb54f46d592e5625886bbc8814fd8b74f" translate="yes" xml:space="preserve">
          <source>The behavior can be fixed by making a new parent window when splitting &lt;var&gt;W2&lt;/var&gt;. The variable described next allows that to be done.</source>
          <target state="translated">Поведение можно исправить, создав новое родительское окно при разделении &lt;var&gt;W2&lt;/var&gt; . Описанная ниже переменная позволяет это сделать.</target>
        </trans-unit>
        <trans-unit id="64b48110852054851530f6c1baded1e70feabdf3" translate="yes" xml:space="preserve">
          <source>The behavior is also controlled by &lt;var&gt;alist&lt;/var&gt; entries for &lt;code&gt;inhibit-same-window&lt;/code&gt;, &lt;code&gt;reusable-frames&lt;/code&gt; and &lt;code&gt;inhibit-switch-frame&lt;/code&gt;, like &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; does.</source>
          <target state="translated">Поведение также контролируется записями &lt;var&gt;alist&lt;/var&gt; для &lt;code&gt;inhibit-same-window&lt;/code&gt; , &lt;code&gt;reusable-frames&lt;/code&gt; и &lt;code&gt;inhibit-switch-frame&lt;/code&gt; , как это делает &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25ff2d06be08150ca72615f6107e00c6cbe0b1b1" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;display-buffer&lt;/code&gt; is highly customizable. To understand how customizations are used in practice, you may wish to study examples illustrating the order of precedence which &lt;code&gt;display-buffer&lt;/code&gt; uses to call action functions (see &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;Precedence of Action Functions&lt;/a&gt;). To avoid conflicts between Lisp programs calling &lt;code&gt;display-buffer&lt;/code&gt; and user customizations of its behavior, it may make sense to follow a number of guidelines which are sketched in the final part of this section (see &lt;a href=&quot;the-zen-of-buffer-display#The-Zen-of-Buffer-Display&quot;&gt;The Zen of Buffer Display&lt;/a&gt;).</source>
          <target state="translated">Поведение &lt;code&gt;display-buffer&lt;/code&gt; легко настраивается. Чтобы понять, как настройки используются на практике, вы можете изучить примеры, иллюстрирующие порядок приоритета, который &lt;code&gt;display-buffer&lt;/code&gt; использует для вызова функций действий (см. &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;Приоритет функций действий&lt;/a&gt; ). Чтобы избежать конфликтов между программами Lisp, вызывающими &lt;code&gt;display-buffer&lt;/code&gt; , и пользовательскими настройками его поведения, может иметь смысл следовать ряду рекомендаций, которые набросаны в заключительной части этого раздела (см &lt;a href=&quot;the-zen-of-buffer-display#The-Zen-of-Buffer-Display&quot;&gt;. Дзен отображения буфера&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="48fe4299049d7c93ed4a533dc27f43e4ebb09779" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; can be controlled with the help of the two options listed next.</source>
          <target state="translated">Поведение &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; можно контролировать с помощью двух опций, перечисленных ниже.</target>
        </trans-unit>
        <trans-unit id="14d6ad7c7b1496920e84cec590095837471103e0" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;parse-partial-sexp&lt;/code&gt; is also affected by &lt;code&gt;parse-sexp-lookup-properties&lt;/code&gt; (see &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Syntax Properties&lt;/a&gt;).</source>
          <target state="translated">На поведение &lt;code&gt;parse-partial-sexp&lt;/code&gt; также влияют &lt;code&gt;parse-sexp-lookup-properties&lt;/code&gt; (см. &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Свойства синтаксиса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4c9653c1321ba597070b3a8bcef63917fd4713f" translate="yes" xml:space="preserve">
          <source>The behavior of buffer display actions (see &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;) can be further modified by the following user options.</source>
          <target state="translated">Поведение действий отображения буфера (см. &amp;laquo; &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Окно выбора&amp;raquo;&lt;/a&gt; ) может быть дополнительно изменено следующими параметрами пользователя.</target>
        </trans-unit>
        <trans-unit id="af430c0aab9b6a6a7fdfe43e9d585a9057ba6897" translate="yes" xml:space="preserve">
          <source>The behavior of child frames deviates from that of top-level frames in a number of other ways as well. Here we sketch a few of them:</source>
          <target state="translated">Поведение детских кадров также отличается от поведения кадров верхнего уровня рядом других способов.Здесь мы набросаем несколько из них:</target>
        </trans-unit>
        <trans-unit id="b740a83bb87c1094d716f669539562dedcf7a073" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be altered by the window parameters of &lt;var&gt;window&lt;/var&gt;, so long as the variable &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value of the &lt;code&gt;delete-other-windows&lt;/code&gt; window parameter is &lt;code&gt;t&lt;/code&gt;, this function ignores all other window parameters. Otherwise, if the value of the &lt;code&gt;delete-other-windows&lt;/code&gt; window parameter is a function, that function is called with the argument &lt;var&gt;window&lt;/var&gt;, in lieu of the usual action of &lt;code&gt;delete-other-windows&lt;/code&gt;. See &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;.</source>
          <target state="translated">Поведение этой функции может быть изменено параметрами &lt;var&gt;window&lt;/var&gt; , пока переменная &lt;code&gt;ignore-window-parameters&lt;/code&gt; равна &lt;code&gt;nil&lt;/code&gt; . Если значение параметра окна &lt;code&gt;delete-other-windows&lt;/code&gt; равно &lt;code&gt;t&lt;/code&gt; , эта функция игнорирует все остальные параметры окна. В противном случае, если значение параметра окна &lt;code&gt;delete-other-windows&lt;/code&gt; является функцией, эта функция вызывается с аргументом &lt;var&gt;window&lt;/var&gt; вместо обычного действия &lt;code&gt;delete-other-windows&lt;/code&gt; . См. &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Параметры окна&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f60ec1dc913f2d4aba64531e32d867d8e2f6ecb" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be altered by the window parameters of &lt;var&gt;window&lt;/var&gt;, so long as the variable &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value of the &lt;code&gt;delete-window&lt;/code&gt; window parameter is &lt;code&gt;t&lt;/code&gt;, this function ignores all other window parameters. Otherwise, if the value of the &lt;code&gt;delete-window&lt;/code&gt; window parameter is a function, that function is called with the argument &lt;var&gt;window&lt;/var&gt;, in lieu of the usual action of &lt;code&gt;delete-window&lt;/code&gt;. See &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;.</source>
          <target state="translated">Поведение этой функции может быть изменено параметрами &lt;var&gt;window&lt;/var&gt; , пока переменная &lt;code&gt;ignore-window-parameters&lt;/code&gt; равна &lt;code&gt;nil&lt;/code&gt; . Если значение параметра окна &lt;code&gt;delete-window&lt;/code&gt; равно &lt;code&gt;t&lt;/code&gt; , эта функция игнорирует все другие параметры окна. В противном случае, если значением параметра окна &lt;code&gt;delete-window&lt;/code&gt; является функция, эта функция вызывается с аргументом &lt;var&gt;window&lt;/var&gt; вместо обычного действия &lt;code&gt;delete-window&lt;/code&gt; . См. &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Параметры окна&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8909897602cd17a4273ebb64ab850510d93123be" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be altered by the window parameters of &lt;var&gt;window&lt;/var&gt;, so long as the variable &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value of the &lt;code&gt;split-window&lt;/code&gt; window parameter is &lt;code&gt;t&lt;/code&gt;, this function ignores all other window parameters. Otherwise, if the value of the &lt;code&gt;split-window&lt;/code&gt; window parameter is a function, that function is called with the arguments &lt;var&gt;window&lt;/var&gt;, &lt;var&gt;size&lt;/var&gt;, and &lt;var&gt;side&lt;/var&gt;, in lieu of the usual action of &lt;code&gt;split-window&lt;/code&gt;. Otherwise, this function obeys the &lt;code&gt;window-atom&lt;/code&gt; or &lt;code&gt;window-side&lt;/code&gt; window parameter, if any. See &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;.</source>
          <target state="translated">Поведение этой функции может быть изменено параметрами &lt;var&gt;window&lt;/var&gt; , пока переменная &lt;code&gt;ignore-window-parameters&lt;/code&gt; равна &lt;code&gt;nil&lt;/code&gt; . Если значение параметра окна с &lt;code&gt;split-window&lt;/code&gt; равно &lt;code&gt;t&lt;/code&gt; , эта функция игнорирует все остальные параметры окна. В противном случае, если значение параметра окна с &lt;code&gt;split-window&lt;/code&gt; является функцией, эта функция вызывается с аргументами &lt;var&gt;window&lt;/var&gt; , &lt;var&gt;size&lt;/var&gt; и &lt;var&gt;side&lt;/var&gt; вместо обычного действия с &lt;code&gt;split-window&lt;/code&gt; . В противном случае эта функция подчиняется параметру &lt;code&gt;window-atom&lt;/code&gt; или &lt;code&gt;window-side&lt;/code&gt; window, если таковой имеется. Видеть&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Параметры окна&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc45d4c978076585a6ff258d4628feaba65d091" translate="yes" xml:space="preserve">
          <source>The bidirectional properties of characters can be overridden by inserting into the text special directional control characters, LEFT-TO-RIGHT OVERRIDE (</source>
          <target state="translated">Двунаправленные свойства символов могут быть переопределены путем вставки в текст специальных символов управления направлением,LEFT-TO-RIGHT OVERRIDE (ВЛЕВО-ПРАВО-ОБРАЗОВАНИЕ)(</target>
        </trans-unit>
        <trans-unit id="7ddc9759fd2b7786cbd37b4781873ad47f324e2a" translate="yes" xml:space="preserve">
          <source>The binding whose definition is &lt;code&gt;(&quot;--&quot;)&lt;/code&gt; is a separator line. Like a real menu item, the separator has a key symbol, in this case &lt;code&gt;separator-replace-tags&lt;/code&gt;. If one menu has two separators, they must have two different key symbols.</source>
          <target state="translated">Привязка, определение которой &lt;code&gt;(&quot;--&quot;)&lt;/code&gt; является разделительной линией. Как и в реальном пункте меню, разделитель имеет символ ключа, в данном случае &lt;code&gt;separator-replace-tags&lt;/code&gt; . Если в одном меню есть два разделителя, они должны иметь два разных символа клавиш.</target>
        </trans-unit>
        <trans-unit id="8bc0cde3ac12a6a4acea584ef36bd73f7c9731fc" translate="yes" xml:space="preserve">
          <source>The bitwise operations in Emacs Lisp apply only to integers.</source>
          <target state="translated">Битовые операции в Emacs Lisp применяются только к целым числам.</target>
        </trans-unit>
        <trans-unit id="457ac28d787de6ecd95feb0905b63526b367e16f" translate="yes" xml:space="preserve">
          <source>The body of the notification. If &lt;var&gt;body&lt;/var&gt; is a string, it specifies the text of the notification message. Use embedded newlines to control how the text is broken into lines. The body text can be up to 255 characters long, and will be truncated if it&amp;rsquo;s longer. Unlike with D-Bus, the body text should be plain text, with no markup.</source>
          <target state="translated">Тело уведомления. Если &lt;var&gt;body&lt;/var&gt; является строкой, оно определяет текст сообщения уведомления. Используйте встроенные символы новой строки, чтобы контролировать, как текст разбивается на строки. Основной текст может иметь длину до 255 символов и будет обрезан, если он длиннее. В отличие от D-Bus, основной текст должен быть простым текстом без разметки.</target>
        </trans-unit>
        <trans-unit id="c5d378c0de07cb367247e7065675fce352e2e8da" translate="yes" xml:space="preserve">
          <source>The brief description is also taken from the first line. Here, it is &amp;lsquo;</source>
          <target state="translated">Краткое описание также взято из первой строки. Вот '</target>
        </trans-unit>
        <trans-unit id="fbd2e470098b8a59979b42d91f57778cec2ac8a5" translate="yes" xml:space="preserve">
          <source>The broadcast address.</source>
          <target state="translated">Адрес трансляции.</target>
        </trans-unit>
        <trans-unit id="9444e738ec3ad2f036ba7f9ef0d9c118bd783945" translate="yes" xml:space="preserve">
          <source>The buffer file name indicates which file is visited.</source>
          <target state="translated">Имя файла буфера указывает,какой файл посещается.</target>
        </trans-unit>
        <trans-unit id="46b639fbc76f834ed60b16f7c2c36f68d4fa8701" translate="yes" xml:space="preserve">
          <source>The buffer object for the buffer that has been killed remains in existence as long as anything refers to it, but it is specially marked so that you cannot make it current or display it. Killed buffers retain their identity, however; if you kill two distinct buffers, they remain distinct according to &lt;code&gt;eq&lt;/code&gt; although both are dead.</source>
          <target state="translated">Буферный объект для буфера, который был уничтожен, остается существующим, пока что-либо ссылается на него, но он специально помечен, чтобы вы не могли сделать его текущим или отобразить его. Однако убитые буферы сохраняют свою идентичность; если вы убьете два разных буфера, они останутся разными согласно &lt;code&gt;eq&lt;/code&gt; , хотя оба мертвы.</target>
        </trans-unit>
        <trans-unit id="2bb148bf41b83dd7c67c5ca983b4f737e34081a2" translate="yes" xml:space="preserve">
          <source>The buffer position of the character clicked on in the text area; or, if the click was outside the text area, the window area where it occurred. It is one of the symbols &lt;code&gt;mode-line&lt;/code&gt;, &lt;code&gt;header-line&lt;/code&gt;, &lt;code&gt;tab-line&lt;/code&gt;, &lt;code&gt;vertical-line&lt;/code&gt;, &lt;code&gt;left-margin&lt;/code&gt;, &lt;code&gt;right-margin&lt;/code&gt;, &lt;code&gt;left-fringe&lt;/code&gt;, or &lt;code&gt;right-fringe&lt;/code&gt;.</source>
          <target state="translated">Положение в буфере символа, по которому щелкнули в текстовой области; или, если щелчок произошел за пределами текстовой области, области окна, где он произошел. Это один из символов &lt;code&gt;mode-line&lt;/code&gt; , &lt;code&gt;header-line&lt;/code&gt; , &lt;code&gt;tab-line&lt;/code&gt; , &lt;code&gt;vertical-line&lt;/code&gt; , &lt;code&gt;left-margin&lt;/code&gt; , &lt;code&gt;right-margin&lt;/code&gt; , &lt;code&gt;left-fringe&lt;/code&gt; или &lt;code&gt;right-fringe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0c6a9c7f2f23737ee9bec0aa37f53da73d239e" translate="yes" xml:space="preserve">
          <source>The buffer to associate with the process. The value can be either a buffer or a string that names a buffer. Process output goes at the end of that buffer, unless you specify an output stream or filter function to handle the output. If &lt;var&gt;buffer&lt;/var&gt; is not given, the process buffer&amp;rsquo;s name is taken from the value of the &lt;code&gt;:name&lt;/code&gt; keyword.</source>
          <target state="translated">Буфер, который нужно связать с процессом. Значение может быть либо буфером, либо строкой с именем буфера. Вывод процесса идет в конец этого буфера, если вы не укажете выходной поток или функцию фильтра для обработки вывода. Если &lt;var&gt;buffer&lt;/var&gt; не указан, имя буфера процесса берется из значения ключевого слова &lt;code&gt;:name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42a7a981c12f34f51806e6af8e44330ecc1873b4" translate="yes" xml:space="preserve">
          <source>The buffer which its text is generated in.</source>
          <target state="translated">Буфер,в котором генерируется его текст.</target>
        </trans-unit>
        <trans-unit id="72b7af992a3abc5d40c1f25fff8d07a12b73f582" translate="yes" xml:space="preserve">
          <source>The buffer will only auto-revert if it is marked unmodified. Hence, you will have to make sure that various functions mark the buffer modified if and only if either the buffer contains information that might be lost by reverting, or there is reason to believe that the user might be inconvenienced by auto-reverting, because he is actively working on the buffer. The user can always override this by manually adjusting the modified status of the buffer. To support this, calling the &lt;code&gt;revert-buffer-function&lt;/code&gt; on a buffer that is marked unmodified should always keep the buffer marked unmodified.</source>
          <target state="translated">Буфер будет автоматически возвращаться, только если он помечен как неизмененный. Следовательно, вам нужно будет убедиться, что различные функции помечают буфер как измененный тогда и только тогда, когда либо буфер содержит информацию, которая может быть потеряна при возврате, либо есть основания полагать, что пользователю может быть неудобно автоматический возврат, потому что он активно работает над буфером. Пользователь всегда может отменить это, вручную настроив измененный статус буфера. Чтобы поддержать это, вызов функции &lt;code&gt;revert-buffer-function&lt;/code&gt; для буфера, помеченного как неизмененный, должен всегда сохранять буфер, помеченный как немодифицированный.</target>
        </trans-unit>
        <trans-unit id="873949287545ef0ee1c24f3a275146b7c289aea3" translate="yes" xml:space="preserve">
          <source>The buffer&amp;rsquo;s value of point, as of the last time a redisplay completed in this window.</source>
          <target state="translated">Значение точки в буфере на момент последнего завершения повторного отображения в этом окне.</target>
        </trans-unit>
        <trans-unit id="4ee204383471ebb747819beeda4333dfcb08b7c3" translate="yes" xml:space="preserve">
          <source>The buffer-local value of &lt;var&gt;variable&lt;/var&gt; starts out as the same value &lt;var&gt;variable&lt;/var&gt; previously had. If &lt;var&gt;variable&lt;/var&gt; was void, it remains void.</source>
          <target state="translated">Буфера локального значения &lt;var&gt;variable&lt;/var&gt; начинается, как то же самое значение &lt;var&gt;variable&lt;/var&gt; ранее имели. Если &lt;var&gt;variable&lt;/var&gt; была недействительной, она остается недействительной.</target>
        </trans-unit>
        <trans-unit id="36ca484b5abddc8c8e81e5e6b9502ec9f88a67b6" translate="yes" xml:space="preserve">
          <source>The buffer-local value of this variable holds the symbol for the current major mode. Its default value holds the default major mode for new buffers. The standard default value is &lt;code&gt;fundamental-mode&lt;/code&gt;.</source>
          <target state="translated">Локальное в буфере значение этой переменной содержит символ текущего основного режима. Его значение по умолчанию содержит основной режим по умолчанию для новых буферов. Стандартное значение по умолчанию - &lt;code&gt;fundamental-mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e4cd19bcf9c24b5b8a282bde2c2fd833888ed62" translate="yes" xml:space="preserve">
          <source>The buffer-local variable &lt;code&gt;enable-multibyte-characters&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; in multibyte buffers, and &lt;code&gt;nil&lt;/code&gt; in unibyte ones. The mode line also indicates whether a buffer is multibyte or not. With a graphical display, in a multibyte buffer, the portion of the mode line that indicates the character set has a tooltip that (amongst other things) says that the buffer is multibyte. In a unibyte buffer, the character set indicator is absent. Thus, in a unibyte buffer (when using a graphical display) there is normally nothing before the indication of the visited file&amp;rsquo;s end-of-line convention (colon, backslash, etc.), unless you are using an input method.</source>
          <target state="translated">Локальная в буфере переменная &lt;code&gt;enable-multibyte-characters&lt;/code&gt; не равна &lt;code&gt;nil&lt;/code&gt; в многобайтовых буферах и &lt;code&gt;nil&lt;/code&gt; в однобайтовых. Строка режима также указывает, является ли буфер многобайтовым или нет. При графическом отображении в многобайтовом буфере часть строки режима, которая указывает на набор символов, имеет всплывающую подсказку, которая (среди прочего) сообщает, что буфер многобайтовый. В однобайтовом буфере индикатор набора символов отсутствует. Таким образом, в однобайтовом буфере (при использовании графического дисплея) обычно нет ничего перед указанием соглашения о конце строки посещаемого файла (двоеточие, обратная косая черта и т. Д.), Если вы не используете метод ввода.</target>
        </trans-unit>
        <trans-unit id="acfac422dea48051a2c7c007628247062d5bf74c" translate="yes" xml:space="preserve">
          <source>The buffer-predicate function for this frame. The function &lt;code&gt;other-buffer&lt;/code&gt; uses this predicate (from the selected frame) to decide which buffers it should consider, if the predicate is not &lt;code&gt;nil&lt;/code&gt;. It calls the predicate with one argument, a buffer, once for each buffer; if the predicate returns a non-&lt;code&gt;nil&lt;/code&gt; value, it considers that buffer.</source>
          <target state="translated">Функция предиката буфера для этого кадра. Функция &lt;code&gt;other-buffer&lt;/code&gt; использует этот предикат (из выбранного кадра), чтобы решить, какие буферы следует учитывать, если предикат не равен &lt;code&gt;nil&lt;/code&gt; . Он вызывает предикат с одним аргументом, буфером, один раз для каждого буфера; если предикат возвращает &lt;code&gt;nil&lt;/code&gt; значение, он считает этот буфер.</target>
        </trans-unit>
        <trans-unit id="b4516ab94968d260129418edf75f3cd31faf9215" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;indirect-function&lt;/code&gt; provides an easy way to perform symbol function indirection explicitly.</source>
          <target state="translated">Встроенная функция &lt;code&gt;indirect-function&lt;/code&gt; обеспечивает простой способ явного косвенного обращения к символьной функции.</target>
        </trans-unit>
        <trans-unit id="f3cdf2d46910f6a19f564d8ab1c23afa5ceb31d7" translate="yes" xml:space="preserve">
          <source>The bulk of &lt;code&gt;grok/pcase&lt;/code&gt; is a single clause of a &lt;code&gt;pcase&lt;/code&gt; form, the pattern on lines 1-8, the (single) body form on line 9. The pattern is &lt;code&gt;or&lt;/code&gt;, which tries to match in turn its argument sub-patterns, first &lt;code&gt;and&lt;/code&gt; (lines 2-7), then &lt;code&gt;let&lt;/code&gt; (line 8), until one of them succeeds.</source>
          <target state="translated">Основная часть &lt;code&gt;grok/pcase&lt;/code&gt; - это отдельное предложение формы &lt;code&gt;pcase&lt;/code&gt; , шаблон в строках 1-8, (единственная) основная форма в строке 9. Шаблон - &lt;code&gt;or&lt;/code&gt; , который пытается сопоставить, в свою очередь, подшаблоны аргументов, сначала &lt;code&gt;and&lt;/code&gt; (строки 2-7), затем &lt;code&gt;let&lt;/code&gt; (строка 8), пока один из них не завершится успешно.</target>
        </trans-unit>
        <trans-unit id="fb70f0ac918e95323b7c7d8c894fa19635af573c" translate="yes" xml:space="preserve">
          <source>The button type. See &lt;a href=&quot;button-types#Button-Types&quot;&gt;Button Types&lt;/a&gt;.</source>
          <target state="translated">Тип кнопки. См. &lt;a href=&quot;button-types#Button-Types&quot;&gt;Типы кнопок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc5bc8ec439519ab1bd1ce7c170e4e3b8e964c13" translate="yes" xml:space="preserve">
          <source>The button&amp;rsquo;s keymap, defining bindings active within the button region. By default this is the usual button region keymap, stored in the variable &lt;code&gt;button-map&lt;/code&gt;, which defines</source>
          <target state="translated">Раскладка кнопок, определяющая привязки, активные в области кнопки. По умолчанию это обычная раскладка для области кнопок, хранящаяся в переменной &lt;code&gt;button-map&lt;/code&gt; , которая определяет</target>
        </trans-unit>
        <trans-unit id="a43c685ec98dba6c7317b7c086d65e4dcee7b6a8" translate="yes" xml:space="preserve">
          <source>The button-creation functions all take the &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument &lt;var&gt;properties&lt;/var&gt;, which should be a sequence of &lt;var&gt;property value&lt;/var&gt; pairs, specifying properties to add to the button; see &lt;a href=&quot;button-properties#Button-Properties&quot;&gt;Button Properties&lt;/a&gt;. In addition, the keyword argument &lt;code&gt;:type&lt;/code&gt; may be used to specify a button-type from which to inherit other properties; see &lt;a href=&quot;button-types#Button-Types&quot;&gt;Button Types&lt;/a&gt;. Any properties not explicitly specified during creation will be inherited from the button&amp;rsquo;s type (if the type defines such a property).</source>
          <target state="translated">Все функции создания кнопки принимают &lt;var&gt;properties&lt;/var&gt; аргумента &lt;code&gt;&amp;amp;rest&lt;/code&gt; , которые должны быть последовательностью пар &lt;var&gt;property value&lt;/var&gt; свойств, определяющих свойства для добавления к кнопке; см. &lt;a href=&quot;button-properties#Button-Properties&quot;&gt;Свойства кнопки&lt;/a&gt; . Кроме того, ключевое слово arguments &lt;code&gt;:type&lt;/code&gt; может использоваться для указания типа кнопки, от которого наследуются другие свойства; см. &lt;a href=&quot;button-types#Button-Types&quot;&gt;Типы кнопок&lt;/a&gt; . Любые свойства, не указанные явно при создании, будут унаследованы от типа кнопки (если тип определяет такое свойство).</target>
        </trans-unit>
        <trans-unit id="07b9418ec8ac4ecbb4a365a5bd8c7af6fd875ba2" translate="yes" xml:space="preserve">
          <source>The byte compiler uses the dynamic function loading feature if the variable &lt;code&gt;byte-compile-dynamic&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; at compilation time. Do not set this variable globally, since dynamic loading is desirable only for certain files. Instead, enable the feature for specific source files with file-local variable bindings. For example, you could do it by writing this text in the source file&amp;rsquo;s first line:</source>
          <target state="translated">Компилятор байтов использует функцию динамической загрузки функций, если переменная &lt;code&gt;byte-compile-dynamic&lt;/code&gt; не равна &lt;code&gt;nil&lt;/code&gt; во время компиляции. Не устанавливайте эту переменную глобально, так как динамическая загрузка желательна только для определенных файлов. Вместо этого включите функцию для определенных исходных файлов с привязками локальных переменных файла. Например, вы можете сделать это, написав этот текст в первой строке исходного файла:</target>
        </trans-unit>
        <trans-unit id="b0f586f7c11295ae6041637f812fe199d118bbd2" translate="yes" xml:space="preserve">
          <source>The byte position corresponding to &lt;code&gt;window_end_pos&lt;/code&gt;.</source>
          <target state="translated">Позиция байта, соответствующая &lt;code&gt;window_end_pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf3fbe15bb3d806e89a2d23a877d978fe26d5b4c" translate="yes" xml:space="preserve">
          <source>The byte-code interpreter is implemented as a simple stack machine. It pushes values onto a stack of its own, then pops them off to use them in calculations whose results are themselves pushed back on the stack. When a byte-code function returns, it pops a value off the stack and returns it as the value of the function.</source>
          <target state="translated">Байт-кодовый интерпретатор реализован в виде простой стековой машины.Он выталкивает значения на свой стек,а затем выталкивает их,чтобы использовать в вычислениях,результаты которых сами же выталкиваются на стек.Когда функция байт-кода возвращается,она вытаскивает значение из стека и возвращает его в качестве значения функции.</target>
        </trans-unit>
        <trans-unit id="8f21eeb3ce4b172d88f4a4054b14733959d546ae" translate="yes" xml:space="preserve">
          <source>The call to &lt;var&gt;func&lt;/var&gt; must be in the &lt;var&gt;then-form&lt;/var&gt; of the &lt;code&gt;if&lt;/code&gt;, and &lt;var&gt;func&lt;/var&gt; must appear quoted in the call to &lt;code&gt;fboundp&lt;/code&gt;. (This feature operates for &lt;code&gt;cond&lt;/code&gt; as well.)</source>
          <target state="translated">Вызов &lt;var&gt;func&lt;/var&gt; должен быть в &lt;var&gt;then-form&lt;/var&gt; из &lt;code&gt;if&lt;/code&gt; и &lt;var&gt;func&lt;/var&gt; должен появиться цитируемый в вызове &lt;code&gt;fboundp&lt;/code&gt; . (Эта функция также работает для &lt;code&gt;cond&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="cd816549d0833bdd182cffeef083166bd9eccadb" translate="yes" xml:space="preserve">
          <source>The canonical way to specify the &lt;em&gt;size of a frame&lt;/em&gt; from within Emacs is by specifying its &lt;em&gt;text size&lt;/em&gt;&amp;mdash;a tuple of the width and height of the frame&amp;rsquo;s text area (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;). It can be measured either in pixels or in terms of the frame&amp;rsquo;s canonical character size (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;).</source>
          <target state="translated">Канонический способ указать &lt;em&gt;размер фрейма&lt;/em&gt; из Emacs - это указать его &lt;em&gt;размер текста&lt;/em&gt; - кортеж ширины и высоты текстовой области &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;фрейма&lt;/a&gt; (см. Макет фрейма ). Он может быть измерен либо в пикселях, либо в единицах канонического размера символа &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;кадра&lt;/a&gt; (см. Шрифт кадра ).</target>
        </trans-unit>
        <trans-unit id="35d63b67cea7481378d16b550f8c7d9339ebd861" translate="yes" xml:space="preserve">
          <source>The canonicalize table maps all of a set of case-related characters into a particular member of that set.</source>
          <target state="translated">Канонизация таблицы сопоставляет весь набор символов,связанных с регистром,с конкретным членом этого набора.</target>
        </trans-unit>
        <trans-unit id="d98adabbf87cc8a08f14746c5fbb4310e30779ab" translate="yes" xml:space="preserve">
          <source>The case change commands described here work on text in the current buffer. See &lt;a href=&quot;case-conversion#Case-Conversion&quot;&gt;Case Conversion&lt;/a&gt;, for case conversion functions that work on strings and characters. See &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;Case Tables&lt;/a&gt;, for how to customize which characters are upper or lower case and how to convert them.</source>
          <target state="translated">Команды изменения регистра, описанные здесь, работают с текстом в текущем буфере. См. &lt;a href=&quot;case-conversion#Case-Conversion&quot;&gt;Преобразование регистра&lt;/a&gt; , где описаны функции преобразования регистра, которые работают со строками и символами. См. &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;Таблицы регистра&lt;/a&gt; , чтобы узнать, как настроить символы верхнего или нижнего регистра и как их преобразовать.</target>
        </trans-unit>
        <trans-unit id="77ee252710982b3fcb0142f8b906f77a763d14f3" translate="yes" xml:space="preserve">
          <source>The case of a graphic character is indicated by its character code; for example,</source>
          <target state="translated">Например,случай графического символа обозначается его символьным кодом,</target>
        </trans-unit>
        <trans-unit id="4e2b2272e435daf5cb6f60baee461dfc446d4222" translate="yes" xml:space="preserve">
          <source>The case table for the</source>
          <target state="translated">Корпусная таблица для</target>
        </trans-unit>
        <trans-unit id="280090829e281a538077bc06a68c1ff20cd3fb94" translate="yes" xml:space="preserve">
          <source>The category table is actually a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;). The element of the category table at index &lt;var&gt;c&lt;/var&gt; is a &lt;em&gt;category set&lt;/em&gt;&amp;mdash;a bool-vector&amp;mdash;that indicates which categories character &lt;var&gt;c&lt;/var&gt; belongs to. In this category set, if the element at index &lt;var&gt;cat&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, that means category &lt;var&gt;cat&lt;/var&gt; is a member of the set, and that character &lt;var&gt;c&lt;/var&gt; belongs to category &lt;var&gt;cat&lt;/var&gt;.</source>
          <target state="translated">Таблица категорий на самом деле является таблицей символов (см. &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Таблицы&lt;/a&gt; символов ). Элемент таблицы категорий с индексом &lt;var&gt;c&lt;/var&gt; является &lt;em&gt;набором категорий&lt;/em&gt; - вектором типа bool, который указывает, к каким категориям принадлежит символ &lt;var&gt;c&lt;/var&gt; . В этом наборе категорий, если элемент с индексом &lt;var&gt;cat&lt;/var&gt; равен &lt;code&gt;t&lt;/code&gt; , это означает, что категория &lt;var&gt;cat&lt;/var&gt; является членом набора, и этот символ &lt;var&gt;c&lt;/var&gt; принадлежит категории &lt;var&gt;cat&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d0485386ae15548477e7a1c3ddbf99aabc72746a" translate="yes" xml:space="preserve">
          <source>The char-table has one extra slot, which determines how to display any character that cannot be displayed with any available font, or cannot be encoded by the terminal&amp;rsquo;s coding system. Its value should be one of the above display methods, except &lt;code&gt;zero-width&lt;/code&gt; or a cons cell.</source>
          <target state="translated">Таблица символов имеет один дополнительный слот, который определяет, как отображать любой символ, который не может быть отображен ни одним доступным шрифтом или не может быть закодирован системой кодирования терминала. Его значение должно быть одним из указанных выше методов отображения, кроме &lt;code&gt;zero-width&lt;/code&gt; или cons-ячейки.</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">Персонаж '</target>
        </trans-unit>
        <trans-unit id="e68ebec1ac879e97e03c36bf47008aa20c6bd7bd" translate="yes" xml:space="preserve">
          <source>The character and byte positions of point in a buffer.</source>
          <target state="translated">Символьная и байтовая позиции точки в буфере.</target>
        </trans-unit>
        <trans-unit id="f22f38b266e9823831c9d0ef2c9a1fe74ed5e490" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the beginning of the accessible range of text in the buffer.</source>
          <target state="translated">Позиция символов и байтов начала доступного диапазона текста в буфере.</target>
        </trans-unit>
        <trans-unit id="6c5385edb6d96d02471dae4f088297c2fa6a7318" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the buffer gap. See &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;Buffer Gap&lt;/a&gt;.</source>
          <target state="translated">Позиции символа и байта в буферном промежутке. См. &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;Buffer Gap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c6314b6b815e7c063f41b61f7f1fd27b17e3df8" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the end of the accessible range of text in the buffer.</source>
          <target state="translated">Позиция символов и байтов конца доступного диапазона текста в буфере.</target>
        </trans-unit>
        <trans-unit id="e3ea8b9851630ca5901561ab1adc692dcbe57e4a" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the end of the buffer text.</source>
          <target state="translated">Позиция символов и байтов конца текста буфера.</target>
        </trans-unit>
        <trans-unit id="159599eecd7ed600dfc647ecdceabd08ac6e6b7e" translate="yes" xml:space="preserve">
          <source>The character case functions change the case of single characters or of the contents of strings. The functions normally convert only alphabetic characters (the letters &amp;lsquo;</source>
          <target state="translated">Функции регистра символов изменяют регистр отдельных символов или содержимого строк. Функции обычно преобразуют только буквенные символы (буквы '</target>
        </trans-unit>
        <trans-unit id="58661f35491edec56426ef5502747311e8425649" translate="yes" xml:space="preserve">
          <source>The character position of the start of the innermost parenthetical grouping containing the stopping point; &lt;code&gt;nil&lt;/code&gt; if none.</source>
          <target state="translated">Позиция символа начала самой внутренней группы в скобках, содержащей точку остановки; &lt;code&gt;nil&lt;/code&gt; если нет.</target>
        </trans-unit>
        <trans-unit id="ed5394eb7206607235f4bd5c8e10df5c68b18fa4" translate="yes" xml:space="preserve">
          <source>The character position of the start of the last complete subexpression terminated; &lt;code&gt;nil&lt;/code&gt; if none.</source>
          <target state="translated">Позиция символа начала последнего полного подвыражения завершена; &lt;code&gt;nil&lt;/code&gt; если нет.</target>
        </trans-unit>
        <trans-unit id="1247f75f37cf02e36f0fa69040f3ac6b097ecbdf" translate="yes" xml:space="preserve">
          <source>The characters &amp;lsquo;</source>
          <target state="translated">Персонажи '</target>
        </trans-unit>
        <trans-unit id="54c2a07fdd0ef1fdb5ddcd9fa98003e13884d86d" translate="yes" xml:space="preserve">
          <source>The characters in &lt;var&gt;string&lt;/var&gt;, other than the format specifications, are copied directly into the output, including their text properties, if any. Any text properties of the format specifications are copied to the produced string representations of the argument &lt;var&gt;objects&lt;/var&gt;.</source>
          <target state="translated">Символы в &lt;var&gt;string&lt;/var&gt; , кроме спецификаций формата, копируются непосредственно в вывод, включая их текстовые свойства, если таковые имеются. Любые текстовые свойства спецификаций формата копируются в создаваемые строковые представления &lt;var&gt;objects&lt;/var&gt; аргументов .</target>
        </trans-unit>
        <trans-unit id="d3187515a75e9f5846604d36640635fa33365798" translate="yes" xml:space="preserve">
          <source>The characters in &lt;var&gt;template&lt;/var&gt;, other than the format specifications, are copied directly into the output, including their text properties, if any. Any text properties of the format specifications are copied to their replacements.</source>
          <target state="translated">Символы в &lt;var&gt;template&lt;/var&gt; , кроме спецификаций формата, копируются непосредственно в вывод, включая их текстовые свойства, если таковые имеются. Любые текстовые свойства спецификаций формата копируются на их замену.</target>
        </trans-unit>
        <trans-unit id="846a19eaa57baaea4ef97563adf70350f2950595" translate="yes" xml:space="preserve">
          <source>The charset registry and encoding of the font, such as &amp;lsquo;</source>
          <target state="translated">Реестр кодировок и кодировка шрифта, например '</target>
        </trans-unit>
        <trans-unit id="b3fa5e7367f49d16057c52ffe48350e2d39e997d" translate="yes" xml:space="preserve">
          <source>The choice of which window edges this function alters depends on the values of the option &lt;code&gt;window-combination-resize&lt;/code&gt; and the combination limits of the involved windows; in some cases, it may alter both edges. See &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Recombining Windows&lt;/a&gt;. To resize by moving only the bottom or right edge of a window, use the function &lt;code&gt;adjust-window-trailing-edge&lt;/code&gt;.</source>
          <target state="translated">Выбор того, какие края окна изменяются этой функцией, зависит от значений опции &lt;code&gt;window-combination-resize&lt;/code&gt; и пределов комбинации задействованных окон; в некоторых случаях это может изменить оба края. См. Раздел &amp;laquo; &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Перекомпоновка Windows&amp;raquo;&lt;/a&gt; . Чтобы изменить размер, перемещая только нижний или правый край окна, используйте функцию &lt;code&gt;adjust-window-trailing-edge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa502a49dcc709424f597b62f00f62cbd92bf872" translate="yes" xml:space="preserve">
          <source>The classification of the terminal&amp;rsquo;s background color, either &lt;code&gt;light&lt;/code&gt; or &lt;code&gt;dark&lt;/code&gt;.</source>
          <target state="translated">Классификация цвета фона терминала: &lt;code&gt;light&lt;/code&gt; или &lt;code&gt;dark&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f93c6d22f7b132786ba6625daad510b5c573fb14" translate="yes" xml:space="preserve">
          <source>The client process&amp;rsquo;s plist is initialized from the server&amp;rsquo;s plist.</source>
          <target state="translated">Список клиентского процесса инициализируется из списка сервера.</target>
        </trans-unit>
        <trans-unit id="fbb47d099826f587fe36a3370bfe320b242c3ce1" translate="yes" xml:space="preserve">
          <source>The code character descriptions below contain a number of key words, defined here as follows:</source>
          <target state="translated">Описания кодовых символов,приведенные ниже,содержат ряд ключевых слов,определенных здесь следующим образом:</target>
        </trans-unit>
        <trans-unit id="75ce7901949b09d49a8e972aae9dfafa61a540ec" translate="yes" xml:space="preserve">
          <source>The code for every major mode should follow various coding conventions, including conventions for local keymap and syntax table initialization, function and variable names, and hooks.</source>
          <target state="translated">Код для каждого основного режима должен следовать различным конвенциям по кодированию,включая соглашения по локальной инициализации ключевых карт и таблиц синтаксиса,имена функций и переменных,а также хуков.</target>
        </trans-unit>
        <trans-unit id="dfef9020b23692b251e830295a72905bdd207aaf" translate="yes" xml:space="preserve">
          <source>The code letter &amp;lsquo;</source>
          <target state="translated">Кодовая буква '</target>
        </trans-unit>
        <trans-unit id="2482022c4c984ca682c681b8a8dff28fc069228d" translate="yes" xml:space="preserve">
          <source>The coding system &lt;code&gt;raw-text&lt;/code&gt; is special in that it prevents character code conversion, and causes the buffer visited with this coding system to be a unibyte buffer. For historical reasons, you can save both unibyte and multibyte text with this coding system. When you use &lt;code&gt;raw-text&lt;/code&gt; to encode multibyte text, it does perform one character code conversion: it converts eight-bit characters to their single-byte external representation. &lt;code&gt;raw-text&lt;/code&gt; does not specify the end-of-line conversion, allowing that to be determined as usual by the data, and has the usual three variants which specify the end-of-line conversion.</source>
          <target state="translated">&lt;code&gt;raw-text&lt;/code&gt; системы кодирования является особенным в том смысле, что он предотвращает преобразование кода символов и заставляет буфер, посещаемый этой системой кодирования, быть однобайтовым буфером. По историческим причинам с помощью этой системы кодирования можно сохранять как однобайтовый, так и многобайтовый текст. Когда вы используете &lt;code&gt;raw-text&lt;/code&gt; для кодирования многобайтового текста, он выполняет преобразование кода одного символа: он преобразует восьмибитные символы в их однобайтовое внешнее представление. &lt;code&gt;raw-text&lt;/code&gt; не определяет преобразование конца строки, что позволяет определять его как обычно по данным, и имеет три обычных варианта, которые определяют преобразование конца строки.</target>
        </trans-unit>
        <trans-unit id="a9d6afb051f08a549ab7418ae16669da3deb347c" translate="yes" xml:space="preserve">
          <source>The coding system &lt;code&gt;utf-8-emacs&lt;/code&gt; specifies that the data is represented in the internal Emacs encoding (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;). This is like &lt;code&gt;raw-text&lt;/code&gt; in that no code conversion happens, but different in that the result is multibyte data. The name &lt;code&gt;emacs-internal&lt;/code&gt; is an alias for &lt;code&gt;utf-8-emacs-unix&lt;/code&gt; (so it forces no conversion of end-of-line, unlike &lt;code&gt;utf-8-emacs&lt;/code&gt;, which can decode all 3 kinds of end-of-line conventions).</source>
          <target state="translated">Система кодирования &lt;code&gt;utf-8-emacs&lt;/code&gt; указывает, что данные представлены во внутренней кодировке Emacs (см. &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Текстовые представления&lt;/a&gt; ). Это похоже на &lt;code&gt;raw-text&lt;/code&gt; в том, что преобразование кода не происходит, но отличается тем, что результатом являются многобайтовые данные. Имя &lt;code&gt;emacs-internal&lt;/code&gt; - это псевдоним для &lt;code&gt;utf-8-emacs-unix&lt;/code&gt; (поэтому он не вызывает преобразования конца строки, в отличие от &lt;code&gt;utf-8-emacs&lt;/code&gt; , который может декодировать все 3 вида соглашений о конце строки) .</target>
        </trans-unit>
        <trans-unit id="b7a3e069788fc7a93ce66f5716c9ee69180ec9a7" translate="yes" xml:space="preserve">
          <source>The color for the border of the frame. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;border&lt;/code&gt; face.</source>
          <target state="translated">Цвет границы кадра. Это эквивалентно &lt;code&gt;:background&lt;/code&gt; атрибут &lt;code&gt;border&lt;/code&gt; лица.</target>
        </trans-unit>
        <trans-unit id="557d8af098a8640c6edfc6b2f65704a4cfb3bb1c" translate="yes" xml:space="preserve">
          <source>The color for the cursor that shows point. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;cursor&lt;/code&gt; face.</source>
          <target state="translated">Цвет курсора, который показывает точку. Он эквивалентен атрибуту &lt;code&gt;:background&lt;/code&gt; лица &lt;code&gt;cursor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="848f3a5cc67c97c12f59ed548791f5c7b9603605" translate="yes" xml:space="preserve">
          <source>The color for the mouse pointer. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;mouse&lt;/code&gt; face.</source>
          <target state="translated">Цвет указателя мыши. Он эквивалентен атрибуту &lt;code&gt;:background&lt;/code&gt; лица &lt;code&gt;mouse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd4a78191273afbed89fbc376fb0e490d94f3411" translate="yes" xml:space="preserve">
          <source>The color of lines drawn, and outlines around solid shapes.</source>
          <target state="translated">Цвет нарисованных линий и очертаний вокруг сплошных форм.</target>
        </trans-unit>
        <trans-unit id="6dae735cc9d80db3034a398a30474af4088c1839" translate="yes" xml:space="preserve">
          <source>The color to use for the background of characters. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">Цвет фона персонажей. Он эквивалентен атрибуту &lt;code&gt;:background&lt;/code&gt; лица по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01cf8df4bfb8df2b7d863a7131e6cc6356c0739b" translate="yes" xml:space="preserve">
          <source>The color to use for the image of a character. It is equivalent to the &lt;code&gt;:foreground&lt;/code&gt; attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">Цвет, используемый для изображения персонажа. Он эквивалентен атрибуту &lt;code&gt;:foreground&lt;/code&gt; лица по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3093a0d9fd7e9a7555a91efc7023426af982bf7e" translate="yes" xml:space="preserve">
          <source>The color used for solid shapes.</source>
          <target state="translated">Цвет,используемый для сплошных форм.</target>
        </trans-unit>
        <trans-unit id="f926aaaf6e9ed7105210907467a7575bcbfb622b" translate="yes" xml:space="preserve">
          <source>The color values are returned for &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display. If &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the information is returned for the selected frame&amp;rsquo;s display. If the frame cannot display colors, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Значения цвета возвращаются для отображения &lt;var&gt;frame&lt;/var&gt; . Если &lt;var&gt;frame&lt;/var&gt; опущен или равен &lt;code&gt;nil&lt;/code&gt; , информация возвращается для отображения выбранного кадра. Если рамка не может отображать цвета, значение равно &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0108b0958456a06b2b6bdb6b65f07e2c22074864" translate="yes" xml:space="preserve">
          <source>The column at which to fill warnings.</source>
          <target state="translated">Столбец,в котором нужно заполнить предупреждения.</target>
        </trans-unit>
        <trans-unit id="c886ad6405a0592fa55644a3f4e64f01c567410f" translate="yes" xml:space="preserve">
          <source>The column functions convert between a character position (counting characters from the beginning of the buffer) and a column position (counting screen characters from the beginning of a line).</source>
          <target state="translated">Функции столбца конвертируют между позицией символа (счетные символы от начала буфера)и позицией столбца (счетные символы экрана от начала строки).</target>
        </trans-unit>
        <trans-unit id="56f303b08f0089973ebdd5308c9f98921ddba9d4" translate="yes" xml:space="preserve">
          <source>The column number currently displayed in this window&amp;rsquo;s mode line, or -1 if column numbers are not being displayed.</source>
          <target state="translated">Номер столбца, отображаемый в данный момент в строке режима этого окна, или -1, если номера столбцов не отображаются.</target>
        </trans-unit>
        <trans-unit id="82c351222697abcc62b85c531b3382118709b682" translate="yes" xml:space="preserve">
          <source>The column to be used for top-level constructs. This replaces the default value of the top-level column used by the sub-mode, usually zero.</source>
          <target state="translated">Колонка,которая будет использоваться для конструкций верхнего уровня.Это заменяет значение по умолчанию столбца верхнего уровня,используемого в подрежиме,обычно равное нулю.</target>
        </trans-unit>
        <trans-unit id="ad930e366f047e47ba168bb838f08a3c092549df" translate="yes" xml:space="preserve">
          <source>The combination limit is meaningful only for an internal window. If it is &lt;code&gt;nil&lt;/code&gt;, then Emacs is allowed to automatically delete &lt;var&gt;window&lt;/var&gt;, in response to a window deletion, in order to group the child windows of &lt;var&gt;window&lt;/var&gt; with its sibling windows to form a new window combination. If the combination limit is &lt;code&gt;t&lt;/code&gt;, the child windows of &lt;var&gt;window&lt;/var&gt; are never automatically recombined with its siblings.</source>
          <target state="translated">Предел комбинации имеет значение только для внутреннего окна. Если он равен &lt;code&gt;nil&lt;/code&gt; , то Emacs может автоматически удалить &lt;var&gt;window&lt;/var&gt; в ответ на удаление окна, чтобы сгруппировать дочерние окна &lt;var&gt;window&lt;/var&gt; с его родственными окнами, чтобы сформировать новую комбинацию окон. Если предел комбинации равен &lt;code&gt;t&lt;/code&gt; , дочерние окна &lt;var&gt;window&lt;/var&gt; никогда автоматически не объединяются со своими братьями и сестрами.</target>
        </trans-unit>
        <trans-unit id="062e4ea98a9662fe6dca5fb34a40a037aa606eb5" translate="yes" xml:space="preserve">
          <source>The command</source>
          <target state="translated">Команда</target>
        </trans-unit>
        <trans-unit id="c1ffc1e3bfdf70f5721200a30a9b90345bdd4e1b" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;display-buffer&lt;/code&gt; flexibly chooses a window for display, and displays a specified buffer in that window. It can be called interactively, via the key binding</source>
          <target state="translated">Команда &lt;code&gt;display-buffer&lt;/code&gt; гибко выбирает окно для отображения и отображает указанный буфер в этом окне. Его можно вызывать интерактивно, через привязку клавиш</target>
        </trans-unit>
        <trans-unit id="9d859d82af47e88b2e948fdd51d7bfa313a3eb5d" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;eval-region&lt;/code&gt; updates &lt;code&gt;load-history&lt;/code&gt;, but does so by adding the symbols defined to the element for the file being visited, rather than replacing that element. See &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;.</source>
          <target state="translated">Команда &lt;code&gt;eval-region&lt;/code&gt; обновляет &lt;code&gt;load-history&lt;/code&gt; , но делает это путем добавления символов, определенных для элемента для посещаемого файла, а не замены этого элемента. См. &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a4fcc51ef457cdf0b2de9d77b741a0669273953" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;switch-to-next-buffer&lt;/code&gt; obeys this option in a similar way. If this option specifies a function, &lt;code&gt;switch-to-next-buffer&lt;/code&gt; will call that function with the third argument always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Аналогично этому параметру подчиняется команда &lt;code&gt;switch-to-next-buffer&lt;/code&gt; . Если эта опция определяет функцию, &lt;code&gt;switch-to-next-buffer&lt;/code&gt; вызовет эту функцию с третьим аргументом всегда &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1bcbea4d3e3a2d7b364ec9e0f15ad7ae8da1bbb" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;temacs&amp;nbsp;-l&amp;nbsp;loadup&lt;/code&gt; would run</source>
          <target state="translated">Команда &lt;code&gt;temacs&amp;nbsp;-l&amp;nbsp;loadup&lt;/code&gt; запустится</target>
        </trans-unit>
        <trans-unit id="ae164833eafad23104809bf29a295b984c817efa" translate="yes" xml:space="preserve">
          <source>The command &lt;var&gt;fname&lt;/var&gt; is defined to handle a few events itself, by scrolling the display of &lt;var&gt;help-text&lt;/var&gt;. When &lt;var&gt;fname&lt;/var&gt; reads one of those special events, it does the scrolling and then reads another event. When it reads an event that is not one of those few, and which has a binding in &lt;var&gt;help-map&lt;/var&gt;, it executes that key&amp;rsquo;s binding and then returns.</source>
          <target state="translated">Команда &lt;var&gt;fname&lt;/var&gt; определена для самой обработки нескольких событий путем прокрутки отображения &lt;var&gt;help-text&lt;/var&gt; . Когда &lt;var&gt;fname&lt;/var&gt; читает одно из этих особых событий, оно выполняет прокрутку, а затем читает другое событие. Когда он читает событие, которое не является одним из этих немногих и которое имеет привязку в &lt;var&gt;help-map&lt;/var&gt; , он выполняет привязку этого ключа и затем возвращается.</target>
        </trans-unit>
        <trans-unit id="bc4bc33db4d6985e9ffe7472f3118727adcea411" translate="yes" xml:space="preserve">
          <source>The command bindings of input events are recorded in data structures called &lt;em&gt;keymaps&lt;/em&gt;. Each entry in a keymap associates (or &lt;em&gt;binds&lt;/em&gt;) an individual event type, either to another keymap or to a command. When an event type is bound to a keymap, that keymap is used to look up the next input event; this continues until a command is found. The whole process is called &lt;em&gt;key lookup&lt;/em&gt;.</source>
          <target state="translated">Привязки команд входных событий записываются в структуры данных, называемые &lt;em&gt;раскладками&lt;/em&gt; . Каждая запись в раскладке клавиатуры связывает (или &lt;em&gt;связывает&lt;/em&gt; ) отдельный тип события либо с другой раскладкой, либо с командой. Когда тип события привязан к раскладке клавиатуры, эта раскладка используется для поиска следующего события ввода; это продолжается до тех пор, пока не будет найдена команда. Весь процесс называется &lt;em&gt;поиском ключа&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e3a0644779d0a1f335811ac6b8e7f487869da769" translate="yes" xml:space="preserve">
          <source>The command does not set &lt;code&gt;this-command&lt;/code&gt; to &lt;code&gt;kill-region&lt;/code&gt;, so a subsequent kill command does not append to the same kill ring entry.</source>
          <target state="translated">Команда не устанавливает &lt;code&gt;this-command&lt;/code&gt; в &lt;code&gt;kill-region&lt;/code&gt; , поэтому последующая команда kill не добавляется к той же записи кольца уничтожения.</target>
        </trans-unit>
        <trans-unit id="54ccd859ab08a7578c2accb2c8a5c8536ee5433a" translate="yes" xml:space="preserve">
          <source>The command loop keeps a history of the complex commands that have been executed, to make it convenient to repeat these commands. A &lt;em&gt;complex command&lt;/em&gt; is one for which the interactive argument reading uses the minibuffer. This includes any</source>
          <target state="translated">Командный цикл хранит историю сложных команд, которые были выполнены, чтобы было удобно повторять эти команды. &lt;em&gt;Комплекс команда&lt;/em&gt; является один , для которых интерактивного чтение аргумента использует минибуфер. Сюда входят любые</target>
        </trans-unit>
        <trans-unit id="7d8344b6378db1df6e46b16defc05a1c3460ae23" translate="yes" xml:space="preserve">
          <source>The command loop reads input a key sequence at a time, by calling &lt;code&gt;read-key-sequence&lt;/code&gt;. Lisp programs can also call this function; for example, &lt;code&gt;describe-key&lt;/code&gt; uses it to read the key to describe.</source>
          <target state="translated">Цикл команд читает вводную последовательность клавиш за раз, вызывая &lt;code&gt;read-key-sequence&lt;/code&gt; . Программы на Лиспе также могут вызывать эту функцию; например, &lt;code&gt;describe-key&lt;/code&gt; использует его для чтения ключа для описания.</target>
        </trans-unit>
        <trans-unit id="2ee88eb3cbfec06fb2f79be62a80a793ed81d1f4" translate="yes" xml:space="preserve">
          <source>The command loop runs this soon after &lt;code&gt;post-command-hook&lt;/code&gt; (q.v.).</source>
          <target state="translated">Командный цикл запускается вскоре после &lt;code&gt;post-command-hook&lt;/code&gt; (qv).</target>
        </trans-unit>
        <trans-unit id="b3556e9617ebdac53a98e97a52551b0c1b562ba7" translate="yes" xml:space="preserve">
          <source>The command loop sets this variable just before running a command, and copies its value into &lt;code&gt;last-command&lt;/code&gt; when the command finishes (unless the command specified a prefix argument for the following command).</source>
          <target state="translated">Цикл команд устанавливает эту переменную непосредственно перед запуском команды и копирует ее значение в &lt;code&gt;last-command&lt;/code&gt; , когда команда завершается (если команда не указала аргумент префикса для следующей команды).</target>
        </trans-unit>
        <trans-unit id="2055d37028ddd0c472cbfc94f6b67d5fdd69b086" translate="yes" xml:space="preserve">
          <source>The command loop sets this variable to &lt;code&gt;nil&lt;/code&gt; before each command, so if a command sets it, the effect applies only to that command.</source>
          <target state="translated">Цикл команд устанавливает для этой переменной значение &lt;code&gt;nil&lt;/code&gt; перед каждой командой, поэтому, если команда устанавливает ее, эффект применяется только к этой команде.</target>
        </trans-unit>
        <trans-unit id="543a4b162ec103c275db3895fe55421dc42ccd27" translate="yes" xml:space="preserve">
          <source>The command named &lt;var&gt;mode&lt;/var&gt; first performs the standard actions such as setting the variable named &lt;var&gt;mode&lt;/var&gt; and then executes the &lt;var&gt;body&lt;/var&gt; forms, if any. It then runs the mode hook variable &lt;code&gt;&lt;var&gt;mode&lt;/var&gt;-hook&lt;/code&gt; and finishes by evaluating any form in &lt;code&gt;:after-hook&lt;/code&gt;.</source>
          <target state="translated">Команда имени &lt;var&gt;mode&lt;/var&gt; сначала выполняет стандартные действия , такие как устанавливая переменную с именем &lt;var&gt;mode&lt;/var&gt; , а затем выполняет &lt;var&gt;body&lt;/var&gt; формы, если таковые имеются. Затем он запускает переменную &lt;code&gt;&lt;var&gt;mode&lt;/var&gt;-hook&lt;/code&gt; &lt;var&gt;mode&lt;/var&gt; -hook и заканчивает вычислением любой формы в &lt;code&gt;:after-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c1e16025c68e4172d32866b90a4de49e795379d" translate="yes" xml:space="preserve">
          <source>The command which is finally found might also be remapped. See &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;.</source>
          <target state="translated">Наконец, найденную команду можно переназначить. См. &amp;laquo; &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Команды переназначения&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46d5686bfeb21ae9e75f3e0cd9110b273ca126ba" translate="yes" xml:space="preserve">
          <source>The command-line arguments are parsed by the &lt;code&gt;command-line-1&lt;/code&gt; function in the</source>
          <target state="translated">Аргументы командной строки анализируются функцией &lt;code&gt;command-line-1&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="3e89f0f5629d43551a732205c85f87087a894dfc" translate="yes" xml:space="preserve">
          <source>The command-line option &amp;lsquo;</source>
          <target state="translated">Параметр командной строки '</target>
        </trans-unit>
        <trans-unit id="33be2dffe066118290e67b49b508bdbeb6703d32" translate="yes" xml:space="preserve">
          <source>The command-line switches &amp;lsquo;</source>
          <target state="translated">Ключи командной строки '</target>
        </trans-unit>
        <trans-unit id="d45c8a3739b868f95df9b38858cd8d04f287a037" translate="yes" xml:space="preserve">
          <source>The command-line with which the process was invoked. This is a string in which individual command-line arguments are separated by blanks; whitespace characters that are embedded in the arguments are quoted as appropriate for the system&amp;rsquo;s shell: escaped by backslash characters on GNU and Unix, and enclosed in double quote characters on Windows. Thus, this command-line string can be directly used in primitives such as &lt;code&gt;shell-command&lt;/code&gt;.</source>
          <target state="translated">Командная строка, с которой был вызван процесс. Это строка, в которой отдельные аргументы командной строки разделены пробелами; символы пробела, встроенные в аргументы, заключаются в кавычки, соответствующие системной оболочке: экранируются символами обратной косой черты в GNU и Unix и заключаются в двойные кавычки в Windows. Таким образом, эту строку командной строки можно напрямую использовать в примитивах, таких как &lt;code&gt;shell-command&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37c706527add4d02a59532cb46df5b7b130d04de" translate="yes" xml:space="preserve">
          <source>The commands available during recursive editing are the same ones available in the top-level editing loop and defined in the keymaps. Only a few special commands exit the recursive editing level; the others return to the recursive editing level when they finish. (The special commands for exiting are always available, but they do nothing when recursive editing is not in progress.)</source>
          <target state="translated">Команды,доступные при рекурсивном редактировании,те же,что доступны в цикле редактирования верхнего уровня и определены в ключевых картах.Только несколько специальных команд выходят из уровня рекурсивного редактирования;остальные возвращаются на уровень рекурсивного редактирования по окончании.(Специальные команды выхода всегда доступны,но они ничего не делают,когда не выполняется рекурсивное редактирование).</target>
        </trans-unit>
        <trans-unit id="a23d2cd639852ecd94cb9df3ddff9d5bd174b632" translate="yes" xml:space="preserve">
          <source>The commands described below can filter the killed text before they save it in the kill ring. They call &lt;code&gt;filter-buffer-substring&lt;/code&gt; (see &lt;a href=&quot;buffer-contents#Buffer-Contents&quot;&gt;Buffer Contents&lt;/a&gt;) to perform the filtering. By default, there&amp;rsquo;s no filtering, but major and minor modes and hook functions can set up filtering, so that text saved in the kill ring is different from what was in the buffer.</source>
          <target state="translated">Команды, описанные ниже, могут фильтровать убитый текст, прежде чем они сохранят его в списке уничтожений. Они вызывают &lt;code&gt;filter-buffer-substring&lt;/code&gt; (см. &lt;a href=&quot;buffer-contents#Buffer-Contents&quot;&gt;Buffer Contents&lt;/a&gt; ) для выполнения фильтрации. По умолчанию фильтрация отсутствует, но основные и второстепенные режимы и функции перехвата могут настраивать фильтрацию, так что текст, сохраненный в списке уничтожений, отличается от того, что было в буфере.</target>
        </trans-unit>
        <trans-unit id="c7a1c8fbb62ae35db0fb700fa5a7a715258f8d84" translate="yes" xml:space="preserve">
          <source>The commands described in this section execute until they reach a specified location. All except</source>
          <target state="translated">Команды,описанные в этом разделе,выполняются до тех пор,пока они не достигнут указанного места.Все,кроме</target>
        </trans-unit>
        <trans-unit id="f7cca3dbc4a5e525b42888654a2250e48c3c88c9" translate="yes" xml:space="preserve">
          <source>The comment lines show that &lt;code&gt;fac&lt;/code&gt; was called 6 times. The first &lt;code&gt;if&lt;/code&gt; statement returned 5 times with the same result each time; the same is true of the condition on the second &lt;code&gt;if&lt;/code&gt;. The recursive call of &lt;code&gt;fac&lt;/code&gt; did not return at all.</source>
          <target state="translated">Строки комментариев показывают, что &lt;code&gt;fac&lt;/code&gt; был вызван 6 раз. Первый оператор &lt;code&gt;if&lt;/code&gt; возвращал 5 раз с одинаковым результатом каждый раз; то же самое верно для условия на втором &lt;code&gt;if&lt;/code&gt; . Рекурсивный вызов &lt;code&gt;fac&lt;/code&gt; вообще не вернулся.</target>
        </trans-unit>
        <trans-unit id="0e2b64e2042c9eae11df7bbc9d8da126ed6518b7" translate="yes" xml:space="preserve">
          <source>The communication type and the process filter and sentinel are inherited from those of the server. The server never directly uses its filter and sentinel; their sole purpose is to initialize connections made to the server.</source>
          <target state="translated">Тип связи,а также фильтр процесса и отправитель наследуются от сервера.Сервер никогда непосредственно не использует свой фильтр и дозорный;их единственной целью является инициализация соединений,сделанных с сервером.</target>
        </trans-unit>
        <trans-unit id="afd81d64f2d80486e0d6f037979b681c7c67b5c5" translate="yes" xml:space="preserve">
          <source>The comparison function &lt;var&gt;predicate&lt;/var&gt; must give reliable results for any given pair of arguments, at least within a single call to &lt;code&gt;sort&lt;/code&gt;. It must be &lt;em&gt;antisymmetric&lt;/em&gt;; that is, if &lt;var&gt;a&lt;/var&gt; is less than &lt;var&gt;b&lt;/var&gt;, &lt;var&gt;b&lt;/var&gt; must not be less than &lt;var&gt;a&lt;/var&gt;. It must be &lt;em&gt;transitive&lt;/em&gt;&amp;mdash;that is, if &lt;var&gt;a&lt;/var&gt; is less than &lt;var&gt;b&lt;/var&gt;, and &lt;var&gt;b&lt;/var&gt; is less than &lt;var&gt;c&lt;/var&gt;, then &lt;var&gt;a&lt;/var&gt; must be less than &lt;var&gt;c&lt;/var&gt;. If you use a comparison function which does not meet these requirements, the result of &lt;code&gt;sort&lt;/code&gt; is unpredictable.</source>
          <target state="translated">&lt;var&gt;predicate&lt;/var&gt; функции сравнения должен давать надежные результаты для любой данной пары аргументов, по крайней мере, в пределах одного вызова &lt;code&gt;sort&lt;/code&gt; . Он должен быть &lt;em&gt;антисимметричным&lt;/em&gt; ; то есть, если &lt;var&gt;a&lt;/var&gt; меньше &lt;var&gt;b&lt;/var&gt; , &lt;var&gt;b&lt;/var&gt; не должно быть меньше &lt;var&gt;a&lt;/var&gt; . Он должен быть &lt;em&gt;транзитивным&lt;/em&gt; - то есть, если &lt;var&gt;a&lt;/var&gt; меньше &lt;var&gt;b&lt;/var&gt; , а &lt;var&gt;b&lt;/var&gt; меньше &lt;var&gt;c&lt;/var&gt; , тогда &lt;var&gt;a&lt;/var&gt; должно быть меньше &lt;var&gt;c&lt;/var&gt; . Если вы используете функцию сравнения, которая не отвечает этим требованиям, результат &lt;code&gt;sort&lt;/code&gt; будет непредсказуемым.</target>
        </trans-unit>
        <trans-unit id="b8af95aafe57d945cb1c3d7b18f42da5e30f98c5" translate="yes" xml:space="preserve">
          <source>The compiler ignores the &lt;code&gt;provide&lt;/code&gt;, then processes the &lt;code&gt;require&lt;/code&gt; by loading the file in question. Loading the file does execute the &lt;code&gt;provide&lt;/code&gt; call, so the subsequent &lt;code&gt;require&lt;/code&gt; call does nothing when the file is loaded.</source>
          <target state="translated">Компилятор игнорирует &lt;code&gt;provide&lt;/code&gt; , а затем обрабатывает &lt;code&gt;require&lt;/code&gt; , загружая соответствующий файл. При загрузке файла выполняется вызов &lt;code&gt;provide&lt;/code&gt; , поэтому последующий вызов &lt;code&gt;require&lt;/code&gt; ничего не делает при загрузке файла.</target>
        </trans-unit>
        <trans-unit id="83b388904b97e9f960dfa5b394422e2b5894fab3" translate="yes" xml:space="preserve">
          <source>The completion function should accept three arguments:</source>
          <target state="translated">Функция завершения должна принимать три аргумента:</target>
        </trans-unit>
        <trans-unit id="0b6b092d0c4ac01b5f509dc38513b84d822a2a94" translate="yes" xml:space="preserve">
          <source>The complexities stem from the modifier bits that keyboard input characters can include. Aside from the Meta modifier, none of these modifier bits can be included in a string, and the Meta modifier is allowed only in special cases.</source>
          <target state="translated">Сложности связаны с битами модификаторов,которые могут включать символы ввода с клавиатуры.Кроме Мета-модификатора,ни один из этих битов-модификаторов не может быть включен в строку,а Мета-модификатор разрешен только в особых случаях.</target>
        </trans-unit>
        <trans-unit id="84f18eeeb5829282eb800b86f2877e8b64e03deb" translate="yes" xml:space="preserve">
          <source>The components of a marker, and how it relocates.</source>
          <target state="translated">Компоненты маркера,и как он перемещается.</target>
        </trans-unit>
        <trans-unit id="27404eab7e82a326e1454e0c0e389aaa34dca41e" translate="yes" xml:space="preserve">
          <source>The concept of raising and lowering frames also applies to text terminal frames. On each text terminal, only the top frame is displayed at any one time.</source>
          <target state="translated">Понятие &quot;подъем и опускание кадров&quot; распространяется также на кадры текстовых терминалов.На каждом текстовом терминале в любой момент времени отображается только верхний кадр.</target>
        </trans-unit>
        <trans-unit id="cce4579f65c0c37d6850842d7ce1d0a6353f8c71" translate="yes" xml:space="preserve">
          <source>The concept of visibility is strongly related to that of (un-)mapped frames. A frame (or, more precisely, its window-system window) is and becomes &lt;em&gt;mapped&lt;/em&gt; when it is displayed for the first time and whenever it changes its state of visibility from &lt;code&gt;iconified&lt;/code&gt; or &lt;code&gt;invisible&lt;/code&gt; to &lt;code&gt;visible&lt;/code&gt;. Conversely, a frame is and becomes &lt;em&gt;unmapped&lt;/em&gt; whenever it changes its status from &lt;code&gt;visible&lt;/code&gt; to &lt;code&gt;iconified&lt;/code&gt; or &lt;code&gt;invisible&lt;/code&gt;.</source>
          <target state="translated">Концепция видимости тесно связана с концепцией (не) отображенных кадров. Фрейм (или, точнее, его окно оконной системы) &lt;em&gt;отображается&lt;/em&gt; и становится &lt;em&gt;отображаемым,&lt;/em&gt; когда он отображается в первый раз и всякий раз, когда он меняет свое состояние видимости с &lt;code&gt;iconified&lt;/code&gt; или &lt;code&gt;invisible&lt;/code&gt; на &lt;code&gt;visible&lt;/code&gt; . И наоборот, фрейм &lt;em&gt;не &lt;/em&gt; &lt;code&gt;visible&lt;/code&gt; и не &lt;code&gt;iconified&lt;/code&gt; всякий раз, когда он меняет свой статус с видимого на значок или &lt;code&gt;invisible&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5676e3bf9106b8a801a2ba7aa8fe6827e6fdc6cf" translate="yes" xml:space="preserve">
          <source>The concise expression of a predicate is known as a &lt;em&gt;pattern&lt;/em&gt;. When the predicate, called on the value of the first arg, returns non-&lt;code&gt;nil&lt;/code&gt;, we say that &amp;ldquo;the pattern matches the value&amp;rdquo; (or sometimes &amp;ldquo;the value matches the pattern&amp;rdquo;).</source>
          <target state="translated">Краткое выражение предиката называется &lt;em&gt;шаблоном&lt;/em&gt; . Когда предикат, вызываемый для значения первого аргумента, возвращает &lt;code&gt;nil&lt;/code&gt; , мы говорим, что &amp;laquo;шаблон соответствует значению&amp;raquo; (или иногда &amp;laquo;значение соответствует шаблону&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="ab15735458ac1022eae759f78cdd057138f6e20d" translate="yes" xml:space="preserve">
          <source>The condition expression is stored in &lt;code&gt;edebug-global-break-condition&lt;/code&gt;. You can specify a new expression using the</source>
          <target state="translated">Выражение условия хранится в &lt;code&gt;edebug-global-break-condition&lt;/code&gt; . Вы можете указать новое выражение, используя</target>
        </trans-unit>
        <trans-unit id="c16f550e5c642194989cb1eb487f94d46efc1764" translate="yes" xml:space="preserve">
          <source>The connection type: &amp;lsquo;</source>
          <target state="translated">Тип подключения: '</target>
        </trans-unit>
        <trans-unit id="467d0ce5daa923b058a0c23d80df3209d2288708" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s local address is set up according to the port number used for the connection.</source>
          <target state="translated">Локальный адрес соединения устанавливается в соответствии с номером порта, используемым для соединения.</target>
        </trans-unit>
        <trans-unit id="507cc7aafdf97b09a145788437398e04599af151" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s process contact information is set according to the client&amp;rsquo;s addressing information (typically an IP address and a port number). This information is associated with the &lt;code&gt;process-contact&lt;/code&gt; keywords &lt;code&gt;:host&lt;/code&gt;, &lt;code&gt;:service&lt;/code&gt;, &lt;code&gt;:remote&lt;/code&gt;.</source>
          <target state="translated">Контактная информация процесса подключения устанавливается в соответствии с адресной информацией клиента (обычно это IP-адрес и номер порта). Эта информация связана с &lt;code&gt;process-contact&lt;/code&gt; ключевыми словами &lt;code&gt;:host&lt;/code&gt; , &lt;code&gt;:service&lt;/code&gt; , &lt;code&gt;:remote&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f972d8622119c5748437af2ecceeff29ecea407" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s process name is constructed by concatenating the server process&amp;rsquo;s &lt;var&gt;name&lt;/var&gt; with a client identification string. The client identification string for an IPv4 connection looks like &amp;lsquo;</source>
          <target state="translated">Имя процесса для данного соединения строится путем конкатенации процесса серверного &lt;var&gt;name&lt;/var&gt; с идентификационным клиентом строкой. Строка идентификации клиента для IPv4-соединения выглядит так:</target>
        </trans-unit>
        <trans-unit id="1e87cd925416db3162f784b538be172c5b7921a1" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;.</source>
          <target state="translated">Постоянное действие &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c760326f932b523d397cb33aa52ed43c6fb58a0c" translate="yes" xml:space="preserve">
          <source>The construct &amp;lsquo;</source>
          <target state="translated">Конструкция '</target>
        </trans-unit>
        <trans-unit id="d66f5e853b6924e849795ab495fa453e6e93fd12" translate="yes" xml:space="preserve">
          <source>The contents of a buffer are much like a string, but buffers are not used like strings in Emacs Lisp, and the available operations are different. For example, you can insert text efficiently into an existing buffer, altering the buffer&amp;rsquo;s contents, whereas inserting text into a string requires concatenating substrings, and the result is an entirely new string object.</source>
          <target state="translated">Содержимое буфера очень похоже на строку, но буферы не используются как строки в Emacs Lisp, и доступные операции различны. Например, вы можете эффективно вставить текст в существующий буфер, изменяя содержимое буфера, тогда как вставка текста в строку требует конкатенации подстрок, и в результате получается совершенно новый строковый объект.</target>
        </trans-unit>
        <trans-unit id="724d66b7323be904f10391c54dc669a39d58cee1" translate="yes" xml:space="preserve">
          <source>The contents of a documentation string should follow certain conventions. In particular, its first line should be a complete sentence (or two complete sentences) that briefly describes what the function or variable does. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Documentation Tips&lt;/a&gt;, for how to write good documentation strings.</source>
          <target state="translated">Содержимое строки документации должно соответствовать определенным соглашениям. В частности, его первая строка должна быть полным предложением (или двумя полными предложениями), в котором кратко описывается, что делает функция или переменная. См. &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Советы по документации&lt;/a&gt; , чтобы узнать, как писать хорошие строки документации.</target>
        </trans-unit>
        <trans-unit id="11a8b449d638b416a746d961844b34d3d803a937" translate="yes" xml:space="preserve">
          <source>The contents of each mode line are specified by the buffer-local variable &lt;code&gt;mode-line-format&lt;/code&gt; (see &lt;a href=&quot;mode-line-top#Mode-Line-Top&quot;&gt;Mode Line Top&lt;/a&gt;). This variable holds a &lt;em&gt;mode line construct&lt;/em&gt;: a template that controls what is displayed on the buffer&amp;rsquo;s mode line. The value of &lt;code&gt;header-line-format&lt;/code&gt; specifies the buffer&amp;rsquo;s header line in the same way. All windows for the same buffer use the same &lt;code&gt;mode-line-format&lt;/code&gt; and &lt;code&gt;header-line-format&lt;/code&gt; unless a &lt;code&gt;mode-line-format&lt;/code&gt; or &lt;code&gt;header-line-format&lt;/code&gt; parameter has been specified for that window (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;).</source>
          <target state="translated">Содержимое каждой строки режима определяется локальной переменной в буфере &lt;code&gt;mode-line-format&lt;/code&gt; (см. &lt;a href=&quot;mode-line-top#Mode-Line-Top&quot;&gt;Верхнюю часть строки режима&lt;/a&gt; ). Эта переменная содержит конструкцию &lt;em&gt;строки режима&lt;/em&gt; : шаблон, который управляет тем, что отображается в строке режима буфера. Значение &lt;code&gt;header-line-format&lt;/code&gt; точно так же определяет строку заголовка буфера. Все окна для одного и того же буфера используют один и тот же &lt;code&gt;mode-line-format&lt;/code&gt; и формат строки &lt;code&gt;header-line-format&lt;/code&gt; если для этого окна не был указан параметр &lt;code&gt;header-line-format&lt;/code&gt; &lt;code&gt;mode-line-format&lt;/code&gt; или формата строки заголовка (см. &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Параметры окна&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6cce8467dc72be542e217587e79031715ed7a080" translate="yes" xml:space="preserve">
          <source>The contents of the function cell are also called the symbol&amp;rsquo;s &lt;em&gt;function definition&lt;/em&gt;. The procedure of using a symbol&amp;rsquo;s function definition in place of the symbol is called &lt;em&gt;symbol function indirection&lt;/em&gt;; see &lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;Function Indirection&lt;/a&gt;. If you have not given a symbol a function definition, its function cell is said to be &lt;em&gt;void&lt;/em&gt;, and it cannot be used as a function.</source>
          <target state="translated">Содержимое ячейки функции также называется &lt;em&gt;определением функции&lt;/em&gt; символа . Процедура использования определения функции символа вместо символа называется &lt;em&gt;косвенным&lt;/em&gt; обращением к &lt;em&gt;функции символа&lt;/em&gt; ; см. &amp;laquo; &lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;Обращение к функциям&amp;raquo;&lt;/a&gt; . Если вы не указали символу определение функции, его функциональная ячейка считается &lt;em&gt;недействительной&lt;/em&gt; и не может использоваться в качестве функции.</target>
        </trans-unit>
        <trans-unit id="9370f04a5544f51098edcb0f278d5570b1dac651" translate="yes" xml:space="preserve">
          <source>The control modifier.</source>
          <target state="translated">Модификатор управления.</target>
        </trans-unit>
        <trans-unit id="aceb7a603d154f5ad7c647717d25306dce220852" translate="yes" xml:space="preserve">
          <source>The convenient way to track the mouse is to ask for events to represent mouse motion. Then you can wait for motion by waiting for an event. In addition, you can easily handle any other sorts of events that may occur. That is useful, because normally you don&amp;rsquo;t want to track the mouse forever&amp;mdash;only until some other event, such as the release of a button.</source>
          <target state="translated">Удобный способ отслеживания мыши - запрашивать события, представляющие движение мыши. Затем вы можете дождаться движения, дождавшись события. Кроме того, вы можете легко справиться с любыми другими возможными событиями. Это полезно, потому что обычно вы не хотите постоянно отслеживать мышь - только до какого-либо другого события, такого как отпускание кнопки.</target>
        </trans-unit>
        <trans-unit id="793961ad223ddf2c3c519ec760da74fb582fe7a6" translate="yes" xml:space="preserve">
          <source>The coordinate arguments &lt;var&gt;frompos&lt;/var&gt; and &lt;var&gt;topos&lt;/var&gt; are cons cells of the form &lt;code&gt;(&lt;var&gt;hpos&lt;/var&gt; . &lt;var&gt;vpos&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">Координатные аргументы &lt;var&gt;frompos&lt;/var&gt; и &lt;var&gt;topos&lt;/var&gt; являются минусы клетки вида &lt;code&gt;(&lt;var&gt;hpos&lt;/var&gt; . &lt;var&gt;vpos&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9db5eb46de2221425799aa8da6390edce63ae470" translate="yes" xml:space="preserve">
          <source>The coordinates are in the divider separating &lt;var&gt;window&lt;/var&gt; from a window beneath.</source>
          <target state="translated">Координаты указаны в разделителе, отделяющем &lt;var&gt;window&lt;/var&gt; от окна внизу.</target>
        </trans-unit>
        <trans-unit id="6affe00f007f6996f29826150462b2973fdef994" translate="yes" xml:space="preserve">
          <source>The coordinates are in the divider separating &lt;var&gt;window&lt;/var&gt; from a window on the right.</source>
          <target state="translated">Координаты указаны в разделителе, отделяющем &lt;var&gt;window&lt;/var&gt; от окна справа.</target>
        </trans-unit>
        <trans-unit id="32afd0d0bc1d682d09fba69eb4617c10c78505bb" translate="yes" xml:space="preserve">
          <source>The coordinates are in the header line of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">Координаты указаны в строке заголовка &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="bd8e5163c2e5b18cd3fb5701dd235e3c1ebcec62" translate="yes" xml:space="preserve">
          <source>The coordinates are in the left or right fringe of the window.</source>
          <target state="translated">Координаты находятся в левой или правой части окна.</target>
        </trans-unit>
        <trans-unit id="c738efd1b8fc20e939382319a3f95f8982d7b37a" translate="yes" xml:space="preserve">
          <source>The coordinates are in the left or right margin of the window.</source>
          <target state="translated">Координаты находятся в левом или правом поле окна.</target>
        </trans-unit>
        <trans-unit id="0cd27cf4656eb11e9fa2ca9618c8c00a5670e522" translate="yes" xml:space="preserve">
          <source>The coordinates are in the mode line of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">Координаты указаны в строке режима &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="40b852e52258e1ed5fab2ee2299205f8ece29d1f" translate="yes" xml:space="preserve">
          <source>The coordinates are in the tab line of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">Координаты находятся в строке вкладок &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a54627ce98dd91ddd99bb3fd351fc372636186" translate="yes" xml:space="preserve">
          <source>The coordinates are in the vertical line between &lt;var&gt;window&lt;/var&gt; and its neighbor to the right. This value occurs only if the window doesn&amp;rsquo;t have a scroll bar; positions in a scroll bar are considered outside the window for these purposes.</source>
          <target state="translated">Координаты указаны по вертикальной линии между &lt;var&gt;window&lt;/var&gt; и его соседом справа. Это значение появляется только в том случае, если в окне нет полосы прокрутки; для этих целей позиции в полосе прокрутки считаются за пределами окна.</target>
        </trans-unit>
        <trans-unit id="b07ce1b12e208ef1aeb507e1116a4d5c9d8ef12e" translate="yes" xml:space="preserve">
          <source>The coordinates are inside &lt;var&gt;window&lt;/var&gt;. The numbers &lt;var&gt;relx&lt;/var&gt; and &lt;var&gt;rely&lt;/var&gt; are the equivalent window-relative coordinates for the specified position, counting from 0 at the top left corner of the window.</source>
          <target state="translated">Координаты внутри &lt;var&gt;window&lt;/var&gt; . Числа &lt;var&gt;relx&lt;/var&gt; и &lt;var&gt;rely&lt;/var&gt; являются эквивалентными окнами-координаты относительно указанной позиции, считая от 0 в верхнем левом углу окна.</target>
        </trans-unit>
        <trans-unit id="3dab1b30075b2eaf66dc2d863b82b8873a9110f1" translate="yes" xml:space="preserve">
          <source>The coordinates are not in any part of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">Координаты не указаны ни в одной части &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="6fbb6d2c4c5aa83c923375a4275035683805d5d9" translate="yes" xml:space="preserve">
          <source>The correspondences in a hash table are in no particular order.</source>
          <target state="translated">Корреспонденция в хэш-таблице не имеет особого порядка.</target>
        </trans-unit>
        <trans-unit id="aa3cbc5742428a7ca49d61d3c1ddaa3f048dcbae" translate="yes" xml:space="preserve">
          <source>The current buffer is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">Текущий буфер восстанавливается даже в случае аварийного выхода из-за &lt;code&gt;throw&lt;/code&gt; или ошибки (см. &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Нелокальные выходы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="49ecbd424345bde3e4a4691932210becf3443056" translate="yes" xml:space="preserve">
          <source>The current buffer name, obtained with the &lt;code&gt;buffer-name&lt;/code&gt; function. See &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;.</source>
          <target state="translated">Текущее имя буфера, полученное с помощью функции &lt;code&gt;buffer-name&lt;/code&gt; . См. &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Имена буферов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93560fb8fbc083bf5b1817cfce168271a106cae0" translate="yes" xml:space="preserve">
          <source>The current column number of point, counting from one starting at the left margin of the window.</source>
          <target state="translated">Номер текущего столбца,отсчитываемый от одного,начинающегося с левого края окна.</target>
        </trans-unit>
        <trans-unit id="37bb7b86b993d6605fefad8b3d7df6dd2fc08c56" translate="yes" xml:space="preserve">
          <source>The current column number of point, counting from zero starting at the left margin of the window.</source>
          <target state="translated">Текущий номер столбца,отсчитываемый от нуля,начинающегося с левого края окна.</target>
        </trans-unit>
        <trans-unit id="21e20a260365897194b21ccb677ca7dc72919de4" translate="yes" xml:space="preserve">
          <source>The current file name in byte-compiled files (see &lt;a href=&quot;docs-and-compilation#Docs-and-Compilation&quot;&gt;Docs and Compilation&lt;/a&gt;). This is not meant to be used in Emacs Lisp source files.</source>
          <target state="translated">Текущее имя файла в байтовых файлах (см. &lt;a href=&quot;docs-and-compilation#Docs-and-Compilation&quot;&gt;Документация и компиляция&lt;/a&gt; ). Это не предназначено для использования в исходных файлах Emacs Lisp.</target>
        </trans-unit>
        <trans-unit id="b0e9ac8163716bfa85a52705be2822c48e82cbd6" translate="yes" xml:space="preserve">
          <source>The current flags of the interface.</source>
          <target state="translated">Текущие флаги интерфейса.</target>
        </trans-unit>
        <trans-unit id="4bc02bf671d789b23dfc61d21042a23f7be5f41a" translate="yes" xml:space="preserve">
          <source>The current line number of point, counting within the accessible portion of the buffer.</source>
          <target state="translated">Номер текущей строки,отсчитываемый в пределах доступной части буфера.</target>
        </trans-unit>
        <trans-unit id="01cbdcc5115b6bb7222af2f5b8c203bd59b36d12" translate="yes" xml:space="preserve">
          <source>The current match data. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">Текущие данные матча. См. &lt;a href=&quot;match-data#Match-Data&quot;&gt;Данные соответствия&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74f9a1d87530d50c4d0bc7b5d1da7fe2f989980b" translate="yes" xml:space="preserve">
          <source>The current setting of an option is available via the &lt;code&gt;process-contact&lt;/code&gt; function.</source>
          <target state="translated">Текущая настройка опции доступна через функцию &lt;code&gt;process-contact&lt;/code&gt; с процессом .</target>
        </trans-unit>
        <trans-unit id="c8841e254b566bf5e794e8e991eb038996ac6058" translate="yes" xml:space="preserve">
          <source>The current value of this variable is used to rebind &lt;code&gt;help-form&lt;/code&gt; locally inside the minibuffer (see &lt;a href=&quot;help-functions#Help-Functions&quot;&gt;Help Functions&lt;/a&gt;).</source>
          <target state="translated">Текущее значение этой переменной используется для переназначения &lt;code&gt;help-form&lt;/code&gt; локально внутри минибуфера (см. &amp;laquo; &lt;a href=&quot;help-functions#Help-Functions&quot;&gt;Функции справки&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="14a941d0e07e1294606a1ecd42518431ac54129d" translate="yes" xml:space="preserve">
          <source>The current working directory of the subprocess is set to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt; if that is local (as determined by &lt;code&gt;unhandled-file-name-directory&lt;/code&gt;), or</source>
          <target state="translated">Текущий рабочий каталог подпроцесса устанавливается равным текущему значению буфера &lt;code&gt;default-directory&lt;/code&gt; , если он локальный (как определено &lt;code&gt;unhandled-file-name-directory&lt;/code&gt; ), или</target>
        </trans-unit>
        <trans-unit id="15dffde8e426c6fb2351035a35c4354ca1d72300" translate="yes" xml:space="preserve">
          <source>The current working directory of the subprocess is set to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt; if that is local (as determined by &lt;code&gt;unhandled-file-name-directory&lt;/code&gt;), or &quot;~&quot; otherwise. If you want to run a process in a remote directory use &lt;code&gt;process-file&lt;/code&gt;.</source>
          <target state="translated">Текущий рабочий каталог подпроцесса устанавливается равным текущему значению буфера &lt;code&gt;default-directory&lt;/code&gt; , если он локальный (как определено &lt;code&gt;unhandled-file-name-directory&lt;/code&gt; ), или &amp;laquo;~&amp;raquo; в противном случае. Если вы хотите запустить процесс в удаленном каталоге, используйте &lt;code&gt;process-file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5788a491a8ca633fe83f7cc719bce2a1bd26a058" translate="yes" xml:space="preserve">
          <source>The customization buffer shows all legitimate values using their read syntax, and the user edits them textually.</source>
          <target state="translated">Буфер настройки показывает все законные значения,используя их читаемый синтаксис,а пользователь редактирует их текстом.</target>
        </trans-unit>
        <trans-unit id="679b679b420f2aea1b845938fef72fa046ada093" translate="yes" xml:space="preserve">
          <source>The customization declarations that we will describe in the next few sections&amp;mdash;&lt;code&gt;defcustom&lt;/code&gt;, &lt;code&gt;defgroup&lt;/code&gt;, etc.&amp;mdash;all accept keyword arguments (see &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;) for specifying various information. This section describes keywords that apply to all types of customization declarations.</source>
          <target state="translated">Объявления настройки, которые мы опишем в следующих нескольких разделах - &lt;code&gt;defcustom&lt;/code&gt; , &lt;code&gt;defgroup&lt;/code&gt; и т. Д. - все принимают аргументы ключевого слова (см. &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Постоянные переменные&lt;/a&gt; ) для указания различной информации. В этом разделе описаны ключевые слова, применимые ко всем типам объявлений настройки.</target>
        </trans-unit>
        <trans-unit id="3245d03a470996818ac4300b0d782a4d8da2f5f0" translate="yes" xml:space="preserve">
          <source>The data as a byte array.</source>
          <target state="translated">Данные в виде массива байт.</target>
        </trans-unit>
        <trans-unit id="ca572036806441020e8effb7e24f638ba88825ed" translate="yes" xml:space="preserve">
          <source>The data structure that controls the mode line.</source>
          <target state="translated">Структура данных,управляющая линией режима.</target>
        </trans-unit>
        <trans-unit id="573b608c65720dd5e9f86107ce3794e2b66f24ad" translate="yes" xml:space="preserve">
          <source>The data type used for byte-compiled functions.</source>
          <target state="translated">Тип данных,используемый для функций,скомпилированных в байтах.</target>
        </trans-unit>
        <trans-unit id="5a82b15b1b8d7d24f2d08410ac1cfd7e6d06997f" translate="yes" xml:space="preserve">
          <source>The datagram connection doesn&amp;rsquo;t have to talk with the same remote peer all the time. It has a &lt;em&gt;remote peer address&lt;/em&gt; which specifies where to send datagrams to. Each time an incoming datagram is passed to the filter function, the peer address is set to the address that datagram came from; that way, if the filter function sends a datagram, it will go back to that place. You can specify the remote peer address when you create the datagram connection using the &lt;code&gt;:remote&lt;/code&gt; keyword. You can change it later on by calling &lt;code&gt;set-process-datagram-address&lt;/code&gt;.</source>
          <target state="translated">Соединение дейтаграммы не должно постоянно взаимодействовать с одним и тем же удаленным узлом. У него есть &lt;em&gt;адрес удаленного узла,&lt;/em&gt; который указывает, куда отправлять дейтаграммы. Каждый раз, когда входящая дейтаграмма передается в функцию фильтрации, одноранговый адрес устанавливается на адрес, с которого пришла дейтаграмма; Таким образом, если функция фильтра отправит дейтаграмму, она вернется в это место. Вы можете указать адрес удаленного узла при создании датаграммного соединения с помощью ключевого слова &lt;code&gt;:remote&lt;/code&gt; . Вы можете изменить его позже, вызвав &lt;code&gt;set-process-datagram-address&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8a99693205cb27465e9a23712b2b01b8e7190e8" translate="yes" xml:space="preserve">
          <source>The day of the month, as an integer between 1 and 31.</source>
          <target state="translated">День месяца,в виде целого числа от 1 до 31.</target>
        </trans-unit>
        <trans-unit id="9368d4933dcb32e8f32e58e12038542028e5bf2e" translate="yes" xml:space="preserve">
          <source>The day of week, as an integer between 0 and 6, where 0 stands for Sunday.</source>
          <target state="translated">День недели,в виде целого числа от 0 до 6,где 0 означает воскресенье.</target>
        </trans-unit>
        <trans-unit id="9391c6fb508041b1a4555e55af0146bfecc28aaf" translate="yes" xml:space="preserve">
          <source>The debugger buffer (in Debugger mode) provides special commands in addition to the usual Emacs commands and to the Backtrace mode commands described in the previous section. The most important use of debugger commands is for stepping through code, so that you can see how control flows. The debugger can step through the control structures of an interpreted function, but cannot do so in a byte-compiled function. If you would like to step through a byte-compiled function, replace it with an interpreted definition of the same function. (To do this, visit the source for the function and type</source>
          <target state="translated">Буфер отладчика (в режиме отладчика)предоставляет специальные команды в дополнение к обычным командам Emacs и к командам режима Backtrace,описанным в предыдущем разделе.Самое важное использование команд отладчика-это шаги по коду,так что вы можете увидеть,как движется управление.Отладчик может пройти через структуры управления интерпретируемой функции,но не может этого сделать в байт-компилированной функции.Если вы хотите пройти через байт-компилированную функцию,замените ее интерпретируемым определением той же самой функции.(Для этого посетите источник для функции и введите тип</target>
        </trans-unit>
        <trans-unit id="204c2340eea809f0b5f4579c67b2c9092c7084dc" translate="yes" xml:space="preserve">
          <source>The debugger itself must be run byte-compiled, since it makes assumptions about the state of the Lisp interpreter. These assumptions are false if the debugger is running interpreted.</source>
          <target state="translated">Сам отладчик должен быть запущен байт-компилированным,так как он делает предположения о состоянии интерпретатора Lisp.Эти предположения ложны,если отладчик запущен с интерпретацией.</target>
        </trans-unit>
        <trans-unit id="ae895d64b56913e2616b56efee1afabf87405459" translate="yes" xml:space="preserve">
          <source>The declare Form</source>
          <target state="translated">Форма заявления</target>
        </trans-unit>
        <trans-unit id="35659d17616bc9465a15f44ceedfcbfe411e25ad" translate="yes" xml:space="preserve">
          <source>The decoding functions ignore newline characters in the encoded text.</source>
          <target state="translated">Функции декодирования игнорируют символы новой строки в кодированном тексте.</target>
        </trans-unit>
        <trans-unit id="e485b5724b35707f570323bcd0914ed0bd5f1c4d" translate="yes" xml:space="preserve">
          <source>The default behavior is abandoned as soon as the user customizes one of these thresholds or manually changes the frame&amp;rsquo;s layout. The default behavior is also abandoned when calling &lt;code&gt;display-buffer&lt;/code&gt; with a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;action&lt;/var&gt; argument or the user customizes one of the options mentioned in the previous subsections. Mastering &lt;code&gt;display-buffer&lt;/code&gt; soon may become a frustrating experience due to the plethora of applicable display actions and the resulting frame layouts.</source>
          <target state="translated">От поведения по умолчанию отказываются, как только пользователь настраивает один из этих пороговых значений или вручную изменяет макет фрейма. От поведения по умолчанию также отказываются при вызове &lt;code&gt;display-buffer&lt;/code&gt; с аргументом &lt;var&gt;action&lt;/var&gt; отличным от &lt;code&gt;nil&lt;/code&gt; , или когда пользователь настраивает одну из опций, упомянутых в предыдущих подразделах. Освоение &lt;code&gt;display-buffer&lt;/code&gt; скоро может стать неприятным занятием из-за множества применимых действий отображения и результирующих макетов кадров.</target>
        </trans-unit>
        <trans-unit id="f9e9c9c82609653ae146c30ac1d8a91cbeb480f4" translate="yes" xml:space="preserve">
          <source>The default directory for temporary files is controlled by the variable &lt;code&gt;temporary-file-directory&lt;/code&gt;. This variable gives the user a uniform way to specify the directory for all temporary files. Some programs use &lt;code&gt;small-temporary-file-directory&lt;/code&gt; instead, if that is non-&lt;code&gt;nil&lt;/code&gt;. To use it, you should expand the prefix against the proper directory before calling &lt;code&gt;make-temp-file&lt;/code&gt;.</source>
          <target state="translated">Каталог по умолчанию для временных файлов управляется переменной &lt;code&gt;temporary-file-directory&lt;/code&gt; . Эта переменная дает пользователю единый способ указать каталог для всех временных файлов. Некоторые программы вместо этого используют &lt;code&gt;small-temporary-file-directory&lt;/code&gt; , если это не &lt;code&gt;nil&lt;/code&gt; . Чтобы использовать его, перед вызовом &lt;code&gt;make-temp-file&lt;/code&gt; вы должны развернуть префикс в соответствующем каталоге .</target>
        </trans-unit>
        <trans-unit id="b24d19f92acdbe56a7d260c78f0a136a2db97aa7" translate="yes" xml:space="preserve">
          <source>The default expansion function returns the abbrev symbol if it did expansion, and &lt;code&gt;nil&lt;/code&gt; otherwise. If the abbrev symbol has a hook function that is a symbol whose &lt;code&gt;no-self-insert&lt;/code&gt; property is non-&lt;code&gt;nil&lt;/code&gt;, and if the hook function returns &lt;code&gt;nil&lt;/code&gt; as its value, then the default expansion function returns &lt;code&gt;nil&lt;/code&gt;, even though expansion did occur.</source>
          <target state="translated">Функция раскрытия по умолчанию возвращает символ сокращения, если выполнялось расширение, и &lt;code&gt;nil&lt;/code&gt; противном случае. Если у символа сокращения есть функция-перехватчик, которая является символом, свойство без &lt;code&gt;nil&lt;/code&gt; которого &lt;code&gt;no-self-insert&lt;/code&gt; равно нулю , и если функция-перехватчик возвращает &lt;code&gt;nil&lt;/code&gt; в качестве своего значения, то функция расширения по умолчанию возвращает &lt;code&gt;nil&lt;/code&gt; , даже если расширение действительно имело место.</target>
        </trans-unit>
        <trans-unit id="24d2b1a3f58aabec28de7b41808ec803c54d89f7" translate="yes" xml:space="preserve">
          <source>The default face spec determines &lt;var&gt;face&lt;/var&gt;&amp;rsquo;s appearance when no customizations are in effect (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;). If &lt;var&gt;face&lt;/var&gt; has already been customized (via Custom themes or via customizations read from the init file), its appearance is determined by the custom face spec(s), which override the default face spec &lt;var&gt;spec&lt;/var&gt;. However, if the customizations are subsequently removed, the appearance of &lt;var&gt;face&lt;/var&gt; will again be determined by its default face spec.</source>
          <target state="translated">Спецификация лица по умолчанию определяет внешний вид &lt;var&gt;face&lt;/var&gt; , когда никакие настройки не действуют (см. &lt;a href=&quot;customization#Customization&quot;&gt;Настройка&lt;/a&gt; ). Если &lt;var&gt;face&lt;/var&gt; уже настроены ( с помощью пользовательских тем или с помощью настройки считываются из файла инициализации), его внешний вид определяется пользовательской лицевой спецификации (ы), которые замещают лицо по умолчанию спецификации &lt;var&gt;spec&lt;/var&gt; . Однако, если впоследствии настройки будут удалены, внешний вид &lt;var&gt;face&lt;/var&gt; снова будет определяться его спецификацией лица по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e352d771642177d9315aafbe09aa957e033f415e" translate="yes" xml:space="preserve">
          <source>The default face, whose attributes are all specified. All other faces implicitly inherit from it: any unspecified attribute defaults to the attribute on this face (see &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Face Attributes&lt;/a&gt;).</source>
          <target state="translated">Лицо по умолчанию, все атрибуты которого указаны. Все остальные грани неявно наследуются от него: любой неуказанный атрибут по умолчанию соответствует атрибуту на этом лице (см. &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Атрибуты лица&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="97f6bab98a77e2dceae2315c3bef9cc3c9e5c926" translate="yes" xml:space="preserve">
          <source>The default file permissions have no effect when you save a modified version of an existing file; saving a file preserves its existing permissions.</source>
          <target state="translated">Права доступа к файлу по умолчанию не действуют,если вы сохраняете измененную версию существующего файла;сохранение файла сохраняет его существующие права.</target>
        </trans-unit>
        <trans-unit id="c78819cd8a5f7400b7e12474830ebf1ad3d9a5da" translate="yes" xml:space="preserve">
          <source>The default filter function consults the obsolete wrapper hook &lt;code&gt;filter-buffer-substring-functions&lt;/code&gt; (see the documentation string of the macro &lt;code&gt;with-wrapper-hook&lt;/code&gt; for the details about this obsolete facility), and the obsolete variable &lt;code&gt;buffer-substring-filters&lt;/code&gt;. If both of these are &lt;code&gt;nil&lt;/code&gt;, it returns the unaltered text from the buffer, i.e., what &lt;code&gt;buffer-substring&lt;/code&gt; would return.</source>
          <target state="translated">Функция фильтра по умолчанию обращается к устаревшим &lt;code&gt;filter-buffer-substring-functions&lt;/code&gt; &lt;code&gt;buffer-substring-filters&lt;/code&gt; &lt;code&gt;with-wrapper-hook&lt;/code&gt; подробности об этой устаревшей возможности см. В строке документации макроса with-wrapper-hook ) и к устаревшей переменной buffer-substring-filters . Если оба они равны &lt;code&gt;nil&lt;/code&gt; , он возвращает неизмененный текст из буфера, то есть, какая &lt;code&gt;buffer-substring&lt;/code&gt; должна возвращаться.</target>
        </trans-unit>
        <trans-unit id="e3750f6dcb047a245eefc466255be6b4a6a8a1ea" translate="yes" xml:space="preserve">
          <source>The default filter function uses this marker to decide where to insert process output, and updates it to point after the inserted text. That is why successive batches of output are inserted consecutively.</source>
          <target state="translated">Функция фильтрации по умолчанию использует этот маркер,чтобы решить,куда вставлять вывод процесса,и обновляет его до точки после вставленного текста.Поэтому последовательные партии вывода вставляются последовательно.</target>
        </trans-unit>
        <trans-unit id="ef4cb4822663d880a22c02717254d159db66694e" translate="yes" xml:space="preserve">
          <source>The default font can be also set directly with the following function:</source>
          <target state="translated">Шрифт по умолчанию также может быть установлен непосредственно с помощью следующей функции:</target>
        </trans-unit>
        <trans-unit id="4569ee97ca7c48221170af5b1c61cb13f6d5f098" translate="yes" xml:space="preserve">
          <source>The default font of a frame and how to set it.</source>
          <target state="translated">Шрифт кадра по умолчанию и как его установить.</target>
        </trans-unit>
        <trans-unit id="7a26ffd4823527bd36b0fa5afabe4c3d579d0f2b" translate="yes" xml:space="preserve">
          <source>The default for &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, so that all keys and values referenced in the hash table are preserved from garbage collection.</source>
          <target state="translated">По умолчанию для &lt;var&gt;weak&lt;/var&gt; установлено значение &lt;code&gt;nil&lt;/code&gt; , поэтому все ключи и значения, указанные в хэш-таблице, сохраняются от сборки мусора.</target>
        </trans-unit>
        <trans-unit id="7b9181999274ee620d9b62b9de5f15a97a955b39" translate="yes" xml:space="preserve">
          <source>The default for binding local variables in Emacs.</source>
          <target state="translated">По умолчанию для привязки локальных переменных в Emacs.</target>
        </trans-unit>
        <trans-unit id="87eae0a90d65d47dac4065dcb8cd03a98d7ed3e0" translate="yes" xml:space="preserve">
          <source>The default history list for minibuffer history input.</source>
          <target state="translated">Список истории по умолчанию для ввода истории минибуфера.</target>
        </trans-unit>
        <trans-unit id="cbb0c0244aefe32651fdecae8e37c9c1d1884caa" translate="yes" xml:space="preserve">
          <source>The default is 200.</source>
          <target state="translated">По умолчанию 200.</target>
        </trans-unit>
        <trans-unit id="582cef5881ae56697d27c6a4543a9c80f1165b5a" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;nil&lt;/code&gt;. Other values are reserved for future use. A specific split operation may ignore the value of this variable if it is affected by a non-&lt;code&gt;nil&lt;/code&gt; value of &lt;code&gt;window-combination-limit&lt;/code&gt;.</source>
          <target state="translated">По умолчанию - &lt;code&gt;nil&lt;/code&gt; . Остальные значения зарезервированы для использования в будущем. Конкретная операция разделения может игнорировать значение этой переменной, если на нее влияет &lt;code&gt;nil&lt;/code&gt; значение &lt;code&gt;window-combination-limit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85c215bf6d37dced9d2e10ebdf1f4c247bbf284b" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;window-size&lt;/code&gt;. Other values are reserved for future use.</source>
          <target state="translated">По умолчанию &lt;code&gt;window-size&lt;/code&gt; . Остальные значения зарезервированы для использования в будущем.</target>
        </trans-unit>
        <trans-unit id="6c4bf2ab4e22795d3bd5f44da1e6a3c75cc6bce8" translate="yes" xml:space="preserve">
          <source>The default is to call &lt;code&gt;iconify-frame&lt;/code&gt; (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;). Alternatively, you may specify either &lt;code&gt;delete-frame&lt;/code&gt; (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;) to remove the frame from its display, &lt;code&gt;make-frame-invisible&lt;/code&gt; to make the frame invisible, &lt;code&gt;ignore&lt;/code&gt; to leave the frame unchanged, or any other function that can take a frame as its sole argument.</source>
          <target state="translated">По умолчанию вызывается &lt;code&gt;iconify-frame&lt;/code&gt; (см. &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Видимость кадров&lt;/a&gt; ). В качестве альтернативы вы можете указать либо &lt;code&gt;delete-frame&lt;/code&gt; (см. &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Удаление кадров&lt;/a&gt; ), чтобы удалить кадр с его отображения, &lt;code&gt;make-frame-invisible&lt;/code&gt; , чтобы сделать кадр невидимым, &lt;code&gt;ignore&lt;/code&gt; , чтобы оставить кадр без изменений, либо любую другую функцию, которая может принимать кадр как его единственный аргумент.</target>
        </trans-unit>
        <trans-unit id="355b0cc7c09a335da133d2cb3faf5fa1f1f66adc" translate="yes" xml:space="preserve">
          <source>The default is to search in the</source>
          <target state="translated">По умолчанию поиск производится в</target>
        </trans-unit>
        <trans-unit id="c192f5222c92d4a59ea28dd931508202451f03f1" translate="yes" xml:space="preserve">
          <source>The default name for this file specifies your home directory and starts with &amp;lsquo;</source>
          <target state="translated">Имя по умолчанию для этого файла указывает ваш домашний каталог и начинается с '</target>
        </trans-unit>
        <trans-unit id="81f50e022429a7e9b2ea12cb7d90ec2be233c641" translate="yes" xml:space="preserve">
          <source>The default size is 65.</source>
          <target state="translated">По умолчанию размер 65.</target>
        </trans-unit>
        <trans-unit id="f81af72138fca1db6fa3768259f2dad66c43e06c" translate="yes" xml:space="preserve">
          <source>The default stroke color on any lines created.</source>
          <target state="translated">Цвет штриха по умолчанию на любых созданных линиях.</target>
        </trans-unit>
        <trans-unit id="a42b364fb936e63b8fb9287c2bd08ed248154ba7" translate="yes" xml:space="preserve">
          <source>The default time zone is determined by the &lt;code&gt;TZ&lt;/code&gt; environment variable. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;. For example, you can tell Emacs to default to Universal Time with &lt;code&gt;(setenv &quot;TZ&quot; &quot;UTC0&quot;)&lt;/code&gt;. If &lt;code&gt;TZ&lt;/code&gt; is not in the environment, Emacs uses system wall clock time, which is a platform-dependent default time zone.</source>
          <target state="translated">Часовой пояс по умолчанию определяется переменной среды &lt;code&gt;TZ&lt;/code&gt; . См. &lt;a href=&quot;system-environment#System-Environment&quot;&gt;Системная среда&lt;/a&gt; . Например, вы можете указать Emacs по умолчанию использовать универсальное время с помощью &lt;code&gt;(setenv &quot;TZ&quot; &quot;UTC0&quot;)&lt;/code&gt; . Если &lt;code&gt;TZ&lt;/code&gt; не находится в среде, Emacs использует время системных часов, которое является часовым поясом по умолчанию, зависящим от платформы.</target>
        </trans-unit>
        <trans-unit id="32d3076afb57dc0f673022de3f52015867d308b4" translate="yes" xml:space="preserve">
          <source>The default tool bar is defined so that items specific to editing do not appear for major modes whose command symbol has a &lt;code&gt;mode-class&lt;/code&gt; property of &lt;code&gt;special&lt;/code&gt; (see &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;). Major modes may add items to the global bar by binding &lt;code&gt;[tool-bar
&lt;var&gt;foo&lt;/var&gt;]&lt;/code&gt; in their local map. It makes sense for some major modes to replace the default tool bar items completely, since not many can be accommodated conveniently, and the default bindings make this easy by using an indirection through &lt;code&gt;tool-bar-map&lt;/code&gt;.</source>
          <target state="translated">Панель инструментов по умолчанию определена таким образом, что элементы, относящиеся к редактированию, не отображаются для основных режимов, символ команды которых имеет свойство &lt;code&gt;special&lt;/code&gt; &lt;code&gt;mode-class&lt;/code&gt; режима (см. &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Соглашения&lt;/a&gt; об основных режимах ). Основные режимы могут добавлять элементы на глобальную панель, привязав &lt;code&gt;[tool-bar &lt;var&gt;foo&lt;/var&gt;]&lt;/code&gt; &lt;var&gt;foo&lt;/var&gt; ] к их локальной карте. Для некоторых основных режимов имеет смысл полностью заменить элементы панели инструментов по умолчанию, поскольку не многие из них могут быть удобно размещены, а привязки по умолчанию упрощают это, используя косвенное обращение через &lt;code&gt;tool-bar-map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8f458800640ea056a6ac8dce525674b542eb25" translate="yes" xml:space="preserve">
          <source>The default value &lt;code&gt;nil&lt;/code&gt; should be used when your window manager follows a &amp;ldquo;click-to-focus&amp;rdquo; policy where you have to click the mouse inside of a frame in order for that frame to gain focus.</source>
          <target state="translated">Значение по умолчанию &lt;code&gt;nil&lt;/code&gt; следует использовать, когда ваш оконный менеджер следует политике &amp;laquo;щелчок для фокусировки&amp;raquo;, когда вы должны щелкнуть мышью внутри кадра, чтобы этот кадр получил фокус.</target>
        </trans-unit>
        <trans-unit id="65c90e417643a9493a18a85edd85f577a906b419" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;fill-column&lt;/code&gt; is 70.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;fill-column&lt;/code&gt; - 70.</target>
        </trans-unit>
        <trans-unit id="1c5ee1145d2310fefd80e39a76e590d4030f537f" translate="yes" xml:space="preserve">
          <source>The default value is 1.5.</source>
          <target state="translated">Значение по умолчанию-1,5.</target>
        </trans-unit>
        <trans-unit id="023d79ed160a6c9a929201a5f88a10d241a22378" translate="yes" xml:space="preserve">
          <source>The default value is 1600. Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute.</source>
          <target state="translated">Значение по умолчанию-1600.Вход в отладчик Lisp увеличивает значение,если осталось мало места,чтобы убедиться,что в самом отладчике есть место для выполнения.</target>
        </trans-unit>
        <trans-unit id="e9c764d13e36573c05043f232522dfc255e445b0" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'(tab-bar-lines tool-bar-lines)&lt;/code&gt; for Lucid, Motif and MS-Windows (which means that adding/removing a tool or tab bar there does not change the outer frame height), &lt;code&gt;'(tab-bar-lines)&lt;/code&gt; on all other window systems including GTK+ (which means that changing any of the parameters listed above with the exception of &lt;code&gt;tab-bar-lines&lt;/code&gt; may change the size of the outer frame), and &lt;code&gt;t&lt;/code&gt; otherwise (which means the outer frame size never changes implicitly when there&amp;rsquo;s no window system support).</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;'(tab-bar-lines tool-bar-lines)&lt;/code&gt; для Lucid, Motif и MS-Windows (что означает, что добавление / удаление инструмента или панели вкладок не изменяет высоту внешней рамки), &lt;code&gt;'(tab-bar-lines)&lt;/code&gt; во всех других оконных системах, включая GTK + (что означает, что изменение любого из параметров, перечисленных выше, за исключением &lt;code&gt;tab-bar-lines&lt;/code&gt; , может изменить размер внешнего фрейма), и &lt;code&gt;t&lt;/code&gt; в противном случае (что означает внешний размер кадра никогда не изменяется неявно, если нет поддержки оконной системы).</target>
        </trans-unit>
        <trans-unit id="41b5142be2a25ab47e2b91994f5b738ecc8aff3e" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;nil&lt;/code&gt;, i.e., the prefix-discarding feature is disabled. This is because discarding prefixes often leads to confusing names for options and faces.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;nil&lt;/code&gt; , т. Е. Функция отмены префикса отключена. Это связано с тем, что отказ от префиксов часто приводит к путанице в именах параметров и лиц.</target>
        </trans-unit>
        <trans-unit id="60739858c427147eccf0a2c0969cc628b2fa3758" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;normal-backup-enable-predicate&lt;/code&gt;, which checks for files in &lt;code&gt;temporary-file-directory&lt;/code&gt; and &lt;code&gt;small-temporary-file-directory&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;normal-backup-enable-predicate&lt;/code&gt; , который проверяет файлы в каталоге &lt;code&gt;temporary-file-directory&lt;/code&gt; и &lt;code&gt;small-temporary-file-directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19763762633973d0ed6336bf3782312f60260a0c" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;step&lt;/code&gt;. This variable can be set interactively with</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;step&lt;/code&gt; . Эта переменная может быть установлена ​​интерактивно с помощью</target>
        </trans-unit>
        <trans-unit id="e11dbb62c77f8d4f68d95a72cdb3ccd5d2250955" translate="yes" xml:space="preserve">
          <source>The default value is determined in a reasonable way for your operating system; it is based on the &lt;code&gt;TMPDIR&lt;/code&gt;, &lt;code&gt;TMP&lt;/code&gt; and &lt;code&gt;TEMP&lt;/code&gt; environment variables, with a fall-back to a system-dependent name if none of these variables is defined.</source>
          <target state="translated">Значение по умолчанию определяется разумным образом для вашей операционной системы; он основан на переменных среды &lt;code&gt;TMPDIR&lt;/code&gt; , &lt;code&gt;TMP&lt;/code&gt; и &lt;code&gt;TEMP&lt;/code&gt; , с возвратом к системно-зависимому имени, если ни одна из этих переменных не определена.</target>
        </trans-unit>
        <trans-unit id="3bcf9e986e7383ce581df716448fe56d672113c0" translate="yes" xml:space="preserve">
          <source>The default value is seen in buffers that don&amp;rsquo;t have their own buffer-local values.</source>
          <target state="translated">Значение по умолчанию отображается в буферах, у которых нет собственных локальных значений буфера.</target>
        </trans-unit>
        <trans-unit id="1193bd78586d719562726255cbef739c27920d29" translate="yes" xml:space="preserve">
          <source>The default value is the function that clears the message displayed in an active minibuffer.</source>
          <target state="translated">Значением по умолчанию является функция,которая очищает сообщение,отображаемое в активном минибуфере.</target>
        </trans-unit>
        <trans-unit id="d5282ebe83f8d6dacbe0acbf2204264b3f3383ec" translate="yes" xml:space="preserve">
          <source>The default value is the function that displays the message at the end of the minibuffer when the minibuffer is active. However, if the text shown in the active minibuffer has the &lt;code&gt;minibuffer-message&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;) on some character, the message will be displayed before the first character having that property.</source>
          <target state="translated">Значение по умолчанию - это функция, которая отображает сообщение в конце минибуфера, когда минибуфер активен. Однако, если текст, отображаемый в активном минибуфере, имеет свойство текста &lt;code&gt;minibuffer-message&lt;/code&gt; (см. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Специальные свойства&lt;/a&gt; ) для некоторого символа, сообщение будет отображаться перед первым символом, имеющим это свойство.</target>
        </trans-unit>
        <trans-unit id="c24a56207aec1ab7e76efac7a53cf162bbbcd2f9" translate="yes" xml:space="preserve">
          <source>The default value is zero, which means that conservative scrolling never happens.</source>
          <target state="translated">Значение по умолчанию равно нулю,что означает,что консервативная прокрутка никогда не происходит.</target>
        </trans-unit>
        <trans-unit id="474d2dbca7fd1c4cd24098b32e8425d766731b4d" translate="yes" xml:space="preserve">
          <source>The default value matches whitespace with certain punctuation characters intermingled.</source>
          <target state="translated">Значение по умолчанию совпадает с пробелами,в которых переплетаются определенные знаки препинания.</target>
        </trans-unit>
        <trans-unit id="708d542b5cb83d6b27cbfcf294ba98e1c6eb4b90" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;auto-hscroll-mode&lt;/code&gt; is &lt;code&gt;t&lt;/code&gt;; setting it to &lt;code&gt;current-line&lt;/code&gt; activates a variant of automatic horizontal scrolling whereby only the line showing the cursor is horizontally scrolled to make point visible, the rest of the window is left either unscrolled, or at the minimum scroll amount set by &lt;code&gt;scroll-left&lt;/code&gt; and &lt;code&gt;scroll-right&lt;/code&gt;, see below.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;auto-hscroll-mode&lt;/code&gt; - &lt;code&gt;t&lt;/code&gt; ; установка его на &lt;code&gt;current-line&lt;/code&gt; активирует вариант автоматической горизонтальной прокрутки, при которой только строка, показывающая курсор, прокручивается горизонтально, чтобы сделать точку видимой, остальная часть окна остается либо без прокрутки, либо с минимальной прокруткой, установленной с помощью &lt;code&gt;scroll-left&lt;/code&gt; и &lt;code&gt;scroll-right&lt;/code&gt; , см. ниже.</target>
        </trans-unit>
        <trans-unit id="b51a5e882958d495ad310784959e1d391806578c" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;bidi-display-reordering&lt;/code&gt; controls the reordering of strings which are not directly supplied by a buffer, including the text displayed in mode lines (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;) and header lines (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;).</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;bidi-display-reordering&lt;/code&gt; управляет переупорядочиванием строк, которые не поставляются напрямую буфером, включая текст, отображаемый в строках режима (см. &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Формат&lt;/a&gt; строки режима ) и строках заголовков (см. &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Строки заголовка&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e746e493f187bcdc9f3fc0f756c6ba6a17eaffe8" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;imenu-create-index-function&lt;/code&gt; is &lt;code&gt;imenu-default-create-index-function&lt;/code&gt;. This function calls the value of &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and the value of &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; to produce the index alist. However, if either of these two variables is &lt;code&gt;nil&lt;/code&gt;, the default function uses &lt;code&gt;imenu-generic-expression&lt;/code&gt; instead.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;imenu-create-index-function&lt;/code&gt; - &lt;code&gt;imenu-default-create-index-function&lt;/code&gt; . Эта функция вызывает значение функции &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; и значение &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; для создания списка индексов. Однако, если любая из этих двух переменных равна &lt;code&gt;nil&lt;/code&gt; , функция по умолчанию использует &lt;code&gt;imenu-generic-expression&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e5a409a50e09859f3f4732e6977f44e72151aa" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;mode-line-format&lt;/code&gt; is designed to use the values of other variables such as &lt;code&gt;mode-line-position&lt;/code&gt; and &lt;code&gt;mode-line-modes&lt;/code&gt; (which in turn incorporates the values of the variables &lt;code&gt;mode-name&lt;/code&gt; and &lt;code&gt;minor-mode-alist&lt;/code&gt;). Very few modes need to alter &lt;code&gt;mode-line-format&lt;/code&gt; itself. For most purposes, it is sufficient to alter some of the variables that &lt;code&gt;mode-line-format&lt;/code&gt; either directly or indirectly refers to.</source>
          <target state="translated">Значение по умолчанию &lt;code&gt;mode-line-format&lt;/code&gt; предназначено для использования значений других переменных, таких как &lt;code&gt;mode-line-position&lt;/code&gt; и &lt;code&gt;mode-line-modes&lt;/code&gt; (которые, в свою очередь, включают значения переменных &lt;code&gt;mode-name&lt;/code&gt; и &lt;code&gt;minor-mode-alist&lt;/code&gt; ). Очень немногие режимы нуждаются в изменении самого &lt;code&gt;mode-line-format&lt;/code&gt; . Для большинства целей достаточно изменить некоторые переменные, на которые прямо или косвенно ссылается &lt;code&gt;mode-line-format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8603f9889e97902f88b37a045802893e502f1a0b" translate="yes" xml:space="preserve">
          <source>The default value of &lt;var&gt;separators&lt;/var&gt; for &lt;code&gt;split-string&lt;/code&gt;. Its usual value is &lt;code&gt;&quot;[&amp;nbsp;\f\t\n\r\v]+&quot;&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;var&gt;separators&lt;/var&gt; по умолчанию для &lt;code&gt;split-string&lt;/code&gt; . Его обычное значение - &lt;code&gt;&quot;[&amp;nbsp;\f\t\n\r\v]+&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f626f251ec5e141bbe937ae58b8aaf07f20d470" translate="yes" xml:space="preserve">
          <source>The default value of this variable is 800. If you set it to a value less than 100, Lisp will reset it to 100 if the given value is reached. Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute.</source>
          <target state="translated">Значение этой переменной по умолчанию равно 800.Если вы установите ее значение меньше 100,то Lisp сбросит его на 100,если заданное значение будет достигнуто.Вход в отладчик Lisp увеличивает значение,если осталось мало места,чтобы убедиться,что в самом отладчике есть место для выполнения.</target>
        </trans-unit>
        <trans-unit id="63779c1cdb9430e4b77e711a1e1ae7eb8735f2c6" translate="yes" xml:space="preserve">
          <source>The default value of this variable is &lt;code&gt;&quot;\\`[&amp;nbsp;\t]*\\'&quot;&lt;/code&gt;, which matches only a string of whitespace. The effect of this default is to force the fill prefixes found in one-line paragraphs always to be pure whitespace.</source>
          <target state="translated">Значение по умолчанию этой переменной - &lt;code&gt;&quot;\\`[&amp;nbsp;\t]*\\'&quot;&lt;/code&gt; , что соответствует только строке пробелов. Эффект от этого значения по умолчанию заключается в том, что префиксы заливки в однострочных абзацах всегда должны быть чистыми пробелами.</target>
        </trans-unit>
        <trans-unit id="217b324a19b504412ef043553ade93bbd8a61750" translate="yes" xml:space="preserve">
          <source>The default value of this variable specifies functions called during redisplay when a window state change has been detected or the window state change flag has been set on at least one frame. The value should be a list of functions that take no argument.</source>
          <target state="translated">Значение по умолчанию этой переменной определяет функции,вызываемые при повторном просмотре,когда обнаружено изменение состояния окна или установлен флаг изменения состояния окна хотя бы на одном кадре.Значение должно представлять собой список функций,не принимающих аргументов.</target>
        </trans-unit>
        <trans-unit id="ac7d9e5d9130c0ce3ad4a6ef24ef8b11019be5bf" translate="yes" xml:space="preserve">
          <source>The default width (in pixels) of any lines created.</source>
          <target state="translated">Ширина (в пикселях)любых созданных линий по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cae16c8270beb52faa207be4ea3ec044cff903b8" translate="yes" xml:space="preserve">
          <source>The default width of the left and right fringes of windows in this frame (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;). If either of these is zero, that effectively removes the corresponding fringe.</source>
          <target state="translated">Ширина по умолчанию левой и правой кромок окон в этом фрейме (см. &amp;laquo; &lt;a href=&quot;fringes#Fringes&quot;&gt;Полосы&amp;raquo;&lt;/a&gt; ). Если любой из них равен нулю, это эффективно удаляет соответствующую полосу.</target>
        </trans-unit>
        <trans-unit id="f3d7400445b75719c99eccd1b0976fe9d039c6d2" translate="yes" xml:space="preserve">
          <source>The defining form itself is not instrumented (that is, Edebug does not stop before and after the defining form), but forms inside it typically will be instrumented. The &lt;code&gt;&amp;amp;define&lt;/code&gt; keyword should be the first element in a list specification.</source>
          <target state="translated">Сама определяющая форма не инструментирована (то есть Edebug не останавливается до и после определяющей формы), но формы внутри нее обычно будут инструментированы. &lt;code&gt;&amp;amp;define&lt;/code&gt; ключевое слово должно быть первым элементом в спецификации списка.</target>
        </trans-unit>
        <trans-unit id="9c5fa5dc8ac20b29bbb924420889ce1b839d9ba5" translate="yes" xml:space="preserve">
          <source>The definition of &amp;ldquo;supported&amp;rdquo; is somewhat heuristic, but basically means that a face containing all the attributes in &lt;var&gt;attributes&lt;/var&gt;, when merged with the default face for display, can be represented in a way that&amp;rsquo;s</source>
          <target state="translated">Определение &amp;laquo;поддерживается&amp;raquo; в некоторой степени эвристично, но в основном означает, что лицо, содержащее все атрибуты в &lt;var&gt;attributes&lt;/var&gt; , при объединении с лицом по умолчанию для отображения, может быть представлено таким образом, чтобы</target>
        </trans-unit>
        <trans-unit id="aedb03aaf6dff1ad0c121d98d3217492fba910a6" translate="yes" xml:space="preserve">
          <source>The definition of a word is any sequence of consecutive characters that are assigned to the word constituent syntax class in the current syntax table (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">Определение слова - это любая последовательность последовательных символов, которая назначена классу синтаксиса, составляющему слово, в текущей таблице синтаксиса (см. &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Таблицу классов синтаксиса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ae3fd0458aa9fbdb36602fe411a8d0a3f565b34" translate="yes" xml:space="preserve">
          <source>The definitions are only available during the macro-expansion of &lt;var&gt;body&lt;/var&gt;, and are thus not present during execution of compiled code.</source>
          <target state="translated">Определения доступны только во время макрорасширения &lt;var&gt;body&lt;/var&gt; и, следовательно, не присутствуют во время выполнения скомпилированного кода.</target>
        </trans-unit>
        <trans-unit id="877a7963eb71e684d92a94b1803dcb705fa62e6e" translate="yes" xml:space="preserve">
          <source>The definitions live in a name space of their own, separate from that of Lisp variables. There is thus no need to attach a suffix like &lt;code&gt;-regexp&lt;/code&gt; to names; they cannot collide with anything else.</source>
          <target state="translated">Определения живут в собственном пространстве имен, отдельном от переменных Лиспа. Таким образом, нет необходимости &lt;code&gt;-regexp&lt;/code&gt; суффикс типа -regexp к именам; они не могут столкнуться ни с чем другим.</target>
        </trans-unit>
        <trans-unit id="c95395c58aba34be09b3406ccfc84562286cab93" translate="yes" xml:space="preserve">
          <source>The degree of &lt;em&gt;travel&lt;/em&gt; of the window through (the visible portion of) the buffer, i.e. the size of the text above the top of the window expressed as a percentage of all the text outside the window, or &amp;lsquo;</source>
          <target state="translated">Степень &lt;em&gt;прохождения&lt;/em&gt; окна через (видимую часть) буфера, то есть размер текста над верхней частью окна, выраженный в процентах от всего текста за пределами окна, или</target>
        </trans-unit>
        <trans-unit id="d4c578bc284c890724d1b4502b0a9e91e91cf747" translate="yes" xml:space="preserve">
          <source>The depth in parentheses, counting from 0. &lt;strong&gt;Warning:&lt;/strong&gt; this can be negative if there are more close parens than open parens between the parser&amp;rsquo;s starting point and end point.</source>
          <target state="translated">Глубина в круглых скобках, отсчитываемая от 0. &lt;strong&gt;Предупреждение:&lt;/strong&gt; это может быть отрицательным, если между начальной и конечной точками парсера больше закрытых скобок, чем открытых.</target>
        </trans-unit>
        <trans-unit id="f9ee4a27b6f69857fe6970eaa91ad4c556960063" translate="yes" xml:space="preserve">
          <source>The depth limit counts internal uses of &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;funcall&lt;/code&gt;, such as for calling the functions mentioned in Lisp expressions, and recursive evaluation of function call arguments and function body forms, as well as explicit calls in Lisp code.</source>
          <target state="translated">Предел глубины подсчитывает внутреннее использование &lt;code&gt;eval&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; и &lt;code&gt;funcall&lt;/code&gt; , например, для вызова функций, упомянутых в выражениях Lisp, и рекурсивного вычисления аргументов вызова функций и форм тела функции, а также явных вызовов в коде Lisp.</target>
        </trans-unit>
        <trans-unit id="a04b7a2c41711ae199f98dbc28e807a536f9db15" translate="yes" xml:space="preserve">
          <source>The derived mode should also define a &lt;em&gt;listing command&lt;/em&gt;. This, not the mode command, is what the user calls (e.g.,</source>
          <target state="translated">Производный режим также должен определять &lt;em&gt;команду листинга&lt;/em&gt; . Это то, что пользователь вызывает, а не команду режима (например,</target>
        </trans-unit>
        <trans-unit id="edf217a40e12d6916d0fa58287c1046472b44fae" translate="yes" xml:space="preserve">
          <source>The descriptions of macros and special forms use a more complex notation to specify optional and repeated arguments, because they can break the argument list down into separate arguments in more complicated ways. &amp;lsquo;</source>
          <target state="translated">В описаниях макросов и специальных форм используется более сложная нотация для указания необязательных и повторяющихся аргументов, поскольку они могут разбивать список аргументов на отдельные аргументы более сложными способами. '</target>
        </trans-unit>
        <trans-unit id="2a9e034a9e7e27057da723954a997fb3896ab0b9" translate="yes" xml:space="preserve">
          <source>The descriptor of the arguments. This can either be a list of arguments, as described in &lt;a href=&quot;argument-list#Argument-List&quot;&gt;Argument List&lt;/a&gt;, or an integer encoding the required number of arguments. In the latter case, the value of the descriptor specifies the minimum number of arguments in the bits zero to 6, and the maximum number of arguments in bits 8 to 14. If the argument list uses &lt;code&gt;&amp;amp;rest&lt;/code&gt;, then bit 7 is set; otherwise it&amp;rsquo;s cleared.</source>
          <target state="translated">Дескриптор аргументов. Это может быть либо список аргументов, как описано в &lt;a href=&quot;argument-list#Argument-List&quot;&gt;разделе &amp;laquo;Список аргументов&amp;raquo;&lt;/a&gt; , либо целое число, кодирующее необходимое количество аргументов. В последнем случае значение дескриптора определяет минимальное количество аргументов в битах от нуля до 6 и максимальное количество аргументов в битах с 8 по 14. Если в списке аргументов используется &lt;code&gt;&amp;amp;rest&lt;/code&gt; , то устанавливается бит 7; в противном случае он очищается.</target>
        </trans-unit>
        <trans-unit id="28d0d52832e8c8eae5fe1ac0bf15f2addec6fe86" translate="yes" xml:space="preserve">
          <source>The destructive aspect of &lt;code&gt;sort&lt;/code&gt; for lists is that it rearranges the cons cells forming &lt;var&gt;sequence&lt;/var&gt; by changing &lt;small&gt;CDR&lt;/small&gt;s. A nondestructive sort function would create new cons cells to store the elements in their sorted order. If you wish to make a sorted copy without destroying the original, copy it first with &lt;code&gt;copy-sequence&lt;/code&gt; and then sort.</source>
          <target state="translated">Деструктивный аспект &lt;code&gt;sort&lt;/code&gt; для списков состоит в том, что он перестраивает &lt;var&gt;sequence&lt;/var&gt; образующую cons-ячейки , путем изменения &lt;small&gt;CDR&lt;/small&gt; . Функция неразрушающей сортировки создаст новые cons-ячейки для хранения элементов в их отсортированном порядке. Если вы хотите сделать отсортированную копию без разрушения оригинала, сначала скопируйте ее с помощью &lt;code&gt;copy-sequence&lt;/code&gt; , а затем отсортируйте.</target>
        </trans-unit>
        <trans-unit id="d572ffee8a2d69eec0c8cc8132950bf3a5e93701" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;defconst&lt;/code&gt; and &lt;code&gt;defvar&lt;/code&gt; is mainly a matter of intent, serving to inform human readers of whether the value should ever change. Emacs Lisp does not actually prevent you from changing the value of a variable defined with &lt;code&gt;defconst&lt;/code&gt;. One notable difference between the two forms is that &lt;code&gt;defconst&lt;/code&gt; unconditionally initializes the variable, whereas &lt;code&gt;defvar&lt;/code&gt; initializes it only if it is originally void.</source>
          <target state="translated">Разница между &lt;code&gt;defconst&lt;/code&gt; и &lt;code&gt;defvar&lt;/code&gt; в основном заключается в намерении, служащем для информирования читателей о том, должно ли значение когда-либо измениться. Emacs Lisp на самом деле не мешает вам изменять значение переменной, определенной с помощью &lt;code&gt;defconst&lt;/code&gt; . Одно заметное различие между двумя формами заключается в том, что &lt;code&gt;defconst&lt;/code&gt; безоговорочно инициализирует переменную, тогда как &lt;code&gt;defvar&lt;/code&gt; инициализирует ее, только если она изначально недействительна.</target>
        </trans-unit>
        <trans-unit id="00f363a6aefc0d2de4ef2a1c12ef0e6acbfbacc8" translate="yes" xml:space="preserve">
          <source>The difference between a directory name and a directory file name is subtle but crucial. When an Emacs variable or function argument is described as being a directory name, a directory file name is not acceptable. When &lt;code&gt;file-name-directory&lt;/code&gt; returns a string, that is always a directory name.</source>
          <target state="translated">Разница между именем каталога и именем файла каталога тонкая, но важная. Когда переменная Emacs или аргумент функции описываются как имя каталога, имя файла каталога неприемлемо. Когда &lt;code&gt;file-name-directory&lt;/code&gt; возвращает строку, это всегда имя каталога.</target>
        </trans-unit>
        <trans-unit id="0c61186b221c080d1307543136c715a6291ad149" translate="yes" xml:space="preserve">
          <source>The difference from &lt;code&gt;start-process&lt;/code&gt; is that this function may invoke a file name handler based on the value of &lt;code&gt;default-directory&lt;/code&gt;. This handler ought to run &lt;var&gt;program&lt;/var&gt;, perhaps on the local host, perhaps on a remote host that corresponds to &lt;code&gt;default-directory&lt;/code&gt;. In the latter case, the local part of &lt;code&gt;default-directory&lt;/code&gt; becomes the working directory of the process.</source>
          <target state="translated">Отличие от &lt;code&gt;start-process&lt;/code&gt; заключается в том, что эта функция может вызывать обработчик имени файла на основе значения &lt;code&gt;default-directory&lt;/code&gt; . Этот обработчик должен запускать &lt;var&gt;program&lt;/var&gt; , возможно, на локальном хосте, возможно, на удаленном хосте, который соответствует &lt;code&gt;default-directory&lt;/code&gt; по умолчанию . В последнем случае локальная часть &lt;code&gt;default-directory&lt;/code&gt; по умолчанию становится рабочим каталогом процесса.</target>
        </trans-unit>
        <trans-unit id="405409528439a35fcd3fdd61f588ad09de4201e8" translate="yes" xml:space="preserve">
          <source>The difference is in &lt;var&gt;boolean-expression&lt;/var&gt; in &lt;code&gt;guard&lt;/code&gt;: &lt;code&gt;CLEAN&lt;/code&gt; references &lt;code&gt;n&lt;/code&gt; simply and directly, while &lt;code&gt;MAYBE&lt;/code&gt; references &lt;code&gt;n&lt;/code&gt; with a side-effect, in the expression &lt;code&gt;(incf n)&lt;/code&gt;. When &lt;code&gt;integer&lt;/code&gt; is 3, here&amp;rsquo;s what happens:</source>
          <target state="translated">Разница заключается в &lt;var&gt;boolean-expression&lt;/var&gt; в &lt;code&gt;guard&lt;/code&gt; : &lt;code&gt;CLEAN&lt;/code&gt; просто и напрямую ссылается на &lt;code&gt;n&lt;/code&gt; , в то время как &lt;code&gt;MAYBE&lt;/code&gt; ссылаться на &lt;code&gt;n&lt;/code&gt; с побочным эффектом в выражении &lt;code&gt;(incf n)&lt;/code&gt; . Когда &lt;code&gt;integer&lt;/code&gt; равно 3, происходит следующее:</target>
        </trans-unit>
        <trans-unit id="fbc5a4ab37f1524874d8f0ded5207cb907043590" translate="yes" xml:space="preserve">
          <source>The direct effect of calling &lt;code&gt;provide&lt;/code&gt; is to add &lt;var&gt;feature&lt;/var&gt; to the front of &lt;code&gt;features&lt;/code&gt; if it is not already in that list and call any &lt;code&gt;eval-after-load&lt;/code&gt; code waiting for it (see &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt;). The argument &lt;var&gt;feature&lt;/var&gt; must be a symbol. &lt;code&gt;provide&lt;/code&gt; returns &lt;var&gt;feature&lt;/var&gt;.</source>
          <target state="translated">Прямым следствием вызова &lt;code&gt;provide&lt;/code&gt; является добавление &lt;var&gt;feature&lt;/var&gt; в начало &lt;code&gt;features&lt;/code&gt; если ее еще нет в этом списке, и вызов любого ожидающего ее кода &lt;code&gt;eval-after-load&lt;/code&gt; (см. &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Хуки для загрузки&lt;/a&gt; ). Аргумент &lt;var&gt;feature&lt;/var&gt; должна быть символом. &lt;code&gt;provide&lt;/code&gt; &lt;var&gt;feature&lt;/var&gt; возврата .</target>
        </trans-unit>
        <trans-unit id="c5e376c6c42e5e68d88b0c49222ae1c46a5afcef" translate="yes" xml:space="preserve">
          <source>The directory for expanding relative file names. This is the value of the buffer-local variable &lt;code&gt;default-directory&lt;/code&gt; (see &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;File Name Expansion&lt;/a&gt;).</source>
          <target state="translated">Каталог для расширения относительных имен файлов. Это значение переменной &lt;code&gt;default-directory&lt;/code&gt; локальной буфера (см. &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;Расширение имени файла&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="95896d2cb5e4e00827d6c52c6324b90256c8c47b" translate="yes" xml:space="preserve">
          <source>The directory for writing temporary files via &lt;code&gt;make-nearby-temp-file&lt;/code&gt;. In case of a remote &lt;code&gt;default-directory&lt;/code&gt;, this is a directory for temporary files on that remote host. If such a directory does not exist, or &lt;code&gt;default-directory&lt;/code&gt; ought to be located on a mounted file system (see &lt;code&gt;mounted-file-systems&lt;/code&gt;), the function returns &lt;code&gt;default-directory&lt;/code&gt;. For a non-remote and non-mounted &lt;code&gt;default-directory&lt;/code&gt;, the value of the variable &lt;code&gt;temporary-file-directory&lt;/code&gt; is returned.</source>
          <target state="translated">Каталог для записи временных файлов через &lt;code&gt;make-nearby-temp-file&lt;/code&gt; . В случае удаленного &lt;code&gt;default-directory&lt;/code&gt; это каталог для временных файлов на этом удаленном хосте. Если такой каталог не существует или &lt;code&gt;default-directory&lt;/code&gt; по умолчанию должен находиться в смонтированной файловой системе (см. &lt;code&gt;mounted-file-systems&lt;/code&gt; ), функция возвращает &lt;code&gt;default-directory&lt;/code&gt; . Для не удаленного и не смонтированного &lt;code&gt;default-directory&lt;/code&gt; возвращается значение переменной &lt;code&gt;temporary-file-directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f0c90883c01ceb7e1d412c839e69e9b41c49f91" translate="yes" xml:space="preserve">
          <source>The directory part of a file name, and the rest.</source>
          <target state="translated">Каталоговая часть имени файла,и остальное.</target>
        </trans-unit>
        <trans-unit id="bb1425231fa4728dea70710d27bed5b876df285a" translate="yes" xml:space="preserve">
          <source>The display Property</source>
          <target state="translated">Дисплей Свойства</target>
        </trans-unit>
        <trans-unit id="574c0a83bdb82c9364892cb8a35e8ae877142b4d" translate="yes" xml:space="preserve">
          <source>The display on which to open this frame. It should be a string of the form &amp;lsquo;</source>
          <target state="translated">Дисплей, на котором открывается этот фрейм. Это должна быть строка вида '</target>
        </trans-unit>
        <trans-unit id="d4d99dccff6bb38fa72897f95b5acb0e7a7f0c6b" translate="yes" xml:space="preserve">
          <source>The display routines insist that the position of point be visible when a buffer is displayed. Normally, they select the display-start position according to their internal logic (and scroll the window if necessary) to make point visible. However, if you specify the start position with this function using &lt;code&gt;nil&lt;/code&gt; for &lt;var&gt;noforce&lt;/var&gt;, it means you want display to start at &lt;var&gt;position&lt;/var&gt; even if that would put the location of point off the screen. If this does place point off screen, the display routines attempt to move point to the left margin on the middle line in the window.</source>
          <target state="translated">Процедуры отображения настаивают на том, чтобы положение точки было видимым при отображении буфера. Обычно они выбирают начальную позицию отображения в соответствии со своей внутренней логикой (и при необходимости прокручивают окно), чтобы сделать точку видимой. Однако, если указать начальную позицию с помощью этой функции , используя &lt;code&gt;nil&lt;/code&gt; для &lt;var&gt;noforce&lt;/var&gt; , это означает , что вы хотите дисплей начать с &lt;var&gt;position&lt;/var&gt; , даже если это будет поставить местоположение точки на экране. Если это действительно перемещает точку за пределы экрана, процедуры отображения пытаются переместить точку к левому краю средней линии в окне.</target>
        </trans-unit>
        <trans-unit id="cfbe7f152c0b39bedc406ebf65bdbb56682447f9" translate="yes" xml:space="preserve">
          <source>The display table also has six &lt;em&gt;extra slots&lt;/em&gt; which serve special purposes. Here is a table of their meanings; &lt;code&gt;nil&lt;/code&gt; in any slot means to use the default for that slot, as stated below.</source>
          <target state="translated">В демонстрационном столе также есть шесть &lt;em&gt;дополнительных слотов,&lt;/em&gt; которые служат для специальных целей. Вот таблица их значений; &lt;code&gt;nil&lt;/code&gt; в любом слоте означает использование значения по умолчанию для этого слота, как указано ниже.</target>
        </trans-unit>
        <trans-unit id="d74cb6c53f98889ae644a4ae44d69a5aaec11ebc" translate="yes" xml:space="preserve">
          <source>The distinction between the values &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;auto-raise&lt;/code&gt; is not needed for &amp;ldquo;normal&amp;rdquo; frames because the window manager usually takes care of raising them. It is useful to automatically raise child frames via &lt;code&gt;mouse-autoselect-window&lt;/code&gt; (see &lt;a href=&quot;mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection&quot;&gt;Mouse Window Auto-selection&lt;/a&gt;).</source>
          <target state="translated">Различие между значениями &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;auto-raise&lt;/code&gt; не требуется для &amp;laquo;обычных&amp;raquo; фреймов, потому что оконный менеджер обычно заботится об их повышении. Полезно автоматически поднимать дочерние фреймы с помощью &lt;code&gt;mouse-autoselect-window&lt;/code&gt; (см. &lt;a href=&quot;mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection&quot;&gt;Автоматический выбор &lt;/a&gt;окна мыши ).</target>
        </trans-unit>
        <trans-unit id="ac49afe1f8b1d00c40d5b387f20271f4e9795b2b" translate="yes" xml:space="preserve">
          <source>The documentation for the variable, as a C comment. See &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;Documentation Basics&lt;/a&gt;, for more details.</source>
          <target state="translated">Документация по переменной в виде комментария C. Подробнее см. &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;Основы документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9096506924630d76469ff43fb14e930091df8acb" translate="yes" xml:space="preserve">
          <source>The documentation string (if any); otherwise, &lt;code&gt;nil&lt;/code&gt;. The value may be a number or a list, in case the documentation string is stored in a file. Use the function &lt;code&gt;documentation&lt;/code&gt; to get the real documentation string (see &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;Accessing Documentation&lt;/a&gt;).</source>
          <target state="translated">Строка документации (если есть); в противном случае - &lt;code&gt;nil&lt;/code&gt; . Значение может быть числом или списком, если строка документации хранится в файле. Используйте &lt;code&gt;documentation&lt;/code&gt; по функциям, чтобы получить реальную строку документации (см. &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;Доступ к документации&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7cda64b5ea11cd6957b261df860267c56e609865" translate="yes" xml:space="preserve">
          <source>The documentation string can be followed by a list of C function attributes for the C function that implements the primitive, like this:</source>
          <target state="translated">За строкой документации может следовать список атрибутов функции C для функции C,реализующей примитив,подобно этому:</target>
        </trans-unit>
        <trans-unit id="c2c2488aff2b6b2c8931c7861476fd8beada96a4" translate="yes" xml:space="preserve">
          <source>The documentation string is a Lisp string object placed within the function definition to describe the function for the Emacs help facilities. See &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;.</source>
          <target state="translated">Строка документации - это строковый объект Лиспа, помещенный в определение функции для описания функции для средств справки Emacs. См. &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Документацию по функциям&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8798fcbcbfa841bfd2050e9aff8cc8aa58c79b62" translate="yes" xml:space="preserve">
          <source>The documentation string may include the special documentation substrings, &amp;lsquo;</source>
          <target state="translated">Строка документации может включать специальные подстроки документации, '</target>
        </trans-unit>
        <trans-unit id="ea2c69ace2daf00b95cdbfd31c14d5463703de87" translate="yes" xml:space="preserve">
          <source>The dumped</source>
          <target state="translated">Брошенный</target>
        </trans-unit>
        <trans-unit id="eb89833eef2d50da5011e2727744d05d6002e503" translate="yes" xml:space="preserve">
          <source>The dynamic loading feature has certain disadvantages:</source>
          <target state="translated">Функция динамической нагрузки имеет определенные недостатки:</target>
        </trans-unit>
        <trans-unit id="07a8b495dabf40d957fd26c3bb5cf9abd29e9d67" translate="yes" xml:space="preserve">
          <source>The earliest GNU Emacs versions represented meta characters as codes in the range of 128 to 255. At that time, the basic character codes ranged from 0 to 127, so all keyboard character codes did fit in a string. Many Lisp programs used &amp;lsquo;</source>
          <target state="translated">Самые ранние версии GNU Emacs представляли метасимволы как коды в диапазоне от 128 до 255. В то время базовые коды символов варьировались от 0 до 127, так что все коды символов клавиатуры помещались в строку. Многие программы на Лиспе использовали '</target>
        </trans-unit>
        <trans-unit id="f317bf5e201146dfa917711748b39145e9d9a2e3" translate="yes" xml:space="preserve">
          <source>The easiest way to construct a keymap with a prompt string is to specify the string as an argument when you call &lt;code&gt;make-keymap&lt;/code&gt;, &lt;code&gt;make-sparse-keymap&lt;/code&gt; (see &lt;a href=&quot;creating-keymaps#Creating-Keymaps&quot;&gt;Creating Keymaps&lt;/a&gt;), or &lt;code&gt;define-prefix-command&lt;/code&gt; (see &lt;a href=&quot;prefix-keys#Definition-of-define_002dprefix_002dcommand&quot;&gt;Definition of define-prefix-command&lt;/a&gt;). If you do not want the keymap to operate as a menu, don&amp;rsquo;t specify a prompt string for it.</source>
          <target state="translated">Самый простой способ создать раскладку клавиш со строкой подсказки - указать эту строку в качестве аргумента при вызове &lt;code&gt;make-keymap&lt;/code&gt; , &lt;code&gt;make-sparse-keymap&lt;/code&gt; (см. &lt;a href=&quot;creating-keymaps#Creating-Keymaps&quot;&gt;Создание раскладок&lt;/a&gt; ) или &lt;code&gt;define-prefix-command&lt;/code&gt; (см. &lt;a href=&quot;prefix-keys#Definition-of-define_002dprefix_002dcommand&quot;&gt;Определение define-prefix -команда&lt;/a&gt; ). Если вы не хотите, чтобы раскладка клавиатуры работала как меню, не указывайте для нее строку приглашения.</target>
        </trans-unit>
        <trans-unit id="14b25b9720e3a5abd52e30eefdd4ec23c3d93327" translate="yes" xml:space="preserve">
          <source>The easiest way to insert and manipulate links is to use the &lt;code&gt;button&lt;/code&gt; package. See &lt;a href=&quot;buttons#Buttons&quot;&gt;Buttons&lt;/a&gt;. In this section, we will explain how to manually set up clickable text in a buffer, using text properties. For simplicity, we will refer to the clickable text as a &lt;em&gt;link&lt;/em&gt;.</source>
          <target state="translated">Самый простой способ вставлять ссылки и манипулировать ими - использовать пакет &lt;code&gt;button&lt;/code&gt; . См. &lt;a href=&quot;buttons#Buttons&quot;&gt;Кнопки&lt;/a&gt; . В этом разделе мы объясним, как вручную настроить интерактивный текст в буфере, используя свойства текста. Для простоты мы будем называть интерактивный текст &lt;em&gt;ссылкой&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="adefbbe3ec3b1c020185f3ff9029cdd73908a5c0" translate="yes" xml:space="preserve">
          <source>The easiest way to make a string with text properties is with &lt;code&gt;propertize&lt;/code&gt;:</source>
          <target state="translated">Самый простой способ создать строку с текстовыми свойствами - использовать &lt;code&gt;propertize&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="21ee8bf0f869856280213273b1b77146340d0758" translate="yes" xml:space="preserve">
          <source>The easiest way to mark a function as obsolete is to put a &lt;code&gt;(declare (obsolete &amp;hellip;))&lt;/code&gt; form in the function&amp;rsquo;s &lt;code&gt;defun&lt;/code&gt; definition. See &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;. Alternatively, you can use the &lt;code&gt;make-obsolete&lt;/code&gt; function, described below.</source>
          <target state="translated">Самый простой способ пометить функцию как устаревшую - это поместить форму &lt;code&gt;(declare (obsolete &amp;hellip;))&lt;/code&gt; в определение функции &lt;code&gt;defun&lt;/code&gt; . См. &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Форму объявления&lt;/a&gt; . В качестве альтернативы вы можете использовать функцию &lt;code&gt;make-obsolete&lt;/code&gt; , описанную ниже.</target>
        </trans-unit>
        <trans-unit id="e578edece4b9081d5686e88591733ede2ce224d7" translate="yes" xml:space="preserve">
          <source>The easiest way to write a major mode is to use the macro &lt;code&gt;define-derived-mode&lt;/code&gt;, which sets up the new mode as a variant of an existing major mode. See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;. We recommend using &lt;code&gt;define-derived-mode&lt;/code&gt; even if the new mode is not an obvious derivative of another mode, as it automatically enforces many coding conventions for you. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;, for common modes to derive from.</source>
          <target state="translated">Самый простой способ написать основной режим - использовать макрос &lt;code&gt;define-derived-mode&lt;/code&gt; , который устанавливает новый режим как вариант существующего основного режима. См. &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Производные режимы&lt;/a&gt; . Мы рекомендуем использовать &lt;code&gt;define-derived-mode&lt;/code&gt; даже если новый режим не является очевидным производным от другого режима, поскольку он автоматически обеспечивает соблюдение многих соглашений о кодировании. См. Раздел &amp;laquo; &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Основные основные режимы&amp;raquo;&lt;/a&gt; , чтобы получить сведения об общих режимах.</target>
        </trans-unit>
        <trans-unit id="d3ecb997307ce78019c7f2cc8553cc19a83270a2" translate="yes" xml:space="preserve">
          <source>The editor command loop automatically calls &lt;code&gt;undo-boundary&lt;/code&gt; just before executing each key sequence, so that each undo normally undoes the effects of one command. A few exceptional commands are &lt;em&gt;amalgamating&lt;/em&gt;: these commands generally cause small changes to buffers, so with these a boundary is inserted only every 20th command, allowing the changes to be undone as a group. By default, the commands &lt;code&gt;self-insert-command&lt;/code&gt;, which produces self-inserting input characters (see &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;Commands for Insertion&lt;/a&gt;), and &lt;code&gt;delete-char&lt;/code&gt;, which deletes characters (see &lt;a href=&quot;deletion#Deletion&quot;&gt;Deletion&lt;/a&gt;), are amalgamating. Where a command affects the contents of several buffers, as may happen, for example, when a function on the &lt;code&gt;post-command-hook&lt;/code&gt; affects a buffer other than the &lt;code&gt;current-buffer&lt;/code&gt;, then &lt;code&gt;undo-boundary&lt;/code&gt; will be called in each of the affected buffers.</source>
          <target state="translated">Командный цикл редактора автоматически вызывает &lt;code&gt;undo-boundary&lt;/code&gt; непосредственно перед выполнением каждой последовательности клавиш, так что каждая отмена обычно отменяет действие одной команды. Несколько исключительных команд &lt;em&gt;объединяются&lt;/em&gt; : эти команды обычно вызывают небольшие изменения в буферах, поэтому с ними граница вставляется только каждую 20-ю команду, что позволяет отменить изменения как группу. По умолчанию команды &lt;code&gt;self-insert-command&lt;/code&gt; , производящие вводимые символы самостоятельно (см. &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;Команды для вставки&lt;/a&gt; ), и &lt;code&gt;delete-char&lt;/code&gt; , удаляющие символы (см. &lt;a href=&quot;deletion#Deletion&quot;&gt;Удаление&lt;/a&gt; ), объединяются. Если команда влияет на содержимое нескольких буферов, что может произойти, например, когда функция в &lt;code&gt;post-command-hook&lt;/code&gt; воздействует на буфер, отличный от &lt;code&gt;current-buffer&lt;/code&gt; , тогда в каждом из затронутых буферов будет вызываться &lt;code&gt;undo-boundary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6175dd788a5ec79d9f8f9e1ade63289de866ae73" translate="yes" xml:space="preserve">
          <source>The editor command loop reads key sequences using the function &lt;code&gt;read-key-sequence&lt;/code&gt;, which uses &lt;code&gt;read-event&lt;/code&gt;. These and other functions for event input are also available for use in Lisp programs. See also &lt;code&gt;momentary-string-display&lt;/code&gt; in &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;, and &lt;code&gt;sit-for&lt;/code&gt; in &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;. See &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;, for functions and variables for controlling terminal input modes and debugging terminal input.</source>
          <target state="translated">Цикл команд редактора считывает последовательности клавиш с помощью функции &lt;code&gt;read-key-sequence&lt;/code&gt; , которая использует &lt;code&gt;read-event&lt;/code&gt; . Эти и другие функции для ввода событий также доступны для использования в программах на Лиспе. Смотрите также &lt;code&gt;momentary-string-display&lt;/code&gt; в &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt; , и &lt;code&gt;sit-for&lt;/code&gt; в &lt;a href=&quot;waiting#Waiting&quot;&gt;ожидании&lt;/a&gt; . См. &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Терминальный ввод&lt;/a&gt; , где описаны функции и переменные для управления режимами ввода терминала и отладки ввода терминала.</target>
        </trans-unit>
        <trans-unit id="b769abdeba8adfc9ee85136ec1467551431d0212" translate="yes" xml:space="preserve">
          <source>The editor command loop sets several Lisp variables to keep status records for itself and for commands that are run. With the exception of &lt;code&gt;this-command&lt;/code&gt; and &lt;code&gt;last-command&lt;/code&gt; it&amp;rsquo;s generally a bad idea to change any of these variables in a Lisp program.</source>
          <target state="translated">Командный цикл редактора устанавливает несколько переменных Лиспа для хранения записей состояния для себя и для выполняемых команд. За исключением &lt;code&gt;this-command&lt;/code&gt; и &lt;code&gt;last-command&lt;/code&gt; , обычно плохая идея изменять любую из этих переменных в программе на Лиспе.</target>
        </trans-unit>
        <trans-unit id="67b5a363399c8d1cc2c7c2647d77f745ef5552bd" translate="yes" xml:space="preserve">
          <source>The effect is that this keymap inherits all the bindings of &lt;var&gt;parent-keymap&lt;/var&gt;, whatever they may be at the time a key is looked up, but can add to them or override them with &lt;var&gt;elements&lt;/var&gt;.</source>
          <target state="translated">Эффект состоит в том, что эта таблица ключей наследует все привязки &lt;var&gt;parent-keymap&lt;/var&gt; , какими бы они ни были во время поиска ключа, но может добавлять к ним или заменять их &lt;var&gt;elements&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="591769f891f8125425d2075adee208efc1bbcaaa" translate="yes" xml:space="preserve">
          <source>The effect of &lt;code&gt;debug&lt;/code&gt; here is only to prevent &lt;code&gt;condition-case&lt;/code&gt; from suppressing the call to the debugger. Any given error will invoke the debugger only if &lt;code&gt;debug-on-error&lt;/code&gt; and the other usual filtering mechanisms say it should. See &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;.</source>
          <target state="translated">Эффект &lt;code&gt;debug&lt;/code&gt; здесь только для предотвращения подавления вызова отладчика &lt;code&gt;condition-case&lt;/code&gt; . Любая данная ошибка вызовет отладчик только в том случае, если &lt;code&gt;debug-on-error&lt;/code&gt; и другие обычные механизмы фильтрации говорят, что это необходимо. См. &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Отладка ошибок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2140fa127d13bbd573539409dfa58bf7787589bd" translate="yes" xml:space="preserve">
          <source>The effective user ID of the user who invoked the process. The corresponding &lt;var&gt;value&lt;/var&gt; is a number. If the process was invoked by the same user who runs the current Emacs session, the value is identical to what &lt;code&gt;user-uid&lt;/code&gt; returns (see &lt;a href=&quot;user-identification#User-Identification&quot;&gt;User Identification&lt;/a&gt;).</source>
          <target state="translated">Эффективный идентификатор пользователя, запустившего процесс. Соответствующее &lt;var&gt;value&lt;/var&gt; - число. Если процесс был запущен тем же пользователем, который запускает текущий сеанс Emacs, значение идентично тому, что возвращает &lt;code&gt;user-uid&lt;/code&gt; (см. &lt;a href=&quot;user-identification#User-Identification&quot;&gt;Идентификация пользователя&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="054dbf07fdb389c2141619772a29e0e605f543c4" translate="yes" xml:space="preserve">
          <source>The element &lt;var&gt;position&lt;/var&gt; is a list describing the position of the event, in the same format as used in a mouse-click event (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), and &lt;var&gt;files&lt;/var&gt; is the list of file names that were dragged and dropped. The usual way to handle this event is by visiting these files.</source>
          <target state="translated">&lt;var&gt;position&lt;/var&gt; элемента - это список, описывающий позицию события, в том же формате, который используется в событии щелчка мышью (см. &lt;a href=&quot;click-events#Click-Events&quot;&gt;События щелчка&lt;/a&gt; ), а &lt;var&gt;files&lt;/var&gt; - это список имен файлов, которые были перетащены. Обычный способ обработать это событие - посетить эти файлы.</target>
        </trans-unit>
        <trans-unit id="39de66e9c3f4b1f00f3f70922dee79dd2890c1eb" translate="yes" xml:space="preserve">
          <source>The elements &lt;code&gt;left-fringe&lt;/code&gt;, &lt;code&gt;right-fringe&lt;/code&gt;, &lt;code&gt;left-margin&lt;/code&gt;, &lt;code&gt;right-margin&lt;/code&gt;, &lt;code&gt;scroll-bar&lt;/code&gt;, and &lt;code&gt;text&lt;/code&gt; specify the width of the corresponding area of the window. When the window displays line numbers (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;), the width of the &lt;code&gt;text&lt;/code&gt; area is decreased by the screen space taken by the line-number display.</source>
          <target state="translated">Элементы &lt;code&gt;left-fringe&lt;/code&gt; , &lt;code&gt;right-fringe&lt;/code&gt; , &lt;code&gt;left-margin&lt;/code&gt; , &lt;code&gt;right-margin&lt;/code&gt; , &lt;code&gt;scroll-bar&lt;/code&gt; и &lt;code&gt;text&lt;/code&gt; определяют ширину соответствующей области окна. Когда в окне отображаются номера строк (см. &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Размер отображаемого текста&lt;/a&gt; ), ширина &lt;code&gt;text&lt;/code&gt; области уменьшается на экранное пространство, занимаемое отображением номера строки.</target>
        </trans-unit>
        <trans-unit id="c19e4ee125f09b12484bc3bf030c6cee2240307a" translate="yes" xml:space="preserve">
          <source>The elements &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are integers, and together specify a range of indices in the string; &lt;var&gt;plist&lt;/var&gt; is the property list for that range. For example,</source>
          <target state="translated">Элементы &lt;var&gt;beg&lt;/var&gt; in и &lt;var&gt;end&lt;/var&gt; являются целыми числами и вместе определяют диапазон индексов в строке; &lt;var&gt;plist&lt;/var&gt; - это список свойств для этого диапазона. Например,</target>
        </trans-unit>
        <trans-unit id="819edd219dab7009427b8b49d18302d9e0dce52d" translate="yes" xml:space="preserve">
          <source>The elements of an array may be referenced or changed with the functions &lt;code&gt;aref&lt;/code&gt; and &lt;code&gt;aset&lt;/code&gt;, respectively (see &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Array Functions&lt;/a&gt;).</source>
          <target state="translated">На элементы массива можно ссылаться или изменять их с помощью функций &lt;code&gt;aref&lt;/code&gt; и &lt;code&gt;aset&lt;/code&gt; соответственно (см. &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Функции массива&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f5842ceb731b62f33d895e3247a64f0979807eb" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;command-switch-alist&lt;/code&gt; look like this:</source>
          <target state="translated">Элементы &lt;code&gt;command-switch-alist&lt;/code&gt; выглядят так:</target>
        </trans-unit>
        <trans-unit id="1f8aa67132fef0998682c755d2d95f66a05ef6fd" translate="yes" xml:space="preserve">
          <source>The elements of the alist are ordered so that the &lt;var&gt;key&lt;/var&gt; increases in length. The first element is always &lt;code&gt;([] . &lt;var&gt;keymap&lt;/var&gt;)&lt;/code&gt;, because the specified keymap is accessible from itself with a prefix of no events.</source>
          <target state="translated">Элементы списка расположены так, что длина &lt;var&gt;key&lt;/var&gt; увеличивается. Первым элементом всегда является &lt;code&gt;([] . &lt;var&gt;keymap&lt;/var&gt;)&lt;/code&gt; , потому что указанная таблица ключей доступна из себя с префиксом отсутствия событий.</target>
        </trans-unit>
        <trans-unit id="bb682157302be72c8e42a6b49f1e7cf04e43ecde" translate="yes" xml:space="preserve">
          <source>The elements of the list describe the types of the arguments of a calling form. The possible elements of a specification list are described in the following sections.</source>
          <target state="translated">Элементы списка описывают типы аргументов вызывающей формы.Возможные элементы спецификационного списка описаны в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="0572510e8d9760b2ddeeb43410bcfcd96d01ed05" translate="yes" xml:space="preserve">
          <source>The elements of the list, in order, are:</source>
          <target state="translated">Элементы списка расположены по порядку:</target>
        </trans-unit>
        <trans-unit id="fdd58fe0f1c0198924c53540b3cf5d2e3265fcff" translate="yes" xml:space="preserve">
          <source>The end of a key sequence is detected when that key sequence either is bound to a command, or when Emacs determines that no additional event can lead to a sequence that is bound to a command.</source>
          <target state="translated">Конец последовательности ключей обнаруживается,когда эта последовательность ключей либо привязана к команде,либо когда Emacs определяет,что никакое дополнительное событие не может привести к последовательности,которая привязана к команде.</target>
        </trans-unit>
        <trans-unit id="3c6ae9a7bf2d6a50e19bef0d7e64a8b9acd8c0d0" translate="yes" xml:space="preserve">
          <source>The environment variable name is the series of alphanumeric characters (including underscores) that follow the &amp;lsquo;</source>
          <target state="translated">Имя переменной среды представляет собой серию буквенно-цифровых символов (включая символы подчеркивания), которые следуют за символом '</target>
        </trans-unit>
        <trans-unit id="3b59d11b9a544f51d2f70a6e20d15c14a62127ce" translate="yes" xml:space="preserve">
          <source>The equality tests use &lt;code&gt;eql&lt;/code&gt;.</source>
          <target state="translated">В тестах на равенство используется &lt;code&gt;eql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32741737ac9bfd8a3c48ea4752a47b7630b57432" translate="yes" xml:space="preserve">
          <source>The equivalences table maps each one of a set of case-related characters into the next character in that set.</source>
          <target state="translated">Таблица эквивалентов сопоставляет каждый из набора символов,связанных с регистром,со следующим символом в этом наборе.</target>
        </trans-unit>
        <trans-unit id="52b719d4135d0c266c0f2bf15ce2d2663180f53c" translate="yes" xml:space="preserve">
          <source>The error message for this error looks like this:</source>
          <target state="translated">Сообщение об ошибке выглядит так:</target>
        </trans-unit>
        <trans-unit id="8003c4b046bb80fba143c9330ff6bd66ac7fbc19" translate="yes" xml:space="preserve">
          <source>The error string should start with a capital letter but it should not end with a period. This is for consistency with the rest of Emacs.</source>
          <target state="translated">Строка ошибки должна начинаться с большой буквы,но не должна заканчиваться периодом.Это для согласованности с остальными Emacs.</target>
        </trans-unit>
        <trans-unit id="7b8cbe15ec1efdbd3cf5c2578bd1e52ef550cbd8" translate="yes" xml:space="preserve">
          <source>The event type of a double-click event contains the prefix &amp;lsquo;</source>
          <target state="translated">Тип события для события двойного щелчка содержит префикс '</target>
        </trans-unit>
        <trans-unit id="e2a9fed30f47fc30631b38b43fbe44a5b00c8585" translate="yes" xml:space="preserve">
          <source>The event type of a function key event is the event symbol itself. See &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;Classifying Events&lt;/a&gt;.</source>
          <target state="translated">Тип события события функциональной клавиши - это сам символ события. См. &amp;laquo; &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;Классификация событий&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46f0d795e1cfdd0fd1c184633351122a8cb62235" translate="yes" xml:space="preserve">
          <source>The event-reading functions invoke the current input method, if any (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;). If the value of &lt;code&gt;input-method-function&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function; when &lt;code&gt;read-event&lt;/code&gt; reads a printing character (including</source>
          <target state="translated">Функции чтения событий вызывают текущий метод ввода, если таковой имеется (см. &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Методы ввода&lt;/a&gt; ). Если значение &lt;code&gt;input-method-function&lt;/code&gt; не равно &lt;code&gt;nil&lt;/code&gt; , это должна быть функция; когда &lt;code&gt;read-event&lt;/code&gt; чтения читает печатный символ (включая</target>
        </trans-unit>
        <trans-unit id="c10bb80d00486007c951e5ce70467305dbc1efa0" translate="yes" xml:space="preserve">
          <source>The events types &lt;code&gt;iconify-frame&lt;/code&gt;, &lt;code&gt;make-frame-visible&lt;/code&gt;, &lt;code&gt;delete-frame&lt;/code&gt;, &lt;code&gt;drag-n-drop&lt;/code&gt;, &lt;code&gt;language-change&lt;/code&gt;, and user signals like &lt;code&gt;sigusr1&lt;/code&gt; are normally handled in this way. The keymap which defines how to handle special events&amp;mdash;and which events are special&amp;mdash;is in the variable &lt;code&gt;special-event-map&lt;/code&gt; (see &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;).</source>
          <target state="translated">Типы событий &lt;code&gt;iconify-frame&lt;/code&gt; , &lt;code&gt;make-frame-visible&lt;/code&gt; , &lt;code&gt;delete-frame&lt;/code&gt; , &lt;code&gt;drag-n-drop&lt;/code&gt; , &lt;code&gt;language-change&lt;/code&gt; и пользовательские сигналы, такие как &lt;code&gt;sigusr1&lt;/code&gt; , обычно обрабатываются таким образом. Таблица клавиш, которая определяет, как обрабатывать особые события - и какие события являются особенными - находится в переменной &lt;code&gt;special-event-map&lt;/code&gt; (см. &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Управление активными картами&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2164e9087e02837e91965cf6aa67235eeccbe4f2" translate="yes" xml:space="preserve">
          <source>The events used so far in the lookup form a complete key, and &lt;var&gt;command&lt;/var&gt; is its binding. See &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;.</source>
          <target state="translated">События, использованные до сих пор в поиске, образуют полный ключ, а &lt;var&gt;command&lt;/var&gt; является его привязкой. См. &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;Что такое функция&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b95399d88e6119154daacebbe8a8379841fe6c4" translate="yes" xml:space="preserve">
          <source>The events used so far in the lookup form a prefix key. The next event of the key sequence is looked up in &lt;var&gt;keymap&lt;/var&gt;.</source>
          <target state="translated">События, использованные до сих пор в поиске, образуют префиксный ключ. Следующее событие ключевой последовательности &lt;var&gt;keymap&lt;/var&gt; в раскладке клавиш .</target>
        </trans-unit>
        <trans-unit id="70cf466181ddda55879b8d247515909cac59befd" translate="yes" xml:space="preserve">
          <source>The exact behavior when using a graphical file dialog is platform-dependent. Here, we simply document the behavior when using the minibuffer.</source>
          <target state="translated">Точное поведение при использовании графического файлового диалога зависит от платформы.Здесь мы просто документируем поведение при использовании минибуфера.</target>
        </trans-unit>
        <trans-unit id="e1783ae90f7011d91125735b7e7f0336f43088d0" translate="yes" xml:space="preserve">
          <source>The exact rules are that at the beginning of a regexp, &amp;lsquo;</source>
          <target state="translated">Точные правила таковы: в начале регулярного выражения '</target>
        </trans-unit>
        <trans-unit id="9d0825e8976bc9a5de722249e68385f249965ce0" translate="yes" xml:space="preserve">
          <source>The examples below use the characters &amp;lsquo;</source>
          <target state="translated">В приведенных ниже примерах используются символы '</target>
        </trans-unit>
        <trans-unit id="103a1f6fa6f3ce096ff2216407f0ee23d1e12e82" translate="yes" xml:space="preserve">
          <source>The expansion should evaluate each macro arg once.</source>
          <target state="translated">Расширение должно оценивать каждый макросодержатель один раз.</target>
        </trans-unit>
        <trans-unit id="143e736dc0ea57164827c20116a0aca1e23342fe" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(require 'comint)&lt;/code&gt; loads the file</source>
          <target state="translated">Выражение &lt;code&gt;(require 'comint)&lt;/code&gt; загружает файл</target>
        </trans-unit>
        <trans-unit id="860aceea4a994059f4b9c519435309d2edcc7bcc" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(sit-for 0)&lt;/code&gt; is equivalent to &lt;code&gt;(redisplay)&lt;/code&gt;, i.e., it requests a redisplay, without any delay, if there is no pending input. See &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;Forcing Redisplay&lt;/a&gt;.</source>
          <target state="translated">Выражение &lt;code&gt;(sit-for 0)&lt;/code&gt; эквивалентно &lt;code&gt;(redisplay)&lt;/code&gt; , т. Е. Оно запрашивает повторное отображение без какой-либо задержки, если нет ожидающих ввода. См. &amp;laquo; &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;Принудительное повторное отображение&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="918f1833b3bdbe7be1276b1a8696214692e3b6ef" translate="yes" xml:space="preserve">
          <source>The expression &lt;var&gt;standard&lt;/var&gt; can be evaluated at various other times, too&amp;mdash;whenever the customization facility needs to know &lt;var&gt;option&lt;/var&gt;&amp;rsquo;s standard value. So be sure to use an expression which is harmless to evaluate at any time.</source>
          <target state="translated">Выражение &lt;var&gt;standard&lt;/var&gt; может быть оценен в различных других случаях, слишком когда настройка объект необходимо знать &lt;var&gt;option&lt;/var&gt; &amp;laquo;s стандартное значение. Поэтому обязательно используйте выражение, которое безобидно оценивать в любое время.</target>
        </trans-unit>
        <trans-unit id="e99a19bec0a84ecbd6e03a29490ce71aa3b4a055" translate="yes" xml:space="preserve">
          <source>The expressions you enter interactively (and their results) are lost when you continue execution; but you can set up an &lt;em&gt;evaluation list&lt;/em&gt; consisting of expressions to be evaluated each time execution stops.</source>
          <target state="translated">Выражения, которые вы вводите интерактивно (и их результаты), теряются при продолжении выполнения; но вы можете настроить &lt;em&gt;список оценки,&lt;/em&gt; состоящий из выражений, которые будут оцениваться каждый раз при остановке выполнения.</target>
        </trans-unit>
        <trans-unit id="acb0941a66e54ab62147b1a507de3916f48108a1" translate="yes" xml:space="preserve">
          <source>The extra arguments &lt;var&gt;arguments&lt;/var&gt; specify the attributes to set, and the values for them. They should consist of alternating attribute names (such as &lt;code&gt;:family&lt;/code&gt; or &lt;code&gt;:underline&lt;/code&gt;) and values. Thus,</source>
          <target state="translated">Дополнительные аргументы &lt;var&gt;arguments&lt;/var&gt; задать атрибуты для набора и значение для них. Они должны состоять из чередующихся имен атрибутов (таких как &lt;code&gt;:family&lt;/code&gt; или &lt;code&gt;:underline&lt;/code&gt; ) и значений. Таким образом,</target>
        </trans-unit>
        <trans-unit id="a7526765bc7635e644a9c02766e092ebdc6743ea" translate="yes" xml:space="preserve">
          <source>The extra table &lt;var&gt;canonicalize&lt;/var&gt; maps each character to a canonical equivalent; any two characters that are related by case-conversion have the same canonical equivalent character. For example, since &amp;lsquo;</source>
          <target state="translated">Дополнительная таблица &lt;var&gt;canonicalize&lt;/var&gt; отображает каждый символ в канонический эквивалент; любые два символа, связанных преобразованием регистра, имеют один и тот же канонический эквивалентный символ. Например, поскольку '</target>
        </trans-unit>
        <trans-unit id="4019803adf73bb1e408bce642878a6814f7ac48a" translate="yes" xml:space="preserve">
          <source>The extra table &lt;var&gt;equivalences&lt;/var&gt; is a map that cyclically permutes each equivalence class (of characters with the same canonical equivalent). (For ordinary</source>
          <target state="translated">&lt;var&gt;equivalences&lt;/var&gt; дополнительных таблиц - это карта, которая циклически переставляет каждый класс эквивалентности (символов с одним и тем же каноническим эквивалентом). (Для обычных</target>
        </trans-unit>
        <trans-unit id="d052c0df805ee1e73aad2615fef93dab0ce7e859" translate="yes" xml:space="preserve">
          <source>The face &lt;var&gt;face&lt;/var&gt; was defined.</source>
          <target state="translated">Лицо &lt;var&gt;face&lt;/var&gt; было определено.</target>
        </trans-unit>
        <trans-unit id="07cf6c9593efbd571e9c6bc6592f49d62f4691d2" translate="yes" xml:space="preserve">
          <source>The faces are listed with descriptions of their typical usage, and in order of greater to lesser prominence. If a mode&amp;rsquo;s syntactic categories do not fit well with the usage descriptions, the faces can be assigned using the ordering as a guide.</source>
          <target state="translated">Лица перечислены с описанием их типичного использования в порядке возрастания значимости. Если синтаксические категории режима не соответствуют описаниям использования, лица можно назначить, используя порядок в качестве руководства.</target>
        </trans-unit>
        <trans-unit id="3adedd7760a2da26b8105efc074b6a1a33143e97" translate="yes" xml:space="preserve">
          <source>The feature &lt;var&gt;feature&lt;/var&gt; was provided.</source>
          <target state="translated">Функция &lt;var&gt;feature&lt;/var&gt; была предоставлена.</target>
        </trans-unit>
        <trans-unit id="5684eb8ff3a533e9acfb4f148b31be6cf5c33b8f" translate="yes" xml:space="preserve">
          <source>The feature &lt;var&gt;feature&lt;/var&gt; was required.</source>
          <target state="translated">Требуется функция &lt;var&gt;feature&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="70390d43913607356ec3483eaaea0f10e086c2b4" translate="yes" xml:space="preserve">
          <source>The fields of a process (for a complete list, see the definition of &lt;code&gt;struct Lisp_Process&lt;/code&gt; in</source>
          <target state="translated">Поля процесса (полный список см. В определении &lt;code&gt;struct Lisp_Process&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="f16afc33ed846d12b97600fcfe0ed162892cfbb4" translate="yes" xml:space="preserve">
          <source>The fields of a window (for a complete list, see the definition of &lt;code&gt;struct window&lt;/code&gt; in</source>
          <target state="translated">Поля окна (полный список см. В определении &lt;code&gt;struct window&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="14ce59edc1be8242ff84e768676f78ed344512ee" translate="yes" xml:space="preserve">
          <source>The fifth argument &lt;var&gt;copy-contents&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to copy the contents of &lt;var&gt;dirname&lt;/var&gt; directly into &lt;var&gt;newname&lt;/var&gt; if the latter is a directory name, instead of copying &lt;var&gt;dirname&lt;/var&gt; into it as a subdirectory.</source>
          <target state="translated">Пятый аргумент &lt;var&gt;copy-contents&lt;/var&gt; , если не &lt;code&gt;nil&lt;/code&gt; , означает копирование содержимого &lt;var&gt;dirname&lt;/var&gt; непосредственно в &lt;var&gt;newname&lt;/var&gt; , если последнее является именем каталога, вместо копирования &lt;var&gt;dirname&lt;/var&gt; в него как подкаталог.</target>
        </trans-unit>
        <trans-unit id="dcfbbcf90dfb29480dabe34cba14a8aa961dc30c" translate="yes" xml:space="preserve">
          <source>The fifth argument, &lt;var&gt;no-remap&lt;/var&gt;, determines how this function treats command remappings (see &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;). There are two cases of interest:</source>
          <target state="translated">Пятый аргумент, &lt;var&gt;no-remap&lt;/var&gt; , определяет, как эта функция обрабатывает переназначения команд (см. &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Команды&lt;/a&gt; переназначения ). Есть два интересных случая:</target>
        </trans-unit>
        <trans-unit id="56bd5499d60d7cc9296335a519b5d67af9c7d7ca" translate="yes" xml:space="preserve">
          <source>The fifth of these hooks is run when a &lt;em&gt;window configuration change&lt;/em&gt; has been detected which means that either the buffer or the size of a window changed. It differs from the four preceding hooks in the way it is run.</source>
          <target state="translated">Пятый из этих хуков запускается, когда обнаруживается &lt;em&gt;изменение конфигурации окна,&lt;/em&gt; что означает, что изменился либо буфер, либо размер окна. Он отличается от четырех предыдущих крючков тем, как работает.</target>
        </trans-unit>
        <trans-unit id="97f57dbba7d52a111e94fa33d8036bc6b350fb92" translate="yes" xml:space="preserve">
          <source>The file descriptor for input from the process.</source>
          <target state="translated">Файловый дескриптор для ввода из процесса.</target>
        </trans-unit>
        <trans-unit id="36604991f22732ab7544e1de9b5cbc643ee537e4" translate="yes" xml:space="preserve">
          <source>The file descriptor for output to the process.</source>
          <target state="translated">Файловый дескриптор для вывода в процесс.</target>
        </trans-unit>
        <trans-unit id="9f84eaecd4c1e8e57755faa13303bc7e7b03876f" translate="yes" xml:space="preserve">
          <source>The file name of the font as a string. This can be &lt;code&gt;nil&lt;/code&gt; if the font back-end does not provide a way to find out the font&amp;rsquo;s file name.</source>
          <target state="translated">Имя файла шрифта в виде строки. Это может быть &lt;code&gt;nil&lt;/code&gt; если серверная часть шрифта не предоставляет способ узнать имя файла шрифта.</target>
        </trans-unit>
        <trans-unit id="f32ef79257eb8ddf49002ec15d79f408c3bb5192" translate="yes" xml:space="preserve">
          <source>The file name of the notification icon. If set to &lt;code&gt;nil&lt;/code&gt;, no icon is displayed. The default is &lt;code&gt;notifications-application-icon&lt;/code&gt;.</source>
          <target state="translated">Имя файла значка уведомления. Если установлено значение &lt;code&gt;nil&lt;/code&gt; , значок не отображается. По умолчанию это &lt;code&gt;notifications-application-icon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c16e8ffefdfcb982bf11b0e3b2389776157f73d" translate="yes" xml:space="preserve">
          <source>The file ought to also contain one or more autoload magic comments, as explained in &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;Packaging Basics&lt;/a&gt;. In the above example, a magic comment autoloads &lt;code&gt;superfrobnicator-mode&lt;/code&gt;.</source>
          <target state="translated">Файл также должен содержать один или несколько магических комментариев автозагрузки, как описано в &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;разделе &amp;laquo;Основы упаковки&amp;raquo;&lt;/a&gt; . В приведенном выше примере волшебный комментарий автоматически &lt;code&gt;superfrobnicator-mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdc9cfc759343b8d06deb729dbcb7ad07ecd770e" translate="yes" xml:space="preserve">
          <source>The file&amp;rsquo;s</source>
          <target state="translated">Файлы</target>
        </trans-unit>
        <trans-unit id="0fae8d03319845dad144dc1c7674908715fd1d6a" translate="yes" xml:space="preserve">
          <source>The file&amp;rsquo;s inode number (&lt;code&gt;file-attribute-inode-number&lt;/code&gt;), a nonnegative integer.</source>
          <target state="translated">Номер inode &lt;code&gt;file-attribute-inode-number&lt;/code&gt; ( file-attribute-inode-number ), неотрицательное целое число.</target>
        </trans-unit>
        <trans-unit id="5cd0cae54bf749d964c2e3a85496f50dbb2f4390" translate="yes" xml:space="preserve">
          <source>The file&amp;rsquo;s modes, as a string of ten letters or dashes, as in &amp;lsquo;</source>
          <target state="translated">Режимы файла в виде строки из десяти букв или тире, например '</target>
        </trans-unit>
        <trans-unit id="b8b5bfed28aef3a1155a21532be86f3c1a999048" translate="yes" xml:space="preserve">
          <source>The filesystem number of the device that the file is on &lt;code&gt;file-attribute-device-number&lt;/code&gt;), an integer. This element and the file&amp;rsquo;s inode number together give enough information to distinguish any two files on the system&amp;mdash;no two files can have the same values for both of these numbers.</source>
          <target state="translated">Номер файловой системы устройства, на котором находится &lt;code&gt;file-attribute-device-number&lt;/code&gt; ), целое число. Этот элемент и номер inode файла вместе дают достаточно информации, чтобы различать любые два файла в системе - никакие два файла не могут иметь одинаковые значения для обоих этих номеров.</target>
        </trans-unit>
        <trans-unit id="9d1fb04dc7a2116b55da5d8efea1baf1fed3eb1e" translate="yes" xml:space="preserve">
          <source>The fill prefix follows the left margin whitespace, if any.</source>
          <target state="translated">Префикс заполнения следует за пробелом левого поля,если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="cea1ef8b331e237b03da44fbd464cdb2d950b871" translate="yes" xml:space="preserve">
          <source>The final thing this command does is to run the hook &lt;code&gt;post-self-insert-hook&lt;/code&gt;. You could use this to automatically reindent text as it is typed, for example. If any function on this hook needs to act on the region (see &lt;a href=&quot;the-region#The-Region&quot;&gt;The Region&lt;/a&gt;), it should make sure Delete Selection mode (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Using-Region.html#Using-Region&quot;&gt;Delete Selection&lt;/a&gt; in</source>
          <target state="translated">Последнее, что делает эта команда, - запускает хук &lt;code&gt;post-self-insert-hook&lt;/code&gt; . Вы можете использовать это, например, для автоматического изменения отступов текста при вводе. Если какая-либо функция на этом хуке должна воздействовать на область (см &lt;a href=&quot;the-region#The-Region&quot;&gt;. Регион&lt;/a&gt; ), она должна убедиться, что режим удаления выделения (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Using-Region.html#Using-Region&quot;&gt;Удалить выделение&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="c1d3c86385f345c5bc7cf463d494da758eaabee6" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;n&lt;/code&gt; binds it to &lt;var&gt;expval&lt;/var&gt;, i.e., the result of evaluating &lt;code&gt;(* 3 3)&lt;/code&gt;, or 9.</source>
          <target state="translated">Первое &lt;code&gt;n&lt;/code&gt; связывает его с &lt;var&gt;expval&lt;/var&gt; , т. Е. Результатом вычисления &lt;code&gt;(* 3 3)&lt;/code&gt; или 9.</target>
        </trans-unit>
        <trans-unit id="41a0ddbc0dd4de61e99ae8c86c48d424b9ae51cb" translate="yes" xml:space="preserve">
          <source>The first &lt;var&gt;number&lt;/var&gt; arguments of the function are &lt;em&gt;distinguished&lt;/em&gt; arguments; the rest are considered the body of the expression. A line in the expression is indented according to whether the first argument on it is distinguished or not. If the argument is part of the body, the line is indented &lt;code&gt;lisp-body-indent&lt;/code&gt; more columns than the open-parenthesis starting the containing expression. If the argument is distinguished and is either the first or second argument, it is indented &lt;em&gt;twice&lt;/em&gt; that many extra columns. If the argument is distinguished and not the first or second argument, the line uses the standard pattern.</source>
          <target state="translated">Аргументы функции с первым &lt;var&gt;number&lt;/var&gt; являются &lt;em&gt;выделенными&lt;/em&gt; аргументами; остальные считаются телом выражения. Строка в выражении имеет отступ в зависимости от того, выделен ли в ней первый аргумент. Если аргумент является частью тела, строка имеет отступ &lt;code&gt;lisp-body-indent&lt;/code&gt; на большее количество столбцов, чем открывающая скобка, начинающая содержащее выражение. Если аргумент выделен и является первым или вторым аргументом, он имеет отступ &lt;em&gt;вдвое больше&lt;/em&gt; , чем количество дополнительных столбцов. Если выделяется аргумент, а не первый или второй аргумент, в строке используется стандартный шаблон.</target>
        </trans-unit>
        <trans-unit id="b6792de20ff613a589b600323a8f2769f8d4328f" translate="yes" xml:space="preserve">
          <source>The first argument given to &lt;var&gt;handler&lt;/var&gt; is the name of the primitive, as a symbol; the remaining arguments are the arguments that were passed to that primitive. (The first of these arguments is most often the file name itself.) For example, if you do this:</source>
          <target state="translated">Первый аргумент, передаваемый &lt;var&gt;handler&lt;/var&gt; - это имя примитива в виде символа; остальные аргументы - это аргументы, переданные этому примитиву. (Первым из этих аргументов чаще всего является само имя файла.) Например, если вы сделаете это:</target>
        </trans-unit>
        <trans-unit id="722b8b8e4de0471d30abd9c4cc7537deb8572c61" translate="yes" xml:space="preserve">
          <source>The first argument that Lisp hands to the function indicates why it was called. The convention for arguments is detailed in the description of &lt;code&gt;debug&lt;/code&gt; (see &lt;a href=&quot;invoking-the-debugger#Invoking-the-Debugger&quot;&gt;Invoking the Debugger&lt;/a&gt;).</source>
          <target state="translated">Первый аргумент, который Лисп передает функции, указывает, почему она была вызвана. Соглашение об аргументах подробно описано в описании &lt;code&gt;debug&lt;/code&gt; (см. &lt;a href=&quot;invoking-the-debugger#Invoking-the-Debugger&quot;&gt;Вызов отладчика&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2066145dc073e9f1dd57632ef58fcd8ec240493d" translate="yes" xml:space="preserve">
          <source>The first case indicates the basic indentation increment to use. If &lt;code&gt;sample-indent-basic&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, then SMIE uses the global setting &lt;code&gt;smie-indent-basic&lt;/code&gt;. The major mode could have set &lt;code&gt;smie-indent-basic&lt;/code&gt; buffer-locally instead, but that is discouraged.</source>
          <target state="translated">В первом случае указывается основной используемый приращение отступа. Если &lt;code&gt;sample-indent-basic&lt;/code&gt; равно &lt;code&gt;nil&lt;/code&gt; , то SMIE использует глобальную настройку &lt;code&gt;smie-indent-basic&lt;/code&gt; . &lt;code&gt;smie-indent-basic&lt;/code&gt; основном режиме можно было бы установить smie-indent-basic buffer- local , но это не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="9276082e8b3010c24531b975ec50bcbea5a7818a" translate="yes" xml:space="preserve">
          <source>The first character in a syntax descriptor must be a syntax class designator character. The second character, if present, specifies a matching character (e.g., in Lisp, the matching character for &amp;lsquo;</source>
          <target state="translated">Первый символ в дескрипторе синтаксиса должен быть символом указателя класса синтаксиса. Второй символ, если он присутствует, указывает соответствующий символ (например, в Лиспе соответствующий символ для '</target>
        </trans-unit>
        <trans-unit id="39c4836db6032a9af6b8895c19c4d302b908bde8" translate="yes" xml:space="preserve">
          <source>The first element of &lt;var&gt;menu&lt;/var&gt; must be a string, which serves as the menu label. It may be followed by any number of the following keyword-argument pairs:</source>
          <target state="translated">Первым элементом &lt;var&gt;menu&lt;/var&gt; должна быть строка, которая служит меткой меню. За ним может следовать любое количество следующих пар ключевое слово-аргумент:</target>
        </trans-unit>
        <trans-unit id="15d23f64cb15de341109c55ba69a978fb148aee5" translate="yes" xml:space="preserve">
          <source>The first element of a lambda expression is always the symbol &lt;code&gt;lambda&lt;/code&gt;. This indicates that the list represents a function. The reason functions are defined to start with &lt;code&gt;lambda&lt;/code&gt; is so that other lists, intended for other uses, will not accidentally be valid as functions.</source>
          <target state="translated">Первым элементом лямбда-выражения всегда является &lt;code&gt;lambda&lt;/code&gt; символ . Это указывает на то, что список представляет функцию. Причина, по которой функции должны начинаться с &lt;code&gt;lambda&lt;/code&gt; состоит в том, что другие списки, предназначенные для других целей, случайно не будут действительны как функции.</target>
        </trans-unit>
        <trans-unit id="68cf8f4ab59e90caee8f7fcdd176030805c02094" translate="yes" xml:space="preserve">
          <source>The first element of an array has index zero, the second element has index 1, and so on. This is called &lt;em&gt;zero-origin&lt;/em&gt; indexing. For example, an array of four elements has indices 0, 1, 2, and 3.</source>
          <target state="translated">Первый элемент массива имеет нулевой индекс, второй элемент имеет индекс 1 и так далее. Это называется индексированием с &lt;em&gt;нулевым происхождением&lt;/em&gt; . Например, массив из четырех элементов имеет индексы 0, 1, 2 и 3.</target>
        </trans-unit>
        <trans-unit id="51f338b4e98aac416f168cd0115601f42b7a93f5" translate="yes" xml:space="preserve">
          <source>The first element of an array has index zero, the second element has index 1, and so on. This is called &lt;em&gt;zero-origin&lt;/em&gt; indexing. For example, an array of four elements has indices 0, 1, 2, and 3. The largest possible index value is one less than the length of the array. Once an array is created, its length is fixed.</source>
          <target state="translated">Первый элемент массива имеет нулевой индекс, второй элемент имеет индекс 1 и так далее. Это называется индексированием с &lt;em&gt;нулевым происхождением&lt;/em&gt; . Например, массив из четырех элементов имеет индексы 0, 1, 2 и 3. Максимально возможное значение индекса на единицу меньше длины массива. После создания массива его длина фиксируется.</target>
        </trans-unit>
        <trans-unit id="2524e323ad39aadf65e6819494415de49cf36cc1" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;quit-restore&lt;/code&gt; parameter is one of the symbols &lt;code&gt;window&lt;/code&gt;, meaning that the window has been specially created by &lt;code&gt;display-buffer&lt;/code&gt;; &lt;code&gt;frame&lt;/code&gt;, a separate frame has been created; &lt;code&gt;same&lt;/code&gt;, the window has only ever displayed this buffer; or &lt;code&gt;other&lt;/code&gt;, the window showed another buffer before. &lt;code&gt;frame&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt; affect how the window is quit, while &lt;code&gt;same&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; affect the redisplay of buffers previously shown in &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">Первый элемент параметра &lt;code&gt;quit-restore&lt;/code&gt; - это один из символов &lt;code&gt;window&lt;/code&gt; , означающий, что окно было специально создано &lt;code&gt;display-buffer&lt;/code&gt; ; &lt;code&gt;frame&lt;/code&gt; , создана отдельная рамка; &lt;code&gt;same&lt;/code&gt; , окно когда-либо отображало только этот буфер; или &lt;code&gt;other&lt;/code&gt; , раньше окно показывало другой буфер. &lt;code&gt;frame&lt;/code&gt; и &lt;code&gt;window&lt;/code&gt; влияют на то, как закрывается окно, в то время как то &lt;code&gt;same&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; влияют на повторное отображение буферов, ранее показанных в &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f41cf4ec0e02e4a679662ba14fa7fdfffa94fd" translate="yes" xml:space="preserve">
          <source>The first element, &lt;var&gt;decoding-system&lt;/var&gt;, is the coding system to use for decoding (in case &lt;var&gt;operation&lt;/var&gt; does decoding), and &lt;var&gt;encoding-system&lt;/var&gt; is the coding system for encoding (in case &lt;var&gt;operation&lt;/var&gt; does encoding).</source>
          <target state="translated">Первый элемент, &lt;var&gt;decoding-system&lt;/var&gt; , - это система кодирования, используемая для декодирования (в случае, если &lt;var&gt;operation&lt;/var&gt; выполняет декодирование), а &lt;var&gt;encoding-system&lt;/var&gt; - это система кодирования для кодирования (в случае, если &lt;var&gt;operation&lt;/var&gt; выполняет кодирование).</target>
        </trans-unit>
        <trans-unit id="2cd75fb3bb07dce6a2ca619dd218795e581be875" translate="yes" xml:space="preserve">
          <source>The first element, &lt;var&gt;keywords&lt;/var&gt;, indirectly specifies the value of &lt;code&gt;font-lock-keywords&lt;/code&gt; which directs search-based fontification. It can be a symbol, a variable or a function whose value is the list to use for &lt;code&gt;font-lock-keywords&lt;/code&gt;. It can also be a list of several such symbols, one for each possible level of fontification. The first symbol specifies the &amp;lsquo;</source>
          <target state="translated">Первый элемент, &lt;var&gt;keywords&lt;/var&gt; , косвенно указывает значение &lt;code&gt;font-lock-keywords&lt;/code&gt; которое направляет фонтификацию на основе поиска. Это может быть символ, переменная или функция, значение которой является списком для использования &lt;code&gt;font-lock-keywords&lt;/code&gt; . Это также может быть список из нескольких таких символов, по одному для каждого возможного уровня фонификации. Первый символ указывает на '</target>
        </trans-unit>
        <trans-unit id="075cb4d42e18fef81945510253ddc7517a2a9450" translate="yes" xml:space="preserve">
          <source>The first five elements correspond to face attributes; if you specify these attributes for a face, it will use this font.</source>
          <target state="translated">Первые пять элементов соответствуют атрибутам лица;если вы укажете эти атрибуты для лица,он будет использовать этот шрифт.</target>
        </trans-unit>
        <trans-unit id="518177047b013c7ced390688d084d6c94e497b17" translate="yes" xml:space="preserve">
          <source>The first function in &lt;code&gt;completion-at-point-functions&lt;/code&gt; to return a non-&lt;code&gt;nil&lt;/code&gt; value is used by &lt;code&gt;completion-at-point&lt;/code&gt;. The remaining functions are not called. The exception to this is when there is an &lt;code&gt;:exclusive&lt;/code&gt; specification, as described above.</source>
          <target state="translated">Первая функция в функциях &lt;code&gt;completion-at-point-functions&lt;/code&gt; возвращающая &lt;code&gt;nil&lt;/code&gt; значение, используется функцией &lt;code&gt;completion-at-point&lt;/code&gt; . Остальные функции не вызываются. Исключение составляют случаи, когда существует &lt;code&gt;:exclusive&lt;/code&gt; спецификация, как описано выше.</target>
        </trans-unit>
        <trans-unit id="61a427cbbd5fa9f87fd4ca66049624d276b3097d" translate="yes" xml:space="preserve">
          <source>The first hook function is passed a &lt;var&gt;fun&lt;/var&gt; that is equivalent to the default operation of &lt;code&gt;filter-buffer-substring&lt;/code&gt;, i.e., it returns the buffer-substring between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; (processed by any &lt;code&gt;buffer-substring-filters&lt;/code&gt;) and optionally deletes the original text from the buffer. In most cases, the hook function will call &lt;var&gt;fun&lt;/var&gt; once, and then do its own processing of the result. The next hook function receives a &lt;var&gt;fun&lt;/var&gt; equivalent to this, and so on. The actual return value is the result of all the hook functions acting in sequence.</source>
          <target state="translated">Первой функции-перехватчику передается &lt;var&gt;fun&lt;/var&gt; , которое эквивалентно операции по умолчанию &lt;code&gt;filter-buffer-substring&lt;/code&gt; , то есть она возвращает буферную подстроку между &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; (обрабатывается любыми &lt;code&gt;buffer-substring-filters&lt;/code&gt; ) и, возможно, удаляет исходный текст. из буфера. В большинстве случаев функция перехвата вызывает &lt;var&gt;fun&lt;/var&gt; один раз, а затем выполняет свою собственную обработку результата. Следующая функция-перехватчик получает &lt;var&gt;fun&lt;/var&gt; эквивалент этой и так далее. Фактическое возвращаемое значение является результатом последовательного действия всех функций ловушки.</target>
        </trans-unit>
        <trans-unit id="b857f369cef6dd27f6c9832f3de8944a6080d980" translate="yes" xml:space="preserve">
          <source>The first line of the documentation string should stand on its own, because &lt;code&gt;apropos&lt;/code&gt; displays just this first line. It should consist of one or two complete sentences that summarize the function&amp;rsquo;s purpose.</source>
          <target state="translated">Первая строка документации должна стоять сама по себе, потому что &lt;code&gt;apropos&lt;/code&gt; отображает только эту первую строку. Он должен состоять из одного или двух полных предложений, в которых кратко излагается цель функции.</target>
        </trans-unit>
        <trans-unit id="95c5ac45f74b85b86e155db5e7a41993f23c1a44" translate="yes" xml:space="preserve">
          <source>The first method, renaming, is the default.</source>
          <target state="translated">Первый метод,переименование,по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d5a94c95ffdfdde685e909b15241ffe89d36a213" translate="yes" xml:space="preserve">
          <source>The first of these hooks is run after a &lt;em&gt;window buffer change&lt;/em&gt; is detected, which means that a window was created, deleted or assigned another buffer.</source>
          <target state="translated">Первый из этих хуков запускается после обнаружения &lt;em&gt;изменения буфера окна&lt;/em&gt; , что означает, что окно было создано, удалено или назначено другое окно.</target>
        </trans-unit>
        <trans-unit id="5a2945984c3f8a17a8400ccf64f981fcb2eabf09" translate="yes" xml:space="preserve">
          <source>The first one is for locally installed files for a specific Emacs version; the second is for locally installed files meant for use with all installed Emacs versions. (If Emacs is running uninstalled, it also adds</source>
          <target state="translated">Первый-для локально установленных файлов для конкретной версии Emacs;второй-для локально установленных файлов,предназначенных для использования со всеми установленными версиями Emacs.(Если Emacs работает в удаленном режиме,он также добавляет</target>
        </trans-unit>
        <trans-unit id="6d1221fe22767b7dddd5d1d969f3a50a7d8c7c01" translate="yes" xml:space="preserve">
          <source>The first or next non-keyboard event in the key sequence that invoked the command. More precisely, &amp;lsquo;</source>
          <target state="translated">Первое или следующее событие, не связанное с клавиатурой, в последовательности клавиш, вызвавшее команду. Точнее, '</target>
        </trans-unit>
        <trans-unit id="d02389cbd7c0e8fe951f0c6a0fa8a070ab93cecb" translate="yes" xml:space="preserve">
          <source>The first part of the pattern is a character alternative that matches any one of three characters: period, question mark, and exclamation mark. The match must begin with one of these three characters. (This is one point where the new default regexp used by Emacs differs from the old. The new value also allows some non-</source>
          <target state="translated">Первая часть шаблона-это альтернативный символ,который соответствует любому из трех символов:период,знак вопроса и восклицательный знак.Матч должен начинаться с одного из этих трех символов.(Это один из моментов,в котором новый регеxp по умолчанию,используемый Emacs,отличается от старого.Новое значение также позволяет некоторые не</target>
        </trans-unit>
        <trans-unit id="2f07493bfdc49d4184b04abbeaf59e9651306278" translate="yes" xml:space="preserve">
          <source>The first part of the string, &lt;var&gt;fontpattern&lt;/var&gt;, should have the form of a standard X font name, except that the last two fields should be &amp;lsquo;</source>
          <target state="translated">Первая часть строки, &lt;var&gt;fontpattern&lt;/var&gt; , должна иметь форму стандартного имени шрифта X, за исключением того, что последние два поля должны быть '</target>
        </trans-unit>
        <trans-unit id="921dc58080d888df09bdaec42ab40231a692a25c" translate="yes" xml:space="preserve">
          <source>The first step in evaluating a function call is to evaluate the remaining elements of the list from left to right. The results are the actual argument values, one value for each list element. The next step is to call the function with this list of arguments, effectively using the function &lt;code&gt;apply&lt;/code&gt; (see &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;Calling Functions&lt;/a&gt;). If the function is written in Lisp, the arguments are used to bind the argument variables of the function (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;); then the forms in the function body are evaluated in order, and the value of the last body form becomes the value of the function call.</source>
          <target state="translated">Первым шагом в оценке вызова функции является оценка оставшихся элементов списка слева направо. Результатом являются фактические значения аргументов, по одному значению для каждого элемента списка. Следующим шагом является вызов функции с этим списком аргументов, эффективно используя функцию &lt;code&gt;apply&lt;/code&gt; (см. &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;Вызов функций&lt;/a&gt; ). Если функция написана на Лиспе, аргументы используются для связывания переменных аргументов функции (см. &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Лямбда-выражения&lt;/a&gt; ); затем формы в теле функции оцениваются по порядку, и значение последней формы тела становится значением вызова функции.</target>
        </trans-unit>
        <trans-unit id="3df285467f12c1e287f61e00067a2ae879440ffa" translate="yes" xml:space="preserve">
          <source>The first step in evaluating a nonempty list is to examine its first element. This element alone determines what kind of form the list is and how the rest of the list is to be processed. The first element is &lt;em&gt;not&lt;/em&gt; evaluated, as it would be in some Lisp dialects such as Scheme.</source>
          <target state="translated">Первым шагом в оценке непустого списка является проверка его первого элемента. Только этот элемент определяет, в какой форме находится список и как будет обрабатываться остальная часть списка. Первый элемент &lt;em&gt;не&lt;/em&gt; вычисляется, как это было бы в некоторых диалектах Lisp, таких как Scheme.</target>
        </trans-unit>
        <trans-unit id="0b91477185c354f0cf6d4f79757bec67efe4ed2f" translate="yes" xml:space="preserve">
          <source>The first step is to find the defun that is unbalanced. If there is an excess open parenthesis, the way to do this is to go to the end of the file and type</source>
          <target state="translated">Первый шаг-найти неуравновешенное.Если есть избыточная открытая скобка,то для этого нужно перейти в конец файла и набрать тип</target>
        </trans-unit>
        <trans-unit id="3e8495b282fa0cf8be0d80ff66ce938f120af166" translate="yes" xml:space="preserve">
          <source>The first thing the command loop must do is read a key sequence, which is a sequence of input events that translates into a command. It does this by calling the function &lt;code&gt;read-key-sequence&lt;/code&gt;. Lisp programs can also call this function (see &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;). They can also read input at a lower level with &lt;code&gt;read-key&lt;/code&gt; or &lt;code&gt;read-event&lt;/code&gt; (see &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;Reading One Event&lt;/a&gt;), or discard pending input with &lt;code&gt;discard-input&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;).</source>
          <target state="translated">Первое, что должен сделать командный цикл, - это прочитать последовательность клавиш, которая представляет собой последовательность событий ввода, которая преобразуется в команду. Это делается путем вызова функции &lt;code&gt;read-key-sequence&lt;/code&gt; . Программы на Лиспе также могут вызывать эту функцию (см. &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Ввод последовательности клавиш&lt;/a&gt; ). Они также могут читать ввод на более низком уровне с помощью &lt;code&gt;read-key&lt;/code&gt; &lt;code&gt;read-event&lt;/code&gt; или события &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;чтения&lt;/a&gt; (см. Чтение одного события ) или отбрасывать ожидающий ввод с помощью &lt;code&gt;discard-input&lt;/code&gt; (см. &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Ввод событий, разное&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9819ecc730c443ef66825eba6fa46be5ddfd672f" translate="yes" xml:space="preserve">
          <source>The first thing this function does is to activate a minibuffer and display it with &lt;var&gt;prompt&lt;/var&gt; (which must be a string) as the prompt. Then the user can edit text in the minibuffer.</source>
          <target state="translated">Первое, что делает эта функция, - это активирует минибуфер и отображает его с &lt;var&gt;prompt&lt;/var&gt; (которая должна быть строкой) в качестве подсказки. Затем пользователь может редактировать текст в минибуфере.</target>
        </trans-unit>
        <trans-unit id="ffe911fc31e45fe7a69d03c024357531769f0422" translate="yes" xml:space="preserve">
          <source>The first three clauses use backquote-style patterns. &lt;code&gt;`(add ,x ,y)&lt;/code&gt; is a pattern that checks that &lt;code&gt;form&lt;/code&gt; is a three-element list starting with the literal symbol &lt;code&gt;add&lt;/code&gt;, then extracts the second and third elements and binds them to symbols &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, respectively. The clause body evaluates &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and adds the results. Similarly, the &lt;code&gt;call&lt;/code&gt; clause implements a function call, and the &lt;code&gt;fn&lt;/code&gt; clause implements an anonymous function definition.</source>
          <target state="translated">В первых трех предложениях используются шаблоны в стиле обратных кавычек. &lt;code&gt;`(add ,x ,y)&lt;/code&gt; - это шаблон, который проверяет, является ли &lt;code&gt;form&lt;/code&gt; трехэлементным списком, начинающимся с буквального символа &lt;code&gt;add&lt;/code&gt; , затем извлекает второй и третий элементы и связывает их с символами &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; соответственно. Тело предложения оценивает &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; и складывает результаты. Точно так же предложение &lt;code&gt;call&lt;/code&gt; реализует вызов функции, а предложение &lt;code&gt;fn&lt;/code&gt; реализует определение анонимной функции.</target>
        </trans-unit>
        <trans-unit id="73abbe89ddba4324d8c8e47f4552f5d79ddd1773" translate="yes" xml:space="preserve">
          <source>The first three sections below should tell you enough about Edebug to start using it.</source>
          <target state="translated">Первые три секции ниже должны рассказать вам достаточно об Edebug,чтобы начать использовать его.</target>
        </trans-unit>
        <trans-unit id="f8cf2175ce1df58161db09af76ff0593cb8a1848" translate="yes" xml:space="preserve">
          <source>The first two arguments, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, are the beginning and end of the region to be filled. The third and fourth arguments, &lt;var&gt;justify&lt;/var&gt; and &lt;var&gt;citation-regexp&lt;/var&gt;, are optional. If &lt;var&gt;justify&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the paragraphs are justified as well as filled. If &lt;var&gt;citation-regexp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it means the function is operating on a mail message and therefore should not fill the header lines. If &lt;var&gt;citation-regexp&lt;/var&gt; is a string, it is used as a regular expression; if it matches the beginning of a line, that line is treated as a citation marker.</source>
          <target state="translated">Первые два аргумента, &lt;var&gt;start&lt;/var&gt; и &lt;var&gt;end&lt;/var&gt; , являются началом и концом области, которую нужно заполнить. Третий и четвертый аргументы, &lt;var&gt;justify&lt;/var&gt; и &lt;var&gt;citation-regexp&lt;/var&gt; , необязательны. Если &lt;var&gt;justify&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , абзацы выравниваются и заполняются. Если &lt;var&gt;citation-regexp&lt;/var&gt; не равно &lt;code&gt;nil&lt;/code&gt; , это означает, что функция работает с почтовым сообщением и, следовательно, не должна заполнять строки заголовка. Если &lt;var&gt;citation-regexp&lt;/var&gt; является строкой, она используется как регулярное выражение; если он совпадает с началом строки, эта строка рассматривается как маркер цитирования.</target>
        </trans-unit>
        <trans-unit id="ba54bb325792850fbc12f938d5d5d0fe16184dae" translate="yes" xml:space="preserve">
          <source>The first variant, explicit selective display, was designed for use in a Lisp program: it controls which lines are hidden by altering the text. This kind of hiding is now obsolete and deprecated; instead you should use the &lt;code&gt;invisible&lt;/code&gt; property (see &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;) to get the same effect.</source>
          <target state="translated">Первый вариант, явное избирательное отображение, был разработан для использования в программе на Лиспе: он контролирует, какие строки скрываются, изменяя текст. Этот вид скрытия теперь устарел и не рекомендуется; вместо этого вы должны использовать свойство &lt;code&gt;invisible&lt;/code&gt; (см. &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Невидимый текст&lt;/a&gt; ), чтобы получить тот же эффект.</target>
        </trans-unit>
        <trans-unit id="ae5b4e16891d5734b38e80c0203fdd0afd0ce6e9" translate="yes" xml:space="preserve">
          <source>The flag &amp;lsquo;</source>
          <target state="translated">Флаг '</target>
        </trans-unit>
        <trans-unit id="1e9d7078efa70faad8e62d7dac2b994d083d12ef" translate="yes" xml:space="preserve">
          <source>The flag &lt;var&gt;current-group&lt;/var&gt; has no effect when a pipe is used to communicate with the subprocess, because the operating system does not support the distinction in the case of pipes. For the same reason, job-control shells won&amp;rsquo;t work when a pipe is used. See &lt;code&gt;process-connection-type&lt;/code&gt; in &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Asynchronous Processes&lt;/a&gt;.</source>
          <target state="translated">Флаг &lt;var&gt;current-group&lt;/var&gt; не действует, когда канал используется для связи с подпроцессом, потому что операционная система не поддерживает различие в случае каналов. По той же причине оболочки управления заданиями не будут работать при использовании канала. См &lt;code&gt;process-connection-type&lt;/code&gt; в &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;асинхронных процессов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec2c9b05e5630a06e86a36a4fbe950b6561191c6" translate="yes" xml:space="preserve">
          <source>The following</source>
          <target state="translated">Нижеперечисленные</target>
        </trans-unit>
        <trans-unit id="c8513321fed0f5129f9fbc478e3010a771a4d3ef" translate="yes" xml:space="preserve">
          <source>The following C data structures are defined in</source>
          <target state="translated">Следующие структуры данных C определены в</target>
        </trans-unit>
        <trans-unit id="5389465bbc2f69e77a3b2484a1984ff2230a7971" translate="yes" xml:space="preserve">
          <source>The following Lisp forms are the forms in Emacs that will work as generalized variables, and so may appear in the &lt;var&gt;place&lt;/var&gt; argument of &lt;code&gt;setf&lt;/code&gt;:</source>
          <target state="translated">Следующие формы Lisp - это формы в Emacs, которые будут работать как обобщенные переменные, и поэтому могут появляться в аргументе &lt;var&gt;place&lt;/var&gt; для &lt;code&gt;setf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="30e3d2decfa7f509aa3c0da9bce3711eec8451b2" translate="yes" xml:space="preserve">
          <source>The following action function for &lt;code&gt;display-buffer&lt;/code&gt; (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) creates or reuses a side window for displaying the specified buffer.</source>
          <target state="translated">Следующая функция действия для &lt;code&gt;display-buffer&lt;/code&gt; (см. &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Функции действий отображения буфера&lt;/a&gt; ) создает или повторно использует боковое окно для отображения указанного буфера.</target>
        </trans-unit>
        <trans-unit id="dfbcb2a836ed9e2ea7b4444cdff4b5302dc8b282" translate="yes" xml:space="preserve">
          <source>The following are functions for altering the</source>
          <target state="translated">Ниже перечислены функции для изменения</target>
        </trans-unit>
        <trans-unit id="4d77a5b5f720da9def084ee3c59bb116b800938f" translate="yes" xml:space="preserve">
          <source>The following are functions for searching for elements in the</source>
          <target state="translated">Ниже приведены функции для поиска элементов в</target>
        </trans-unit>
        <trans-unit id="1dfb54b3aba09435f9c449c921d9fd5796ec1366" translate="yes" xml:space="preserve">
          <source>The following aspects of ranges are specific to Emacs, in that POSIX allows but does not require this behavior and programs other than Emacs may behave differently:</source>
          <target state="translated">Следующие аспекты диапазонов специфичны для Emacs,в том,что POSIX позволяет,но не требует такого поведения,и программы,отличные от Emacs,могут вести себя по-другому:</target>
        </trans-unit>
        <trans-unit id="05135351c4db9bc9b01c91cca9c14d0e6246c79f" translate="yes" xml:space="preserve">
          <source>The following basic action functions are defined in Emacs.</source>
          <target state="translated">В Emacs определены следующие основные функции действия.</target>
        </trans-unit>
        <trans-unit id="dd8640559e0a3145f35e39076da3835c9d10c816" translate="yes" xml:space="preserve">
          <source>The following buffer-local variables control the position and width of fringes in windows showing that buffer.</source>
          <target state="translated">Следующие переменные буфера-локальные контролируют положение и ширину полос в окнах,показывающих этот буфер.</target>
        </trans-unit>
        <trans-unit id="00cbfbb2bbd87d9035fce6f335cba5b08cdc1cad" translate="yes" xml:space="preserve">
          <source>The following caveats should be considered when adding a function to window change functions:</source>
          <target state="translated">При добавлении функции к функциям смены окон следует учитывать следующие предостережения:</target>
        </trans-unit>
        <trans-unit id="fce85ab64d52f9ad9fc3dd20003408e7fd70e516" translate="yes" xml:space="preserve">
          <source>The following code snippet, when applied to a single-window frame, first splits the selected window and makes the selected and the new window constituents of an atomic window with their parent as root. It then displays the buffer</source>
          <target state="translated">Следующий фрагмент кода,при применении к однооконному фрейму,сначала разделяет выделенное окно и делает выделенное и новое окно компонентами атомарного окна с родителем в качестве корня.Затем он отображает буфер</target>
        </trans-unit>
        <trans-unit id="e841b3081cb8d309a73a3b7e4ec19b8e893a44c5" translate="yes" xml:space="preserve">
          <source>The following command is handy to toggle the appearance of all side windows on a specified frame.</source>
          <target state="translated">Следующая команда удобна для переключения внешнего вида всех боковых окон на заданной раме.</target>
        </trans-unit>
        <trans-unit id="57fb79cd5a56bc93119b550457684621fd2045d9" translate="yes" xml:space="preserve">
          <source>The following command uses information on how the window for displaying the buffer was obtained in the first place, thus attempting to automate the above decisions for you.</source>
          <target state="translated">Следующая команда использует информацию о том,как было получено окно для отображения буфера,тем самым пытаясь автоматизировать для вас вышеуказанные решения.</target>
        </trans-unit>
        <trans-unit id="f73e0bc0f4740059294b61a0f93df3282d2be9cb" translate="yes" xml:space="preserve">
          <source>The following command-line options affect some aspects of the startup sequence. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Initial-Options.html#Initial-Options&quot;&gt;Initial Options&lt;/a&gt; in</source>
          <target state="translated">Следующие параметры командной строки влияют на некоторые аспекты последовательности запуска. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Initial-Options.html#Initial-Options&quot;&gt;Начальные параметры&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="52e933df89f8a6d2d6eb75a953cd492fb460f70a" translate="yes" xml:space="preserve">
          <source>The following commands and functions mostly provide compatibility with old versions of Emacs. They work by calling &lt;code&gt;set-face-attribute&lt;/code&gt;. Values of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; (or omitted) for their &lt;var&gt;frame&lt;/var&gt; argument are handled just like &lt;code&gt;set-face-attribute&lt;/code&gt; and &lt;code&gt;face-attribute&lt;/code&gt;. The commands read their arguments using the minibuffer, if called interactively.</source>
          <target state="translated">Следующие ниже команды и функции в основном обеспечивают совместимость со старыми версиями Emacs. Они работают, вызывая &lt;code&gt;set-face-attribute&lt;/code&gt; . Значения &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;nil&lt;/code&gt; (или опущенные) для их аргумента &lt;var&gt;frame&lt;/var&gt; обрабатываются так же, как &lt;code&gt;set-face-attribute&lt;/code&gt; и &lt;code&gt;face-attribute&lt;/code&gt; . Команды считывают свои аргументы с помощью минибуфера, если они вызываются в интерактивном режиме.</target>
        </trans-unit>
        <trans-unit id="37349965f15dc9da05dfef5324363eb60ce661c7" translate="yes" xml:space="preserve">
          <source>The following commands can be used to cycle through the global buffer list, much like &lt;code&gt;bury-buffer&lt;/code&gt; and &lt;code&gt;unbury-buffer&lt;/code&gt;. However, they cycle according to the specified window&amp;rsquo;s history list, rather than the global buffer list. In addition, they restore window-specific window start and point positions, and may show a buffer even if it is already shown in another window. The &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; command, in particular, is used by &lt;code&gt;replace-buffer-in-windows&lt;/code&gt;, &lt;code&gt;bury-buffer&lt;/code&gt; and &lt;code&gt;quit-window&lt;/code&gt; to find a replacement buffer for a window.</source>
          <target state="translated">Следующие команды могут использоваться для циклического просмотра глобального списка буферов, как и &lt;code&gt;bury-buffer&lt;/code&gt; и &lt;code&gt;unbury-buffer&lt;/code&gt; . Однако они выполняются циклически согласно списку истории указанного окна, а не глобальному списку буферов. Кроме того, они восстанавливают зависящие от окна положения начала и точки окна и могут отображать буфер, даже если он уже отображается в другом окне. В частности, команда &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; используется командами &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; , &lt;code&gt;bury-buffer&lt;/code&gt; и &lt;code&gt;quit-window&lt;/code&gt; , чтобы найти буфер замены для окна.</target>
        </trans-unit>
        <trans-unit id="4cfae661f65e37ca3c8203dfeb12091ccfd13ecb" translate="yes" xml:space="preserve">
          <source>The following commands exist to set up prefix arguments for the following command. Do not call them for any other reason.</source>
          <target state="translated">Существуют следующие команды для установки префиксных аргументов следующей команды.Не вызывайте их по какой-либо другой причине.</target>
        </trans-unit>
        <trans-unit id="aa7ca6b67a7690e608cf5f0b3d4b7e967062b1ce" translate="yes" xml:space="preserve">
          <source>The following commands resize windows in more specific ways. When called interactively, they act on the selected window.</source>
          <target state="translated">Следующие команды изменяют размер окон более конкретными способами.При интерактивном вызове они действуют на выбранное окно.</target>
        </trans-unit>
        <trans-unit id="570dc96146735c82ffd1bfbddf49607518fc0e37" translate="yes" xml:space="preserve">
          <source>The following completion functions have nothing in themselves to do with minibuffers. We describe them here to keep them near the higher-level completion features that do use the minibuffer.</source>
          <target state="translated">Следующие функции завершения не имеют ничего общего с минибуферами.Мы описываем их здесь,чтобы держать их рядом с функциями завершения более высокого уровня,которые используют минибуфер.</target>
        </trans-unit>
        <trans-unit id="0211a8b24b8be85ca2c0dab5dd381bc0a3351017" translate="yes" xml:space="preserve">
          <source>The following convenience function should be used by major mode&amp;rsquo;s indentation engine in support of invocations as sub-modes of another major mode.</source>
          <target state="translated">Следующие функции удобства должны использоваться механизмом отступов основного режима для поддержки вызовов как подрежимов другого основного режима.</target>
        </trans-unit>
        <trans-unit id="dcdef829dc684ff37c33f2db214834e347de051b" translate="yes" xml:space="preserve">
          <source>The following diagram shows the relationship between these types:</source>
          <target state="translated">На следующей диаграмме показана взаимосвязь между этими типами:</target>
        </trans-unit>
        <trans-unit id="263c6cdc21149473ee03d3c1db3fc6ad830a42fa" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this. Given this (malformed) HTML document:</source>
          <target state="translated">Следующий пример демонстрирует это.Учитывая этот (некорректный)HTML документ:</target>
        </trans-unit>
        <trans-unit id="6e4d4fe31f9b5d0412811ce2d12a130a112c7a7c" translate="yes" xml:space="preserve">
          <source>The following example features a &lt;code&gt;pcase&lt;/code&gt; form with two clauses and two &lt;var&gt;seqpat&lt;/var&gt;, A and B. Both A and B first check that &lt;var&gt;expval&lt;/var&gt; is a pair (using &lt;code&gt;pred&lt;/code&gt;), and then bind symbols to the &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; of &lt;var&gt;expval&lt;/var&gt; (using one &lt;code&gt;app&lt;/code&gt; each).</source>
          <target state="translated">Следующий пример показывает &lt;code&gt;pcase&lt;/code&gt; форму с двумя пунктами и двумя &lt;var&gt;seqpat&lt;/var&gt; , А и В. А и Б сначала проверить , что &lt;var&gt;expval&lt;/var&gt; пара ( с использованием &lt;code&gt;pred&lt;/code&gt; ), а затем связывают символы к &lt;code&gt;car&lt;/code&gt; и &lt;code&gt;cdr&lt;/code&gt; из &lt;var&gt;expval&lt;/var&gt; ( с использованием одного &lt;code&gt;app&lt;/code&gt; каждый ).</target>
        </trans-unit>
        <trans-unit id="cd027753313db3e2bda6d7bd77fd22b1e4340a82" translate="yes" xml:space="preserve">
          <source>The following example has four clauses, which test for the cases where the value of &lt;code&gt;x&lt;/code&gt; is a number, string, buffer and symbol, respectively:</source>
          <target state="translated">В следующем примере есть четыре предложения, которые проверяют случаи, когда значение &lt;code&gt;x&lt;/code&gt; является числом, строкой, буфером и символом соответственно:</target>
        </trans-unit>
        <trans-unit id="327e6914ac3c21e45d4f2593af1fe07d9cc74645" translate="yes" xml:space="preserve">
          <source>The following example illustrates how window parameters (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) can be used with &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; (see &lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;Displaying Buffers in Side Windows&lt;/a&gt;) to set up code for producing the frame layout sketched above.</source>
          <target state="translated">В следующем примере показано, как параметры окна (см. &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Параметры окна&lt;/a&gt; ) могут использоваться с &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; (см. &lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;Отображение буферов в &lt;/a&gt;боковых окнах ) для настройки кода для создания макета кадра, показанного выше.</target>
        </trans-unit>
        <trans-unit id="dc386ed858292344d4ceae67e2b47d225cbdc5c4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the symbol indirection process. We use &lt;code&gt;fset&lt;/code&gt; to set the function cell of a symbol and &lt;code&gt;symbol-function&lt;/code&gt; to get the function cell contents (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;). Specifically, we store the symbol &lt;code&gt;car&lt;/code&gt; into the function cell of &lt;code&gt;first&lt;/code&gt;, and the symbol &lt;code&gt;first&lt;/code&gt; into the function cell of &lt;code&gt;erste&lt;/code&gt;.</source>
          <target state="translated">В следующем примере показан процесс косвенного обращения к символу. Мы используем &lt;code&gt;fset&lt;/code&gt; для установки функциональной ячейки символа и &lt;code&gt;symbol-function&lt;/code&gt; для получения содержимого функциональной ячейки (см. &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Функциональные ячейки&lt;/a&gt; ). В частности, мы сохраняем символ &lt;code&gt;car&lt;/code&gt; в функции клетки &lt;code&gt;first&lt;/code&gt; , и символ &lt;code&gt;first&lt;/code&gt; в функции клетки &lt;code&gt;erste&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50417c92f73fbb1570f2868b9a274b2b3768d629" translate="yes" xml:space="preserve">
          <source>The following example reads from the minibuffer. The prompt is: &amp;lsquo;</source>
          <target state="translated">В следующем примере выполняется чтение из минибуфера. Подсказка: '</target>
        </trans-unit>
        <trans-unit id="332aeac42ef2f3fa049798dfb6a5f1315671df58" translate="yes" xml:space="preserve">
          <source>The following example shows how &lt;code&gt;doctor&lt;/code&gt; is prepared for autoloading with a magic comment:</source>
          <target state="translated">В следующем примере показано, как &lt;code&gt;doctor&lt;/code&gt; готовится к автозагрузке с помощью волшебного комментария:</target>
        </trans-unit>
        <trans-unit id="e5c2aa47b7a24022abda108bb46b665cf282e882" translate="yes" xml:space="preserve">
          <source>The following example shows how to change the &lt;code&gt;make-backup-files&lt;/code&gt; variable only in the Rmail buffers and not elsewhere. Setting it &lt;code&gt;nil&lt;/code&gt; stops Emacs from making backups of these files, which may save disk space. (You would put this code in your init file.)</source>
          <target state="translated">В следующем примере показано, как изменить переменную &lt;code&gt;make-backup-files&lt;/code&gt; только в буферах Rmail, а не где-либо еще. Установка его в &lt;code&gt;nil&lt;/code&gt; запрещает Emacs создавать резервные копии этих файлов, что может сэкономить место на диске. (Вы должны поместить этот код в свой файл инициализации.)</target>
        </trans-unit>
        <trans-unit id="a65479aec9ccbd5d9fca631c244266e471eff184" translate="yes" xml:space="preserve">
          <source>The following example shows how to implement this behavior (it is similar to the code generated by the &lt;code&gt;define-minor-mode&lt;/code&gt; macro):</source>
          <target state="translated">В следующем примере показано, как реализовать это поведение (он похож на код, созданный макросом &lt;code&gt;define-minor-mode&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="41826d1f446a51f4203f921570333293d6e9a365" translate="yes" xml:space="preserve">
          <source>The following example shows output to the echo area:</source>
          <target state="translated">В следующем примере показан вывод в область эха:</target>
        </trans-unit>
        <trans-unit id="ed8de281701b10f23d7cf126c2510f9e62a9fd5e" translate="yes" xml:space="preserve">
          <source>The following example uses the GNU Multiprecision Library (GMP) to calculate the next probable prime after a given integer. See &lt;a href=&quot;http://www.gmplib.org/manual/index.html#Top&quot;&gt;(gmp)Top&lt;/a&gt;, for a general overview of GMP, and see &lt;a href=&quot;http://www.gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export&quot;&gt;(gmp)Integer Import and Export&lt;/a&gt; for how to convert the &lt;code&gt;magnitude&lt;/code&gt; array to and from GMP &lt;code&gt;mpz_t&lt;/code&gt; values.</source>
          <target state="translated">В следующем примере используется библиотека GNU Multiprecision (GMP) для вычисления следующего вероятного простого числа после заданного целого числа. См. &lt;a href=&quot;http://www.gmplib.org/manual/index.html#Top&quot;&gt;(Gmp) Вверху&lt;/a&gt; для общего обзора GMP и см. &lt;a href=&quot;http://www.gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export&quot;&gt;(Gmp) Целочисленный импорт и экспорт,&lt;/a&gt; чтобы узнать, как преобразовать массив &lt;code&gt;magnitude&lt;/code&gt; в значения GMP &lt;code&gt;mpz_t&lt;/code&gt; и обратно .</target>
        </trans-unit>
        <trans-unit id="8ccc6f71275edccfcefe025151e857765f2bef74" translate="yes" xml:space="preserve">
          <source>The following examples apply to C mode. (We use &lt;code&gt;string&lt;/code&gt; to make it easier to see the character returned by &lt;code&gt;char-syntax&lt;/code&gt;.)</source>
          <target state="translated">Следующие примеры относятся к режиму C. (Мы используем &lt;code&gt;string&lt;/code&gt; чтобы упростить просмотр символа, возвращаемого &lt;code&gt;char-syntax&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="26d92c15072c5c240ab885269951f66b6b35d5e1" translate="yes" xml:space="preserve">
          <source>The following expressions are supported:</source>
          <target state="translated">Поддерживаются следующие выражения:</target>
        </trans-unit>
        <trans-unit id="ea979b34ff1306c51163d99f45af8eeacfd3a2ed" translate="yes" xml:space="preserve">
          <source>The following four functions return size information about fonts used by various faces, allowing various layout considerations in Lisp programs. These functions take face remapping into consideration, returning information about the remapped face, if the face in question was remapped. See &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;Face Remapping&lt;/a&gt;.</source>
          <target state="translated">Следующие четыре функции возвращают информацию о размере шрифтов, используемых различными начертаниями, что позволяет учитывать различные аспекты компоновки в программах на Лиспе. Эти функции принимают во внимание переназначение лица, возвращая информацию о переназначенном лице, если рассматриваемое лицо было переназначено. См. &amp;laquo; &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;Переназначение лица&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be78e6b29260e74d50737c0ccdf28a858bff746b" translate="yes" xml:space="preserve">
          <source>The following four functions take as argument a live window which defaults to the selected one.</source>
          <target state="translated">Следующие четыре функции принимают в качестве аргумента живое окно,которое по умолчанию является выбранным.</target>
        </trans-unit>
        <trans-unit id="b28622c4a0c44a36e614e4b99f2b96928420c806" translate="yes" xml:space="preserve">
          <source>The following frame parameters are semi-obsolete in that they are automatically equivalent to particular face attributes of particular faces (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;Standard Faces&lt;/a&gt; in</source>
          <target state="translated">Следующие параметры кадра являются частично устаревшими, поскольку они автоматически эквивалентны определенным атрибутам лица определенных лиц (см. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;Стандартные лица&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="cb0d5dbd228f2db46d29d8fd495eae184f9211a5" translate="yes" xml:space="preserve">
          <source>The following frame parameters control various aspects of the frame&amp;rsquo;s interaction with the window manager or window system. They have no effect on text terminals.</source>
          <target state="translated">Следующие параметры кадра управляют различными аспектами взаимодействия кадра с оконным менеджером или оконной системой. Они не действуют на текстовые терминалы.</target>
        </trans-unit>
        <trans-unit id="bf7261ff6189a415c2673c506f413d2b2705feb4" translate="yes" xml:space="preserve">
          <source>The following function allows the entire window tree of a frame to be retrieved:</source>
          <target state="translated">Следующая функция позволяет получить все дерево окна рамки:</target>
        </trans-unit>
        <trans-unit id="3c4762fdb24ff2e4d3cb60e8188c313f3b2fbda2" translate="yes" xml:space="preserve">
          <source>The following function can be used to check whether the height of a particular window is preserved:</source>
          <target state="translated">Следующая функция может быть использована для проверки сохранения высоты конкретного окна:</target>
        </trans-unit>
        <trans-unit id="117c5514e9c0c86e45b8ed5efd7004d773fd526d" translate="yes" xml:space="preserve">
          <source>The following function can be used to retrieve the edges of the outer, native and inner frame.</source>
          <target state="translated">Следующая функция может быть использована для извлечения краев наружной,внутренней и внутренней рамы.</target>
        </trans-unit>
        <trans-unit id="ea2cbed368d68e203932ff80be174434c94a4f4d" translate="yes" xml:space="preserve">
          <source>The following function can tell whether the mouse cursor is currently visible on a frame:</source>
          <target state="translated">Следующая функция может определить,виден ли курсор мыши в данный момент на кадре:</target>
        </trans-unit>
        <trans-unit id="e2ca3d1c501ec1cc5dd734a37cfc409f12e0b6fa" translate="yes" xml:space="preserve">
          <source>The following function comes in handy for applying a certain function to all or part of the characters in a charset:</source>
          <target state="translated">Следующая функция подходит для применения определенной функции ко всем или к части символов в кодовой таблице:</target>
        </trans-unit>
        <trans-unit id="f77a31c265b7eeea36fdbae05e58d9985d0570a4" translate="yes" xml:space="preserve">
          <source>The following function may be used to explicitly load the library specified by an autoload object:</source>
          <target state="translated">Следующая функция может быть использована для явной загрузки библиотеки,указанной объектом автозагрузки:</target>
        </trans-unit>
        <trans-unit id="ceeeb0b1e3b74324880960da48962febae85922a" translate="yes" xml:space="preserve">
          <source>The following function provides a convenient way to perform completion on an arbitrary stretch of text in an Emacs buffer:</source>
          <target state="translated">Следующая функция предоставляет удобный способ выполнить завершение на произвольном отрезке текста в буфере Emacs:</target>
        </trans-unit>
        <trans-unit id="73acc10fc0f8415d20b19b3c2e44bcf404ab2072" translate="yes" xml:space="preserve">
          <source>The following function returns the largest rectangle that can be inscribed in a window without covering text displayed in that window.</source>
          <target state="translated">Следующая функция возвращает самый большой прямоугольник,который можно вписать в окно,не закрывая текст,отображаемый в этом окне.</target>
        </trans-unit>
        <trans-unit id="fc810414382be279064aacb6e28913b8de3c3ff6" translate="yes" xml:space="preserve">
          <source>The following function returns the root of the atomic window a specified window is part of:</source>
          <target state="translated">Следующая функция возвращает корень атомарного окна,частью которого является указанное окно:</target>
        </trans-unit>
        <trans-unit id="31bd0e6b32efb7b36c0cf9948bd05648d25d411b" translate="yes" xml:space="preserve">
          <source>The following function returns the screen coordinates of a buffer position visible in a window:</source>
          <target state="translated">Следующая функция возвращает координаты позиции буфера,видимого в окне:</target>
        </trans-unit>
        <trans-unit id="26a2f135aeb3b3b38b6b9f7e18e5eead9f063326" translate="yes" xml:space="preserve">
          <source>The following function returns the size in pixels of text as if it were displayed in a given window. This function is used by &lt;code&gt;fit-window-to-buffer&lt;/code&gt; and &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;) to make a window exactly as large as the text it contains.</source>
          <target state="translated">Следующая функция возвращает размер текста в пикселях, как если бы он отображался в данном окне. Эта функция используется &lt;code&gt;fit-window-to-buffer&lt;/code&gt; и &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (см. &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Изменение размера окна&lt;/a&gt; ), чтобы сделать окно точно таким же большим, как текст, который он содержит.</target>
        </trans-unit>
        <trans-unit id="baaad99ca2ee271ccecab2b6a3ef8d793aeb7ed5" translate="yes" xml:space="preserve">
          <source>The following function returns the window showing the currently active minibuffer.</source>
          <target state="translated">Следующая функция возвращает окно,показывающее текущий активный минибуфер.</target>
        </trans-unit>
        <trans-unit id="8b75ec29519dc9fe45770dfcb9354804e2c7afa9" translate="yes" xml:space="preserve">
          <source>The following function tells how small a specific window can get taking into account the sizes of its areas and the values of &lt;code&gt;window-min-height&lt;/code&gt;, &lt;code&gt;window-min-width&lt;/code&gt; and &lt;code&gt;window-size-fixed&lt;/code&gt; (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</source>
          <target state="translated">Следующая функция сообщает, насколько маленьким может стать конкретное окно с учетом размеров его областей и значений &lt;code&gt;window-min-height&lt;/code&gt; , &lt;code&gt;window-min-width&lt;/code&gt; и &lt;code&gt;window-size-fixed&lt;/code&gt; (см. &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Сохранение размеров окна&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="17e4594a68f250e3e8b85fe3ee7531e8c73e1aaf" translate="yes" xml:space="preserve">
          <source>The following function uses the current buffer for temporary display:</source>
          <target state="translated">Следующая функция использует текущий буфер для временного отображения:</target>
        </trans-unit>
        <trans-unit id="3f030bbc8b308337c1d8037400878c12fc6b75a0" translate="yes" xml:space="preserve">
          <source>The following functions add a button using an overlay (see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;) to hold the button properties:</source>
          <target state="translated">Следующие функции добавляют кнопку с помощью наложения (см. &lt;a href=&quot;overlays#Overlays&quot;&gt;Наложения&lt;/a&gt; ) для хранения свойств кнопки:</target>
        </trans-unit>
        <trans-unit id="9af23f6b20961af61b76c648d84296f5b4b0e9ad" translate="yes" xml:space="preserve">
          <source>The following functions are responsible for installing the user&amp;rsquo;s customization settings for variables and faces, respectively. When the user invokes &amp;lsquo;</source>
          <target state="translated">Следующие функции отвечают за установку пользовательских настроек для переменных и лиц соответственно. Когда пользователь вызывает '</target>
        </trans-unit>
        <trans-unit id="d7b4e728a53c2e4b67182aeaebf7454821ce8777" translate="yes" xml:space="preserve">
          <source>The following functions are similar, but using text properties (see &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;) to hold the button properties. Such buttons do not add markers to the buffer, so editing in the buffer does not slow down if there is an extremely large numbers of buttons. However, if there is an existing face text property on the text (e.g., a face assigned by Font Lock mode), the button face may not be visible. Both of these functions return the starting position of the new button.</source>
          <target state="translated">Следующие функции аналогичны, но с использованием свойств текста (см. &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Свойства текста&lt;/a&gt; ) для хранения свойств кнопки. Такие кнопки не добавляют маркеры в буфер, поэтому редактирование в буфере не замедляется при слишком большом количестве кнопок. Однако, если в тексте есть свойство текста лица (например, лицо, назначенное режимом Font Lock), лицо кнопки может быть не видно. Обе эти функции возвращают начальную позицию новой кнопки.</target>
        </trans-unit>
        <trans-unit id="84f3c437913b719438332ee8562848724259dd06" translate="yes" xml:space="preserve">
          <source>The following functions are specialized for handling floating-point numbers:</source>
          <target state="translated">Следующие функции специализируются на работе с числами с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="b893e578fff503e7493ed1c552081eb143f20c3f" translate="yes" xml:space="preserve">
          <source>The following functions are useful for programmatically enabling and disabling themes:</source>
          <target state="translated">Следующие функции полезны для программного включения и отключения тем:</target>
        </trans-unit>
        <trans-unit id="531016c102f8f2a24b0893c6bb0481e625b81509" translate="yes" xml:space="preserve">
          <source>The following functions can be used to access symbol properties.</source>
          <target state="translated">Для доступа к свойствам символов можно использовать следующие функции.</target>
        </trans-unit>
        <trans-unit id="a9b7c957393c6e1fb8ce8837669b7366c5d35273" translate="yes" xml:space="preserve">
          <source>The following functions can be used to determine whether a given window has any adjacent windows.</source>
          <target state="translated">Следующие функции могут быть использованы для определения того,имеет ли данное окно какие-либо соседние окна.</target>
        </trans-unit>
        <trans-unit id="aad4cbdda12c20812720683836916585e55b1f16" translate="yes" xml:space="preserve">
          <source>The following functions can be used to manipulate property lists. They all compare property names using &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">Следующие функции можно использовать для управления списками свойств. Все они сравнивают имена свойств, используя &lt;code&gt;eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b8bab067bedd523b26cfb38d2407d422ebc6485" translate="yes" xml:space="preserve">
          <source>The following functions can be used to obtain information about a font. For these functions, the &lt;var&gt;font&lt;/var&gt; argument can be a font object, a font entity, or a font spec.</source>
          <target state="translated">Следующие функции можно использовать для получения информации о шрифте. Для этих функций аргумент &lt;var&gt;font&lt;/var&gt; может быть объектом шрифта, объектом шрифта или спецификацией шрифта.</target>
        </trans-unit>
        <trans-unit id="890cbaf248b1c3bd0429284d2b0998f1856c73a5" translate="yes" xml:space="preserve">
          <source>The following functions can be used to relate a set of frame-relative coordinates to a window:</source>
          <target state="translated">Следующие функции могут быть использованы для связи набора координат рамки относительно окна:</target>
        </trans-unit>
        <trans-unit id="907f5fb790174097faee980eaa3e6e493703e37f" translate="yes" xml:space="preserve">
          <source>The following functions can be used to retrieve a child window of an internal window, and the siblings of a child window.</source>
          <target state="translated">Следующие функции могут быть использованы для получения дочернего окна внутреннего окна,а также братьев и сестер дочернего окна.</target>
        </trans-unit>
        <trans-unit id="5abac45b57d6cb02f4a44218dad6bcf05e357901" translate="yes" xml:space="preserve">
          <source>The following functions can be used to work with this structure. Each function takes a</source>
          <target state="translated">Для работы с этой структурой могут использоваться следующие функции.Каждая функция принимает</target>
        </trans-unit>
        <trans-unit id="5e7b9f761ac410965453c46cb12a7b79355721cc" translate="yes" xml:space="preserve">
          <source>The following functions can be useful to locate a window within its frame.</source>
          <target state="translated">Следующие функции могут быть полезны для размещения окна в его раме.</target>
        </trans-unit>
        <trans-unit id="d4d8b453efb193de073f07eacd52282b298d2182" translate="yes" xml:space="preserve">
          <source>The following functions create strings, either from scratch, or by putting strings together, or by taking them apart.</source>
          <target state="translated">Следующие функции создают строки,либо с нуля,либо складывая их вместе,либо разбирая их.</target>
        </trans-unit>
        <trans-unit id="2830de83f3df2374878d8790525a0ec899df66a3" translate="yes" xml:space="preserve">
          <source>The following functions examine the attributes of a face. They mostly provide compatibility with old versions of Emacs. If you don&amp;rsquo;t specify &lt;var&gt;frame&lt;/var&gt;, they refer to the selected frame; &lt;code&gt;t&lt;/code&gt; refers to the default data for new frames. They return &lt;code&gt;unspecified&lt;/code&gt; if the face doesn&amp;rsquo;t define any value for that attribute. If &lt;var&gt;inherit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, only an attribute directly defined by the face is returned. If &lt;var&gt;inherit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, any faces specified by its &lt;code&gt;:inherit&lt;/code&gt; attribute are considered as well, and if &lt;var&gt;inherit&lt;/var&gt; is a face or a list of faces, then they are also considered, until a specified attribute is found. To ensure that the return value is always specified, use a value of &lt;code&gt;default&lt;/code&gt; for &lt;var&gt;inherit&lt;/var&gt;.</source>
          <target state="translated">Следующие функции проверяют атрибуты лица. В основном они обеспечивают совместимость со старыми версиями Emacs. Если вы не укажете &lt;var&gt;frame&lt;/var&gt; , они будут ссылаться на выбранный фрейм; &lt;code&gt;t&lt;/code&gt; относится к данным по умолчанию для новых кадров. Они возвращают &lt;code&gt;unspecified&lt;/code&gt; если лицо не определяет никакого значения для этого атрибута. Если &lt;var&gt;inherit&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , возвращается только атрибут, непосредственно определенный лицом. Если &lt;var&gt;inherit&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , также учитываются все грани, указанные в его атрибуте &lt;code&gt;:inherit&lt;/code&gt; , а если &lt;var&gt;inherit&lt;/var&gt; - это лицо или список лиц, то они также рассматриваются, пока не будет найден указанный атрибут. Чтобы гарантировать, что возвращаемое значение всегда указано, используйте значение по &lt;code&gt;default&lt;/code&gt; для &lt;var&gt;inherit&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="34336bc291047ecc82ef9e39f037db9645e68fee" translate="yes" xml:space="preserve">
          <source>The following functions implement a higher-level interface to &lt;code&gt;face-remapping-alist&lt;/code&gt;. Most Lisp code should use these functions instead of setting &lt;code&gt;face-remapping-alist&lt;/code&gt; directly, to avoid trampling on remappings applied elsewhere. These functions are intended for buffer-local remappings, so they all make &lt;code&gt;face-remapping-alist&lt;/code&gt; buffer-local as a side-effect. They manage &lt;code&gt;face-remapping-alist&lt;/code&gt; entries of the form</source>
          <target state="translated">Следующие функции реализуют высокоуровневый интерфейс для &lt;code&gt;face-remapping-alist&lt;/code&gt; . Большая часть кода на Лиспе должна использовать эти функции вместо непосредственной установки &lt;code&gt;face-remapping-alist&lt;/code&gt; , чтобы избежать нарушения переназначений, применяемых где-то еще. Эти функции предназначены для локального переназначения буфера, поэтому все они делают &lt;code&gt;face-remapping-alist&lt;/code&gt; локальным буфером в качестве побочного эффекта. Они управляют записями &lt;code&gt;face-remapping-alist&lt;/code&gt; лиц в форме</target>
        </trans-unit>
        <trans-unit id="f45de0afa1e82c2bee6e9b103afe4d0400313b5d" translate="yes" xml:space="preserve">
          <source>The following functions may be used to manipulate and query the watch functions for a variable.</source>
          <target state="translated">Следующие функции могут быть использованы для манипулирования и запроса часовых функций для переменной.</target>
        </trans-unit>
        <trans-unit id="297514168ef2ea3e190861ad8aed9621b2bf0fde" translate="yes" xml:space="preserve">
          <source>The following functions replace characters within a specified region based on their character codes.</source>
          <target state="translated">Следующие функции заменяют символы в пределах указанного региона на основе их символьных кодов.</target>
        </trans-unit>
        <trans-unit id="8ef4900912dcb434358d1e1cc34146dd4ae71b7f" translate="yes" xml:space="preserve">
          <source>The following functions return a window which satisfies some criterion, without selecting it:</source>
          <target state="translated">Следующие функции возвращают окно,которое удовлетворяет определенному критерию,без его выбора:</target>
        </trans-unit>
        <trans-unit id="6c1b3a2ec1e9d599ce858d9c865cc30d35b9cfbd" translate="yes" xml:space="preserve">
          <source>The following functions return window positions in pixels, rather than character units. Though mostly useful on graphical displays, they can also be called on text terminals, where the screen area of each text character is taken to be one pixel.</source>
          <target state="translated">Следующие функции возвращают позиции окна в пикселях,а не в символьных единицах.Хотя в основном они полезны на графических дисплеях,их также можно вызывать на текстовых терминалах,где область экрана каждого текстового символа принимается за один пиксель.</target>
        </trans-unit>
        <trans-unit id="f2f37ec3b726c43a4c87205d55e42808f4009de8" translate="yes" xml:space="preserve">
          <source>The following functions return window positions in pixels, relative to the origin of the display screen rather than that of the frame:</source>
          <target state="translated">Следующие функции возвращают позиции окна в пикселях относительно начала экрана дисплея,а не рамки:</target>
        </trans-unit>
        <trans-unit id="155cd68525e1e78f8dc1877edd4a3b4cc3b3b32f" translate="yes" xml:space="preserve">
          <source>The following is a list of metadata entries that a completion function may return in response to a &lt;code&gt;metadata&lt;/code&gt; flag argument:</source>
          <target state="translated">Ниже приводится список записей метаданных, которые функция завершения может возвращать в ответ на аргумент флага &lt;code&gt;metadata&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4a1e6d11578135dd2c40c588ed3ccefbb4f97f26" translate="yes" xml:space="preserve">
          <source>The following is a list of properties that are meaningful for all image types (there are also properties which are meaningful only for certain image types, as documented in the following subsections):</source>
          <target state="translated">Ниже приведен список свойств,которые имеют значение для всех типов изображений (также есть свойства,которые имеют значение только для определенных типов изображений,как описано в следующих подразделах):</target>
        </trans-unit>
        <trans-unit id="4093aee444ad060f90230a5ef648f614d3a0ca58" translate="yes" xml:space="preserve">
          <source>The following is a list of some hook variables that let you provide functions to be called from within Emacs on suitable occasions.</source>
          <target state="translated">Ниже приведен список некоторых переменных перехвата,которые позволяют вызывать функции из Emacs в подходящих случаях.</target>
        </trans-unit>
        <trans-unit id="ccb2830cf31ad8ceb9e30c7ff4ee6d68c4873ecb" translate="yes" xml:space="preserve">
          <source>The following list of conventions is only partial. Each major mode should aim for consistency in general with other Emacs major modes, as this makes Emacs as a whole more coherent. It is impossible to list here all the possible points where this issue might come up; if the Emacs developers point out an area where your major mode deviates from the usual conventions, please make it compatible.</source>
          <target state="translated">Следующий список конвенций является неполным.Каждый основной режим должен быть направлен на согласованность в целом с другими основными режимами Emacs,так как это делает Emacs в целом более согласованным.Здесь невозможно перечислить все возможные моменты,в которых может возникнуть эта проблема;если разработчики Emacs укажут область,в которой ваш основной режим отличается от обычных конвенций,пожалуйста,сделайте его совместимым.</target>
        </trans-unit>
        <trans-unit id="2f4c46986c8a870fb9516c70d5b6f51ae0a91573" translate="yes" xml:space="preserve">
          <source>The following macro provides a convenient way to define pop-up menus and/or menu bar menus.</source>
          <target state="translated">Следующий макрос обеспечивает удобный способ определения всплывающих меню и/или меню панели меню.</target>
        </trans-unit>
        <trans-unit id="5ad57c1f83c65077036b934b7fd3727e3ea0f239" translate="yes" xml:space="preserve">
          <source>The following macros should be used in the body of a function defined by &lt;code&gt;define-inline&lt;/code&gt;.</source>
          <target state="translated">Следующие макросы следует использовать в теле функции, определенной с помощью &lt;code&gt;define-inline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61cd8af7f02eeb28f4ce378e89ac8b778f999f77" translate="yes" xml:space="preserve">
          <source>The following network options can be specified when you create a network process. Except for &lt;code&gt;:reuseaddr&lt;/code&gt;, you can also set or modify these options later, using &lt;code&gt;set-network-process-option&lt;/code&gt;.</source>
          <target state="translated">При создании сетевого процесса можно указать следующие параметры сети. За исключением &lt;code&gt;:reuseaddr&lt;/code&gt; , вы также можете установить или изменить эти параметры позже, используя &lt;code&gt;set-network-process-option&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2fc598c57ec7c3805d2638d2b8b8ee1d26d24c" translate="yes" xml:space="preserve">
          <source>The following option allows to automatically select the window under the mouse pointer. This accomplishes a policy similar to that of window managers that give focus to a frame (and thus trigger its subsequent selection) whenever the mouse pointer enters its window-system window (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">Следующая опция позволяет автоматически выбирать окно под курсором мыши. Это реализует политику, аналогичную политике оконных менеджеров, которые дают фокус кадру (и, таким образом, запускают его последующий выбор) всякий раз, когда указатель мыши входит в его окно оконной системы (см. &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Фокус ввода&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d7851e2664e5c756dae87ae16e5d4cb14feb40f7" translate="yes" xml:space="preserve">
          <source>The following option specifies how to deal with a frame containing just one window that should be either quit, or whose buffer should be buried.</source>
          <target state="translated">Следующая опция определяет,как работать с фреймом,содержащим только одно окно,которое должно либо выйти,либо чей буфер должен быть закопан.</target>
        </trans-unit>
        <trans-unit id="ada5ff929af79df9bfadbae1b79b7910e6c1c8cf" translate="yes" xml:space="preserve">
          <source>The following options affect some aspects of the startup sequence.</source>
          <target state="translated">Следующие варианты влияют на некоторые аспекты последовательности ввода в эксплуатацию.</target>
        </trans-unit>
        <trans-unit id="e1aec0ad769964195d8b0b82e98cb13200879f29" translate="yes" xml:space="preserve">
          <source>The following options provide additional control over the placement of side windows.</source>
          <target state="translated">Следующие опции обеспечивают дополнительный контроль над размещением боковых окон.</target>
        </trans-unit>
        <trans-unit id="0d184dd753268c287e714dc96de749f048d0308b" translate="yes" xml:space="preserve">
          <source>The following parameters are currently used by the window management code:</source>
          <target state="translated">Следующие параметры в настоящее время используются кодом управления окном:</target>
        </trans-unit>
        <trans-unit id="bbb0060fafb1b1a12e73884154b4dd11377c3b26" translate="yes" xml:space="preserve">
          <source>The following parameters are supported:</source>
          <target state="translated">Поддерживаются следующие параметры:</target>
        </trans-unit>
        <trans-unit id="4f59f6941bde6c4db5d1e3e41b34d7afbaba9370" translate="yes" xml:space="preserve">
          <source>The following piece of code demonstrates some important principles of working with iterators.</source>
          <target state="translated">Следующая часть кода демонстрирует некоторые важные принципы работы с итераторами.</target>
        </trans-unit>
        <trans-unit id="a4f0eab4462560047e86c6b11d762d5644d33c5b" translate="yes" xml:space="preserve">
          <source>The following predicates test whether a Lisp object is an atom, whether it is a cons cell or is a list, or whether it is the distinguished object &lt;code&gt;nil&lt;/code&gt;. (Many of these predicates can be defined in terms of the others, but they are used so often that it is worth having them.)</source>
          <target state="translated">Следующие предикаты проверяют, является ли объект Lisp атомом, является ли он cons-ячейкой или списком, или же это выделенный объект &lt;code&gt;nil&lt;/code&gt; . (Многие из этих предикатов можно определить в терминах других, но они используются настолько часто, что их стоит иметь.)</target>
        </trans-unit>
        <trans-unit id="826b4fe071d5c29efd8caca96b29fad3a0a2f2d1" translate="yes" xml:space="preserve">
          <source>The following properties have special meaning:</source>
          <target state="translated">Следующие свойства имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="ebef11ee154eef7f4eb1fc917c2aac083fcb211f" translate="yes" xml:space="preserve">
          <source>The following properties have special meanings:</source>
          <target state="translated">Следующие свойства имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="57c6bef4e378aea04508546ae08d21653ab1f737" translate="yes" xml:space="preserve">
          <source>The following regular expression constructs match the empty string&amp;mdash;that is, they don&amp;rsquo;t use up any characters&amp;mdash;but whether they match depends on the context. For all, the beginning and end of the accessible portion of the buffer are treated as if they were the actual beginning and end of the buffer.</source>
          <target state="translated">Следующие конструкции регулярных выражений соответствуют пустой строке, т. Е. Не используют никаких символов, но их соответствие зависит от контекста. Для всех начало и конец доступной части буфера обрабатываются так, как если бы они были фактическим началом и концом буфера.</target>
        </trans-unit>
        <trans-unit id="ab93757b1beab2aa1b514e6ad4b5403f0cf390d7" translate="yes" xml:space="preserve">
          <source>The following sample code shows a simple use of &lt;code&gt;abbrev-expand-function&lt;/code&gt;. It assumes that &lt;code&gt;foo-mode&lt;/code&gt; is a mode for editing certain files in which lines that start with &amp;lsquo;</source>
          <target state="translated">В следующем примере кода показано простое использование функции &lt;code&gt;abbrev-expand-function&lt;/code&gt; . Предполагается, что &lt;code&gt;foo-mode&lt;/code&gt; - это режим редактирования определенных файлов, в которых строки начинаются с '</target>
        </trans-unit>
        <trans-unit id="cd3bff5b4b8d36513361c4cb174579259d0a14c3" translate="yes" xml:space="preserve">
          <source>The following schematic shows the structure of a live window:</source>
          <target state="translated">Следующая схема показывает структуру живого окна:</target>
        </trans-unit>
        <trans-unit id="3812318991beb737b8ecfc0d3eb9bffa47526a30" translate="yes" xml:space="preserve">
          <source>The following sections describe how to create a package, and how to put it in a &lt;em&gt;package archive&lt;/em&gt; for others to download. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages&quot;&gt;Packages&lt;/a&gt; in</source>
          <target state="translated">В следующих разделах описывается, как создать пакет и как поместить его в &lt;em&gt;архив пакетов&lt;/em&gt; для загрузки другими пользователями. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages&quot;&gt;Пакеты&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="a7f5eb5126f13e48e5d8a4cfa1f8a337e3e76816" translate="yes" xml:space="preserve">
          <source>The following subsections describe dynamic binding and lexical binding in greater detail, and how to enable lexical binding in Emacs Lisp programs.</source>
          <target state="translated">Следующие подразделы более подробно описывают динамическое связывание и лексическое связывание,а также то,как включить лексическое связывание в программах Emacs Lisp.</target>
        </trans-unit>
        <trans-unit id="f427796ad98b404b1017d94a966c0d6e0b800693" translate="yes" xml:space="preserve">
          <source>The following subsections describe these tasks and the</source>
          <target state="translated">Следующие подразделы описывают эти задачи и</target>
        </trans-unit>
        <trans-unit id="557e3858b495db8eb07b06d74c4bda7f399bc1fd" translate="yes" xml:space="preserve">
          <source>The following three functions are convenient subroutines for packages that define non-</source>
          <target state="translated">Следующие три функции являются удобными подпрограммами для пакетов,которые определяют non-</target>
        </trans-unit>
        <trans-unit id="536c73ef47f549795a27c13372e2ba64eb41c149" translate="yes" xml:space="preserve">
          <source>The following three functions are like &lt;code&gt;memq&lt;/code&gt;, &lt;code&gt;delq&lt;/code&gt; and &lt;code&gt;remq&lt;/code&gt;, but use &lt;code&gt;equal&lt;/code&gt; rather than &lt;code&gt;eq&lt;/code&gt; to compare elements. See &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicates&lt;/a&gt;.</source>
          <target state="translated">Следующие три функции похожи на &lt;code&gt;memq&lt;/code&gt; , &lt;code&gt;delq&lt;/code&gt; и &lt;code&gt;remq&lt;/code&gt; , но для сравнения элементов используются &lt;code&gt;equal&lt;/code&gt; а не &lt;code&gt;eq&lt;/code&gt; . См. &amp;laquo; &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Предикаты равенства&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="355f4e1293b1c2362148cc63e3a7bedf8f34b49f" translate="yes" xml:space="preserve">
          <source>The following three functions take as argument a live frame which defaults to the selected one.</source>
          <target state="translated">Следующие три функции принимают в качестве аргумента живой кадр,который по умолчанию является выбранным.</target>
        </trans-unit>
        <trans-unit id="1f17162ac41b5c364770f2de0d633eda6a4b0b6a" translate="yes" xml:space="preserve">
          <source>The following three variables are used in &lt;code&gt;mode-line-modes&lt;/code&gt;:</source>
          <target state="translated">Следующие три переменные используются в &lt;code&gt;mode-line-modes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="29c7181d047de2cd97f0970a6987cb63e7fbbb89" translate="yes" xml:space="preserve">
          <source>The following three variables, when non-&lt;code&gt;nil&lt;/code&gt;, cause the second method to be used in certain special cases. They have no effect on the treatment of files that don&amp;rsquo;t fall into the special cases.</source>
          <target state="translated">Следующие три переменные, если они не &lt;code&gt;nil&lt;/code&gt; , вызывают использование второго метода в определенных особых случаях. Они не влияют на обработку файлов, не относящихся к особым случаям.</target>
        </trans-unit>
        <trans-unit id="115768852bac8cdf35b7fa82a90cdf33ddc11555" translate="yes" xml:space="preserve">
          <source>The following two &lt;code&gt;%&lt;/code&gt;-constructs are still supported, but they are obsolete, since you can get the same results with the variables &lt;code&gt;mode-name&lt;/code&gt; and &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">Следующие две &lt;code&gt;%&lt;/code&gt; -конструкции по-прежнему поддерживаются, но они устарели, поскольку вы можете получить те же результаты с помощью переменных &lt;code&gt;mode-name&lt;/code&gt; &lt;code&gt;global-mode-string&lt;/code&gt; и глобальная-строка-режима .</target>
        </trans-unit>
        <trans-unit id="c8bf40b8538d6f6330c64f3c882e6c1bcb9062c8" translate="yes" xml:space="preserve">
          <source>The following two functions are meant for modes that want to provide help without relinquishing control, such as the electric modes. Their names begin with &amp;lsquo;</source>
          <target state="translated">Следующие две функции предназначены для режимов, в которых требуется помощь без отказа от управления, например для электрических режимов. Их имена начинаются с '</target>
        </trans-unit>
        <trans-unit id="1abd9368a3d734825a10efb49b4dabc426bea1a2" translate="yes" xml:space="preserve">
          <source>The following two functions are useful for combining a list of individual command-line argument strings into a single string, and taking a string apart into a list of individual command-line arguments. These functions are mainly intended for converting user input in the minibuffer, a Lisp string, into a list of string arguments to be passed to &lt;code&gt;make-process&lt;/code&gt;, &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, or for converting such lists of arguments into a single Lisp string to be presented in the minibuffer or echo area. Note that if a shell is involved (e.g., if using &lt;code&gt;call-process-shell-command&lt;/code&gt;), arguments should still be protected by &lt;code&gt;shell-quote-argument&lt;/code&gt;; &lt;code&gt;combine-and-quote-strings&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; intended to protect special characters from shell evaluation.</source>
          <target state="translated">Следующие две функции полезны для объединения списка отдельных строк аргументов командной строки в одну строку и разделения строки на список отдельных аргументов командной строки. Эти функции в основном предназначены для преобразования пользовательского ввода в минибуфер, строки Лиспа, в список строковых аргументов, передаваемых в &lt;code&gt;make-process&lt;/code&gt; , &lt;code&gt;call-process&lt;/code&gt; или &lt;code&gt;start-process&lt;/code&gt; , или для преобразования таких списков аргументов в единый Лисп. строка, которая будет представлена ​​в минибуфере или эхо-области. Обратите внимание, что если задействована оболочка (например, при использовании команды &lt;code&gt;call-process-shell-command&lt;/code&gt; ), аргументы все равно должны быть защищены &lt;code&gt;shell-quote-argument&lt;/code&gt; ; &lt;code&gt;combine-and-quote-strings&lt;/code&gt; это &lt;em&gt;не&lt;/em&gt; предназначен для защиты специальных символов от оценки оболочки.</target>
        </trans-unit>
        <trans-unit id="345ce9209913e7b713026911f4f5e94a02bd44b6" translate="yes" xml:space="preserve">
          <source>The following two functions are useful when a Lisp program needs to map buffer positions to byte offsets in a file visited by the buffer.</source>
          <target state="translated">Следующие две функции полезны,когда программе на языке Lisp необходимо сопоставить позиции буфера со смещениями байт в файле,посещаемом буфером.</target>
        </trans-unit>
        <trans-unit id="f6e12a6446862c2522d3f1a9ffd8ddf8904cc177" translate="yes" xml:space="preserve">
          <source>The following two functions can be used to return the total size of a window in units of pixels.</source>
          <target state="translated">Следующие две функции могут быть использованы для возврата общего размера окна в единицах пикселей.</target>
        </trans-unit>
        <trans-unit id="a48c7947820ecbb53fcfdd25e5c96ba5864b3d86" translate="yes" xml:space="preserve">
          <source>The following two functions can be useful when working with child and parent frames:</source>
          <target state="translated">Следующие две функции могут быть полезны при работе с дочерними и родительскими кадрами:</target>
        </trans-unit>
        <trans-unit id="2a83b06e67c6529bbdbddb0d5afbb5cf809d5bcc" translate="yes" xml:space="preserve">
          <source>The following two functions convert between directory names and directory file names. They do nothing special with environment variable substitutions such as &amp;lsquo;</source>
          <target state="translated">Следующие две функции преобразуют имена каталогов в имена файлов каталогов. Они не делают ничего особенного с заменами переменных среды, такими как '</target>
        </trans-unit>
        <trans-unit id="4fac544aa9936ae6c2b6929f4306babf281bddd4" translate="yes" xml:space="preserve">
          <source>The following two functions move point over a specified set of characters. For example, they are often used to skip whitespace. For related functions, see &lt;a href=&quot;motion-and-syntax#Motion-and-Syntax&quot;&gt;Motion and Syntax&lt;/a&gt;.</source>
          <target state="translated">Следующие две функции перемещают точку по указанному набору символов. Например, они часто используются для пропуска пробелов. Для связанных функций см. &lt;a href=&quot;motion-and-syntax#Motion-and-Syntax&quot;&gt;Движение и Синтаксис&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c338e0f1681bbeb0ada6c9b11a1251284be5bda" translate="yes" xml:space="preserve">
          <source>The following two functions return a mouse position list (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), specifying the position of a mouse event.</source>
          <target state="translated">Следующие две функции возвращают список положений мыши (см. &amp;laquo; &lt;a href=&quot;click-events#Click-Events&quot;&gt;События щелчка&amp;raquo;&lt;/a&gt; ), определяя положение события мыши.</target>
        </trans-unit>
        <trans-unit id="cc0b4c0c74f55c58b403e95e6a1acfb6ff12b20c" translate="yes" xml:space="preserve">
          <source>The following two functions return important information about a font.</source>
          <target state="translated">Следующие две функции возвращают важную информацию о шрифте.</target>
        </trans-unit>
        <trans-unit id="1e7e472e6478094296cd45e3d521f50016cac3a3" translate="yes" xml:space="preserve">
          <source>The following two options control whether minibuffer windows are resized automatically and how large they can get in the process.</source>
          <target state="translated">Следующие два варианта контролируют автоматическое изменение размера окон минибуфера и их размер.</target>
        </trans-unit>
        <trans-unit id="24fa8abe9618c4cb6b7db987de4f0d9cacb7fa8f" translate="yes" xml:space="preserve">
          <source>The following two regular expressions should &lt;em&gt;not&lt;/em&gt; assume the match always starts at the beginning of a line; they should not use &amp;lsquo;</source>
          <target state="translated">Следующие два регулярных выражения &lt;em&gt;не&lt;/em&gt; должны предполагать, что совпадение всегда начинается в начале строки; они не должны использовать '</target>
        </trans-unit>
        <trans-unit id="cc6bf9832061e83897200953f3dd12c79d5af846" translate="yes" xml:space="preserve">
          <source>The following two variables are obsoleted by &lt;code&gt;filter-buffer-substring-function&lt;/code&gt;, but are still supported for backward compatibility.</source>
          <target state="translated">Следующие две переменные устарели &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; , но все еще поддерживаются для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="4d489eae93ac203d9b2ffd3584656c2dde948029" translate="yes" xml:space="preserve">
          <source>The following values are respected:</source>
          <target state="translated">Соблюдаются следующие ценности:</target>
        </trans-unit>
        <trans-unit id="09aa9057414e7950dd19147648c16cf90861056f" translate="yes" xml:space="preserve">
          <source>The following variables affect how certain characters are displayed on the screen. Since they change the number of columns the characters occupy, they also affect the indentation functions. They also affect how the mode line is displayed; if you want to force redisplay of the mode line using the new values, call the function &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">Следующие переменные влияют на то, как определенные символы отображаются на экране. Поскольку они изменяют количество столбцов, которые занимают символы, они также влияют на функции отступа. Они также влияют на то, как отображается строка режима; если вы хотите принудительно повторно отобразить строку режима с использованием новых значений, вызовите функцию &lt;code&gt;force-mode-line-update&lt;/code&gt; (см. &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Формат строки режима&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="14dec20b7fbc6fcced5e5d29086ee55e867ebdd4" translate="yes" xml:space="preserve">
          <source>The following will create a linear gradient that goes from red at the start, to green 25% of the way, to blue at the end:</source>
          <target state="translated">Следующее создаст линейный градиент,который переходит от красного в начале,к зеленому 25% пути,к синему в конце:</target>
        </trans-unit>
        <trans-unit id="e95288a0f9a444d98e8a41cba18b24ae66da9ad1" translate="yes" xml:space="preserve">
          <source>The font must be an OpenType font that supports these OpenType features, provided Emacs is compiled with a library, such as &amp;lsquo;</source>
          <target state="translated">Шрифт должен быть шрифтом OpenType, который поддерживает эти функции OpenType, при условии, что Emacs скомпилирован с библиотекой, такой как '</target>
        </trans-unit>
        <trans-unit id="6556801bce4e544f06ab7ea9eb5f7746cb4afd5e" translate="yes" xml:space="preserve">
          <source>The font name (a string), in either XLFD, Fontconfig, or GTK+ format. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">Имя шрифта (строка) в формате XLFD, Fontconfig или GTK +. См. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Шрифты&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="af0bd798857380a819581a44d67b89d6f115632d" translate="yes" xml:space="preserve">
          <source>The font name, a string.</source>
          <target state="translated">Имя шрифта,строка.</target>
        </trans-unit>
        <trans-unit id="a7248edb376ccd7b3b10bb9e3cb840736177f911" translate="yes" xml:space="preserve">
          <source>The font size&amp;mdash;either a non-negative integer that specifies the pixel size, or a floating-point number that specifies the point size.</source>
          <target state="translated">Размер шрифта - неотрицательное целое число, определяющее размер в пикселях, или число с плавающей запятой, определяющее размер точки.</target>
        </trans-unit>
        <trans-unit id="23f58ef9a79c9daa9a087fb25286120885af393b" translate="yes" xml:space="preserve">
          <source>The font used to display the face. Its value should be a font object or a fontset. See &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Low-Level Font&lt;/a&gt;, for information about font objects, font specs, and font entities. See &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;, for information about fontsets.</source>
          <target state="translated">Шрифт, используемый для отображения лица. Его значение должно быть объектом шрифта или набором шрифтов. См. &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Низкоуровневый шрифт&lt;/a&gt; для получения информации об объектах шрифтов, спецификациях шрифтов и объектах шрифтов. См. &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Наборы шрифтов&lt;/a&gt; для получения информации о наборах шрифтов.</target>
        </trans-unit>
        <trans-unit id="3e2495d3f6b500a7c3764a7896dc703df930eb34" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(+ &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; adds up the value of the expressions. The form &lt;code&gt;(- &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; negates or subtracts the value of the expressions.</source>
          <target state="translated">Форма &lt;code&gt;(+ &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; суммирует значения выражений. Форма &lt;code&gt;(- &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; отрицает или вычитает значение выражений.</target>
        </trans-unit>
        <trans-unit id="f9074ede26f7f654c16278889f1f4de2d0cebbf4" translate="yes" xml:space="preserve">
          <source>The form &lt;var&gt;num&lt;/var&gt; specifies a fraction of the default frame font height or width. The form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt;)&lt;/code&gt; specifies an absolute number of pixels. If &lt;var&gt;num&lt;/var&gt; is a symbol, &lt;var&gt;symbol&lt;/var&gt;, its buffer-local variable binding is used; that binding can be either a number or a cons cell of the forms shown above (including yet another cons cell whose &lt;code&gt;car&lt;/code&gt; is a symbol that has a buffer-local binding).</source>
          <target state="translated">Форма &lt;var&gt;num&lt;/var&gt; определяет долю высоты или ширины шрифта рамки по умолчанию. Форма &lt;code&gt;(&lt;var&gt;num&lt;/var&gt;)&lt;/code&gt; указывает абсолютное количество пикселей. Если &lt;var&gt;num&lt;/var&gt; является символом, &lt;var&gt;symbol&lt;/var&gt; , используется его привязка к локальной переменной в буфере; эта привязка может быть числом или cons-ячейкой форм, показанных выше (включая еще одну cons-ячейку, &lt;code&gt;car&lt;/code&gt; которой является символом, имеющим локальную привязку к буферу).</target>
        </trans-unit>
        <trans-unit id="eefdf767b9da94cedb2272c4d442fd16a210f77a" translate="yes" xml:space="preserve">
          <source>The format of &lt;var&gt;local-address&lt;/var&gt; or &lt;var&gt;remote-address&lt;/var&gt; depends on the address family:</source>
          <target state="translated">Формат &lt;var&gt;local-address&lt;/var&gt; или &lt;var&gt;remote-address&lt;/var&gt; зависит от семейства адресов:</target>
        </trans-unit>
        <trans-unit id="f1523839ef4d5afd7ac94bcc51e58e0b20efc3f4" translate="yes" xml:space="preserve">
          <source>The format of this list is the same as what &lt;code&gt;decode-time&lt;/code&gt; accepts (see &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;), and is described in more detail there. Any element that cannot be determined from the input will be set to &lt;code&gt;nil&lt;/code&gt;. The argument &lt;var&gt;string&lt;/var&gt; should resemble an RFC 822 (or later) or ISO 8601 string, like &amp;ldquo;Fri, 25 Mar 2016 16:24:56 +0100&amp;rdquo; or &amp;ldquo;1998-09-12T12:21:54-0200&amp;rdquo;, but this function will attempt to parse less well-formed time strings as well.</source>
          <target state="translated">Формат этого списка совпадает с форматом, который принимает &lt;code&gt;decode-time&lt;/code&gt; (см. &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Преобразование времени&lt;/a&gt; ), и описан там более подробно. Любой элемент, который не может быть определен из ввода, будет установлен в &lt;code&gt;nil&lt;/code&gt; . &lt;var&gt;string&lt;/var&gt; аргумента должна напоминать строку RFC 822 (или новее) или ISO 8601, например &amp;laquo;Пятница, 25 марта 2016 16:24:56 +0100&amp;raquo; или &amp;laquo;1998-09-12T12: 21: 54-0200&amp;raquo;, но эта функция также попытается проанализировать менее правильно сформированные строки времени.</target>
        </trans-unit>
        <trans-unit id="a420ccf20ba6d5b4c425fdd899162dfbbd53605d" translate="yes" xml:space="preserve">
          <source>The format we use for buffer contents in examples.</source>
          <target state="translated">Формат,который мы используем для содержимого буфера в примерах.</target>
        </trans-unit>
        <trans-unit id="4a56368511816baafb987e4550f7fd019ef9406d" translate="yes" xml:space="preserve">
          <source>The format we use for examples of errors.</source>
          <target state="translated">Формат,который мы используем для примеров ошибок.</target>
        </trans-unit>
        <trans-unit id="39ba77d521c50dab220364437e7b5dabde639177" translate="yes" xml:space="preserve">
          <source>The format we use for examples of evaluation.</source>
          <target state="translated">Формат,который мы используем для примеров оценки.</target>
        </trans-unit>
        <trans-unit id="37518e914cc1faa1cdf2b3e15db2c5a92c8aeff9" translate="yes" xml:space="preserve">
          <source>The format we use when examples print text.</source>
          <target state="translated">Формат,который мы используем,когда примеры печатают текст.</target>
        </trans-unit>
        <trans-unit id="17e1d52af71f6c32ba5e92306abc4c53f00bf057" translate="yes" xml:space="preserve">
          <source>The former is used by overlay arrows. The latter is unused.</source>
          <target state="translated">Первый используется стрелками наложения.Вторая не используется.</target>
        </trans-unit>
        <trans-unit id="203096a174bb892e518022e452e96010dd9a8b89" translate="yes" xml:space="preserve">
          <source>The forms &lt;var&gt;pre-form&lt;/var&gt; and &lt;var&gt;post-form&lt;/var&gt; can be used to initialize before, and cleanup after, &lt;var&gt;anchored-matcher&lt;/var&gt; is used. Typically, &lt;var&gt;pre-form&lt;/var&gt; is used to move point to some position relative to the match of &lt;var&gt;matcher&lt;/var&gt;, before starting with &lt;var&gt;anchored-matcher&lt;/var&gt;. &lt;var&gt;post-form&lt;/var&gt; might be used to move back, before resuming with &lt;var&gt;matcher&lt;/var&gt;.</source>
          <target state="translated">Формы &lt;var&gt;pre-form&lt;/var&gt; и &lt;var&gt;post-form&lt;/var&gt; могут использоваться для инициализации до и очистки после использования &lt;var&gt;anchored-matcher&lt;/var&gt; . Как правило, &lt;var&gt;pre-form&lt;/var&gt; используется для перемещения точки в некоторую позицию относительно соответствия &lt;var&gt;matcher&lt;/var&gt; перед запуском с &lt;var&gt;anchored-matcher&lt;/var&gt; . &lt;var&gt;post-form&lt;/var&gt; может использоваться для возврата перед возобновлением с помощью &lt;var&gt;matcher&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ceadb637a596eb2ee47bea0bcd88b1125c133ad0" translate="yes" xml:space="preserve">
          <source>The fourth argument &lt;var&gt;parents&lt;/var&gt; says whether to create parent directories if they don&amp;rsquo;t exist. Interactively, this happens by default.</source>
          <target state="translated">Четвертый аргумент &lt;var&gt;parents&lt;/var&gt; говорят, создавать ли родительские каталоги, если они не существуют. В интерактивном режиме это происходит по умолчанию.</target>
        </trans-unit>
        <trans-unit id="49ca71782e46f41b945559e28fbf6e1d7928a06f" translate="yes" xml:space="preserve">
          <source>The fourth element is the buffer whose display caused the creation of this parameter. This function may delete &lt;var&gt;window&lt;/var&gt; if and only if it still shows that buffer.</source>
          <target state="translated">Четвертый элемент - буфер, отображение которого вызвало создание этого параметра. Эта функция может удалить &lt;var&gt;window&lt;/var&gt; тогда и только тогда, когда он все еще показывает этот буфер.</target>
        </trans-unit>
        <trans-unit id="d53d197ac8b2d3804741dce6c2249997a484aa11" translate="yes" xml:space="preserve">
          <source>The fourth of these hooks is run when a &lt;em&gt;window state change&lt;/em&gt; has been detected, which means that at least one of the three preceding window changes has occurred.</source>
          <target state="translated">Четвертая из этих ловушек запускается при обнаружении &lt;em&gt;изменения состояния окна&lt;/em&gt; , что означает, что произошло по крайней мере одно из трех предыдущих изменений окна.</target>
        </trans-unit>
        <trans-unit id="d2076a0c8c9f8876e127e6de37bf8d5c9fd0314f" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a GNUstep or Macintosh Cocoa graphical terminal.</source>
          <target state="translated">Рамка отображается на графическом терминале GNUstep или Macintosh Cocoa.</target>
        </trans-unit>
        <trans-unit id="367eb419b499e34c2cd9b561d4ff309824830d6d" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a MS-Windows graphical terminal.</source>
          <target state="translated">Рамка отображается на графическом терминале MS-Windows.</target>
        </trans-unit>
        <trans-unit id="bd7f603302ec782d1f108752979a4bc3b06f4239" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a text terminal.</source>
          <target state="translated">Рамка отображается на текстовом терминале.</target>
        </trans-unit>
        <trans-unit id="fcb9d54a78150d03f883ce9267fb2578c072d2bd" translate="yes" xml:space="preserve">
          <source>The frame is displayed on an MS-DOS terminal.</source>
          <target state="translated">Рамка отображается на терминале MS-DOS.</target>
        </trans-unit>
        <trans-unit id="0cd07edbb9f4b3175639e8806bf60c5f910fe981" translate="yes" xml:space="preserve">
          <source>The frame is displayed on an X graphical terminal.</source>
          <target state="translated">Рамка отображается на графическом терминале X.</target>
        </trans-unit>
        <trans-unit id="fede82ee27758855ee100077f5a256f38ab0e02a" translate="yes" xml:space="preserve">
          <source>The frame parameter &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; controls whether the windows in the frame have horizontal scroll bars. The frame parameter &lt;code&gt;scroll-bar-height&lt;/code&gt; specifies how high they are (&lt;code&gt;nil&lt;/code&gt; meaning the default). See &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;.</source>
          <target state="translated">Параметр frame &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; определяет, есть ли в окнах во фрейме горизонтальные полосы прокрутки. Параметр frame &lt;code&gt;scroll-bar-height&lt;/code&gt; указывает их высоту ( &lt;code&gt;nil&lt;/code&gt; означает значение по умолчанию). См. &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Параметры макета&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="438a2d89a52bbe188d6d849c93e8088d3f1e967a" translate="yes" xml:space="preserve">
          <source>The frame that this window is on, as a Lisp object.</source>
          <target state="translated">Рамка,на которой находится это окно,как объект Lisp.</target>
        </trans-unit>
        <trans-unit id="f2ddf76bbb94fa6e3bd71370e008e9006e3aab9c" translate="yes" xml:space="preserve">
          <source>The frame with input focus might not take up the entire screen, and the user might move the mouse outside the scope of the frame. Inside the &lt;code&gt;track-mouse&lt;/code&gt; special form, that produces an event like this:</source>
          <target state="translated">Рамка с фокусом ввода может не занимать весь экран, и пользователь может переместить мышь за пределы рамки. Внутри специальной формы &lt;code&gt;track-mouse&lt;/code&gt; , которая генерирует подобное событие:</target>
        </trans-unit>
        <trans-unit id="875b4545e11911510ae3368c34f49d2bafeade1c" translate="yes" xml:space="preserve">
          <source>The frames can be used either to represent multiple pages (this is usually the case with multi-frame TIFF files, for example), or to create animation (usually the case with multi-frame GIF files).</source>
          <target state="translated">Кадры могут использоваться как для представления нескольких страниц (обычно это происходит,например,в многокадровых файлах TIFF),так и для создания анимации (обычно это происходит в многокадровых GIF-файлах).</target>
        </trans-unit>
        <trans-unit id="07c1bfad504d407e4dd4bddeff5e7e54de2cc8eb" translate="yes" xml:space="preserve">
          <source>The fringes normally appear between the display margins and the window text. If the value is non-&lt;code&gt;nil&lt;/code&gt;, they appear outside the display margins. See &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;.</source>
          <target state="translated">Полосы обычно появляются между полями отображения и текстом окна. Если значение не равно &lt;code&gt;nil&lt;/code&gt; , они появляются за пределами полей дисплея. См. Раздел &amp;laquo; &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Отображаемые поля&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10a232c8c99be2bcdac3d854a4c57a0b7926f249" translate="yes" xml:space="preserve">
          <source>The full keymap containing default global key bindings. Modes should not modify the Global map.</source>
          <target state="translated">Полная клавиатурная карта,содержащая привязки глобальных ключей по умолчанию.Режимы не должны изменять карту мира.</target>
        </trans-unit>
        <trans-unit id="ab21d625fa99d9e8689a87a9df340768d973d686" translate="yes" xml:space="preserve">
          <source>The full name of the font, a string.</source>
          <target state="translated">Полное имя шрифта,строка.</target>
        </trans-unit>
        <trans-unit id="55c491134e3f247e07eb606aa328fc5be9cb20cc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;accept-process-output&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt; if it got output from &lt;var&gt;process&lt;/var&gt;, or from any process if &lt;var&gt;process&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;; this can occur even after a process has exited if the corresponding connection contains buffered data. The function returns &lt;code&gt;nil&lt;/code&gt; if the timeout expired or the connection was closed before output arrived.</source>
          <target state="translated">Функция &lt;code&gt;accept-process-output&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; если она получила вывод от &lt;var&gt;process&lt;/var&gt; , или от любого процесса, если &lt;var&gt;process&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; ; это может произойти даже после выхода из процесса, если соответствующее соединение содержит буферизованные данные. Функция возвращает &lt;code&gt;nil&lt;/code&gt; если истекло время ожидания или соединение было закрыто до получения вывода.</target>
        </trans-unit>
        <trans-unit id="ec51fe801ce783ab41bbcfb2b068eb8495fcb6f6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;assoc-string&lt;/code&gt; is much like &lt;code&gt;assoc&lt;/code&gt; except that it ignores certain differences between strings. See &lt;a href=&quot;text-comparison#Text-Comparison&quot;&gt;Text Comparison&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;assoc-string&lt;/code&gt; очень похожа на &lt;code&gt;assoc&lt;/code&gt; , за исключением того, что она игнорирует определенные различия между строками. См. &lt;a href=&quot;text-comparison#Text-Comparison&quot;&gt;Сравнение текстов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2e7d56e51665dc0e2c86ee380cef89f5612161" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;backtrace-frame&lt;/code&gt; is intended for use in Lisp debuggers. It returns information about what computation is happening in the stack frame &lt;var&gt;frame-number&lt;/var&gt; levels down.</source>
          <target state="translated">Функция &lt;code&gt;backtrace-frame&lt;/code&gt; предназначена для использования в отладчиках Lisp. Он возвращает информацию о том, какие вычисления происходят в стеке на нижний уровень &lt;var&gt;frame-number&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="2a41471492f0d30da94cc86b34cd0a1d952ae5da" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;backward-prefix-chars&lt;/code&gt; moves back over these characters, as well as over characters whose primary syntax class is prefix (&amp;lsquo;</source>
          <target state="translated">Функция &lt;code&gt;backward-prefix-chars&lt;/code&gt; перемещается назад по этим символам, а также по символам, основным синтаксическим классом которых является prefix ('</target>
        </trans-unit>
        <trans-unit id="ff9303e475f1b984abb99f23fe5e1bde3414024c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; does not call these functions, since it ignores text properties anyway.</source>
          <target state="translated">Функция &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; не вызывает эти функции, так как в любом случае игнорирует текстовые свойства.</target>
        </trans-unit>
        <trans-unit id="ab0ed3a952ff9a1871cc2361e3809682f2c953e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;collapse-delayed-warnings&lt;/code&gt; removes repeated entries from &lt;code&gt;delayed-warnings-list&lt;/code&gt;. The function &lt;code&gt;display-delayed-warnings&lt;/code&gt; calls &lt;code&gt;display-warning&lt;/code&gt; on each of the entries in &lt;code&gt;delayed-warnings-list&lt;/code&gt;, in turn, and then sets &lt;code&gt;delayed-warnings-list&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;collapse-delayed-warnings&lt;/code&gt; удаляет повторяющиеся записи из &lt;code&gt;delayed-warnings-list&lt;/code&gt; . Функция &lt;code&gt;display-delayed-warnings&lt;/code&gt; вызывает &lt;code&gt;display-warning&lt;/code&gt; о каждом из записей в &lt;code&gt;delayed-warnings-list&lt;/code&gt; , в свою очередь, а затем устанавливает &lt;code&gt;delayed-warnings-list&lt;/code&gt; на &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aca3a04eca1514a9f44c05fb78a24a6564571ff6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;completing-read&lt;/code&gt; provides a higher-level interface for completion. A call to &lt;code&gt;completing-read&lt;/code&gt; specifies how to determine the list of valid names. The function then activates the minibuffer with a local keymap that binds a few keys to commands useful for completion. Other functions provide convenient simple interfaces for reading certain kinds of names with completion.</source>
          <target state="translated">Функция &lt;code&gt;completing-read&lt;/code&gt; предоставляет интерфейс более высокого уровня для завершения. Вызов функции &lt;code&gt;completing-read&lt;/code&gt; указывает, как определить список допустимых имен. Затем функция активирует минибуфер с локальной раскладкой клавиш, которая связывает несколько клавиш с командами, полезными для завершения. Другие функции предоставляют удобные простые интерфейсы для чтения определенных видов имен с завершением.</target>
        </trans-unit>
        <trans-unit id="743a6545ecb435ebd9f3de6185649c8ee66cb997" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;completing-read&lt;/code&gt; uses &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; as the keymap if &lt;var&gt;require-match&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and uses &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt; if &lt;var&gt;require-match&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Completion Commands&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;completing-read&lt;/code&gt; использует &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; как карту ключей, если &lt;var&gt;require-match&lt;/var&gt; равно &lt;code&gt;nil&lt;/code&gt; , и использует &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt; если &lt;var&gt;require-match&lt;/var&gt; отличное от &lt;code&gt;nil&lt;/code&gt; . См. &amp;laquo; &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Команды завершения&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb114701d962dcc2e639c63a654e62af9ffd7c5a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coordinates-in-window-p&lt;/code&gt; does not require a frame as argument because it always uses the frame that &lt;var&gt;window&lt;/var&gt; is on.</source>
          <target state="translated">Функция &lt;code&gt;coordinates-in-window-p&lt;/code&gt; не требует фрейма в качестве аргумента, поскольку всегда использует фрейм, в котором находится &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b3ded67b9cd070ced5aa2445c9069b81dfc417" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current-kill&lt;/code&gt; rotates the yanking pointer, which designates the front of the kill ring, by &lt;var&gt;n&lt;/var&gt; places (from newer kills to older ones), and returns the text at that place in the ring.</source>
          <target state="translated">Функция &lt;code&gt;current-kill&lt;/code&gt; поворачивает указатель дергания, который обозначает переднюю часть кольца уничтожений, на &lt;var&gt;n&lt;/var&gt; мест (от новых убийств к старым) и возвращает текст в этом месте кольца.</target>
        </trans-unit>
        <trans-unit id="c09d1b87df08862239116751f48f0df4995d72f7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;default-boundp&lt;/code&gt; tells you whether &lt;var&gt;symbol&lt;/var&gt;&amp;rsquo;s default value is nonvoid. If &lt;code&gt;(default-boundp 'foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;(default-value 'foo)&lt;/code&gt; would get an error.</source>
          <target state="translated">Функция &lt;code&gt;default-boundp&lt;/code&gt; сообщает вам, является ли значение &lt;var&gt;symbol&lt;/var&gt; умолчанию недействительным. Если &lt;code&gt;(default-boundp 'foo)&lt;/code&gt; возвращает &lt;code&gt;nil&lt;/code&gt; , тогда &lt;code&gt;(default-value 'foo)&lt;/code&gt; получит ошибку.</target>
        </trans-unit>
        <trans-unit id="3d944e42054c18a15837fce5fb4f736d90edcbfc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;delete-other-windows&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to make the atomic window fill its frame or main window (see &lt;a href=&quot;side-windows#Side-Windows&quot;&gt;Side Windows&lt;/a&gt;).</source>
          <target state="translated">Функция &lt;code&gt;delete-other-windows&lt;/code&gt; (см. &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Раздел &amp;laquo;Удаление окон&amp;raquo;&lt;/a&gt; ) при применении к составной части атомарного окна будет пытаться заставить атомарное окно заполнить его фрейм или главное окно (см. &lt;a href=&quot;side-windows#Side-Windows&quot;&gt;Боковые окна&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9dffa9767ac8103870c396df1d01712edad9731f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;delete-window&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to delete the entire atomic window instead.</source>
          <target state="translated">Функция &lt;code&gt;delete-window&lt;/code&gt; (см. Раздел &amp;laquo; &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Удаление окон&amp;raquo;&lt;/a&gt; ), когда применяется к составной части атомарного окна, вместо этого будет пытаться удалить все атомарное окно.</target>
        </trans-unit>
        <trans-unit id="6dbf1bcd36e45950ad0668297034db25fc20918d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;elt&lt;/code&gt; is similar, but applies to any kind of sequence. For historical reasons, it takes its arguments in the opposite order. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;elt&lt;/code&gt; аналогична, но применима к любой последовательности. По историческим причинам он приводит аргументы в обратном порядке. См. &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Последовательные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53ea0623909a1543789ee0d4705170a49f5a1097" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;equal&lt;/code&gt; can also compare two window configurations; it regards configurations as unequal if they differ in any respect, even a saved point.</source>
          <target state="translated">Функция &lt;code&gt;equal&lt;/code&gt; также может сравнивать две конфигурации окон; он считает конфигурации неравными, если они различаются в каком-либо отношении, даже если они сохранены.</target>
        </trans-unit>
        <trans-unit id="15f22c5a8ef685b2d1157d55627f2e569a64550a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;foo&lt;/code&gt; subtracts &lt;var&gt;integer1&lt;/var&gt; from &lt;var&gt;integer2&lt;/var&gt;, then adds all the rest of the arguments to the result. If &lt;var&gt;integer2&lt;/var&gt; is not supplied, then the number 19 is used by default.</source>
          <target state="translated">Функция &lt;code&gt;foo&lt;/code&gt; вычитает &lt;var&gt;integer1&lt;/var&gt; из &lt;var&gt;integer2&lt;/var&gt; , а затем добавляет все остальные аргументы к результату. Если &lt;var&gt;integer2&lt;/var&gt; не указан, то по умолчанию используется число 19.</target>
        </trans-unit>
        <trans-unit id="142092b37bd14d5b1415337e59a8ef7820027ffe" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format-spec&lt;/code&gt; described in this section performs a similar function to &lt;code&gt;format&lt;/code&gt;, except it operates on format control strings that use arbitrary specification characters.</source>
          <target state="translated">Функция &lt;code&gt;format-spec&lt;/code&gt; , описанная в этом разделе, выполняет функцию, аналогичную функции &lt;code&gt;format&lt;/code&gt; , за исключением того, что она работает со строками управления форматом, которые используют произвольные символы спецификации.</target>
        </trans-unit>
        <trans-unit id="580c556614ef2beffd862c0457ca3264d0d95fa2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;frame-parameters&lt;/code&gt; returns an alist listing all the parameters of &lt;var&gt;frame&lt;/var&gt; and their values. If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, this returns the selected frame&amp;rsquo;s parameters</source>
          <target state="translated">Функция &lt;code&gt;frame-parameters&lt;/code&gt; возвращает список, в котором перечислены все параметры &lt;var&gt;frame&lt;/var&gt; и их значения. Если &lt;var&gt;frame&lt;/var&gt; равен &lt;code&gt;nil&lt;/code&gt; или опущен, это возвращает параметры выбранного кадра</target>
        </trans-unit>
        <trans-unit id="fc4daa549e176d014e533dbad29a89e4b64d4d76" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;getx&lt;/code&gt; refers to &lt;code&gt;x&lt;/code&gt;. This is a &lt;em&gt;free&lt;/em&gt; reference, in the sense that there is no binding for &lt;code&gt;x&lt;/code&gt; within that &lt;code&gt;defun&lt;/code&gt; construct itself. When we call &lt;code&gt;getx&lt;/code&gt; from within a &lt;code&gt;let&lt;/code&gt; form in which &lt;code&gt;x&lt;/code&gt; is (dynamically) bound, it retrieves the local value (i.e., 1). But when we call &lt;code&gt;getx&lt;/code&gt; outside the &lt;code&gt;let&lt;/code&gt; form, it retrieves the global value (i.e., -99).</source>
          <target state="translated">Функция &lt;code&gt;getx&lt;/code&gt; ссылается на &lt;code&gt;x&lt;/code&gt; . Это &lt;em&gt;бесплатная&lt;/em&gt; ссылка в том смысле, что нет привязки для &lt;code&gt;x&lt;/code&gt; внутри самой этой &lt;code&gt;defun&lt;/code&gt; конструкции. Когда мы вызываем &lt;code&gt;getx&lt;/code&gt; из формы &lt;code&gt;let&lt;/code&gt; , в которой &lt;code&gt;x&lt;/code&gt; (динамически) привязан, он извлекает локальное значение (например, 1). Но когда мы вызываем &lt;code&gt;getx&lt;/code&gt; вне формы &lt;code&gt;let&lt;/code&gt; , он получает глобальное значение (например, -99).</target>
        </trans-unit>
        <trans-unit id="e222099e0dbd9ca9d8f1867678a5de58c410df4b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-file-contents&lt;/code&gt; automatically recognizes file formats when it reads the specified file. It checks the text of the beginning of the file against the regular expressions of the format definitions, and if it finds a match, it calls the decoding function for that format. Then it checks all the known formats over again. It keeps checking them until none of them is applicable.</source>
          <target state="translated">Функция &lt;code&gt;insert-file-contents&lt;/code&gt; автоматически распознает форматы файлов при чтении указанного файла. Он проверяет текст начала файла на соответствие регулярным выражениям определений формата и, если обнаруживает совпадение, вызывает функцию декодирования для этого формата. Затем снова проверяет все известные форматы. Он продолжает проверять их до тех пор, пока ни один из них не подходит.</target>
        </trans-unit>
        <trans-unit id="1b53622592c53b4408af724ef50deb90f84d0660" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-file-contents&lt;/code&gt;:</source>
          <target state="translated">Функция &lt;code&gt;insert-file-contents&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0ced44529508f6a3572121eaa375fc4ced75820b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-for-yank&lt;/code&gt; automatically sets this variable according to the &lt;var&gt;undo&lt;/var&gt; element of the &lt;code&gt;yank-handler&lt;/code&gt; text property, if there is one.</source>
          <target state="translated">Функция &lt;code&gt;insert-for-yank&lt;/code&gt; автоматически устанавливает эту переменную в соответствии с элементом &lt;var&gt;undo&lt;/var&gt; в текстовом свойстве &lt;code&gt;yank-handler&lt;/code&gt; , если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="63c67cfe6f9d58e7894dfaf98f9e257cab3b6ab1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;kill-all-local-variables&lt;/code&gt; runs this normal hook before it does anything else. This gives major modes a way to arrange for something special to be done if the user switches to a different major mode. It is also useful for buffer-specific minor modes that should be forgotten if the user changes the major mode.</source>
          <target state="translated">Функция &lt;code&gt;kill-all-local-variables&lt;/code&gt; запускает этот обычный перехватчик до того, как сделает что-нибудь еще. Это дает основным режимам возможность организовать что-то особенное, если пользователь переключается в другой основной режим. Это также полезно для второстепенных режимов, специфичных для буфера, о которых следует забыть, если пользователь изменяет основной режим.</target>
        </trans-unit>
        <trans-unit id="db6ce2dd6e8f67ccadb8ee5dc896d171a780cbcc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;macroexpand&lt;/code&gt; does not expand calls to inline functions. Normally there is no need for that, since a call to an inline function is no harder to understand than a call to an ordinary function.</source>
          <target state="translated">Функция &lt;code&gt;macroexpand&lt;/code&gt; не расширяет вызовы встроенных функций. Обычно в этом нет необходимости, поскольку вызов встроенной функции понять не сложнее, чем вызов обычной функции.</target>
        </trans-unit>
        <trans-unit id="8ca63acdedc01018b5b5ff8ef5fd299f693dc141" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;map-keymap&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; once for each binding in &lt;var&gt;keymap&lt;/var&gt;. It passes two arguments, the event type and the value of the binding. If &lt;var&gt;keymap&lt;/var&gt; has a parent, the parent&amp;rsquo;s bindings are included as well. This works recursively: if the parent has itself a parent, then the grandparent&amp;rsquo;s bindings are also included and so on.</source>
          <target state="translated">Функция &lt;code&gt;map-keymap&lt;/code&gt; вызывает &lt;var&gt;function&lt;/var&gt; один раз для каждой привязки в &lt;var&gt;keymap&lt;/var&gt; . Он передает два аргумента: тип события и значение привязки. Если у &lt;var&gt;keymap&lt;/var&gt; есть родитель, привязки родителя также включаются. Это работает рекурсивно: если у родителя есть сам родитель, то также включаются привязки дедушки и бабушки и так далее.</target>
        </trans-unit>
        <trans-unit id="4993f97cab68094466e932cb10bb5175cf66f558" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mapbacktrace&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; once for each frame in the backtrace, starting at the first frame whose function is &lt;var&gt;base&lt;/var&gt; (or from the top if &lt;var&gt;base&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">Функция &lt;code&gt;mapbacktrace&lt;/code&gt; вызывает &lt;var&gt;function&lt;/var&gt; один раз для каждого кадра в обратной трассировке, начиная с первого кадра, функция которого является &lt;var&gt;base&lt;/var&gt; (или сверху, если &lt;var&gt;base&lt;/var&gt; опущено или равно &lt;code&gt;nil&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ccd658c08c200f4281112668bf7e651adc648cfe" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;member&lt;/code&gt; tests to see whether &lt;var&gt;object&lt;/var&gt; is a member of &lt;var&gt;list&lt;/var&gt;, comparing members with &lt;var&gt;object&lt;/var&gt; using &lt;code&gt;equal&lt;/code&gt;. If &lt;var&gt;object&lt;/var&gt; is a member, &lt;code&gt;member&lt;/code&gt; returns a list starting with its first occurrence in &lt;var&gt;list&lt;/var&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Функция- &lt;code&gt;member&lt;/code&gt; проверяет, является ли &lt;var&gt;object&lt;/var&gt; членом &lt;var&gt;list&lt;/var&gt; , сравнивая члены с &lt;var&gt;object&lt;/var&gt; с использованием &lt;code&gt;equal&lt;/code&gt; . Если &lt;var&gt;object&lt;/var&gt; является членом, &lt;code&gt;member&lt;/code&gt; возвращает список, начиная с его первого вхождения в &lt;var&gt;list&lt;/var&gt; . В противном случае возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="836706fff80e951f88d58f54e4d11838289bf1e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;memql&lt;/code&gt; tests to see whether &lt;var&gt;object&lt;/var&gt; is a member of &lt;var&gt;list&lt;/var&gt;, comparing members with &lt;var&gt;object&lt;/var&gt; using &lt;code&gt;eql&lt;/code&gt;, so floating-point elements are compared by value. If &lt;var&gt;object&lt;/var&gt; is a member, &lt;code&gt;memql&lt;/code&gt; returns a list starting with its first occurrence in &lt;var&gt;list&lt;/var&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;memql&lt;/code&gt; проверяет, является ли &lt;var&gt;object&lt;/var&gt; членом &lt;var&gt;list&lt;/var&gt; , сравнивая члены с &lt;var&gt;object&lt;/var&gt; с помощью &lt;code&gt;eql&lt;/code&gt; , поэтому элементы с плавающей запятой сравниваются по значению. Если &lt;var&gt;object&lt;/var&gt; является членом, &lt;code&gt;memql&lt;/code&gt; возвращает список, начиная с его первого вхождения в &lt;var&gt;list&lt;/var&gt; . В противном случае возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2086c23f1633b32f5d281ae45401849ef50ca00d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;process-type&lt;/code&gt; returns the symbol &lt;code&gt;serial&lt;/code&gt; for a process object representing a serial port connection.</source>
          <target state="translated">Функция &lt;code&gt;process-type&lt;/code&gt; возвращает символ &lt;code&gt;serial&lt;/code&gt; для объекта процесса , представляющего собой соединение через последовательный порт.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
