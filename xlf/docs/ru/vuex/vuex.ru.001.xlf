<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="vuex">
    <body>
      <group id="vuex">
        <trans-unit id="74ae1a27792287a53f632864ec413cb560452e7e" translate="yes" xml:space="preserve">
          <source>&quot;createLogger&quot; function is exported from the core module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b529393c3179a77a9306c183468564863d0ff0" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;present Evan You</source>
          <target state="translated">&amp;copy; 2015 &amp;ndash; настоящее время Эван Ю</target>
        </trans-unit>
        <trans-unit id="3dbca386b3bf4c0c03ea3c64d065f726c26a64b7" translate="yes" xml:space="preserve">
          <source>1. Installation</source>
          <target state="translated">1.Установка</target>
        </trans-unit>
        <trans-unit id="7644d763c0c7ace9ff19d36e4552b445a389efe0" translate="yes" xml:space="preserve">
          <source>10. Strict Mode</source>
          <target state="translated">10.Строгий режим</target>
        </trans-unit>
        <trans-unit id="290258555d6677c0ac84626e214aa009f8a85e64" translate="yes" xml:space="preserve">
          <source>11. Form Handling</source>
          <target state="translated">11.обработка бланков</target>
        </trans-unit>
        <trans-unit id="4129c08ad5f758bb8883f75f714cc03d6b8724d7" translate="yes" xml:space="preserve">
          <source>12. Testing</source>
          <target state="translated">12-е тестирование</target>
        </trans-unit>
        <trans-unit id="528a3b9b2d03ca80ea557ac5c60aa567789512ff" translate="yes" xml:space="preserve">
          <source>13. Hot Reloading</source>
          <target state="translated">13.Горячая перезагрузка</target>
        </trans-unit>
        <trans-unit id="dbc8b357691409e9c4daf2c6428dbe68446dc47c" translate="yes" xml:space="preserve">
          <source>2. Getting Started</source>
          <target state="translated">2.Начало работы</target>
        </trans-unit>
        <trans-unit id="999bcc9c65f419d4177fbc85fb43d8d53350ea26" translate="yes" xml:space="preserve">
          <source>3. State</source>
          <target state="translated">3.Государственный .</target>
        </trans-unit>
        <trans-unit id="86901adbf99889e89f6fb5664ba644ee179d5895" translate="yes" xml:space="preserve">
          <source>4. Getters</source>
          <target state="translated">4.Геттеры</target>
        </trans-unit>
        <trans-unit id="f5dd21d6df4b83ebbdd0d793bd18c24ecafd3d6a" translate="yes" xml:space="preserve">
          <source>5. Mutations</source>
          <target state="translated">5.мутации</target>
        </trans-unit>
        <trans-unit id="d2db7e791345bd3756bb20faaf9a14d8b1ca6e1d" translate="yes" xml:space="preserve">
          <source>6. Actions</source>
          <target state="translated">6.Действия</target>
        </trans-unit>
        <trans-unit id="311b202ab670d27bdcb3786803bee13f6ac0dd04" translate="yes" xml:space="preserve">
          <source>7. Modules</source>
          <target state="translated">7.Модули</target>
        </trans-unit>
        <trans-unit id="5b2c110974e654cf654a583f99f4466b77ffad4a" translate="yes" xml:space="preserve">
          <source>8. Application Structure</source>
          <target state="translated">8.Структура приложения</target>
        </trans-unit>
        <trans-unit id="35fca60c7ce35ec44954758baa9845c6764c93f3" translate="yes" xml:space="preserve">
          <source>9. Plugins</source>
          <target state="translated">9.Плагины</target>
        </trans-unit>
        <trans-unit id="e491a21fa71516f2b26e081f14ece268b038b5c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; provides NPM-based CDN links. The above link will always point to the latest release on NPM. You can also use a specific version/tag via URLs like &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; предоставляет ссылки CDN на основе NPM. Приведенная выше ссылка всегда будет указывать на последнюю версию NPM. Вы также можете использовать определенную версию / тег через URL-адреса, например &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ab7dbdd7961ea625457c4f71c2a103e97577e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createLogger&lt;/code&gt; function is exported from the core module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140249cc0098c39ea9eee2f348b83aec84aeaea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;preserveState: true&lt;/code&gt; that allows to preserve the previous state. Useful with Server Side Rendering.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; могут иметь &lt;code&gt;preserveState: true&lt;/code&gt; что позволяет сохранить предыдущее состояние. Полезно при рендеринге на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="1d43392242421ea5926dd1b8219417091c58e5ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeAction&lt;/code&gt; can also specify an &lt;code&gt;error&lt;/code&gt; handler to catch an error thrown when an action is dispatched. The function will receive an &lt;code&gt;error&lt;/code&gt; object as the third argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efda1a76b4931ed64f56c475099103b6b342e77a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeAction&lt;/code&gt; can also specify whether the subscribe handler should be called &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; an action dispatch (the default behavior is &lt;em&gt;before&lt;/em&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bc29b6324b7d1ed0dc681c2aa882c85b026c76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not enable strict mode when deploying for production!&lt;/strong&gt; Strict mode runs a synchronous deep watcher on the state tree for detecting inappropriate mutations, and it can be quite expensive when you make large amount of mutations to the state. Make sure to turn it off in production to avoid the performance cost.</source>
          <target state="translated">&lt;strong&gt;Не включайте строгий режим при развертывании в производственной среде! &lt;/strong&gt;Строгий режим запускает синхронный глубокий наблюдатель в дереве состояний для обнаружения несоответствующих мутаций, и это может быть довольно дорогостоящим, если вы вносите большое количество мутаций в состояние. Не забудьте выключить его в производственной среде, чтобы избежать снижения производительности.</target>
        </trans-unit>
        <trans-unit id="9f9016c15f9b85d16a456b0a8fed9e60d27f0c18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; We will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;you should&lt;/a&gt;!</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ.&lt;/strong&gt; Мы будем использовать синтаксис ES2015 для примеров кода для остальных документов. Если вы еще не подняли его, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;то должны&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="543738af7550fb2b326fb4aec1d84822e5d85d47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins that take state snapshots should be used only during development.&lt;/strong&gt; When using webpack or Browserify, we can let our build tools handle that for us:</source>
          <target state="translated">&lt;strong&gt;Плагины, которые делают снимки состояния, следует использовать только во время разработки. &lt;/strong&gt;При использовании webpack или Browserify мы можем позволить нашим инструментам сборки сделать это за нас:</target>
        </trans-unit>
        <trans-unit id="152494aaef0de9abdd755c1e397ccd919faab73b" translate="yes" xml:space="preserve">
          <source>A more practical example of real-world actions would be an action to checkout a shopping cart, which involves &lt;strong&gt;calling an async API&lt;/strong&gt; and &lt;strong&gt;committing multiple mutations&lt;/strong&gt;:</source>
          <target state="translated">Более практичным примером реальных действий может быть действие по оформлению покупки в корзине, которое включает &lt;strong&gt;вызов асинхронного API&lt;/strong&gt; и выполнение &lt;strong&gt;нескольких мутаций&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API ссылка</target>
        </trans-unit>
        <trans-unit id="5f613656881e083dfef9e6ff61f4361ce0a8891f" translate="yes" xml:space="preserve">
          <source>Accessing Global Assets in Namespaced Modules</source>
          <target state="translated">Доступ к глобальным активам в модулях с пространством имен</target>
        </trans-unit>
        <trans-unit id="a6ab98e7c5d9fe16cce79fc5b58d4c6a0bb97528" translate="yes" xml:space="preserve">
          <source>Accessing Mutations and Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d2c21a5e764fa3068b12a662b48a445b54e874" translate="yes" xml:space="preserve">
          <source>Accessing State and Getters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5c235f81dfbc7a38598e493ee1ecf48d2948cf" translate="yes" xml:space="preserve">
          <source>Action handlers receive a context object which exposes the same set of methods/properties on the store instance, so you can call &lt;code&gt;context.commit&lt;/code&gt; to commit a mutation, or access the state and getters via &lt;code&gt;context.state&lt;/code&gt; and &lt;code&gt;context.getters&lt;/code&gt;. We can even call other actions with &lt;code&gt;context.dispatch&lt;/code&gt;. We will see why this context object is not the store instance itself when we introduce &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; later.</source>
          <target state="translated">Обработчики действий получают объект контекста, который предоставляет тот же набор методов / свойств в экземпляре хранилища, поэтому вы можете вызвать &lt;code&gt;context.commit&lt;/code&gt; для фиксации мутации или получить доступ к состоянию и геттерам через &lt;code&gt;context.state&lt;/code&gt; и &lt;code&gt;context.getters&lt;/code&gt; . Мы даже можем вызывать другие действия с помощью &lt;code&gt;context.dispatch&lt;/code&gt; . Мы увидим, почему этот объект контекста не является самим экземпляром хранилища, когда мы представим &lt;a href=&quot;modules&quot;&gt;модули&lt;/a&gt; позже.</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="fd2b38844159f4c8bd1a540f724142f21bcb2783" translate="yes" xml:space="preserve">
          <source>Actions are often asynchronous, so how do we know when an action is done? And more importantly, how can we compose multiple actions together to handle more complex async flows?</source>
          <target state="translated">Действия часто бывают асинхронными,так как же узнать,когда действие сделано? И что еще более важно,как мы можем составить несколько действий вместе,чтобы справиться с более сложными асинхронными потоками?</target>
        </trans-unit>
        <trans-unit id="eebbe3f939d0e7eb5a702bddfd2a09d58662a331" translate="yes" xml:space="preserve">
          <source>Actions are similar to mutations, the differences being that:</source>
          <target state="translated">Действия похожи на мутации,разница в этом:</target>
        </trans-unit>
        <trans-unit id="2fb7f3eefbb910c724298c1fe2f73e2dd2775642" translate="yes" xml:space="preserve">
          <source>Actions are triggered with the &lt;code&gt;store.dispatch&lt;/code&gt; method:</source>
          <target state="translated">Действия запускаются с &lt;code&gt;store.dispatch&lt;/code&gt; метода store.dispatch :</target>
        </trans-unit>
        <trans-unit id="e0710bf63012535b6c8d8716b3dcac5cf1237306" translate="yes" xml:space="preserve">
          <source>Actions can be a bit more tricky because they may call out to external APIs. When testing actions, we usually need to do some level of mocking - for example, we can abstract the API calls into a service and mock that service inside our tests. In order to easily mock dependencies, we can use webpack and &lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;inject-loader&lt;/a&gt; to bundle our test files.</source>
          <target state="translated">Действия могут быть немного сложнее, потому что они могут вызывать внешние API. При тестировании действий нам обычно требуется некоторый уровень имитации - например, мы можем абстрагировать вызовы API в службу и имитировать эту службу внутри наших тестов. Чтобы легко имитировать зависимости, мы можем использовать webpack и inject &lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;-loader&lt;/a&gt; для объединения наших тестовых файлов.</target>
        </trans-unit>
        <trans-unit id="5b7eca18a813d34c8aa01e8ef07ee7519aaf8e37" translate="yes" xml:space="preserve">
          <source>Actions can contain arbitrary asynchronous operations.</source>
          <target state="translated">Действия могут содержать произвольные асинхронные операции.</target>
        </trans-unit>
        <trans-unit id="20c41c87b2101245945eb4d510d08709af6ca47f" translate="yes" xml:space="preserve">
          <source>Actions from different views may need to mutate the same piece of state.</source>
          <target state="translated">Действия с разных точек зрения могут потребовать мутации одного и того же кусочка состояния.</target>
        </trans-unit>
        <trans-unit id="cc658d581fafc63b17159bbd703e4b6ae9e6654d" translate="yes" xml:space="preserve">
          <source>Actions support the same payload format and object-style dispatch:</source>
          <target state="translated">Действия поддерживают один и тот же формат полезной нагрузки и объектно-ориентированную рассылку:</target>
        </trans-unit>
        <trans-unit id="e6f1f5e24996a891b4012e435efadfe597fd76af" translate="yes" xml:space="preserve">
          <source>Admittedly, the above is quite a bit more verbose than &lt;code&gt;v-model&lt;/code&gt; + local state, and we lose some of the useful features from &lt;code&gt;v-model&lt;/code&gt; as well. An alternative approach is using a two-way computed property with a setter:</source>
          <target state="translated">По общему признанию, приведенное выше является немного более подробным, чем &lt;code&gt;v-model&lt;/code&gt; + локальное состояние, и мы также теряем некоторые полезные функции из &lt;code&gt;v-model&lt;/code&gt; . Альтернативный подход - использование двустороннего вычисляемого свойства с установщиком:</target>
        </trans-unit>
        <trans-unit id="1202f0740ed7d8ae90a711fe902caaa8f08e09b3" translate="yes" xml:space="preserve">
          <source>After &lt;a href=&quot;../installation&quot;&gt;installing&lt;/a&gt; Vuex, let's create a store. It is pretty straightforward - just provide an initial state object, and some mutations:</source>
          <target state="translated">После &lt;a href=&quot;../installation&quot;&gt;установки&lt;/a&gt; Vuex создадим магазин. Это довольно просто - просто укажите объект начального состояния и некоторые изменения:</target>
        </trans-unit>
        <trans-unit id="a38a6afdb72dbde1dead2d25ed43a801e44eeba7" translate="yes" xml:space="preserve">
          <source>Again, the reason we are committing a mutation instead of changing &lt;code&gt;store.state.count&lt;/code&gt; directly, is because we want to explicitly track it. This simple convention makes your intention more explicit, so that you can reason about state changes in your app better when reading the code. In addition, this gives us the opportunity to implement tools that can log every mutation, take state snapshots, or even perform time travel debugging.</source>
          <target state="translated">Опять же, причина, по которой мы фиксируем мутацию вместо прямого изменения &lt;code&gt;store.state.count&lt;/code&gt; , заключается в том, что мы хотим явно отслеживать ее. Это простое соглашение делает ваше намерение более явным, чтобы вы могли лучше рассуждать об изменениях состояния в вашем приложении при чтении кода. Кроме того, это дает нам возможность реализовать инструменты, которые могут регистрировать каждую мутацию, делать снимки состояния или даже выполнять отладку в путешествиях во времени.</target>
        </trans-unit>
        <trans-unit id="eab081c4e733f3e8e7fc4113e3a4c3e9822d6e7f" translate="yes" xml:space="preserve">
          <source>Almost all Vuex 4 APIs have remained unchanged from Vuex 3. However, there are still a few breaking changes that you must fix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321cdc14e97d2ee50f5d65dc4d313dcb119e79c0" translate="yes" xml:space="preserve">
          <source>Also, inside module getters, the root state will be exposed as their 3rd argument:</source>
          <target state="translated">Также внутри геттеров модуля в качестве 3-го аргумента будет выставлено корневое состояние:</target>
        </trans-unit>
        <trans-unit id="2eee5b4fbbc1f54a27e6412f36e8fc0250ed0ca4" translate="yes" xml:space="preserve">
          <source>An alternative way to commit a mutation is by directly using an object that has a &lt;code&gt;type&lt;/code&gt; property:</source>
          <target state="translated">Альтернативный способ зафиксировать мутацию - напрямую использовать объект, имеющий свойство &lt;code&gt;type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c5bfc0baa5cb6ec7b1c1c279caffbe5d5b8218a2" translate="yes" xml:space="preserve">
          <source>An array of plugin functions to be applied to the store. The plugin simply receives the store as the only argument and can either listen to mutations (for outbound data persistence, logging, or debugging) or dispatch mutations (for inbound data e.g. websockets or observables).</source>
          <target state="translated">Массив функций плагина для применения в магазине.Плагин просто принимает хранилище в качестве единственного аргумента и может либо слушать мутации (для устойчивости исходящих данных,протоколирования или отладки),либо посылать мутации (для входящих данных,например,вебсокетов или наблюдаемых).</target>
        </trans-unit>
        <trans-unit id="6b626f3c447742f2fad682725d05b28250d88b5f" translate="yes" xml:space="preserve">
          <source>An object containing sub modules to be merged into the store, in the shape of:</source>
          <target state="translated">Объект,содержащий подмодули,подлежащие объединению в магазин,в виде:</target>
        </trans-unit>
        <trans-unit id="dc46a43c367676022711c845ac16cc5387d782f6" translate="yes" xml:space="preserve">
          <source>And also in another action:</source>
          <target state="translated">А также в другом действии:</target>
        </trans-unit>
        <trans-unit id="4db792123502a659fd37a4ca852f43e15ee1ef57" translate="yes" xml:space="preserve">
          <source>And also receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">А также получает второй аргумент &lt;code&gt;payload&lt;/code&gt; если он есть.</target>
        </trans-unit>
        <trans-unit id="6eb1eaafd8f229821b275541a054f723a80d42bf" translate="yes" xml:space="preserve">
          <source>And can be used like this:</source>
          <target state="translated">И может использоваться вот так:</target>
        </trans-unit>
        <trans-unit id="fe2969186d8cff2f758236d5c540ae4e48a2d751" translate="yes" xml:space="preserve">
          <source>And here's the mutation handler:</source>
          <target state="translated">А вот обработчик мутаций:</target>
        </trans-unit>
        <trans-unit id="d71de8152541f4a1b7fda48b87f3fe315656e14c" translate="yes" xml:space="preserve">
          <source>Application Structure</source>
          <target state="translated">Структура приложения</target>
        </trans-unit>
        <trans-unit id="2ba5dece67f8efdf3c81bb9be56daf28e8655190" translate="yes" xml:space="preserve">
          <source>Application-level state is centralized in the store.</source>
          <target state="translated">В магазине централизовано состояние на уровне приложений.</target>
        </trans-unit>
        <trans-unit id="710522a05d77912ddae3e734e0a2d1d370529418" translate="yes" xml:space="preserve">
          <source>As a reference, check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/classic/shopping-cart&quot;&gt;Shopping Cart Example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a169df16a0c175be12b4d7b1cd59df717591a1" translate="yes" xml:space="preserve">
          <source>As a reference, check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;Shopping Cart Example&lt;/a&gt;.</source>
          <target state="translated">В качестве справки ознакомьтесь с &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;примером корзины покупок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90a44e426a7e60755b1c84d1d390da1cb4f500d2" translate="yes" xml:space="preserve">
          <source>As long as you follow these rules, it's up to you how to structure your project. If your store file gets too big, simply start splitting the actions, mutations and getters into separate files.</source>
          <target state="translated">До тех пор,пока вы будете следовать этим правилам,все зависит от вас,как структурировать ваш проект.Если ваш файл хранилища станет слишком большим,просто начните разбивать действия,мутации и геттеры на отдельные файлы.</target>
        </trans-unit>
        <trans-unit id="fc6ed90023b96fb6043edbdf30e42cf5dd8527fd" translate="yes" xml:space="preserve">
          <source>As of Vue 3.0, the getter's result is &lt;strong&gt;not cached&lt;/strong&gt; as the computed property does. This is a known issue that requires Vue 3.1 to be released. You can learn more at &lt;a href=&quot;https://github.com/vuejs/vuex/pull/1883&quot;&gt;PR #1878&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfd062060191d75d85aa467d9473a70ac205ad2" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;obj&lt;/code&gt; is a computed property that returns an Object from the store, the &lt;code&gt;v-model&lt;/code&gt; here will attempt to directly mutate &lt;code&gt;obj.message&lt;/code&gt; when the user types in the input. In strict mode, this will result in an error because the mutation is not performed inside an explicit Vuex mutation handler.</source>
          <target state="translated">Предполагая, что &lt;code&gt;obj&lt;/code&gt; является вычисляемым свойством, которое возвращает объект из хранилища, &lt;code&gt;v-model&lt;/code&gt; здесь будет пытаться напрямую &lt;code&gt;obj.message&lt;/code&gt; когда пользователь вводит ввод. В строгом режиме это приведет к ошибке, поскольку мутация не выполняется внутри явного обработчика мутации Vuex.</target>
        </trans-unit>
        <trans-unit id="6d84d9b230182d02f5132507784662fee81bd183" translate="yes" xml:space="preserve">
          <source>Asynchronicity combined with state mutation can make your program very hard to reason about. For example, when you call two methods both with async callbacks that mutate the state, how do you know when they are called and which callback was called first? This is exactly why we want to separate the two concepts. In Vuex, &lt;strong&gt;mutations are synchronous transactions&lt;/strong&gt;:</source>
          <target state="translated">Асинхронность в сочетании с мутацией состояний может сделать вашу программу очень сложной для понимания. Например, когда вы вызываете два метода с асинхронными обратными вызовами, которые изменяют состояние, как узнать, когда они вызываются и какой обратный вызов был вызван первым? Именно поэтому мы хотим разделить эти два понятия. В Vuex &lt;strong&gt;мутации - это синхронные транзакции&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="b626c6a5b4f21b273497b11b0696d3709db0b3b9" translate="yes" xml:space="preserve">
          <source>Asynchronous logic should be encapsulated in, and can be composed with &lt;strong&gt;actions&lt;/strong&gt;.</source>
          <target state="translated">Асинхронная логика должна быть инкапсулирована и может состоять из &lt;strong&gt;действий&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b24ba5aae3b57ed131c31fce3d9e7c01ee0a8934" translate="yes" xml:space="preserve">
          <source>At the center of every Vuex application is the &lt;strong&gt;store&lt;/strong&gt;. A &quot;store&quot; is basically a container that holds your application &lt;strong&gt;state&lt;/strong&gt;. There are two things that make a Vuex store different from a plain global object:</source>
          <target state="translated">В центре каждого приложения Vuex находится &lt;strong&gt;магазин&lt;/strong&gt; . А &amp;laquo;магазин&amp;raquo; в основном контейнер , который содержит прикладное &lt;strong&gt;состояние&lt;/strong&gt; . Хранилище Vuex отличается от простого глобального объекта двумя вещами:</target>
        </trans-unit>
        <trans-unit id="c7d1a78232de1c9a47af6445001c58c1d1a7ff3f" translate="yes" xml:space="preserve">
          <source>Binding Helpers with Namespace</source>
          <target state="translated">Обязательные помощники с пространством имён</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b82d0b3ff29a71b23bd07d252bf2496be796144" translate="yes" xml:space="preserve">
          <source>Built-in Logger Plugin</source>
          <target state="translated">Встроенный модуль регистрации</target>
        </trans-unit>
        <trans-unit id="308a059e768af3165c20d5c89a88a895db34b5d3" translate="yes" xml:space="preserve">
          <source>Bundles are now aligned with Vue 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b63c58271c9e6140433eb13c24cac57c216ef45" translate="yes" xml:space="preserve">
          <source>By committing mutations, a plugin can be used to sync a data source to the store. For example, to sync a websocket data source to the store (this is just a contrived example, in reality the &lt;code&gt;createWebSocketPlugin&lt;/code&gt; function can take some additional options for more complex tasks):</source>
          <target state="translated">Коммитируя мутации, можно использовать плагин для синхронизации источника данных с магазином. Например, чтобы синхронизировать источник данных websocket с магазином (это просто надуманный пример, на самом &lt;code&gt;createWebSocketPlugin&lt;/code&gt; функция createWebSocketPlugin может принимать некоторые дополнительные параметры для более сложных задач):</target>
        </trans-unit>
        <trans-unit id="54e6c17c9d96ae95deebc44ddbbdf708643bcdb6" translate="yes" xml:space="preserve">
          <source>By default, actions and mutations are still registered under the &lt;strong&gt;global namespace&lt;/strong&gt; - this allows multiple modules to react to the same action/mutation type. Getters are also registered in the global namespace by default. However, this currently has no functional purpose (it's as is to avoid breaking changes). You must be careful not to define two getters with the same name in different, non-namespaced modules, resulting in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6129d443ac8169bdc5fb7a33f1a6e3a49e6acbc" translate="yes" xml:space="preserve">
          <source>By default, actions, mutations and getters inside modules are still registered under the &lt;strong&gt;global namespace&lt;/strong&gt; - this allows multiple modules to react to the same mutation/action type.</source>
          <target state="translated">По умолчанию действия, мутации и геттеры внутри модулей по-прежнему регистрируются в &lt;strong&gt;глобальном пространстве имен&lt;/strong&gt; - это позволяет нескольким модулям реагировать на один и тот же тип мутации / действия.</target>
        </trans-unit>
        <trans-unit id="e5c047ce83c6997dc7276f84aba1f5edb7e54735" translate="yes" xml:space="preserve">
          <source>By default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding &lt;code&gt;prepend: true&lt;/code&gt; to &lt;code&gt;options&lt;/code&gt;, which will add the handler to the beginning of the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ce5306c9b50098f499e2c37705e5ca375897a5" translate="yes" xml:space="preserve">
          <source>By defining and separating the concepts involved in state management and enforcing rules that maintain independence between views and states, we give our code more structure and maintainability.</source>
          <target state="translated">Определяя и разделяя понятия,связанные с управлением государством,и применяя правила,поддерживающие независимость между взглядами и государствами,мы придаем нашему кодексу большую структурированность и удобство в использовании.</target>
        </trans-unit>
        <trans-unit id="5f057ce6f76c7748c97610c88355154f282ad2c0" translate="yes" xml:space="preserve">
          <source>By providing the &lt;code&gt;store&lt;/code&gt; option to the root instance, the store will be injected into all child components of the root and will be available on them as &lt;code&gt;this.$store&lt;/code&gt;. Let's update our &lt;code&gt;Counter&lt;/code&gt; implementation:</source>
          <target state="translated">Предоставляя опцию &lt;code&gt;store&lt;/code&gt; корневому экземпляру, хранилище будет внедрено во все дочерние компоненты корневого экземпляра и будет доступно для них как &lt;code&gt;this.$store&lt;/code&gt; . Давайте обновим нашу реализацию &lt;code&gt;Counter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="afbfca3e9562078c83014d5d713ed214293086dc" translate="yes" xml:space="preserve">
          <source>Caveat for Plugin Developers</source>
          <target state="translated">Кейват для разработчиков плагинов</target>
        </trans-unit>
        <trans-unit id="b802f993bec634c517b9f6ea60df4c1f6d0862f1" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;entry&lt;/code&gt; from the webpack config above to &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt;.</source>
          <target state="translated">Измените &lt;code&gt;entry&lt;/code&gt; из конфигурации webpack выше на &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad552703e8fdce0a6e99ce76eff171c7cb0b2e6e" translate="yes" xml:space="preserve">
          <source>Check if the module with the given name is already registered. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a64ba9ebedb4fb168b3e805adfe8c5b4531bcc" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/composition&quot;&gt;Composition API example&lt;/a&gt; to see example applications utilising Vuex and Vue's Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce2cc7e2a5aca96dce40c7472c844313c6128f9" translate="yes" xml:space="preserve">
          <source>Checkout the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;counter-hot example&lt;/a&gt; to play with hot-reload.</source>
          <target state="translated">Ознакомьтесь с &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;примером counter-hot,&lt;/a&gt; чтобы поиграть с горячей перезагрузкой.</target>
        </trans-unit>
        <trans-unit id="4fa10bacb249d780150d867ebb85a6f26364c8f3" translate="yes" xml:space="preserve">
          <source>Commit a mutation. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to commit root mutations in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. &lt;a href=&quot;../guide/mutations&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Совершите мутацию. &lt;code&gt;options&lt;/code&gt; могут иметь &lt;code&gt;root: true&lt;/code&gt; что позволяет фиксировать корневые мутации в &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;модулях с именами&lt;/a&gt; . &lt;a href=&quot;../guide/mutations&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abb9b61bf1bcc0d24bf3814462346ec637d49ab2" translate="yes" xml:space="preserve">
          <source>Commit with Payload</source>
          <target state="translated">Обязаться с грузом</target>
        </trans-unit>
        <trans-unit id="ed6c4a7e621ba1c9ba60ff20a8e8dcf01877ef46" translate="yes" xml:space="preserve">
          <source>Committing Mutations Inside Plugins</source>
          <target state="translated">Внутренние плагины для совершения мутаций</target>
        </trans-unit>
        <trans-unit id="ace0d08016e7028b4da846721e8e8ac868a1df57" translate="yes" xml:space="preserve">
          <source>Committing Mutations in Components</source>
          <target state="translated">Обязательные мутации в компонентах</target>
        </trans-unit>
        <trans-unit id="1f6dc35fce777380808e0419957ee6d4ef776d2a" translate="yes" xml:space="preserve">
          <source>Component Binding Helpers</source>
          <target state="translated">Помощники по привязке компонентов</target>
        </trans-unit>
        <trans-unit id="4d8cf2331522b00be9ba0f265b611e2039ac37bf" translate="yes" xml:space="preserve">
          <source>Components Can Still Have Local State</source>
          <target state="translated">Компоненты могут все еще иметь местное состояние</target>
        </trans-unit>
        <trans-unit id="c21ad08c0baf7033efdd17f3b90986ad6f2a3b53" translate="yes" xml:space="preserve">
          <source>Composable Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15cc8250e54a4e4e49adf02d259f1fa59279242" translate="yes" xml:space="preserve">
          <source>Composing Actions</source>
          <target state="translated">Составляющие действия</target>
        </trans-unit>
        <trans-unit id="612f6427c9092a5834602047d990b4384c86915b" translate="yes" xml:space="preserve">
          <source>Composition API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede404da36f4056ccf7af05d460f44cb9c43066f" translate="yes" xml:space="preserve">
          <source>Consult the setup in &lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;vue-loader documentation&lt;/a&gt;.</source>
          <target state="translated">Проконсультируйтесь с настройкой в &lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;документации&lt;/a&gt; по vue-loader .</target>
        </trans-unit>
        <trans-unit id="fdf30dd4ea6fdb8cb2d048ae6de2346d62859fba" translate="yes" xml:space="preserve">
          <source>Contains hard-coded prod/dev branches and the prod build is pre-minified. Use the &lt;code&gt;.prod.js&lt;/code&gt; files for production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da10239b688b761162ce39505c1fb91b8a0f2cff" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the evaluated value of a getter. &lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Создайте вычисляемые параметры компонента, которые возвращают оцененное значение геттера. &lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31bb75db599ebdfdee4a1705ea2cde4fc02ae7e9" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the sub tree of the Vuex store. &lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Создайте вычисляемые параметры компонента, которые возвращают поддерево хранилища Vuex. &lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dbfc6c00c0be1ce1d1c67ae2ab7ad29e56233ee" translate="yes" xml:space="preserve">
          <source>Create component methods options that commit a mutation. &lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Создайте параметры методов компонента, которые фиксируют мутацию. &lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abafed37072bae96880b76a80729da6f20135f55" translate="yes" xml:space="preserve">
          <source>Create component methods options that dispatch an action. &lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Создайте параметры методов компонента, которые отправляют действие. &lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e2d6b72bf5a70877397f0095b2d65aff35b1892" translate="yes" xml:space="preserve">
          <source>Create namespaced component binding helpers. The returned object contains &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; that are bound with the given namespace. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Создайте помощники привязки компонентов с пространством имен. &lt;code&gt;mapState&lt;/code&gt; объект содержит mapState , &lt;code&gt;mapGetters&lt;/code&gt; , &lt;code&gt;mapActions&lt;/code&gt; и &lt;code&gt;mapMutations&lt;/code&gt; , которые связаны с данным пространством имен. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9ad68aa689b0ae8f0f0130cf5684aa9556b2ca9" translate="yes" xml:space="preserve">
          <source>Create the following webpack config (together with proper &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;&lt;code&gt;.babelrc&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Создайте следующую конфигурацию веб-пакета (вместе с правильным &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt; &lt;code&gt;.babelrc&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="6d783b874c20d56d3f40a248f291e37048c0af28" translate="yes" xml:space="preserve">
          <source>Creates a new store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9105fc825a43c6d4845f7a03ee377cd299c7a10e" translate="yes" xml:space="preserve">
          <source>Creating multiple stores that use the same module (e.g. To &lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;avoid stateful singletons in the SSR&lt;/a&gt; when the &lt;code&gt;runInNewContext&lt;/code&gt; option is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;'once'&lt;/code&gt;);</source>
          <target state="translated">Создание нескольких хранилищ, использующих один и тот же модуль (например, чтобы &lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;избежать синглтонов&lt;/a&gt; с &lt;code&gt;runInNewContext&lt;/code&gt; состояния в SSR, когда параметр runInNewContext имеет значение &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;'once'&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="21eac18e2c98912ec301de36518dcca3257d3520" translate="yes" xml:space="preserve">
          <source>Define the typed &lt;code&gt;InjectionKey&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="40d9b9f619dbd27ad649a2fb2ed512704a8498dc" translate="yes" xml:space="preserve">
          <source>Dev Build</source>
          <target state="translated">Dev Build</target>
        </trans-unit>
        <trans-unit id="500633464b5e072d2c92585f64d2a894aa70607e" translate="yes" xml:space="preserve">
          <source>Development vs. Production</source>
          <target state="translated">Развитие против производства</target>
        </trans-unit>
        <trans-unit id="3802d9202faed1ee478163e33ce9ddf939795ae9" translate="yes" xml:space="preserve">
          <source>Direct Download / CDN</source>
          <target state="translated">Прямая загрузка/CDN</target>
        </trans-unit>
        <trans-unit id="ea82e3864abf2011a82f27aa87646711a6dde792" translate="yes" xml:space="preserve">
          <source>Dispatch an action. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to dispatch root actions in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. Returns a Promise that resolves all triggered action handlers. &lt;a href=&quot;../guide/actions&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Отправьте действие. &lt;code&gt;options&lt;/code&gt; могут иметь &lt;code&gt;root: true&lt;/code&gt; что позволяет отправлять корневые действия в &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;модулях с именами&lt;/a&gt; . Возвращает обещание, которое разрешает все обработчики запущенных действий. &lt;a href=&quot;../guide/actions&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5de1b3bf84cda5dd071c256e4397b905445d1ed" translate="yes" xml:space="preserve">
          <source>Dispatching Actions</source>
          <target state="translated">Диспетчерские действия</target>
        </trans-unit>
        <trans-unit id="7bbf007bb6622957664e35e62427c33b4787bbb3" translate="yes" xml:space="preserve">
          <source>Dispatching Actions in Components</source>
          <target state="translated">Диспетчерские действия в компонентах</target>
        </trans-unit>
        <trans-unit id="e84816ed7caab86d4177979788d92260896d7646" translate="yes" xml:space="preserve">
          <source>Does not ship minified builds (to be done together with the rest of the code after bundling).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d9131cd512bae245202d7fdc5bab5cceca6887" translate="yes" xml:space="preserve">
          <source>Due to using a single state tree, all state of our application is contained inside one big object. However, as our application grows in scale, the store can get really bloated.</source>
          <target state="translated">Благодаря использованию единого дерева состояний,все состояние нашего приложения содержится внутри одного большого объекта.Однако,по мере роста масштаба нашего приложения,магазин может сильно раздуться.</target>
        </trans-unit>
        <trans-unit id="e37126c9ff488c45faa7f6c167a21e521222db0b" translate="yes" xml:space="preserve">
          <source>Due to using a single state tree, all states of our application are contained inside one big object. However, as our application grows in scale, the store can get really bloated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38587c029f9616f99732e5fadca02a9d8f2a6d2" translate="yes" xml:space="preserve">
          <source>Dynamic Module Registration</source>
          <target state="translated">Регистрация динамического модуля</target>
        </trans-unit>
        <trans-unit id="cc0be31613baaad452c149bb9c4e8586cb8a8114" translate="yes" xml:space="preserve">
          <source>Dynamic module hot reloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eff12ca8da9deedbd39f6bb9fd354742d118c9c" translate="yes" xml:space="preserve">
          <source>Dynamic module registration makes it possible for other Vue plugins to also leverage Vuex for state management by attaching a module to the application's store. For example, the &lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt;&lt;code&gt;vuex-router-sync&lt;/code&gt;&lt;/a&gt; library integrates vue-router with vuex by managing the application's route state in a dynamically attached module.</source>
          <target state="translated">Регистрация динамического модуля позволяет другим плагинам Vue также использовать Vuex для управления состоянием, прикрепляя модуль к хранилищу приложения. Например, &lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt; &lt;code&gt;vuex-router-sync&lt;/code&gt; &lt;/a&gt; интегрирует vue-router с vuex, управляя состоянием маршрута приложения в динамически присоединяемом модуле.</target>
        </trans-unit>
        <trans-unit id="9e3580cb8f8917bfac5059a2f1b0b379d39800d4" translate="yes" xml:space="preserve">
          <source>Each module can contain &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;mutations&lt;/code&gt; similar to the root options. A module's state will be attached to the store's root state using the module's key. A module's mutations and getters will only receives the module's local state as the first argument instead of the root state, and module actions' &lt;code&gt;context.state&lt;/code&gt; will also point to the local state.</source>
          <target state="translated">Каждый модуль может содержать &lt;code&gt;state&lt;/code&gt; и &lt;code&gt;mutations&lt;/code&gt; аналогичные корневым параметрам. Состояние модуля будет привязано к корневому состоянию хранилища с помощью ключа модуля. Мутации и геттеры модуля будут получать только локальное состояние модуля в качестве первого аргумента вместо корневого состояния, а &lt;code&gt;context.state&lt;/code&gt; действий модуля также будет указывать на локальное состояние.</target>
        </trans-unit>
        <trans-unit id="f41155bdc10bb27f60f1da2c63993929e366cfa2" translate="yes" xml:space="preserve">
          <source>Edit this page on GitHub</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6af0b4fa90bb496d791139a634a4d2d65a25408" translate="yes" xml:space="preserve">
          <source>Example testing a getter:</source>
          <target state="translated">Пример тестирования геттера:</target>
        </trans-unit>
        <trans-unit id="dd8e6bd0108987b857bb2a736cd9e6e1f11f7746" translate="yes" xml:space="preserve">
          <source>Example testing a mutation using Mocha + Chai (you can use any framework/assertion libraries you like):</source>
          <target state="translated">Пример тестирования мутации с использованием Mocha+Chai (Вы можете использовать любые библиотеки фреймворка/установки по своему усмотрению):</target>
        </trans-unit>
        <trans-unit id="4dadb731f14e104d4245f8a4e7627c9bb1d8c139" translate="yes" xml:space="preserve">
          <source>Example testing an async action:</source>
          <target state="translated">Пример проверки асинхронного действия:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="cd172f61d02f40968010ccf686bd62765d497609" translate="yes" xml:space="preserve">
          <source>Exposes registered getters. Read only.</source>
          <target state="translated">Выставляет зарегистрированных получателей.Только для чтения.</target>
        </trans-unit>
        <trans-unit id="6a0705ebf0c44ae72129e31b63faf83cc8385e86" translate="yes" xml:space="preserve">
          <source>Fetches the injected store when called inside the &lt;code&gt;setup&lt;/code&gt; hook. When using the Composition API, you can retrieve the store by calling this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e1190595d9109275e6d9d5c10a089a3981a13d" translate="yes" xml:space="preserve">
          <source>Finally, if we make use of &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await&lt;/a&gt;, we can compose our actions like this:</source>
          <target state="translated">Наконец, если мы используем &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await&lt;/a&gt; , мы можем составить наши действия следующим образом:</target>
        </trans-unit>
        <trans-unit id="ecf5f38fd7c4dac49ef3d463f17a75ccd2d813ac" translate="yes" xml:space="preserve">
          <source>Finally, you can pass the key to the &lt;code&gt;useStore&lt;/code&gt; method to retrieve the typed store instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fcf80576ac0f89837fff4eaee1452a5292cce8" translate="yes" xml:space="preserve">
          <source>Finally, you can pass the key to the &lt;code&gt;useStore&lt;/code&gt; method to retrieve the typed store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0760cb8d91e6272575ced160dd4e33845f64e540" translate="yes" xml:space="preserve">
          <source>First, declare the injection key using Vue's &lt;code&gt;InjectionKey&lt;/code&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841c8a4f0fbdf7bd78d33837ca0ec3734ac74a01" translate="yes" xml:space="preserve">
          <source>Flux libraries are like glasses: you&amp;rsquo;ll know when you need them.</source>
          <target state="translated">Библиотеки Flux похожи на очки: вы будете знать, когда они вам понадобятся.</target>
        </trans-unit>
        <trans-unit id="38238c24d7f78b5d636a16e313302582a752f404" translate="yes" xml:space="preserve">
          <source>For any non-trivial app, we will likely need to leverage modules. Here's an example project structure:</source>
          <target state="translated">Для любого нетривиального приложения нам,скорее всего,понадобятся дополнительные модули.Вот пример структуры проекта:</target>
        </trans-unit>
        <trans-unit id="a300dd270b0c9c1a922b569511c43841912d4bc3" translate="yes" xml:space="preserve">
          <source>For direct use with &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt; in the browser. Exposes the Vuex global.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033826f9380de6f34a8b452670d3506eb71f91c9" translate="yes" xml:space="preserve">
          <source>For mutations and modules, you need to use the &lt;code&gt;store.hotUpdate()&lt;/code&gt; API method:</source>
          <target state="translated">Для мутаций и модулей вам необходимо использовать метод API &lt;code&gt;store.hotUpdate()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="52511d0a336b3eb2bef841ae607141d7cff1fb7f" translate="yes" xml:space="preserve">
          <source>For problem one, passing props can be tedious for deeply nested components, and simply doesn't work for sibling components. For problem two, we often find ourselves resorting to solutions such as reaching for direct parent/child instance references or trying to mutate and synchronize multiple copies of the state via events. Both of these patterns are brittle and quickly lead to unmaintainable code.</source>
          <target state="translated">Для первой проблемы,прохождение реквизита может быть утомительным для глубоко вложенных компонентов,и просто не работает для брата и сестры компонентов.Для проблемы номер два мы часто прибегаем к таким решениям,как поиск прямых ссылок на родительский/детский экземпляр или попытка мутировать и синхронизировать несколько копий состояния с помощью событий.Оба эти шаблона хрупки и быстро приводят к недостижимому коду.</target>
        </trans-unit>
        <trans-unit id="2a82f8d5ce145c881352007d801685ce832abbc7" translate="yes" xml:space="preserve">
          <source>For use in Node.js server-side rendering with &lt;code&gt;require()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424e49071bb58b22df700b0f0b42bc3fdfc8d652" translate="yes" xml:space="preserve">
          <source>For use with bundlers such as &lt;code&gt;webpack&lt;/code&gt;, &lt;code&gt;rollup&lt;/code&gt; and &lt;code&gt;parcel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd780fa7ac6288608638eda9123dd968783ffa71" translate="yes" xml:space="preserve">
          <source>For use with native ES module imports (including module supporting browsers via &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea63837c28f9e496db300536e9f97becac0fe11" translate="yes" xml:space="preserve">
          <source>Force the Vuex store into strict mode. In strict mode any mutations to Vuex state outside of mutation handlers will throw an Error.</source>
          <target state="translated">Переведите магазин Vuex в строгий режим.В строгом режиме любые мутации в состояние Vuex вне обработчиков мутаций приведут к ошибке.</target>
        </trans-unit>
        <trans-unit id="320e36f6db4da7afda899f2251cea1a84a74c2fd" translate="yes" xml:space="preserve">
          <source>Form Handling</source>
          <target state="translated">обработка пресс-форм</target>
        </trans-unit>
        <trans-unit id="8f92675b7ffe5ac821405fab6ddb6dee755e7a33" translate="yes" xml:space="preserve">
          <source>Furthermore, add the below line into anywhere in your code before using Vuex:</source>
          <target state="translated">Кроме того,перед использованием Vuex добавьте строку ниже в любое место своего кода:</target>
        </trans-unit>
        <trans-unit id="e156a94f2c9e52e0ddb1f3009ed07dd2abf8f227" translate="yes" xml:space="preserve">
          <source>Furthermore, you can create namespaced helpers by using &lt;code&gt;createNamespacedHelpers&lt;/code&gt;. It returns an object having new component binding helpers that are bound with the given namespace value:</source>
          <target state="translated">Кроме того, вы можете создавать помощники с пространством имен, используя &lt;code&gt;createNamespacedHelpers&lt;/code&gt; . Он возвращает объект с новыми помощниками привязки компонентов, которые связаны с заданным значением пространства имен:</target>
        </trans-unit>
        <trans-unit id="3bbbe89e1bf4029f9a507d85d668e0d1d5478d40" translate="yes" xml:space="preserve">
          <source>Getters</source>
          <target state="translated">Getters</target>
        </trans-unit>
        <trans-unit id="a2c7b1aaac2b0cd5b5c8cf82e9116fb532a36719" translate="yes" xml:space="preserve">
          <source>Getters will also receive other getters as the 2nd argument:</source>
          <target state="translated">Геттеры получат и другие геттеры в качестве 2-го аргумента:</target>
        </trans-unit>
        <trans-unit id="d5976d58530e9ba51288bd1c3ba468cfba584344" translate="yes" xml:space="preserve">
          <source>Getters will receive the state as their 1st argument:</source>
          <target state="translated">Геттеры получат состояние в качестве своего первого аргумента:</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Начало работы</target>
        </trans-unit>
        <trans-unit id="fca659dd312a705a6e05d1f829f26c05b73a3925" translate="yes" xml:space="preserve">
          <source>Getting Vuex State into Vue Components</source>
          <target state="translated">Получение состояния Vuex в Vue-компоненты</target>
        </trans-unit>
        <trans-unit id="4277a56d46a56f9393fef01ea88a4610c015a3f2" translate="yes" xml:space="preserve">
          <source>Global build is built as IIFE, and not UMD, and is only meant for direct use with &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="722346bbd4db03c1c92c2a13e486f0e957996d98" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt;.</source>
          <target state="translated">Перейдите на &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="f6642ec74afc236ede9f28e965753353dfeeed2c" translate="yes" xml:space="preserve">
          <source>Having to import &lt;code&gt;InjectionKey&lt;/code&gt; and passing it to &lt;code&gt;useStore&lt;/code&gt; everywhere it's used can quickly become a repetitive task. To simplify matters, you can define your own composable function to retrieve a typed store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a02043733710be9556d86b3bc87f17a5cbb0c2" translate="yes" xml:space="preserve">
          <source>Here's an example of the &lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;most basic Vuex counter app&lt;/a&gt;.</source>
          <target state="translated">Вот пример &lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;самого простого приложения счетчика Vuex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e74485fd2af89802a7ce36b6ae42c0bfcc32ed2" translate="yes" xml:space="preserve">
          <source>Hot Reloading</source>
          <target state="translated">Горячая перезагрузка</target>
        </trans-unit>
        <trans-unit id="c75202151698b65793216f709dd23fa91c67ca82" translate="yes" xml:space="preserve">
          <source>Hot swap new actions and mutations. &lt;a href=&quot;../guide/hot-reload&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Горячая замена новых действий и мутаций. &lt;a href=&quot;../guide/hot-reload&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adbb8bac10b93929c10b60c23f56b5f8139a3463" translate="yes" xml:space="preserve">
          <source>However, if you're writing your Vue components in TypeScript, there're a few steps to follow that require for you to correctly provide typings for a store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9fe831345a6e109e78580913b99472521a13a7" translate="yes" xml:space="preserve">
          <source>However, the simplicity quickly breaks down when we have &lt;strong&gt;multiple components that share a common state&lt;/strong&gt;:</source>
          <target state="translated">Однако простота быстро теряется, когда у нас есть &lt;strong&gt;несколько компонентов, которые имеют общее состояние&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c5371d6ce87417e1b9eefdc865251be6386c405f" translate="yes" xml:space="preserve">
          <source>However, this pattern causes the component to rely on the global store singleton. When using a module system, it requires importing the store in every component that uses store state, and also requires mocking when testing the component.</source>
          <target state="translated">Однако эта закономерность заставляет компонент полагаться на одиночку глобального магазина.При использовании модульной системы он требует импортирования магазина в каждый компонент,который использует состояние магазина,а также требует высмеивания при тестировании компонента.</target>
        </trans-unit>
        <trans-unit id="b36b5bee1a64a661bc0d45de384b9124cbd72bfe" translate="yes" xml:space="preserve">
          <source>If more than one component needs to make use of this, we have to either duplicate the function, or extract it into a shared helper and import it in multiple places - both are less than ideal.</source>
          <target state="translated">Если необходимо использовать более одного компонента,мы должны либо дублировать функцию,либо извлечь ее в общий помощник и импортировать ее в нескольких местах-и то,и другое менее чем идеально.</target>
        </trans-unit>
        <trans-unit id="bcd403966a8c64a6cc2f12e14145c0930fd23c8f" translate="yes" xml:space="preserve">
          <source>If we use a plain object to declare the state of the module, then that state object will be shared by reference and cause cross store/module state pollution when it's mutated.</source>
          <target state="translated">Если мы используем обычный объект для объявления состояния модуля,то этот объект состояния будет разделен по ссылке и вызовет перекрестное загрязнение состояния хранилища/модуля при его мутации.</target>
        </trans-unit>
        <trans-unit id="b7ec52a51a8cf587b9d439ecdf520d3332d63b46" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; you probably don't need this.</source>
          <target state="translated">Если вы используете &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools,&lt;/a&gt; вам это, вероятно, не нужно.</target>
        </trans-unit>
        <trans-unit id="cee9eac37fcab09966f32a737634f82881a4edd4" translate="yes" xml:space="preserve">
          <source>If you have spies available in your testing environment (for example via &lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt;), you can use them instead of the &lt;code&gt;testAction&lt;/code&gt; helper:</source>
          <target state="translated">Если в вашей тестовой среде есть шпионы (например, через &lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt; ), вы можете использовать их вместо помощника &lt;code&gt;testAction&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99253187df56aff1e087c7f8349702f7e584c5c0" translate="yes" xml:space="preserve">
          <source>If you pass a function that returns an object, the returned object is used as the root state. This is useful when you want to reuse the state object especially for module reuse. &lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Если вы передаете функцию, которая возвращает объект, возвращаемый объект используется в качестве корневого состояния. Это полезно, когда вы хотите повторно использовать объект состояния, особенно для повторного использования модуля. &lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09433d887f39cc66b122d2113ece04bd4c9edb90" translate="yes" xml:space="preserve">
          <source>If you prefer using a package manager such as NPM or Yarn, install it with the following commands:</source>
          <target state="translated">Если вы предпочитаете использовать менеджер пакетов,такой как NPM или Yarn,установите его следующими командами:</target>
        </trans-unit>
        <trans-unit id="c818e621900aa5c6ea1f6dea69d53344a7ed6a02" translate="yes" xml:space="preserve">
          <source>If you use modules exclusively, you can use &lt;code&gt;require.context&lt;/code&gt; to load and hot reload all modules dynamically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c23688fd4c0302fe8a3ccf68a85702b829cacd" translate="yes" xml:space="preserve">
          <source>If you want to learn Vuex in an interactive way you can check out this &lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;Vuex course on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">Если вы хотите изучить Vuex в интерактивном режиме, вы можете проверить этот &lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;курс Vuex на Scrimba&lt;/a&gt; , который дает вам сочетание скринкастов и площадок для кода, которые вы можете приостановить и поиграть в любое время.</target>
        </trans-unit>
        <trans-unit id="f3eb7c190d4d6d7796c724c80957f823f5be66cc" translate="yes" xml:space="preserve">
          <source>If you want to map a getter to a different name, use an object:</source>
          <target state="translated">Если вы хотите сопоставить эстафету с другим именем,используйте объект:</target>
        </trans-unit>
        <trans-unit id="20e00848ec8ade0a6824f9de7344231d1bfc9ba4" translate="yes" xml:space="preserve">
          <source>If you want to register global actions in namespaced modules, you can mark it with &lt;code&gt;root: true&lt;/code&gt; and place the action definition to function &lt;code&gt;handler&lt;/code&gt;. For example:</source>
          <target state="translated">Если вы хотите зарегистрировать глобальные действия в модулях с именами, вы можете пометить его с помощью &lt;code&gt;root: true&lt;/code&gt; и поместить определение действия в &lt;code&gt;handler&lt;/code&gt; функции . Например:</target>
        </trans-unit>
        <trans-unit id="4f4b8e63a24cc27e082d0c2aea79d7dec7762531" translate="yes" xml:space="preserve">
          <source>If you want to use global state and getters, &lt;code&gt;rootState&lt;/code&gt; and &lt;code&gt;rootGetters&lt;/code&gt; are passed as the 3rd and 4th arguments to getter functions, and also exposed as properties on the &lt;code&gt;context&lt;/code&gt; object passed to action functions.</source>
          <target state="translated">Если вы хотите использовать глобальное состояние и геттеры, &lt;code&gt;rootState&lt;/code&gt; и &lt;code&gt;rootGetters&lt;/code&gt; передаются в качестве 3-го и 4-го аргументов для функций-получателей, а также отображаются как свойства в объекте &lt;code&gt;context&lt;/code&gt; передаваемом функциям действия.</target>
        </trans-unit>
        <trans-unit id="6fcf9a3ab85ce67825ec590efb360c383d7dfca6" translate="yes" xml:space="preserve">
          <source>If you want your modules to be more self-contained or reusable, you can mark it as namespaced with &lt;code&gt;namespaced: true&lt;/code&gt;. When the module is registered, all of its getters, actions and mutations will be automatically namespaced based on the path the module is registered at. For example:</source>
          <target state="translated">Если вы хотите, чтобы ваши модули были более автономными или многоразовыми, вы можете пометить их как пространство имен с помощью &lt;code&gt;namespaced: true&lt;/code&gt; . Когда модуль зарегистрирован, все его геттеры, действия и мутации будут автоматически помещены в пространство имен в зависимости от пути, по которому модуль зарегистрирован. Например:</target>
        </trans-unit>
        <trans-unit id="09a871b493d3905657b3f74ae734baad18e2aaf1" translate="yes" xml:space="preserve">
          <source>If you've never built a large-scale SPA and jump right into Vuex, it may feel verbose and daunting. That's perfectly normal - if your app is simple, you will most likely be fine without Vuex. A simple &lt;a href=&quot;https://v3.vuejs.org/guide/state-management.html#simple-state-management-from-scratch&quot;&gt;store pattern&lt;/a&gt; may be all you need. But if you are building a medium-to-large-scale SPA, chances are you have run into situations that make you think about how to better handle state outside of your Vue components, and Vuex will be the natural next step for you. There's a good quote from Dan Abramov, the author of Redux:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c0c63467aaecb0aa7b51168b383f900b5a513b" translate="yes" xml:space="preserve">
          <source>If you've never built a large-scale SPA and jump right into Vuex, it may feel verbose and daunting. That's perfectly normal - if your app is simple, you will most likely be fine without Vuex. A simple &lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;store pattern&lt;/a&gt; may be all you need. But if you are building a medium-to-large-scale SPA, chances are you have run into situations that make you think about how to better handle state outside of your Vue components, and Vuex will be the natural next step for you. There's a good quote from Dan Abramov, the author of Redux:</source>
          <target state="translated">Если вы никогда не создавали крупномасштабный SPA и сразу переходили на Vuex, это может показаться многословным и пугающим. Это совершенно нормально - если ваше приложение простое, вы, скорее всего, обойдетесь без Vuex. Все, что вам может понадобиться, - это простой &lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;шаблон магазина&lt;/a&gt; . Но если вы создаете SPA среднего и крупного масштаба, скорее всего, вы столкнулись с ситуациями, которые заставят вас задуматься о том, как лучше обрабатывать состояние вне ваших компонентов Vue, и Vuex станет для вас естественным следующим шагом. Хорошая цитата Дэна Абрамова, автора Redux:</target>
        </trans-unit>
        <trans-unit id="c6537ddc12952ad16232d8a921be6b7d5a76a6d6" translate="yes" xml:space="preserve">
          <source>If your getters have complicated computation, it is worth testing them. Getters are also very straightforward to test for the same reason as mutations.</source>
          <target state="translated">Если у ваших геттеров сложные вычисления,стоит их протестировать.Геттеры также очень просты в тестировании по той же причине,что и мутации.</target>
        </trans-unit>
        <trans-unit id="4de758dad2a92aec248785ac4d6dbc0ff778d9aa" translate="yes" xml:space="preserve">
          <source>If your mutations and actions are written properly, the tests should have no direct dependency on Browser APIs after proper mocking. Thus you can simply bundle the tests with webpack and run it directly in Node. Alternatively, you can use &lt;code&gt;mocha-loader&lt;/code&gt; or Karma + &lt;code&gt;karma-webpack&lt;/code&gt; to run the tests in real browsers.</source>
          <target state="translated">Если ваши мутации и действия написаны правильно, тесты не должны иметь прямой зависимости от API-интерфейсов браузера после правильного имитации. Таким образом, вы можете просто связать тесты с веб-пакетом и запустить его прямо в Node. В качестве альтернативы вы можете использовать &lt;code&gt;mocha-loader&lt;/code&gt; или Karma + &lt;code&gt;karma-webpack&lt;/code&gt; для запуска тестов в реальных браузерах.</target>
        </trans-unit>
        <trans-unit id="6ee31c41647a54af22ae141a98d0fec5c96154f7" translate="yes" xml:space="preserve">
          <source>In Vuex 3, &lt;code&gt;createLogger&lt;/code&gt; function was exported from &lt;code&gt;vuex/dist/logger&lt;/code&gt; but it's now included in the core package. The function should be imported directly from the &lt;code&gt;vuex&lt;/code&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a410e66d911dd3ae0a50e7b80b34a4ce49f0e9c" translate="yes" xml:space="preserve">
          <source>In a Vue component, you can access the store as &lt;code&gt;this.$store&lt;/code&gt;. Now we can commit a mutation using a component method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21dc6e7af159e44f13e61d052a381cc5930fcfa" translate="yes" xml:space="preserve">
          <source>In most cases, the payload should be an object so that it can contain multiple fields, and the recorded mutation will also be more descriptive:</source>
          <target state="translated">В большинстве случаев полезная нагрузка должна быть объектом,чтобы она могла содержать несколько полей,а записанная мутация также будет более описательной:</target>
        </trans-unit>
        <trans-unit id="c8e693418938cacbff5b768a895b5e05008f1bcd" translate="yes" xml:space="preserve">
          <source>In order to access state and getters, you will want to create &lt;code&gt;computed&lt;/code&gt; references to retain reactivity. This is the equivalent of creating computed properties using the Option API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b379a9de19b6c2947713c2e819c098b0d0414341" translate="yes" xml:space="preserve">
          <source>In practice, we often use ES2015 &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;argument destructuring&lt;/a&gt; to simplify the code a bit (especially when we need to call &lt;code&gt;commit&lt;/code&gt; multiple times):</source>
          <target state="translated">На практике мы часто используем деструктуризацию &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;аргументов&lt;/a&gt; ES2015, чтобы немного упростить код (особенно когда нам нужно вызвать &lt;code&gt;commit&lt;/code&gt; несколько раз):</target>
        </trans-unit>
        <trans-unit id="3857e213dc0f7b8c7391de2df6fe7f4ad9600a0c" translate="yes" xml:space="preserve">
          <source>In strict mode, whenever Vuex state is mutated outside of mutation handlers, an error will be thrown. This ensures that all state mutations can be explicitly tracked by debugging tools.</source>
          <target state="translated">В строгом режиме,всякий раз,когда состояние Vuex мутируется вне обработчиков мутации,будет сбрасываться ошибка.Это гарантирует,что все мутации состояний могут быть явно отслежены средствами отладки.</target>
        </trans-unit>
        <trans-unit id="f605f46f5b670a253f694d77a6479a46bf60c051" translate="yes" xml:space="preserve">
          <source>In such cases, you can pass the module namespace string as the first argument to the helpers so that all bindings are done using that module as the context. The above can be simplified to:</source>
          <target state="translated">В таких случаях вы можете передать строку пространства имён модуля в качестве первого аргумента помощникам,чтобы все привязки выполнялись с использованием этого модуля в качестве контекста.Все вышеизложенное можно упростить:</target>
        </trans-unit>
        <trans-unit id="fb4ca597574fefd3c18365a4df91a07d3925f51b" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;vuex&lt;/code&gt; after Vue and it will install itself automatically:</source>
          <target state="translated">Включите &lt;code&gt;vuex&lt;/code&gt; после Vue, и он установится автоматически:</target>
        </trans-unit>
        <trans-unit id="4edd5883cfc0f50d6093450192a5526d804c388e" translate="yes" xml:space="preserve">
          <source>Inside a module's mutations and getters, the first argument received will be &lt;strong&gt;the module's local state&lt;/strong&gt;.</source>
          <target state="translated">Внутри мутаций и геттеров модуля первым полученным аргументом будет &lt;strong&gt;локальное состояние модуля&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="457ba19288441fafbf211b7b6c88681a0845bc6a" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;mocha-loader&lt;/code&gt;.</source>
          <target state="translated">Установите &lt;code&gt;mocha-loader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="cddc92ee3266aa27b7cb36a384142725c9edaa5f" translate="yes" xml:space="preserve">
          <source>Installation process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0fe35d22060e945e08d2b96b5abfd85eb87e88" translate="yes" xml:space="preserve">
          <source>Instead of mutating the state, actions commit mutations.</source>
          <target state="translated">Вместо того,чтобы мутировать государство,действия совершают мутации.</target>
        </trans-unit>
        <trans-unit id="fb1e51da35f8b4fc5e80bad74fa44c9f09edf0fe" translate="yes" xml:space="preserve">
          <source>It is a commonly seen pattern to use constants for mutation types in various Flux implementations. This allows the code to take advantage of tooling like linters, and putting all constants in a single file allows your collaborators to get an at-a-glance view of what mutations are possible in the entire application:</source>
          <target state="translated">Часто встречается закономерность использования констант для типов мутаций в различных реализациях Flux.Это позволяет коду использовать такие инструменты,как linters,а размещение всех констант в одном файле позволяет вашим сотрудникам получить мгновенное представление о том,какие мутации возможны во всем приложении:</target>
        </trans-unit>
        <trans-unit id="b3f113c6b42082f72c3757fb134ac642d34ef542" translate="yes" xml:space="preserve">
          <source>It is a self-contained app with the following parts:</source>
          <target state="translated">Это автономное приложение со следующими частями:</target>
        </trans-unit>
        <trans-unit id="3ed4288f050eb852b800df4047f36461f3b17cbb" translate="yes" xml:space="preserve">
          <source>It may be likely that you want to preserve the previous state when registering a new module, such as preserving state from a Server Side Rendered app. You can achieve this with &lt;code&gt;preserveState&lt;/code&gt; option: &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</source>
          <target state="translated">Возможно, вы захотите сохранить предыдущее состояние при регистрации нового модуля, например, сохранить состояние из приложения, отображаемого на стороне сервера. Вы можете добиться этого с помощью параметра &lt;code&gt;preserveState&lt;/code&gt; : &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35dface9e340cb4e3bddcda3e4f2453cf5b8832e" translate="yes" xml:space="preserve">
          <source>It's possible for a &lt;code&gt;store.dispatch&lt;/code&gt; to trigger multiple action handlers in different modules. In such a case the returned value will be a Promise that resolves when all triggered handlers have been resolved.</source>
          <target state="translated">Это возможно для &lt;code&gt;store.dispatch&lt;/code&gt; , чтобы вызвать несколько обработчиков действий в различных модулях. В таком случае возвращаемое значение будет Promise, которое разрешается, когда все запущенные обработчики были разрешены.</target>
        </trans-unit>
        <trans-unit id="c26d954c51975d2534551b78c8a2337962fddd24" translate="yes" xml:space="preserve">
          <source>Last Updated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea187f850a75f522b6507857c44f2cc66982153" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.&lt;wbr/&gt;env.NODE_ENV&lt;/code&gt; guards (must be replaced by bundler).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad0c3d2dd4948e1dc7eca7ef59267b9baf27c8d" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; guards (must be replaced by bundler).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9285043eca58d77420a4ea528c9c0140b7f99e5" translate="yes" xml:space="preserve">
          <source>Let's register a simple action:</source>
          <target state="translated">Давайте зарегистрируем простое действие:</target>
        </trans-unit>
        <trans-unit id="e58183fe873032e36b18fd13feeb2f3de6adac51" translate="yes" xml:space="preserve">
          <source>Let's start with a simple Vue counter app:</source>
          <target state="translated">Давайте начнем с простого приложения для счетчика Vue:</target>
        </trans-unit>
        <trans-unit id="c7d28df54f0ee7bb49a6c375079257b9e2ce533e" translate="yes" xml:space="preserve">
          <source>Let's tackle this step by step. First, define the key using Vue's &lt;code&gt;InjectionKey&lt;/code&gt; interface along with your own store typing definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="3c4e2ff1708a0052c627ff0c7963ae29daba2c37" translate="yes" xml:space="preserve">
          <source>Method-Style Access</source>
          <target state="translated">Доступ по методу-стилю</target>
        </trans-unit>
        <trans-unit id="c2e90d9f7d5710359410a2feb78df1c412eb56ec" translate="yes" xml:space="preserve">
          <source>Migrating to 4.0 from 3.x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f4a0ce2e411202b8f65d464a7de482b8f37081" translate="yes" xml:space="preserve">
          <source>Module Local State</source>
          <target state="translated">Модуль Местное государство</target>
        </trans-unit>
        <trans-unit id="da07abb5f2f59744fb9d34a53f63697e0f2d1603" translate="yes" xml:space="preserve">
          <source>Module Reuse</source>
          <target state="translated">Повторное использование модуля</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="f4e46025da22a7ac6c15f6c0d760b1ec96373a5b" translate="yes" xml:space="preserve">
          <source>Most commonly used in plugins. &lt;a href=&quot;../guide/plugins&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Чаще всего используется в плагинах. &lt;a href=&quot;../guide/plugins&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="415ace164c00364e28e4d1cc0b1dea319d4e4fe4" translate="yes" xml:space="preserve">
          <source>Multiple views may depend on the same piece of state.</source>
          <target state="translated">Несколько представлений могут зависеть от одного и того же состояния.</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="104200b8a17f6d972a707d856a1247d4c7c79f01" translate="yes" xml:space="preserve">
          <source>Mutations Follow Vue's Reactivity Rules</source>
          <target state="translated">Мутации следуют правилам реактивности Vue</target>
        </trans-unit>
        <trans-unit id="1c4ca77f8cfecf119f2abce71ca721d4bcfe55b6" translate="yes" xml:space="preserve">
          <source>Mutations Must Be Synchronous</source>
          <target state="translated">Мутации должны быть синхронными</target>
        </trans-unit>
        <trans-unit id="654ac141ada51cc2648d26957205d691ce5cdaec" translate="yes" xml:space="preserve">
          <source>Mutations are very straightforward to test, because they are just functions that completely rely on their arguments. One trick is that if you are using ES2015 modules and put your mutations inside your &lt;code&gt;store.js&lt;/code&gt; file, in addition to the default export, you should also export the mutations as a named export:</source>
          <target state="translated">Мутации очень легко проверить, потому что это просто функции, полностью полагающиеся на свои аргументы. Один из приемов заключается в том, что если вы используете модули ES2015 и помещаете свои мутации в файл &lt;code&gt;store.js&lt;/code&gt; , помимо экспорта по умолчанию, вы также должны экспортировать мутации как именованный экспорт:</target>
        </trans-unit>
        <trans-unit id="a8ad860c15810cce0e7beac1c91da3ab2cb22c47" translate="yes" xml:space="preserve">
          <source>NOTE</source>
          <target state="translated">NOTE</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="f0146eaf3d75ae19152beec5a891e0df9b9d3793" translate="yes" xml:space="preserve">
          <source>Namespaced getters and actions will receive localized &lt;code&gt;getters&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;. In other words, you can use the module assets without writing prefix in the same module. Toggling between namespaced or not does not affect the code inside the module.</source>
          <target state="translated">Получатели и действия с пространством имен получат локализованные &lt;code&gt;getters&lt;/code&gt; , &lt;code&gt;dispatch&lt;/code&gt; и &lt;code&gt;commit&lt;/code&gt; . Другими словами, вы можете использовать активы модуля, не записывая префикс в том же самом модуле. Переключение между пространством имен и без него не влияет на код внутри модуля.</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="156e3db7d7ff24a58bfd4733460906ddcf9c82d6" translate="yes" xml:space="preserve">
          <source>New &quot;useStore&quot; composition function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71d5762c0258836841ff5df622a89af0d09ccba" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;useStore&lt;/code&gt; composition function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025519ea3f483eb11a3c8608b8a731eee0947b1b" translate="yes" xml:space="preserve">
          <source>New Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4820b6a8eaff4049273790823038a2d97641ee6b" translate="yes" xml:space="preserve">
          <source>New in 2.5.0</source>
          <target state="translated">Новое в 2.5.0</target>
        </trans-unit>
        <trans-unit id="ee5b92286bff361e6506cbde70ab9d79b67f9e22" translate="yes" xml:space="preserve">
          <source>New in 3.1.0</source>
          <target state="translated">Новое в 3.1.0</target>
        </trans-unit>
        <trans-unit id="f603edae1429a95385a9e96dce7eed555212b05b" translate="yes" xml:space="preserve">
          <source>Next, pass the defined injection key when installing the store to the Vue app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cbec932a3607b921845482469e8e3e43a2cef8" translate="yes" xml:space="preserve">
          <source>Next, we will discuss each core concept in much finer details, starting with &lt;a href=&quot;state&quot;&gt;State&lt;/a&gt;.</source>
          <target state="translated">Далее мы обсудим каждую основную концепцию более подробно, начиная с &lt;a href=&quot;state&quot;&gt;состояния&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a19151987fbe02547ee0f70513d32dd282c4ac0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mapState&lt;/code&gt; returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to &lt;code&gt;computed&lt;/code&gt;. However with the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread operator&lt;/a&gt; (which is a stage-4 ECMAScript proposal), we can greatly simplify the syntax:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;mapState&lt;/code&gt; возвращает объект. Как мы можем использовать его в сочетании с другими локальными вычисляемыми свойствами? Обычно нам нужно использовать служебную программу для объединения нескольких объектов в один, чтобы мы могли передать последний объект &lt;code&gt;computed&lt;/code&gt; . Однако с помощью &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;оператора распространения объекта&lt;/a&gt; (который является предложением ECMAScript этапа 4) мы можем значительно упростить синтаксис:</target>
        </trans-unit>
        <trans-unit id="8fdd2db4fff8fb671f8b5b5304c69fa03718c6bb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mapState&lt;/code&gt; returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to &lt;code&gt;computed&lt;/code&gt;. However with the &lt;a href=&quot;https://github.com/tc39/proposal-object-rest-spread&quot;&gt;object spread operator&lt;/a&gt;, we can greatly simplify the syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383f040aea7fdc521540d519355364a1d7f735a8" translate="yes" xml:space="preserve">
          <source>Note that getters accessed as properties are cached as part of Vue's reactivity system.</source>
          <target state="translated">Обратите внимание,что геттеры,доступные как свойства,кэшируются как часть системы реактивности Vue.</target>
        </trans-unit>
        <trans-unit id="ee0bf46abe7c412da05c2c7e1afee2ada212118c" translate="yes" xml:space="preserve">
          <source>Note that getters accessed via methods will run each time you call them, and the result is not cached.</source>
          <target state="translated">Обратите внимание,что геттеры,доступные через методы,будут запускаться каждый раз,когда вы их вызываете,и результат не будет кэшироваться.</target>
        </trans-unit>
        <trans-unit id="d5717e27426eb7a2d5c1747c90156711ec9ef26a" translate="yes" xml:space="preserve">
          <source>Note that you may check if the module is already registered to the store or not via &lt;code&gt;store.hasModule(moduleName)&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fca34876045ca8e7715e28c6d04cb4373157ba" translate="yes" xml:space="preserve">
          <source>Note the logger plugin takes state snapshots, so use it only during development.</source>
          <target state="translated">Обратите внимание,что плагин регистратора делает снимки состояния,поэтому используйте его только в процессе разработки.</target>
        </trans-unit>
        <trans-unit id="11f45dfd75b6d4fbcfd55b7ac788bd4b130224b1" translate="yes" xml:space="preserve">
          <source>Note we are performing a flow of asynchronous operations, and recording the side effects (state mutations) of the action by committing them.</source>
          <target state="translated">Обратите внимание,что мы выполняем поток асинхронных операций и записываем побочные эффекты (мутации состояния)действия,фиксируя их.</target>
        </trans-unit>
        <trans-unit id="ab293ff1751dac6b50aacc1c946da9ff9bd12a5a" translate="yes" xml:space="preserve">
          <source>Now imagine we are debugging the app and looking at the devtool's mutation logs. For every mutation logged, the devtool will need to capture a &quot;before&quot; and &quot;after&quot; snapshots of the state. However, the asynchronous callback inside the example mutation above makes that impossible: the callback is not called yet when the mutation is committed, and there's no way for the devtool to know when the callback will actually be called - any state mutation performed in the callback is essentially un-trackable!</source>
          <target state="translated">А теперь представьте,что мы отлаживаем приложение и смотрим журналы мутаций девственника.Для каждой мутации,записанной в журнале,девтушке нужно будет сделать снимки состояния &quot;до&quot; и &quot;после&quot;.Однако,асинхронный вызов внутри приведенного выше примера мутации делает это невозможным:вызов еще не вызывается,когда мутация зафиксирована,и для девтула нет способа узнать,когда вызов будет действительно вызван-любая мутация состояния,осуществленная при вызове,по сути,не отслеживается!</target>
        </trans-unit>
        <trans-unit id="93b9e7a0a6529c120d308e3a9afc60556aa4685a" translate="yes" xml:space="preserve">
          <source>Now you can do:</source>
          <target state="translated">Теперь ты можешь:</target>
        </trans-unit>
        <trans-unit id="a5bc280bd65d97298b6a537bbd98ca0fca61ada2" translate="yes" xml:space="preserve">
          <source>Now, by importing your own composable function, you can retrieve the typed store &lt;strong&gt;without&lt;/strong&gt; having to provide the injection key and it's typing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab930ccc32a830cf1b2daffb710e302771e1ccf" translate="yes" xml:space="preserve">
          <source>Now, you can access the state object as &lt;code&gt;store.state&lt;/code&gt;, and trigger a state change with the &lt;code&gt;store.commit&lt;/code&gt; method:</source>
          <target state="translated">Теперь вы можете получить доступ к объекту состояния как &lt;code&gt;store.state&lt;/code&gt; и вызвать изменение состояния с &lt;code&gt;store.commit&lt;/code&gt; метода store.commit :</target>
        </trans-unit>
        <trans-unit id="ace4a2b4fe085d950494ad9721a19fbdb4b869ed" translate="yes" xml:space="preserve">
          <source>Object Spread Operator</source>
          <target state="translated">Оператор распространения объектов</target>
        </trans-unit>
        <trans-unit id="4e55a0d58d5e1d3dd2c370978eeab3967aadea55" translate="yes" xml:space="preserve">
          <source>Object-Style Commit</source>
          <target state="translated">Объектно-стилевой комитет</target>
        </trans-unit>
        <trans-unit id="af6888b6f45f7db98c78eb748575fc0a520bf758" translate="yes" xml:space="preserve">
          <source>On to Actions</source>
          <target state="translated">Переходим к действиям</target>
        </trans-unit>
        <trans-unit id="be28144bfe8196f5de9245ef24f38b80c1795631" translate="yes" xml:space="preserve">
          <source>One important rule to remember is that &lt;strong&gt;mutation handler functions must be synchronous&lt;/strong&gt;. Why? Consider the following example:</source>
          <target state="translated">Следует помнить одно важное правило: &lt;strong&gt;функции обработчика мутаций должны быть синхронными&lt;/strong&gt; . Зачем? Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="0a517ce6f632f361387aae43f330fac6b9ff2fb5" translate="yes" xml:space="preserve">
          <source>Pass the typed &lt;code&gt;InjectionKey&lt;/code&gt; to the &lt;code&gt;useStore&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2228a15359ec1787af59c5da6ce5e371da06846" translate="yes" xml:space="preserve">
          <source>Place the following code in your project to allow &lt;code&gt;this.$store&lt;/code&gt; to be typed correctly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="22f632f9f25219b387e3b3f91a16935bbf27d29a" translate="yes" xml:space="preserve">
          <source>Plugins are not allowed to directly mutate state - similar to your components, they can only trigger changes by committing mutations.</source>
          <target state="translated">Плагины не допускают прямого мутирования состояния-подобно вашим компонентам,они могут инициировать изменения только путем фиксации мутаций.</target>
        </trans-unit>
        <trans-unit id="184f9c5d6a512ea46935550bc3405af620cc2aa9" translate="yes" xml:space="preserve">
          <source>Prefer initializing your store's initial state with all desired fields upfront.</source>
          <target state="translated">Предпочтителено инициализировать начальное состояние вашего магазина всеми желаемыми полями.</target>
        </trans-unit>
        <trans-unit id="e7e706a353f493baa85f48336645f1af9ce6a62b" translate="yes" xml:space="preserve">
          <source>Preserving state</source>
          <target state="translated">Сохраняющее государство</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="8dc7952272c26facc9a2c5604edbd77344108471" translate="yes" xml:space="preserve">
          <source>Property-Style Access</source>
          <target state="translated">Доступ к недвижимости</target>
        </trans-unit>
        <trans-unit id="f3080b3597ce40f7b3c7da14211527d0235807a1" translate="yes" xml:space="preserve">
          <source>Provide the typed &lt;code&gt;InjectionKey&lt;/code&gt; when installing a store to the Vue app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fffd76e54cabe19ee1677cc2622cd23e6e275e9" translate="yes" xml:space="preserve">
          <source>Reactively watch &lt;code&gt;fn&lt;/code&gt;'s return value, and call the callback when the value changes. &lt;code&gt;fn&lt;/code&gt; receives the store's state as the first argument, and getters as the second argument. Accepts an optional options object that takes the same options as &lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;Vue's &lt;code&gt;vm.$watch&lt;/code&gt; method&lt;/a&gt;.</source>
          <target state="translated">Реактивно следите за возвращаемым значением &lt;code&gt;fn&lt;/code&gt; и вызывайте обратный вызов при изменении значения. &lt;code&gt;fn&lt;/code&gt; получает состояние хранилища в качестве первого аргумента, а методы получения - в качестве второго аргумента. Принимает необязательный объект параметров, который принимает те же параметры, что &lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;и метод &lt;code&gt;vm.$watch&lt;/code&gt; Vue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75e4ab33b7b5dc7455e9eadf2e7119121508fb6e" translate="yes" xml:space="preserve">
          <source>Register Global Action in Namespaced Modules</source>
          <target state="translated">Регистрация глобальных действий в модулях с разными названиями</target>
        </trans-unit>
        <trans-unit id="de6210ec05f575ccd3825af5410dca87db3c1a7e" translate="yes" xml:space="preserve">
          <source>Register a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Зарегистрируйте динамический модуль. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad2bb0219d3b7cad70e9aeaf8b370461d8c5f459" translate="yes" xml:space="preserve">
          <source>Register actions on the store. The handler function receives a &lt;code&gt;context&lt;/code&gt; object that exposes the following properties:</source>
          <target state="translated">Зарегистрируйте действия в магазине. Функция-обработчик получает объект &lt;code&gt;context&lt;/code&gt; который предоставляет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="0c3c4cb0360b08ab239d9d6ce7ef5979c7bd75c9" translate="yes" xml:space="preserve">
          <source>Register getters on the store. The getter function receives the following arguments:</source>
          <target state="translated">Зарегистрируйте получателей в магазине.Функция геттера получает следующие аргументы:</target>
        </trans-unit>
        <trans-unit id="b656445541eada906150dd7ca28e7277b3f8ac2d" translate="yes" xml:space="preserve">
          <source>Register mutations on the store. The handler function always receives &lt;code&gt;state&lt;/code&gt; as the first argument (will be module local state if defined in a module), and receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">Зарегистрируйте мутации в магазине. Функция-обработчик всегда получает &lt;code&gt;state&lt;/code&gt; в качестве первого аргумента (будет локальным состоянием модуля, если оно определено в модуле), и получает второй аргумент &lt;code&gt;payload&lt;/code&gt; если он есть.</target>
        </trans-unit>
        <trans-unit id="17a6292e850aa27ddd8a69f3670d7bf427ff4201" translate="yes" xml:space="preserve">
          <source>Register the same module multiple times in the same store.</source>
          <target state="translated">Зарегистрируйте один и тот же модуль несколько раз в одном и том же магазине.</target>
        </trans-unit>
        <trans-unit id="9adccc4f4e3ee229d76671c447375a4b4430cf1a" translate="yes" xml:space="preserve">
          <source>Registered getters are exposed on &lt;code&gt;store.getters&lt;/code&gt;.</source>
          <target state="translated">Зарегистрированные геттеры доступны на &lt;code&gt;store.getters&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e74661ca249919f9eff75810910ad50f600b9f27" translate="yes" xml:space="preserve">
          <source>Replace that Object with a fresh one. For example, using the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread syntax&lt;/a&gt; we can write it like this:</source>
          <target state="translated">Замените этот Объект новым. Например, используя &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;синтаксис распространения объекта,&lt;/a&gt; мы можем записать его так:</target>
        </trans-unit>
        <trans-unit id="cfc7d1d9a1abac11e07fd8298b3033a2dd367be4" translate="yes" xml:space="preserve">
          <source>Replace the store's root state. Use this only for state hydration / time-travel purposes.</source>
          <target state="translated">Замените корневое состояние магазина.Используйте это только для гидратации состояния/путешествия во времени.</target>
        </trans-unit>
        <trans-unit id="7ec9eede60ad8e8637510a86e616531533ada02f" translate="yes" xml:space="preserve">
          <source>Running Tests</source>
          <target state="translated">Испытания на прочность</target>
        </trans-unit>
        <trans-unit id="11b20f83f47c6fa0a2ecb66cf17c37a8bf3312ce" translate="yes" xml:space="preserve">
          <source>Running in Browser</source>
          <target state="translated">Запуск в браузере</target>
        </trans-unit>
        <trans-unit id="27b89784a5a88ae4dea9d0fe0a57d6ac83db22be" translate="yes" xml:space="preserve">
          <source>Running in Browser with Karma + karma-webpack</source>
          <target state="translated">Браузер с кармой+карма-вэбпак</target>
        </trans-unit>
        <trans-unit id="cbd1c1641d5f61fff635a6b95f6786707cdb60a6" translate="yes" xml:space="preserve">
          <source>Running in Node</source>
          <target state="translated">Запуск в узле</target>
        </trans-unit>
        <trans-unit id="b7a73f532334578b3a16beb74895158fa37aca37" translate="yes" xml:space="preserve">
          <source>Similar to plugins, we can let the build tools handle that:</source>
          <target state="translated">Как и плагины,мы можем позволить инструментам сборки справиться с этим:</target>
        </trans-unit>
        <trans-unit id="6440404824fd3c3690de22244c1449cd72882e79" translate="yes" xml:space="preserve">
          <source>Similarly, inside module actions, &lt;code&gt;context.state&lt;/code&gt; will expose the local state, and root state will be exposed as &lt;code&gt;context.rootState&lt;/code&gt;:</source>
          <target state="translated">Точно так же внутри действий модуля &lt;code&gt;context.state&lt;/code&gt; будет отображать локальное состояние, а корневое состояние будет отображаться как &lt;code&gt;context.rootState&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ca9c5e520923e6214e6e652479441ba757527ff7" translate="yes" xml:space="preserve">
          <source>Simplifying &lt;code&gt;useStore&lt;/code&gt; usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025e718449a36bec79871ddaaf94c1265848b2f1" translate="yes" xml:space="preserve">
          <source>Since 3.1.0, &lt;code&gt;subscribeAction&lt;/code&gt; can also specify whether the subscribe handler should be called &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; an action dispatch (the default behavior is &lt;em&gt;before&lt;/em&gt;):</source>
          <target state="translated">Начиная с версии 3.1.0, &lt;code&gt;subscribeAction&lt;/code&gt; также может указывать, должен ли обработчик подписки вызываться &lt;em&gt;до&lt;/em&gt; или &lt;em&gt;после&lt;/em&gt; отправки действия (поведение по умолчанию - &lt;em&gt;до&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="f3fd68e0c5995c6798e0356b50e929c10917b3a4" translate="yes" xml:space="preserve">
          <source>Since a Vuex store's state is made reactive by Vue, when we mutate the state, Vue components observing the state will update automatically. This also means Vuex mutations are subject to the same reactivity caveats when working with plain Vue:</source>
          <target state="translated">Так как состояние магазина Vuex становится реактивным с помощью Vue,то при мутации состояния компоненты Vue,наблюдающие за состоянием,будут обновляться автоматически.Это также означает,что мутации Vuex при работе с обычным Vue подвержены тем же самым предупреждениям о реактивности:</target>
        </trans-unit>
        <trans-unit id="92041cc87d58be0a729eade29063235fe14b3c9c" translate="yes" xml:space="preserve">
          <source>Single State Tree</source>
          <target state="translated">Одно дерево</target>
        </trans-unit>
        <trans-unit id="5f6ffb7192daf8fe93bcac0572129c5101463336" translate="yes" xml:space="preserve">
          <source>So how do we display state inside the store in our Vue components? Since Vuex stores are reactive, the simplest way to &quot;retrieve&quot; state from it is simply returning some store state from within a &lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;computed property&lt;/a&gt;:</source>
          <target state="translated">Итак, как мы отображаем состояние внутри хранилища в наших компонентах Vue? Поскольку хранилища Vuex являются реактивными, самый простой способ &amp;laquo;получить&amp;raquo; из них состояние - просто вернуть некоторое состояние хранилища из &lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;вычисляемого свойства&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="54d205729e342259f235761f9ebec2b225fe9abb" translate="yes" xml:space="preserve">
          <source>So why don't we extract the shared state out of the components, and manage it in a global singleton? With this, our component tree becomes a big &quot;view&quot;, and any component can access the state or trigger actions, no matter where they are in the tree!</source>
          <target state="translated">Так почему бы нам не извлечь общее состояние из компонентов и не управлять им в глобальном одиночку? При этом наше дерево компонентов становится большим &quot;видом&quot;,и любой компонент может получить доступ к состоянию или запустить действия,независимо от того,где они находятся в дереве!</target>
        </trans-unit>
        <trans-unit id="f9f500529b87d6c41aa1c9ce2a53ab85b0f73f09" translate="yes" xml:space="preserve">
          <source>Sometimes a plugin may want to receive &quot;snapshots&quot; of the state, and also compare the post-mutation state with pre-mutation state. To achieve that, you will need to perform a deep-copy on the state object:</source>
          <target state="translated">Иногда плагин может захотеть получить &quot;снимки&quot; состояния,а также сравнить состояние после мутации с состоянием до мутации.Для этого необходимо выполнить глубокую копию объекта состояния:</target>
        </trans-unit>
        <trans-unit id="ae8a5bdac2cd3270ab81602ae7fc6131bdbc35db" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to compute derived state based on store state, for example filtering through a list of items and counting them:</source>
          <target state="translated">Иногда может потребоваться вычислить производное состояние,основанное на состоянии хранилища,например,фильтрация по списку элементов и их подсчет:</target>
        </trans-unit>
        <trans-unit id="35ae76006ac7e393b8d6ac1ac6f19a1ddefd3da2" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to create multiple instances of a module, for example:</source>
          <target state="translated">Иногда,например,может понадобиться создать несколько экземпляров модуля:</target>
        </trans-unit>
        <trans-unit id="13e4487543b6d8b06a46672cfa73442042e5fe18" translate="yes" xml:space="preserve">
          <source>Specific when defined in a module</source>
          <target state="translated">Конкретные,если они определены в модуле</target>
        </trans-unit>
        <trans-unit id="aabf420288f022d987bce3f9558b9c31ba749e69" translate="yes" xml:space="preserve">
          <source>Start &lt;code&gt;webpack-dev-server&lt;/code&gt; using the config.</source>
          <target state="translated">Запустите &lt;code&gt;webpack-dev-server&lt;/code&gt; с помощью config.</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="cc646793e5a188b7dfed3c624e7ab770f511a330" translate="yes" xml:space="preserve">
          <source>Store Constructor Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3918202b47796e149a1504576be44f9c797b67" translate="yes" xml:space="preserve">
          <source>Store Instance Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78960d483bd318512b15157254083d90ec1e70bb" translate="yes" xml:space="preserve">
          <source>Store Instance Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2f83ae922aab27ffe541f2875e43e6786c6d9f" translate="yes" xml:space="preserve">
          <source>StoreOptions.actions</source>
          <target state="translated">StoreOptions.actions</target>
        </trans-unit>
        <trans-unit id="7c2fb974fe6ac37076408fe6492caf0b5a840a6c" translate="yes" xml:space="preserve">
          <source>StoreOptions.devtools</source>
          <target state="translated">StoreOptions.devtools</target>
        </trans-unit>
        <trans-unit id="27bc45330a80e26b40635dc4a8b8fc17abc36877" translate="yes" xml:space="preserve">
          <source>StoreOptions.getters</source>
          <target state="translated">StoreOptions.getters</target>
        </trans-unit>
        <trans-unit id="13d89889e279cf3f4db38944cc0e1b9022ac7e5b" translate="yes" xml:space="preserve">
          <source>StoreOptions.modules</source>
          <target state="translated">StoreOptions.modules</target>
        </trans-unit>
        <trans-unit id="f35c2bfcf842e192031830ea98d80cec6e137cc2" translate="yes" xml:space="preserve">
          <source>StoreOptions.mutations</source>
          <target state="translated">StoreOptions.mutations</target>
        </trans-unit>
        <trans-unit id="9b08c590c8720def20c8cc4d49a23a43f356dabe" translate="yes" xml:space="preserve">
          <source>StoreOptions.plugins</source>
          <target state="translated">StoreOptions.plugins</target>
        </trans-unit>
        <trans-unit id="249ab110bf5289e564529ec006774bd6849ef3fa" translate="yes" xml:space="preserve">
          <source>StoreOptions.state</source>
          <target state="translated">StoreOptions.state</target>
        </trans-unit>
        <trans-unit id="057f939fdf0b4897b3dea09feff450cb50fdf3a3" translate="yes" xml:space="preserve">
          <source>StoreOptions.strict</source>
          <target state="translated">StoreOptions.strict</target>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="translated">Строгий режим</target>
        </trans-unit>
        <trans-unit id="cf363d0f2bd89c65219cc88d7452d61570ae39f4" translate="yes" xml:space="preserve">
          <source>Subscribe to store actions. The &lt;code&gt;handler&lt;/code&gt; is called for every dispatched action and receives the action descriptor and current store state as arguments. The &lt;code&gt;subscribe&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, when unregistering a Vuex module or before destroying a Vue component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4be8ac142fac6db9e88ed567eba8eb3225184f" translate="yes" xml:space="preserve">
          <source>Subscribe to store actions. The &lt;code&gt;handler&lt;/code&gt; is called for every dispatched action and receives the action descriptor and current store state as arguments:</source>
          <target state="translated">Подпишитесь на действия магазина. &lt;code&gt;handler&lt;/code&gt; вызывается для каждого обработанным действием и принимает дескриптор действия и текущее состояние хранилища в качестве аргументов:</target>
        </trans-unit>
        <trans-unit id="120d63b068274dc6942d114c566d657d42c319d8" translate="yes" xml:space="preserve">
          <source>Subscribe to store mutations. The &lt;code&gt;handler&lt;/code&gt; is called after every mutation and receives the mutation descriptor and post-mutation state as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1e862a182cd71e72218de4a57d6428ba414773" translate="yes" xml:space="preserve">
          <source>Subscribe to store mutations. The &lt;code&gt;handler&lt;/code&gt; is called after every mutation and receives the mutation descriptor and post-mutation state as arguments:</source>
          <target state="translated">Подпишитесь, чтобы хранить мутации. &lt;code&gt;handler&lt;/code&gt; вызывается после каждой мутации и получает дескриптор мутации и состояние после мутации в качестве аргументов:</target>
        </trans-unit>
        <trans-unit id="4a190c880575f8d6d89a23b4172d04f0a311e4e6" translate="yes" xml:space="preserve">
          <source>Taking State Snapshots</source>
          <target state="translated">Делаем снимки состояния</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="c59410bf3ca2f20fd8b0393728deccf2dc47f93a" translate="yes" xml:space="preserve">
          <source>Testing Actions</source>
          <target state="translated">Испытательные действия</target>
        </trans-unit>
        <trans-unit id="34e8d11332da2e378672d0a243a1d14c5129d499" translate="yes" xml:space="preserve">
          <source>Testing Getters</source>
          <target state="translated">Тест-генераторы</target>
        </trans-unit>
        <trans-unit id="97aad71ba2619e15a2576f93a06f963d9f14710f" translate="yes" xml:space="preserve">
          <source>Testing Mutations</source>
          <target state="translated">Испытательные мутации</target>
        </trans-unit>
        <trans-unit id="9c06adb3a316efc06559622690345fb618cbaf08" translate="yes" xml:space="preserve">
          <source>The &quot;Vuex way&quot; to deal with it is binding the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;'s value and call a method on the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a5f0cdaf9e2b8de2bd8a7b0367c1b182465746" translate="yes" xml:space="preserve">
          <source>The &quot;Vuex way&quot; to deal with it is binding the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;'s value and call an action on the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">&amp;laquo;Способ Vuex&amp;raquo; - это привязка значения &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; и вызов действия для события &lt;code&gt;input&lt;/code&gt; или &lt;code&gt;change&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f04c49ca29bd705949d5268ee1592e8506b75b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;createLogger&lt;/code&gt; function takes a few options:</source>
          <target state="translated">Функция &lt;code&gt;createLogger&lt;/code&gt; принимает несколько параметров:</target>
        </trans-unit>
        <trans-unit id="7f82a0b0f64bd49ff203795584f21da841843a62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; Helper</source>
          <target state="translated">&lt;code&gt;mapGetters&lt;/code&gt; Helper</target>
        </trans-unit>
        <trans-unit id="98e2bb1175bd22373105493a5a1bff66a0f61906" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; helper simply maps store getters to local computed properties:</source>
          <target state="translated">В &lt;code&gt;mapGetters&lt;/code&gt; помощник просто MAPS магазина добытчиков местных вычисленных свойств:</target>
        </trans-unit>
        <trans-unit id="1c64da128ff2a5fa70401dea47d5ef1a1c1ebe06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapState&lt;/code&gt; Helper</source>
          <target state="translated">&lt;code&gt;mapState&lt;/code&gt; Helper</target>
        </trans-unit>
        <trans-unit id="4ed23a0b581ae30af2dc1a6fb0ab9dd6e2a32e58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribe&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call &lt;code&gt;subscribe&lt;/code&gt; from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d697d8557ee6fc852c1e6a6fc7993902dd98d06b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribeAction&lt;/code&gt; method is most commonly used in plugins. &lt;a href=&quot;../guide/plugins&quot;&gt;Details&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b142924d441d0b8c053ee3a0c60776db52d2668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribeAction&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call &lt;code&gt;subscribeAction&lt;/code&gt; from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536ee7b8ae92c527384d1572270e55ace22c2cdd" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;actions&lt;/strong&gt;, the possible ways the state could change in reaction to user inputs from the &lt;strong&gt;view&lt;/strong&gt;.</source>
          <target state="translated">Эти &lt;strong&gt;действия&lt;/strong&gt; , возможные пути состояние может измениться в ответ на входы пользователей с точки &lt;strong&gt;зрения&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="44d7e5a292944a9b8f0f212a5769200231c994ce" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state&lt;/strong&gt;, the source of truth that drives our app;</source>
          <target state="translated">&lt;strong&gt;Государство&lt;/strong&gt; , источник истины , что приводит наше приложение;</target>
        </trans-unit>
        <trans-unit id="c7a29052af8d9c9885446ea356702c7246ba9728" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;view&lt;/strong&gt;, a declarative mapping of the &lt;strong&gt;state&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong&gt;Вид&lt;/strong&gt; , декларативное отображение &lt;strong&gt;состояния&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6efff60c6e384f46bfee8d934ae7afa0e3123d5a" translate="yes" xml:space="preserve">
          <source>The Simplest Store</source>
          <target state="translated">Самый простой магазин</target>
        </trans-unit>
        <trans-unit id="65dc52e6fb3379afbda779041f713e48286fc0aa" translate="yes" xml:space="preserve">
          <source>The data you store in Vuex follows the same rules as the &lt;code&gt;data&lt;/code&gt; in a Vue instance, ie the state object must be plain. &lt;strong&gt;See also:&lt;/strong&gt;&lt;a href=&quot;https://v3.vuejs.org/api/options-data.html#data-2&quot;&gt;Vue#data&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad57ff3f59fd1cdbd6a9c2eb4f3c380f8789e16" translate="yes" xml:space="preserve">
          <source>The data you store in Vuex follows the same rules as the &lt;code&gt;data&lt;/code&gt; in a Vue instance, ie the state object must be plain. &lt;strong&gt;See also:&lt;/strong&gt;&lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue#data&lt;/a&gt;.</source>
          <target state="translated">Данные, которые вы храните в Vuex, подчиняются тем же правилам, что и &lt;code&gt;data&lt;/code&gt; в экземпляре Vue, то есть объект состояния должен быть простым. &lt;strong&gt;См. Также: &lt;/strong&gt;&lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue # data&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b279e03c4074677e1ff56b9ff66e460fb14fa89" translate="yes" xml:space="preserve">
          <source>The first argument can optionally be a namespace string. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Первый аргумент необязательно может быть строкой пространства имен. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bcb1f41246213850c11b36c10d1fea79e5d77bc" translate="yes" xml:space="preserve">
          <source>The first thing to know is that &lt;code&gt;store.dispatch&lt;/code&gt; can handle Promise returned by the triggered action handler and it also returns Promise:</source>
          <target state="translated">Первое, что нужно знать, это то, что &lt;code&gt;store.dispatch&lt;/code&gt; может обрабатывать Promise, возвращаемый обработчиком инициированного действия, а также возвращает Promise:</target>
        </trans-unit>
        <trans-unit id="dcebb29ecfe7deb0999fa8e584b599cd2758454e" translate="yes" xml:space="preserve">
          <source>The following bundles are generated to align with Vue 3 bundles:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d9183239b6fa2ab9370efe48b42def65630f59" translate="yes" xml:space="preserve">
          <source>The getters will be exposed on the &lt;code&gt;store.getters&lt;/code&gt; object, and you access values as properties:</source>
          <target state="translated">Получатели будут представлены в объекте &lt;code&gt;store.getters&lt;/code&gt; , и вы получите доступ к значениям как к свойствам:</target>
        </trans-unit>
        <trans-unit id="188d06901f5c54b49ca05463c758d45fe516d6f3" translate="yes" xml:space="preserve">
          <source>The logger file can also be included directly via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, and will expose the &lt;code&gt;createVuexLogger&lt;/code&gt; function globally.</source>
          <target state="translated">Файл регистратора также может быть включен напрямую через &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; и будет предоставлять &lt;code&gt;createVuexLogger&lt;/code&gt; функцию createVuexLogger .</target>
        </trans-unit>
        <trans-unit id="7f53ab8729ac1f593a9e9d471a3a3f15e2c84ca7" translate="yes" xml:space="preserve">
          <source>The main parts we want to unit test in Vuex are mutations and actions.</source>
          <target state="translated">Основные части,которые мы хотим унифицировать в Vuex-это мутации и действия.</target>
        </trans-unit>
        <trans-unit id="5f7f524307005481f2e4aca2c93d29527f99f1e2" translate="yes" xml:space="preserve">
          <source>The module's state will be exposed as &lt;code&gt;store.state.myModule&lt;/code&gt; and &lt;code&gt;store.state.nested.myModule&lt;/code&gt;.</source>
          <target state="translated">Состояние модуля будет представлено как &lt;code&gt;store.state.myModule&lt;/code&gt; и &lt;code&gt;store.state.nested.myModule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbed472d8720aba4f0e28e8c80ccedb98ce30b99" translate="yes" xml:space="preserve">
          <source>The only way to actually change state in a Vuex store is by committing a mutation. Vuex mutations are very similar to events: each mutation has a string &lt;strong&gt;type&lt;/strong&gt; and a &lt;strong&gt;handler&lt;/strong&gt;. The handler function is where we perform actual state modifications, and it will receive the state as the first argument:</source>
          <target state="translated">Единственный способ изменить состояние в хранилище Vuex - это совершить мутацию. Мутации Vuex очень похожи на события: каждая мутация имеет строковый &lt;strong&gt;тип&lt;/strong&gt; и &lt;strong&gt;обработчик&lt;/strong&gt; . Функция-обработчик - это то место, где мы выполняем фактические изменения состояния, и она получит состояние в качестве первого аргумента:</target>
        </trans-unit>
        <trans-unit id="a6a0b4e8e1721ea8c21549fafae87877e2734097" translate="yes" xml:space="preserve">
          <source>The only way to mutate the state is by committing &lt;strong&gt;mutations&lt;/strong&gt;, which are synchronous transactions.</source>
          <target state="translated">Единственный способ изменить состояние - это совершить &lt;strong&gt;мутации&lt;/strong&gt; , которые являются синхронными транзакциями.</target>
        </trans-unit>
        <trans-unit id="dcbcf8b9a2e6b42000823c0ebf624eaedbb9d653" translate="yes" xml:space="preserve">
          <source>The plugin will be used by default. For production, you will need &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; for webpack or &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; for Browserify to convert the value of &lt;code&gt;process.&lt;wbr/&gt;env.NODE_ENV !== 'production'&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for the final build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e235aa33469d6967a6809446c33b1593819a40" translate="yes" xml:space="preserve">
          <source>The plugin will be used by default. For production, you will need &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; for webpack or &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; for Browserify to convert the value of &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for the final build.</source>
          <target state="translated">Плагин будет использоваться по умолчанию. Для производства вам понадобится &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; для webpack или &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; для Browserify, чтобы преобразовать значение &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; в &lt;code&gt;false&lt;/code&gt; для окончательной сборки.</target>
        </trans-unit>
        <trans-unit id="f01042e3fecd699c90149ef1ee5ae1c35a436639" translate="yes" xml:space="preserve">
          <source>The root state object for the Vuex store. &lt;a href=&quot;../guide/state&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Объект корневого состояния для хранилища Vuex. &lt;a href=&quot;../guide/state&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0280fc5ea89ec8da31027d69c613be9a3c9680dc" translate="yes" xml:space="preserve">
          <source>The root state. Read only.</source>
          <target state="translated">Корневое состояние.Только для чтения.</target>
        </trans-unit>
        <trans-unit id="2c3de3def96fcc05fedc5eb419a984266aa2428b" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">Члены второго аргумента объекта могут быть функцией. &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26cd7f1bcabc21254ac5b9199d279b0ef8555a89" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">Члены второго аргумента объекта могут быть функцией. &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fdcb9da7768a075ddd1fe33f0287a0514029824" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(state: any)&lt;/code&gt;</source>
          <target state="translated">Члены второго аргумента объекта могут быть функцией. &lt;code&gt;function(state: any)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="038cb5b264feb5642de1de9d5ce3def91138027b" translate="yes" xml:space="preserve">
          <source>The single state tree does not conflict with modularity - in later chapters we will discuss how to split your state and mutations into sub modules.</source>
          <target state="translated">Единое дерево состояний не противоречит модульности-в последующих главах мы обсудим,как разделить ваше состояние и мутации на подмодули.</target>
        </trans-unit>
        <trans-unit id="b7e90dfde3eb455667e93149720981dac77b8e85" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;window.Promise&lt;/code&gt; will be available automatically.</source>
          <target state="translated">После этого &lt;code&gt;window.Promise&lt;/code&gt; будет доступно автоматически.</target>
        </trans-unit>
        <trans-unit id="3b8439ab3ba17300e601fb8e0cd832d27c3875b1" translate="yes" xml:space="preserve">
          <source>Then, pass the defined key as the second argument for the &lt;code&gt;app.use&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="66d594b0f1f59f13c4f1fb32be8056b70d5a1027" translate="yes" xml:space="preserve">
          <source>This is a simple representation of the concept of &quot;one-way data flow&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b6185e9c9c13a311c71ea345f0a1bcffe543f2" translate="yes" xml:space="preserve">
          <source>This is actually the exact same problem with &lt;code&gt;data&lt;/code&gt; inside Vue components. So the solution is also the same - use a function for declaring module state (supported in 2.3.0+):</source>
          <target state="translated">На самом деле это та же проблема с &lt;code&gt;data&lt;/code&gt; внутри компонентов Vue. Так что решение тоже такое же - используйте функцию для объявления состояния модуля (поддерживается в 2.3.0+):</target>
        </trans-unit>
        <trans-unit id="32e874b1aade463ecb43dfd8a24212e0197c777b" translate="yes" xml:space="preserve">
          <source>This is an simple representation of the concept of &quot;one-way data flow&quot;:</source>
          <target state="translated">Это простое представление концепции &quot;одностороннего потока данных&quot;:</target>
        </trans-unit>
        <trans-unit id="4784799e1632043ab612568498af4698285efa24" translate="yes" xml:space="preserve">
          <source>This is the basic idea behind Vuex, inspired by &lt;a href=&quot;https://facebook.github.io/flux/docs/overview&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; and &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;. Unlike the other patterns, Vuex is also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ae803eb94d79146b96a33ead3a2a7574ab90f7" translate="yes" xml:space="preserve">
          <source>This is the basic idea behind Vuex, inspired by &lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; and &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;. Unlike the other patterns, Vuex is also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates.</source>
          <target state="translated">Это основная идея Vuex, вдохновленная &lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt; , &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; и &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt; . В отличие от других шаблонов, Vuex также представляет собой реализацию библиотеки, созданную специально для Vue.js, чтобы использовать преимущества его детальной системы реактивности для эффективных обновлений.</target>
        </trans-unit>
        <trans-unit id="01d82844153a1e06b9ed0ac7a7deee86d8194f29" translate="yes" xml:space="preserve">
          <source>This is the docs for Vuex 4, which works with Vue 3. If you're looking for docs for Vuex 3, which works with Vue 2, &lt;a href=&quot;https://vuex.vuejs.org/&quot;&gt;please check it out here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6765e94633afe8dfabe4c196fd106659f3711625" translate="yes" xml:space="preserve">
          <source>This may look silly at first sight: if we want to increment the count, why don't we just call &lt;code&gt;store.commit('increment')&lt;/code&gt; directly? Remember that &lt;strong&gt;mutations have to be synchronous&lt;/strong&gt;. Actions don't. We can perform &lt;strong&gt;asynchronous&lt;/strong&gt; operations inside an action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac43b405b6b649d36442b0894b012509c8256f1" translate="yes" xml:space="preserve">
          <source>This may look silly at first sight: if we want to increment the count, why don't we just call &lt;code&gt;store.commit('increment')&lt;/code&gt; directly? Remember that &lt;strong&gt;mutations have to be synchronous&lt;/strong&gt;? Actions don't. We can perform &lt;strong&gt;asynchronous&lt;/strong&gt; operations inside an action:</source>
          <target state="translated">На первый взгляд это может показаться глупым: если мы хотим &lt;code&gt;store.commit('increment')&lt;/code&gt; счетчик, почему бы нам просто не вызвать store.commit ('increment') напрямую? Помните, что &lt;strong&gt;мутации должны быть синхронными&lt;/strong&gt; ? Действия - нет. Мы можем выполнять &lt;strong&gt;асинхронные&lt;/strong&gt; операции внутри действия:</target>
        </trans-unit>
        <trans-unit id="0e6ac10721f7dad6b0d54424ccab8e328eca8722" translate="yes" xml:space="preserve">
          <source>To access the store within the &lt;code&gt;setup&lt;/code&gt; hook, you can call the &lt;code&gt;useStore&lt;/code&gt; function. This is the equivalent of retrieving &lt;code&gt;this.$store&lt;/code&gt; within a component using the Option API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdbc54a1defb978e6cf0175dfb530c6313ce51a" translate="yes" xml:space="preserve">
          <source>To align with the new Vue 3 initialization process, the installation process of Vuex has changed. To create a new store, users are now encouraged to use the newly introduced createStore function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fad06b8194c84f29399e28d3869f1cd5156e9bf" translate="yes" xml:space="preserve">
          <source>To dispatch actions or commit mutations in the global namespace, pass &lt;code&gt;{ root: true }&lt;/code&gt; as the 3rd argument to &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;.</source>
          <target state="translated">Чтобы отправить действия или зафиксировать мутации в глобальном пространстве имен, передайте &lt;code&gt;{ root: true }&lt;/code&gt; в качестве третьего аргумента для &lt;code&gt;dispatch&lt;/code&gt; и &lt;code&gt;commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c0e5afb99acb54f27fa2c4dc5de58b64ac70359" translate="yes" xml:space="preserve">
          <source>To do so, declare custom typings for Vue's &lt;code&gt;ComponentCustomProperties&lt;/code&gt; by adding a declaration file in your project folder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a17f7fd54b6a036cf2a11b136e992ee23b897e" translate="yes" xml:space="preserve">
          <source>To enable strict mode, simply pass in &lt;code&gt;strict: true&lt;/code&gt; when creating a Vuex store:</source>
          <target state="translated">Чтобы включить строгий режим, просто передайте &lt;code&gt;strict: true&lt;/code&gt; при создании хранилища Vuex:</target>
        </trans-unit>
        <trans-unit id="b4555cdaed64feb01f23395f68a87fbe45b67dce" translate="yes" xml:space="preserve">
          <source>To handle asynchronous operations, let's introduce &lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt;.</source>
          <target state="translated">Чтобы обрабатывать асинхронные операции, давайте представим &lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4195b1d72692d3750d2a410e7d9981a761f2d655" translate="yes" xml:space="preserve">
          <source>To help with that, Vuex allows us to divide our store into &lt;strong&gt;modules&lt;/strong&gt;. Each module can contain its own state, mutations, actions, getters, and even nested modules - it's fractal all the way down:</source>
          <target state="translated">Чтобы помочь с этим, Vuex позволяет нам разделить наш магазин на &lt;strong&gt;модули&lt;/strong&gt; . Каждый модуль может содержать свое собственное состояние, мутации, действия, геттеры и даже вложенные модули - он фрактален до конца:</target>
        </trans-unit>
        <trans-unit id="69ba8fbdd0f126138d738eba7ba3e25ab721058c" translate="yes" xml:space="preserve">
          <source>To install Vuex to a Vue instance, pass the &lt;code&gt;store&lt;/code&gt; instead of Vuex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c12dedfc5d2ae19c1382030d2827746c9b159b" translate="yes" xml:space="preserve">
          <source>To stop subscribing, call the returned unsubscribe function.</source>
          <target state="translated">Чтобы прекратить подписку,позвоните в функцию возврата подписки.</target>
        </trans-unit>
        <trans-unit id="b38919feb133ed92197ba6b4d1ca2851ce856830" translate="yes" xml:space="preserve">
          <source>To stop watching, call the returned unwatch function.</source>
          <target state="translated">Чтобы остановить просмотр,вызовите функцию возврата разворота.</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Попробуйте этот урок на Scrimba</target>
        </trans-unit>
        <trans-unit id="812241cb367543e758bb2d6b8d6eb7df0bca334e" translate="yes" xml:space="preserve">
          <source>Turn the devtools on or off for a particular Vuex instance. For instance, passing &lt;code&gt;false&lt;/code&gt; tells the Vuex store to not subscribe to devtools plugin. Useful when you have multiple stores on a single page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9df75c2e4aa99920a38d6895f257e82c103c0e" translate="yes" xml:space="preserve">
          <source>Turn the devtools on or off for a particular vuex instance. For instance passing false tells the Vuex store to not subscribe to devtools plugin. Useful for if you have multiple stores on a single page.</source>
          <target state="translated">Включите или выключите Devtools для определенного экземпляра vuex.Например,передача false говорит магазину Vuex не подписываться на плагин devtools.Полезно,если у вас несколько магазинов на одной странице.</target>
        </trans-unit>
        <trans-unit id="6d53cb5abedd0ebe3cd4c7395842755f71c30dbc" translate="yes" xml:space="preserve">
          <source>Two-way Computed Property</source>
          <target state="translated">Двухстороннее вычисление собственности</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdea23efbec9c8bf6ee85ec63b78ab2e12f528cd" translate="yes" xml:space="preserve">
          <source>TypeScript support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d095b72c23ae6ff8f64d6304776100771251da" translate="yes" xml:space="preserve">
          <source>TypeScript users can use an injection key to retrieve a typed store. In order for this to work, you must define the injection key and pass it along with the store when installing the store instance to the Vue app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a035bd5d610b0e0f578980487f3e136c53e9a2df" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;$store&lt;/code&gt; Property in Vue Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f301538ed68fe96d60ca381f974527cc0892825" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;useStore&lt;/code&gt; Composition Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88625f6fb2e47a984fc469839b246cc1bbd39a3d" translate="yes" xml:space="preserve">
          <source>Under the hood, Vuex installs the store to the Vue app using Vue's &lt;a href=&quot;https://v3.vuejs.org/api/composition-api.html#provide-inject&quot;&gt;Provide/Inject&lt;/a&gt; feature which is why the injection key is an important factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a34f2bdebff21a52c61f411732c8009ceffd74" translate="yes" xml:space="preserve">
          <source>Unregister a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Отмените регистрацию динамического модуля. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;подробности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e189823fb0c39c232d21cb4f56d5d5263ffa4a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt;, or</source>
          <target state="translated">Используйте &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt; или</target>
        </trans-unit>
        <trans-unit id="b49c80c66c6311a904333a467355c7e6bf1e59e1" translate="yes" xml:space="preserve">
          <source>Using Constants for Mutation Types</source>
          <target state="translated">Использование констант для типов мутации</target>
        </trans-unit>
        <trans-unit id="2a3ef6422ba574dc83a7da5c0294678dde94d811" translate="yes" xml:space="preserve">
          <source>Using Vuex doesn't mean you should put &lt;strong&gt;all&lt;/strong&gt; the state in Vuex. Although putting more state into Vuex makes your state mutations more explicit and debuggable, sometimes it could also make the code more verbose and indirect. If a piece of state strictly belongs to a single component, it could be just fine leaving it as local state. You should weigh the trade-offs and make decisions that fit the development needs of your app.</source>
          <target state="translated">Использование Vuex не означает, что вы должны поместить &lt;strong&gt;все&lt;/strong&gt; состояние в Vuex. Хотя добавление большего количества состояний в Vuex делает ваши мутации состояния более явными и отлаживаемыми, иногда это также может сделать код более подробным и косвенным. Если часть состояния строго принадлежит одному компоненту, можно оставить его как локальное состояние. Вы должны взвесить компромиссы и принять решения, которые соответствуют потребностям разработки вашего приложения.</target>
        </trans-unit>
        <trans-unit id="0c1ee6f0263ee019fc5e3fcd7fa266eb225b6cc7" translate="yes" xml:space="preserve">
          <source>Using store state in a component simply involves returning the state within a computed property, because the store state is reactive. Triggering changes simply means committing mutations in component methods.</source>
          <target state="translated">Использование состояния хранилища в компоненте просто подразумевает возврат состояния в вычисленном свойстве,поскольку состояние хранилища является реактивным.Включение изменений просто означает фиксацию мутаций в методах компонента.</target>
        </trans-unit>
        <trans-unit id="de0b33121be26507e3433bd94203e17aa9b5f222" translate="yes" xml:space="preserve">
          <source>Vuex</source>
          <target state="translated">Vuex</target>
        </trans-unit>
        <trans-unit id="03cbaaf12cf9de839a6ef24add75f70804c3bd36" translate="yes" xml:space="preserve">
          <source>Vuex &quot;injects&quot; the store into all child components from the root component through Vue's plugin system, and will be available on them as &lt;code&gt;this.$store&lt;/code&gt;. Let's update our &lt;code&gt;Counter&lt;/code&gt; implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8cd4f61d900f72acb2af9c3655c9d0d3121feb" translate="yes" xml:space="preserve">
          <source>Vuex 4 introduces a new API to interact with the store in Composition API. You can use the &lt;code&gt;useStore&lt;/code&gt; composition function to retrieve the store within the component &lt;code&gt;setup&lt;/code&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa60c01f6f8d53bbb571c7cc4c0e43d605867024" translate="yes" xml:space="preserve">
          <source>Vuex 4 removes its global typings for &lt;code&gt;this.$store&lt;/code&gt; within a Vue component to solve &lt;a href=&quot;https://github.com/vuejs/vuex/issues/994&quot;&gt;issue #994&lt;/a&gt;. When used with TypeScript, you must declare your own module augmentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5043b9867f4c1f3c2a241e7e15f0309bf2b67e5" translate="yes" xml:space="preserve">
          <source>Vuex allows us to define &quot;getters&quot; in the store. You can think of them as computed properties for stores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d6f301a857638a6008e626f1c08e4b841279dd" translate="yes" xml:space="preserve">
          <source>Vuex allows us to define &quot;getters&quot; in the store. You can think of them as computed properties for stores. Like computed properties, a getter's result is cached based on its dependencies, and will only re-evaluate when some of its dependencies have changed.</source>
          <target state="translated">Vuex позволяет определить &quot;геттеры&quot; в магазине.Вы можете думать о них как о вычисляемых свойствах для магазинов.Как и вычисленные свойства,результат геттера кэшируется на основе его зависимостей,и будет пересматриваться только тогда,когда некоторые из его зависимостей изменились.</target>
        </trans-unit>
        <trans-unit id="0e2cd15820316b9d525f31489d6930bdf8394d91" translate="yes" xml:space="preserve">
          <source>Vuex comes with a logger plugin for common debugging usage:</source>
          <target state="translated">Vuex поставляется с плагином логгера для обычного использования при отладке:</target>
        </trans-unit>
        <trans-unit id="7a50b771f48dfa484820de4fbf6edb422dbc1306" translate="yes" xml:space="preserve">
          <source>Vuex doesn't provide typings for &lt;code&gt;this.$store&lt;/code&gt; property out of the box. When used with TypeScript, you must declare your own module augmentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c7149a09097949a0cfcc2fbe94537dc69fb1ce" translate="yes" xml:space="preserve">
          <source>Vuex doesn't really restrict how you structure your code. Rather, it enforces a set of high-level principles:</source>
          <target state="translated">Vuex на самом деле не ограничивает то,как вы структурируете свой код.Скорее,он навязывает набор принципов высокого уровня:</target>
        </trans-unit>
        <trans-unit id="d17df34d062fc479eb107a94c88abf9ec059beae" translate="yes" xml:space="preserve">
          <source>Vuex helps us deal with shared state management with the cost of more concepts and boilerplate. It's a trade-off between short term and long term productivity.</source>
          <target state="translated">Vuex помогает нам справляться с общим государственным управлением с затратами на большее количество концепций и шаблонов.Это компромисс между краткосрочной и долгосрочной производительностью.</target>
        </trans-unit>
        <trans-unit id="685c1dd978a181fa797afacac4d6f9601b7d5fda" translate="yes" xml:space="preserve">
          <source>Vuex is a &lt;strong&gt;state management pattern + library&lt;/strong&gt; for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4865c12b8c32edd994472010e09de64c7196db52" translate="yes" xml:space="preserve">
          <source>Vuex is a &lt;strong&gt;state management pattern + library&lt;/strong&gt; for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. It also integrates with Vue's official &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;devtools extension&lt;/a&gt; to provide advanced features such as zero-config time-travel debugging and state snapshot export / import.</source>
          <target state="translated">Vuex - это &lt;strong&gt;шаблон + библиотека управления состоянием&lt;/strong&gt; для приложений Vue.js. Он служит централизованным хранилищем для всех компонентов в приложении с правилами, гарантирующими, что состояние может изменяться только предсказуемым образом. Он также интегрируется с официальным &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;расширением&lt;/a&gt; Vue для инструментов разработки, чтобы обеспечить расширенные функции, такие как отладка с нулевой конфигурацией во времени и экспорт / импорт снимков состояния.</target>
        </trans-unit>
        <trans-unit id="0ab5b1ceae85cef3c7070700973eed24ddceb3f1" translate="yes" xml:space="preserve">
          <source>Vuex provides a mechanism to &quot;inject&quot; the store into all child components from the root component with the &lt;code&gt;store&lt;/code&gt; option (enabled by &lt;code&gt;Vue.use(Vuex)&lt;/code&gt;):</source>
          <target state="translated">Vuex предоставляет механизм для &amp;laquo;встраивания&amp;raquo; хранилища во все дочерние компоненты из корневого компонента с опцией &lt;code&gt;store&lt;/code&gt; (включенной &lt;code&gt;Vue.use(Vuex)&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="13c8b9558d25a74364d073902412ab0e29b9c7d8" translate="yes" xml:space="preserve">
          <source>Vuex provides its typings so you can use TypeScript to write a store definition. You don't need any special TypeScript configuration for Vuex. Please follow &lt;a href=&quot;https://v3.vuejs.org/guide/typescript-support.html&quot;&gt;Vue's basic TypeScript setup&lt;/a&gt; to configure your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e6083d0ea2da692697abc408390a78b3fbb6a1" translate="yes" xml:space="preserve">
          <source>Vuex requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promise&lt;/a&gt;. If your supporting browsers do not implement Promise (e.g. IE), you can use a polyfill library, such as &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;es6-promise&lt;/a&gt;.</source>
          <target state="translated">Vuex требует &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promise&lt;/a&gt; . Если ваши поддерживающие браузеры не реализуют Promise (например, IE), вы можете использовать библиотеку polyfill, такую ​​как &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;es6-prom&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7c44a44a893f704da779f2a6753cb99fdabc86c" translate="yes" xml:space="preserve">
          <source>Vuex stores accept the &lt;code&gt;plugins&lt;/code&gt; option that exposes hooks for each mutation. A Vuex plugin is simply a function that receives the store as the only argument:</source>
          <target state="translated">Хранилища Vuex принимают опцию &lt;code&gt;plugins&lt;/code&gt; которая предоставляет хуки для каждой мутации. Плагин Vuex - это просто функция, которая получает хранилище в качестве единственного аргумента:</target>
        </trans-unit>
        <trans-unit id="f9de6b1a8f9893aec2c24f2eb638d08f8c27963a" translate="yes" xml:space="preserve">
          <source>Vuex stores are reactive. When Vue components retrieve state from it, they will reactively and efficiently update if the store's state changes.</source>
          <target state="translated">Магазины Vuex реагируют.Когда компоненты Vue извлекают из него состояние,они будут быстро и эффективно обновляться,если состояние магазина изменится.</target>
        </trans-unit>
        <trans-unit id="d1005b8dfed9f5da523d44fa0408fb96e863b48e" translate="yes" xml:space="preserve">
          <source>Vuex supports hot-reloading mutations, modules, actions and getters during development, using webpack's &lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;Hot Module Replacement API&lt;/a&gt;. You can also use it in Browserify with the &lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;browserify-hmr&lt;/a&gt; plugin.</source>
          <target state="translated">Vuex поддерживает горячую перезагрузку мутаций, модулей, действий и геттеров во время разработки, используя &lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;API замены горячих модулей&lt;/a&gt; webpack . Вы также можете использовать его в Browserify с &lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;помощью&lt;/a&gt; плагина browserify-hmr .</target>
        </trans-unit>
        <trans-unit id="1c91ec10df2bcecd2b18c0eb4c34783559fcaf6b" translate="yes" xml:space="preserve">
          <source>Vuex uses a &lt;strong&gt;single state tree&lt;/strong&gt; - that is, this single object contains all your application level state and serves as the &quot;single source of truth&quot;. This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.</source>
          <target state="translated">Vuex использует &lt;strong&gt;единое дерево состояний&lt;/strong&gt; - то есть этот единый объект содержит все состояние на уровне вашего приложения и служит &amp;laquo;единым источником истины&amp;raquo;. Это также означает, что обычно у вас будет только одно хранилище для каждого приложения. Единое дерево состояний упрощает поиск определенной части состояния и позволяет нам легко делать снимки текущего состояния приложения для целей отладки.</target>
        </trans-unit>
        <trans-unit id="38d7ee9ea99de16acff8c72ca2947db3c8964cfb" translate="yes" xml:space="preserve">
          <source>Vuex uses a &lt;strong&gt;single state tree&lt;/strong&gt; - that is, this single object contains all your application level state and serves as the &quot;single source of truth.&quot; This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daddb132dbb693223d1a8285c450a768b5e90526" translate="yes" xml:space="preserve">
          <source>Vuex.Store</source>
          <target state="translated">Vuex.Store</target>
        </trans-unit>
        <trans-unit id="e27d6d35e937e025eb96c09b1248e5c2676afd99" translate="yes" xml:space="preserve">
          <source>Vuex.Store Constructor Options</source>
          <target state="translated">Vuex.Store Constructor Options</target>
        </trans-unit>
        <trans-unit id="a12ddea81e37a47b9cf92721a2c3b3dce724518b" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Methods</source>
          <target state="translated">Vuex.Store Instance методы</target>
        </trans-unit>
        <trans-unit id="bf2e5bd997aabdf6407575808a7810ae806bc168" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Properties</source>
          <target state="translated">Vuex.Store Instance Properties</target>
        </trans-unit>
        <trans-unit id="f9f831a5e0694e0c14522dd98fa88137c445d453" translate="yes" xml:space="preserve">
          <source>Vuex.Store.commit()</source>
          <target state="translated">Vuex.Store.commit()</target>
        </trans-unit>
        <trans-unit id="6525945e6ceed925f1b32505317c836dca657a7b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.dispatch()</source>
          <target state="translated">Vuex.Store.dispatch()</target>
        </trans-unit>
        <trans-unit id="875eca0d2c435721934d6e21026feaf2c458121e" translate="yes" xml:space="preserve">
          <source>Vuex.Store.getters</source>
          <target state="translated">Vuex.Store.getters</target>
        </trans-unit>
        <trans-unit id="36f6be1d986b4f405099f5f30b602d52e9e30867" translate="yes" xml:space="preserve">
          <source>Vuex.Store.hotUpdate()</source>
          <target state="translated">Vuex.Store.hotUpdate()</target>
        </trans-unit>
        <trans-unit id="da4335e82262f6f8d6790534c7ad0926cc4745e2" translate="yes" xml:space="preserve">
          <source>Vuex.Store.registerModule()</source>
          <target state="translated">Vuex.Store.registerModule()</target>
        </trans-unit>
        <trans-unit id="94ac4b985f66595cf0a6092e1a82c5ad38bbb16b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.replaceState()</source>
          <target state="translated">Vuex.Store.replaceState()</target>
        </trans-unit>
        <trans-unit id="4f304b4fdb3bf5548021e12438f19b8a3c837429" translate="yes" xml:space="preserve">
          <source>Vuex.Store.state</source>
          <target state="translated">Vuex.Store.state</target>
        </trans-unit>
        <trans-unit id="646d93a6768d3e6602cdefd17248482210916c01" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribe()</source>
          <target state="translated">Vuex.Store.subscribe()</target>
        </trans-unit>
        <trans-unit id="f3e660b4b4bcbf28c208b2cb1849c08db1e4a864" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribeAction()</source>
          <target state="translated">Vuex.Store.subscribeAction()</target>
        </trans-unit>
        <trans-unit id="ae9d201aeec49d5494691627724de63760974852" translate="yes" xml:space="preserve">
          <source>Vuex.Store.unregisterModule()</source>
          <target state="translated">Vuex.Store.unregisterModule()</target>
        </trans-unit>
        <trans-unit id="a78a21d356c3413617b93e60de03e3c4c85613bf" translate="yes" xml:space="preserve">
          <source>Vuex.Store.watch()</source>
          <target state="translated">Vuex.Store.watch()</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="972f097fe8de7d9024e0cac7324df8bc2bd5d8a7" translate="yes" xml:space="preserve">
          <source>We can also pass a string array to &lt;code&gt;mapState&lt;/code&gt; when the name of a mapped computed property is the same as a state sub tree name.</source>
          <target state="translated">Мы также можем передать массив строк в &lt;code&gt;mapState&lt;/code&gt; , если имя сопоставленного вычисляемого свойства совпадает с именем поддерева состояния.</target>
        </trans-unit>
        <trans-unit id="62a0d6990ce81e2c8fb572ac1e1a0f61bc100c86" translate="yes" xml:space="preserve">
          <source>We can now easily make use of it inside any component:</source>
          <target state="translated">Теперь мы можем легко использовать его внутри любого компонента:</target>
        </trans-unit>
        <trans-unit id="8745c67924f31017daab7ed40bb8f21170388cd9" translate="yes" xml:space="preserve">
          <source>We will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;you should&lt;/a&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e679c86924ed36ac40c73653131acb30c335823" translate="yes" xml:space="preserve">
          <source>What is Vuex?</source>
          <target state="translated">Что такое Вюэкс?</target>
        </trans-unit>
        <trans-unit id="4f7cb23fbc792a907900b6c227a08a9ce44bbb08" translate="yes" xml:space="preserve">
          <source>What is a &quot;State Management Pattern&quot;?</source>
          <target state="translated">Что такое &quot;модель государственного управления&quot;?</target>
        </trans-unit>
        <trans-unit id="bfb57f97eebc790fb0f996df58cf05c904d765fe" translate="yes" xml:space="preserve">
          <source>When Should I Use It?</source>
          <target state="translated">Когда я должен его использовать?</target>
        </trans-unit>
        <trans-unit id="7049f8d400f975057b510f35754e4b4a55b8a447" translate="yes" xml:space="preserve">
          <source>When a component needs to make use of multiple store state properties or getters, declaring all these computed properties can get repetitive and verbose. To deal with this we can make use of the &lt;code&gt;mapState&lt;/code&gt; helper which generates computed getter functions for us, saving us some keystrokes:</source>
          <target state="translated">Когда компоненту необходимо использовать несколько свойств или методов получения состояния хранилища, объявление всех этих вычисленных свойств может стать повторяющимся и подробным. Чтобы справиться с этим, мы можем использовать помощник &lt;code&gt;mapState&lt;/code&gt; , который генерирует для нас вычисленные функции получения, экономя нам несколько нажатий клавиш:</target>
        </trans-unit>
        <trans-unit id="b0e91b1a6d070c61fac000b9d3b95342ccf2db46" translate="yes" xml:space="preserve">
          <source>When accessing mutations and actions, you can simply provide the &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt; function inside the &lt;code&gt;setup&lt;/code&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17e29a6e47a7d53eb7540fe5f43fd3c7ec25ef4" translate="yes" xml:space="preserve">
          <source>When adding new properties to an Object, you should either:</source>
          <target state="translated">При добавлении новых свойств к Объекту,вы тоже должны:</target>
        </trans-unit>
        <trans-unit id="efff342070587a8120ff0a0f2a1a6c593581e9da" translate="yes" xml:space="preserve">
          <source>When binding a namespaced module to components with the &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; helpers, it can get a bit verbose:</source>
          <target state="translated">При привязке модуля с пространством имен к компонентам с помощью &lt;code&gt;mapState&lt;/code&gt; , &lt;code&gt;mapGetters&lt;/code&gt; , &lt;code&gt;mapActions&lt;/code&gt; и &lt;code&gt;mapMutations&lt;/code&gt; он может быть немного подробным:</target>
        </trans-unit>
        <trans-unit id="99195dc5710842be6bed30d96a1def16fb32d71c" translate="yes" xml:space="preserve">
          <source>When used with a module system, you must explicitly install Vuex via &lt;code&gt;Vue.use()&lt;/code&gt;:</source>
          <target state="translated">При использовании с модульной системой вы должны явно установить Vuex через &lt;code&gt;Vue.use()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="77c1ff3694c93e3a5898ebf5b137f7620c5e12dd" translate="yes" xml:space="preserve">
          <source>When using Vuex in strict mode, it could be a bit tricky to use &lt;code&gt;v-model&lt;/code&gt; on a piece of state that belongs to Vuex:</source>
          <target state="translated">При использовании Vuex в строгом режиме может быть немного сложно использовать &lt;code&gt;v-model&lt;/code&gt; для части состояния, принадлежащей Vuex:</target>
        </trans-unit>
        <trans-unit id="fd5fb9660a82033a1f5e0bdd5e988d5fee11ea79" translate="yes" xml:space="preserve">
          <source>When using object-style commit, the entire object will be passed as the payload to mutation handlers, so the handler remains the same:</source>
          <target state="translated">При использовании коммита в стиле объекта весь объект будет передан в качестве полезной нагрузки в обработчики мутаций,поэтому обработчик остается тем же самым:</target>
        </trans-unit>
        <trans-unit id="4c9c007e95ce7e90fdef65d514914f8a48ea50fc" translate="yes" xml:space="preserve">
          <source>When you set &lt;code&gt;preserveState: true&lt;/code&gt;, the module is registered, actions, mutations and getters are added to the store, but the state is not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b97d35575f008d89a5abcf758506366a1df6c9" translate="yes" xml:space="preserve">
          <source>When you set &lt;code&gt;preserveState: true&lt;/code&gt;, the module is registered, actions, mutations and getters are added to the store, but the state not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.</source>
          <target state="translated">Когда вы устанавливаете &lt;code&gt;preserveState: true&lt;/code&gt; , модуль регистрируется, в хранилище добавляются действия, мутации и геттеры, а состояние - нет. Предполагается, что состояние вашего хранилища уже содержит состояние для этого модуля, и вы не хотите его перезаписывать.</target>
        </trans-unit>
        <trans-unit id="b67645573519bd6745c7692e115ca001bffedc35" translate="yes" xml:space="preserve">
          <source>When you're writing your Vue component in Composition API, you will most likely want &lt;code&gt;useStore&lt;/code&gt; to return the typed store. For &lt;code&gt;useStore&lt;/code&gt; to correctly return the typed store, you must:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0672c57fbbf8e8ecf0e7b63699f5a7c92edcd4d" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;store.state.count&lt;/code&gt; changes, it will cause the computed property to re-evaluate, and trigger associated DOM updates.</source>
          <target state="translated">Всякий раз, когда &lt;code&gt;store.state.count&lt;/code&gt; изменяется, это вызывает повторную оценку вычисляемого свойства и запускает связанные обновления DOM.</target>
        </trans-unit>
        <trans-unit id="a085ea0f1aa78bea832392da9c502369be0887a2" translate="yes" xml:space="preserve">
          <source>Whether to use constants is largely a preference - it can be helpful in large projects with many developers, but it's totally optional if you don't like them.</source>
          <target state="translated">Использовать ли константы во многом предпочтительнее-это может быть полезно в больших проектах с большим количеством разработчиков,но это абсолютно необязательно,если они вам не нравятся.</target>
        </trans-unit>
        <trans-unit id="4c08b16ee1dc63cbfb31d2273bccaca063856191" translate="yes" xml:space="preserve">
          <source>Whilst this is not technically a breaking change, you may still use the &lt;code&gt;new Store(...)&lt;/code&gt; syntax, we recommend this approach to align with Vue 3 and Vue Router Next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de67a4d313139fb2f1d0ad9d2c13d0921ddb131" translate="yes" xml:space="preserve">
          <source>Yarn</source>
          <target state="translated">Yarn</target>
        </trans-unit>
        <trans-unit id="63134a6d55a8d86ebefa1d7e28dd4e4938a617f5" translate="yes" xml:space="preserve">
          <source>You can also pass arguments to getters by returning a function. This is particularly useful when you want to query an array in the store:</source>
          <target state="translated">Вы также можете передавать аргументы геттерам,возвращая функцию.Это особенно полезно,когда необходимо запросить массив в хранилище:</target>
        </trans-unit>
        <trans-unit id="23de97b968754adb5c8071394c94800b27c8ebc7" translate="yes" xml:space="preserve">
          <source>You can also remove a dynamically registered module with &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt;. Note you cannot remove static modules (declared at store creation) with this method.</source>
          <target state="translated">Вы также можете удалить динамически зарегистрированный модуль с помощью &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt; . Обратите внимание, что вы не можете удалить статические модули (объявленные при создании магазина) с помощью этого метода.</target>
        </trans-unit>
        <trans-unit id="d29c54157aed563d47280cf164e51dba16933038" translate="yes" xml:space="preserve">
          <source>You can commit mutations in components with &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapMutations&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.commit&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">Вы можете зафиксировать мутации в компонентах с помощью &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt; или использовать помощник &lt;code&gt;mapMutations&lt;/code&gt; , который сопоставляет методы компонентов с &lt;code&gt;store.commit&lt;/code&gt; (требуется внедрение корневого &lt;code&gt;store&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="1215721038a305c2ecee17f52181bc37f1909ea8" translate="yes" xml:space="preserve">
          <source>You can dispatch actions in components with &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapActions&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.dispatch&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">Вы можете отправлять действия в компонентах с помощью &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt; или использовать помощник &lt;code&gt;mapActions&lt;/code&gt; , который сопоставляет методы компонентов с &lt;code&gt;store.dispatch&lt;/code&gt; (требуется внедрение корневого &lt;code&gt;store&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="8881848045fd86241cc9c9d7d92edbe765adb62d" translate="yes" xml:space="preserve">
          <source>You can include it via CDN:</source>
          <target state="translated">Вы можете включить его через CDN:</target>
        </trans-unit>
        <trans-unit id="5ad1656a1ce03c34ec4d07184a92309aa7cbeafd" translate="yes" xml:space="preserve">
          <source>You can learn more in the &lt;a href=&quot;composition-api&quot;&gt;Composition API&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc0fa46dba60197b55bd958d17dd6ccb01559a1" translate="yes" xml:space="preserve">
          <source>You can learn more in the &lt;a href=&quot;typescript-support&quot;&gt;TypeScript Support&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c0fe7b987a059291687c75ef24f147484cb473" translate="yes" xml:space="preserve">
          <source>You can pass an additional argument to &lt;code&gt;store.commit&lt;/code&gt;, which is called the &lt;strong&gt;payload&lt;/strong&gt; for the mutation:</source>
          <target state="translated">Вы можете передать &lt;code&gt;store.commit&lt;/code&gt; дополнительный аргумент , который называется &lt;strong&gt;полезной нагрузкой&lt;/strong&gt; для мутации:</target>
        </trans-unit>
        <trans-unit id="3669fc0f4547fc417e6184797578f0ae3a315436" translate="yes" xml:space="preserve">
          <source>You can register a module &lt;strong&gt;after&lt;/strong&gt; the store has been created with the &lt;code&gt;store.registerModule&lt;/code&gt; method:</source>
          <target state="translated">Вы можете зарегистрировать модуль &lt;strong&gt;после&lt;/strong&gt; создания хранилища с &lt;code&gt;store.registerModule&lt;/code&gt; метода store.registerModule :</target>
        </trans-unit>
        <trans-unit id="535a2512801117d140454c6e5cb378ba940f4b23" translate="yes" xml:space="preserve">
          <source>You cannot directly call a mutation handler. Think of it more like event registration: &quot;When a mutation with type &lt;code&gt;increment&lt;/code&gt; is triggered, call this handler.&quot; To invoke a mutation handler, you need to call &lt;code&gt;store.commit&lt;/code&gt; with its type:</source>
          <target state="translated">Вы не можете напрямую вызвать обработчик мутации. Думайте об этом больше как о регистрации события: &amp;laquo;Когда запускается мутация с &lt;code&gt;increment&lt;/code&gt; типа , вызовите этот обработчик&amp;raquo;. Чтобы вызвать обработчик мутации, вам нужно вызвать &lt;code&gt;store.commit&lt;/code&gt; с его типом:</target>
        </trans-unit>
        <trans-unit id="daa96a4f6ba2541961bc6b0ba61ad44c19c2cd8d" translate="yes" xml:space="preserve">
          <source>You cannot directly mutate the store's state. The only way to change a store's state is by explicitly &lt;strong&gt;committing mutations&lt;/strong&gt;. This ensures every state change leaves a track-able record, and enables tooling that helps us better understand our applications.</source>
          <target state="translated">Вы не можете напрямую изменять состояние магазина. Единственный способ изменить состояние хранилища - это явно &lt;strong&gt;зафиксировать мутации&lt;/strong&gt; . Это гарантирует, что каждое изменение состояния оставляет отслеживаемую запись, и позволяет использовать инструменты, которые помогают нам лучше понимать наши приложения.</target>
        </trans-unit>
        <trans-unit id="360fc60f946b0e1fb46441c21ec094cefc382a47" translate="yes" xml:space="preserve">
          <source>You don't need to do this when using global script tags.</source>
          <target state="translated">Вам не нужно делать этого при использовании глобальных тегов сценариев.</target>
        </trans-unit>
        <trans-unit id="c70f3011e5bb2100175201538c23d3b8d06c1f46" translate="yes" xml:space="preserve">
          <source>You may care about unpredictable namespacing for your modules when you create a &lt;a href=&quot;plugins&quot;&gt;plugin&lt;/a&gt; that provides the modules and let users add them to a Vuex store. Your modules will be also namespaced if the plugin users add your modules under a namespaced module. To adapt this situation, you may need to receive a namespace value via your plugin option:</source>
          <target state="translated">Вы можете заботиться о непредсказуемом пространстве имен для ваших модулей, когда создаете &lt;a href=&quot;plugins&quot;&gt;плагин,&lt;/a&gt; который предоставляет модули и позволяет пользователям добавлять их в магазин Vuex. Ваши модули также будут иметь пространство имен, если пользователи плагина добавят ваши модули в модуль с пространством имен. Чтобы адаптировать эту ситуацию, вам может потребоваться получить значение пространства имен через параметр вашего плагина:</target>
        </trans-unit>
        <trans-unit id="3f63bbd45ca0e396d20716f1a9faff811b1810cb" translate="yes" xml:space="preserve">
          <source>You will have to clone directly from GitHub and build &lt;code&gt;vuex&lt;/code&gt; yourself if you want to use the latest dev build.</source>
          <target state="translated">Вам нужно будет клонировать прямо из GitHub и собрать &lt;code&gt;vuex&lt;/code&gt; самостоятельно, если вы хотите использовать последнюю сборку разработчика.</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="c0b7cc8520ca125ff38dd308c300837ea02ab867" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers</source>
          <target state="translated">createNamespacedHelpers</target>
        </trans-unit>
        <trans-unit id="59211592ba313c330272b3b02e6654aaf2030698" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers()</source>
          <target state="translated">createNamespacedHelpers()</target>
        </trans-unit>
        <trans-unit id="d2d86ff5a0cd4d9837f7acff55b3a7cd9d364ab3" translate="yes" xml:space="preserve">
          <source>createStore</source>
          <target state="translated">createStore</target>
        </trans-unit>
        <trans-unit id="b853518a7253a67751993712323af2afe8d26a75" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">по умолчанию: &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="05b145cfb6fbc24d08a8e01155c0aa2bf8460c87" translate="yes" xml:space="preserve">
          <source>dispatch</source>
          <target state="translated">dispatch</target>
        </trans-unit>
        <trans-unit id="6ec8d967f553282c8a0b78d6540dfc8d420a3ef0" translate="yes" xml:space="preserve">
          <source>getters</source>
          <target state="translated">getters</target>
        </trans-unit>
        <trans-unit id="7035b5cff18dc8c3847faa85107fdff08894d5e1" translate="yes" xml:space="preserve">
          <source>hasModule</source>
          <target state="translated">hasModule</target>
        </trans-unit>
        <trans-unit id="191d360d6e9259ceda69018c10b131806a257339" translate="yes" xml:space="preserve">
          <source>hotUpdate</source>
          <target state="translated">hotUpdate</target>
        </trans-unit>
        <trans-unit id="7f3c4da8402c9feb0a967e99e24a689f07ad9538" translate="yes" xml:space="preserve">
          <source>mapActions</source>
          <target state="translated">mapActions</target>
        </trans-unit>
        <trans-unit id="1c9faade8425f6bc337e39a55a39ae4126bc894c" translate="yes" xml:space="preserve">
          <source>mapActions()</source>
          <target state="translated">mapActions()</target>
        </trans-unit>
        <trans-unit id="c5092a452ac716aa7395be56d5a3e111411ab603" translate="yes" xml:space="preserve">
          <source>mapGetters</source>
          <target state="translated">mapGetters</target>
        </trans-unit>
        <trans-unit id="4bed8eb971d49de14d01396cd2061d4908c28770" translate="yes" xml:space="preserve">
          <source>mapGetters()</source>
          <target state="translated">mapGetters()</target>
        </trans-unit>
        <trans-unit id="a837f5acfc97cfd8166f5f0c59fcbb7dfc666465" translate="yes" xml:space="preserve">
          <source>mapMutations</source>
          <target state="translated">mapMutations</target>
        </trans-unit>
        <trans-unit id="80e0f1f5c3583f0fd0d207c7f3df5c3aba3bd7ec" translate="yes" xml:space="preserve">
          <source>mapMutations()</source>
          <target state="translated">mapMutations()</target>
        </trans-unit>
        <trans-unit id="e5461d7d29007a5a5aa44df5c418d146a0695054" translate="yes" xml:space="preserve">
          <source>mapState</source>
          <target state="translated">mapState</target>
        </trans-unit>
        <trans-unit id="2d1ce243674082e4c821c3525927a44e71d4d016" translate="yes" xml:space="preserve">
          <source>mapState()</source>
          <target state="translated">mapState()</target>
        </trans-unit>
        <trans-unit id="4580485d482a9037af94f68af98adf23819cbdf4" translate="yes" xml:space="preserve">
          <source>modules</source>
          <target state="translated">modules</target>
        </trans-unit>
        <trans-unit id="3db5c1d36e4a153d7b5cda1e2d65b175222ccf09" translate="yes" xml:space="preserve">
          <source>mutations</source>
          <target state="translated">mutations</target>
        </trans-unit>
        <trans-unit id="440c3339cb056522cd1edf391e616ceb636e1a08" translate="yes" xml:space="preserve">
          <source>plugins</source>
          <target state="translated">plugins</target>
        </trans-unit>
        <trans-unit id="3f170c2be21627360e728ba4b0f15e0c20cc0126" translate="yes" xml:space="preserve">
          <source>registerModule</source>
          <target state="translated">registerModule</target>
        </trans-unit>
        <trans-unit id="eb49199248380da5116beeb5a5bdf9606ac21f82" translate="yes" xml:space="preserve">
          <source>replaceState</source>
          <target state="translated">replaceState</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="41eaab877ca3a0e3aa14f5a4b7981f590e3c2bd6" translate="yes" xml:space="preserve">
          <source>strict</source>
          <target state="translated">strict</target>
        </trans-unit>
        <trans-unit id="4c91330c57b1f26f16a92bbcb0653bc2a60a5b88" translate="yes" xml:space="preserve">
          <source>subscribe</source>
          <target state="translated">subscribe</target>
        </trans-unit>
        <trans-unit id="c8be9eb77e0a063aa55220d426f0169f12707d24" translate="yes" xml:space="preserve">
          <source>subscribeAction</source>
          <target state="translated">subscribeAction</target>
        </trans-unit>
        <trans-unit id="575fade49b23c513149d6cbd60de79f6715e014d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</source>
          <target state="translated">тип: &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="501ad78bfb628eb307d521b862f9d31d47e25be6" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Boolean&lt;/code&gt;</source>
          <target state="translated">тип: &lt;code&gt;Boolean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f896effac2d60505acabced97b30bbb769a74db" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object | Function&lt;/code&gt;</source>
          <target state="translated">тип: &lt;code&gt;Object | Function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="459de9ab6bbb747b424aa86431b8923f3e3cebed" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">тип: &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0800374f05dce7addc4f97d5a68d2e7b35b3ef4" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;boolean&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adf6137f83fccfe39fef3d4143300d0f0d7953d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</source>
          <target state="translated">тип: &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116a5df420232cc247b1f0bf6bbbec8667db410b" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</source>
          <target state="translated">тип: &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a69e7241a5b047759b4617f9a2bc7130db75edc" translate="yes" xml:space="preserve">
          <source>unregisterModule</source>
          <target state="translated">unregisterModule</target>
        </trans-unit>
        <trans-unit id="53c05e9fd370dfe1efd890820e99c7a18b9c5414" translate="yes" xml:space="preserve">
          <source>useStore</source>
          <target state="translated">useStore</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes" xml:space="preserve">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
