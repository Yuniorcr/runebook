<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="619488f89279c23ae3a2459830944ea15030660d" translate="yes" xml:space="preserve">
          <source>auto_mixed_precision: Change certain float32 ops to float16 on Volta GPUs and above. Without the use of loss scaling, this can cause numerical underflow (see &lt;a href=&quot;../../keras/mixed_precision/experimental/lossscaleoptimizer&quot;&gt;&lt;code&gt;keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">auto_mixed_precision: измените некоторые операции float32 на float16 на графических процессорах Volta и выше. Без использования масштабирования потерь это может вызвать потерю числового значения (см. &lt;a href=&quot;../../keras/mixed_precision/experimental/lossscaleoptimizer&quot;&gt; &lt;code&gt;keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="002b2a1ebd41ccef89d58e7608eec433a104cac0" translate="yes" xml:space="preserve">
          <source>average of the numbers of input and output units, if &lt;code&gt;mode=&quot;fan_avg&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f6401ea42a20ac58babe989dcfe67f5d6a85d8" translate="yes" xml:space="preserve">
          <source>average of the numbers of input and output units, if mode = &quot;fan_avg&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60db329aa466d44c2e2e0eb129daefe58b67456" translate="yes" xml:space="preserve">
          <source>axis along which to normalize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3bbc60a2573f56d672b412e7957606aeea5a74" translate="yes" xml:space="preserve">
          <source>axis along which to perform normalization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4ed28312712c0f85b75eca50aeb8bc8c63d0c6" translate="yes" xml:space="preserve">
          <source>axis along which to perform the reduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42196d958f18bea2afbb96730ce41e0664400c9e" translate="yes" xml:space="preserve">
          <source>b = tf.constant([7, 8, 9, 10, 11, 12], shape=[3, 2]) b # 2-D tensor</source>
          <target state="translated">b=tf.constant([7,8,9,10,11,12],shape=[3,2])b#2-D тензор</target>
        </trans-unit>
        <trans-unit id="331c18342e7de328d492864220ecd97a17015fe4" translate="yes" xml:space="preserve">
          <source>b = tf.constant(np.arange(13, 25, dtype=np.int32), shape=[2, 3, 2]) b # 3-D tensor</source>
          <target state="translated">b=tf.constant(np.arange(13,25,dtype=np.int32),shape=[2,3,2])b#3D тензор</target>
        </trans-unit>
        <trans-unit id="b3320d5417b786180d6a88859ca33be71ffb5b58" translate="yes" xml:space="preserve">
          <source>b) If a loop variable is an IndexedSlices, the shape invariant must be a shape invariant of the values tensor of the IndexedSlices. It means the shapes of the three tensors of the IndexedSlices are (shape, [shape[0]], [shape.ndims]).</source>
          <target state="translated">б)Если переменная цикла является IndexedSlices,то инвариант формы должен быть инвариантом тензора значений IndexedSlices.Это означает,что формы трех тензоров IndexedSlices (форма,[форма[0]],[форма.ndims]).</target>
        </trans-unit>
        <trans-unit id="ebff310bfb597dca9af90cc7bb89e113f3105c06" translate="yes" xml:space="preserve">
          <source>b^2}\). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccc035633d62f88de0622d178fdcb0294d354f1" translate="yes" xml:space="preserve">
          <source>batch_to_space_nd( op(space_to_batch_nd(input, adjusted_dilation_rate, adjusted_paddings), num_spatial_dims, &quot;VALID&quot;) adjusted_dilation_rate, adjusted_crops),</source>
          <target state="translated">batch_to_space_nd(op(space_to_batch_nd(input,adjusted_dilation_rate,adjusted_paddings),num_spatial_dims,&quot;VALID&quot;)adjusted_dilation_rate,adjusted_crops),</target>
        </trans-unit>
        <trans-unit id="c093a465e4e07e5fa20e4fb7f7f76b8aa08f949f" translate="yes" xml:space="preserve">
          <source>batched_tensor: The possibly transformed output of Batch. The size of the first dimension should remain unchanged by the transformations for the operation to work. batch_index: The matching batch_index obtained from Batch. id: The id scalar emitted by Batch. unbatched_tensor: The Tensor corresponding to this execution. timeout_micros: Maximum amount of time (in microseconds) to wait to receive the batched input tensor associated with a given invocation of the op. container: Container to control resource sharing. shared_name: Instances of Unbatch with the same container and shared_name are assumed to possibly belong to the same batch. If left empty, the op name will be used as the shared name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9bc5128b98bd8e78ed572fa0d85d3ece46ead7" translate="yes" xml:space="preserve">
          <source>because a pair of consecutive &lt;code&gt;space_to_batch&lt;/code&gt; and &lt;code&gt;batch_to_space&lt;/code&gt; ops with the same &lt;code&gt;block_size&lt;/code&gt; cancel out when their respective &lt;code&gt;paddings&lt;/code&gt; and &lt;code&gt;crops&lt;/code&gt; inputs are identical.</source>
          <target state="translated">потому что пара последовательных &lt;code&gt;space_to_batch&lt;/code&gt; и &lt;code&gt;batch_to_space&lt;/code&gt; OPS с тем же &lt;code&gt;block_size&lt;/code&gt; отмены, когда их соответствующие &lt;code&gt;paddings&lt;/code&gt; и &lt;code&gt;crops&lt;/code&gt; входы идентичны.</target>
        </trans-unit>
        <trans-unit id="dbe87a48392f9193173d712866c0cbdb50b0e053" translate="yes" xml:space="preserve">
          <source>before each call to &lt;code&gt;Saver.save()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5521c8cb6e29442cb11b0fb0f21efd6edc16ae" translate="yes" xml:space="preserve">
          <source>before using the session</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8592abd982bea11fcaf0e400a42a85e26ee543" translate="yes" xml:space="preserve">
          <source>block_shape + [batch] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shape</source>
          <target state="translated">block_shape+[пакет]+[padded_shape[1]/block_shape[0],...,padded_shape[M]/block_shape[M-1]].+оставшийся_образную форму</target>
        </trans-unit>
        <trans-unit id="a62b7a77bb29e2a36e1ebae2231955fdfd9068b4" translate="yes" xml:space="preserve">
          <source>bool - Whether to support comma as an additional separator. If false then only whitespace is supported. This is intended only for backwards compatibility with flags that used to be comma-separated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55468afeacf1d405eea1087e545589426b03f7f0" translate="yes" xml:space="preserve">
          <source>bool, &lt;code&gt;False&lt;/code&gt; by default. When this is true, only the prediction graph is saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da802835f77b0fef901abbe0f44feda1b98642f6" translate="yes" xml:space="preserve">
          <source>bool, &lt;code&gt;False&lt;/code&gt; by default. Whether to write the &lt;code&gt;SavedModel&lt;/code&gt; proto in text format. Currently unavailable in serving-only mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232262472bbc019b28e61d995176d4ba22492567" translate="yes" xml:space="preserve">
          <source>bool, Traverse in order if True, post order if False. Errors that happen while listing directories are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57dfb2488d6b3d00a298ceefe842566fbe26001" translate="yes" xml:space="preserve">
          <source>bool, Traverse pre order if True, post order if False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83552383937cdc106e863b57278305399ceabc37" translate="yes" xml:space="preserve">
          <source>bool, if &lt;code&gt;False&lt;/code&gt;, will pad dimensions with unknown size to maximum length in batch. If &lt;code&gt;True&lt;/code&gt;, will pad dimensions with unknown size to bucket boundary minus 1 (i.e., the maximum length in each bucket), and caller must ensure that the source &lt;code&gt;Dataset&lt;/code&gt; does not contain any elements with length longer than &lt;code&gt;max(bucket_boundaries)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a184c002e2bf17ea0d28f9add1613294fc6fe578" translate="yes" xml:space="preserve">
          <source>bool, if False, --flagfile parsing obeys the FLAGS.is_gnu_getopt() value. If True, ignore the value and always follow gnu_getopt semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4111133dcce83c8f4dc9fc0c881c12e1b2d0f24d" translate="yes" xml:space="preserve">
          <source>bool, if True, parse and remove known flags; return the rest untouched. Unknown flags specified by --undefok are not returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961b77256a57e1d5bf7ff8450c2d2d09793f837d" translate="yes" xml:space="preserve">
          <source>bool, set True to enable diagonal/peephole connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed8bd0fbe209802090f1de695ccaed7a293b15b" translate="yes" xml:space="preserve">
          <source>bool, whether or not the enum is to be case-sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6de556942a9fd30beef64de05b7986ad3ac464" translate="yes" xml:space="preserve">
          <source>bool, whether or not the enum is to be case-sensitive. If False, all member names must be unique when case is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32263368ab8b01d15d8debd8a133bb99c14e1804" translate="yes" xml:space="preserve">
          <source>bool, whether or not to use GNU style scanning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9ad6a0afefa218cc4783fe668480cbdb6f5de3" translate="yes" xml:space="preserve">
          <source>bool, whether to also output log messages to &lt;code&gt;sys.stdout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c24010c6e7c09bd8ae6ac36fa3391c24a833a7d" translate="yes" xml:space="preserve">
          <source>bool, whether to include description of SPECIAL_FLAGS, i.e. --flagfile and --undefok.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e2c860f802d4f8a55e3fe4011ad109224542f4" translate="yes" xml:space="preserve">
          <source>bool, whether to map strings to members of the enum_class without considering case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594f287cc233d858b9e54ffcd7a4f78ed3fe53be" translate="yes" xml:space="preserve">
          <source>bool, whether to read the records in random order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6fde73b4278f70b922d28e859363b59536b552d" translate="yes" xml:space="preserve">
          <source>bool, whether to support comma as an additional separator. If False then only whitespace is supported. This is intended only for backwards compatibility with flags that used to be comma-separated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f84f6248178a598ae52240a0e43d5b64232c8f" translate="yes" xml:space="preserve">
          <source>bool. Defaults to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="357010cb12b280c194442bb4a80f321eba6fd337" translate="yes" xml:space="preserve">
          <source>bool. If True, the centers of the 4 corner pixels of the input and output tensors are aligned, preserving the values at the corner pixels. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35422a7a9ff447466e96a499ec607385137c027" translate="yes" xml:space="preserve">
          <source>bool. If true, exactly one flag must be True. Otherwise, at most one flag can be True, and it is valid for all flags to be False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3443ae1524f1680151d6a19618cbba0515d2c9" translate="yes" xml:space="preserve">
          <source>bool. If true, exactly one of the flags must have a value other than None. Otherwise, at most one of the flags can have a value other than None, and it is valid for all of the flags to be None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e392861274de790ab12e0df135dfb8201e8c32f" translate="yes" xml:space="preserve">
          <source>boolean determining whether to ignore randomized attribute values that appear in V2 checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2774f839f0f68c52da54df050f55908e8eed06" translate="yes" xml:space="preserve">
          <source>boolean determining whether to ignore randomized shared_names that appear in HashTableV2 op defs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e0ef87716e0ab0cd83edb19fe2a5b51c013305" translate="yes" xml:space="preserve">
          <source>boolean indicating whether multilabel data should be treated as such, wherein AUC is computed separately for each label and then averaged across labels, or (when False) if the data should be flattened into a single label before AUC computation. In the latter case, when multilabel data is passed to AUC, each label-prediction pair is treated as an individual data point. Should be set to False for multi-class data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1751e3198f57ff032cc2bc363d8041ffe1c24e" translate="yes" xml:space="preserve">
          <source>boolean, if false it's an error for &lt;code&gt;dst&lt;/code&gt; to be occupied by an existing file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad196b1e39b4df3c36aabf3d8b257600a878daf2" translate="yes" xml:space="preserve">
          <source>boolean, if false it's an error for &lt;code&gt;newname&lt;/code&gt; to be occupied by an existing file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61702f599fce4f7d1cb7442f8ac2e68604e64ea5" translate="yes" xml:space="preserve">
          <source>boolean, if false it's an error for &lt;code&gt;newpath&lt;/code&gt; to be occupied by an existing file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f6e68cef8ce1516627bd21b8cec8437a541117" translate="yes" xml:space="preserve">
          <source>boolean, whether the outermost context is in eager mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6be307d18a1433bcc21a4015dcf43d34b7cf101" translate="yes" xml:space="preserve">
          <source>boolean. Whether to apply Nesterov momentum. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428cda69161fb5e4993f3b8d5433314b7fb922d7" translate="yes" xml:space="preserve">
          <source>boolean. Whether to set the text to lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1be2d739784783b5fd7cbe912869a3afd497dc" translate="yes" xml:space="preserve">
          <source>bool|str|None, the default value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f46fcbb7150625b3376d41472e14860e8c77b3" translate="yes" xml:space="preserve">
          <source>build() is already called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe0b741c205bd8b78c7a9dfbaae7ede18737dc7" translate="yes" xml:space="preserve">
          <source>c = tf.matmul(a, b) c # &lt;code&gt;a&lt;/code&gt; * &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">c = tf.matmul (a, b) c # &lt;code&gt;a&lt;/code&gt; * &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="320b384a8312ebd4e71df6cff7eb697ad2c9cebc" translate="yes" xml:space="preserve">
          <source>caching_device: Optional device string describing where the Variable should be cached for reading. Defaults to the Variable's device. If not &lt;code&gt;None&lt;/code&gt;, caches on another device. Typical use is to cache on the device where the Ops using the Variable reside, to deduplicate copying through &lt;code&gt;Switch&lt;/code&gt; and other conditional statements.</source>
          <target state="translated">caching_device: необязательная строка устройства, описывающая, где переменная должна быть кэширована для чтения. По умолчанию используется устройство переменной. Если не &lt;code&gt;None&lt;/code&gt; , кешируется на другом устройстве. Типичное использование - кэширование на устройстве, где находятся операторы, использующие переменную, для дедупликации копирования с помощью &lt;code&gt;Switch&lt;/code&gt; и других условных операторов.</target>
        </trans-unit>
        <trans-unit id="7ad45d7f43fdbe7156056570171195cef23baee7" translate="yes" xml:space="preserve">
          <source>caffe: will convert the images from RGB to BGR, then will zero-center each color channel with respect to the ImageNet dataset, without scaling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c4f2896e8818bad02017decc3aa2b040b1b146" translate="yes" xml:space="preserve">
          <source>callable or &lt;code&gt;None&lt;/code&gt;: the partitioner passed to &lt;code&gt;get_variable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21a11b5cc2db3ab35475bd3e9d049bfef161424" translate="yes" xml:space="preserve">
          <source>callable, a function to validate the flag. input - dict, with keys() being flag_names, and value for each key being the value of the corresponding flag (string, boolean, etc). output - bool, True if validator constraint is satisfied. If constraint is not satisfied, it should either return False or raise flags.ValidationError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7aad64842ab221dca86ded73e31802b5ea20bd0" translate="yes" xml:space="preserve">
          <source>called at the beginning of every batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a18d26e33cc0c60f5cec1872402cdc7cdac16ab" translate="yes" xml:space="preserve">
          <source>called at the beginning of every epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e6dd35db8a92311ffdcd47c800e0eb9617a8d6" translate="yes" xml:space="preserve">
          <source>called at the beginning of model training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ae29d02451f26105eee845ea3badac99f0af3c" translate="yes" xml:space="preserve">
          <source>called at the end of every batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3259bb1492193066de05a94c1d731b17e1077f7" translate="yes" xml:space="preserve">
          <source>called at the end of every epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950133fed7cbbe0c9d95678214dab980e6306f5e" translate="yes" xml:space="preserve">
          <source>called at the end of model training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15c40326c4c52aca4d634221675089ef3f9372d" translate="yes" xml:space="preserve">
          <source>calls &lt;code&gt;hook.after_create_session()&lt;/code&gt;</source>
          <target state="translated">вызывает &lt;code&gt;hook.after_create_session()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6560c3a7d1fd751cac5e526396f58761ea2bec0" translate="yes" xml:space="preserve">
          <source>calls &lt;code&gt;hook.after_run()&lt;/code&gt;</source>
          <target state="translated">вызывает &lt;code&gt;hook.after_run()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fff680f28bca9038a2a088f909e686ea245d855f" translate="yes" xml:space="preserve">
          <source>calls &lt;code&gt;hook.before_run()&lt;/code&gt;</source>
          <target state="translated">вызывает &lt;code&gt;hook.before_run()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4620eebcbe111662aca04ec4fc8ffe7c11876ed" translate="yes" xml:space="preserve">
          <source>calls &lt;code&gt;hook.begin()&lt;/code&gt; for each given hook</source>
          <target state="translated">вызывает &lt;code&gt;hook.begin()&lt;/code&gt; для каждого заданного крючка</target>
        </trans-unit>
        <trans-unit id="6fff1a970af5c5efc7567de429c5998ea9aab947" translate="yes" xml:space="preserve">
          <source>calls &lt;code&gt;hook.end()&lt;/code&gt;</source>
          <target state="translated">вызывает &lt;code&gt;hook.end()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b2f096e00b533f3d41f20c9803f45c55f018092" translate="yes" xml:space="preserve">
          <source>calls TensorFlow &lt;code&gt;session.run()&lt;/code&gt; with merged fetches and feed_dict</source>
          <target state="translated">вызывает TensorFlow &lt;code&gt;session.run()&lt;/code&gt; с объединенными выборками и feed_dict</target>
        </trans-unit>
        <trans-unit id="a43ca37130953f646c5b2bee30d9f4eeae4887ac" translate="yes" xml:space="preserve">
          <source>can be True, False, a bool Tensor, or a callable providing such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213006ad598dbc0f82a89503d141ea76ff1598cb" translate="yes" xml:space="preserve">
          <source>can be combined into a single &lt;code&gt;with_space_to_batch&lt;/code&gt; operation as follows:</source>
          <target state="translated">можно объединить в одну операцию &lt;code&gt;with_space_to_batch&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="c8134ccfff78bbf2590e5607ee1803365874833d" translate="yes" xml:space="preserve">
          <source>can be equivalently performed cheaper in terms of computation and memory as:</source>
          <target state="translated">может быть эквивалентно дешевле с точки зрения вычислений и памяти как:</target>
        </trans-unit>
        <trans-unit id="0d36bf326f969cd786725e34418bdbaa4b2bae0e" translate="yes" xml:space="preserve">
          <source>can be rewritten as</source>
          <target state="translated">может быть переписано как</target>
        </trans-unit>
        <trans-unit id="ce949af1a07f93922c5d731ded6dbb99391a90dd" translate="yes" xml:space="preserve">
          <source>class A(object): def &lt;strong&gt;init&lt;/strong&gt;(self, x, y): self.x = x self.y = y</source>
          <target state="translated">класс A (объект): def &lt;strong&gt;init&lt;/strong&gt; (self, x, y): self.x = x self.y = y</target>
        </trans-unit>
        <trans-unit id="ea1ab55353c766d5bfc461fe922ecb5077a2b166" translate="yes" xml:space="preserve">
          <source>class CallCounter(tf_decorator.TFDecorator): def &lt;strong&gt;init&lt;/strong&gt;(self, target): super(CallCounter, self).&lt;strong&gt;init&lt;/strong&gt;('count_calls', target) self.call_count = 0</source>
          <target state="translated">класс CallCounter (tf_decorator.TFDecorator): def &lt;strong&gt;init&lt;/strong&gt; (self, target): super (CallCounter, self). &lt;strong&gt;init&lt;/strong&gt; ('count_calls', цель) self.call_count = 0</target>
        </trans-unit>
        <trans-unit id="5971074ca6fb4ea74027d3417be8610f9144c56a" translate="yes" xml:space="preserve">
          <source>class vector to be converted into a matrix (integers from 0 to num_classes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c7b2ab503ea5ebea87df6b742fe988653fc86a" translate="yes" xml:space="preserve">
          <source>class, the Enum class with all possible flag values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d518156944f5d713fbc238ca7467a05358e1eb" translate="yes" xml:space="preserve">
          <source>class, the Enum class with all the possible values for the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a37d069dccd977ea3621b51126efe559886b00d" translate="yes" xml:space="preserve">
          <source>class, the Enum class with all the possible values for the flag. help: str, the help message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1adaa84dc07a16d34ede5b9a70713ff832a0f853" translate="yes" xml:space="preserve">
          <source>classes</source>
          <target state="translated">classes</target>
        </trans-unit>
        <trans-unit id="a14acbf5679090cec23f9a4cf3c00bd1e06896b6" translate="yes" xml:space="preserve">
          <source>closes the queue runners and the session</source>
          <target state="translated">закрывает очередь бегунов и сессию</target>
        </trans-unit>
        <trans-unit id="0acc7af1f9b3a93f967742398c067f423da99888" translate="yes" xml:space="preserve">
          <source>collection to which the loss will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5634bc6a7f91789985d1ebced15431b5bd61acc" translate="yes" xml:space="preserve">
          <source>collection to which this loss will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572db9c8e76fcbc4e0380c7e93a22fc5924631e1" translate="yes" xml:space="preserve">
          <source>collections: List of graph collections keys. The new variable is added to these collections. Defaults to &lt;code&gt;[GraphKeys.GLOBAL_VARIABLES]&lt;/code&gt;.</source>
          <target state="translated">collections: Список ключей коллекций графов. В эти коллекции добавляется новая переменная. По умолчанию &lt;code&gt;[GraphKeys.GLOBAL_VARIABLES]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c606301adefe697699b10b1057325737152414" translate="yes" xml:space="preserve">
          <source>compression method or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd516ec4b6f40ba46beb38731bb1790e05441869" translate="yes" xml:space="preserve">
          <source>computes the logits. It is designed to be used during prediction. It traverses all the trees and calculates the final score for each instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287a4e48dfc1742f34a472bbf58a13f95f03056e" translate="yes" xml:space="preserve">
          <source>computes the update to cached logits. It is designed to be used during training. It traverses the trees starting from cached tree id and cached node id and calculates the updates to be pushed to the cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee44424891fc3e5c532c07d1ccd3abc73c78ac7" translate="yes" xml:space="preserve">
          <source>concatenation axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166b4a7b91b0c6668491a451cd849528db0a522b" translate="yes" xml:space="preserve">
          <source>config: config attribute of the &lt;code&gt;estimator&lt;/code&gt;.</source>
          <target state="translated">config: атрибут config &lt;code&gt;estimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0e8de333b8aad23c2224f01cc326128d46c7350" translate="yes" xml:space="preserve">
          <source>constant_folding: Fold constants Statically infer the value of tensors when possible, and materialize the result using constants.</source>
          <target state="translated">константа_складка:Константы складывания Статически вычисляют значение тензоров,когда это возможно,и материализуют результат с помощью констант.</target>
        </trans-unit>
        <trans-unit id="1004203b7f9920db9cbb5f51d7bea7471804e200" translate="yes" xml:space="preserve">
          <source>constraint: A constraint function to be applied to the variable after updates by some algorithms.</source>
          <target state="translated">Ограничение:Функция ограничения,которая будет применена к переменной после обновления некоторыми алгоритмами.</target>
        </trans-unit>
        <trans-unit id="0fd47551d07c7fca820de921a5cdbf17623fe4f2" translate="yes" xml:space="preserve">
          <source>container name string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cda5c2f5a8a893f7508d7aef54f08d18d16281" translate="yes" xml:space="preserve">
          <source>control flow v2 (cfv2) is an improved version of control flow in TensorFlow with support for higher order derivatives. Enabling cfv2 will change the graph/function representation of control flow, e.g., &lt;a href=&quot;../../while_loop&quot;&gt;&lt;code&gt;tf.while_loop&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cond&quot;&gt;&lt;code&gt;tf.cond&lt;/code&gt;&lt;/a&gt; will generate functional &lt;code&gt;While&lt;/code&gt; and &lt;code&gt;If&lt;/code&gt; ops instead of low-level &lt;code&gt;Switch&lt;/code&gt;, &lt;code&gt;Merge&lt;/code&gt; etc. ops. Note: Importing and running graphs exported with old control flow will still be supported.</source>
          <target state="translated">поток управления v2 (cfv2) - это улучшенная версия потока управления в TensorFlow с поддержкой производных более высокого порядка. Включение cfv2 изменит графическое / функциональное представление потока управления, например, &lt;a href=&quot;../../while_loop&quot;&gt; &lt;code&gt;tf.while_loop&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../cond&quot;&gt; &lt;code&gt;tf.cond&lt;/code&gt; &lt;/a&gt; будут генерировать функциональные операции &lt;code&gt;While&lt;/code&gt; и &lt;code&gt;If&lt;/code&gt; вместо операций &lt;code&gt;Switch&lt;/code&gt; , &lt;code&gt;Merge&lt;/code&gt; и т. Д. Низкого уровня. Примечание. Импорт и выполнение графиков, экспортированных со старым потоком управления, по-прежнему поддерживаются.</target>
        </trans-unit>
        <trans-unit id="8969aaf6687cd04b6a08c7b12acb63530d53bb76" translate="yes" xml:space="preserve">
          <source>controls what format to use when saving checkpoints. It also affects certain filepath matching logic. The V2 format is the recommended choice: it is much more optimized than V1 in terms of memory required and latency incurred during restore. Regardless of this flag, the Saver is able to restore from both V2 and V1 checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb8e53b5e563459f22a874a8a2f417576fe8296" translate="yes" xml:space="preserve">
          <source>convolution kernel for the depthwise convolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa223ce6606fc4db86496b58246b64d1e1d5e7e" translate="yes" xml:space="preserve">
          <source>convolution(input, data_format, **kwargs) = tf.transpose(convolution(tf.transpose(input, [0] + range(2,N+2) + [1]), **kwargs), [0, N+1] + range(1, N+1))</source>
          <target state="translated">convolution(input,data_format,**kwargs)=tf.transpose(convolution(tf.transpose(input,[0]+диапазон(2,N+2)+[1]),**kwargs),[0,N+1]+диапазон(1,N+1)))</target>
        </trans-unit>
        <trans-unit id="2dfa6e41645b6d695da7f9c140140df1cb9e8a8d" translate="yes" xml:space="preserve">
          <source>cosine similarity = (a . b) / ||a|| ||b|| &lt;a href=&quot;https://en.wikipedia.org/wiki/Cosine_similarity&quot;&gt;Cosine Similarity&lt;/a&gt;</source>
          <target state="translated">косинусное подобие = (a. b) / || a || || b || &lt;a href=&quot;https://en.wikipedia.org/wiki/Cosine_similarity&quot;&gt;Косинусное подобие&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a603399ca63f102e5719bfde04e73dc907255fa" translate="yes" xml:space="preserve">
          <source>count(self: tensorflow.python._tf_stack.StackSummary, x: tensorflow.python._tf_stack.FrameSummary) -&amp;gt; int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6561407d8111db6f65b97909d1531b90b91a1cbd" translate="yes" xml:space="preserve">
          <source>create session</source>
          <target state="translated">сеанс создания</target>
        </trans-unit>
        <trans-unit id="067554dfada58ece552f7c58c038dc321b5e6471" translate="yes" xml:space="preserve">
          <source>create_slots (if your optimizer algorithm requires additional variables)</source>
          <target state="translated">create_slots (если ваш алгоритм оптимизации требует дополнительных переменных)</target>
        </trans-unit>
        <trans-unit id="7e89165c664759ed118a849ac5e157c7a7420cee" translate="yes" xml:space="preserve">
          <source>creates directory if not existing.</source>
          <target state="translated">создает каталог,если он не существует.</target>
        </trans-unit>
        <trans-unit id="081b707adb8ee559bb4d1ff71e37620e1d554dbc" translate="yes" xml:space="preserve">
          <source>crops = [[crop_top, crop_bottom], [crop_left, crop_right]]</source>
          <target state="translated">crop=[[crop_top,crop_bottom],[crop_left,crop_right]]].</target>
        </trans-unit>
        <trans-unit id="8ac8931b552de49d36c8c10b3b173cffe6cfde0b" translate="yes" xml:space="preserve">
          <source>crops[i, 0] = 0 crops[i, 1] = paddings[i, 1] - base_paddings[i, 1]</source>
          <target state="translated">crops[i,0]=0 crops[i,1]=paddings[i,1]-base_paddings[i,1]</target>
        </trans-unit>
        <trans-unit id="f9891128069c86fb92a3fabee7a8253451caf028" translate="yes" xml:space="preserve">
          <source>ctc_unique_labels([[3, 4, 4, 3]]) -&amp;gt; unique labels padded with 0: [[3, 4, 0, 0]] indices of original labels in unique: [0, 1, 1, 0]</source>
          <target state="translated">ctc_unique_labels ([[3, 4, 4, 3]]) -&amp;gt; уникальные метки, дополненные 0: [[3, 4, 0, 0]] индексы исходных меток в уникальных: [0, 1, 1, 0]</target>
        </trans-unit>
        <trans-unit id="9261a095475d82ac2395de16ad813930a0821d0b" translate="yes" xml:space="preserve">
          <source>cuda_version</source>
          <target state="translated">cuda_version</target>
        </trans-unit>
        <trans-unit id="61d4d9e1b165e8e4fdf97931260eab648e6515aa" translate="yes" xml:space="preserve">
          <source>cudart_dll_name</source>
          <target state="translated">cudart_dll_name</target>
        </trans-unit>
        <trans-unit id="55f7705b823156ca7127762f2926b65ee4bdc20d" translate="yes" xml:space="preserve">
          <source>cudnn_dll_name</source>
          <target state="translated">cudnn_dll_name</target>
        </trans-unit>
        <trans-unit id="177180bb7a0b8460b40a6aba843213be4525b6d8" translate="yes" xml:space="preserve">
          <source>cudnn_version</source>
          <target state="translated">cudnn_version</target>
        </trans-unit>
        <trans-unit id="5c6f87a5f7e23412684ce83f622fb8f3ce90a78c" translate="yes" xml:space="preserve">
          <source>d = a @ b @ [[10], [11]] d = tf.matmul(tf.matmul(a, b), [[10], [11]])</source>
          <target state="translated">d=a @ b @ [[10],[11]]d=tf.matmul(tf.matmul(a,b),[[10],[11]]))</target>
        </trans-unit>
        <trans-unit id="3d40fa2f98ac152247e08d883549bda01bfdba78" translate="yes" xml:space="preserve">
          <source>d_values[j] = grad_values[reverse_index_map[j]] d_default&lt;em&gt;value = sum&lt;/em&gt;{k : 0 .. N_full - 1} ( grad_values[k] * 1{k not in reverse_index_map})</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db534c996326aab12c91b5dda8134e155a11a390" translate="yes" xml:space="preserve">
          <source>data to be embedded at layers specified in &lt;code&gt;embeddings_layer_names&lt;/code&gt;. Numpy array (if the model has a single input) or list of Numpy arrays (if the model has multiple inputs). Learn more about embeddings &lt;a href=&quot;https://www.tensorflow.org/programmers_guide/embedding&quot;&gt;in this guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92e32421aa41f05dc68e2e6e1954f525114a546" translate="yes" xml:space="preserve">
          <source>data type for the constructed &lt;code&gt;RaggedTensor&lt;/code&gt;'s row_splits. One of &lt;a href=&quot;../../../../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a870700b6808260e028c772a234203f1312a9720" translate="yes" xml:space="preserve">
          <source>data type for the constructed &lt;code&gt;RaggedTensor&lt;/code&gt;'s row_splits. One of &lt;a href=&quot;../../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687bf46f819012d358ca2f9a5286b273df46243b" translate="yes" xml:space="preserve">
          <source>data type of returned Keras variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a0cbfc434d066ddea05f77d478859793878755" translate="yes" xml:space="preserve">
          <source>dataset For the first two cases, &lt;code&gt;batch_size&lt;/code&gt; must be provided. For the last case, &lt;code&gt;validation_steps&lt;/code&gt; could be provided.</source>
          <target state="translated">набор данных Для первых двух случаев необходимо &lt;code&gt;batch_size&lt;/code&gt; . В последнем случае можно &lt;code&gt;validation_steps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b3c815233af7496e693ef0673624f1826ffe84e" translate="yes" xml:space="preserve">
          <source>dataset For the first two cases, &lt;code&gt;batch_size&lt;/code&gt; must be provided. For the last case, &lt;code&gt;validation_steps&lt;/code&gt; could be provided. Note that &lt;code&gt;validation_data&lt;/code&gt; does not support all the data types that are supported in &lt;code&gt;x&lt;/code&gt;, eg, dict, generator or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d2ba254147e85f6a02909629f6ccabbfe44bc2" translate="yes" xml:space="preserve">
          <source>dataset For the first two cases, &lt;code&gt;batch_size&lt;/code&gt; must be provided. For the last case, &lt;code&gt;validation_steps&lt;/code&gt; could be provided. Note that &lt;code&gt;validation_data&lt;/code&gt; does not support all the data types that are supported in &lt;code&gt;x&lt;/code&gt;, eg, dict, generator or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e234129c60dec6324b5f643e695cdba1a5e75012" translate="yes" xml:space="preserve">
          <source>debug_stripper: Strips debug-related nodes from the graph.</source>
          <target state="translated">debug_stripper:Отрисовывает отладочные узлы с графика.</target>
        </trans-unit>
        <trans-unit id="3b5286a75a577043ec33fdce7e535f55b7b4b9d1" translate="yes" xml:space="preserve">
          <source>decay for the noise's variance. See computation above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea0884d65eb8ec7c27c7eb7bc4d7980cfd33ff6" translate="yes" xml:space="preserve">
          <source>def &lt;strong&gt;call&lt;/strong&gt;(self, *args, *&lt;em&gt;kwargs): self.call_count += 1 return super(CallCounter, self).decorated_target(&lt;/em&gt;args, **kwargs)</source>
          <target state="translated">def &lt;strong&gt;call&lt;/strong&gt; (self, * args, * &lt;em&gt;kwargs): self.call_count + = 1 return super (CallCounter, self) .decorated_target (&lt;/em&gt; args, ** kwargs)</target>
        </trans-unit>
        <trans-unit id="b6bf158433cfae2c912d4d20037c21436b88a3ad" translate="yes" xml:space="preserve">
          <source>def &lt;strong&gt;hash&lt;/strong&gt;(self): return hash(self.x)</source>
          <target state="translated">def &lt;strong&gt;hash&lt;/strong&gt; (self): вернуть хеш (self.x)</target>
        </trans-unit>
        <trans-unit id="d7d64ddea4a1a04222372fd1d42ba7a9b83ec2c4" translate="yes" xml:space="preserve">
          <source>def &lt;strong&gt;lt&lt;/strong&gt;(self, other): try: return self.x &amp;lt; other.x except AttributeError: return NotImplemented</source>
          <target state="translated">def &lt;strong&gt;lt&lt;/strong&gt; (self, other): try: return self.x &amp;lt;other.x except AttributeError: return NotImplemented</target>
        </trans-unit>
        <trans-unit id="0b739d3451ecc417ae38b94f2b12e255e2e0fde9" translate="yes" xml:space="preserve">
          <source>def combined_op(converted_input, num_spatial_dims, _): result = op_1(converted_input, num_spatial_dims, &quot;SAME&quot;) ... result = op_k(result, num_spatial_dims, &quot;SAME&quot;)</source>
          <target state="translated">def combined_op(converted_input,num_spatial_dims,_):result=op_1(converted_input,num_spatial_dims,&quot;SAME&quot;)...result=op_k(result,num_spatial_dims,&quot;SAME&quot;)</target>
        </trans-unit>
        <trans-unit id="6d99321e9860b560a343cc60276965958dcaffe8" translate="yes" xml:space="preserve">
          <source>def combined_op(converted_input, num_spatial_dims, _): result = op_1(converted_input, num_spatial_dims, &quot;VALID&quot;) ... result = op_k(result, num_spatial_dims, &quot;VALID&quot;)</source>
          <target state="translated">def combined_op(converted_input,num_spatial_dims,_):result=op_1(converted_input,num_spatial_dims,&quot;VALID&quot;)...result=op_k(result,num_spatial_dims,&quot;VALID&quot;)</target>
        </trans-unit>
        <trans-unit id="c6742c4d87eb8a1588bec5ca35789ce0447474e4" translate="yes" xml:space="preserve">
          <source>def computation_with_string_ops(x): # strings types are not supported on TPU's and below ops must # run on CPU instead. output = tf.strings.format('1{}', x) return tf.strings.to_number(output)</source>
          <target state="translated">def computation_with_string_ops(x):#типы строк не поддерживаются на TPU и ниже ops должны#выполняться на CPU.output=tf.strings.format('1{}',x)возвращает tf.strings.to_number(output)</target>
        </trans-unit>
        <trans-unit id="d125938822ce482a4fb184fcc6acf85bec343142" translate="yes" xml:space="preserve">
          <source>def count_calls(target): return CallCounter(target)</source>
          <target state="translated">def count_calls(target):возвращает CallCounter(target)</target>
        </trans-unit>
        <trans-unit id="930f4fd3edf0ac478abd5997dcc865ae04ba3d2c" translate="yes" xml:space="preserve">
          <source>def my_op(a): with tf.name_scope(&quot;MyOp&quot;) as scope: a = tf.convert_to_tensor(a, name=&quot;a&quot;) # Define some computation that uses &lt;code&gt;a&lt;/code&gt;. return foo_op(..., name=scope)</source>
          <target state="translated">def my_op (a): with tf.name_scope (&quot;MyOp&quot;) в качестве области видимости: a = tf.convert_to_tensor (a, name = &quot;a&quot;) # Определите некоторые вычисления, которые используют &lt;code&gt;a&lt;/code&gt; . вернуть foo_op (..., name = scope)</target>
        </trans-unit>
        <trans-unit id="3af6c8098e50bc574f6a3cdf577cf3684ed6722d" translate="yes" xml:space="preserve">
          <source>def print_hello_before_calling(target): def wrapper(*args, *&lt;em&gt;kwargs): print('hello') return target(&lt;/em&gt;args, **kwargs) return tf_decorator.make_decorator(target, wrapper)</source>
          <target state="translated">def print_hello_before_calling (цель): def wrapper (* args, * &lt;em&gt;kwargs): print ('hello') return target (&lt;/em&gt; args, ** kwargs) return tf_decorator.make_decorator (target, wrapper)</target>
        </trans-unit>
        <trans-unit id="00f6bf283c943399d3fa5039f0fc82bfcd676c75" translate="yes" xml:space="preserve">
          <source>def simple_parametrized_wrapper(*args, *&lt;em&gt;kwds): return simple_parametrized&lt;em&gt;wrapper.&lt;/em&gt;&lt;em&gt;wrapped&lt;/em&gt;_(&lt;/em&gt;args, **kwds)</source>
          <target state="translated">def simple_parametrized_wrapper (* args, * &lt;em&gt;kwds): вернуть &lt;em&gt;оболочку&lt;/em&gt; simple_parametrized &lt;em&gt;. &lt;/em&gt;&lt;em&gt;завернутый&lt;/em&gt; _ (&lt;/em&gt; аргументы, ** kwds)</target>
        </trans-unit>
        <trans-unit id="431b8cb088ce9ca3cee3c518bded03d8cb933ed5" translate="yes" xml:space="preserve">
          <source>def simple_parametrized_wrapper(*args, *&lt;em&gt;kwds): return wrapped_fn(&lt;/em&gt;args, **kwds)</source>
          <target state="translated">def simple_parametrized_wrapper (* args, * &lt;em&gt;kwds): вернуть wrapped_fn (&lt;/em&gt; args, ** kwds)</target>
        </trans-unit>
        <trans-unit id="e6ccade472b6591a10dd1ec758fc3200663939d7" translate="yes" xml:space="preserve">
          <source>def tpu_computation(): # Expected output is 11. output = tf.tpu.outside_compilation(computation_with_string_ops, 1)</source>
          <target state="translated">def tpu_computation():#Ожидаемый результат 11.output=tf.tpu.outside_compilation(computation_with_string_ops,1)</target>
        </trans-unit>
        <trans-unit id="3e96b32a2edc8e572b214a9f54bdf6261a57dde9" translate="yes" xml:space="preserve">
          <source>default caching device for variables within this scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2df16d2675afd170272c5e55e0b26291c4143f" translate="yes" xml:space="preserve">
          <source>default custom getter for variables within this scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76915519a6f602b8ea4d69c6eb0939247f04f13f" translate="yes" xml:space="preserve">
          <source>default custom getter passed to get_variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fa2ad5d60eca319b01083d3368713bbf09a22c" translate="yes" xml:space="preserve">
          <source>default initializer for variables within this scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddacfef1590357d30ddebac9db500687d11f1e4d" translate="yes" xml:space="preserve">
          <source>default initializer passed to get_variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b9378cd2ec2ecb5aa450bb4209c7ace5c22490" translate="yes" xml:space="preserve">
          <source>default partitioner for variables within this scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bd7fad74dcac92cd95a808c23e586aa5656c70" translate="yes" xml:space="preserve">
          <source>default regularizer for variables within this scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa565adcb7c2b4282a00b73f27e1a96696c4326d" translate="yes" xml:space="preserve">
          <source>default regularizer passed to get_variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0115a270f55463f5b75591d03caa3275804e365a" translate="yes" xml:space="preserve">
          <source>default type passed to get_variable (defaults to DT_FLOAT).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2edfaa4edca3dd5e04811717f4c45fd83392e6b" translate="yes" xml:space="preserve">
          <source>defined as follows:</source>
          <target state="translated">определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="f4a9ec55a842c80027835c4d179160665aaf80b6" translate="yes" xml:space="preserve">
          <source>defines the type of values. Default value is &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;. Must be a non-quantized, real integer or floating point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f02ec0eb3877402d3462e56a63f49a16d92da02" translate="yes" xml:space="preserve">
          <source>dense CTC labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e42ae1e873be8814d7c9a59a012186a5c6a1b9" translate="yes" xml:space="preserve">
          <source>dense Matrix (or SparseTensor) B, with the same dtype as sp_a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59d2465a9e6561ffe24c2765287f07a897f8194" translate="yes" xml:space="preserve">
          <source>dependency_optimization: Control dependency optimizations. Remove redundant control dependencies, which may enable other optimization. This optimizer is also essential for pruning Identity and NoOp nodes.</source>
          <target state="translated">зависимость_оптимизация:Оптимизация зависимостей управления.Удаление избыточных зависимостей управления,которые могут позволить другую оптимизацию.Этот оптимизатор также необходим для обрезки узлов Identity и NoOp.</target>
        </trans-unit>
        <trans-unit id="5da06516347a2103ddebfdc5c1ab59902ca234c9" translate="yes" xml:space="preserve">
          <source>deprecated alias for &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5de296170f45c849a1b6e03c889c1b99436f4d9" translate="yes" xml:space="preserve">
          <source>deprecated arguments support. Supports &lt;code&gt;batch_shape&lt;/code&gt; and &lt;code&gt;batch_input_shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e900d3a76987e139becf5be813e480c66da8ced" translate="yes" xml:space="preserve">
          <source>depth of input crossing. By default None, all inputs are crossed into one output. It can also be an int or tuple/list of ints. Passing an integer will create combinations of crossed outputs with depth up to that integer, i.e., [1, 2, ..., &lt;code&gt;depth&lt;/code&gt;), and passing a tuple of integers will create crossed outputs with depth for the specified values in the tuple, i.e., &lt;code&gt;depth&lt;/code&gt;=(N1, N2) will create all possible crossed outputs with depth equal to N1 or N2. Passing &lt;code&gt;None&lt;/code&gt; means a single crossed output with all inputs. For example, with inputs &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;depth=2&lt;/code&gt; means the output will be [a;b;c;cross(a, b);cross(bc);cross(ca)].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aacf14a4dd6803c97dcb0b4df3d72dbe97c8b34" translate="yes" xml:space="preserve">
          <source>dict mapping class names (or function names) of custom (non-Keras) objects to class/functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5c128c5f45573824353453db907ea29bacca45" translate="yes" xml:space="preserve">
          <source>dict mapping string input names to tensors. These are added to the SignatureDef as the inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e960aff95c2c52e1214044ef375daad39a10739" translate="yes" xml:space="preserve">
          <source>dict mapping string output names to tensors. These are added to the SignatureDef as the outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7f3266d18045fcb8d651e5731b033749855e8f" translate="yes" xml:space="preserve">
          <source>dict of &lt;a href=&quot;../../../../estimator/modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;input_receiver_fn&lt;/code&gt; mappings, where the &lt;code&gt;input_receiver_fn&lt;/code&gt; is a function that takes no arguments and returns the appropriate subclass of &lt;code&gt;InputReceiver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810fec15e7cccc4a7034c45ab52579a79bdbdd4a" translate="yes" xml:space="preserve">
          <source>dict of &lt;a href=&quot;../../../estimator/modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;input_receiver_fn&lt;/code&gt; mappings, where the &lt;code&gt;input_receiver_fn&lt;/code&gt; is a function that takes no arguments and returns the appropriate subclass of &lt;code&gt;InputReceiver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8edd41ec5be059b6eefa6ac90131b868eeea346c" translate="yes" xml:space="preserve">
          <source>dict of &lt;a href=&quot;../modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;input_receiver_fn&lt;/code&gt; mappings, where the &lt;code&gt;input_receiver_fn&lt;/code&gt; is a function that takes no arguments and returns the appropriate subclass of &lt;code&gt;InputReceiver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ff0df9a51027176ae6bc5cb787ce5ed6664dda" translate="yes" xml:space="preserve">
          <source>dict of &lt;a href=&quot;modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;input_receiver_fn&lt;/code&gt; mappings, where the &lt;code&gt;input_receiver_fn&lt;/code&gt; is a function that takes no arguments and returns the appropriate subclass of &lt;code&gt;InputReceiver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daee04585cad581e65e6c00f7febae73d9adec14" translate="yes" xml:space="preserve">
          <source>dict of keyword arguments for base layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a9620b652cbd96befc60709fa2aefbe733aed3" translate="yes" xml:space="preserve">
          <source>dict of string to &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2ed5ff523578826b11fdf6910f7f00951f82fc" translate="yes" xml:space="preserve">
          <source>dict of the form {'class_name': str, 'config': dict}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183220d4a9e6580be3414aeaafeff7011fa93f91" translate="yes" xml:space="preserve">
          <source>dict that allows fixing specified tensor values during the Jacobian calculation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24eb6fbc867d81ddeca49145357c98449118f60f" translate="yes" xml:space="preserve">
          <source>dict, a mapping where the keys are flag names (strings). values are treated according to their type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6859c14f9fed377997aa8e5fb73ffa38e438c9" translate="yes" xml:space="preserve">
          <source>dict, the extra keyword args that are passed to DEFINE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc2a2d4249832224e9aa59fef8c1e6b58e5ca29" translate="yes" xml:space="preserve">
          <source>dict, the extra keyword args that are passed to Flag &lt;strong&gt;init&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a33894202b008e5cf12a1ef72b12b7ade34694" translate="yes" xml:space="preserve">
          <source>dictionary arguments Legal arguments are the arguments of &lt;a href=&quot;../../model#evaluate&quot;&gt;&lt;code&gt;Sequential.evaluate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a160ca3c6487882d8c840903ed31de89be67aad" translate="yes" xml:space="preserve">
          <source>dictionary arguments Legal arguments are the arguments of &lt;a href=&quot;../../model#fit&quot;&gt;&lt;code&gt;Sequential.fit&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c48c206c825280a84bde42f152aab6cce04be9c" translate="yes" xml:space="preserve">
          <source>dictionary arguments Legal arguments are the arguments of &lt;a href=&quot;../../model#predict&quot;&gt;&lt;code&gt;Sequential.predict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013bcfc9a1916f32f521dc34d07ab964c1d24108" translate="yes" xml:space="preserve">
          <source>dictionary arguments Legal arguments are the arguments of &lt;a href=&quot;../../sequential#predict_classes&quot;&gt;&lt;code&gt;Sequential.predict_classes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad646079f3719b9c06c7db8c6557e759fb4df39" translate="yes" xml:space="preserve">
          <source>dictionary containing variables in both &lt;code&gt;sk_params&lt;/code&gt; and &lt;code&gt;fn&lt;/code&gt;'s arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4db25e08cfb182dd8f551c685acf6d98fe71d6d" translate="yes" xml:space="preserve">
          <source>dictionary with (&lt;code&gt;Tensor&lt;/code&gt; to shape) items, or a list of (&lt;code&gt;Tensor&lt;/code&gt;, shape) tuples. A shape must be an iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ea143340e92a80770783c75cbf3696557fa9b8" translate="yes" xml:space="preserve">
          <source>dictionary, values to override &lt;code&gt;sk_params&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9db26848a2671df6a5ade9dcdee64c9361374a8" translate="yes" xml:space="preserve">
          <source>dictionary; the parameters to be checked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8948bc0b427190ac45b31779cc166ea6971ae1" translate="yes" xml:space="preserve">
          <source>dilated_filter_shape = filter_shape + (filter_shape - 1) * (dilation_rate - 1)</source>
          <target state="translated">dilated_filter_shape=форма_фильтра+(форма_фильтра-1)*(скорость_расширения-1)</target>
        </trans-unit>
        <trans-unit id="36ce8e764bcb7ffcef77230101c78a14f99bf62f" translate="yes" xml:space="preserve">
          <source>directory to saved the converted SavedModel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b7e8df1c35148efeef440fe31604a763229a52" translate="yes" xml:space="preserve">
          <source>directory to write the log file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ced8260f1cf1554a2635bc6a280b7e4199eeac" translate="yes" xml:space="preserve">
          <source>directory where model parameters, graph, etc are saved. If &lt;code&gt;PathLike&lt;/code&gt; object, the path will be resolved. If &lt;code&gt;None&lt;/code&gt;, will use a default value set by the Estimator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2a096ac42b541b6ba4e5f86b3b26d83884ec8d" translate="yes" xml:space="preserve">
          <source>disable_meta_optimizer: Disable the entire meta optimizer.</source>
          <target state="translated">disable_meta_optimizer:Отключить весь метаоптимизатор.</target>
        </trans-unit>
        <trans-unit id="a7669cabb379d4201a0a0c139ed40b145de2fe0b" translate="yes" xml:space="preserve">
          <source>disable_model_pruning: Disable removal of unnecessary ops from the graph</source>
          <target state="translated">disable_model_pruning:Отключить удаление ненужных операторов с графика</target>
        </trans-unit>
        <trans-unit id="6805ffc8131dc12b5975373f4780ea8386107058" translate="yes" xml:space="preserve">
          <source>divide gradient by the root of this average</source>
          <target state="translated">разделить градиент на корень этого среднего значения</target>
        </trans-unit>
        <trans-unit id="55f409129e3c9d7ff39481afc14068aab3ee29fb" translate="yes" xml:space="preserve">
          <source>dot product between tensors</source>
          <target state="translated">точечный продукт между тензорами</target>
        </trans-unit>
        <trans-unit id="ae6ee7caec70eadbbf158b8aa9fbf331117b92a3" translate="yes" xml:space="preserve">
          <source>drop summation signs, and (&lt;code&gt;ik = ij, jk&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8ce52c3754d2b878fffdf0f01c19fa0461f498" translate="yes" xml:space="preserve">
          <source>dtype for returned histogram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1aece61ff465175a34fd203ade70c789a86ec4" translate="yes" xml:space="preserve">
          <source>dtype of returned Keras variable. &lt;code&gt;None&lt;/code&gt; uses the dtype of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60543d5ec749e1c0f644902aa7c1882b775cc309" translate="yes" xml:space="preserve">
          <source>dtype: If set, initial_value will be converted to the given type. If &lt;code&gt;None&lt;/code&gt;, either the datatype will be kept (if &lt;code&gt;initial_value&lt;/code&gt; is a Tensor), or &lt;code&gt;convert_to_tensor&lt;/code&gt; will decide.</source>
          <target state="translated">dtype: если установлено, initial_value будет преобразовано в данный тип. Если &lt;code&gt;None&lt;/code&gt; , либо тип данных будет сохранен (если &lt;code&gt;initial_value&lt;/code&gt; - Tensor), либо &lt;code&gt;convert_to_tensor&lt;/code&gt; решит.</target>
        </trans-unit>
        <trans-unit id="7f53a68d324346fc8457a1665141697dcc97ee86" translate="yes" xml:space="preserve">
          <source>e.g.</source>
          <target state="translated">e.g.</target>
        </trans-unit>
        <trans-unit id="2a9b71c488471889c55b47d4766ff91a7e4f6f56" translate="yes" xml:space="preserve">
          <source>e.g. &lt;code&gt;[[4], [20]] -&amp;gt; [[0.25, 0.1], [0.6, -0.2]]&lt;/code&gt;</source>
          <target state="translated">например &lt;code&gt;[[4], [20]] -&amp;gt; [[0.25, 0.1], [0.6, -0.2]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2ecc8cbd684804dbd286d8d9ddde733ac357de4" translate="yes" xml:space="preserve">
          <source>e.g. if T = qint8, and initially min_range = -10, and max_range = 9, we would compare -128/-10.0 = 12.8 to 127/9.0 = 14.11, and set scaling_factor = 12.8 In this case, min_range would remain -10, but max_range would be adjusted to 127 / 12.8 = 9.921875</source>
          <target state="translated">например,если T=qint8,а изначально min_range=-10,и max_range=9,мы сравним -128/-10.0=12.8 с 127/9.0=14.11,и установим масштабный_фактор=12.8 В этом случае min_range останется -10,но max_range будет скорректирован на 127/12.8=9.921875.</target>
        </trans-unit>
        <trans-unit id="50c06cd85c469bb9cf059a71d70b64caddf370b7" translate="yes" xml:space="preserve">
          <source>either a &lt;code&gt;SparseTensor&lt;/code&gt; of float / double weights, or &lt;code&gt;None&lt;/code&gt; to indicate all weights should be taken to be 1. If specified, &lt;code&gt;sp_weights&lt;/code&gt; must have exactly the same shape and indices as &lt;code&gt;sp_ids&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b12e634694dfb913a143288c69bf4f51482bf7" translate="yes" xml:space="preserve">
          <source>either a tensor, or a callable that returns a tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f0da536fdcf5aeed1617b7eb747bf19adaf302" translate="yes" xml:space="preserve">
          <source>element_shape: the shape of the future elements of the list num_elements: the number of elements to reserve handle: the output list element_dtype: the desired type of elements in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd43d4a521638a4e8365bac3cc1cc48a0bd0ff0e" translate="yes" xml:space="preserve">
          <source>ensemble.</source>
          <target state="translated">ensemble.</target>
        </trans-unit>
        <trans-unit id="6ad6e1fc248d38b0e0f2ba5255accc50e85d827d" translate="yes" xml:space="preserve">
          <source>epsilon for ZCA whitening. Default is 1e-6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f791ea4b7a318f6de4208c6fa294af266559df" translate="yes" xml:space="preserve">
          <source>errors.NotFoundError if directory doesn't exist</source>
          <target state="translated">ошибки.NotFoundError,если каталог не существует.</target>
        </trans-unit>
        <trans-unit id="8e57d2e1d7a30dcf6f17acc93e0fea68f3cb0904" translate="yes" xml:space="preserve">
          <source>errors.OpError: If there are filesystem / directory listing errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dac5a34e0b232b7c5b77788538b81d1e3545258" translate="yes" xml:space="preserve">
          <source>evaluated using Horner's method, i.e.</source>
          <target state="translated">оценивается по методу Хорнера,т.е.</target>
        </trans-unit>
        <trans-unit id="3d81dd4ac3e4f8cb89985148eca2bfcab6b1e91f" translate="yes" xml:space="preserve">
          <source>event file name pattern relative to model_dir. If None, however, the exporter would not be preemption-safe. To be preemption-safe, event_file_pattern must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5028f57b2d7a0e6b1e22f4d6a98d89d41eac9cea" translate="yes" xml:space="preserve">
          <source>execution.</source>
          <target state="translated">execution.</target>
        </trans-unit>
        <trans-unit id="95d6621d260ac7736e3a565c4519088053159865" translate="yes" xml:space="preserve">
          <source>exp(A) = \sum_{n=0}^\infty A^n/n!</source>
          <target state="translated">exp(A)=\sum_{n=0}^\infty A^n/n!</target>
        </trans-unit>
        <trans-unit id="3d4aded1d5de0cbd666e28fa14fcde0760948cbb" translate="yes" xml:space="preserve">
          <source>extend(*args, **kwargs) Overloaded function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b827c62a42434126b441f0b338eb6c48c38f3111" translate="yes" xml:space="preserve">
          <source>extend(self: tensorflow.python._tf_stack.StackSummary, L: iterable) -&amp;gt; None</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a4d944b67ec1383dbb23e2c4c6e666edfa9999" translate="yes" xml:space="preserve">
          <source>extend(self: tensorflow.python._tf_stack.StackSummary, L: tensorflow.python._tf_stack.StackSummary) -&amp;gt; None</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be23c121a9df7a920185c3e3e3af39fe5f1fca4" translate="yes" xml:space="preserve">
          <source>f(5)</source>
          <target state="translated">f(5)</target>
        </trans-unit>
        <trans-unit id="f1c7e261ba8d28d0ac5fb9d3372d158f8b3cb57d" translate="yes" xml:space="preserve">
          <source>factor by which the learning rate will be reduced. &lt;code&gt;new_lr = lr * factor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6addc9e5cd06fa0237f6aca5a29961493c810f5" translate="yes" xml:space="preserve">
          <source>features -- A &lt;a href=&quot;../../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt;. features are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e8caf51dd7197c9a1b5bf448b97201a9664c66" translate="yes" xml:space="preserve">
          <source>features -- A &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt;. features are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a305b00fb8af276dd83cbfb5435792f21c78f2" translate="yes" xml:space="preserve">
          <source>features -- A &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt;. features are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1f22c6b56ac9ca8db38696298fc39dd2c197e2" translate="yes" xml:space="preserve">
          <source>features -- A &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt;. features are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a747fda8314eecb773c1b00112b1461f66c74f2d" translate="yes" xml:space="preserve">
          <source>features: A &lt;a href=&quot;../../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt;. features are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="translated">features: &lt;a href=&quot;../../../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; или словарь имени строковой функции для &lt;code&gt;Tensor&lt;/code&gt; . функции потребляются &lt;code&gt;model_fn&lt;/code&gt; . Они должны удовлетворять ожиданиям &lt;code&gt;model_fn&lt;/code&gt; от входных данных.</target>
        </trans-unit>
        <trans-unit id="bb5783827f7821e69a871a9b65b321281d0220c9" translate="yes" xml:space="preserve">
          <source>features: A &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt;. features are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="translated">features: &lt;a href=&quot;../../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; или словарь имени строковой функции для &lt;code&gt;Tensor&lt;/code&gt; . функции потребляются &lt;code&gt;model_fn&lt;/code&gt; . Они должны удовлетворять ожиданиям &lt;code&gt;model_fn&lt;/code&gt; от входных данных.</target>
        </trans-unit>
        <trans-unit id="042dc4921c022cfaf1737bea340bf4acf986181f" translate="yes" xml:space="preserve">
          <source>features: A &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt;. features are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="translated">features: &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; или словарь имени строковой функции для &lt;code&gt;Tensor&lt;/code&gt; . функции потребляются &lt;code&gt;model_fn&lt;/code&gt; . Они должны удовлетворять ожиданиям &lt;code&gt;model_fn&lt;/code&gt; от входных данных.</target>
        </trans-unit>
        <trans-unit id="63004d39309ac253fef9ee42c74ef18a5130ca4d" translate="yes" xml:space="preserve">
          <source>features: A &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt;. features are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="translated">features: &lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; или словарь имени строковой функции для &lt;code&gt;Tensor&lt;/code&gt; . функции потребляются &lt;code&gt;model_fn&lt;/code&gt; . Они должны удовлетворять ожиданиям &lt;code&gt;model_fn&lt;/code&gt; от входных данных.</target>
        </trans-unit>
        <trans-unit id="b4f4aaa673316e77ae40eec02042b35f5fba2e91" translate="yes" xml:space="preserve">
          <source>features: Input &lt;code&gt;dict&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt; objects created by &lt;code&gt;input_fn&lt;/code&gt; which is given to &lt;code&gt;estimator.evaluate&lt;/code&gt; as an argument.</source>
          <target state="translated">Особенности: Input &lt;code&gt;dict&lt;/code&gt; из &lt;code&gt;Tensor&lt;/code&gt; объектов , созданные &lt;code&gt;input_fn&lt;/code&gt; , вверенные &lt;code&gt;estimator.evaluate&lt;/code&gt; в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="c3db266482de5f3a58e5d72b3c66aab6027f2958" translate="yes" xml:space="preserve">
          <source>fibonacci(7)</source>
          <target state="translated">fibonacci(7)</target>
        </trans-unit>
        <trans-unit id="854a1dd957af8ddf651d8b582e7ac2490fa7c7c2" translate="yes" xml:space="preserve">
          <source>filename for output, usually suffixed with .pb.gz.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a02d4079e5f47f7b4ea33cff804fafdbb823f0" translate="yes" xml:space="preserve">
          <source>finalizes the graph via &lt;code&gt;scaffold.finalize()&lt;/code&gt;</source>
          <target state="translated">завершает график через &lt;code&gt;scaffold.finalize()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1cc9148b0d49fa27fcbf8d6d90a40c6a14cbdaf" translate="yes" xml:space="preserve">
          <source>flags.FlagValues, optional FlagValues instance to validate against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c202ae164a165a34d4354679db88c91b0148f1" translate="yes" xml:space="preserve">
          <source>flags.FlagValues, optional FlagValues instance where the flag is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a912cf4d9b3fae6ab4019f86198b053d928505a" translate="yes" xml:space="preserve">
          <source>flags.FlagValues, optional FlagValues instance where the flags are defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21324a41e8c7c6c0df5c83692bc8fe1571de7320" translate="yes" xml:space="preserve">
          <source>flags.declare_key_flag('flag_1')</source>
          <target state="translated">flags.declare_key_flag('flag_1')</target>
        </trans-unit>
        <trans-unit id="b28fff9022895ace0bdda576bbec4b298eee46cb" translate="yes" xml:space="preserve">
          <source>flat sequence to pack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410541f084d299db3dba6c1daa1bc6af5ddc7b8d" translate="yes" xml:space="preserve">
          <source>float (0, 1], fraction of size to crop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f8fb487613cc49a4c66db414f2c8a1e2a246a4" translate="yes" xml:space="preserve">
          <source>float Mean accuracy of predictions on &lt;code&gt;x&lt;/code&gt; wrt. &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7e908d4b493759f580d5aad152b7e9ab8a005f" translate="yes" xml:space="preserve">
          <source>float between 0 and 1. Error bound for quantile computation. This is only used for float feature columns, and the number of buckets generated per float feature is &lt;code&gt;1/quantile_sketch_epsilon&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289b000636c76a7b39b225d249643377b5520906" translate="yes" xml:space="preserve">
          <source>float hyperparameter &amp;gt;= 0 that accelerates gradient descent in the relevant direction and dampens oscillations. Defaults to 0, i.e., vanilla gradient descent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891dd654f370b000f1841e130772a6977bd454af" translate="yes" xml:space="preserve">
          <source>float, The bias added to forget gates (see above). Must set to &lt;code&gt;0.0&lt;/code&gt; manually when restoring from CudnnLSTM-trained checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40717971f035b74660c4ebcc7ad068718396ec9" translate="yes" xml:space="preserve">
          <source>float, drop probability (as with &lt;code&gt;Dropout&lt;/code&gt;). The multiplicative noise will have standard deviation &lt;code&gt;sqrt(rate / (1 - rate))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3b0955ef6c01fba7e4470066ff67d767469ae4" translate="yes" xml:space="preserve">
          <source>float, max value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5fccb92686be4282f47743767ee6fbb47ebf8a5" translate="yes" xml:space="preserve">
          <source>float, max values of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6187bc778da4a03d37f47c235705f8c3f0ce4356" translate="yes" xml:space="preserve">
          <source>float, min value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a86ebabfe11520e5228df4e7c471d7f95d4edb0" translate="yes" xml:space="preserve">
          <source>float, min values of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ba04b0a464d79ec1f42274df0154e4b9d1fc86" translate="yes" xml:space="preserve">
          <source>float, must be non-negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1acb9e7f220e64ee74acee8622c40e86cf10dd92" translate="yes" xml:space="preserve">
          <source>float. Factor to multiply the saturation by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10c89804f82ec9e6d2bab95a706003af6bcef99" translate="yes" xml:space="preserve">
          <source>float. How much to add to the hue channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afc02da3b840c5bfe9db7bd3749e018f67c8e2c" translate="yes" xml:space="preserve">
          <source>float. Lower bound for the random contrast factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398618e1a19031d017f22d3a4d8f0cba07fe61ac" translate="yes" xml:space="preserve">
          <source>float. Lower bound for the random saturation factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7bed3d3bbe6d376da23105607ea0e8e3c0a95a" translate="yes" xml:space="preserve">
          <source>float. New value of epsilon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7274792093f92a6164163de0f1ba5d539f3fe6b" translate="yes" xml:space="preserve">
          <source>float. Saturation threshold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf2cb1570e369110805a60c07f8011360c358c5" translate="yes" xml:space="preserve">
          <source>float. The maximum value for the random delta.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd097dbe88b61988c7021143adabe5c2fbf939d0" translate="yes" xml:space="preserve">
          <source>float. Threshold value for thresholded activation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7c7815aa363e6a58a5e9c1e3cd266905a0f0b1" translate="yes" xml:space="preserve">
          <source>float. Upper bound for the random contrast factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a7ba4433c59efbfc7bc6af3d1652cbc74eb8ee8" translate="yes" xml:space="preserve">
          <source>float. Upper bound for the random saturation factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d672077bfe52307086791b4fa3a011645d528b96" translate="yes" xml:space="preserve">
          <source>float: fraction of total height, if &amp;lt; 1, or pixels if &amp;gt;= 1.</source>
          <target state="translated">float: доля общей высоты, если &amp;lt;1, или пикселей, если&amp;gt; = 1.</target>
        </trans-unit>
        <trans-unit id="89c144a1c987c2122f2afa4cff925295efa2d190" translate="yes" xml:space="preserve">
          <source>float: fraction of total width, if &amp;lt; 1, or pixels if &amp;gt;= 1.</source>
          <target state="translated">float: доля общей ширины, если &amp;lt;1, или пикселей, если&amp;gt; = 1.</target>
        </trans-unit>
        <trans-unit id="4a20898337d5d9ae315ef97bc91cb664488d6d8d" translate="yes" xml:space="preserve">
          <source>float|str|None, the default value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2c4bd11f2a8bd9b01987ce0e2c5fb673c42266" translate="yes" xml:space="preserve">
          <source>flush mode or &lt;code&gt;None&lt;/code&gt;, Default: Z_NO_FLUSH.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7cfde982d3bb21c7a417aed9f324f3029dfdfc2" translate="yes" xml:space="preserve">
          <source>foldl on the list of tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0.</source>
          <target state="translated">foldl в списке тензоров, распакованных из &lt;code&gt;elems&lt;/code&gt; размерности 0.</target>
        </trans-unit>
        <trans-unit id="5ae9088c58482e054a830d160dd40ad4dd25dae1" translate="yes" xml:space="preserve">
          <source>foldl on the list of tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0. (deprecated argument values)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf5c450b886f3aee9cc8558fb3938e2df5dacb6" translate="yes" xml:space="preserve">
          <source>foldr on the list of tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0.</source>
          <target state="translated">foldr в списке тензоров, распакованных из &lt;code&gt;elems&lt;/code&gt; размерности 0.</target>
        </trans-unit>
        <trans-unit id="96e6609560ed49ee030240dacf927099d9963849" translate="yes" xml:space="preserve">
          <source>foldr on the list of tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0. (deprecated argument values)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5573bd57b060626331210e8deaa0453f09f671c" translate="yes" xml:space="preserve">
          <source>follows the same semantics as python's xrange. len(args) == 1 -&amp;gt; start = 0, stop = args[0], step = 1. len(args) == 2 -&amp;gt; start = args[0], stop = args[1], step = 1. len(args) == 3 -&amp;gt; start = args[0], stop = args[1], step = args[2].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d719c6036135c155db1d621534ac4230131af3" translate="yes" xml:space="preserve">
          <source>foo = tf.constant([-10, -5, 0.0, 5, 10], dtype = tf.float32) tf.keras.activations.relu(foo).numpy() array([ 0., 0., 0., 5., 10.], dtype=float32) tf.keras.activations.relu(foo, alpha=0.5).numpy() array([-5. , -2.5, 0. , 5. , 10. ], dtype=float32) tf.keras.activations.relu(foo, max_value=5).numpy() array([0., 0., 0., 5., 5.], dtype=float32) tf.keras.activations.relu(foo, threshold=5).numpy() array([-0., -0., 0., 0., 10.], dtype=float32)</source>
          <target state="translated">foo=tf.constant([-10,-5,0.0,5,10],dtype=tf.float32)tf.keras.activations.relu(foo).numpy()array([0.,0.,0.,5.,10.],dtype=float32)tf.keras.activations.relu(foo,alpha=0.5).numpy()array([-5.,-2.5,0.,5.,10.],dtype=float32)tf.keras.activations.relu(foo,max_value=5).numpy()array([0.,0.,0.,5.,5.],dtype=float32)tf.keras.activations.relu(foo,threshold=5).numpy()array([-0.,-0.,0.,0.,10.],dtype=float32)</target>
        </trans-unit>
        <trans-unit id="26684b5fbd438feeadfc452c221391744e097dff" translate="yes" xml:space="preserve">
          <source>for details. For an example of utilizing this attribute see this &lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.cc&quot;&gt;example&lt;/a&gt; The code above automatically detects and substitutes function that implements &quot;embedded_matmul&quot; and allows TFLite to substitute its own implementations. For instance, a tensorflow user can use this attribute to mark that their function also implements &lt;code&gt;embedded_matmul&lt;/code&gt; (perhaps more efficiently!) by specifying it using this parameter: &lt;code&gt;@tf.function(experimental_implements=&quot;embedded_matmul&quot;)&lt;/code&gt; This can either be specified as just the string name of the function or a NameAttrList corresponding to a list of key-value attributes associated with the function name. The name of the function will be in the 'name' field of the NameAttrList.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2a3ecfed7ec15e6f256b3268387743a7d39f71" translate="yes" xml:space="preserve">
          <source>for each &lt;code&gt;column&lt;/code&gt; in &lt;code&gt;context_feature_columns&lt;/code&gt;:</source>
          <target state="translated">для каждого &lt;code&gt;column&lt;/code&gt; в &lt;code&gt;context_feature_columns&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c2838a9979a6d44c333fc536508bf80fd9c268f0" translate="yes" xml:space="preserve">
          <source>for each &lt;code&gt;column&lt;/code&gt; in &lt;code&gt;dnn_feature_columns&lt;/code&gt; + &lt;code&gt;linear_feature_columns&lt;/code&gt;:</source>
          <target state="translated">для каждого &lt;code&gt;column&lt;/code&gt; в &lt;code&gt;dnn_feature_columns&lt;/code&gt; + &lt;code&gt;linear_feature_columns&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7a577528de83e53a337075075c6a83fd4deb27ab" translate="yes" xml:space="preserve">
          <source>for each &lt;code&gt;column&lt;/code&gt; in &lt;code&gt;feature_columns&lt;/code&gt;:</source>
          <target state="translated">для каждого &lt;code&gt;column&lt;/code&gt; в &lt;code&gt;feature_columns&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="041e2897f9d31acbc6eaa576e6ce502753484251" translate="yes" xml:space="preserve">
          <source>for each &lt;code&gt;column&lt;/code&gt; in &lt;code&gt;sequence_feature_columns&lt;/code&gt;:</source>
          <target state="translated">для каждого &lt;code&gt;column&lt;/code&gt; в &lt;code&gt;sequence_feature_columns&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="599322720e847ecd593ecf6d2271659ede3d33dd" translate="yes" xml:space="preserve">
          <source>for more details on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85e69dca6e6675f3ba8c4df79dbb1db28116007" translate="yes" xml:space="preserve">
          <source>for simple batch normalization pass &lt;code&gt;axes=[0]&lt;/code&gt; (batch only).</source>
          <target state="translated">для простой пакетной нормализации проход &lt;code&gt;axes=[0]&lt;/code&gt; (только пакет).</target>
        </trans-unit>
        <trans-unit id="d5505d86ad1685caa0fd04e3cd0ef935afd88aea" translate="yes" xml:space="preserve">
          <source>for so-called &quot;global normalization&quot;, used with convolutional filters with shape &lt;code&gt;[batch, height, width, depth]&lt;/code&gt;, pass &lt;code&gt;axes=[0, 1, 2]&lt;/code&gt;.</source>
          <target state="translated">для так называемой &amp;laquo;глобальной нормализации&amp;raquo;, используемой со сверточными фильтрами с формой &lt;code&gt;[batch, height, width, depth]&lt;/code&gt; , &lt;code&gt;axes=[0, 1, 2]&lt;/code&gt; прохода = [0, 1, 2] .</target>
        </trans-unit>
        <trans-unit id="976c61b9a4f0a18c8974343e91d24cfb1307a0b2" translate="yes" xml:space="preserve">
          <source>fraction of the data to reserve as test set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93df90c0f28ecbe9a301f223299e27108a1a2b12" translate="yes" xml:space="preserve">
          <source>fraction of the entries in the tensor that will be set to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee4662958f0734a4fd9d8e145dd93e6c5dca53b" translate="yes" xml:space="preserve">
          <source>frequency (in epochs) at which embedding layers will be visualized. If set to 0, embeddings won't be visualized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2f4be1a75d1d83eec4511380362df26419773d" translate="yes" xml:space="preserve">
          <source>frequency (in epochs) at which selected embedding layers will be saved. If set to 0, embeddings won't be computed. Data to be visualized in TensorBoard's Embedding tab must be passed as &lt;code&gt;embeddings_data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103b178628f2fc6649f276d99a4ca431edbcc056" translate="yes" xml:space="preserve">
          <source>frequency (in epochs) at which to compute activation and weight histograms for the layers of the model. If set to 0, histograms won't be computed. Validation data (or split) must be specified for histogram visualizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a46a9ae6a8920d757c69f89d66a353e1493ae0" translate="yes" xml:space="preserve">
          <source>from &lt;code&gt;updates&lt;/code&gt; according to indices &lt;code&gt;indices&lt;/code&gt;. The updates are non-aliasing: &lt;code&gt;input&lt;/code&gt; is only modified in-place if no other operations will use it. Otherwise, a copy of &lt;code&gt;input&lt;/code&gt; is made. This operation has a gradient with respect to both &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;updates&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ccfce04c7ee64f088843c6af5489db41451f05a" translate="yes" xml:space="preserve">
          <source>from tensorflow.keras import backend as K kvar = K.variable(np.random.random((2,3))) kvar_zeros = K.zeros_like(kvar) K.eval(kvar_zeros)</source>
          <target state="translated">из tensorflow.keras импортировать бэкэнд как K kvar=K.variable(np.random.random((2,3)))kvar_zeros=K.zeros_like(kvar)K.eval(kvar_zeros)</target>
        </trans-unit>
        <trans-unit id="9df1da832177ed8791c7a5e33cfb39e054897e71" translate="yes" xml:space="preserve">
          <source>from tensorflow_estimator.python.estimator.canned import head_lib</source>
          <target state="translated">из tensorflow_estimator.python.estimatedator.canned import head_lib</target>
        </trans-unit>
        <trans-unit id="682c0799b9f3d14676439dea32a9bde1e5fda225" translate="yes" xml:space="preserve">
          <source>from the underlying container. If the underlying container does not contain elements, the op will block until it does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c680d0fc5b5759e6281c3eff2dbafab6351abeb" translate="yes" xml:space="preserve">
          <source>from the underlying container. If the underlying container does not contain this key, the op will block until it does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d343a1928d49bdc2a15f8fa68752564955bbde8" translate="yes" xml:space="preserve">
          <source>full_matrices is &lt;code&gt;False&lt;/code&gt; by default as opposed to &lt;code&gt;True&lt;/code&gt; for numpy.linalg.svd.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8510b934f74662730c458c176d82cae8ae0ebaaa" translate="yes" xml:space="preserve">
          <source>full_name</source>
          <target state="translated">full_name</target>
        </trans-unit>
        <trans-unit id="13ba475db05aba9651e3af08cae2330ec1a9d2d1" translate="yes" xml:space="preserve">
          <source>full_shape</source>
          <target state="translated">full_shape</target>
        </trans-unit>
        <trans-unit id="55f84871575834632002a87d348e344bb912df5d" translate="yes" xml:space="preserve">
          <source>function &lt;code&gt;f(*x)&lt;/code&gt; that returns a &lt;code&gt;Tensor&lt;/code&gt; or nested structure of &lt;code&gt;Tensor&lt;/code&gt; outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2e14a58235426032613606dd226ceb97c5fbdc" translate="yes" xml:space="preserve">
          <source>function &lt;code&gt;f(*x)&lt;/code&gt; that returns a &lt;code&gt;Tensor&lt;/code&gt; or sequence of &lt;code&gt;Tensor&lt;/code&gt; outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4eda67c536bfa83231c66461c58ff116765aae" translate="yes" xml:space="preserve">
          <source>function &lt;code&gt;f(*x)&lt;/code&gt; that returns a tuple &lt;code&gt;(y, grad_fn)&lt;/code&gt; where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d40a025861c98c91dbce826a0076b5115db3407" translate="yes" xml:space="preserve">
          <source>function from element in &lt;code&gt;Dataset&lt;/code&gt; to &lt;a href=&quot;../../../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt;, determines the length of the element, which will determine the bucket it goes into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378f5fcadde0ec3c67542cd6d10ef8457b80efa3" translate="yes" xml:space="preserve">
          <source>function instead.</source>
          <target state="translated">функционировать вместо этого.</target>
        </trans-unit>
        <trans-unit id="ae2da4e924cba3702fc537fd5796aea356dd936b" translate="yes" xml:space="preserve">
          <source>function that takes no arguments and returns &lt;code&gt;dict&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt; to feed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdaf5b8c3eb9b9e3e5d0afbb59d5212f74112596" translate="yes" xml:space="preserve">
          <source>function that will be applied on each input. The function will run after the image is resized and augmented. The function should take one argument: one image (Numpy tensor with rank 3), and should output a Numpy tensor with the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1106943b9b989d3472362a06c7b453859360b0df" translate="yes" xml:space="preserve">
          <source>function to be called on data when retrieved</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e025c034a0af8a17c40cb72683231f0de5bae27" translate="yes" xml:space="preserve">
          <source>function to decorate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73de7ba746e1fef01fb02401e4e7e63a367e4271" translate="yes" xml:space="preserve">
          <source>function to run (will be run once per replica).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f29f23d5a2076e3bfeb081d14d52e6550f9cef" translate="yes" xml:space="preserve">
          <source>function to run using this distribution strategy. The function must have the following signature: &lt;code&gt;def fn(context, inputs)&lt;/code&gt;. &lt;code&gt;context&lt;/code&gt; is an instance of &lt;code&gt;MultiStepContext&lt;/code&gt; that will be passed when &lt;code&gt;fn&lt;/code&gt; is run. &lt;code&gt;context&lt;/code&gt; can be used to specify the outputs to be returned from &lt;code&gt;fn&lt;/code&gt; by calling &lt;code&gt;context.set_last_step_output&lt;/code&gt;. It can also be used to capture non tensor outputs by &lt;code&gt;context.set_non_tensor_output&lt;/code&gt;. See &lt;code&gt;MultiStepContext&lt;/code&gt; documentation for more information. &lt;code&gt;inputs&lt;/code&gt; will have same type/structure as &lt;code&gt;iterator.get_next()&lt;/code&gt;. Typically, &lt;code&gt;fn&lt;/code&gt; will use &lt;code&gt;call_for_each_replica&lt;/code&gt; method of the strategy to distribute the computation over multiple replicas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1e0f1c394c16cbcc852d4aa04cc1c40e2e4b2d" translate="yes" xml:space="preserve">
          <source>function, takes dict of &lt;code&gt;tag&lt;/code&gt;-&amp;gt;&lt;code&gt;Tensor&lt;/code&gt; and returns a string. If &lt;code&gt;None&lt;/code&gt; uses default printing all tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee17ed0fabb2d60e80b358ab2dad1ea5fa7ac858" translate="yes" xml:space="preserve">
          <source>function_optimization: Function optimizations and inlining.</source>
          <target state="translated">function_optimization:Оптимизация функций и встраивание.</target>
        </trans-unit>
        <trans-unit id="2f887def33825e52ffbcca83446cfd6a6f676ff7" translate="yes" xml:space="preserve">
          <source>functions</source>
          <target state="translated">functions</target>
        </trans-unit>
        <trans-unit id="b5f8958fb679f9f8ba50d130439f062c03ae13f7" translate="yes" xml:space="preserve">
          <source>gRPC address of profiler service e.g. grpc://10.0.0.2:8466.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc6880783358cbf27991207173a5135c9fafe63" translate="yes" xml:space="preserve">
          <source>gRPC address of profiler service e.g. grpc://localhost:6009.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f16d773b0e7b57b490982fcd1183f6be6cef7c" translate="yes" xml:space="preserve">
          <source>gamma: \(r \dot M \dot r\), equivalent to \(||r||_2^2\) when &lt;code&gt;preconditioner=None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7daa598ab5e37c9b5eda2a3430f7630440c55daa" translate="yes" xml:space="preserve">
          <source>get_config (serialization of the optimizer, include all hyper parameters)</source>
          <target state="translated">get_config (сериализация оптимизатора,включать все гиперпараметры)</target>
        </trans-unit>
        <trans-unit id="4e6bf3184c3fa062bf1aec2fe07d14c139ce7062" translate="yes" xml:space="preserve">
          <source>grad_with_shrinkage = grad + 2 * l2_shrinkage * var accum_new = accum + grad * grad linear += grad_with_shrinkage - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2 var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0 accum = accum_new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6d2bab97d704731db0d4f399c289f787b8e1c5" translate="yes" xml:space="preserve">
          <source>grad_with_shrinkage = grad + 2 * l2_shrinkage * var accum_new = accum + grad_with_shrinkage * grad_with_shrinkage linear += grad_with_shrinkage + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2 var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0 accum = accum_new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a4af1d55cff81c76113bbf327008f090d6646e" translate="yes" xml:space="preserve">
          <source>gradient is evaluated at theta(t) + momentum * v(t), and the variables always store theta + beta_1 * m / sqrt(v) instead of theta.</source>
          <target state="translated">градиент оценивается при тета(t)+импульс*v(t),а переменные всегда хранят тета+бета_1*m/sqrt(v)вместо тета.</target>
        </trans-unit>
        <trans-unit id="d611d54da5aeaa48a0e015b453398ac2e1866114" translate="yes" xml:space="preserve">
          <source>group_assignment=&lt;code&gt;[[0, 1]]&lt;/code&gt; concat_dimension=0 split_dimension=1 split_count=2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5ce99db1470d28e8a82067f33bf8b8de324111" translate="yes" xml:space="preserve">
          <source>handle: an empty tensor list. element_dtype: the type of elements in the list. element_shape: a shape compatible with that of elements in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7a47755d59da94be35e420e8ba81d7781e798a" translate="yes" xml:space="preserve">
          <source>head = head_lib._regression_head(label_dimension=1) est = boosted_trees.BoostedTreesEstimator( feature_columns=..., n_batches_per_layer=..., head=head, n_trees=..., max_depth=...)</source>
          <target state="translated">head=head_lib._regression_head(label_dimension=1)est=boosted_trees.BoostedTreesEstimator(feature_columns=...,n_batches_per_layer=...,head=head,n_trees=...,max_depth=...)</target>
        </trans-unit>
        <trans-unit id="b4fa3a726c19c0dd6d89ad5febf4f1a9366b2df8" translate="yes" xml:space="preserve">
          <source>height_pad = pad_top + height + pad_bottom width_pad = pad_left + width + pad_right</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80097e068e45b969c07f48907945f1be4890875a" translate="yes" xml:space="preserve">
          <source>here &lt;code&gt;range(T) = numeric_limits&amp;lt;T&amp;gt;::max() - numeric_limits&amp;lt;T&amp;gt;::min()&lt;/code&gt;</source>
          <target state="translated">здесь &lt;code&gt;range(T) = numeric_limits&amp;lt;T&amp;gt;::max() - numeric_limits&amp;lt;T&amp;gt;::min()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="936b7ec6322f6e9d6b2d036d56bb9dcf9196fca0" translate="yes" xml:space="preserve">
          <source>i.e. &lt;code&gt;exp(x) - 1&lt;/code&gt; or &lt;code&gt;e^(x) - 1&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the input tensor. &lt;code&gt;e&lt;/code&gt; denotes Euler's number and is approximately equal to 2.718281.</source>
          <target state="translated">т.е. &lt;code&gt;exp(x) - 1&lt;/code&gt; или &lt;code&gt;e^(x) - 1&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; - входной тензор. &lt;code&gt;e&lt;/code&gt; обозначает число Эйлера и приблизительно равно 2,718281.</target>
        </trans-unit>
        <trans-unit id="dc140fb76e1faac0b793384a20cfeac02c62b8a8" translate="yes" xml:space="preserve">
          <source>i: A scalar &lt;code&gt;int32&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;. Number of iterations executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581901332b2eef5c6274605c4b47c7e9909171f4" translate="yes" xml:space="preserve">
          <source>idx: a tensor with a shape of [..., num_boxes] representing the indices selected by non-max suppression. The leadign dimensions are the batch dimensions of the input boxes. All numbers are are within [0, num_boxes). For each image (i.e., idx[i]), only the first num_valid[i] indices (i.e., idx[i][:num_valid[i]]) are valid. num_valid: a tensor of rank 0 or higher with a shape of [...] representing the number of valid indices in idx. Its dimensions are the batch dimensions of the input boxes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e29791878048667885d8ab4512f563fbed880b90" translate="yes" xml:space="preserve">
          <source>if &amp;lt; 0, &lt;code&gt;scale * features&lt;/code&gt; otherwise.</source>
          <target state="translated">если &amp;lt;0, &lt;code&gt;scale * features&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="4353c042c631b635db35214584bb615212de71e1" translate="yes" xml:space="preserve">
          <source>if 'shuffle' is not provided or a bool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e341f2228bb6e90146980eac45af1f5ffa0287" translate="yes" xml:space="preserve">
          <source>if 'summary' is not a Summary proto or a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c55c208ccbce987d24f14a7210af9603812cd0" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;AbortedError&lt;/code&gt; or &lt;code&gt;UnavailableError&lt;/code&gt; occurs, it recovers or reinitializes the session before executing the run() call again</source>
          <target state="translated">если происходит &lt;code&gt;AbortedError&lt;/code&gt; или &lt;code&gt;UnavailableError&lt;/code&gt; , он восстанавливает или повторно инициализирует сеанс перед повторным выполнением вызова run ()</target>
        </trans-unit>
        <trans-unit id="d8f3f78eecaa06f17bf4bd9b53e80f8d3efc2cb6" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;True&lt;/code&gt;, use a faster, fused implementation if possible. If &lt;code&gt;False&lt;/code&gt;, use the system recommended implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c46c3a2128f2bb72d6821a9614288d21d18f642" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;True&lt;/code&gt; (default) types of sequences are checked as well, including the keys of dictionaries. If set to &lt;code&gt;False&lt;/code&gt;, for example a list and a tuple of objects will look the same if they have the same size. Note that namedtuples with identical name and fields are always considered to have the same shallow structure. Two types will also be considered the same if they are both list subtypes (which allows &quot;list&quot; and &quot;_ListWrapper&quot; from trackable dependency tracking to compare equal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c7dc99d422ebd0cf84dcaff060aa6b5eb72e3c" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;True&lt;/code&gt;, attempt to statically determine the shape of &lt;code&gt;tensor&lt;/code&gt; and encode it as a constant. (optional, defaults to &lt;code&gt;True&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a981e44fa02edb4cb33121c37d939dfa65356116" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;True&lt;/code&gt;, use a faster, fused implementation, or raise a ValueError if the fused implementation cannot be used. If &lt;code&gt;None&lt;/code&gt;, use the faster implementation if possible. If False, do not used the fused implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba0b2cb6429da38c0d59b5ecd1d8ae4cadf64aa" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;axis == 0&lt;/code&gt; then the &lt;code&gt;output&lt;/code&gt; tensor will have the shape &lt;code&gt;(N, A, B, C)&lt;/code&gt;. if &lt;code&gt;axis == 1&lt;/code&gt; then the &lt;code&gt;output&lt;/code&gt; tensor will have the shape &lt;code&gt;(A, N, B, C)&lt;/code&gt;. Etc.</source>
          <target state="translated">если &lt;code&gt;axis == 0&lt;/code&gt; , то &lt;code&gt;output&lt;/code&gt; тензор будет иметь форму &lt;code&gt;(N, A, B, C)&lt;/code&gt; . если &lt;code&gt;axis == 1&lt;/code&gt; , то &lt;code&gt;output&lt;/code&gt; тензор будет иметь вид &lt;code&gt;(A, N, B, C)&lt;/code&gt; . И т.п.</target>
        </trans-unit>
        <trans-unit id="38cbdb320f52412dedb741520e5c416a05817c41" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;axis&lt;/code&gt; is neither -1 nor one of the axes of &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d874d1cf7b89f2f2c7ce20ccd10bf6c9caa80a" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;axis&lt;/code&gt;=None, per-tensor quantization is performed as normal.</source>
          <target state="translated">если &lt;code&gt;axis&lt;/code&gt; = None, тензорное квантование выполняется как обычно.</target>
        </trans-unit>
        <trans-unit id="868b7e555aad80f665a5e4521c7b7c6f09ccb132" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;cell&lt;/code&gt; is not an &lt;code&gt;RNNCell&lt;/code&gt;, or &lt;code&gt;keep_state_fn&lt;/code&gt; is provided but not &lt;code&gt;callable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51f399972a655871ebaa4aeab16633554f20eff" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;classifier_activation&lt;/code&gt; is not &lt;code&gt;softmax&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; when using a pretrained top layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e153f3ef7fba2ac99990bf03a0926b92bd558d9b" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;color_mode&lt;/code&gt; is &lt;code&gt;grayscale&lt;/code&gt;, there's 1 channel in the image tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae6f2de8a38ba3f257dba67c1ffb9b16ef52a55" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;color_mode&lt;/code&gt; is &lt;code&gt;rgb&lt;/code&gt;, there are 3 channel in the image tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d264f81bc00f53fe943025c90e31a7791d2a3d6" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;color_mode&lt;/code&gt; is &lt;code&gt;rgba&lt;/code&gt;, there are 4 channel in the image tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af843a4d564fe1883b1af206a31294b3df249fc" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;column&lt;/code&gt; is a &lt;code&gt;CategoricalColumn&lt;/code&gt;, a feature with &lt;code&gt;key=column.name&lt;/code&gt; whose &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;column&lt;/code&gt; является &lt;code&gt;CategoricalColumn&lt;/code&gt; столбцом , функция с &lt;code&gt;key=column.name&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; которого является &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4bea04012338785875d8e879d50703a0721e107" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;column&lt;/code&gt; is a &lt;code&gt;DenseColumn&lt;/code&gt;, a feature with &lt;code&gt;key=column.name&lt;/code&gt; whose &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;column&lt;/code&gt; является &lt;code&gt;DenseColumn&lt;/code&gt; , функция с &lt;code&gt;key=column.name&lt;/code&gt; , чье &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b50fbd504730c8c0ab1d9f44dbe776c2995b91df" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;column&lt;/code&gt; is a &lt;code&gt;RealValuedColumn&lt;/code&gt;, a feature with &lt;code&gt;key=column.name&lt;/code&gt; whose &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;column&lt;/code&gt; является &lt;code&gt;RealValuedColumn&lt;/code&gt; , функция с &lt;code&gt;key=column.name&lt;/code&gt; которого &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93cc00148e12371b1e41cb97a0738d42b3ab099d" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;column&lt;/code&gt; is a &lt;code&gt;SparseColumn&lt;/code&gt;, a feature with &lt;code&gt;key=column.name&lt;/code&gt; whose &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;column&lt;/code&gt; является &lt;code&gt;SparseColumn&lt;/code&gt; , функция с &lt;code&gt;key=column.name&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; которого является &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3308287f5f98b2793cb3552ce59e4ee239d058a0" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;column&lt;/code&gt; is a &lt;code&gt;WeightedCategoricalColumn&lt;/code&gt;, two features: the first with &lt;code&gt;key&lt;/code&gt; the id column name, the second with &lt;code&gt;key&lt;/code&gt; the weight column name. Both features' &lt;code&gt;value&lt;/code&gt; must be a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;column&lt;/code&gt; является &lt;code&gt;WeightedCategoricalColumn&lt;/code&gt; , две функции: первая с &lt;code&gt;key&lt;/code&gt; имя столбца идентификатора, вторая с &lt;code&gt;key&lt;/code&gt; имя столбца веса. &lt;code&gt;value&lt;/code&gt; обеих функций должно быть &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a9c533761ac9bb527388d7229c3fc93bb96102d" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;column&lt;/code&gt; is a &lt;code&gt;WeightedSparseColumn&lt;/code&gt;, two features: the first with &lt;code&gt;key&lt;/code&gt; the id column name, the second with &lt;code&gt;key&lt;/code&gt; the weight column name. Both features' &lt;code&gt;value&lt;/code&gt; must be a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;column&lt;/code&gt; является &lt;code&gt;WeightedSparseColumn&lt;/code&gt; , две функции: первая с &lt;code&gt;key&lt;/code&gt; имя столбца идентификатора, вторая с &lt;code&gt;key&lt;/code&gt; имя столбца веса. &lt;code&gt;value&lt;/code&gt; обеих функций должно быть &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d52eb784c5b589475c3f305395c84663ca2bcc5" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;combiner&lt;/code&gt; is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dc267aceef8cc3ff2d041b3e697ff84cfebf3b7" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;concentration&lt;/code&gt; and &lt;code&gt;rate&lt;/code&gt; are different dtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57dd37de43e5ef2c02857c7d1ddb565adba8640" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;cond&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; is not callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348c949caa7dc9616e318847da41304aec10815c" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;config&lt;/code&gt; is not a dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0afe6ba367c1b77f21551c87776be738618e1625" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;data&lt;/code&gt; is not a Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e457595b54f9cd56f854575b5c760fd5006f7f5" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;data_format&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b0799268a954ed01c8e8530f4f6641efcd6248" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;data_format&lt;/code&gt; is neither &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; or &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e135f56d3fe04007f8445cc2e4133ef096d8bec0" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;data_format&lt;/code&gt; is neither &lt;code&gt;channels_last&lt;/code&gt; or &lt;code&gt;channels_first&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacdd9438bcc51c71d8e191d05f7b07b689d0721" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;dataset&lt;/code&gt; is not a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object. InvalidArgumentError (at runtime): if &lt;code&gt;dataset&lt;/code&gt; does not contain exactly one element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebb14aad472934d8e90e60e8ea838283176427a" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;default_name&lt;/code&gt; is passed in but not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a8445481f5b177a7ef2d604ca93b5afaf393da" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;default_value&lt;/code&gt; is an iterable but not compatible with &lt;code&gt;shape&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fdf4926b1223468527ceb4f4ad7e7f9a852676" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;default_value&lt;/code&gt; is not compatible with &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb832932482c8e11690c4740cc00095fcaa206b5" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;default_value&lt;/code&gt; is not in range &lt;code&gt;[0, num_buckets)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c6f689ec3e855cd60a53e924082cb456502319" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;dim&lt;/code&gt; is not a positive integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c39f35150d3214dd65b57baaab967a6e347006" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;dimension&lt;/code&gt; not &amp;gt; 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43cb0d42fd69e8dbef39569fe3cdef9eb654a5c5" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;dtype&lt;/code&gt; is not convertible to &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c9bdbd33b5f1144a96725b2f72a15576240de3" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;dtype&lt;/code&gt; is not convertible to float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d850c32854ffb080a8430007c173b77b7bd797be" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;dtype&lt;/code&gt; is not integer or string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be214f20ddffba44e8023a9b970abf68d90959da" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;embedding_weights&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2aa03dc5bf1e86835a1deba6439352b4803dcb" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;every_n_iter&lt;/code&gt; is non-positive or it's not a single machine training</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4a38351c257c30366dcf68129b35c3a0e82542" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;every_n_iter&lt;/code&gt; is non-positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7dc3a6f6fc2238c0bd84bf66fdfaec1b78bf443" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;fn&lt;/code&gt; calls &lt;code&gt;get_replica_context().merge_call(merge_fn, ...)&lt;/code&gt;, then inside &lt;code&gt;merge_fn&lt;/code&gt; you are back in the cross-replica context (and again this function will return &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">если &lt;code&gt;fn&lt;/code&gt; вызывает &lt;code&gt;get_replica_context().merge_call(merge_fn, ...)&lt;/code&gt; , то внутри &lt;code&gt;merge_fn&lt;/code&gt; вы вернетесь в контекст кросс-реплик (и снова эта функция вернет &lt;code&gt;None&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e9a06a4ec17bb5aa5790357002b5c1288c3fda95" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;fn&lt;/code&gt; is not callable or the structure of the output of &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;fn_output_signature&lt;/code&gt; do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c608c59d84a95bbdaf71f2e72eebf57cce48bd1e" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;fn&lt;/code&gt; is not callable or the structure of the output of &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;initializer&lt;/code&gt; do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c98fdf1711815995b3a2380bfae83a06deb70069" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;fn&lt;/code&gt; is not callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd9f4e9b540943d60489cf6ca2642a9a84b9b3a" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;global_batch_size&lt;/code&gt; not divisible by &lt;code&gt;num_replicas_in_sync&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21dcbedc9e9ab0f0d26bbbcb697f061285ae7ea" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;global_step&lt;/code&gt; is not supplied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14734d6f77543745d89bb57b6eb9d54809519d8" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;greedy&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, how many of the most probable paths will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ab0a8361fa7b7c5e7bb0db038f711984c8666f" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;greedy&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;: a beam search decoder will be used with a beam of this width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5cc07ee3175a1a8b3736a2dcccc9db96d335ca" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;initializer&lt;/code&gt; is specified and is not callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a513d5dfbf320dbc246fea9862d888c5d2e081f" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;initializer&lt;/code&gt; is specified but not callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0287002978519ec0bfe37c7fb60e84d92f86068" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;label_mode&lt;/code&gt; is &lt;code&gt;binary&lt;/code&gt;, the labels are a &lt;code&gt;float32&lt;/code&gt; tensor of 1s and 0s of shape &lt;code&gt;(batch_size, 1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4ce59ca049951bada912433390827d3cf9d560" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;label_mode&lt;/code&gt; is &lt;code&gt;categorial&lt;/code&gt;, the labels are a &lt;code&gt;float32&lt;/code&gt; tensor of shape &lt;code&gt;(batch_size, num_classes)&lt;/code&gt;, representing a one-hot encoding of the class index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2272d7e112e0261e179bf7374b018221b7c8a541" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;label_mode&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;, the labels are an &lt;code&gt;int32&lt;/code&gt; tensor of shape &lt;code&gt;(batch_size,)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21909dcf08c96dbfcc7341c1b8531784f1efbfd9" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;len(bucket_batch_sizes) != len(bucket_boundaries) + 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377ac3c86ba3bc384c70c90aab957396e85ec5c9" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are of different dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2297ed6e9936b63bfff9054abb0d8e36fee996" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; have different &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721d9f2a62d8f2e037038b3d70d21e12cad41e5a" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;logits&lt;/code&gt; is empty or &lt;code&gt;axis&lt;/code&gt; is beyond the last dimension of &lt;code&gt;logits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6891640bde189cf5891869f9c93b08f361050b" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;loop_vars&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93af595c76c1fe8ed0daa8d09c71b22688b6a21d" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;losses&lt;/code&gt; is not iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86fbb355bd30672634e239b7f405fc21055741c2" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;low &amp;gt;= high&lt;/code&gt; and &lt;code&gt;validate_args=False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6c81b3fe6b10d78539b22969829c7733e29d75" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;mask&lt;/code&gt; is provided (not &lt;code&gt;None&lt;/code&gt;) but states is not provided (&lt;code&gt;len(states)&lt;/code&gt; == 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0858bc0b5a12597c22fccfc77a793e6ab59b48" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;max_delta&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41543882996e945f4aa2f7b706ce0f61bd794339" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;max_delta&lt;/code&gt; is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f79242d176f956312d4db8dc6294108008a174" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;max_sequence_length&lt;/code&gt; not an integer or is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4835e3cbd3867fe9a89a1ca214739cde1ab827aa" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;max_sequence_lengths&lt;/code&gt; is positive for a non sequence column or 0 for a sequence column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fbca0cb341a10e71a77ff4cac53433aef19d75" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;max_sequence_lengths&lt;/code&gt; is specified and not the same length as &lt;code&gt;categorical_columns&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a225345446250aca930262834fc7016c9d19a46e" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;maxlen&lt;/code&gt; is not a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f00d16f8212dee145d5cdce1b2068cd8e7d8543" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;min_jpeg_quality&lt;/code&gt; or &lt;code&gt;max_jpeg_quality&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d7e1c629e9dddbe4227b77d6ad10119677de8f" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;name_&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf261a7c2dea678fedd64d14bedaf72317e3dba" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;num_buckets&lt;/code&gt; is less than one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb005acefe2139cfb57d38afba774929ed3dc8a5" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;num_epochs&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9588e8736c4e1fd30713ca3c32be658aa3818798" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;num_or_size_splits&lt;/code&gt; is a scalar returns &lt;code&gt;num_or_size_splits&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects; if &lt;code&gt;num_or_size_splits&lt;/code&gt; is a 1-D Tensor returns &lt;code&gt;num_or_size_splits.get_shape[0]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects resulting from splitting &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;num_or_size_splits&lt;/code&gt; является скаляром, возвращает &lt;code&gt;num_or_size_splits&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; объекты; если &lt;code&gt;num_or_size_splits&lt;/code&gt; является 1-D Tensor, возвращает &lt;code&gt;num_or_size_splits.get_shape[0]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; объектов, полученных в результате разделения &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35a92e298cfea1f759ba5e5f927922312eeea8bb" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;num_or_size_splits&lt;/code&gt; is a scalar returns a list of &lt;code&gt;num_or_size_splits&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects; if &lt;code&gt;num_or_size_splits&lt;/code&gt; is a 1-D Tensor returns &lt;code&gt;num_or_size_splits.get_shape[0]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects resulting from splitting &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e19fae527782f1853dd96d66f02fa9b5be1fef" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;num_shards&lt;/code&gt; or &lt;code&gt;index&lt;/code&gt; are illegal values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720a2a53074517f81984bf36577db4f22fcd5c3d" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;num_steps&lt;/code&gt; is specified, it indicates the number of steps to execute after &lt;code&gt;begin()&lt;/code&gt; is called. If instead &lt;code&gt;last_step&lt;/code&gt; is specified, it indicates the last step we want to execute, as passed to the &lt;code&gt;after_run()&lt;/code&gt; call.</source>
          <target state="translated">если указано &lt;code&gt;num_steps&lt;/code&gt; , это указывает количество шагов, которые нужно выполнить после &lt;code&gt;begin()&lt;/code&gt; . Если вместо &lt;code&gt;last_step&lt;/code&gt; указан last_step , он указывает последний шаг, который мы хотим выполнить, как передается в &lt;code&gt;after_run()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd8ddbc1cf865a26203f44f09a1f5466d413b7ab" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;pad_values&lt;/code&gt; is set to an invalid type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f845de83b32d4602d76f6058786cd7d3b684906" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;pad_values&lt;/code&gt;, &lt;code&gt;padding_width&lt;/code&gt;, or &lt;code&gt;ngram_width&lt;/code&gt; is set to an invalid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58694dfe74516fe15f036d26a27f5900f32d2d0" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;padding&lt;/code&gt; is &quot;causal&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d33c0cfb33db1fdbc1c3709819bd286c822ede" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;padding&lt;/code&gt; is &lt;code&gt;&quot;causal&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9fe127a05da86cab9f2825e98491cffc2f1716" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;padding&lt;/code&gt; is invalid or the arguments are incompatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799650182149df84e83b2769de4dba7539faff98" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;pool_mode&lt;/code&gt; is neither &lt;code&gt;&quot;max&quot;&lt;/code&gt; or &lt;code&gt;&quot;avg&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8823cd47c019b97aab3281e6c2d444cfd85faa52" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;pool_size&lt;/code&gt; is not a tuple of 2 integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85c6163071e261ba48ec68cdf14e5f50a49ee50" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;rank(mask)&lt;/code&gt; is not known statically; or if &lt;code&gt;mask.shape&lt;/code&gt; is not a prefix of &lt;code&gt;data.shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec45d0258958d1bfbd5a9ce7c940887094a716a9" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;sample_shape&lt;/code&gt; is a &lt;code&gt;TensorShape&lt;/code&gt; and is not fully defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bfc1fef2ca54722cc6fee783773d876c81323c" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;save_best_only=True&lt;/code&gt;, the latest best model according to the quantity monitored will not be overwritten. If &lt;code&gt;filepath&lt;/code&gt; doesn't contain formatting options like &lt;code&gt;{epoch}&lt;/code&gt; then &lt;code&gt;filepath&lt;/code&gt; will be overwritten by each new better model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017c5153fbe93ef061d319a04af99d2503bbb734" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;sess&lt;/code&gt; is None and there isn't any default session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f054efe38afb37487d07568631f2bb7348a26f8" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;sess&lt;/code&gt; is not a &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9e9ff5302ba11295f816246777cf73e853a50b" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;size&lt;/code&gt; has an invalid shape or type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eb9916ecd2b748e8f405bedba0ce6c5b19ec24" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;size&lt;/code&gt; has invalid shape or type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240db8411494dff4ba1e1d46bc94f0f10a031009" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;slice_input_producer&lt;/code&gt; produces nothing from &lt;code&gt;tensor_list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a06e0d359ab2a20a91e80c00cbeca9e203d7d2e" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;sparse_delta&lt;/code&gt; is not an &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbb150a9c158bcb85b1cc387a73d584b1c876cf" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;spatial_dims&lt;/code&gt; are invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da2ca8344a2377973e03c95d1357f39aae199c4" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;step_fn&lt;/code&gt; doesn't have a single argument called &lt;code&gt;step_context&lt;/code&gt;. It may also optionally have &lt;code&gt;self&lt;/code&gt; for cases when it belongs to an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78796b522adb79370232753de1779675f02217d" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;step_fn&lt;/code&gt; has called &lt;code&gt;request_stop()&lt;/code&gt;. It may be caught by &lt;code&gt;with tf.MonitoredSession()&lt;/code&gt; to close the session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce7160bbb48a04bedaaaf524b14895e48b58a02" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;strides&lt;/code&gt; is not a tuple of 2 integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51dd260a6515fcd5c4c38c539acf226afbd05c92" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;summary()&lt;/code&gt; is called before the model is built.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549e55afde2660c47720230ba545a201c49b13ee" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;super().__init__()&lt;/code&gt; was not called in the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="439b40b835503754cacf1f8d95bfe8c486048e29" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;table&lt;/code&gt; is not an instance of &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c21f76c45df5f7d6a182d7db99e2d7cb3a6a31" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;target_height&lt;/code&gt; or &lt;code&gt;target_width&lt;/code&gt; are zero or negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edbddae79ed2e2bc1687a11f100e79341b92bf3" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;true_fn&lt;/code&gt; and &lt;code&gt;false_fn&lt;/code&gt; do not return the same number of tensors, or return tensors of different types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1715a2256e362c444bd770e16d5db05993ce580" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;true_fn&lt;/code&gt; or &lt;code&gt;false_fn&lt;/code&gt; is not callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb735d18abcc72fd22e16d9c814b4822121f973a" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;unroll&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; but input timestep is not a fixed number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84201c28150faef4cd2846eb9ba23a172bec8a59" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;upper &amp;lt;= lower&lt;/code&gt; or if &lt;code&gt;lower &amp;lt; 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2027979a9c95be745581912b396e23eae45d283e" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;value&lt;/code&gt; is neither &lt;code&gt;0&lt;/code&gt; nor &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9f313e605bb2199d00ceb08fddc345d04215f1" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;value_destination_pairs&lt;/code&gt; is not an iterable of tuples of PerReplica objects and destinations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcaaa88d129ae16d3acd148f02b13c695a4359b7" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;value_destination_pairs&lt;/code&gt; is not an iterable of tuples of PerReplica objects and destinations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce14e6bc54172536289198c34c3702e6b810f24" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;vocabulary_list&lt;/code&gt; is empty, or contains duplicate keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff195641ae432e78d7cc577c0704161a0ad6216" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;vocabulary_size&lt;/code&gt; is not a positive integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8867f4aacd830504ca9e31a8f9915efefd9e01d6" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;weight_column&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, a feature with &lt;code&gt;key=weight_column&lt;/code&gt; whose value is a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;weight_column&lt;/code&gt; не равно &lt;code&gt;None&lt;/code&gt; , функция с &lt;code&gt;key=weight_column&lt;/code&gt; , значением которой является &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28b3afd1c36d8e5df24ab0b324bdbfa0500a32ad" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;weight_column&lt;/code&gt; is specified in the &lt;code&gt;head&lt;/code&gt; constructor (and not None) for the head passed to BaselineEstimator's constructor, a feature with &lt;code&gt;key=weight_column&lt;/code&gt; whose value is a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;weight_column&lt;/code&gt; указан в &lt;code&gt;head&lt;/code&gt; конструктору (и не None) для головы передается в конструктор BaselineEstimator в, функция с &lt;code&gt;key=weight_column&lt;/code&gt; , значение которого является &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2efc5d79a34c86d2e23dccd6903a8c68251bfae8" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;x&lt;/code&gt; already contains a column with the same name as &lt;code&gt;y&lt;/code&gt;, or if the indexes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; don't match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb80bb98b3fb7eaa2edab5d23cf46f005344bdb" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;x&lt;/code&gt; has shape (samples, dim) and &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, the output will have shape &lt;code&gt;(samples, 2, dim)&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;x&lt;/code&gt; имеет форму (образцы, тусклый) и &lt;code&gt;n&lt;/code&gt; равно &lt;code&gt;2&lt;/code&gt; , результат будет иметь форму &lt;code&gt;(samples, 2, dim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f42f77a769fcc039ac0caf0769a7b45549f3a8" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;x&lt;/code&gt; is not a numeric tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdc529b2b9b83567e407871f5a9bb0c35cde4ce" translate="yes" xml:space="preserve">
          <source>if &lt;strong&gt;name&lt;/strong&gt; == '&lt;strong&gt;main&lt;/strong&gt;': flags.mark_flag_as_required('your_flag_name') app.run()</source>
          <target state="translated">if &lt;strong&gt;name&lt;/strong&gt; == ' &lt;strong&gt;main&lt;/strong&gt; ': flags.mark_flag_as_required ('your_flag_name') app.run ()</target>
        </trans-unit>
        <trans-unit id="73df495545d68f890e5e29cede7171242a4dea1f" translate="yes" xml:space="preserve">
          <source>if &lt;strong&gt;name&lt;/strong&gt; == '&lt;strong&gt;main&lt;/strong&gt;': flags.mark_flags_as_required(['flag1', 'flag2', 'flag3']) app.run()</source>
          <target state="translated">if &lt;strong&gt;name&lt;/strong&gt; == ' &lt;strong&gt;main&lt;/strong&gt; ': flags.mark_flags_as_required (['flag1', 'flag2', 'flag3']) app.run ()</target>
        </trans-unit>
        <trans-unit id="80ef88cfba28944b395eae907ab0c3a91bfd6772" translate="yes" xml:space="preserve">
          <source>if False, create a normal Variable; if True create an experimental ResourceVariable with well-defined semantics. Defaults to False (will later change to True). When eager execution is enabled this argument is always forced to be True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f155b064c9d4cc0516dae0d8c430f7132e86f7f" translate="yes" xml:space="preserve">
          <source>if PIL is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f102fe076dc5e23df7050533112e396749e9be2" translate="yes" xml:space="preserve">
          <source>if True, pads the global step number in the checkpoint filepaths to some fixed width (8 by default). This is turned off by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5327f4cf1e12b5b1322ef581963f6414d47f803" translate="yes" xml:space="preserve">
          <source>if True, the contents of the table are saved to and restored from checkpoints. If &lt;code&gt;shared_name&lt;/code&gt; is empty for a checkpointed table, it is shared using the table node name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46ef99470969a25688a6c72a6abd5fa00242a71" translate="yes" xml:space="preserve">
          <source>if True, then only the model's weights will be saved (&lt;code&gt;model.save_weights(filepath)&lt;/code&gt;), else the full model is saved (&lt;code&gt;model.save(filepath)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2433ebe69c4e9e5486b23e6058586b5d6337088" translate="yes" xml:space="preserve">
          <source>if True, will return something which evaluates to the new value of the variable; if False will return the assign op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff4cf86593cdf73f120de86088259b680870db19" translate="yes" xml:space="preserve">
          <source>if a DT_RESOURCE op is found whose ancestor Variables are both blacklisted AND whitelisted for freezing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380998823f8d052df70ebc23ea6c7d8619645b04" translate="yes" xml:space="preserve">
          <source>if a KL divergence function has already been registered for the given argument classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df11540215a42d33a034ac9ab05da1a587cb132" translate="yes" xml:space="preserve">
          <source>if a default writer exists, but no step was provided and &lt;a href=&quot;experimental/get_step&quot;&gt;&lt;code&gt;tf.summary.experimental.get_step()&lt;/code&gt;&lt;/a&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cdfacc6e86733a56727e2d579bcc620b6743f4" translate="yes" xml:space="preserve">
          <source>if a default writer exists, but no step was provided and &lt;a href=&quot;get_step&quot;&gt;&lt;code&gt;tf.summary.experimental.get_step()&lt;/code&gt;&lt;/a&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ed6494da977e462c542da3320d220e252ade35" translate="yes" xml:space="preserve">
          <source>if adjoint_a == false: A should be sorted in lexicographically increasing order. Use SparseReorder if you're not sure. if adjoint_a == true: A should be sorted in order of increasing dimension 1 (i.e., &quot;column major&quot; order instead of &quot;row major&quot; order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e9311f9362de3248af037d98cd85665f1d86c02" translate="yes" xml:space="preserve">
          <source>if an element contains a non-&lt;code&gt;Tensor&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5e0b3b5ae0f0c37dad7806473f6cc7e6509167" translate="yes" xml:space="preserve">
          <source>if an item in &lt;code&gt;feature_columns&lt;/code&gt; is neither a &lt;code&gt;_DenseColumn&lt;/code&gt; nor &lt;code&gt;_CategoricalColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb7d6924aa4e897504ddbca890fdecb38209769" translate="yes" xml:space="preserve">
          <source>if an item in &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;DenseColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd255772325080e220db7689d471a266c735174f" translate="yes" xml:space="preserve">
          <source>if an item in &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;_DenseColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a439b7f4e2b6a92eddf284074e92ad1bdfa65ddd" translate="yes" xml:space="preserve">
          <source>if an unsupported resize method is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095ced0ff37ea91b1eb7273553ee0d3751c36d6c" translate="yes" xml:space="preserve">
          <source>if any &lt;code&gt;input_receiver_fn&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, no &lt;code&gt;export_outputs&lt;/code&gt; are provided, or no checkpoint can be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a597cf100c75bd6ddea8b1142dadff60c673cb" translate="yes" xml:space="preserve">
          <source>if any argument is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd69ad28d285e57b85451fd1c652b1269e7767d5" translate="yes" xml:space="preserve">
          <source>if any arguments is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f5de00af722a5f1713f44c597c3117fee16c74" translate="yes" xml:space="preserve">
          <source>if any dimension in shape is not a positive integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f2a11ec3ad010d2831ff9b42eb01a9dcf1f8f5e" translate="yes" xml:space="preserve">
          <source>if any dimension in shape is not a positive integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da97ecf5ec59cb218ae6b1eeb3a79df0ecde1f42" translate="yes" xml:space="preserve">
          <source>if any dimension in shape is not an int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743531b64fa8a86651066680f74547e98605be64" translate="yes" xml:space="preserve">
          <source>if any dimension in shape is not an int.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3219eb3858ba3582b2ee6fdc8a2fe0a3c7123d6f" translate="yes" xml:space="preserve">
          <source>if any feature is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6db89a26350322243f91bc18928f69bfa2abb46" translate="yes" xml:space="preserve">
          <source>if any member of &lt;code&gt;params&lt;/code&gt; is not a valid argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef693e2c852ed3232c8293082f69ba60ad72310" translate="yes" xml:space="preserve">
          <source>if any member of graph_parents is &lt;code&gt;None&lt;/code&gt; or not a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e67b25175ee647802ed94cfe8bec3361538840e" translate="yes" xml:space="preserve">
          <source>if any of the elements do not fall into &lt;code&gt;expected_set&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21cef54288ed5de4b96196d93b71a20492959a9" translate="yes" xml:space="preserve">
          <source>if any of the given &lt;code&gt;categorical_columns&lt;/code&gt; is of different type or has different arguments than the others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93559abb19bd84bde2f7ea7b742bc21d503bdc03" translate="yes" xml:space="preserve">
          <source>if any of the inputs is not a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7777ddb7de20644067556388dfc27dac28ae3c34" translate="yes" xml:space="preserve">
          <source>if any of the keep_probs are not between 0 and 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc734ccdde05b446f338882ed3e8647c8b0b5cef" translate="yes" xml:space="preserve">
          <source>if any unrecognized parameters are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df1db3b7b5995eebaf1434dd6a2005a43148948" translate="yes" xml:space="preserve">
          <source>if arguments are invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774abc5449f0b641f3c84309a3f646134cded19f" translate="yes" xml:space="preserve">
          <source>if arguments have inappropriate values or if verify_shape is True and shape of values is not equals to a shape from the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b40a2a4a62fa0f43f18f4f3c30bdc6288d7832" translate="yes" xml:space="preserve">
          <source>if both handle and tensor_array_name are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabeb3ced1d6452db23ffc31315bcd8c5163eeba" translate="yes" xml:space="preserve">
          <source>if box coordinates are given as &lt;code&gt;[y_min, x_min, y_max, x_max]&lt;/code&gt;, settign to True eliminate redundant computation to canonicalize box coordinates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859838995ffcee49b22530b9c6dc20dd828fcb4e" translate="yes" xml:space="preserve">
          <source>if called in Eager mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fc691fedc875fae508a2949cd00e00cf763a85" translate="yes" xml:space="preserve">
          <source>if called inside the context of the tape, or if called more than once on a non-persistent tape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf3f52be56a988c15ef0adbc2fea699a53bd644" translate="yes" xml:space="preserve">
          <source>if called on a symbolic tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770675873013db1805e130ca7d7b5d06400f4dac" translate="yes" xml:space="preserve">
          <source>if called when eager execution is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440c2f211d7cc30a81f3b1588c44df858ed72957" translate="yes" xml:space="preserve">
          <source>if cells is empty (not allowed), or at least one of the cells returns a state tuple but the flag &lt;code&gt;state_is_tuple&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5bd7ccc01f030938148987c1cdef4c23f33bc6b" translate="yes" xml:space="preserve">
          <source>if central_crop_fraction is not within (0, 1].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca46d6b6879e9fe4e49065f57821fd88118d20f" translate="yes" xml:space="preserve">
          <source>if cluster is not None and the provided session_config has a cluster_def already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978b17b90399ed9376eeae8c4026d2a3719e0422" translate="yes" xml:space="preserve">
          <source>if colocation conflicts with existing device assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23dfc461ee986d3e2948e2d4c1d9505c0dcb909" translate="yes" xml:space="preserve">
          <source>if control inputs are not Operations or Tensors, or if &lt;code&gt;node_def&lt;/code&gt; is not a &lt;code&gt;NodeDef&lt;/code&gt;, or if &lt;code&gt;g&lt;/code&gt; is not a &lt;code&gt;Graph&lt;/code&gt;, or if &lt;code&gt;inputs&lt;/code&gt; are not tensors, or if &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;input_types&lt;/code&gt; are incompatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d24dc55622b812437e622f85d77d1d8fcf1404" translate="yes" xml:space="preserve">
          <source>if data_format is None or does not start with &quot;NC&quot;, or</source>
          <target state="translated">если data_format нет или не начинается с &quot;NC&quot;,или</target>
        </trans-unit>
        <trans-unit id="f8a573407f16d7aca1b9b15ef7d75f763c901cb6" translate="yes" xml:space="preserve">
          <source>if data_format starts with &quot;NC&quot;, where &lt;code&gt;output_spatial_shape&lt;/code&gt; depends on the value of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">если data_format начинается с &amp;laquo;NC&amp;raquo;, где &lt;code&gt;output_spatial_shape&lt;/code&gt; зависит от значения &lt;code&gt;padding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6054be2a7214b032d47a8c7dc017af767b16116" translate="yes" xml:space="preserve">
          <source>if data_format starts with &quot;NC&quot;, where &lt;code&gt;output_spatial_shape&lt;/code&gt; depends on the value of padding:</source>
          <target state="translated">если data_format начинается с &amp;laquo;NC&amp;raquo;, где &lt;code&gt;output_spatial_shape&lt;/code&gt; зависит от значения заполнения:</target>
        </trans-unit>
        <trans-unit id="59a56423f22117e2ef81f7c9c51b1b55508dbfea" translate="yes" xml:space="preserve">
          <source>if duplicate keys are in both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; when &lt;code&gt;y&lt;/code&gt; is a dict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5de25057c6808f30d0f14fa287516c84d4c4fff" translate="yes" xml:space="preserve">
          <source>if eager execution is enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2266ad9caa756f883b48492ac9399e26257e9ed3" translate="yes" xml:space="preserve">
          <source>if eager execution is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49292a2ac369ccac38055c45c4627e058222510b" translate="yes" xml:space="preserve">
          <source>if eager execution is not enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ca3beab01807ff746ce717216d95e776eea61c" translate="yes" xml:space="preserve">
          <source>if either both or neither of &lt;code&gt;dim&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt; are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0517ef2513b5829b9b7d2dc2a00dfc0739a1913" translate="yes" xml:space="preserve">
          <source>if either bound is not between [0, 1], or upper bound is less than lower bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96197bdccad81945857038f962712c9314eba635" translate="yes" xml:space="preserve">
          <source>if environment variable &lt;code&gt;TF_CONFIG&lt;/code&gt; is incorrectly set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da9a7a1c33832a3ff4e29c8f12797b2dce50104" translate="yes" xml:space="preserve">
          <source>if exactly one of &lt;code&gt;ckpt_to_load_from&lt;/code&gt; and &lt;code&gt;tensor_name_in_ckpt&lt;/code&gt; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65b87bdb12d758b8d7f47e56a9669bd4df78c45" translate="yes" xml:space="preserve">
          <source>if expand_nonconcat_dim = False, this will result in an error. But if expand_nonconcat_dim = True, this will result in:</source>
          <target state="translated">если expand_nonconcat_dim=False,то это приведет к ошибке.Но если переменная expand_nonconcat_dim=True,то это приведет к ошибке:</target>
        </trans-unit>
        <trans-unit id="9f2464a8290190ee76ca6b6a75149b68d335c18a" translate="yes" xml:space="preserve">
          <source>if features and labels have overlapping keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66efbfd8abf744c0bb35f608d0014ee2275f7204" translate="yes" xml:space="preserve">
          <source>if features argument is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e420ee4a9eda5e4a2a119e47e26fb0f802041aa5" translate="yes" xml:space="preserve">
          <source>if global step tensor is already defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da0a0271141f0d61dec9fe25a85f5fe2a86d735" translate="yes" xml:space="preserve">
          <source>if graph state is incompatible with this initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027f9e569e9b62766979968b66535cb449a8d35b" translate="yes" xml:space="preserve">
          <source>if graphviz or pydot are not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140226a893b596122c3b72de6ca6cf536c699eca" translate="yes" xml:space="preserve">
          <source>if handle is provided but is not a Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa04bdc09ffcbd8bfdbda949e213df9e157a919d" translate="yes" xml:space="preserve">
          <source>if hashed_output=true then the output will be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07894a2c468d831f3af908b772a0e3a6ac2c5c4" translate="yes" xml:space="preserve">
          <source>if images.shape is not a 3-D or 4-D vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110a9f0f435bcf9064b8c9df92044bd3e39f205c" translate="yes" xml:space="preserve">
          <source>if input &lt;code&gt;a&lt;/code&gt; does not have &lt;code&gt;float&lt;/code&gt;-like &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89e026fecdd066a16c115fd91797f1c51e90dbb" translate="yes" xml:space="preserve">
          <source>if input &lt;code&gt;a&lt;/code&gt; has fewer than 2 dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6696d0b6028b56541b42429b3eaa244b49e910" translate="yes" xml:space="preserve">
          <source>if input dimension is less than 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa835a7121e03f6326c09d429628c93fa095dfb" translate="yes" xml:space="preserve">
          <source>if interpolation method is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99137c346ab75a1a3aa184674f9a24cc4e69f98" translate="yes" xml:space="preserve">
          <source>if invalid &lt;code&gt;img&lt;/code&gt; or &lt;code&gt;data_format&lt;/code&gt; is passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd87bc782d044a6714be546357d0bf3a8eea84a8" translate="yes" xml:space="preserve">
          <source>if invalid &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;data_format&lt;/code&gt; is passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1dedb4e4bb6d532b666e852e116c1ff57480bcb" translate="yes" xml:space="preserve">
          <source>if invalid kwargs are passed in or if in eager execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a78db163365627c39f797e7ac9631fe83c3905" translate="yes" xml:space="preserve">
          <source>if it encounters something that is not a tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a9823740d2a2f06e6fc29c9456512ad139dd85" translate="yes" xml:space="preserve">
          <source>if k is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1268cfe1e48b6c0fc63ec7ccc2ba9209cfc42521" translate="yes" xml:space="preserve">
          <source>if kl_fn is not a callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de422d6ad84da8318f1668bcef542cdaf1d1fe4e" translate="yes" xml:space="preserve">
          <source>if label_key is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb7b2b4187bcf56bebfcdfe1fbc0ae7da895f3d" translate="yes" xml:space="preserve">
          <source>if labels is not a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984f282bfdbbf6b53c65a2859f90fbc97e315c27" translate="yes" xml:space="preserve">
          <source>if len(args) == 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd65eecc1529c25452a66b6024bb3aa52c76b210" translate="yes" xml:space="preserve">
          <source>if loading from an hdf5 file and h5py is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ac839d61429abd7e4cb31e3c17f21acd2e51fd" translate="yes" xml:space="preserve">
          <source>if loc and scale are different dtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721a8fd601ff2d4da280a3d79feeac37b924c76d" translate="yes" xml:space="preserve">
          <source>if logit_fn does not return a Tensor or a dictionary mapping strings to Tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a64dd6b99b8d4523d741c319451c07e8aadeab2" translate="yes" xml:space="preserve">
          <source>if lower bound is not between [0, 1], or upper bound is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4202dcdea20a233b67b6b76a48f2fac8b88945c" translate="yes" xml:space="preserve">
          <source>if more than one session.run call is simultaneously trying to compute &lt;code&gt;b&lt;/code&gt; the values of &lt;code&gt;w&lt;/code&gt; will be gathered, non-deterministically concatenated along the first axis, and only one thread will run the computation. See the documentation of the &lt;code&gt;Batch&lt;/code&gt; op for more details.</source>
          <target state="translated">если более одного вызова session.run одновременно пытаются вычислить &lt;code&gt;b&lt;/code&gt; , значения &lt;code&gt;w&lt;/code&gt; будут собраны, недетерминированно объединены по первой оси, и только один поток будет выполнять вычисления. См. Документацию по &lt;code&gt;Batch&lt;/code&gt; операции для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="ba27b6bca894ac274c25454249205ebdc03eb69c" translate="yes" xml:space="preserve">
          <source>if n_classes &amp;lt; 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24df00e69da11822e32483ff264af5d2d5b91fe" translate="yes" xml:space="preserve">
          <source>if neither &lt;code&gt;tensors&lt;/code&gt; nor &lt;code&gt;dtype&lt;/code&gt; is supplied, or result is not float, or the common type of the inputs is not a floating point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f055cafa22a323f675c43f4402683e055d17752" translate="yes" xml:space="preserve">
          <source>if neither classes nor scores is set, or one of them is not a &lt;code&gt;Tensor&lt;/code&gt; with the correct dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43390b9dd4dea8e2923f99b8294103c7ac309597" translate="yes" xml:space="preserve">
          <source>if neither or both of {&lt;code&gt;window_size&lt;/code&gt;, &lt;code&gt;window_size_func&lt;/code&gt;} are passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6efa33aceeafc76d3d755bd57f26fc436fd797c" translate="yes" xml:space="preserve">
          <source>if no &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; is provided, no &lt;code&gt;export_outputs&lt;/code&gt; are provided, or no checkpoint can be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39752e70b96c85f465ce5d8c62bc1ef33ee7339b" translate="yes" xml:space="preserve">
          <source>if not &lt;code&gt;None&lt;/code&gt;, a &lt;code&gt;DeviceAssignment&lt;/code&gt; describing the mapping between logical cores in the computation with physical cores in the TPU topology. May be omitted for a single-core computation, in which case the core attached to task 0, TPU device 0 is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e52425c01a60b970c305588cf1711c0b95ae52" translate="yes" xml:space="preserve">
          <source>if one of the operations between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; does not have a registered gradient function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a893b900e8bf37f8c332ee88c6f1f326d3ad9a5f" translate="yes" xml:space="preserve">
          <source>if one of the operations between &lt;code&gt;xs&lt;/code&gt; and &lt;code&gt;ys&lt;/code&gt; does not have a registered gradient function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7006c6d574e28d975e7e0c94b507efb8ebad5e98" translate="yes" xml:space="preserve">
          <source>if only one of &lt;code&gt;a[p]&lt;/code&gt; and &lt;code&gt;b[p]&lt;/code&gt; is a dict or &lt;code&gt;a[p]&lt;/code&gt; and &lt;code&gt;b[p]&lt;/code&gt; have different length, where &lt;code&gt;[p]&lt;/code&gt; denotes a path to the nested structure, e.g. given &lt;code&gt;a = [(1, 1), {'d': (6, 7)}]&lt;/code&gt; and &lt;code&gt;[p] = [1]['d']&lt;/code&gt;, then &lt;code&gt;a[p] = (6, 7)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a45a19f5100bb181e5930426682e98a55f5d3b5" translate="yes" xml:space="preserve">
          <source>if op is None but ignore_existing is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1de27538c0c55ff6262b317e42b1549be2a9e1" translate="yes" xml:space="preserve">
          <source>if per_replica_value can't be converted to a PerReplica object or if destinations aren't strings, Variables or DistributedValues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204cf39266fee6be1c4fda1ed0c3f92c42653029" translate="yes" xml:space="preserve">
          <source>if per_replica_value can't be converted to a PerReplica object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e1ee97d9696a2138c657301031b2d758ef9f28" translate="yes" xml:space="preserve">
          <source>if portpicker module was not found at load time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49c73979394be24d6ec35bc08c50c00b8cc3134" translate="yes" xml:space="preserve">
          <source>if remote_host is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4e0c96c14e7c8493f88412564b7b4538279831" translate="yes" xml:space="preserve">
          <source>if scalar is not a 0-D &lt;code&gt;scalar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bc798aa4eec0611714a738d20115545dd97e3f" translate="yes" xml:space="preserve">
          <source>if shape is incorrectly specified or unsupported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79477479dcf3421b5ecbb49505468d2974a1b6d8" translate="yes" xml:space="preserve">
          <source>if signature_key or method_name are not defined or if no metagraphs were found with the associated tags or if no meta graph has a signature_def that matches signature_key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc596c7a594531690c6cb8070e7f040971373cc8" translate="yes" xml:space="preserve">
          <source>if tensor has unsupported type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d94dcd50c8e6f40f32fef5abad445a5323a4a1" translate="yes" xml:space="preserve">
          <source>if tensor is not an ops.Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f3504e52e4021ba77da665aac7e44cea4e26c6" translate="yes" xml:space="preserve">
          <source>if the &lt;code&gt;gpus&lt;/code&gt; argument does not match available devices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a933d57cff80ee49f7f8f702cdffe0684e3ed012" translate="yes" xml:space="preserve">
          <source>if the &lt;code&gt;node_def&lt;/code&gt; name is not valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6024dd2ea22d2416f468cf85c134935530e80adc" translate="yes" xml:space="preserve">
          <source>if the Supervisor was created without a &lt;code&gt;logdir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb3f877f4daa5b2df562e3ebd6c3a4915bb5120" translate="yes" xml:space="preserve">
          <source>if the arguments are invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891ed8a5c1d4481d272ebd0f497625a476b687a5" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x != y&lt;/code&gt; is False for any pair of elements in &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2d2ec5edbbd2c63237549cad74c58de1619cbb" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x != y&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713563ad72cdd5894f64de73197c9a92cca5e1f3" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x &amp;gt; 0&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86105ffaba4c7158be78db5ee115be86a9e5ce0b" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x &amp;gt; y&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc18a18eef82874193685933a520f0c3fea3a1d2" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9497a9c49e4ea14cd0481c1422271b918e660e0" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x &amp;gt;= y&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c238d5703c38860c8c83a16057a3b9d99a0296a" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x &amp;lt; 0&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8674de5809e30b4e516bf2c52897e9ccbc52ab1" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x &amp;lt; y&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe82c4dd860015ce1162ebe8f7830aafe7795b47" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x &amp;lt;= 0&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf10e58e37b52505af70939b297b2e0846a92a4" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x &amp;lt;= y&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d3e590d8fe85b44c92240ec765ced9a828d4cc" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x == y&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ca3b111ca675523d69b4854f0b82a5e82f9ae5" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x&lt;/code&gt; does not have rank &lt;code&gt;rank&lt;/code&gt;. The check can be performed immediately during eager execution or if the shape of &lt;code&gt;x&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81989665507e2192b2f80870d3d82172c73b6c4d" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x[i] &amp;gt; 0&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e12d8b91ef3c96d2ba408894c37af7fa5a132a1" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x[i] &amp;gt;= 0&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea369d21c8c50062fbbc74170e7e973d341cd84" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x[i] &amp;lt; 0&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3630162c68d3e880ad56ffde269b65f128af0e5" translate="yes" xml:space="preserve">
          <source>if the check can be performed immediately and &lt;code&gt;x[i] &amp;lt;= 0&lt;/code&gt; is False. The check can be performed immediately during eager execution or if &lt;code&gt;x&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d86dfca1b78e2c96dc27691405fc916ceafd04" translate="yes" xml:space="preserve">
          <source>if the checkpoint read doesn't have model_checkpoint_path set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95443e70b74e32f4fe3b73a0a7ac82208bb596f7" translate="yes" xml:space="preserve">
          <source>if the combination of the parameters is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7d8cebb95caa49895c30f44a43837a0b7150de" translate="yes" xml:space="preserve">
          <source>if the dictionaries are not equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89e4e83561997d64584bb2c15bc32f7480f8c3d" translate="yes" xml:space="preserve">
          <source>if the given &lt;a href=&quot;options&quot;&gt;&lt;code&gt;tf.data.Options&lt;/code&gt;&lt;/a&gt; cannot be merged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e66b6eac059533d69b2fa730269f2dc37eb59a" translate="yes" xml:space="preserve">
          <source>if the head's &lt;code&gt;weight_column&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, a feature with &lt;code&gt;key=weight_column&lt;/code&gt; whose value is a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">если &lt;code&gt;weight_column&lt;/code&gt; головы не &lt;code&gt;None&lt;/code&gt; , функция с &lt;code&gt;key=weight_column&lt;/code&gt; , значение которой является &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1012731ca6531dbaad92b7e4dcf1bbec216aa5" translate="yes" xml:space="preserve">
          <source>if the input combination is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5080c831c450dbdb0f60e402aceecce2238022" translate="yes" xml:space="preserve">
          <source>if the layer cannot be adapted at this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4997dbb3832ad6db392ef8a212ac42b5318a1c9b" translate="yes" xml:space="preserve">
          <source>if the layer isn't yet built (in which case its weights aren't yet defined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa06f8fad2b1bc8544934d38a80436f89b16d39" translate="yes" xml:space="preserve">
          <source>if the layer's &lt;code&gt;call&lt;/code&gt; method returns None (an invalid value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd765839e989c7ff54b2f18f3ebb590fbe31347" translate="yes" xml:space="preserve">
          <source>if the lengths of the output of &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;fn_output_signature&lt;/code&gt; do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f669e77102a299af38c394c786110bfff93096" translate="yes" xml:space="preserve">
          <source>if the lengths of the output of &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;initializer&lt;/code&gt; do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc463ff696b668b9d6496662a99b66dc768d6fd" translate="yes" xml:space="preserve">
          <source>if the node is not a summary op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcbdd5fc6ef90e8529a538c90075538a4058021" translate="yes" xml:space="preserve">
          <source>if the number of elements in the lists do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e667238637c680e5cf8872b6a83af30b4aad57" translate="yes" xml:space="preserve">
          <source>if the number of placeholders does not match the number of inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6f2af843b5be73c3bd3c7b1e405539be1d6ae0" translate="yes" xml:space="preserve">
          <source>if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0, 10.0]: it would use a scale_factor of 127 / 10.0 = 12.7 In this case, it would update input_min to be 128.0 / 12.7 = -10.07874</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ae64c1b0745d0ea7d6e78fe2202e78c731f893" translate="yes" xml:space="preserve">
          <source>if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0, 5.0]: it would use a scale_factor of -128 / -10.0 = 12.8 In this case, it would update input_max to be 127 / 12.8 = 9.921875</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7ab655759428ed78c19bf6a5933237e8263407" translate="yes" xml:space="preserve">
          <source>if the output is unsigned, input_min is forced to be 0, and only the specified input_max is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa3b1f93ea4d7e41974a3f0f274a01dfc609a78" translate="yes" xml:space="preserve">
          <source>if the outputs is not dict, or any of its keys are not strings, or any of its values are not &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2092ba027bfea9c4fe82595857d5c7b25c27a7fb" translate="yes" xml:space="preserve">
          <source>if the session is not available after max_wait_secs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2edfb286ff3d6dc742246973753f3284a9e2810d" translate="yes" xml:space="preserve">
          <source>if the shape inference fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c692aac24ea2e8eb3bce9ab67f95b58e3f1b1f" translate="yes" xml:space="preserve">
          <source>if the shape of 'image' is incompatible with this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08284f7b617f28ff0212ea4102e8fad6d34c427" translate="yes" xml:space="preserve">
          <source>if the shape of &lt;code&gt;image&lt;/code&gt; not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d148c391cdc86b21966afe74210df8c742299b8" translate="yes" xml:space="preserve">
          <source>if the shape of &lt;code&gt;images&lt;/code&gt; is incompatible with the shape arguments to this function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e6ea464c716c9a113f8834b0fb52ece9633963" translate="yes" xml:space="preserve">
          <source>if the shape of &lt;code&gt;y&lt;/code&gt; mismatches the shape of values in &lt;code&gt;x&lt;/code&gt; (i.e., values in &lt;code&gt;x&lt;/code&gt; have same shape).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05907b44b5e95565479162af68d2c9cbc7cacdc" translate="yes" xml:space="preserve">
          <source>if the spec was not valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03597ce9b00079fa1b0e0387eafcea6686c17e19" translate="yes" xml:space="preserve">
          <source>if the tape is not currently recording.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d67835eba03078a6e81f7e0b7a0ef5fab9154c" translate="yes" xml:space="preserve">
          <source>if the target is a variable or if unconnected gradients is called with an unknown value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b410be3f2353187abce934810f0687da7658281" translate="yes" xml:space="preserve">
          <source>if the value is not a &lt;code&gt;Tensor&lt;/code&gt; with dtype tf.float32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6815af14253345fa60de5af5f0a14903e9c37f1e" translate="yes" xml:space="preserve">
          <source>if the value tensor does not have an ordered numeric type (float* or int*), or if there are nan values, or if any of the elements do not fall in the specified range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761d214f481530735c1a95c9aee6d00042b79e18" translate="yes" xml:space="preserve">
          <source>if there are more writers than specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ece4d1eee140c2a4d075f77c19bd83ea941a407" translate="yes" xml:space="preserve">
          <source>if there are no layers in the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7988a212539073bef647cd253c2f6284a81d69" translate="yes" xml:space="preserve">
          <source>if this is called via a subclass and if that class overrides a member of &lt;code&gt;Estimator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1775f6354ed830e735279efad359510f33d9a259" translate="yes" xml:space="preserve">
          <source>if true, &lt;code&gt;weight_decay_factor&lt;/code&gt; is multiplied by the current learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a536c6f618f1cb37d653a37196160170a9e756" translate="yes" xml:space="preserve">
          <source>if true, attempt to statically determine the shape of 'tensor' and encode it as a constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9515db1eae91c1c675c66d25d330f7b61b961920" translate="yes" xml:space="preserve">
          <source>if types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;boundaries&lt;/code&gt; do not match, or types of all &lt;code&gt;values&lt;/code&gt; do not match or the number of elements in the lists does not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234e6142149e8cc7afed0b4a614c733568be0baa" translate="yes" xml:space="preserve">
          <source>if unsupported types are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79f700abc16cc72c85b1491179d85c2ce3a016d" translate="yes" xml:space="preserve">
          <source>if x or y is an empty dict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7764062a2b67983dff7e5935795ce411d16bd1c8" translate="yes" xml:space="preserve">
          <source>if yaml module is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73179eedb6b6dae5d5cda028d0ceec6667de4088" translate="yes" xml:space="preserve">
          <source>ignored (exists for API compatibility).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a165678a63380a8d2576622ae33518863eb113f" translate="yes" xml:space="preserve">
          <source>image must have 1 or 3 channels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e06aaa2393a44b881c4f4d68e2ea91dfacf3aa" translate="yes" xml:space="preserve">
          <source>images = np.array( ... [ ... [[[1], [2]], [[3], [4]]], ... [[[5], [6]], [[7], [8]]] ... ]) tf.image.random_flip_left_right(images, 6).numpy().tolist() [[[[2], [1]], [[4], [3]]], [[[5], [6]], [[7], [8]]]]</source>
          <target state="translated">изображения=np.array(...[...[[[1],[2]],[[3],[4]]],...[[[5],[6]],[[7],[8]]]...])tf.image.random_flip_left_right(изображения,6).numpy().tolist()[[[2],[1]],[[4],[3]]],[[[5],[6]],[[7],[8]]]]].</target>
        </trans-unit>
        <trans-unit id="0482853f7a3978a9e3e80770dd2609a35a1a146f" translate="yes" xml:space="preserve">
          <source>images = np.array( ... [ ... [[[1], [2]], [[3], [4]]], ... [[[5], [6]], [[7], [8]]] ... ]) tf.image.random_flip_up_down(images, 4).numpy().tolist() [[[[3], [4]], [[1], [2]]], [[[5], [6]], [[7], [8]]]]</source>
          <target state="translated">изображения=np.array(...[...[[[1],[2]],[[3],[4]]],...[[[5],[6]],[[7],[8]]]...])tf.image.random_flip_up_down(изображения,4).numpy().tolist()[[[3],[4]]],[[1],[2]]],[[[5],[6]],[[7],[8]]]]].</target>
        </trans-unit>
        <trans-unit id="bc5226187d991de728eaa9c2bd66acbc83f07313" translate="yes" xml:space="preserve">
          <source>implementation mode, either &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;. &lt;code&gt;1&lt;/code&gt; loops over input spatial locations to perform the forward pass. It is memory-efficient but performs a lot of (small) ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d46238512c2be6af91681cf4ce6649fccc4812" translate="yes" xml:space="preserve">
          <source>implementation_selector: Enable the swap of kernel implementations based on the device placement.</source>
          <target state="translated">implementation_selector:Включает подмену реализаций ядра на основе размещения устройств.</target>
        </trans-unit>
        <trans-unit id="bcab709e15bed658b61ee4181f314cd59ed91952" translate="yes" xml:space="preserve">
          <source>import numpy as np</source>
          <target state="translated">импорт онемелый как пшт</target>
        </trans-unit>
        <trans-unit id="12bb521ffcebe569e243130772f9a19175769d59" translate="yes" xml:space="preserve">
          <source>in case &lt;code&gt;maxlen&lt;/code&gt; is so low that no input sequence could be kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c942844894de9bc7d4e6c76a8a28d7bfcfa86f6f" translate="yes" xml:space="preserve">
          <source>in case of incorrect value for &lt;code&gt;data_format&lt;/code&gt; or &lt;code&gt;interpolation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4532cdff8b57a721638a8a2b068657b1458076e3" translate="yes" xml:space="preserve">
          <source>in case of invalid &lt;code&gt;label_mode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10715abb5a3d14ea3e888387e14a88d5b243d65" translate="yes" xml:space="preserve">
          <source>in case of invalid &lt;code&gt;model&lt;/code&gt; argument value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec395b5db62da04819f12ecb94f8d4cd0ebfe65" translate="yes" xml:space="preserve">
          <source>in case of invalid argument for &lt;code&gt;weights&lt;/code&gt;, or invalid input shape or invalid alpha, rows when weights='imagenet'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f3b49427e72f959b9e613a7e7da2015d71bb33" translate="yes" xml:space="preserve">
          <source>in case of invalid argument for &lt;code&gt;weights&lt;/code&gt;, or invalid input shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0867da1a73119fc524ca02d2105888bdaa06f6a3" translate="yes" xml:space="preserve">
          <source>in case of invalid arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5735208524cee36d2ff3cc85a0e0d533e4160bf" translate="yes" xml:space="preserve">
          <source>in case of invalid constructor arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3bd3dd0f9feb59c350dde92e207dca182be74f" translate="yes" xml:space="preserve">
          <source>in_tensors: The tensors to be batched. num_batch_threads: Number of scheduling threads for processing batches of work. Determines the number of batches processed in parallel. max_batch_size: Batch sizes will never be bigger than this. batch_timeout_micros: Maximum number of microseconds to wait before outputting an incomplete batch. allowed_batch_sizes: Optional list of allowed batch sizes. If left empty, does nothing. Otherwise, supplies a list of batch sizes, causing the op to pad batches up to one of those sizes. The entries must increase monotonically, and the final entry must equal max_batch_size. grad_timeout_micros: The timeout to use for the gradient. See Unbatch. batched_tensors: Either empty tensors or a batch of concatenated Tensors. batch_index: If out_tensors is non-empty, has information to invert it. container: Controls the scope of sharing of this batch. id: always contains a scalar with a unique ID for this invocation of Batch. shared_name: Concurrently running instances of batch in the same device with the same container and shared_name will batch their elements together. If left empty, the op name will be used as the shared name. T: the types of tensors to be batched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5e1933411ed838480116bdced0d3c970f5817d" translate="yes" xml:space="preserve">
          <source>index tokens (associate a unique int value with each token)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb16aa5effa3880c62e1530f8a13341f247635e" translate="yes" xml:space="preserve">
          <source>indexing: Either 'xy' or 'ij' (optional, default: 'xy').</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20356c3f1393aae668c7092fb89b44ee4c35f532" translate="yes" xml:space="preserve">
          <source>indices = [0, 0; 0, 1; 1, 0; 1, 1; 1, 2] shape = [2, 3] values = ['hello', 'world', 'a', 'b', 'c']</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3117d16c38907a549c2e40556bc64fd6ee3f3c81" translate="yes" xml:space="preserve">
          <source>indices into unique labels, shape &lt;code&gt;[batch_size, max_label_length]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e0b0818c977c0382ecfe0ea21345bae42b410a" translate="yes" xml:space="preserve">
          <source>initial accumulator for Adagrad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5203f574584581fc4c78d89c5123891505563d67" translate="yes" xml:space="preserve">
          <source>initial variance for the noise. See computation above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61169edc7e14dee7c69b04e8658ab8f22496afd1" translate="yes" xml:space="preserve">
          <source>initial_value: A &lt;code&gt;Tensor&lt;/code&gt;, or Python object convertible to a &lt;code&gt;Tensor&lt;/code&gt;, which is the initial value for the Variable. The initial value must have a shape specified unless &lt;code&gt;validate_shape&lt;/code&gt; is set to False. Can also be a callable with no argument that returns the initial value when called. In that case, &lt;code&gt;dtype&lt;/code&gt; must be specified. (Note that initializer functions from init_ops.py must first be bound to a shape before being used here.)</source>
          <target state="translated">initial_value: объект &lt;code&gt;Tensor&lt;/code&gt; или Python, конвертируемый в &lt;code&gt;Tensor&lt;/code&gt; , который является начальным значением для переменной. У начального значения должна быть указана форма, если для &lt;code&gt;validate_shape&lt;/code&gt; не установлено значение False. Также может быть вызываемым без аргументов, возвращающим начальное значение при вызове. В этом случае необходимо указать &lt;code&gt;dtype&lt;/code&gt; . (Обратите внимание, что функции инициализатора из init_ops.py должны быть сначала привязаны к форме, прежде чем использоваться здесь.)</target>
        </trans-unit>
        <trans-unit id="84f5e915f74fca9c6e1ead23ba7ffebfa8108c47" translate="yes" xml:space="preserve">
          <source>initializes the model via initialization ops provided by &lt;code&gt;Scaffold&lt;/code&gt;</source>
          <target state="translated">инициализирует модель с помощью операций инициализации, предоставленных &lt;code&gt;Scaffold&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a87e7a165bd0910ffdb2f653ad85222acfb3b553" translate="yes" xml:space="preserve">
          <source>inp_1 = ['a', 'b', 'c'] inp_2 = ['d', 'e', 'f'] layer = tf.keras.layers.experimental.preprocessing.CategoryCrossing() layer([inp_1, inp_2])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7572f94df2a5caca4da29ca455605688c8b5b52d" translate="yes" xml:space="preserve">
          <source>input = np.array([[-1.5, 1.0, 3.4, .5], [0.0, 3.0, 1.3, 0.0]]) layer = tf.keras.layers.experimental.preprocessing.Discretization( ... bins=[0., 1., 2.]) layer(input)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58021f3528223c38d64977ca08e66879308ce6b" translate="yes" xml:space="preserve">
          <source>input data, as a Numpy array or list of Numpy arrays (if the model has multiple inputs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef1c93b3631a08e1230ea85d115a157a34fd7ec" translate="yes" xml:space="preserve">
          <source>input must have 3 channels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e2bc891d016bfc6ed1012e19bcb9446fcd9afd" translate="yes" xml:space="preserve">
          <source>input tensor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce2551df57a57f31be1f903c33c3e28f5ad2796" translate="yes" xml:space="preserve">
          <source>input variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995b0e1f6d2d11fbd441d7a0289e823158188fff" translate="yes" xml:space="preserve">
          <source>input: A &lt;code&gt;CSRSparseMatrix&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029ee6a85d486a0d7f2e2f10a710efa6ebd2044b" translate="yes" xml:space="preserve">
          <source>input: A &lt;code&gt;CSRSparseMatrix&lt;/code&gt;. permutation: A &lt;code&gt;Tensor&lt;/code&gt;. type: The type of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c69f380fd9a4467fc47b49d604c49daff38451" translate="yes" xml:space="preserve">
          <source>input: The input to the broadcast. output: The same as input. shape: The shape of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc9aebc9e3b29156c21e44bad7b7a69c8dbbcea" translate="yes" xml:space="preserve">
          <source>input: The input to the reduction. data: the value of the reduction across all &lt;code&gt;num_devices&lt;/code&gt; devices. reduction: the reduction operation to perform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee0fa44cd6131a7798536c5c63107c233e8ccb9" translate="yes" xml:space="preserve">
          <source>input: the input to the reduction data: the value of the reduction across all &lt;code&gt;num_devices&lt;/code&gt; devices. reduction: the reduction operation to perform. num_devices: The number of devices participating in this reduction. shared_name: Identifier that shared between ops of the same reduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1ee4971ae575e749338431929d550b805b6d68" translate="yes" xml:space="preserve">
          <source>input=ragged.from_nested_row_splits(rt_dense_values, rt_nested_splits) output=SparseTensor(indices=sparse_indices, values=sparse_values, dense_shape=sparse_dense_shape)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8827e47815833f966cf5393b6c99d256e4b837e" translate="yes" xml:space="preserve">
          <source>input_handle: The input list. element_shape: The shape of the uninitialized elements in the list. If the first dimension is not -1, it is assumed that all list elements have the same leading dim. leading_dims: The list of leading dims of uninitialized list elements. Used if the leading dim of input_handle.element_shape or the element_shape input arg is not already set. tensor: The concated result. lengths: Output tensor containing sizes of the 0th dimension of tensors in the list, used for computing the gradient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283005accaa8725b1effabae996e96c38596ffe2" translate="yes" xml:space="preserve">
          <source>input_handle: The input list. tensor: The concated result. lengths: Output tensor containing sizes of the 0th dimension of tensors in the list, used for computing the gradient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b57d8cb8f2c7388418aee73ab74fa0c0c297704" translate="yes" xml:space="preserve">
          <source>input_handle: The input tensor list. indices: The indices used to index into the list. values: The tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7011d9b4bf358b97a48c238031fd3264c400a3" translate="yes" xml:space="preserve">
          <source>input_handle: The list to scatter into. tensor: The input tensor. indices: The indices used to index into the list. output_handle: The TensorList.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8835e935414639ae9512682c0c1a4546fed4ed" translate="yes" xml:space="preserve">
          <source>input_handle: the input list length: the number of tensors in the list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c50b1381a74c3e46e5b809407320eccddb9eb98" translate="yes" xml:space="preserve">
          <source>input_handle: the input list size: size of the output list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a08b7c24eb6b500cc22628acfceb557cfa4c118" translate="yes" xml:space="preserve">
          <source>input_handle: the input list tensor: the gathered result num_elements: optional. If not -1, the number of elements in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe68263bcaebe2a3a1b9eab67e0114edbdba14e7" translate="yes" xml:space="preserve">
          <source>input_handle: the input list tensor: the withdrawn last element of the list element_dtype: the type of elements in the list element_shape: the shape of the output tensor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6360984b7a9c9d12a90984af246c0aa280bf9ad" translate="yes" xml:space="preserve">
          <source>input_handle: the list element_shape: the shape of elements of the list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3770c102faff09bf011a6b84219c9382414d7c2" translate="yes" xml:space="preserve">
          <source>input_handle: the list index: the position in the list from which an element will be retrieved item: the element at that position</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46edb374b25241f59c112ffaba0d4fe5519b6a78" translate="yes" xml:space="preserve">
          <source>input_handle: the list index: the position in the list to which the tensor will be assigned item: the element to be assigned to that position output_handle: the new list, with the element in the proper position</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6636d976b19900c17bca1fac423d73e4d6eb288" translate="yes" xml:space="preserve">
          <source>input_row_length : the number of rows from the input set</source>
          <target state="translated">input_row_length:количество строк из входного набора</target>
        </trans-unit>
        <trans-unit id="215a6dcf472f6c123943af88a21bbf3143d9ebee" translate="yes" xml:space="preserve">
          <source>input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1], ..., input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],</source>
          <target state="translated">input_shape[1]*block_shape[0]-crops[0,0]-crops[0,1],...,input_shape[M]*block_shape[M-1]-crops[M-1,0]-crops[M-1,1],</target>
        </trans-unit>
        <trans-unit id="9d36dc3b6c97433831476772c5fa29cae87f5700" translate="yes" xml:space="preserve">
          <source>input_shape[1] * block_shape[0], ..., input_shape[M] * block_shape[M-1],</source>
          <target state="translated">input_shape[1]*block_shape[0],...,input_shape[M]*block_shape[M-1],</target>
        </trans-unit>
        <trans-unit id="63f5e29ebb7d178d9dfb7b2f4ea4565fd5f6a4a4" translate="yes" xml:space="preserve">
          <source>input_shape[1], block_shape[0], ..., input_shape[M], block_shape[M-1],</source>
          <target state="translated">input_shape[1],block_shape[0],...,input_shape[M],block_shape[M-1],</target>
        </trans-unit>
        <trans-unit id="582b93828bed7d84c78292a961b930efdc258c75" translate="yes" xml:space="preserve">
          <source>input_shape[M+1], ..., input_shape[N-1]]</source>
          <target state="translated">input_shape[M+1],...,input_shape[N-1]].</target>
        </trans-unit>
        <trans-unit id="04ae7cd2ef08de761d9073ecaa10ec67c57edd40" translate="yes" xml:space="preserve">
          <source>input_shapes = [[(1, 16), (2, 16)], # 1st input list [(2, 32), (4, 32)], # 2nd list of two tensors [(4, 32), (8, 32)]] # 3rd input list for shapes in input_shapes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f68a6baf94c1f452df94234dcc9776df37696bb" translate="yes" xml:space="preserve">
          <source>insert(self: tensorflow.python._tf_stack.StackSummary, i: int, x: tensorflow.python._tf_stack.FrameSummary) -&amp;gt; None</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6568964b0e39083c6acb94093d9e6cd117dbe508" translate="yes" xml:space="preserve">
          <source>instead.</source>
          <target state="translated">instead.</target>
        </trans-unit>
        <trans-unit id="2f9bde6003a82465d3f4ef4fdd4399a04f1de2e9" translate="yes" xml:space="preserve">
          <source>int or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0eed1a55db9de5544817b768e61cb1cd45fe6a" translate="yes" xml:space="preserve">
          <source>int or None. Maximum sequence length. Any longer sequence will be truncated. Defaults to None, which means no truncation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5664576dc4f87206b50030d57d6768eb73a71d5c" translate="yes" xml:space="preserve">
          <source>int tensor of shape [batch] with new sequence lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46ddedc8cf24d0883e0acd9e725eaf0ff6dcf04" translate="yes" xml:space="preserve">
          <source>int, An id used to group one or more different &lt;code&gt;run_meta&lt;/code&gt; together. When profiling with the profile_xxx APIs, user can use the &lt;code&gt;step&lt;/code&gt; id in the &lt;code&gt;options&lt;/code&gt; to profile these &lt;code&gt;run_meta&lt;/code&gt; together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b5b2f198a3ff362a8c83f14a6daa8c5c2b7a28" translate="yes" xml:space="preserve">
          <source>int, The number of units in the GRU cell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc296fbc289298c32c38d6a3cf7af36aeb4e509" translate="yes" xml:space="preserve">
          <source>int, The number of units in the LSTM cell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6079936d03f39b9d377f9f40e03b7579ca069e8e" translate="yes" xml:space="preserve">
          <source>int, The number of units in the RNN cell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30782762ff76ac21f3e65138ef3acfa681f111e" translate="yes" xml:space="preserve">
          <source>int, end of desired slice of the specified dataset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc1d238af4e15eaa99001def12710a94dd3bea7" translate="yes" xml:space="preserve">
          <source>int, float, or unit Tensor representing the batch size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d5510f4ef1c938c12593fd333f4019ef98dabe" translate="yes" xml:space="preserve">
          <source>int, max value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230988ff1d19a9cf77ed5605cf7608ed682d8b30" translate="yes" xml:space="preserve">
          <source>int, max values of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd29d19510bed1b5d54e2dabfe095750210a7d0" translate="yes" xml:space="preserve">
          <source>int, maximum length of a line, includes indentation. If this is None then use get_help_width()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b315d1c6b15b5d9dcc6d8b79a1d520ecb6974ea" translate="yes" xml:space="preserve">
          <source>int, min value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec5ec2722d1f4df1223a498cc4dbc71ec73bb21" translate="yes" xml:space="preserve">
          <source>int, min values of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054e5df82dda564d33f6f2931c07e3d53e9bd7cf" translate="yes" xml:space="preserve">
          <source>int, number of epochs to iterate over data. If not &lt;code&gt;None&lt;/code&gt;, read attempts that would exceed this value will raise &lt;code&gt;OutOfRangeError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3862c9df968a140114068b9539e21d0c3daa1133" translate="yes" xml:space="preserve">
          <source>int, size of batches to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5db02160dca52f1623f8be98146197403d3411" translate="yes" xml:space="preserve">
          <source>int, size of the read queue. If &lt;code&gt;None&lt;/code&gt;, it will be set roughly to the size of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29380ce9e2226edac854b23229e7633b0a1eb5b0" translate="yes" xml:space="preserve">
          <source>int, start of desired slice of the specified dataset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6b41b374fece6a9af6f4256474d6e327b765e6" translate="yes" xml:space="preserve">
          <source>int, the ID of the Python module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8204c9700ffd9a6a1b29fd552f467b6e1bc1af27" translate="yes" xml:space="preserve">
          <source>int, the verbosity level; larger values specify increased verbosity; 0 means no logging. When reporting bugs, it is recommended to set this value to a larger number, like 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6216f3e4478c83715a395073f2db96bff3b46d94" translate="yes" xml:space="preserve">
          <source>int. 0: quiet, 1: update messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f56362a039889d43f24d78d50db90ee5cf0906a" translate="yes" xml:space="preserve">
          <source>int. Index actual words with this index and higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c15e7173596131e54cdb909a99e52ff2ba5740" translate="yes" xml:space="preserve">
          <source>int. Optional device index. If left unspecified, device represents 'any' device_index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea704d73d1003bd6d5a57f817c6bf9bcf4ec1b47" translate="yes" xml:space="preserve">
          <source>int. Optional replica index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb41d73567ac2d756b283354a12d3c325487f7e2" translate="yes" xml:space="preserve">
          <source>int. Optional task index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3b8ca316feee1257d3426385887cc0008e667c" translate="yes" xml:space="preserve">
          <source>int. Seed for reproducible data shuffling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d908dfe5222f1ddea532a2322c44a316ac3adb" translate="yes" xml:space="preserve">
          <source>int. Size of vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e556913a5bf2d8d4fb4552035deb524387e8a56" translate="yes" xml:space="preserve">
          <source>int. The out-of-vocabulary character. Words that were cut out because of the &lt;code&gt;num_words&lt;/code&gt; or &lt;code&gt;skip_top&lt;/code&gt; limits will be replaced with this character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2313c3665615adc9dec0480e8490d6f380a84042" translate="yes" xml:space="preserve">
          <source>int. The start of a sequence will be marked with this character. Defaults to 1 because 0 is usually the padding character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f05ef2bc7b475649b158a11f8552affc6863b58" translate="yes" xml:space="preserve">
          <source>int32 Tensor of &lt;em&gt;known&lt;/em&gt; shape [num_spatial_dims].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccac6818a55817c365424628ae2c09fbef822cd5" translate="yes" xml:space="preserve">
          <source>int32 Tensor of shape [N].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc527931e976f53f23a0e88c398e756d2e88fc29" translate="yes" xml:space="preserve">
          <source>int: integer number of pixels from interval &lt;code&gt;(-height_shift_range, +height_shift_range)&lt;/code&gt;</source>
          <target state="translated">int: целое число пикселей из интервала &lt;code&gt;(-height_shift_range, +height_shift_range)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8f7cdaeefccaf14822ef0c14861152b6b6ce396" translate="yes" xml:space="preserve">
          <source>int: integer number of pixels from interval &lt;code&gt;(-width_shift_range, +width_shift_range)&lt;/code&gt;</source>
          <target state="translated">int: целое число пикселей из интервала &lt;code&gt;(-width_shift_range, +width_shift_range)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e2c0ac917d5350fc1a4cf40b10454dda60aca31" translate="yes" xml:space="preserve">
          <source>int_A^B{Precision.dP} = TP_B - TP_A + intercept * log(P_B / P_A)</source>
          <target state="translated">int_A^B{Precision.dP}=TP_B-TP_A+перехват*log(P_B/P_A)</target>
        </trans-unit>
        <trans-unit id="bb0ad77554cdd0adb1dbb32ec50fd302af02ad5f" translate="yes" xml:space="preserve">
          <source>int_A^B{Precision.dP} = int_A^B{(TP_A + slope * (P - P_A)) * dP / P} int_A^B{Precision.dP} = int_A^B{slope * dP + intercept * dP / P}</source>
          <target state="translated">int_A^B{Precision.dP}=int_A^B{(TP_A+наклон*(P-P_A))*dP/P}int_A^B{Precision.dP}=int_A^B{slope*dP+перехват*dP/P}</target>
        </trans-unit>
        <trans-unit id="39e14144cd47793f78fb4552d74a0e79713534a3" translate="yes" xml:space="preserve">
          <source>int_A^B{Precision.dTP} = int_A^B{slope * dTP} = slope * (TP_B - TP_A)</source>
          <target state="translated">int_A^B{Precision.dTP}=int_A^B{slope*dTP}=наклон*(TP_B-TP_A)</target>
        </trans-unit>
        <trans-unit id="41ad7f4bf1092487ace16bf267f3321476d0f37b" translate="yes" xml:space="preserve">
          <source>integer dilate rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43abaa1a6dece1d4545a543c8b96a247a4b6e658" translate="yes" xml:space="preserve">
          <source>integer or None. Words are ranked by how often they occur (in the training set) and only the &lt;code&gt;num_words&lt;/code&gt; most frequent words are kept. Any less frequent word will appear as &lt;code&gt;oov_char&lt;/code&gt; value in the sequence data. If None, all words are kept. Defaults to None, so all words are kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a117af2f4b51126c775c85b2f584681d435937b" translate="yes" xml:space="preserve">
          <source>integer or tuple of 2 integers, factors by which to downscale (vertical, horizontal). &lt;code&gt;(2, 2)&lt;/code&gt; will halve the input in both spatial dimension. If only one integer is specified, the same window length will be used for both dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590fe655fa939c5479690ced9e84582e2ebf5e9d" translate="yes" xml:space="preserve">
          <source>integer or tuple of 2 integers, window size over which to take the maximum. &lt;code&gt;(2, 2)&lt;/code&gt; will take the max value over a 2x2 pooling window. If only one integer is specified, the same window length will be used for both dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b832237f240d3a87036c5ddaf0c2618088edd20" translate="yes" xml:space="preserve">
          <source>integer tensor, all its values &amp;lt;= maxlen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7903aed43b37636323afcd940313c050618e452" translate="yes" xml:space="preserve">
          <source>integer type to use for the output. Defaults to int64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b53264719a32144ffad3789541b76d8cf9c57c2" translate="yes" xml:space="preserve">
          <source>integer, axis along which to calculate weight norms. For instance, in a &lt;code&gt;Dense&lt;/code&gt; layer the weight matrix has shape &lt;code&gt;(input_dim, output_dim)&lt;/code&gt;, set &lt;code&gt;axis&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; to constrain each weight vector of length &lt;code&gt;(input_dim,)&lt;/code&gt;. In a &lt;code&gt;Conv2D&lt;/code&gt; layer with &lt;code&gt;data_format=&quot;channels_last&quot;&lt;/code&gt;, the weight tensor has shape &lt;code&gt;(rows, cols, input_depth, output_depth)&lt;/code&gt;, set &lt;code&gt;axis&lt;/code&gt; to &lt;code&gt;[0, 1, 2]&lt;/code&gt; to constrain the weights of each filter tensor of size &lt;code&gt;(rows, cols, input_depth)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c016832a41b3a8b00cba889f8b4ab61d07d7a7da" translate="yes" xml:space="preserve">
          <source>integer.</source>
          <target state="translated">integer.</target>
        </trans-unit>
        <trans-unit id="0b17a7fb25b998d0349d6e49fee952795757002c" translate="yes" xml:space="preserve">
          <source>interger. Number of TPU cores per host (TPU worker).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea37f716d80c5d5766be3d807d6507886fea4fa" translate="yes" xml:space="preserve">
          <source>interger. Total number of TPU cores in the TPU system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b6ad6db09f08022ce078fe6325a30a510b786a" translate="yes" xml:space="preserve">
          <source>interger. Total number of hosts (TPU workers) in the TPU system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53f8c97c06a77e41fa5044607dbf66fbec85e2d" translate="yes" xml:space="preserve">
          <source>int|str|None, the default value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f7be3973564f89ba62497d80421972d63f27b9" translate="yes" xml:space="preserve">
          <source>invalid &lt;code&gt;data_format&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="894f3b3529bf71efe7937ab07c46560e20b26e29" translate="yes" xml:space="preserve">
          <source>invalid bias shape. the bias should be either a vector or a tensor with ndim(x) - 1 dimension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16067b331b6522917e0d813c0172cf6085c21bf7" translate="yes" xml:space="preserve">
          <source>is alive, any other request to use &lt;code&gt;MutexLock&lt;/code&gt; with this mutex will wait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec285792f84b2006557cfe7a76ef03e4dffbd46" translate="yes" xml:space="preserve">
          <source>is equivalent to</source>
          <target state="translated">равносильно</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">эквивалентно:</target>
        </trans-unit>
        <trans-unit id="f676744fe1cc3cdeedd163ef5929b52761f5e2b1" translate="yes" xml:space="preserve">
          <source>is the bias and</source>
          <target state="translated">заключается в предвзятости и</target>
        </trans-unit>
        <trans-unit id="0dcf56b0234c8aefebc21b87a267f1607f2ebd4e" translate="yes" xml:space="preserve">
          <source>is the incomplete beta function and \(B(a, b)\) is the &lt;em&gt;complete&lt;/em&gt; beta function.</source>
          <target state="translated">- неполная бета-функция, а \ (B (a, b) \) - &lt;em&gt;полная&lt;/em&gt; бета-функция.</target>
        </trans-unit>
        <trans-unit id="8d6ec29819896c7154ba310ecfb294ffe6dd6d28" translate="yes" xml:space="preserve">
          <source>is the lower incomplete Gamma function.</source>
          <target state="translated">это нижняя незавершенная Гамма-функция.</target>
        </trans-unit>
        <trans-unit id="142410405cb1c972e9f58af8472ded75d6af685d" translate="yes" xml:space="preserve">
          <source>is the upper incomplete Gama function.</source>
          <target state="translated">это верхняя незавершенная функция Гамы.</target>
        </trans-unit>
        <trans-unit id="4fe98637c52118c1b88b8e69237d3989ab4385e5" translate="yes" xml:space="preserve">
          <source>is the weight for each feature.</source>
          <target state="translated">это вес каждой функции.</target>
        </trans-unit>
        <trans-unit id="1b558105be66aeb17157d59d874d5960ad8485e8" translate="yes" xml:space="preserve">
          <source>is this::</source>
          <target state="translated">это..:</target>
        </trans-unit>
        <trans-unit id="2b217fdb184b9d9882d21ca5fad129a9fbae103d" translate="yes" xml:space="preserve">
          <source>is variable index):</source>
          <target state="translated">это переменный индекс):</target>
        </trans-unit>
        <trans-unit id="b0537e4d6ce429000c7efae02c6d89e7e8155b98" translate="yes" xml:space="preserve">
          <source>is_cuda_build</source>
          <target state="translated">is_cuda_build</target>
        </trans-unit>
        <trans-unit id="234ef7acfb58a3c9c579d74f2913f2eec23f173a" translate="yes" xml:space="preserve">
          <source>is_rocm_build</source>
          <target state="translated">is_rocm_build</target>
        </trans-unit>
        <trans-unit id="2a269871329b58d031adee27475a94b6e6e1000d" translate="yes" xml:space="preserve">
          <source>it cannot be directly used here as there is no fast way of applying it to each prefix &lt;code&gt;x[:i]&lt;/code&gt;. Instead, this function implements a prefix scan using pairwise log-add-exp, which is a commutative and associative (up to floating point precision) operator:</source>
          <target state="translated">его нельзя использовать здесь напрямую, так как нет быстрого способа применить его к каждому префиксу &lt;code&gt;x[:i]&lt;/code&gt; . Вместо этого эта функция реализует сканирование префикса с использованием попарного log-add-exp, который является коммутативным и ассоциативным (до точности с плавающей запятой) оператором:</target>
        </trans-unit>
        <trans-unit id="c91b64061d65424690ab93c1cadfda56911f5863" translate="yes" xml:space="preserve">
          <source>it cannot be sent to saver.save.</source>
          <target state="translated">он не может быть отправлен в Спасательную службу.</target>
        </trans-unit>
        <trans-unit id="e7ed9bb61b5e9527391909f9689ba90b9c8a52db" translate="yes" xml:space="preserve">
          <source>it cannot be sent to tf.train.start_queue_runners.</source>
          <target state="translated">он не может быть отправлен в tf.train.start_queue_runners.</target>
        </trans-unit>
        <trans-unit id="979398de5704ce65c4da53333edd85506c0856eb" translate="yes" xml:space="preserve">
          <source>it cannot be set as default session.</source>
          <target state="translated">он не может быть установлен как сессия по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6b1c9628e4067445b63db13a5f2bb0ff8b36b2e0" translate="yes" xml:space="preserve">
          <source>it encourages code like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbac1575d647eff7684772bff845140722b05af" translate="yes" xml:space="preserve">
          <source>iterable of integers, axes over which to normalize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b7c03ec646d98cecbdc829c7cb94fc14b897a1" translate="yes" xml:space="preserve">
          <source>join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception.</source>
          <target state="translated">join()вызывает ошибку RuntimeError,если была предпринята попытка присоединиться к текущему потоку,так как это может привести к блокировке.Ошибка join()потока до того,как он был запущен,и попытки сделать это вызывают такое же исключение.</target>
        </trans-unit>
        <trans-unit id="f6d10c00c34234489f716bd2e3f78dd7440668ea" translate="yes" xml:space="preserve">
          <source>k1 = 0.01, k2 = 0.03 as in the original paper.</source>
          <target state="translated">k1=0,01,k2=0,03,как в оригинальной бумаге.</target>
        </trans-unit>
        <trans-unit id="2447a7104e7dbfc8f3bb57ae9cd432d50ee2bc43" translate="yes" xml:space="preserve">
          <source>kernel for the 1x1 convolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663aeaf75fbec7b21b7a40eb091f9ce24d07826f" translate="yes" xml:space="preserve">
          <source>kernel tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ede5b354ee4a1c5164e60fe2d53bb97c2244f6" translate="yes" xml:space="preserve">
          <source>key from the underlying container. If the underlying container does not contain elements, the op will block until it does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746933d303018c9218bbc90844b142026fe52928" translate="yes" xml:space="preserve">
          <source>key: Optional key &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt;. If not given, will use &lt;code&gt;value&lt;/code&gt; for both &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;, which is the most common case.</source>
          <target state="translated">key: Необязательный ключ &lt;code&gt;Tensor&lt;/code&gt; формы &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt; . Если не указан, будет использоваться &lt;code&gt;value&lt;/code&gt; как для &lt;code&gt;key&lt;/code&gt; и для &lt;code&gt;value&lt;/code&gt; , что является наиболее распространенным случаем.</target>
        </trans-unit>
        <trans-unit id="adacddebefc3dd0e469298a88e6a9c2818bfa9dd" translate="yes" xml:space="preserve">
          <source>keyword arguments. Allowed to be {&lt;code&gt;clipnorm&lt;/code&gt;, &lt;code&gt;clipvalue&lt;/code&gt;, &lt;code&gt;lr&lt;/code&gt;, &lt;code&gt;decay&lt;/code&gt;}. &lt;code&gt;clipnorm&lt;/code&gt; is clip gradients by norm; &lt;code&gt;clipvalue&lt;/code&gt; is clip gradients by value, &lt;code&gt;decay&lt;/code&gt; is included for backward compatibility to allow time inverse decay of learning rate. &lt;code&gt;lr&lt;/code&gt; is included for backward compatibility, recommended to use &lt;code&gt;learning_rate&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35e13567a5689a8b7dde2328fe3e4c5fa48b8d1" translate="yes" xml:space="preserve">
          <source>keyword config parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54451c21257979511cfbd1def6d53261c814f975" translate="yes" xml:space="preserve">
          <source>keyword named properties with new values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b3e86d41182d7b39ce5d557e3cd1a85d63c1f8" translate="yes" xml:space="preserve">
          <source>kl_fn</source>
          <target state="translated">kl_fn</target>
        </trans-unit>
        <trans-unit id="24abaadf79e408cd76a10c64d002674f26391ff5" translate="yes" xml:space="preserve">
          <source>kvar = tf.keras.backend.random_normal_variable((2,3), 0, 1) kvar</source>
          <target state="translated">kvar=tf.keras.backend.random_normal_variable((2,3),0,1)kvar</target>
        </trans-unit>
        <trans-unit id="c3c9a96154cb7c4bd07af48c88b12aa1479bb2b6" translate="yes" xml:space="preserve">
          <source>kvar = tf.keras.backend.random_uniform_variable((2,3), 0, 1) kvar</source>
          <target state="translated">kvar=tf.keras.backend.random_uniform_variable((2,3),0,1)kvar</target>
        </trans-unit>
        <trans-unit id="6e0723fd76ed9f3c2c5df83628e9240f5b0ae65e" translate="yes" xml:space="preserve">
          <source>labels: Labels &lt;code&gt;Tensor&lt;/code&gt; or dict of &lt;code&gt;Tensor&lt;/code&gt; created by &lt;code&gt;input_fn&lt;/code&gt; which is given to &lt;code&gt;estimator.evaluate&lt;/code&gt; as an argument.</source>
          <target state="translated">label: Ярлыки &lt;code&gt;Tensor&lt;/code&gt; или dict of &lt;code&gt;Tensor&lt;/code&gt; , созданные &lt;code&gt;input_fn&lt;/code&gt; , который передается в &lt;code&gt;estimator.evaluate&lt;/code&gt; в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="d1df609660312a9560a72f9aa327c9fb1db105e0" translate="yes" xml:space="preserve">
          <source>last_step_outputs: A dictionary containing tensors set using &lt;code&gt;context.set_last_step_output&lt;/code&gt;. Evaluating this returns the value of the tensors after the last iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d49ed7bf167bb64f672116300ae6f34b6b9a7ba" translate="yes" xml:space="preserve">
          <source>launches queue runners</source>
          <target state="translated">бегуны в очереди на запуски</target>
        </trans-unit>
        <trans-unit id="3d00b829e9a96fd10fcba58b30f25d9fe2f0f4bb" translate="yes" xml:space="preserve">
          <source>layer = tf.keras.layers.experimental.preprocessing.Hashing(num_bins=3) inp_1 = [['A'], ['B'], ['C'], ['D'], ['E']] inp_2 = np.asarray([[5], [4], [3], [2], [1]]) layer([inp_1, inp_2])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a8bd371d2e19bb30141638acf06237b1c58fc4" translate="yes" xml:space="preserve">
          <source>layer instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033f565e01d360e75a63cfc4ed8abc2d9bcbc29e" translate="yes" xml:space="preserve">
          <source>layout_optimizer: Optimize tensor layouts e.g. This will try to use NCHW layout on GPU which is faster.</source>
          <target state="translated">layout_optimizer:Оптимизируйте тензорные раскладки,например,это позволит быстрее использовать NCHW-раскладку на GPU.</target>
        </trans-unit>
        <trans-unit id="de912af8c403df09ae093f3ebc260a0b7982613f" translate="yes" xml:space="preserve">
          <source>legacy arguments for raising deprecation warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836ce2611c75a89c39d48f11d0922cb87c235da8" translate="yes" xml:space="preserve">
          <source>length &lt;code&gt;num_new_vocab&lt;/code&gt;, where &lt;code&gt;remapping[i]&lt;/code&gt; contains the row number in the old vocabulary that corresponds to row &lt;code&gt;i&lt;/code&gt; in the new vocabulary (starting at line &lt;code&gt;new_vocab_offset&lt;/code&gt; and up to &lt;code&gt;num_new_vocab&lt;/code&gt; entities), or &lt;code&gt;-1&lt;/code&gt; if entry &lt;code&gt;i&lt;/code&gt; in the new vocabulary is not in the old vocabulary. The old vocabulary is constrained to the first &lt;code&gt;old_vocab_size&lt;/code&gt; entries if &lt;code&gt;old_vocab_size&lt;/code&gt; is not the default value of -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bb132ecb3e48056046d38672212aba9e55d251" translate="yes" xml:space="preserve">
          <source>length of the labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162fcf77aa289dc1be6b089b206972465dbb0e6c" translate="yes" xml:space="preserve">
          <source>length(row_pooling_sequence) = output_row_length+1</source>
          <target state="translated">length(row_pooling_sequence)=output_row_length+1</target>
        </trans-unit>
        <trans-unit id="c0d68c3655d810d9dd234c6dcf2a4286f6313cfc" translate="yes" xml:space="preserve">
          <source>limit the search to CUDA GPUs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72487028abdec24d4c26714830b89ad0f798843" translate="yes" xml:space="preserve">
          <source>linalg.lstsq is currently disabled for complex128 and l2_regularizer != 0 due to poor accuracy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947b76ec4efd6f9898868316cb4d3a02b4e37eba" translate="yes" xml:space="preserve">
          <source>linear models with L1 + L2 regularization. As global optimization objective is strongly-convex, the optimizer optimizes the dual objective at each step. The optimizer applies each update one example at a time. Examples are sampled uniformly, and the optimizer is learning rate free and enjoys linear convergence rate.</source>
          <target state="translated">линейные модели с регуляризацией L1+L2.Так как глобальная цель оптимизации сильно запутана,оптимизатор оптимизирует двойную цель на каждом шаге.Оптимизатор применяет каждое обновление по одному примеру за раз.Примеры выбираются равномерно,оптимизатор не учится и пользуется скоростью линейной конвергенции.</target>
        </trans-unit>
        <trans-unit id="7308a8c20d33a3e94b3227fed5100a94eff003d7" translate="yes" xml:space="preserve">
          <source>list (or concatenation) of characters to filter out, such as punctuation. Default: &lt;code&gt;!&quot;#$%&amp;amp;()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~\t\n&lt;/code&gt;, includes basic punctuation, tabs, and newlines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fef61c0d5995d89d56e34853569b3b9b98286d8" translate="yes" xml:space="preserve">
          <source>list (or concatenation) of characters to filter out, such as punctuation. Default: &lt;code&gt;'!&quot;#$%&amp;amp;()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_&lt;/code&gt;{|}~\t\n'&lt;code&gt;, includes basic punctuation, tabs, and newlines. &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&lt;/code&gt;lower&lt;code&gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; boolean. Whether to convert the input to lowercase. &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&lt;/code&gt;split`</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dff54048dbe22b39baf29ee573ea8afaa88783b0" translate="yes" xml:space="preserve">
          <source>list of &lt;code&gt;CheckpointSaverListener&lt;/code&gt; objects. Used for callbacks that run immediately before or after checkpoint savings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643566612078338af9f1a1af14b6055f2d4ad7c0" translate="yes" xml:space="preserve">
          <source>list of &lt;code&gt;DType&lt;/code&gt; objects. List of the types of the &lt;code&gt;Tensors&lt;/code&gt; computed by this operation. The length of this list indicates the number of output endpoints of the &lt;code&gt;Operation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cf3012e63b0e58ac49a787fb2deb7b3f096226" translate="yes" xml:space="preserve">
          <source>list of &lt;code&gt;SessionRunHook&lt;/code&gt; objects. Activate these hooks if &lt;code&gt;is_chief==True&lt;/code&gt;, ignore otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba2ff79573703e07e2d4ca6b4f23bed4f6686fa" translate="yes" xml:space="preserve">
          <source>list of &lt;code&gt;Tensor&lt;/code&gt; objects. The inputs to this &lt;code&gt;Operation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2d6c83aa6624e4363b6f0f66e90098561768b7" translate="yes" xml:space="preserve">
          <source>list of &lt;code&gt;str&lt;/code&gt;, name of the keys to predict. It is used if the &lt;a href=&quot;../../../../estimator/estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;dict&lt;/code&gt;. If &lt;code&gt;predict_keys&lt;/code&gt; is used then rest of the predictions will be filtered from the dictionary. If &lt;code&gt;None&lt;/code&gt;, returns all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3e9875b2e5cbf56b910b0dfce787cd8443185d" translate="yes" xml:space="preserve">
          <source>list of &lt;code&gt;str&lt;/code&gt;, name of the keys to predict. It is used if the &lt;a href=&quot;../../../estimator/estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;dict&lt;/code&gt;. If &lt;code&gt;predict_keys&lt;/code&gt; is used then rest of the predictions will be filtered from the dictionary. If &lt;code&gt;None&lt;/code&gt;, returns all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995c5a65e0c3b03906a5d4333e88c1d72153487d" translate="yes" xml:space="preserve">
          <source>list of &lt;code&gt;str&lt;/code&gt;, name of the keys to predict. It is used if the &lt;a href=&quot;../estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;dict&lt;/code&gt;. If &lt;code&gt;predict_keys&lt;/code&gt; is used then rest of the predictions will be filtered from the dictionary. If &lt;code&gt;None&lt;/code&gt;, returns all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c7f34cb053bc6d68921b3d4729574d9d60abcf" translate="yes" xml:space="preserve">
          <source>list of &lt;code&gt;str&lt;/code&gt;, name of the keys to predict. It is used if the &lt;a href=&quot;estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;dict&lt;/code&gt;. If &lt;code&gt;predict_keys&lt;/code&gt; is used then rest of the predictions will be filtered from the dictionary, with the exception of 'bias' and 'dfc', which will always be in the dictionary. If &lt;code&gt;None&lt;/code&gt;, returns all keys in prediction dict, as well as two new keys 'dfc' and 'bias'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7314e983b64c8a1004f247534a8a37dc3e20cf40" translate="yes" xml:space="preserve">
          <source>list of &lt;code&gt;str&lt;/code&gt;, name of the keys to predict. It is used if the &lt;a href=&quot;estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;dict&lt;/code&gt;. If &lt;code&gt;predict_keys&lt;/code&gt; is used then rest of the predictions will be filtered from the dictionary. If &lt;code&gt;None&lt;/code&gt;, returns all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd6fb9286244be4bc458d2ab254b67e23514821" translate="yes" xml:space="preserve">
          <source>list of RNNCells that will be composed in this order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7a8c95dcedc3b82095d107b683ac751a7d674c" translate="yes" xml:space="preserve">
          <source>list of node name regexes from where to stop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081bcce041047d385de4457d4e8992f91f854f35" translate="yes" xml:space="preserve">
          <source>list of node name regexes to start displaying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f087f76fc81e32ab0c89f91f9415be13eb676c" translate="yes" xml:space="preserve">
          <source>list of node names regexes to display.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346c8b5bd0392f3edf47e18a834c0a29bf479e4f" translate="yes" xml:space="preserve">
          <source>list of node_names regexes that should be hidden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d200015e3bdd27707d4e305ba976546c37e6b9" translate="yes" xml:space="preserve">
          <source>list of operations or tensors from which to have a control dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8120d3b2d7dac14eb66fbe5c6784a48b39163524" translate="yes" xml:space="preserve">
          <source>list of ops to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3107dcf2aa34afbad06d2de13a1d8cda7a23d817" translate="yes" xml:space="preserve">
          <source>list of tags to load the SavedModel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435ca5783ffb2592dd0edf0c7f101fcfe85fd6a3" translate="yes" xml:space="preserve">
          <source>list of targets to run to initialize model params.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a73baefee3b6fa1d6db401e91416fb3a14f0540" translate="yes" xml:space="preserve">
          <source>list of tensors to concatenate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057b63600e3eca820c6af31fb672c1a8c7b7df28" translate="yes" xml:space="preserve">
          <source>list or tuple of &lt;code&gt;Variable&lt;/code&gt; objects to update to minimize &lt;code&gt;loss&lt;/code&gt;, or a callable returning the list or tuple of &lt;code&gt;Variable&lt;/code&gt; objects. Use callable when the variable list would otherwise be incomplete before &lt;code&gt;minimize&lt;/code&gt; since the variables are created at the first time &lt;code&gt;loss&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50a5033735695b28f6818c8f852decfa160aaa7" translate="yes" xml:space="preserve">
          <source>list[i] corresponds to lengths[i] tensors from the input tensor. The tensor must have rank at least 1 and contain exactly sum(lengths) elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5a471e4e472610162cc920a0a8b1f3cc4962e8" translate="yes" xml:space="preserve">
          <source>list|str|None, the default value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4adc00e8f35b9c7ea2cf5f3fe759e4d7f6ec04" translate="yes" xml:space="preserve">
          <source>logits &lt;code&gt;Tensor&lt;/code&gt; to be used for metrics update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce0529b97746a5ac897f12264465981df78e8d7" translate="yes" xml:space="preserve">
          <source>logits &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[D0, D1, ... DN, logits_dimension]&lt;/code&gt;. For many applications, the shape is &lt;code&gt;[batch_size, logits_dimension]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed540c2d7f8194fd56e5e404ef02b72cd59fc8b2" translate="yes" xml:space="preserve">
          <source>logits = [[4.0, 2.0, 1.0], [0.0, 5.0, 1.0]] labels = [[1.0, 0.0, 0.0], [0.0, 0.8, 0.2]] tf.nn.softmax_cross_entropy_with_logits(labels=labels, logits=logits)</source>
          <target state="translated">logits=[[4.0,2.0,1.0],[0.0,5.0,1.0]]labelels=[[1.0,0.0,0.0],[0.0,0.8,0.2]]tf.nn.softmax_cross_entropy_with_logits(labels=labels,logits=logits)</target>
        </trans-unit>
        <trans-unit id="6185c7f71f7d2edd8df9ccc47928847262a2bb51" translate="yes" xml:space="preserve">
          <source>logits = np.array([[-1., 1., 2., -2., 2.], [-1.5, 1., -3., 2., -2.]],</source>
          <target state="translated">logits=np.array([[-1.,1.,2.,-2.,2.],[-1.5,1.,-3.,2.,-2.]],</target>
        </trans-unit>
        <trans-unit id="866c662734c366b09041687025e6b355bd1714a8" translate="yes" xml:space="preserve">
          <source>logits_dict = {'head1_name': [[-1., 1.], [-1.5, 1.]],</source>
          <target state="translated">logits_dict={'head1_name':[[-1.,1.],[-1.5,1.]],</target>
        </trans-unit>
        <trans-unit id="3585aa2c2ebbed634c28803cc016cb3ccb9f8aaa" translate="yes" xml:space="preserve">
          <source>loop_optimization: Loop optimizations.</source>
          <target state="translated">loop_optimization:Оптимизация циклов.</target>
        </trans-unit>
        <trans-unit id="eb4c376897ff81e6d782b7f140744be981466ddd" translate="yes" xml:space="preserve">
          <source>lower bound of the range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232948d763baa767fe272aa331733310ab52bfc1" translate="yes" xml:space="preserve">
          <source>lower bound on the learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c778bcb682f29d959865e915ffa12abe3748d3b" translate="yes" xml:space="preserve">
          <source>m&lt;em&gt;t &amp;lt;- beta1 * m&lt;/em&gt;{t-1} + (1 - beta1) * g update &amp;lt;- (alpha + sign_decay * sign(g) *sign(m)) * g variable &amp;lt;- variable - lr_t * update</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0839c5d65b9f690257c2c1bc0f20463acce85b8c" translate="yes" xml:space="preserve">
          <source>m&lt;em&gt;t &amp;lt;- beta1 * m&lt;/em&gt;{t-1} + (1 - beta1) * g update &amp;lt;- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g variable &amp;lt;- variable - lr_t * update</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8ad4952806012750033d01510c87da45d90c97" translate="yes" xml:space="preserve">
          <source>m&lt;em&gt;t &amp;lt;- beta1 * m&lt;/em&gt;{t-1} + (1 - beta1) * g v&lt;em&gt;t &amp;lt;- max(beta2 * v&lt;/em&gt;{t-1}, abs(g)) variable &amp;lt;- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa328dac5d4e4d7e5ca5561900b7fd26e5e4787f" translate="yes" xml:space="preserve">
          <source>maintain a moving (discounted) average of the square of gradients</source>
          <target state="translated">поддерживать скользящую (дисконтированную)среднюю величину квадрата градиентов</target>
        </trans-unit>
        <trans-unit id="c6cfa9d32b834c1fc1fb3ff3fa471263651c38c9" translate="yes" xml:space="preserve">
          <source>map on the list of tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0.</source>
          <target state="translated">map в списке тензоров, распакованных из &lt;code&gt;elems&lt;/code&gt; по размерности 0.</target>
        </trans-unit>
        <trans-unit id="9e7b625b92e734eb002c177ddba41adf281266b5" translate="yes" xml:space="preserve">
          <source>matmul(sqrtm(A), sqrtm(A)) = A</source>
          <target state="translated">matmul(sqrtm(A),sqrtm(A))=A</target>
        </trans-unit>
        <trans-unit id="d71b96af3b73efa6f554324eae1dff351e1a1047" translate="yes" xml:space="preserve">
          <source>matrix_44 = tf.random.normal(shape=[2, 3, 4, 4]) operator_44 = tf.linalg.LinearOperatorFullMatrix(matrix_44)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7763e1416f160c9b8026099d7012e9750f019e98" translate="yes" xml:space="preserve">
          <source>matrix_54 = tf.random.normal(shape=[1, 3, 5, 4]) operator_54 = tf.linalg.LinearOperatorFullMatrix(matrix_54)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518acf933b493400a775cc502490ed749f6bc57a" translate="yes" xml:space="preserve">
          <source>matrix_55 = tf.random.normal(shape=[1, 3, 5, 5]) operator_55 = tf.linalg.LinearOperatorFullMatrix(matrix_55)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b4e3699ad245e971e7d4fc86ac2a202b9f320b" translate="yes" xml:space="preserve">
          <source>maximum depth of the tree to grow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e113b391c148ef4e9fe73c27b142fe7cf14e0176" translate="yes" xml:space="preserve">
          <source>maximum of two tensors</source>
          <target state="translated">максимум два тензора</target>
        </trans-unit>
        <trans-unit id="6de8519dfb9500969d9b3dce614b54961a05616d" translate="yes" xml:space="preserve">
          <source>maximum time to wait on &lt;code&gt;thread.join()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd23654ef9778af82d4ad788acd41cc9c12ed956" translate="yes" xml:space="preserve">
          <source>mean_square = decay * mean_square + (1-decay) * gradient ** 2 Delta = learning_rate * gradient / sqrt(mean_square + epsilon)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17283f13497ba07d46ef42402b4ae8be7242eb7" translate="yes" xml:space="preserve">
          <source>mean_square = decay * mean_square + (1-decay) * gradient ** 2 mean_grad = decay * mean_grad + (1-decay) * gradient</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f189ed59f005d8808f37b207d8eb67f3b6b46c2c" translate="yes" xml:space="preserve">
          <source>mean_square = decay * mean_square + (1-decay) * gradient ** 2 mean_grad = decay * mean_grad + (1-decay) * gradient Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242248717e980d85eddffe714ae27d7915350fd3" translate="yes" xml:space="preserve">
          <source>metadata in key-value pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f13766eaa1a62602c25a2bdfad4bbbda3fc7ce7" translate="yes" xml:space="preserve">
          <source>mg &amp;lt;- rho * mg&lt;em&gt;{t-1} + (1-rho) * grad ms &amp;lt;- rho * ms&lt;/em&gt;{t-1} + (1-rho) * grad * grad mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon) var &amp;lt;- var - mom</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bc9d34bb8354e3db17530dd6256fd0f6187184" translate="yes" xml:space="preserve">
          <source>min_graph_nodes: The minimum number of nodes in a graph to optimizer. For smaller graphs, optimization is skipped.</source>
          <target state="translated">min_graph_nodes:Минимальное количество узлов на графике для оптимизатора.Для меньших графов оптимизация пропускается.</target>
        </trans-unit>
        <trans-unit id="91a8382a3d034d6d3d404d921863cb30f1c9d64c" translate="yes" xml:space="preserve">
          <source>min_node_weight: minimum hessian a node must have for a split to be considered. The value will be compared with &lt;code&gt;sum(leaf_hessian)/(batch_size * n_batches_per_layer)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7f00ae420f74cc3bc27b08f8bbe7edc17fc783" translate="yes" xml:space="preserve">
          <source>minimum hessian a node must have for a split to be considered. The value will be compared with &lt;code&gt;sum(leaf_hessian)/ (batch_size * n_batches_per_layer)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507140bf767842aa1b3801d26f6a121d86619e77" translate="yes" xml:space="preserve">
          <source>model_fn can populate all arguments independent of mode. In this case, some arguments will be ignored by an &lt;code&gt;Estimator&lt;/code&gt;. E.g. &lt;code&gt;train_op&lt;/code&gt; will be ignored in eval and infer modes. Example:</source>
          <target state="translated">model_fn может заполнять все аргументы независимо от режима. В этом случае некоторые аргументы будут проигнорированы в &lt;code&gt;Estimator&lt;/code&gt; . Например, &lt;code&gt;train_op&lt;/code&gt; будет игнорироваться в режимах eval и infer. Пример:</target>
        </trans-unit>
        <trans-unit id="acca6f97d19eadad381e13873d0e2843c3010026" translate="yes" xml:space="preserve">
          <source>module, the module object from which all key flags will be declared as key flags to the current module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e825ab961163a68e576e27548d4a4f935f824e" translate="yes" xml:space="preserve">
          <source>module|str, the module to describe the key flags for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce07e27cd20dd93c40e016e7d28d2355543b1ec" translate="yes" xml:space="preserve">
          <source>module|str, the module to get flags from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27b089ecf11de6423e1169bde5ba644569a1055" translate="yes" xml:space="preserve">
          <source>module|str, the module to get key flags from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99408068ad16dc8a92ff60a015ecb81d14b722dd" translate="yes" xml:space="preserve">
          <source>move the output to the right, while replacing &quot;=&quot; with &quot;-&amp;gt;&quot;. (&lt;code&gt;ij,jk-&amp;gt;ik&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6511348a585a16f79786c328d0fafa6288b5368b" translate="yes" xml:space="preserve">
          <source>ms &amp;lt;- rho * ms&lt;em&gt;{t-1} + (1-rho) * grad * grad mom &amp;lt;- momentum * mom&lt;/em&gt;{t-1} + lr * grad / sqrt(ms + epsilon) var &amp;lt;- var - mom</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0954261cf97d1f5fc41028b0cd87976524ed001" translate="yes" xml:space="preserve">
          <source>msvcp_dll_names</source>
          <target state="translated">msvcp_dll_names</target>
        </trans-unit>
        <trans-unit id="e08f36d031b6359ecae1f6373649adf7c02830aa" translate="yes" xml:space="preserve">
          <source>multiplicative factor to apply to the orthogonal matrix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daafddefe043818ecc05f461abbec68eb52ecdf3" translate="yes" xml:space="preserve">
          <source>nD integer tensor of shape &lt;code&gt;(batch_size, dim1, dim2, ... dim(n-1))&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e229d0385862d2cd370288ff8dc1c61a57b49622" translate="yes" xml:space="preserve">
          <source>name for the variable to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16755b36ba68942675be5dc836a9968f0468e549" translate="yes" xml:space="preserve">
          <source>name of operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1e3ed6bdef8946774654dc12c7162cba013b39" translate="yes" xml:space="preserve">
          <source>name of returned Keras variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f94a8a531ed21483d82469a6a478e0fb336d6b" translate="yes" xml:space="preserve">
          <source>name of the TensorFlow master to use. See the &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; constructor for how this is interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a2b57c8a3644819eb9831df936221b3ca419bb" translate="yes" xml:space="preserve">
          <source>name of the current scope, used as prefix in get_variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c21428b3226b515a8a0d2c1b183cd0989efb5de" translate="yes" xml:space="preserve">
          <source>name of the head. If provided, summary and metrics keys will be suffixed by &lt;code&gt;&quot;/&quot; + name&lt;/code&gt;. Also used as &lt;code&gt;name_scope&lt;/code&gt; when creating ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454ee1f11654483a9f5b48bcc97aebe99e8fb88d" translate="yes" xml:space="preserve">
          <source>name of the op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c4b304be84ce6baef92ee0ef88dc9b13cf4203" translate="yes" xml:space="preserve">
          <source>name to give to the op</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f2e7e3e82f9e7d296d2d556a5f456af648b586" translate="yes" xml:space="preserve">
          <source>name to give to the op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f334fd8cb7ec1e0d2260807c77e853bc844b0487" translate="yes" xml:space="preserve">
          <source>name to prepend ops with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ef030a50b21a74a99f14166d8aa16efd1f0d78" translate="yes" xml:space="preserve">
          <source>name: A name for the operation (optional).</source>
          <target state="translated">Название:Название операции (необязательно).</target>
        </trans-unit>
        <trans-unit id="7bdaedca23cabc92898abdcfd6923e6d26d0fa2c" translate="yes" xml:space="preserve">
          <source>name: An arbitrary name for this output.</source>
          <target state="translated">имя:произвольное имя для этого выхода.</target>
        </trans-unit>
        <trans-unit id="996cf0c22ba5f416f74ff08ee41b19a938cf6072" translate="yes" xml:space="preserve">
          <source>name: Optional name for the variable. Defaults to &lt;code&gt;'Variable'&lt;/code&gt; and gets uniquified automatically.</source>
          <target state="translated">name: необязательное имя для переменной. По умолчанию - &lt;code&gt;'Variable'&lt;/code&gt; и автоматически унифицируется.</target>
        </trans-unit>
        <trans-unit id="d7fa81b7fbc7f3cee2d6b448e447ff014bda8363" translate="yes" xml:space="preserve">
          <source>name: Optional name for the variable. Defaults to &lt;code&gt;'Variable'&lt;/code&gt; and gets uniquified automatically. dtype: If set, initial_value will be converted to the given type. If &lt;code&gt;None&lt;/code&gt;, either the datatype will be kept (if &lt;code&gt;initial_value&lt;/code&gt; is a Tensor), or &lt;code&gt;convert_to_tensor&lt;/code&gt; will decide.</source>
          <target state="translated">name: необязательное имя для переменной. По умолчанию - &lt;code&gt;'Variable'&lt;/code&gt; и автоматически унифицируется. dtype: если установлено, initial_value будет преобразовано в данный тип. Если &lt;code&gt;None&lt;/code&gt; , либо тип данных будет сохранен (если &lt;code&gt;initial_value&lt;/code&gt; - Tensor), либо &lt;code&gt;convert_to_tensor&lt;/code&gt; решит.</target>
        </trans-unit>
        <trans-unit id="e0f358a126b5b68b7beb2c7c0ccbe7a0f598b0d7" translate="yes" xml:space="preserve">
          <source>namedtuple of ProfilerOptions for miscellaneous profiler options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff16c98228035beb57a08a337047e37244b69a2" translate="yes" xml:space="preserve">
          <source>natural shape: [4, 5, 6] shape: [3, -1, 2] output shape: [3, 5, 2]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc86289161fa08bc82097f322478930a3b36600b" translate="yes" xml:space="preserve">
          <source>natural shape: [4, 5, 6] shape: [3, 7, 2] output shape: [3, 7, 2]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57cad7feded66b9f9604d6630c689ca444518b3" translate="yes" xml:space="preserve">
          <source>need to co-locate with reftype input(s) which are from CPU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507425dfcc920659b4327a4b5f458a65401b84ff" translate="yes" xml:space="preserve">
          <source>net = with_space_to_batch(net, dilation_rate, &quot;SAME&quot;, op_1, filter_shape_1) ... net = with_space_to_batch(net, dilation_rate, &quot;SAME&quot;, op_k, filter_shape_k)</source>
          <target state="translated">net=с_пробел_в_бэтч(net,dilation_rate,&quot;SAME&quot;,op_1,filter_shape_1)...net=с_пробел_в_бэтч(net,dilation_rate,&quot;SAME&quot;,op_k,filter_shape_k)</target>
        </trans-unit>
        <trans-unit id="9629de86541bc09ca56a588ec520b31047774cac" translate="yes" xml:space="preserve">
          <source>net = with_space_to_batch(net, dilation_rate, &quot;VALID&quot;, combined_op)</source>
          <target state="translated">net=с_space_to_batch(net,dilation_rate,&quot;VALID&quot;,combined_op)</target>
        </trans-unit>
        <trans-unit id="f23f7d60f11f4328364d8ccbf2e748e87ea0ee4d" translate="yes" xml:space="preserve">
          <source>net = with_space_to_batch(net, dilation_rate, &quot;VALID&quot;, op_1) ... net = with_space_to_batch(net, dilation_rate, &quot;VALID&quot;, op_k)</source>
          <target state="translated">net=с_space_to_batch(net,dilation_rate,&quot;VALID&quot;,op_1)...net=с_space_to_batch(net,dilation_rate,&quot;VALID&quot;,op_k)</target>
        </trans-unit>
        <trans-unit id="7e602e641ed97cc32e5ad703d87c6f5bdf40fcfd" translate="yes" xml:space="preserve">
          <source>new method_name to replace the existing one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14ff22799e08aac561271fc60c98660c1780952" translate="yes" xml:space="preserve">
          <source>no GPU devices are known or registered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93b4ad9558fdddae1cda24d60ab27f4458ee242" translate="yes" xml:space="preserve">
          <source>non_tensor_outputs: A dictionary containing anything that was set by &lt;code&gt;fn&lt;/code&gt; by calling &lt;code&gt;context.set_non_tensor_output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0836e25beb88c4c4dec79da9f4d5a6951c021642" translate="yes" xml:space="preserve">
          <source>none of those changes will affect the internals of this FlagValue instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd40bdd507bf54590c9aac3d2d0c4746626a065" translate="yes" xml:space="preserve">
          <source>nothing.</source>
          <target state="translated">nothing.</target>
        </trans-unit>
        <trans-unit id="74bfcfc74aa173db322155154667e22541967f81" translate="yes" xml:space="preserve">
          <source>np.prod(strides))&lt;code&gt;, where inputs to and outputs of the layer are assumed to have shapes&lt;/code&gt;input_size + (input_filters,)&lt;code&gt;,&lt;/code&gt;output_size + (filters,)` respectively.</source>
          <target state="translated">np.prod (strides)) &lt;code&gt;, where inputs to and outputs of the layer are assumed to have shapes&lt;/code&gt; input_size + (input_filters,) &lt;code&gt;,&lt;/code&gt; output_size + (filters,) `соответственно.</target>
        </trans-unit>
        <trans-unit id="bd868427dc9d0c76f87addc06e2d1d3aab1ac429" translate="yes" xml:space="preserve">
          <source>num_layers: Specifies the number of layers in the RNN model. num_units: Specifies the size of the hidden state. input_size: Specifies the size of the input state. num_params: number of parameter sets for all layers. Each layer may contain multiple parameter sets, with each set consisting of a weight matrix and a bias vector. weights: the canonical form of weights that can be used for saving and restoration. They are more likely to be compatible across different generations. biases: the canonical form of biases that can be used for saving and restoration. They are more likely to be compatible across different generations. rnn_mode: Indicates the type of the RNN model. input_mode: Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1 dropout: dropout probability. When set to 0., dropout is disabled. seed: the 1st part of a seed to initialize dropout. seed2: the 2nd part of a seed to initialize dropout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec945188edfd6369b9c249b473a00aaeb09162da" translate="yes" xml:space="preserve">
          <source>num_layers: Specifies the number of layers in the RNN model. num_units: Specifies the size of the hidden state. input_size: Specifies the size of the input state. num_params_weights: number of weight parameter matrix for all layers. num_params_biases: number of bias parameter vector for all layers. weights: the canonical form of weights that can be used for saving and restoration. They are more likely to be compatible across different generations. biases: the canonical form of biases that can be used for saving and restoration. They are more likely to be compatible across different generations. rnn_mode: Indicates the type of the RNN model. input_mode: Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1 dropout: dropout probability. When set to 0., dropout is disabled. seed: the 1st part of a seed to initialize dropout. seed2: the 2nd part of a seed to initialize dropout. num_proj: The output dimensionality for the projection matrices. If None or 0, no projection is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a5d0068e8fa8fde86e734a66c93fcdb5f19f75" translate="yes" xml:space="preserve">
          <source>num_layers: Specifies the number of layers in the RNN model. num_units: Specifies the size of the hidden state. input_size: Specifies the size of the input state. rnn_mode: Indicates the type of the RNN model. input_mode: Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1 dropout: dropout probability. When set to 0., dropout is disabled. seed: the 1st part of a seed to initialize dropout. seed2: the 2nd part of a seed to initialize dropout. params_size: The size of the params buffer that should be allocated and initialized for this RNN model. Note that this params buffer may not be compatible across GPUs. Please use CudnnRNNParamsWeights and CudnnRNNParamsBiases to save and restore them in a way that is compatible across different runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8853523081a5a5efd63ab532e6f497efb5f9d48" translate="yes" xml:space="preserve">
          <source>num_layers: Specifies the number of layers in the RNN model. num_units: Specifies the size of the hidden state. input_size: Specifies the size of the input state. weights: the canonical form of weights that can be used for saving and restoration. They are more likely to be compatible across different generations. biases: the canonical form of biases that can be used for saving and restoration. They are more likely to be compatible across different generations. num_params: number of parameter sets for all layers. Each layer may contain multiple parameter sets, with each set consisting of a weight matrix and a bias vector. rnn_mode: Indicates the type of the RNN model. input_mode: Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1 dropout: dropout probability. When set to 0., dropout is disabled. seed: the 1st part of a seed to initialize dropout. seed2: the 2nd part of a seed to initialize dropout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13aa15dc158ca8d658a9a101b06a218d9fe7b6f6" translate="yes" xml:space="preserve">
          <source>num_layers: Specifies the number of layers in the RNN model. num_units: Specifies the size of the hidden state. input_size: Specifies the size of the input state. weights: the canonical form of weights that can be used for saving and restoration. They are more likely to be compatible across different generations. biases: the canonical form of biases that can be used for saving and restoration. They are more likely to be compatible across different generations. num_params_weights: number of weight parameter matrix for all layers. num_params_biases: number of bias parameter vector for all layers. rnn_mode: Indicates the type of the RNN model. input_mode: Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1 dropout: dropout probability. When set to 0., dropout is disabled. seed: the 1st part of a seed to initialize dropout. seed2: the 2nd part of a seed to initialize dropout. num_proj: The output dimensionality for the projection matrices. If None or 0, no projection is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff03313b4c9a6c0e1f98dfd133ba6937714d38d" translate="yes" xml:space="preserve">
          <source>number of epochs to wait before resuming normal operation after lr has been reduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f3aa2cab89d4578168c97dc89263ad68c4eace" translate="yes" xml:space="preserve">
          <source>number of epochs with no improvement after which learning rate will be reduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390e0dbe32cc7930cd49425707265c0268855594" translate="yes" xml:space="preserve">
          <source>number of input units in the weight tensor, if &lt;code&gt;mode=&quot;fan_in&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba8c609440516ada4a5f8fe9685ea11133e5dce" translate="yes" xml:space="preserve">
          <source>number of input units in the weight tensor, if mode = &quot;fan_in&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a306a67e4f4dfdc875d231e14009cf618949ba70" translate="yes" xml:space="preserve">
          <source>number of inputs or their shapes are inconsistent with &lt;code&gt;equation&lt;/code&gt;.</source>
          <target state="translated">количество входов или их формы не соответствуют &lt;code&gt;equation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c77f3a0fedbb994a30c0e1e9bc7f185b3ed0bbee" translate="yes" xml:space="preserve">
          <source>number of label classes. Default is binary classification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f9d80ff45c27a53d4c893ff7babf9f35fa4c1b" translate="yes" xml:space="preserve">
          <source>number of label classes. Default is binary classification. It must be greater than 1. Note: Class labels are integers representing the class index (i.e. values from 0 to n_classes-1). For arbitrary label values (e.g. string labels), convert to class indices first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4d42491911f5313d3b8e05f297864124299a09" translate="yes" xml:space="preserve">
          <source>number of label classes. Default is binary classification. Note that class labels are integers representing the class index (i.e. values from 0 to n_classes-1). For arbitrary label values (e.g. string labels), convert to class indices first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3446a1ca0ee787d2e617e596c50d68732bb8baeb" translate="yes" xml:space="preserve">
          <source>number of output units, if &lt;code&gt;mode=&quot;fan_out&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2a1694df45c5313f69b622bcf542bfd8f27ba1" translate="yes" xml:space="preserve">
          <source>number of output units, if mode = &quot;fan_out&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4360d731d0636138a8ebc6adad10b74366abe30" translate="yes" xml:space="preserve">
          <source>number of replicas to aggregate for each variable update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986600ecf7e4cb56c6f87340dc123d650c8970ba" translate="yes" xml:space="preserve">
          <source>number trees to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4828460111335110da3453ca384a7cbea59bf062" translate="yes" xml:space="preserve">
          <source>numpy array object or dict of numpy array object. &lt;code&gt;None&lt;/code&gt; if absent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3625af0e1e45f5a0e83819a95ed4953548427e6b" translate="yes" xml:space="preserve">
          <source>numpy array object or dict of numpy array objects. If an array, the array will be treated as a single feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301dbee88b609916a3f6461c68327458e384f639" translate="yes" xml:space="preserve">
          <source>nvcuda_dll_name</source>
          <target state="translated">nvcuda_dll_name</target>
        </trans-unit>
        <trans-unit id="06609b417b0fa9c8ea5c6514e56e95ed0e35083a" translate="yes" xml:space="preserve">
          <source>object details about the training history at each epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6751f5ba4ca8022696023d44f42de4026c9562" translate="yes" xml:space="preserve">
          <source>object methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc177983afc125e5761b3dbd80d308f052f3c452" translate="yes" xml:space="preserve">
          <source>of dummy input data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389765b6785b803b70eafbc253d057329001b5d2" translate="yes" xml:space="preserve">
          <source>of the input dataset. In particular, the first element of the first window will always be the first element of the input dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0c44657f149a96a0e65f75bc58153190e7c724" translate="yes" xml:space="preserve">
          <source>on size 224 x 224:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b83f79b1a5eb60b6826ddb3076399e4746a383" translate="yes" xml:space="preserve">
          <source>on the input image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105f01d9cab58c7a99e202e6b7c67960a82504da" translate="yes" xml:space="preserve">
          <source>one in the source data format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c058feda0e67611eeab3672b78c3f08cfa0cd3b1" translate="yes" xml:space="preserve">
          <source>one of &quot;binary&quot;, &quot;categorical&quot;, &quot;input&quot;, &quot;multi_output&quot;, &quot;raw&quot;, sparse&quot; or None. Default: &quot;categorical&quot;. Mode for yielding the targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973360fe90637d713adffaf922850e2e72afc1fb" translate="yes" xml:space="preserve">
          <source>one of &quot;fine&quot;, &quot;coarse&quot;. If it is &quot;fine&quot; the category labels are the fine-grained labels, if it is &quot;coarse&quot; the output labels are the coarse-grained superclasses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8ed38e6d0f3b3e4327e6a67739ea552ee8b15b" translate="yes" xml:space="preserve">
          <source>one of &quot;grayscale&quot;, &quot;rgb&quot;, &quot;rgba&quot;. Default: &quot;rgb&quot;. Whether the images will be converted to have 1 or 3 color channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464caaa7ac181dc90a902003d97a5eec55a3f4dc" translate="yes" xml:space="preserve">
          <source>one of &quot;png&quot;, &quot;jpeg&quot; (only relevant if &lt;code&gt;save_to_dir&lt;/code&gt; is set). Default: &quot;png&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00331b722b2dca423d1965d71e4fc53ba901ff3" translate="yes" xml:space="preserve">
          <source>one of &lt;code&gt;&quot;valid&quot;&lt;/code&gt; or &lt;code&gt;&quot;same&quot;&lt;/code&gt; (case-insensitive).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763969c2585ec790a2fd52832b369e8021281f8e" translate="yes" xml:space="preserve">
          <source>one of &lt;code&gt;'valid'&lt;/code&gt; or &lt;code&gt;'same'&lt;/code&gt; (case-insensitive).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92e9cff49a76743538a9df1c442200490ca842e" translate="yes" xml:space="preserve">
          <source>one of &lt;code&gt;None&lt;/code&gt; (random initialization), 'imagenet' (pre-training on ImageNet), or the path to the weights file to be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98ea36256a7e25145ca68c5255896e7b8580a1d" translate="yes" xml:space="preserve">
          <source>one of &lt;code&gt;matrix&lt;/code&gt;, &lt;code&gt;sequence&lt;/code&gt;, or &lt;code&gt;compact&lt;/code&gt;. Default is &lt;code&gt;compact&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3d7b1501a711954fad4900c172e5b8049392b2" translate="yes" xml:space="preserve">
          <source>one of &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;pre&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt; to indicate no pruning, pre- pruning (do not split a node if not enough gain is observed) and post pruning (build the tree up to a max depth and then prune branches with negative gain). For pre and post pruning, you MUST provide &lt;code&gt;tree_complexity &amp;gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb43b0b9ee4f671c14ba42edd2a13ed9e78efc55" translate="yes" xml:space="preserve">
          <source>one of &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;pre&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt; to indicate no pruning, pre- pruning (do not split a node if not enough gain is observed) and post pruning (build the tree up to a max depth and then prune branches with negative gain). For pre and post pruning, you MUST provide &lt;code&gt;tree_complexity&amp;gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85670d1919682390842e0890a50cfe8612635387" translate="yes" xml:space="preserve">
          <source>one of &lt;code&gt;sequence&lt;/code&gt;, or &lt;code&gt;compact&lt;/code&gt;. Default is &lt;code&gt;compact&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3c7b04e40d57fda596a1002fcd3ed3d1b774b2" translate="yes" xml:space="preserve">
          <source>one of &lt;code&gt;{'auto', 'min', 'max'}&lt;/code&gt;. In &lt;code&gt;'min'&lt;/code&gt; mode, the learning rate will be reduced when the quantity monitored has stopped decreasing; in &lt;code&gt;'max'&lt;/code&gt; mode it will be reduced when the quantity monitored has stopped increasing; in &lt;code&gt;'auto'&lt;/code&gt; mode, the direction is automatically inferred from the name of the monitored quantity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e1a8035c41ca8a8965a7be40eeddc6debd4904a" translate="yes" xml:space="preserve">
          <source>one of {auto, min, max}. If &lt;code&gt;save_best_only=True&lt;/code&gt;, the decision to overwrite the current save file is made based on either the maximization or the minimization of the monitored quantity. For &lt;code&gt;val_acc&lt;/code&gt;, this should be &lt;code&gt;max&lt;/code&gt;, for &lt;code&gt;val_loss&lt;/code&gt; this should be &lt;code&gt;min&lt;/code&gt;, etc. In &lt;code&gt;auto&lt;/code&gt; mode, the direction is automatically inferred from the name of the monitored quantity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4910abb32b1e7bb7b618b96c243f75162e392911" translate="yes" xml:space="preserve">
          <source>one or more square matrices.</source>
          <target state="translated">одна или несколько квадратных матриц.</target>
        </trans-unit>
        <trans-unit id="346f7146c032e0d6b1f4e817342d26fdde6a7b19" translate="yes" xml:space="preserve">
          <source>op = [[A_00 0 ... 0 ... 0], [A_10 A_11 ... 0 ... 0], ... [A_k0 A_k1 ... A_kk ... 0], ... [A_n0 A_n1 ... A_nk ... A_nn]]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09aabb6bc528855c68e16842ecbd23d4dd197619" translate="yes" xml:space="preserve">
          <source>op(input, num_spatial_dims, padding)</source>
          <target state="translated">op(input,num_spatial_dims,padding)</target>
        </trans-unit>
        <trans-unit id="b4cf5407d6170cc098a24db2830af8d91cc0342c" translate="yes" xml:space="preserve">
          <source>operator.shape = [B1,...,Bb] + [N, N], with b &amp;gt;= 0 x.shape = [C1,...,Cc] + [N, R], and [C1,...,Cc] broadcasts with [B1,...,Bb] to [D1,...,Dd]</source>
          <target state="translated">operator.shape = [B1, ..., Bb] + [N, N], где b&amp;gt; = 0 x.shape = [C1, ..., Cc] + [N, R] и [C1 ,. .., Cc] транслирует с [B1, ..., Bb] на [D1, ..., Dd]</target>
        </trans-unit>
        <trans-unit id="21f0f4eef11186599d8d5f9bc9bed989f6e90bed" translate="yes" xml:space="preserve">
          <source>operator_0 = tf.linalg.LinearOperatorFullMatrix([[1., 2.], [3., 4.]]) operator_1 = tf.linalg.LinearOperatorFullMatrix([[1., 0.], [0., 1.]]) operator_2 = tf.linalg.LinearOperatorLowerTriangular([[5., 6.], [7., 8]]) operator = LinearOperatorBlockLowerTriangular( ... [[operator_0], [operator_1, operator_2]])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a202ae75579cff200e2ee520ccf002ade5a95e0a" translate="yes" xml:space="preserve">
          <source>operator_99 = LinearOperatorBlockLowerTriangular( ... [[operator_44], [operator_54, operator_55]]) operator_99.shape TensorShape([2, 3, 9, 9])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b077968c422e42013aec16cf638cc59c33d6d94" translate="yes" xml:space="preserve">
          <source>optimize: Optimization strategy to use to find contraction path using opt_einsum. Must be 'greedy', 'optimal', 'branch-2', 'branch-all' or 'auto'. (optional, default: 'greedy').</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde2236d715af9d424d959bce4c2ae86d35f4559" translate="yes" xml:space="preserve">
          <source>optional &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; object. The default ClusterResolver that is used is the TFConfigClusterResolver which is instantiated from the TF_CONFIG env var.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58e4d73a4c4ea4f9247eb9e5d335a06c3e82f1d" translate="yes" xml:space="preserve">
          <source>optional Enum of type &lt;a href=&quot;collectivecommunication&quot;&gt;&lt;code&gt;distribute.experimental.CollectiveCommunication&lt;/code&gt;&lt;/a&gt;. This provides a way for the user to override the choice of collective op communication. Possible values include &lt;code&gt;AUTO&lt;/code&gt;, &lt;code&gt;RING&lt;/code&gt;, and &lt;code&gt;NCCL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9729f11c3a752289eb0b6328efc642ffc4a3c01e" translate="yes" xml:space="preserve">
          <source>optional Keras tensor (i.e. output of &lt;a href=&quot;../input&quot;&gt;&lt;code&gt;layers.Input()&lt;/code&gt;&lt;/a&gt;) to use as image input for the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300993185987b4b165e69ffd904e0a65f34d98a8" translate="yes" xml:space="preserve">
          <source>optional handler for errors. Should be a function, it will be called with the error as argument. Rethrowing the error aborts the walk. Errors that happen while listing directories are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1accecbc5436166b3d737d7d1b877088a0094c78" translate="yes" xml:space="preserve">
          <source>optional list of classes (e.g. &lt;code&gt;['dogs', 'cats']&lt;/code&gt;). Default is None. If not provided, the list of classes will be automatically inferred from the &lt;code&gt;y_col&lt;/code&gt;, which will map to the label indices, will be alphanumeric). The dictionary containing the mapping from class names to class indices can be obtained via the attribute &lt;code&gt;class_indices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51061b8693b5cb4059f1ba89bb4b1eac66233af0" translate="yes" xml:space="preserve">
          <source>optional list of input tensors or InputLayer objects to build the model upon. If not provided, placeholders will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62dc26cafa18de0af296d834c62073ba364066b3" translate="yes" xml:space="preserve">
          <source>optional name of the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35dd1fd46110c18f1663d7bef9e8405d3d2b8230" translate="yes" xml:space="preserve">
          <source>optional number of classes to classify images into, only to be specified if &lt;code&gt;include_top&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, and if no &lt;code&gt;weights&lt;/code&gt; argument is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef572abce5567657330bd39231a0f1b9bed8649" translate="yes" xml:space="preserve">
          <source>optional number of classes to classify images into, only to be specified if &lt;code&gt;include_top&lt;/code&gt; is True, and if no &lt;code&gt;weights&lt;/code&gt; argument is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595a86711a4fe24ae48419d4d3d81a75a28e301a" translate="yes" xml:space="preserve">
          <source>optional number of classes to classify images into, only to be specified if &lt;code&gt;include_top&lt;/code&gt; is True, and if no &lt;code&gt;weights&lt;/code&gt; argument is specified. Default to 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95c29bb34fe1fac946c55bab8ef0ea0188216bd" translate="yes" xml:space="preserve">
          <source>optional random seed for shuffling and transformations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208d98b674402add93d1db71f76643c60114882f" translate="yes" xml:space="preserve">
          <source>optional shape tuple, only to be specified if &lt;code&gt;include_top&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; (otherwise the input shape has to be &lt;code&gt;(299, 299, 3)&lt;/code&gt; (with &lt;code&gt;'channels_last'&lt;/code&gt; data format) or &lt;code&gt;(3, 299, 299)&lt;/code&gt; (with &lt;code&gt;'channels_first'&lt;/code&gt; data format). It should have exactly 3 inputs channels, and width and height should be no smaller than 75. E.g. &lt;code&gt;(150, 150, 3)&lt;/code&gt; would be one valid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba798180d824f116c362c21d78fe51d09c47502" translate="yes" xml:space="preserve">
          <source>optional shape tuple, only to be specified if &lt;code&gt;include_top&lt;/code&gt; is False (otherwise the input shape has to be &lt;code&gt;(224, 224, 3)&lt;/code&gt; (with &lt;code&gt;'channels_last'&lt;/code&gt; data format) or &lt;code&gt;(3, 224, 224)&lt;/code&gt; (with &lt;code&gt;'channels_first'&lt;/code&gt; data format). It should have exactly 3 inputs channels, and width and height should be no smaller than 32. E.g. &lt;code&gt;(200, 200, 3)&lt;/code&gt; would be one valid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a06f5d13629167c0f360d544eb576709aa22e7b" translate="yes" xml:space="preserve">
          <source>optional static batch size (integer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904cb580ce388d912cf731adf6f371473ec88758" translate="yes" xml:space="preserve">
          <source>optional suffix for the event file name. Defaults to &lt;code&gt;.v2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c4da23204bbfeff39841f2c4520fb0b05532ee" translate="yes" xml:space="preserve">
          <source>optional tensorflow.RunMetadata proto. It is necessary to to support run time information profiling, such as time and memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c497ce29cd53778bcd428235ca59df727040c1d4" translate="yes" xml:space="preserve">
          <source>optional, a descedant of &lt;code&gt;CrossDeviceOps&lt;/code&gt;. If this is not set, &lt;code&gt;NcclAllReduce()&lt;/code&gt; will be used by default. One would customize this if NCCL isn't available or if a special implementation that exploits the particular hardware is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68833953818bb6ed0871b40ba9bbaf5c9ef531a" translate="yes" xml:space="preserve">
          <source>optional, a positive integer or scalar tensor indicating the number of seeds to produce (default 2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d5afab0f2102124a8d2237963f6e3412321462" translate="yes" xml:space="preserve">
          <source>optional. tensorflow::tfprof::OpLogProto proto. Used to define extra op types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="dd541cc3c68f3ef91373cec69451d3b76f56e593" translate="yes" xml:space="preserve">
          <source>or /job:</source>
          <target state="translated">или работа:</target>
        </trans-unit>
        <trans-unit id="2d43d16984a64536e2a464f0e93cd2bdf2e45fb1" translate="yes" xml:space="preserve">
          <source>or Computes (if &lt;code&gt;nesterov = False&lt;/code&gt;):</source>
          <target state="translated">или &lt;code&gt;nesterov = False&lt;/code&gt; (если nesterov = False ):</target>
        </trans-unit>
        <trans-unit id="3ca88a1cdefee41cd41410b053fb754f166cad09" translate="yes" xml:space="preserve">
          <source>or a list of matrices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc42b5c2fa0b7e6e35cc07b91d36686318016e5e" translate="yes" xml:space="preserve">
          <source>or by fetching individual elements explicitly via &lt;code&gt;get_next()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c4fdca86fea9084a0facccb4eff628873cf1c2" translate="yes" xml:space="preserve">
          <source>or by starting a new tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714484b0221ca19694ee456d81aae2901e571adc" translate="yes" xml:space="preserve">
          <source>or without a value using the &lt;code&gt;empty()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830265d787441d1beac539e2bcbd559ae280180d" translate="yes" xml:space="preserve">
          <source>or, if &lt;code&gt;staircase&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, as:</source>
          <target state="translated">или, если &lt;code&gt;staircase&lt;/code&gt; является &lt;code&gt;True&lt;/code&gt; , как:</target>
        </trans-unit>
        <trans-unit id="ee698e909f8e537c2692e0bc8487b9c4367ee73b" translate="yes" xml:space="preserve">
          <source>original_input: The input to the Unbatch operation this is the gradient of. batch_index: The batch_index given to the Unbatch operation this is the gradient of. grad: The downstream gradient. id: The id scalar emitted by Batch. batched_grad: The return value, either an empty tensor or the batched gradient. container: Container to control resource sharing. shared_name: Instances of UnbatchGrad with the same container and shared_name are assumed to possibly belong to the same batch. If left empty, the op name will be used as the shared name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e012cc8e4dbe068a1e786d4a7f5493b62e26aaca" translate="yes" xml:space="preserve">
          <source>output = cond ? then_branch(input) : else_branch(input)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654e3c94d4cbd9c9f8994a6925d2327931578882" translate="yes" xml:space="preserve">
          <source>output = input; While (Cond(output)) { output = Body(output) }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e221c3a17e595a6fe2e7d7aff7c7fc93f2483f" translate="yes" xml:space="preserve">
          <source>output = round(clamp(value, input_min, input_max) * scale_factor) / scale_factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0da7a7230ffa67664b3b11cce87961b260e7c7" translate="yes" xml:space="preserve">
          <source>output type of the resulting tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708f559a18bb2be82174b9014390e5c3c3501eb6" translate="yes" xml:space="preserve">
          <source>output: A double tensor of shape [14 + nDimensions], where nDimensions is the number of dimensions of the tensor's shape. The elements of output are: [0]: is initialized (1.0) or not (0.0). [1]: total number of elements [2]: NaN element count [3]: generalized -inf count: elements &amp;lt;= lower_bound. lower_bound is -inf by default. [4]: negative element count (excluding -inf), if lower_bound is the default -inf. Otherwise, this is the count of elements &amp;gt; lower_bound and &amp;lt; 0. [5]: zero element count [6]: positive element count (excluding +inf), if upper_bound is the default +inf. Otherwise, this is the count of elements &amp;lt; upper_bound and &amp;gt; 0. [7]: generalized +inf count, elements &amp;gt;= upper_bound. upper_bound is +inf by default. Output elements [1:8] are all zero, if the tensor is uninitialized. [8]: minimum of all non-inf and non-NaN elements. If uninitialized or no such element exists: +inf. [9]: maximum of all non-inf and non-NaN elements. If uninitialized or no such element exists: -inf. [10]: mean of all non-inf and non-NaN elements. If uninitialized or no such element exists: NaN. [11]: variance of all non-inf and non-NaN elements. If uninitialized or no such element exists: NaN. [12]: Data type of the tensor encoded as an enum integer. See the DataType proto for more details. [13]: Number of dimensions of the tensor (ndims). [14+]: Sizes of the dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6d717f194cd224c2028a5f320d74be818984c4" translate="yes" xml:space="preserve">
          <source>output: an &lt;code&gt;ExportOutput&lt;/code&gt; object such as &lt;code&gt;ClassificationOutput&lt;/code&gt;, &lt;code&gt;RegressionOutput&lt;/code&gt;, or &lt;code&gt;PredictOutput&lt;/code&gt;. Single-headed models only need to specify one entry in this dictionary. Multi-headed models should specify one entry for each head, one of which must be named using &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt;. If no entry is provided, a default &lt;code&gt;PredictOutput&lt;/code&gt; mapping to &lt;code&gt;predictions&lt;/code&gt; will be created.</source>
          <target state="translated">вывод: объект &lt;code&gt;ExportOutput&lt;/code&gt; , такой как &lt;code&gt;ClassificationOutput&lt;/code&gt; , &lt;code&gt;RegressionOutput&lt;/code&gt; или &lt;code&gt;PredictOutput&lt;/code&gt; . Одноголовые модели должны указать только одну запись в этом словаре. Многоголовые модели должны указывать одну запись для каждой головы, одна из которых должна быть названа с использованием &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt; . Если запись не &lt;code&gt;PredictOutput&lt;/code&gt; будет создано сопоставление PredictOutput по умолчанию с &lt;code&gt;predictions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f844c54d59ef069cec9e3b46187e9dbd1ec7c38b" translate="yes" xml:space="preserve">
          <source>output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72e1d002d084174fd4b79fe4876d09fce7ee868" translate="yes" xml:space="preserve">
          <source>output_row_length : which will be smaller than the input</source>
          <target state="translated">output_row_length:который будет меньше входа</target>
        </trans-unit>
        <trans-unit id="84fa6155d4a56c014bd4a280c3f42f12be9be026" translate="yes" xml:space="preserve">
          <source>output_type: Its expected dtype. (Optional, default: &lt;a href=&quot;../../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a2936724ee0767d09b1560f7f0d34f9bfc5bf1" translate="yes" xml:space="preserve">
          <source>output_type: Its expected dtype. (Optional, default: &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a669f96eb5ac7685028daff4e4ca865b3b2f9e" translate="yes" xml:space="preserve">
          <source>output_type: Its expected dtype. (Optional, default: &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="913dd2c0929edc9c9305b6ca44ff13373f7911df" translate="yes" xml:space="preserve">
          <source>output_type: Its expected dtype. (Optional, default: &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f358e871419fb2490bac439cb45d64be8fbf7953" translate="yes" xml:space="preserve">
          <source>outputs is a length T list of outputs (one for each input), or a nested tuple of such elements.</source>
          <target state="translated">Выходы-это список выходов длиной T (по одному на каждый вход)или вложенный кортеж таких элементов.</target>
        </trans-unit>
        <trans-unit id="21010b5635dfe61011bf39ba7ec46eb59f94b0b6" translate="yes" xml:space="preserve">
          <source>p(x) = coeffs[n-1] + coeffs[n-2] * x + ... + coeffs[0] * x**(n-1)</source>
          <target state="translated">p(x)=коэффициенты[n-1]+коэффициенты[n-2]*x+...+coeffs[0]*x**(n-1)</target>
        </trans-unit>
        <trans-unit id="13ebac9b892f43a8bbaa27f1eb1a2b2a68364dc6" translate="yes" xml:space="preserve">
          <source>p(x) = coeffs[n-1] + x * (coeffs[n-2] + ... + x * (coeffs[1] + x * coeffs[0]))</source>
          <target state="translated">p(x)=коэффициенты [n-1]+x*(коэффициенты [n-2]+...+х*(коэффициенты [1]+х*коэффициенты [0]))</target>
        </trans-unit>
        <trans-unit id="f77fd94618cf2342eacdd0a0dc29eec799cdff41" translate="yes" xml:space="preserve">
          <source>p: A rank-1 &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., N]&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt;-conjugate basis vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ee79f9d53d9dead813c0c01ea93fa91e2851e6" translate="yes" xml:space="preserve">
          <source>paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8f2a31112ec7027bad1e42c76111e09e2d539f" translate="yes" xml:space="preserve">
          <source>paddings, crops = required_space_to_batch_paddings( input_shape[spatial_dims], dilation_rate)</source>
          <target state="translated">paddings,crops=required_space_to_batch_paddings(input_shape[spatial_dims],dilation_rate])</target>
        </trans-unit>
        <trans-unit id="f6f0cc4dcfa78d598a7318ca58056f743675cd22" translate="yes" xml:space="preserve">
          <source>paddings, crops = required_space_to_batch_paddings( input_shape[spatial_dims], dilation_rate, [(dilated_filter_shape - 1) // 2, dilated_filter_shape - 1 - (dilated_filter_shape - 1) // 2])</source>
          <target state="translated">прокладки,crops=required_space_to_batch_paddings(input_shape[spatial_dims],dilation_rate,[(dilated_filter_shape-1)//2,dilated_filter_shape-1-(dilated_filter_shape-1)//2])</target>
        </trans-unit>
        <trans-unit id="4caf18d663abbb6ff6eb4c6569a8b3c81cd6e52f" translate="yes" xml:space="preserve">
          <source>paddings[i, 0] = base_paddings[i, 0]. 0 &amp;lt;= paddings[i, 1] - base_paddings[i, 1] &amp;lt; block_shape&lt;a href=&quot;input_shape%5bi%5d%20+%20paddings%5bi,%200%5d%20+%20paddings%5bi,%201%5d&quot;&gt;i&lt;/a&gt; % block_shape[i] == 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce81c6a8f81440fd8c4eb66d38b27459f5557ab" translate="yes" xml:space="preserve">
          <source>pandas &lt;code&gt;DataFrame&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8af267513c3358e3e5ab795e2f32504ffbcd0b9" translate="yes" xml:space="preserve">
          <source>pandas &lt;code&gt;Series&lt;/code&gt; object or &lt;code&gt;DataFrame&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; if absent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950593b1f42de841169aa7d59486b7e980bc15cf" translate="yes" xml:space="preserve">
          <source>paper</source>
          <target state="translated">paper</target>
        </trans-unit>
        <trans-unit id="49ed3ce8815b0f1c023b0f3764f86fc3b935b981" translate="yes" xml:space="preserve">
          <source>param_shapes with static (i.e. &lt;code&gt;TensorShape&lt;/code&gt;) shapes.</source>
          <target state="translated">param_shapes со статическими (например, &lt;code&gt;TensorShape&lt;/code&gt; ) формами.</target>
        </trans-unit>
        <trans-unit id="10f8be316b3e0047f5e5f915c18879845ae2a38e" translate="yes" xml:space="preserve">
          <source>parameters of &lt;code&gt;model_fn&lt;/code&gt; don't match &lt;code&gt;params&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b8a8cea68a6ae5ee46a98e249e2dc5a39612fb" translate="yes" xml:space="preserve">
          <source>parse() is also called during &lt;strong&gt;init&lt;/strong&gt; to parse the default value and initialize the .value attribute. This enables other python modules to safely use flags even if the &lt;strong&gt;main&lt;/strong&gt; module neglects to parse the command line arguments. The .present attribute is cleared after &lt;strong&gt;init&lt;/strong&gt; parsing. If the default value is set to None, then the &lt;strong&gt;init&lt;/strong&gt; parsing step is skipped and the .value attribute is initialized to None.</source>
          <target state="translated">parse () также вызывается во время &lt;strong&gt;инициализации&lt;/strong&gt; для анализа значения по умолчанию и инициализации атрибута .value. Это позволяет другим модулям Python безопасно использовать флаги, даже если &lt;strong&gt;основной&lt;/strong&gt; модуль не выполняет синтаксический анализ аргументов командной строки. Атрибут .present очищается после синтаксического анализа &lt;strong&gt;init&lt;/strong&gt; . Если значение по умолчанию установлено на None, то этап синтаксического анализа &lt;strong&gt;инициализации&lt;/strong&gt; пропускается, а атрибут .value инициализируется значением None.</target>
        </trans-unit>
        <trans-unit id="2dd888a3f9077be7036ea5caeddac8327e48819f" translate="yes" xml:space="preserve">
          <source>passed to this instance of the &lt;code&gt;TPUEmbedding&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb9c2bf4197e59931df52abbccb1f51a9e7170e" translate="yes" xml:space="preserve">
          <source>path where to cache the dataset locally (relative to &lt;code&gt;~/.keras/datasets&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e850cc2e5567dfedc02301cb4fbdd8b308f54925" translate="yes" xml:space="preserve">
          <source>perform much faster best-path search if &lt;code&gt;true&lt;/code&gt;. This does not use a dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabde60aa75e1cd006b643998fc0e174b2d7bb18" translate="yes" xml:space="preserve">
          <source>pin_to_host_optimization: Force small ops onto the CPU.</source>
          <target state="translated">pin_to_host_optimization:Форсирование небольших опций на процессор.</target>
        </trans-unit>
        <trans-unit id="973442da3d764973f568e533f6219db650cc17fc" translate="yes" xml:space="preserve">
          <source>pop(*args, **kwargs) Overloaded function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860a66191813f93105e168f29ef024c22c8c2e07" translate="yes" xml:space="preserve">
          <source>pop(self: tensorflow.python._tf_stack.StackSummary) -&amp;gt; tensorflow.python._tf_stack.FrameSummary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4047ecc8080e1acbaf40412d39e00e1906c36e" translate="yes" xml:space="preserve">
          <source>pop(self: tensorflow.python._tf_stack.StackSummary, i: int) -&amp;gt; tensorflow.python._tf_stack.FrameSummary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3fb58b43d642faa4cd3f287ae2a340c410e66f9" translate="yes" xml:space="preserve">
          <source>port profiler server listens to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb9c277ff8d7341a5bc7042daff5e9b206b19ee" translate="yes" xml:space="preserve">
          <source>position of the batch in the Sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb12f2f652f57f55e2637aeeb627de4e59c52c44" translate="yes" xml:space="preserve">
          <source>pprof -png --nodecount=100 --sample_index=1</source>
          <target state="translated">pprof -png --nodecount=100 --sample_index=1</target>
        </trans-unit>
        <trans-unit id="1cbb65f63a43dde4454fdf620d85eed7da2182d9" translate="yes" xml:space="preserve">
          <source>predictions: Predictions &lt;code&gt;Tensor&lt;/code&gt; or dict of &lt;code&gt;Tensor&lt;/code&gt; created by given &lt;code&gt;estimator&lt;/code&gt;.</source>
          <target state="translated">предсказания: &lt;code&gt;Tensor&lt;/code&gt; предсказаний или диктатор &lt;code&gt;Tensor&lt;/code&gt; , созданный данным &lt;code&gt;estimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10579f780c2a8daa2002917a11d056babf873333" translate="yes" xml:space="preserve">
          <source>processing_mode=&quot;parallel_epochs&quot; means that multiple tf.data workers will iterate through the dataset in parallel, each producing all elements of the dataset. For example, if the dataset contains {0, 1, 2}, every tf.data worker used for execution will produce {0, 1, 2}. If there are 3 workers, the job will produce the elements {0, 0, 0, 1, 1, 1, 2, 2, 2} (though not necessarily in that order). To account for this, it is recommended to randomly shuffle your dataset, so that different tf.data workers will iterate through the dataset in different orders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1bfc6a48ac2d542db9ef59ddc8a95cf6aeb7ed" translate="yes" xml:space="preserve">
          <source>produce moments with the same dimensionality as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0699e063fb556ca4839a28338fcd1e47660cfb94" translate="yes" xml:space="preserve">
          <source>produce statistics with the same dimensionality as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5aa39f1449421d2beeca37812e3dc8fffd8a98" translate="yes" xml:space="preserve">
          <source>produces the same output as</source>
          <target state="translated">производит тот же объем продукции,что и</target>
        </trans-unit>
        <trans-unit id="adabfed444928e2f0a9e9699928e13cf5736a50b" translate="yes" xml:space="preserve">
          <source>profile data will save to this directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cc4e4c5b2f6718473e2a922972f01e2b133d60" translate="yes" xml:space="preserve">
          <source>profiler.experimental.ProfilerOptions namedtuple for miscellaneous profiler options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e845e7678efd89943e3990f8e48e367772abf573" translate="yes" xml:space="preserve">
          <source>proto message in original or ascii form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c836c79e2e7c9facf33796b1ea251c768fb7eec" translate="yes" xml:space="preserve">
          <source>prox_v = var - alpha * delta var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593a657d2c9adee40e9361139dab15d3a998c5a6" translate="yes" xml:space="preserve">
          <source>pruning away boxes that have high intersection-over-union (IOU) overlap with previously selected boxes. Bounding boxes are supplied as [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any diagonal pair of box corners and the coordinates can be provided as normalized (i.e., lying in the interval [0, 1]) or absolute. Note that this algorithm is agnostic to where the origin is in the coordinate system. Note that this algorithm is invariant to orthogonal transformations and translations of the coordinate system; thus translating or reflections of the coordinate system result in the same boxes being selected by the algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e694dceae31e078ddb8809dafcc06aac2cda4c9a" translate="yes" xml:space="preserve">
          <source>pruning away boxes that have high intersection-over-union (IOU) overlap with previously selected boxes. Bounding boxes are supplied as [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any diagonal pair of box corners and the coordinates can be provided as normalized (i.e., lying in the interval [0, 1]) or absolute. Note that this algorithm is agnostic to where the origin is in the coordinate system. Note that this algorithm is invariant to orthogonal transformations and translations of the coordinate system; thus translating or reflections of the coordinate system result in the same boxes being selected by the algorithm. The output of this operation is a set of integers indexing into the input collection of bounding boxes representing the selected boxes. The bounding box coordinates corresponding to the selected indices can then be obtained using the &lt;code&gt;tf.gather operation&lt;/code&gt;. For example: selected_indices = tf.image.non_max_suppression( boxes, scores, max_output_size, iou_threshold) selected_boxes = tf.gather(boxes, selected_indices)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d8a1c25b7314e5ba6755747734b19ab3b8f89d" translate="yes" xml:space="preserve">
          <source>pruning away boxes that have high intersection-over-union (IOU) overlap with previously selected boxes. Bounding boxes with score less than &lt;code&gt;score_threshold&lt;/code&gt; are removed. Bounding boxes are supplied as [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any diagonal pair of box corners and the coordinates can be provided as normalized (i.e., lying in the interval [0, 1]) or absolute. Note that this algorithm is agnostic to where the origin is in the coordinate system and more generally is invariant to orthogonal transformations and translations of the coordinate system; thus translating or reflections of the coordinate system result in the same boxes being selected by the algorithm. The output of this operation is a set of integers indexing into the input collection of bounding boxes representing the selected boxes. The bounding box coordinates corresponding to the selected indices can then be obtained using the &lt;code&gt;tf.gather operation&lt;/code&gt;. For example: selected_indices = tf.image.non_max_suppression_v2( boxes, scores, max_output_size, iou_threshold, score_threshold) selected_boxes = tf.gather(boxes, selected_indices)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450016572dc5235d8f8db5e9c76e341fa8971c08" translate="yes" xml:space="preserve">
          <source>pruning away boxes that have high intersection-over-union (IOU) overlap with previously selected boxes. Bounding boxes with score less than &lt;code&gt;score_threshold&lt;/code&gt; are removed. Bounding boxes are supplied as [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any diagonal pair of box corners and the coordinates can be provided as normalized (i.e., lying in the interval [0, 1]) or absolute. Note that this algorithm is agnostic to where the origin is in the coordinate system and more generally is invariant to orthogonal transformations and translations of the coordinate system; thus translating or reflections of the coordinate system result in the same boxes being selected by the algorithm. The output of this operation is a set of integers indexing into the input collection of bounding boxes representing the selected boxes. The bounding box coordinates corresponding to the selected indices can then be obtained using the &lt;code&gt;tf.gather operation&lt;/code&gt;. For example: selected_indices = tf.image.non_max_suppression_v2( boxes, scores, max_output_size, iou_threshold, score_threshold) selected_boxes = tf.gather(boxes, selected_indices) This op also supports a Soft-NMS (with Gaussian weighting) mode (c.f. Bodla et al, &lt;a href=&quot;https://arxiv.org/abs/1704.04503&quot;&gt;https://arxiv.org/abs/1704.04503&lt;/a&gt;) where boxes reduce the score of other overlapping boxes instead of directly causing them to be pruned. To enable this Soft-NMS mode, set the &lt;code&gt;soft_nms_sigma&lt;/code&gt; parameter to be larger than 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0332b9cecb3347954bae39093ae055fc3f74f61" translate="yes" xml:space="preserve">
          <source>pruning away boxes that have high overlaps with previously selected boxes. Bounding boxes with score less than &lt;code&gt;score_threshold&lt;/code&gt; are removed. N-by-n overlap values are supplied as square matrix, which allows for defining a custom overlap criterium (eg. intersection over union, intersection over area, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a02b01e6c71a1282bc9eb0ec7e4e2a04b6a71b" translate="yes" xml:space="preserve">
          <source>pseudorandomly.</source>
          <target state="translated">pseudorandomly.</target>
        </trans-unit>
        <trans-unit id="04ab52557c87382099dd62ce1b1fc8a17019adcd" translate="yes" xml:space="preserve">
          <source>pylint: disable=line-too-long</source>
          <target state="translated">пилинт:disable=line-too-long</target>
        </trans-unit>
        <trans-unit id="1f2375b3373da432fed38eb09b4ad050725534d1" translate="yes" xml:space="preserve">
          <source>python function to be wrapped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ff869df67d72a2c7a982321b5c0343cea3a01d" translate="yes" xml:space="preserve">
          <source>quality must be in [0,100]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c149c463a63b92c21330a415b262efcec72e7e87" translate="yes" xml:space="preserve">
          <source>quantity to be monitored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2fd0cd1d0804a30ea46b17a11af066e38af65c" translate="yes" xml:space="preserve">
          <source>quantity to monitor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787fb2efed06eaec76aeca89412b1b481b4fc2a8" translate="yes" xml:space="preserve">
          <source>query: Query &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, Tq, dim]&lt;/code&gt;.</source>
          <target state="translated">query: &lt;code&gt;[batch_size, Tq, dim]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; формы [batch_size, Tq, dim] .</target>
        </trans-unit>
        <trans-unit id="0a21ec2522ccb6ed671ded21cdb008d6fde237c2" translate="yes" xml:space="preserve">
          <source>query_mask: A boolean mask &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, Tq]&lt;/code&gt;. If given, the output will be zero at the positions where &lt;code&gt;mask==False&lt;/code&gt;.</source>
          <target state="translated">query_mask: логическая маска &lt;code&gt;Tensor&lt;/code&gt; формы &lt;code&gt;[batch_size, Tq]&lt;/code&gt; . Если задано, вывод будет нулевым в тех позициях, где &lt;code&gt;mask==False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="534d50be9952f01d926360dadefaea2a149fd5e0" translate="yes" xml:space="preserve">
          <source>queue size (when full, workers could block on &lt;code&gt;put()&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07229cd287095c17c3682b3836ecf0311c09132d" translate="yes" xml:space="preserve">
          <source>r: A rank-1 &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[.., M]&lt;/code&gt; containing the residual vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5efc24bbcc70db24ce0aa347bb4dbeb364aba7" translate="yes" xml:space="preserve">
          <source>random seed for candidate sampling. Default to None, which doesn't set the op-level random seed for candidate sampling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9189ff84071d472a8f167150989e48f1c95a6c5f" translate="yes" xml:space="preserve">
          <source>random seed to ensure determinism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f8edbdff757c5671baab2d00bbef0b43fe5eb9" translate="yes" xml:space="preserve">
          <source>rate for enforcing the constraint: weights will be rescaled to yield &lt;code&gt;(1 - rate) * norm + rate * norm.clip(min_value, max_value)&lt;/code&gt;. Effectively, this means that rate=1.0 stands for strict enforcement of the constraint, while rate&amp;lt;1.0 means that weights will be rescaled at each step to slowly move towards a value inside the desired interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639da06088c59ce48071fc042e1d1506504ba4f2" translate="yes" xml:space="preserve">
          <source>recombine substrings into tokens (usually ngrams)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31547518deedc2237f71d9f9d5bde14dd688b8d9" translate="yes" xml:space="preserve">
          <source>regularization factor to penalize trees with more leaves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeabfc18263faf44c1a61def004fd56ccfc15191" translate="yes" xml:space="preserve">
          <source>regularization multiplier applied to the absolute weights of the tree leafs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5f49f67d6a2b691864ab076c337e6e33e37988" translate="yes" xml:space="preserve">
          <source>regularization multiplier applied to the square weights of the tree leafs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309bbeb30f4bf7bc003afbba098d535cce6902a5" translate="yes" xml:space="preserve">
          <source>regularizer = tf.keras.regularizers.L2(2.) tensor = tf.ones(shape=(5, 5)) regularizer(tensor)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b8b7881108edabc49b87fd215143cd4511d7db" translate="yes" xml:space="preserve">
          <source>regularizer = tf.keras.regularizers.l2(2.) tensor = tf.ones(shape=(5, 5)) regularizer(tensor)</source>
          <target state="translated">регуляризатор=tf.keras.regularizers.l2(2.)тензор=tf.ones(shape=(5,5))регуляризатор(тензор)</target>
        </trans-unit>
        <trans-unit id="59e1cf543b454900661bf9faea4e051544d6b296" translate="yes" xml:space="preserve">
          <source>regularizer for bias vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2789a235ac17e7ac79312aa83992961425d727c6" translate="yes" xml:space="preserve">
          <source>regularizer for kernel vectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b64a3921a503c7ed1f3fed59c79f4ec577942c" translate="yes" xml:space="preserve">
          <source>relative tolerance for bfloat16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02eb9f8d34ac73245e97107e07c27541d11a74d4" translate="yes" xml:space="preserve">
          <source>relative tolerance for float16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6540d374295c7a2997b964d81dccaafcb781f31d" translate="yes" xml:space="preserve">
          <source>relative tolerance for float32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02729d523aa837a7d004f75ae00f8448f91b655" translate="yes" xml:space="preserve">
          <source>relative tolerance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e7a6bc925c03aa66228ca36d00950548a3685f" translate="yes" xml:space="preserve">
          <source>remapping: Remap subgraphs onto more efficient implementations.</source>
          <target state="translated">перестроение:Переместить подграфы на более эффективные внедрения.</target>
        </trans-unit>
        <trans-unit id="c60ee09390a6e35d97e520a2197948df73ce6a4d" translate="yes" xml:space="preserve">
          <source>remove variable names, brackets, and commas, (&lt;code&gt;ik = sum_j ij * jk&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9b1dd0a1526b75553de00d888b17ad12a44877" translate="yes" xml:space="preserve">
          <source>remove(self: tensorflow.python._tf_stack.StackSummary, x: tensorflow.python._tf_stack.FrameSummary) -&amp;gt; None</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0dfe2c2e0f677a40e93bbdae8e093f909e1910" translate="yes" xml:space="preserve">
          <source>replace &quot;*&quot; with &quot;,&quot;, (&lt;code&gt;ik = sum_j ij , jk&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3dd4205ba114888ed31b5058ee33c9f732743f" translate="yes" xml:space="preserve">
          <source>replacement string provided in &lt;code&gt;rewrite&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60390a3a9e0edba825c550f7c32449a747e071f9" translate="yes" xml:space="preserve">
          <source>replica 0's output: &lt;code&gt;[[A], [C]]&lt;/code&gt; replica 1's output: &lt;code&gt;[[B], [D]]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353fc99f7d38352410ced6251d064e4a6052dd9e" translate="yes" xml:space="preserve">
          <source>represents the dense tensor</source>
          <target state="translated">представляет собой плотный тензор</target>
        </trans-unit>
        <trans-unit id="8034408843fdf51f85fc2a50941fc50f31b15cfd" translate="yes" xml:space="preserve">
          <source>rescaling factor. Defaults to None. If None or 0, no rescaling is applied, otherwise we multiply the data by the value provided (after applying all other transformations).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c015d4668b73fe4b03ca29a641d3ef8b9e81bfb6" translate="yes" xml:space="preserve">
          <source>resource_apply_dense (update variable given gradient tensor is dense)</source>
          <target state="translated">resource_apply_dense (обновление переменной с учетом тензора градиента плотности)</target>
        </trans-unit>
        <trans-unit id="39693de5ec1c6562ec40db8fcb7c5a5cce34bae0" translate="yes" xml:space="preserve">
          <source>resource_apply_sparse (update variable given gradient tensor is sparse)</source>
          <target state="translated">resource_apply_sparse (обновление переменной с учетом тензора градиента мало)</target>
        </trans-unit>
        <trans-unit id="01c5c9df34b5137648c4ee6874385933a85453c2" translate="yes" xml:space="preserve">
          <source>restores variables if a checkpoint exists</source>
          <target state="translated">восстанавливает переменные,если контрольно-пропускной пункт существует</target>
        </trans-unit>
        <trans-unit id="8a30e1d6ee2e32285fef08eb641cbddf5b83e06f" translate="yes" xml:space="preserve">
          <source>result = LowerBound(sorted_sequence, values)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3478a240ddba140c0b8959d3cef0c127286175e" translate="yes" xml:space="preserve">
          <source>result = UpperBound(sorted_sequence, values)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1af01a57a03db19010f3e9c90a5242a10ef8e3d" translate="yes" xml:space="preserve">
          <source>result == [[1, 2, 2], [0, 1, 5]]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999fe0799450a768de4b501b06b9bf7eb6837b84" translate="yes" xml:space="preserve">
          <source>result == [[1, 2, 4], [0, 2, 5]]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7759b67f1396ab7164410cf112e6dbc6f65f9831" translate="yes" xml:space="preserve">
          <source>result is one logical checkpoint, with one physical metadata file and renamed data files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a39fc740b7a0a7e3c1bbfc1848bd2ec812c9d77" translate="yes" xml:space="preserve">
          <source>return a list of input tensors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82243045092732f574e638bcaae47122cc9193f" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;f(inputs)&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt;'s body is placed and partitioned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26823405302e841464ab5d81bf62da8dba9e94b" translate="yes" xml:space="preserve">
          <source>returns None</source>
          <target state="translated">Вернулось Нет</target>
        </trans-unit>
        <trans-unit id="01de8257caa02c520182ae5bfbef7a2ea2a5f22d" translate="yes" xml:space="preserve">
          <source>returns result of &lt;code&gt;session.run()&lt;/code&gt; asked by user</source>
          <target state="translated">возвращает результат &lt;code&gt;session.run()&lt;/code&gt; запрошенный пользователем</target>
        </trans-unit>
        <trans-unit id="ffcf538e172a2e4fa64b41b07c1f6fefeb67c379" translate="yes" xml:space="preserve">
          <source>rnn_mode: Indicates the type of the RNN model. input_mode: Indicate whether there is a linear projection between the input and the actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. Should be &quot;unidirectional&quot; or &quot;bidirectional&quot;. dropout: Dropout probability. When set to 0., dropout is disabled. seed: The 1st part of a seed to initialize dropout. seed2: The 2nd part of a seed to initialize dropout. input: A 3-D tensor with the shape of [seq_length, batch_size, input_size]. input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size, num_units]. input_c: For LSTM, a 3-D tensor with the shape of [num_layer * dir, batch, num_units]. For other models, it is ignored. params: A 1-D tensor that contains the weights and biases in an opaque layout. The size must be created through CudnnRNNParamsSize, and initialized separately. Note that they might not be compatible across different generations. So it is a good idea to save and restore output: A 3-D tensor with the shape of [seq_length, batch_size, dir * num_units]. output_h: The same shape has input_h. output_c: The same shape as input_c for LSTM. An empty tensor for other models. is_training: Indicates whether this operation is used for inference or training. reserve_space: An opaque tensor that can be used in backprop calculation. It is only produced if is_training is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01f3687a592f539f2e61c8b0888a13d4250c1f4" translate="yes" xml:space="preserve">
          <source>rnn_mode: Indicates the type of the RNN model. input_mode: Indicate whether there is a linear projection between the input and the actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. Should be &quot;unidirectional&quot; or &quot;bidirectional&quot;. dropout: Dropout probability. When set to 0., dropout is disabled. seed: The 1st part of a seed to initialize dropout. seed2: The 2nd part of a seed to initialize dropout. input: A 3-D tensor with the shape of [seq_length, batch_size, input_size]. input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size, num_units]. input_c: For LSTM, a 3-D tensor with the shape of [num_layer * dir, batch, num_units]. For other models, it is ignored. params: A 1-D tensor that contains the weights and biases in an opaque layout. The size must be created through CudnnRNNParamsSize, and initialized separately. Note that they might not be compatible across different generations. So it is a good idea to save and restore output: A 3-D tensor with the shape of [seq_length, batch_size, dir * num_units]. output_h: The same shape has input_h. output_c: The same shape as input_c for LSTM. An empty tensor for other models. output_backprop: A 3-D tensor with the same shape as output in the forward pass. output_h_backprop: A 3-D tensor with the same shape as output_h in the forward pass. output_c_backprop: A 3-D tensor with the same shape as output_c in the forward pass. reserve_space: The same reserve_space produced in for forward operation. input_backprop: The backprop to input in the forward pass. Has the same shape as input. input_h_backprop: The backprop to input_h in the forward pass. Has the same shape as input_h. input_c_backprop: The backprop to input_c in the forward pass. Has the same shape as input_c. params_backprop: The backprop to the params buffer in the forward pass. Has the same shape as params.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2c1e58f5f3cb3576bbc5871cbbd89c555d2a05" translate="yes" xml:space="preserve">
          <source>rnn_mode: Indicates the type of the RNN model. input_mode: Indicates whether there is a linear projection between the input and the actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. Should be &quot;unidirectional&quot; or &quot;bidirectional&quot;. dropout: Dropout probability. When set to 0., dropout is disabled. seed: The 1st part of a seed to initialize dropout. seed2: The 2nd part of a seed to initialize dropout. input: A 3-D tensor with the shape of [seq_length, batch_size, input_size]. input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size, num_units]. input_c: For LSTM, a 3-D tensor with the shape of [num_layer * dir, batch, num_units]. For other models, it is ignored. params: A 1-D tensor that contains the weights and biases in an opaque layout. The size must be created through CudnnRNNParamsSize, and initialized separately. Note that they might not be compatible across different generations. So it is a good idea to save and restore output: A 3-D tensor with the shape of [seq_length, batch_size, dir * num_units]. output_h: The same shape has input_h. output_c: The same shape as input_c for LSTM. An empty tensor for other models. is_training: Indicates whether this operation is used for inference or training. reserve_space: An opaque tensor that can be used in backprop calculation. It is only produced if is_training is true. host_reserved: An opaque tensor that can be used in backprop calculation. It is only produced if is_training is true. It is output on host memory rather than device memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70665fcc9ce3d71d359c3bddbe89588b563a31cd" translate="yes" xml:space="preserve">
          <source>rnn_mode: Indicates the type of the RNN model. input_mode: Indicates whether there is a linear projection between the input and the actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. Should be &quot;unidirectional&quot; or &quot;bidirectional&quot;. dropout: Dropout probability. When set to 0., dropout is disabled. seed: The 1st part of a seed to initialize dropout. seed2: The 2nd part of a seed to initialize dropout. input: A 3-D tensor with the shape of [seq_length, batch_size, input_size]. input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size, num_units]. input_c: For LSTM, a 3-D tensor with the shape of [num_layer * dir, batch, num_units]. For other models, it is ignored. params: A 1-D tensor that contains the weights and biases in an opaque layout. The size must be created through CudnnRNNParamsSize, and initialized separately. Note that they might not be compatible across different generations. So it is a good idea to save and restore output: A 3-D tensor with the shape of [seq_length, batch_size, dir * num_units]. output_h: The same shape has input_h. output_c: The same shape as input_c for LSTM. An empty tensor for other models. output_backprop: A 3-D tensor with the same shape as output in the forward pass. output_h_backprop: A 3-D tensor with the same shape as output_h in the forward pass. output_c_backprop: A 3-D tensor with the same shape as output_c in the forward pass. reserve_space: The same reserve_space produced in the forward operation. host_reserved: The same host_reserved produced in the forward operation. input_backprop: The backprop to input in the forward pass. Has the same shape as input. input_h_backprop: The backprop to input_h in the forward pass. Has the same shape as input_h. input_c_backprop: The backprop to input_c in the forward pass. Has the same shape as input_c. params_backprop: The backprop to the params buffer in the forward pass. Has the same shape as params.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5a199bd5189e7f2bd9fadb25180fb6b7791e77" translate="yes" xml:space="preserve">
          <source>rnn_mode: Indicates the type of the RNN model. input_mode: Indicates whether there is a linear projection between the input and the actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. Should be &quot;unidirectional&quot; or &quot;bidirectional&quot;. dropout: Dropout probability. When set to 0., dropout is disabled. seed: The 1st part of a seed to initialize dropout. seed2: The 2nd part of a seed to initialize dropout. input: If time_major is true, this is a 3-D tensor with the shape of [seq_length, batch_size, input_size]. If time_major is false, the shape is [batch_size, seq_length, input_size]. input_h: If time_major is true, this is a 3-D tensor with the shape of [num_layer * dir, batch_size, num_units]. If time_major is false, the shape is [batch_size, num_layer * dir, num_units]. input_c: For LSTM, a 3-D tensor with the shape of [num_layer * dir, batch, num_units]. For other models, it is ignored. params: A 1-D tensor that contains the weights and biases in an opaque layout. The size must be created through CudnnRNNParamsSize, and initialized separately. Note that they might not be compatible across different generations. So it is a good idea to save and restore sequence_lengths: a vector of lengths of each input sequence. output: If time_major is true, this is a 3-D tensor with the shape of [seq_length, batch_size, dir * num_units]. If time_major is false, the shape is [batch_size, seq_length, dir * num_units]. output_h: The same shape has input_h. output_c: The same shape as input_c for LSTM. An empty tensor for other models. is_training: Indicates whether this operation is used for inference or training. time_major: Indicates whether the input/output format is time major or batch major. reserve_space: An opaque tensor that can be used in backprop calculation. It is only produced if is_training is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0218ec339f21ee15a68915046b4d9ea049ea77c5" translate="yes" xml:space="preserve">
          <source>rnn_mode: Indicates the type of the RNN model. input_mode: Indicates whether there is a linear projection between the input and the actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'. direction: Indicates whether a bidirectional model will be used. Should be &quot;unidirectional&quot; or &quot;bidirectional&quot;. dropout: Dropout probability. When set to 0., dropout is disabled. seed: The 1st part of a seed to initialize dropout. seed2: The 2nd part of a seed to initialize dropout. input: If time_major is true, this is a 3-D tensor with the shape of [seq_length, batch_size, input_size]. If time_major is false, the shape is [batch_size, seq_length, input_size]. input_h: If time_major is true, this is a 3-D tensor with the shape of [num_layer * dir, batch_size, num_units]. If time_major is false, the shape is [batch_size, num_layer * dir, num_units]. input_c: For LSTM, a 3-D tensor with the shape of [num_layer * dir, batch, num_units]. For other models, it is ignored. params: A 1-D tensor that contains the weights and biases in an opaque layout. The size must be created through CudnnRNNParamsSize, and initialized separately. Note that they might not be compatible across different generations. So it is a good idea to save and restore sequence_lengths: a vector of lengths of each input sequence. output: If time_major is true, this is a 3-D tensor with the shape of [seq_length, batch_size, dir * num_units]. If time_major is false, the shape is [batch_size, seq_length, dir * num_units]. output_h: The same shape has input_h. output_c: The same shape as input_c for LSTM. An empty tensor for other models. output_backprop: A 3-D tensor with the same shape as output in the forward pass. output_h_backprop: A 3-D tensor with the same shape as output_h in the forward pass. output_c_backprop: A 3-D tensor with the same shape as output_c in the forward pass. time_major: Indicates whether the input/output format is time major or batch major. reserve_space: The same reserve_space produced in the forward operation. input_backprop: The backprop to input in the forward pass. Has the same shape as input. input_h_backprop: The backprop to input_h in the forward pass. Has the same shape as input_h. input_c_backprop: The backprop to input_c in the forward pass. Has the same shape as input_c. params_backprop: The backprop to the params buffer in the forward pass. Has the same shape as params.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ab6ffc68e5c44d88d50d4a9f9d217a8753e60b" translate="yes" xml:space="preserve">
          <source>row_pooling_sequence : this is the result list of pool boundary rows</source>
          <target state="translated">row_pooling_последовательность:это список результатов строк границы пула</target>
        </trans-unit>
        <trans-unit id="275edb19dd7f1f99d15343aafde231f9060022ce" translate="yes" xml:space="preserve">
          <source>rpc_layer - (Optional) Override value for the RPC layer used by TensorFlow. task_type - (Optional) Override value for the current task type. task_id - (Optional) Override value for the current task index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fe9d93f3e47df8d9c783fcf6cb077917e56b29" translate="yes" xml:space="preserve">
          <source>rpc_layer is the protocol used by TensorFlow to communicate with other TensorFlow servers in a distributed environment.</source>
          <target state="translated">rpc_layer-это протокол,используемый TensorFlow для связи с другими серверами TensorFlow в распределенной среде.</target>
        </trans-unit>
        <trans-unit id="2dfdb61fd455fa837cc24b301c2eb99b8b1a3140" translate="yes" xml:space="preserve">
          <source>run_op: An op that runs &lt;code&gt;fn&lt;/code&gt;&lt;code&gt;iterations&lt;/code&gt; times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6fc3775c4d72155b8a971612b98e7bbc36f85f" translate="yes" xml:space="preserve">
          <source>same meaning as preferred_dtype, and overrides it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0408801394dbcad00a9b6e0b2e3cb1c994071969" translate="yes" xml:space="preserve">
          <source>same value for all the internal fields.</source>
          <target state="translated">одинаковое значение для всех внутренних полей.</target>
        </trans-unit>
        <trans-unit id="0006b4ffc1019a531f2deae89d1185661520bd28" translate="yes" xml:space="preserve">
          <source>sample_indices[i], embedding_indices[i] and aggregation_weights[i] correspond to the ith feature. table_ids[i] indicates which embedding table to look up ith feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6d5f695cc7595fedbbc1d6559a1ff9e986d1b4" translate="yes" xml:space="preserve">
          <source>sample_splits[i], embedding_indices[i] and aggregation_weights[i] correspond to the ith feature. table_ids[i] indicates which embedding table to look up ith feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2707d34c06fb1d7676cac65aca74dc8a1d98d6a" translate="yes" xml:space="preserve">
          <source>scalar integer tensor, size of last dimension of returned tensor. Default is the maximum value in &lt;code&gt;lengths&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56511ccc6863b48ca791184fcfd93368726efd9c" translate="yes" xml:space="preserve">
          <source>scalar which applies to the entire output, or a vector of length shape[0] which stores the parameters for each batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5361389569374b99a8dc019695bccde2e4f3068" translate="yes" xml:space="preserve">
          <source>scalar, or tuple or dict or list of constructed scalars and/or other tuples/lists, or scalars. Note: numpy arrays are considered as scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985f0803f47344f05bfd41072710af4dcfef9530" translate="yes" xml:space="preserve">
          <source>scan on the list of tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0.</source>
          <target state="translated">сканировать список тензоров, распакованных из &lt;code&gt;elems&lt;/code&gt; по размерности 0.</target>
        </trans-unit>
        <trans-unit id="8096c4f51922d03acd87a51f1a8040b5de459843" translate="yes" xml:space="preserve">
          <source>scan on the list of tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0. (deprecated argument values)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748611751799fccdd19a378206b3fe8f19e36e1c" translate="yes" xml:space="preserve">
          <source>scoped_allocator_optimization: Try to allocate some independent Op outputs contiguously in order to merge or eliminate downstream Ops.</source>
          <target state="translated">scoped_allocator_оптимизация:Попробуйте выделить несколько независимых выходов Op сопроводительно для слияния или устранения последующих Ops.</target>
        </trans-unit>
        <trans-unit id="583cf791de63e8c90b16ccdf6e729c6194d10b88" translate="yes" xml:space="preserve">
          <source>scores of the ROI boxes in the ROIs' tensor.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
