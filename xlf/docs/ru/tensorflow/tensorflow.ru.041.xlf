<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="7b76c8215965b6d6548dad5cc3be42ab9b948c2e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;signatures&lt;/code&gt; argument controls which methods in &lt;code&gt;obj&lt;/code&gt; will be available to programs which consume &lt;code&gt;SavedModel&lt;/code&gt;s, for example, serving APIs. Python functions may be decorated with &lt;code&gt;@tf.function(input_signature=...)&lt;/code&gt; and passed as signatures directly, or lazily with a call to &lt;code&gt;get_concrete_function&lt;/code&gt; on the method decorated with &lt;code&gt;@tf.function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb10eb93ba6242a60bc81190f01e4562cc7c7f2" translate="yes" xml:space="preserve">
          <source>The options are &quot;global&quot; in the sense they apply to the entire dataset. If options are set multiple times, they are merged as long as different options do not use different non-default values.</source>
          <target state="translated">Варианты являются &quot;глобальными&quot; в том смысле,что они применимы ко всему набору данных.Если опции заданы несколько раз,они объединяются до тех пор,пока различные опции не используют разные значения не по умолчанию.</target>
        </trans-unit>
        <trans-unit id="839958c9eddae1511a49cbdd886b3f520fbec271" translate="yes" xml:space="preserve">
          <source>The order of output arguments here is &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; when &lt;code&gt;compute_uv&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, as opposed to &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; for numpy.linalg.svd.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bc730bbfda16a7dd0623a512f8a88cc6217898" translate="yes" xml:space="preserve">
          <source>The original device on which &lt;code&gt;input_dataset&lt;/code&gt; will be placed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d387209dd33fca87db5f4de4ba44e61656b7a9" translate="yes" xml:space="preserve">
          <source>The original input to &lt;a href=&quot;lu&quot;&gt;&lt;code&gt;tf.linalg.lu&lt;/code&gt;&lt;/a&gt;, i.e., &lt;code&gt;x&lt;/code&gt; as in, &lt;code&gt;lu_reconstruct(*tf.linalg.lu(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af401239a74cc22bb0656ceab277ae88265e81dd" translate="yes" xml:space="preserve">
          <source>The original method wrapped such that it enters the module's name scope.</source>
          <target state="translated">Оригинальный метод обернут таким образом,что он попадает в область видимости имени модуля.</target>
        </trans-unit>
        <trans-unit id="f891d19803fb509490762be082d2f8ade6148c86" translate="yes" xml:space="preserve">
          <source>The original registered Flag objects can be retrieved through the use of the dictionary-like operator, &lt;strong&gt;getitem&lt;/strong&gt;: x = FLAGS['longname'] # access the registered Flag object</source>
          <target state="translated">Исходные зарегистрированные объекты Flag могут быть получены с помощью оператора, &lt;strong&gt;подобного словарю&lt;/strong&gt; , &lt;strong&gt;getitem&lt;/strong&gt; : x = FLAGS ['longname'] # доступ к зарегистрированному объекту Flag</target>
        </trans-unit>
        <trans-unit id="b71549bb8296bfb172b0e5fa059a19b9055f4136" translate="yes" xml:space="preserve">
          <source>The other method &lt;code&gt;uniform&lt;/code&gt; only covers the range [minval, maxval), which cannot be &lt;code&gt;dtype&lt;/code&gt;'s full range because &lt;code&gt;maxval&lt;/code&gt; is of type &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">Другой метод &lt;code&gt;uniform&lt;/code&gt; охватывает только диапазон [MINVAL, MAXVAL), которая не может быть &lt;code&gt;dtype&lt;/code&gt; с полным , так как диапазон &lt;code&gt;maxval&lt;/code&gt; имеет тип &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d650eca6a136e51fc7375e0969bc2ea1115b2e2" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;SparseTensor&lt;/code&gt; object's shape values for all dimensions but the first are the max across the input &lt;code&gt;SparseTensor&lt;/code&gt; objects' shape values for the corresponding dimensions. Its first shape value is &lt;code&gt;N&lt;/code&gt;, the minibatch size.</source>
          <target state="translated">Выходные &lt;code&gt;SparseTensor&lt;/code&gt; формы объекта SparseTensor для всех измерений, кроме первого, являются максимальными значениями формы входных объектов &lt;code&gt;SparseTensor&lt;/code&gt; для соответствующих измерений. Его первое значение формы - &lt;code&gt;N&lt;/code&gt; , размер мини-партии.</target>
        </trans-unit>
        <trans-unit id="f7899fd3a60fa39b01002b08a0bd2e514e0a6d60" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;SparseTensor&lt;/code&gt; object's shape values for the original dimensions are the max across the input &lt;code&gt;SparseTensor&lt;/code&gt; objects' shape values for the corresponding dimensions. The new dimensions match the size of the batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cd935b967006cc01a667a4b3f9d0444d7da4c5" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;SparseTensor&lt;/code&gt; will be in row-major order and will have the same shape as the input.</source>
          <target state="translated">Выходной &lt;code&gt;SparseTensor&lt;/code&gt; будет располагаться в строчном порядке и будет иметь ту же форму, что и входной.</target>
        </trans-unit>
        <trans-unit id="3ed7c320b010e6441e9928df89e4f8feea635e72" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;y&lt;/code&gt; has the same rank as &lt;code&gt;x&lt;/code&gt;. The shapes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; satisfy: &lt;code&gt;y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7bc3e3640548894477903c76a63029f0684b7b" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;y&lt;/code&gt; has the same rank as &lt;code&gt;x&lt;/code&gt;. The shapes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; satisfy: &lt;code&gt;y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]&lt;/code&gt;&lt;code&gt;y[i,j,k,...,s,t,u] == conj(x[perm[i], perm[j], perm[k],...,perm[s], perm[t], perm[u]])&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a24380035e136d9ea98af6a346f119051ef56c" translate="yes" xml:space="preserve">
          <source>The output Tensor as described above, dimensions will vary based on the op provided.</source>
          <target state="translated">Выходной тензор,как описано выше,размеры будут меняться в зависимости от поставляемой опции.</target>
        </trans-unit>
        <trans-unit id="47c4d6134bd40a175fa44afa8f9b377d5850de3c" translate="yes" xml:space="preserve">
          <source>The output consists of two tensors LU and P containing the LU decomposition of all input submatrices &lt;code&gt;[..., :, :]&lt;/code&gt;. LU encodes the lower triangular and upper triangular factors.</source>
          <target state="translated">Выход состоит из двух тензоров LU и P, содержащих LU-разложение всех входных подматриц &lt;code&gt;[..., :, :]&lt;/code&gt; . LU кодирует множители нижнего треугольника и верхнего треугольника.</target>
        </trans-unit>
        <trans-unit id="797ecd44b1fb4a552924484c7a55ad507593ed55" translate="yes" xml:space="preserve">
          <source>The output dtype; defaults to &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31482f2ff54a3aa8fae10ccd117f3f60685fed5f" translate="yes" xml:space="preserve">
          <source>The output dtype; defaults to &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048c6e1cfd308f6012ab77e90cbc674670b136c0" translate="yes" xml:space="preserve">
          <source>The output elements are taken from the input at intervals given by the &lt;code&gt;rate&lt;/code&gt; argument, as in dilated convolutions.</source>
          <target state="translated">Выходные элементы берутся из входных через интервалы, заданные аргументом &lt;code&gt;rate&lt;/code&gt; , как в расширенных свертках.</target>
        </trans-unit>
        <trans-unit id="01cfec4a29cc69f6abe94502062c73070782ab76" translate="yes" xml:space="preserve">
          <source>The output elements will be resorted to preserve the sort order along increasing dimension number.</source>
          <target state="translated">Выходные элементы будут использоваться для сохранения порядка сортировки по возрастающему размерному ряду.</target>
        </trans-unit>
        <trans-unit id="38c8f8944795768b987abf44161bc29810671bc1" translate="yes" xml:space="preserve">
          <source>The output is a tensor of rank &lt;code&gt;k+1&lt;/code&gt; with dimensions &lt;code&gt;[I, J, ..., L, M, N]&lt;/code&gt;. If &lt;code&gt;k&lt;/code&gt; is scalar or &lt;code&gt;k[0] == k[1]&lt;/code&gt;:</source>
          <target state="translated">На выходе получается тензор ранга &lt;code&gt;k+1&lt;/code&gt; с размерностями &lt;code&gt;[I, J, ..., L, M, N]&lt;/code&gt; . Если &lt;code&gt;k&lt;/code&gt; скалярное значение или &lt;code&gt;k[0] == k[1]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b9f3b180f0596bc470d2fb79c1dedac7776f93d9" translate="yes" xml:space="preserve">
          <source>The output is a tensor of shape &lt;code&gt;[..., M, K]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the innermost matrices in &lt;code&gt;output&lt;/code&gt; satisfy matrix equations &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then the strictly then the innermost matrices in &lt;code&gt;output&lt;/code&gt; satisfy matrix equations &lt;code&gt;adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]&lt;/code&gt;.</source>
          <target state="translated">На выходе получается тензор формы &lt;code&gt;[..., M, K]&lt;/code&gt; . Если &lt;code&gt;adjoint&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , то самые внутренние матрицы в &lt;code&gt;output&lt;/code&gt; удовлетворяют матричным уравнениям &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt; . Если &lt;code&gt;adjoint&lt;/code&gt; равен &lt;code&gt;False&lt;/code&gt; , то самые внутренние матрицы на &lt;code&gt;output&lt;/code&gt; удовлетворяют матричным уравнениям &lt;code&gt;adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1488da1cb166b21e2e086e4e08f96c22ee229379" translate="yes" xml:space="preserve">
          <source>The output is a tensor of shape &lt;code&gt;[..., M, N]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the innermost matrices in &lt;code&gt;output&lt;/code&gt; satisfy matrix equations &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then the strictly then the innermost matrices in &lt;code&gt;output&lt;/code&gt; satisfy matrix equations &lt;code&gt;adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6768fd2c3c792ee19a1c494dc0c8f3d25ef95d97" translate="yes" xml:space="preserve">
          <source>The output is a tensor of shape &lt;code&gt;[..., M, N]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the innermost matrices in output satisfy matrix equations &lt;code&gt;sum_k matrix[..., i, k] * output[..., k, j] = rhs[..., i, j]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then the innermost matrices in output satisfy matrix equations &lt;code&gt;sum_k adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24258a9b3cf1537928d726a4c142766d14a612d5" translate="yes" xml:space="preserve">
          <source>The output is a tensor of the same shape as &lt;code&gt;rhs&lt;/code&gt;: either &lt;code&gt;[..., M]&lt;/code&gt; or &lt;code&gt;[..., M, K]&lt;/code&gt;.</source>
          <target state="translated">На выходе получается тензор той же формы, что и &lt;code&gt;rhs&lt;/code&gt; : либо &lt;code&gt;[..., M]&lt;/code&gt; либо &lt;code&gt;[..., M, K]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3db7f6f2ef07d73508fa555433bf8d83a75eaa" translate="yes" xml:space="preserve">
          <source>The output is a tensor of the same shape as the input containing the Cholesky decompositions for all input submatrices &lt;code&gt;[..., :, :]&lt;/code&gt;.</source>
          <target state="translated">Выходные данные представляют собой тензор той же формы, что и входные, содержащие разложения Холецкого для всех входных подматриц &lt;code&gt;[..., :, :]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6194740e93c206c46e0bfecd7aa22357ddec1b58" translate="yes" xml:space="preserve">
          <source>The output is computed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cc9038a532f36829ca3735f949f57712e9a776" translate="yes" xml:space="preserve">
          <source>The output locations corresponding to the implicitly zero elements in the sparse tensor will be zero (i.e., will not take up storage space), regardless of the contents of the dense tensor (even if it's +/-INF and that INF*0 == NaN).</source>
          <target state="translated">Выходные места,соответствующие неявно нулевым элементам в разреженном тензоре,будут равны нулю (т.е.не будут занимать место в памяти),независимо от содержимого плотного тензора (даже если это +/-INF и что INF*0 ==NaN).</target>
        </trans-unit>
        <trans-unit id="4921b3c960168ec33230d0e2275991a2a480fee7" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;../compat/v1/estimator/estimator#evaluate&quot;&gt;&lt;code&gt;Estimator.evaluate&lt;/code&gt;&lt;/a&gt; on this checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30d98674beeba8558b72dc407638d1340b74552" translate="yes" xml:space="preserve">
          <source>The output of the 1-arg function that takes the &lt;code&gt;step&lt;/code&gt; is &lt;code&gt;values[0]&lt;/code&gt; when &lt;code&gt;step &amp;lt;= boundaries[0]&lt;/code&gt;, &lt;code&gt;values[1]&lt;/code&gt; when &lt;code&gt;step &amp;gt; boundaries[0]&lt;/code&gt; and &lt;code&gt;step &amp;lt;= boundaries[1]&lt;/code&gt;, ..., and values[-1] when &lt;code&gt;step &amp;gt; boundaries[-1]&lt;/code&gt;.</source>
          <target state="translated">Результатом функции 1-arg, которая принимает &lt;code&gt;step&lt;/code&gt; являются &lt;code&gt;values[0]&lt;/code&gt; когда &lt;code&gt;step &amp;lt;= boundaries[0]&lt;/code&gt; , &lt;code&gt;values[1]&lt;/code&gt; когда &lt;code&gt;step &amp;gt; boundaries[0]&lt;/code&gt; и &lt;code&gt;step &amp;lt;= boundaries[1]&lt;/code&gt; , ..., и значения [-1], когда &lt;code&gt;step &amp;gt; boundaries[-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d04584f160db196293c2030ae17c2dacfbfcd30d" translate="yes" xml:space="preserve">
          <source>The output of this Op is a single bounding box that may be used to crop the original image. The output is returned as 3 tensors: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;bboxes&lt;/code&gt;. The first 2 tensors can be fed directly into &lt;a href=&quot;../../../slice&quot;&gt;&lt;code&gt;tf.slice&lt;/code&gt;&lt;/a&gt; to crop the image. The latter may be supplied to &lt;a href=&quot;../../../image/draw_bounding_boxes&quot;&gt;&lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt;&lt;/a&gt; to visualize what the bounding box looks like.</source>
          <target state="translated">Результатом этой операции является единственная ограничивающая рамка, которую можно использовать для обрезки исходного изображения. Результат возвращается как 3 тензора: &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; и &lt;code&gt;bboxes&lt;/code&gt; . Первые 2 тензора можно подавать непосредственно в &lt;a href=&quot;../../../slice&quot;&gt; &lt;code&gt;tf.slice&lt;/code&gt; &lt;/a&gt; для обрезки изображения. Последний может быть &lt;a href=&quot;../../../image/draw_bounding_boxes&quot;&gt; &lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt; &lt;/a&gt; в tf.image.draw_bounding_boxes для визуализации того, как выглядит ограничивающая рамка.</target>
        </trans-unit>
        <trans-unit id="cc8ae412cea3a206e259aeb86af6654e659ed171" translate="yes" xml:space="preserve">
          <source>The output of this Op is a single bounding box that may be used to crop the original image. The output is returned as 3 tensors: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;bboxes&lt;/code&gt;. The first 2 tensors can be fed directly into &lt;a href=&quot;../slice&quot;&gt;&lt;code&gt;tf.slice&lt;/code&gt;&lt;/a&gt; to crop the image. The latter may be supplied to &lt;a href=&quot;../image/draw_bounding_boxes&quot;&gt;&lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt;&lt;/a&gt; to visualize what the bounding box looks like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e995a951ce7a3cd16e04e8cd70419e327350a30" translate="yes" xml:space="preserve">
          <source>The output of this Op is a single bounding box that may be used to crop the original image. The output is returned as 3 tensors: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;bboxes&lt;/code&gt;. The first 2 tensors can be fed directly into &lt;a href=&quot;../slice&quot;&gt;&lt;code&gt;tf.slice&lt;/code&gt;&lt;/a&gt; to crop the image. The latter may be supplied to &lt;a href=&quot;draw_bounding_boxes&quot;&gt;&lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt;&lt;/a&gt; to visualize what the bounding box looks like.</source>
          <target state="translated">Результатом этой операции является единственная ограничивающая рамка, которую можно использовать для обрезки исходного изображения. Результат возвращается как 3 тензора: &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; и &lt;code&gt;bboxes&lt;/code&gt; . Первые 2 тензора можно подавать непосредственно в &lt;a href=&quot;../slice&quot;&gt; &lt;code&gt;tf.slice&lt;/code&gt; &lt;/a&gt; для обрезки изображения. Последний может быть &lt;a href=&quot;draw_bounding_boxes&quot;&gt; &lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt; &lt;/a&gt; в tf.image.draw_bounding_boxes для визуализации того, как выглядит ограничивающая рамка.</target>
        </trans-unit>
        <trans-unit id="867a41c15dc52766b0de85d04ee44344a9063866" translate="yes" xml:space="preserve">
          <source>The output of this method is a 3D &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, T, D]&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; is the maximum sequence length for this batch, which could differ from batch to batch.</source>
          <target state="translated">Результатом этого метода является 3D- &lt;code&gt;Tensor&lt;/code&gt; формы &lt;code&gt;[batch_size, T, D]&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; - максимальная длина последовательности для этого пакета, которая может отличаться от партии к партии.</target>
        </trans-unit>
        <trans-unit id="753b9e20d6aac1628ca75bf0511c387d43eb2530" translate="yes" xml:space="preserve">
          <source>The output of this operation is a set of integers indexing into the input collection of bounding boxes representing the selected boxes. The bounding box coordinates corresponding to the selected indices can then be obtained using the &lt;code&gt;tf.gather operation&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6a14177a19f48147884875b20440b0d347e68f" translate="yes" xml:space="preserve">
          <source>The output shape is identical to the inputs', except along the concat dimension, where it is the sum of the inputs' sizes along that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b30057b1110d4946855f0f7f77e28efcaa8cc94" translate="yes" xml:space="preserve">
          <source>The output shapes are compatible in a way that the first dimension of all tensors are the same and equal to the number of possible split nodes for each feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3907a316796c56324c363351b8f0ffb1dbcb1c06" translate="yes" xml:space="preserve">
          <source>The output signature of &lt;code&gt;fn&lt;/code&gt;. Must be specified if &lt;code&gt;fn&lt;/code&gt;'s input and output signatures are different (i.e., if their structures, dtypes, or tensor types do not match). &lt;code&gt;fn_output_signature&lt;/code&gt; can be specified using any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac10a40d7ace5a75143c2fbccbd028ece77a9fb" translate="yes" xml:space="preserve">
          <source>The output slice &lt;code&gt;i&lt;/code&gt; along dimension &lt;code&gt;batch_axis&lt;/code&gt; is then given by input slice &lt;code&gt;i&lt;/code&gt;, with the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; slices along dimension &lt;code&gt;seq_axis&lt;/code&gt; reversed.</source>
          <target state="translated">Выходной срез &lt;code&gt;i&lt;/code&gt; по измерению &lt;code&gt;batch_axis&lt;/code&gt; затем задается входным срезом &lt;code&gt;i&lt;/code&gt; , при этом первые &lt;code&gt;seq_lengths[i]&lt;/code&gt; по измерению &lt;code&gt;seq_axis&lt;/code&gt; перевернуты.</target>
        </trans-unit>
        <trans-unit id="b24ce3e8aaca6570e3ec8cec6e775f6c5f2c52dd" translate="yes" xml:space="preserve">
          <source>The output slice &lt;code&gt;i&lt;/code&gt; along dimension &lt;code&gt;batch_dim&lt;/code&gt; is then given by input slice &lt;code&gt;i&lt;/code&gt;, with the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; slices along dimension &lt;code&gt;seq_dim&lt;/code&gt; reversed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e5d3d89821526e9a3ed69b0fc0e5605bddfe28" translate="yes" xml:space="preserve">
          <source>The output stream, logging level, or file to print to. Defaults to sys.stderr, but sys.stdout, tf.compat.v1.logging.info, tf.compat.v1.logging.warning, tf.compat.v1.logging.error, absl.logging.info, absl.logging.warning and absl.logging.error are also supported. To print to a file, pass a string started with &quot;file://&quot; followed by the file path, e.g., &quot;file:///tmp/foo.out&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098e1ce5365a1d1a1384c17c4ced06e659b0880f" translate="yes" xml:space="preserve">
          <source>The output subscripts must contain only labels appearing in at least one of the input subscripts. Furthermore, all dimensions mapping to the same axis label must be equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0270145e0963e3fa6b4466fddef88fdbf60e481" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; and value:</source>
          <target state="translated">Выходной тензор имеет форму &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; и значение:</target>
        </trans-unit>
        <trans-unit id="aff644b1606cf977042c3f329c0b44912b343d5f" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; and value:</source>
          <target state="translated">Выходной тензор имеет форму &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; и значение:</target>
        </trans-unit>
        <trans-unit id="26ecc2d485656620c8ddae36c3377b136f2c8ef6" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[1, 4, 4, 1]&lt;/code&gt; and value:</source>
          <target state="translated">Выходной тензор имеет форму &lt;code&gt;[1, 4, 4, 1]&lt;/code&gt; и значение:</target>
        </trans-unit>
        <trans-unit id="413cce56d7e73e0557f6955da012eeb198f78207" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[2, 2, 4, 1]&lt;/code&gt; and value:</source>
          <target state="translated">Выходной тензор имеет форму &lt;code&gt;[2, 2, 4, 1]&lt;/code&gt; и значение:</target>
        </trans-unit>
        <trans-unit id="580524501d7754a464d140a489afd8a69565b7e8" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[4, 1, 1, 1]&lt;/code&gt; and value:</source>
          <target state="translated">Выходной тензор имеет форму &lt;code&gt;[4, 1, 1, 1]&lt;/code&gt; и значение:</target>
        </trans-unit>
        <trans-unit id="43b93cea1c5beede2692779450404b22ddd16414" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[4, 1, 1, 3]&lt;/code&gt; and value:</source>
          <target state="translated">Выходной тензор имеет форму &lt;code&gt;[4, 1, 1, 3]&lt;/code&gt; и значение:</target>
        </trans-unit>
        <trans-unit id="863590a97a6747705662d02c1d09d524c465ba85" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[4, 2, 2, 1]&lt;/code&gt; and value:</source>
          <target state="translated">Выходной тензор имеет форму &lt;code&gt;[4, 2, 2, 1]&lt;/code&gt; и значение:</target>
        </trans-unit>
        <trans-unit id="951a2f1acb5ea54cd01c5c69fad552b3af0398ec" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[8, 1, 2, 1]&lt;/code&gt; and value:</source>
          <target state="translated">Выходной тензор имеет форму &lt;code&gt;[8, 1, 2, 1]&lt;/code&gt; и значение:</target>
        </trans-unit>
        <trans-unit id="b991f9c184601aa1cf79a030dce35cd2e1811686" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[8, 1, 3, 1]&lt;/code&gt; and value:</source>
          <target state="translated">Выходной тензор имеет форму &lt;code&gt;[8, 1, 3, 1]&lt;/code&gt; и значение:</target>
        </trans-unit>
        <trans-unit id="8a7212b9117e06db921246aafe5499cc8ff0cedb" translate="yes" xml:space="preserve">
          <source>The output tensor is 2-D or higher with shape &lt;code&gt;[..., r_o, c_o]&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6dc975d4ffc27e7fe4b516c5e078460e61b472d" translate="yes" xml:space="preserve">
          <source>The output tensor is a tensor with dimensions described by 'size' whose values are extracted from 'input' starting at the offsets in 'begin'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018a92a28c57571fe5c1edcfb924689c52abc4b8" translate="yes" xml:space="preserve">
          <source>The output tensor, of rank 3.</source>
          <target state="translated">Выходной тензор,3-его ранга.</target>
        </trans-unit>
        <trans-unit id="1f5eef2e4414626524178eb10c4ab831f83220c9" translate="yes" xml:space="preserve">
          <source>The output tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f156d1cf6b13fd91d5c1751333de4bfa7481e5ec" translate="yes" xml:space="preserve">
          <source>The output tensors for the loop variables after the loop. If &lt;code&gt;return_same_structure&lt;/code&gt; is True, the return value has the same structure as &lt;code&gt;loop_vars&lt;/code&gt;. If &lt;code&gt;return_same_structure&lt;/code&gt; is False, the return value is a Tensor, TensorArray or IndexedSlice if the length of &lt;code&gt;loop_vars&lt;/code&gt; is 1, or a list otherwise.</source>
          <target state="translated">Выходные тензоры для переменных цикла после цикла. Если &lt;code&gt;return_same_structure&lt;/code&gt; имеет значение True, возвращаемое значение имеет ту же структуру, что и &lt;code&gt;loop_vars&lt;/code&gt; . Если &lt;code&gt;return_same_structure&lt;/code&gt; имеет значение False, возвращаемое значение - Tensor, TensorArray или IndexedSlice, если длина &lt;code&gt;loop_vars&lt;/code&gt; равна 1, или список в противном случае.</target>
        </trans-unit>
        <trans-unit id="0bda5fbd6b0783b500c1218ac7c4c0e7746a4905" translate="yes" xml:space="preserve">
          <source>The output tensors for the loop variables after the loop. The return value has the same structure as &lt;code&gt;loop_vars&lt;/code&gt;.</source>
          <target state="translated">Выходные тензоры для переменных цикла после цикла. Возвращаемое значение имеет ту же структуру, что и &lt;code&gt;loop_vars&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a54d6c5881e40fdc200259b55b1119a1261f8a4" translate="yes" xml:space="preserve">
          <source>The output type (&lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;). Default is &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf2d0fef772f974b83b58a081ba47917d2e0a4c" translate="yes" xml:space="preserve">
          <source>The output will be a 3x2 matrix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcada90c4c3eacc21413e8c1e200a0e90b07ffc" translate="yes" xml:space="preserve">
          <source>The output will then have shape &lt;code&gt;(32, 10, 32)&lt;/code&gt;.</source>
          <target state="translated">Результат будет иметь форму &lt;code&gt;(32, 10, 32)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d23cb786d0f9d1271884eaa7c1f7cc8c8a656c8" translate="yes" xml:space="preserve">
          <source>The output will then have shape &lt;code&gt;(32, 10, 8)&lt;/code&gt;.</source>
          <target state="translated">Результат будет иметь форму &lt;code&gt;(32, 10, 8)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95238fe986246430e838c38242139b3ddafc69a1" translate="yes" xml:space="preserve">
          <source>The output(s) of the model. See Functional API example below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae41f4c527c0741341a2f8b321fd1e43f0f98b" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179a09c09a45e5c62e2dec3d73d951ec617567f3" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt;, &lt;code&gt;seed&lt;/code&gt;, &lt;code&gt;counts&lt;/code&gt;, and &lt;code&gt;probs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94bca360c8d84e96136112086d8b12a0b843587" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt;, &lt;code&gt;seed&lt;/code&gt;, &lt;code&gt;minval&lt;/code&gt;, and &lt;code&gt;maxval&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94289abe2083c6f7cb75f0c826a60167f1e5c8a7" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt;, &lt;code&gt;seed&lt;/code&gt;, and &lt;code&gt;alpha&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228f72119b53e369b51ce6a29a98f2313a7f281f" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt;, &lt;code&gt;seed&lt;/code&gt;, and &lt;code&gt;lam&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262b53d310948dd3d4d6f3d1b24c8027dcc78d4c" translate="yes" xml:space="preserve">
          <source>The outputs from all shards are concatenated back together along their 0-th dimension.</source>
          <target state="translated">Выходы всех осколков собраны вместе по их 0-му размеру.</target>
        </trans-unit>
        <trans-unit id="fec5d02e1747f7a22db33ab6777959dc638f2020" translate="yes" xml:space="preserve">
          <source>The outputs of functions used as &lt;code&gt;signatures&lt;/code&gt; must either be flat lists, in which case outputs will be numbered, or a dictionary mapping string keys to &lt;code&gt;Tensor&lt;/code&gt;, in which case the keys will be used to name outputs.</source>
          <target state="translated">Выходы функций, используемых в качестве &lt;code&gt;signatures&lt;/code&gt; должны быть либо плоскими списками, в этом случае выходы будут пронумерованы, либо строковыми ключами словаря для &lt;code&gt;Tensor&lt;/code&gt; , и в этом случае ключи будут использоваться для именования выходов.</target>
        </trans-unit>
        <trans-unit id="3777ae82c580b33611793d1c79fb38091c169efb" translate="yes" xml:space="preserve">
          <source>The package that this class belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fe37226e907ad6b84032ccb7a1a60c428d9656" translate="yes" xml:space="preserve">
          <source>The padded size of each dimension D of the output is:</source>
          <target state="translated">Размер подушки каждого измерения D на выходе:</target>
        </trans-unit>
        <trans-unit id="a3493bda610bfabe1d614c17be7bea5bab6bc509" translate="yes" xml:space="preserve">
          <source>The padding algorithm, must be &quot;SAME&quot; or &quot;VALID&quot;. Defaults to &quot;SAME&quot;. See the &quot;returns&quot; section of &lt;a href=&quot;convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a793cb35afefaa9825726cef177d5eba1c0835" translate="yes" xml:space="preserve">
          <source>The padding algorithm, must be &quot;SAME&quot; or &quot;VALID&quot;. See the &quot;returns&quot; section of &lt;a href=&quot;../../../nn/convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82cf1bc0ef022c1c7dcb21d0cd3cf77bf756e7b4" translate="yes" xml:space="preserve">
          <source>The paper demonstrates the performance of MobileNets using &lt;code&gt;alpha&lt;/code&gt; values of 1.0 (also called 100 % MobileNet), 0.35, 0.5, 0.75, 1.0, 1.3, and 1.4 For each of these &lt;code&gt;alpha&lt;/code&gt; values, weights for 5 different input image sizes are provided (224, 192, 160, 128, and 96).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5b7b8864997727d8fb01740ad8b9e08b14f5f" translate="yes" xml:space="preserve">
          <source>The paper demonstrates the performance of MobileNets using &lt;code&gt;alpha&lt;/code&gt; values of 1.0 (also called 100 % MobileNet), 0.75, 0.5 and 0.25. For each of these &lt;code&gt;alpha&lt;/code&gt; values, weights for 4 different input image sizes are provided (224, 192, 160, 128).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91e185b3ec2b95e4e28b058fb7de6ed54c4f63d" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;concentration&lt;/code&gt; and &lt;code&gt;rate&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g. &lt;code&gt;concentration + rate&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Параметры &lt;code&gt;concentration&lt;/code&gt; и &lt;code&gt;rate&lt;/code&gt; должны быть сформированы таким образом, чтобы поддерживать трансляцию (например, &lt;code&gt;concentration + rate&lt;/code&gt; является допустимой операцией).</target>
        </trans-unit>
        <trans-unit id="c4bf0f9162b85380657aa85a48762d0989942eac" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;df&lt;/code&gt;, &lt;code&gt;loc&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g. &lt;code&gt;df + loc + scale&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Параметры &lt;code&gt;df&lt;/code&gt; , &lt;code&gt;loc&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; должны иметь форму, поддерживающую широковещательную передачу (например, &lt;code&gt;df + loc + scale&lt;/code&gt; - допустимая операция).</target>
        </trans-unit>
        <trans-unit id="f624db393a0283cdff3712a3c4bd723d749a30a5" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g. &lt;code&gt;loc + scale&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Параметры &lt;code&gt;loc&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; должны иметь такую ​​форму, которая поддерживает широковещательную передачу (например, &lt;code&gt;loc + scale&lt;/code&gt; является допустимой операцией).</target>
        </trans-unit>
        <trans-unit id="a2bb7ef60bf0239928d550799fd1318ab8a8e22c" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g., &lt;code&gt;loc / scale&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Параметры &lt;code&gt;loc&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; должны иметь такую ​​форму, которая поддерживает широковещательную передачу (например, &lt;code&gt;loc / scale&lt;/code&gt; является допустимой операцией).</target>
        </trans-unit>
        <trans-unit id="caea2d657314fc74a3b4c82a6b1a8e2927d4e265" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g., &lt;code&gt;high - low&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Параметры &lt;code&gt;low&lt;/code&gt; и &lt;code&gt;high&lt;/code&gt; должны иметь форму, которая поддерживает широковещательную передачу (например, допустимая операция &lt;code&gt;high - low&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2da0524f5e34c476f58d52fd7e4bbaca30e3840a" translate="yes" xml:space="preserve">
          <source>The parameters apply to and only to the immediately enclosing loop. It only has effect if the loop is staged as a TF while_loop; otherwise the parameters have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f861e09ace62d9cf6a436ce61f90b0514dff3612" translate="yes" xml:space="preserve">
          <source>The parameters can be intuited via their relationship to mean and stddev,</source>
          <target state="translated">Параметры могут быть интуитивно понятны через их отношение к среднему и stddev,</target>
        </trans-unit>
        <trans-unit id="78832ff2cd51fc67f3284e123b0a8c7a1096d66b" translate="yes" xml:space="preserve">
          <source>The parent could be a module when the child is a function at module scope. Or the parent could be a class when a class' method is being replaced. The named child is set to new_child, while the prior definition is saved away for later, when UnsetAll() is called.</source>
          <target state="translated">Родительским может быть модуль,если дочерний элемент является функцией в области действия модуля.Или родитель может быть классом при замене метода класса.Именованный дочерний элемент устанавливается в new_child,а предыдущее определение сохраняется на потом,при вызове UnsetAll().</target>
        </trans-unit>
        <trans-unit id="cc13d476090ccb6ba884188ddcc28a81f62b0726" translate="yes" xml:space="preserve">
          <source>The parse() method checks to make sure that the string argument is a legal value and convert it to a native type. If the value cannot be converted, it should throw a 'ValueError' exception with a human readable explanation of why the value is illegal.</source>
          <target state="translated">Метод parse()проверяет,что строковый аргумент является юридическим значением,и преобразует его в родной тип.Если значение не может быть преобразовано,он должен бросить исключение 'ValueError' с удобочитаемым объяснением того,почему значение является незаконным.</target>
        </trans-unit>
        <trans-unit id="cf0794be97523b0be42896e118da1be5a61ff4da" translate="yes" xml:space="preserve">
          <source>The parsed value in native type.</source>
          <target state="translated">Разобранное значение в нативном типе.</target>
        </trans-unit>
        <trans-unit id="8cff8c184992ecf7d79d6a190fc8e2ad81b8dd10" translate="yes" xml:space="preserve">
          <source>The partitioned embedding in &lt;code&gt;embedding_weights&lt;/code&gt; must all be the same shape except for the first dimension. The first dimension is allowed to vary as the vocabulary size is not necessarily a multiple of &lt;code&gt;P&lt;/code&gt;. &lt;code&gt;embedding_weights&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../compat/v1/get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">Разделенные вложения в &lt;code&gt;embedding_weights&lt;/code&gt; должны иметь одинаковую форму, за исключением первого измерения. Первое измерение может меняться , как словарный размер не обязательно является кратным &lt;code&gt;P&lt;/code&gt; . &lt;code&gt;embedding_weights&lt;/code&gt; может быть &lt;code&gt;PartitionedVariable&lt;/code&gt; , возвращенным с помощью &lt;a href=&quot;../compat/v1/get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt; с разделителем.</target>
        </trans-unit>
        <trans-unit id="8e157288a667a186f035deba918682c801fa1abf" translate="yes" xml:space="preserve">
          <source>The partitioned embedding in &lt;code&gt;embedding_weights&lt;/code&gt; must all be the same shape except for the first dimension. The first dimension is allowed to vary as the vocabulary size is not necessarily a multiple of &lt;code&gt;P&lt;/code&gt;. &lt;code&gt;embedding_weights&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">Разделенные вложения в &lt;code&gt;embedding_weights&lt;/code&gt; должны иметь одинаковую форму, за исключением первого измерения. Первое измерение может меняться , как словарный размер не обязательно является кратным &lt;code&gt;P&lt;/code&gt; . &lt;code&gt;embedding_weights&lt;/code&gt; может быть &lt;code&gt;PartitionedVariable&lt;/code&gt; , возвращенным с помощью &lt;a href=&quot;../get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt; с разделителем.</target>
        </trans-unit>
        <trans-unit id="1549f14314cb2911099be0c08464c7d5489a22a6" translate="yes" xml:space="preserve">
          <source>The partitioned embedding in &lt;code&gt;embedding_weights&lt;/code&gt; must all be the same shape except for the first dimension. The first dimension is allowed to vary as the vocabulary size is not necessarily a multiple of num of shards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b7bcbb761db59d963bb51839f46a4b29f4af4e" translate="yes" xml:space="preserve">
          <source>The path is relative to tensorflow/</source>
          <target state="translated">Путь относителен к тензорному потоку/</target>
        </trans-unit>
        <trans-unit id="f48baa97e568a9b9e3b5f52a6ab7e866fecd8550" translate="yes" xml:space="preserve">
          <source>The path of the output proto file.</source>
          <target state="translated">Путь к выходному файлу прото.</target>
        </trans-unit>
        <trans-unit id="ee14c49610bbef1394c243e137f1c0c32f1960be" translate="yes" xml:space="preserve">
          <source>The path to a directory in which to write checkpoints. A special file named &quot;checkpoint&quot; is also written to this directory (in a human-readable text format) which contains the state of the &lt;code&gt;CheckpointManager&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d2248f6c5ba1b79f5657059376b70c88f9d6c1" translate="yes" xml:space="preserve">
          <source>The path to an event file created by a &lt;code&gt;SummaryWriter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7713229c9d7bf490b65513fab0d07d2cad4f51" translate="yes" xml:space="preserve">
          <source>The path to the TFRecords file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c5edf8f8528c6dcc19dfeb36d929c09dc91f28" translate="yes" xml:space="preserve">
          <source>The path to the checkpoint as returned by &lt;code&gt;write&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8030756c5c759c44f9f3cb2091477d30b127210" translate="yes" xml:space="preserve">
          <source>The path to the checkpoint, as returned by &lt;code&gt;save&lt;/code&gt; or &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. If None (as when there is no latest checkpoint for &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt; to return), returns an object which may run initializers for objects in the dependency graph. If the checkpoint was written by the name-based &lt;a href=&quot;saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt;, names are used to match variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9bb46d11e0a3efc649638be0d00aa480e84e55" translate="yes" xml:space="preserve">
          <source>The path to the checkpoint, as returned by &lt;code&gt;save&lt;/code&gt; or &lt;a href=&quot;latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. If the checkpoint was written by the name-based &lt;a href=&quot;../compat/v1/train/saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt;, names are used to match variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c8f8b6fd3cf107eb955208c8e6315d0e1a6163" translate="yes" xml:space="preserve">
          <source>The path to the exported directory as a bytes object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6d384388d19ed3fa790b1769ea860a0e6be8d0" translate="yes" xml:space="preserve">
          <source>The path to the new checkpoint. It is also recorded in the &lt;code&gt;checkpoints&lt;/code&gt; and &lt;code&gt;latest_checkpoint&lt;/code&gt; properties.</source>
          <target state="translated">Путь к новой КПП. Он также записывается в свойствах &lt;code&gt;checkpoints&lt;/code&gt; и &lt;code&gt;latest_checkpoint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="995443700e473d68dc872f5c69aa35e966bca809" translate="yes" xml:space="preserve">
          <source>The path to the new checkpoint. It is also recorded in the &lt;code&gt;checkpoints&lt;/code&gt; and &lt;code&gt;latest_checkpoint&lt;/code&gt; properties. &lt;code&gt;None&lt;/code&gt; if no checkpoint is saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee0e0b9b831848f3b4065f81ba73b2d7593c0f8" translate="yes" xml:space="preserve">
          <source>The path to the specified file present in the data attribute of py_test or py_binary.</source>
          <target state="translated">Путь к указанному файлу,присутствующему в атрибуте данных py_test или py_binary.</target>
        </trans-unit>
        <trans-unit id="c28b39685fa19f5fe1fe963ce50d396e16dbe87f" translate="yes" xml:space="preserve">
          <source>The path to the specified file present in the data attribute of py_test or py_binary. Falls back to returning the same as get_data_files_path if it fails to detect a bazel runfiles directory.</source>
          <target state="translated">Путь к указанному файлу,присутствующему в атрибуте данных py_test или py_binary.Возвращает к возврату того же пути,что и путь get_data_files_path,если не удается обнаружить каталог runfiles бейзела.</target>
        </trans-unit>
        <trans-unit id="87756ef48ceb2a46a88324fa1e20a23d5ed02a12" translate="yes" xml:space="preserve">
          <source>The path to which the SavedModel protocol buffer was written.</source>
          <target state="translated">Путь,по которому был записан буфер протокола SavedModel.</target>
        </trans-unit>
        <trans-unit id="8be5bab78d1909543ad9986a84ecdbc0832b8254" translate="yes" xml:space="preserve">
          <source>The path to which the SavedModel will be stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dab2a06ad633869bd90e943c4184ac0e2fe54a0" translate="yes" xml:space="preserve">
          <source>The pattern follows the re2 syntax (&lt;a href=&quot;https://github.com/google/re2/wiki/Syntax&quot;&gt;https://github.com/google/re2/wiki/Syntax&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7281e72ad08903abeb2bd587c7c0dfd0d8772e6" translate="yes" xml:space="preserve">
          <source>The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)</source>
          <target state="translated">Шаблон следует синтаксису re2 (https://github.com/google/re2/wiki/Syntax).</target>
        </trans-unit>
        <trans-unit id="6073374fbdf4fdacc0b93351a02133e64c1915d8" translate="yes" xml:space="preserve">
          <source>The patterns are defined as strings. Supported patterns are defined here. Note that the pattern can be a Python iteratable of string patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c52ca33f774b534fe80a4db87092be76893e002" translate="yes" xml:space="preserve">
          <source>The peephole implementation is based on:</source>
          <target state="translated">Реализация глазка основана:</target>
        </trans-unit>
        <trans-unit id="baf8710cc0a85723dd8aa2526d303f0863e63136" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; depends on the underlying operators performance.</source>
          <target state="translated">Производительность &lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; зависит от производительности базовых операторов.</target>
        </trans-unit>
        <trans-unit id="80d488d70fd1fbe1594d7c6c118ae3795bd1145d" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; on any operation is equal to the sum of the individual operators' operations.</source>
          <target state="translated">Производительность &lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; для любой операции равна сумме операций отдельных операторов.</target>
        </trans-unit>
        <trans-unit id="9b2ab24a37ac3d66ce6ff090c15ce4c8f5b1d480" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorComposition&lt;/code&gt; on any operation is equal to the sum of the individual operators' operations.</source>
          <target state="translated">Производительность &lt;code&gt;LinearOperatorComposition&lt;/code&gt; для любой операции равна сумме операций отдельных операторов.</target>
        </trans-unit>
        <trans-unit id="f94bad31467a9ea9f4b4d537674d8e77b0cf1a22" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorInversion&lt;/code&gt; depends on the underlying operators performance: &lt;code&gt;solve&lt;/code&gt; and &lt;code&gt;matmul&lt;/code&gt; are swapped, and determinant is inverted.</source>
          <target state="translated">Производительность &lt;code&gt;LinearOperatorInversion&lt;/code&gt; зависит от лежащих в основе производительности операторов: &lt;code&gt;solve&lt;/code&gt; и &lt;code&gt;matmul&lt;/code&gt; меняются местами, и определитель инвертируется.</target>
        </trans-unit>
        <trans-unit id="bc0efd32d22cd6d37162492744eb9c09073101ec" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorKronecker&lt;/code&gt; on any operation is equal to the sum of the individual operators' operations.</source>
          <target state="translated">Производительность &lt;code&gt;LinearOperatorKronecker&lt;/code&gt; на любой операции равна сумме операций отдельных операторов.</target>
        </trans-unit>
        <trans-unit id="3adcc83502b5bf35b4db3b88505bc6feb67f24c9" translate="yes" xml:space="preserve">
          <source>The polygamma function is defined as:</source>
          <target state="translated">Полигамная функция определяется как:</target>
        </trans-unit>
        <trans-unit id="58805a4c695a0c84e281d698b93c5605de911e7d" translate="yes" xml:space="preserve">
          <source>The port the TensorFlow server is listening on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278a092ca102f6f63192c91f543df0b76f86bf53" translate="yes" xml:space="preserve">
          <source>The position where padding or truncation happens is determined by the arguments &lt;code&gt;padding&lt;/code&gt; and &lt;code&gt;truncating&lt;/code&gt;, respectively. Pre-padding or removing values from the beginning of the sequence is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d524ae593bfca1cec825db026e283842ef95ed3" translate="yes" xml:space="preserve">
          <source>The possible number of labels the classification task can have. If this value is not provided, it will be calculated using both predictions and labels array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efb3a74fd166658f111b04a0c0279818ee74864" translate="yes" xml:space="preserve">
          <source>The possible number of labels the prediction task can have. This value must be provided, since a confusion matrix of dimension = [num_classes, num_classes] will be allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0a01897541e4cc7358dd44c0abef35501aae05" translate="yes" xml:space="preserve">
          <source>The possible number of labels the prediction task can have. This value must be provided, since two variables with shape = [num_classes] will be allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692359d83812b544d928c04fadf8b5c3c2df67a0" translate="yes" xml:space="preserve">
          <source>The possible values are: &lt;code&gt;GATE_NONE&lt;/code&gt;, &lt;code&gt;GATE_OP&lt;/code&gt;, and &lt;code&gt;GATE_GRAPH&lt;/code&gt;.</source>
          <target state="translated">Возможные значения: &lt;code&gt;GATE_NONE&lt;/code&gt; , &lt;code&gt;GATE_OP&lt;/code&gt; и &lt;code&gt;GATE_GRAPH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5d3e18deacf1c7ef93bee6d5b865603caff1a2a" translate="yes" xml:space="preserve">
          <source>The potentially support list contains a list of ops that are partially or fully supported, which is derived by simply scanning op names to check whether they can be handled without real conversion and specific parameters.</source>
          <target state="translated">Список потенциально поддерживаемых операторов содержит список частично или полностью поддерживаемых операторов,который выводится путем простого сканирования имен операторов,чтобы проверить,могут ли они быть обработаны без реального преобразования и определенных параметров.</target>
        </trans-unit>
        <trans-unit id="7c853ad9a21d66e7bd6fdc646ae396c38787f2e0" translate="yes" xml:space="preserve">
          <source>The predicted outputs, a tensor of size &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; where N+1 is the total number of dimensions in &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f104bcdd7d5f421504142d2c94d5f8c62a0e743f" translate="yes" xml:space="preserve">
          <source>The predicted outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70f131e2a7ce29596591e28a1cfededaebaff6a" translate="yes" xml:space="preserve">
          <source>The predicted values, a &lt;code&gt;Tensor&lt;/code&gt; of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6728a30c6037094fe5c0a9ed3f50b7de76aa2e0d" translate="yes" xml:space="preserve">
          <source>The predicted values, a &lt;code&gt;Tensor&lt;/code&gt; of arbitrary dimensions. Will be cast to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f7a8826bad533ae16d312cbce730009c206751" translate="yes" xml:space="preserve">
          <source>The predicted values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4778ceab3533971f6aa86d7a9cab9cffa7b4ebb" translate="yes" xml:space="preserve">
          <source>The predicted values. Each element must be in the range &lt;code&gt;[0, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f018a513047301d5f31c33cb992832bb0aa35d" translate="yes" xml:space="preserve">
          <source>The predicted values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9916875b88168e8e1d45339b98305ac670cab32" translate="yes" xml:space="preserve">
          <source>The predicted values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350857c387e91589b30efc773f0aa8bb73f1dd8b" translate="yes" xml:space="preserve">
          <source>The prediction values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22221eb5e9024f9d30d6d77902385bdae34280a3" translate="yes" xml:space="preserve">
          <source>The prefix of a V1 or V2 checkpoint. Typically the result of &lt;code&gt;Saver.save()&lt;/code&gt; or that of &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint()&lt;/code&gt;&lt;/a&gt;, regardless of sharded/non-sharded or V1/V2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf184bbd1e736ec9f0efcfa8ff77fd74b286f9f" translate="yes" xml:space="preserve">
          <source>The prefix of the most recent checkpoint in &lt;code&gt;directory&lt;/code&gt;.</source>
          <target state="translated">Префикс самой последней контрольной точки в &lt;code&gt;directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e79e9868436b7bc9300626a15307ccf5673bf8d" translate="yes" xml:space="preserve">
          <source>The prefix to use on all names created within the name scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a7df5de41d0edab56a0d1dc85f3a8f7b95e198" translate="yes" xml:space="preserve">
          <source>The primary case where you need extra work to support mixed precision or float64 is when you create a new tensor, such as with &lt;a href=&quot;../../../ones&quot;&gt;&lt;code&gt;tf.ones&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt;. In such cases, you must create the tensor of the correct dtype. For example, suppose you modify the &lt;code&gt;MyDense&lt;/code&gt; layer to add a random number to the output using &lt;a href=&quot;../../../random/normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;. You must pass the input dtype to &lt;a href=&quot;../../../random/normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt; to ensure the dtypes match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70445e39cb7672ad4a6b06501270c1f13979a70f" translate="yes" xml:space="preserve">
          <source>The primary use case for this API is to put tensors in a set/dictionary. We can't put tensors in a set/dictionary as &lt;code&gt;tensor.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c5bb1e4f98a69939280a641cea06563cef1412" translate="yes" xml:space="preserve">
          <source>The primary use case for this API is to put variables in a set/dictionary. We can't put variables in a set/dictionary as &lt;code&gt;variable.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cdbe0557abf05d8c31ba3846734c76d96d3bcc3" translate="yes" xml:space="preserve">
          <source>The primary usecase for this API is to put tensors in a set/dictionary. We can't put tensors in a set/dictionary as &lt;code&gt;tensor.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="translated">Основным вариантом использования этого API является размещение тензоров в наборе / словаре. Мы не можем помещать тензоры в набор / словарь как &lt;code&gt;tensor.__hash__()&lt;/code&gt; больше не доступен, начиная с Tensorflow 2.0.</target>
        </trans-unit>
        <trans-unit id="14c5ca1e155e62f217839df947a76604aa7befe7" translate="yes" xml:space="preserve">
          <source>The primary usecase for this API is to put variables in a set/dictionary. We can't put variables in a set/dictionary as &lt;code&gt;variable.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="translated">Основной способ использования этого API - помещать переменные в набор / словарь. Мы не можем помещать переменные в набор / словарь как &lt;code&gt;variable.__hash__()&lt;/code&gt; больше не доступен, начиная с Tensorflow 2.0.</target>
        </trans-unit>
        <trans-unit id="bfffea38233a7f94cfc568cf11eefdfb38392417" translate="yes" xml:space="preserve">
          <source>The probability density function (pdf) is,</source>
          <target state="translated">Функция плотности вероятности (pdf),</target>
        </trans-unit>
        <trans-unit id="d639692ffbb24f5fe23fd0cf8f29f9ea56836d74" translate="yes" xml:space="preserve">
          <source>The probability density function (pdf) of this distribution is,</source>
          <target state="translated">Функция плотности вероятности (pdf)этого распределения,</target>
        </trans-unit>
        <trans-unit id="c2092fccabcd3a2abdef73412d545365899001b8" translate="yes" xml:space="preserve">
          <source>The probability mass function (pmf) is,</source>
          <target state="translated">Функция массы вероятности (pmf),</target>
        </trans-unit>
        <trans-unit id="331d712cc96a7cb254a89657cf4ba910cc781864" translate="yes" xml:space="preserve">
          <source>The processing of each sample contains the following steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1597763a35d57db9c807276fa76fead0e6bf3d7" translate="yes" xml:space="preserve">
          <source>The processing of each sample contains the following steps: 1) standardize each sample (usually lowercasing + punctuation stripping) 2) split each sample into substrings (usually words) 3) recombine substrings into tokens (usually ngrams) 4) index tokens (associate a unique int value with each token) 5) transform each sample using this index, either into a vector of ints or a dense float vector.</source>
          <target state="translated">Обработка каждого образца состоит из следующих этапов:1)стандартизация каждой выборки (обычно в нижнем регистре+снятие пунктуации)2)разбиение каждой выборки на подложки (обычно в словах)3)рекомбинация подложек на токены (обычно в граммах)4)маркеры индексов (ассоциирование уникального значения int с каждой маркерой)5)преобразование каждой выборки с помощью этого индекса,либо в вектор чернил,либо в плотный вектор плавающего поплавка.</target>
        </trans-unit>
        <trans-unit id="bc3e043e3089ab9c2cc2954b166a1bf6364579df" translate="yes" xml:space="preserve">
          <source>The profiler server will exit when the process finishes. The service is defined in tensorflow/core/profiler/profiler_service.proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67a4435185658688f7c2b52360cda7ea81a0d75" translate="yes" xml:space="preserve">
          <source>The profiler session will be stopped and profile results can be saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcf3e7dfeb12410a9d6122f19a6f9f6186a333b" translate="yes" xml:space="preserve">
          <source>The protocol TensorFlow used to communicate between nodes. Defaults to 'grpc'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e9c7a33590d968d1c4d2adb1f14e30ca9d6e013" translate="yes" xml:space="preserve">
          <source>The provided generator can be finite in which case the class will throw a &lt;code&gt;StopIteration&lt;/code&gt; exception.</source>
          <target state="translated">Предоставленный генератор может быть конечным, и в этом случае класс &lt;code&gt;StopIteration&lt;/code&gt; исключение StopIteration .</target>
        </trans-unit>
        <trans-unit id="8129f9559f62303b98c598e584d99bb1465d425d" translate="yes" xml:space="preserve">
          <source>The provided value can be a python boolean, a scalar boolean Tensor, or or a callable providing such a value; if a callable is passed it will be invoked on-demand to determine whether summary writing will occur.</source>
          <target state="translated">Предоставляемое значение может быть питоновым булевым,скалярным булевым тензором или вызываемым,предоставляющим такое значение;при передаче вызываемого значения оно будет вызвано по требованию для определения того,произойдет ли суммарная запись.</target>
        </trans-unit>
        <trans-unit id="d84a7589708b247ba11ef0a6241d0276fd1c0415" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix &lt;code&gt;A&lt;/code&gt;, is defined as: 'the matrix that 'solves' [the least-squares problem] &lt;code&gt;A @ x = b&lt;/code&gt;,' i.e., if &lt;code&gt;x_hat&lt;/code&gt; is a solution, then &lt;code&gt;A_pinv&lt;/code&gt; is the matrix such that &lt;code&gt;x_hat = A_pinv @ b&lt;/code&gt;. It can be shown that if &lt;code&gt;U @ Sigma @ V.T = A&lt;/code&gt; is the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, then &lt;code&gt;A_pinv = V @ inv(Sigma) U^T&lt;/code&gt;. [(Strang, 1980)][1]</source>
          <target state="translated">Псевдообратная матрица &lt;code&gt;A&lt;/code&gt; определяется как: &amp;laquo;матрица, которая&amp;laquo; решает &amp;raquo;[задачу наименьших квадратов] &lt;code&gt;A @ x = b&lt;/code&gt; , то есть, если &lt;code&gt;x_hat&lt;/code&gt; является решением, то &lt;code&gt;A_pinv&lt;/code&gt; - это матрица, такая что &lt;code&gt;x_hat = A_pinv @ b&lt;/code&gt; . Можно показать , что если &lt;code&gt;U @ Sigma @ V.T = A&lt;/code&gt; является значением разложения единственного числа &lt;code&gt;A&lt;/code&gt; , то &lt;code&gt;A_pinv = V @ inv(Sigma) U^T&lt;/code&gt; . [(Стрэнг, 1980)] [1]</target>
        </trans-unit>
        <trans-unit id="9b22641be848196f7d9c02ba6fc3610602324007" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to allow users of existing layers to slowly transition to Keras layers API without breaking existing functionality.</source>
          <target state="translated">Цель этой функции-позволить пользователям существующих слоев медленно переходить на Keras layers API,не нарушая при этом существующий функционал.</target>
        </trans-unit>
        <trans-unit id="d088d5e5d63d8b56ec540e3afc689671a1995e6f" translate="yes" xml:space="preserve">
          <source>The purpose of this scope is to allow users of existing layers to slowly transition to a Keras layers API without breaking existing functionality.</source>
          <target state="translated">Цель этого диапазона-позволить пользователям существующих слоев медленно перейти на Keras layers API,не нарушая при этом существующую функциональность.</target>
        </trans-unit>
        <trans-unit id="7c5cb70c5a3b792465bd5ce774c8ea2af3bb85e3" translate="yes" xml:space="preserve">
          <source>The python function &lt;code&gt;fn&lt;/code&gt; will be called once with symbolic arguments specified in the &lt;code&gt;signature&lt;/code&gt;, traced, and turned into a graph function. Any variables created by &lt;code&gt;fn&lt;/code&gt; will be owned by the object returned by &lt;code&gt;wrap_function&lt;/code&gt;. The resulting graph function can be called with tensors which match the signature.</source>
          <target state="translated">Функция python &lt;code&gt;fn&lt;/code&gt; будет вызываться один раз с символьными аргументами, указанными в &lt;code&gt;signature&lt;/code&gt; , отслеживаться и превращаться в функцию графика. Любые переменные, созданные &lt;code&gt;fn&lt;/code&gt; , будут принадлежать объекту, возвращаемому &lt;code&gt;wrap_function&lt;/code&gt; . Полученная функция-график может быть вызвана с тензорами, соответствующими сигнатуре.</target>
        </trans-unit>
        <trans-unit id="d03bcbea9ec248eeaa20713d75d526a9879de1ff" translate="yes" xml:space="preserve">
          <source>The quantity to be monitored needs to be available in &lt;code&gt;logs&lt;/code&gt; dict. To make it so, pass the loss or metrics at &lt;code&gt;model.compile()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8a7f5ae13c0deb4cd4a8012ab18a5fdec064e5" translate="yes" xml:space="preserve">
          <source>The queue reference, i.e. the output of the queue op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaadc5a70ca763680cae28ccccd312176ae7929f" translate="yes" xml:space="preserve">
          <source>The ragged rank for the &lt;code&gt;RaggedTensor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2591fdff5d530b2526efe01b41c14d72949b69" translate="yes" xml:space="preserve">
          <source>The random integers are slightly biased unless &lt;code&gt;maxval - minval&lt;/code&gt; is an exact power of two. The bias is small for values of &lt;code&gt;maxval - minval&lt;/code&gt; significantly smaller than the range of the output (either &lt;code&gt;2^32&lt;/code&gt; or &lt;code&gt;2^64&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20ff491ff5822812275688511b761f22476aa65" translate="yes" xml:space="preserve">
          <source>The range of pixel values for the output image might be slightly different from the range for the input image because of limited numerical precision. To guarantee an output range, for example &lt;code&gt;[0.0, 1.0]&lt;/code&gt;, apply &lt;a href=&quot;../../../clip_by_value&quot;&gt;&lt;code&gt;tf.clip_by_value&lt;/code&gt;&lt;/a&gt; to the output.</source>
          <target state="translated">Диапазон значений пикселей для выходного изображения может немного отличаться от диапазона для входного изображения из-за ограниченной числовой точности. Чтобы гарантировать диапазон вывода, например &lt;code&gt;[0.0, 1.0]&lt;/code&gt; , примените к выводу &lt;a href=&quot;../../../clip_by_value&quot;&gt; &lt;code&gt;tf.clip_by_value&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8fedfebee027b536f10130b6d675ab2045757c3" translate="yes" xml:space="preserve">
          <source>The range of pixel values for the output image might be slightly different from the range for the input image because of limited numerical precision. To guarantee an output range, for example &lt;code&gt;[0.0, 1.0]&lt;/code&gt;, apply &lt;a href=&quot;../clip_by_value&quot;&gt;&lt;code&gt;tf.clip_by_value&lt;/code&gt;&lt;/a&gt; to the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6294e1714e1b2b241bb1943b70eb74fc15a98222" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the same &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; kernel (i.e. internal representation) is used by TensorFlow for all calls of it with the same arguments, and the kernel maintains an internal counter which is incremented every time it is executed, generating different results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afabff9ee6287914682ddea57965fb5330ae1825" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the same &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; kernel (i.e. internel representation) is used by TensorFlow for all calls of it with the same arguments, and the kernel maintains an internal counter which is incremented every time it is executed, generating different results.</source>
          <target state="translated">Причина, по которой мы получаем 'A2' вместо 'A1' при втором вызове &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; выше, заключается в том, что одно и то же ядро &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; (т.е. внутреннее представление) используется TensorFlow для всех его вызовов с одинаковыми аргументами. , а ядро ​​поддерживает внутренний счетчик, который увеличивается каждый раз при выполнении, генерируя разные результаты.</target>
        </trans-unit>
        <trans-unit id="466c31e39da78ea430b94cdcadf9fd7405e0f0cf" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the secand call uses a different operation seed.</source>
          <target state="translated">Причина, по которой мы получаем &amp;laquo;A2&amp;raquo; вместо &amp;laquo;A1&amp;raquo; при втором вызове &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; выше, заключается в том, что вызов secand использует другое начальное значение операции.</target>
        </trans-unit>
        <trans-unit id="784df8a2c4aec00572bf8c70feb9ae2a52a2afdd" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the second call uses a different operation seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1280cfc6968446075563e60ad83288d637db87ba" translate="yes" xml:space="preserve">
          <source>The reconstruct one or more matrices from their LU decomposition(s).</source>
          <target state="translated">Восстановите одну или несколько матриц из их LU-разложения (разложения).</target>
        </trans-unit>
        <trans-unit id="39397157700bab61929a7d8ce8314e15144efa4b" translate="yes" xml:space="preserve">
          <source>The reduced SparseTensor.</source>
          <target state="translated">Уменьшенный сенсор Спарсе.</target>
        </trans-unit>
        <trans-unit id="162a81b2ee639009df98d0138880fb964fcbc8fc" translate="yes" xml:space="preserve">
          <source>The reduced Tensor or the reduced SparseTensor if &lt;code&gt;output_is_sparse&lt;/code&gt; is True.</source>
          <target state="translated">Уменьшенный Tensor или уменьшенный SparseTensor, если &lt;code&gt;output_is_sparse&lt;/code&gt; имеет значение True.</target>
        </trans-unit>
        <trans-unit id="1e34999a75a17ec65b85f93cb20fe03874e9d9e8" translate="yes" xml:space="preserve">
          <source>The reduced Tensor.</source>
          <target state="translated">Сниженный тензор.</target>
        </trans-unit>
        <trans-unit id="fa52820210f038254236a33cd72deaaa4f2921cc" translate="yes" xml:space="preserve">
          <source>The reduced tensor (number of nonzero values).</source>
          <target state="translated">Сниженный тензор (количество ненулевых значений).</target>
        </trans-unit>
        <trans-unit id="5089f15002ac696c728750d278b7a2bb4b8292fd" translate="yes" xml:space="preserve">
          <source>The reduced tensor, of the same dtype as the input_tensor.</source>
          <target state="translated">Уменьшенный тензор,того же типа d,что и входной_тензор.</target>
        </trans-unit>
        <trans-unit id="db036397ce15010ca38b7140e4ed7771da72f4bd" translate="yes" xml:space="preserve">
          <source>The reduced tensor, of the same dtype as the input_tensor. Note, for &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt; input, the returned &lt;code&gt;Tensor&lt;/code&gt; will be of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377005a84a788fcaae09139342bfe31ee6c3e407" translate="yes" xml:space="preserve">
          <source>The reduced tensor.</source>
          <target state="translated">Сниженный тензор.</target>
        </trans-unit>
        <trans-unit id="4ca20066ecafb2f76458db7f5aae15b94f4599bf" translate="yes" xml:space="preserve">
          <source>The reduction to apply to the shard losses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32126f130f539d8b348c3776e0d288e0eb3023ae" translate="yes" xml:space="preserve">
          <source>The reference to the TensorArray.</source>
          <target state="translated">Ссылка на TensorArray.</target>
        </trans-unit>
        <trans-unit id="bec5f1d035188c5f615977438d1fd8d80cd736d2" translate="yes" xml:space="preserve">
          <source>The regular expressions we want to match against str. See &quot;Notes&quot; above for detailed notes on how this is interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626421317b8daa7c4481578d7b1400cbc817027c" translate="yes" xml:space="preserve">
          <source>The regularized incomplete beta integral is defined as:</source>
          <target state="translated">Регуляризованный неполный бета-интеграл определяется как:</target>
        </trans-unit>
        <trans-unit id="6b4ae5690943cd94c52d8b3b53e424b70c0a6f84" translate="yes" xml:space="preserve">
          <source>The remapping tensors can be generated using the GenerateVocabRemapping op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f76fd4e0a09c22f0b1432236fcf10360b759293" translate="yes" xml:space="preserve">
          <source>The remappings are 1-D tensors with the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb549ec0edb51386556b04bcb293e63f29c79c8" translate="yes" xml:space="preserve">
          <source>The replacement character codepoint to be used in place of any invalid input when &lt;code&gt;errors='replace'&lt;/code&gt;. Any valid unicode codepoint may be used. The default value is the default unicode replacement character which is 0xFFFD (U+65533).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc58567cf18ed1da38d660adbff7112eaf4a0c43" translate="yes" xml:space="preserve">
          <source>The replacement codepoint to be used in place of invalid substrings in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;errors='replace'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5861bd77b8284cbd383ce9fa80004e5915d9c8c5" translate="yes" xml:space="preserve">
          <source>The replacement codepoint to be used in place of invalid substrings in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;errors='replace'&lt;/code&gt;; and in place of C0 control characters in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;replace_control_characters=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f7982eae76c3d1b8d5c546c5c6087586c14c26" translate="yes" xml:space="preserve">
          <source>The request does not have valid authentication credentials.</source>
          <target state="translated">Запрос не имеет действительных учетных данных для аутентификации.</target>
        </trans-unit>
        <trans-unit id="11fac311a887cb1b94b956ea27985cb8f91c9eab" translate="yes" xml:space="preserve">
          <source>The requirements to use the cuDNN implementation are:</source>
          <target state="translated">Требования,предъявляемые к применению кюДНН,являются следующими:</target>
        </trans-unit>
        <trans-unit id="b7f944aa478f301b9d7d37d3ac6e02aa0ab614e1" translate="yes" xml:space="preserve">
          <source>The rescaling is applied both during training and inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10dd1c4bdea08780ec12768ba2f0c0cc6e6418e" translate="yes" xml:space="preserve">
          <source>The resizing Ops accept input images as tensors of several types. They always output resized images as float32 tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f32138dd7f669a33bea7319cf66264923452d20" translate="yes" xml:space="preserve">
          <source>The restored checkpoint path if the lastest checkpoint is found and restored. Otherwise None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06ff612c69fb3df1f3d794bb785e13f8da40620" translate="yes" xml:space="preserve">
          <source>The result is a 4-D tensor of shape &lt;code&gt;[batch_size, glimpse_height, glimpse_width, channels]&lt;/code&gt;. The channels and batch dimensions are the same as that of the input tensor. The height and width of the output windows are specified in the &lt;code&gt;size&lt;/code&gt; parameter.</source>
          <target state="translated">Результатом является &lt;code&gt;[batch_size, glimpse_height, glimpse_width, channels]&lt;/code&gt; тензор формы [batch_size, glimpse_height, glimpse_width, channels] . Каналы и размеры пакета такие же, как у входного тензора. Высота и ширина окон вывода указываются в параметре &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af8e15d374bd08a8ea2bebed96d25f27af99cc58" translate="yes" xml:space="preserve">
          <source>The result is a 4D tensor which is indexed by batch, row, and column. &lt;code&gt;output[i, x, y]&lt;/code&gt; contains a flattened patch of size &lt;code&gt;sizes[1], sizes[2]&lt;/code&gt; which is taken from the input starting at &lt;code&gt;images[i, x*strides[1], y*strides[2]]&lt;/code&gt;.</source>
          <target state="translated">В результате получается четырехмерный тензор, индексируемый по пакетам, строкам и столбцам. &lt;code&gt;output[i, x, y]&lt;/code&gt; содержит сплющенный фрагмент size &lt;code&gt;sizes[1], sizes[2]&lt;/code&gt; который берется из входа, начиная с &lt;code&gt;images[i, x*strides[1], y*strides[2]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3408db8eec06fef64e88ca8c2438893f2827e593" translate="yes" xml:space="preserve">
          <source>The result is a [..., M+1, M] matrix with [..., 0,:] containing the eigenvalues, and subsequent [...,1:, :] containing the eigenvectors. The eigenvalues are sorted in non-decreasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e981525729cfb7323f601fab3d959548453e14" translate="yes" xml:space="preserve">
          <source>The result is not a global index to the entire &lt;code&gt;Tensor&lt;/code&gt;, but rather just the index in the last dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0fc847805d05865dd1fc80479599ef10e030da" translate="yes" xml:space="preserve">
          <source>The result of calling parse_example on these examples will produce a dictionary with entries for &quot;ids&quot; and &quot;values&quot;. Passing those two objects to this function along with vocab_size=6, will produce a &lt;code&gt;SparseTensor&lt;/code&gt; that sparsely represents all three instances. Namely, the &lt;code&gt;indices&lt;/code&gt; property will contain the coordinates of the non-zero entries in the feature matrix (the first dimension is the row number in the matrix, i.e., the index within the batch, and the second dimension is the column number, i.e., the feature id); &lt;code&gt;values&lt;/code&gt; will contain the actual values. &lt;code&gt;shape&lt;/code&gt; will be the shape of the original matrix, i.e., (3, 6). For our example above, the output will be equal to:</source>
          <target state="translated">В результате вызова parse_example в этих примерах будет создан словарь с записями для &amp;laquo;идентификаторов&amp;raquo; и &amp;laquo;значений&amp;raquo;. Передача этих двух объектов в эту функцию вместе с vocab_size = 6 приведет к созданию &lt;code&gt;SparseTensor&lt;/code&gt; , который редко представляет все три экземпляра. А именно, свойство &lt;code&gt;indices&lt;/code&gt; будет содержать координаты ненулевых элементов в матрице признаков (первое измерение - это номер строки в матрице, т. Е. Индекс в пакете, а второе измерение - это номер столбца, т. Е. идентификатор функции); &lt;code&gt;values&lt;/code&gt; будут содержать фактические значения. &lt;code&gt;shape&lt;/code&gt; будет формой исходной матрицы, т.е. (3, 6). В нашем примере выше результат будет равен:</target>
        </trans-unit>
        <trans-unit id="c532f85716ab7d9d5ac1221540a16a00cf14d0f8" translate="yes" xml:space="preserve">
          <source>The result of one inference step, typically the output of calling the &lt;code&gt;Model&lt;/code&gt; on data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b712de5339fc3e663594598e87ccb0f331d98d0d" translate="yes" xml:space="preserve">
          <source>The result of the elementwise &lt;code&gt;!=&lt;/code&gt; operation, or &lt;code&gt;True&lt;/code&gt; if the arguments are not broadcast-compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bf62ac9a12a3ed583f3696b9ec4dfdd36908c0" translate="yes" xml:space="preserve">
          <source>The result of the elementwise &lt;code&gt;+&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0379f511e04f35dbfdf4e95a15f796515177e5" translate="yes" xml:space="preserve">
          <source>The result of the elementwise &lt;code&gt;==&lt;/code&gt; operation, or &lt;code&gt;False&lt;/code&gt; if the arguments are not broadcast-compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7181bf7e73106c9b2b97d9fffba14ef65fbf1f8" translate="yes" xml:space="preserve">
          <source>The result of this op should be passed through a &lt;code&gt;sparse_to_dense&lt;/code&gt; operation, then added to the logits of the sampled classes. This removes the contradictory effect of accidentally sampling the true target classes as noise classes for the same example.</source>
          <target state="translated">Результат этой операции должен быть передан через операцию &lt;code&gt;sparse_to_dense&lt;/code&gt; , а затем добавлен в логиты выбранных классов. Это устраняет противоречивый эффект случайной выборки истинных целевых классов в качестве классов шума для того же примера.</target>
        </trans-unit>
        <trans-unit id="95bce95270c24fcef8ff10f45294119d2cbaf8aa" translate="yes" xml:space="preserve">
          <source>The result will be biased towards the initial value of the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01298564c21aafdba5ad8531a719b0b62528e9fe" translate="yes" xml:space="preserve">
          <source>The result will have those bits set, that are different in &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The computation is performed on the underlying representations of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">В результате будут установлены те биты, которые различаются по &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Вычисления выполняются на базовых представлениях &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="685b62e5962fffb0313c314fe8766a83e91dc7ce" translate="yes" xml:space="preserve">
          <source>The result will have those bits set, that are set in &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; or both. The computation is performed on the underlying representations of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">В результате будут установлены те биты, которые установлены в &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; или в обоих. Вычисления выполняются на базовых представлениях &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b74f37adc87a210e3154c60f498551da0c0a3084" translate="yes" xml:space="preserve">
          <source>The result will have those bits set, that are set in both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The computation is performed on the underlying representations of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">В результате будут установлены те биты, которые установлены как в &lt;code&gt;x&lt;/code&gt; ,так и в &lt;code&gt;y&lt;/code&gt; . Вычисления выполняются на базовых представлениях &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a454b218545175a81109283a1b62827f2751cc1d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Tensor&lt;/code&gt; of parsing a single &lt;code&gt;SequenceExample&lt;/code&gt; or &lt;code&gt;Example&lt;/code&gt; has a static &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[None] + shape&lt;/code&gt; and the specified &lt;code&gt;dtype&lt;/code&gt;. The resulting &lt;code&gt;Tensor&lt;/code&gt; of parsing a &lt;code&gt;batch_size&lt;/code&gt; many &lt;code&gt;Example&lt;/code&gt;s has a static &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[batch_size, None] + shape&lt;/code&gt; and the specified &lt;code&gt;dtype&lt;/code&gt;. The entries in the &lt;code&gt;batch&lt;/code&gt; from different &lt;code&gt;Examples&lt;/code&gt; will be padded with &lt;code&gt;default_value&lt;/code&gt; to the maximum length present in the &lt;code&gt;batch&lt;/code&gt;.</source>
          <target state="translated">В результате &lt;code&gt;Tensor&lt;/code&gt; разбора одну &lt;code&gt;SequenceExample&lt;/code&gt; или &lt;code&gt;Example&lt;/code&gt; имеет статическую &lt;code&gt;shape&lt;/code&gt; из &lt;code&gt;[None] + shape&lt;/code&gt; и указанный &lt;code&gt;dtype&lt;/code&gt; . Результате &lt;code&gt;Tensor&lt;/code&gt; из разбора &lt;code&gt;batch_size&lt;/code&gt; многого &lt;code&gt;Example&lt;/code&gt; ы имеет статическую &lt;code&gt;shape&lt;/code&gt; из &lt;code&gt;[batch_size, None] + shape&lt;/code&gt; и указанный &lt;code&gt;dtype&lt;/code&gt; . Записи в &lt;code&gt;batch&lt;/code&gt; из разных &lt;code&gt;Examples&lt;/code&gt; будут дополнены значением &lt;code&gt;default_value&lt;/code&gt; до максимальной длины, присутствующей в &lt;code&gt;batch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a538e992c4e715c1f91b7c40110e2510e29c989" translate="yes" xml:space="preserve">
          <source>The resulting SavedModel is then servable with an input named &quot;x&quot;, its value having any shape and dtype float32.</source>
          <target state="translated">Результирующая SavedModel затем обслуживается входом с именем &quot;x&quot;,его значение имеет любую форму и тип float32.</target>
        </trans-unit>
        <trans-unit id="b71ce2b54de94b7e8ecf2e651366ba952c5ce3a3" translate="yes" xml:space="preserve">
          <source>The resulting dataset is similar to the &lt;code&gt;InterleaveDataset&lt;/code&gt;, except that the dataset will fetch records from the interleaved datasets in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8659c50ab2dced91f800b38d49965e49b25d1c" translate="yes" xml:space="preserve">
          <source>The resulting dataset is similar to the &lt;code&gt;InterleaveDataset&lt;/code&gt;, with the exception that if retrieving the next value from a dataset would cause the requester to block, it will skip that input dataset. This dataset is especially useful when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it allows the training step to proceed so long as some data is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd835a476d97294a9a531a06c729ae1427276dc8" translate="yes" xml:space="preserve">
          <source>The resulting function is assumed stateful and will never be optimized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f53b61193a80c029c5a448efed06c1a8f6588c5" translate="yes" xml:space="preserve">
          <source>The resulting output shape when using the &quot;same&quot; padding option is: &lt;code&gt;output_shape = input_shape / strides&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef25e64d2e423f7de1f3a02ba7a25085c38c8a1" translate="yes" xml:space="preserve">
          <source>The resulting tensor is populated with values of type &lt;code&gt;dtype&lt;/code&gt;, as specified by arguments &lt;code&gt;value&lt;/code&gt; and (optionally) &lt;code&gt;shape&lt;/code&gt; (see examples below).</source>
          <target state="translated">Результирующий тензор заполняется значениями типа &lt;code&gt;dtype&lt;/code&gt; , как указано аргументами &lt;code&gt;value&lt;/code&gt; и (необязательно) &lt;code&gt;shape&lt;/code&gt; (см. Примеры ниже).</target>
        </trans-unit>
        <trans-unit id="0b674f3072695f2111704701dbc3947bfb383f3f" translate="yes" xml:space="preserve">
          <source>The resulting tensor is populated with values of type &lt;code&gt;dtype&lt;/code&gt;, as specified by arguments &lt;code&gt;value&lt;/code&gt; following the desired &lt;code&gt;shape&lt;/code&gt; of the new tensor (see examples below).</source>
          <target state="translated">Результирующий тензор заполняется значениями типа &lt;code&gt;dtype&lt;/code&gt; , как указано в аргументах &lt;code&gt;value&lt;/code&gt; , следующих за желаемой &lt;code&gt;shape&lt;/code&gt; нового тензора (см. Примеры ниже).</target>
        </trans-unit>
        <trans-unit id="ef74e8f16df07a307babda0cfa120db0e980020d" translate="yes" xml:space="preserve">
          <source>The resulting tensor would look like this:</source>
          <target state="translated">Получившийся тензор будет выглядеть вот так:</target>
        </trans-unit>
        <trans-unit id="381b1e6543678db4ed459c1cba156ecc8ca01172" translate="yes" xml:space="preserve">
          <source>The resulting update to ref would look like this:</source>
          <target state="translated">Результирующее обновление для ссылки будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="cbbd169c06c5469910e771887e06b5ed0c01b738" translate="yes" xml:space="preserve">
          <source>The resulting update to v would look like this:</source>
          <target state="translated">Результирующее обновление до v будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="993bb51caef566927c6f2034eead7ae47fdb56d0" translate="yes" xml:space="preserve">
          <source>The resulting value &lt;code&gt;output&lt;/code&gt; would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc6293ac412a772df6f0e78ca55482c98eb64a2" translate="yes" xml:space="preserve">
          <source>The results of the lookup are concatenated into a dense tensor. The returned tensor has shape &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt;.</source>
          <target state="translated">Результаты поиска объединяются в плотный тензор. Возвращенный тензор имеет форму &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1f40e1bca978cc7aa38e548317ee19cb7dfd8c" translate="yes" xml:space="preserve">
          <source>The return value has the same type as &lt;code&gt;images&lt;/code&gt; if &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;. It will also have the same type as &lt;code&gt;images&lt;/code&gt; if the size of &lt;code&gt;images&lt;/code&gt; can be statically determined to be the same as &lt;code&gt;size&lt;/code&gt;, because &lt;code&gt;images&lt;/code&gt; is returned in this case. Otherwise, the return value has type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение имеет тот же тип, что и &lt;code&gt;images&lt;/code&gt; если &lt;code&gt;method&lt;/code&gt; - &lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt; &lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt; &lt;/a&gt; . Он также будет иметь тот же тип, что и &lt;code&gt;images&lt;/code&gt; если размер &lt;code&gt;images&lt;/code&gt; может быть статически определен как такой же, как &lt;code&gt;size&lt;/code&gt; , потому что в этом случае возвращаются &lt;code&gt;images&lt;/code&gt; . В противном случае возвращаемое значение имеет тип &lt;code&gt;float32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d56a51802c9fd20b938ff0224e17cc92fbe0a0fd" translate="yes" xml:space="preserve">
          <source>The return value has the same type as &lt;code&gt;images&lt;/code&gt; if &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;tf.image.ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;. It will also have the same type as &lt;code&gt;images&lt;/code&gt; if the size of &lt;code&gt;images&lt;/code&gt; can be statically determined to be the same as &lt;code&gt;size&lt;/code&gt;, because &lt;code&gt;images&lt;/code&gt; is returned in this case. Otherwise, the return value has type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90335752084dfbdd6479bc3425e07c2c184fac03" translate="yes" xml:space="preserve">
          <source>The return value has the same type as &lt;code&gt;images&lt;/code&gt; if &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;. Otherwise, the return value has type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение имеет тот же тип, что и &lt;code&gt;images&lt;/code&gt; если &lt;code&gt;method&lt;/code&gt; - &lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt; &lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt; &lt;/a&gt; . В противном случае возвращаемое значение имеет тип &lt;code&gt;float32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d380f2c5d4525994512f90f349c7eb51132c6e2" translate="yes" xml:space="preserve">
          <source>The return value has type &lt;code&gt;float32&lt;/code&gt;, unless the &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;, then the return dtype is the dtype of &lt;code&gt;images&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6bf11d3c25e837bbcedc93fcb0930b2a99ab3" translate="yes" xml:space="preserve">
          <source>The return value is not the same Tensor as the original, but contains the same values. This operation is fast when used on the same device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3b67eed807726677126c856d0a6214fa8f8e4a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;merge_fn&lt;/code&gt;, except for &lt;code&gt;PerReplica&lt;/code&gt; values which are unpacked.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;merge_fn&lt;/code&gt; , за исключением значений &lt;code&gt;PerReplica&lt;/code&gt; , которые распакованы.</target>
        </trans-unit>
        <trans-unit id="b729f575891182a1cf2b646557e584015983e0cf" translate="yes" xml:space="preserve">
          <source>The return values from &lt;code&gt;Session.run()&lt;/code&gt; corresponding to the fetches attribute returned in the RunArgs. Note that this has the same shape as the RunArgs fetches. For example: fetches = global_step_tensor =&amp;gt; results = nparray(int) fetches = [train_op, summary_op, global_step_tensor] =&amp;gt; results = [None, nparray(string), nparray(int)] fetches = {'step': global_step_tensor, 'summ': summary_op} =&amp;gt; results = {'step': nparray(int), 'summ': nparray(string)}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e968254f01cab6234b67bba030e47e2fb4dbf82" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54bb88894be8aec22542ba047bf035708660a8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc73b952597eebba1bc9614e25b86603811dd74" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;../distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77573df9f9325728fade9f377ed047dae4204229" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dea02fa1b7f8947a51fb716ddcefda916820715" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; is determined at &lt;em&gt;build&lt;/em&gt; time, without executing the underlying kernel. It is not a &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;. If you need a shape &lt;em&gt;tensor&lt;/em&gt;, either convert the &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; to a &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt;, or use the &lt;a href=&quot;shape&quot;&gt;&lt;code&gt;tf.shape(tensor)&lt;/code&gt;&lt;/a&gt; function, which returns the tensor's shape at &lt;em&gt;execution&lt;/em&gt; time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111bba19cc7fb0062ed6fe66a53428292ab2ad62" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;RaggedTensor&lt;/code&gt; corresponds with the python list defined by:</source>
          <target state="translated">Возвращенное &lt;code&gt;RaggedTensor&lt;/code&gt; соответствует списку питона определяется по формуле:</target>
        </trans-unit>
        <trans-unit id="ecbcae5eb984661e7de2445f57c60c5e40e3d894" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Session&lt;/code&gt; will be the innermost session on which a &lt;code&gt;Session&lt;/code&gt; or &lt;code&gt;Session.as_default()&lt;/code&gt; context has been entered.</source>
          <target state="translated">Возвращенный &lt;code&gt;Session&lt;/code&gt; будет самым внутренним сеансом, в который был введен контекст &lt;code&gt;Session&lt;/code&gt; или &lt;code&gt;Session.as_default()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95a65357f0f57659490bed4f233c4a4d8fc08588" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Tensor&lt;/code&gt; will be close to an exact solution if &lt;code&gt;A&lt;/code&gt; is well conditioned. Otherwise closeness will vary. See class docstring for details.</source>
          <target state="translated">Возвращенный &lt;code&gt;Tensor&lt;/code&gt; будет близок к точному решению , если хорошо кондиционеру. В противном случае близость будет отличаться. Подробнее см. В строке документации класса. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="210a2253a38d62adf49c231834e4374a228751a1" translate="yes" xml:space="preserve">
          <source>The returned callable will have the same return type as &lt;code&gt;tf.Session.run(fetches, ...)&lt;/code&gt;. For example, if &lt;code&gt;fetches&lt;/code&gt; is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, the callable will return a numpy ndarray; if &lt;code&gt;fetches&lt;/code&gt; is a &lt;a href=&quot;../../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt;, it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый вызываемый объект будет иметь тот же тип возвращаемого значения, что и &lt;code&gt;tf.Session.run(fetches, ...)&lt;/code&gt; . Например, если &lt;code&gt;fetches&lt;/code&gt; является &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; , то вызываемая возвратит Numpy ndarray; если &lt;code&gt;fetches&lt;/code&gt; является &lt;a href=&quot;../../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt; , он будет возвращать &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdda7d94aac832546a913098111bedb3a5af104" translate="yes" xml:space="preserve">
          <source>The returned callable will take &lt;code&gt;len(feed_list)&lt;/code&gt; arguments whose types must be compatible feed values for the respective elements of &lt;code&gt;feed_list&lt;/code&gt;. For example, if element &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;feed_list&lt;/code&gt; is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;i&lt;/code&gt;th argument to the returned callable must be a numpy ndarray (or something convertible to an ndarray) with matching element type and shape. See &lt;code&gt;tf.Session.run&lt;/code&gt; for details of the allowable feed key and value types.</source>
          <target state="translated">Возвращаемый вызываемый &lt;code&gt;len(feed_list)&lt;/code&gt; будет принимать len (feed_list) аргументов, типы которых должны быть совместимыми значениями каналов для соответствующих элементов &lt;code&gt;feed_list&lt;/code&gt; . Например, если элемент &lt;code&gt;i&lt;/code&gt; из &lt;code&gt;feed_list&lt;/code&gt; является &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;i&lt;/code&gt; - й аргумент возвращаемого вызываемого объекта должен быть numpy ndarray (или чем-то, что можно преобразовать в ndarray) с соответствующим типом элемента и формой. См. &lt;code&gt;tf.Session.run&lt;/code&gt; для получения подробной информации о допустимых типах ключей и значений фида.</target>
        </trans-unit>
        <trans-unit id="5ae9baaba07ae2a863bb456cb56b210b15bfeca4" translate="yes" xml:space="preserve">
          <source>The returned dataset is a wrapped strategy dataset which creates a multidevice iterator under the hood. It prefetches the input data to the specified devices on the worker. The returned distributed dataset can be iterated over similar to how regular datasets can.</source>
          <target state="translated">Возвращаемый набор данных является обернутым набором стратегических данных,который создает много-устройственный итератор под капотом.Он предварительно устанавливает входные данные на указанные устройства на рабочем.Возвращаемый распределенный набор данных может быть подвергнут итерации аналогично тому,как это делают обычные наборы данных.</target>
        </trans-unit>
        <trans-unit id="b16f128652226cd5df44d3210c5abe8996d2a7b8" translate="yes" xml:space="preserve">
          <source>The returned dict may have the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7e2363fe125c1a5cdb798835abe8de5ac8aef0" translate="yes" xml:space="preserve">
          <source>The returned dictionary can be used as arg 'features' in &lt;a href=&quot;../../../io/parse_example&quot;&gt;&lt;code&gt;tf.io.parse_example&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../io/parse_example&quot;&gt; &lt;code&gt;tf.io.parse_example&lt;/code&gt; &lt;/a&gt; словарь можно использовать как arg 'features' в tf.io.parse_example .</target>
        </trans-unit>
        <trans-unit id="27148d9610fe5857a584045bc355cd08d4ce68b2" translate="yes" xml:space="preserve">
          <source>The returned dictionary can be used as arg 'features' in &lt;a href=&quot;../io/parse_example&quot;&gt;&lt;code&gt;tf.io.parse_example&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../io/parse_example&quot;&gt; &lt;code&gt;tf.io.parse_example&lt;/code&gt; &lt;/a&gt; словарь можно использовать как arg 'features' в tf.io.parse_example .</target>
        </trans-unit>
        <trans-unit id="e41cdf1dd9ec5b48c6c1a627e04bc9cd0f5646ec" translate="yes" xml:space="preserve">
          <source>The returned distributed dataset can be iterated over similar to how regular datasets can. NOTE: Currently, the user cannot add any more transformations to a distributed dataset.</source>
          <target state="translated">Возвращаемый распределенный набор данных может быть итерациирован по аналогии с обычными наборами данных.ПРИМЕЧАНИЕ:В настоящее время пользователь больше не может добавлять трансформации в распределенный набор данных.</target>
        </trans-unit>
        <trans-unit id="8e5c9b1714c669dc39fd802e652891ab6982a58a" translate="yes" xml:space="preserve">
          <source>The returned graph will be the innermost graph on which a &lt;a href=&quot;../../graph#as_default&quot;&gt;&lt;code&gt;Graph.as_default()&lt;/code&gt;&lt;/a&gt; context has been entered, or a global default graph if none has been explicitly created.</source>
          <target state="translated">&lt;a href=&quot;../../graph#as_default&quot;&gt; &lt;code&gt;Graph.as_default()&lt;/code&gt; &lt;/a&gt; граф будет самым внутренним графом, для которого был введен контекст Graph.as_default () , или глобальным графом по умолчанию, если ни один не был явно создан.</target>
        </trans-unit>
        <trans-unit id="a3ca6a76bf18bc7eb9e290fd0f8d92384b3fc63a" translate="yes" xml:space="preserve">
          <source>The returned graph will be the innermost graph on which a &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Graph#as_default&quot;&gt;&lt;code&gt;Graph.as_default()&lt;/code&gt;&lt;/a&gt; context has been entered, or a global default graph if none has been explicitly created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4983b6188d9b3a5503f72bc1978affb47cac7b6d" translate="yes" xml:space="preserve">
          <source>The returned iterator implements the Python Iterator protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b38dad137146b9ef38ba7c509e2c0442b75c1f0" translate="yes" xml:space="preserve">
          <source>The returned iterator implements the Python iterator protocol and therefore can only be used in eager mode.</source>
          <target state="translated">Возвращаемый итератор реализует протокол итератора Python и поэтому может быть использован только в режиме eager.</target>
        </trans-unit>
        <trans-unit id="7e0593141fa29e4d333dddf121d2181c125317c5" translate="yes" xml:space="preserve">
          <source>The returned iterator is not bound to a particular dataset, and it has no &lt;code&gt;initializer&lt;/code&gt;. To initialize the iterator, run the operation returned by &lt;code&gt;Iterator.make_initializer(dataset)&lt;/code&gt;.</source>
          <target state="translated">Возвращенный итератор не привязан к определенному набору данных и не имеет &lt;code&gt;initializer&lt;/code&gt; . Чтобы инициализировать итератор, запустите операцию, возвращенную &lt;code&gt;Iterator.make_initializer(dataset)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35c004b6fa1c65f47bcd7047f0f10a1978a605f3" translate="yes" xml:space="preserve">
          <source>The returned operation is a dequeue operation and will throw &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; if the input queue is exhausted. If this operation is feeding another input queue, its queue runner will catch this exception, however, if this operation is used in your main thread you are responsible for catching this yourself.</source>
          <target state="translated">Возвращенная операция является операцией &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt; из очереди и вызовет ошибку tf.errors.OutOfRangeError, если входная очередь исчерпана. Если эта операция загружает другую очередь ввода, ее обработчик очереди перехватит это исключение, однако, если эта операция используется в вашем основном потоке, вы несете ответственность за перехват этого исключения.</target>
        </trans-unit>
        <trans-unit id="388161f4aeaed3801662f433bd19fe4a8d446b0a" translate="yes" xml:space="preserve">
          <source>The returned permutation may be used to permute the rows and columns of the given sparse matrix. This typically results in permuted sparse matrix's sparse Cholesky (or other decompositions) in having fewer zero fill-in compared to decomposition of the original matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34611a4904c47d805a50142b42fe43a0ecae787f" translate="yes" xml:space="preserve">
          <source>The returned sparse matrix has the same dense shape as the input sparse matrix. For each component &lt;code&gt;A&lt;/code&gt; of the input sparse matrix, the corresponding output sparse matrix represents &lt;code&gt;L&lt;/code&gt;, the lower triangular Cholesky factor satisfying the following identity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283d98979ab1e70cde916469a5e89b9e786cbb6c" translate="yes" xml:space="preserve">
          <source>The returned status object has the following methods:</source>
          <target state="translated">Возвращаемый объект статуса имеет следующие методы:</target>
        </trans-unit>
        <trans-unit id="b692f2b05a18e92aff1d5bc6f670c1b3f429e602" translate="yes" xml:space="preserve">
          <source>The returned string will be in the form protocol://address, e.g. &quot;grpc://localhost:5050&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c118b1fddbb7639875cad9b7ab197644effe14a5" translate="yes" xml:space="preserve">
          <source>The returned tensor uses the memory shared by dlpack capsules from other framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a9be24217f14af8b4e90ac374a00f3e69a4114" translate="yes" xml:space="preserve">
          <source>The returned tensor will contain a serialized &lt;a href=&quot;../../summary&quot;&gt;&lt;code&gt;tf.compat.v1.summary.Summary&lt;/code&gt;&lt;/a&gt; protocol buffer, which can be used with the standard TensorBoard logging facilities.</source>
          <target state="translated">&lt;a href=&quot;../../summary&quot;&gt; &lt;code&gt;tf.compat.v1.summary.Summary&lt;/code&gt; &lt;/a&gt; тензор будет содержать сериализованный буфер протокола tf.compat.v1.summary.Summary , который можно использовать со стандартными средствами ведения журнала TensorBoard.</target>
        </trans-unit>
        <trans-unit id="c2eac31d16e8529bfab56c61e3821bc8b01c5d91" translate="yes" xml:space="preserve">
          <source>The returned tensor's dimension &lt;code&gt;i&lt;/code&gt; will correspond to the input dimension &lt;code&gt;perm[i]&lt;/code&gt;. If &lt;code&gt;perm&lt;/code&gt; is not given, it is set to (n-1...0), where n is the rank of the input tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input Tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d1c361e6f8f0d84bf0a1bcea9214b49e8cf3d3" translate="yes" xml:space="preserve">
          <source>The returned tensor's dimension i will correspond to the input dimension &lt;code&gt;perm[i]&lt;/code&gt;. If &lt;code&gt;perm&lt;/code&gt; is not given, it is set to (n-1...0), where n is the rank of the input tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input Tensors.</source>
          <target state="translated">Возвращенная размерность тензора i будет соответствовать входной размерности &lt;code&gt;perm[i]&lt;/code&gt; . Если &lt;code&gt;perm&lt;/code&gt; не задан, он устанавливается в (n-1 ... 0), где n - ранг входного тензора. Следовательно, по умолчанию эта операция выполняет обычное транспонирование матрицы на входных двумерных тензорах.</target>
        </trans-unit>
        <trans-unit id="d9c115cc2d00147127224aefb2bd6a8e1bbe0c5c" translate="yes" xml:space="preserve">
          <source>The returned tensor's dimension i will correspond to the input dimension &lt;code&gt;perm[i]&lt;/code&gt;. If &lt;code&gt;perm&lt;/code&gt; is not given, it is set to (n-1...0), where n is the rank of the input tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input Tensors. If conjugate is True and &lt;code&gt;a.dtype&lt;/code&gt; is either &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt; then the values of &lt;code&gt;a&lt;/code&gt; are conjugated and transposed.</source>
          <target state="translated">Возвращенная размерность тензора i будет соответствовать входной размерности &lt;code&gt;perm[i]&lt;/code&gt; . Если &lt;code&gt;perm&lt;/code&gt; не задан, он устанавливается в (n-1 ... 0), где n - ранг входного тензора. Следовательно, по умолчанию эта операция выполняет обычное транспонирование матрицы на входных двумерных тензорах. Если конъюгат Истинный и &lt;code&gt;a.dtype&lt;/code&gt; либо &lt;code&gt;complex64&lt;/code&gt; или &lt;code&gt;complex128&lt;/code&gt; то значения сопряжены и перенесенный. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="838e6e70eeb12ce61fde540b38b4044a46a8f134" translate="yes" xml:space="preserve">
          <source>The returned tensors are &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s if &lt;code&gt;input&lt;/code&gt; is a scalar, or &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s otherwise.</source>
          <target state="translated">&lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; тензоры - это tf.Tensor, если &lt;code&gt;input&lt;/code&gt; является скаляром, или &lt;a href=&quot;../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; в&lt;/a&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="710644f5cd50999519cd748e88ddf36f02a2b455" translate="yes" xml:space="preserve">
          <source>The right-hand side of the &lt;code&gt;!=&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e668edbb07540997101fa0f49a39faa5f38caec8" translate="yes" xml:space="preserve">
          <source>The right-hand side of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff72258325f43cdf735f357c785333acbdbfc89a" translate="yes" xml:space="preserve">
          <source>The right-hand side of the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca75c2c84ca7c94aaa9f8f708d895cba56b5cf74" translate="yes" xml:space="preserve">
          <source>The row partition tensors are in the order of the dimensions. At present, the types can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85216d0bd898c6d1680f5aac974d5348d1d96c2f" translate="yes" xml:space="preserve">
          <source>The row-split indices for this ragged tensor's &lt;code&gt;values&lt;/code&gt;.</source>
          <target state="translated">Индексы разделения строк для &lt;code&gt;values&lt;/code&gt; этого рваного тензора .</target>
        </trans-unit>
        <trans-unit id="5854e78835764512ec754b4ac011bb9b48f7d380" translate="yes" xml:space="preserve">
          <source>The row_splits for all ragged dimensions in this ragged tensor value.</source>
          <target state="translated">Строка_сплиты для всех неровных размеров в этом неровном значении тензора.</target>
        </trans-unit>
        <trans-unit id="5158c81c5ea5bb74de68daed2eacbf5dc32d4ad8" translate="yes" xml:space="preserve">
          <source>The runtime is then free to make optimizations based on this.</source>
          <target state="translated">В этом случае время выполнения может быть свободно оптимизировано на основе этого.</target>
        </trans-unit>
        <trans-unit id="ca5cdf682a9605ca998129dd4a854da399041aba" translate="yes" xml:space="preserve">
          <source>The same array (Numpy array if &lt;code&gt;x&lt;/code&gt; was a Numpy array, or TensorFlow tensor if &lt;code&gt;x&lt;/code&gt; was a tensor), cast to its new type.</source>
          <target state="translated">Тот же массив (массив Numpy, если &lt;code&gt;x&lt;/code&gt; был массивом Numpy, или тензор TensorFlow, если &lt;code&gt;x&lt;/code&gt; был тензором), приведенный к его новому типу.</target>
        </trans-unit>
        <trans-unit id="e4b3e7c37b806fc9d4b600343aa28d9179c53706" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../raggedtensor#__div__&quot;&gt;&lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt;&lt;/a&gt; for integers, but uses &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by &lt;code&gt;x // y&lt;/code&gt; floor division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;.</source>
          <target state="translated">То же, что &lt;a href=&quot;../../raggedtensor#__div__&quot;&gt; &lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt; &lt;/a&gt; для целых чисел, но использует &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; для аргументов с плавающей запятой, поэтому результат всегда является целым числом ( хотя возможно целое число, представленное как плавающая точка). Эта операция генерируется делением этажа &lt;code&gt;x // y&lt;/code&gt; в Python 3 и в Python 2.7 с &lt;code&gt;from __future__ import division&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07525f9495ce7a62b86179e9f6083e34f20d8d8b" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../raggedtensor#__div__&quot;&gt;&lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt;&lt;/a&gt; for integers, but uses &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by &lt;code&gt;x // y&lt;/code&gt; floor division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;.</source>
          <target state="translated">То же, что &lt;a href=&quot;../raggedtensor#__div__&quot;&gt; &lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt; &lt;/a&gt; для целых чисел, но использует &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; для аргументов с плавающей запятой, поэтому результат всегда является целым числом ( хотя возможно целое число, представленное как плавающая точка). Эта операция генерируется делением этажа &lt;code&gt;x // y&lt;/code&gt; в Python 3 и в Python 2.7 с &lt;code&gt;from __future__ import division&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3240798db52d492b4a5e0a4f1101b0ce22e5dea6" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;raggedtensor#__div__&quot;&gt;&lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt;&lt;/a&gt; for integers, but uses &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by &lt;code&gt;x // y&lt;/code&gt; floor division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;.</source>
          <target state="translated">То же, что &lt;a href=&quot;raggedtensor#__div__&quot;&gt; &lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt; &lt;/a&gt; для целых чисел, но использует &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; для аргументов с плавающей запятой, поэтому результат всегда является целым числом ( хотя возможно целое число, представленное как плавающая точка). Эта операция генерируется делением этажа &lt;code&gt;x // y&lt;/code&gt; в Python 3 и в Python 2.7 с &lt;code&gt;from __future__ import division&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6016fab50d93b1e77917677d258e0e003f237e6" translate="yes" xml:space="preserve">
          <source>The same tensor &lt;code&gt;x&lt;/code&gt;, unchanged.</source>
          <target state="translated">Тот же тензор &lt;code&gt;x&lt;/code&gt; без изменений.</target>
        </trans-unit>
        <trans-unit id="e28b3d74027804ad355c817f8c256af8b2d25a2a" translate="yes" xml:space="preserve">
          <source>The samples are differentiable w.r.t. alpha and beta. The derivatives are computed using the approach described in (Figurnov et al., 2018).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3935638fc889928b31f22a28b40af71a593afd" translate="yes" xml:space="preserve">
          <source>The samples are differentiable w.r.t. alpha and beta. The derivatives are computed using the approach described in the paper</source>
          <target state="translated">Образцы дифференцированы по альфа и бета.Деривативы вычисляются с использованием подхода,описанного в работе</target>
        </trans-unit>
        <trans-unit id="92952659dac1bf101ab8c26a5fd0e7570c899948" translate="yes" xml:space="preserve">
          <source>The sampling probabilities are generated according to the sampling distribution used in word2vec:</source>
          <target state="translated">Вероятности выборки генерируются в соответствии с распределением выборки,используемым в слове2vec:</target>
        </trans-unit>
        <trans-unit id="7e70c09e21b733e9d2a808af0f600268962663fb" translate="yes" xml:space="preserve">
          <source>The save counter variable.</source>
          <target state="translated">Переменная счетчика сохранения.</target>
        </trans-unit>
        <trans-unit id="ab43a8a642f72175fe828def8c8d03e9a692fe7b" translate="yes" xml:space="preserve">
          <source>The saved checkpoint includes variables created by this object and any trackable objects it depends on at the time &lt;a href=&quot;../../../train/checkpoint#save&quot;&gt;&lt;code&gt;Checkpoint.save()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">Сохраненная контрольная точка включает в себя переменные, созданные этим объектом, и любые отслеживаемые объекты, от которых он зависит во время &lt;a href=&quot;../../../train/checkpoint#save&quot;&gt; &lt;code&gt;Checkpoint.save()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21ba0881308b74c027819f31603cfc6647b52c80" translate="yes" xml:space="preserve">
          <source>The saved checkpoint includes variables created by this object and any trackable objects it depends on at the time &lt;a href=&quot;checkpoint#save&quot;&gt;&lt;code&gt;Checkpoint.save()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">Сохраненная контрольная точка включает в себя переменные, созданные этим объектом, и любые отслеживаемые объекты, от которых он зависит во время &lt;a href=&quot;checkpoint#save&quot;&gt; &lt;code&gt;Checkpoint.save()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38adbe2f58aa8b45a85ccd9d545a08f193885a40" translate="yes" xml:space="preserve">
          <source>The saved checkpoint includes variables created by this object and any trackable objects it depends on at the time &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/train/Checkpoint#save&quot;&gt;&lt;code&gt;Checkpoint.save()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6290af5f5d901c235fa2702c12d35d14bd8fbb8" translate="yes" xml:space="preserve">
          <source>The saved dataset is saved in multiple file &quot;shards&quot;. By default, the dataset output is divided to shards in a round-robin fashion but custom sharding can be specified via the &lt;code&gt;shard_func&lt;/code&gt; function. For example, you can save the dataset to using a single shard as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32eabd05b895cc5cbd843e5d58a26478d871b570" translate="yes" xml:space="preserve">
          <source>The saved model contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b7070f1ecc16e817793f6b5d01b2b53b58703e" translate="yes" xml:space="preserve">
          <source>The saved model contains: - the model's configuration (topology) - the model's weights - the model's optimizer's state (if any)</source>
          <target state="translated">Сохраненная модель содержит:-конфигурация модели (топология)-вес модели-состояние оптимизатора модели (если есть)</target>
        </trans-unit>
        <trans-unit id="eeb866c0e9b8a790b2b06bb4bf72fe83fcf3b7fd" translate="yes" xml:space="preserve">
          <source>The savefile includes:</source>
          <target state="translated">Сохраненный файл включает в себя:</target>
        </trans-unit>
        <trans-unit id="2be8f8b013a0bea1b78a799bc083aef46d344f06" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;default_value&lt;/code&gt; is the value output for keys not present in the table. It must also be of the same type as the table values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3fd5f27f08bbd84c446309ecdaecd1825d0b40" translate="yes" xml:space="preserve">
          <source>The scalar PSNR between a and b. The returned tensor has type &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt; and shape [batch_size, 1].</source>
          <target state="translated">Скалярный PSNR между a и b. Возвращаемый тензор имеет тип &lt;a href=&quot;../../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt; и форму [batch_size, 1].</target>
        </trans-unit>
        <trans-unit id="dd78e4034ea5bbefe47a5585f3fa965bc5acaa8e" translate="yes" xml:space="preserve">
          <source>The scaled exponential unit activation: &lt;code&gt;scale * elu(x, alpha)&lt;/code&gt;.</source>
          <target state="translated">Активация масштабированной экспоненциальной единицы: &lt;code&gt;scale * elu(x, alpha)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7cdf9b27ca1dd2bbd540e30d82d6f1126674d88" translate="yes" xml:space="preserve">
          <source>The scaling_factor is determined from &lt;code&gt;min_range&lt;/code&gt;, &lt;code&gt;max_range&lt;/code&gt;, and &lt;code&gt;narrow_range&lt;/code&gt; in a way that is compatible with &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt; and &lt;code&gt;QuantizeV2&lt;/code&gt;, using the following algorithm:</source>
          <target state="translated">&lt;code&gt;min_range&lt;/code&gt; определяется из min_range , &lt;code&gt;max_range&lt;/code&gt; и &lt;code&gt;narrow_range&lt;/code&gt; способом, совместимым с &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt; и &lt;code&gt;QuantizeV2&lt;/code&gt; , с использованием следующего алгоритма:</target>
        </trans-unit>
        <trans-unit id="d82c0e384909c0dd188de5ead9b2872459677ae8" translate="yes" xml:space="preserve">
          <source>The schedule a 1-arg callable that produces a decayed learning rate when passed the current optimizer step. This can be useful for changing the learning rate value across different invocations of optimizer functions.</source>
          <target state="translated">График 1-карточного вызова,который при прохождении текущего шага оптимизатора приводит к снижению скорости обучения.Это может быть полезно для изменения значения скорости обучения при различных вызовах функций оптимизатора.</target>
        </trans-unit>
        <trans-unit id="c2ad88fa788374ec95b4583696db082a634b18eb" translate="yes" xml:space="preserve">
          <source>The schedule a 1-arg callable that produces a decayed learning rate when passed the current optimizer step. This can be useful for changing the learning rate value across different invocations of optimizer functions. It is computed as:</source>
          <target state="translated">График 1-карточного вызова,который при прохождении текущего шага оптимизатора приводит к снижению скорости обучения.Это может быть полезно для изменения значения скорости обучения при различных вызовах функций оптимизатора.Он рассчитывается как:</target>
        </trans-unit>
        <trans-unit id="71d2993ed1ad7b32ffe04dab2486da899c3f2739" translate="yes" xml:space="preserve">
          <source>The schedule is a 1-arg callable that produces a decayed learning rate when passed the current optimizer step. This can be useful for changing the learning rate value across different invocations of optimizer functions. It is computed as:</source>
          <target state="translated">График-это 1-тарифный позывной,который при прохождении текущего шага оптимизатора приводит к снижению скорости обучения.Это может быть полезно для изменения значения скорости обучения при различных вызовах функций оптимизатора.Оно вычисляется как:</target>
        </trans-unit>
        <trans-unit id="70da9d42a4b299e69bb575bc1c369e715f3022f0" translate="yes" xml:space="preserve">
          <source>The scope for the operations performed in computing the loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf5542bf013cf2cd0c7e2cee3c5c6cd6c529ad0" translate="yes" xml:space="preserve">
          <source>The scope name.</source>
          <target state="translated">Название области.</target>
        </trans-unit>
        <trans-unit id="50f230356c528b135a5e5c8be0185503e716f9b3" translate="yes" xml:space="preserve">
          <source>The second call of &lt;code&gt;foo&lt;/code&gt; returns '(A2, A2)' instead of '(A1, A1)' because &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; maintains an internal counter. If you want &lt;code&gt;foo&lt;/code&gt; to return '(A1, A1)' every time, use the stateless random ops such as &lt;a href=&quot;stateless_uniform&quot;&gt;&lt;code&gt;tf.random.stateless_uniform&lt;/code&gt;&lt;/a&gt;. Also see &lt;a href=&quot;experimental/generator&quot;&gt;&lt;code&gt;tf.random.experimental.Generator&lt;/code&gt;&lt;/a&gt; for a new set of stateful random ops that use external variables to manage their states.</source>
          <target state="translated">Второй вызов &lt;code&gt;foo&lt;/code&gt; возвращает '(A2, A2)' вместо '(A1, A1)', потому что &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; поддерживает внутренний счетчик. Если вы хотите, чтобы &lt;code&gt;foo&lt;/code&gt; возвращал '(A1, A1)' каждый раз, используйте случайные &lt;a href=&quot;stateless_uniform&quot;&gt; &lt;code&gt;tf.random.stateless_uniform&lt;/code&gt; &lt;/a&gt; без сохранения состояния, такие как tf.random.stateless_uniform . Также см. &lt;a href=&quot;experimental/generator&quot;&gt; &lt;code&gt;tf.random.experimental.Generator&lt;/code&gt; &lt;/a&gt; чтобы узнать о новом наборе случайных операций с отслеживанием состояния, которые используют внешние переменные для управления своими состояниями.</target>
        </trans-unit>
        <trans-unit id="99c1ec05a48b05e1a2d2c74a95c41738070d1d52" translate="yes" xml:space="preserve">
          <source>The second call of &lt;code&gt;foo&lt;/code&gt; returns '(A2, A2)' instead of '(A1, A1)' because &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; maintains an internal counter. If you want &lt;code&gt;foo&lt;/code&gt; to return '(A1, A1)' every time, use the stateless random ops such as &lt;a href=&quot;stateless_uniform&quot;&gt;&lt;code&gt;tf.random.stateless_uniform&lt;/code&gt;&lt;/a&gt;. Also see &lt;a href=&quot;generator&quot;&gt;&lt;code&gt;tf.random.experimental.Generator&lt;/code&gt;&lt;/a&gt; for a new set of stateful random ops that use external variables to manage their states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08568c721bd015f102f6c3ec1b535d6153171292" translate="yes" xml:space="preserve">
          <source>The second dict contains the feature_list key/values.</source>
          <target state="translated">Второй диктат содержит ключ/значения feature_list.</target>
        </trans-unit>
        <trans-unit id="55c0e48b341890b90c7222213ebdf6711ed127c5" translate="yes" xml:space="preserve">
          <source>The second distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73916e07f6ea34c81abd799027349571045df1c6" translate="yes" xml:space="preserve">
          <source>The second innermost dimension of &lt;code&gt;diagonal&lt;/code&gt; has double meaning. When &lt;code&gt;k&lt;/code&gt; is scalar or &lt;code&gt;k[0] == k[1]&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt; is part of the batch size [I, J, ..., M], and the output tensor is:</source>
          <target state="translated">Второе внутреннее измерение &lt;code&gt;diagonal&lt;/code&gt; имеет двоякое значение. Когда &lt;code&gt;k&lt;/code&gt; является скалярным или &lt;code&gt;k[0] == k[1]&lt;/code&gt; , &lt;code&gt;M&lt;/code&gt; является частью размера пакета [I, J, ..., M], а выходной тензор:</target>
        </trans-unit>
        <trans-unit id="897c8f258e58c08596b32bdbc51f703aa19e32cb" translate="yes" xml:space="preserve">
          <source>The second list to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d2101b8340d508be1c61741652a76d9deb3b07" translate="yes" xml:space="preserve">
          <source>The second operand; &lt;code&gt;SparseTensor&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt;. At least one operand must be sparse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb28a5566b72083d75d5c15273e66594bb2b10e4" translate="yes" xml:space="preserve">
          <source>The second sequence to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44476a07dabc329393369e874eaf7a10133de21" translate="yes" xml:space="preserve">
          <source>The second set to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f193b83c375843f2a04bc17c95ee85c91007fcdb" translate="yes" xml:space="preserve">
          <source>The second structure to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bef3c10ad61ff65c7724ce0d24e0698479866c" translate="yes" xml:space="preserve">
          <source>The second tuple to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b310dae88696133dc7ed85369e494d665ee6beaf" translate="yes" xml:space="preserve">
          <source>The second variant is compatible with CuDNNGRU (GPU-only) and allows inference on CPU. Thus it has separate biases for &lt;code&gt;kernel&lt;/code&gt; and &lt;code&gt;recurrent_kernel&lt;/code&gt;. To use this variant, set &lt;code&gt;'reset_after'=True&lt;/code&gt; and &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt;.</source>
          <target state="translated">Второй вариант совместим с CuDNNGRU (только для GPU) и позволяет делать выводы на CPU. Таким образом, у него есть отдельные смещения для &lt;code&gt;kernel&lt;/code&gt; и &lt;code&gt;recurrent_kernel&lt;/code&gt; . Чтобы использовать этот вариант, установите &lt;code&gt;'reset_after'=True&lt;/code&gt; и &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44fd41a3b2fd550cb5e331da22b4349e8495f086" translate="yes" xml:space="preserve">
          <source>The second variant is compatible with CuDNNGRU (GPU-only) and allows inference on CPU. Thus it has separate biases for &lt;code&gt;kernel&lt;/code&gt; and &lt;code&gt;recurrent_kernel&lt;/code&gt;. Use &lt;code&gt;'reset_after'=True&lt;/code&gt; and &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt;.</source>
          <target state="translated">Второй вариант совместим с CuDNNGRU (только для GPU) и позволяет делать выводы на CPU. Таким образом, у него есть отдельные смещения для &lt;code&gt;kernel&lt;/code&gt; и &lt;code&gt;recurrent_kernel&lt;/code&gt; . Используйте &lt;code&gt;'reset_after'=True&lt;/code&gt; и &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef054429664e25cebbffadf1c7499db194568c6" translate="yes" xml:space="preserve">
          <source>The second way is through a callable function that does not accept any arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1ff7b195e25bb1e934a1faddac3cb31e9dda14" translate="yes" xml:space="preserve">
          <source>The selected tensor.</source>
          <target state="translated">Выбранный тензор.</target>
        </trans-unit>
        <trans-unit id="6d81fff9b6102438ec592417def3c2112c0846b7" translate="yes" xml:space="preserve">
          <source>The semantics of the input tensor depends on tensor_debug_mode. In typical usage, the input tensor comes directly from the user computation only when graph_debug_mode is FULL_TENSOR (see protobuf/debug_event.proto for a list of all the possible values of graph_debug_mode). For the other debug modes, the input tensor should be produced by an additional op or subgraph that computes summary information about one or more tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1450544c35748cfa003192a74e09ceb10f67e4f7" translate="yes" xml:space="preserve">
          <source>The separator string used between ngram elements. Must be a string constant, not a Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84f4757d0db527182bb06d2afdc87b1042d6fea" translate="yes" xml:space="preserve">
          <source>The sequence in which to look for prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14448741add9013596276b373f9b2b4fe8b71b2b" translate="yes" xml:space="preserve">
          <source>The sequence of &lt;code&gt;Tensor&lt;/code&gt; objects representing the data inputs of this op.</source>
          <target state="translated">Последовательность объектов &lt;code&gt;Tensor&lt;/code&gt; , представляющих входные данные этой операции.</target>
        </trans-unit>
        <trans-unit id="ad56b1734b2aec94010201da62b3c74ae59652ee" translate="yes" xml:space="preserve">
          <source>The sequence that we are testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c721fd10cd508d808b1312a2194dc7e4890a7fc" translate="yes" xml:space="preserve">
          <source>The serialized &lt;code&gt;GraphDef&lt;/code&gt; can be imported into another &lt;code&gt;Graph&lt;/code&gt; (using &lt;a href=&quot;graph_util/import_graph_def&quot;&gt;&lt;code&gt;tf.import_graph_def&lt;/code&gt;&lt;/a&gt;) or used with the &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/cc/index&quot;&gt;C++ Session API&lt;/a&gt;.</source>
          <target state="translated">Сериализованный &lt;code&gt;GraphDef&lt;/code&gt; можно импортировать в другой &lt;code&gt;Graph&lt;/code&gt; (используя &lt;a href=&quot;graph_util/import_graph_def&quot;&gt; &lt;code&gt;tf.import_graph_def&lt;/code&gt; &lt;/a&gt; ) или использовать с &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/cc/index&quot;&gt;C ++ Session API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73859165e320015abdcf466de88e9720ebb22082" translate="yes" xml:space="preserve">
          <source>The serialized &lt;code&gt;GraphDef&lt;/code&gt; can be imported into another &lt;code&gt;Graph&lt;/code&gt; (using &lt;a href=&quot;graph_util/import_graph_def&quot;&gt;&lt;code&gt;tf.import_graph_def&lt;/code&gt;&lt;/a&gt;) or used with the &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/cc/index&quot;&gt;C++ Session API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766157bb0379c94a2b06eab4d5860dfc7335b141" translate="yes" xml:space="preserve">
          <source>The session to evaluate variables in. Ignored when executing eagerly. If not provided when graph building, the default session is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a72456f672e80ba24848fd6a912b31242ea6b05" translate="yes" xml:space="preserve">
          <source>The session to use to evaluate this variable. If none, the default session is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec73351af802bdf6746d29fb3d40b6d4c532bba4" translate="yes" xml:space="preserve">
          <source>The set of absent/default values may be specified using a vector of lengths or a padding value (but not both). If &lt;code&gt;lengths&lt;/code&gt; is specified, then the output tensor will satisfy &lt;code&gt;output[row] = tensor[row][:lengths[row]]&lt;/code&gt;. If 'lengths' is a list of lists or tuple of lists, those lists will be used as nested row lengths. If &lt;code&gt;padding&lt;/code&gt; is specified, then any row &lt;em&gt;suffix&lt;/em&gt; consisting entirely of &lt;code&gt;padding&lt;/code&gt; will be excluded from the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. If neither &lt;code&gt;lengths&lt;/code&gt; nor &lt;code&gt;padding&lt;/code&gt; is specified, then the returned &lt;code&gt;RaggedTensor&lt;/code&gt; will have no absent/default values.</source>
          <target state="translated">Набор отсутствующих / значений по умолчанию может быть указан с использованием вектора длин или значения заполнения (но не обоих сразу). Если &lt;code&gt;lengths&lt;/code&gt; указана, то выходной тензор будет удовлетворять условию &lt;code&gt;output[row] = tensor[row][:lengths[row]]&lt;/code&gt; . Если 'lengths' - это список списков или кортеж списков, эти списки будут использоваться как длины вложенных строк. Если указано &lt;code&gt;padding&lt;/code&gt; , то любой &lt;em&gt;суффикс&lt;/em&gt; строки, полностью состоящий из &lt;code&gt;padding&lt;/code&gt; будет исключен из возвращаемого &lt;code&gt;RaggedTensor&lt;/code&gt; . Если не указаны ни &lt;code&gt;lengths&lt;/code&gt; ни &lt;code&gt;padding&lt;/code&gt; , то возвращаемый &lt;code&gt;RaggedTensor&lt;/code&gt; не будет иметь отсутствующих / значений по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0c1258f12879c9bd1b917a210f7db35cdd522088" translate="yes" xml:space="preserve">
          <source>The set of ops to be run as part of the main op upon the load operation.</source>
          <target state="translated">Набор опций,которые должны выполняться в рамках основной операции при работе с нагрузкой.</target>
        </trans-unit>
        <trans-unit id="b8a942e9ca1e31cdbe28c47ba81e62ec5b4daae6" translate="yes" xml:space="preserve">
          <source>The set of variable names to convert (by default, all variables are converted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708ef0da29666e679f2d004edd19c8b18d49eb0b" translate="yes" xml:space="preserve">
          <source>The set of variable names to omit converting to constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc94cf8836a9ff2b4e0118d0144216371d4137e" translate="yes" xml:space="preserve">
          <source>The shape and dtype of any intermediate or output tensors in the computation of &lt;code&gt;fn&lt;/code&gt; should not depend on the input to &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915b2e710b3b023da7cd3921f1c34459542c194c" translate="yes" xml:space="preserve">
          <source>The shape for individual flat values in the &lt;code&gt;RaggedTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1218538acb5cc473fe08e57d6e893aaca21938d" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; Tensors. If True, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[max_time, batch_size, num_classes]&lt;/code&gt;. If False, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[batch_size, max_time, num_classes]&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; (default) is a bit more efficient because it avoids transposes at the beginning of the ctc_loss calculation. However, most TensorFlow data is batch-major, so by this function also accepts inputs in batch-major form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd03f61b772d8cecf2105a6fa68f431df30d2490" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; Tensors. If true, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[max_time, batch_size, depth]&lt;/code&gt;. If false, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[batch_size, max_time, depth]&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fa5d6d5a2b3f7febe8c6a21da6334423de8f46" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; tensors. If True, the inputs and outputs will be in shape &lt;code&gt;(timesteps, batch, ...)&lt;/code&gt;, whereas in the False case, it will be &lt;code&gt;(batch, timesteps, ...)&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca9d07b430e38f671c59fb716e05624f9098d82" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; tensors. If True, the inputs and outputs will be in shape &lt;code&gt;[timesteps, batch, feature]&lt;/code&gt;, whereas in the False case, it will be &lt;code&gt;[batch, timesteps, feature]&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9705c68d850f3729f14c8b0e86c4e7a7c9b8a9c5" translate="yes" xml:space="preserve">
          <source>The shape inference functions propagate shapes to the extent possible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cb3dea60cfc74ebbae7817c2108c229a9e9930" translate="yes" xml:space="preserve">
          <source>The shape invariants for the loop variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081af2a7657fa36a381b1785e67936a8d191debb" translate="yes" xml:space="preserve">
          <source>The shape is computed using shape inference functions that are registered for each &lt;a href=&quot;operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc1bd93e711b8be01e066d838cfcf34409f0c38" translate="yes" xml:space="preserve">
          <source>The shape is computed using shape inference functions that are registered in the Op for each &lt;code&gt;Operation&lt;/code&gt;. See &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; for more details of what a shape represents.</source>
          <target state="translated">Форма вычисляется с использованием функций вывода формы, которые зарегистрированы в Op для каждой &lt;code&gt;Operation&lt;/code&gt; . См. &lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; &lt;/a&gt; для более подробной информации о том, что представляет собой фигура.</target>
        </trans-unit>
        <trans-unit id="5319f783b1231c02b92342d27602eef300f0a629" translate="yes" xml:space="preserve">
          <source>The shape of arguments to &lt;code&gt;__init__&lt;/code&gt;, &lt;code&gt;cdf&lt;/code&gt;, &lt;code&gt;log_cdf&lt;/code&gt;, &lt;code&gt;prob&lt;/code&gt;, and &lt;code&gt;log_prob&lt;/code&gt; reflect this broadcasting, as does the return value of &lt;code&gt;sample&lt;/code&gt; and &lt;code&gt;sample_n&lt;/code&gt;.</source>
          <target state="translated">Форма аргументов &lt;code&gt;__init__&lt;/code&gt; , &lt;code&gt;cdf&lt;/code&gt; , &lt;code&gt;log_cdf&lt;/code&gt; , &lt;code&gt;prob&lt;/code&gt; и &lt;code&gt;log_prob&lt;/code&gt; отражает эту трансляцию, как это делает возвращаемое значение &lt;code&gt;sample&lt;/code&gt; и &lt;code&gt;sample_n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9539ceccae379560bc28e4de427220124dc1b7f" translate="yes" xml:space="preserve">
          <source>The shape of each element in the &lt;code&gt;TensorArray&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019adcd66453633d864b6a68c6e8a1ef2fb39d18" translate="yes" xml:space="preserve">
          <source>The shape of the &lt;code&gt;indices&lt;/code&gt; component, which indicates how many slices are in the &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a83199f6a8139b3838bc185a252e39d72f892d5" translate="yes" xml:space="preserve">
          <source>The shape of the RaggedTensor, or &lt;code&gt;None&lt;/code&gt; to allow any shape. If a shape is specified, then all ragged dimensions must have size &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed84e9082260c1530ba06836ab583c0743099df" translate="yes" xml:space="preserve">
          <source>The shape of the elements of the given list, as a tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae769cd7a979ed862a9572cd30406fef8fee2dc" translate="yes" xml:space="preserve">
          <source>The shape of the input data per sequence id. E.g. if &lt;code&gt;shape=(2,)&lt;/code&gt;, each example must contain &lt;code&gt;2 * sequence_length&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3720998b3d73539e8c9661d288914e2cdaa82ba7" translate="yes" xml:space="preserve">
          <source>The shape of the output tensor is:</source>
          <target state="translated">Форма выходного тензора:</target>
        </trans-unit>
        <trans-unit id="b54a3296d32e764f7303629c8f4e133de6a9a7b0" translate="yes" xml:space="preserve">
          <source>The shape of the output will be:</source>
          <target state="translated">Форма выхода будет:</target>
        </trans-unit>
        <trans-unit id="ac04b940314214f5e17141730326fbc95d00e6e3" translate="yes" xml:space="preserve">
          <source>The shape of the resulting dense tensor. In particular, &lt;code&gt;result.shape[i]&lt;/code&gt; is &lt;code&gt;shape[i]&lt;/code&gt; (if &lt;code&gt;shape[i]&lt;/code&gt; is not None), or &lt;code&gt;self.bounding_shape(i)&lt;/code&gt; (otherwise).&lt;code&gt;shape.rank&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt; or equal to &lt;code&gt;self.rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9a810e455caa2b0b6f686bf9c200a962c54ef3" translate="yes" xml:space="preserve">
          <source>The shape of the state is algorithm-specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3389c6b2701837ccb66fc16af6826d909f63b514" translate="yes" xml:space="preserve">
          <source>The shape of the tensor to be fed (optional). If the shape is not specified, you can feed a sparse tensor of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376d2cc370b5ba232fdf37d951603c116bb04786" translate="yes" xml:space="preserve">
          <source>The shape of the tensor to be fed (optional). If the shape is not specified, you can feed a tensor of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04d4e03100c6f081b5e785ea772cca017db1933" translate="yes" xml:space="preserve">
          <source>The shapes of the two operands must match: broadcasting is not supported.</source>
          <target state="translated">Формы двух операндов должны совпадать:трансляция не поддерживается.</target>
        </trans-unit>
        <trans-unit id="348113de328d02812f9ca2ed7f6d52b929c19ce9" translate="yes" xml:space="preserve">
          <source>The simplest form of RNN network generated is:</source>
          <target state="translated">Самая простая форма создаваемой сети RNN:</target>
        </trans-unit>
        <trans-unit id="ff2f171ddc511ae06abeb2ff57b6d8a5b4678a63" translate="yes" xml:space="preserve">
          <source>The simplest form of scatter is to insert individual elements in a tensor by index. For example, say we want to insert 4 scattered elements in a rank-1 tensor with 8 elements.</source>
          <target state="translated">Самая простая форма рассеяния-вставка отдельных элементов в тензор по индексу.Например,скажем,мы хотим вставить 4 рассеянных элемента в тензор ранга-1 с 8 элементами.</target>
        </trans-unit>
        <trans-unit id="f366cdfba69e2fc90954206f2645c89f45fbcd17" translate="yes" xml:space="preserve">
          <source>The simplest form of tensor_scatter_add is to add individual elements to a tensor by index. For example, say we want to add 4 elements in a rank-1 tensor with 8 elements.</source>
          <target state="translated">Самая простая форма tensor_scatter_add-это добавление отдельных элементов в тензор по индексу.Например,скажем,мы хотим добавить 4 элемента в тензор ранга-1 с 8 элементами.</target>
        </trans-unit>
        <trans-unit id="3af9f04f82cbb797b19d70da5fb65e10e6f6ef91" translate="yes" xml:space="preserve">
          <source>The simplest form of tensor_scatter_sub is to subtract individual elements from a tensor by index. For example, say we want to insert 4 scattered elements in a rank-1 tensor with 8 elements.</source>
          <target state="translated">Самая простая форма tensor_scatter_sub-вычитание отдельных элементов из тензора по индексу.Например,мы хотим вставить 4 рассеянных элемента в тензор ранга 1 с 8 элементами.</target>
        </trans-unit>
        <trans-unit id="802d517fc471afa54d770d15cdbc678a89e0c7a9" translate="yes" xml:space="preserve">
          <source>The simplest version of &lt;code&gt;map_fn&lt;/code&gt; repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from first to last. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt;. &lt;code&gt;dtype&lt;/code&gt; is the data type of the return value of &lt;code&gt;fn&lt;/code&gt;. Users must provide &lt;code&gt;dtype&lt;/code&gt; if it is different from the data type of &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">Простейшая версия &lt;code&gt;map_fn&lt;/code&gt; многократно применяет вызываемую &lt;code&gt;fn&lt;/code&gt; к последовательности элементов от первого до последнего. Элементы составлены из тензоров, распакованных из &lt;code&gt;elems&lt;/code&gt; . &lt;code&gt;dtype&lt;/code&gt; - это тип данных возвращаемого значения &lt;code&gt;fn&lt;/code&gt; . Пользователи должны &lt;code&gt;dtype&lt;/code&gt; если он отличается от типа данных &lt;code&gt;elems&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7f6d20e0852a13ae739990f6fedc34688b995c0" translate="yes" xml:space="preserve">
          <source>The simplest version of &lt;code&gt;scan&lt;/code&gt; repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from first to last. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0. The callable fn takes two tensors as arguments. The first argument is the accumulated value computed from the preceding invocation of fn, and the second is the value at the current position of &lt;code&gt;elems&lt;/code&gt;. If &lt;code&gt;initializer&lt;/code&gt; is None, &lt;code&gt;elems&lt;/code&gt; must contain at least one element, and its first element is used as the initializer.</source>
          <target state="translated">Самая простая версия &lt;code&gt;scan&lt;/code&gt; многократно применяет вызываемую &lt;code&gt;fn&lt;/code&gt; к последовательности элементов от первого до последнего. Элементы состоят из тензоров, распакованных из &lt;code&gt;elems&lt;/code&gt; в размерности 0. Вызываемая функция fn принимает в качестве аргументов два тензора. Первый аргумент - это накопленное значение, вычисленное в результате предыдущего вызова fn, а второй - это значение в текущей позиции &lt;code&gt;elems&lt;/code&gt; . Если &lt;code&gt;initializer&lt;/code&gt; равен None, &lt;code&gt;elems&lt;/code&gt; должен содержать хотя бы один элемент, и его первый элемент используется как инициализатор.</target>
        </trans-unit>
        <trans-unit id="7a38981091aad7a606ea4d4d2a567d64ac905976" translate="yes" xml:space="preserve">
          <source>The simplest way to create a dataset is to create it from a python &lt;code&gt;list&lt;/code&gt;:</source>
          <target state="translated">Самый простой способ создать набор данных - создать его из &lt;code&gt;list&lt;/code&gt; Python :</target>
        </trans-unit>
        <trans-unit id="8c730f2755df0951b225a0138c6c5b2d885cf90a" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;tensor_names&lt;/code&gt; must match the number of tensors in &lt;code&gt;data&lt;/code&gt;. &lt;code&gt;data[i]&lt;/code&gt; is written to &lt;code&gt;filename&lt;/code&gt; with name &lt;code&gt;tensor_names[i]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab51731901ff080d9eff54a48d6859d0f1323c1a" translate="yes" xml:space="preserve">
          <source>The size of the resulting dataset will match the size of the smallest input dataset, and no error will be raised if input datasets have different sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017e6c560666c8b8adcda856df4242248fd294ae" translate="yes" xml:space="preserve">
          <source>The sizes of the pooling regions are generated randomly but are fairly uniform. For example, let's look at the height dimension, and the constraints on the list of rows that will be pool boundaries.</source>
          <target state="translated">Размеры областей объединения генерируются случайным образом,но они достаточно равномерны.Например,давайте посмотрим на размерность высоты и ограничения на список строк,которые будут границами пула.</target>
        </trans-unit>
        <trans-unit id="3c43eb48e9249082c6dab3dc37ecd5648014a1b5" translate="yes" xml:space="preserve">
          <source>The snapshot API allows users to transparently persist the output of their preprocessing pipeline to disk, and materialize the pre-processed data on a different training run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a231b5d401442573df3e17bbb0c7335e8e5d44" translate="yes" xml:space="preserve">
          <source>The softmax of each vector x is calculated by &lt;code&gt;exp(x)/tf.reduce_sum(exp(x))&lt;/code&gt;. The input values in are the log-odds of the resulting probability.</source>
          <target state="translated">Softmax каждого вектора x вычисляется как &lt;code&gt;exp(x)/tf.reduce_sum(exp(x))&lt;/code&gt; . Входные значения представляют собой логарифмические шансы результирующей вероятности.</target>
        </trans-unit>
        <trans-unit id="887fc2159220b03235a84826c28912f3876b1988" translate="yes" xml:space="preserve">
          <source>The softmax of each vector x is computed as &lt;code&gt;exp(x) / tf.reduce_sum(exp(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d8793457c083f0d11acb319bb58de8dcf61657" translate="yes" xml:space="preserve">
          <source>The softplus activation: &lt;code&gt;log(exp(x) + 1)&lt;/code&gt;.</source>
          <target state="translated">Активация softplus: &lt;code&gt;log(exp(x) + 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a35f61726860bd793a42b2269f7f12bfff5f5061" translate="yes" xml:space="preserve">
          <source>The softplus activation: &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt;.</source>
          <target state="translated">Активация softplus: &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cdf43d3dd10a8cc3aa784daa0a9e1312644b77d" translate="yes" xml:space="preserve">
          <source>The softsign activation: &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6542d7e39f0c310801daa6538837ad6138ffae82" translate="yes" xml:space="preserve">
          <source>The solution is to ensure any access to the underlying resource &lt;code&gt;v&lt;/code&gt; is only processed through a critical section:</source>
          <target state="translated">Решение состоит в том, чтобы гарантировать, что любой доступ к базовому ресурсу &lt;code&gt;v&lt;/code&gt; обрабатывается только через критическую секцию:</target>
        </trans-unit>
        <trans-unit id="48c0d2fec393318121a3ea291f2dd8dccd7b38fa" translate="yes" xml:space="preserve">
          <source>The solution is to identify which gradient call this particular TensorArray gradient is being called in. This is performed by identifying a unique string (e.g. &quot;gradients&quot;, &quot;gradients_1&quot;, ...) from the input gradient Tensor's name. This string is used as a suffix when creating the TensorArray gradient object here (the attribute &lt;code&gt;source&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9c87c3bbd16608d71f6244bf102c899fcfe323" translate="yes" xml:space="preserve">
          <source>The solution is to wrap the model construction and execution in a keras-style scope:</source>
          <target state="translated">Решение заключается в том,чтобы обернуть конструкцию и исполнение модели в прицел в стиле keras:</target>
        </trans-unit>
        <trans-unit id="e590f462584ca8d9fda3b6ea3ab70cb8db99fef3" translate="yes" xml:space="preserve">
          <source>The source of the non-determinism will be platform- and time-dependent.</source>
          <target state="translated">Источником недетерминизма будет платформенная и временная зависимость.</target>
        </trans-unit>
        <trans-unit id="7b94d68698f376ae68caf545ac2ad9ff65451535" translate="yes" xml:space="preserve">
          <source>The sparse implementation of this algorithm (used when the gradient is an IndexedSlices object, typically because of &lt;a href=&quot;../../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) does apply momentum to variable slices even if they were not used in the forward pass (meaning they have a gradient equal to zero). Momentum decay (beta1) is also applied to the entire momentum accumulator. This means that the sparse behavior is equivalent to the dense behavior (in contrast to some momentum implementations which ignore momentum unless a variable slice was actually used).</source>
          <target state="translated">Разреженная реализация этого алгоритма (используется, когда градиент является объектом IndexedSlices, обычно из-за &lt;a href=&quot;../../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; или поиска встраивания в прямом проходе) действительно применяет импульс к переменным срезам, даже если они не использовались в прямом проходе (то есть они имеют градиент, равный нулю). Распад импульса (бета1) также применяется ко всему аккумулятору импульса. Это означает, что разреженное поведение эквивалентно плотному поведению (в отличие от некоторых реализаций импульса, которые игнорируют импульс, если на самом деле не использовался переменный срез).</target>
        </trans-unit>
        <trans-unit id="2c28505e1992f5a2d21a399d52aaf1d49a6228f7" translate="yes" xml:space="preserve">
          <source>The sparse implementation of this algorithm (used when the gradient is an IndexedSlices object, typically because of &lt;a href=&quot;../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) does apply momentum to variable slices even if they were not used in the forward pass (meaning they have a gradient equal to zero). Momentum decay (beta1) is also applied to the entire momentum accumulator. This means that the sparse behavior is equivalent to the dense behavior (in contrast to some momentum implementations which ignore momentum unless a variable slice was actually used).</source>
          <target state="translated">Разреженная реализация этого алгоритма (используется, когда градиент является объектом IndexedSlices, обычно из-за &lt;a href=&quot;../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; или поиска встраивания в прямом проходе) действительно применяет импульс к переменным срезам, даже если они не использовались в прямом проходе (то есть они имеют градиент, равный нулю). Распад импульса (бета1) также применяется ко всему аккумулятору импульса. Это означает, что разреженное поведение эквивалентно плотному поведению (в отличие от некоторых реализаций импульса, которые игнорируют импульс, если на самом деле не использовался переменный срез).</target>
        </trans-unit>
        <trans-unit id="e5bdcabcaa194b28393438e39e1590c0f77ff2c8" translate="yes" xml:space="preserve">
          <source>The sparse matrix product may have numeric (non-structural) zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedfba1684c4375e13d104a45eb8d51735e2b834" translate="yes" xml:space="preserve">
          <source>The sparse tensor to convert. Must have rank 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54e597f7fe46cc2667d4b65cc738c9c9db301ba" translate="yes" xml:space="preserve">
          <source>The specified output type of the operation (&lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;). Defaults to &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt;(optional).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b88004b19728b58b00753256fbdb980b735e8d2" translate="yes" xml:space="preserve">
          <source>The split indices for the ragged tensor value.</source>
          <target state="translated">Дробные индексы для неровного значения тензора.</target>
        </trans-unit>
        <trans-unit id="f49d81f2a44d35cf534ae7fd8c45debcfaf469ae" translate="yes" xml:space="preserve">
          <source>The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fdcf5ad4499cdb6d4201c3ecb0186f730f52b9" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;segment_*&lt;/code&gt; functions assert that the segment indices are sorted. If you have unsorted indices use the equivalent &lt;code&gt;unsorted_segment_&lt;/code&gt; function. These functions take an additional argument &lt;code&gt;num_segments&lt;/code&gt; so that the output tensor can be efficiently allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29667fc1f908940634484906fb6441d097a55ad" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;segment_*&lt;/code&gt; functions assert that the segment indices are sorted. If you have unsorted indices use the equivalent &lt;code&gt;unsorted_segment_&lt;/code&gt; function. Thses functions take an additional argument &lt;code&gt;num_segments&lt;/code&gt; so that the output tensor can be efficiently allocated.</source>
          <target state="translated">Стандартные функции &lt;code&gt;segment_*&lt;/code&gt; утверждают, что индексы сегментов отсортированы. Если у вас есть несортированные индексы, используйте эквивалентную функцию &lt;code&gt;unsorted_segment_&lt;/code&gt; . Эти функции принимают дополнительный аргумент &lt;code&gt;num_segments&lt;/code&gt; , чтобы можно было эффективно выделить выходной тензор.</target>
        </trans-unit>
        <trans-unit id="6cf74e13a5dc987612c9d705626f37de29ad545f" translate="yes" xml:space="preserve">
          <source>The standard library uses various well-known names to collect and retrieve values associated with a graph. For example, the &lt;code&gt;tf.Optimizer&lt;/code&gt; subclasses default to optimizing the variables collected under &lt;code&gt;tf.GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; if none is specified, but it is also possible to pass an explicit list of variables.</source>
          <target state="translated">Стандартная библиотека использует различные хорошо известные имена для сбора и извлечения значений, связанных с графом. Например, подклассы &lt;code&gt;tf.Optimizer&lt;/code&gt; по умолчанию оптимизируют переменные, собранные в &lt;code&gt;tf.GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; , если ничего не указано, но также можно передать явный список переменных.</target>
        </trans-unit>
        <trans-unit id="ce8c36f190ecab29f1604c69bb1fdd2396d6f9bd" translate="yes" xml:space="preserve">
          <source>The standard pattern for updating variables is to:</source>
          <target state="translated">Стандартный шаблон для обновления переменных должен быть таковым:</target>
        </trans-unit>
        <trans-unit id="1df550e9ac2ff1efc86381fe4007d40151e6c36c" translate="yes" xml:space="preserve">
          <source>The started thread is added to the list of threads managed by the supervisor so it does not need to be passed to the &lt;code&gt;stop()&lt;/code&gt; method.</source>
          <target state="translated">Запущенный поток добавляется в список потоков, управляемых супервизором, поэтому его не нужно передавать в метод &lt;code&gt;stop()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22b0c0a61720b2b49f3bdb46b68ab2ffe3bd7116" translate="yes" xml:space="preserve">
          <source>The started thread.</source>
          <target state="translated">Начальная нить.</target>
        </trans-unit>
        <trans-unit id="04fb16ca663bd50a2194064568a76d4c96b84f17" translate="yes" xml:space="preserve">
          <source>The starting value for accumulators. Only zero or positive values are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25d85454a9ea543e59596d91af95b242b42d7a4" translate="yes" xml:space="preserve">
          <source>The state of the RNG after &lt;code&gt;rng_skip(n)&lt;/code&gt; will be the same as that after &lt;code&gt;stateful_uniform([n])&lt;/code&gt; (or any other distribution). The actual increment added to the counter is an unspecified implementation detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd546c154f1294509a35cef6daf7e05272419f55" translate="yes" xml:space="preserve">
          <source>The state of the optimizer, allowing to resume training exactly where you left off.</source>
          <target state="translated">Состояние оптимизатора,позволяющее возобновить обучение именно там,где вы остановились.</target>
        </trans-unit>
        <trans-unit id="712f8a6f55bf7c5b4fd684dab030efe40f46ccee" translate="yes" xml:space="preserve">
          <source>The statically known shape of this ragged tensor.</source>
          <target state="translated">Статически известная форма этого оборванного тензора.</target>
        </trans-unit>
        <trans-unit id="05eef5966a4733b45681c7bb2c1cfa7fcd7e3ded" translate="yes" xml:space="preserve">
          <source>The statistics options associated with the dataset. See &lt;a href=&quot;experimental/statsoptions&quot;&gt;&lt;code&gt;tf.data.experimental.StatsOptions&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Параметры статистики, связанные с набором данных. См. &lt;a href=&quot;experimental/statsoptions&quot;&gt; &lt;code&gt;tf.data.experimental.StatsOptions&lt;/code&gt; &lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="a8c6e46a80c3223660eded889659ea2c4138b476" translate="yes" xml:space="preserve">
          <source>The step set by &lt;a href=&quot;set_step&quot;&gt;&lt;code&gt;tf.summary.experimental.set_step()&lt;/code&gt;&lt;/a&gt; if one has been set, otherwise None.</source>
          <target state="translated">Шаг, установленный &lt;a href=&quot;set_step&quot;&gt; &lt;code&gt;tf.summary.experimental.set_step()&lt;/code&gt; &lt;/a&gt; если он был установлен, в противном случае - None.</target>
        </trans-unit>
        <trans-unit id="5dff7b910b7ad17251b2c5a9c0f91aaacc64e975" translate="yes" xml:space="preserve">
          <source>The str() operator of a 'FlagValues' object provides help for all of the registered 'Flag' objects.</source>
          <target state="translated">Оператор str()объекта 'FlagValues' предоставляет помощь для всех зарегистрированных объектов 'Flag'.</target>
        </trans-unit>
        <trans-unit id="13be6068510e1bba9bcaba7458adf0809e711454" translate="yes" xml:space="preserve">
          <source>The strategy may choose to put the variable on multiple devices, like mirrored variables, but unlike mirrored variables we don't synchronize the updates to them to make sure they have the same value. Instead, the synchronization is performed when reading in cross-replica context. In a replica context, reads and writes are performed on the local copy (we allow reads so you can write code like &lt;code&gt;v = 0.9*v + 0.1*update&lt;/code&gt;). We don't allow operations like &lt;code&gt;v.assign_add&lt;/code&gt; in a cross-replica context for sync on read variables; right now we don't have a use case for such updates and depending on the aggregation mode such updates may not be sensible.</source>
          <target state="translated">Стратегия может выбрать размещение переменной на нескольких устройствах, например, зеркальных переменных, но, в отличие от зеркальных переменных, мы не синхронизируем обновления с ними, чтобы убедиться, что они имеют одинаковое значение. Вместо этого синхронизация выполняется при чтении в контексте перекрестной реплики. В контексте реплики чтение и запись выполняются в локальной копии (мы разрешаем чтение, поэтому вы можете писать код типа &lt;code&gt;v = 0.9*v + 0.1*update&lt;/code&gt; ). Мы не разрешаем такие операции, как &lt;code&gt;v.assign_add&lt;/code&gt; , в контексте кросс-реплик для синхронизации с переменными чтения; прямо сейчас у нас нет варианта использования таких обновлений, и в зависимости от режима агрегирования такие обновления могут быть неразумными.</target>
        </trans-unit>
        <trans-unit id="d3fd5c3cf46ac06d0260b1f659bcc1a0b81cadee" translate="yes" xml:space="preserve">
          <source>The stream whose writes should be captured. This stream must have a file descriptor, support writing via using that file descriptor, and must have a &lt;code&gt;.flush()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644f3a81fca55d1677b34a373591148f236e0ab3" translate="yes" xml:space="preserve">
          <source>The string &quot;tensorflow&quot;.</source>
          <target state="translated">Строка &quot;tensorflow&quot;.</target>
        </trans-unit>
        <trans-unit id="cc503fc832fae0582037d46d99a283b2143a5687" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;-&lt;/code&gt; meaning that the slice covers all indices of this dimension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8540ba2c73157ed83e7a8b8d1ba5f66009b9e41f" translate="yes" xml:space="preserve">
          <source>The string name of a job in this cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56132600b50269345758de3a44957eaf5ba36a10" translate="yes" xml:space="preserve">
          <source>The string name of the device to which this op has been assigned, or an empty string if it has not been assigned to a device.</source>
          <target state="translated">Строковое имя устройства,которому была назначена данная операция,или пустая строка,если она не была назначена устройству.</target>
        </trans-unit>
        <trans-unit id="8992e1dfe2880c9a4de6beb1ac8e0230422a7a79" translate="yes" xml:space="preserve">
          <source>The string name of the underlying Queue.</source>
          <target state="translated">Строковое имя базовой очереди.</target>
        </trans-unit>
        <trans-unit id="a96aa4c9d9595a33bb0f9789d55b573d138edebb" translate="yes" xml:space="preserve">
          <source>The string name of this tensor.</source>
          <target state="translated">Строковое имя этого тензора.</target>
        </trans-unit>
        <trans-unit id="c67de356b037fd5e8be6d855afae37205aa00794" translate="yes" xml:space="preserve">
          <source>The string path to the exported directory or &lt;code&gt;None&lt;/code&gt; if export is skipped.</source>
          <target state="translated">Строковый путь к экспортированному каталогу или &lt;code&gt;None&lt;/code&gt; , если экспорт пропущен.</target>
        </trans-unit>
        <trans-unit id="e5efe1c4c830550f08c9bea1e979d7c9a7668a12" translate="yes" xml:space="preserve">
          <source>The string path to the exported directory.</source>
          <target state="translated">Строковый путь к экспортируемому каталогу.</target>
        </trans-unit>
        <trans-unit id="e6d17d88d9f96bec8835a8d4d00d7ee284382edf" translate="yes" xml:space="preserve">
          <source>The string representation of a persistent tensor handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d628e9b8c8f44ad4c03facb818cd42847e7780" translate="yes" xml:space="preserve">
          <source>The string to use to separate the inputs. Defaults to &quot; &quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d0576ccdc2458c02c95d244e31139154833425" translate="yes" xml:space="preserve">
          <source>The string type of an operation. This corresponds to the &lt;code&gt;OpDef.name&lt;/code&gt; field for the proto that defines the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17bd3da8a69a3dada0980459ac9d927bbc1c342" translate="yes" xml:space="preserve">
          <source>The string we try to match with the items in regexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb20559dca432fe77c06ffe1211357d7726b77ab" translate="yes" xml:space="preserve">
          <source>The structure of the components of this optional.</source>
          <target state="translated">Структура компонентов этой опции.</target>
        </trans-unit>
        <trans-unit id="636182e5686aa0b143279a1925716c9803dd42dc" translate="yes" xml:space="preserve">
          <source>The stubbing is using the builtin getattr and setattr. So, the &lt;strong&gt;get&lt;/strong&gt; and &lt;strong&gt;set&lt;/strong&gt; will be called when stubbing ( probably be to manipulate obj.&lt;strong&gt;dict&lt;/strong&gt; instead of getattr() and setattr()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e607f82b834bedf8082612b2f31785cf1834ed" translate="yes" xml:space="preserve">
          <source>The stubbing is using the builtin getattr and setattr. So, the &lt;strong&gt;get&lt;/strong&gt; and &lt;strong&gt;set&lt;/strong&gt; will be called when stubbing (TODO: A better idea would probably be to manipulate obj.&lt;strong&gt;dict&lt;/strong&gt; instead of getattr() and setattr()).</source>
          <target state="translated">Заглушка использует встроенные getattr и setattr. Таким образом, &lt;strong&gt;прибудет&lt;/strong&gt; и &lt;strong&gt;набор&lt;/strong&gt; будут вызываться при гася (TODO:. Лучшая идея, вероятно , будет манипулировать OBJ &lt;strong&gt;Сыроватским&lt;/strong&gt; вместо GetAttr () и SetAttr ()).</target>
        </trans-unit>
        <trans-unit id="e3a83e1ccdb64a4c6aff88c02b12dcc686b2bf3b" translate="yes" xml:space="preserve">
          <source>The suffix for the variable that keeps the gradient squared accumulator. If not present, defaults to name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628f884b08eaa26944d28d228cad39f4b6e377f6" translate="yes" xml:space="preserve">
          <source>The suffix for the variable that keeps the linear gradient accumulator. If not present, defaults to name + &quot;&lt;em&gt;1&quot;. &lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b87677b2e7091b18f84e0a5a53ce47bf2fbc17a" translate="yes" xml:space="preserve">
          <source>The sum of the squared distance from each point in the first batch of inputs to its nearest cluster center.</source>
          <target state="translated">Сумма квадратного расстояния от каждой точки первой партии входов до ближайшего центра кластера.</target>
        </trans-unit>
        <trans-unit id="b87e105d01203888c35de69e0d8cabac2d7238b3" translate="yes" xml:space="preserve">
          <source>The summary has up to &lt;code&gt;max_images&lt;/code&gt; summary values containing images. The images are built from &lt;code&gt;tensor&lt;/code&gt; which must be 4-D with shape &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt; and where &lt;code&gt;channels&lt;/code&gt; can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f45fd11021d0fbbacbdd0bd0b9e463916250a5" translate="yes" xml:space="preserve">
          <source>The summary has up to &lt;code&gt;max_outputs&lt;/code&gt; summary values containing audio. The audio is built from &lt;code&gt;tensor&lt;/code&gt; which must be 3-D with shape &lt;code&gt;[batch_size, frames, channels]&lt;/code&gt; or 2-D with shape &lt;code&gt;[batch_size, frames]&lt;/code&gt;. The values are assumed to be in the range of &lt;code&gt;[-1.0, 1.0]&lt;/code&gt; with a sample rate of &lt;code&gt;sample_rate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8749a05b6c387d61ef6d60497d42b829e20f04" translate="yes" xml:space="preserve">
          <source>The summary has up to &lt;code&gt;max_outputs&lt;/code&gt; summary values containing images. The images are built from &lt;code&gt;tensor&lt;/code&gt; which must be 4-D with shape &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt; and where &lt;code&gt;channels&lt;/code&gt; can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ad74c802e798c2d2739d6fd3d4c8a9a95f1067" translate="yes" xml:space="preserve">
          <source>The summary stats contains gradients and hessians accumulated for each node, bucket and dimension id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4c4f21208a76ec80b0674286557919ec4d96bb" translate="yes" xml:space="preserve">
          <source>The summary stats contains gradients and hessians accumulated for each node, feature dimension id and bucket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdad9771b45b958101ba790c70a250dceed1de82" translate="yes" xml:space="preserve">
          <source>The summary stats contains gradients and hessians accumulated into the corresponding node and bucket for each example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa003ab56e1eb5342f9795fdbfba586bfe2f1900" translate="yes" xml:space="preserve">
          <source>The supervisor is notified of any exception raised by one of the services. After an exception is raised, &lt;code&gt;should_stop()&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;. In that case the training loop should also stop. This is why the training loop has to check for &lt;code&gt;sv.should_stop()&lt;/code&gt;.</source>
          <target state="translated">Супервизор уведомляется о любом исключении, вызванном одной из служб. После возникновения исключения &lt;code&gt;should_stop()&lt;/code&gt; возвращает &lt;code&gt;True&lt;/code&gt; . В этом случае цикл обучения также должен остановиться. Вот почему цикл обучения должен проверять &lt;code&gt;sv.should_stop()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50528fab5ce38e9d3b4fc6e5612ddf34e494bebf" translate="yes" xml:space="preserve">
          <source>The swish activation applied to &lt;code&gt;x&lt;/code&gt; (see reference paper for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c298d20320b239b254c85a68c7638e9b3d6999d9" translate="yes" xml:space="preserve">
          <source>The table initializer to use. See &lt;code&gt;HashTable&lt;/code&gt; kernel for supported key and value types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b372ddff28f44f63c6e232f1c30d44e36e67c586" translate="yes" xml:space="preserve">
          <source>The table key dtype.</source>
          <target state="translated">Клавиша &quot;Таблица&quot;.</target>
        </trans-unit>
        <trans-unit id="92555821a111ce6704d66c3accb512005dcb54c2" translate="yes" xml:space="preserve">
          <source>The table to be initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284ce4f13ba5d1db3bbec94a52d693d3d2283853" translate="yes" xml:space="preserve">
          <source>The table to initialize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ea7c0740084e6be8859e3f6c6a5a25999322a4" translate="yes" xml:space="preserve">
          <source>The table value dtype.</source>
          <target state="translated">Тип значения таблицы d.</target>
        </trans-unit>
        <trans-unit id="8e9701fdc91c90f3e0a50b0354216b715e7e2b61" translate="yes" xml:space="preserve">
          <source>The tag name for this metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6370789b18c4cef6f8f91690bde182484827c1" translate="yes" xml:space="preserve">
          <source>The target value of comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6bc45ea60aa5301cecc35d1fbbe5b21036c5bda" translate="yes" xml:space="preserve">
          <source>The task index for this particular VM, within the GCE instance group. In particular, every single instance should be assigned a unique ordinal index within an instance group manually so that they can be distinguished from each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fc3d1afa951ce1fc0c6acdffe30bf9d05aaa6f" translate="yes" xml:space="preserve">
          <source>The task of an Enqueuer is to use parallelism to speed up preprocessing. This is done with processes or threads.</source>
          <target state="translated">Задача Enqueuer-использовать параллелизм для ускорения препроцессирования.Это делается с процессами или потоками.</target>
        </trans-unit>
        <trans-unit id="8d203e324545cf312d1311ac6ed39dbe8533902e" translate="yes" xml:space="preserve">
          <source>The temporary directory.</source>
          <target state="translated">Временный каталог.</target>
        </trans-unit>
        <trans-unit id="89760396be504814d1d16fffe685b4c4ed9d185b" translate="yes" xml:space="preserve">
          <source>The tensor &lt;code&gt;keys&lt;/code&gt; must be of the same type as the keys of the table. The tensor &lt;code&gt;values&lt;/code&gt; must be of the type of the table values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba629a56d84ff4136c8aeadbf5a5b5c5e14b4183" translate="yes" xml:space="preserve">
          <source>The tensor &lt;code&gt;keys&lt;/code&gt; must of the same type as the keys of the table. Keys not already in the table are silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784e799f8d450863febee3c764bd275192b18bd8" translate="yes" xml:space="preserve">
          <source>The tensor &lt;code&gt;keys&lt;/code&gt; must of the same type as the keys of the table. The output &lt;code&gt;values&lt;/code&gt; is of the type of the table values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8d97a1a9f6a392dad767f9f5f935fc3b942c5f" translate="yes" xml:space="preserve">
          <source>The tensor at index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">Тензор по индексу &lt;code&gt;index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2316496cec696b46dadd19db7c5fa7648eaa2e07" translate="yes" xml:space="preserve">
          <source>The tensor for the keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acc2ca709af133edb5533c7cf72d36eab353cfc" translate="yes" xml:space="preserve">
          <source>The tensor for the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8bac0316b66126d9a5f3d03ead635dc9c4e503" translate="yes" xml:space="preserve">
          <source>The tensor is shuffled along dimension 0, such that each &lt;code&gt;value[j]&lt;/code&gt; is mapped to one and only one &lt;code&gt;output[i]&lt;/code&gt;. For example, a mapping that might occur for a 3x2 tensor is:</source>
          <target state="translated">Тензор перетасовывается по размерности 0, так что каждое &lt;code&gt;value[j]&lt;/code&gt; отображается на один и только один &lt;code&gt;output[i]&lt;/code&gt; . Например, отображение, которое может произойти для тензора 3x2:</target>
        </trans-unit>
        <trans-unit id="b2ebac51ffaed872fc6c58ab59a37320ff00d8b4" translate="yes" xml:space="preserve">
          <source>The tensor over which to pool. Must have rank 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d66a49c4d56f6740c34ad1abd2330c2a53d237" translate="yes" xml:space="preserve">
          <source>The tensor over which to pool. Must have rank 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6751ac1718f3abff2c47f31b4ce194ddbe60a5" translate="yes" xml:space="preserve">
          <source>The tensor over which to pool. Must have rank 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba96488585c7e70161cf56eacc0bc675e7c2bf5" translate="yes" xml:space="preserve">
          <source>The tensor returned by this operation is immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374a08aed4e22028f8c4f1a7a5332f381742c546" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should be of numeric type, &lt;code&gt;bool&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6cdbb07f5f2007c7664b9fc800d495933f2079" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should have numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76ee355f90903f0cc3c888c4e5cbb97172bd55d" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should have real numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f9620fdd17bd0ae7e2e11319433d1d510e064f" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should have real or complex type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a48c532dffc217f038e38531b427ddb3f91bda" translate="yes" xml:space="preserve">
          <source>The tensor to start from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7b892140fc1cca57f3b6847beb68b7faa703c7" translate="yes" xml:space="preserve">
          <source>The tensor type for the result: one of &lt;code&gt;&quot;RaggedTensor&quot;&lt;/code&gt; or &lt;code&gt;&quot;SparseTensor&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c73ec4612fec81093c6dca3603df5977d11e17" translate="yes" xml:space="preserve">
          <source>The tensor_shape to resize the input to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79aa982763ef4786022042e868a3556033a0c5ec" translate="yes" xml:space="preserve">
          <source>The tensors at corresponding positions in the three input lists (sample_indices, embedding_indices and aggregation_weights) must have the same shape, i.e. rank 1 with dim_size() equal to the total number of lookups into the table described by the corresponding feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f41fba569c688c2ad85251ea878f2cfba46898a" translate="yes" xml:space="preserve">
          <source>The tensors at corresponding positions in the three input lists must have the same shape, i.e. rank 1 with dim_size() equal to the total number of lookups into the table described by the corresponding table_id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5925b962b25493edc9ea9353afe8ff0989d3ebc" translate="yes" xml:space="preserve">
          <source>The tensors at corresponding positions in two of the input lists, embedding_indices and aggregation_weights, must have the same shape, i.e. rank 1 with dim_size() equal to the total number of lookups into the table described by the corresponding feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263280cf1684ff5fb9dc90aff492167c49c357e8" translate="yes" xml:space="preserve">
          <source>The tensors in the &lt;code&gt;TensorArray&lt;/code&gt; selected by &lt;code&gt;indices&lt;/code&gt;, packed into one tensor.</source>
          <target state="translated">&lt;code&gt;TensorArray&lt;/code&gt; в TensorArray, отобранные по &lt;code&gt;indices&lt;/code&gt; , упакованы в один тензор.</target>
        </trans-unit>
        <trans-unit id="14d5f93ad26c02d132da873b0983deda8cc5ede0" translate="yes" xml:space="preserve">
          <source>The tensors returned by the callable identified by &lt;code&gt;branch_index&lt;/code&gt;, or those returned by &lt;code&gt;default&lt;/code&gt; if no key matches and &lt;code&gt;default&lt;/code&gt; was provided, or those returned by the max-keyed &lt;code&gt;branch_fn&lt;/code&gt; if no &lt;code&gt;default&lt;/code&gt; is provided.</source>
          <target state="translated">&lt;code&gt;branch_index&lt;/code&gt; , возвращаемые вызываемым объектом, идентифицированным с помощью branch_index , или те, которые возвращаются по &lt;code&gt;default&lt;/code&gt; если не было совпадений ключей и &lt;code&gt;default&lt;/code&gt; , или те, которые возвращаются с помощью &lt;code&gt;branch_fn&lt;/code&gt; с максимальным ключом, если &lt;code&gt;default&lt;/code&gt; не указано.</target>
        </trans-unit>
        <trans-unit id="0ea9d9d23c406f164fd2c56245bf91a63b2aa423" translate="yes" xml:space="preserve">
          <source>The tensors returned by the first pair whose predicate evaluated to True, or those returned by &lt;code&gt;default&lt;/code&gt; if none does.</source>
          <target state="translated">Тензоры, возвращаемые первой парой, чей предикат оценивается как True, или те, которые возвращаются по &lt;code&gt;default&lt;/code&gt; если их нет.</target>
        </trans-unit>
        <trans-unit id="62c909c71b66d6f5bfc11fa3e5279c6761971045" translate="yes" xml:space="preserve">
          <source>The tensors returned from &lt;code&gt;fn()&lt;/code&gt;.</source>
          <target state="translated">Тензоры вернулись из &lt;code&gt;fn()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ac69b5b20154b08a328b1d97feb7527a2ebab36" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and first few entries of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de476c8a1f81cdd546d80c349f6129aaf3737e55" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and first few entries of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d755f0b97c63b7eff4b6dbe33de5d6acf734d32c" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and first few entries of the violating tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e71fc634a3e1532ea4fdaf908aef7f0776c5d2" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and the shape of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c87ea478ca9312b37363d8086e97ef6cac7d50" translate="yes" xml:space="preserve">
          <source>The tensors to print out when condition is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f38446647c9bdb5f6c17c4098bf60d7f38504af" translate="yes" xml:space="preserve">
          <source>The tensors will be printed to the log, with &lt;code&gt;INFO&lt;/code&gt; severity. If you are not seeing the logs, you might want to add the following line after your imports:</source>
          <target state="translated">Тензоры будут напечатаны в журнале с серьезностью &lt;code&gt;INFO&lt;/code&gt; . Если вы не видите журналы, вы можете добавить следующую строку после импорта:</target>
        </trans-unit>
        <trans-unit id="6922a3a9fd52a35b3e308cba8bec364b7d504e80" translate="yes" xml:space="preserve">
          <source>The tf.Graph in which tensors are looked up. If None, the current default graph is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11bfdd9c3d39d4a32c1a375c3ce8bfd375bd0b18" translate="yes" xml:space="preserve">
          <source>The tf.tpu.Topology object for the topology of the TPU cluster.</source>
          <target state="translated">Объект tf.tpu.Topology для топологии TPU кластера.</target>
        </trans-unit>
        <trans-unit id="befdc8701902b7376e60ef81bed3d724c3bb2879" translate="yes" xml:space="preserve">
          <source>The the elements of the output vector are in range (0, 1) and sum to 1.</source>
          <target state="translated">Элементы выходного вектора находятся в диапазоне (0,1)и суммируются с 1.</target>
        </trans-unit>
        <trans-unit id="e8a1b74b382d4bec7d008b052874fc8efea06387" translate="yes" xml:space="preserve">
          <source>The threading options associated with the dataset. See &lt;a href=&quot;experimental/threadingoptions&quot;&gt;&lt;code&gt;tf.data.experimental.ThreadingOptions&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Параметры потоковой передачи, связанные с набором данных. См. &lt;a href=&quot;experimental/threadingoptions&quot;&gt; &lt;code&gt;tf.data.experimental.ThreadingOptions&lt;/code&gt; &lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="ed8f460f2dbd5613ea876b9d93397d3969bdc742" translate="yes" xml:space="preserve">
          <source>The thresholds used for evaluating AUC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d718a76c8894d5837a42ef966440d43045adca5" translate="yes" xml:space="preserve">
          <source>The token representing an out-of-vocabulary value. Defaults to &quot;[UNK]&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e4fd90c9e18807d72bafd4f4716080dd6bc34f" translate="yes" xml:space="preserve">
          <source>The total number of dimensions in a &lt;code&gt;RaggedTensor&lt;/code&gt; is called its &lt;em&gt;rank&lt;/em&gt;, and the number of ragged dimensions in a &lt;code&gt;RaggedTensor&lt;/code&gt; is called its &lt;em&gt;ragged-rank&lt;/em&gt;. A &lt;code&gt;RaggedTensor&lt;/code&gt;'s ragged-rank is fixed at graph creation time: it can't depend on the runtime values of &lt;code&gt;Tensor&lt;/code&gt;s, and can't vary dynamically for different session runs.</source>
          <target state="translated">Общее количество измерений в &lt;code&gt;RaggedTensor&lt;/code&gt; называется его &lt;em&gt;рангом&lt;/em&gt; , а количество оборванных измерений в &lt;code&gt;RaggedTensor&lt;/code&gt; называется его &lt;em&gt;рангом&lt;/em&gt; . A &lt;code&gt;RaggedTensor&lt;/code&gt; &amp;laquo;s рваного ранга фиксируется на графике время создания: он не может зависеть от значений во время выполнения &lt;code&gt;Tensor&lt;/code&gt; с, и не может динамически изменяться для различных трасс сеанса.</target>
        </trans-unit>
        <trans-unit id="7366f216b0f07a06f98c4cfb72b6efd8edad2b69" translate="yes" xml:space="preserve">
          <source>The total variation is the sum of the absolute differences for neighboring pixel-values in the input images. This measures how much noise is in the images.</source>
          <target state="translated">Суммарная вариация представляет собой сумму абсолютных разностей для соседних значений пикселей на входных изображениях.Это измеряет количество шумов на изображениях.</target>
        </trans-unit>
        <trans-unit id="4cd5555b6721cf29a977af9cf8bb6114222ca75d" translate="yes" xml:space="preserve">
          <source>The total variation of &lt;code&gt;images&lt;/code&gt;.</source>
          <target state="translated">Полная вариация &lt;code&gt;images&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1be006e04763947d6204304381da8047ab403c6" translate="yes" xml:space="preserve">
          <source>The trace of input tensor.</source>
          <target state="translated">След входного тензора.</target>
        </trans-unit>
        <trans-unit id="e883a1ea41a9a9c563ecd15d66e0cea02e0fd475" translate="yes" xml:space="preserve">
          <source>The transformation calls &lt;code&gt;reduce_func&lt;/code&gt; successively on every element of the input dataset until the dataset is exhausted, aggregating information in its internal state. The &lt;code&gt;initial_state&lt;/code&gt; argument is used for the initial state and the final state is returned as the result.</source>
          <target state="translated">Преобразование вызывает &lt;code&gt;reduce_func&lt;/code&gt; последовательно для каждого элемента входного набора данных, пока набор данных не будет исчерпан, агрегируя информацию во внутреннем состоянии. &lt;code&gt;initial_state&lt;/code&gt; аргумент используется для начального состояния и конечное состояние возвращается в качестве результата.</target>
        </trans-unit>
        <trans-unit id="a76374d8db32ee668d78ea0cbd0b4fb2bd9d2baf" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;atrous_conv2d&lt;/code&gt;.</source>
          <target state="translated">Транспонирование &lt;code&gt;atrous_conv2d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24fae844f58c6b39229d2519fcdd2125a204111b" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;conv1d&lt;/code&gt;.</source>
          <target state="translated">Транспонирование &lt;code&gt;conv1d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5584a45278a21e44f011bf21c57aa5501a09482" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;conv2d&lt;/code&gt;.</source>
          <target state="translated">Транспонирование &lt;code&gt;conv2d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88458abd7b78099fd74249ee9fe81104261b47e7" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;conv3d&lt;/code&gt;.</source>
          <target state="translated">Транспонирование &lt;code&gt;conv3d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4974672a5f0bdf2f1f4a3ac2ea5cc95568047305" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;convolution&lt;/code&gt;.</source>
          <target state="translated">Транспонирование &lt;code&gt;convolution&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1519a20ef4fe586180643d48497a05b2e0fad92f" translate="yes" xml:space="preserve">
          <source>The tuple of concatenated tensors that was dequeued.</source>
          <target state="translated">Кортеж конкатенированных тензоров,который был выкуплен.</target>
        </trans-unit>
        <trans-unit id="947a12be95ae913828fb29965c58acb416f681d0" translate="yes" xml:space="preserve">
          <source>The tuple of tensors that was dequeued.</source>
          <target state="translated">Кортеж тензоров,который был выведен из-под контроля.</target>
        </trans-unit>
        <trans-unit id="3ac8da8c53a0fe7729ca96dc99672e3deaee4160" translate="yes" xml:space="preserve">
          <source>The tutorials cover how to use &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; to do distributed training with native Keras APIs, custom training loops, and Esitmator APIs. They also cover how to save/load model when using &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81263e37d187db94dad3d1abafbff5fd315364f1" translate="yes" xml:space="preserve">
          <source>The tutorials cover how to use &lt;a href=&quot;distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; to do distributed training with native Keras APIs, custom training loops, and Esitmator APIs. They also cover how to save/load model when using &lt;a href=&quot;distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcce8e7308a1f27fd06f367ce630638c93d290a0" translate="yes" xml:space="preserve">
          <source>The two arguments should be data trees consisting of trees of dicts and lists. They will be deeply compared by walking into the contents of dicts and lists; other items will be compared using the == operator. If the two structures differ in content, the failure message will indicate the location within the structures where the first difference is found. This may be helpful when comparing large structures.</source>
          <target state="translated">Двумя аргументами должны быть деревья данных,состоящие из деревьев диктатов и списков.Они будут глубоко сравниваться,заходя в содержимое диктатов и списков;остальные элементы будут сравниваться с помощью оператора ==.Если эти две структуры различаются по содержанию,то в сообщении об ошибке будет указано место внутри структур,где найдено первое различие.Это может быть полезно при сравнении больших структур.</target>
        </trans-unit>
        <trans-unit id="c63ea59f28eeb3c5ef7f12904295f5acd2abba7d" translate="yes" xml:space="preserve">
          <source>The two optional lists, &lt;code&gt;shapes&lt;/code&gt; and &lt;code&gt;names&lt;/code&gt;, must be of the same length as &lt;code&gt;dtypes&lt;/code&gt; if provided. The values at a given index &lt;code&gt;i&lt;/code&gt; indicate the shape and name to use for the corresponding queue component in &lt;code&gt;dtypes&lt;/code&gt;.</source>
          <target state="translated">Два дополнительных списков, &lt;code&gt;shapes&lt;/code&gt; и &lt;code&gt;names&lt;/code&gt; , должны быть одинаковой длины , как &lt;code&gt;dtypes&lt;/code&gt; , если это предусмотрено. Значения в данном индексе &lt;code&gt;i&lt;/code&gt; указывают форму и имя, которые будут использоваться для соответствующего компонента очереди в &lt;code&gt;dtypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2509253fc683a9173057f5630f71d4971cacd9bd" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;values&lt;/code&gt; elements in the tensor to be fed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1114eda45ad0aa9835c881c7ed41948119a5f6" translate="yes" xml:space="preserve">
          <source>The type of alpha, beta, and the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb9c58891241a3653f7ed23f1f4e9ce6c454d7f" translate="yes" xml:space="preserve">
          <source>The type of an element in the resulting &lt;code&gt;Tensor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cccbb2c85e31880b8682b2d0adfb113b78b64da" translate="yes" xml:space="preserve">
          <source>The type of compression for the record.</source>
          <target state="translated">Тип сжатия для записи.</target>
        </trans-unit>
        <trans-unit id="1b4dd7863bb3d0a86631168ad97e3c5ad4e8e603" translate="yes" xml:space="preserve">
          <source>The type of element in the resulting &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94422215aeace7edcb47320386970071b5179d19" translate="yes" xml:space="preserve">
          <source>The type of elements for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. If not specified, then a default is chosen based on the scalar values in &lt;code&gt;pylist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a013615eda1f8f0ede1ff237cff4a624ad2cf8a" translate="yes" xml:space="preserve">
          <source>The type of elements in the tensor to be fed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc1d3e87a785b70bd5fa0c191f6b8f9a2dab411" translate="yes" xml:space="preserve">
          <source>The type of encoding for the file. Defaults to none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00002f765021b74ae3866db29b33e5675d9c97a" translate="yes" xml:space="preserve">
          <source>The type of features. Only string and integer types are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405fc0a59f40a1f68ad3da9d2cbead3200ca93bb" translate="yes" xml:space="preserve">
          <source>The type of features. Only string and integer types are supported. If &lt;code&gt;None&lt;/code&gt;, it will be inferred from &lt;code&gt;vocabulary_list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e39ef94a4f11a83b4f0f2df2ede7e0ef31ede65" translate="yes" xml:space="preserve">
          <source>The type of loss reduction used in the head.</source>
          <target state="translated">Тип уменьшения потерь,используемый в голове.</target>
        </trans-unit>
        <trans-unit id="9e1c8635c975f4590fc90901ef34444f7e5713cc" translate="yes" xml:space="preserve">
          <source>The type of sharding that auto-shard should attempt. If this is set to FILE, then we will attempt to shard by files (each worker will get a set of files to process). If we cannot find a set of files to shard for at least one file per worker, we will error out. When this option is selected, make sure that you have enough files so that each worker gets at least one file. There will be a runtime error thrown if there are insufficient files. If this is set to DATA, then we will shard by elements produced by the dataset, and each worker will process the whole dataset and discard the portion that is not for itself. If this is set to OFF, then we will not autoshard, and each worker will receive a copy of the full dataset. This option is set to AUTO by default, AUTO will attempt to first shard by FILE, and fall back to sharding by DATA if we cannot find a set of files to shard.</source>
          <target state="translated">Тип осколка,который должен попытаться сделать автоосколок.Если он установлен в FILE,то мы будем пытаться шардировать по файлам (каждый работник получит набор файлов для обработки).Если мы не сможем найти набор файлов для шардинга хотя бы для одного файла на каждый рабочий,то получим ошибку.Когда эта опция выбрана,убедитесь,что у вас достаточно файлов,чтобы каждый рабочий получил как минимум один файл.При недостаточном количестве файлов будет выброшена ошибка во время выполнения.Если эта опция установлена в DATA,то мы будем шардировать элементы,созданные набором данных,и каждый рабочий будет обрабатывать весь набор данных и отбрасывать ту часть,которая не является для него самой.Если установлено значение OFF,то мы не будем выполнять автошифрование,и каждый работник получит копию полного набора данных.По умолчанию эта опция установлена в AUTO,AUTO будет пытаться сначала шардировать по FILE,а затем возвращаться к шардингу по DATA,если мы не сможем найти набор файлов на шардинге.</target>
        </trans-unit>
        <trans-unit id="1076c8ce1d97d2aae1dd52bec1be1eb1d7da0726" translate="yes" xml:space="preserve">
          <source>The type of the elements of the resulting tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8bb7b7574042b37e7c6afeec47ae6a75f4b513" translate="yes" xml:space="preserve">
          <source>The type of the elements of the resulting tensor. If not specified, then a value is chosen based on the other args.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed6e689e6786fb190bf4135aa5cf05a31f4f0b3" translate="yes" xml:space="preserve">
          <source>The type of the event samples (default: int32).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0617255d963a3d9373238c1968c00abc24574b" translate="yes" xml:space="preserve">
          <source>The type of the event samples. &lt;code&gt;None&lt;/code&gt; implies no type-enforcement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6ae3861b6b33f7202d6cb04f51d8a43f2ebb83" translate="yes" xml:space="preserve">
          <source>The type of the event samples. Default: &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ac8c9ef31246fab5b3b784f6fdb5ffec2b2eba" translate="yes" xml:space="preserve">
          <source>The type of the op (e.g. &lt;code&gt;&quot;MatMul&quot;&lt;/code&gt;).</source>
          <target state="translated">Тип операции (например, &lt;code&gt;&quot;MatMul&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="067097eae217bc20b817dae41bcd6adaa941c2bf" translate="yes" xml:space="preserve">
          <source>The type of the op that generated the tensor with bad numerics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a9b8c589712a808dd41511f2b9583296c78486" translate="yes" xml:space="preserve">
          <source>The type of the output tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac7350774189c9f4f0f6d153487ae1c0df2dfef" translate="yes" xml:space="preserve">
          <source>The type of the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da83b3257815d9c8a52c8c2fe774ab08e0d4a548" translate="yes" xml:space="preserve">
          <source>The type of the output. Default: tf.int32</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa045fdeece95a6373419965f4b455817b39af60" translate="yes" xml:space="preserve">
          <source>The type of the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27b43df09bda0cc0e4bd074ae7a03dba23972ee" translate="yes" xml:space="preserve">
          <source>The type of the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, or &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8cc4d05affc30251cb4e72ec85d99c502c39e2b" translate="yes" xml:space="preserve">
          <source>The type of the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, or &lt;code&gt;int64&lt;/code&gt;. For unbounded uniform ints (&lt;code&gt;minval&lt;/code&gt;, &lt;code&gt;maxval&lt;/code&gt; both &lt;code&gt;None&lt;/code&gt;), &lt;code&gt;uint32&lt;/code&gt; and &lt;code&gt;uint64&lt;/code&gt; may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2e4f649b30bc99091c2da410cb8448c8ba873a" translate="yes" xml:space="preserve">
          <source>The type of the this &lt;code&gt;LinearOperator&lt;/code&gt;. Arguments to &lt;code&gt;matmul&lt;/code&gt; and &lt;code&gt;solve&lt;/code&gt; will have to be this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e0737155eb6c648136eb7aa61f1f5f53eaee2c" translate="yes" xml:space="preserve">
          <source>The type of the variable. Defaults to &lt;code&gt;self.dtype&lt;/code&gt; or &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89eb9b54cfc1eb5edbdf1804af86410f57c03f40" translate="yes" xml:space="preserve">
          <source>The type of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc791524ffdf48de9024b17fb2e81e72b1743abc" translate="yes" xml:space="preserve">
          <source>The type specification of an element of &lt;a href=&quot;distributediterator&quot;&gt;&lt;code&gt;tf.distribute.DistributedIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586865cdc2362857bdac73e4d9d4aafd45add2e6" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4d546108b4584207f8473dd28294356ddeede5" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this dataset.</source>
          <target state="translated">Типовая спецификация элемента данного набора данных.</target>
        </trans-unit>
        <trans-unit id="31f5cdd5cadead57bcfc00f19cdc637b778a8dfa" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this iterator.</source>
          <target state="translated">Типовая спецификация элемента этого итератора.</target>
        </trans-unit>
        <trans-unit id="31e1b2499af19cb707e87dbc9b32089b65e02169" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce40406c73aa0072207096be99446cc37cd3334" translate="yes" xml:space="preserve">
          <source>The types of the tensors in &lt;code&gt;values&lt;/code&gt; must match the schema for the fields specified in &lt;code&gt;field_names&lt;/code&gt;. All the tensors in &lt;code&gt;values&lt;/code&gt; must have a common shape prefix, &lt;em&gt;batch_shape&lt;/em&gt;.</source>
          <target state="translated">Типы тензоров в &lt;code&gt;values&lt;/code&gt; должны соответствовать схеме для полей, указанных в &lt;code&gt;field_names&lt;/code&gt; . Все тензоры в &lt;code&gt;values&lt;/code&gt; должны иметь общий префикс формы, &lt;em&gt;batch_shape&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e5381b2e579e07c748270f78ee35dd566e3eb442" translate="yes" xml:space="preserve">
          <source>The typical scenario for &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; is to compute moving averages of variables during training, and restore the variables from the computed moving averages during evaluations.</source>
          <target state="translated">Типичный сценарий для &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; заключается в вычислении скользящих средних переменных во время обучения и восстановлении переменных из вычисленных скользящих средних во время оценок.</target>
        </trans-unit>
        <trans-unit id="3da77fbceb0e840441ce8c39192555e97fa2928b" translate="yes" xml:space="preserve">
          <source>The underlying accumulator reference.</source>
          <target state="translated">Ссылка на базовый аккумулятор.</target>
        </trans-unit>
        <trans-unit id="c25ef637b6290d9c594d8a4f22f2ec949aa1bd01" translate="yes" xml:space="preserve">
          <source>The underlying queue reference.</source>
          <target state="translated">Ссылка на основную очередь.</target>
        </trans-unit>
        <trans-unit id="e903c075a80c182337230b41e8fc05a166057ed0" translate="yes" xml:space="preserve">
          <source>The unique &lt;code&gt;frame_name&lt;/code&gt; is used by the &lt;code&gt;Executor&lt;/code&gt; to identify frames. If &lt;code&gt;is_constant&lt;/code&gt; is true, &lt;code&gt;output&lt;/code&gt; is a constant in the child frame; otherwise it may be changed in the child frame. At most &lt;code&gt;parallel_iterations&lt;/code&gt; iterations are run in parallel in the child frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2570833b8fed9aa7ee0f6db077c7e434ab3d563b" translate="yes" xml:space="preserve">
          <source>The unpacked tuple, with &lt;code&gt;None&lt;/code&gt;s for &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;sample_weight&lt;/code&gt; if they are not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25a2d45745d4308947942d9bddb3fe51f90e219" translate="yes" xml:space="preserve">
          <source>The update rule for &lt;code&gt;variable&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; uses an optimization described at the end of section 2 of the paper:</source>
          <target state="translated">Правило обновления для &lt;code&gt;variable&lt;/code&gt; с градиентом &lt;code&gt;g&lt;/code&gt; использует оптимизацию, описанную в конце раздела 2 статьи:</target>
        </trans-unit>
        <trans-unit id="dcaa87717690c893cddcbb06c2774de0d640ef88" translate="yes" xml:space="preserve">
          <source>The update rule for &lt;code&gt;variable&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; uses an optimization described at the end of section 7.1 of the paper:</source>
          <target state="translated">Правило обновления для &lt;code&gt;variable&lt;/code&gt; с градиентом &lt;code&gt;g&lt;/code&gt; использует оптимизацию, описанную в конце раздела 7.1 документа:</target>
        </trans-unit>
        <trans-unit id="0efd76819f39cf3bcb5dd14bc65d8c8c72cef23d" translate="yes" xml:space="preserve">
          <source>The update rule for parameter &lt;code&gt;w&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; is described at the end of section 7.1 of the paper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9901f8d5a239b98ad1f04b6bbdac6a25b5dbe0" translate="yes" xml:space="preserve">
          <source>The updated config has something needed to run a strategy, e.g. configuration to run collective ops, or device filters to improve distributed training performance.</source>
          <target state="translated">Обновленная конфигурация имеет что-то необходимое для запуска стратегии,например,конфигурация для запуска коллективных операций,или фильтры устройств для улучшения производительности распределенного обучения.</target>
        </trans-unit>
        <trans-unit id="60dd7fe2afadb5341f05d411ef207c2859229807" translate="yes" xml:space="preserve">
          <source>The updated copy of the &lt;code&gt;config_proto&lt;/code&gt;.</source>
          <target state="translated">Обновленная копия &lt;code&gt;config_proto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d9e39fd60700bb347ed0039e54d9af3ef5a5100" translate="yes" xml:space="preserve">
          <source>The updated decorator. If decorator_func is not a tf_decorator, new_target is returned.</source>
          <target state="translated">Обновленный декоратор.Если декоратор_func не является tf_decorator,возвращается new_target.</target>
        </trans-unit>
        <trans-unit id="fa6ecd5172af3b96400529c50d0c7eb9f4adaa33" translate="yes" xml:space="preserve">
          <source>The updated variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0ce841932dc29d8f332a4acc96a1313d2133b7" translate="yes" xml:space="preserve">
          <source>The updated variable. If &lt;code&gt;read_value&lt;/code&gt; is false, instead returns None in Eager mode and the assign op in graph mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8daec55baf3c813ce2f2fc4a5eab596ea78fbf" translate="yes" xml:space="preserve">
          <source>The upper regularized incomplete Gamma function is defined as:</source>
          <target state="translated">Верхняя регуляризованная неполная Гамма-функция определена как:</target>
        </trans-unit>
        <trans-unit id="a16fb2ccec6d9e76f7b18eacf6123674146710e7" translate="yes" xml:space="preserve">
          <source>The user could also use &lt;code&gt;make_input_fn_iterator&lt;/code&gt; if they want to customize which input is fed to which replica/worker etc.</source>
          <target state="translated">Пользователь также может использовать &lt;code&gt;make_input_fn_iterator&lt;/code&gt; , если он хочет настроить, какой ввод будет передан какой реплике / работнику и т. Д.</target>
        </trans-unit>
        <trans-unit id="ab789081815c49957f21bd695c2a3924b82c20ff" translate="yes" xml:space="preserve">
          <source>The user is given the option of raising an exception or returning &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Пользователю предоставляется возможность вызвать исключение или вернуть &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d78e502adf2b1729b9f368b8135c69dbb97bac0" translate="yes" xml:space="preserve">
          <source>The usual cross-entropy cost is defined as:</source>
          <target state="translated">Обычная стоимость кросс-энтропии определяется как:</target>
        </trans-unit>
        <trans-unit id="55894b0693429bc52d5ca851ab5e7e50a45cb526" translate="yes" xml:space="preserve">
          <source>The valid keyword arguments in kwds are:</source>
          <target state="translated">В kwds действительны аргументы по ключевым словам:</target>
        </trans-unit>
        <trans-unit id="2e9dcb12c3ec9343c2b4d76ebee61442f18c708d" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;delta&lt;/code&gt; is added to all components of the tensor &lt;code&gt;image&lt;/code&gt;. &lt;code&gt;image&lt;/code&gt; is converted to &lt;code&gt;float&lt;/code&gt; and scaled appropriately if it is in fixed-point representation, and &lt;code&gt;delta&lt;/code&gt; is converted to the same data type. For regular images, &lt;code&gt;delta&lt;/code&gt; should be in the range &lt;code&gt;[0,1)&lt;/code&gt;, as it is added to the image in floating point representation, where pixel values are in the &lt;code&gt;[0,1)&lt;/code&gt; range.</source>
          <target state="translated">&lt;code&gt;delta&lt;/code&gt; значения добавляется ко всем компонентам тензорного &lt;code&gt;image&lt;/code&gt; . &lt;code&gt;image&lt;/code&gt; преобразуется в число с &lt;code&gt;float&lt;/code&gt; и соответствующим образом масштабируется, если оно находится в представлении с фиксированной точкой, а &lt;code&gt;delta&lt;/code&gt; преобразуется в тот же тип данных. Для обычных изображений &lt;code&gt;delta&lt;/code&gt; должна быть в диапазоне &lt;code&gt;[0,1)&lt;/code&gt; , поскольку она добавляется к изображению в представлении с плавающей запятой, где значения пикселей находятся в диапазоне &lt;code&gt;[0,1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0cc40289aaf5ca63368c701a28edf746620f686" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;gt; other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">Значение &lt;code&gt;self.value &amp;gt; other.value&lt;/code&gt; если оба известны, в противном случае - None.</target>
        </trans-unit>
        <trans-unit id="28eee150e3c68dabbd6edcffc1df83846a31e392" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;gt;= other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">Значение &lt;code&gt;self.value &amp;gt;= other.value&lt;/code&gt; если оба известны, в противном случае - None.</target>
        </trans-unit>
        <trans-unit id="1ac388cf68a7917e640172de08cfda57213cf191" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;lt; other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">Значение &lt;code&gt;self.value &amp;lt; other.value&lt;/code&gt; если оба известны, в противном случае - None.</target>
        </trans-unit>
        <trans-unit id="b01cea77304d81c49aa6bfe991a86b9994cc913b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;lt;= other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">Значение &lt;code&gt;self.value &amp;lt;= other.value&lt;/code&gt; если оба известны, в противном случае - None.</target>
        </trans-unit>
        <trans-unit id="97a93b3e6e5220aba9e50c43c510d2bbbc1a87e0" translate="yes" xml:space="preserve">
          <source>The value of such a flag is a list that contains the individual values from all the appearances of that flag on the command-line.</source>
          <target state="translated">Значение такого флага-это список,содержащий отдельные значения из всех появлений этого флага в командной строке.</target>
        </trans-unit>
        <trans-unit id="a54451b41292d69deaf5cd8ce0771065680d134d" translate="yes" xml:space="preserve">
          <source>The value of the attr, as a Python object.</source>
          <target state="translated">Значение аттра,как объекта на питоне.</target>
        </trans-unit>
        <trans-unit id="6e7716dffe6353c157e4a2c3f2e655d155be6b4b" translate="yes" xml:space="preserve">
          <source>The value of the flag is always a list, even if the option was only supplied once, and even if the default value is a single value</source>
          <target state="translated">Значение флага всегда является списком,даже если опция была поставлена только один раз,и даже если значение по умолчанию является одним значением.</target>
        </trans-unit>
        <trans-unit id="f28d312af2bea03bbf52afb2a569177bf8ca705a" translate="yes" xml:space="preserve">
          <source>The value of the flag, empty if the flag is not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8b3cb3b48dec54fd1680c59ba7cefb3dfc3602" translate="yes" xml:space="preserve">
          <source>The value of the variable after the update.</source>
          <target state="translated">Значение переменной после обновления.</target>
        </trans-unit>
        <trans-unit id="d29c684e1056225784225bef1dc61fddd3c411d6" translate="yes" xml:space="preserve">
          <source>The value of this dimension, or None if it is unknown.</source>
          <target state="translated">Значение этого измерения,или Нет,если неизвестно.</target>
        </trans-unit>
        <trans-unit id="dc40d49743dfe15cf0fa34edb80ecfa5afa70d65" translate="yes" xml:space="preserve">
          <source>The value or values returned by &lt;code&gt;map_func&lt;/code&gt; determine the structure of each element in the returned dataset.</source>
          <target state="translated">Значение или значения, возвращаемые &lt;code&gt;map_func&lt;/code&gt; , определяют структуру каждого элемента в возвращаемом наборе данных.</target>
        </trans-unit>
        <trans-unit id="277f6e101a6f4f13a9cc5f1fee440972491084f4" translate="yes" xml:space="preserve">
          <source>The value representing an out-of-vocabulary value. Defaults to -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a9bdb78e692ccca6e6eeacfe9cf8259c37e6d7" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;run()&lt;/code&gt; has the same shape as the &lt;code&gt;fetches&lt;/code&gt; argument, where the leaves are replaced by the corresponding values returned by TensorFlow.</source>
          <target state="translated">Значение, возвращаемое функцией &lt;code&gt;run()&lt;/code&gt; имеет ту же форму, что и аргумент &lt;code&gt;fetches&lt;/code&gt; , где листья заменяются соответствующими значениями, возвращаемыми TensorFlow.</target>
        </trans-unit>
        <trans-unit id="6455c45d9b49b1bb8f4ec9b5dff00531b9342ec2" translate="yes" xml:space="preserve">
          <source>The value returned by the &lt;code&gt;activity_regularizer&lt;/code&gt; is divided by the input batch size so that the relative weighting between the weight regularizers and the activity regularizers does not change with the batch size.</source>
          <target state="translated">Значение, возвращаемое функцией &lt;code&gt;activity_regularizer&lt;/code&gt; , делится на размер входного пакета, так что относительный вес между регуляризаторами веса и регуляризаторами активности не меняется с размером пакета.</target>
        </trans-unit>
        <trans-unit id="e67ea60a1d86085a3a91a8df093188ea7d78231f" translate="yes" xml:space="preserve">
          <source>The value returned by this operation is guaranteed to be influenced by all the writes on which this operation depends directly or indirectly, and to not be influenced by any of the writes which depend directly or indirectly on this operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8a88dac26c441fe66426635dcf33f3ecddba85" translate="yes" xml:space="preserve">
          <source>The value to add to the collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67488a526901c9a4f2769ad17a3b244c04775dbb" translate="yes" xml:space="preserve">
          <source>The value to add to the collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0467f1eec9e713645aba39b382503cafa6ae6856" translate="yes" xml:space="preserve">
          <source>The value to fill for empty rows, with the same type as &lt;code&gt;sp_input.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9729e11273c726456e8e0c3c8e270a5166729e" translate="yes" xml:space="preserve">
          <source>The value to fill the area outside the specified diagonal band with. Default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f548425b8c43bbee75c542b6da5327e5f5f507" translate="yes" xml:space="preserve">
          <source>The value to use if a key is missing in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46cf38cbb0627d0763f0f1b40f1bcbf960cd2dde" translate="yes" xml:space="preserve">
          <source>The values generated are similar to values from a &lt;a href=&quot;randomnormal&quot;&gt;&lt;code&gt;tf.keras.initializers.RandomNormal&lt;/code&gt;&lt;/a&gt; initializer except that values more than two standard deviations from the mean are discarded and re-drawn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61a71eb4077cf30110803e381657708b49ae932" translate="yes" xml:space="preserve">
          <source>The values must include 0. There can be no duplicate values or negative values.</source>
          <target state="translated">Значения должны включать 0.Дублирующих или отрицательных значений быть не может.</target>
        </trans-unit>
        <trans-unit id="1050986413ba8aa09be08e1ada6c99bfa286c827" translate="yes" xml:space="preserve">
          <source>The values not defined in &lt;code&gt;sp_input&lt;/code&gt; don't participate in the reduce max, as opposed to be implicitly assumed 0 -- hence it can return negative values for sparse &lt;code&gt;axis&lt;/code&gt;. But, in case there are no values in &lt;code&gt;axis&lt;/code&gt;, it will reduce to 0. See second example below.</source>
          <target state="translated">Значения, не определенные в &lt;code&gt;sp_input&lt;/code&gt; , не участвуют в уменьшении max, в отличие от неявно предполагаемого 0 - следовательно, он может возвращать отрицательные значения для разреженной &lt;code&gt;axis&lt;/code&gt; . Но, если на &lt;code&gt;axis&lt;/code&gt; нет значений , оно уменьшится до 0. См. Второй пример ниже.</target>
        </trans-unit>
        <trans-unit id="15f0cbbec41c8cec7a1600faa3fd0ba6c8267aeb" translate="yes" xml:space="preserve">
          <source>The values not defined in &lt;code&gt;sp_input&lt;/code&gt; don't participate in the reduce max, as opposed to be implicitly assumed 0 -- hence it can return negative values for sparse &lt;code&gt;reduction_axes&lt;/code&gt;. But, in case there are no values in &lt;code&gt;reduction_axes&lt;/code&gt;, it will reduce to 0. See second example below.</source>
          <target state="translated">Значения, не определенные в &lt;code&gt;sp_input&lt;/code&gt; , не участвуют в уменьшении max, в отличие от неявно предполагаемого 0 - следовательно, он может возвращать отрицательные значения для sparse &lt;code&gt;reduction_axes&lt;/code&gt; . Но, в случае, если нет значения в &lt;code&gt;reduction_axes&lt;/code&gt; , она уменьшится до 0. См второго примера ниже.</target>
        </trans-unit>
        <trans-unit id="01b28056c2bd0c58a2e89c42fd350d1a9e497580" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are chosen so that the mean and variance of the inputs are preserved between two consecutive layers as long as the weights are initialized correctly (see &lt;a href=&quot;../initializers/lecun_normal&quot;&gt;&lt;code&gt;lecun_normal&lt;/code&gt; initialization&lt;/a&gt;) and the number of inputs is &quot;large enough&quot; (see references for more information).</source>
          <target state="translated">Значения &lt;code&gt;alpha&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; выбираются таким образом, чтобы среднее значение и дисперсия входных данных сохранялись между двумя последовательными слоями, пока веса инициализированы правильно (см. &lt;a href=&quot;../initializers/lecun_normal&quot;&gt;Инициализацию &lt;/a&gt; &lt;code&gt;lecun_normal&lt;/code&gt; ) и количество входов &amp;laquo;достаточно велико&amp;raquo; (см. Ссылки для больше информации).</target>
        </trans-unit>
        <trans-unit id="64ea94b6b8cce4972e532c22a39ade0ab1c04bbd" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are chosen so that the mean and variance of the inputs are preserved between two consecutive layers as long as the weights are initialized correctly (see &lt;a href=&quot;../initializers/lecunnormal&quot;&gt;&lt;code&gt;tf.keras.initializers.LecunNormal&lt;/code&gt;&lt;/a&gt; initializer) and the number of input units is &quot;large enough&quot; (see reference paper for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f733a02fe3b03768ab1ca9ec4da3805a1ad4b791" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;value&lt;/code&gt; are assigned to the positions in the tensor &lt;code&gt;input&lt;/code&gt; that are selected by the slice parameters. The slice parameters &lt;code&gt;begin&lt;/code&gt;&lt;code&gt;end&lt;/code&gt;&lt;code&gt;strides&lt;/code&gt; etc. work exactly as in &lt;code&gt;StridedSlice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39cb348464cd40ba244caddc3b9020cc754ba4b" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;value&lt;/code&gt; are assigned to the positions in the variable &lt;code&gt;ref&lt;/code&gt; that are selected by the slice parameters. The slice parameters &lt;code&gt;begin,&lt;/code&gt;end&lt;code&gt;,&lt;/code&gt;strides&lt;code&gt;, etc. work exactly as in&lt;/code&gt;StridedSlice`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2d5c98a3c37925f071ae528d2a1426fcf8d79c" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;value&lt;/code&gt; are assigned to the positions in the variable &lt;code&gt;ref&lt;/code&gt; that are selected by the slice parameters. The slice parameters &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;strides&lt;/code&gt;, etc. work exactly as in &lt;code&gt;StridedSlice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823a169cfff816da0e0ed79e7aa0fca33f12184b" translate="yes" xml:space="preserve">
          <source>The values to be used in the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340b53ddcc61e1600456fa6a942b3a9db9dcd7f4" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; updated.</source>
          <target state="translated">Переменная &lt;code&gt;x&lt;/code&gt; обновлена.</target>
        </trans-unit>
        <trans-unit id="9b98520ded5c59855ccbb91e15451f218e4fed8a" translate="yes" xml:space="preserve">
          <source>The variable corresponding to &lt;code&gt;input_&lt;/code&gt; or None</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58067393f30493e389388e4808eed6d24490c13" translate="yes" xml:space="preserve">
          <source>The variable dtype of this policy, or None if the variable dtype should be inferred from the inputs.</source>
          <target state="translated">Тип переменной d этой политики,или None,если тип переменной d должен быть выведен из входных данных.</target>
        </trans-unit>
        <trans-unit id="bb822034c75bacc81fb53dec6e4b25c54f49ac48" translate="yes" xml:space="preserve">
          <source>The variable dtype of this policy.</source>
          <target state="translated">Тип переменной d этой политики.</target>
        </trans-unit>
        <trans-unit id="cf801794eaaba6ef2f8f7f433ed37a63d7d2327d" translate="yes" xml:space="preserve">
          <source>The variance for Student's T equals</source>
          <target state="translated">Разница для Студента Т равна</target>
        </trans-unit>
        <trans-unit id="d641778ea2685b7b78fd228569c0026aa6abdc9c" translate="yes" xml:space="preserve">
          <source>The vocabulary file name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde4cff8a5ecda6c3308cd587b5940a27adec93c" translate="yes" xml:space="preserve">
          <source>The vocabulary file should be in CSV-like format, with the last field being the weight associated with the word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1063f666d548cfe042252b2f4239aa647a4b8506" translate="yes" xml:space="preserve">
          <source>The weights of a layer represent the state of the layer. This function returns both trainable and non-trainable weight values associated with this layer as a list of Numpy arrays, which can in turn be used to load state into similarly parameterized layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4e9211223da35fb0cefc91c559dd39cd92d9f5" translate="yes" xml:space="preserve">
          <source>The weights of a layer represent the state of the layer. This function sets the weight values from numpy arrays. The weight values should be passed in the order they are created by the layer. Note that the layer's weights must be instantiated before calling this function by calling the layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9c5e7f6fe29d5feb4e712a5efa9aacc5795ce1" translate="yes" xml:space="preserve">
          <source>The weights of an optimizer are its state (ie, variables). This function returns the weight values associated with this optimizer as a list of Numpy arrays. The first value is always the iterations count of the optimizer, followed by the optimizer's state variables in the order they were created. The returned list can in turn be used to load state into similarly parameterized optimizers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbc3d68ba3835fc93e47564b7ed4f1325c6e8cd" translate="yes" xml:space="preserve">
          <source>The weights of an optimizer are its state (ie, variables). This function takes the weight values associated with this optimizer as a list of Numpy arrays. The first value is always the iterations count of the optimizer, followed by the optimizer's state variables in the order they are created. The passed values are used to set the new state of the optimizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e91da427b6cf2b2fbc5ac9447fe8b24dd8aa82" translate="yes" xml:space="preserve">
          <source>The width the output tensor is &lt;code&gt;input_depth * block_size&lt;/code&gt;, whereas the height is &lt;code&gt;input_height * block_size&lt;/code&gt;.</source>
          <target state="translated">Ширина выходного тензора - &lt;code&gt;input_depth * block_size&lt;/code&gt; , а высота - &lt;code&gt;input_height * block_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a165b5ce96be1f52d9f7edf6d8a65c227dd997f" translate="yes" xml:space="preserve">
          <source>The width(s) of the ngrams to create. If this is a list or tuple, the op will return ngrams of all specified arities in list order. Values must be non-Tensor integers greater than 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fda38eef982ddecbfd2142c00746b57a76815b" translate="yes" xml:space="preserve">
          <source>The word index dictionary.</source>
          <target state="translated">Словарь словарного индекса.</target>
        </trans-unit>
        <trans-unit id="524d27d9a78ab988dfdffc5a8ddf699fa93cbe93" translate="yes" xml:space="preserve">
          <source>The word index dictionary. Keys are word strings, values are their index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273384d93f6363b2a2a4c34767e0268890f5d5af" translate="yes" xml:space="preserve">
          <source>The wrapped input tensor.</source>
          <target state="translated">Завернутый входной тензор.</target>
        </trans-unit>
        <trans-unit id="e4a82e3bb086ae7e63715facddf72f40e0765006" translate="yes" xml:space="preserve">
          <source>The wrapped output tensor.</source>
          <target state="translated">Завернутый выходной тензор.</target>
        </trans-unit>
        <trans-unit id="52457270e7a01e13ee00378b3108ea8fc12315e0" translate="yes" xml:space="preserve">
          <source>The wrapped value.</source>
          <target state="translated">Завернутое значение.</target>
        </trans-unit>
        <trans-unit id="bb274ffefe3874a86b65898ba52aa9be06563172" translate="yes" xml:space="preserve">
          <source>The wrapper function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c29d607aec40364caa8044d1b086cb311bf2d17" translate="yes" xml:space="preserve">
          <source>Theano-like behavior example</source>
          <target state="translated">Теано-образный пример поведения</target>
        </trans-unit>
        <trans-unit id="c3d562c283b894723caae359b0851a3c4fb15dc1" translate="yes" xml:space="preserve">
          <source>Then calling &lt;code&gt;image_dataset_from_directory(main_directory, labels='inferred')&lt;/code&gt; will return a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; that yields batches of images from the subdirectories &lt;code&gt;class_a&lt;/code&gt; and &lt;code&gt;class_b&lt;/code&gt;, together with labels 0 and 1 (0 corresponding to &lt;code&gt;class_a&lt;/code&gt; and 1 corresponding to &lt;code&gt;class_b&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5fae7664a9f8954314f95eaa134030803e80ccc" translate="yes" xml:space="preserve">
          <source>Then calling &lt;code&gt;text_dataset_from_directory(main_directory, labels='inferred')&lt;/code&gt; will return a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; that yields batches of texts from the subdirectories &lt;code&gt;class_a&lt;/code&gt; and &lt;code&gt;class_b&lt;/code&gt;, together with labels 0 and 1 (0 corresponding to &lt;code&gt;class_a&lt;/code&gt; and 1 corresponding to &lt;code&gt;class_b&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb44a39f5e3304ba1e47cd9001107c1190200e02" translate="yes" xml:space="preserve">
          <source>Then output is &lt;code&gt;[2 x 2 x 3]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70803c29e37a6cdd022ef83164306a19f47318ca" translate="yes" xml:space="preserve">
          <source>Then output is &lt;code&gt;[3 x 4]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609a89b6f4ea61b7d43929c28cac3cb16c1a8704" translate="yes" xml:space="preserve">
          <source>Then output is &lt;code&gt;[4 x 3]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6380335743da8e76766d68f136c813dfdf80835" translate="yes" xml:space="preserve">
          <source>Then the final line will print out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d073abde2a1df4b5c62a21448d955ee1c50a80df" translate="yes" xml:space="preserve">
          <source>Then the output is a dictionary:</source>
          <target state="translated">Тогда на выходе-словарь:</target>
        </trans-unit>
        <trans-unit id="4c6244085178ac4f66fb4367c44b652758bf26c2" translate="yes" xml:space="preserve">
          <source>Then you can run a &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt; operation only on logical device 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77a2ae4d69da67530e4f97b9e84f16f29f79cdf" translate="yes" xml:space="preserve">
          <source>Then,</source>
          <target state="translated">Then,</target>
        </trans-unit>
        <trans-unit id="18c6dda9e31a83fdb5a90169c27005c658e8056f" translate="yes" xml:space="preserve">
          <source>Then, row_pooling_sequence should satisfy:</source>
          <target state="translated">Тогда,строка_пулинг_последовательность должна удовлетворять:</target>
        </trans-unit>
        <trans-unit id="3debd4416d24691c45dc01b19b3489468194d8c2" translate="yes" xml:space="preserve">
          <source>There are a number of questions to ask in the decision process, including:</source>
          <target state="translated">В процессе принятия решения необходимо задать ряд вопросов,в том числе:</target>
        </trans-unit>
        <trans-unit id="6f58afb7ffb8a1e95bc14a4cccd59e26c144fddb" translate="yes" xml:space="preserve">
          <source>There are a number of requirements on what needs to happen inside the scope. However, in places where we have information about which strategy is in use, we often enter the scope for the user, so they don't have to do it explicitly (i.e. calling those either inside or outside the scope is OK).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0dc8d396849561a849ade939c069a913c651243" translate="yes" xml:space="preserve">
          <source>There are different ways to quantize. This version uses only scaling, so 0.0 maps to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372d16d9e0a1868251f75c59e5f513839dddd179" translate="yes" xml:space="preserve">
          <source>There are many different ways to implement atrous convolution (see the refs above). The implementation here reduces</source>
          <target state="translated">Существует много различных способов реализации атронной свертки (см.ссылки выше).Реализация здесь снижает</target>
        </trans-unit>
        <trans-unit id="4b4c86e082be3a02799da3aa4833e74149042874" translate="yes" xml:space="preserve">
          <source>There are nodes like Identity and CheckNumerics that are only useful during training, and can be removed in graphs that will be used for nothing but inference. Here we identify and remove them, returning an equivalent graph. To be specific, CheckNumerics nodes are always removed, and Identity nodes that aren't involved in control edges are spliced out so that their input and outputs are directly connected.</source>
          <target state="translated">Есть такие узлы,как Identity и CheckNumerics,которые полезны только во время обучения,и могут быть удалены на графиках,которые будут использоваться только для умозаключений.Здесь мы идентифицируем и удаляем их,возвращая эквивалентный график.Если быть точным,то узлы CheckNumerics всегда удаляются,а узлы Identity,не вовлеченные в контрольные фронты,сращиваются таким образом,что их входы и выходы напрямую соединяются друг с другом.</target>
        </trans-unit>
        <trans-unit id="a4fe5597954ba439b4679d614be0e1e5164b606b" translate="yes" xml:space="preserve">
          <source>There are several delicate issues when running multiple threads that way: closing the queues in sequence as the input is exhausted, correctly catching and reporting exceptions, etc.</source>
          <target state="translated">Таким образом,при запуске нескольких потоков возникает несколько деликатных проблем:последовательное закрытие очередей по мере исчерпания входных данных,корректный перехват и сообщение об исключениях и т.д.</target>
        </trans-unit>
        <trans-unit id="20bc80fe9d0b075a12bc0575d2ba4a5d5fe1269d" translate="yes" xml:space="preserve">
          <source>There are several ways to run the conversion:</source>
          <target state="translated">Есть несколько способов запустить преобразование:</target>
        </trans-unit>
        <trans-unit id="9a0c34e11b24dd273612b5e842b9ca3db6c2dc5f" translate="yes" xml:space="preserve">
          <source>There are three important concepts associated with TensorFlow Distributions shapes:</source>
          <target state="translated">Существуют три важные концепции,связанные с формами распределений TensorFlow:</target>
        </trans-unit>
        <trans-unit id="d89ee0299ae366416b4bb7507b2e32a19b6a4278" translate="yes" xml:space="preserve">
          <source>There are two APIs to create a &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; object: &lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset(dataset)&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function(dataset_fn)&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;When to use which?&lt;/em&gt; When you have a &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; instance, and the regular batch splitting (i.e. re-batch the input &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; instance with a new batch size that is equal to the global batch size divided by the number of replicas in sync) and autosharding (i.e. the &lt;a href=&quot;../data/experimental/autoshardpolicy&quot;&gt;&lt;code&gt;tf.data.experimental.AutoShardPolicy&lt;/code&gt;&lt;/a&gt; options) work for you, use the former API. Otherwise, if you are &lt;em&gt;not&lt;/em&gt; using a canonical &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; instance, or you would like to customize the batch splitting or sharding, you can wrap these logic in a &lt;code&gt;dataset_fn&lt;/code&gt; and use the latter API. Both API handles prefetch to device for the user. For more details and examples, follow the links to the APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8f13eb2103d67ac4feee46d41de0d462019931" translate="yes" xml:space="preserve">
          <source>There are two main usages of a &lt;code&gt;DistributedDataset&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3536015a851856ea989836d31de530e9b064da8c" translate="yes" xml:space="preserve">
          <source>There are two means to control the logging verbosity:</source>
          <target state="translated">Есть два способа контролировать лесозаготовительные глаголы:</target>
        </trans-unit>
        <trans-unit id="93dc11cfab5744c0fd203945e6587a775aa790bd" translate="yes" xml:space="preserve">
          <source>There are two modes under which the &lt;code&gt;TPUEmbedding&lt;/code&gt; class can used. This depends on if the class was created under a &lt;code&gt;TPUStrategy&lt;/code&gt; scope or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe77a90ab442852a7e0e410775f1f4aa154097a" translate="yes" xml:space="preserve">
          <source>There are two possible return values, &quot;google&quot; (when TensorFlow is running in a Google-internal environment) or an empty string (when TensorFlow is running elsewhere).</source>
          <target state="translated">Существует два возможных возвращаемых значения:&quot;google&quot; (когда TensorFlow запущен во внутренней среде Google)или пустая строка (когда TensorFlow запущен в другом месте).</target>
        </trans-unit>
        <trans-unit id="c121ae8dd46f0cedd4d9939e53220e70d1795c85" translate="yes" xml:space="preserve">
          <source>There are two questions to ask in the decision process: Do you need gradients computed as sparse too? Is your sparse data represented as two &lt;code&gt;SparseTensor&lt;/code&gt;s: ids and values? There is more explanation about data format below. If you answer any of these questions as yes, consider using &lt;a href=&quot;../nn/embedding_lookup_sparse&quot;&gt;&lt;code&gt;tf.nn.embedding_lookup_sparse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В процессе принятия решения нужно задать два вопроса: нужны ли вам градиенты, вычисляемые как разреженные? Представлены ли ваши разреженные данные в виде двух &lt;code&gt;SparseTensor&lt;/code&gt; : идентификаторов и значений? Ниже приводится более подробное объяснение формата данных. Если вы ответили на любой из этих вопросов утвердительно, подумайте об использовании &lt;a href=&quot;../nn/embedding_lookup_sparse&quot;&gt; &lt;code&gt;tf.nn.embedding_lookup_sparse&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0878716bd35f31f600ff16927cc66d2e1bdcca8d" translate="yes" xml:space="preserve">
          <source>There are two variants of the GRU implementation. The default one is based on &lt;a href=&quot;https://arxiv.org/abs/1406.1078v3&quot;&gt;v3&lt;/a&gt; and has reset gate applied to hidden state before matrix multiplication. The other one is based on &lt;a href=&quot;https://arxiv.org/abs/1406.1078v1&quot;&gt;original&lt;/a&gt; and has the order reversed.</source>
          <target state="translated">Есть два варианта реализации ГРУ. Значение по умолчанию основано на &lt;a href=&quot;https://arxiv.org/abs/1406.1078v3&quot;&gt;v3,&lt;/a&gt; и перед умножением матриц применяется сброс ворот к скрытому состоянию. Другой основан на &lt;a href=&quot;https://arxiv.org/abs/1406.1078v1&quot;&gt;оригинале&lt;/a&gt; и имеет обратный порядок.</target>
        </trans-unit>
        <trans-unit id="f3d0da97f844d09b6bac8339000119f443c41934" translate="yes" xml:space="preserve">
          <source>There are two variants. The default one is based on 1406.1078v3 and has reset gate applied to hidden state before matrix multiplication. The other one is based on original 1406.1078v1 and has the order reversed.</source>
          <target state="translated">Есть два варианта.По умолчанию один из них основан на 1406.1078v3 и имеет функцию сброса затвора,примененную к скрытому состоянию до умножения матриц.Другой основан на оригинальном 1406.1078v1 и имеет обратный порядок.</target>
        </trans-unit>
        <trans-unit id="f1e5ef8034bae35c3455bef5218f7a32bbdb1aa7" translate="yes" xml:space="preserve">
          <source>There are two versions of the API: 1 or 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c11322b50f362088a37650ccaf3b2e479b115a" translate="yes" xml:space="preserve">
          <source>There are two versions of the API: ExportSavedModelApiVersion.V1 and V2.</source>
          <target state="translated">Существует две версии API:ExportSavedModelApiVersion.V1 и V2.</target>
        </trans-unit>
        <trans-unit id="c409af06e5c37c31d5d6e63ae53409968bb739b2" translate="yes" xml:space="preserve">
          <source>There are two ways to create decorators that TensorFlow can introspect into. This is important for documentation generation purposes, so that function signatures aren't obscured by the (*args, **kwds) signature that decorators often provide.</source>
          <target state="translated">Существует два способа создания декораторов,в которые TensorFlow может провести интроспекцию.Это важно для создания документации,чтобы сигнатуры функций не заслонялись подписью (*args,**kwds),которую часто предоставляют декораторы.</target>
        </trans-unit>
        <trans-unit id="49196c8dfb0588201d8b9733a14917623170a741" translate="yes" xml:space="preserve">
          <source>There are two ways to instantiate a &lt;code&gt;Model&lt;/code&gt;:</source>
          <target state="translated">Есть два способа создать экземпляр &lt;code&gt;Model&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a3e498654dcff830e5be467e55fbbbbc20e2910f" translate="yes" xml:space="preserve">
          <source>There are two ways to use the moving averages for evaluations:</source>
          <target state="translated">Существуют два способа использования скользящих средних для оценок:</target>
        </trans-unit>
        <trans-unit id="14b50269ad70f1441184d03f5b9e983ae0e09462" translate="yes" xml:space="preserve">
          <source>There is a special node with &lt;code&gt;task_type&lt;/code&gt; as &lt;code&gt;evaluator&lt;/code&gt;, which is not part of the (training) &lt;code&gt;cluster_spec&lt;/code&gt;. It handles the distributed evaluation job.</source>
          <target state="translated">Существует специальный узел с &lt;code&gt;task_type&lt;/code&gt; в качестве &lt;code&gt;evaluator&lt;/code&gt; , который не является частью (обучающей) &lt;code&gt;cluster_spec&lt;/code&gt; . Он выполняет распределенную оценку.</target>
        </trans-unit>
        <trans-unit id="ff5a342ad76b4f6dbc02bde4742c1939d0847ee4" translate="yes" xml:space="preserve">
          <source>There is also a global generator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a273890eb3544a6c0002e05e862f10bbfd245d" translate="yes" xml:space="preserve">
          <source>There is an equivalent description in terms of the [batch] spectrum &lt;code&gt;H&lt;/code&gt; and Fourier transforms. Here we consider &lt;code&gt;A.shape = [N, N]&lt;/code&gt; and ignore batch dimensions.</source>
          <target state="translated">Имеется эквивалентное описание в терминах [пакетного] спектра &lt;code&gt;H&lt;/code&gt; и преобразований Фурье. Здесь мы &lt;code&gt;A.shape = [N, N]&lt;/code&gt; и игнорируем размеры партии.</target>
        </trans-unit>
        <trans-unit id="34b53209d83711d378deaa8b481a2f90355eb0e3" translate="yes" xml:space="preserve">
          <source>There is an equivalent description in terms of the [batch] spectrum &lt;code&gt;H&lt;/code&gt; and Fourier transforms. Here we consider &lt;code&gt;A.shape = [N, N]&lt;/code&gt; and ignore batch dimensions. Define the discrete Fourier transform (DFT) and its inverse by</source>
          <target state="translated">Имеется эквивалентное описание в терминах [пакетного] спектра &lt;code&gt;H&lt;/code&gt; и преобразований Фурье. Здесь мы &lt;code&gt;A.shape = [N, N]&lt;/code&gt; и игнорируем размеры партии. Определим дискретное преобразование Фурье (ДПФ) и его обратное как</target>
        </trans-unit>
        <trans-unit id="70db84bf8987013d7aeb820bf2eec70af7a073ca" translate="yes" xml:space="preserve">
          <source>There is no need to delete the directory after the test.</source>
          <target state="translated">Нет необходимости удалять каталог после тестирования.</target>
        </trans-unit>
        <trans-unit id="897a9d5198f512dcaeb305f37bd31486ee120960" translate="yes" xml:space="preserve">
          <source>There is no transformation in the &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; Python API for creating this dataset. Instead, it is created as a result of the &lt;code&gt;filter_with_random_uniform_fusion&lt;/code&gt; static optimization. Whether this optimization is performed is determined by the &lt;code&gt;experimental_optimization.filter_with_random_uniform_fusion&lt;/code&gt; option of &lt;a href=&quot;../data/options&quot;&gt;&lt;code&gt;tf.data.Options&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b246461630b3c81ed498d37ca7dc4b93263133aa" translate="yes" xml:space="preserve">
          <source>There is often a need to lift variable initialization ops out of control-flow scopes, function-building graphs, and gradient tapes. Entering an &lt;code&gt;init_scope&lt;/code&gt; is a mechanism for satisfying these desiderata. In particular, entering an &lt;code&gt;init_scope&lt;/code&gt; has three effects:</source>
          <target state="translated">Часто возникает необходимость вывести операции инициализации переменных из областей потока управления, графиков построения функций и градиентных лент. Ввод &lt;code&gt;init_scope&lt;/code&gt; - это механизм для удовлетворения этих желаний. В частности, ввод &lt;code&gt;init_scope&lt;/code&gt; имеет три эффекта:</target>
        </trans-unit>
        <trans-unit id="9600bed3adf3351d3b6785f43a000c7d51f5ddee" translate="yes" xml:space="preserve">
          <source>There is one exception: if the final (i.e., innermost) element(s) of &lt;code&gt;partitions&lt;/code&gt; are &lt;code&gt;UniformRowLength&lt;/code&gt;s, then the values are simply reshaped (as a higher-dimensional &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;), rather than being wrapped in a &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Есть одно исключение: если последний (т. &lt;code&gt;UniformRowLength&lt;/code&gt; внутренний) элемент (-ы) &lt;code&gt;partitions&lt;/code&gt; - это UniformRowLength s, то значения просто изменяются (как многомерный &lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; ), а не обертываются в &lt;a href=&quot;../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0e762e9fe47e7a8aaa65fed7f11b0b738414c89" translate="yes" xml:space="preserve">
          <source>There should be no data dependency between the different semantic invocations of &lt;code&gt;fn&lt;/code&gt;, i.e. it should be safe to map the elements of the inputs in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f7128e30301479f7dbfc0ac8f483f3d6d00a4d" translate="yes" xml:space="preserve">
          <source>Therefore we introduce some decoupling using a queue. The queue contains the work units and the Reader dequeues from the queue when it is asked to produce a record (via Read()) but it has finished the last work unit.</source>
          <target state="translated">Поэтому мы вводим развязку с помощью очереди.Очередь содержит рабочие элементы и Читатель выводит из очереди,когда его просят произвести запись (с помощью функции Read()),но он закончил последний рабочий элемент.</target>
        </trans-unit>
        <trans-unit id="86cd25893d67c9049a975fb7c203728b1fcc6c8b" translate="yes" xml:space="preserve">
          <source>These are arguments passed to the optimizer subclass constructor (the &lt;code&gt;__init__&lt;/code&gt; method), and then passed to &lt;code&gt;self._set_hyper()&lt;/code&gt;. They can be either regular Python values (like 1.0), tensors, or callables. If they are callable, the callable will be called during &lt;code&gt;apply_gradients()&lt;/code&gt; to get the value for the hyper parameter.</source>
          <target state="translated">Это аргументы, переданные конструктору подкласса оптимизатора ( метод &lt;code&gt;__init__&lt;/code&gt; ), а затем переданные в &lt;code&gt;self._set_hyper()&lt;/code&gt; . Это могут быть обычные значения Python (например, 1.0), тензоры или вызываемые объекты. Если они вызываемые, вызываемые &lt;code&gt;apply_gradients()&lt;/code&gt; будут вызываться во время apply_gradients () для получения значения гиперпараметра.</target>
        </trans-unit>
        <trans-unit id="d1eefae8eebd09f04dd361373c7c577f0cf1144d" translate="yes" xml:space="preserve">
          <source>These conversion options are experimental. They are subject to change without notice and offer no guarantees.</source>
          <target state="translated">Эти варианты преобразования являются экспериментальными.Они могут быть изменены без предварительного уведомления и не дают никаких гарантий.</target>
        </trans-unit>
        <trans-unit id="c291964ed47da0b87e8a53387f07ca95b28e890c" translate="yes" xml:space="preserve">
          <source>These indices specify where the values for each row begin in &lt;code&gt;self.values&lt;/code&gt;. &lt;code&gt;rt.row_starts()&lt;/code&gt; is equal to &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt;.</source>
          <target state="translated">Эти индексы указывают, где значения для каждой строки начинаются в &lt;code&gt;self.values&lt;/code&gt; . &lt;code&gt;rt.row_starts()&lt;/code&gt; совпадает с &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99b0058dc30c77b214aebabddab907af2da4a216" translate="yes" xml:space="preserve">
          <source>These indices specify where the values for each row end in &lt;code&gt;self.values&lt;/code&gt;. &lt;code&gt;rt.row_limits(self)&lt;/code&gt; is equal to &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt;.</source>
          <target state="translated">Эти индексы указывают, где значения для каждой строки заканчиваются на &lt;code&gt;self.values&lt;/code&gt; . &lt;code&gt;rt.row_limits(self)&lt;/code&gt; равно &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23fdcaa94183d818b1595f88d3e5484cc7528a37" translate="yes" xml:space="preserve">
          <source>These layers expose 3 keyword arguments:</source>
          <target state="translated">Эти слои выставляют 3 аргумента по ключевым словам:</target>
        </trans-unit>
        <trans-unit id="76c2c66d43654cd0b29da8b2ca646058c82ed16b" translate="yes" xml:space="preserve">
          <source>These might be stored sparsely in the following Example protos by storing only the feature ids (column number if the vectors are treated as a matrix) of the non-zero elements and the corresponding values:</source>
          <target state="translated">Они могут храниться редко в следующих Примерах прототипов,сохраняя только идентификаторы признаков (номер столбца,если векторы рассматриваются как матрица)ненулевых элементов и соответствующие значения:</target>
        </trans-unit>
        <trans-unit id="e47f03b2a63c4e509a81c6c7d3f37f7d1be1a857" translate="yes" xml:space="preserve">
          <source>These sufficient statistics are computed using the one pass algorithm on an input that's optionally shifted. See: &lt;a href=&quot;https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data&quot;&gt;https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0616278e0670c1f8a838c05616c2906a5ad628" translate="yes" xml:space="preserve">
          <source>These sufficient statistics are computed using the one pass algorithm on an input that's optionally shifted. See: https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</source>
          <target state="translated">Эта достаточная статистика вычисляется по алгоритму одного прохода на входе,который опционально сдвинут.См.:https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data.</target>
        </trans-unit>
        <trans-unit id="5c983cdacd0a0593413a5e4ab438ec1b6414a3f5" translate="yes" xml:space="preserve">
          <source>These typically correspond to model heads.</source>
          <target state="translated">Обычно они соответствуют модельным головкам.</target>
        </trans-unit>
        <trans-unit id="a2e13849b656ad081d144e8fb21e76af2be31973" translate="yes" xml:space="preserve">
          <source>These values are similar to values from a &lt;code&gt;random_normal_initializer&lt;/code&gt; except that values more than two standard deviations from the mean are discarded and re-drawn. This is the recommended initializer for neural network weights and filters.</source>
          <target state="translated">Эти значения аналогичны значениям из &lt;code&gt;random_normal_initializer&lt;/code&gt; , за исключением того, что значения, превышающие два стандартных отклонения от среднего, отбрасываются и перерисовываются. Это рекомендуемый инициализатор для весов и фильтров нейронной сети.</target>
        </trans-unit>
        <trans-unit id="6f69d15ae681fb68548cb2f0cf5da97b8f2f416c" translate="yes" xml:space="preserve">
          <source>They are not resettable. Once a one-shot iterator reaches the end of its underlying dataset, subsequent &quot;IteratorGetNext&quot; operations on that iterator will always produce an &lt;code&gt;OutOfRange&lt;/code&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a7de6a736dfa8a46716669d941754c78b26714" translate="yes" xml:space="preserve">
          <source>They do not support parameterization: all logic for creating the underlying dataset must be bundled in the &lt;code&gt;dataset_factory&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035fa9e40dd64ae60fe7c5634de4cc5ea73a82db" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized to have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; by providing &lt;code&gt;spectrum&lt;/code&gt;, a &lt;code&gt;[B1,...,Bb, N0, N1, N2]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;N0*N1*N2 = N&lt;/code&gt;.</source>
          <target state="translated">Это &lt;code&gt;LinearOperator&lt;/code&gt; инициализируется , чтобы иметь форму &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; , предоставляя &lt;code&gt;spectrum&lt;/code&gt; , A &lt;code&gt;[B1,...,Bb, N0, N1, N2]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; с &lt;code&gt;N0*N1*N2 = N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dc76893f409505eb4af8e3ca9d9b50f0907d32c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized to have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; by providing &lt;code&gt;spectrum&lt;/code&gt;, a &lt;code&gt;[B1,...,Bb, N0, N1]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;N0*N1 = N&lt;/code&gt;.</source>
          <target state="translated">Это &lt;code&gt;LinearOperator&lt;/code&gt; инициализируется , чтобы иметь форму &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; , предоставляя &lt;code&gt;spectrum&lt;/code&gt; , A &lt;code&gt;[B1,...,Bb, N0, N1]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; с &lt;code&gt;N0*N1 = N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45faa2260146699c38e2dafd91d1b8425180a30a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized to have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; by providing &lt;code&gt;spectrum&lt;/code&gt;, a &lt;code&gt;[B1,...,Bb, N]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">Этот &lt;code&gt;LinearOperator&lt;/code&gt; инициализируется, чтобы иметь форму &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; путем предоставления &lt;code&gt;spectrum&lt;/code&gt; , &lt;code&gt;Tensor&lt;/code&gt; &lt;code&gt;[B1,...,Bb, N]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14d38c8190663bcf5aee0e569e1c9fa815f97d9a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized with boolean flags of the form &lt;code&gt;is_X&lt;/code&gt;, for &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt;. These have the following meaning</source>
          <target state="translated">Этот &lt;code&gt;LinearOperator&lt;/code&gt; инициализируется логическими флагами формы &lt;code&gt;is_X&lt;/code&gt; , для &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt; . Они имеют следующее значение</target>
        </trans-unit>
        <trans-unit id="59e2aeacdf121218eb0206f7223d277271e20ff4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized with boolean flags of the form &lt;code&gt;is_X&lt;/code&gt;, for &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt;. These have the following meaning:</source>
          <target state="translated">Этот &lt;code&gt;LinearOperator&lt;/code&gt; инициализируется логическими флагами формы &lt;code&gt;is_X&lt;/code&gt; , для &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt; . Они имеют следующее значение:</target>
        </trans-unit>
        <trans-unit id="c893a77a5cadc49b62c18f0fba68970cb1dcbaf6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized with boolean flags of the form &lt;code&gt;is_X&lt;/code&gt;, for &lt;code&gt;X = non_singular&lt;/code&gt;, &lt;code&gt;self_adjoint&lt;/code&gt;, &lt;code&gt;positive_definite&lt;/code&gt;, &lt;code&gt;diag_update_positive&lt;/code&gt; and &lt;code&gt;square&lt;/code&gt;. These have the following meaning:</source>
          <target state="translated">Этот &lt;code&gt;LinearOperator&lt;/code&gt; инициализируется логическими флагами формы &lt;code&gt;is_X&lt;/code&gt; , для &lt;code&gt;X = non_singular&lt;/code&gt; , &lt;code&gt;self_adjoint&lt;/code&gt; , &lt;code&gt;positive_definite&lt;/code&gt; , &lt;code&gt;diag_update_positive&lt;/code&gt; и &lt;code&gt;square&lt;/code&gt; . Они имеют следующее значение:</target>
        </trans-unit>
        <trans-unit id="1af767d14077ff11d4e7fc9b014e22bbf1d448de" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Model&lt;/code&gt; has a dependency named &quot;input_transform&quot; on its &lt;code&gt;Dense&lt;/code&gt; layer, which in turn depends on its variables. As a result, saving an instance of &lt;code&gt;Regress&lt;/code&gt; using &lt;a href=&quot;../../../train/checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt; will also save all the variables created by the &lt;code&gt;Dense&lt;/code&gt; layer.</source>
          <target state="translated">Эта &lt;code&gt;Model&lt;/code&gt; имеет зависимость под названием input_transform от своего &lt;code&gt;Dense&lt;/code&gt; - слоя, который, в свою очередь, зависит от ее переменных. В результате сохранение экземпляра &lt;code&gt;Regress&lt;/code&gt; с использованием &lt;a href=&quot;../../../train/checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt; также сохранит все переменные, созданные слоем &lt;code&gt;Dense&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bb0cfce4d3ef61c634cae7fd40aef46d6d26e65" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Model&lt;/code&gt; has a dependency named &quot;input_transform&quot; on its &lt;code&gt;Dense&lt;/code&gt; layer, which in turn depends on its variables. As a result, saving an instance of &lt;code&gt;Regress&lt;/code&gt; using &lt;a href=&quot;checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt; will also save all the variables created by the &lt;code&gt;Dense&lt;/code&gt; layer.</source>
          <target state="translated">Эта &lt;code&gt;Model&lt;/code&gt; имеет зависимость под названием input_transform от своего &lt;code&gt;Dense&lt;/code&gt; - слоя, который, в свою очередь, зависит от ее переменных. В результате сохранение экземпляра &lt;code&gt;Regress&lt;/code&gt; с использованием &lt;a href=&quot;checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt; также сохранит все переменные, созданные слоем &lt;code&gt;Dense&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5871012b5796b5a485fbd2ea90e6e96dc8a6361" translate="yes" xml:space="preserve">
          <source>This API allows querying the physical hardware resources prior to runtime initialization. Thus, giving an opportunity to call any additional configuration APIs. This is in contrast to &lt;a href=&quot;list_logical_devices&quot;&gt;&lt;code&gt;tf.config.list_logical_devices&lt;/code&gt;&lt;/a&gt;, which triggers runtime initialization in order to list the configured devices.</source>
          <target state="translated">Этот API позволяет запрашивать физические аппаратные ресурсы перед инициализацией среды выполнения. Таким образом, давая возможность вызывать любые дополнительные API конфигурации. В этом отличие от &lt;a href=&quot;list_logical_devices&quot;&gt; &lt;code&gt;tf.config.list_logical_devices&lt;/code&gt; &lt;/a&gt; , который запускает инициализацию среды выполнения для вывода списка настроенных устройств.</target>
        </trans-unit>
        <trans-unit id="74aac56e82063765baca7f72b6ef73462943063c" translate="yes" xml:space="preserve">
          <source>This API enables repeated preprocessing steps to be consolidated, and allows re-use of already processed data, trading off disk storage and network bandwidth for freeing up more valuable CPU resources and accelerator compute time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762aea1a89e9b0e55d82633b7d3d567f5d2f187d" translate="yes" xml:space="preserve">
          <source>This API takes in a &lt;a href=&quot;../physicaldevice&quot;&gt;&lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;../list_physical_devices&quot;&gt;&lt;code&gt;tf.config.list_physical_devices&lt;/code&gt;&lt;/a&gt;. It returns a dict with string keys containing various details about the device. Each key is only supported by a subset of devices, so you should not assume the returned dict will have any particular key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22207bc9bfb65faecbe8df80de09b7c7ff71edfd" translate="yes" xml:space="preserve">
          <source>This API will connect to remote TPU cluster and initialize the TPU hardwares. Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9102764cadc1d75fc4b0e80481d3d9ed63d68c" translate="yes" xml:space="preserve">
          <source>This Estimator implements the following variants of the K-means algorithm:</source>
          <target state="translated">Данный Оценщик реализует следующие варианты алгоритма К-среднего:</target>
        </trans-unit>
        <trans-unit id="80c1b7fb2eecacd5d699b9ee230de5704ca37c8d" translate="yes" xml:space="preserve">
          <source>This Multinomial distribution is parameterized by &lt;code&gt;probs&lt;/code&gt;, a (batch of) length-&lt;code&gt;K&lt;/code&gt;&lt;code&gt;prob&lt;/code&gt; (probability) vectors (&lt;code&gt;K &amp;gt; 1&lt;/code&gt;) such that &lt;code&gt;tf.reduce_sum(probs, -1) = 1&lt;/code&gt;, and a &lt;code&gt;total_count&lt;/code&gt; number of trials, i.e., the number of trials per draw from the Multinomial. It is defined over a (batch of) length-&lt;code&gt;K&lt;/code&gt; vector &lt;code&gt;counts&lt;/code&gt; such that &lt;code&gt;tf.reduce_sum(counts, -1) = total_count&lt;/code&gt;. The Multinomial is identically the Binomial distribution when &lt;code&gt;K = 2&lt;/code&gt;.</source>
          <target state="translated">Это полиномиальное распределение параметризовано &lt;code&gt;probs&lt;/code&gt; , а (партия) длина- &lt;code&gt;K&lt;/code&gt; &lt;code&gt;prob&lt;/code&gt; (вероятность) векторы ( &lt;code&gt;K &amp;gt; 1&lt;/code&gt; ) такое , что &lt;code&gt;tf.reduce_sum(probs, -1) = 1&lt;/code&gt; , и &lt;code&gt;total_count&lt;/code&gt; число испытаний, т.е. количество попыток за розыгрыш из Мультиномина. Он определяется для (пакета) векторных &lt;code&gt;counts&lt;/code&gt; &lt;code&gt;tf.reduce_sum(counts, -1) = total_count&lt;/code&gt; &lt;code&gt;K&lt;/code&gt; , так что tf.reduce_sum (counts, -1) = total_count . Полиномиальное распределение идентично биномиальному распределению при &lt;code&gt;K = 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61586b843c2a7242a7ce5f726a415d728d094add" translate="yes" xml:space="preserve">
          <source>This Op also supports repeated indices in the output subscript, which is not supported by &lt;code&gt;numpy.einsum&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c42e63acc7dcc7eea605a766b11674d1c53e82" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] != y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] != y[i]&lt;/code&gt; выполняется для каждой пары (возможно, широковещательных) элементов &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="74ec1aa4f8491ea53037a0fc532d4741eb9218bd" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt; 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] &amp;gt; 0&lt;/code&gt; выполняется для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; пуст, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="64284c5803db04a210d1a9048bfe82459a849a9d" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt; выполняется для каждой пары (возможно, широковещательных) элементов &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="382c384f5bde2874efffdf9480af145ba234b875" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt;= 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] &amp;gt;= 0&lt;/code&gt; выполняется для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; пуст, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="501dbba0dad9772b46dd6dbe6d32dfc34b3073e4" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt; выполняется для каждой пары (возможно, широковещательных) элементов &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="86a98c771b136d5122e127f8b045988c2c9039d5" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt; 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] &amp;lt; 0&lt;/code&gt; выполняется для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; пуст, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="a26f9f0c29e64714922c2bda7e956bffe84f5c0c" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt; выполняется для каждой пары (возможно, широковещательных) элементов &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="c63795d0aad1b74648e6a4624d3ec74f6c7d4a1e" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt;= 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] &amp;lt;= 0&lt;/code&gt; выполняется для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; пуст, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="52d38297a91871d25885ecc0eb75b01217f176df" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt; выполняется для каждой пары (возможно, широковещательных) элементов &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="a274dbd07debbab7fc4511fde87c45ce7dd5f11a" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] - y[i] &amp;lt; atol + rtol * tf.abs(y[i])&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] - y[i] &amp;lt; atol + rtol * tf.abs(y[i])&lt;/code&gt; выполняется для каждой пары (возможно широковещательных) элементов &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="afe67f7444ede4a73d34ba9ae37a78f686f755dd" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] == y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Эта операция проверяет, что &lt;code&gt;x[i] == y[i]&lt;/code&gt; выполняется для каждой пары (возможно, широковещательных) элементов &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="47fcdf77a806254f145cef6045f72f7418b87096" translate="yes" xml:space="preserve">
          <source>This Op checks that a collection of tensors shape relationships satisfies given constraints.</source>
          <target state="translated">Этот Op проверяет,что коллекция тензоров формирует отношения,удовлетворяющие заданным ограничениям.</target>
        </trans-unit>
        <trans-unit id="70d8b32973294baa04c2b6c2343f69d0d35b251b" translate="yes" xml:space="preserve">
          <source>This Op checks that the rank of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">Эта операция проверяет, что ранг &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;rank&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45bf526016d2ed135926c16509b05dd90dd8b920" translate="yes" xml:space="preserve">
          <source>This Op checks that the rank of &lt;code&gt;x&lt;/code&gt; is greater or equal to &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">Эта операция проверяет, что ранг &lt;code&gt;x&lt;/code&gt; больше или равен &lt;code&gt;rank&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef8abcb7ef7c82e56e48acf10aee7a915b661e8e" translate="yes" xml:space="preserve">
          <source>This Op checks that the rank of &lt;code&gt;x&lt;/code&gt; is in &lt;code&gt;ranks&lt;/code&gt;.</source>
          <target state="translated">Эта операция проверяет, что ранг &lt;code&gt;x&lt;/code&gt; находится в &lt;code&gt;ranks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bbbc71838cec9daa4b798c766e634988ae8eda0" translate="yes" xml:space="preserve">
          <source>This Op does not require &lt;code&gt;a_indices&lt;/code&gt; be sorted in standard lexicographic order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995662dbb5ee7bd63655bfa102038ae50bbbb546" translate="yes" xml:space="preserve">
          <source>This Op does not support implicit form. (i.e. equations without &lt;code&gt;-&amp;gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b037dc8de7a8b2184874f7694988339f20126019" translate="yes" xml:space="preserve">
          <source>This Op eases the porting of code that uses embedding_lookup_sparse(), although some Python preprocessing of the SparseTensor arguments to embedding_lookup_sparse() is required to produce the arguments to this Op, since only a single EnqueueTPUEmbeddingSparseBatch Op is allowed per training step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3230f00e0154436022761e6b1f967d770055298" translate="yes" xml:space="preserve">
          <source>This Op first attempts to find the V2 index file pointed to by &quot;prefix&quot;, and if found proceed to read it as a V2 checkpoint;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed5e982672256e8ea90d7bd0d72e83dbb1172c0" translate="yes" xml:space="preserve">
          <source>This Op only supports unary and binary forms of &lt;code&gt;numpy.einsum&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793a60433b6712b8062346cc2fb3747282971aed" translate="yes" xml:space="preserve">
          <source>This Op picks a random location in &lt;code&gt;image&lt;/code&gt; and crops a &lt;code&gt;height&lt;/code&gt; by &lt;code&gt;width&lt;/code&gt; rectangle from that location. The random location is picked so the cropped area will fit inside the original image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214a679e138acba179edb8672f1201325c1e87b6" translate="yes" xml:space="preserve">
          <source>This Op produces a set of TPU cores (for warm-up) or a single TPU core (for regular inference) to execute the TPU program on. The output is consumed by TPUPartitionedCall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1956a13a2a0626040a0d05adca12d21c39b428f4" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceSum, this Op returns a SparseTensor.</source>
          <target state="translated">Эта операция принимает SparseTensor и является разреженным аналогом &lt;a href=&quot;../../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; &lt;/a&gt; . В отличие от SparseReduceSum, этот Op возвращает SparseTensor.</target>
        </trans-unit>
        <trans-unit id="21543202b1cccf9199ac85ba0b6367bb37a43438" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="translated">Эта операция принимает SparseTensor и является разреженным аналогом &lt;a href=&quot;../../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; &lt;/a&gt; . В частности, эта операция также возвращает плотный &lt;code&gt;Tensor&lt;/code&gt; вместо разреженного.</target>
        </trans-unit>
        <trans-unit id="a92cf7c266fad63ba2ede16d013a7954c0a3ed23" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceSum, this Op returns a SparseTensor.</source>
          <target state="translated">Эта операция принимает SparseTensor и является разреженным аналогом &lt;a href=&quot;../../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; &lt;/a&gt; . В отличие от SparseReduceSum, этот Op возвращает SparseTensor.</target>
        </trans-unit>
        <trans-unit id="eff3316c87e58a0e09844e295d654acad826f230" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="translated">Эта операция принимает SparseTensor и является разреженным аналогом &lt;a href=&quot;../../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; &lt;/a&gt; . В частности, эта операция также возвращает плотный &lt;code&gt;Tensor&lt;/code&gt; вместо разреженного.</target>
        </trans-unit>
        <trans-unit id="02bfe7eb6e17547c27337071dde6515aea09a633" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceMax, this Op returns a SparseTensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7321159b3f380865d8a3ddbbd1ea9288e20a93c6" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, or a &lt;code&gt;SparseTensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Эта операция принимает SparseTensor и является разреженным аналогом &lt;a href=&quot;../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; &lt;/a&gt; . В частности, эта &lt;code&gt;output_is_sparse&lt;/code&gt; также возвращает плотный &lt;code&gt;Tensor&lt;/code&gt; если output_is_sparse равен &lt;code&gt;False&lt;/code&gt; , или &lt;code&gt;SparseTensor&lt;/code&gt; , если &lt;code&gt;output_is_sparse&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1103b246b6e1caad53d997c04c64c3898e6d3b5" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81865bba66b7cb3ccd5c843f29a627466d44c58" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceSum, this Op returns a SparseTensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a574e60c745da5b56aeabab5fc189ca97095b4e6" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, or a &lt;code&gt;SparseTensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Эта операция принимает SparseTensor и является разреженным аналогом &lt;a href=&quot;../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; &lt;/a&gt; . В частности, эта &lt;code&gt;output_is_sparse&lt;/code&gt; также возвращает плотный &lt;code&gt;Tensor&lt;/code&gt; если output_is_sparse равен &lt;code&gt;False&lt;/code&gt; , или &lt;code&gt;SparseTensor&lt;/code&gt; , если &lt;code&gt;output_is_sparse&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0611fe28cd2ae42a84cd683414a5531be62247ed" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9513360fe89de6564516b0de822250d992516167" translate="yes" xml:space="preserve">
          <source>This adjusts the dynamic range of the gradient evaluation by scaling up the &lt;code&gt;loss&lt;/code&gt; value. The gradient values are then scaled back down by the recipricol of the loss scale. This is useful in reduced precision training where small gradient values would otherwise underflow the representable range.</source>
          <target state="translated">Это регулирует динамический диапазон оценки градиента, увеличивая значение &lt;code&gt;loss&lt;/code&gt; . Затем значения градиента снова уменьшаются на обратную величину шкалы потерь. Это полезно при обучении с пониженной точностью, когда небольшие значения градиента в противном случае вышли бы за пределы представимого диапазона.</target>
        </trans-unit>
        <trans-unit id="f5e97086794cce37b1d5d739075a4835500e01f8" translate="yes" xml:space="preserve">
          <source>This adjusts the dynamic range of the gradient evaluation by scaling up the &lt;code&gt;loss&lt;/code&gt; value. The gradient values are then scaled back down by the reciprocal of the loss scale. This is useful in reduced precision training where small gradient values would otherwise underflow the representable range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c2fc8a5963a345edc285e854dc6f61f0166cef" translate="yes" xml:space="preserve">
          <source>This allows 'names' which should be a list of names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4742c30308cfd6082fa96c4df5f33b7fbb5afa83" translate="yes" xml:space="preserve">
          <source>This allows communication and coordination when there are multiple calls to the step_fn triggered by a call to &lt;code&gt;strategy.experimental_run_v2(step_fn, ...)&lt;/code&gt;.</source>
          <target state="translated">Это обеспечивает связь и координацию, когда есть несколько вызовов step_fn, запускаемых вызовом &lt;code&gt;strategy.experimental_run_v2(step_fn, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54e8d42d088337b5915c0ad3a362c2e5bfd670e4" translate="yes" xml:space="preserve">
          <source>This allows communication and coordination when there are multiple calls to the step_fn triggered by a call to &lt;code&gt;strategy.run(step_fn, ...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6406854276bccf2ce7a8330ff5c67c7e93bc6f24" translate="yes" xml:space="preserve">
          <source>This allows creating a sub-tensor from part of the current contents of a variable. See &lt;a href=&quot;../../tensor#__getitem__&quot;&gt;&lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; for detailed examples of slicing.</source>
          <target state="translated">Это позволяет создать суб-тензор из части текущего содержимого переменной. См. &lt;a href=&quot;../../tensor#__getitem__&quot;&gt; &lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt; для подробных примеров нарезки.</target>
        </trans-unit>
        <trans-unit id="3f9bd14a03a5b9808d578e330775308ae0518e1f" translate="yes" xml:space="preserve">
          <source>This allows creating a sub-tensor from part of the current contents of a variable. See &lt;a href=&quot;tensor#__getitem__&quot;&gt;&lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; for detailed examples of slicing.</source>
          <target state="translated">Это позволяет создать суб-тензор из части текущего содержимого переменной. См. &lt;a href=&quot;tensor#__getitem__&quot;&gt; &lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt; для подробных примеров нарезки.</target>
        </trans-unit>
        <trans-unit id="4a0031976f29ed8ed5b38f0545ffe09ca05a84a3" translate="yes" xml:space="preserve">
          <source>This allows reading and writing to this tensors w/o copies. This more closely mirrors the C++ Interpreter class interface's tensor() member, hence the name. Be careful to not hold these output references through calls to &lt;code&gt;allocate_tensors()&lt;/code&gt; and &lt;code&gt;invoke()&lt;/code&gt;. This function cannot be used to read intermediate results.</source>
          <target state="translated">Это позволяет читать и писать в эти тензоры без копий. Это более точно отражает член tenor () интерфейса класса C ++ Interpreter, отсюда и название. Будьте осторожны, чтобы не удерживать эти выходные ссылки через вызовы &lt;code&gt;allocate_tensors()&lt;/code&gt; и &lt;code&gt;invoke()&lt;/code&gt; . Эту функцию нельзя использовать для чтения промежуточных результатов.</target>
        </trans-unit>
        <trans-unit id="aab58add7bb75e6c4119bf13ecc09894979d960d" translate="yes" xml:space="preserve">
          <source>This allows you to save the entirety of the state of a model in a single file.</source>
          <target state="translated">Это позволяет сохранить все состояние модели в одном файле.</target>
        </trans-unit>
        <trans-unit id="083c822ae2751294f6b801ab1aec618144643d76" translate="yes" xml:space="preserve">
          <source>This also supports either output striding via the optional &lt;code&gt;strides&lt;/code&gt; parameter or atrous convolution (also known as convolution with holes or dilated convolution, based on the French word &quot;trous&quot; meaning holes in English) via the optional &lt;code&gt;dilation_rate&lt;/code&gt; parameter. Currently, however, output striding is not supported for atrous convolutions.</source>
          <target state="translated">Это также поддерживает как выход шагающий через опциональные &lt;code&gt;strides&lt;/code&gt; параметр или atrous свертку (также известный как свертка с отверстиями или дилатационной сверткой, на основе французского слова &amp;laquo;trous&amp;raquo; означает отверстие на английском языке) через дополнительный &lt;code&gt;dilation_rate&lt;/code&gt; параметр. Однако в настоящее время выходной шаг не поддерживается для жестких сверток.</target>
        </trans-unit>
        <trans-unit id="0282c5f56f860d1be334e321248ec8429b6f156d" translate="yes" xml:space="preserve">
          <source>This also supports either output striding via the optional &lt;code&gt;strides&lt;/code&gt; parameter or atrous convolution (also known as convolution with holes or dilated convolution, based on the French word &quot;trous&quot; meaning holes in English) via the optional &lt;code&gt;dilations&lt;/code&gt; parameter. Currently, however, output striding is not supported for atrous convolutions.</source>
          <target state="translated">Это также поддерживает как выход шагающий через опциональные &lt;code&gt;strides&lt;/code&gt; параметр или atrous свертку (также известный как свертка с отверстиями или дилатационной сверткой, на основе французского слова &amp;laquo;trous&amp;raquo; означает отверстие на английском языке) через дополнительные &lt;code&gt;dilations&lt;/code&gt; параметра. Однако в настоящее время выходной шаг не поддерживается для жестких сверток.</target>
        </trans-unit>
        <trans-unit id="40ecf12ea54cbb9c03cee235c92870bdadc05d0e" translate="yes" xml:space="preserve">
          <source>This assumes the input dictionary contains a &lt;code&gt;SparseTensor&lt;/code&gt; for key 'terms', and a &lt;code&gt;SparseTensor&lt;/code&gt; for key 'frequencies'. These 2 tensors must have the same indices and dense shape.</source>
          <target state="translated">Это предполагает, что входной словарь содержит &lt;code&gt;SparseTensor&lt;/code&gt; для ключевых &amp;laquo;терминов&amp;raquo; и &lt;code&gt;SparseTensor&lt;/code&gt; для ключевых &amp;laquo;частот&amp;raquo;. Эти 2 тензора должны иметь одинаковые индексы и плотную форму.</target>
        </trans-unit>
        <trans-unit id="ec5e01502dedce9b5506d5284b5d16bed3dce6f8" translate="yes" xml:space="preserve">
          <source>This avoids adding &lt;code&gt;numpy_input&lt;/code&gt; as a large constant in the graph, and copies the data to the machine or machines that will be processing the input.</source>
          <target state="translated">Это позволяет избежать добавления &lt;code&gt;numpy_input&lt;/code&gt; в качестве большой константы в график и копирует данные на машину или машины, которые будут обрабатывать ввод.</target>
        </trans-unit>
        <trans-unit id="542cdf0657b556d7d4f13254bf996896da1af7f2" translate="yes" xml:space="preserve">
          <source>This behaves similarly to &lt;a href=&quot;../../name_scope&quot;&gt;&lt;code&gt;tf.name_scope&lt;/code&gt;&lt;/a&gt;, except that it returns a generated summary tag in addition to the scope name. The tag is structurally similar to the scope name - derived from the user-provided name, prefixed with enclosing name scopes if any - but we relax the constraint that it be uniquified, as well as the character set limitation (so the user-provided name can contain characters not legal for scope names; in the scope name these are removed).</source>
          <target state="translated">Он ведет себя аналогично &lt;a href=&quot;../../name_scope&quot;&gt; &lt;code&gt;tf.name_scope&lt;/code&gt; &lt;/a&gt; , за исключением того, что он возвращает сгенерированный сводный тег в дополнение к имени области. Тег структурно похож на имя области - производное от имени, предоставленного пользователем, с префиксом включающих областей имен, если таковые имеются, - но мы ослабляем ограничение на его унификацию, а также ограничение набора символов (так что имя, указанное пользователем может содержать символы, недопустимые для имен областей; в имени области они удаляются).</target>
        </trans-unit>
        <trans-unit id="5d690c9d397a6da08fd08939e695a0fb6ea89e4b" translate="yes" xml:space="preserve">
          <source>This behavior gives control to callers on what to do if checkpoints do not come fast enough or stop being generated. For example, if callers have a way to detect that the training has stopped and know that no new checkpoints will be generated, they can provide a &lt;code&gt;timeout_fn&lt;/code&gt; that returns &lt;code&gt;True&lt;/code&gt; when the training has stopped. If they know that the training is still going on they return &lt;code&gt;False&lt;/code&gt; instead.</source>
          <target state="translated">Это поведение дает вызывающим абонентам контроль над тем, что делать, если контрольные точки не приходят достаточно быстро или перестают генерироваться. Например, если у вызывающих абонентов есть способ обнаружить, что обучение остановлено, и они знают, что новые контрольные точки не будут созданы, они могут предоставить &lt;code&gt;timeout_fn&lt;/code&gt; , который возвращает &lt;code&gt;True&lt;/code&gt; , когда обучение остановлено. Если они знают, что обучение все еще продолжается, они вместо этого возвращают &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d87911d57456c793352550a56288318dbdc2112" translate="yes" xml:space="preserve">
          <source>This behavior has been introduced in TensorFlow 2.0, in order to enable &lt;code&gt;layer.trainable = False&lt;/code&gt; to produce the most commonly expected behavior in the convnet fine-tuning use case.</source>
          <target state="translated">Это поведение было введено в TensorFlow 2.0, чтобы включить &lt;code&gt;layer.trainable = False&lt;/code&gt; для получения наиболее часто ожидаемого поведения в случае использования тонкой настройки свертки.</target>
        </trans-unit>
        <trans-unit id="566da943133ad9f7ff89e0ae58ccee97f0942cd9" translate="yes" xml:space="preserve">
          <source>This behavior only occurs as of TensorFlow 2.0. In 1.*, setting &lt;code&gt;layer.trainable = False&lt;/code&gt; would freeze the layer but would not switch it to inference mode.</source>
          <target state="translated">Такое поведение наблюдается только в TensorFlow 2.0. В 1. * установка &lt;code&gt;layer.trainable = False&lt;/code&gt; заморозит слой, но не переключит его в режим вывода.</target>
        </trans-unit>
        <trans-unit id="947e43a536a4f632b306b7d5c3e4805a08d13eec" translate="yes" xml:space="preserve">
          <source>This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs.</source>
          <target state="translated">Это блокирует вызывающий поток до тех пор,пока поток,чей метод join()вызывается,не завершится --либо нормально,либо через необработанное исключение,либо до тех пор,пока не произойдет необязательный таймаут.</target>
        </trans-unit>
        <trans-unit id="f576e406288a87f269b5d6306d3d486ac32d4798" translate="yes" xml:space="preserve">
          <source>This boolean flag determines whether variables should be initialized as they are instantiated (default), or if the user should handle the initialization (e.g. via &lt;a href=&quot;../../compat/v1/initialize_all_variables&quot;&gt;&lt;code&gt;tf.compat.v1.initialize_all_variables()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Этот логический флаг определяет, должны ли переменные инициализироваться по мере их создания (по умолчанию), или пользователь должен обрабатывать инициализацию (например, через &lt;a href=&quot;../../compat/v1/initialize_all_variables&quot;&gt; &lt;code&gt;tf.compat.v1.initialize_all_variables()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4711e34ac0b0f311f0826db62648fbfab1ecfcb6" translate="yes" xml:space="preserve">
          <source>This boolean is True when this is an export in the end of training. It is False for the intermediate exports during the training. When passing &lt;code&gt;Exporter&lt;/code&gt; to &lt;a href=&quot;train_and_evaluate&quot;&gt;&lt;code&gt;tf.estimator.train_and_evaluate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;is_the_final_export&lt;/code&gt; is always False if &lt;a href=&quot;trainspec#max_steps&quot;&gt;&lt;code&gt;TrainSpec.max_steps&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d320c46f5814a56c1f3f60058177b848b6fe981" translate="yes" xml:space="preserve">
          <source>This call blocks until a set of threads have terminated. The set of thread is the union of the threads passed in the &lt;code&gt;threads&lt;/code&gt; argument and the list of threads that registered with the coordinator by calling &lt;a href=&quot;coordinator#register_thread&quot;&gt;&lt;code&gt;Coordinator.register_thread()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот вызов блокируется до тех пор, пока не завершится набор потоков. Набор потоков - это объединение потоков, переданных в аргументе &lt;code&gt;threads&lt;/code&gt; и список потоков, которые зарегистрированы координатором путем вызова &lt;a href=&quot;coordinator#register_thread&quot;&gt; &lt;code&gt;Coordinator.register_thread()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51c54c7d5726811d44822079b16e485771669c24" translate="yes" xml:space="preserve">
          <source>This call is ignored when eager execution is enabled (in that case, variable updates are run on the fly and thus do not need to be tracked for later execution).</source>
          <target state="translated">Этот вызов игнорируется,когда включено ускоренное выполнение (в этом случае обновления переменных выполняются &quot;на лету&quot; и,таким образом,их не нужно отслеживать для последующего выполнения).</target>
        </trans-unit>
        <trans-unit id="062df39159f4972c7eb0c0bbc3c621a80385af7d" translate="yes" xml:space="preserve">
          <source>This callback is automatically applied to every Keras model.</source>
          <target state="translated">Этот обратный вызов автоматически применяется к каждой модели Keras.</target>
        </trans-unit>
        <trans-unit id="4a2209138c3b99588918296a296e9d5cba348ee9" translate="yes" xml:space="preserve">
          <source>This callback is automatically applied to every Keras model. The &lt;code&gt;History&lt;/code&gt; object gets returned by the &lt;code&gt;fit&lt;/code&gt; method of models.</source>
          <target state="translated">Этот обратный вызов автоматически применяется к каждой модели Keras. Объект &lt;code&gt;History&lt;/code&gt; возвращается &lt;code&gt;fit&lt;/code&gt; методом моделей.</target>
        </trans-unit>
        <trans-unit id="9a8fccab0666eafd61c1fb78dee506da35fb92ce" translate="yes" xml:space="preserve">
          <source>This callback is constructed with anonymous functions that will be called at the appropriate time. Note that the callbacks expects positional arguments, as:</source>
          <target state="translated">Этот обратный вызов построен с анонимными функциями,которые будут вызваны в соответствующее время.Обратите внимание,что обратные вызовы ожидают позиционных аргументов,как:</target>
        </trans-unit>
        <trans-unit id="d5a28ff485e6238d1ad10ebb9f92b4945e5fbef4" translate="yes" xml:space="preserve">
          <source>This callback is not compatible with disabling eager execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fd53cd69211c630c172b830b110ef6741f78e7" translate="yes" xml:space="preserve">
          <source>This callback logs events for TensorBoard, including:</source>
          <target state="translated">Этот обратный вызов регистрирует события для TensorBoard,в том числе:</target>
        </trans-unit>
        <trans-unit id="6cbedc26a564f8697fb303c927049b43625f8671" translate="yes" xml:space="preserve">
          <source>This can also be used in a &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt; as the optimizer parameter to set a table specific optimizer. This will override the optimizer and parameters for global embedding optimizer defined above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4d9ff06bd1c217d75cb9a57ebc28626f964add" translate="yes" xml:space="preserve">
          <source>This can always be checked statically, so this method returns nothing.</source>
          <target state="translated">Это всегда можно проверить статически,поэтому этот метод ничего не возвращает.</target>
        </trans-unit>
        <trans-unit id="6f195f030f5d6a3952c927a303c10a3d51f131c5" translate="yes" xml:space="preserve">
          <source>This can be faster than multiple individual &lt;code&gt;reduce&lt;/code&gt;s because we can fuse several tensors into one or multiple packs before reduction.</source>
          <target state="translated">Это может быть быстрее, чем несколько отдельных &lt;code&gt;reduce&lt;/code&gt; потому что мы можем объединить несколько тензоров в один или несколько пакетов перед сокращением.</target>
        </trans-unit>
        <trans-unit id="ef728ae4ad68ee3a6531133cdd224d4406968fce" translate="yes" xml:space="preserve">
          <source>This can be passed to methods like &lt;code&gt;tf.distribute.get_replica_context().all_reduce()&lt;/code&gt; to optimize collective operation performance. Note that these are only hints, which may or may not change the actual behavior. Some options only apply to certain strategy and are ignored by others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c1e8ee1a694edb65fdf5329eae65afdec683d9" translate="yes" xml:space="preserve">
          <source>This can be used as a &quot;join&quot; mechanism for parallel computations: all the argument tensors can be computed in parallel, but the values of any tensor returned by &lt;code&gt;tuple&lt;/code&gt; are only available after all the parallel computations are done.</source>
          <target state="translated">Это можно использовать как механизм &amp;laquo;соединения&amp;raquo; для параллельных вычислений: все тензоры аргументов могут быть вычислены параллельно, но значения любого тензора, возвращаемого &lt;code&gt;tuple&lt;/code&gt; , доступны только после того, как все параллельные вычисления будут выполнены.</target>
        </trans-unit>
        <trans-unit id="66b08400383b183cc1cba0b591ec90b5fe85d73d" translate="yes" xml:space="preserve">
          <source>This can be used as a loss-function during optimization so as to suppress noise in images. If you have a batch of images, then you should calculate the scalar loss-value as the sum: &lt;code&gt;loss = tf.reduce_sum(tf.image.total_variation(images))&lt;/code&gt;</source>
          <target state="translated">Это можно использовать как функцию потерь во время оптимизации, чтобы подавить шум в изображениях. Если у вас есть пакет изображений, вы должны рассчитать скалярное значение потерь как сумму: &lt;code&gt;loss = tf.reduce_sum(tf.image.total_variation(images))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9d5c2eebbfc8025f5c8da3b80769337a79a6187" translate="yes" xml:space="preserve">
          <source>This can be used to hold some strategy specific configs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff61da80eb1038583fadf6e588b06357b27a55d8" translate="yes" xml:space="preserve">
          <source>This can be useful for debugging or profiling. For example, let's say you implemented a simple iterative sqrt function, and you want to collect the intermediate values and plot the convergence. Appending the values to a list in &lt;code&gt;@tf.function&lt;/code&gt; normally wouldn't work since it will just record the Tensors being traced, not the values. Instead, you can do the following.</source>
          <target state="translated">Это может быть полезно для отладки или профилирования. Например, предположим, что вы реализовали простую итеративную функцию sqrt и хотите собрать промежуточные значения и построить график сходимости. Добавление значений к списку в &lt;code&gt;@tf.function&lt;/code&gt; обычно не работает, поскольку она просто записывает отслеживаемые тензоры, а не значения. Вместо этого вы можете сделать следующее.</target>
        </trans-unit>
        <trans-unit id="5bc85a9ecd105989dec28b806afbbe4faa69f248" translate="yes" xml:space="preserve">
          <source>This can be useful if you want to log debug a training algorithm, report stats about the slots, etc.</source>
          <target state="translated">Это может быть полезно,если вы хотите записать в журнал отладку алгоритма обучения,сообщить статистику по слотам и т.д.</target>
        </trans-unit>
        <trans-unit id="de803dd8ed0f3487c59166443a170b97850a2c8d" translate="yes" xml:space="preserve">
          <source>This class allows to vectorize a text corpus, by turning each text into either a sequence of integers (each integer being the index of a token in a dictionary) or into a vector where the coefficient for each token could be binary, based on word count, based on tf-idf...</source>
          <target state="translated">Данный класс позволяет векторизовать текстовый корпус,превращая каждый текст либо в последовательность целых чисел (каждое целое число-это индекс лексемы в словаре),либо в вектор,где коэффициент для каждой лексемы может быть двоичным,основанным на подсчете слов,на основе tf-idf...</target>
        </trans-unit>
        <trans-unit id="c35c7cb7e9df11039724d697524b210395fe269e" translate="yes" xml:space="preserve">
          <source>This class assumes each worker is running the same code independently, but parameter servers are running a standard server. This means that while each worker will synchronously compute a single gradient update across all GPUs, updates between workers proceed asynchronously. Operations that occur only on the first replica (such as incrementing the global step), will occur on the first replica &lt;em&gt;of every worker&lt;/em&gt;.</source>
          <target state="translated">Этот класс предполагает, что каждый рабочий запускает один и тот же код независимо, но на серверах параметров работает стандартный сервер. Это означает, что, хотя каждый рабочий процесс будет синхронно вычислять одно обновление градиента для всех графических процессоров, обновления между рабочими процессами выполняются асинхронно. Операции, которые выполняются только на первой реплике (например, увеличение глобального шага), будут выполняться на первой реплике &lt;em&gt;каждого рабочего&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1ea4dadc6d5580b6a9567a54f238c77dab3d0a06" translate="yes" xml:space="preserve">
          <source>This class caches file writers, one per directory.</source>
          <target state="translated">Этот класс кэширует записывающие файлы,по одному на каталог.</target>
        </trans-unit>
        <trans-unit id="b8684cfbd26f7ff4ba54e9a816ce8e5ac6de8988" translate="yes" xml:space="preserve">
          <source>This class can be used to support training large embeddings on TPU. When creating an instance of this class, you must specify the complete set of tables and features you expect to lookup in those tables. See the documentation of &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;featureconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt;&lt;/a&gt; for more details on the complete set of options. We will cover the basic usage here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9243b860278b8d7215f95a8eb101fc7a883ab5b" translate="yes" xml:space="preserve">
          <source>This class can create placeholders for tf.Tensors, tf.SparseTensors, and tf.RaggedTensors by choosing 'sparse=True' or 'ragged=True'.</source>
          <target state="translated">Этот класс может создавать плейсхолдеры для tf.Tensors,tf.SparseTensors и tf.RaggedTensors,выбирая 'sparse=True' или 'ragged=True'.</target>
        </trans-unit>
        <trans-unit id="805ec9c49684c57a889497d64617b10bca6259a1" translate="yes" xml:space="preserve">
          <source>This class can create placeholders for tf.Tensors, tf.SparseTensors, and tf.RaggedTensors by choosing 'sparse=True' or 'ragged=True'. Note that 'sparse' and 'ragged' can't be configured to True at same time. Usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93eb86d4b8b199ed8de190972226d76d3ddbda5" translate="yes" xml:space="preserve">
          <source>This class defines the API to add Ops to train a model. You never use this class directly, but instead instantiate one of its subclasses such as &lt;a href=&quot;sgd&quot;&gt;&lt;code&gt;tf.keras.optimizers.SGD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;adam&quot;&gt;&lt;code&gt;tf.keras.optimizers.Adam&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот класс определяет API для добавления операций для обучения модели. Вы никогда не используете этот класс напрямую, а вместо этого &lt;a href=&quot;sgd&quot;&gt; &lt;code&gt;tf.keras.optimizers.SGD&lt;/code&gt; &lt;/a&gt; экземпляр одного из его подклассов, например tf.keras.optimizers.SGD , &lt;a href=&quot;adam&quot;&gt; &lt;code&gt;tf.keras.optimizers.Adam&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1921ba1f544676f9bbcb9030a711c397087751d1" translate="yes" xml:space="preserve">
          <source>This class defines the API to add Ops to train a model. You never use this class directly, but instead instantiate one of its subclasses such as &lt;code&gt;GradientDescentOptimizer&lt;/code&gt;, &lt;code&gt;AdagradOptimizer&lt;/code&gt;, or &lt;code&gt;MomentumOptimizer&lt;/code&gt;.</source>
          <target state="translated">Этот класс определяет API для добавления операций для обучения модели. Вы никогда не используете этот класс напрямую, а вместо этого &lt;code&gt;AdagradOptimizer&lt;/code&gt; экземпляр одного из его подклассов, таких как &lt;code&gt;GradientDescentOptimizer&lt;/code&gt; , AdagradOptimizer или &lt;code&gt;MomentumOptimizer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b4934ebc6e87e946a8327b096ccaba6f902fbb" translate="yes" xml:space="preserve">
          <source>This class defines the key and value used for tf.lookup.TextFileInitializer.</source>
          <target state="translated">Данный класс определяет ключ и значение,используемое для tf.lookup.TextFileInitializer.</target>
        </trans-unit>
        <trans-unit id="bbef232ee84dd43e03ff0bb31e2fff3d62ddb086" translate="yes" xml:space="preserve">
          <source>This class exports the serving graph and checkpoints at the end.</source>
          <target state="translated">Этот класс экспортирует обслуживающий граф и контрольно-пропускные пункты в конце.</target>
        </trans-unit>
        <trans-unit id="2398f265a0682e91ce8fc30c31cc00a32b85cf94" translate="yes" xml:space="preserve">
          <source>This class exports the serving graph and checkpoints of the best models.</source>
          <target state="translated">Этот класс экспортирует обслуживающий граф и контрольно-пропускные пункты лучших моделей.</target>
        </trans-unit>
        <trans-unit id="f378b5fe5691dc39f9cd3d236136a8685104c4fd" translate="yes" xml:space="preserve">
          <source>This class has been deprecated. Please use &lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Этот класс устарел. &lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt; &lt;code&gt;lite.TFLiteConverter&lt;/code&gt; &lt;/a&gt; этого используйте lite.TFLiteConverter .</target>
        </trans-unit>
        <trans-unit id="56db13aef8a0368de7cd44eab17a2a6ce7b0dc42" translate="yes" xml:space="preserve">
          <source>This class has been deprecated. Please use &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/lite/TFLiteConverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8616741a1ce86b957920807cdf7bdf7cd9ce000e" translate="yes" xml:space="preserve">
          <source>This class has two primary purposes:</source>
          <target state="translated">У этого класса есть две основные цели:</target>
        </trans-unit>
        <trans-unit id="42f7db2b92ba92041bfe671280afd36a3919a9f0" translate="yes" xml:space="preserve">
          <source>This class holds the configuration data for a single embedding feature. The main use is to assign features to &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt;s via the table parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9133b931fbc77d042cdefc7dee2428d484b0ed" translate="yes" xml:space="preserve">
          <source>This class holds the configuration data for a single embedding table. It is used as the &lt;code&gt;table&lt;/code&gt; parameter of a &lt;a href=&quot;featureconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt;&lt;/a&gt;. Multiple &lt;a href=&quot;featureconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt;&lt;/a&gt; objects can use the same &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt; object. In this case a shared table will be created for those feature lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41eb7b59b50f02eb388655630751957c627b643" translate="yes" xml:space="preserve">
          <source>This class implements &lt;code&gt;__enter__&lt;/code&gt; and &lt;code&gt;__exit__&lt;/code&gt;, and can be used in &lt;code&gt;with&lt;/code&gt; blocks like a normal file.</source>
          <target state="translated">Этот класс реализует &lt;code&gt;__enter__&lt;/code&gt; и &lt;code&gt;__exit__&lt;/code&gt; и может использоваться &lt;code&gt;with&lt;/code&gt; блоками, как обычный файл.</target>
        </trans-unit>
        <trans-unit id="8e6a775ae22bedf95251724d923983db37089b28" translate="yes" xml:space="preserve">
          <source>This class implements &lt;code&gt;__enter__&lt;/code&gt; and &lt;code&gt;__exit__&lt;/code&gt;, and can be used in &lt;code&gt;with&lt;/code&gt; blocks like a normal file. (See the usage example above.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d78e6233b72d451051551f631a8d253b9c0d10" translate="yes" xml:space="preserve">
          <source>This class implements a simple mechanism to coordinate the termination of a set of threads.</source>
          <target state="translated">В данном классе реализован простой механизм координации завершения набора потоков.</target>
        </trans-unit>
        <trans-unit id="2c453470b9fb7d2dd4c8372805a2c5b45dcafe1a" translate="yes" xml:space="preserve">
          <source>This class in stateful and thread-compatible.</source>
          <target state="translated">Этот класс по stateful и потоковой совместимости.</target>
        </trans-unit>
        <trans-unit id="b6c71f2399c238428100228254e29a64f6c45e19" translate="yes" xml:space="preserve">
          <source>This class is a simple wrapper for a pair of &lt;code&gt;Tensor&lt;/code&gt; objects:</source>
          <target state="translated">Этот класс представляет собой простую оболочку для пары объектов &lt;code&gt;Tensor&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aaddfb846b1d90d727149969bb3d79f9de0c7466" translate="yes" xml:space="preserve">
          <source>This class is a small wrapper that takes care of session creation and checkpoint recovery. It also provides functions that to facilitate coordination among multiple training threads or processes.</source>
          <target state="translated">Этот класс представляет собой небольшую обертку,которая заботится о создании сеанса и восстановлении контрольной точки.Он также предоставляет функции,которые облегчают координацию между несколькими учебными потоками или процессами.</target>
        </trans-unit>
        <trans-unit id="17463f3d93317c6b5e6f0cc508b2a6f39e7358ea" translate="yes" xml:space="preserve">
          <source>This class is deprecated. For synchrononous training, please use &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;Distribution Strategies&lt;/a&gt;.</source>
          <target state="translated">Этот класс устарел. Для синхронного обучения используйте &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;стратегии распределения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="000d9e8de17ad9ab35fd8858d3f373310d7cf1c7" translate="yes" xml:space="preserve">
          <source>This class is deprecated. For synchronous training, please use &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;Distribution Strategies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4616d8f2e476585f5e22705937707332b5baeb5b" translate="yes" xml:space="preserve">
          <source>This class is deprecated. Please use &lt;a href=&quot;monitoredtrainingsession&quot;&gt;&lt;code&gt;tf.compat.v1.train.MonitoredTrainingSession&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Этот класс устарел. &lt;a href=&quot;monitoredtrainingsession&quot;&gt; &lt;code&gt;tf.compat.v1.train.MonitoredTrainingSession&lt;/code&gt; &lt;/a&gt; этого используйте tf.compat.v1.train.MonitoredTrainingSession .</target>
        </trans-unit>
        <trans-unit id="42d3bc86be52a8736e6d7aa317815110401307ef" translate="yes" xml:space="preserve">
          <source>This class is heavily overloaded:</source>
          <target state="translated">Этот класс сильно перегружен:</target>
        </trans-unit>
        <trans-unit id="22170de053f3420fc08a96260e613e3fa8486018" translate="yes" xml:space="preserve">
          <source>This class is meant to be used with dynamic iteration primitives such as &lt;code&gt;while_loop&lt;/code&gt; and &lt;code&gt;map_fn&lt;/code&gt;. It supports gradient back-propagation via special &quot;flow&quot; control flow dependencies.</source>
          <target state="translated">Этот класс предназначен для использования с примитивами динамической итерации, такими как &lt;code&gt;while_loop&lt;/code&gt; и &lt;code&gt;map_fn&lt;/code&gt; . Он поддерживает обратное распространение градиента с помощью специальных зависимостей потока управления.</target>
        </trans-unit>
        <trans-unit id="3c5c516c190cd8f8be6eb152047649a9bf6735af" translate="yes" xml:space="preserve">
          <source>This class is not thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121c6274230c0f7d1b806b54f9d580ba8e2d228a" translate="yes" xml:space="preserve">
          <source>This class merges the output of multiple &lt;code&gt;Head&lt;/code&gt; objects. Specifically:</source>
          <target state="translated">Этот класс объединяет вывод нескольких объектов &lt;code&gt;Head&lt;/code&gt; . В частности:</target>
        </trans-unit>
        <trans-unit id="7cd980fdc04e7da43f8abb3e3be6ffdf25b7685d" translate="yes" xml:space="preserve">
          <source>This class performs a model export everytime the new model is better than any existing model.</source>
          <target state="translated">Этот класс выполняет экспорт модели каждый раз,когда новая модель лучше любой существующей модели.</target>
        </trans-unit>
        <trans-unit id="391aed511e9154256ca236f23d6877cb0f9d37db" translate="yes" xml:space="preserve">
          <source>This class performs a single export at the end of training.</source>
          <target state="translated">По окончании обучения этот класс осуществляет единичный экспорт.</target>
        </trans-unit>
        <trans-unit id="b83c252083ca3edbed9d1168a0ed9755da22c25f" translate="yes" xml:space="preserve">
          <source>This class performs a union given two or more existing ClusterResolvers. It merges the underlying ClusterResolvers, and returns one unified ClusterSpec when cluster_spec is called. The details of the merge function is documented in the cluster_spec function.</source>
          <target state="translated">Этот класс выполняет объединение с двумя или более существующими резольверами кластеров.Он объединяет базовые резольверы ClusterResolvers и возвращает один унифицированный ClusterSpec при вызове cluster_spec.Детали функции слияния описаны в функции cluster_spec.</target>
        </trans-unit>
        <trans-unit id="631d6a58bb184da4fc166c1a1dbaf36a0e45d9c8" translate="yes" xml:space="preserve">
          <source>This class performs the softmax operation for you, so inputs should be e.g. linear projections of outputs by an LSTM.</source>
          <target state="translated">Этот класс выполняет для вас операцию софтмакс,поэтому входами должны быть,например,линейные проекции выходов LSTM.</target>
        </trans-unit>
        <trans-unit id="d2810b13f641fd9987b2ce8b38f939b3369079e3" translate="yes" xml:space="preserve">
          <source>This class processes one step within the whole time sequence input, whereas &lt;code&gt;tf.keras.layer.GRU&lt;/code&gt; processes the whole sequence.</source>
          <target state="translated">Этот класс обрабатывает один шаг во всем вводе временной последовательности, тогда как &lt;code&gt;tf.keras.layer.GRU&lt;/code&gt; обрабатывает всю последовательность.</target>
        </trans-unit>
        <trans-unit id="9a1d5a35670a2cc4cfac2401e85535a1c8acffb8" translate="yes" xml:space="preserve">
          <source>This class processes one step within the whole time sequence input, whereas &lt;code&gt;tf.keras.layer.LSTM&lt;/code&gt; processes the whole sequence.</source>
          <target state="translated">Этот класс обрабатывает один шаг во всем вводе временной последовательности, тогда как &lt;code&gt;tf.keras.layer.LSTM&lt;/code&gt; обрабатывает всю последовательность.</target>
        </trans-unit>
        <trans-unit id="85aecc3ec7757c0f4286579ce3ab5119031dd197" translate="yes" xml:space="preserve">
          <source>This class processes one step within the whole time sequence input, whereas &lt;code&gt;tf.keras.layer.SimpleRNN&lt;/code&gt; processes the whole sequence.</source>
          <target state="translated">Этот класс обрабатывает один шаг во всем вводе временной последовательности, тогда как &lt;code&gt;tf.keras.layer.SimpleRNN&lt;/code&gt; обрабатывает всю последовательность.</target>
        </trans-unit>
        <trans-unit id="c2cd1ab18438d633073fa2c3300d94950ce386b5" translate="yes" xml:space="preserve">
          <source>This class regularly exports the serving graph and checkpoints.</source>
          <target state="translated">Этот класс регулярно экспортирует график обслуживания и контрольно-пропускные пункты.</target>
        </trans-unit>
        <trans-unit id="44829f1dbd5fa6ec4b7c405e96fb0cb7473fedd5" translate="yes" xml:space="preserve">
          <source>This class specifies the configurations for an &lt;code&gt;Estimator&lt;/code&gt; run.</source>
          <target state="translated">Этот класс определяет конфигурации для запуска &lt;code&gt;Estimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="349b70f1528f5d483fc48af054599841c5669982" translate="yes" xml:space="preserve">
          <source>This class takes in a sequence of data-points gathered at equal intervals, along with time series parameters such as stride, length of history, etc., to produce batches for training/validation.</source>
          <target state="translated">В этом классе производится последовательность точек данных,собранных через равные промежутки времени,наряду с такими параметрами временных рядов,как шаг,длина истории и т.д.,для получения партий для обучения/проверки.</target>
        </trans-unit>
        <trans-unit id="2020d8f19309c20263f69977f3eb5adfc93381e1" translate="yes" xml:space="preserve">
          <source>This class uses a &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; to manage its internal state. Every time random numbers are generated, the state of the generator will change. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45bad515b0c24287a7857bc49730849b980995da" translate="yes" xml:space="preserve">
          <source>This classifier ignores feature values and will learn to predict the average value of each label. For single-label problems, this will predict the probability distribution of the classes as seen in the labels. For multi-label problems, this will predict the fraction of examples that are positive for each class.</source>
          <target state="translated">Этот классификатор игнорирует значения функций и учится предсказывать среднее значение каждой метки.Для задач с одной меткой это позволит предсказать распределение вероятностей по классам,как это видно на метках.Для задач с несколькими метками,это позволит предсказать долю примеров,которые являются положительными для каждого класса.</target>
        </trans-unit>
        <trans-unit id="1203741987f9f009e5e86b580142b5f23085017c" translate="yes" xml:space="preserve">
          <source>This computes the internal data stats related to the data-dependent transformations, based on an array of sample data.</source>
          <target state="translated">При этом вычисляется внутренняя статистика данных,связанная с зависимыми от данных преобразованиями,на основе массива данных выборки.</target>
        </trans-unit>
        <trans-unit id="38619017d4eec4e645fa2f91a523c788477cd3cb" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have</source>
          <target state="translated">Это условие выполняется, если для каждой пары (возможно широковещательных) элементов &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; мы имеем</target>
        </trans-unit>
        <trans-unit id="462aa0ba39503de33a78d3a4ed1c72d0eb71fa77" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] != y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Это условие выполняется, если для каждой пары (возможно широковещательных) элементов &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; мы имеем &lt;code&gt;x[i] != y[i]&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="e25b6ae62c3ffc2ef4953d25e9698856f0a3b77a" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Это условие выполняется, если для каждой пары (возможно широковещательных) элементов &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; мы имеем &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="ad801aabcdd92fbf94ec233e05dfeadd68d460b3" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Это условие выполняется , если для каждой пары (возможно , радиопередача) элементов &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; , мы имеем &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="512ed74cbec98906ad1a4d1866d9484e4d2ad504" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Это условие выполняется, если для каждой пары (возможно широковещательных) элементов &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; мы имеем &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="81434868d39629bbc35c170df36a994a92015b46" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Это условие выполняется, если для каждой пары (возможно широковещательных) элементов &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; мы имеем &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="93ee9d4d5438fdc7dae43626edce4fb33cefa73b" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] == y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Это условие выполняется, если для каждой пары (возможно широковещательных) элементов &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; мы имеем &lt;code&gt;x[i] == y[i]&lt;/code&gt; . Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="1107421e32062956898c5a66e60e49bd95c7ed45" translate="yes" xml:space="preserve">
          <source>This constraint can be applied to any &lt;code&gt;Conv2D&lt;/code&gt; layer version, including &lt;code&gt;Conv2DTranspose&lt;/code&gt; and &lt;code&gt;SeparableConv2D&lt;/code&gt;, and with either &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; or &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; data format. The method assumes the weight tensor is of shape &lt;code&gt;(rows, cols, input_depth, output_depth)&lt;/code&gt;.</source>
          <target state="translated">Это ограничение может быть применен к любой &lt;code&gt;Conv2D&lt;/code&gt; версии слоя, в том числе &lt;code&gt;Conv2DTranspose&lt;/code&gt; и &lt;code&gt;SeparableConv2D&lt;/code&gt; , и либо с &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; или &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; формат данных. Метод предполагает, что тензор веса имеет форму &lt;code&gt;(rows, cols, input_depth, output_depth)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5e140df8d55549c17df75f17763f4c88b908cd9" translate="yes" xml:space="preserve">
          <source>This constructor creates both a &lt;code&gt;variable&lt;/code&gt; Op and an &lt;code&gt;assign&lt;/code&gt; Op to set the variable to its initial value.</source>
          <target state="translated">Этот конструктор создает как &lt;code&gt;variable&lt;/code&gt; Op, так и &lt;code&gt;assign&lt;/code&gt; Op для установки переменной в ее начальное значение.</target>
        </trans-unit>
        <trans-unit id="0853b5f1d96849514913dcea4715e205fe7e9be9" translate="yes" xml:space="preserve">
          <source>This constructor is private -- please use one of the following ops to build &lt;code&gt;RaggedTensor&lt;/code&gt;s:</source>
          <target state="translated">Этот конструктор является частным - используйте одну из следующих операций для создания &lt;code&gt;RaggedTensor&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="fa9706d28ea0bf76646310aace552e8f79dee4fd" translate="yes" xml:space="preserve">
          <source>This constructor only applies if the algorithm is a counter-based algorithm. See method &lt;code&gt;key&lt;/code&gt; for the meaning of &quot;key&quot; and &quot;counter&quot;.</source>
          <target state="translated">Этот конструктор применяется только в том случае, если алгоритм основан на счетчике. См. &amp;laquo; &lt;code&gt;key&lt;/code&gt; метода&amp;raquo;, чтобы узнать значение &amp;laquo;ключ&amp;raquo; и &amp;laquo;счетчик&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="abd1f92b92080f9534139ad50b5578924ec063f6" translate="yes" xml:space="preserve">
          <source>This contains most of the synchronization implementation and also wraps the apply_gradients() from the real optimizer.</source>
          <target state="translated">Она содержит большую часть реализации синхронизации,а также обертывает apply_gradients()из реального оптимизатора.</target>
        </trans-unit>
        <trans-unit id="dac62a0f0dbdc3c6a9231598871c80876ac21c3b" translate="yes" xml:space="preserve">
          <source>This context handler simplifies the exception handling. Use it as follows:</source>
          <target state="translated">Этот контекстный обработчик упрощает обработку исключений.Используйте его следующим образом:</target>
        </trans-unit>
        <trans-unit id="92e2326270a118c9b1678bb4952443a859f4c559" translate="yes" xml:space="preserve">
          <source>This context manager can be used to override the gradient function that will be used for ops within the scope of the context.</source>
          <target state="translated">Этот контекстный менеджер может быть использован для переопределения функции градиента,которая будет использоваться для оп в пределах контекста.</target>
        </trans-unit>
        <trans-unit id="790e879037e30f5e5546c1be4c06bf6476dca2dd" translate="yes" xml:space="preserve">
          <source>This context manager captures all writes to a given stream inside of a &lt;code&gt;CapturedWrites&lt;/code&gt; object. When this context manager is created, it yields the &lt;code&gt;CapturedWrites&lt;/code&gt; object. The captured contents can be accessed by calling &lt;code&gt;.contents()&lt;/code&gt; on the &lt;code&gt;CapturedWrites&lt;/code&gt;.</source>
          <target state="translated">Этот диспетчер контекста захватывает все записи в заданный поток внутри объекта &lt;code&gt;CapturedWrites&lt;/code&gt; . Когда этот диспетчер контекста создается, он дает объект &lt;code&gt;CapturedWrites&lt;/code&gt; . Доступ к захваченному содержимому можно получить, вызвав &lt;code&gt;.contents()&lt;/code&gt; для &lt;code&gt;CapturedWrites&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41c375fab79db6dca2a3052fe26a3bb1f0a48127" translate="yes" xml:space="preserve">
          <source>This context manager creates and automatically recovers a session. It optionally starts the standard services that handle checkpoints and summaries. It monitors exceptions raised from the &lt;code&gt;with&lt;/code&gt; block or from the services and stops the supervisor as needed.</source>
          <target state="translated">Этот диспетчер контекста создает и автоматически восстанавливает сеанс. При желании он запускает стандартные службы, которые обрабатывают контрольные точки и сводки. Он отслеживает исключения, вызванные блоком &lt;code&gt;with&lt;/code&gt; или службами, и при необходимости останавливает супервизор.</target>
        </trans-unit>
        <trans-unit id="1dfc6367da2112861ba5a19ab74136e2bfa59bd7" translate="yes" xml:space="preserve">
          <source>This context manager pushes a name scope, which will make the name of all operations added within it have a prefix.</source>
          <target state="translated">Этот контекстный менеджер выталкивает область имён,в результате чего имя всех операций,добавленных в неё,будет иметь префикс.</target>
        </trans-unit>
        <trans-unit id="cadf2e29564a69f6d9e78e18436e128fc8603a09" translate="yes" xml:space="preserve">
          <source>This context manager validates that the (optional) &lt;code&gt;values&lt;/code&gt; are from the same graph, ensures that graph is the default graph, and pushes a name scope and a variable scope.</source>
          <target state="translated">Этот диспетчер контекста проверяет, что (необязательные) &lt;code&gt;values&lt;/code&gt; взяты из одного и того же графика, гарантирует, что график является графиком по умолчанию, и подталкивает область имени и область переменной.</target>
        </trans-unit>
        <trans-unit id="9fe8f8972b4d68b13082f0d96ff8de4b430acf3b" translate="yes" xml:space="preserve">
          <source>This context manager validates that the given &lt;code&gt;values&lt;/code&gt; are from the same graph, makes that graph the default graph, and pushes a name scope in that graph (see &lt;a href=&quot;../../../../graph#name_scope&quot;&gt;&lt;code&gt;tf.Graph.name_scope&lt;/code&gt;&lt;/a&gt; for more details on that).</source>
          <target state="translated">Этот диспетчер контекста проверяет, что данные &lt;code&gt;values&lt;/code&gt; взяты из одного и того же графика, делает этот график графиком по умолчанию и подталкивает область имени в этом графике (см. &lt;a href=&quot;../../../../graph#name_scope&quot;&gt; &lt;code&gt;tf.Graph.name_scope&lt;/code&gt; &lt;/a&gt; для более подробной информации).</target>
        </trans-unit>
        <trans-unit id="8bc9405ecd91e0aa7f29a32f0b001ccc17dfce1e" translate="yes" xml:space="preserve">
          <source>This convenience method requires a session where the graph containing this variable has been launched. If no session is passed, the default session is used. See &lt;a href=&quot;compat/v1/session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; for more information on launching a graph and on sessions.</source>
          <target state="translated">Этот удобный метод требует сеанса, в котором был запущен граф, содержащий эту переменную. Если сеанс не пройден, используется сеанс по умолчанию. См. &lt;a href=&quot;compat/v1/session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о запуске графика и сеансах.</target>
        </trans-unit>
        <trans-unit id="69597b8afaecf26bf780e17dbe96db99a176f9db" translate="yes" xml:space="preserve">
          <source>This convenience method requires a session where the graph containing this variable has been launched. If no session is passed, the default session is used. See &lt;a href=&quot;session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; for more information on launching a graph and on sessions.</source>
          <target state="translated">Этот удобный метод требует сеанса, в котором был запущен граф, содержащий эту переменную. Если сеанс не пройден, используется сеанс по умолчанию. См. &lt;a href=&quot;session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о запуске графика и сеансах.</target>
        </trans-unit>
        <trans-unit id="049bd1098346a19ff3fab486ff6a7b47c3fd7819" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;LinearOperator&lt;/code&gt; of the form &lt;code&gt;A = L + U D V^H&lt;/code&gt;, with &lt;code&gt;L&lt;/code&gt; a &lt;code&gt;LinearOperator&lt;/code&gt;, &lt;code&gt;U, V&lt;/code&gt; both [batch] matrices, and &lt;code&gt;D&lt;/code&gt; a [batch] diagonal matrix.</source>
          <target state="translated">Это создает &lt;code&gt;LinearOperator&lt;/code&gt; формы &lt;code&gt;A = L + U D V^H&lt;/code&gt; , где &lt;code&gt;L&lt;/code&gt; - &lt;code&gt;LinearOperator&lt;/code&gt; , &lt;code&gt;U, V&lt;/code&gt; обе [пакетные] матрицы, а &lt;code&gt;D&lt;/code&gt; - [пакетная] диагональная матрица.</target>
        </trans-unit>
        <trans-unit id="20e733fb47526c81e38b7224224a075d45127bb0" translate="yes" xml:space="preserve">
          <source>This creates a named directory on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary directories for test purposes, as well as makes it easier to setup directories and verify their contents.</source>
          <target state="translated">При этом создается именованная директория на диске,которая изолирована для данного теста,и будет должным образом очищена тестом.Это позволяет избежать нескольких подводных камней при создании временных каталогов для целей теста,а также упрощает настройку каталогов и проверку их содержимого.</target>
        </trans-unit>
        <trans-unit id="63a4f566bb13c25047e12750280d68497191b0d8" translate="yes" xml:space="preserve">
          <source>This creates a named directory on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary directories for test purposes, as well as makes it easier to setup directories and verify their contents. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75714df8d9550841d3043fbd62dad500169275e6" translate="yes" xml:space="preserve">
          <source>This creates a named file on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary files for test purposes, as well as makes it easier to setup files, their data, read them back, and inspect them when a test fails.</source>
          <target state="translated">При этом создается именованный файл на диске,который изолирован от этого теста,и будет должным образом очищен тестом.Это позволяет избежать нескольких подводных камней при создании временных файлов для целей теста,а также упрощает настройку файлов,их данных,их чтение и проверку в случае неудачи теста.</target>
        </trans-unit>
        <trans-unit id="2f4f8ffa306c5f0499e24ea63e1e0e690360c7a3" translate="yes" xml:space="preserve">
          <source>This creates a named file on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary files for test purposes, as well as makes it easier to setup files, their data, read them back, and inspect them when a test fails. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42646afd71d42ede988399add1a74a5f6b4c93c2" translate="yes" xml:space="preserve">
          <source>This creates a tuple of tensors with the same values as the &lt;code&gt;tensors&lt;/code&gt; argument, except that the value of each tensor is only returned after the values of all tensors have been computed.</source>
          <target state="translated">Это создает кортеж тензоров с теми же значениями, что и аргумент &lt;code&gt;tensors&lt;/code&gt; , за исключением того, что значение каждого тензора возвращается только после того, как значения всех тензоров были вычислены.</target>
        </trans-unit>
        <trans-unit id="89651a110f241aba282c0d3c4d5816a82b95a5ce" translate="yes" xml:space="preserve">
          <source>This dataset attempts to determine whether a valid snapshot exists at the &lt;code&gt;snapshot_path&lt;/code&gt;, and reads from the snapshot in lieu of using &lt;code&gt;input_dataset&lt;/code&gt;. If not, it will run the preprocessing pipeline as usual, and write out a snapshot of the data processed for future use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9dc1c4d1a56233dc4a8e886da12f3f0a495623a" translate="yes" xml:space="preserve">
          <source>This dataset fills a buffer with &lt;code&gt;buffer_size&lt;/code&gt; elements, then randomly samples elements from this buffer, replacing the selected elements with new elements. For perfect shuffling, a buffer size greater than or equal to the full size of the dataset is required.</source>
          <target state="translated">Этот набор данных заполняет буфер элементами &lt;code&gt;buffer_size&lt;/code&gt; , а затем произвольно выбирает элементы из этого буфера, заменяя выбранные элементы новыми элементами. Для идеального перемешивания требуется размер буфера больше или равный полному размеру набора данных.</target>
        </trans-unit>
        <trans-unit id="28c299276126ace248fef26b3267fca38b82ca7a" translate="yes" xml:space="preserve">
          <source>This dataset has been superseded by &lt;code&gt;ParallelInterleaveDatasetV2&lt;/code&gt;. New code should use &lt;code&gt;ParallelInterleaveDatasetV2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97fff19a84ee410a08999fab8be4d199f9066fdc" translate="yes" xml:space="preserve">
          <source>This dataset operator is very useful when running distributed training, as it allows each worker to read a unique subset.</source>
          <target state="translated">Этот оператор набора данных очень полезен при проведении распределенного обучения,так как позволяет каждому работнику прочитать уникальное подмножество.</target>
        </trans-unit>
        <trans-unit id="0601b18d7846c9e12aa36064d4b2b93f04fe9903" translate="yes" xml:space="preserve">
          <source>This dataset will throw a NotFound error if we cannot shard the dataset automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38966f21ae4fd315566bc2e9e41902f2d11ad1fd" translate="yes" xml:space="preserve">
          <source>This decorator allows fine grained control over the gradients of a sequence for operations. This may be useful for multiple reasons, including providing a more efficient or numerically stable gradient for a sequence of operations.</source>
          <target state="translated">Этот декоратор позволяет осуществлять мелкозернистый контроль над градиентами последовательности операций.Это может быть полезно по нескольким причинам,в том числе для обеспечения более эффективного или численно стабильного градиента последовательности операций.</target>
        </trans-unit>
        <trans-unit id="507c4c48f689d10862643a9c65b8ad1497b61251" translate="yes" xml:space="preserve">
          <source>This decorator injects the decorated class or function into the Keras custom object dictionary, so that it can be serialized and deserialized without needing an entry in the user-provided custom object dict. It also injects a function that Keras will call to get the object's serializable string key.</source>
          <target state="translated">Этот декоратор впрыскивает декорированный класс или функцию в пользовательский словарь объектов Keras,так что он может быть сериализован и десериализован без необходимости записи в пользовательском диктате пользовательского объекта.Он также вводит функцию,которую Keras будет вызывать,чтобы получить сериализуемый строковый ключ объекта.</target>
        </trans-unit>
        <trans-unit id="99ba7a22516d6648f4353818a77d3239c06fe661" translate="yes" xml:space="preserve">
          <source>This decorator is only used when defining a new op type. For an op with &lt;code&gt;m&lt;/code&gt; inputs and &lt;code&gt;n&lt;/code&gt; outputs, the gradient function is a function that takes the original &lt;code&gt;Operation&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects (representing the gradients with respect to each output of the op), and returns &lt;code&gt;m&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects (representing the partial gradients with respect to each input of the op).</source>
          <target state="translated">Этот декоратор используется только при определении нового типа операции. Для операции с &lt;code&gt;m&lt;/code&gt; входами и &lt;code&gt;n&lt;/code&gt; выходами функция градиента - это функция, которая принимает исходную &lt;code&gt;Operation&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; объектов &lt;code&gt;Tensor&lt;/code&gt; (представляющих градиенты по отношению к каждому выходу операции) и возвращает &lt;code&gt;m&lt;/code&gt; объектов &lt;code&gt;Tensor&lt;/code&gt; (представляющих частичные градиенты с относительно каждого входа op).</target>
        </trans-unit>
        <trans-unit id="f69390eec43b9170084ec67f23f7df44213faadc" translate="yes" xml:space="preserve">
          <source>This defines the skeleton for all implementations of ClusterResolvers. ClusterResolvers are a way for TensorFlow to communicate with various cluster management systems (e.g. GCE, AWS, etc...) and gives TensorFlow necessary information to set up distributed training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c4ff795b26f67c26110ef2a390028f451d7769" translate="yes" xml:space="preserve">
          <source>This defines the skeleton for all implementations of ClusterResolvers. ClusterResolvers are a way for TensorFlow to communicate with various cluster management systems (e.g. GCE, AWS, etc...).</source>
          <target state="translated">Это определяет скелет для всех реализаций ClusterResolvers.ClusterResolvers-это способ связи TensorFlow с различными системами управления кластерами (например,GCE,AWS и т.д...).</target>
        </trans-unit>
        <trans-unit id="0df31e40439c17db3321616e25b535cdb0316252" translate="yes" xml:space="preserve">
          <source>This definition of cell differs from the definition used in the literature. In the literature, 'cell' refers to an object with a single scalar output. This definition refers to a horizontal array of such units.</source>
          <target state="translated">Это определение ячейки отличается от определения,используемого в литературе.В литературе под &quot;ячейкой&quot; понимается объект с одним скалярным выходом.Это определение относится к горизонтальному массиву таких единиц.</target>
        </trans-unit>
        <trans-unit id="0725a72c209eb53df1440f5a39a25dbf2ab21a14" translate="yes" xml:space="preserve">
          <source>This distribution has parameters: degree of freedom &lt;code&gt;df&lt;/code&gt;, location &lt;code&gt;loc&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;.</source>
          <target state="translated">Это распределение имеет параметры: степень свободы &lt;code&gt;df&lt;/code&gt; , местоположение &lt;code&gt;loc&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11a222f9738197dadd6eb7c453e22ae24d0f3567" translate="yes" xml:space="preserve">
          <source>This does not close the session.</source>
          <target state="translated">Это не закрывает сеанс.</target>
        </trans-unit>
        <trans-unit id="e3bddf2a09aebf2b7d2bb27cde671e8328a7dc27" translate="yes" xml:space="preserve">
          <source>This does not undo the effects of loss scaling. Any optimizers wrapped with a LossScaleOptimizer will continue to do loss scaling, although this loss scaling will no longer be useful if the optimizer is used in new Sessions, as the graph rewrite no longer converts the graph to use float16.</source>
          <target state="translated">Это не отменяет эффекта масштабирования убытков.Любой оптимизатор,обернутый в LossScaleOptimizer,будет продолжать выполнять масштабирование потерь,хотя такое масштабирование потерь будет бесполезно,если оптимизатор будет использоваться в новых сеансах,так как перезапись графика больше не преобразует его в использование float16.</target>
        </trans-unit>
        <trans-unit id="02c54112c729e547b6e3e03e55cab5ced9766b9c" translate="yes" xml:space="preserve">
          <source>This does not undo the effects of loss scaling. Any optimizers wrapped with a LossScaleOptimizer will continue to do loss scaling, although this loss scaling will no longer be useful, as the graph rewrite no longer converts tf.functions to use float16.</source>
          <target state="translated">Это не отменяет эффекта масштабирования убытков.Любой оптимизатор,обернутый в LossScaleOptimizer,будет продолжать делать масштабирование потерь,хотя это масштабирование потерь больше не будет полезным,так как перезапись графа больше не преобразует tf.functions в использование float16.</target>
        </trans-unit>
        <trans-unit id="3bfa5300d7e625917e03fb074107ed12abbdcbbe" translate="yes" xml:space="preserve">
          <source>This eliminates the overhead of &lt;code&gt;k-1&lt;/code&gt; calls to &lt;code&gt;space_to_batch_nd&lt;/code&gt; and &lt;code&gt;batch_to_space_nd&lt;/code&gt;.</source>
          <target state="translated">Это устраняет накладные расходы, связанные &lt;code&gt;k-1&lt;/code&gt; вызовами k-1 для &lt;code&gt;space_to_batch_nd&lt;/code&gt; и &lt;code&gt;batch_to_space_nd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c1542adb4efbb08745cf8660782eb015be7e9a8" translate="yes" xml:space="preserve">
          <source>This enables the new behavior.</source>
          <target state="translated">Это обеспечивает новое поведение.</target>
        </trans-unit>
        <trans-unit id="e158c4e53eb8ef556e4d562ffa77e16f6fc696bb" translate="yes" xml:space="preserve">
          <source>This enables the user to close and release the resource in the middle of a step/run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70309885ebd2feded30214b2bff057bfcef522b" translate="yes" xml:space="preserve">
          <source>This enables variables to be read as bfloat16 type when using get_variable.</source>
          <target state="translated">Это позволяет считывать переменные как тип bfloat16 при использовании get_variable.</target>
        </trans-unit>
        <trans-unit id="9b4ec5604b14a4a73674990062864327b53e189b" translate="yes" xml:space="preserve">
          <source>This enumeration represents optional conversion options.</source>
          <target state="translated">Это перечисление представляет собой необязательные опции преобразования.</target>
        </trans-unit>
        <trans-unit id="26d8315a3de6d7adfdf3bbd23a3ef83e0e870212" translate="yes" xml:space="preserve">
          <source>This estimator ignores feature values and will learn to predict the average value of each label. E.g. for single-label classification problems, this will predict the probability distribution of the classes as seen in the labels. For multi-label classification problems, it will predict the ratio of examples that contain each class.</source>
          <target state="translated">Этот оценщик игнорирует значения функций и учится предсказывать среднее значение каждой метки.Например,для задач классификации по одной этикетке это позволит предсказать распределение вероятностей по классам,как это видно на этикетках.Для задач многомаркировочной классификации он предскажет соотношение примеров,содержащих каждый класс.</target>
        </trans-unit>
        <trans-unit id="c0a3c93652b7acdf673bb2d9770fb27696ed0299" translate="yes" xml:space="preserve">
          <source>This example creates a lookup layer and generates the vocabulary by analyzing the dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9de20f542fbd733883e56dc873754dfb758c273" translate="yes" xml:space="preserve">
          <source>This example creates a lookup layer with a pre-existing vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b0f0177841bd64344b603ca5701c7a1c4bfeec" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to map indices to strings using this layer. (You can also use adapt() with inverse=True, but for simplicity we'll pass the vocab in this example.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a755e66edb0249a30f62c3fbfa9da1107d08395" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to map indices to values using this layer. (You can also use adapt() with inverse=True, but for simplicity we'll pass the vocab in this example.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494bbe4febd153531076a3e5cddcbab4e936bc24" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use a lookup layer with multiple OOV tokens. When a layer is created with more than one OOV token, any OOV values are hashed into the number of OOV buckets, distributing OOV values in a deterministic fashion across the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a4365d2fc53f53ca98893f19670abd4d1d2032" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use the vocabulary of a standard lookup layer to create an inverse lookup layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68786f5a17b7958b628ee0e8691b24f56ab38dc" translate="yes" xml:space="preserve">
          <source>This example gives binary output instead of counting the occurrence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f03708fe58a6d112475001cb64ef56af4e257ac" translate="yes" xml:space="preserve">
          <source>This example instantiates a TextVectorization layer that lowercases text, splits on whitespace, strips punctuation, and outputs integer vocab indices.</source>
          <target state="translated">В этом примере инстанцируется слой TextVectorization,который разбивает текст на пробельные символы,препинания полос и выводит целые словарные индексы.</target>
        </trans-unit>
        <trans-unit id="ee52f3666629477330cedb91ea1ff2368d33cc78" translate="yes" xml:space="preserve">
          <source>This example shows how to instantiate a layer that applies the same dense operation to every element in a sequence, but uses the ellipsis notation instead of specifying the batch and sequence dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7af74c46a4fae38ce9ff64ebe601e504aada00" translate="yes" xml:space="preserve">
          <source>This example shows how to instantiate a layer that applies the same dense operation to every element in a sequence. Here, the 'output_shape' has two values (since there are two non-batch dimensions in the output); the first dimension in the output_shape is &lt;code&gt;None&lt;/code&gt;, because the sequence dimension &lt;code&gt;b&lt;/code&gt; has an unknown shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e9f20f12802c04c896151951f7fd5800246d6c" translate="yes" xml:space="preserve">
          <source>This example shows how to instantiate a standard Keras dense layer using einsum operations. This example is equivalent to &lt;a href=&quot;../dense&quot;&gt;&lt;code&gt;tf.keras.layers.Dense(64, use_bias=True)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf32128894beae4e1d5986c66f68269f1ae0857f" translate="yes" xml:space="preserve">
          <source>This example takes a 2 dimensional input and returns a &lt;code&gt;Tensor&lt;/code&gt; with bincounting on each sample.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f9c3d77008f03aede1949e1e8b86cf490084ce8" translate="yes" xml:space="preserve">
          <source>This example takes an input (which could be a Tensor, RaggedTensor, or SparseTensor) and returns a SparseTensor where (i,j) is 1 if the value j appears in batch i at least once and is 0 otherwise. Note that, even though some values (like 20 in batch 1 and 11 in batch 2) appear more than once, the 'values' tensor is all 1s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3981b34919fca04a3be3649adee342abfe3505a" translate="yes" xml:space="preserve">
          <source>This example takes an input (which could be a Tensor, RaggedTensor, or SparseTensor) and returns a SparseTensor where the value of (i,j) is the number of times value j appears in batch i.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd04c77a84f7fb7b79c65a0782e87dc8901b29b" translate="yes" xml:space="preserve">
          <source>This example takes an input (which could be a Tensor, RaggedTensor, or SparseTensor) and returns a SparseTensor where the value of (i,j) is the number of times value j appears in batch i. However, all values of j above 'maxlength' are ignored. The dense_shape of the output sparse tensor is set to 'minlength'. Note that, while the input is identical to the example above, the value '10001' in batch item 2 is dropped, and the dense shape is [2, 500] instead of [2,10002] or [2, 102].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad6c7816616b3241d748e89b2cfcff037903efa" translate="yes" xml:space="preserve">
          <source>This example takes two inputs - a values tensor and a weights tensor. These tensors must be identically shaped, and have the same row splits or indices in the case of RaggedTensors or SparseTensors. When performing a weighted count, the op will output a SparseTensor where the value of (i, j) is the sum of the values in the weight tensor's batch i in the locations where the values tensor has the value j. In this case, the output dtype is the same as the dtype of the weights tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8a0001b21c834c94ffc58110b29147780ed1bc" translate="yes" xml:space="preserve">
          <source>This exception is most commonly raised when running an operation that reads a &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; before it has been initialized.</source>
          <target state="translated">Это исключение чаще всего возникает при запуске операции, которая считывает &lt;a href=&quot;../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; до ее инициализации.</target>
        </trans-unit>
        <trans-unit id="5c5a8c57c6d5ff0bef6c24b2e2bd3f673907515f" translate="yes" xml:space="preserve">
          <source>This exception is not currently used.</source>
          <target state="translated">В настоящее время это исключение не используется.</target>
        </trans-unit>
        <trans-unit id="f99d6b607eb42d98eb52dda612321114e3e91d9d" translate="yes" xml:space="preserve">
          <source>This exception is raised in &quot;end-of-file&quot; conditions, such as when a &lt;code&gt;tf.QueueBase.dequeue&lt;/code&gt; operation is blocked on an empty queue, and a &lt;code&gt;tf.QueueBase.close&lt;/code&gt; operation executes.</source>
          <target state="translated">Это исключение возникает в условиях &amp;laquo;конца файла&amp;raquo;, например, когда операция &lt;code&gt;tf.QueueBase.dequeue&lt;/code&gt; блокируется в пустой очереди и &lt;code&gt;tf.QueueBase.close&lt;/code&gt; операция tf.QueueBase.close .</target>
        </trans-unit>
        <trans-unit id="78d71c0636a2aa1fd087c8298d2d2e031276f9b2" translate="yes" xml:space="preserve">
          <source>This exception is raised when some invariant expected by the runtime has been broken. Catching this exception is not recommended.</source>
          <target state="translated">Это исключение поднимается,когда некоторый инвариант,ожидаемый во время выполнения,был нарушен.Ловить это исключение не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="7057b737e9dfe1ba0218e510ec51533edf1eab95" translate="yes" xml:space="preserve">
          <source>This exists primarily to support the definition of type-specific summary ops like scalar() and image(), and is not intended for direct use unless defining a new type-specific summary op.</source>
          <target state="translated">Это существует в первую очередь для поддержки определений сводных операторов,таких как scalar()и image(),и не предназначено для непосредственного использования,если только не определен новый сводный оператор,специфичный для конкретного типа.</target>
        </trans-unit>
        <trans-unit id="42562f80c79b3f19581dfb21136c32f3ec5adea4" translate="yes" xml:space="preserve">
          <source>This facilitates a cleaner api around global state. Instead of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7cea24b85385b2c626baad7c000ac087d0ac17d" translate="yes" xml:space="preserve">
          <source>This file includes functions and constants from core (model_utils) and export.py</source>
          <target state="translated">Этот файл включает функции и константы из ядра (model_utils)и export.py.</target>
        </trans-unit>
        <trans-unit id="1ed5997b223ee14f22d4d6301133fe48a3becd70" translate="yes" xml:space="preserve">
          <source>This flag will have a value of None, True or False. None is possible if default=None and the user does not specify the flag on the command line.</source>
          <target state="translated">Этот флаг будет иметь значение None,True или False.Нет возможно,если по умолчанию=None и пользователь не указывает флаг в командной строке.</target>
        </trans-unit>
        <trans-unit id="edc3e42fb098d2f82cf52f313f0a2bbc39d59acf" translate="yes" xml:space="preserve">
          <source>This foldl operator repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from first to last. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0. The callable fn takes two tensors as arguments. The first argument is the accumulated value computed from the preceding invocation of fn, and the second is the value at the current position of &lt;code&gt;elems&lt;/code&gt;. If &lt;code&gt;initializer&lt;/code&gt; is None, &lt;code&gt;elems&lt;/code&gt; must contain at least one element, and its first element is used as the initializer.</source>
          <target state="translated">Этот оператор foldl многократно применяет вызываемую &lt;code&gt;fn&lt;/code&gt; к последовательности элементов от первого до последнего. Элементы состоят из тензоров, распакованных из &lt;code&gt;elems&lt;/code&gt; в размерности 0. Вызываемая функция fn принимает в качестве аргументов два тензора. Первый аргумент - это накопленное значение, вычисленное из предыдущего вызова fn, а второй - это значение в текущей позиции &lt;code&gt;elems&lt;/code&gt; . Если &lt;code&gt;initializer&lt;/code&gt; равен None, &lt;code&gt;elems&lt;/code&gt; должен содержать хотя бы один элемент, и его первый элемент используется как инициализатор.</target>
        </trans-unit>
        <trans-unit id="5c9efc4e60690682d054976cd526187b0ec74f90" translate="yes" xml:space="preserve">
          <source>This foldr operator repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from last to first. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt;. The callable fn takes two tensors as arguments. The first argument is the accumulated value computed from the preceding invocation of fn, and the second is the value at the current position of &lt;code&gt;elems&lt;/code&gt;. If &lt;code&gt;initializer&lt;/code&gt; is None, &lt;code&gt;elems&lt;/code&gt; must contain at least one element, and its first element is used as the initializer.</source>
          <target state="translated">Этот оператор foldr многократно применяет вызываемую &lt;code&gt;fn&lt;/code&gt; к последовательности элементов от последнего до первого. Элементы составлены из тензоров, распакованных из &lt;code&gt;elems&lt;/code&gt; . Вызываемая функция fn принимает в качестве аргументов два тензора. Первый аргумент - это накопленное значение, вычисленное в результате предыдущего вызова fn, а второй - это значение в текущей позиции &lt;code&gt;elems&lt;/code&gt; . Если &lt;code&gt;initializer&lt;/code&gt; равен None, &lt;code&gt;elems&lt;/code&gt; должен содержать хотя бы один элемент, и его первый элемент используется как инициализатор.</target>
        </trans-unit>
        <trans-unit id="e47bc5be6551c40b285b99814572b5e2b249a8b5" translate="yes" xml:space="preserve">
          <source>This function adds operations to the current session. To compute the error using a particular device, such as a GPU, use the standard methods for setting a device (e.g. using with sess.graph.device() or setting a device function in the session constructor).</source>
          <target state="translated">Эта функция добавляет операции к текущей сессии.Для вычисления ошибки с использованием конкретного устройства,например,GPU,используйте стандартные методы для установки устройства (например,используя sess.graph.device()или устанавливая функцию устройства в конструкторе сеанса).</target>
        </trans-unit>
        <trans-unit id="b1c988623a891fbccad5b0fbb3db51dcb83f9a90" translate="yes" xml:space="preserve">
          <source>This function adds the following to the current &lt;code&gt;Graph&lt;/code&gt;:</source>
          <target state="translated">Эта функция добавляет к текущему &lt;code&gt;Graph&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7391056d9f36003196c437fbb04f6186eed40dde" translate="yes" xml:space="preserve">
          <source>This function allows expressing computations in a TensorFlow graph as Python functions. In particular, it wraps a Python function &lt;code&gt;func&lt;/code&gt; in a once-differentiable TensorFlow operation that executes it with eager execution enabled. As a consequence, &lt;a href=&quot;py_function&quot;&gt;&lt;code&gt;tf.py_function&lt;/code&gt;&lt;/a&gt; makes it possible to express control flow using Python constructs (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, etc.), instead of TensorFlow control flow constructs (&lt;a href=&quot;cond&quot;&gt;&lt;code&gt;tf.cond&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;while_loop&quot;&gt;&lt;code&gt;tf.while_loop&lt;/code&gt;&lt;/a&gt;). For example, you might use &lt;a href=&quot;py_function&quot;&gt;&lt;code&gt;tf.py_function&lt;/code&gt;&lt;/a&gt; to implement the log huber function:</source>
          <target state="translated">Эта функция позволяет выражать вычисления на графике TensorFlow как функции Python. В частности, он оборачивает функцию Python &lt;code&gt;func&lt;/code&gt; в некогда дифференцируемую операцию TensorFlow, которая выполняет ее с включенным нетерпеливым выполнением. Как следствие, &lt;a href=&quot;py_function&quot;&gt; &lt;code&gt;tf.py_function&lt;/code&gt; &lt;/a&gt; позволяет выражать поток управления с использованием конструкций Python ( &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; и т. Д.) Вместо конструкций потока управления &lt;a href=&quot;cond&quot;&gt; &lt;code&gt;tf.cond&lt;/code&gt; &lt;/a&gt; ( tf.cond , &lt;a href=&quot;while_loop&quot;&gt; &lt;code&gt;tf.while_loop&lt;/code&gt; &lt;/a&gt; . While_loop ). Например, вы можете использовать &lt;a href=&quot;py_function&quot;&gt; &lt;code&gt;tf.py_function&lt;/code&gt; &lt;/a&gt; для реализации функции log huber:</target>
        </trans-unit>
        <trans-unit id="fa49b9c5fb3cc27a08b15ff4c8fbc286bffc2bb3" translate="yes" xml:space="preserve">
          <source>This function allows replacing a function wrapped by &lt;code&gt;decorator_func&lt;/code&gt;, assuming the decorator that wraps the function is written as described below.</source>
          <target state="translated">Эта функция позволяет заменить функцию, обернутую &lt;code&gt;decorator_func&lt;/code&gt; , при условии, что декоратор, который обертывает функцию, написан, как описано ниже.</target>
        </trans-unit>
        <trans-unit id="f1af1fe4443bcb9edf1df9ce5ca5cc1b073069a3" translate="yes" xml:space="preserve">
          <source>This function also returns a &lt;code&gt;should_apply_gradients&lt;/code&gt; bool. If False, gradients should not be applied to the variables that step, as nonfinite gradients were found, and the loss scale has been be updated to reduce the chance of finding nonfinite gradients in the next step. Some loss scale classes will always return True, as they cannot adjust themselves in response to nonfinite gradients.</source>
          <target state="translated">Эта функция также возвращает &lt;code&gt;should_apply_gradients&lt;/code&gt; значение should_apply_gradients . Если установлено значение False, градиенты не должны применяться к переменным на этом шаге, поскольку были обнаружены нескончаемые градиенты и была обновлена ​​шкала потерь, чтобы уменьшить вероятность обнаружения нескончаемых градиентов на следующем шаге. Некоторые классы шкалы потерь всегда возвращают True, поскольку они не могут настраиваться в ответ на неопределенные градиенты.</target>
        </trans-unit>
        <trans-unit id="a970dd1ee86d1ed9e7a0f4a5fcb3e14f9903fdf2" translate="yes" xml:space="preserve">
          <source>This function assumes that &lt;code&gt;img1&lt;/code&gt; and &lt;code&gt;img2&lt;/code&gt; are image batches, i.e. the last three dimensions are [height, width, channels].</source>
          <target state="translated">Эта функция предполагает, что &lt;code&gt;img1&lt;/code&gt; и &lt;code&gt;img2&lt;/code&gt; являются пакетами изображений, то есть последние три измерения - это [высота, ширина, каналы].</target>
        </trans-unit>
        <trans-unit id="05e4418b517bd473a485966680131f4c4c444d83" translate="yes" xml:space="preserve">
          <source>This function attempts to partially evaluate the given tensor, and returns its value as a numpy ndarray if this succeeds.</source>
          <target state="translated">Эта функция пытается частично оценить данный тензор и возвращает его значение в виде числового индикатора,если это удается.</target>
        </trans-unit>
        <trans-unit id="cf86c424c057435bb07a468ed262a1bc87e5ff48" translate="yes" xml:space="preserve">
          <source>This function can be called at the beginning of the program (before &lt;code&gt;Tensors&lt;/code&gt;, &lt;code&gt;Graphs&lt;/code&gt; or other structures have been created, and before devices have been initialized. It switches all global behaviors that are different between TensorFlow 1.x and 2.x to behave as intended for 1.x.</source>
          <target state="translated">Эта функция может быть вызвана в начале программы (до &lt;code&gt;Tensors&lt;/code&gt; , &lt;code&gt;Graphs&lt;/code&gt; или других структур и до инициализации устройств. Она переключает все глобальные поведения, которые различаются между TensorFlow 1.x и 2.x, чтобы вести себя как предназначен для 1.x.</target>
        </trans-unit>
        <trans-unit id="10057d11c28687d408d56022580e8ea6fe2a793b" translate="yes" xml:space="preserve">
          <source>This function can be called at the beginning of the program (before &lt;code&gt;Tensors&lt;/code&gt;, &lt;code&gt;Graphs&lt;/code&gt; or other structures have been created, and before devices have been initialized. It switches all global behaviors that are different between TensorFlow 1.x and 2.x to behave as intended for 2.x.</source>
          <target state="translated">Эта функция может быть вызвана в начале программы (до &lt;code&gt;Tensors&lt;/code&gt; , &lt;code&gt;Graphs&lt;/code&gt; или других структур и до инициализации устройств. Она переключает все глобальные поведения, которые различаются между TensorFlow 1.x и 2.x, чтобы вести себя как предназначен для 2.x.</target>
        </trans-unit>
        <trans-unit id="b42e569daa67e0a1534f20b78d521ba43e71fa0e" translate="yes" xml:space="preserve">
          <source>This function can be used to calculate a suitable paddings argument for use with space_to_batch_nd and batch_to_space_nd.</source>
          <target state="translated">Эта функция может быть использована для вычисления подходящего аргумента paddings для использования с space_to_batch_nd и batch_to_space_nd.</target>
        </trans-unit>
        <trans-unit id="c744362e6d55098ce01656aff7353b51e78a3f8e" translate="yes" xml:space="preserve">
          <source>This function can be useful when composing a new operation in Python (such as &lt;code&gt;my_func&lt;/code&gt; in the example above). All standard Python op constructors apply this function to each of their Tensor-valued inputs, which allows those ops to accept numpy arrays, Python lists, and scalars in addition to &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="translated">Эта функция может быть полезна при создании новой операции в Python (например, &lt;code&gt;my_func&lt;/code&gt; в приведенном выше примере). Все стандартные конструкторы операций Python применяют эту функцию к каждому из своих входов с тензорным значением, что позволяет этим операциям принимать массивы numpy, списки Python и скаляры в дополнение к объектам &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217d0b2441a5002feaf4d45bd68846f61852099e" translate="yes" xml:space="preserve">
          <source>This function can compute several different vector norms (the 1-norm, the Euclidean or 2-norm, the inf-norm, and in general the p-norm for p &amp;gt; 0) and matrix norms (Frobenius, 1-norm, 2-norm and inf-norm).</source>
          <target state="translated">Эта функция может вычислять несколько различных векторных норм (1-норма, евклидова или 2-норма, инф-норма и вообще p-норма для p&amp;gt; 0) и матричных норм (Фробениуса, 1-норма, 2- норма и инф-норма).</target>
        </trans-unit>
        <trans-unit id="3ea434ce2125739c9300b55f884e2363f68836bb" translate="yes" xml:space="preserve">
          <source>This function can only be called before any Graphs, Ops, or Tensors have been created. It can be used at the beginning of the program for complex migration projects from TensorFlow 1.x to 2.x.</source>
          <target state="translated">Эта функция может быть вызвана только до того,как будут созданы графики,операционные системы или тензоры.Она может быть использована в начале программы для сложных проектов миграции с TensorFlow 1.x на 2.x.</target>
        </trans-unit>
        <trans-unit id="588718f27309c0577e10569b211613b30b1126d6" translate="yes" xml:space="preserve">
          <source>This function casts the input to &lt;code&gt;dtype&lt;/code&gt; without applying any scaling. If there is a danger that values would over or underflow in the cast, this op applies the appropriate clamping before the cast.</source>
          <target state="translated">Эта функция &lt;code&gt;dtype&lt;/code&gt; входные данные в dtype без применения масштабирования. Если существует опасность того, что значения будут переполнены или занижены в отливке, эта операция применяет соответствующий зажим перед отливкой.</target>
        </trans-unit>
        <trans-unit id="09decee67bf539dd150a70f2c58935c601acb068" translate="yes" xml:space="preserve">
          <source>This function computes the exponential of every element in the input tensor. i.e. &lt;code&gt;exp(x)&lt;/code&gt; or &lt;code&gt;e^(x)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the input tensor. &lt;code&gt;e&lt;/code&gt; denotes Euler's number and is approximately equal to 2.718281. Output is positive for any real input.</source>
          <target state="translated">Эта функция вычисляет экспоненту каждого элемента входного тензора. т.е. &lt;code&gt;exp(x)&lt;/code&gt; или &lt;code&gt;e^(x)&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; - входной тензор. &lt;code&gt;e&lt;/code&gt; обозначает число Эйлера и приблизительно равно 2,718281. Выход положительный для любого реального входа.</target>
        </trans-unit>
        <trans-unit id="5fcc9bd16353155f925829234fcc96a9dbe0c86d" translate="yes" xml:space="preserve">
          <source>This function computes the exponential of the input tensor element-wise. i.e. &lt;a href=&quot;exp&quot;&gt;&lt;code&gt;math.exp(x)&lt;/code&gt;&lt;/a&gt; or \(e^x\), where &lt;code&gt;x&lt;/code&gt; is the input tensor. \(e\) denotes Euler's number and is approximately equal to 2.718281. Output is positive for any real input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0a191a50e5e9af59c01d8569f306fc43d930b1" translate="yes" xml:space="preserve">
          <source>This function computes the matrix logarithm using the Schur-Parlett algorithm. Details of the algorithm can be found in Section 11.6.2 of: Nicholas J. Higham, Functions of Matrices: Theory and Computation, SIAM 2008. ISBN 978-0-898716-46-7.</source>
          <target state="translated">Данная функция вычисляет логарифм матрицы,используя алгоритм Шур-Парлетта.Подробнее с алгоритмом можно ознакомиться в разделе 11.6.2:Николаса Хайама,Функции матриц:Теория и вычисления,SIAM 2008.ISBN 978-0-898716-46-7.</target>
        </trans-unit>
        <trans-unit id="be1f544dd8e61bda50e9ba11ee30c7fa32e6f8ea" translate="yes" xml:space="preserve">
          <source>This function converts Python objects of various types to &lt;code&gt;Tensor&lt;/code&gt; objects. It accepts &lt;code&gt;Tensor&lt;/code&gt; objects, numpy arrays, Python lists, and Python scalars. For example:</source>
          <target state="translated">Эта функция преобразует объекты Python различных типов в объекты &lt;code&gt;Tensor&lt;/code&gt; . Он принимает объекты &lt;code&gt;Tensor&lt;/code&gt; , массивы numpy, списки Python и скаляры Python. Например:</target>
        </trans-unit>
        <trans-unit id="e487da37eb7d13adb8d956491efcafe1ed6b6abd" translate="yes" xml:space="preserve">
          <source>This function creates a new Generator object (and the Variable object within), which does not work well with tf.function because (1) tf.function puts restrictions on Variable creation thus reset_global_generator can't be freely used inside tf.function; (2) redirecting a global variable to a new object is problematic with tf.function because the old object may be captured by a 'tf.function'ed function and still be used by it. A 'tf.function'ed function only keeps weak references to variables, so deleting a variable and then calling that function again may raise an error, as demonstrated by random_test.py/RandomTest.testResetGlobalGeneratorBadWithDefun .</source>
          <target state="translated">Эта функция создает новый объект Generator (и объект Variable внутри него),который плохо работает с tf.function,потому что (1)tf.function накладывает ограничения на создание переменных,поэтому reset_global_generator не может свободно использоваться внутри tf.function;(2)перенаправление глобальной переменной на новый объект проблематично с tf.function,потому что старый объект может быть перехвачен функцией 'tf.function' ed и все еще использоваться ею.Функция 'tf.function' ed хранит только слабые ссылки на переменные,поэтому удаление переменной и последующий вызов этой функции может привести к ошибке,что демонстрируется функцией random_test.py/RandomTest.testResetGlobalGeneratorBadWithDefun .</target>
        </trans-unit>
        <trans-unit id="7bd8be377fdf00edb4e98ffd4a0d17d3f66c21a2" translate="yes" xml:space="preserve">
          <source>This function divides &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, forcing Python 2 semantics. That is, if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both integers then the result will be an integer. This is in contrast to Python 3, where division with &lt;code&gt;/&lt;/code&gt; is always a float while division with &lt;code&gt;//&lt;/code&gt; is always an integer.</source>
          <target state="translated">Эта функция делит &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , форсируя семантику Python 2. То есть, если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются целыми числами, результатом будет целое число. В этом отличие от Python 3, где деление на &lt;code&gt;/&lt;/code&gt; всегда является числом с плавающей запятой, а деление на &lt;code&gt;//&lt;/code&gt; всегда целым числом.</target>
        </trans-unit>
        <trans-unit id="d24aa00a66ce40fc5a2092349ae7643f400f331a" translate="yes" xml:space="preserve">
          <source>This function enables you to use a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; in a stateless &quot;tensor-in tensor-out&quot; expression, without creating a &lt;a href=&quot;../../compat/v1/data/iterator&quot;&gt;&lt;code&gt;tf.compat.v1.data.Iterator&lt;/code&gt;&lt;/a&gt;. This can be useful when your preprocessing transformations are expressed as a &lt;code&gt;Dataset&lt;/code&gt;, and you want to use the transformation at serving time. For example:</source>
          <target state="translated">Эта функция позволяет использовать &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; в выражении &amp;laquo;тензор- вход -тензор-выход&amp;raquo; без &lt;a href=&quot;../../compat/v1/data/iterator&quot;&gt; &lt;code&gt;tf.compat.v1.data.Iterator&lt;/code&gt; &lt;/a&gt; , не создавая tf.compat.v1.data.Iterator . Это может быть полезно, когда ваши преобразования предварительной обработки выражены как &lt;code&gt;Dataset&lt;/code&gt; , и вы хотите использовать преобразование во время обслуживания. Например:</target>
        </trans-unit>
        <trans-unit id="dcd4ee76305c19cb19df5a4e6d70410c1e1185ec" translate="yes" xml:space="preserve">
          <source>This function enables you to use a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; in a stateless &quot;tensor-in tensor-out&quot; expression, without creating an iterator. This can be useful when your preprocessing transformations are expressed as a &lt;code&gt;Dataset&lt;/code&gt;, and you want to use the transformation at serving time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43245fcf24b3e5f89c388ed18c02c0b4b9e1fd8d" translate="yes" xml:space="preserve">
          <source>This function enqueues a structure of features to be looked up in the embedding tables. We expect that the batch size of each of the tensors in features matches the per core batch size. This will automatically happen if your input dataset is batched to the global batch size and you use &lt;a href=&quot;../../../distribute/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; or if you use &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; and batch to the per core batch size computed by the context passed to your input function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af17991dd15e2b7fa7774cc8e8187690043ab3dd" translate="yes" xml:space="preserve">
          <source>This function exists only for backwards compatibility purposes; new code should use &lt;code&gt;__floordiv__&lt;/code&gt; via the syntax &lt;code&gt;x // y&lt;/code&gt;. Using &lt;code&gt;x // y&lt;/code&gt; communicates clearly that the result rounds down, and is forward compatible to Python 3.</source>
          <target state="translated">Эта функция существует только для целей обратной совместимости; новый код должен использовать &lt;code&gt;__floordiv__&lt;/code&gt; через синтаксис &lt;code&gt;x // y&lt;/code&gt; . Использование &lt;code&gt;x // y&lt;/code&gt; ясно показывает, что результат округляется в меньшую сторону и совместим с Python 3.</target>
        </trans-unit>
        <trans-unit id="1a2f6439e571c218e4f990c2f6f9f31b011962aa" translate="yes" xml:space="preserve">
          <source>This function exists only to have a better error message. Instead of: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'Dimension' and 'int'&lt;/code&gt;, this function will explicitly call for usage of &lt;code&gt;//&lt;/code&gt; instead.</source>
          <target state="translated">Эта функция существует только для лучшего сообщения об ошибке. Вместо: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'Dimension' and 'int'&lt;/code&gt; , эта функция будет явно вызывать использование &lt;code&gt;//&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="6bf09410a9b47558afad7eb9fc6a9929885c6dd9" translate="yes" xml:space="preserve">
          <source>This function exists only to have a better error message. Instead of: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'int' and 'Dimension'&lt;/code&gt;, this function will explicitly call for usage of &lt;code&gt;//&lt;/code&gt; instead.</source>
          <target state="translated">Эта функция существует только для лучшего сообщения об ошибке. Вместо: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'int' and 'Dimension'&lt;/code&gt; , эта функция будет явно вызывать использование &lt;code&gt;//&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="7046a2ab2d223422699f2f1db88f8efbcff064ed" translate="yes" xml:space="preserve">
          <source>This function exports the graph, saver, and collection objects into &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer with the intention of it being imported at a later time or location to restart training, run inference, or be a subgraph.</source>
          <target state="translated">Эта функция экспортирует объекты графика, заставки и коллекции в &lt;code&gt;MetaGraphDef&lt;/code&gt; протокола MetaGraphDef с намерением импортировать их в более позднее время или в другое место, чтобы перезапустить обучение, выполнить логический вывод или стать подграфом.</target>
        </trans-unit>
        <trans-unit id="7a855742752eb51788b391963ce908a091cbe366" translate="yes" xml:space="preserve">
          <source>This function follows the &lt;a href=&quot;http://htk.eng.cam.ac.uk/&quot;&gt;Hidden Markov Model Toolkit (HTK)&lt;/a&gt; convention, defining the mel scale in terms of a frequency in hertz according to the following formula:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a27fb60b44269b202e3c908e7cb802642c2ac28" translate="yes" xml:space="preserve">
          <source>This function forces Python 3 division operator semantics where all integer arguments are cast to floating types first. This op is generated by normal &lt;code&gt;x / y&lt;/code&gt; division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;. If you want integer division that rounds down, use &lt;code&gt;x // y&lt;/code&gt; or &lt;code&gt;tf.math.floordiv&lt;/code&gt;.</source>
          <target state="translated">Эта функция форсирует семантику оператора деления Python 3, в которой все целочисленные аргументы сначала приводятся к плавающим типам. Эта операция генерируется обычным делением &lt;code&gt;x / y&lt;/code&gt; в Python 3 и Python 2.7 с &lt;code&gt;from __future__ import division&lt;/code&gt; . Если вам нужно целочисленное деление с &lt;code&gt;tf.math.floordiv&lt;/code&gt; сторону, используйте &lt;code&gt;x // y&lt;/code&gt; или tf.math.floordiv .</target>
        </trans-unit>
        <trans-unit id="4d4720bce15c58196c687612f77168d6737d499a" translate="yes" xml:space="preserve">
          <source>This function generalizes the &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; op by also supporting a Soft-NMS (with Gaussian weighting) mode (c.f. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes instead of directly causing them to be pruned. Consequently, in contrast to &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;non_max_suppression_padded&quot;&gt;&lt;code&gt;tf.image.non_max_suppression_padded&lt;/code&gt;&lt;/a&gt; returns the new scores of each input box in the second output, &lt;code&gt;selected_scores&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b139bf71180b25aa620a27f39c22f066fe31fcf7" translate="yes" xml:space="preserve">
          <source>This function generalizes the &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; op by also supporting a Soft-NMS (with Gaussian weighting) mode (c.f. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes instead of directly causing them to be pruned. Consequently, in contrast to &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; returns the new scores of each input box in the second output, &lt;code&gt;selected_scores&lt;/code&gt;.</source>
          <target state="translated">Эта функция обобщает &lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt; , также поддерживая режим Soft-NMS (с гауссовским взвешиванием) (см. Бодла и др., Https://arxiv.org/abs/1704.04503), где блоки уменьшают оценку других перекрывающихся блоков. вместо того, чтобы напрямую вызывать их обрезку. Следовательно, в отличие от &lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; возвращает новые оценки каждого поля ввода во втором выводе &lt;code&gt;selected_scores&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f78cfdbddd70d6ebd322125da902964ca2c0221" translate="yes" xml:space="preserve">
          <source>This function generates a weighted sum based on output dimension &lt;code&gt;units&lt;/code&gt;. Weighted sum refers to logits in classification problems. It refers to the prediction itself for linear regression problems.</source>
          <target state="translated">Эта функция генерирует взвешенную сумму на основе &lt;code&gt;units&lt;/code&gt; измерения вывода . Взвешенная сумма относится к логитам в задачах классификации. Это относится к самому прогнозу для задач линейной регрессии.</target>
        </trans-unit>
        <trans-unit id="b7164aa4227947230adf26e333ecf50d207f9d4e" translate="yes" xml:space="preserve">
          <source>This function ignores flags whose value is None. Each flag assignment is separated by a newline.</source>
          <target state="translated">Эта функция игнорирует флаги,значение которых равно None.Каждое присвоение флага отделяется новой строкой.</target>
        </trans-unit>
        <trans-unit id="0c81aeff7442b1d7f71d30de1b5da89dfe187de7" translate="yes" xml:space="preserve">
          <source>This function in addition also allows assignment to a sliced range. This is similar to &lt;code&gt;__setitem__&lt;/code&gt; functionality in Python. However, the syntax is different so that the user can capture the assignment operation for grouping or passing to &lt;code&gt;sess.run()&lt;/code&gt;. For example,</source>
          <target state="translated">Эта функция дополнительно также позволяет назначать нарезанный диапазон. Это похоже на функциональность &lt;code&gt;__setitem__&lt;/code&gt; в Python. Однако синтаксис отличается, поэтому пользователь может зафиксировать операцию присваивания для группировки или передачи в &lt;code&gt;sess.run()&lt;/code&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="f477dc6f411c004d0b07e1741886385a8bad1741" translate="yes" xml:space="preserve">
          <source>This function is a more primitive version of &lt;code&gt;dynamic_rnn&lt;/code&gt; that provides more direct access to the inputs each iteration. It also provides more control over when to start and finish reading the sequence, and what to emit for the output.</source>
          <target state="translated">Эта функция является более примитивной версией &lt;code&gt;dynamic_rnn&lt;/code&gt; , которая обеспечивает более прямой доступ к входам на каждой итерации. Он также обеспечивает больший контроль над тем, когда начинать и заканчивать чтение последовательности, и что выдавать для вывода.</target>
        </trans-unit>
        <trans-unit id="b35cb926e7e56c5e0bb4984bfdd19c6c71696446" translate="yes" xml:space="preserve">
          <source>This function is a simpler wrapper around the more general &lt;a href=&quot;convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt;, and exists only for backwards compatibility. You can use &lt;a href=&quot;convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt; to perform 1-D, 2-D, or 3-D atrous convolution.</source>
          <target state="translated">Эта функция является более простой оболочкой для более общего &lt;a href=&quot;convolution&quot;&gt; &lt;code&gt;tf.nn.convolution&lt;/code&gt; &lt;/a&gt; и существует только для обратной совместимости. Вы можете использовать &lt;a href=&quot;convolution&quot;&gt; &lt;code&gt;tf.nn.convolution&lt;/code&gt; &lt;/a&gt; для выполнения одномерной , двухмерной или трехмерной свертки.</target>
        </trans-unit>
        <trans-unit id="1fde94a598e8772eaea3cc47dd741a3aa23b5c85" translate="yes" xml:space="preserve">
          <source>This function is analogous to &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.pinv.html&quot;&gt;&lt;code&gt;numpy.linalg.pinv&lt;/code&gt;&lt;/a&gt;. It differs only in default value of &lt;code&gt;rcond&lt;/code&gt;. In &lt;code&gt;numpy.linalg.pinv&lt;/code&gt;, the default &lt;code&gt;rcond&lt;/code&gt; is &lt;code&gt;1e-15&lt;/code&gt;. Here the default is &lt;code&gt;10. * max(num_rows, num_cols) * np.finfo(dtype).eps&lt;/code&gt;.</source>
          <target state="translated">Эта функция аналогична &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.pinv.html&quot;&gt; &lt;code&gt;numpy.linalg.pinv&lt;/code&gt; &lt;/a&gt; . Он отличается только значением &lt;code&gt;rcond&lt;/code&gt; по умолчанию . В &lt;code&gt;numpy.linalg.pinv&lt;/code&gt; , по умолчанию &lt;code&gt;rcond&lt;/code&gt; является &lt;code&gt;1e-15&lt;/code&gt; . Здесь значение по умолчанию - &lt;code&gt;10. * max(num_rows, num_cols) * np.finfo(dtype).eps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c82b17de9fe920f72f7a5369e74c77b8a5f75d81" translate="yes" xml:space="preserve">
          <source>This function is based on the standard SSIM implementation from: Wang, Z., Bovik, A. C., Sheikh, H. R., &amp;amp; Simoncelli, E. P. (2004). Image quality assessment: from error visibility to structural similarity. IEEE transactions on image processing.</source>
          <target state="translated">Эта функция основана на стандартной реализации SSIM от Wang, Z., Bovik, AC, Sheikh, HR, &amp;amp; Simoncelli, EP (2004). Оценка качества изображения: от видимости ошибок до структурного сходства. Транзакции IEEE по обработке изображений.</target>
        </trans-unit>
        <trans-unit id="3f78f322021258197ee0401af332233d4fb6c937" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;../model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;../model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d4062526248415274d1920f151d5925ea1d106" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;../model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73ed236f67dee6103073403c6d29f26833958d9" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;../model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;../model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c02b98872d235ad42d3656b50ce22017eda7ff2" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1d8a8ff69ef7a941ba68b453aec429bfe458e1" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0db761a3ad75448d327cc87f61eb8b0729f377" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecacc04269db8f28f91780c2b346f24c2d101704" translate="yes" xml:space="preserve">
          <source>This function is called between epochs/steps, when a metric is evaluated during training.</source>
          <target state="translated">Эта функция вызывается между эпохами/шагами,когда метрика оценивается во время обучения.</target>
        </trans-unit>
        <trans-unit id="a75cbe1aa934dcb50e2537aae264b28dbab09250" translate="yes" xml:space="preserve">
          <source>This function is called by FLAGS(argv). It scans the input list for a flag that looks like: --flagfile=</source>
          <target state="translated">Эта функция вызывается FLAGS(argv).Она сканирует входной список на наличие флага,который выглядит как:--flagfile=</target>
        </trans-unit>
        <trans-unit id="e57b5dff2b7e230f6a359d3b07cb810778cc3047" translate="yes" xml:space="preserve">
          <source>This function is called in the main TensorFlow &lt;code&gt;__init__.py&lt;/code&gt; file, user should not need to call it, except during complex migrations.</source>
          <target state="translated">Эта функция вызывается в основном файле TensorFlow &lt;code&gt;__init__.py&lt;/code&gt; , пользователю не нужно вызывать ее, за исключением сложных миграций.</target>
        </trans-unit>
        <trans-unit id="0831cfa041ba84a9c1bb953a8575728ee9dbe8bf" translate="yes" xml:space="preserve">
          <source>This function is faster and numerically stabler than &lt;code&gt;bessel_i0(x)&lt;/code&gt;.</source>
          <target state="translated">Эта функция быстрее и численно более стабильна, чем &lt;code&gt;bessel_i0(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f2e499db54e57708a372078c16af5df37036099" translate="yes" xml:space="preserve">
          <source>This function is faster and numerically stabler than &lt;code&gt;bessel_i1(x)&lt;/code&gt;.</source>
          <target state="translated">Эта функция быстрее и численно более стабильна, чем &lt;code&gt;bessel_i1(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7e374cf0f52d98689ddb22ec7b9e2a428cd4956" translate="yes" xml:space="preserve">
          <source>This function is implemented using a queue. A &lt;code&gt;QueueRunner&lt;/code&gt; for the queue is added to the current &lt;code&gt;Graph&lt;/code&gt;'s &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; collection.</source>
          <target state="translated">Эта функция реализована с помощью очереди. &lt;code&gt;QueueRunner&lt;/code&gt; для очереди добавляются к текущей &lt;code&gt;Graph&lt;/code&gt; &amp;laquo;s &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; коллекции.</target>
        </trans-unit>
        <trans-unit id="4c4c3026638168daaa4ab1a3c114680f01d9d246" translate="yes" xml:space="preserve">
          <source>This function is more numerically stable than log(sum(exp(input))). It avoids overflows caused by taking the exp of large inputs and underflows caused by taking the log of small inputs.</source>
          <target state="translated">Эта функция более численно стабильна,чем log(sum(exp(input))).Она позволяет избежать переполнений,вызванных взятием exp больших входов и недопотоков,вызванных взятием logа малых входов.</target>
        </trans-unit>
        <trans-unit id="80c0f02cfab4a0ee1574d2a1145f5fca28f12b11" translate="yes" xml:space="preserve">
          <source>This function is only available with the TensorFlow backend for the time being.</source>
          <target state="translated">На данный момент эта функция доступна только с бэкэндом TensorFlow.</target>
        </trans-unit>
        <trans-unit id="11a7ac7f028baf06c483242a158777b17ee8b353" translate="yes" xml:space="preserve">
          <source>This function is only used when defining a new op type. It may be used for ops such as &lt;a href=&quot;size&quot;&gt;&lt;code&gt;tf.size()&lt;/code&gt;&lt;/a&gt; that are not differentiable. For example:</source>
          <target state="translated">Эта функция используется только при определении нового типа операции. Его можно использовать для операций, таких как &lt;a href=&quot;size&quot;&gt; &lt;code&gt;tf.size()&lt;/code&gt; &lt;/a&gt; , которые не дифференцируются. Например:</target>
        </trans-unit>
        <trans-unit id="61969c39a3dfe9d632e8e43316d05aa062590efa" translate="yes" xml:space="preserve">
          <source>This function is part of the Keras serialization and deserialization framework. It maps objects to the string names associated with those objects for serialization/deserialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa4be9a74ac3f90821c5e3ef2a47e10c4dfdcb8" translate="yes" xml:space="preserve">
          <source>This function is part of the Keras serialization and deserialization framework. It maps strings to the objects associated with them for serialization/deserialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577a32736f43471cd2cd1266738343fb80596d48" translate="yes" xml:space="preserve">
          <source>This function is the canonical way to get/validate an object of one of the allowed types from an external argument reference in the Session API.</source>
          <target state="translated">Эта функция является каноническим способом получения/проверки объекта одного из разрешенных типов из ссылки на внешний аргумент в Session API.</target>
        </trans-unit>
        <trans-unit id="130785c66d51b0bf917ff1a83e8cb5fd0234052e" translate="yes" xml:space="preserve">
          <source>This function is to generate &lt;a href=&quot;../distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; to pass into &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or other methods that take distributed values when not using datasets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ff67d2523742ed898675e46a84da4adae4f6b1" translate="yes" xml:space="preserve">
          <source>This function is to generate &lt;a href=&quot;distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; to pass into &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or other methods that take distributed values when not using datasets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691cc7f8251e205cf948be38afb6e034f26a2e72" translate="yes" xml:space="preserve">
          <source>This function is used to perform parallel lookups on the list of tensors in &lt;code&gt;params&lt;/code&gt;. It is a generalization of &lt;a href=&quot;../../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;params&lt;/code&gt; is interpreted as a partitioning of a large embedding tensor. &lt;code&gt;params&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">Эта функция используется для параллельного поиска в списке тензоров в &lt;code&gt;params&lt;/code&gt; . Это обобщение &lt;a href=&quot;../../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; , где &lt;code&gt;params&lt;/code&gt; интерпретируется как разбиение большого тензора вложения. &lt;code&gt;params&lt;/code&gt; может быть &lt;code&gt;PartitionedVariable&lt;/code&gt; , возвращенной с помощью &lt;a href=&quot;../get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt; с разделителем.</target>
        </trans-unit>
        <trans-unit id="4938f0a72e046cd0e52c1383bdb6cd4186015a22" translate="yes" xml:space="preserve">
          <source>This function is used to perform parallel lookups on the list of tensors in &lt;code&gt;params&lt;/code&gt;. It is a generalization of &lt;a href=&quot;../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;params&lt;/code&gt; is interpreted as a partitioning of a large embedding tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237e26d699d02ce05b0e4079a36fba68db8a8789" translate="yes" xml:space="preserve">
          <source>This function is used to perform parallel lookups on the list of tensors in &lt;code&gt;params&lt;/code&gt;. It is a generalization of &lt;a href=&quot;../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;params&lt;/code&gt; is interpreted as a partitioning of a large embedding tensor. &lt;code&gt;params&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../compat/v1/get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">Эта функция используется для параллельного поиска в списке тензоров в &lt;code&gt;params&lt;/code&gt; . Это обобщение &lt;a href=&quot;../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; , где &lt;code&gt;params&lt;/code&gt; интерпретируется как разбиение большого тензора вложения. &lt;code&gt;params&lt;/code&gt; может быть &lt;code&gt;PartitionedVariable&lt;/code&gt; , возвращенной с помощью &lt;a href=&quot;../compat/v1/get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt; с разделителем.</target>
        </trans-unit>
        <trans-unit id="f577da20d8fc0c2379f7e51688987afe782aa9c2" translate="yes" xml:space="preserve">
          <source>This function is useful for unit testing. A unit test can test using the mixed precision graph rewrite, then disable it so future unit tests continue using float32.</source>
          <target state="translated">Эта функция полезна при тестировании модулей.Юнит-тест может проверить,используя перезапись графа смешанной точности,а затем отключить его,так что будущие юнит-тесты продолжают использовать float32.</target>
        </trans-unit>
        <trans-unit id="d61d06f477fe487d45a847bca66c249257c10fe4" translate="yes" xml:space="preserve">
          <source>This function is useful for unit testing. A unit tests can test using the mixed precision graph rewrite, then disable it so future unit tests continue using float32. If this is done, unit tests should not share a single session, as &lt;code&gt;enable_mixed_precision_graph_rewrite&lt;/code&gt; and &lt;code&gt;disable_mixed_precision_graph_rewrite&lt;/code&gt; have no effect on existing sessions.</source>
          <target state="translated">Эта функция полезна для модульного тестирования. Модульные тесты могут тестировать с использованием перезаписи графа со смешанной точностью, а затем отключать его, чтобы в будущих модульных тестах продолжать использовать float32. Если это сделано, модульные тесты не должны совместно использовать один сеанс, поскольку &lt;code&gt;enable_mixed_precision_graph_rewrite&lt;/code&gt; и &lt;code&gt;disable_mixed_precision_graph_rewrite&lt;/code&gt; не влияют на существующие сеансы.</target>
        </trans-unit>
        <trans-unit id="929b9d5a5eeca32709da98b98c1fa20f11f6684a" translate="yes" xml:space="preserve">
          <source>This function may be used in the &lt;code&gt;options&lt;/code&gt; argument in functions that load a SavedModel (&lt;a href=&quot;load&quot;&gt;&lt;code&gt;tf.saved_model.load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../keras/models/load_model&quot;&gt;&lt;code&gt;tf.keras.models.load_model&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e537bea1c76cb2cbcdaeafa3c9baedcb0e335e" translate="yes" xml:space="preserve">
          <source>This function may be used in the &lt;code&gt;options&lt;/code&gt; argument in functions that save a SavedModel (&lt;a href=&quot;save&quot;&gt;&lt;code&gt;tf.saved_model.save&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../keras/models/save_model&quot;&gt;&lt;code&gt;tf.keras.models.save_model&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эта функция может использоваться в аргументе &lt;code&gt;options&lt;/code&gt; в функциях, сохраняющих SavedModel ( &lt;a href=&quot;save&quot;&gt; &lt;code&gt;tf.saved_model.save&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../keras/models/save_model&quot;&gt; &lt;code&gt;tf.keras.models.save_model&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="23d4449e48af4e4a9efae86d49cf037eac266df3" translate="yes" xml:space="preserve">
          <source>This function only gets the device policy for the current thread. Any subsequently started thread will again use the default policy.</source>
          <target state="translated">Эта функция получает только политику устройства для текущего потока.Любой последующий запущенный поток снова будет использовать политику по умолчанию.</target>
        </trans-unit>
        <trans-unit id="69c8cb582945069c7d9496b069e6902700fc7e3d" translate="yes" xml:space="preserve">
          <source>This function only sets the device policy for the current thread. Any subsequently started thread will again use the default policy.</source>
          <target state="translated">Эта функция устанавливает политику устройства только для текущего потока.Любой последующий запущенный поток снова будет использовать политику по умолчанию.</target>
        </trans-unit>
        <trans-unit id="128baaf391e006514e7e2e442ed3dbb64e14a3c9" translate="yes" xml:space="preserve">
          <source>This function performs the equivalent of</source>
          <target state="translated">Эта функция выполняет эквивалент</target>
        </trans-unit>
        <trans-unit id="fac08ba1f46139129a2f42247910a712f1085f49" translate="yes" xml:space="preserve">
          <source>This function prefixes the name with the current variable scope and performs reuse checks. See the &lt;a href=&quot;https://tensorflow.org/guide/variables&quot;&gt;Variable Scope How To&lt;/a&gt; for an extensive description of how reusing works. Here is a basic example:</source>
          <target state="translated">Эта функция ставит перед именем префикс текущей области переменной и выполняет проверки повторного использования. Подробное описание того, как работает повторное использование, см. В разделе &amp;laquo; &lt;a href=&quot;https://tensorflow.org/guide/variables&quot;&gt;Как&lt;/a&gt; сделать&amp;raquo;. Вот простой пример:</target>
        </trans-unit>
        <trans-unit id="85bc4aa7e8b39b071c3a83bcd2bcb628b96948b5" translate="yes" xml:space="preserve">
          <source>This function produces signatures intended for use with the TensorFlow Serving Classify API (tensorflow_serving/apis/prediction_service.proto), and so constrains the input and output types to those allowed by TensorFlow Serving.</source>
          <target state="translated">Эта функция производит сигнатуры,предназначенные для использования с API классификации TensorFlow Serving (tensorflow_serving/apis/prediction_service.proto),и таким образом ограничивает типы входных и выходных сигнатур теми,которые разрешены TensorFlow Serving.</target>
        </trans-unit>
        <trans-unit id="795898cb16fc0e553ecaa87cbe16e8417edef412" translate="yes" xml:space="preserve">
          <source>This function produces signatures intended for use with the TensorFlow Serving Predict API (tensorflow_serving/apis/prediction_service.proto). This API imposes no constraints on the input and output types.</source>
          <target state="translated">Данная функция производит сигнатуры,предназначенные для использования с TensorFlow Serving Predict API (tensorflow_serving/apis/prediction_service.proto).Данный API не накладывает никаких ограничений на типы входных и выходных сигнатур.</target>
        </trans-unit>
        <trans-unit id="0bd91f24173f9c6c06caccaa86fb2987286936b9" translate="yes" xml:space="preserve">
          <source>This function produces signatures intended for use with the TensorFlow Serving Regress API (tensorflow_serving/apis/prediction_service.proto), and so constrains the input and output types to those allowed by TensorFlow Serving.</source>
          <target state="translated">Эта функция создает сигнатуры,предназначенные для использования с TensorFlow Serving Regress API (tensorflow_serving/apis/prediction_service.proto),и таким образом ограничивает типы входных и выходных сигнатур теми,которые разрешены TensorFlow Serving.</target>
        </trans-unit>
        <trans-unit id="da2207550b053f2e41ed03fce80a539629a65e2e" translate="yes" xml:space="preserve">
          <source>This function provides a way to import a serialized TensorFlow &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt;&lt;code&gt;GraphDef&lt;/code&gt;&lt;/a&gt; protocol buffer, and extract individual objects in the &lt;code&gt;GraphDef&lt;/code&gt; as &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; objects. Once extracted, these objects are placed into the current default &lt;code&gt;Graph&lt;/code&gt;. See &lt;a href=&quot;../graph#as_graph_def&quot;&gt;&lt;code&gt;tf.Graph.as_graph_def&lt;/code&gt;&lt;/a&gt; for a way to create a &lt;code&gt;GraphDef&lt;/code&gt; proto.</source>
          <target state="translated">Эта функция предоставляет способ импортировать сериализованный &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt; &lt;code&gt;GraphDef&lt;/code&gt; &lt;/a&gt; протокола TensorFlow GraphDef и извлекать отдельные объекты в &lt;code&gt;GraphDef&lt;/code&gt; как &lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt; . После извлечения эти объекты помещаются в текущий &lt;code&gt;Graph&lt;/code&gt; умолчанию . См. &lt;a href=&quot;../graph#as_graph_def&quot;&gt; &lt;code&gt;tf.Graph.as_graph_def&lt;/code&gt; &lt;/a&gt; чтобы узнать, как создать &lt;code&gt;GraphDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59bf9d9f9818c530570cd3baaed9172f0b655e0a" translate="yes" xml:space="preserve">
          <source>This function raises &lt;code&gt;ValueError&lt;/code&gt; unless it can be certain that the given &lt;code&gt;tensor&lt;/code&gt; is a scalar. &lt;code&gt;ValueError&lt;/code&gt; is also raised if the shape of &lt;code&gt;tensor&lt;/code&gt; is unknown.</source>
          <target state="translated">Эта функция вызывает &lt;code&gt;ValueError&lt;/code&gt; , если нельзя быть уверенным, что данный &lt;code&gt;tensor&lt;/code&gt; является скаляром. &lt;code&gt;ValueError&lt;/code&gt; также возникает, если форма &lt;code&gt;tensor&lt;/code&gt; неизвестна.</target>
        </trans-unit>
        <trans-unit id="22fe780c67f001ded49fb5e4133cb0847481dd48" translate="yes" xml:space="preserve">
          <source>This function receives as input a string of text and returns a list of encoded integers each corresponding to a word (or token) in the given input string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3009d910bdcd32cff99d1458043403e12c1c254c" translate="yes" xml:space="preserve">
          <source>This function reinstantiates model state by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a733b4ff78c36cb4d261221c5118416ce8061d8e" translate="yes" xml:space="preserve">
          <source>This function reinstantiates model state by: 1) loading model topology from json (this will eventually come from metagraph). 2) loading model weights from checkpoint.</source>
          <target state="translated">Эта функция восстанавливает модельное состояние:1)загрузкой топологии модели из json (в конечном итоге это будет происходить из подпункта).2)загрузкой весов модели из контрольно-пропускного пункта.</target>
        </trans-unit>
        <trans-unit id="ff0b45b19346e757b8eb62e1bc7385c9d06f1d69" translate="yes" xml:space="preserve">
          <source>This function returns a tensor whose elements are defined by &lt;code&gt;equation&lt;/code&gt;, which is written in a shorthand form inspired by the Einstein summation convention. As an example, consider multiplying two matrices A and B to form a matrix C. The elements of C are given by:</source>
          <target state="translated">Эта функция возвращает тензор, элементы которого определены &lt;code&gt;equation&lt;/code&gt; , которое записано в сокращенной форме, вдохновленной соглашением Эйнштейна о суммировании. В качестве примера рассмотрим умножение двух матриц A и B, чтобы сформировать матрицу C. Элементы C задаются следующим образом:</target>
        </trans-unit>
        <trans-unit id="0b7b7a286f6486a214583e48df98d413e08472ce" translate="yes" xml:space="preserve">
          <source>This function should &lt;em&gt;not&lt;/em&gt; be used for operations that have a well-defined gradient that is not yet implemented.</source>
          <target state="translated">Эту функцию &lt;em&gt;не&lt;/em&gt; следует использовать для операций, которые имеют четко определенный градиент, который еще не реализован.</target>
        </trans-unit>
        <trans-unit id="1b640a4c1fd849556e2182a5a501c968b01e5603" translate="yes" xml:space="preserve">
          <source>This function should contain the mathemetical logic for one step of evaluation. This typically includes the forward pass, loss calculation, and metrics updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48eea658706b62c655231b07e7ecfd12850950f0" translate="yes" xml:space="preserve">
          <source>This function should only be called during TRAIN mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92add72d0f856bfc3fd4e7bcbf6ab90dc2a5a26d" translate="yes" xml:space="preserve">
          <source>This function specifies the device to be used for ops created/executed in a particular context. Nested contexts will inherit and also create/execute their ops on the specified device. If a specific device is not required, consider not using this function so that a device can be automatically assigned. In general the use of this function is optional. &lt;code&gt;device_name&lt;/code&gt; can be fully specified, as in &quot;/job:worker/task:1/device:cpu:0&quot;, or partially specified, containing only a subset of the &quot;/&quot;-separated fields. Any fields which are specified will override device annotations from outer scopes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c538dca8aca927a7d8bbd1b0bb2e590f6c5ad3a5" translate="yes" xml:space="preserve">
          <source>This function supports a subset of tf.gather, see tf.gather for details on usage.</source>
          <target state="translated">Эта функция поддерживает подмножество tf.gather,подробнее об использовании см.в разделе tf.gather.</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">Эта функция меняет местами полупространства для всех перечисленных осей (по умолчанию все). Обратите внимание, что &lt;code&gt;y[0]&lt;/code&gt; является компонентом Найквиста, только если &lt;code&gt;len(x)&lt;/code&gt; четно.</target>
        </trans-unit>
        <trans-unit id="700dee7b88966a0547c5ef0b6e43b47147bea1dd" translate="yes" xml:space="preserve">
          <source>This function takes a &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer as input. If the argument is a file containing a &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer , it constructs a protocol buffer from the file content. The function then adds all the nodes from the &lt;code&gt;graph_def&lt;/code&gt; field to the current graph, recreates all the collections, and returns a saver constructed from the &lt;code&gt;saver_def&lt;/code&gt; field.</source>
          <target state="translated">Эта функция принимает на &lt;code&gt;MetaGraphDef&lt;/code&gt; буфер протокола MetaGraphDef . Если аргументом является файл, содержащий &lt;code&gt;MetaGraphDef&lt;/code&gt; протокола MetaGraphDef , он создает буфер протокола из содержимого файла. Затем функция добавляет все узлы из поля &lt;code&gt;graph_def&lt;/code&gt; в текущий граф, воссоздает все коллекции и возвращает заставку, &lt;code&gt;saver_def&lt;/code&gt; поля saver_def .</target>
        </trans-unit>
        <trans-unit id="fd08a12501f4bce4f0a38bb7f61e556860ac6186" translate="yes" xml:space="preserve">
          <source>This function takes in a sequence of data-points gathered at equal intervals, along with time series parameters such as length of the sequences/windows, spacing between two sequence/windows, etc., to produce batches of timeseries inputs and targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d25a51ea520664ee90a7477aef16d45f240f73" translate="yes" xml:space="preserve">
          <source>This function transforms a list (of length &lt;code&gt;num_samples&lt;/code&gt;) of sequences (lists of integers) into a 2D Numpy array of shape &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt;. &lt;code&gt;num_timesteps&lt;/code&gt; is either the &lt;code&gt;maxlen&lt;/code&gt; argument if provided, or the length of the longest sequence in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fc01032dc6978adba1e0b4d64fc3f4b8d2c710" translate="yes" xml:space="preserve">
          <source>This function transforms a list of &lt;code&gt;num_samples&lt;/code&gt; sequences (lists of integers) into a 2D Numpy array of shape &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt;. &lt;code&gt;num_timesteps&lt;/code&gt; is either the &lt;code&gt;maxlen&lt;/code&gt; argument if provided, or the length of the longest sequence otherwise.</source>
          <target state="translated">Эта функция преобразует список последовательностей &lt;code&gt;num_samples&lt;/code&gt; (списки целых чисел) в массив 2D Numpy формы &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt; . &lt;code&gt;num_timesteps&lt;/code&gt; - это либо аргумент &lt;code&gt;maxlen&lt;/code&gt; , если он указан , либо длина самой длинной последовательности в противном случае.</target>
        </trans-unit>
        <trans-unit id="c60464500521000032d7d0dd44fb1270d9c6691c" translate="yes" xml:space="preserve">
          <source>This function transforms a sequence of word indexes (list of integers) into tuples of words of the form:</source>
          <target state="translated">Эта функция преобразует последовательность индексов слов (список целых чисел)в кортежи слов формы:</target>
        </trans-unit>
        <trans-unit id="109cf8b58e8d5422a5502fb692567a43d8008aa5" translate="yes" xml:space="preserve">
          <source>This function transforms a string of text into a list of words while ignoring &lt;code&gt;filters&lt;/code&gt; which include punctuations by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf6cff1a07ce3f9dd6dd3457b8400fd6ba9faf8" translate="yes" xml:space="preserve">
          <source>This function uses substring matching, i.e. the matching succeeds if &lt;em&gt;any&lt;/em&gt; substring of the error message matches &lt;em&gt;any&lt;/em&gt; regex in the list. This is more convenient for the user than full-string matching.</source>
          <target state="translated">Эта функция использует сопоставление подстрок, т. Е. Сопоставление считается успешным, если &lt;em&gt;какая-либо&lt;/em&gt; подстрока сообщения об ошибке соответствует &lt;em&gt;любому&lt;/em&gt; регулярному выражению в списке. Это более удобно для пользователя, чем соответствие полной строки.</target>
        </trans-unit>
        <trans-unit id="6ea3c37a0724be70d72aba9456ec479ad3e1efd0" translate="yes" xml:space="preserve">
          <source>This function validates that &lt;code&gt;obj&lt;/code&gt; represents an element of this graph, and gives an informative error message if it is not.</source>
          <target state="translated">Эта функция проверяет, что &lt;code&gt;obj&lt;/code&gt; представляет элемент этого графика, и выдает информативное сообщение об ошибке, если это не так.</target>
        </trans-unit>
        <trans-unit id="5535ae7e49ad8d44ba9e9cbd32412f5d3383ba9d" translate="yes" xml:space="preserve">
          <source>This function will check the outermost context for the program and see if it is in eager mode. It is useful comparing to &lt;a href=&quot;../../executing_eagerly&quot;&gt;&lt;code&gt;tf.executing_eagerly()&lt;/code&gt;&lt;/a&gt;, which checks the current context and will return &lt;code&gt;False&lt;/code&gt; within a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; body. It can be used to build library that behave differently in eager runtime and v1 session runtime (deprecated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b809c8513edcf65ff2e661e67bc392f776c9e7e" translate="yes" xml:space="preserve">
          <source>This function will create the global generator the first time it is called, and the generator will be placed at the default device at that time, so one needs to be careful when this function is first called. Using a generator placed on a less-ideal device will incur performance regression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bde45a9d6e8e699bac43f2a09b2f06fe6c3d12" translate="yes" xml:space="preserve">
          <source>This function will modify the tensors passed in as it adds more operations and hence changing the consumers of the operations of the input tensors.</source>
          <target state="translated">Эта функция модифицирует переданные тензоры,так как добавляет больше операций и,следовательно,изменяет потребителей операций входных тензоров.</target>
        </trans-unit>
        <trans-unit id="e4e12e3274ef470af1606308b5afb5383f0e4373" translate="yes" xml:space="preserve">
          <source>This function works on either a single image (&lt;code&gt;image&lt;/code&gt; is a 3-D Tensor), or a batch of images (&lt;code&gt;image&lt;/code&gt; is a 4-D Tensor).</source>
          <target state="translated">Эта функция работает либо с одним изображением ( &lt;code&gt;image&lt;/code&gt; представляет собой трехмерный тензор), либо с пакетом изображений ( &lt;code&gt;image&lt;/code&gt; представляет собой четырехмерный тензор).</target>
        </trans-unit>
        <trans-unit id="3bc4d91f81e39f3ea54e11412256f8f82c2a442a" translate="yes" xml:space="preserve">
          <source>This function wraps tensor placeholders in a supervised_receiver_fn with the expectation that the features and labels appear precisely as the model_fn expects them. Features and labels can therefore be dicts of tensors, or raw tensors.</source>
          <target state="translated">Эта функция обертывает плейсхолдеры тензора в контролируемых_receiver_fn с ожиданием,что функции и метки будут выглядеть именно так,как их ожидает model_fn.Следовательно,функции и метки могут быть как в виде декретов тензоров,так и в виде необработанных тензоров.</target>
        </trans-unit>
        <trans-unit id="390f51be88bc027febcd4f2fc680ab5ff0ecb909" translate="yes" xml:space="preserve">
          <source>This functionality can be used to remap both row vocabularies (typically, features) and column vocabularies (typically, classes) from TensorFlow checkpoints. Note that the partitioning logic relies on contiguous vocabularies corresponding to div-partitioned variables. Moreover, the underlying remapping uses an IndexTable (as opposed to an inexact CuckooTable), so client code should use the corresponding index_table_from_file() as the FeatureColumn framework does (as opposed to tf.feature_to_id(), which uses a CuckooTable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061aef760e659c96c1579128f6e2913f90a85e0a" translate="yes" xml:space="preserve">
          <source>This has the effect of transforming sliding window operations into the corresponding &quot;atrous&quot; operation in which the input is sampled at the specified &lt;code&gt;dilation_rate&lt;/code&gt;.</source>
          <target state="translated">Это приводит к преобразованию операций скользящего окна в соответствующую &quot;агрессивную&quot; операцию, в которой входные данные дискретизируются с указанной скоростью &lt;code&gt;dilation_rate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10c41b6251ef0bcbec27e5d4c8ebb2292ccebcaa" translate="yes" xml:space="preserve">
          <source>This helper method provides a higher-level alternative to using &lt;code&gt;tf.contrib.summary.summary_writer_initializer_op&lt;/code&gt; and &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt;.</source>
          <target state="translated">Этот вспомогательный метод предоставляет альтернативу более высокого уровня использованию &lt;code&gt;tf.contrib.summary.summary_writer_initializer_op&lt;/code&gt; и &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="671c9eb768ee498e26815ceb625e7ee7c309f7e7" translate="yes" xml:space="preserve">
          <source>This hook delays execution until global step reaches to &lt;code&gt;wait_until_step&lt;/code&gt;. It is used to gradually start workers in distributed settings. One example usage would be setting &lt;code&gt;wait_until_step=int(K*log(task_id+1))&lt;/code&gt; assuming that task_id=0 is the chief.</source>
          <target state="translated">Этот хук задерживает выполнение, пока глобальный шаг не достигнет &lt;code&gt;wait_until_step&lt;/code&gt; . Он используется для постепенного запуска воркеров в распределенных настройках. Одним из примеров использования может быть установка &lt;code&gt;wait_until_step=int(K*log(task_id+1))&lt;/code&gt; предполагая, что task_id = 0 является главным.</target>
        </trans-unit>
        <trans-unit id="1a0fa0f63117915fa2c817fa42b4c67a4f5c8b33" translate="yes" xml:space="preserve">
          <source>This hook requests stop after either a number of steps have been executed or a last step has been reached. Only one of the two options can be specified.</source>
          <target state="translated">Запросы на перехват прекращаются либо после выполнения нескольких шагов,либо после достижения последнего шага.Можно указать только один из двух вариантов.</target>
        </trans-unit>
        <trans-unit id="29326e19d0dc3f4c325692b2b9f948f424da0e4f" translate="yes" xml:space="preserve">
          <source>This hook saves the state of the iterators in the &lt;code&gt;Graph&lt;/code&gt; so that when training is resumed the input pipeline continues from where it left off. This could potentially avoid overfitting in certain pipelines where the number of training steps per eval are small compared to the dataset size or if the training pipeline is pre-empted.</source>
          <target state="translated">Этот хук сохраняет состояние итераторов в &lt;code&gt;Graph&lt;/code&gt; , так что, когда обучение возобновляется, входной конвейер продолжается с того места, где он был остановлен. Это потенциально могло бы избежать переобучения в определенных конвейерах, где количество шагов обучения на оценку мало по сравнению с размером набора данных или если конвейер обучения опережает.</target>
        </trans-unit>
        <trans-unit id="362202ba29e8d6beed9c2059ae03ede13f3cd76f" translate="yes" xml:space="preserve">
          <source>This hook should be used if the input pipeline state needs to be saved separate from the model checkpoint. Doing so may be useful for a few reasons:</source>
          <target state="translated">Этот крюк следует использовать,если состояние входного трубопровода необходимо сохранить отдельно от контрольно-пропускного пункта модели.Это может быть полезно по нескольким причинам:</target>
        </trans-unit>
        <trans-unit id="b6ae1f6a6bb162ce4153046b8500ec1c1479c758" translate="yes" xml:space="preserve">
          <source>This identifies the replica that is part of a sync group. Currently we assume that all sync groups contain the same number of replicas. The value of the replica id can range from 0 to &lt;code&gt;num_replica_in_sync&lt;/code&gt; - 1.</source>
          <target state="translated">Это идентифицирует реплику, которая является частью группы синхронизации. В настоящее время мы предполагаем, что все группы синхронизации содержат одинаковое количество реплик. Значение идентификатора реплики может варьироваться от 0 до &lt;code&gt;num_replica_in_sync&lt;/code&gt; - 1.</target>
        </trans-unit>
        <trans-unit id="1b29036c26df39b1ea3c52cbf28f86f795fcf9f0" translate="yes" xml:space="preserve">
          <source>This implementation is based off of the Cephes math library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f20df5d52794499c7d70f58fc604ea383aee58e" translate="yes" xml:space="preserve">
          <source>This implementation is to be used in conjunction of BlockLSTMV2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e20691c6271c3052db6329ff09bab3c3926f92" translate="yes" xml:space="preserve">
          <source>This implementation is to be used in conjunction of LSTMBlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2023d65f880c26efdc064ba734473728a5acce91" translate="yes" xml:space="preserve">
          <source>This implementation is to be used in conjunction of LSTMBlockCell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd5efd797cabcd540fdce983afef271dcb8292a" translate="yes" xml:space="preserve">
          <source>This implementation of RMSprop uses plain momentum, not Nesterov momentum.</source>
          <target state="translated">Эта реализация RMSprop использует обычный импульс,а не Нестеров импульс.</target>
        </trans-unit>
        <trans-unit id="32650114feea17cac9bd97ba7f3acc193158dc56" translate="yes" xml:space="preserve">
          <source>This implementation uses 1 weight matrix and 1 bias vector, and there's an optional peephole connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69398f914b35c5353b93476810576462db6eec45" translate="yes" xml:space="preserve">
          <source>This implements the anisotropic 2-D version of the formula described here:</source>
          <target state="translated">Это реализует анизотропную 2-D версию описанной здесь формулы:</target>
        </trans-unit>
        <trans-unit id="cd31200075bd4a5cc039e35e154eab86539a7999" translate="yes" xml:space="preserve">
          <source>This improves training speed. Please see &lt;code&gt;optimization_parameters.proto&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa40933c0c7c31f3c54363539d17de16903a6ff" translate="yes" xml:space="preserve">
          <source>This includes ops from TF 2.0 tf.summary and TF 1.x tf.contrib.summary (except for &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt; and &lt;code&gt;tf.contrib.summary.import_event&lt;/code&gt;), but does &lt;em&gt;not&lt;/em&gt; include TF 1.x tf.summary ops.</source>
          <target state="translated">Сюда входят операции из TF 2.0 tf.summary и TF 1.x tf.contrib.summary (за исключением &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt; и &lt;code&gt;tf.contrib.summary.import_event&lt;/code&gt; ), но &lt;em&gt;не&lt;/em&gt; включает TF 1.x tf.summary опс.</target>
        </trans-unit>
        <trans-unit id="2cbffbf5b87e7d08406cd7f76d2f7936c22b5d07" translate="yes" xml:space="preserve">
          <source>This includes the operations to synchronize replicas: aggregate gradients, apply to variables, increment global step, insert tokens to token queue.</source>
          <target state="translated">Сюда входят операции по синхронизации реплик:агрегирование градиентов,применение к переменным,инкремент глобального шага,вставка маркеров в очередь маркеров.</target>
        </trans-unit>
        <trans-unit id="dc77baa2dba67576cde30b92064b3afa6abe84f1" translate="yes" xml:space="preserve">
          <source>This induces quasi-linear speedup on up to 8 GPUs.</source>
          <target state="translated">Это обеспечивает квазилинейное ускорение до 8 GPU.</target>
        </trans-unit>
        <trans-unit id="9e91bcd2748922b865fbdb3c28f16a3f92c87b0e" translate="yes" xml:space="preserve">
          <source>This initializer assigns one entry in the table for each line in the file.</source>
          <target state="translated">Этот инициализатор назначает по одной записи в таблице для каждой строки в файле.</target>
        </trans-unit>
        <trans-unit id="93a30392533a2023857f78a57a8100de69db56b7" translate="yes" xml:space="preserve">
          <source>This initializes a new Kubernetes ClusterResolver. The ClusterResolver will attempt to talk to the Kubernetes master to retrieve all the instances of pods matching a label selector.</source>
          <target state="translated">Это инициализирует новый кластерный резольвер Kubernetes.ClusterResolver попытается поговорить с мастером Kubernetes,чтобы получить все экземпляры стручков,подходящих к селектору меток.</target>
        </trans-unit>
        <trans-unit id="ded15c2fc6dc030fcd9627bdc75c00460c2cb65d" translate="yes" xml:space="preserve">
          <source>This is (mostly) a special case of &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;bias&lt;/code&gt; is restricted to 1-D. Broadcasting is supported, so &lt;code&gt;value&lt;/code&gt; may have any number of dimensions. Unlike &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt;, the type of &lt;code&gt;bias&lt;/code&gt; is allowed to differ from &lt;code&gt;value&lt;/code&gt; in the case where both types are quantized.</source>
          <target state="translated">Это (в основном) частный случай &lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; ,&lt;/a&gt; когда &lt;code&gt;bias&lt;/code&gt; ограничено 1-D. Поддерживается широковещательная передача, поэтому &lt;code&gt;value&lt;/code&gt; может иметь любое количество измерений. В отличие от &lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt; , тип &lt;code&gt;bias&lt;/code&gt; может отличаться от &lt;code&gt;value&lt;/code&gt; в случае, когда оба типа квантованы.</target>
        </trans-unit>
        <trans-unit id="9f67d123191520f4a8994999dc8cd88f7fe320b7" translate="yes" xml:space="preserve">
          <source>This is EXPERIMENTAL and subject to change.</source>
          <target state="translated">Это ЭКСПЕРИМЕНТАЛЬНО и может быть изменено.</target>
        </trans-unit>
        <trans-unit id="02f8d625292f24a8f6fa6d8a843ae5c003159e97" translate="yes" xml:space="preserve">
          <source>This is a class method that describes what key/value arguments are required to instantiate the given &lt;code&gt;Distribution&lt;/code&gt; so that a particular shape is returned for that instance's call to &lt;code&gt;sample()&lt;/code&gt;.</source>
          <target state="translated">Это метод класса, который описывает, какие аргументы ключ / значение требуются для создания экземпляра данного &lt;code&gt;Distribution&lt;/code&gt; чтобы при вызове этого экземпляра к &lt;code&gt;sample()&lt;/code&gt; возвращалась определенная форма .</target>
        </trans-unit>
        <trans-unit id="012a7836bd88d1e3c2c595506564d4812be83ba5" translate="yes" xml:space="preserve">
          <source>This is a class method that describes what key/value arguments are required to instantiate the given &lt;code&gt;Distribution&lt;/code&gt; so that a particular shape is returned for that instance's call to &lt;code&gt;sample()&lt;/code&gt;. Assumes that the sample's shape is known statically.</source>
          <target state="translated">Это метод класса, который описывает, какие аргументы типа ключ / значение требуются для создания экземпляра данного &lt;code&gt;Distribution&lt;/code&gt; чтобы при вызове этого экземпляра в &lt;code&gt;sample()&lt;/code&gt; возвращалась определенная форма . Предполагается, что форма образца известна статически.</target>
        </trans-unit>
        <trans-unit id="fead40a760af2fb3753f3e33415c41be437e055a" translate="yes" xml:space="preserve">
          <source>This is a companion method to &lt;code&gt;add_queue_runner()&lt;/code&gt;. It just starts threads for all queue runners collected in the graph. It returns the list of all threads.</source>
          <target state="translated">Это &lt;code&gt;add_queue_runner()&lt;/code&gt; метод для add_queue_runner () . Он просто запускает потоки для всех обработчиков очереди, собранных в графе. Он возвращает список всех потоков.</target>
        </trans-unit>
        <trans-unit id="9590afd024cc456ab84ee4d2f95cabc25b5ebe3a" translate="yes" xml:space="preserve">
          <source>This is a context class that is passed to the &lt;code&gt;value_fn&lt;/code&gt; in &lt;code&gt;strategy.experimental_distribute_values_from_function&lt;/code&gt; and contains information about the compute replicas. The &lt;code&gt;num_replicas_in_sync&lt;/code&gt; and &lt;code&gt;replica_id&lt;/code&gt; can be used to customize the value on each replica.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309ae6e7b107ea04158b03fa5671cc2764a5cdf7" translate="yes" xml:space="preserve">
          <source>This is a context class that is passed to the user's input function and contains information about the compute replicas and input pipelines. The number of compute replicas (in sync training) helps compute the local batch size from the desired global batch size for each replica. The input pipeline information can be used to return a different subset of the input in each replica (for e.g. shard the input pipeline, use a different input source etc).</source>
          <target state="translated">Это контекстный класс,который передается в пользовательскую функцию ввода и содержит информацию о вычислительных репликах и входных трубопроводах.Количество вычисляемых реплик (обучение синхронизации)помогает вычислить локальный размер партии из желаемого глобального размера партии для каждой реплики.Информация о входном трубопроводе может быть использована для возврата различного подмножества входных данных в каждой реплике (например,для создания осколков входного трубопровода,использования различных источников входных данных и т.д.).</target>
        </trans-unit>
        <trans-unit id="1659a3286a3bedb8cf721b60523b4bfde4d51caf" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, adjusts their brightness, and then converts them back to the original data type. If several adjustments are chained, it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">Это удобный метод,который преобразует RGB-изображения в плавающее представление,регулирует их яркость,а затем преобразует их обратно в исходный тип данных.Если несколько корректировок цепочечно,то желательно минимизировать количество избыточных преобразований.</target>
        </trans-unit>
        <trans-unit id="7bcc711030b8e6b303b05fbb2eadad7a51295960" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, adjusts their contrast, and then converts them back to the original data type. If several adjustments are chained, it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">Это удобный метод,который преобразует RGB-изображения в плавающее представление,регулирует их контрастность,а затем преобразует их обратно в исходный тип данных.Если несколько корректировок цепочечно,то желательно минимизировать количество избыточных преобразований.</target>
        </trans-unit>
        <trans-unit id="689582a22623e8b58ba6e0ed65682c48dc03d8f0" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, converts them to HSV, add an offset to the saturation channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">Это удобный метод,который преобразует RGB-изображения в плавающее представление,преобразует их в HSV,добавляет смещение в канал насыщения,преобразует обратно в RGB,а затем обратно в исходный тип данных.Если несколько корректировок цепочечно,то желательно минимизировать количество избыточных преобразований.</target>
        </trans-unit>
        <trans-unit id="154fc7928cd01964ea2a05b16a1fbc2cadc62c3b" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, converts them to HSV, adds an offset to the saturation channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157983bd7b4bf865fccf95ec9e2bc8ddd381392d" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts an RGB image to float representation, converts it to HSV, add an offset to the hue channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">Это удобный метод,который преобразует RGB-изображение в плавающее представление,преобразует его в HSV,добавляет смещение в канал оттенков,преобразует обратно в RGB,а затем обратно в исходный тип данных.Если несколько корректировок цепочечно,то желательно минимизировать количество избыточных преобразований.</target>
        </trans-unit>
        <trans-unit id="bc1addde10acbe587836014417c1c886ecf1e9cf" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts an RGB image to float representation, converts it to HSV, adds an offset to the hue channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b85cb6fb2b17c1cfe1f8becbb4b4eeadf576adb" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts an image to uint8 representation, encodes it to jpeg with &lt;code&gt;jpeg_quality&lt;/code&gt;, decodes it, and then converts back to the original data type.</source>
          <target state="translated">Это удобный метод, который преобразует изображение в представление uint8, кодирует его в jpeg с помощью &lt;code&gt;jpeg_quality&lt;/code&gt; , декодирует его, а затем преобразует обратно в исходный тип данных.</target>
        </trans-unit>
        <trans-unit id="040dbe98920d5a5c1090b8783413f490c3abe113" translate="yes" xml:space="preserve">
          <source>This is a convenience utility for packing data into the tuple formats that &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177a96552c22761995fc2a02f86657fdf66dd73d" translate="yes" xml:space="preserve">
          <source>This is a convenience utility to be used when overriding &lt;a href=&quot;../model#train_step&quot;&gt;&lt;code&gt;Model.train_step&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../model#test_step&quot;&gt;&lt;code&gt;Model.test_step&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../model#predict_step&quot;&gt;&lt;code&gt;Model.predict_step&lt;/code&gt;&lt;/a&gt;. This utility makes it easy to support data of the form &lt;code&gt;(x,)&lt;/code&gt;, &lt;code&gt;(x, y)&lt;/code&gt;, or &lt;code&gt;(x, y, sample_weight)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b259f9b8e5db6abf1f7ca2cc64744a095dde1b" translate="yes" xml:space="preserve">
          <source>This is a dataset of 11,228 newswires from Reuters, labeled over 46 topics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768eb884c8ee5b48b0c147f90ce4407a6a9884da" translate="yes" xml:space="preserve">
          <source>This is a dataset of 25,000 movies reviews from IMDB, labeled by sentiment (positive/negative). Reviews have been preprocessed, and each review is encoded as a list of word indexes (integers). For convenience, words are indexed by overall frequency in the dataset, so that for instance the integer &quot;3&quot; encodes the 3rd most frequent word in the data. This allows for quick filtering operations such as: &quot;only consider the top 10,000 most common words, but eliminate the top 20 most common words&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86bf0041eb6fb31b4e9ede482e55b7d43a98c80" translate="yes" xml:space="preserve">
          <source>This is a dataset of 50,000 32x32 color training images and 10,000 test images, labeled over 10 categories. See more info at the &lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot;&gt;CIFAR homepage&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435f80948690367d77e0f3784d30df76f7f3d98a" translate="yes" xml:space="preserve">
          <source>This is a dataset of 50,000 32x32 color training images and 10,000 test images, labeled over 100 fine-grained classes that are grouped into 20 coarse-grained classes. See more info at the &lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot;&gt;CIFAR homepage&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a8fb4dd54ee096f6f9e8b6100e0ded183914c6" translate="yes" xml:space="preserve">
          <source>This is a dataset of 60,000 28x28 grayscale images of 10 fashion categories, along with a test set of 10,000 images. This dataset can be used as a drop-in replacement for MNIST. The class labels are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30665bff921b2720a3a63831af563bf188d5b46" translate="yes" xml:space="preserve">
          <source>This is a dataset of 60,000 28x28 grayscale images of the 10 digits, along with a test set of 10,000 images. More info can be found at the &lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;MNIST homepage&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710ac221d7447de49c2c2452f75596e4bb685c1c" translate="yes" xml:space="preserve">
          <source>This is a dataset taken from the StatLib library which is maintained at Carnegie Mellon University.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab28ad9476b59e4ae1d47c731d1e80592c84261d" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of &lt;code&gt;fractional_avg_pool&lt;/code&gt;.</source>
          <target state="translated">Это устаревшая версия &lt;code&gt;fractional_avg_pool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89fac60f109fd0365fd768e5b0c1efda980aac29" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of &lt;code&gt;fractional_max_pool&lt;/code&gt;.</source>
          <target state="translated">Это устаревшая версия &lt;code&gt;fractional_max_pool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec0b5065eeff136feb43dbfad07e272612b79d8c" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of BiasAdd and will be soon removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066f7ab7935722a8bd3e79702ee438f7b2aad916" translate="yes" xml:space="preserve">
          <source>This is a difference between DatasetV1 and DatasetV2. DatasetV1 does not take anything in its constructor whereas in the DatasetV2, we expect subclasses to create a variant_tensor and pass it in to the super() call.</source>
          <target state="translated">В этом разница между DatasetV1 и DatasetV2.DatasetV1 ничего не принимает в своем конструкторе,в то время как в DatasetV2 мы ожидаем,что подклассы создадут variant_tensor и передадут его при вызове super().</target>
        </trans-unit>
        <trans-unit id="e7c85e6a460e7ff32a9089528b0d0f38042adaa0" translate="yes" xml:space="preserve">
          <source>This is a faster way to train a softmax classifier over a huge number of classes.</source>
          <target state="translated">Это более быстрый способ обучения классификатора софтмакс по огромному количеству классов.</target>
        </trans-unit>
        <trans-unit id="d7e11ee2edab133ca8b8374faafd78e7821ed539" translate="yes" xml:space="preserve">
          <source>This is a legacy behaviour of TensorFlow and is highly discouraged.</source>
          <target state="translated">Это унаследованное от TensorFlow поведение,и оно крайне обескураживает.</target>
        </trans-unit>
        <trans-unit id="a3be19c517fb6a6f6742dcaed9be8bb79e5a6a4d" translate="yes" xml:space="preserve">
          <source>This is a legacy version of the more general BatchToSpaceND.</source>
          <target state="translated">Это унаследованная версия более общего BatchToSpaceND.</target>
        </trans-unit>
        <trans-unit id="c2584be3bd38ee90f3ac17e87b40fd5fb1908bdb" translate="yes" xml:space="preserve">
          <source>This is a legacy version of the more general SpaceToBatchND.</source>
          <target state="translated">Это унаследованная версия более общего SpaceToBatchND.</target>
        </trans-unit>
        <trans-unit id="c0ae3cb7ef651d4c8fb957d4b4823d4c0713533f" translate="yes" xml:space="preserve">
          <source>This is a low-level interface for creating an &lt;code&gt;Operation&lt;/code&gt;. Most programs will not call this method directly, and instead use the Python op constructors, such as &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;tf.constant()&lt;/code&gt;&lt;/a&gt;, which add ops to the default graph.</source>
          <target state="translated">Это низкоуровневый интерфейс для создания &lt;code&gt;Operation&lt;/code&gt; . Большинство программ не будут вызывать этот метод напрямую, а вместо этого используют конструкторы &lt;a href=&quot;constant&quot;&gt; &lt;code&gt;tf.constant()&lt;/code&gt; &lt;/a&gt; Python, такие как tf.constant () , которые добавляют операции к графу по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1cd850dc655362d680df73debd3d92a42edd1883" translate="yes" xml:space="preserve">
          <source>This is a method that implementers of subclasses of &lt;code&gt;Layer&lt;/code&gt; or &lt;code&gt;Model&lt;/code&gt; can override if they need a state-creation step in-between layer instantiation and layer call.</source>
          <target state="translated">Это метод, который разработчики подклассов &lt;code&gt;Layer&lt;/code&gt; или &lt;code&gt;Model&lt;/code&gt; могут переопределить, если им нужен этап создания состояния между созданием экземпляра уровня и вызовом уровня.</target>
        </trans-unit>
        <trans-unit id="62c4042c7b665a4296b8d1a943304048eb64aec7" translate="yes" xml:space="preserve">
          <source>This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</source>
          <target state="translated">Это ненулевое целое число.См.функцию get_ident().Идентификаторы потоков могут быть переработаны,когда поток выходит и создается другой поток.Идентификатор доступен даже после выхода потока.</target>
        </trans-unit>
        <trans-unit id="31eb573dcb4f05e127842ce7a2c523b4f9fd2e61" translate="yes" xml:space="preserve">
          <source>This is a reduction created for Nvidia DGX-1 which assumes GPUs connects like that on DGX-1 machine. If you have different GPU inter-connections, it is likely that it would be slower than &lt;a href=&quot;reductiontoonedevice&quot;&gt;&lt;code&gt;tf.distribute.ReductionToOneDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это сокращение создано для Nvidia DGX-1, которое предполагает, что графические процессоры подключаются таким же образом на машине DGX-1. Если у вас разные соединения с графическим процессором, вполне вероятно, что это будет медленнее, чем &lt;a href=&quot;reductiontoonedevice&quot;&gt; &lt;code&gt;tf.distribute.ReductionToOneDevice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85f7e8c05b61af3e5451f6e510d0b0985383c1d8" translate="yes" xml:space="preserve">
          <source>This is a special case of &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;bias&lt;/code&gt; is restricted to be 1-D. Broadcasting is supported, so &lt;code&gt;value&lt;/code&gt; may have any number of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbdbb1332709a943bc7d0db1d68caf76c3a99f69" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;../../../random/categorical&quot;&gt;&lt;code&gt;tf.random.categorical&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81cb44c6cca42a31a07fbae208fd1a7a56619cfa" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;../../../random/categorical&quot;&gt;&lt;code&gt;tf.random.categorical&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Это версия &lt;a href=&quot;../../../random/categorical&quot;&gt; &lt;code&gt;tf.random.categorical&lt;/code&gt; &lt;/a&gt; без сохранения состояния : если запустить дважды с одними и теми же начальными числами, будут получены одинаковые псевдослучайные числа. Вывод согласован при нескольких запусках на одном и том же оборудовании (и между ЦП и ГП), но может изменяться между версиями TensorFlow или на оборудовании, не являющемся ЦП / ГП.</target>
        </trans-unit>
        <trans-unit id="de68a47b12e07130e567ec24bb61927f4f535092" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;gamma&quot;&gt;&lt;code&gt;tf.random.gamma&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d527e38ee04e494f8d4e9909ef23824c02f218d2" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;generator#binomial&quot;&gt;&lt;code&gt;tf.random.Generator.binomial&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9d7559f26ce2def191894981d83e7101b4893f" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812a072511f22cc831859b50e28ff4fe62133693" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Это версия &lt;a href=&quot;normal&quot;&gt; &lt;code&gt;tf.random.normal&lt;/code&gt; &lt;/a&gt; без сохранения состояния : при двойном запуске с одними и теми же начальными числами будут получены одинаковые псевдослучайные числа. Вывод согласован при нескольких запусках на одном и том же оборудовании (и между ЦП и ГП), но может меняться между версиями TensorFlow или на оборудовании без ЦП / ГП.</target>
        </trans-unit>
        <trans-unit id="eb02c3777bd174779389bb97e4e8d5e8436a288c" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;poisson&quot;&gt;&lt;code&gt;tf.random.poisson&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware, but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca51d036bc29518d8577d5bfc5e3dc7a0421db6" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;truncated_normal&quot;&gt;&lt;code&gt;tf.random.truncated_normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6096e0d7eff9f42170cc05a1fe61ba85be91f4" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;truncated_normal&quot;&gt;&lt;code&gt;tf.random.truncated_normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Это версия &lt;a href=&quot;truncated_normal&quot;&gt; &lt;code&gt;tf.random.truncated_normal&lt;/code&gt; &lt;/a&gt; без сохранения состояния : если запустить дважды с одними и теми же начальными числами, будут получены одинаковые псевдослучайные числа. Вывод согласован при нескольких запусках на одном и том же оборудовании (и между ЦП и ГП), но может меняться между версиями TensorFlow или на оборудовании без ЦП / ГП.</target>
        </trans-unit>
        <trans-unit id="ac72baa117d9b4a5bdf610d359eb9848fb6723ce" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b120804ac2994699c2b37663ac0990fd63dfd70" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Это версия &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; без сохранения состояния : если запустить дважды с одними и теми же начальными числами, она выдаст одинаковые псевдослучайные числа. Вывод согласован при нескольких запусках на одном и том же оборудовании (и между ЦП и ГП), но может меняться между версиями TensorFlow или на оборудовании без ЦП / ГП.</target>
        </trans-unit>
        <trans-unit id="93abfee5707aabda372725092df92726179f4164" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;code&gt;tf.categorical&lt;/code&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada11b1aaca11d67319d958bd7d1da13f15ebb7f" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;code&gt;tf.categorical&lt;/code&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Это версия &lt;code&gt;tf.categorical&lt;/code&gt; без сохранения состояния : при двойном запуске с одними и теми же начальными числами будут выданы одинаковые псевдослучайные числа. Вывод согласован при нескольких запусках на одном и том же оборудовании (и между ЦП и ГП), но может меняться между версиями TensorFlow или на оборудовании без ЦП / ГП.</target>
        </trans-unit>
        <trans-unit id="9603abb8f073d177d05702e0bc2ac4de5a04a74c" translate="yes" xml:space="preserve">
          <source>This is a wrapper to the &lt;code&gt;hashing_trick&lt;/code&gt; function using &lt;code&gt;hash&lt;/code&gt; as the hashing function; unicity of word to index mapping non-guaranteed.</source>
          <target state="translated">Это оболочка для функции &lt;code&gt;hashing_trick&lt;/code&gt; , использующей &lt;code&gt;hash&lt;/code&gt; в качестве функции хеширования; Единственность слова в отображение индекса не гарантируется.</target>
        </trans-unit>
        <trans-unit id="5b00a32a0d99275c6a4a177506328b41e8a5cbe9" translate="yes" xml:space="preserve">
          <source>This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a tensor, so its value can change during training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7a813777192ceaa721f12e2b167eefa5ce19d7" translate="yes" xml:space="preserve">
          <source>This is always checked statically, so this method returns nothing.</source>
          <target state="translated">Это всегда проверяется статически,поэтому этот метод ничего не возвращает.</target>
        </trans-unit>
        <trans-unit id="edf37ccd5d1846dec567da6f67dc930901f7907c" translate="yes" xml:space="preserve">
          <source>This is an abstract base class, so you cannot instantiate it directly. Instead, use one of its concrete subclasses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb8330008d86d94ea39351a6992d0b396765e55" translate="yes" xml:space="preserve">
          <source>This is an abstract class which allows extensions to TensorFlow's object-based checkpointing (see &lt;a href=&quot;../checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt;). For example a wrapper for NumPy arrays:</source>
          <target state="translated">Это абстрактный класс, который позволяет расширять объектно-ориентированную контрольную &lt;a href=&quot;../checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt; (см. Tf.train.Checkpoint ). Например, обертка для массивов NumPy:</target>
        </trans-unit>
        <trans-unit id="f0c3e68e0358a0f76609938022081ba5ccf573dd" translate="yes" xml:space="preserve">
          <source>This is an experimental op for internal use only and it is possible to use this op in unsafe ways. DO NOT USE unless you fully understand the risks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbaa33b6f8b11a0355ba861cdf03d3e08622a92" translate="yes" xml:space="preserve">
          <source>This is an identity op (behaves like &lt;a href=&quot;../../identity&quot;&gt;&lt;code&gt;tf.identity&lt;/code&gt;&lt;/a&gt;) with the side effect of printing &lt;code&gt;data&lt;/code&gt; when evaluating.</source>
          <target state="translated">Это &lt;a href=&quot;../../identity&quot;&gt; &lt;code&gt;tf.identity&lt;/code&gt; &lt;/a&gt; идентификации (ведет себя как tf.identity ) с побочным эффектом печати &lt;code&gt;data&lt;/code&gt; при оценке.</target>
        </trans-unit>
        <trans-unit id="5c9b3651662523b2ca2e5016d6f25cb9aff58541" translate="yes" xml:space="preserve">
          <source>This is an implementation of ClusterResolver for Slurm clusters. This allows the specification of jobs and task counts, number of tasks per node, number of GPUs on each node and number of GPUs for each task. It retrieves system attributes by Slurm environment variables, resolves allocated computing node names, constructs a cluster and returns a ClusterResolver object which can be used for distributed TensorFlow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04be17d14e8556e45ddfd971016c00de8c4f5796" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for Kubernetes. When given the the Kubernetes namespace and label selector for pods, we will retrieve the pod IP addresses of all running pods matching the selector, and return a ClusterSpec based on that information.</source>
          <target state="translated">Это реализация кластерных резольверов для Kubernetes.Когда нам дано пространство имен Kubernetes и селектор меток для подов,мы получим IP-адреса всех запущенных подов,соответствующих селектору,и вернем ClusterSpec,основываясь на этой информации.</target>
        </trans-unit>
        <trans-unit id="fbfdd6a723bd3e94666f26590d4249971ef2fb48" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for Slurm clusters. This allows the specification of jobs and task counts, number of tasks per node, number of GPUs on each node and number of GPUs for each task. It retrieves system attributes by Slurm environment variables, resolves allocated computing node names, constructs a cluster and returns a ClusterResolver object which can be use for distributed TensorFlow.</source>
          <target state="translated">Это реализация кластерных резольверов для кластеров Slurm.Это позволяет специфицировать задания и количество задач,количество задач на узле,количество GPU на каждом узле и количество GPU для каждой задачи.Он получает системные атрибуты по переменным окружения Slurm,решает имена выделенных вычислительных узлов,строит кластер и возвращает объект ClusterResolver,который может быть использован для распределенного TensorFlow.</target>
        </trans-unit>
        <trans-unit id="6c7332a1bfb936db2e58085e5162712580a9aab8" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for the Google Cloud TPU service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71688349367e3a46bf633affe83f7f67a539cf79" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for the Google Cloud TPU service. As Cloud TPUs are in alpha, you will need to specify a API definition file for this to consume, in addition to a list of Cloud TPUs in your Google Cloud Platform project.</source>
          <target state="translated">Это реализация кластерных резольверов для службы Google Cloud TPU.Поскольку облачные ТПУ находятся в альфа-формате,для их использования вам потребуется указать файл определения API в дополнение к списку облачных ТПУ в вашем проекте Google Cloud Platform.</target>
        </trans-unit>
        <trans-unit id="ad683e8f469fc31a1a6f2ec923965536267cfedf" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for the Google Compute Engine instance group platform. By specifying a project, zone, and instance group, this will retrieve the IP address of all the instances within the instance group and return a ClusterResolver object suitable for use for distributed TensorFlow.</source>
          <target state="translated">Это реализация кластерных резольверов для групповой платформы экземпляров Google Compute Engine.Указав проект,зону и группу экземпляров,он получит IP-адрес всех экземпляров внутри группы экземпляров и вернет объект ClusterResolver,подходящий для использования в распределенном потоке TensorFlow.</target>
        </trans-unit>
        <trans-unit id="a371677e8e3150f82fcdcb41fbdf4b2aece50db2" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers when using TF_CONFIG to set information about the cluster. The cluster spec returned will be initialized from the TF_CONFIG environment variable.</source>
          <target state="translated">Это реализация кластерных резольверов при использовании TF_CONFIG для установки информации о кластере.Возвращаемая спецификация кластера будет инициализирована из переменной окружения TF_CONFIG.</target>
        </trans-unit>
        <trans-unit id="f2e4a40b99bc22ad76a6b8d488160787266d96b7" translate="yes" xml:space="preserve">
          <source>This is because evaluating the gradient graph does not require evaluating the constant(1) op created in the forward pass.</source>
          <target state="translated">Это связано с тем,что оценка градиента не требует оценки константы(1),созданной в прямом проходе.</target>
        </trans-unit>
        <trans-unit id="b402b2ea93d17cfe8814c2e2dd9513661013af48" translate="yes" xml:space="preserve">
          <source>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which &lt;code&gt;begin&lt;/code&gt; is called:</source>
          <target state="translated">Это вызывается, чтобы сигнализировать ловушкам о создании нового сеанса. Здесь есть два существенных отличия от ситуации, в которой вызывается &lt;code&gt;begin&lt;/code&gt; :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
