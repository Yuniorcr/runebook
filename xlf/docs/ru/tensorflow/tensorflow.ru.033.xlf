<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="a54dcf4080998972f139ff7554df53efbf2918b1" translate="yes" xml:space="preserve">
          <source>If the shape of the tensor to initialize is more than two-dimensional, a matrix of shape &lt;code&gt;(shape[0] * ... * shape[n - 2], shape[n - 1])&lt;/code&gt; is initialized, where &lt;code&gt;n&lt;/code&gt; is the length of the shape vector. The matrix is subsequently reshaped to give a tensor of the desired shape.</source>
          <target state="translated">Если форма инициализируемого тензора более чем двумерная, инициализируется матрица формы &lt;code&gt;(shape[0] * ... * shape[n - 2], shape[n - 1])&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - длина вектора формы. Впоследствии матрица изменяет форму, чтобы получить тензор желаемой формы.</target>
        </trans-unit>
        <trans-unit id="b8d51b3cc2d47981a522a4c9c34d0625aae79fab" translate="yes" xml:space="preserve">
          <source>If the shape of the tensor to initialize is two-dimensional, it is initialized with an orthogonal matrix obtained from the QR decomposition of a matrix of random numbers drawn from a normal distribution. If the matrix has fewer rows than columns then the output will have orthogonal rows. Otherwise, the output will have orthogonal columns.</source>
          <target state="translated">Если форма тензора для инициализации двумерна,то она инициализируется ортогональной матрицей,полученной в результате QR-разложения матрицы случайных чисел,взятой из нормального распределения.Если матрица имеет меньшее количество строк,чем столбцы,то на выходе будут ортогональные строки.В противном случае на выходе будут ортогональные столбцы.</target>
        </trans-unit>
        <trans-unit id="411bd1e755c6445ce89548664295dcd91a5d4f8f" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; do not match in any dimension other than the last dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88be12eb5c7fd4e220c4fe96c602fca142984f22" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;axes&lt;/code&gt; are incompatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0c1592ab9cdd3bf5f1c096b576c80fbc8d2ff4" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;logits&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; don't match or if &lt;code&gt;labels&lt;/code&gt; or &lt;code&gt;logits&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dafbcea11dbd05f2198f43ce1950635ed08ea45" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;logits&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;, and &lt;code&gt;weights&lt;/code&gt; are incompatible, or if any of them are None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7df478231ff6f50f0a79744cfc374602c1a9d3" translate="yes" xml:space="preserve">
          <source>If the slice indices aren't int, slice, ellipsis, tf.newaxis or scalar int32/int64 tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59791a0403cf8a35ad3d5f8e04ef9fd71c74268" translate="yes" xml:space="preserve">
          <source>If the static &lt;code&gt;inputs&lt;/code&gt; dimensions don't match with the values given in &lt;code&gt;maximum_shapes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305adc686f0d35611fc45f59ebff259e89edb85d" translate="yes" xml:space="preserve">
          <source>If the string_tensor is a null Python list. At runtime, will fail with an assertion if string_tensor becomes a null tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ee97b5be1b0def3d40b95369d5a5715a3eff8d" translate="yes" xml:space="preserve">
          <source>If the structure of inputs per replica does not match the structure of &lt;code&gt;maximum_shapes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d30e9d875fd192cb3baaabd913b4b57914b7a37" translate="yes" xml:space="preserve">
          <source>If the structures of &lt;code&gt;output_shapes&lt;/code&gt; and &lt;code&gt;output_types&lt;/code&gt; are not the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef1c30d1f578546d2ac2a550f76da4a58e33bff" translate="yes" xml:space="preserve">
          <source>If the sum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">Если сумма пуста для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="873ee7c62a98d7de613cf70bb2470219e6db5cb9" translate="yes" xml:space="preserve">
          <source>If the sum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;. If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, the value is dropped and will not be added to the sum of the segment.</source>
          <target state="translated">Если сумма пуста для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; . Если данный идентификатор сегмента &lt;code&gt;i&lt;/code&gt; отрицательный, значение отбрасывается и не будет добавлено к сумме сегмента.</target>
        </trans-unit>
        <trans-unit id="3b513c82152e6957978048500ff9bfbeecd96db7" translate="yes" xml:space="preserve">
          <source>If the task_type or task_id is not specified and the &lt;code&gt;TF_CONFIG&lt;/code&gt; environment variable does not contain a task section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36e9fd8063e68e549307244c175aa35d72257cf" translate="yes" xml:space="preserve">
          <source>If the tensor has rank &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; non-empty values, &lt;code&gt;input_indices&lt;/code&gt; has shape &lt;code&gt;[N, R]&lt;/code&gt;, input_values has length &lt;code&gt;N&lt;/code&gt;, and input_shape has length &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59713476f3de6c632928eea81b1fc2ac46a8cac3" translate="yes" xml:space="preserve">
          <source>If the tensor is not scalar (rank 0), or if its shape is unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23837fad92f5de53c22f485995bbc7eb51b99864" translate="yes" xml:space="preserve">
          <source>If the tensor's data type doesn't match &lt;code&gt;tf_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bfa6ca2caca4913525a3c6982871f158747c35" translate="yes" xml:space="preserve">
          <source>If the tensors data type doesn't match &lt;code&gt;tf_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a6d43b61a912e98de11addfc5b73fcd9317a33" translate="yes" xml:space="preserve">
          <source>If the timeout expires and no &lt;code&gt;timeout_fn&lt;/code&gt; was specified, the iterator stops yielding.</source>
          <target state="translated">Если тайм-аут истекает и &lt;code&gt;timeout_fn&lt;/code&gt; не указан, итератор прекращает работу.</target>
        </trans-unit>
        <trans-unit id="0ce0283a8891c6dd66c32b4615d78fc780d2dda4" translate="yes" xml:space="preserve">
          <source>If the two objects compare equal then they will automatically compare almost equal.</source>
          <target state="translated">Если два объекта сравниваются равными,то они автоматически сравнивают почти равные объекты.</target>
        </trans-unit>
        <trans-unit id="35ceb4feec8fb5679f604323d53b185248a5db16" translate="yes" xml:space="preserve">
          <source>If the two sequences compare equal then they will automatically compare almost equal.</source>
          <target state="translated">Если две последовательности сравнивают равные,то они автоматически сравнивают почти равные.</target>
        </trans-unit>
        <trans-unit id="9eae4d4a1fd60b32f2c7d8f6f2a10067a9a6d7e6" translate="yes" xml:space="preserve">
          <source>If the two shapes can not be broadcasted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3475d1b1b8cd88a2f94da998df8de0a1aae9b7" translate="yes" xml:space="preserve">
          <source>If the two structures differ in the type of sequence in any of their substructures. Only possible if &lt;code&gt;check_types&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95bfb47b075490744ea9721025fb70fedba814a4" translate="yes" xml:space="preserve">
          <source>If the two structures do not have the same number of elements or if the two structures are not nested in the same way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73def4adcaec6420d05f38da2b9b05aadf56707a" translate="yes" xml:space="preserve">
          <source>If the type of any sequence in &lt;code&gt;features&lt;/code&gt; does not match corresponding sequence in &lt;code&gt;feature_config&lt;/code&gt;. Similarly for &lt;code&gt;weights&lt;/code&gt;, if not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c31d4a26026b902293fe12faee2cc27d70da5f2" translate="yes" xml:space="preserve">
          <source>If the type of any sequence in &lt;code&gt;gradients&lt;/code&gt; does not match corresponding sequence in &lt;code&gt;feature_config&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de6747c93c96034acd5b828eb4c1ac1d1759818" translate="yes" xml:space="preserve">
          <source>If the underlying model isn't configured to compute accuracy. You should pass &lt;code&gt;metrics=[&quot;accuracy&quot;]&lt;/code&gt; to the &lt;code&gt;.compile()&lt;/code&gt; method of the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64507e1140a9c0626ea583b5e87dbd260bda51eb" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;trainable&lt;/code&gt; attribute is changed after calling &lt;code&gt;compile()&lt;/code&gt; on a model, the new value doesn't take effect for this model until &lt;code&gt;compile()&lt;/code&gt; is called again.</source>
          <target state="translated">Если значение &lt;code&gt;trainable&lt;/code&gt; атрибута изменяется после вызова &lt;code&gt;compile()&lt;/code&gt; в модели, новое значение не вступает в силу для этой модели до тех пор, пока &lt;code&gt;compile()&lt;/code&gt; будет вызван снова.</target>
        </trans-unit>
        <trans-unit id="0ec166eb5f0480259a89fe33597cbbfaf40ea475" translate="yes" xml:space="preserve">
          <source>If the values in axes exceed the rank of the corresponding tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd89116881b160da2d890f238051b8324a1b3f6" translate="yes" xml:space="preserve">
          <source>If the variable was initialized to zero, you can divide by &lt;code&gt;1 - momentum ** num_updates&lt;/code&gt; to debias it (Section 3 of &lt;a href=&quot;https://arxiv.org/abs/1412.6980&quot;&gt;Kingma et al., 2015&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2bf8a9253fdc438cae9ed780e601ca5be3a051" translate="yes" xml:space="preserve">
          <source>If the vocabulary cannot be set when this function is called. This happens when &quot;binary&quot;, &quot;count&quot;, and &quot;tfidf&quot; modes, if &quot;pad_to_max_tokens&quot; is False and the layer itself has already been called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364282886e323bb3ccb0f79b39dcdce0b99762de" translate="yes" xml:space="preserve">
          <source>If there are conflicting keys detected when merging two or more dictionaries, this exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a726849408c4956726cdbe5ad4e4c413105f47a" translate="yes" xml:space="preserve">
          <source>If there are errors during the file save operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388fe17c0df4d7e0778657b27663a6a6e2a4aad0" translate="yes" xml:space="preserve">
          <source>If there are filesystem / directory listing errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acb8371bc3eb15ec09be518ceef07a3ea9797ba" translate="yes" xml:space="preserve">
          <source>If there are no arguments passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397c97cfbe31f32ae505b25e33933f6512b38899" translate="yes" xml:space="preserve">
          <source>If there are too many inputs, the inputs do not match, or input data is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9279bebc813b4c73813e2c61b0ade7210ad036f6" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;../../../../estimator/estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899df9e02e8493f5b070e1bc0642e86903996f5d" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;../../../estimator/estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84b959e75c6d0c07150d6bf472c7eaa938705d4" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;../estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fba7df71af1734c3900ec5722da912184e87acd" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d869a15febad2f275c04757cafb49397fc0fa415" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;../../../../distribute/reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">Если есть последний частичный пакет, вам нужно будет указать ось, чтобы результирующая форма была согласованной для всех реплик. Таким образом, если последний пакет имеет размер 6 и разделен на [0, 1, 2, 3] и [4, 5], вы получите несоответствие формы, если вы не укажете &lt;code&gt;axis=0&lt;/code&gt; . Если вы укажете &lt;a href=&quot;../../../../distribute/reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; &lt;/a&gt; , то при использовании &lt;code&gt;axis=0&lt;/code&gt; будет использоваться правильный знаменатель 6. Сравните это с вычислением &lt;code&gt;reduce_mean&lt;/code&gt; , чтобы получить скалярное значение для каждой реплики, и этой функцией для усреднения этих средних, которые будут весить некоторые значения &lt;code&gt;1/8&lt;/code&gt; и другие &lt;code&gt;1/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c72f727cca64a808cf7c4b7c3edec0a4599f0ee" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;../../../distribute/reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">Если есть последний частичный пакет, вам нужно будет указать ось, чтобы результирующая форма была согласованной для всех реплик. Таким образом, если последний пакет имеет размер 6 и разделен на [0, 1, 2, 3] и [4, 5], вы получите несоответствие формы, если вы не укажете &lt;code&gt;axis=0&lt;/code&gt; . Если вы укажете &lt;a href=&quot;../../../distribute/reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; &lt;/a&gt; , то при использовании &lt;code&gt;axis=0&lt;/code&gt; будет использоваться правильный знаменатель 6. Сравните это с вычислением &lt;code&gt;reduce_mean&lt;/code&gt; , чтобы получить скалярное значение для каждой реплики, и этой функцией для усреднения этих средних, которые будут весить некоторые значения &lt;code&gt;1/8&lt;/code&gt; и другие &lt;code&gt;1/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="611167fb33b99cb5686e6e2a810b98db2c2349ad" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;../reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">Если есть последний частичный пакет, вам нужно будет указать ось, чтобы результирующая форма была согласованной для всех реплик. Таким образом, если последний пакет имеет размер 6 и разделен на [0, 1, 2, 3] и [4, 5], вы получите несоответствие формы, если вы не укажете &lt;code&gt;axis=0&lt;/code&gt; . Если вы укажете &lt;a href=&quot;../reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; &lt;/a&gt; , то при использовании &lt;code&gt;axis=0&lt;/code&gt; будет использоваться правильный знаменатель 6. Сравните это с вычислением &lt;code&gt;reduce_mean&lt;/code&gt; , чтобы получить скалярное значение для каждой реплики, и этой функцией для усреднения этих средних, которые будут весить некоторые значения &lt;code&gt;1/8&lt;/code&gt; и другие &lt;code&gt;1/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9048470fa4efaf23b25ac2170e5cb511464506dc" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">Если есть последний частичный пакет, вам нужно будет указать ось, чтобы результирующая форма была согласованной для всех реплик. Таким образом, если последний пакет имеет размер 6 и разделен на [0, 1, 2, 3] и [4, 5], вы получите несоответствие формы, если вы не укажете &lt;code&gt;axis=0&lt;/code&gt; . Если вы укажете &lt;a href=&quot;reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; &lt;/a&gt; , то при использовании &lt;code&gt;axis=0&lt;/code&gt; будет использоваться правильный знаменатель 6. Сравните это с вычислением &lt;code&gt;reduce_mean&lt;/code&gt; , чтобы получить скалярное значение для каждой реплики, и этой функцией для усреднения этих средних, которые будут весить некоторые значения &lt;code&gt;1/8&lt;/code&gt; и другие &lt;code&gt;1/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7191342d52aa3d47ff7927195bf323c54a2bcc" translate="yes" xml:space="preserve">
          <source>If there is a shape mismatch between the inputs and the shapes cannot be broadcasted to match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85ee17d394a0c122c1d9a09f179d26aa5670744" translate="yes" xml:space="preserve">
          <source>If there is no KL method registered specifically for &lt;code&gt;type(distribution_a)&lt;/code&gt; and &lt;code&gt;type(distribution_b)&lt;/code&gt;, then the class hierarchies of these types are searched.</source>
          <target state="translated">Если KL-метод не зарегистрирован специально для &lt;code&gt;type(distribution_a)&lt;/code&gt; и &lt;code&gt;type(distribution_b)&lt;/code&gt; , выполняется поиск в иерархиях классов этих типов.</target>
        </trans-unit>
        <trans-unit id="0aad6242676f764d7914e7304fd4bc4d049fdd75" translate="yes" xml:space="preserve">
          <source>If there is no TypeSpec that is compatible with both &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8e6b1b3d8134f559708fe8c9597d36901255cf" translate="yes" xml:space="preserve">
          <source>If there is no active profiling session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7912243ede8abeeda54d04f710e447b16a7a2e" translate="yes" xml:space="preserve">
          <source>If there is no entry for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs 0.</source>
          <target state="translated">Если для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; нет записи , выводится 0.</target>
        </trans-unit>
        <trans-unit id="cf1d14f3c88546018feaf0d39b2b59114e95d67f" translate="yes" xml:space="preserve">
          <source>If there is no entry for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs 1.</source>
          <target state="translated">Если для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; нет записи , выводится 1.</target>
        </trans-unit>
        <trans-unit id="8b273aa994678829ffd0b282cbffdded4906ae32" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Session&lt;/code&gt; is in an invalid state (e.g. has been closed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5311650ce8de279027f2e15a0c08573e4eb50ee1" translate="yes" xml:space="preserve">
          <source>If this is callable, it should be a function of one argument that inspects the passed-in exception and returns True (success) or False (please fail the test). Otherwise, the error message is expected to match this regular expression partially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905304f1bcc984112aa96111001589bd421fac68" translate="yes" xml:space="preserve">
          <source>If this is called before apply_gradients().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf5400cdc3e4d05bcb2e0233a34376a166c6575" translate="yes" xml:space="preserve">
          <source>If this is not the case for your loss (if, for example, your loss references a &lt;code&gt;Variable&lt;/code&gt; of one of the model's layers), you can wrap your loss in a zero-argument lambda. These losses are not tracked as part of the model's topology since they can't be serialized.</source>
          <target state="translated">Если это не относится к вашей потере (если, например, ваша потеря ссылается на &lt;code&gt;Variable&lt;/code&gt; одного из слоев модели), вы можете заключить свою потерю в лямбду с нулевым аргументом. Эти потери не отслеживаются как часть топологии модели, поскольку они не могут быть сериализованы.</target>
        </trans-unit>
        <trans-unit id="a16f543cad9c6d848f192a10e84648afb82147fd" translate="yes" xml:space="preserve">
          <source>If this layer is used when using tf.distribute strategy to train models across devices/workers, there will be an allreduce call to aggregate batch statistics across all replicas at every training step. Without tf.distribute strategy, this layer behaves as a regular &lt;a href=&quot;../batchnormalization&quot;&gt;&lt;code&gt;tf.keras.layers.BatchNormalization&lt;/code&gt;&lt;/a&gt; layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe81d5d5eaf76d2a5be367788954521f73bd4d6" translate="yes" xml:space="preserve">
          <source>If this method is called inside defun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a84b9a7746118e73d604dc320af07d2b1b6de8" translate="yes" xml:space="preserve">
          <source>If this method is called, &lt;code&gt;get_scaled_loss&lt;/code&gt; should also be called. See the &lt;a href=&quot;lossscaleoptimizer&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt;&lt;/a&gt; doc for an example.</source>
          <target state="translated">Если вызывается этот метод, следует также вызвать &lt;code&gt;get_scaled_loss&lt;/code&gt; . См. &lt;a href=&quot;lossscaleoptimizer&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt; &lt;/a&gt; документации tf.keras.mixed_precision.experimental.LossScaleOptimizer .</target>
        </trans-unit>
        <trans-unit id="90126041d843d207c1a230dd608378fc394de215" translate="yes" xml:space="preserve">
          <source>If this method is called, &lt;code&gt;get_unscaled_gradients&lt;/code&gt; should also be called. See the &lt;a href=&quot;lossscaleoptimizer&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt;&lt;/a&gt; doc for an example.</source>
          <target state="translated">Если этот метод вызывается, также следует вызывать &lt;code&gt;get_unscaled_gradients&lt;/code&gt; . См. &lt;a href=&quot;lossscaleoptimizer&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt; &lt;/a&gt; документации tf.keras.mixed_precision.experimental.LossScaleOptimizer .</target>
        </trans-unit>
        <trans-unit id="668c59e4c87d0ca62e75f8e9f92138d3a33081f3" translate="yes" xml:space="preserve">
          <source>If this op does not have an attr with the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab5fd845bbcbc69da7d15bc16ce0eb8f62203dd" translate="yes" xml:space="preserve">
          <source>If this op is configured to not have padding, or if it is configured to add padding with &lt;code&gt;padding_width&lt;/code&gt; set to less than ngram_width-1, it is possible that a sequence, or a sequence plus padding, is smaller than the ngram width. In that case, no ngrams will be generated for that sequence. This can be prevented by setting &lt;code&gt;preserve_short_sequences&lt;/code&gt;, which will cause the op to always generate at least one ngram per non-empty sequence.</source>
          <target state="translated">Если эта операция настроена на отсутствие заполнения или если она настроена на добавление заполнения с &lt;code&gt;padding_width&lt;/code&gt; , установленным на значение меньше ngram_width-1, возможно, что последовательность или последовательность плюс заполнение меньше, чем ширина ngram. В этом случае для этой последовательности не будут созданы диаграммы. Этого можно избежать, установив &lt;code&gt;preserve_short_sequences&lt;/code&gt; , что заставит op всегда генерировать по крайней мере одну ngram на непустую последовательность.</target>
        </trans-unit>
        <trans-unit id="ab839358f55486546d3d029071a450dcaefa7d5b" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор действует как пакетные матрицы &lt;code&gt;A&lt;/code&gt; с &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; , то это возвращает &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ce9f7e3db7531975f11e7f4a68cd88c0d560996" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор действует как пакетные матрицы &lt;code&gt;A&lt;/code&gt; с &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; , то это возвращает &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62e8ab46dc91b8378fc928855066ea5b3d23a6e6" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;TensorShape([B1,...,Bb, M, N])&lt;/code&gt;, equivalent to &lt;code&gt;A.shape&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор действует как пакетная матрица &lt;code&gt;A&lt;/code&gt; с &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; , то он возвращает &lt;code&gt;TensorShape([B1,...,Bb, M, N])&lt;/code&gt; , что эквивалентно &lt;code&gt;A.shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="689aa8d64b08329267dae138eebcb059972cf24c" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;TensorShape([B1,...,Bb])&lt;/code&gt;, equivalent to &lt;code&gt;A.shape[:-2]&lt;/code&gt;</source>
          <target state="translated">Если этот оператор действует как пакетная матрица &lt;code&gt;A&lt;/code&gt; с &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; , то он возвращает &lt;code&gt;TensorShape([B1,...,Bb])&lt;/code&gt; , эквивалентный &lt;code&gt;A.shape[:-2]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e16fa6d80d3c7cfd9673c1871d91dcd51542d167" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;b + 2&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор действует как матрица партии &lt;code&gt;A&lt;/code&gt; с &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; , то он возвращает &lt;code&gt;b + 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03127ec398775f2a4051ba0c818b1ec18cf14baf" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns a &lt;code&gt;Tensor&lt;/code&gt; holding &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt;, equivalent to &lt;a href=&quot;../shape&quot;&gt;&lt;code&gt;tf.shape(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если этот оператор действует как матрица партии &lt;code&gt;A&lt;/code&gt; с &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; , то он возвращает &lt;code&gt;Tensor&lt;/code&gt; содержащий &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; , что эквивалентно &lt;a href=&quot;../shape&quot;&gt; &lt;code&gt;tf.shape(A)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ab4fc41b0560bb6a934607949bd5b386ee29f8" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns a &lt;code&gt;Tensor&lt;/code&gt; holding &lt;code&gt;[B1,...,Bb]&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор действует как пакетная матрица &lt;code&gt;A&lt;/code&gt; с &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; , тогда он возвращает &lt;code&gt;Tensor&lt;/code&gt; содержащий &lt;code&gt;[B1,...,Bb]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="921347482b8fd91ee313851ca1cccdafc480cddb" translate="yes" xml:space="preserve">
          <source>If this operator has shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt;, this returns a &lt;code&gt;Tensor&lt;/code&gt;&lt;code&gt;diagonal&lt;/code&gt;, of shape &lt;code&gt;[B1,...,Bb, min(M, N)]&lt;/code&gt;, where &lt;code&gt;diagonal[b1,...,bb, i] = self.to_dense()[b1,...,bb, i, i]&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор имеет форму &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; , он возвращает &lt;code&gt;Tensor&lt;/code&gt; &lt;code&gt;diagonal&lt;/code&gt; формы &lt;code&gt;[B1,...,Bb, min(M, N)]&lt;/code&gt; , где &lt;code&gt;diagonal[b1,...,bb, i] = self.to_dense()[b1,...,bb, i, i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f17df02cdfdf16ae55ddc38c4d96a43d8d0194c" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this hints &lt;code&gt;D &amp;gt; 0&lt;/code&gt; elementwise.</source>
          <target state="translated">Если этот оператор &lt;code&gt;A = L + U D V^H&lt;/code&gt; , это намекает на &lt;code&gt;D &amp;gt; 0&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="3d7432da8d98b1f600f518b45f152630261f8725" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор &lt;code&gt;A = L + U D V^H&lt;/code&gt; , это &lt;code&gt;D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac0c26f8d498bda35983c79790cb84038dcc48a1" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is the &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор &lt;code&gt;A = L + U D V^H&lt;/code&gt; , это &lt;code&gt;L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed4f7079684ac253ddfaf867eaf34bf8cf0aed43" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is the &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор &lt;code&gt;A = L + U D V^H&lt;/code&gt; , это &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b75fcf71c0a569ab0e4f88a68f9b2ba47762aa34" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is the &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор &lt;code&gt;A = L + U D V^H&lt;/code&gt; , это &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11a0d778ea7b358f23842e885c1d5a8c5ecc2928" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is the diagonal of &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="translated">Если этот оператор &lt;code&gt;A = L + U D V^H&lt;/code&gt; , это диагональ &lt;code&gt;D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac015fe43443b780f0f83ee7a02dba87f69812e3" translate="yes" xml:space="preserve">
          <source>If this optional does not have a value (i.e. &lt;code&gt;self.has_value()&lt;/code&gt; evaluates to &lt;code&gt;False&lt;/code&gt;), this operation will raise &lt;a href=&quot;../../errors/invalidargumenterror&quot;&gt;&lt;code&gt;tf.errors.InvalidArgumentError&lt;/code&gt;&lt;/a&gt; at runtime.</source>
          <target state="translated">Если этот дополнительный параметр не имеет значения (например, &lt;code&gt;self.has_value()&lt;/code&gt; оценивается как &lt;code&gt;False&lt;/code&gt; ), эта операция вызовет &lt;a href=&quot;../../errors/invalidargumenterror&quot;&gt; &lt;code&gt;tf.errors.InvalidArgumentError&lt;/code&gt; &lt;/a&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="e721351d62e8560faa79940bb195f1f52214823e" translate="yes" xml:space="preserve">
          <source>If this optional does not have a value (i.e. &lt;code&gt;self.has_value()&lt;/code&gt; evaluates to &lt;code&gt;False&lt;/code&gt;), this operation will raise &lt;a href=&quot;../errors/invalidargumenterror&quot;&gt;&lt;code&gt;tf.errors.InvalidArgumentError&lt;/code&gt;&lt;/a&gt; at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b41f377cbcb0fda59b6793b37f389278a7f495c" translate="yes" xml:space="preserve">
          <source>If this value is more than 1, OOV inputs are hashed to determine their OOV value; if this value is 0, passing an OOV input will result in a '-1' being returned for that value in the output tensor. (Note that, because the value is -1 and not 0, this will allow you to effectively drop OOV values from categorical encodings.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1514ab93b97285018f1c274f51c16deb4d70ee5" translate="yes" xml:space="preserve">
          <source>If this value is more than 1, OOV inputs are modulated to determine their OOV value; if this value is 0, passing an OOV input will result in a '-1' being returned for that value in the output tensor. (Note that, because the value is -1 and not 0, this will allow you to effectively drop OOV values from categorical encodings.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cdf432873b1c4a434c37672f4c11b50efb424e" translate="yes" xml:space="preserve">
          <source>If time_major == False (default), this will be a &lt;code&gt;Tensor&lt;/code&gt; shaped: &lt;code&gt;[batch_size, max_time, cell.output_size]&lt;/code&gt;.</source>
          <target state="translated">Если time_major == False (по умолчанию), это будет &lt;code&gt;Tensor&lt;/code&gt; форма: &lt;code&gt;[batch_size, max_time, cell.output_size]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ef8f486f9257f3c609cd71034848e31051aeee" translate="yes" xml:space="preserve">
          <source>If time_major == True, this will be a &lt;code&gt;Tensor&lt;/code&gt; shaped: &lt;code&gt;[max_time, batch_size, cell.output_size]&lt;/code&gt;.</source>
          <target state="translated">Если time_major == True, это будет &lt;code&gt;Tensor&lt;/code&gt; форма: &lt;code&gt;[max_time, batch_size, cell.output_size]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e814ed4eb2aa229b46d9532ee0af8eee2088116" translate="yes" xml:space="preserve">
          <source>If transpose_a and adjoint_a are both set to True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9771c610e0ca580ebfd1ee02c48a63efc43f4a" translate="yes" xml:space="preserve">
          <source>If transpose_output is &lt;code&gt;true&lt;/code&gt;, returns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be7f5250b50d753b36e91700f51df547557d415" translate="yes" xml:space="preserve">
          <source>If transpose_output is false, returns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987f748364c0cbac5dff0794850510411dc2ab70" translate="yes" xml:space="preserve">
          <source>If true put each gradient subgraph into a separate compilation scope. This gives fine-grained control over which portions of the graph will be compiled as a single unit. Compiling gradients separately may yield better performance for some graphs. The scope is named based on the scope of the forward computation as well as the name of the gradients. As a result, the gradients will be compiled in a scope that is separate from both the forward computation, and from other gradients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4bf4531db5255ca9a9edafe8fc64d442d3621ea" translate="yes" xml:space="preserve">
          <source>If true the resulting &lt;code&gt;k&lt;/code&gt; elements will be sorted by the values in descending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e6ce40eef5a70bfa5ac1274964be590a2c1a68" translate="yes" xml:space="preserve">
          <source>If true use &lt;code&gt;input_min&lt;/code&gt; and &lt;code&gt;input_max&lt;/code&gt; for the range of the input, otherwise determine min and max from the input &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d835c5abdde926d74d741995b5b63e74e4a04d" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;MonitoredSession&lt;/code&gt; stops iterations. Returns: A &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">Если true, &lt;code&gt;MonitoredSession&lt;/code&gt; останавливает итерации. Возвращает: a &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="642245f4a87a8ae51f595e743952d5f1a8383e6b" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;obj&lt;/code&gt; may refer to a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb038c7a2651630e273adec4e4668df52c87e0e" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;obj&lt;/code&gt; may refer to an &lt;code&gt;Operation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0427ac6b0b0fdb1672cf3af3d4818c9a571f5214" translate="yes" xml:space="preserve">
          <source>If true, adds an &quot;_output_shapes&quot; list attr to each node with the inferred shapes of each of its outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2410d14ffcca817b83e0409520b16ad690792a61" translate="yes" xml:space="preserve">
          <source>If true, compute full-sized &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;. If false (the default), compute only the leading &lt;code&gt;P&lt;/code&gt; singular vectors. Ignored if &lt;code&gt;compute_uv&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f633a10a54cff5eadc8d762cd005175ec8c3e6f1" translate="yes" xml:space="preserve">
          <source>If true, on failing to vectorize an operation, the unsupported op is wrapped in a tf.while_loop to execute the map iterations. Note that this fallback only happens for unsupported ops and other parts of &lt;code&gt;fn&lt;/code&gt; are still vectorized. If false, on encountering an unsupported op, a ValueError is thrown. Note that the fallbacks can result in slowdowns since vectorization often yields speedup of one to two orders of magnitude.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048f1f24a5bcac1d8894f5b93c0a90fdbe61f251" translate="yes" xml:space="preserve">
          <source>If true, only account statistics of nodes eventually displayed by the outputs. Otherwise, a node's statistics are accounted by its parents as long as it's types match 'account_type_regexes', even if it is hidden from the output, say, by hide_name_regexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d83a8ec3b4b432ce5abe190cc7b46d4bf56426" translate="yes" xml:space="preserve">
          <source>If true, only applies colocation of this op within the context, rather than applying all colocation properties on the stack. If &lt;code&gt;op&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, this value must be &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5991704ef5e5ed338b15a5a568def2fee052f4" translate="yes" xml:space="preserve">
          <source>If true, retain reduced dimensions with length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e2c570f4b644f41dc5e0706770850ecf206aa3" translate="yes" xml:space="preserve">
          <source>If true, retains reduced dimensions with length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bd78dc8c3d9722bd2751248ac3d2d2f79be2ad" translate="yes" xml:space="preserve">
          <source>If true, returns a &lt;code&gt;SparseTensor&lt;/code&gt; instead of a dense &lt;code&gt;Tensor&lt;/code&gt; (the default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fecd242704de37b3dd904a022f989afe06213fd" translate="yes" xml:space="preserve">
          <source>If true, the coordinates of output nmsed boxes will be clipped to [0, 1]. If false, output the box coordinates as it is. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502ce0cdb04da01c657079618fa04e2987ef5a38" translate="yes" xml:space="preserve">
          <source>If true, then composite tensors such as &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; are expanded into their component tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f3e3debcd743db974fadd47bb3a3fd32699bd6" translate="yes" xml:space="preserve">
          <source>If true, then ensure that at least one ngram is generated for each input sequence. In particular, if an input sequence is shorter than &lt;code&gt;min(ngram_width) + 2*pad_width&lt;/code&gt;, then generate a single ngram containing the entire sequence. If false, then no ngrams are generated for these short input sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8897b80b8903485de9da49cf445089ca28e01ee" translate="yes" xml:space="preserve">
          <source>If true, then the absolute value of the quantized minimum value is the same as the quantized maximum value, instead of 1 greater. i.e. for 8 bit quantization, the minimum value is -127 instead of -128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605f28ad697888d560565e20edb2658524ca80dd" translate="yes" xml:space="preserve">
          <source>If true, then use assertions to check that the arguments form a valid &lt;code&gt;RaggedTensor&lt;/code&gt;. Note: these assertions incur a runtime cost, since they must be checked for each tensor value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e1750211ccf0ffd4d7bf04033e96ab6703e8b1" translate="yes" xml:space="preserve">
          <source>If true, this layer will map indices to vocabulary items instead of mapping vocabulary items to indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5fe58711f7508a2f179f8f78c412b0f3855389" translate="yes" xml:space="preserve">
          <source>If true, uses pfor for computing the Jacobian. Else uses a tf.while_loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0088562ae1b7677b52faeef211542485c79f6d3c" translate="yes" xml:space="preserve">
          <source>If true, uses safe_embedding_lookup_sparse instead of embedding_lookup_sparse. safe_embedding_lookup_sparse ensures there are no empty rows and all weights and ids are positive at the expense of extra compute cost. This only applies to rank 2 (NxM) shaped input tensors. Defaults to true, consider turning off if the above checks are not needed. Note that having empty rows will not trigger any error though the output result might be 0 or omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbeb35334fcf898781955202c2c41a0263216176" translate="yes" xml:space="preserve">
          <source>If true, vectorizes the jacobian computation. Else falls back to a sequential while_loop. Vectorization can sometimes fail or lead to excessive memory usage. This option can be used to disable vectorization in such cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bb27a9d56dc099a7acc0da9b42015044430fff" translate="yes" xml:space="preserve">
          <source>If true, we do not use the minimum quantized value. i.e. for int8 the quantized output, it would be restricted to the range -127..127 instead of the full -128..127 range. This is provided for compatibility with certain inference backends. (Only applies to SCALED mode)</source>
          <target state="translated">Если верно,то мы не используем минимальное квантованное значение,т.е.для int8 квантованный выход был бы ограничен диапазоном -127...127,а не полным диапазоном -128...127.Это предусмотрено для совместимости с определенными бэкэндами вывода.(применяется только к режиму SCALED).</target>
        </trans-unit>
        <trans-unit id="83490805bb1f49a5f8bb8f11bf034585aac8c23b" translate="yes" xml:space="preserve">
          <source>If tuple of 2 ints: interpreted as two different symmetric cropping values for height and width: &lt;code&gt;(symmetric_height_crop, symmetric_width_crop)&lt;/code&gt;.</source>
          <target state="translated">Если кортеж из 2 целых чисел: интерпретируется как два разных симметричных значения обрезки для высоты и ширины: &lt;code&gt;(symmetric_height_crop, symmetric_width_crop)&lt;/code&gt; symric_height_crop, symric_width_crop ) .</target>
        </trans-unit>
        <trans-unit id="29288c4cdf42a8a30d0d3b67f8aed321e16ae670" translate="yes" xml:space="preserve">
          <source>If tuple of 2 ints: interpreted as two different symmetric padding values for height and width: &lt;code&gt;(symmetric_height_pad, symmetric_width_pad)&lt;/code&gt;.</source>
          <target state="translated">Если кортеж из 2 целых чисел: интерпретируется как два разных симметричных значения заполнения для высоты и ширины: &lt;code&gt;(symmetric_height_pad, symmetric_width_pad)&lt;/code&gt; symric_height_pad, symric_width_pad ) .</target>
        </trans-unit>
        <trans-unit id="0b67c19bd4a86767a2e3f540ca915d81b144b003" translate="yes" xml:space="preserve">
          <source>If tuple of 2 tuples of 2 ints: interpreted as &lt;code&gt;((top_crop, bottom_crop), (left_crop, right_crop))&lt;/code&gt;</source>
          <target state="translated">Если кортеж из 2 кортежей по 2 целых: интерпретируется как &lt;code&gt;((top_crop, bottom_crop), (left_crop, right_crop))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="487146df721c523689eaeddaf64885a4a783f231" translate="yes" xml:space="preserve">
          <source>If tuple of 2 tuples of 2 ints: interpreted as &lt;code&gt;((top_pad, bottom_pad), (left_pad, right_pad))&lt;/code&gt;</source>
          <target state="translated">Если кортеж из 2 кортежей по 2 int: интерпретируется как &lt;code&gt;((top_pad, bottom_pad), (left_pad, right_pad))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="812fc65b353a07607726b2966667ffdf62fd3b3c" translate="yes" xml:space="preserve">
          <source>If tuple of 3 ints: interpreted as two different symmetric cropping values for depth, height, and width: &lt;code&gt;(symmetric_dim1_crop, symmetric_dim2_crop, symmetric_dim3_crop)&lt;/code&gt;.</source>
          <target state="translated">Если кортеж из 3 целых чисел: интерпретируется как два разных симметричных значения обрезки для глубины, высоты и ширины: &lt;code&gt;(symmetric_dim1_crop, symmetric_dim2_crop, symmetric_dim3_crop)&lt;/code&gt; symric_dim1_crop, symric_dim2_crop, symric_dim3_crop ) .</target>
        </trans-unit>
        <trans-unit id="43b0e46a9dc3a1e8c76f88c379c30be852303e72" translate="yes" xml:space="preserve">
          <source>If tuple of 3 ints: interpreted as two different symmetric padding values for height and width: &lt;code&gt;(symmetric_dim1_pad, symmetric_dim2_pad, symmetric_dim3_pad)&lt;/code&gt;.</source>
          <target state="translated">Если кортеж из 3 целых чисел: интерпретируется как два разных симметричных значения заполнения для высоты и ширины: &lt;code&gt;(symmetric_dim1_pad, symmetric_dim2_pad, symmetric_dim3_pad)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c88b2c00149b3f5340f436ed5d7d8a348e7c720" translate="yes" xml:space="preserve">
          <source>If tuple of 3 tuples of 2 ints: interpreted as &lt;code&gt;((left_dim1_crop, right_dim1_crop), (left_dim2_crop, right_dim2_crop), (left_dim3_crop, right_dim3_crop))&lt;/code&gt;</source>
          <target state="translated">Если кортеж из 3 кортежей по 2 целых: интерпретируется как &lt;code&gt;((left_dim1_crop, right_dim1_crop), (left_dim2_crop, right_dim2_crop), (left_dim3_crop, right_dim3_crop))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f527489de1e80e2130364ad7b3746cd24f497905" translate="yes" xml:space="preserve">
          <source>If tuple of 3 tuples of 2 ints: interpreted as &lt;code&gt;((left_dim1_pad, right_dim1_pad), (left_dim2_pad, right_dim2_pad), (left_dim3_pad, right_dim3_pad))&lt;/code&gt;</source>
          <target state="translated">Если кортеж из 3 кортежей по 2 целых числа: интерпретируется как &lt;code&gt;((left_dim1_pad, right_dim1_pad), (left_dim2_pad, right_dim2_pad), (left_dim3_pad, right_dim3_pad))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3faf4c1ccd2136f577d7a0c4205048d0ffd1bdee" translate="yes" xml:space="preserve">
          <source>If tuple of int (length 2): How many zeros to add at the beginning and at the end of the padding dimension (&lt;code&gt;(left_pad, right_pad)&lt;/code&gt;).</source>
          <target state="translated">Если кортеж имеет тип int (длина 2): сколько нулей добавить в начало и в конец измерения заполнения ( &lt;code&gt;(left_pad, right_pad)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="04717633bfa1f5d00ee7921c11bc933528638c7c" translate="yes" xml:space="preserve">
          <source>If tuple of int (length 2): How many zeros to add at the beginning and the end of the padding dimension (&lt;code&gt;(left_pad, right_pad)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5216b9fe5dfaa382d9801ed52c23fb17ea2eda" translate="yes" xml:space="preserve">
          <source>If two elements are equal, the lower-index element appears first.</source>
          <target state="translated">Если два элемента равны,то первым появляется элемент нижнего индекса.</target>
        </trans-unit>
        <trans-unit id="db885c2d7731f7899921d98b5677edf2220668cb" translate="yes" xml:space="preserve">
          <source>If units is not an int.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bce7b71d5fde27e87108fc2b8f29d9e9dd019f3" translate="yes" xml:space="preserve">
          <source>If user called &lt;code&gt;MonitoredSession.run(fetches=a, feed_dict=b)&lt;/code&gt;, then this field is equal to SessionRunArgs(a, b).</source>
          <target state="translated">Если пользователь вызвал &lt;code&gt;MonitoredSession.run(fetches=a, feed_dict=b)&lt;/code&gt; , то это поле равно SessionRunArgs (a, b).</target>
        </trans-unit>
        <trans-unit id="a7b2692658ec0f3b0fedbacc5e4dc8afebe62f2f" translate="yes" xml:space="preserve">
          <source>If users keep data in tf.Example format, they need to call tf.parse_example with a proper feature spec. There are two main things that this utility helps:</source>
          <target state="translated">Если пользователи хранят данные в формате tf.example,им необходимо вызвать tf.parse_example с соответствующей спецификацией функции.Есть две основные вещи,которые помогает эта утилита:</target>
        </trans-unit>
        <trans-unit id="50cf7138d7b09704383c9338ec705e7ebf6961a1" translate="yes" xml:space="preserve">
          <source>If using exclusive &lt;code&gt;labels&lt;/code&gt; (wherein one and only one class is true at a time), see &lt;code&gt;sparse_softmax_cross_entropy_with_logits&lt;/code&gt;.</source>
          <target state="translated">Если используются эксклюзивные &lt;code&gt;labels&lt;/code&gt; (в которых истинен только один и только один класс), см. &lt;code&gt;sparse_softmax_cross_entropy_with_logits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19d3637a3d6d25647e984cf647cb8291a36aa8b9" translate="yes" xml:space="preserve">
          <source>If valid compression_type can't be determined from &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87079ede7f1a53d1f2cf6b63c82bcae55f52855b" translate="yes" xml:space="preserve">
          <source>If validation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f309484c1aebad69e2272b3c3b34b511f44f66" translate="yes" xml:space="preserve">
          <source>If value is False, then only the name prepended with 'no' is emitted.</source>
          <target state="translated">Если значение параметра False,то выдается только имя,дополненное символом &quot;нет&quot;.</target>
        </trans-unit>
        <trans-unit id="0d582533f76f9fbe72b42e141cd8db21e3ebbecb" translate="yes" xml:space="preserve">
          <source>If value is None, then only the name is emitted.</source>
          <target state="translated">Если значение None,то передается только имя.</target>
        </trans-unit>
        <trans-unit id="4d1b932d0c6b9763d6c98a7c7a4f7d4c559674b7" translate="yes" xml:space="preserve">
          <source>If value is True, then only the name is emitted.</source>
          <target state="translated">Если значение равно True,то передается только имя.</target>
        </trans-unit>
        <trans-unit id="ba9125247d16d07818ddb28c97b11a7ccc26f154" translate="yes" xml:space="preserve">
          <source>If value is a collection, this will emit --name=value1,value2,value3, unless the flag name is in multi_flags, in which case this will emit --name=value1 --name=value2 --name=value3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4ad20b53a04eec43483216203f6cf47ad97680" translate="yes" xml:space="preserve">
          <source>If value is a collection, this will emit --name=value1,value2,value3.</source>
          <target state="translated">Если значение является коллекцией,то при этом будет выдано --name=значение1,value2,value3.</target>
        </trans-unit>
        <trans-unit id="e94289cc0ab276f55f2d57923859f1b90e55cdac" translate="yes" xml:space="preserve">
          <source>If value is a string then --name=value is emitted.</source>
          <target state="translated">Если значение является строкой,то выдается --name=значение.</target>
        </trans-unit>
        <trans-unit id="20d186d757c8e634482f4b0ae70d6c1979fa6163" translate="yes" xml:space="preserve">
          <source>If value_range does not satisfy value_range[0] &amp;lt; value_range[1].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269bcbd39e8d044a050279a6fd20ff4311dabf60" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;ref&lt;/code&gt; is to be updated more than once, because there are duplicate entries in &lt;code&gt;indices&lt;/code&gt;, the order at which the updates happen for each value is undefined.</source>
          <target state="translated">Если значения в &lt;code&gt;ref&lt;/code&gt; должны обновляться более одного раза, потому что в &lt;code&gt;indices&lt;/code&gt; есть повторяющиеся записи , порядок, в котором происходят обновления для каждого значения, не определен.</target>
        </trans-unit>
        <trans-unit id="d4d6a559f5a98c45e6ddecc38bc713096d867c80" translate="yes" xml:space="preserve">
          <source>If values is not a &lt;code&gt;RaggedTensor&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt;, or row_partition is not a &lt;code&gt;RowPartition&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6316280f4f6f5ca675262d96420bb0b27b62bd" translate="yes" xml:space="preserve">
          <source>If vectorization fails and fallback_to_while_loop is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab9ab3db6068354900613f2c4625d2d8e843adc" translate="yes" xml:space="preserve">
          <source>If vectorization of jacobian computation fails or if first dimension of &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6afc73dd15833cabdb9c1824eeedbffd6886893b" translate="yes" xml:space="preserve">
          <source>If vectorization of jacobian computation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c17ad3469647662115f724bb24589b2f2fe2137" translate="yes" xml:space="preserve">
          <source>If we cannot talk to a TPU worker after retrying or if the number of TPU devices per host is different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2d3ade5eb0388154905624037e8e2403cf867e" translate="yes" xml:space="preserve">
          <source>If we had the following files on our filesystem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb844cd4d2f332924e15531b086460f3069fb1e" translate="yes" xml:space="preserve">
          <source>If we had the following files on our filesystem: - /path/to/dir/a.txt - /path/to/dir/b.py - /path/to/dir/c.py If we pass &quot;/path/to/dir/*.py&quot; as the directory, the dataset would produce: - /path/to/dir/b.py - /path/to/dir/c.py</source>
          <target state="translated">Если бы в нашей файловой системе были следующие файлы:-/path/to/dir/a.txt-/path/to/dir/b.py-/path/to/dir/c.py Если бы в качестве каталога мы передали &quot;/path/to/dir/*.py&quot;,то набор данных выдал бы его:-/path/to/dir/b.py-/path/to/dir/c.py</target>
        </trans-unit>
        <trans-unit id="c56249ff57de445c0d669230b1aed90585bd8f33" translate="yes" xml:space="preserve">
          <source>If we mark the pixels in the input image which are taken for the output with &lt;code&gt;*&lt;/code&gt;, we see the pattern:</source>
          <target state="translated">Если мы помечаем пиксели на входном изображении, которые принимаются для вывода, знаком &lt;code&gt;*&lt;/code&gt; , мы видим шаблон:</target>
        </trans-unit>
        <trans-unit id="1ae663933de0e8928039055bec37a56ddb299b82" translate="yes" xml:space="preserve">
          <source>If we pass &quot;/path/to/dir/*.py&quot; as the directory, the dataset would produce:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e165b6980fcb6841fc0e5a5137adce0275712d9" translate="yes" xml:space="preserve">
          <source>If weight_column is used in &lt;code&gt;feature_columns&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf89ab89e64bfcf039295e9f006b5cf17e441357" translate="yes" xml:space="preserve">
          <source>If with the default behavior you are still seeing errors of the form &quot;Connecting to invalid output X of source node Y which has Z outputs&quot; try setting &lt;a href=&quot;output_all_intermediates&quot;&gt;&lt;code&gt;tf.compat.v1.experimental.output_all_intermediates(True)&lt;/code&gt;&lt;/a&gt; and please file an issue at https://github.com/tensorflow/tensorflow/issues.</source>
          <target state="translated">Если при поведении по умолчанию вы по-прежнему видите ошибки в форме &amp;laquo;Подключение к недопустимому выходу X исходного узла Y, который имеет выходы Z&amp;raquo;, попробуйте установить &lt;a href=&quot;output_all_intermediates&quot;&gt; &lt;code&gt;tf.compat.v1.experimental.output_all_intermediates(True)&lt;/code&gt; &lt;/a&gt; и сообщите о проблеме на https: //github.com/tensorflow/tensorflow/issues.</target>
        </trans-unit>
        <trans-unit id="179651235595979238d6d1b42291336cc1b0116d" translate="yes" xml:space="preserve">
          <source>If writing your own layer, it is recommended to accept tensors only in the first argument. This way, all tensors are casted to the layer's compute dtype. &lt;code&gt;MyLayer&lt;/code&gt; should therefore be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb0682ea4f5a735a707df158e50587d8f0af257" translate="yes" xml:space="preserve">
          <source>If wrong keyword arguments are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34be2be24c5f0073337a7cac4785baf1c58af41e" translate="yes" xml:space="preserve">
          <source>If x is a SparseTensor, returns SparseTensor(x.indices, tf.math.sign(x.values, ...), x.dense_shape).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c552947837446cda68c94afb3c12def67506f5" translate="yes" xml:space="preserve">
          <source>If x is not list, but any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da86ecefe3f269e32bca33996606c1bbf1c5d57" translate="yes" xml:space="preserve">
          <source>If you are creating many models in a loop, this global state will consume an increasing amount of memory over time, and you may want to clear it. Calling &lt;code&gt;clear_session()&lt;/code&gt; releases the global state: this helps avoid clutter from old models and layers, especially when memory is limited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3520c54d6dc04ce1b07ddaf989e991f6131aee9c" translate="yes" xml:space="preserve">
          <source>If you are implementing a ClusterResolver that works in both the Google environment and the open-source world (for instance, a TPU ClusterResolver or similar), you will have to return the appropriate string depending on the environment, which you will have to detect.</source>
          <target state="translated">Если вы реализуете ClusterResolver,который работает как в среде Google,так и в мире с открытым исходным кодом (например,TPU ClusterResolver или аналогичный),вам нужно будет вернуть соответствующую строку в зависимости от среды,которую вы должны будете обнаружить.</target>
        </trans-unit>
        <trans-unit id="811aed6a83297431f65eb3e17b9462a562e7f734" translate="yes" xml:space="preserve">
          <source>If you are not using these and you want to average gradients, you should use &lt;a href=&quot;../../math/reduce_sum&quot;&gt;&lt;code&gt;tf.math.reduce_sum&lt;/code&gt;&lt;/a&gt; to add up your per-example losses and then divide by the global batch size. Note that when using &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;, the first component of a tensor's shape is the &lt;em&gt;replica-local&lt;/em&gt; batch size, which is off by a factor equal to the number of replicas being used to compute a single step. As a result, using &lt;a href=&quot;../../math/reduce_mean&quot;&gt;&lt;code&gt;tf.math.reduce_mean&lt;/code&gt;&lt;/a&gt; will give the wrong answer, resulting in gradients that can be many times too big.</source>
          <target state="translated">Если вы не используете их и хотите усреднить градиенты, вам следует использовать &lt;a href=&quot;../../math/reduce_sum&quot;&gt; &lt;code&gt;tf.math.reduce_sum&lt;/code&gt; ,&lt;/a&gt; чтобы сложить потери для каждого примера, а затем разделить их на глобальный размер пакета. Обратите внимание, что при использовании &lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; первым компонентом формы тензора является размер пакета, &lt;em&gt;локальный для реплики&lt;/em&gt; , который отличается от количества реплик, используемых для вычисления одного шага. В результате использование &lt;a href=&quot;../../math/reduce_mean&quot;&gt; &lt;code&gt;tf.math.reduce_mean&lt;/code&gt; &lt;/a&gt; даст неправильный ответ, в результате чего градиенты могут быть во много раз слишком большими.</target>
        </trans-unit>
        <trans-unit id="59f63bd02d496354bd6dba5b7411d9b6c135d1dc" translate="yes" xml:space="preserve">
          <source>If you are using a tf.estimator.Estimator, this will automatically be called during training.</source>
          <target state="translated">Если Вы используете tf.estimatedator.Estimator,то он будет автоматически вызван во время обучения.</target>
        </trans-unit>
        <trans-unit id="2c2917c6169e51767f3a1cf473ef3869b6db63a6" translate="yes" xml:space="preserve">
          <source>If you are writing a custom training loop, you will need to call a few more methods, &lt;a href=&quot;https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_custom_training_loops&quot;&gt;see the guide&lt;/a&gt;:</source>
          <target state="translated">Если вы пишете собственный цикл обучения, вам нужно будет вызвать еще несколько методов, &lt;a href=&quot;https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_custom_training_loops&quot;&gt;см. Руководство&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a7892158ce0223192ea1db18bc5c647fa4e1ee34" translate="yes" xml:space="preserve">
          <source>If you call the scaffold constructor without any arguments, it will pick pieces from the collections, creating default ones if needed when &lt;code&gt;scaffold.finalize()&lt;/code&gt; is called. You can pass arguments to the constructor to provide your own pieces. Pieces that you pass to the constructor are not added to the graph collections.</source>
          <target state="translated">Если вы вызываете конструктор скаффолда без каких-либо аргументов, он будет выбирать части из коллекций, создавая при необходимости те, которые используются по умолчанию, при вызове &lt;code&gt;scaffold.finalize()&lt;/code&gt; . Вы можете передать аргументы конструктору, чтобы предоставить свои собственные части. Части, которые вы передаете конструктору, не добавляются в коллекции графов.</target>
        </trans-unit>
        <trans-unit id="dc4b64fc1392f71d3b32889d1028fdf4c14a5708" translate="yes" xml:space="preserve">
          <source>If you call this method multiple times during in a test, it will return the same folder. However, across different runs the directories will be different. This will ensure that across different runs tests will not be able to pollute each others environment. If you need multiple unique directories within a single test, you should use tempfile.mkdtemp as follows: tempfile.mkdtemp(dir=self.get_temp_dir()):</source>
          <target state="translated">При многократном вызове этого метода во время теста,он вернет одну и ту же папку.Однако,для разных запусков каталоги будут разными.Это гарантирует,что во время различных запусков тесты не смогут загрязнить среду друг друга.Если вам нужно несколько уникальных каталогов в одном тесте,вы должны использовать tempfile.mkdtemp следующим образом:tempfile.mkdtemp(dir=self.get_temp_dir()):</target>
        </trans-unit>
        <trans-unit id="a3580f3a4d3112463848bcded904b9614c30e36b" translate="yes" xml:space="preserve">
          <source>If you create several savers, you can specify a different filename for the protocol buffer file in the call to &lt;code&gt;save()&lt;/code&gt;.</source>
          <target state="translated">Если вы создаете несколько заставок, вы можете указать другое имя файла для файла буфера протокола в вызове &lt;code&gt;save()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28103958dfc2a16c0c732f42cc7e814e32d142b8" translate="yes" xml:space="preserve">
          <source>If you did not pass &lt;code&gt;dtype=inputs.dtype&lt;/code&gt; to &lt;a href=&quot;../../../random/normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;TypeError&lt;/code&gt; would have occurred. This is because the dtype defaults to &lt;code&gt;&quot;float32&quot;&lt;/code&gt;, so the layer would only work if the inputs were float32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3c655b2c0cd15900dc6ea65570d055839af0e8" translate="yes" xml:space="preserve">
          <source>If you have a single image of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d1cb8a274c0bbb6c61df5f30bfb914148bc1ce" translate="yes" xml:space="preserve">
          <source>If you have a sparse tensor with shape &lt;code&gt;[height, width, depth]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643bb410030ee559023f612081129a136d785967" translate="yes" xml:space="preserve">
          <source>If you have a trained graph containing Variable ops, it can be convenient to convert them all to Const ops holding the same values. This makes it possible to describe the network fully with a single GraphDef file, and allows the removal of a lot of ops related to loading and saving the variables.</source>
          <target state="translated">Если у вас есть тренированный график,содержащий Переменные оп,то удобно конвертировать их все в Const ops с одинаковыми значениями.Это позволяет полностью описать сеть с помощью одного файла GraphDef,а также позволяет удалить большое количество оп,связанных с загрузкой и сохранением переменных.</target>
        </trans-unit>
        <trans-unit id="cbbe35a21e92354b6099726c1f1b63c090066bd0" translate="yes" xml:space="preserve">
          <source>If you have installed TensorFlow with pip, you should be able to launch TensorBoard from the command line:</source>
          <target state="translated">Если вы установили TensorFlow с pip,вы должны быть в состоянии запустить TensorBoard из командной строки:</target>
        </trans-unit>
        <trans-unit id="016085ae26a60bbb61348962a0dfeec05c644fd2" translate="yes" xml:space="preserve">
          <source>If you intend to create your own optimization algorithm, simply inherit from this class and override the following methods:</source>
          <target state="translated">Если вы собираетесь создать свой собственный алгоритм оптимизации,то просто наследуйте от этого класса и переопределите следующие методы:</target>
        </trans-unit>
        <trans-unit id="7a4975dd1a9a628301d8fcc46c4c1c4006240c2f" translate="yes" xml:space="preserve">
          <source>If you need to create a variable with an initial value dependent on another variable, use the other variable's &lt;code&gt;initialized_value()&lt;/code&gt;. This ensures that variables are initialized in the right order.</source>
          <target state="translated">Если вам нужно создать переменную с начальным значением, зависящим от другой переменной, используйте &lt;code&gt;initialized_value()&lt;/code&gt; другой переменной . Это гарантирует, что переменные инициализируются в правильном порядке.</target>
        </trans-unit>
        <trans-unit id="0dc17bf51002e45117b6f345986483c155902a03" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;code&gt;Graph&lt;/code&gt; to the constructor it is added to the event file. (This is equivalent to calling &lt;code&gt;add_graph()&lt;/code&gt; later).</source>
          <target state="translated">Если вы передадите &lt;code&gt;Graph&lt;/code&gt; в конструктор, он будет добавлен в файл события. (Это эквивалентно вызову &lt;code&gt;add_graph()&lt;/code&gt; позже).</target>
        </trans-unit>
        <trans-unit id="3b597fd2dcc48bc48d2628a974c7978b906354cd" translate="yes" xml:space="preserve">
          <source>If you should use &lt;code&gt;_distributed_apply()&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2781f7468959178d029e9786cd7a67e84aa2b60a" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;code&gt;Model&lt;/code&gt;, you can optionally have a &lt;code&gt;training&lt;/code&gt; argument (boolean) in &lt;code&gt;call&lt;/code&gt;, which you can use to specify a different behavior in training and inference:</source>
          <target state="translated">Если вы создаете подкласс &lt;code&gt;Model&lt;/code&gt; , вы можете дополнительно иметь аргумент &lt;code&gt;training&lt;/code&gt; (логическое значение) в &lt;code&gt;call&lt;/code&gt; , который вы можете использовать для указания другого поведения при обучении и выводе:</target>
        </trans-unit>
        <trans-unit id="d5da8bcdbe00cdaa6f02c6698e68c0a2734bda5f" translate="yes" xml:space="preserve">
          <source>If you use infrastructure or other tooling that relies on Estimators, you can still build a Keras model and use model_to_estimator to convert the Keras model to an Estimator for use with downstream systems.</source>
          <target state="translated">Если вы используете инфраструктуру или другие инструменты,которые полагаются на Оценщики,вы все равно можете построить модель Keras и использовать Model_to_estimator для преобразования модели Keras в Оценщик для использования с последующими системами.</target>
        </trans-unit>
        <trans-unit id="14b4c4dfa2247d3068e5eb1177e034e3d1c73d48" translate="yes" xml:space="preserve">
          <source>If you want to avoid copying, you can use the &lt;code&gt;tensor()&lt;/code&gt; function to get a numpy buffer pointing to the input buffer in the tflite interpreter.</source>
          <target state="translated">Если вы хотите избежать копирования, вы можете использовать функцию &lt;code&gt;tensor()&lt;/code&gt; чтобы получить буфер numpy, указывающий на входной буфер в интерпретаторе tflite.</target>
        </trans-unit>
        <trans-unit id="30064acebab6ecca146a1290566e335cd8e88f84" translate="yes" xml:space="preserve">
          <source>If you want to change the shape of a variable later you have to use an &lt;code&gt;assign&lt;/code&gt; Op with &lt;code&gt;validate_shape=False&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите изменить форму переменной позже, вы должны использовать операцию &lt;code&gt;assign&lt;/code&gt; с &lt;code&gt;validate_shape=False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e9d13dc74d0a69d3dde9828649eff4bfd882d5c" translate="yes" xml:space="preserve">
          <source>If you want to obfuscate the hashed output, you can also pass a random &lt;code&gt;salt&lt;/code&gt; argument in the constructor. In that case, the layer will use the &lt;a href=&quot;https://github.com/google/highwayhash&quot;&gt;SipHash64&lt;/a&gt; hash function, with the &lt;code&gt;salt&lt;/code&gt; value serving as additional input to the hash function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62aa5f24c44d925f32d0da5e3403123315297df8" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the Dimension instance corresponding to a certain index in a TensorShape instance, use this utility, like this:</source>
          <target state="translated">Если вы хотите получить экземпляр Dimension,соответствующий определенному индексу в экземпляре TensorShape,используйте данную утилиту:</target>
        </trans-unit>
        <trans-unit id="b8ffbf1a170d32110a5930f1952bac45b4d249c7" translate="yes" xml:space="preserve">
          <source>If you want to retry the training loop in case of preemption you can do it as follows:</source>
          <target state="translated">Если ты хочешь повторить попытку тренировочного цикла,ты можешь сделать это следующим образом:</target>
        </trans-unit>
        <trans-unit id="adc45763eb8027d619cccae315120edbed7cddbd" translate="yes" xml:space="preserve">
          <source>If you wish to avoid the copy, use &lt;code&gt;tensor()&lt;/code&gt;. This function cannot be used to read intermediate results.</source>
          <target state="translated">Если вы хотите избежать копирования, используйте &lt;code&gt;tensor()&lt;/code&gt; . Эту функцию нельзя использовать для чтения промежуточных результатов.</target>
        </trans-unit>
        <trans-unit id="cb43b900ca1b66e6594e59c48bc30ab315af1d0f" translate="yes" xml:space="preserve">
          <source>If your code needs tf.disable_control_flow_v2() to be called to work properly please file a bug.</source>
          <target state="translated">Если ваш код нуждается в вызове tf.disable_control_flow_v2()для корректной работы,пожалуйста,зарегистрируйте ошибку.</target>
        </trans-unit>
        <trans-unit id="bb220fa51853484751849912116a41cad5054655" translate="yes" xml:space="preserve">
          <source>If your code needs tf.disable_resource_variables() to be called to work properly please file a bug.</source>
          <target state="translated">Если ваш код нуждается в вызове tf.disable_resource_variables()для корректной работы,пожалуйста,зарегистрируйте ошибку.</target>
        </trans-unit>
        <trans-unit id="bd9af0a911d43ef76ca8009ab8b340966b03cf39" translate="yes" xml:space="preserve">
          <source>If your directory structure is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5848859753847331f8db1042c28d2504dd35ba7f" translate="yes" xml:space="preserve">
          <source>If, however, the function is not expressible as a TensorFlow op, then use</source>
          <target state="translated">Если,однако,эта функция не может быть использована в качестве опции TensorFlow,тогда используйте</target>
        </trans-unit>
        <trans-unit id="9f96f3d16af9765cccba84d66825f4c203ba2397" translate="yes" xml:space="preserve">
          <source>Igamma</source>
          <target state="translated">Igamma</target>
        </trans-unit>
        <trans-unit id="f50fb74a9b438de96e68b1a585aafd4cb6f6d09e" translate="yes" xml:space="preserve">
          <source>IgammaGradA</source>
          <target state="translated">IgammaGradA</target>
        </trans-unit>
        <trans-unit id="7f4710aed5a69f33a81d3a0ee849c534177e5893" translate="yes" xml:space="preserve">
          <source>Igammac</source>
          <target state="translated">Igammac</target>
        </trans-unit>
        <trans-unit id="ea3708d0408dabca1e98f4d1dfe44e1dff457200" translate="yes" xml:space="preserve">
          <source>IgnoreErrorsDataset</source>
          <target state="translated">IgnoreErrorsDataset</target>
        </trans-unit>
        <trans-unit id="04737b2fc646203f8956213c304c3ff669721355" translate="yes" xml:space="preserve">
          <source>Imag</source>
          <target state="translated">Imag</target>
        </trans-unit>
        <trans-unit id="ad9de5a5ad019656d0e1d16433eb9b2e33cb4c7b" translate="yes" xml:space="preserve">
          <source>Image Adjustments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c42b5ea19e3b21d08dd7b7c8a4d6dfa69396f0bf" translate="yes" xml:space="preserve">
          <source>Image captioning with visual attention</source>
          <target state="translated">Надписи к изображению с визуальным вниманием</target>
        </trans-unit>
        <trans-unit id="c57a791cfe94292451c577369e78dd317dacf038" translate="yes" xml:space="preserve">
          <source>Image classification</source>
          <target state="translated">Классификация изображений</target>
        </trans-unit>
        <trans-unit id="b9dc38b92b74ab56c396229633605467280d3ad3" translate="yes" xml:space="preserve">
          <source>Image data format, can be either &quot;channels_first&quot; or &quot;channels_last&quot;. Defaults to &lt;code&gt;None&lt;/code&gt;, in which case the global setting &lt;a href=&quot;../../backend/image_data_format&quot;&gt;&lt;code&gt;tf.keras.backend.image_data_format()&lt;/code&gt;&lt;/a&gt; is used (unless you changed it, it defaults to &quot;channels_last&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03bc4f1f3dc0b8877ffe7138fa5c01d4b1ed5f6f" translate="yes" xml:space="preserve">
          <source>Image data format, either &quot;channels_first&quot; or &quot;channels_last&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99ccc1e8a027a31ba180fcc93dd7b3a5384bb01" translate="yes" xml:space="preserve">
          <source>Image data format, either &quot;channels_first&quot; or &quot;channels_last&quot;. &quot;channels_last&quot; mode means that the images should have shape &lt;code&gt;(samples, height, width, channels)&lt;/code&gt;, &quot;channels_first&quot; mode means that the images should have shape &lt;code&gt;(samples, channels, height, width)&lt;/code&gt;. It defaults to the &lt;code&gt;image_data_format&lt;/code&gt; value found in your Keras config file at &lt;code&gt;~/.keras/keras.json&lt;/code&gt;. If you never set it, then it will be &quot;channels_last&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd7056b6a4b9fce0b732dbb7496a4870360b85c" translate="yes" xml:space="preserve">
          <source>Image decoding and encoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a69cfa619159e9e923882fbbb472ea75a854f3" translate="yes" xml:space="preserve">
          <source>Image ops work either on individual images or on batches of images, depending on the shape of their input Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b2aca7ed267b133c1905bcbc3ee8c0ced0047e" translate="yes" xml:space="preserve">
          <source>Image ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb3ad26e2fda3cd343bd1dc49196d9e2b80c785" translate="yes" xml:space="preserve">
          <source>Image processing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de38a279dcdcd93610ed628ea92871220d9f71d2" translate="yes" xml:space="preserve">
          <source>Image processing and decoding ops.</source>
          <target state="translated">Обработка и декодирование изображений.</target>
        </trans-unit>
        <trans-unit id="1f104cd249212e0c24d68445f341b223f49368be" translate="yes" xml:space="preserve">
          <source>Image resizing layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7c6b63a88cb374ff63fc7f30662360ee0eafa4" translate="yes" xml:space="preserve">
          <source>Image segmentation</source>
          <target state="translated">Сегментация изображения</target>
        </trans-unit>
        <trans-unit id="549ffedf349ced70c3596d6a5af3e5e9f2f85606" translate="yes" xml:space="preserve">
          <source>Image tensor with shape [batch_size, h, w, d] and type float32 or float64. The image(s) must be 2x2 or larger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1679853a715a13372b9dbba5c8e3dee507c85e51" translate="yes" xml:space="preserve">
          <source>ImageProjectiveTransformV2</source>
          <target state="translated">ImageProjectiveTransformV2</target>
        </trans-unit>
        <trans-unit id="05d0d38956d6d758e651d5df3fe161d5df79ca6f" translate="yes" xml:space="preserve">
          <source>ImageSummary</source>
          <target state="translated">ImageSummary</target>
        </trans-unit>
        <trans-unit id="6b5de061768f5b63882ed2d718f0716548970fc8" translate="yes" xml:space="preserve">
          <source>Images that are represented using floating point values are expected to have values in the range [0,1). Image data stored in integer data types are expected to have values in the range &lt;code&gt;[0,MAX]&lt;/code&gt;, where &lt;code&gt;MAX&lt;/code&gt; is the largest positive representable number for the data type.</source>
          <target state="translated">Ожидается, что изображения, представленные с использованием значений с плавающей запятой, будут иметь значения в диапазоне [0,1). Ожидается, что данные изображения, хранящиеся в целочисленных типах данных, будут иметь значения в диапазоне &lt;code&gt;[0,MAX]&lt;/code&gt; , где &lt;code&gt;MAX&lt;/code&gt; - наибольшее положительное представимое число для данного типа данных.</target>
        </trans-unit>
        <trans-unit id="ccc97dec6d4395a74fe2285c4a5cffe536e82bbb" translate="yes" xml:space="preserve">
          <source>Images to adjust. At least 3-D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfb47d7a3d4989535a89f1c2c00a918608b2b94" translate="yes" xml:space="preserve">
          <source>ImmutableConst</source>
          <target state="translated">ImmutableConst</target>
        </trans-unit>
        <trans-unit id="012973862f6d580b577f1ca55fe2d5d026bfe3a4" translate="yes" xml:space="preserve">
          <source>Implement serialization via &lt;code&gt;get_config()&lt;/code&gt; and &lt;code&gt;from_config()&lt;/code&gt;. Note that the recommended way to create new RNN layers is to write a custom RNN cell and use it with &lt;a href=&quot;rnn&quot;&gt;&lt;code&gt;keras.layers.RNN&lt;/code&gt;&lt;/a&gt;, instead of subclassing &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;keras.layers.Layer&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcae14734b26e859d782e85cd6d711a5ef2255b" translate="yes" xml:space="preserve">
          <source>Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 (default) will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications. Default: 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9a2fe91a457a38eea4454f2e5c0a2dfb6358ae" translate="yes" xml:space="preserve">
          <source>Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d338df7aebbbd96f6ef415f339b2419e491891fb" translate="yes" xml:space="preserve">
          <source>Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications. Default: 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ae76c5a033525b9bebb71fc5faddfefe6500ee" translate="yes" xml:space="preserve">
          <source>Implementation of a ClusterResolver which reads the TF_CONFIG EnvVar.</source>
          <target state="translated">Внедрение ClusterResolver,который читается как TF_CONFIG EnvVar.</target>
        </trans-unit>
        <trans-unit id="d540ae9790266c43ea448cc58760dee1f4459524" translate="yes" xml:space="preserve">
          <source>Implementation of broadcast the &lt;code&gt;tensor&lt;/code&gt; to destinations.</source>
          <target state="translated">Реализация трансляции &lt;code&gt;tensor&lt;/code&gt; по направлениям.</target>
        </trans-unit>
        <trans-unit id="ed2e87a0db4ddf68319e3f3abca999b37869d878" translate="yes" xml:space="preserve">
          <source>Implementation of reduce PerReplica objects in a batch.</source>
          <target state="translated">Реализация сокращения PerReplica объектов в партии.</target>
        </trans-unit>
        <trans-unit id="e8639a6ef1f4702b490c2cdeb6e50d5693132a19" translate="yes" xml:space="preserve">
          <source>Implementation of the Keras API meant to be a high-level API for TensorFlow.</source>
          <target state="translated">Внедрение Keras API должно было стать API высокого уровня для TensorFlow.</target>
        </trans-unit>
        <trans-unit id="89723e13fc88450d8f0a38ed3d90958d12a4e396" translate="yes" xml:space="preserve">
          <source>Implementation of the scikit-learn classifier API for Keras.</source>
          <target state="translated">Внедрение API классификатора &quot;Scikit-learn&quot; для Keras.</target>
        </trans-unit>
        <trans-unit id="7de56b2d26746dd73b9fcddfd1c104e0c913f8f8" translate="yes" xml:space="preserve">
          <source>Implementation of the scikit-learn regressor API for Keras.</source>
          <target state="translated">Реализация API научно-обученного регрессора для Кераса.</target>
        </trans-unit>
        <trans-unit id="08c5c38cccf1eb318b9ecd19fdc9f41a46cfbb1e" translate="yes" xml:space="preserve">
          <source>Implemented using a Queue -- a &lt;code&gt;QueueRunner&lt;/code&gt; for the Queue is added to the current &lt;code&gt;Graph&lt;/code&gt;'s &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; collection.</source>
          <target state="translated">Реализовано с помощью Queue - это &lt;code&gt;QueueRunner&lt;/code&gt; для очереди добавляется к текущей &lt;code&gt;Graph&lt;/code&gt; &amp;laquo;s &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; коллекции.</target>
        </trans-unit>
        <trans-unit id="99ad440c7b2df497d09111d62c37946bec231ffe" translate="yes" xml:space="preserve">
          <source>Implemented with GPU-compatible ops and supports gradients.</source>
          <target state="translated">Реализовано с GPU-совместимыми операционными и поддерживает градиенты.</target>
        </trans-unit>
        <trans-unit id="131bd86e21be57724f2b5e9ee7e658b5ecb52043" translate="yes" xml:space="preserve">
          <source>Implemented with TPU/GPU-compatible ops and supports gradients.</source>
          <target state="translated">Реализовано с TPU/GPU-совместимыми операционными и поддерживает градиенты.</target>
        </trans-unit>
        <trans-unit id="597f3136a6ebd70744437c04d68554ff073fbb6c" translate="yes" xml:space="preserve">
          <source>Implementors of this function must take care in ensuring that the ClusterSpec returned is up-to-date at the time of calling this function. This usually means retrieving the information from the underlying cluster management system every time this function is invoked and reconstructing a cluster_spec, rather than attempting to cache anything.</source>
          <target state="translated">Реализующие эту функцию должны позаботиться о том,чтобы возвращаемый ClusterSpec был обновлен во время вызова этой функции.Обычно это означает получение информации из базовой системы управления кластером каждый раз при вызове этой функции и реконструкцию cluster_spec,а не попытки кэшировать что-либо.</target>
        </trans-unit>
        <trans-unit id="6d2f9e9adc660c2a8db8b19c19593d1554adf0a2" translate="yes" xml:space="preserve">
          <source>Implementors of this function must take care in ensuring that the master returned is up-to-date at the time to calling this function. This usually means retrieving the master every time this function is invoked.</source>
          <target state="translated">Исполнители этой функции должны позаботиться о том,чтобы возвращаемое ведущее устройство было актуальным на момент вызова этой функции.Как правило,это означает,что при каждом вызове этой функции ведущий должен вызывать ее.</target>
        </trans-unit>
        <trans-unit id="f959bfc7a5d94e9325629ea88125d58bf26d97e5" translate="yes" xml:space="preserve">
          <source>Implements categorical feature hashing, also known as &quot;hashing trick&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc7a1efdef9331be59eaffeca4ae1e2cd8a5e8f2" translate="yes" xml:space="preserve">
          <source>Implements generalized Tensor contraction and reduction. Each input Tensor must have a corresponding input subscript appearing in the comma-separated left-hand side of the equation. The right-hand side of the equation consists of the output subscript. The input subscripts and the output subscript should consist of zero or more named axis labels and at most one ellipsis (&lt;code&gt;...&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52c4746cca5aa22e651ddd176b154ea55d83a22" translate="yes" xml:space="preserve">
          <source>Implicit Reparameterization Gradients: &lt;a href=&quot;http://papers.nips.cc/paper/7326-implicit-reparameterization-gradients&quot;&gt;Figurnov et al., 2018&lt;/a&gt; (&lt;a href=&quot;http://papers.nips.cc/paper/7326-implicit-reparameterization-gradients.pdf&quot;&gt;pdf&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34153a7b6c2ed124d924be11081a13d32dadcc7" translate="yes" xml:space="preserve">
          <source>Implicit in the &lt;code&gt;tape.gradient&lt;/code&gt; call is a length-one vector which left-multiplies the Jacobian, a vector-Jacobian product.</source>
          <target state="translated">Неявные в &lt;code&gt;tape.gradient&lt;/code&gt; вызова является длиной один вектор , который левой умножает якобиевы, вектор-Якобиан продукта.</target>
        </trans-unit>
        <trans-unit id="6d5ca9be0a1bd2497683f94ed45157a705abee73" translate="yes" xml:space="preserve">
          <source>Import a GraphDef and convert it to a textual MLIR module.</source>
          <target state="translated">Импорт GraphDef и преобразование в текстовый модуль MLIR.</target>
        </trans-unit>
        <trans-unit id="545c1126ae772bf7a2e6008df556dad256e5b169" translate="yes" xml:space="preserve">
          <source>Import router for absl.flags. See &lt;a href=&quot;https://github.com/abseil/abseil-py&quot;&gt;https://github.com/abseil/abseil-py&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3750f606daadb180526d7ccaf9a3482ec4910c6" translate="yes" xml:space="preserve">
          <source>Import router for absl.flags. See https://github.com/abseil/abseil-py.</source>
          <target state="translated">Импортный маршрутизатор для absl.flags.См.https://github.com/abseil/abseil-py.</target>
        </trans-unit>
        <trans-unit id="d3375d44e4b643dfc4f13312d4430da6429af78a" translate="yes" xml:space="preserve">
          <source>Import router for file_io.</source>
          <target state="translated">Импортируйте маршрутизатор для file_io.</target>
        </trans-unit>
        <trans-unit id="c14a7d57f569579c21ce1fdc7d99c47f7db6b828" translate="yes" xml:space="preserve">
          <source>ImportError if HDF5 &amp;amp; h5py are not installed</source>
          <target state="translated">ImportError, если HDF5 и h5py не установлены</target>
        </trans-unit>
        <trans-unit id="241bfbb99446e43904d0271d5420c06643897761" translate="yes" xml:space="preserve">
          <source>ImportEvent</source>
          <target state="translated">ImportEvent</target>
        </trans-unit>
        <trans-unit id="06cbfad937d0c9edcdf28651087ed18c71fcfcc4" translate="yes" xml:space="preserve">
          <source>Important caveats:</source>
          <target state="translated">Важные предостережения:</target>
        </trans-unit>
        <trans-unit id="d7515a79183f4fea6cdf71780ae3ef25fdf0ea35" translate="yes" xml:space="preserve">
          <source>Important note: This class &lt;em&gt;is not&lt;/em&gt; thread-safe for graph construction. All operations should be created from a single thread, or external synchronization must be provided. Unless otherwise specified, all methods are not thread-safe.</source>
          <target state="translated">Важное примечание: этот класс &lt;em&gt;не является&lt;/em&gt; потокобезопасным для построения графов. Все операции должны быть созданы из одного потока или должна быть обеспечена внешняя синхронизация. Если не указано иное, все методы не являются потокобезопасными.</target>
        </trans-unit>
        <trans-unit id="dee6dd71bc893fc99d70b2da2a20f8ba1b604f3f" translate="yes" xml:space="preserve">
          <source>Important note: This validator checks if flag values are None, and it does not distinguish between default and explicit values. Therefore, this validator does not make sense when applied to flags with default values other than None, including other false values (e.g. False, 0, '', []). That includes multi flags with a default value of [] instead of None.</source>
          <target state="translated">Важное примечание:Этот валидатор проверяет,не является ли значение флага None,и не делает различия между значениями по умолчанию и явными.Поэтому данный валидатор не имеет смысла при применении к флагам со значениями по умолчанию,отличными от None,включая другие ложные значения (например,False,0,'',[]).Это включает в себя несколько флагов со значением по умолчанию []вместо None.</target>
        </trans-unit>
        <trans-unit id="d8c7b39b8707e89a6e9ce5503ad33254f378a175" translate="yes" xml:space="preserve">
          <source>Imports the graph from &lt;code&gt;graph_def&lt;/code&gt; into the current default &lt;code&gt;Graph&lt;/code&gt;. (deprecated arguments)</source>
          <target state="translated">Импортирует график из &lt;code&gt;graph_def&lt;/code&gt; в текущий &lt;code&gt;Graph&lt;/code&gt; умолчанию . (устаревшие аргументы)</target>
        </trans-unit>
        <trans-unit id="fe4ad23456cf41a5fe35769340815f2088fbbdc4" translate="yes" xml:space="preserve">
          <source>In &quot;CONSTANT&quot; mode, the scalar pad value to use. Must be same type as &lt;code&gt;tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73407b35ca652d79b02dd24b5db9d02e3e0e5f03" translate="yes" xml:space="preserve">
          <source>In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:</source>
          <target state="translated">В режиме 'MIN_COMBINED' каждое значение тензора будет проходить следующее:</target>
        </trans-unit>
        <trans-unit id="5dc7fe91c429ae9bf237811621354fd582a8d06b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CentralStorageStrategy&lt;/code&gt; there is a single worker so the value returned will be all the values on that worker.</source>
          <target state="translated">В &lt;code&gt;CentralStorageStrategy&lt;/code&gt; есть один рабочий процесс, поэтому возвращаемое значение будет включать все значения этого рабочего.</target>
        </trans-unit>
        <trans-unit id="f911260e196d9d52bc11c1d245f364fa94ee6a5e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CentralStorageStrategy&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; is called on each of the compute replicas, with the provided &quot;per replica&quot; arguments specific to that device.</source>
          <target state="translated">В &lt;code&gt;CentralStorageStrategy&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; называются на каждом из вычислительных реплик, с представленным &amp;laquo;на реплики&amp;raquo; аргументы , специфичные для данного устройства.</target>
        </trans-unit>
        <trans-unit id="83a783316a9edd78ba1fd02d394a253388645aea" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MultiWorkerMirroredStrategy&lt;/code&gt;, all variables created inside `strategy.scope() will be mirrored on all replicas of each worker. Moreover, it also sets a default device scope so that ops without specified devices will end up on the correct worker.</source>
          <target state="translated">В &lt;code&gt;MultiWorkerMirroredStrategy&lt;/code&gt; все переменные, созданные внутри `strategy.scope (), будут зеркалироваться на всех репликах каждого рабочего. Более того, он также устанавливает область устройства по умолчанию, чтобы операции без указанных устройств выполнялись на правильном рабочем месте.</target>
        </trans-unit>
        <trans-unit id="fc27e94172bcfc6d46e82386176739ca5f0a870a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OneDeviceStrategy&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; is simply called within a device scope for the given device, with the provided arguments.</source>
          <target state="translated">В &lt;code&gt;OneDeviceStrategy&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; называется просто в пределах области устройства для данного устройства, с предусмотренными аргументами.</target>
        </trans-unit>
        <trans-unit id="a37b98485da84e0982814ff7b9a05e1c529e56f1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OneDeviceStrategy&lt;/code&gt;, all variables created inside &lt;code&gt;strategy.scope()&lt;/code&gt; will be on &lt;code&gt;device&lt;/code&gt; specified at strategy construction time. See example in the docs for this class.</source>
          <target state="translated">В &lt;code&gt;OneDeviceStrategy&lt;/code&gt; все переменные, созданные внутри &lt;code&gt;strategy.scope()&lt;/code&gt; будут на &lt;code&gt;device&lt;/code&gt; указанном во время построения стратегии. См. Пример в документации для этого класса.</target>
        </trans-unit>
        <trans-unit id="89dca9293fe8e75256246ee570af4561031fe2c4" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OneDeviceStrategy&lt;/code&gt;, the &lt;code&gt;value&lt;/code&gt; is always expected to be a single value, so the result is just the value in a tuple.</source>
          <target state="translated">В &lt;code&gt;OneDeviceStrategy&lt;/code&gt; , то &lt;code&gt;value&lt;/code&gt; всегда ожидается, будет одно значение, поэтому результат просто значение в кортеже.</target>
        </trans-unit>
        <trans-unit id="5d17dc9c8bbe0f8426ef33525f3803ac13280d23" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OneDeviceStrategy&lt;/code&gt;, there is only one replica, so if axis=None, value is simply returned. If axis is specified as something other than None, such as axis=0, value is reduced along that axis and returned.</source>
          <target state="translated">В &lt;code&gt;OneDeviceStrategy&lt;/code&gt; есть только одна реплика, поэтому, если axis = None, значение просто возвращается. Если для оси указано иное значение, кроме None, например, axis = 0, значение уменьшается вдоль этой оси и возвращается.</target>
        </trans-unit>
        <trans-unit id="64ad04a752452a82392f727330adb50f1b0ef1ed" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;PREDICT&lt;/code&gt; mode, only returns logits and predictions (&lt;code&gt;=tf.sigmoid(logits)&lt;/code&gt;), whereas &lt;code&gt;BinaryClassHead&lt;/code&gt; also returns probabilities, classes, and class_ids.</source>
          <target state="translated">В режиме &lt;code&gt;PREDICT&lt;/code&gt; возвращает только логиты и прогнозы ( &lt;code&gt;=tf.sigmoid(logits)&lt;/code&gt; ), тогда как &lt;code&gt;BinaryClassHead&lt;/code&gt; также возвращает вероятности, классы и class_ids.</target>
        </trans-unit>
        <trans-unit id="f12d35a27cca8e8a6a072f66b7e466bedf447861" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;compact&lt;/code&gt; format the three diagonals are brought together into one tensor of shape &lt;code&gt;[..., 3, M]&lt;/code&gt;, with last two dimensions containing superdiagonals, diagonals, and subdiagonals, in order. Similarly to &lt;code&gt;sequence&lt;/code&gt; format, elements &lt;code&gt;diagonals[..., 0, M-1]&lt;/code&gt; and &lt;code&gt;diagonals[..., 2, 0]&lt;/code&gt; are ignored.</source>
          <target state="translated">В &lt;code&gt;compact&lt;/code&gt; формате три диагонали объединены в один тензор формы &lt;code&gt;[..., 3, M]&lt;/code&gt; , причем последние два измерения содержат супердиагонали, диагонали и субдиагонали по порядку. Аналогично формату &lt;code&gt;sequence&lt;/code&gt; , &lt;code&gt;diagonals[..., 0, M-1]&lt;/code&gt; элементов [..., 0, M-1] и &lt;code&gt;diagonals[..., 2, 0]&lt;/code&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="66cbdb97f05830f246eaf05dcd7ae0826bf8f242" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;matrix&lt;/code&gt; format, &lt;code&gt;diagonals&lt;/code&gt; must be a tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt;, with two inner-most dimensions representing the square tridiagonal matrices. Elements outside of the three diagonals will be ignored.</source>
          <target state="translated">В &lt;code&gt;matrix&lt;/code&gt; формате &lt;code&gt;diagonals&lt;/code&gt; должны быть тензором формы &lt;code&gt;[..., M, M]&lt;/code&gt; с двумя самыми внутренними измерениями, представляющими квадратные трехдиагональные матрицы. Элементы вне трех диагоналей игнорируются.</target>
        </trans-unit>
        <trans-unit id="8148d8cfce5b0dec87e1cdaa0ca93570d75b1c32" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;numpy&lt;/code&gt; transposes are memory-efficient constant time operations as they simply return a new view of the same data with adjusted &lt;code&gt;strides&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;numpy&lt;/code&gt; transposes - это эффективные для памяти операции с постоянным временем, поскольку они просто возвращают новое представление тех же данных с настроенными &lt;code&gt;strides&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02241eae37adc7c28b9d589b3d5cb723cc8b981e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sequence&lt;/code&gt; format, &lt;code&gt;diagonals&lt;/code&gt; are supplied as a tuple or list of three tensors of shapes &lt;code&gt;[..., N]&lt;/code&gt;, &lt;code&gt;[..., M]&lt;/code&gt;, &lt;code&gt;[..., N]&lt;/code&gt; representing superdiagonals, diagonals, and subdiagonals, respectively. &lt;code&gt;N&lt;/code&gt; can be either &lt;code&gt;M-1&lt;/code&gt; or &lt;code&gt;M&lt;/code&gt;; in the latter case, the last element of superdiagonal and the first element of subdiagonal will be ignored.</source>
          <target state="translated">В формате &lt;code&gt;sequence&lt;/code&gt; &lt;code&gt;diagonals&lt;/code&gt; представлены в виде кортежа или списка из трех тензоров форм &lt;code&gt;[..., N]&lt;/code&gt; , &lt;code&gt;[..., M]&lt;/code&gt; , &lt;code&gt;[..., N]&lt;/code&gt; представляющих супердиагонали, диагонали и поддиагонали соответственно. &lt;code&gt;N&lt;/code&gt; может быть &lt;code&gt;M-1&lt;/code&gt; или &lt;code&gt;M&lt;/code&gt; ; в последнем случае будут игнорироваться последний элемент наддиагонали и первый элемент поддиагонали.</target>
        </trans-unit>
        <trans-unit id="5a812208d3ae75e4f5c273197394db05dc66f0f9" translate="yes" xml:space="preserve">
          <source>In Candidate Sampling, this operation facilitates virtually removing sampled classes which happen to match target classes. This is done in Sampled Softmax and Sampled Logistic.</source>
          <target state="translated">В Candidate Sampling эта операция позволяет практически удалить классы выборки,которые случайно совпадают с целевыми классами.Это делается в программах Sampled Softmax и Sampled Logistic.</target>
        </trans-unit>
        <trans-unit id="6d03c984270e6b66cc992ac2d4de0113fb1792f7" translate="yes" xml:space="preserve">
          <source>In Keras models, sometimes variables are created when the model is first called, instead of construction time. Examples include 1) sequential models without input shape pre-defined, or 2) subclassed models. Pass var_list as callable in these cases.</source>
          <target state="translated">В моделях Keras иногда вместо времени построения создаются переменные при первом вызове модели.Примеры включают в себя 1)последовательные модели без предопределенной входной формы или 2)модели с подклассами.В этих случаях передайте var_list как вызываемый.</target>
        </trans-unit>
        <trans-unit id="6d24dc0640eec7767c8580a01fe0f2534a32f8b6" translate="yes" xml:space="preserve">
          <source>In Python, this scatter add operation would look like this:</source>
          <target state="translated">На Пайтоне эта операция добавления рассеяния выглядела бы так:</target>
        </trans-unit>
        <trans-unit id="17844ec0dbf5e24da91f6ffe78f9342efe5f4f37" translate="yes" xml:space="preserve">
          <source>In Python, this scatter operation would look like this:</source>
          <target state="translated">На Пайтоне эта операция по рассеиванию выглядела бы так:</target>
        </trans-unit>
        <trans-unit id="81965bf71c83e468654101016f87a74649d16e39" translate="yes" xml:space="preserve">
          <source>In Python, this scatter subtract operation would look like this:</source>
          <target state="translated">На Пайтоне эта операция вычитания рассеяния выглядела бы так:</target>
        </trans-unit>
        <trans-unit id="3d8782d76c3f4b01f4fdcf84d62e403122ad04f2" translate="yes" xml:space="preserve">
          <source>In TF 2.0, &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; objects are Python iterables which makes it possible to also create epochs through Python iteration:</source>
          <target state="translated">В TF 2.0 объекты &lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; являются итерациями Python, что позволяет также создавать эпохи с помощью итерации Python:</target>
        </trans-unit>
        <trans-unit id="ceb7ca0c46558f03e6086af25fef434bd7045721" translate="yes" xml:space="preserve">
          <source>In TF 2.0, &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; objects are Python iterables which makes it possible to also create epochs through Python iteration:</source>
          <target state="translated">В TF 2.0 объекты &lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; являются итерациями Python, что позволяет также создавать эпохи с помощью итерации Python:</target>
        </trans-unit>
        <trans-unit id="9b30346591377f8c72aca3c84be793a8ed9d8c0f" translate="yes" xml:space="preserve">
          <source>In TF 2.0, &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; objects are Python iterables which makes it possible to also create epochs through Python iteration:</source>
          <target state="translated">В TF 2.0 объекты &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; являются итерациями Python, что позволяет также создавать эпохи с помощью итерации Python:</target>
        </trans-unit>
        <trans-unit id="48e9b024a95539e5d2ffaf50c0d7d26e7f011943" translate="yes" xml:space="preserve">
          <source>In TF 2.0, &lt;a href=&quot;dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; objects are Python iterables which makes it possible to also create epochs through Python iteration:</source>
          <target state="translated">В TF 2.0 объекты &lt;a href=&quot;dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; являются итерациями Python, что позволяет также создавать эпохи с помощью итерации Python:</target>
        </trans-unit>
        <trans-unit id="8fdae45e06a3d82dc5e8823e248b14458447ba71" translate="yes" xml:space="preserve">
          <source>In TensorFlow 1, only the &quot;infer&quot; policy is available.</source>
          <target state="translated">В TensorFlow 1 доступна только политика &quot;infer&quot;.</target>
        </trans-unit>
        <trans-unit id="5252a64a0f9e26ac451b24dc3a78078e2d45a06e" translate="yes" xml:space="preserve">
          <source>In TensorFlow 2.0, iterating over a TensorShape instance returns values.</source>
          <target state="translated">В TensorFlow 2.0 итерация по экземпляру TensorShape возвращает значения.</target>
        </trans-unit>
        <trans-unit id="4632390b454bb4fddbcccffafb20fab0ac9e532b" translate="yes" xml:space="preserve">
          <source>In TensorFlow 2.0, representing tensors as protos should no longer be a common workflow. That said, this utility function is still useful for generating TF Serving request protos:</source>
          <target state="translated">В TensorFlow 2.0 представление тензоров в качестве прототипов больше не должно быть обычным рабочим процессом.Тем не менее,эта утилита по-прежнему полезна для генерации протосов запросов на обслуживание TF:</target>
        </trans-unit>
        <trans-unit id="4d52755e5ee76e2c362b3006fe73af38e7a988b4" translate="yes" xml:space="preserve">
          <source>In TensorFlow distributed environment, each job may have an applicable task id, which is the index of the instance within its task type. This is useful when user needs to run specific code according to task index. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c85eb2376f8951b058a131e7a9b908f6bdef73c" translate="yes" xml:space="preserve">
          <source>In TensorFlow distributed environment, each job may have an applicable task type. Valid task types in TensorFlow include 'chief': a worker that is designated with more responsibility, 'worker': a regular worker for training/evaluation, 'ps': a parameter server, or 'evaluator': an evaluator that evaluates the checkpoints for metrics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1127e50fd25c3f8e9dda641959bbb9354598c6f4" translate="yes" xml:space="preserve">
          <source>In TensorFlow, &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s are a common way to define graph execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8db8f91b921bd7ce4f80fb0d9da7d36b0960f78" translate="yes" xml:space="preserve">
          <source>In V1, the exported CPU graph is &lt;code&gt;model_fn&lt;/code&gt; as it is. The exported TPU graph wraps &lt;code&gt;tpu.rewrite()&lt;/code&gt; and &lt;code&gt;TPUPartitionedCallOp&lt;/code&gt; around &lt;code&gt;model_fn&lt;/code&gt; so &lt;code&gt;model_fn&lt;/code&gt; is on TPU by default. To place ops on CPU, &lt;code&gt;tpu.outside_compilation(host_call, logits)&lt;/code&gt; can be used.</source>
          <target state="translated">В V1 экспортируемый график ЦП - это &lt;code&gt;model_fn&lt;/code&gt; как есть. Экспортированный график TPU обертывает &lt;code&gt;tpu.rewrite()&lt;/code&gt; и &lt;code&gt;TPUPartitionedCallOp&lt;/code&gt; вокруг &lt;code&gt;model_fn&lt;/code&gt; , поэтому &lt;code&gt;model_fn&lt;/code&gt; по умолчанию находится в TPU. Чтобы разместить &lt;code&gt;tpu.outside_compilation(host_call, logits)&lt;/code&gt; на ЦП, можно использовать tpu.outside_compilation (host_call, logits) .</target>
        </trans-unit>
        <trans-unit id="96357d45f74c44c1cd59ce5a4e69f6c961b9be20" translate="yes" xml:space="preserve">
          <source>In V2, &lt;code&gt;export_saved_model()&lt;/code&gt; sets up &lt;code&gt;params['use_tpu']&lt;/code&gt; flag to let the user know if the code is exporting to TPU (or not). When &lt;code&gt;params['use_tpu']&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, users need to call &lt;code&gt;tpu.rewrite()&lt;/code&gt;, &lt;code&gt;TPUPartitionedCallOp&lt;/code&gt; and/or &lt;code&gt;batch_function()&lt;/code&gt;. Alternatively use &lt;code&gt;inference_on_tpu()&lt;/code&gt; which is a convenience wrapper of the three.</source>
          <target state="translated">В версии 2 &lt;code&gt;export_saved_model()&lt;/code&gt; устанавливает флаг &lt;code&gt;params['use_tpu']&lt;/code&gt; чтобы пользователь знал, экспортируется ли код в TPU (или нет). Когда &lt;code&gt;params['use_tpu']&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , пользователям необходимо вызвать &lt;code&gt;tpu.rewrite()&lt;/code&gt; , &lt;code&gt;TPUPartitionedCallOp&lt;/code&gt; и / или &lt;code&gt;batch_function()&lt;/code&gt; . В качестве альтернативы используйте &lt;code&gt;inference_on_tpu()&lt;/code&gt; который является удобной оболочкой из трех.</target>
        </trans-unit>
        <trans-unit id="0ea5307e4ab9dbcd3254304c2d948acdc37b34b0" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or when building a model using &lt;a href=&quot;keras/input&quot;&gt;&lt;code&gt;tf.keras.Input&lt;/code&gt;&lt;/a&gt;, they return the build-time shape of the tensor, which may be partially unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa5bd380e5aa574a254ecdd687c73cfcb27bf28" translate="yes" xml:space="preserve">
          <source>In a multi-worker setting, we will first attempt to distribute the dataset by attempting to detect whether the dataset is being created out of ReaderDatasets (e.g. TFRecordDataset, TextLineDataset, etc.) and if so, attempting to shard the input files. Note that there has to be at least one input file per worker. If you have less than one input file per worker, we suggest that you should disable distributing your dataset using the method below.</source>
          <target state="translated">В многопользовательской настройке мы сначала попытаемся распределить набор данных,пытаясь определить,создается ли этот набор данных из ReaderDatasets (например,TFRecordDataset,TextLineDataset и т.д.),и если да,то попытаемся разбить входные файлы на куски.Обратите внимание,что на каждого работника должен быть как минимум один входной файл.Если у вас меньше одного входного файла на одного рабочего,мы предлагаем вам отключить распространение набора данных с помощью метода,описанного ниже.</target>
        </trans-unit>
        <trans-unit id="dfef8f2d9cb8b91e7e364f089f14bf6f6b4950f4" translate="yes" xml:space="preserve">
          <source>In a pure mathematical sense, a vector-argument vector-valued function &lt;code&gt;f&lt;/code&gt;'s derivatives should be its Jacobian matrix &lt;code&gt;J&lt;/code&gt;. Here we are expressing the Jacobian &lt;code&gt;J&lt;/code&gt; as a function &lt;code&gt;grad_fn&lt;/code&gt; which defines how &lt;code&gt;J&lt;/code&gt; will transform a vector &lt;code&gt;grad_ys&lt;/code&gt; when left-multiplied with it (&lt;code&gt;grad_ys * J&lt;/code&gt;, the vector-Jacobian product, or VJP). This functional representation of a matrix is convenient to use for chain-rule calculation (in e.g. the back-propagation algorithm).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1189c10d2b5b4c2dfe6ce8f122a5b82d16ddb6" translate="yes" xml:space="preserve">
          <source>In a replica context, you may freely read the values of variables, but you may only update their value if they specify a way to aggregate the update using the &lt;code&gt;aggregation&lt;/code&gt; parameter in the variable's constructor. In a cross-replica context, you may read or write variables (writes may need to be broadcast to all copies of the variable if it is mirrored).</source>
          <target state="translated">В контексте реплики вы можете свободно читать значения переменных, но вы можете обновлять их значения только в том случае, если они указывают способ агрегирования обновления с использованием параметра &lt;code&gt;aggregation&lt;/code&gt; в конструкторе переменной. В контексте кросс-реплик вы можете читать или записывать переменные (запись может потребоваться широковещательно для всех копий переменной, если она является зеркальной).</target>
        </trans-unit>
        <trans-unit id="5a6a3b1bf3355979185c8ba5fde475cd00334849" translate="yes" xml:space="preserve">
          <source>In a session, computes and returns the value of this variable.</source>
          <target state="translated">В сеансе вычисляет и возвращает значение этой переменной.</target>
        </trans-unit>
        <trans-unit id="2522a9b6956696f7d2f65c27000e4d85acba5fa9" translate="yes" xml:space="preserve">
          <source>In a typical asynchronous training environment, it's common to have some stale gradients. For example, with a N-replica asynchronous training, gradients will be applied to the variables N times independently. Depending on each replica's training speed, some gradients might be calculated from copies of the variable from several steps back (N-1 steps on average). This optimizer avoids stale gradients by collecting gradients from all replicas, averaging them, then applying them to the variables in one shot, after which replicas can fetch the new variables and continue.</source>
          <target state="translated">В типичной асинхронной тренировочной среде обычным делом является наличие застоявшихся градиентов.Например,при асинхронном обучении N-реплики градиенты будут применяться к переменным N времен независимо друг от друга.В зависимости от скорости обучения каждой реплики,некоторые градиенты могут быть рассчитаны по копиям переменной с нескольких шагов назад (в среднем N-1 шагов).Этот оптимизатор позволяет избежать застоявшиеся градиенты,собирая градиенты от всех реплик,усредняя их,а затем применять их к переменным в один выстрел,после чего реплики могут получить новые переменные и продолжить.</target>
        </trans-unit>
        <trans-unit id="add8c5b79597d8fbfc4deddcbbc75442d1193218" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;row_splits&lt;/code&gt;, ragged tensors provide support for five other row-partitioning schemes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5c7e39ca1e2646f184bebbdccd8352fd472889" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;row_splits&lt;/code&gt;, ragged tensors provide support for four other row-partitioning schemes:</source>
          <target state="translated">Помимо &lt;code&gt;row_splits&lt;/code&gt; , рваные тензоры обеспечивают поддержку четырех других схем разбиения строк:</target>
        </trans-unit>
        <trans-unit id="c4c6856a33d33c73a855c3ce15ea6283e7abc71a" translate="yes" xml:space="preserve">
          <source>In addition to checkpoint files, savers keep a protocol buffer on disk with the list of recent checkpoints. This is used to manage numbered checkpoint files and by &lt;code&gt;latest_checkpoint()&lt;/code&gt;, which makes it easy to discover the path to the most recent checkpoint. That protocol buffer is stored in a file named 'checkpoint' next to the checkpoint files.</source>
          <target state="translated">Помимо файлов контрольных точек, хранители хранят на диске буфер протокола со списком недавних контрольных точек. Это используется для управления пронумерованными файлами контрольных точек и с помощью &lt;code&gt;latest_checkpoint()&lt;/code&gt; , что упрощает обнаружение пути к самой последней контрольной точке. Этот буфер протокола хранится в файле с именем &amp;laquo;контрольная точка&amp;raquo; рядом с файлами контрольных точек.</target>
        </trans-unit>
        <trans-unit id="440848afff541ac2b1bbb1684820f47d256a8eae" translate="yes" xml:space="preserve">
          <source>In addition to exporting, this class also garbage collects stale exports.</source>
          <target state="translated">Помимо экспорта,этот класс мусора также собирает просроченный экспорт.</target>
        </trans-unit>
        <trans-unit id="3ba65f5de5f4ca5afe2d4c86c2ddac7a22edaf68" translate="yes" xml:space="preserve">
          <source>In addition to regular Tensors or IndexedSlices, the body may accept and return TensorArray objects. The flows of the TensorArray objects will be appropriately forwarded between loops and during gradient calculations.</source>
          <target state="translated">В дополнение к обычным Tensors или IndexedSlices,тело может принимать и возвращать объекты TensorArray.Потоки объектов TensorArray будут соответствующим образом перенаправлены между петлями и во время градиентных вычислений.</target>
        </trans-unit>
        <trans-unit id="b83ef61c3670f06537ff1c141b52be7ac2a9fe87" translate="yes" xml:space="preserve">
          <source>In addition to slot variables which should be colocated with their primary variables, optimizers also define non-slot variables. These can be things like &quot;number of step updates performed&quot; or &quot;beta1^t&quot; and &quot;beta2^t&quot;. Each strategy has some policy for which devices those variables should be copied too, called the &quot;non-slot devices&quot; (some subset of the parameter devices). We require that all non-slot variables are allocated on the same device, or mirrored across the same set of devices. You can use &lt;a href=&quot;../../../distribute/strategyextended#non_slot_devices&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.non_slot_devices&lt;/code&gt;&lt;/a&gt; to pick a consistent set of devices to pass to both &lt;a href=&quot;../../../distribute/strategyextended#colocate_vars_with&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.colocate_vars_with&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../distribute/strategyextended#update_non_slot&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.update_non_slot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В дополнение к переменным слота, которые должны быть размещены вместе с их первичными переменными, оптимизаторы также определяют переменные без слота. Это могут быть такие вещи, как &amp;laquo;количество выполненных обновлений шага&amp;raquo; или &amp;laquo;beta1 ^ t&amp;raquo; и &amp;laquo;beta2 ^ t&amp;raquo;. Каждая стратегия имеет некоторую политику, для каких устройств эти переменные также должны копироваться, называемые &amp;laquo;неслотовыми устройствами&amp;raquo; (некоторое подмножество параметрических устройств). Мы требуем, чтобы все переменные, не являющиеся слотами, размещались на одном устройстве или отображались на одном и том же наборе устройств. Вы можете использовать &lt;a href=&quot;../../../distribute/strategyextended#non_slot_devices&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.non_slot_devices&lt;/code&gt; ,&lt;/a&gt; чтобы выбрать согласованный набор устройств для передачи как &lt;a href=&quot;../../../distribute/strategyextended#colocate_vars_with&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.colocate_vars_with&lt;/code&gt; ,так&lt;/a&gt; и &lt;a href=&quot;../../../distribute/strategyextended#update_non_slot&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.update_non_slot&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72581f64b9b0dd39e47dc7fa9df7182573016778" translate="yes" xml:space="preserve">
          <source>In addition to slot variables which should be colocated with their primary variables, optimizers also define non-slot variables. These can be things like &quot;number of step updates performed&quot; or &quot;beta1^t&quot; and &quot;beta2^t&quot;. Each strategy has some policy for which devices those variables should be copied too, called the &quot;non-slot devices&quot; (some subset of the parameter devices). We require that all non-slot variables are allocated on the same device, or mirrored across the same set of devices. You can use &lt;a href=&quot;strategyextended#non_slot_devices&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.non_slot_devices&lt;/code&gt;&lt;/a&gt; to pick a consistent set of devices to pass to both &lt;a href=&quot;strategyextended#colocate_vars_with&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.colocate_vars_with&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;strategyextended#update_non_slot&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.update_non_slot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В дополнение к переменным слота, которые должны быть размещены вместе с их первичными переменными, оптимизаторы также определяют переменные без слота. Это могут быть такие вещи, как &amp;laquo;количество выполненных обновлений шага&amp;raquo; или &amp;laquo;beta1 ^ t&amp;raquo; и &amp;laquo;beta2 ^ t&amp;raquo;. Каждая стратегия имеет некоторую политику, для каких устройств эти переменные также должны копироваться, называемые &amp;laquo;неслотовыми устройствами&amp;raquo; (некоторое подмножество параметрических устройств). Мы требуем, чтобы все переменные, не являющиеся слотами, размещались на одном устройстве или отображались на одном и том же наборе устройств. Вы можете использовать &lt;a href=&quot;strategyextended#non_slot_devices&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.non_slot_devices&lt;/code&gt; ,&lt;/a&gt; чтобы выбрать согласованный набор устройств для передачи как &lt;a href=&quot;strategyextended#colocate_vars_with&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.colocate_vars_with&lt;/code&gt; ,так&lt;/a&gt; и &lt;a href=&quot;strategyextended#update_non_slot&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.update_non_slot&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d87268b6a8ad6822e1a801c24a40186835816c0b" translate="yes" xml:space="preserve">
          <source>In addition to the above mentioned policies, a policy can also be &quot;infer&quot;. This Policy is deprecated, and it is not recommended. When a layer has an infer policy, it will infer the computation and variable dtype from the first input the first time the layer is called. Once the layer is called for the first time, the layer's policy will change to the dtype of the first input.</source>
          <target state="translated">В дополнение к вышеупомянутой политике,политика может также быть &quot;выводом&quot;.Эта политика является устаревшей и не рекомендуется.Когда уровень имеет политику &quot;инфер&quot;,она будет выводить вычисления и тип переменной d из первого входного сигнала при первом вызове уровня.После первого вызова слоя политика слоя изменится на тип d на первом входе.</target>
        </trans-unit>
        <trans-unit id="9b6a36c1b72da17b3ac1903013012d88a399c6a3" translate="yes" xml:space="preserve">
          <source>In addition, either &lt;code&gt;save_checkpoints_steps&lt;/code&gt; or &lt;code&gt;save_checkpoints_secs&lt;/code&gt; can be set (should not be both).</source>
          <target state="translated">Кроме того, можно &lt;code&gt;save_checkpoints_steps&lt;/code&gt; либо save_checkpoints_steps, либо &lt;code&gt;save_checkpoints_secs&lt;/code&gt; (не должно быть одновременно).</target>
        </trans-unit>
        <trans-unit id="a8be97737386632e5930d1a505669c0ea1a77181" translate="yes" xml:space="preserve">
          <source>In addition, non-raising iteration is supported via &lt;code&gt;get_next_as_optional()&lt;/code&gt;, which returns the next element (if available) wrapped in a &lt;a href=&quot;../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555925888abcb6ab1ea3af1dd5cd6edbb9ea4874" translate="yes" xml:space="preserve">
          <source>In addition, this operation returns tensors &lt;code&gt;true_expected_count&lt;/code&gt; and &lt;code&gt;sampled_expected_count&lt;/code&gt; representing the number of times each of the target classes (&lt;code&gt;true_classes&lt;/code&gt;) and the sampled classes (&lt;code&gt;sampled_candidates&lt;/code&gt;) is expected to occur in an average tensor of sampled classes. These values correspond to &lt;code&gt;Q(y|x)&lt;/code&gt; defined in &lt;a href=&quot;http://www.tensorflow.org/extras/candidate_sampling.pdf&quot;&gt;this document&lt;/a&gt;. If &lt;code&gt;unique=True&lt;/code&gt;, then these are post-rejection probabilities and we compute them approximately.</source>
          <target state="translated">Кроме того, эта операция возвращает тензоры &lt;code&gt;true_expected_count&lt;/code&gt; и &lt;code&gt;sampled_expected_count&lt;/code&gt; , представляющие, сколько раз каждый из целевых классов ( &lt;code&gt;true_classes&lt;/code&gt; ) и выбранных классов ( &lt;code&gt;sampled_candidates&lt;/code&gt; ), как ожидается, будет встречаться в среднем тензоре выбранных классов. Эти значения соответствуют &lt;code&gt;Q(y|x)&lt;/code&gt; определенному в &lt;a href=&quot;http://www.tensorflow.org/extras/candidate_sampling.pdf&quot;&gt;этом документе&lt;/a&gt; . Если &lt;code&gt;unique=True&lt;/code&gt; , то это вероятности после отклонения, и мы их приблизительно вычисляем.</target>
        </trans-unit>
        <trans-unit id="7dcd7b097b6d5afefa90c28e9166ddea07927f7a" translate="yes" xml:space="preserve">
          <source>In all cases, an exception is raised if &lt;em&gt;invalid&lt;/em&gt; parameters are passed, e.g.</source>
          <target state="translated">Во всех случаях возникает исключение, если переданы &lt;em&gt;недопустимые&lt;/em&gt; параметры, например</target>
        </trans-unit>
        <trans-unit id="528f7eb98213e1189f2afa9ee728c00ddb010d6a" translate="yes" xml:space="preserve">
          <source>In all cases, suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt; of shape &lt;code&gt;[M, N]&lt;/code&gt;, and &lt;code&gt;x.shape = [N, R]&lt;/code&gt;. Then</source>
          <target state="translated">Во всех случаях предположим, что &lt;code&gt;operator&lt;/code&gt; - это &lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt; формы &lt;code&gt;[M, N]&lt;/code&gt; и &lt;code&gt;x.shape = [N, R]&lt;/code&gt; . затем</target>
        </trans-unit>
        <trans-unit id="93b282de1b601498957a67e9a5151ecf41c723ca" translate="yes" xml:space="preserve">
          <source>In all generality, they can have the same number of dimensions as the input &lt;code&gt;x&lt;/code&gt;, with identical sizes as &lt;code&gt;x&lt;/code&gt; for the dimensions that are not normalized over (the 'depth' dimension(s)), and dimension 1 for the others which are being normalized over. &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;variance&lt;/code&gt; in this case would typically be the outputs of &lt;a href=&quot;moments&quot;&gt;&lt;code&gt;tf.nn.moments(..., keepdims=True)&lt;/code&gt;&lt;/a&gt; during training, or running averages thereof during inference.</source>
          <target state="translated">В общем, они могут иметь то же количество измерений, что и входной &lt;code&gt;x&lt;/code&gt; , с такими же размерами, как &lt;code&gt;x&lt;/code&gt; , для измерений, которые не нормализованы по (размер (а) `` глубины ''), и размер 1 для других, которые нормализовано более. &lt;code&gt;mean&lt;/code&gt; и &lt;code&gt;variance&lt;/code&gt; в этом случае обычно будут выходными &lt;a href=&quot;moments&quot;&gt; &lt;code&gt;tf.nn.moments(..., keepdims=True)&lt;/code&gt; &lt;/a&gt; во время обучения или их средними значениями во время логического вывода.</target>
        </trans-unit>
        <trans-unit id="af9bb28b05876d0ccb840fb8a94305e3cb54b9b8" translate="yes" xml:space="preserve">
          <source>In async execution mode, an error in op/function execution can lead to errors in subsequent ops/functions that are scheduled but not yet executed. Calling this method clears all pending operations and reset the async execution state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe8f97776752806df6355aaaa49e006af4475b5" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;dim(x) == 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59ff15195ac0b7ba502c82f75c359a3a89caeb8" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;x&lt;/code&gt; is not a symbolic tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="956b77064ba946148cb66db1a94e9bc12bc62027" translate="yes" xml:space="preserve">
          <source>In case a simplified &lt;code&gt;str&lt;/code&gt; version of the path is needed from an &lt;code&gt;os.PathLike&lt;/code&gt; object</source>
          <target state="translated">Если требуется упрощенная версия пути &lt;code&gt;str&lt;/code&gt; от объекта &lt;code&gt;os.PathLike&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30551f2608204c57e8337c88a4d6f97d73d92a19" translate="yes" xml:space="preserve">
          <source>In case any gradient cannot be computed (e.g. if gradient function not implemented).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1942b63ea63dd70e10beed0fe1ee42f2a0cdf472" translate="yes" xml:space="preserve">
          <source>In case of an invalid savefile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df42ea719e7879084ed8921f411b4a23cb710e77" translate="yes" xml:space="preserve">
          <source>In case of an invalid value for the &quot;scale&quot;, mode&quot; or &quot;distribution&quot; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49bc9a2673c96fd0fd0baf753f07cc548462df41" translate="yes" xml:space="preserve">
          <source>In case of identity returns the smallest index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a756fd05962bc6c4d94331c5d62934a1832aad" translate="yes" xml:space="preserve">
          <source>In case of invalid &lt;code&gt;count_mode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e5909e8575c0cbcfc7db58a53aa66c85848f81" translate="yes" xml:space="preserve">
          <source>In case of invalid &lt;code&gt;data_format&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1717d00a3a0045ddd9f92c5cc529a4e7c9f003" translate="yes" xml:space="preserve">
          <source>In case of invalid &lt;code&gt;merge_mode&lt;/code&gt; argument.</source>
          <target state="translated">В случае неверного аргумента &lt;code&gt;merge_mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97f5045ff946d97ba4c9acb1689a743a28154c87" translate="yes" xml:space="preserve">
          <source>In case of invalid argument for &lt;code&gt;weights&lt;/code&gt;, or invalid input shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb8a53372e8c458d83ef7d391910d625cbd8153" translate="yes" xml:space="preserve">
          <source>In case of invalid arguments for &lt;code&gt;optimizer&lt;/code&gt;, &lt;code&gt;loss&lt;/code&gt; or &lt;code&gt;metrics&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e673c8fb2afe88153bb056ca340c78ed246af7" translate="yes" xml:space="preserve">
          <source>In case of invalid layer name or index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21767b805d2046804a0b0734c4781738bfc5c332" translate="yes" xml:space="preserve">
          <source>In case of invalid shape for &lt;code&gt;y&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b74392dc8d34a728d3b0ec6714f69356073b4cb" translate="yes" xml:space="preserve">
          <source>In case of invalid shape of the &lt;code&gt;pred&lt;/code&gt; array (must be 2D).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298ea3c5b9bb5ef3bfdac85152badfbfd0186005" translate="yes" xml:space="preserve">
          <source>In case of invalid user-provided arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be920aa09b321446df6b0f1334f4492100d28e32" translate="yes" xml:space="preserve">
          <source>In case of invalid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d6f8d31911fd565c48ceb279f3955fdb2afb4f" translate="yes" xml:space="preserve">
          <source>In case of invalid values for &lt;code&gt;truncating&lt;/code&gt; or &lt;code&gt;padding&lt;/code&gt;, or in case of invalid shape for a &lt;code&gt;sequences&lt;/code&gt; entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7366cef910f45bfb2939d4d4c5cf6cd689029dd" translate="yes" xml:space="preserve">
          <source>In case of mismatch between given number of inputs and expectations of the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a356d199013f3b93a8b76ba4e11b70567e3a0225" translate="yes" xml:space="preserve">
          <source>In case of mismatch between the provided input data and the model's expectations, or in case a stateful model receives a number of samples that is not a multiple of the batch size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88899ad29ae66b9d00b954a2811e29531475819a" translate="yes" xml:space="preserve">
          <source>In case of mismatch between the provided input data and what the model expects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec3c64c6374329c52184178b1fd4857d4d1aac9" translate="yes" xml:space="preserve">
          <source>In case of tie, the rounding mode used is &quot;half to even&quot;.</source>
          <target state="translated">В случае галстука используется режим округления &quot;от половины до четности&quot;.</target>
        </trans-unit>
        <trans-unit id="05c8a481504fdcb81f5439304e5ef2205ea5569c" translate="yes" xml:space="preserve">
          <source>In case of unknown &lt;code&gt;data_format&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab787931384443fb17693b20f0b8c8362027dccc" translate="yes" xml:space="preserve">
          <source>In case of unknown &lt;code&gt;mode&lt;/code&gt; or &lt;code&gt;data_format&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d126fd29a8ae675359d884c4be757cfd379d70f9" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;layer&lt;/code&gt; argument does not know its input shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e569e98d391d8a27e0d7375479c95eedc6a211e" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;layer&lt;/code&gt; argument has multiple output tensors, or is already connected somewhere else (forbidden in &lt;code&gt;Sequential&lt;/code&gt; models).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5137fc820e731c1a5875992af949685dd9a61a" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;export_meta_graph()&lt;/code&gt;, this function can be used to</source>
          <target state="translated">В сочетании с &lt;code&gt;export_meta_graph()&lt;/code&gt; эту функцию можно использовать для</target>
        </trans-unit>
        <trans-unit id="6bee6cf2cd5a89443d441a5ec667007c0d0d0875" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;Adam&lt;/code&gt;, the sparse implementation of this algorithm (used when the gradient is an IndexedSlices object, typically because of &lt;a href=&quot;../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) only updates variable slices and corresponding &lt;code&gt;m_t&lt;/code&gt;, &lt;code&gt;v_t&lt;/code&gt; terms when that part of the variable was used in the forward pass. This means that the sparse behavior is contrast to the dense behavior (similar to some momentum implementations which ignore momentum unless a variable slice was actually used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472a2f767cd2905e561f41c34043559b02af126d" translate="yes" xml:space="preserve">
          <source>In contrast to the &lt;code&gt;mean&lt;/code&gt; function which returns a scalar with the mean, this function returns an average tensor with the same shape as the input tensors.</source>
          <target state="translated">В отличие от функции &lt;code&gt;mean&lt;/code&gt; которая возвращает скаляр со средним значением, эта функция возвращает тензор среднего значения той же формы, что и входные тензоры.</target>
        </trans-unit>
        <trans-unit id="be45b63e4fad80b73ce37784737cf2cbbeaea97c" translate="yes" xml:space="preserve">
          <source>In contrast, if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911ecdd444d109bdd2686fa0899f4e17288b1949" translate="yes" xml:space="preserve">
          <source>In detail, the grayscale morphological 2-D dilation is the max-sum correlation (for consistency with &lt;code&gt;conv2d&lt;/code&gt;, we use unmirrored filters):</source>
          <target state="translated">В деталях, морфологическое двумерное расширение оттенков серого - это корреляция максимальной суммы (для согласованности с &lt;code&gt;conv2d&lt;/code&gt; мы используем фильтры без зеркального отражения ):</target>
        </trans-unit>
        <trans-unit id="010b81280676156048e3aae3d209bcf71a9b3066" translate="yes" xml:space="preserve">
          <source>In detail, the grayscale morphological 2-D erosion is given by:</source>
          <target state="translated">Подробнее морфологическая 2-D серая эрозия представлена:</target>
        </trans-unit>
        <trans-unit id="517b8d5a149f4c161ca1ea27c45c37a98c18260e" translate="yes" xml:space="preserve">
          <source>In detail, with the default NHWC format,</source>
          <target state="translated">Подробнее,с форматом NHWC по умолчанию,</target>
        </trans-unit>
        <trans-unit id="39ee2fb212e9ff65eb60f4c2eed006218ac4350f" translate="yes" xml:space="preserve">
          <source>In distributed setting for a non-chief worker, you can use following:</source>
          <target state="translated">В распределенной настройке для не главного работника можно использовать следующее:</target>
        </trans-unit>
        <trans-unit id="432fd70bbc9af278575edb8550ab4d0e6d429837" translate="yes" xml:space="preserve">
          <source>In each mask field (&lt;code&gt;begin_mask&lt;/code&gt;, &lt;code&gt;end_mask&lt;/code&gt;, &lt;code&gt;ellipsis_mask&lt;/code&gt;, &lt;code&gt;new_axis_mask&lt;/code&gt;, &lt;code&gt;shrink_axis_mask&lt;/code&gt;) the ith bit will correspond to the ith spec.</source>
          <target state="translated">В каждом поле маски ( &lt;code&gt;begin_mask&lt;/code&gt; , &lt;code&gt;end_mask&lt;/code&gt; , &lt;code&gt;ellipsis_mask&lt;/code&gt; , &lt;code&gt;new_axis_mask&lt;/code&gt; , &lt;code&gt;shrink_axis_mask&lt;/code&gt; ) г - й бит будет соответствовать спецификациям г - я.</target>
        </trans-unit>
        <trans-unit id="a827b2d32c94f4d078081b87422b337df7153cca" translate="yes" xml:space="preserve">
          <source>In each repetition, this dataset fills a buffer with &lt;code&gt;buffer_size&lt;/code&gt; elements, then randomly samples elements from this buffer, replacing the selected elements with new elements. For perfect shuffling, set the buffer size equal to the full size of the dataset.</source>
          <target state="translated">При каждом повторении этот набор данных заполняет буфер элементами &lt;code&gt;buffer_size&lt;/code&gt; , а затем произвольно выбирает элементы из этого буфера, заменяя выбранные элементы новыми элементами. Для идеального перемешивания установите размер буфера равным полному размеру набора данных.</target>
        </trans-unit>
        <trans-unit id="ab4f684abeec2fbace4964ba714b6c3030a31435" translate="yes" xml:space="preserve">
          <source>In eager execution the shape is always fully-known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad9df451db78bb007e8c2331091212546191af9" translate="yes" xml:space="preserve">
          <source>In eager mode, None. In graph mode, an op to update the loss scale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5bcda8bd9453fe45c3ad8b95cc83910933e573a" translate="yes" xml:space="preserve">
          <source>In eager mode, no special code is needed to initialize the table. Example usage in eager mode:</source>
          <target state="translated">В режиме ожидания для инициализации таблицы никакого специального кода не требуется.Пример использования в режиме ожидания:</target>
        </trans-unit>
        <trans-unit id="8a80543ed8233233bcba2882c158c2bd26a1a267" translate="yes" xml:space="preserve">
          <source>In eager mode, this directly updates the loss scale, so that calling &lt;code&gt;__call__&lt;/code&gt; will return the newly updated loss scale. In graph mode, this returns an op that, when evaluated, updates the loss scale.</source>
          <target state="translated">В активном режиме это напрямую обновляет шкалу потерь, так что вызов &lt;code&gt;__call__&lt;/code&gt; вернет недавно обновленную шкалу потерь. В режиме графика это возвращает операцию, которая при оценке обновляет шкалу потерь.</target>
        </trans-unit>
        <trans-unit id="71ccf90ba0d4e13bfe64aa70496805e8e26edd75" translate="yes" xml:space="preserve">
          <source>In either case above, the numpy ndarray (either the caller provided or the auto-converted) must have the compatible type with dtype.</source>
          <target state="translated">В любом из вышеперечисленных случаев numpy ndarray (либо предоставленный звонящий,либо автоматически конвертированный)должен иметь совместимый тип с типом d.</target>
        </trans-unit>
        <trans-unit id="b2af86db54b3c6e559c751f3b18febb46377d6d4" translate="yes" xml:space="preserve">
          <source>In every case, these &lt;code&gt;Tensor&lt;/code&gt;s are all floating dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df70ac6f46a69a033f507ba69518b4967c5b0477" translate="yes" xml:space="preserve">
          <source>In fact, a higher-level solution to update a distributed variable is by calling &lt;code&gt;assign&lt;/code&gt; on the variable as you would do to a regular &lt;a href=&quot;../../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;. You can call the method in both &lt;em&gt;replica context&lt;/em&gt; and &lt;em&gt;cross-replica context&lt;/em&gt;. For a &lt;em&gt;mirrored variable&lt;/em&gt;, calling &lt;code&gt;assign&lt;/code&gt; in &lt;em&gt;replica context&lt;/em&gt; requires you to specify the &lt;code&gt;aggregation&lt;/code&gt; type in the variable constructor. In that case, the context switching and sync described in steps 2 through 4 are handled for you. If you call &lt;code&gt;assign&lt;/code&gt; on &lt;em&gt;mirrored variable&lt;/em&gt; in &lt;em&gt;cross-replica context&lt;/em&gt;, you can only assign a single value or assign values from another mirrored variable or a mirrored &lt;a href=&quot;../../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt;. For a &lt;em&gt;SyncOnRead variable&lt;/em&gt;, in &lt;em&gt;replica context&lt;/em&gt;, you can simply call &lt;code&gt;assign&lt;/code&gt; on it and no aggregation happens under the hood. In &lt;em&gt;cross-replica context&lt;/em&gt;, you can only assign a single value to a SyncOnRead variable. One example case is restoring from a checkpoint: if the &lt;code&gt;aggregation&lt;/code&gt; type of the variable is &lt;a href=&quot;../../../variableaggregation#SUM&quot;&gt;&lt;code&gt;tf.VariableAggregation.SUM&lt;/code&gt;&lt;/a&gt;, it is assumed that replica values were added before checkpointing, so at the time of restoring, the value is divided by the number of replicas and then assigned to each replica; if the &lt;code&gt;aggregation&lt;/code&gt; type is &lt;a href=&quot;../../../variableaggregation#MEAN&quot;&gt;&lt;code&gt;tf.VariableAggregation.MEAN&lt;/code&gt;&lt;/a&gt;, the value is assigned to each replica directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09214f6918bfb65897e422e8565cff18e083e90" translate="yes" xml:space="preserve">
          <source>In fact, a higher-level solution to update a distributed variable is by calling &lt;code&gt;assign&lt;/code&gt; on the variable as you would do to a regular &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;. You can call the method in both &lt;em&gt;replica context&lt;/em&gt; and &lt;em&gt;cross-replica context&lt;/em&gt;. For a &lt;em&gt;mirrored variable&lt;/em&gt;, calling &lt;code&gt;assign&lt;/code&gt; in &lt;em&gt;replica context&lt;/em&gt; requires you to specify the &lt;code&gt;aggregation&lt;/code&gt; type in the variable constructor. In that case, the context switching and sync described in steps 2 through 4 are handled for you. If you call &lt;code&gt;assign&lt;/code&gt; on &lt;em&gt;mirrored variable&lt;/em&gt; in &lt;em&gt;cross-replica context&lt;/em&gt;, you can only assign a single value or assign values from another mirrored variable or a mirrored &lt;a href=&quot;distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt;. For a &lt;em&gt;SyncOnRead variable&lt;/em&gt;, in &lt;em&gt;replica context&lt;/em&gt;, you can simply call &lt;code&gt;assign&lt;/code&gt; on it and no aggregation happens under the hood. In &lt;em&gt;cross-replica context&lt;/em&gt;, you can only assign a single value to a SyncOnRead variable. One example case is restoring from a checkpoint: if the &lt;code&gt;aggregation&lt;/code&gt; type of the variable is &lt;a href=&quot;../variableaggregation#SUM&quot;&gt;&lt;code&gt;tf.VariableAggregation.SUM&lt;/code&gt;&lt;/a&gt;, it is assumed that replica values were added before checkpointing, so at the time of restoring, the value is divided by the number of replicas and then assigned to each replica; if the &lt;code&gt;aggregation&lt;/code&gt; type is &lt;a href=&quot;../variableaggregation#MEAN&quot;&gt;&lt;code&gt;tf.VariableAggregation.MEAN&lt;/code&gt;&lt;/a&gt;, the value is assigned to each replica directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458f9bf1f3a55d57242c3dfd6a8b1b2360358c13" translate="yes" xml:space="preserve">
          <source>In general multiprocessing.Pool can interact quite badly with other, seemingly unrelated, parts of a codebase due to Pool's reliance on fork. This method cleans up all pools which are known to belong to Keras (and thus can be safely terminated).</source>
          <target state="translated">Обычно многопроцессорный пул может довольно плохо взаимодействовать с другими,казалось бы,не связанными между собой частями кодовой базы из-за того,что пул полагается на развилку.Этот метод очищает все пулы,которые,как известно,принадлежат Keras (и,таким образом,могут быть безопасно завершены).</target>
        </trans-unit>
        <trans-unit id="05fa93477d180d1acfa7da38b422f9dbed979a61" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;../../devicespec#from_string&quot;&gt;&lt;code&gt;DeviceSpec.from_string&lt;/code&gt;&lt;/a&gt; should completely replace &lt;a href=&quot;../../devicespec#parse_from_string&quot;&gt;&lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../devicespec#replace&quot;&gt;&lt;code&gt;DeviceSpec.replace&lt;/code&gt;&lt;/a&gt; should completely replace setting attributes directly.</source>
          <target state="translated">В общем, &lt;a href=&quot;../../devicespec#from_string&quot;&gt; &lt;code&gt;DeviceSpec.from_string&lt;/code&gt; &lt;/a&gt; должен полностью заменять &lt;a href=&quot;../../devicespec#parse_from_string&quot;&gt; &lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt; &lt;/a&gt; , а &lt;a href=&quot;../../devicespec#replace&quot;&gt; &lt;code&gt;DeviceSpec.replace&lt;/code&gt; &lt;/a&gt; должен полностью заменять атрибуты настройки напрямую.</target>
        </trans-unit>
        <trans-unit id="c1759e56b5d26a55f209d28b2c39da67c3d2c868" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;devicespec#from_string&quot;&gt;&lt;code&gt;DeviceSpec.from_string&lt;/code&gt;&lt;/a&gt; should completely replace &lt;a href=&quot;devicespec#parse_from_string&quot;&gt;&lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;devicespec#replace&quot;&gt;&lt;code&gt;DeviceSpec.replace&lt;/code&gt;&lt;/a&gt; should completely replace setting attributes directly.</source>
          <target state="translated">В общем, &lt;a href=&quot;devicespec#from_string&quot;&gt; &lt;code&gt;DeviceSpec.from_string&lt;/code&gt; &lt;/a&gt; должен полностью заменять &lt;a href=&quot;devicespec#parse_from_string&quot;&gt; &lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt; &lt;/a&gt; , а &lt;a href=&quot;devicespec#replace&quot;&gt; &lt;code&gt;DeviceSpec.replace&lt;/code&gt; &lt;/a&gt; должен полностью заменять атрибуты настройки напрямую.</target>
        </trans-unit>
        <trans-unit id="0be78576bf089134edc696318f9dc842768f1015" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/DeviceSpec#from_string&quot;&gt;&lt;code&gt;DeviceSpec.from_string&lt;/code&gt;&lt;/a&gt; should completely replace &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/DeviceSpec#parse_from_string&quot;&gt;&lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/DeviceSpec#replace&quot;&gt;&lt;code&gt;DeviceSpec.replace&lt;/code&gt;&lt;/a&gt; should completely replace setting attributes directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b1248ae5eafe23fc297bb9a228b2f925c57498" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;0 &amp;lt; dim(mask) = K &amp;lt;= dim(tensor)&lt;/code&gt;, and &lt;code&gt;mask&lt;/code&gt;'s shape must match the first K dimensions of &lt;code&gt;tensor&lt;/code&gt;'s shape. We then have: &lt;code&gt;boolean_mask(tensor, mask)[i, j1,...,jd] = tensor[i1,...,iK,j1,...,jd]&lt;/code&gt; where &lt;code&gt;(i1,...,iK)&lt;/code&gt; is the ith &lt;code&gt;True&lt;/code&gt; entry of &lt;code&gt;mask&lt;/code&gt; (row-major order). The &lt;code&gt;axis&lt;/code&gt; could be used with &lt;code&gt;mask&lt;/code&gt; to indicate the axis to mask from. In that case, &lt;code&gt;axis + dim(mask) &amp;lt;= dim(tensor)&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt;'s shape must match the first &lt;code&gt;axis + dim(mask)&lt;/code&gt; dimensions of &lt;code&gt;tensor&lt;/code&gt;'s shape.</source>
          <target state="translated">В общем, &lt;code&gt;0 &amp;lt; dim(mask) = K &amp;lt;= dim(tensor)&lt;/code&gt; , и форма &lt;code&gt;mask&lt;/code&gt; должна соответствовать первым размерностям K формы &lt;code&gt;tensor&lt;/code&gt; . Тогда у нас есть: &lt;code&gt;boolean_mask(tensor, mask)[i, j1,...,jd] = tensor[i1,...,iK,j1,...,jd]&lt;/code&gt; где &lt;code&gt;(i1,...,iK)&lt;/code&gt; - это i-й &lt;code&gt;True&lt;/code&gt; элемент &lt;code&gt;mask&lt;/code&gt; (строчный порядок). &lt;code&gt;axis&lt;/code&gt; может быть использована с &lt;code&gt;mask&lt;/code&gt; для указания оси маскировать из. В этом случае &lt;code&gt;axis + dim(mask) &amp;lt;= dim(tensor)&lt;/code&gt; и форма &lt;code&gt;mask&lt;/code&gt; должны совпадать с размерами первой &lt;code&gt;axis + dim(mask)&lt;/code&gt; формы &lt;code&gt;tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df73d635dcf19899192fc8057c9a906f0ba749f2" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;order(c) = order(a) + order(b) - 2*len(axes[0])&lt;/code&gt;.</source>
          <target state="translated">В общем, &lt;code&gt;order(c) = order(a) + order(b) - 2*len(axes[0])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8197a907e7eede9a4ab49989b9c67df1ecf6abfd" translate="yes" xml:space="preserve">
          <source>In general, Lambda layers can be convenient for simple stateless computation, but anything more complex should use a subclass Layer instead.</source>
          <target state="translated">В целом,слои Lambda могут быть удобны для простых вычислений без присутствия,но что-либо более сложное должно использовать подкласс Layer.</target>
        </trans-unit>
        <trans-unit id="f38c9626976c1df9169c1e0b677516dea631b670" translate="yes" xml:space="preserve">
          <source>In general, it is recommended to create stateful objects like &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; outside of &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and passing them as arguments.</source>
          <target state="translated">В общем, рекомендуется создавать объекты с состоянием, такие как &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; ,&lt;/a&gt; вне &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; и передавать их в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="619dfbe395f886ec7d908acd2d16888a420d60c9" translate="yes" xml:space="preserve">
          <source>In general, multi-client tf.distribute strategies such as &lt;a href=&quot;../experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; require task_type and task_id properties to be available in the &lt;code&gt;ClusterResolver&lt;/code&gt; they are using. On the other hand, these concepts are not applicable in single-client strategies, such as &lt;a href=&quot;../experimental/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy&lt;/code&gt;&lt;/a&gt;, because the program is only expected to be run on one task, so there should not be a need to have code branches according to task type and task id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75611dab36791d918a60f2d742b07af8d1fae0c4" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;equation&lt;/code&gt; is obtained from the more familiar element-wise equation by 1. removing variable names, brackets, and commas, 2. replacing &quot;*&quot; with &quot;,&quot;, 3. dropping summation signs, and 4. moving the output to the right, and replacing &quot;=&quot; with &quot;-&amp;gt;&quot;.</source>
          <target state="translated">В общем, &lt;code&gt;equation&lt;/code&gt; получается из более знакомого поэлементного уравнения путем 1. удаления имен переменных, скобок и запятых, 2. замены &amp;laquo;*&amp;raquo; на &amp;laquo;,&amp;raquo;, 3. удаления знаков суммирования и 4. перемещения вывода вправо и заменив &quot;=&quot; на &quot;-&amp;gt;&quot;.</target>
        </trans-unit>
        <trans-unit id="052bab4a4ace4679f5fac38b0fa6d8e9de67b67a" translate="yes" xml:space="preserve">
          <source>In general, to convert the element-wise equation into the &lt;code&gt;equation&lt;/code&gt; string, use the following procedure (intermediate strings for matrix multiplication example provided in parentheses):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c259f3cade9e31230407abe615fe31af4bb9832a" translate="yes" xml:space="preserve">
          <source>In general, when using a multi-worker &lt;a href=&quot;../../../../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; strategy such as &lt;a href=&quot;../../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../distribute/experimental/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt;&lt;/a&gt;, there is a &lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; associated with the strategy used, and such an instance is returned by this property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7eeb79a4204a5424bef497bd6fd4d234294c4f4" translate="yes" xml:space="preserve">
          <source>In general, when using a multi-worker &lt;a href=&quot;../../../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; strategy such as &lt;a href=&quot;../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../distribute/experimental/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt;&lt;/a&gt;, there is a &lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; associated with the strategy used, and such an instance is returned by this property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1852073079600e10293c9450fade374fcb9f2a19" translate="yes" xml:space="preserve">
          <source>In general, when using a multi-worker &lt;a href=&quot;../../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; strategy such as &lt;a href=&quot;multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt;&lt;/a&gt;, there is a &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; associated with the strategy used, and such an instance is returned by this property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77606f598bc444a0148a3b80b85e17cb5930008" translate="yes" xml:space="preserve">
          <source>In general, when using a multi-worker &lt;a href=&quot;../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; strategy such as &lt;a href=&quot;experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;experimental/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt;&lt;/a&gt;, there is a &lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; associated with the strategy used, and such an instance is returned by this property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ba21f1479a022109ab2f3d99be347c7bb01f17" translate="yes" xml:space="preserve">
          <source>In general, you should use the &lt;code&gt;with strategy.scope():&lt;/code&gt; API, but this alternative may be convenient in notebooks where you would have to put each cell in a &lt;code&gt;with strategy.scope():&lt;/code&gt; block.</source>
          <target state="translated">В общем, вы должны использовать &lt;code&gt;with strategy.scope():&lt;/code&gt; API, но этот вариант может быть удобен в ноутбуках , где вы должны поместить каждую ячейку в &lt;code&gt;with strategy.scope():&lt;/code&gt; блок.</target>
        </trans-unit>
        <trans-unit id="c093e0c853b18b211b082dc234fa39265b721fa2" translate="yes" xml:space="preserve">
          <source>In graph mode, this returns an operation which when executed performs the write. In eager mode, the write is performed by the method itself and there is no return value.</source>
          <target state="translated">В графическом режиме это возвращает операцию,которая при выполнении выполняет запись.В режиме ожидания запись выполняется самим методом,а возвращаемого значения нет.</target>
        </trans-unit>
        <trans-unit id="1321491278c9fd1609935b5dea7b2ba0f946dfd9" translate="yes" xml:space="preserve">
          <source>In graph mode, you should typically call this method &lt;em&gt;once&lt;/em&gt; and use its result as the input to another computation. A typical loop will then call &lt;code&gt;tf.Session.run&lt;/code&gt; on the result of that computation. The loop will terminate when the &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Iterator#get_next&quot;&gt;&lt;code&gt;Iterator.get_next()&lt;/code&gt;&lt;/a&gt; operation raises &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt;. The following skeleton shows how to use this method when building a training loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716f31f5a03aef3f69ebd13d12a35b86aebe2e30" translate="yes" xml:space="preserve">
          <source>In graph mode, you should typically call this method &lt;em&gt;once&lt;/em&gt; and use its result as the input to another computation. A typical loop will then call &lt;code&gt;tf.Session.run&lt;/code&gt; on the result of that computation. The loop will terminate when the &lt;code&gt;Iterator.get_next()&lt;/code&gt; operation raises &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt;. The following skeleton shows how to use this method when building a training loop:</source>
          <target state="translated">В графическом режиме вы обычно должны вызвать этот метод &lt;em&gt;один раз&lt;/em&gt; и использовать его результат в качестве входных данных для другого вычисления. Типичный цикл затем вызывает &lt;code&gt;tf.Session.run&lt;/code&gt; по результату этого вычисления. Цикл завершится, когда операция &lt;code&gt;Iterator.get_next()&lt;/code&gt; &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt; . Следующий скелет показывает, как использовать этот метод при построении цикла обучения:</target>
        </trans-unit>
        <trans-unit id="a6ca36a8e0927892e5adf0bea0071edf9a03306d" translate="yes" xml:space="preserve">
          <source>In many common cases, saving models for serving will be as simple as:</source>
          <target state="translated">Во многих распространенных случаях сохранить модели для сервировки будет так же просто:</target>
        </trans-unit>
        <trans-unit id="0c1e157d5c07c3be9a526b99a8cd938ffdff518e" translate="yes" xml:space="preserve">
          <source>In most cases you can set session arguments as follows:</source>
          <target state="translated">В большинстве случаев вы можете установить аргументы сессии следующим образом:</target>
        </trans-unit>
        <trans-unit id="b24eb32e772a4b559b69c542c15c36c63f4a898a" translate="yes" xml:space="preserve">
          <source>In most functions that accept a LossScale, you can also pass an int (such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b8e52a139b65c15d15047812c546d3fc8efe99" translate="yes" xml:space="preserve">
          <source>In one of the two cases below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e583468a15187c915f71a5317544c6b871de6462" translate="yes" xml:space="preserve">
          <source>In other words,</source>
          <target state="translated">Другими словами,</target>
        </trans-unit>
        <trans-unit id="36ca12036e617d13dd1e10a27cdcc10a21abe207" translate="yes" xml:space="preserve">
          <source>In other words, if</source>
          <target state="translated">Другими словами,если</target>
        </trans-unit>
        <trans-unit id="68f09d96ffe8138bea778134c4c062b38232e1d6" translate="yes" xml:space="preserve">
          <source>In other words, it flattens each data samples of a batch.</source>
          <target state="translated">Другими словами,он сглаживает каждый образец данных партии.</target>
        </trans-unit>
        <trans-unit id="cdb1bf5db2bd1845e8b9a621343dc2f7674e34e9" translate="yes" xml:space="preserve">
          <source>In other words, the last dimension is treated as the $z$ vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0871ff786a8a3fd603a58b9722f796614ebc2719" translate="yes" xml:space="preserve">
          <source>In other words, the last dimension is treated as the &lt;code&gt;z&lt;/code&gt; vector.</source>
          <target state="translated">Другими словами, последнее измерение рассматривается как вектор &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78ff35f7c65003df3e7bcf3683132006bf742ac9" translate="yes" xml:space="preserve">
          <source>In parent, replace child_name's old definition with new_child.</source>
          <target state="translated">В родителях,замените старое определение child_name на new_child.</target>
        </trans-unit>
        <trans-unit id="d76da88946b010ac70fdfba18e1366302d30f656" translate="yes" xml:space="preserve">
          <source>In particular, all values that are compatible with this TypeSpec must be an instance of this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a5bb936a13cf0b0b5a2a5c1cb9a4facd12daec" translate="yes" xml:space="preserve">
          <source>In particular, the tolerance is reduced to 1e-3 if at least one of the arguments is of type float16.</source>
          <target state="translated">В частности,допуск уменьшается до 1e-3,если хотя бы один из аргументов имеет тип float16.</target>
        </trans-unit>
        <trans-unit id="44d0d4248217b7cffdeccf5ed82b70d82d1494ed" translate="yes" xml:space="preserve">
          <source>In particular, this adds any losses you have added with &lt;code&gt;tf.add_loss()&lt;/code&gt; to any regularization losses that have been added by regularization parameters on layers constructors e.g. &lt;code&gt;tf.layers&lt;/code&gt;. Be very sure to use this if you are constructing a loss_op manually. Otherwise regularization arguments on &lt;code&gt;tf.layers&lt;/code&gt; methods will not function.</source>
          <target state="translated">В частности, это добавляет любые потери, которые вы добавили с помощью &lt;code&gt;tf.add_loss()&lt;/code&gt; к любым потерям регуляризации, которые были добавлены параметрами регуляризации в конструкторах слоев, например &lt;code&gt;tf.layers&lt;/code&gt; . Обязательно используйте это, если вы создаете loss_op вручную. В противном случае аргументы &lt;code&gt;tf.layers&lt;/code&gt; методах tf.layers не будут работать.</target>
        </trans-unit>
        <trans-unit id="569e331ba8296ea2e67c10dc906718d574087feb" translate="yes" xml:space="preserve">
          <source>In practice, this is most useful for taking output from operations like QuantizedMatMul that can produce higher bit-depth outputs than their inputs and may have large potential output ranges, but in practice have a distribution of input values that only uses a small fraction of the possible range. By feeding that output into this operator, we can reduce it from 32 bits down to 8 with minimal loss of accuracy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60680116f8f10f4ec9328db9798f3167d053000" translate="yes" xml:space="preserve">
          <source>In python 2.7, make sure to import the following: &lt;code&gt;from __future__ import print_function&lt;/code&gt;</source>
          <target state="translated">В python 2.7 обязательно импортируйте следующее: &lt;code&gt;from __future__ import print_function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">Короче говоря:</target>
        </trans-unit>
        <trans-unit id="88d124b3a5514b4439d86d509898719151ee7194" translate="yes" xml:space="preserve">
          <source>In signal processing, cross-correlation is a measure of similarity of two waveforms as a function of a time-lag applied to one of them. This is also known as a sliding dot product or sliding inner-product.</source>
          <target state="translated">При обработке сигналов кросс-корреляция является мерой подобия двух форм волны как функции временного зазора,применяемой к одной из них.Это также известно как скользящее точечное изделие или скользящий внутренний продукт.</target>
        </trans-unit>
        <trans-unit id="be0bf3082cdcee4f10548b89039a3787e696144d" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;a href=&quot;../../vectorized_map&quot;&gt;&lt;code&gt;tf.vectorized_map&lt;/code&gt;&lt;/a&gt; can be used to automatically convert a function to a vectorized eqivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8cc8853b99fc4bbc66bb3fd1188773731a713d" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;a href=&quot;vectorized_map&quot;&gt;&lt;code&gt;tf.vectorized_map&lt;/code&gt;&lt;/a&gt; can be used to automatically convert a function to a vectorized eqivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3834a387ac572a1a80e915dcbd47e2584fd2d76" translate="yes" xml:space="preserve">
          <source>In some cases, such as a metric, we want to accumulate a bunch of updates on each replica independently and only aggregate when reading. This can be a big performance win when the value is read only rarely (maybe the value is only read at the end of an epoch or when checkpointing). These are variables created by passing &lt;code&gt;synchronization=ON_READ&lt;/code&gt; to the variable's constructor (and some value for &lt;code&gt;aggregation&lt;/code&gt;).</source>
          <target state="translated">В некоторых случаях, например для метрики, мы хотим накапливать несколько обновлений для каждой реплики независимо и агрегировать только при чтении. Это может быть большим выигрышем в производительности, если значение читается редко (возможно, значение читается только в конце эпохи или при установлении контрольных точек). Это переменные, созданные путем передачи &lt;code&gt;synchronization=ON_READ&lt;/code&gt; конструктору переменной (и некоторого значения для &lt;code&gt;aggregation&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f1db5fe6989f9a4d4881a86d7d0f8ee7689b077f" translate="yes" xml:space="preserve">
          <source>In some cases, the inferred shape may have unknown dimensions. If the caller has additional information about the values of these dimensions, &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;Tensor.set_shape()&lt;/code&gt;&lt;/a&gt; can be used to augment the inferred shape.</source>
          <target state="translated">В некоторых случаях предполагаемая форма может иметь неизвестные размеры. Если у вызывающей стороны есть дополнительная информация о значениях этих измерений, &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;Tensor.set_shape()&lt;/code&gt; &lt;/a&gt; может использоваться для увеличения предполагаемой формы.</target>
        </trans-unit>
        <trans-unit id="94661b97f98e1631edeff74724d2853ddff0e3b6" translate="yes" xml:space="preserve">
          <source>In some strategies, a default device scope may also be entered: in &lt;code&gt;MultiWorkerMiroredStrategy&lt;/code&gt;, a default device scope of &quot;/CPU:0&quot; is entered on each worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88eb075661eb4f67a83a555945256eb9a90b0cc1" translate="yes" xml:space="preserve">
          <source>In subsequent layers, there is no need for the &lt;code&gt;input_shape&lt;/code&gt;:</source>
          <target state="translated">В последующих слоях &lt;code&gt;input_shape&lt;/code&gt; не требуется :</target>
        </trans-unit>
        <trans-unit id="857fdd5affc004f92507d11901ea9986d0376b16" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;chief&lt;/em&gt; task, the &lt;code&gt;Supervisor&lt;/code&gt; works exactly as in the first example above. In the other tasks &lt;code&gt;sv.managed_session()&lt;/code&gt; waits for the Model to have been initialized before returning a session to the training code. The non-chief tasks depend on the chief task for initializing the model.</source>
          <target state="translated">В &lt;em&gt;главной&lt;/em&gt; задаче &lt;code&gt;Supervisor&lt;/code&gt; работает точно так же, как в первом примере выше. В других задачах &lt;code&gt;sv.managed_session()&lt;/code&gt; ожидает инициализации модели перед возвратом сеанса в обучающий код. Неосновные задачи зависят от главной задачи инициализации модели.</target>
        </trans-unit>
        <trans-unit id="49fca8ddc23c4fbc33f583e5bbd044e3ced4da7d" translate="yes" xml:space="preserve">
          <source>In the TensorFlow Python API, you can instantiate this dataset via the class &lt;a href=&quot;../data/experimental/randomdataset&quot;&gt;&lt;code&gt;tf.data.experimental.RandomDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d0ac75602613f08d522ad4bae89f61c4aea3ea" translate="yes" xml:space="preserve">
          <source>In the above example, the first feature will be looked up in a table that has a learning rate of 0.2 while the second feature will be looked up in a table that has a learning rate of 0.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e28b216fb36afdc49dad60997d42beaa6422e3" translate="yes" xml:space="preserve">
          <source>In the above example, the first two lines (before the call to &lt;code&gt;distribute&lt;/code&gt;) will be executed on tf.data workers, and the elements provided over RPC. The remaining transformations (after the call to &lt;code&gt;distribute&lt;/code&gt;) will be executed locally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86c807225e5481b2e9889d17693e52a348a5bb6" translate="yes" xml:space="preserve">
          <source>In the above example, the input Tensor with the shape of &lt;code&gt;[1, 3]&lt;/code&gt; is broadcasted to output Tensor with shape of &lt;code&gt;[3, 3]&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере входной тензор с формой &lt;code&gt;[1, 3]&lt;/code&gt; транслируется на выходной тензор с формой &lt;code&gt;[3, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6277b5ea0c4836f9eb1fc077e5a179b440871327" translate="yes" xml:space="preserve">
          <source>In the above examples, we assume that the user has a dataset which returns a tuple where the first element of the tuple matches the structure of what was passed as the &lt;code&gt;feature_config&lt;/code&gt; argument to the object initializer. Also we utilize &lt;a href=&quot;../../../range&quot;&gt;&lt;code&gt;tf.range&lt;/code&gt;&lt;/a&gt; to get a &lt;a href=&quot;../../../while_loop&quot;&gt;&lt;code&gt;tf.while_loop&lt;/code&gt;&lt;/a&gt; in order to increase performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6b4719a2c3219a2bbde7c4f83c1120564a1d57" translate="yes" xml:space="preserve">
          <source>In the case of dict instances, the sequence consists of the values, sorted by key to ensure deterministic behavior. This is true also for OrderedDict instances: their sequence order is ignored, the sorting order of keys is used instead. The same convention is followed in pack_sequence_as. This correctly repacks dicts and OrderedDicts after they have been flattened, and also allows flattening an OrderedDict and then repacking it back using a corresponding plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be flattened.</source>
          <target state="translated">В случае диктата,последовательность состоит из значений,отсортированных по ключам для обеспечения детерминированного поведения.Это справедливо и для экземпляров OrderedDict:их порядок следования игнорируется,вместо них используется порядок сортировки по ключам.Та же самая конвенция соблюдается в pack_sequence_as.Это корректно переупаковывает dicts и OrderedDicts после того,как они сглажены,а также позволяет сгладить OrderedDict и затем переупаковать его обратно с помощью соответствующего простого диктата,или наоборот.Словари с неразборчивыми клавишами не могут быть сплющены.</target>
        </trans-unit>
        <trans-unit id="4802827e52e703aec4f9202f8faaec1cab12a93e" translate="yes" xml:space="preserve">
          <source>In the case of dynamically sized TensorArrays, gradient computation should only be performed on read operations that have themselves been chained via flow to occur only after all writes have executed. That way the final size of the forward TensorArray is known when this operation is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb2d8441c532154e13fdb15d9d6cebc3cc43934" translate="yes" xml:space="preserve">
          <source>In the case of variable slice assignment, the Variable object to slice (i.e. tensor is the read-only view of this variable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ed01e4d71ead3866c98e46077be45f69b99800" translate="yes" xml:space="preserve">
          <source>In the case that &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot;, computes for 0 &amp;lt;= b &amp;lt; batch_size, 0 &amp;lt;= x[i] &amp;lt; output_spatial_shape[i], 0 &amp;lt;= c &amp;lt; num_channels:</source>
          <target state="translated">В случае, если &lt;code&gt;data_format&lt;/code&gt; не начинается с &amp;laquo;NC&amp;raquo;, вычисляется для 0 &amp;lt;= b &amp;lt;batch_size, 0 &amp;lt;= x [i] &amp;lt;output_spatial_shape [i], 0 &amp;lt;= c &amp;lt;num_channels:</target>
        </trans-unit>
        <trans-unit id="f7489a66c28d483acf8142e46fd3d2bce2a97dfd" translate="yes" xml:space="preserve">
          <source>In the case that &lt;code&gt;data_format&lt;/code&gt; does start with &lt;code&gt;&quot;NC&quot;&lt;/code&gt;, the &lt;code&gt;input&lt;/code&gt; and output (but not the &lt;code&gt;filter&lt;/code&gt;) are simply transposed as follows:</source>
          <target state="translated">В случае, если &lt;code&gt;data_format&lt;/code&gt; начинается с &lt;code&gt;&quot;NC&quot;&lt;/code&gt; , &lt;code&gt;input&lt;/code&gt; и вывод (но не &lt;code&gt;filter&lt;/code&gt; ) просто транспонируются следующим образом:</target>
        </trans-unit>
        <trans-unit id="15f5b22f7879c5fdc5ce4821da71380664867c9e" translate="yes" xml:space="preserve">
          <source>In the case that &lt;code&gt;data_format&lt;/code&gt; does start with &lt;code&gt;&quot;NC&quot;&lt;/code&gt;, the &lt;code&gt;input&lt;/code&gt; and output (but not the &lt;code&gt;filters&lt;/code&gt;) are simply transposed as follows:</source>
          <target state="translated">В случае, если &lt;code&gt;data_format&lt;/code&gt; начинается с &lt;code&gt;&quot;NC&quot;&lt;/code&gt; , &lt;code&gt;input&lt;/code&gt; и вывод (но не &lt;code&gt;filters&lt;/code&gt; ) просто транспонируются следующим образом:</target>
        </trans-unit>
        <trans-unit id="14d0f86400986de97cae42ee5dcb99d4d7671a66" translate="yes" xml:space="preserve">
          <source>In the case that &lt;code&gt;data_format&lt;/code&gt; starts with &lt;code&gt;&quot;NC&quot;&lt;/code&gt;, the &lt;code&gt;input&lt;/code&gt; and output are simply transposed as follows:</source>
          <target state="translated">В случае, если &lt;code&gt;data_format&lt;/code&gt; начинается с &lt;code&gt;&quot;NC&quot;&lt;/code&gt; , &lt;code&gt;input&lt;/code&gt; и вывод просто транспонируются следующим образом:</target>
        </trans-unit>
        <trans-unit id="7585f71a96a6a1ba424fe17e28a732edc83fab83" translate="yes" xml:space="preserve">
          <source>In the case where texts contains lists, we assume each entry of the lists to be a token.</source>
          <target state="translated">В случае,когда тексты содержат списки,мы предполагаем,что каждая запись списков является токеном.</target>
        </trans-unit>
        <trans-unit id="b27ad5d7c7812f56a3419c5193f53b839dec7afb" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the &lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;&lt;code&gt;dist_dataset&lt;/code&gt; is batched by &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;, and we iterate through it using &lt;code&gt;for x in dist_dataset&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; a &lt;a href=&quot;../../../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; containing data for all replicas, which aggregates to a batch of &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;. &lt;a href=&quot;../../../../distribute/strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; will take care of feeding the right per-replica data in &lt;code&gt;x&lt;/code&gt; to the right &lt;code&gt;replica_fn&lt;/code&gt; executed on each replica.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0ee0fc7fad22052facea76762652a1189c53cf" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the &lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;&lt;code&gt;dist_dataset&lt;/code&gt; is batched by &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;, and we iterate through it using &lt;code&gt;for x in dist_dataset&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; a &lt;a href=&quot;../../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; containing data for all replicas, which aggregates to a batch of &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;. &lt;a href=&quot;../../../distribute/strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; will take care of feeding the right per-replica data in &lt;code&gt;x&lt;/code&gt; to the right &lt;code&gt;replica_fn&lt;/code&gt; executed on each replica.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de2e5a52ce490990b1fec55c4aff42334fa5999" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the &lt;a href=&quot;../distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;&lt;code&gt;dist_dataset&lt;/code&gt; is batched by &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;, and we iterate through it using &lt;code&gt;for x in dist_dataset&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; a &lt;a href=&quot;../distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; containing data for all replicas, which aggregates to a batch of &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;. &lt;a href=&quot;../strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; will take care of feeding the right per-replica data in &lt;code&gt;x&lt;/code&gt; to the right &lt;code&gt;replica_fn&lt;/code&gt; executed on each replica.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66841e03e2835d1f04c157d851fbcf3d05c9105" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;&lt;code&gt;dist_dataset&lt;/code&gt; is batched by &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;, and we iterate through it using &lt;code&gt;for x in dist_dataset&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; a &lt;a href=&quot;distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; containing data for all replicas, which aggregates to a batch of &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;. &lt;a href=&quot;strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; will take care of feeding the right per-replica data in &lt;code&gt;x&lt;/code&gt; to the right &lt;code&gt;replica_fn&lt;/code&gt; executed on each replica.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441c8788356ac631e91eb9d0cc144a89f12dd164" translate="yes" xml:space="preserve">
          <source>In the common case where the 'depth' dimension is the last dimension in the input tensor &lt;code&gt;x&lt;/code&gt;, they may be one dimensional tensors of the same size as the 'depth' dimension. This is the case for example for the common &lt;code&gt;[batch, depth]&lt;/code&gt; layout of fully-connected layers, and &lt;code&gt;[batch, height, width, depth]&lt;/code&gt; for convolutions. &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;variance&lt;/code&gt; in this case would typically be the outputs of &lt;a href=&quot;moments&quot;&gt;&lt;code&gt;tf.nn.moments(..., keepdims=False)&lt;/code&gt;&lt;/a&gt; during training, or running averages thereof during inference.</source>
          <target state="translated">В общем случае, когда измерение &amp;laquo;глубина&amp;raquo; является последним измерением во входном тензоре &lt;code&gt;x&lt;/code&gt; , они могут быть одномерными тензорами того же размера, что и измерение &amp;laquo;глубины&amp;raquo;. Это имеет место, например, для обычного макета &lt;code&gt;[batch, depth]&lt;/code&gt; полностью связанных слоев и &lt;code&gt;[batch, height, width, depth]&lt;/code&gt; для сверток. &lt;code&gt;mean&lt;/code&gt; и &lt;code&gt;variance&lt;/code&gt; в этом случае обычно будут выходными &lt;a href=&quot;moments&quot;&gt; &lt;code&gt;tf.nn.moments(..., keepdims=False)&lt;/code&gt; &lt;/a&gt; во время обучения или их средними значениями во время логического вывода.</target>
        </trans-unit>
        <trans-unit id="a2fdaa32535bc5d1425dc1f4179459c262cc1196" translate="yes" xml:space="preserve">
          <source>In the event that L and D are positive-definite, and U = V, solves and determinants can be done using a Cholesky factorization.</source>
          <target state="translated">В случае,если L и D являются положительно-определенными,а U=V,решения и детерминанты могут быть сделаны с помощью факторизации Холесского.</target>
        </trans-unit>
        <trans-unit id="f900f7fb08d74d77d09a58c36e14dae29b1b5604" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, and &lt;code&gt;e&lt;/code&gt; are symbolic &lt;code&gt;Tensor&lt;/code&gt; objects, whereas &lt;code&gt;result&lt;/code&gt; is a numpy array that stores a concrete value:</source>
          <target state="translated">В следующем примере &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; и &lt;code&gt;e&lt;/code&gt; являются символическими объектами &lt;code&gt;Tensor&lt;/code&gt; , тогда как &lt;code&gt;result&lt;/code&gt; - это массив numpy, в котором хранится конкретное значение:</target>
        </trans-unit>
        <trans-unit id="f8159cd552f6905daabd6b0759c879dc3cb02b31" translate="yes" xml:space="preserve">
          <source>In the following example, both &lt;code&gt;z&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; will be scaled by the same &lt;code&gt;y&lt;/code&gt;. It is important to note that if we didn't assign &lt;code&gt;scalar_name&lt;/code&gt; and used a different name for z and w that a &lt;code&gt;ValueError&lt;/code&gt; would be thrown because it couldn't reuse the variable.</source>
          <target state="translated">В следующем примере и &lt;code&gt;z&lt;/code&gt; , и &lt;code&gt;w&lt;/code&gt; будут масштабированы на один &lt;code&gt;y&lt;/code&gt; тот же y . Важно отметить, что если мы не назначили &lt;code&gt;scalar_name&lt;/code&gt; и использовали другое имя для z и w, то будет выдана ошибка &lt;code&gt;ValueError&lt;/code&gt; , поскольку она не сможет повторно использовать переменную.</target>
        </trans-unit>
        <trans-unit id="af225700bf663e20d927b904a713beaec69b8ae6" translate="yes" xml:space="preserve">
          <source>In the following example, the value returned by &lt;a href=&quot;raggedtensor#numpy&quot;&gt;&lt;code&gt;RaggedTensor.numpy()&lt;/code&gt;&lt;/a&gt; contains three numpy &lt;code&gt;array&lt;/code&gt; objects: one for each row (with &lt;code&gt;rank=1&lt;/code&gt; and &lt;code&gt;dtype=int64&lt;/code&gt;), and one to combine them (with &lt;code&gt;rank=1&lt;/code&gt; and &lt;code&gt;dtype=object&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd46fe1d494a119de52de4263e78cb6431e1f9cf" translate="yes" xml:space="preserve">
          <source>In the following examples, each input in the range &lt;code&gt;[0, 1000000)&lt;/code&gt; is assigned the same value. All other inputs are assigned &lt;code&gt;default_value&lt;/code&gt; 0. Note that a literal 0 in inputs will result in the same default ID.</source>
          <target state="translated">В следующих примерах каждому входу в диапазоне &lt;code&gt;[0, 1000000)&lt;/code&gt; назначается одно и то же значение. Всем другим входам присваивается значение &lt;code&gt;default_value&lt;/code&gt; 0. Обратите внимание, что буквальный 0 во входных данных приведет к тому же идентификатору по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e4ffded633c0b56e0d92344cf2671f58b989b260" translate="yes" xml:space="preserve">
          <source>In the following shapes, &lt;code&gt;nnz&lt;/code&gt; is the count after taking &lt;code&gt;thresh&lt;/code&gt; into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0a21a5321a939e4c6ec979642cca57482d54e4" translate="yes" xml:space="preserve">
          <source>In the future we may use this object to add more information about result of run without changing the Hook API.</source>
          <target state="translated">В будущем мы можем использовать этот объект для добавления дополнительной информации о результате выполнения без изменения Hook API.</target>
        </trans-unit>
        <trans-unit id="76fa778b0319a626a08c3bad3138553249a30e42" translate="yes" xml:space="preserve">
          <source>In the future, there will be additional processing modes. For example, a &quot;one_epoch&quot; mode which partitions the dataset across the tf.data workers, so that the consumers see each element of the dataset only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321470037eed07ac96098def67a575832b48e3a6" translate="yes" xml:space="preserve">
          <source>In the general case, produces an output tensor where:</source>
          <target state="translated">В общем случае,производит выходной тензор где:</target>
        </trans-unit>
        <trans-unit id="14120b56799edd7f482d4829806eaaaa1dc71825" translate="yes" xml:space="preserve">
          <source>In the integer case, the random integers are slightly biased unless &lt;code&gt;maxval - minval&lt;/code&gt; is an exact power of two. The bias is small for values of &lt;code&gt;maxval - minval&lt;/code&gt; significantly smaller than the range of the output (either &lt;code&gt;2**32&lt;/code&gt; or &lt;code&gt;2**64&lt;/code&gt;).</source>
          <target state="translated">В случае целых чисел случайные целые числа немного смещены, если &lt;code&gt;maxval - minval&lt;/code&gt; не является точной степенью двойки. Смещение невелико для значений &lt;code&gt;maxval - minval&lt;/code&gt; значительно меньших, чем диапазон вывода ( &lt;code&gt;2**32&lt;/code&gt; или &lt;code&gt;2**64&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="80812666c20de5f1b3022c6818967c980a3249c2" translate="yes" xml:space="preserve">
          <source>In the normal case, this returns the grpc path (grpc://1.2.3.4:8470) of first instance in the ClusterSpec returned by the cluster_spec function.</source>
          <target state="translated">В обычном случае это возвращает путь grpc (grpc://1.2.3.4:8470)первого экземпляра в ClusterSpec,возвращенного функцией cluster_spec.</target>
        </trans-unit>
        <trans-unit id="6055b65c599f09ebc21e3aeb62b02718663e00f7" translate="yes" xml:space="preserve">
          <source>In the returned matrix, all the triangles (filterbanks) have a peak value of 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d60edca816e4a2eab7c2afcd535e33631948ae" translate="yes" xml:space="preserve">
          <source>In the snippet below, each of the four examples has only a single floating-pointing value, and both &lt;code&gt;y_pred&lt;/code&gt; and &lt;code&gt;y_true&lt;/code&gt; have the shape &lt;code&gt;[batch_size]&lt;/code&gt;.</source>
          <target state="translated">В приведенном ниже фрагменте каждый из четырех примеров имеет только одно значение с плавающей &lt;code&gt;y_pred&lt;/code&gt; а &lt;code&gt;y_true&lt;/code&gt; и y_true имеют форму &lt;code&gt;[batch_size]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c495e13d301e9ffca0e963e7389b1c288c748a1" translate="yes" xml:space="preserve">
          <source>In the snippet below, there is &lt;code&gt;# classes&lt;/code&gt; floating pointing values per example. The shape of both &lt;code&gt;y_pred&lt;/code&gt; and &lt;code&gt;y_true&lt;/code&gt; are &lt;code&gt;[batch_size, num_classes]&lt;/code&gt;.</source>
          <target state="translated">В приведенном ниже фрагменте есть &lt;code&gt;# classes&lt;/code&gt; значений с плавающей точкой для каждого примера. Форма обоих &lt;code&gt;y_pred&lt;/code&gt; и &lt;code&gt;y_true&lt;/code&gt; являются &lt;code&gt;[batch_size, num_classes]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca0a25a87addb666ce34fdcd635cb0fb4ef8b8c8" translate="yes" xml:space="preserve">
          <source>In the snippet below, there is a single floating point value per example for &lt;code&gt;y_true&lt;/code&gt; and &lt;code&gt;# classes&lt;/code&gt; floating pointing values per example for &lt;code&gt;y_pred&lt;/code&gt;. The shape of &lt;code&gt;y_true&lt;/code&gt; is &lt;code&gt;[batch_size]&lt;/code&gt; and the shape of &lt;code&gt;y_pred&lt;/code&gt; is &lt;code&gt;[batch_size, num_classes]&lt;/code&gt;.</source>
          <target state="translated">В приведенном ниже фрагменте есть одно значение с плавающей запятой для примера для &lt;code&gt;y_true&lt;/code&gt; и &lt;code&gt;# classes&lt;/code&gt; значений с плавающей запятой для примера для &lt;code&gt;y_pred&lt;/code&gt; . Форма &lt;code&gt;y_true&lt;/code&gt; - &lt;code&gt;[batch_size]&lt;/code&gt; , а форма &lt;code&gt;y_pred&lt;/code&gt; - &lt;code&gt;[batch_size, num_classes]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edfa06a723b9aaa9b154321c98c5e60a3a87f241" translate="yes" xml:space="preserve">
          <source>In the special case that &lt;code&gt;dilation_rate&lt;/code&gt; is uniformly 1, this simply returns:</source>
          <target state="translated">В особом случае, когда &lt;code&gt;dilation_rate&lt;/code&gt; равно 1, это просто возвращает:</target>
        </trans-unit>
        <trans-unit id="1c3bff4b004264f13b9d5870cad9395d93194227" translate="yes" xml:space="preserve">
          <source>In the training program you will just have to run the returned Op.</source>
          <target state="translated">В тренировочной программе вам нужно будет просто запустить возвращаемый Op.</target>
        </trans-unit>
        <trans-unit id="d2890695a83ce1f36c63f8da28ce25a62b890df2" translate="yes" xml:space="preserve">
          <source>In the training program, every worker will run the train_op as if not synchronized.</source>
          <target state="translated">В учебной программе каждый работник будет запускать train_op так,как будто он не синхронизирован.</target>
        </trans-unit>
        <trans-unit id="050220458220cef5d8bae5a963a516346fce1ddc" translate="yes" xml:space="preserve">
          <source>In these cases, using &lt;a href=&quot;tensor#shape&quot;&gt;&lt;code&gt;tf.Tensor.shape&lt;/code&gt;&lt;/a&gt; will return more informative results.</source>
          <target state="translated">В этих случаях использование &lt;a href=&quot;tensor#shape&quot;&gt; &lt;code&gt;tf.Tensor.shape&lt;/code&gt; &lt;/a&gt; вернет более информативные результаты.</target>
        </trans-unit>
        <trans-unit id="a1fd23dc3b76dcc4f826b1d79ad28663677c68d6" translate="yes" xml:space="preserve">
          <source>In this case if &lt;code&gt;foo.shape&lt;/code&gt; is (5, 5, 5, 5, 5, 5) the final shape of the slice becomes (2, 1, 5, 5, 2, 5). Let us walk step by step through each argument specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de68be184025a4393a876c4969dd2dac3ec1ddab" translate="yes" xml:space="preserve">
          <source>In this case the last 3 data points are discarded since no full sequence can be generated to include them (the next sequence would have started at index 81, and thus its last step would have gone over 99).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2660fc8b716618056f3f2486b9d3eda40cce99bb" translate="yes" xml:space="preserve">
          <source>In this case, no TRT engines will be built or saved in the converted SavedModel. But if input data is available during conversion, we can still build and save the TRT engines to reduce the cost during inference (see option 2 below).</source>
          <target state="translated">В этом случае ни один двигатель TRT не будет построен или сохранен в переделанной SavedModel.Но если входные данные будут доступны во время конвертации,мы все равно сможем построить и сохранить движки TRT,чтобы снизить стоимость во время вывода (см.вариант 2 ниже).</target>
        </trans-unit>
        <trans-unit id="e5fc3e497d02a7bd7ecbf4bfc91e80a8c16dab8c" translate="yes" xml:space="preserve">
          <source>In this case, the L2-norm of the output tensor is &lt;code&gt;clip_norm&lt;/code&gt;.</source>
          <target state="translated">В этом случае L2-норма выходного тензора - &lt;code&gt;clip_norm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb53270a9519bb4c8fc2a2da8dd867f7bc0eb615" translate="yes" xml:space="preserve">
          <source>In this case, the average L2-norm of the output tensor is &lt;code&gt;clip_norm&lt;/code&gt;.</source>
          <target state="translated">В этом случае средняя L2-норма выходного тензора равна &lt;code&gt;clip_norm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82633df4f4d329acaa3d11394d5cdde32a611bc2" translate="yes" xml:space="preserve">
          <source>In this case, the default value used is &lt;code&gt;l1=0.01&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f71d9a8d2db7be1d1b1df2b421e4dfeaafef046" translate="yes" xml:space="preserve">
          <source>In this case, the default value used is &lt;code&gt;l2=0.01&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20678523ff7af42a84aac9bea4ae4af2f137e76a" translate="yes" xml:space="preserve">
          <source>In this case, the default values used are &lt;code&gt;l1=0.01&lt;/code&gt; and &lt;code&gt;l2=0.01&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1634e039fe69dd10f4980724390eee9597b30add" translate="yes" xml:space="preserve">
          <source>In this case, there is only one device, so this is only a thin wrapper around the input dataset. It will, however, prefetch the input data to the specified device. The returned distributed dataset can be iterated over similar to how regular datasets can.</source>
          <target state="translated">В данном случае есть только одно устройство,так что это только тонкая оболочка вокруг входного набора данных.Она,однако,предварительно устанавливает входные данные на указанное устройство.Возвращаемый распределенный набор данных может быть итерациирован по аналогии с обычными наборами данных.</target>
        </trans-unit>
        <trans-unit id="7e6c4c191f1042cc1f68cb766a50b94ec5bf0741" translate="yes" xml:space="preserve">
          <source>In this case, we are setting both the global and operation-level seed to ensure this result is reproducible. See &lt;a href=&quot;set_seed&quot;&gt;&lt;code&gt;tf.random.set_seed&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08e98fab219660f174a2388abcd7b00423921f2" translate="yes" xml:space="preserve">
          <source>In this example, the input value 'z' resulted in an output of '[UNK]', since 1000 was not in the vocabulary - it got represented as an OOV, and all OOV values are returned as '[OOV}' in the inverse layer. Also, note that for the inverse to work, you must have already set the forward layer vocabulary either directly or via fit() before calling get_vocabulary().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7c2f6499422f484ac6f330b882d5c04cd4e3dc" translate="yes" xml:space="preserve">
          <source>In this example, the input value 1000 resulted in an output of -1, since 1000 was not in the vocabulary - it got represented as an OOV, and all OOV values are returned as -1 in the inverse layer. Also, note that for the inverse to work, you must have already set the forward layer vocabulary either directly or via fit() before calling get_vocabulary().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36765b42855ac10a2bf8048f167e7fc07d039efe" translate="yes" xml:space="preserve">
          <source>In this example, we want to trace how much time spent on calling a function, which includes compilation and execution. The compilation can be either getting a cached copy of the binary or actually generating the binary, which is indicated by the boolean &quot;in_cache&quot; returned by jit_compile(). We need to use set_metadata() to pass in_cache because we did not know the in_cache value when the trace was created (and we cannot create the trace after jit_compile(), because we want to measure the entire duration of call()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2073cc64d02b3bf0e594d35e4cce41ba26845eb" translate="yes" xml:space="preserve">
          <source>In this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a8363320500d7fb6d0fa2afac0abec913757b2" translate="yes" xml:space="preserve">
          <source>In this way, one engine will be built/saved for each unique input shapes of the TRTEngineOp. This is good for applications that cannot afford building engines during inference but have access to input data that is similar to the one used in production (for example, that has the same input shapes). Also, the generated TRT engines is platform dependent, so we need to run &lt;code&gt;build()&lt;/code&gt; in an environment that is similar to production (e.g. with same type of GPU).</source>
          <target state="translated">Таким образом, будет создан / сохранен один движок для каждой уникальной формы ввода TRTEngineOp. Это хорошо для приложений, которые не могут позволить себе создавать механизмы во время логического вывода, но имеют доступ к входным данным, аналогичным тем, которые используются в производстве (например, с такими же входными формами). Кроме того, сгенерированные движки TRT зависят от платформы, поэтому нам нужно запускать &lt;code&gt;build()&lt;/code&gt; в среде, аналогичной производственной (например, с таким же типом GPU).</target>
        </trans-unit>
        <trans-unit id="d79a01d9608f76fd6bbb337a8da6d7bca3045f57" translate="yes" xml:space="preserve">
          <source>In your function passed to &lt;a href=&quot;../../../distribute/strategy#experimental_run_v2&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt;&lt;/a&gt;, compute a list of (update, variable) pairs. For example, the update might be a the gradient of the loss with respect to the variable.</source>
          <target state="translated">В вашей функции, переданной в &lt;a href=&quot;../../../distribute/strategy#experimental_run_v2&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt; &lt;/a&gt; , вычислите список пар (обновление, переменная). Например, обновление может быть градиентом потерь по переменной.</target>
        </trans-unit>
        <trans-unit id="49a3474d0eadcec0f5e50cac1d06d710f2afe071" translate="yes" xml:space="preserve">
          <source>In your function passed to &lt;a href=&quot;../../../distribute/strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt;, compute a list of (update, variable) pairs. For example, the update might be a gradient of the loss with respect to the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2be7b3f65cefd5207608f7e806a86637c30fe91" translate="yes" xml:space="preserve">
          <source>In your function passed to &lt;a href=&quot;strategy#experimental_run_v2&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt;&lt;/a&gt;, compute a list of (update, variable) pairs. For example, the update might be a the gradient of the loss with respect to the variable.</source>
          <target state="translated">В вашей функции, переданной в &lt;a href=&quot;strategy#experimental_run_v2&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt; &lt;/a&gt; , вычислите список пар (обновление, переменная). Например, обновление может быть градиентом потерь по переменной.</target>
        </trans-unit>
        <trans-unit id="a83b0c1dab2d4de5a70f6316ecc8989d437aa351" translate="yes" xml:space="preserve">
          <source>In your function passed to &lt;a href=&quot;strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt;, compute a list of (update, variable) pairs. For example, the update might be a gradient of the loss with respect to the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f49734e2288a63e9d6cf105bcbf81ab57a1bf7f" translate="yes" xml:space="preserve">
          <source>InTopK</source>
          <target state="translated">InTopK</target>
        </trans-unit>
        <trans-unit id="29498645b8e9de5e6fa1f035894033a32dcc0f61" translate="yes" xml:space="preserve">
          <source>InTopKV2</source>
          <target state="translated">InTopKV2</target>
        </trans-unit>
        <trans-unit id="ce8d799de35e2f145c21e92a425ca2ee660eb326" translate="yes" xml:space="preserve">
          <source>Inception V3 model for Keras.</source>
          <target state="translated">Начало V3 модель для Keras.</target>
        </trans-unit>
        <trans-unit id="7d73f3eef76607d1a301c6ca302e845c6db2ac6e" translate="yes" xml:space="preserve">
          <source>Inception-ResNet V2 model for Keras.</source>
          <target state="translated">Модель Inception-ResNet V2 для Keras.</target>
        </trans-unit>
        <trans-unit id="8cf033bd7091b2790e4f777f8b19874075bff1bf" translate="yes" xml:space="preserve">
          <source>Included for symmetry with assertIsInstance.</source>
          <target state="translated">Входит в комплект для симметрии с утверждениями.</target>
        </trans-unit>
        <trans-unit id="dcefd427b6a3fb13c379c178050dfc9a698717db" translate="yes" xml:space="preserve">
          <source>Included for symmetry with assertIsNone.</source>
          <target state="translated">Включено для симметрии с assertIsNone.</target>
        </trans-unit>
        <trans-unit id="dd470208c6fa4ca92528cf0186d20c9f5b2f59b7" translate="yes" xml:space="preserve">
          <source>Includes slot variables and additional global variables created by the optimizer in the current default graph.</source>
          <target state="translated">Включает в текущий график по умолчанию переменные слотов и дополнительные глобальные переменные,созданные оптимизатором.</target>
        </trans-unit>
        <trans-unit id="8c54bd291b44a258e4c2d45445c731a1166f33f9" translate="yes" xml:space="preserve">
          <source>Increases loss scale every &lt;code&gt;increment_period&lt;/code&gt; consecutive steps that finite gradients are encountered. If a nonfinite gradient is encountered, the count is reset back to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b7858555d1e2aa8307bbc5a543b25db84aeba7" translate="yes" xml:space="preserve">
          <source>Incremented when &lt;code&gt;save()&lt;/code&gt; is called. Used to number checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728ce17bd1a7957f53eadbd1391ef352561ac235" translate="yes" xml:space="preserve">
          <source>Increments 'ref' until it reaches 'limit'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b391a6fad790101cab029c9fe225295336e842c" translate="yes" xml:space="preserve">
          <source>Increments 'ref' until it reaches 'limit'. (deprecated)</source>
          <target state="translated">Увеличивает &quot;ссылка&quot;,пока не достигнет &quot;предела&quot;.(устарело)</target>
        </trans-unit>
        <trans-unit id="de594db0e57668b8b85789cc78fb4c139b3a182a" translate="yes" xml:space="preserve">
          <source>Increments this variable until it reaches &lt;code&gt;limit&lt;/code&gt;. (deprecated)</source>
          <target state="translated">Увеличивает эту переменную, пока не достигнет &lt;code&gt;limit&lt;/code&gt; . (не рекомендуется)</target>
        </trans-unit>
        <trans-unit id="b394c28b7279ea2928e8eb6964bdab03004d76bb" translate="yes" xml:space="preserve">
          <source>Increments variable pointed to by 'resource' until it reaches 'limit'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb762cdb787c49b81cc06d51b455e4a3ecd0341" translate="yes" xml:space="preserve">
          <source>Index of current step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d219bcbd2ca8f15aeb03cccca9e989e6dc9c7d0" translate="yes" xml:space="preserve">
          <source>Indexing into a 3-tensor:</source>
          <target state="translated">Индексация в 3 тензора:</target>
        </trans-unit>
        <trans-unit id="5e79dd26697e6bbf367b2fdeab36765d539b5fbd" translate="yes" xml:space="preserve">
          <source>Indicate that a summary was computed.</source>
          <target state="translated">Укажите,что было составлено резюме.</target>
        </trans-unit>
        <trans-unit id="82dbc404b49d6777aa92664b08fd68f890d9eccb" translate="yes" xml:space="preserve">
          <source>Indicates how a distributed variable will be aggregated.</source>
          <target state="translated">Показывает,как распределенная переменная будет агрегирована.</target>
        </trans-unit>
        <trans-unit id="355fab5dece9905786ed039c29043ef923b3adf5" translate="yes" xml:space="preserve">
          <source>Indicates how a distributed variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;../../variableaggregation&quot;&gt;&lt;code&gt;tf.VariableAggregation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f0ecce80ce2d885c3b8c2bb0d0238071880b87" translate="yes" xml:space="preserve">
          <source>Indicates how a distributed variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;variableaggregation&quot;&gt;&lt;code&gt;tf.VariableAggregation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8aeb2df9b17e0f40b4d8f5858f3321132bd0c3" translate="yes" xml:space="preserve">
          <source>Indicates how a set of values should be reduced.</source>
          <target state="translated">Указывает,как следует уменьшить набор значений.</target>
        </trans-unit>
        <trans-unit id="502061f2d3846ae3f85cff4075516765180924ed" translate="yes" xml:space="preserve">
          <source>Indicates that &lt;code&gt;batch_shape == []&lt;/code&gt;.</source>
          <target state="translated">Указывает, что &lt;code&gt;batch_shape == []&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f2a3ecc77c9bfd142bdfa3269a1a531f475325d" translate="yes" xml:space="preserve">
          <source>Indicates that &lt;code&gt;event_shape == []&lt;/code&gt;.</source>
          <target state="translated">Указывает, что &lt;code&gt;event_shape == []&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f9580d405e3ceadc7ccac78cfd939bcd2065bff" translate="yes" xml:space="preserve">
          <source>Indicates when a distributed a variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;../../variablesynchronization&quot;&gt;&lt;code&gt;tf.VariableSynchronization&lt;/code&gt;&lt;/a&gt;. By default the synchronization is set to &lt;code&gt;AUTO&lt;/code&gt; and the current &lt;code&gt;DistributionStrategy&lt;/code&gt; chooses when to synchronize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d6c4f854b8135221915994629436858fce328c" translate="yes" xml:space="preserve">
          <source>Indicates when a distributed a variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;../../variablesynchronization&quot;&gt;&lt;code&gt;tf.VariableSynchronization&lt;/code&gt;&lt;/a&gt;. By default the synchronization is set to &lt;code&gt;AUTO&lt;/code&gt; and the current &lt;code&gt;DistributionStrategy&lt;/code&gt; chooses when to synchronize. If &lt;code&gt;synchronization&lt;/code&gt; is set to &lt;code&gt;ON_READ&lt;/code&gt;, &lt;code&gt;trainable&lt;/code&gt; must not be set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585b652a60535a87a9ca42ef02672c3d4be7441b" translate="yes" xml:space="preserve">
          <source>Indicates when a distributed a variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;variablesynchronization&quot;&gt;&lt;code&gt;tf.VariableSynchronization&lt;/code&gt;&lt;/a&gt;. By default the synchronization is set to &lt;code&gt;AUTO&lt;/code&gt; and the current &lt;code&gt;DistributionStrategy&lt;/code&gt; chooses when to synchronize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b98b1943a15cc44f7a930e94a7aaa9be7ea89a2e" translate="yes" xml:space="preserve">
          <source>Indicates when a distributed variable will be synced.</source>
          <target state="translated">Указывает,когда будет синхронизирована распределенная переменная.</target>
        </trans-unit>
        <trans-unit id="8c75d22921ecccc2882756dcd16f765287e01395" translate="yes" xml:space="preserve">
          <source>Indicates which piece of the RaggedTensor to return, using standard Python semantics (e.g., negative values index from the end). &lt;code&gt;key&lt;/code&gt; may have any of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd9ad5b5718ae90949c420290ff39b5e8317055" translate="yes" xml:space="preserve">
          <source>Indices are output in row-major order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bea990e2e30a7eb039911159d0ee2d92ff71de" translate="yes" xml:space="preserve">
          <source>Indices must be without repeats. This is only tested if &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Индексы должны быть без повторов. Это проверяется, только если &lt;code&gt;validate_indices&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d1e9061deb0780f8cf8761707437290ba05e6b" translate="yes" xml:space="preserve">
          <source>Indices of elements to mask.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f1e52513d8b0a7cd11c918b2299a04adcf6867" translate="yes" xml:space="preserve">
          <source>Indices of the sparse gradient to be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afd7134a89ddbe19e6cadca6ca3f19798d1fd1c" translate="yes" xml:space="preserve">
          <source>Indices should be sorted in lexicographic order, and indices must not contain any repeats. If &lt;code&gt;validate_indices&lt;/code&gt; is True, these properties are checked during execution.</source>
          <target state="translated">Индексы должны быть отсортированы в лексикографическом порядке, и индексы не должны содержать повторов. Если &lt;code&gt;validate_indices&lt;/code&gt; имеет значение True, эти свойства проверяются во время выполнения.</target>
        </trans-unit>
        <trans-unit id="1c195df5805c1138eb51a9a5c959d8b14d48139b" translate="yes" xml:space="preserve">
          <source>Indices should be sorted in lexicographic order, and indices must not contain any repeats. If &lt;code&gt;validate_indices&lt;/code&gt; is true, these properties are checked during execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e0ca5db01771d327910e5e9f88826a2e60ad47" translate="yes" xml:space="preserve">
          <source>InfeedDequeue</source>
          <target state="translated">InfeedDequeue</target>
        </trans-unit>
        <trans-unit id="bcf6bd551bdd1dc178e212ec66098733e64b69f4" translate="yes" xml:space="preserve">
          <source>InfeedDequeueTuple</source>
          <target state="translated">InfeedDequeueTuple</target>
        </trans-unit>
        <trans-unit id="63af23d2efb54dff58bbef1e77ed37bbb7276cc1" translate="yes" xml:space="preserve">
          <source>InfeedEnqueue</source>
          <target state="translated">InfeedEnqueue</target>
        </trans-unit>
        <trans-unit id="149c1ecf9aec0d9d6cc77516abaf46375e31a222" translate="yes" xml:space="preserve">
          <source>InfeedEnqueuePrelinearizedBuffer</source>
          <target state="translated">InfeedEnqueuePrelinearizedBuffer</target>
        </trans-unit>
        <trans-unit id="f3de6b03c8e3115d2e11421b93ac58353f46116c" translate="yes" xml:space="preserve">
          <source>InfeedEnqueueTuple</source>
          <target state="translated">InfeedEnqueueTuple</target>
        </trans-unit>
        <trans-unit id="6b68b09f9769efecac45bf8fdca33e3d2565957a" translate="yes" xml:space="preserve">
          <source>Information about a command-line flag.</source>
          <target state="translated">Информация о флаге командной строки.</target>
        </trans-unit>
        <trans-unit id="ec0acf85df4b3add32f27c24edcda3c4ac12ef0c" translate="yes" xml:space="preserve">
          <source>Information on how to save this Variable as a slice.</source>
          <target state="translated">Информация о том,как сохранить эту Переменную как кусочек.</target>
        </trans-unit>
        <trans-unit id="0e51852bd546da5f45f8e214683a1a350100bb05" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/categoryencoding&quot;&gt;&lt;code&gt;CategoryEncoding&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baac1737720873667a943deae5dfc7a9206719a0" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/integerlookup&quot;&gt;&lt;code&gt;IntegerLookup&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f51cd32183bed67eebdc24505fe9c60be0ff24" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/normalization&quot;&gt;&lt;code&gt;Normalization&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/normalization&quot;&gt; &lt;code&gt;Normalization&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc4f19f5f5a1aae8d9a70979bdc84b8879158d3e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/stringlookup&quot;&gt;&lt;code&gt;StringLookup&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d16843c9ea341a1347986bb59d03f16c9fb7aa" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/textvectorization&quot;&gt;&lt;code&gt;TextVectorization&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/textvectorization&quot;&gt; &lt;code&gt;TextVectorization&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97a31c19a22414ef8ef5f357f1617f4cc1d647c1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../estimator/runconfig&quot;&gt;&lt;code&gt;RunConfig&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../../estimator/runconfig&quot;&gt; &lt;code&gt;RunConfig&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3d75bd146887dd05312c665b5ee9485003d0b9e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../keras/callbacks/callback&quot;&gt;&lt;code&gt;Callback&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;../../../../keras/callbacks/callback&quot;&gt; &lt;code&gt;Callback&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="137a14a45c0bb4c7ff0cd0805c170a01887b76aa" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../keras/callbacks/tensorboard&quot;&gt;&lt;code&gt;TensorBoard&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f48823b67183fe4d3982fdf099fd964de492638" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../keras/layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../../keras/layers/layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="101288461115cd97710e1c4a718e36857f88eeb0" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../keras/layers/rnn&quot;&gt;&lt;code&gt;RNN&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../../keras/layers/rnn&quot;&gt; &lt;code&gt;RNN&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c98cf787068e63e655af32c1f75becc1009cb055" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;Dataset&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;Dataset&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b69b334b62f492a552001cca525723b81da0f8c3" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;Strategy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;Strategy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92ca55cab0329d064ac4fac10f97a987dd809443" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../distribute/strategyextended&quot;&gt;&lt;code&gt;StrategyExtended&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../distribute/strategyextended&quot;&gt; &lt;code&gt;StrategyExtended&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce2f291600404f60ebcf454fa3465a5983be16e9" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/averagepooling1d&quot;&gt;&lt;code&gt;AveragePooling1D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;../../../keras/layers/averagepooling1d&quot;&gt; &lt;code&gt;AveragePooling1D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42a8a44e1d03faeea5270e723f842a3c2b65a425" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/averagepooling2d&quot;&gt;&lt;code&gt;AveragePooling2D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;../../../keras/layers/averagepooling2d&quot;&gt; &lt;code&gt;AveragePooling2D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1dbcb4046a301b62c85eab641c002d5100bb5b1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/averagepooling3d&quot;&gt;&lt;code&gt;AveragePooling3D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;../../../keras/layers/averagepooling3d&quot;&gt; &lt;code&gt;AveragePooling3D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f3c972c579e20efad3f3479906c3fc65c603f93" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv1d&quot;&gt;&lt;code&gt;Conv1D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/conv1d&quot;&gt; &lt;code&gt;Conv1D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f254da78653b4606006651809bbe544bb36c261f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv2d&quot;&gt;&lt;code&gt;Conv2D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/conv2d&quot;&gt; &lt;code&gt;Conv2D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0effe74634550b4623dd89f19fb3491982b74c2" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv2dtranspose&quot;&gt;&lt;code&gt;Conv2DTranspose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/conv2dtranspose&quot;&gt; &lt;code&gt;Conv2DTranspose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f697c3bc6da2ce250b73eefb92542a6c67912d6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv3d&quot;&gt;&lt;code&gt;Conv3D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/conv3d&quot;&gt; &lt;code&gt;Conv3D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8a3fb6f41c3a9e4dc192dd3ed365c7f15d77fc2" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv3dtranspose&quot;&gt;&lt;code&gt;Conv3DTranspose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/conv3dtranspose&quot;&gt; &lt;code&gt;Conv3DTranspose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29b1fcf2404228be9923887f99e1f80308a0f551" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/dense&quot;&gt;&lt;code&gt;Dense&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/dense&quot;&gt; &lt;code&gt;Dense&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0af60cb1a6134b54526b90870c8a41324c86484" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/dropout&quot;&gt;&lt;code&gt;Dropout&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/dropout&quot;&gt; &lt;code&gt;Dropout&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e68321961235af8baeb6a5bf163c3912867702ac" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/flatten&quot;&gt;&lt;code&gt;Flatten&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/flatten&quot;&gt; &lt;code&gt;Flatten&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc8c1e4f9a9c221452851820ebe247974471806e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28a3a29fe589494fc0af3d023b9cb3692724e795" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/maxpool1d&quot;&gt;&lt;code&gt;MaxPool1D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;../../../keras/layers/maxpool1d&quot;&gt; &lt;code&gt;MaxPool1D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7584250f981dacb4544b81a0445f6abdf4dac4c8" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/maxpool2d&quot;&gt;&lt;code&gt;MaxPool2D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;../../../keras/layers/maxpool2d&quot;&gt; &lt;code&gt;MaxPool2D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="154fe6589fea17c9dbbfd13300c3302b5cbec52a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/maxpool3d&quot;&gt;&lt;code&gt;MaxPool3D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../keras/layers/maxpool3d&quot;&gt; &lt;code&gt;MaxPool3D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7ff649eddfed113ec4b0f9190c07241e844f314" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/separableconv1d&quot;&gt;&lt;code&gt;SeparableConv1D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;../../../keras/layers/separableconv1d&quot;&gt; &lt;code&gt;SeparableConv1D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76bebda566676ef2b3fefccf517c4294e818101f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/separableconv2d&quot;&gt;&lt;code&gt;SeparableConv2D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;../../../keras/layers/separableconv2d&quot;&gt; &lt;code&gt;SeparableConv2D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0a3c9aaf5c80873ddedbb167634670d3320e6f1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../lookup/statichashtable&quot;&gt;&lt;code&gt;StaticHashTable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../lookup/statichashtable&quot;&gt; &lt;code&gt;StaticHashTable&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a3bebd87957ebec2bdeed2ec6c3fd343e87182a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../lookup/staticvocabularytable&quot;&gt;&lt;code&gt;StaticVocabularyTable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../../lookup/staticvocabularytable&quot;&gt; &lt;code&gt;StaticVocabularyTable&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1684aa0ac086b4c33905e11ca938ca00eeb69e59" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/estimator/estimator&quot;&gt;&lt;code&gt;Estimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../compat/v1/estimator/estimator&quot;&gt; &lt;code&gt;Estimator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aefa14b86c312089f44417b29a0fefe55dd55580" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/densefeatures&quot;&gt;&lt;code&gt;DenseFeatures&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../compat/v1/keras/layers/densefeatures&quot;&gt; &lt;code&gt;DenseFeatures&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb19ef7b8a7a993bf890f5f9f8e3aa82a58da54c" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/gru&quot;&gt;&lt;code&gt;GRU&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../compat/v1/keras/layers/gru&quot;&gt; &lt;code&gt;GRU&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25bbb6425736acc7eba310b4733d000e527fdb41" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/grucell&quot;&gt;&lt;code&gt;GRUCell&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../compat/v1/keras/layers/grucell&quot;&gt; &lt;code&gt;GRUCell&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a6399774002d5547cc32cc9d4b9edee523ac71de" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/lstm&quot;&gt;&lt;code&gt;LSTM&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../compat/v1/keras/layers/lstm&quot;&gt; &lt;code&gt;LSTM&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6e365aef9a953772960e2a2d0594d4484de5f37" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/lstmcell&quot;&gt;&lt;code&gt;LSTMCell&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../compat/v1/keras/layers/lstmcell&quot;&gt; &lt;code&gt;LSTMCell&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61def0c79e4e14034ebc42dd5e16bbb937237db8" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../devicespec&quot;&gt;&lt;code&gt;DeviceSpec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../devicespec&quot;&gt; &lt;code&gt;DeviceSpec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e22d1fd60d17bfd6bb8dea29e2d168c3d11cab79" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../estimator/sessionrunhook&quot;&gt;&lt;code&gt;SessionRunHook&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../estimator/sessionrunhook&quot;&gt; &lt;code&gt;SessionRunHook&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c823efc68822885dff47a787a20718225f30976c" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0253e6a8463328df70cf0bde386ae58d5d4a52b3" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../layers/layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d380ebfc4ac0e11225bf40c85216fcb9ab9ca5be" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ac000ff3e9397e03d5c9b3dd15afcd623075932" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../ones_initializer&quot;&gt;&lt;code&gt;ones_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431bc7dc03654938db639520210941a6890ffea2" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../optimizers/optimizer&quot;&gt;&lt;code&gt;Optimizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../optimizers/optimizer&quot;&gt; &lt;code&gt;Optimizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e1cf9747c58dbedac3aa16db0a27265a12d8699" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../random_normal_initializer&quot;&gt;&lt;code&gt;random_normal_initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../random_normal_initializer&quot;&gt; &lt;code&gt;random_normal_initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c23d9d73d8c84d12ce7849fdfb684631d2c7f4d1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../random_normal_initializer&quot;&gt;&lt;code&gt;random_normal_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7949d09e2384198677c50c86af2bf0ed68fd209" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../random_uniform_initializer&quot;&gt;&lt;code&gt;random_uniform_initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../random_uniform_initializer&quot;&gt; &lt;code&gt;random_uniform_initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b8b6d3e6850689ca8d44a060f6f5dacbcbb2309" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../random_uniform_initializer&quot;&gt;&lt;code&gt;random_uniform_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e65a22887b2ddde41692586ecc0c1e8dec9c5b" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../truncated_normal_initializer&quot;&gt;&lt;code&gt;truncated_normal_initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;../../truncated_normal_initializer&quot;&gt; &lt;code&gt;truncated_normal_initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1829a659c829a9f36645de8ac301505b51be50d6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../utils/sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../utils/sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0e5a6aee3812cf9bfb851074c2d13a47b335f5d" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../variable&quot;&gt;&lt;code&gt;Variable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../../variable&quot;&gt; &lt;code&gt;Variable&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b72a646568595cd082eabef4131c846b923b5942" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../zeros_initializer&quot;&gt;&lt;code&gt;zeros_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b555e28ab5ffb41e3c4dc14c70bf133942c54b2c" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../callback&quot;&gt;&lt;code&gt;Callback&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9bc9d9bcf253cedabcee6c97ec168ce829644a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../compat/v1/estimator/estimator&quot;&gt;&lt;code&gt;Estimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../compat/v1/estimator/estimator&quot;&gt; &lt;code&gt;Estimator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25426e2a5713897c0289518989a9cd3a8db983ff" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../estimator&quot;&gt;&lt;code&gt;Estimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../estimator&quot;&gt; &lt;code&gt;Estimator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="080d3ec42c2add7514a21ad699a8fc4784f62dcf" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../keras/layers/batchnormalization&quot;&gt;&lt;code&gt;BatchNormalization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../keras/layers/batchnormalization&quot;&gt; &lt;code&gt;BatchNormalization&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7fd82eb6ae25585268bdb2e754aa9b0cea42c0fc" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ccbe17f941cfb541dacdc6e6f8df9e364e9903" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../layers/layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3343ff80aad6eccce0b0ff9a92e6f1138ded04de" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../model&quot;&gt;&lt;code&gt;Model&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../model&quot;&gt; &lt;code&gt;Model&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9bc653a3de4a5b711fa178780efa227044183c6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bae83d89b65139dbc57c20256c7416930811a62f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../optimizer&quot;&gt;&lt;code&gt;Optimizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../optimizer&quot;&gt; &lt;code&gt;Optimizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4dfd48c0fad88d69677a52e92941c20045e7f8d" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../optimizers/schedules/learningrateschedule&quot;&gt;&lt;code&gt;LearningRateSchedule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../optimizers/schedules/learningrateschedule&quot;&gt; &lt;code&gt;LearningRateSchedule&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bac031a4f0d93559c0b5a038481a55db80bffb1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../sessionrunhook&quot;&gt;&lt;code&gt;SessionRunHook&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../sessionrunhook&quot;&gt; &lt;code&gt;SessionRunHook&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1e8fe6f775917267679cd58b67ba07d4031d153" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;Strategy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../strategy&quot;&gt; &lt;code&gt;Strategy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e7d0440491afa6fb0a72459e5330c1c6c5f3a9fd" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../train/optimizer&quot;&gt;&lt;code&gt;Optimizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;../train/optimizer&quot;&gt; &lt;code&gt;Optimizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09f24deac9eb963d66c92025a28b74323dca2a37" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../typespec&quot;&gt;&lt;code&gt;TypeSpec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac0a165f2cf448ecb4b394e261add8aee2b6e02" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;argumentparser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;argumentparser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b53c52c65f50149ff85e0e72be5e18e5ebd0627" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;argumentserializer&quot;&gt;&lt;code&gt;ArgumentSerializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;argumentserializer&quot;&gt; &lt;code&gt;ArgumentSerializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80e09409191cf57a51dbc558605c61bf1e959f0f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;baselistparser&quot;&gt;&lt;code&gt;BaseListParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;baselistparser&quot;&gt; &lt;code&gt;BaseListParser&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc4c26c0cc8fd71ef96bcb06650fc6ea34b1a676" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;callback&quot;&gt;&lt;code&gt;Callback&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;callback&quot;&gt; &lt;code&gt;Callback&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37a3e2923879231076529ff16964e3254f28644a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;clusterresolver&quot;&gt;&lt;code&gt;ClusterResolver&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;clusterresolver&quot;&gt; &lt;code&gt;ClusterResolver&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f56dfe51ff751c5c35642aef72a91e03dc8eb325" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;conditionalaccumulatorbase&quot;&gt;&lt;code&gt;ConditionalAccumulatorBase&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;conditionalaccumulatorbase&quot;&gt; &lt;code&gt;ConditionalAccumulatorBase&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4451c0007ffb8c85d8049d366dd976e53638d7d6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;constraint&quot;&gt;&lt;code&gt;Constraint&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;constraint&quot;&gt; &lt;code&gt;Constraint&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e4caf5e5194b7ac96cde7a55cf4136f8f46fdba" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;conv1d&quot;&gt;&lt;code&gt;Conv1D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf3bf045963ef0e24f8894a2e9152ee83749492" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;conv2d&quot;&gt;&lt;code&gt;Conv2D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;conv2d&quot;&gt; &lt;code&gt;Conv2D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="283b19ef5cabdd9464503df3847e05e6683b4c31" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;conv3d&quot;&gt;&lt;code&gt;Conv3D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;conv3d&quot;&gt; &lt;code&gt;Conv3D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f2e2d2138c18dd431317480b04654c2a90d72819" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;crossdeviceops&quot;&gt;&lt;code&gt;CrossDeviceOps&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;crossdeviceops&quot;&gt; &lt;code&gt;CrossDeviceOps&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="22140b78b2e4625ecb8d6cb9f4e06748658330fb" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;dataset&quot;&gt;&lt;code&gt;Dataset&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;dataset&quot;&gt; &lt;code&gt;Dataset&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa02fcf49761dd366a56034083175af69d0964fc" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;distribution&quot;&gt;&lt;code&gt;Distribution&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;distribution&quot;&gt; &lt;code&gt;Distribution&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b51b20c1f658b10e05c97ac0210ccc81f121087" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;dropout&quot;&gt;&lt;code&gt;Dropout&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;dropout&quot;&gt; &lt;code&gt;Dropout&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e878e37e306fee3dbc483d11717bf9341c22b53e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5dfc58dfa8f92ceeec773d4079a01572ca2cd806" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;estimator&quot;&gt;&lt;code&gt;Estimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;estimator&quot;&gt; &lt;code&gt;Estimator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a2ae2c02899c2e4f78d776e809915721c13881a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;exporter&quot;&gt;&lt;code&gt;Exporter&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;exporter&quot;&gt; &lt;code&gt;Exporter&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58dcf205446e67668da4cee5c19d32d67d820dc8" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;exportoutput&quot;&gt;&lt;code&gt;ExportOutput&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;exportoutput&quot;&gt; &lt;code&gt;ExportOutput&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84e5436e8e1add9f0b776920cdc41d900f226bb9" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0db0c480f0cb5392640cfdd5f72b4e7ae28a556" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;gamma&quot;&gt;&lt;code&gt;Gamma&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;gamma&quot;&gt; &lt;code&gt;Gamma&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ef4a4c2192c1e1137ac1cdc387d568a072f314d" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;head&quot;&gt;&lt;code&gt;Head&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;head&quot;&gt; &lt;code&gt;Head&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e6a2ad1e98cf96c2f87570045e8cc2185aec4bd" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a30dfeb3ba7f1f880dbdb0a428cbd9056f33e550" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea34304998eb45063cccb9f7518ed59ed029b3fb" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;keras/initializers/initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;keras/initializers/initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="208224ad9829e548920e4711cb9800c0bbf02a79" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1074de264eed43a2c35c1e9e34add7d6f6407038" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23330460480edbb4fc738157f7a5471232f7c83" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;learningrateschedule&quot;&gt;&lt;code&gt;LearningRateSchedule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;learningrateschedule&quot;&gt; &lt;code&gt;LearningRateSchedule&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a1c3867710811bb11042f959bfcb4d5f8b519a0" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;linearoperator&quot;&gt;&lt;code&gt;LinearOperator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;linearoperator&quot;&gt; &lt;code&gt;LinearOperator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f62175fd1a3fcbb5f5a876a78c6edd7356485def" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;lossscale&quot;&gt;&lt;code&gt;LossScale&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;lossscale&quot;&gt; &lt;code&gt;LossScale&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb33eb889582345ba3f1d78863f8d00b235c5ee1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;mean&quot;&gt;&lt;code&gt;Mean&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;mean&quot;&gt; &lt;code&gt;Mean&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23b8f0e2c60442efd1f3f24a1b9098b8e3720a04" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;metric&quot;&gt;&lt;code&gt;Metric&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;metric&quot;&gt; &lt;code&gt;Metric&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3491dcb6475f6cdcd9bfbfb9a50f3b524fc4f8b0" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;model&quot;&gt;&lt;code&gt;Model&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;model&quot;&gt; &lt;code&gt;Model&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d14b97aeea22bcdb096843d7cfb8024f32a8d496" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;multiflag&quot;&gt;&lt;code&gt;MultiFlag&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;multiflag&quot;&gt; &lt;code&gt;MultiFlag&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80158f4961cf1668db5fd8c4f7cefdd6b4f0b29a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;operror&quot;&gt;&lt;code&gt;OpError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;operror&quot;&gt; &lt;code&gt;OpError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d0af4ebd255fd6f617c8d538add3730d1f29225" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;optimizer&quot;&gt;&lt;code&gt;Optimizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;optimizer&quot;&gt; &lt;code&gt;Optimizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="04c2e54a79367272f125c78e8460cacd30e00ebd" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;queuebase&quot;&gt;&lt;code&gt;QueueBase&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;queuebase&quot;&gt; &lt;code&gt;QueueBase&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ccbec78a7b42e602f358942d26c9d05f169ed7c" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;readerbase&quot;&gt;&lt;code&gt;ReaderBase&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;readerbase&quot;&gt; &lt;code&gt;ReaderBase&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad0372cd2d15c62f344d2a9750b22878629b0740" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;regressionhead&quot;&gt;&lt;code&gt;RegressionHead&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;regressionhead&quot;&gt; &lt;code&gt;RegressionHead&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e3d5b150747f41525b95698f7bbd95312e28809" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;regularizer&quot;&gt;&lt;code&gt;Regularizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;regularizer&quot;&gt; &lt;code&gt;Regularizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41240b7c3505b27c7d0d17bd731d675d120e69a7" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;rnn&quot;&gt;&lt;code&gt;RNN&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;rnn&quot;&gt; &lt;code&gt;RNN&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d4bc99967778b197915dfb1e03b3aac7430e2d06" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;rnncell&quot;&gt;&lt;code&gt;RNNCell&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;rnncell&quot;&gt; &lt;code&gt;RNNCell&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92968f787ed32c0b2652202feacd0e1bb742a548" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;rnnestimator&quot;&gt;&lt;code&gt;RNNEstimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;rnnestimator&quot;&gt; &lt;code&gt;RNNEstimator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35b9f8a26efc7813a5fc71ac2e35eb36ea0752ed" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;sequenceenqueuer&quot;&gt;&lt;code&gt;SequenceEnqueuer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;sequenceenqueuer&quot;&gt; &lt;code&gt;SequenceEnqueuer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9097ee84e0043bad50f3732959fe4f03cde569e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;sessioncreator&quot;&gt;&lt;code&gt;SessionCreator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;sessioncreator&quot;&gt; &lt;code&gt;SessionCreator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f16acebe1259f779d2c3a0f7a4d97de5b66ad39f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;sessionrunhook&quot;&gt;&lt;code&gt;SessionRunHook&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;sessionrunhook&quot;&gt; &lt;code&gt;SessionRunHook&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78de757e66b0204e828d8e24b165b9614dcddef6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;stacktracefilter&quot;&gt;&lt;code&gt;StackTraceFilter&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;stacktracefilter&quot;&gt; &lt;code&gt;StackTraceFilter&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1314e1f7b68e8d2e740d84aa7ff167503f726bd3" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;stacktracetransform&quot;&gt;&lt;code&gt;StackTraceTransform&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;stacktracetransform&quot;&gt; &lt;code&gt;StackTraceTransform&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74e8664d5defb70dad460e27e606424d03ad7f8e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;Strategy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;Strategy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5b5461c11487a577320988d6c7910a14af6eabb" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;typespec&quot;&gt;&lt;code&gt;TypeSpec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;typespec&quot;&gt; &lt;code&gt;TypeSpec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7923ecf7967dad1a15ad737b679bd8050b2a8bd" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;variancescaling&quot;&gt;&lt;code&gt;VarianceScaling&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследует от: &lt;a href=&quot;variancescaling&quot;&gt; &lt;code&gt;VarianceScaling&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53c43532e5cbca0b52801f19115633789d7d2a84" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;wrapper&quot;&gt;&lt;code&gt;Wrapper&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Наследуется от: &lt;a href=&quot;wrapper&quot;&gt; &lt;code&gt;Wrapper&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3dde0fdb1c7620a5dbdcc30fcd0ab45a5b2ebfb" translate="yes" xml:space="preserve">
          <source>Initial seed for workers, will be incremented by one for each worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896a5ab9538c1a67c1f3e659ad90640e62f8b8da" translate="yes" xml:space="preserve">
          <source>Initialization:</source>
          <target state="translated">Initialization:</target>
        </trans-unit>
        <trans-unit id="6b4c4e02ed448c5a81def9a1e3687e52b103b145" translate="yes" xml:space="preserve">
          <source>Initialization: At creation time the hooked session does following things in given order:</source>
          <target state="translated">Инициализация:Во время создания сессия с подключением делает все в указанном порядке:</target>
        </trans-unit>
        <trans-unit id="08031e322fd9617e1573ed5dbfa09ff216adcc09" translate="yes" xml:space="preserve">
          <source>Initialization: At creation time the monitored session does following things in given order:</source>
          <target state="translated">Инициализация:Во время создания проконтролированная сессия делает следующие действия в заданном порядке:</target>
        </trans-unit>
        <trans-unit id="b0355561fecfea92594a45fdcb6ca88daca19bec" translate="yes" xml:space="preserve">
          <source>Initialize Categorical distributions using class log-probabilities. (deprecated)</source>
          <target state="translated">Инициализировать категориальные распределения,используя лог-возможности класса.(устаревший)</target>
        </trans-unit>
        <trans-unit id="eb53dcaa811ac7688015872c0307120a73670815" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorAdjoint&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="750f138f781c88fbb0701d39c348820ff999fad8" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f39eb5cba37cc32a15ef159441cb53292159952a" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorComposition&lt;/code&gt;.</source>
          <target state="translated">Инициализировать &lt;code&gt;LinearOperatorComposition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b05907b33c8a9de0c0979de3f32b251ac1c8aad" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorDiag&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorDiag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="693135b5de80f140c35b24fa0e2aef0094c05d68" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbd6633639933b006a538ab0aef4fdf5a8441992" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorHouseholder&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorHouseholder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fc6c13d8271533b4e0c6a52055f390134df1f4e" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorIdentity&lt;/code&gt;.</source>
          <target state="translated">Инициализировать &lt;code&gt;LinearOperatorIdentity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e00c7d507871b6245d20ab7f29a8de43b054e478" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorInversion&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorInversion&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d4e66ea801fb0915db2ab44c3588f99c13535da" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorKronecker&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorKronecker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eeb390cc0f4fac75926a62916c88ab4b661c42c4" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorLowRankUpdate&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorLowRankUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9d706bfa28f87040a2e0b40cdf0afbf7e16b64a" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorLowerTriangular&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorLowerTriangular&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7588d86ee76ca246898555ddb33325423ac0aa2d" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorPermutation&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorPermutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad616170739db723a76b2a6610fee8afdb496005" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorScaledIdentity&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorScaledIdentity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf523f71058bd9f6bac48a09bd89a7d0645d188b" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorToeplitz&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorToeplitz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac13eedefc7b6b32a2cd134693fd9e0177e8fcf6" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorZeros&lt;/code&gt;.</source>
          <target state="translated">Инициализировать &lt;code&gt;LinearOperatorZeros&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="738190cdc5cd301e6242cb86b444286367b38ff6" translate="yes" xml:space="preserve">
          <source>Initialize a batch of Beta distributions. (deprecated)</source>
          <target state="translated">Инициализировать партию бета-дистрибутивов.(устаревший)</target>
        </trans-unit>
        <trans-unit id="dc7ea2e4332b90aa477204eac854c35a52c9e897" translate="yes" xml:space="preserve">
          <source>Initialize a batch of Dirichlet distributions. (deprecated)</source>
          <target state="translated">Инициализируйте партию дистрибутивов Дирихлета.(устаревший)</target>
        </trans-unit>
        <trans-unit id="fc8d3695b732b4c84d7528c8d6686ac5b6c4efba" translate="yes" xml:space="preserve">
          <source>Initialize a batch of DirichletMultinomial distributions. (deprecated)</source>
          <target state="translated">Инициализируйте партию дирихлетом-многочисленных дистрибутивов.(устаревший)</target>
        </trans-unit>
        <trans-unit id="e92be9f5b309bd342947a735a43d5120077fec20" translate="yes" xml:space="preserve">
          <source>Initialize a batch of Multinomial distributions. (deprecated)</source>
          <target state="translated">Инициализировать партию мультиномиальных дистрибутивов.(устаревший)</target>
        </trans-unit>
        <trans-unit id="a08179d319a047367bc8f5fa7409bac517eae691" translate="yes" xml:space="preserve">
          <source>Initialize a batch of Uniform distributions. (deprecated)</source>
          <target state="translated">Инициализировать партию Унифицированных распределений.(устаревший)</target>
        </trans-unit>
        <trans-unit id="7176bd72795dadb8c783acaefcff5df66a240124" translate="yes" xml:space="preserve">
          <source>Initialize an &lt;code&gt;LinearOperatorCirculant2D&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorCirculant2D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b868fe74c4ce2558ee85147bd4de2aef5e9e70" translate="yes" xml:space="preserve">
          <source>Initialize an &lt;code&gt;LinearOperatorCirculant&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperatorCirculant&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8049ed73769cea9db916044a5c096b1780e5ad" translate="yes" xml:space="preserve">
          <source>Initialize ophint argument.</source>
          <target state="translated">Инициализируй аргумент оффициента.</target>
        </trans-unit>
        <trans-unit id="5f66672d1a211feccb2663e524389cc7bbdc9544" translate="yes" xml:space="preserve">
          <source>Initialize self. See help(type(self)) for accurate signature.</source>
          <target state="translated">Инициализируй себя.См.справку(type(self))для точной подписи.</target>
        </trans-unit>
        <trans-unit id="774126eedb486505371aeb53fcb908707fda92f1" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;code&gt;LinearOperator&lt;/code&gt;. (deprecated arguments)</source>
          <target state="translated">Инициализируйте &lt;code&gt;LinearOperator&lt;/code&gt; . (устаревшие аргументы)</target>
        </trans-unit>
        <trans-unit id="ab2e1f2d631fceec84acd055ae017bb35b138793" translate="yes" xml:space="preserve">
          <source>Initialize the KL registrar. (deprecated)</source>
          <target state="translated">Инициализируйте регистратора KL.(устаревший)</target>
        </trans-unit>
        <trans-unit id="a6ebdd831ac3202b3781c72a34d4adf2eae8f045" translate="yes" xml:space="preserve">
          <source>Initialize the TPU devices.</source>
          <target state="translated">Инициализируйте устройства TPU.</target>
        </trans-unit>
        <trans-unit id="92e2d30e35ba9382e113f9b082b909176f6d30a2" translate="yes" xml:space="preserve">
          <source>Initialize the basic LSTM cell. (deprecated)</source>
          <target state="translated">Инициализируйте основную ячейку LSTM.(устаревший)</target>
        </trans-unit>
        <trans-unit id="b590a960cba96e3ec2bd76607c374e10df648ac8" translate="yes" xml:space="preserve">
          <source>Initialize the context manager.</source>
          <target state="translated">Инициализируйте контекстного менеджера.</target>
        </trans-unit>
        <trans-unit id="fa67a798e83e54f567e4c72f649b904fcbc46e99" translate="yes" xml:space="preserve">
          <source>Initialize the converter.</source>
          <target state="translated">Инициализируйте преобразователь.</target>
        </trans-unit>
        <trans-unit id="bc16e43bd3119b5ee14cd85b3e95a73c462f9e60" translate="yes" xml:space="preserve">
          <source>Initialize the parameters for an LSTM cell.</source>
          <target state="translated">Инициализируйте параметры ячейки LSTM.</target>
        </trans-unit>
        <trans-unit id="a276f0d2cb8c74827ade5547808ad2460ab61df8" translate="yes" xml:space="preserve">
          <source>Initialize the parameters for an LSTM cell. (deprecated)</source>
          <target state="translated">Инициализируйте параметры ячейки LSTM.(устаревший)</target>
        </trans-unit>
        <trans-unit id="f8de61c60cae88e66471bf5bc57e9c4fbd41701f" translate="yes" xml:space="preserve">
          <source>InitializeTable</source>
          <target state="translated">InitializeTable</target>
        </trans-unit>
        <trans-unit id="5aed30f7b6fc98dc524f5833e005c4e4ec7a42cb" translate="yes" xml:space="preserve">
          <source>InitializeTableFromDataset</source>
          <target state="translated">InitializeTableFromDataset</target>
        </trans-unit>
        <trans-unit id="7c3bd8734fc960e9600fa97e6141676591a46831" translate="yes" xml:space="preserve">
          <source>InitializeTableFromTextFile</source>
          <target state="translated">InitializeTableFromTextFile</target>
        </trans-unit>
        <trans-unit id="c2a3468a32393944b646bf84f4d3a50fe75c3793" translate="yes" xml:space="preserve">
          <source>InitializeTableFromTextFileV2</source>
          <target state="translated">InitializeTableFromTextFileV2</target>
        </trans-unit>
        <trans-unit id="d595985e2c5ded73f4a9de35a2d130afb6f8c587" translate="yes" xml:space="preserve">
          <source>InitializeTableV2</source>
          <target state="translated">InitializeTableV2</target>
        </trans-unit>
        <trans-unit id="444bc80fd9904870633d2e8861ecfda9efc99b9c" translate="yes" xml:space="preserve">
          <source>Initializer base class: all Keras initializers inherit from this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0a3f70258a349042e3af55ded6d87eee852d82" translate="yes" xml:space="preserve">
          <source>Initializer base class: all initializers inherit from this class.</source>
          <target state="translated">Базовый класс инициализатора:все инициализаторы наследуют от этого класса.</target>
        </trans-unit>
        <trans-unit id="7408f1164bc8abcd3cd06ec2d69e780bd33dcfc9" translate="yes" xml:space="preserve">
          <source>Initializer capable of adapting its scale to the shape of weights tensors.</source>
          <target state="translated">Инициализатор,способный адаптировать свою шкалу к форме тензоров весов.</target>
        </trans-unit>
        <trans-unit id="3f3e650f5d31cec8ee9c79d6f7e362575199454d" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;embeddings&lt;/code&gt; matrix (see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4d0f3ab47bea318b1c37c93519d1a1da732eeb" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba628f9ea30369bd578dc8d48cd1e3d28bf5c41" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix ( see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba55c172dc5eab60693e689ec7fb38d97b36486" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix (see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e262bd0196c6fec5362e38ce4fd7bd8f850ecb" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix, used for the linear transformation of the inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781ea722b1bd54fe46786e4b204fb94df6ff4f4f" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix, used for the linear transformation of the inputs. Default: &lt;code&gt;glorot_uniform&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c20a701e64041d46893780c75432a86bf96c2ef" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix, used for the linear transformation of the inputs..</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c985b4c4c3a2d5a5db286eb608a6aaa41c24744" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4305dd5a4f4497e59c08e01b2b9016f38ddc44" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix, used for the linear transformation of the recurrent state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4be5e35088634a9fc1d3d2f991d38a5e1787388" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix, used for the linear transformation of the recurrent state. Default: &lt;code&gt;orthogonal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af38116f02da6c39b58cc8da4c28be61a81d876" translate="yes" xml:space="preserve">
          <source>Initializer for the beta weight.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d51bc1b3c7639715a0b517ddb1db22866613a8" translate="yes" xml:space="preserve">
          <source>Initializer for the beta weight. Defaults to zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e4f24e2d42625333b9e3d5b356c24fd8e1ddcd" translate="yes" xml:space="preserve">
          <source>Initializer for the bias vector ( see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db262f6cbeba981795f8d7953bf4533bf6250526" translate="yes" xml:space="preserve">
          <source>Initializer for the bias vector (see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f2ea2379cb97d28a3c54f26c8c1f8072222138c" translate="yes" xml:space="preserve">
          <source>Initializer for the bias vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f270770d498ec4fc3655cf0eb9baa466587762d" translate="yes" xml:space="preserve">
          <source>Initializer for the bias vector. Default: &lt;code&gt;zeros&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5201cba3e441bccae15337f6e669e493ac9d21b9" translate="yes" xml:space="preserve">
          <source>Initializer for the depthwise kernel matrix ( see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9928e7831c90bb494792ace6d7b7f956169e16ae" translate="yes" xml:space="preserve">
          <source>Initializer for the gamma weight.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add6797439df2873a8707c82ca252f6c8be936c5" translate="yes" xml:space="preserve">
          <source>Initializer for the gamma weight. Defaults to ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ecf7540e5a3ff8d2e0717705278320e8321a60" translate="yes" xml:space="preserve">
          <source>Initializer for the moving mean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f890659b046c43e8f9396b0f7812624e17bdaae2" translate="yes" xml:space="preserve">
          <source>Initializer for the moving variance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629a0ebdff9c5f3c21412ceaf83712cd99c7c93e" translate="yes" xml:space="preserve">
          <source>Initializer for the pointwise kernel matrix ( see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de36279d1a9e86d4e1cde4822bb5ee964eb2fb05" translate="yes" xml:space="preserve">
          <source>Initializer for the variable if one is created. Can either be an initializer object or a Tensor. If it's a Tensor, its shape must be known unless validate_shape is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23be94303001d621e4dc7d04c27de3d1b3679cf" translate="yes" xml:space="preserve">
          <source>Initializer function for the bias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86357e48ce6faf014cf422087761d8012cac0b71" translate="yes" xml:space="preserve">
          <source>Initializer function for the weight matrix. If &lt;code&gt;None&lt;/code&gt; (default), weights are initialized using the default initializer used by &lt;a href=&quot;../get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea33d8e91f4848f1335260de0a767bf9d2fc824f" translate="yes" xml:space="preserve">
          <source>Initializer function for the weights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394655039e380227cacb4c80f86e6cac564639ab" translate="yes" xml:space="preserve">
          <source>Initializer instance (callable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60811326fed85c17ddc6a9fa74dd3e187f5f2eb" translate="yes" xml:space="preserve">
          <source>Initializer that generates a truncated normal distribution.</source>
          <target state="translated">Инициализатор,который генерирует усеченное нормальное распределение.</target>
        </trans-unit>
        <trans-unit id="28a79d9ea883c4f5cd6e250dbcccda1f34cc830e" translate="yes" xml:space="preserve">
          <source>Initializer that generates an orthogonal matrix.</source>
          <target state="translated">Инициализатор,который генерирует ортогональную матрицу.</target>
        </trans-unit>
        <trans-unit id="1792d0500f8e70d942738b949ce3b4da4a9ed270" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors initialized to 0.</source>
          <target state="translated">Инициализатор,который генерирует тензоры,инициализированные до 0.</target>
        </trans-unit>
        <trans-unit id="a36980b211658b282787d0374f188f82dec6bdb5" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors initialized to 1.</source>
          <target state="translated">Инициализатор,который генерирует тензоры,инициализированные на 1.</target>
        </trans-unit>
        <trans-unit id="15754fbc0acedd6e5262c409c57d5c268cae842f" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors with a normal distribution.</source>
          <target state="translated">Инициализатор,который генерирует тензоры с нормальным распределением.</target>
        </trans-unit>
        <trans-unit id="2e48457893b98a46c7f6098fecb5c04951df9791" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors with a uniform distribution.</source>
          <target state="translated">Инициализатор,который генерирует тензоры с равномерным распределением.</target>
        </trans-unit>
        <trans-unit id="3bee63cb84d4df7eb9ae6d89ea8269883a3a2f73" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors with constant values.</source>
          <target state="translated">Инициализатор,который генерирует тензоры с постоянными значениями.</target>
        </trans-unit>
        <trans-unit id="a63680d71f7ed8d10b2e994835a64ae1af02ec9e" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors without scaling variance.</source>
          <target state="translated">Инициализатор,который генерирует тензоры без дисперсии масштабирования.</target>
        </trans-unit>
        <trans-unit id="1ad2d9eaadec9573877dacc1cb60e6be8ac9c172" translate="yes" xml:space="preserve">
          <source>Initializer that generates the identity matrix.</source>
          <target state="translated">Инициализатор,который генерирует матрицу идентичности.</target>
        </trans-unit>
        <trans-unit id="ba3489968dced82d9caa31fe8dbca460cc2e2ca7" translate="yes" xml:space="preserve">
          <source>Initializer.</source>
          <target state="translated">Initializer.</target>
        </trans-unit>
        <trans-unit id="c300579a9fafe19c627626ad79a72342dd2efc6f" translate="yes" xml:space="preserve">
          <source>Initializers allow you to pre-specify an initialization strategy, encoded in the Initializer object, without knowing the shape and dtype of the variable being initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27c91c237b2a008f7246947c44a699389b5681f" translate="yes" xml:space="preserve">
          <source>Initializers should implement a &lt;code&gt;__call__&lt;/code&gt; method with the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae3569d509cdfe1b8eeda1c03736c231164aa1d" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;FinalOpHook&lt;/code&gt; with ops to run at the end of the session.</source>
          <target state="translated">Инициализирует &lt;code&gt;FinalOpHook&lt;/code&gt; с операциями для запуска в конце сеанса.</target>
        </trans-unit>
        <trans-unit id="0af270707bfe64bad53b93831ed2ef62271f7b4f" translate="yes" xml:space="preserve">
          <source>Initializes EnumParser.</source>
          <target state="translated">Инициализирует EnumParser.</target>
        </trans-unit>
        <trans-unit id="0c6c3eb42679c70ce8e567e3a3d01b9974f44165" translate="yes" xml:space="preserve">
          <source>Initializes SessionRunContext.</source>
          <target state="translated">Инициализирует SessionRunContext.</target>
        </trans-unit>
        <trans-unit id="f9d8cdaca3e42fa2ece9b86eebceb7ecac5115af" translate="yes" xml:space="preserve">
          <source>Initializes TPU and returns a TPUClusterResolver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9596221f894466401f26eb2ad3d3bb9bca21a0" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;BoostedTreesClassifier&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;BoostedTreesClassifier&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="641a92d161ea17f97b3f75efe25bd49c3aff8e50" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;BoostedTreesEstimator&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;BoostedTreesEstimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8291a5b18fc232c8c600a8530a9160b317faf613" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;BoostedTreesRegressor&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;BoostedTreesRegressor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf1dbcb62a62aa47798f17328b9db5bfda87a371" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;CheckpointInputPipelineHook&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;CheckpointInputPipelineHook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="575a2d3cd1c6cefb0d8c20d7511f5f2328199dea" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;CheckpointSaverHook&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;CheckpointSaverHook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2bf50de7719118633c38d4887574c861cacae90" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;DNNClassifier&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;DNNClassifier&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c551665d393a8ff2ebb59249f9845ad31f5e64c" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;DNNEstimator&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;DNNEstimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd3fbf5dea3545531f5a1265c354ed7b46e1d19" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;DNNRegressor&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;DNNRegressor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0af051ae925bb350c4f5229f3c01f96feb14a59b" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;FeedFnHook&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;FeedFnHook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc1915707125a14da164ca446507b73fb2b92efa" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;GlobalStepWaiterHook&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;GlobalStepWaiterHook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbbe5f2cbae68cf255194ac13f981b98c75307c1" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;InMemoryEvaluatorHook&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;InMemoryEvaluatorHook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d129af7a0307c26eab90b28ebd51b9618ad292be" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;LinearEstimator&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;LinearEstimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44409c31c23e5093785e966d4116f3612c1704af" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;LinearRegressor&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;LinearRegressor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c02d624ee0a9807bd61d94c49113d6ab4a74c47b" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;LoggingTensorHook&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;LoggingTensorHook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11306ffe02fcfd7255133712c0c10d8f6b861a21" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;NanTensorHook&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;NanTensorHook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="546f19884e0d132fdd88d1130640aa01b21aace9" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RNNClassifier&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;RNNClassifier&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea803d756c15f8ac4cf7e7ccc1c8153c06bdd9a" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RNNEstimator&lt;/code&gt; instance.</source>
          <target state="translated">Инициализирует экземпляр &lt;code&gt;RNNEstimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e2ad4948c5069b73b42132f07ca898494bfe604" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;StopAtStepHook&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;StopAtStepHook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecebafebcc1ed7893c42ca6adbe3a6e7c3f3d309" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;SummarySaverHook&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;SummarySaverHook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd3617c2d5051723d22bb771dbeeefc7cb141af" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;TFRecordWriter&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;TFRecordWriter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b9e921bd19e339c3c62dd30db062a771c9111c7" translate="yes" xml:space="preserve">
          <source>Initializes a BaselineClassifier instance.</source>
          <target state="translated">Инициализирует экземпляр BaselineClassifier.</target>
        </trans-unit>
        <trans-unit id="f2ca17291afb7e8cb98eae1421a6d34024556fe2" translate="yes" xml:space="preserve">
          <source>Initializes a BaselineEstimator instance.</source>
          <target state="translated">Инициализирует экземпляр BaselineEstimator.</target>
        </trans-unit>
        <trans-unit id="6df9376ec784999b4324a701a11055ec4641b248" translate="yes" xml:space="preserve">
          <source>Initializes a BaselineRegressor instance.</source>
          <target state="translated">Инициализирует экземпляр BaselineRegressor.</target>
        </trans-unit>
        <trans-unit id="a0774ef910763d2c62bd641db60c78cc26f5f0c0" translate="yes" xml:space="preserve">
          <source>Initializes a DNNLinearCombinedClassifier instance.</source>
          <target state="translated">Инициализирует экземпляр DNNLinearCombinedClassifier.</target>
        </trans-unit>
        <trans-unit id="783d0c854480043cc2c0181e9e30a857fc22e30e" translate="yes" xml:space="preserve">
          <source>Initializes a DNNLinearCombinedEstimator instance.</source>
          <target state="translated">Инициализирует экземпляр DNNLinearCombinedEstimator.</target>
        </trans-unit>
        <trans-unit id="739deeaaeb79fadd6c52fea70a1826f73947e113" translate="yes" xml:space="preserve">
          <source>Initializes a DNNLinearCombinedRegressor instance.</source>
          <target state="translated">Инициализирует экземпляр DNNLinearCombinedRegressor.</target>
        </trans-unit>
        <trans-unit id="0c40d6ce99ac68c2b27ea09e79d9aa0795cdf29d" translate="yes" xml:space="preserve">
          <source>Initializes a UnionClusterResolver with other ClusterResolvers.</source>
          <target state="translated">Инициализирует резольвер UnionClusterResolver с другими резольверами кластеров.</target>
        </trans-unit>
        <trans-unit id="33532b330cba4da4287395c3bcee952368758bde" translate="yes" xml:space="preserve">
          <source>Initializes a chief session creator.</source>
          <target state="translated">Инициализирует главного создателя сеанса.</target>
        </trans-unit>
        <trans-unit id="f0fbe2018ecf0aac090ce758a3b9ad7c64b0d419" translate="yes" xml:space="preserve">
          <source>Initializes a distributed TPU system for use with TensorFlow.</source>
          <target state="translated">Инициализирует распределенную систему TPU для использования с TensorFlow.</target>
        </trans-unit>
        <trans-unit id="f9ecfd4934d70f84d7899a79d879721a3e413c28" translate="yes" xml:space="preserve">
          <source>Initializes a hook that takes periodic profiling snapshots.</source>
          <target state="translated">Инициализирует крюк,который делает периодические снимки профилирования.</target>
        </trans-unit>
        <trans-unit id="997de8101a00d090e563fabad75f25c03ff57046" translate="yes" xml:space="preserve">
          <source>Initializes a new KubernetesClusterResolver.</source>
          <target state="translated">Инициализирует новый резольвер KubernetesCluster.</target>
        </trans-unit>
        <trans-unit id="639ee79e578c9c1534d9a97348960057ce542dee" translate="yes" xml:space="preserve">
          <source>Initializes a table from a text file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a000286aa35868ad7a4442c66081e50874ea4509" translate="yes" xml:space="preserve">
          <source>Initializes a worker session creator.</source>
          <target state="translated">Инициализирует создателя рабочего сеанса.</target>
        </trans-unit>
        <trans-unit id="52e2a9b43cb09a5b97b21e2638d508223e7d9295" translate="yes" xml:space="preserve">
          <source>Initializes an InputContext object.</source>
          <target state="translated">Инициализирует объект InputContext.</target>
        </trans-unit>
        <trans-unit id="9f766a8a68267cac7d59732c88bb6823db3efc5f" translate="yes" xml:space="preserve">
          <source>Initializes summary writing for graph execution mode.</source>
          <target state="translated">Инициализирует написание сводок для режима исполнения графика.</target>
        </trans-unit>
        <trans-unit id="a923a4b25ad6812b374a90843b54d284a15dffcb" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;step_context&lt;/code&gt; argument for a &lt;code&gt;step_fn&lt;/code&gt; invocation.</source>
          <target state="translated">Инициализирует аргумент &lt;code&gt;step_context&lt;/code&gt; для вызова &lt;code&gt;step_fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="064630dcdc1b915396129f044f0af7f3ed3178c1" translate="yes" xml:space="preserve">
          <source>Initializes the TPUStrategy object.</source>
          <target state="translated">Инициализирует объект TPUStrategy.</target>
        </trans-unit>
        <trans-unit id="a095094fc43a8f61df14737cdbd7e74e010345c8" translate="yes" xml:space="preserve">
          <source>Initializes the given &lt;code&gt;table&lt;/code&gt; with &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; tensors.</source>
          <target state="translated">Инициализировать данную &lt;code&gt;table&lt;/code&gt; с &lt;code&gt;keys&lt;/code&gt; и &lt;code&gt;values&lt;/code&gt; тензоров.</target>
        </trans-unit>
        <trans-unit id="5015344a3098f58ff7e43767db7a65fd51001358" translate="yes" xml:space="preserve">
          <source>Initializes the loss scale class.</source>
          <target state="translated">Инициализирует класс шкалы убытков.</target>
        </trans-unit>
        <trans-unit id="25a3e19a4075de6c96af04a4d7d33034705f5421" translate="yes" xml:space="preserve">
          <source>Initializes the multi device iterator with the given dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2ebcb62e07bfa23fe63ff902381554659598f7" translate="yes" xml:space="preserve">
          <source>Initializes the object.</source>
          <target state="translated">Инициализирует объект.</target>
        </trans-unit>
        <trans-unit id="96c249c719463e9cbe91e8dfab76ecf97217371c" translate="yes" xml:space="preserve">
          <source>Initializes the parameters for an RNN cell.</source>
          <target state="translated">Инициализирует параметры ячейки RNN.</target>
        </trans-unit>
        <trans-unit id="926bdaa7bd8079fe9e99087d53c0e1e6f3926945" translate="yes" xml:space="preserve">
          <source>Initializes the summary writer.</source>
          <target state="translated">Инициализирует составителя резюме.</target>
        </trans-unit>
        <trans-unit id="8ce5d08116a5422425173483db4afb40e381960e" translate="yes" xml:space="preserve">
          <source>Initializes the table from a text file.</source>
          <target state="translated">Инициализирует таблицу из текстового файла.</target>
        </trans-unit>
        <trans-unit id="166aee7623091cf78477483a2b69d759bad97f4c" translate="yes" xml:space="preserve">
          <source>Initializes this loss scale optimizer.</source>
          <target state="translated">Инициализирует этот оптимизатор шкалы потерь.</target>
        </trans-unit>
        <trans-unit id="420eb1414b9510458affd7d7f221b2d916a76daf" translate="yes" xml:space="preserve">
          <source>Initializes this strategy with an optional &lt;code&gt;cluster_resolver&lt;/code&gt;.</source>
          <target state="translated">Инициализирует эту стратегию необязательным &lt;code&gt;cluster_resolver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d2c52d1b5ccc55d62f5f28f184bbca571994a96" translate="yes" xml:space="preserve">
          <source>Initializes with a device to reduce to and a way to accumulate.</source>
          <target state="translated">Инициализируется устройством для уменьшения до и способа накопления.</target>
        </trans-unit>
        <trans-unit id="b0239e06bf33c2a0502643ba3bac0a932d185f3a" translate="yes" xml:space="preserve">
          <source>Initializing variables on startup, restoring them from the most recent checkpoint after a crash, or wait for checkpoints to become available.</source>
          <target state="translated">Инициализация переменных при запуске,восстановление их с последней контрольно-пропускной точки после аварии или ожидание доступности контрольно-пропускных пунктов.</target>
        </trans-unit>
        <trans-unit id="6cfc0b3ada9a1caff4180ec7edad85d08676e0cf" translate="yes" xml:space="preserve">
          <source>Injects a new target into a function built by make_decorator.</source>
          <target state="translated">Вставляет новую цель в функцию,встроенную make_decorator.</target>
        </trans-unit>
        <trans-unit id="678429d49a474ad8ec94a587c28e389acd6369f3" translate="yes" xml:space="preserve">
          <source>InplaceAdd</source>
          <target state="translated">InplaceAdd</target>
        </trans-unit>
        <trans-unit id="ec6af4517abefc843097599d82d36ce1eb1a270d" translate="yes" xml:space="preserve">
          <source>InplaceSub</source>
          <target state="translated">InplaceSub</target>
        </trans-unit>
        <trans-unit id="f0e0363a75f31977f3e73ce8f596bfbdfd61bf73" translate="yes" xml:space="preserve">
          <source>InplaceUpdate</source>
          <target state="translated">InplaceUpdate</target>
        </trans-unit>
        <trans-unit id="c43b6bd566f5c25fdb732766cd21b9ae75943d6a" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;Tensor&lt;/code&gt; of 4 dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555cccc16566c1858242a991bb2d577980094119" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;Tensor&lt;/code&gt; of arbitrary dimensionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47e882af7f7b4bf59f38df7ea0de6601132847c" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;dict&lt;/code&gt; keyed by head name, or logits &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[D0, D1, ... DN, logits_dimension]&lt;/code&gt;. For many applications, the &lt;code&gt;Tensor&lt;/code&gt; shape is &lt;code&gt;[batch_size, logits_dimension]&lt;/code&gt;. If logits is a &lt;code&gt;Tensor&lt;/code&gt;, it will split the &lt;code&gt;Tensor&lt;/code&gt; along the last dimension and distribute it appropriately among the heads. Check &lt;code&gt;MultiHead&lt;/code&gt; for examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55df84b1e295dfaf67dfff1b3a1fdcf1773c8846" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;dict&lt;/code&gt; keyed by head name. For each head, the label value can be integer or string &lt;code&gt;Tensor&lt;/code&gt; with shape matching its corresponding &lt;code&gt;logits&lt;/code&gt;.&lt;code&gt;labels&lt;/code&gt; is a required argument when &lt;code&gt;mode&lt;/code&gt; equals &lt;code&gt;TRAIN&lt;/code&gt; or &lt;code&gt;EVAL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0ae41f6575650de2d584cfceb38b4e40bc36c9" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;dict&lt;/code&gt; mapping string feature names to &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; objects containing the values for that feature in a minibatch. Often to be used to fetch example-weight tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc3579a5d678f887fecef572ddf9366f2f9c7cc" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;dict&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae71208250add9941ed13ea2029409afa7b93fb" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;set1&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;set1_indices&lt;/code&gt;, &lt;code&gt;set1_values&lt;/code&gt;, and &lt;code&gt;set1_shape&lt;/code&gt;. For &lt;code&gt;set1&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, 1st &lt;code&gt;n-1&lt;/code&gt; dimensions must be the same as &lt;code&gt;set2&lt;/code&gt;. Dimension &lt;code&gt;n&lt;/code&gt; contains values in a set, duplicates are allowed but ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c336a84296dacace527a71edd564eea1f7ffa2" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;set2&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;set2_indices&lt;/code&gt;, &lt;code&gt;set2_values&lt;/code&gt;, and &lt;code&gt;set2_shape&lt;/code&gt;. For &lt;code&gt;set2&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, 1st &lt;code&gt;n-1&lt;/code&gt; dimensions must be the same as &lt;code&gt;set1&lt;/code&gt;. Dimension &lt;code&gt;n&lt;/code&gt; contains values in a set, duplicates are allowed but ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f99bc7303fea77788e4b5a62891d37be161744" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;set&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;set_indices&lt;/code&gt;, &lt;code&gt;set_values&lt;/code&gt;, and &lt;code&gt;set_shape&lt;/code&gt;. The last dimension contains values in a set, duplicates are allowed but ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f66030afeade18b9456df8065e5c951d6d480c2" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;tensor&lt;/code&gt; or &lt;code&gt;variable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0e981b33830b81d9ff2818d62f005b2928c167" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;tf.Example&lt;/code&gt; objects:</source>
          <target state="translated">Входные объекты &lt;code&gt;tf.Example&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="027ba0d2bd1ac3c2c0126ee6ab5e33bed78269f7" translate="yes" xml:space="preserve">
          <source>Input Numpy array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e22ca8ccf9f6c32e67d850f39a63b8ae3ce0acb" translate="yes" xml:space="preserve">
          <source>Input PIL Image instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393b83efcad37fe7f24fb15bdef2bbd7b9a13b1f" translate="yes" xml:space="preserve">
          <source>Input data (i.e. often &lt;code&gt;sess.graph_def&lt;/code&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8492f8050f5a2252c39818c585ca67b9a56893" translate="yes" xml:space="preserve">
          <source>Input data. It could be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4273256e3bf47b078b718fcd16e88b74b26a5f2c" translate="yes" xml:space="preserve">
          <source>Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7804e6f6c4e4eb9aa841a2db499d73f590eec04d" translate="yes" xml:space="preserve">
          <source>Input data. Numpy array of rank 4 or a tuple. If tuple, the first element should contain the images and the second element another numpy array or a list of numpy arrays that gets passed to the output without any modifications. Can be used to feed the model miscellaneous data along with the images. In case of grayscale data, the channels axis of the image array should have value 1, in case of RGB data, it should have value 3, and in case of RGBA data, it should have value 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe0277ca1258b71f70bd599617a938764ac3895" translate="yes" xml:space="preserve">
          <source>Input images and output images must be quantized types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f2bad16eec61ee4379ef2b4aeb9cc4c2a4a510" translate="yes" xml:space="preserve">
          <source>Input images can be of different types but output images are always float.</source>
          <target state="translated">Входные изображения могут быть разных типов,но выходные изображения всегда плавают.</target>
        </trans-unit>
        <trans-unit id="db26f74f2a7583e55f737d0b7c1d7bc9abb03c30" translate="yes" xml:space="preserve">
          <source>Input is an unknown function or string, i.e., the input does not denote any defined function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4239004a11dea4c51531321c98ec214cc8cbb13c" translate="yes" xml:space="preserve">
          <source>Input logits.</source>
          <target state="translated">Входные логиты.</target>
        </trans-unit>
        <trans-unit id="fda1e7a11af1cc3301f80e9a5418b19a3ab29bb4" translate="yes" xml:space="preserve">
          <source>Input mask tensor (potentially None) or list of input mask tensors.</source>
          <target state="translated">Тензор входной маски (потенциально Нет)или список тензоров входной маски.</target>
        </trans-unit>
        <trans-unit id="edbe051ef8c9da1130a2117a0a044159ca1b63de" translate="yes" xml:space="preserve">
          <source>Input may or may not have padding at the end. See EncodeBase64 for padding. Web-safe means that input must use - and _ instead of + and /.</source>
          <target state="translated">Вход может иметь или не иметь набивку на конце.См.раздел &quot;Набивка&quot; в документе EncodeBase64.Web-безопасность означает,что при вводе необходимо использовать-и_вместо+и /.</target>
        </trans-unit>
        <trans-unit id="f8658e95ed1bbcd180ec9de2eb39b3ac7043313a" translate="yes" xml:space="preserve">
          <source>Input of &lt;code&gt;train&lt;/code&gt; and &lt;code&gt;evaluate&lt;/code&gt; should have following features, otherwise there will be a &lt;code&gt;KeyError&lt;/code&gt;:</source>
          <target state="translated">Ввод &lt;code&gt;train&lt;/code&gt; и &lt;code&gt;evaluate&lt;/code&gt; должен иметь следующие особенности, иначе возникнет &lt;code&gt;KeyError&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88e394c2930956f582ca9ae4eef0469cb05766cc" translate="yes" xml:space="preserve">
          <source>Input of &lt;code&gt;train&lt;/code&gt; and &lt;code&gt;evaluate&lt;/code&gt; should have following features, otherwise there will be a KeyError:</source>
          <target state="translated">Ввод &lt;code&gt;train&lt;/code&gt; и &lt;code&gt;evaluate&lt;/code&gt; должен иметь следующие особенности, иначе возникнет KeyError:</target>
        </trans-unit>
        <trans-unit id="ebfa8d05c9d2a729345a882e4621644a960bf43d" translate="yes" xml:space="preserve">
          <source>Input pipelines based on Queues are not supported when eager execution is enabled. Please use the &lt;a href=&quot;../../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; API to ingest data under eager execution.</source>
          <target state="translated">Конвейеры ввода на основе очередей не поддерживаются, если включено активное выполнение. Пожалуйста, используйте &lt;a href=&quot;../../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; API для приема данных при активном выполнении.</target>
        </trans-unit>
        <trans-unit id="598edbed9cb4bf5b632040c88948229e65c299b6" translate="yes" xml:space="preserve">
          <source>Input points. See &lt;a href=&quot;../../../../estimator/estimator#evaluate&quot;&gt;&lt;code&gt;tf.estimator.Estimator.evaluate&lt;/code&gt;&lt;/a&gt;. Only one batch is retrieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6c78aba2a9c76b9d951d8db1402d9aba390207" translate="yes" xml:space="preserve">
          <source>Input points. See &lt;a href=&quot;../../../../estimator/estimator#predict&quot;&gt;&lt;code&gt;tf.estimator.Estimator.predict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0931987f07b0aec0f450122b07367564fc58ded" translate="yes" xml:space="preserve">
          <source>Input requirements:</source>
          <target state="translated">Требования к вводу:</target>
        </trans-unit>
        <trans-unit id="3dc6f8eee6bce10a8537a2917c22a3cc2c8dc7ed" translate="yes" xml:space="preserve">
          <source>Input samples. It could be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edc3b92bc5323054e3dc2775081c31d37f39632" translate="yes" xml:space="preserve">
          <source>Input shape is not specified. None value for dimension in input_tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6150fd4490609fe6a3c79de568883b2478811095" translate="yes" xml:space="preserve">
          <source>Input shape, as an integer shape tuple (or list of shape tuples, one tuple per input tensor).</source>
          <target state="translated">Входная форма,как целочисленный кортеж формы (или список кортежей формы,по одному кортежу на входной тензор).</target>
        </trans-unit>
        <trans-unit id="73a2fcb17cd33f0bbcaa985f8ff933859938cfdb" translate="yes" xml:space="preserve">
          <source>Input shape:</source>
          <target state="translated">Форма входа:</target>
        </trans-unit>
        <trans-unit id="59eecd0cfa473638c7d2777b11ac1545f57165a4" translate="yes" xml:space="preserve">
          <source>Input shape: A single or list of string, int32 or int64 &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;SparseTensor&lt;/code&gt; or &lt;code&gt;RaggedTensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, ...,]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fadd4c954d4398a6a8aa787506ce19f5ddef089" translate="yes" xml:space="preserve">
          <source>Input shape: Arbitrary. Use the keyword argument &lt;code&gt;input_shape&lt;/code&gt; (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model. Output shape: Same shape as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406a1ac666c22757785ff154ffb25a854854e54d" translate="yes" xml:space="preserve">
          <source>Input shape: Arbitrary. Use the keyword argument &lt;code&gt;input_shape&lt;/code&gt; (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model. Output shape: Same shape as input. Reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaf155b1421e874b8972d3235373826e11ba63d" translate="yes" xml:space="preserve">
          <source>Input shape: a list of string or int tensors or sparse tensors of shape &lt;code&gt;[batch_size, d1, ..., dm]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924a9478691303fe05bafb1fc1238c07cb44c3db" translate="yes" xml:space="preserve">
          <source>Input tensor or list of input tensors.</source>
          <target state="translated">Входной тензор или список входных тензоров.</target>
        </trans-unit>
        <trans-unit id="d26122fe46ad936a639db8a98f7a7d831a07c743" translate="yes" xml:space="preserve">
          <source>Input tensor or variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dba3b7a1a9cdef336ee977c7f2a6df0eea23b06" translate="yes" xml:space="preserve">
          <source>Input tensor to annotate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411356d9f9c5901fb808283dc5ce56a97f9f81c2" translate="yes" xml:space="preserve">
          <source>Input tensor to crop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6f81b7596b400c309065016d4f825b54519070" translate="yes" xml:space="preserve">
          <source>Input tensor, or list/tuple of input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36402c7384044ec8d1afe082a66fd774f30b26a5" translate="yes" xml:space="preserve">
          <source>Input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83473fd83a8c624217c365881f9195c2e91b4bf5" translate="yes" xml:space="preserve">
          <source>Input text (string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb11121330c8874b43826ca8a1da1c1d3c194fb5" translate="yes" xml:space="preserve">
          <source>Inputs and outputs of the computation must be at least rank-1 Tensors.</source>
          <target state="translated">Входы и выходы вычислений должны быть как минимум 1-го ранга тензоров.</target>
        </trans-unit>
        <trans-unit id="e7fe0dcaa3f3ef9a8f095388d2bf7868e5702be9" translate="yes" xml:space="preserve">
          <source>Inputs are &lt;code&gt;query&lt;/code&gt; tensor of shape &lt;code&gt;[batch_size, Tq, dim]&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; tensor of shape &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; tensor of shape &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt;. The calculation follows the steps:</source>
          <target state="translated">Входы &lt;code&gt;query&lt;/code&gt; тензор формы &lt;code&gt;[batch_size, Tq, dim]&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; тензора формы &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt; и &lt;code&gt;key&lt;/code&gt; тензора формы &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt; . Расчет выполняется следующим образом:</target>
        </trans-unit>
        <trans-unit id="1c0e56ccaddb0c8890b27ec9abecd06903924122" translate="yes" xml:space="preserve">
          <source>Inputs are not masked or strictly right padded.</source>
          <target state="translated">Входы не замаскированы или имеют строго правильную подкладку.</target>
        </trans-unit>
        <trans-unit id="b70811df5293dc1d88b0b4d8c3745fc0c3e2e349" translate="yes" xml:space="preserve">
          <source>Inputs are tensor and if the tensors contains more than one element, an element-wise logical XOR is computed.</source>
          <target state="translated">Входы являются тензорами,и если тензоры содержат более одного элемента,вычисляется логический XOR по элементам.</target>
        </trans-unit>
        <trans-unit id="23d064e3d9a6fa10428c435dfb012de3079138c9" translate="yes" xml:space="preserve">
          <source>Inputs are the logits, not probabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137804bd98ee5ed803aad41b3b2bb45555e950ca" translate="yes" xml:space="preserve">
          <source>Inputs must be a &lt;code&gt;CategoricalColumn&lt;/code&gt; created by any of the &lt;code&gt;categorical_column_*&lt;/code&gt; function. Here is an example of using &lt;code&gt;embedding_column&lt;/code&gt; with &lt;code&gt;DNNClassifier&lt;/code&gt;:</source>
          <target state="translated">Входные данные должны быть &lt;code&gt;CategoricalColumn&lt;/code&gt; созданным любой из функций &lt;code&gt;categorical_column_*&lt;/code&gt; . Вот пример использования &lt;code&gt;embedding_column&lt;/code&gt; с &lt;code&gt;DNNClassifier&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78623993ab6e74c3ee21bef7821841777f171f6b" translate="yes" xml:space="preserve">
          <source>Inputs must be a list of categorical columns created by any of the &lt;code&gt;categorical_column_*&lt;/code&gt; function. They must all be of the same type and have the same arguments except &lt;code&gt;key&lt;/code&gt;. E.g. they can be categorical_column_with_vocabulary_file with the same vocabulary_file. Some or all columns could also be weighted_categorical_column.</source>
          <target state="translated">Входные данные должны быть списком категориальных столбцов, созданных любой из функций &lt;code&gt;categorical_column_*&lt;/code&gt; . Все они должны быть одного типа и иметь одинаковые аргументы, кроме &lt;code&gt;key&lt;/code&gt; . Например, они могут быть категориальным_столбцем_с_файлом_вокабуляра с тем же файлом словаря. Некоторые или все столбцы также могут быть weighted_categorical_column.</target>
        </trans-unit>
        <trans-unit id="a1efe96c91fcd8bed8fa1d7ca844191407c209f4" translate="yes" xml:space="preserve">
          <source>Inputs must be of same size and shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc1e2618a909f1924de892464f8fe683c626f63" translate="yes" xml:space="preserve">
          <source>Inputs of the SignatureDef defined as a proto map of string to tensor info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a13494d1fa9208f2eba7e981b495a987da5cd5a" translate="yes" xml:space="preserve">
          <source>Inputs, if use masking, are strictly right-padded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023ec1ebccdae7f83573df2912447d135544d80b" translate="yes" xml:space="preserve">
          <source>Inputs/Outputs mapping for children hints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f102a3cf4073e5d93951de1381197dd8a18010c" translate="yes" xml:space="preserve">
          <source>Insert a &lt;code&gt;Masking&lt;/code&gt; layer with &lt;code&gt;mask_value=0.&lt;/code&gt; before the LSTM layer:</source>
          <target state="translated">Вставьте &lt;code&gt;Masking&lt;/code&gt; слой с &lt;code&gt;mask_value=0.&lt;/code&gt; перед слоем LSTM:</target>
        </trans-unit>
        <trans-unit id="bfe1c55114da692160a20eed9799d0591600c538" translate="yes" xml:space="preserve">
          <source>Insert an item at a given position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4289ec1fa78fdfefe11042b9998b439fa9c81395" translate="yes" xml:space="preserve">
          <source>Insert name scopes that name ops according to context, like the function they were defined in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3070ae425dbe8df14be97a01e4f83025dd75be12" translate="yes" xml:space="preserve">
          <source>Insert of control dependencies in the generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f87207530b85579b12d1c5e52ad8a13807845e" translate="yes" xml:space="preserve">
          <source>Inserts a dimension of 1 into a tensor's shape.</source>
          <target state="translated">Вставляет размер 1 в форму тензора.</target>
        </trans-unit>
        <trans-unit id="29b723ab1ad43456db942b0b8bd7c8d59bddf967" translate="yes" xml:space="preserve">
          <source>Inserts a dimension of 1 into a tensor's shape. (deprecated arguments)</source>
          <target state="translated">Вставляет размер 1 в форму тензора.(устаревшие аргументы)</target>
        </trans-unit>
        <trans-unit id="1d269ecf38e8f23806fcb544f73ec6c7d82059d0" translate="yes" xml:space="preserve">
          <source>Inserts a placeholder for a sparse tensor that will be always fed.</source>
          <target state="translated">Вставляет держатель для разреженного тензора,который будет всегда подаваться.</target>
        </trans-unit>
        <trans-unit id="2f562655f77a6d82ddf22ccda7140bb2b957c8a1" translate="yes" xml:space="preserve">
          <source>Inserts a placeholder for a tensor that will be always fed.</source>
          <target state="translated">Вставляет держатель для тензора,который будет всегда подаваться.</target>
        </trans-unit>
        <trans-unit id="c3bbe50b7a8e09f46aa5f5b6f4c704a039abb44e" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;../../config/experimental_run_functions_eagerly&quot;&gt;&lt;code&gt;tf.config.experimental_run_functions_eagerly(True)&lt;/code&gt;&lt;/a&gt; is called:</source>
          <target state="translated">Внутри &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; после &lt;a href=&quot;../../config/experimental_run_functions_eagerly&quot;&gt; &lt;code&gt;tf.config.experimental_run_functions_eagerly(True)&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="88242efed2a90369bd7739cd77fd6bb5c625b08a" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;../../config/run_functions_eagerly&quot;&gt;&lt;code&gt;tf.config.run_functions_eagerly(True)&lt;/code&gt;&lt;/a&gt; is called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac98a58dead80c80e907d0722a4a50459411da6d" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Внутри &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7a059d78a854aeca57acd67a3369e631a93c4c21" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; after</source>
          <target state="translated">Внутри &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; после</target>
        </trans-unit>
        <trans-unit id="ec60a47239e5418aff75738619bde1b49257788d" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;config/run_functions_eagerly&quot;&gt;&lt;code&gt;tf.config.run_functions_eagerly(True)&lt;/code&gt;&lt;/a&gt; is called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a75c2b38172e2164e085145cea76fd33af363c" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Внутри &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ec79e0ca854d631053514bae0e263ceb9c0d6303" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;graph&quot;&gt;&lt;code&gt;v1.Graph&lt;/code&gt;&lt;/a&gt; context it checks both the buildtime and runtime shapes. This is stricter than &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt; which only checks the buildtime shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82afdb80382fb2fc992e989613b663643ddaa8e4" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, if the scope name already exists, the name will be made unique by appending &lt;code&gt;_n&lt;/code&gt;. For example, calling &lt;code&gt;my_op&lt;/code&gt; the second time will generate &lt;code&gt;MyOp_1/a&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2cab75c40098f2631f31b554fa63d8c8ec4f9a" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;with strategy.scope():&lt;/code&gt; code block, this thread will use a variable creator set by &lt;code&gt;strategy&lt;/code&gt;, and will enter its &quot;cross-replica context&quot;.</source>
          <target state="translated">Внутри блока &lt;code&gt;with strategy.scope():&lt;/code&gt; code этот поток будет использовать создателя переменной, установленного &lt;code&gt;strategy&lt;/code&gt; , и войдет в свой &amp;laquo;контекст перекрестной реплики&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2d5243ea93579bbab1a7b795e88dfd8e5238e331" translate="yes" xml:space="preserve">
          <source>Inside a transformation function for &lt;code&gt;tf.dataset&lt;/code&gt;:</source>
          <target state="translated">Внутри функции преобразования для &lt;code&gt;tf.dataset&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d4b06861e26c80e2e1dae15e440b54ad617bc0bb" translate="yes" xml:space="preserve">
          <source>Inspect per replica values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc357acb9630e774fef71bd6f4e9fe4746202ac" translate="yes" xml:space="preserve">
          <source>Inspect the &lt;a href=&quot;../typespec&quot;&gt;&lt;code&gt;tf.TypeSpec&lt;/code&gt;&lt;/a&gt; of the data generated by &lt;code&gt;DistributedDataset&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a53dd6e8ab19c662119f50b518c24c49162ee4b" translate="yes" xml:space="preserve">
          <source>Instance of &lt;a href=&quot;../model&quot;&gt;&lt;code&gt;keras.models.Model&lt;/code&gt;&lt;/a&gt;. Reference of the model being trained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a130b5a080aaac67de31b1fa82cb3dfac9a1069" translate="yes" xml:space="preserve">
          <source>Instance of &lt;code&gt;ImageDataGenerator&lt;/code&gt; to use for random transformations and normalization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cf2092da978e7620ab63b4e192bd7a04ad4b4b" translate="yes" xml:space="preserve">
          <source>Instance of &lt;code&gt;Model&lt;/code&gt; (could be a functional model or a Sequential model).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b43b03a6052c1e3c68139c3abf477e110080e9" translate="yes" xml:space="preserve">
          <source>Instance of &lt;code&gt;ReparameterizationType&lt;/code&gt;. If &lt;a href=&quot;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions#FULLY_REPARAMETERIZED&quot;&gt;&lt;code&gt;distributions.FULLY_REPARAMETERIZED&lt;/code&gt;&lt;/a&gt;, this &lt;code&gt;Distribution&lt;/code&gt; can be reparameterized in terms of some standard distribution with a function whose Jacobian is constant for the support of the standard distribution. If &lt;a href=&quot;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions#NOT_REPARAMETERIZED&quot;&gt;&lt;code&gt;distributions.NOT_REPARAMETERIZED&lt;/code&gt;&lt;/a&gt;, then no such reparameterization is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a571b362fde52d2a6b69563361ddf991b6c92df5" translate="yes" xml:space="preserve">
          <source>Instance of &lt;code&gt;TensorShape&lt;/code&gt;, or list of instances of &lt;code&gt;TensorShape&lt;/code&gt; if the layer expects a list of inputs (one instance per input).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a058c45032e7de16ba71c01fab3738d287a42a" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;NumpyWrapper&lt;/code&gt; are checkpointable objects, and will be saved and restored from checkpoints along with TensorFlow state like variables.</source>
          <target state="translated">Экземпляры &lt;code&gt;NumpyWrapper&lt;/code&gt; являются объектами с контрольными точками и будут сохраняться и восстанавливаться из контрольных точек вместе с состоянием TensorFlow, как переменные.</target>
        </trans-unit>
        <trans-unit id="78eccaaba0fdade93205fff1e00fbadcaeaba337" translate="yes" xml:space="preserve">
          <source>Instances of this class represent a loss scale. Calling instances of this class returns the loss scale as a scalar float32 tensor, while method &lt;code&gt;update()&lt;/code&gt; updates the loss scale depending on the values of the gradients. Optimizers use instances of this class to scale loss and gradients.</source>
          <target state="translated">Экземпляры этого класса представляют собой шкалу потерь. Вызов экземпляров этого класса возвращает масштаб потерь в виде скалярного тензора float32, а метод &lt;code&gt;update()&lt;/code&gt; обновляет масштаб потерь в зависимости от значений градиентов. Оптимизаторы используют экземпляры этого класса для масштабирования потерь и градиентов.</target>
        </trans-unit>
        <trans-unit id="abc0db5b227fc3047fc2a6c06364fc3c54136965" translate="yes" xml:space="preserve">
          <source>Instances of this class represent how sampling is reparameterized.</source>
          <target state="translated">Примеры этого класса показывают,как производится репараметризация выборки.</target>
        </trans-unit>
        <trans-unit id="a0b4097742556a6fb1f2198ba723bf3c67e4062b" translate="yes" xml:space="preserve">
          <source>Instances of this dataset are also created as a result of the &lt;code&gt;hoist_random_uniform&lt;/code&gt; static optimization. Whether this optimization is performed is determined by the &lt;code&gt;experimental_optimization.hoist_random_uniform&lt;/code&gt; option of &lt;a href=&quot;../data/options&quot;&gt;&lt;code&gt;tf.data.Options&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e23834d9ad625b0a72d7e2f1be4a4069c499c5c" translate="yes" xml:space="preserve">
          <source>Instantiate an identity matrix and returns it.</source>
          <target state="translated">Создать матрицу идентичности и вернуть ее.</target>
        </trans-unit>
        <trans-unit id="9adc3a521be5ffb465cee66aa19ff8ac84ae4cea" translate="yes" xml:space="preserve">
          <source>Instantiates a &lt;code&gt;LearningRateSchedule&lt;/code&gt; from its config.</source>
          <target state="translated">Создает экземпляр &lt;code&gt;LearningRateSchedule&lt;/code&gt; из своей конфигурации.</target>
        </trans-unit>
        <trans-unit id="e819f31f0ce693841e6703a84bf49642d0f0646a" translate="yes" xml:space="preserve">
          <source>Instantiates a &lt;code&gt;Loss&lt;/code&gt; from its config (output of &lt;code&gt;get_config()&lt;/code&gt;).</source>
          <target state="translated">Создает экземпляр &lt;code&gt;Loss&lt;/code&gt; из своей конфигурации (вывод &lt;code&gt;get_config()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6ba64f03d4a9f988022614425c9d39f3e4c08eec" translate="yes" xml:space="preserve">
          <source>Instantiates a Keras function.</source>
          <target state="translated">воплощает в жизнь функцию Кераса.</target>
        </trans-unit>
        <trans-unit id="86be24bfd95437c4ccded5012ad87863f17418f2" translate="yes" xml:space="preserve">
          <source>Instantiates a Keras model from its config.</source>
          <target state="translated">Фактически воплощает модель Keras из своей конфигурации.</target>
        </trans-unit>
        <trans-unit id="bc64840a2606c1465edcdf6de298724ac46c006a" translate="yes" xml:space="preserve">
          <source>Instantiates a Mobile NASNet model in ImageNet mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a38d91d8d2817de0090aee963f8e886b2ccdc4" translate="yes" xml:space="preserve">
          <source>Instantiates a NASNet model in ImageNet mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1139b10a46081f05ee7e89e2f44088cc63dc7ce" translate="yes" xml:space="preserve">
          <source>Instantiates a layer from a config dictionary.</source>
          <target state="translated">Фактически,это слой из словаря конфигураций.</target>
        </trans-unit>
        <trans-unit id="f2e8a39a6c72f1d2adbc3a7102dbfb7499d810f2" translate="yes" xml:space="preserve">
          <source>Instantiates a placeholder tensor and returns it.</source>
          <target state="translated">Обосновывает тензор плейсхолдера и возвращает его.</target>
        </trans-unit>
        <trans-unit id="56fcc9aa753f9745e6fd3098bb85d40d054e5bf6" translate="yes" xml:space="preserve">
          <source>Instantiates a variable and returns it.</source>
          <target state="translated">Фактически определяет переменную и возвращает ее.</target>
        </trans-unit>
        <trans-unit id="e4ee72f81497fc62ef8381301600c750a4c3bf6b" translate="yes" xml:space="preserve">
          <source>Instantiates a variable with values drawn from a normal distribution.</source>
          <target state="translated">Служит для инстанцирования переменной со значениями,полученными из нормального распределения.</target>
        </trans-unit>
        <trans-unit id="25c5cf039c5c919ae65a83e5f4aa30370b25a668" translate="yes" xml:space="preserve">
          <source>Instantiates a variable with values drawn from a uniform distribution.</source>
          <target state="translated">Конкретно описывает переменную со значениями,полученными из равномерного распределения.</target>
        </trans-unit>
        <trans-unit id="20d6d4e9f45134915d0ed9873dfceccd0144de71" translate="yes" xml:space="preserve">
          <source>Instantiates an all-ones variable and returns it.</source>
          <target state="translated">Обнаруживает переменную,состоящую из всех частей,и возвращает ее.</target>
        </trans-unit>
        <trans-unit id="5ddc4e890d0448de00a1911ddc70ef24681ca3b6" translate="yes" xml:space="preserve">
          <source>Instantiates an all-ones variable of the same shape as another tensor.</source>
          <target state="translated">Фактически представляет собой многоточечную переменную той же формы,что и другой тензор.</target>
        </trans-unit>
        <trans-unit id="05d54627ce37da1dd958b8c24f85136425c8109f" translate="yes" xml:space="preserve">
          <source>Instantiates an all-zeros variable and returns it.</source>
          <target state="translated">Образует переменную,состоящую из всех нулей,и возвращает ее.</target>
        </trans-unit>
        <trans-unit id="94d5c94851b51c4270f6a95b7c0475db1f95de16" translate="yes" xml:space="preserve">
          <source>Instantiates an all-zeros variable of the same shape as another tensor.</source>
          <target state="translated">Образует все нули переменной той же формы,что и другой тензор.</target>
        </trans-unit>
        <trans-unit id="473a492fa8efc4ff13a257196fc8bcdbedc7a3be" translate="yes" xml:space="preserve">
          <source>Instantiates an initializer from a configuration dictionary.</source>
          <target state="translated">Инициализирует инициализатор из конфигурационного словаря.</target>
        </trans-unit>
        <trans-unit id="37c35605484e0d745ddc5664f56cd31ede10bf0c" translate="yes" xml:space="preserve">
          <source>Instantiates the Densenet121 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653e7446bf8e535b95649a14a1a4040bb848a0b" translate="yes" xml:space="preserve">
          <source>Instantiates the Densenet169 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f508e422c41ca1583ddcf82367eac1c471fd48b0" translate="yes" xml:space="preserve">
          <source>Instantiates the Densenet201 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9dfa1e763ba9c6ee2a8efbc3b3a17aaaf64ef6" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB0 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee114842722aaf43b1f00ba82ed047ce9ea3625c" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB1 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49a42cfb87e77c9458417cc44f0470e88bd18fb" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB2 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec05ff7ddf6d159bc29b6ab06f9919b453979907" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB3 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e274afe59e85bd28123c509e293ddef256fc47e7" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB4 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670cd5b074f325a33ec1e7cb64c2835e0650303e" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB5 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6190fec6179c6ac2542069c4aa38c7426259e5fb" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB6 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d01c143ca90bb8d3f8102a2cb478d8ce8006779" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB7 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75adf7e363222d5982bb56012c80c73ff05f830f" translate="yes" xml:space="preserve">
          <source>Instantiates the Inception v3 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d78bcfb25bd570f535140464bdf38a98cccde81" translate="yes" xml:space="preserve">
          <source>Instantiates the Inception-ResNet v2 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b89338d0787e01e1e52b18673f6ae4ee703c4d" translate="yes" xml:space="preserve">
          <source>Instantiates the MobileNetV2 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531578a4574367ea2e522f8daeb216a6ce63c736" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet101 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125861983e29828c299a903f43d798714d2a4065" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet101V2 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8086b3c4c214259579bd6fac585cf9962ba4b8" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet152 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e500067287dc9f9611a296525538c5abcd7cc2" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet152V2 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27fa3302c8b3ab65c7c2bc821f6a3c6a294198d4" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet50V2 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ef306da9dababdc7dcdebe674cef89859a3705" translate="yes" xml:space="preserve">
          <source>Instead of a string enum, prefer &lt;code&gt;DEFINE_enum_class&lt;/code&gt;, which allows defining enums from an &lt;code&gt;enum.Enum&lt;/code&gt; class.</source>
          <target state="translated">Вместо строкового перечисления предпочтите &lt;code&gt;DEFINE_enum_class&lt;/code&gt; , который позволяет определять перечисления из класса &lt;code&gt;enum.Enum&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">Вместо этого:</target>
        </trans-unit>
        <trans-unit id="512626e184ef04fe486402828c5c025627c4c4b2" translate="yes" xml:space="preserve">
          <source>Instead of working with &lt;code&gt;Tensor&lt;/code&gt; objects, most operations work with &lt;code&gt;TensorArray&lt;/code&gt; objects directly.</source>
          <target state="translated">Вместо работы с объектами &lt;code&gt;Tensor&lt;/code&gt; большинство операций работают напрямую с объектами &lt;code&gt;TensorArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5af1b9159af411b6d7c635a164a0a3cae7782b83" translate="yes" xml:space="preserve">
          <source>Instead, use TensorFlow collections like &lt;a href=&quot;tensorarray&quot;&gt;&lt;code&gt;tf.TensorArray&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вместо этого используйте коллекции &lt;a href=&quot;tensorarray&quot;&gt; &lt;code&gt;tf.TensorArray&lt;/code&gt; &lt;/a&gt; например tf.TensorArray :</target>
        </trans-unit>
        <trans-unit id="986b3aa1fa9c8a53c78f4ac79b77467a9d988af6" translate="yes" xml:space="preserve">
          <source>Instead, we can use &lt;code&gt;tensor.experimental_ref()&lt;/code&gt;.</source>
          <target state="translated">Вместо этого мы можем использовать &lt;code&gt;tensor.experimental_ref()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6172bfc8c17542f600fe289d1b62d9a4b7a9359b" translate="yes" xml:space="preserve">
          <source>Instead, we can use &lt;code&gt;tensor.ref()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f88879032bd2f2457bad138fb5059212807b2a" translate="yes" xml:space="preserve">
          <source>Instead, we can use &lt;code&gt;variable.experimental_ref()&lt;/code&gt;.</source>
          <target state="translated">Вместо этого мы можем использовать &lt;code&gt;variable.experimental_ref()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3ce0ddf9c926093dd6fb8689fc2f4b12d054544" translate="yes" xml:space="preserve">
          <source>Instead, we can use &lt;code&gt;variable.ref()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865bac3875319b333427170b8f58a76d52bdfa96" translate="yes" xml:space="preserve">
          <source>Instead, wrap nested &lt;code&gt;@tf.custom_gradients&lt;/code&gt; in another function:</source>
          <target state="translated">Вместо этого оберните вложенные &lt;code&gt;@tf.custom_gradients&lt;/code&gt; в другую функцию:</target>
        </trans-unit>
        <trans-unit id="48fdffce381680dc01bd7387e5ff47c9e92e8b06" translate="yes" xml:space="preserve">
          <source>Int (default: 32).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aaccd55781d8df00a39c7af94d3d28b37361602" translate="yes" xml:space="preserve">
          <source>Int (default: None).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaec79069c9826c094fc28bfba022f7ba15126dc" translate="yes" xml:space="preserve">
          <source>Int or tuple of int (length 2) How many units should be trimmed off at the beginning and end of the cropping dimension (axis 1). If a single int is provided, the same value will be used for both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e182a1f01e97f35d5924b841ddd0d35ebe2837ad" translate="yes" xml:space="preserve">
          <source>Int specifying the channels axis. &lt;code&gt;axis=-1&lt;/code&gt; corresponds to data format &lt;code&gt;channels_last', and&lt;/code&gt;axis=1&lt;code&gt;corresponds to data format&lt;/code&gt;channels_first`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c1fe0f3b374162b4a2ca48b5634cc5e178bbe3" translate="yes" xml:space="preserve">
          <source>Int, how many dropout mask will be generated. It is useful for cell that has internal weights fused together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91567b0bdb3e9d727777ac8dfb086e5450943279" translate="yes" xml:space="preserve">
          <source>Int, or tuple of 2 integers. The upsampling factors for rows and columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d4b52ccd5a5944ba036967e1e0013e3a712e87" translate="yes" xml:space="preserve">
          <source>Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1094de6d5b113921eb5a29974615186e064dad7a" translate="yes" xml:space="preserve">
          <source>Int, or tuple of 3 integers. The upsampling factors for dim1, dim2 and dim3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605a79b8c702d3c89a259892042db0a515f2131e" translate="yes" xml:space="preserve">
          <source>Int, or tuple of 3 ints, or tuple of 3 tuples of 2 ints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c26a9027902710fd5c332e37e53db69471e1a23" translate="yes" xml:space="preserve">
          <source>Int, or tuple of int (length 2), or dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce684fb120f5dbcc5717f1102bb3deb9fd23c797" translate="yes" xml:space="preserve">
          <source>Int. Degree range for random rotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b74cc7edd585738b5f3ce8b9218040b2725b64" translate="yes" xml:space="preserve">
          <source>Int. Do not re-evaluate unless the last evaluation was started at least this many seconds ago. Of course, evaluation does not occur if no new checkpoints are available, hence, this is the minimum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e678a94768fbb08f3be3daec9e20719ff102cce6" translate="yes" xml:space="preserve">
          <source>Int. Positive number of steps for which to evaluate model. If &lt;code&gt;None&lt;/code&gt;, evaluates until &lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception. See &lt;a href=&quot;../compat/v1/estimator/estimator#evaluate&quot;&gt;&lt;code&gt;Estimator.evaluate&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b68a61eb5205896629486296aef43add0c23c824" translate="yes" xml:space="preserve">
          <source>Int. Positive number of total steps for which to train model. If &lt;code&gt;None&lt;/code&gt;, train forever. The training &lt;code&gt;input_fn&lt;/code&gt; is not expected to generate &lt;code&gt;OutOfRangeError&lt;/code&gt; or &lt;code&gt;StopIteration&lt;/code&gt; exceptions. See the &lt;code&gt;train_and_evaluate&lt;/code&gt; stop condition section for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128d22b45ec9bf45bb8958a64657b9ae9b3016e7" translate="yes" xml:space="preserve">
          <source>Int. Start evaluating after waiting for this many seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c893667a4725d4728d8955120def8bd0caef8554" translate="yes" xml:space="preserve">
          <source>Int. global step this summary is associated with. If &lt;code&gt;None&lt;/code&gt;, it will try to fetch the current step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f1b9c838e3bdee9d4226dd5a70ef1f7d198e1a" translate="yes" xml:space="preserve">
          <source>Integer &amp;gt;= 2, number of on GPUs on which to create model replicas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5a90a943564f7a628a84e21312bf2ef63b9877" translate="yes" xml:space="preserve">
          <source>Integer (scalar), number of axes.</source>
          <target state="translated">Целое (скаляр),количество осей.</target>
        </trans-unit>
        <trans-unit id="632b435479a4f941ea8cb031b6434f5cf0246f4a" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;Tensor&lt;/code&gt; with shape [D1, ... DN, k] where N &amp;gt;= 1. Commonly, N=1 and predictions has shape [batch size, k]. The final dimension contains the top &lt;code&gt;k&lt;/code&gt; predicted class indices. [D1, ... DN] must match &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba10e8d77de8d85dc8f7ffede369439ca46e1793" translate="yes" xml:space="preserve">
          <source>Integer class ID for which we want binary metrics. This should be in range [0, num_classes), where num_classes is the last dimension of &lt;code&gt;predictions&lt;/code&gt;. If class_id is outside this range, the method returns NAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7584ef68ba028e33c608eba25f0800f58fd323d" translate="yes" xml:space="preserve">
          <source>Integer class ID for which we want binary metrics. This should be in range [0, num_classes], where num_classes is the last dimension of &lt;code&gt;predictions&lt;/code&gt;. If &lt;code&gt;class_id&lt;/code&gt; is outside this range, the method returns NAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f540c874285d721d8fcd0d3ea0c7ef0568ca56a6" translate="yes" xml:space="preserve">
          <source>Integer dtype to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a5d193b7855cdee378a1f1325316aa3d36fe9d" translate="yes" xml:space="preserve">
          <source>Integer ground truth values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8db02371b65068479c3c0bd540c1643d1742823" translate="yes" xml:space="preserve">
          <source>Integer hash_key that will be used by the &lt;code&gt;FingerprintCat64&lt;/code&gt; function. If not given, a default key is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb0bee49a715975c31f963e5f0149fa6c8ed7e6" translate="yes" xml:space="preserve">
          <source>Integer hash_key that will be used by the &lt;code&gt;FingerprintCat64&lt;/code&gt; function. If not given, will use a default key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d56b77568017246afb3e6304f9b0829a9d58f81" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per batch of computation. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of a dataset, generators, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9865f8ea271cb814a62944707f966161b1f988f" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per batch of computation. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of a dataset, generators, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec55393c87a831154f49f5a6c6a96f32c7c0366d" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per batch. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of dataset, generators, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cf10e04b5ec63fa0038e1d594552454650016f" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per batch. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of dataset, generators, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2980185c242625e64631aa2188651861e27ce5fc" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per gradient update. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of datasets, generators, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bbc8f9459243c926740f24c7bc12e664a5dec2" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per gradient update. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of datasets, generators, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a869efbb667ad57f17e3cba30053054a9847d5f8" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per validation batch. If unspecified, will default to &lt;code&gt;batch_size&lt;/code&gt;. Do not specify the &lt;code&gt;validation_batch_size&lt;/code&gt; if your data is in the form of datasets, generators, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877acce569d433d882bfc7dcaaef24db8428c9c3" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per validation batch. If unspecified, will default to &lt;code&gt;batch_size&lt;/code&gt;. Do not specify the &lt;code&gt;validation_batch_size&lt;/code&gt; if your data is in the form of datasets, generators, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8221094e8ae1087245a4899dd4587e32e1631a3" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default &lt;code&gt;None&lt;/code&gt; is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the &lt;code&gt;steps_per_epoch&lt;/code&gt; argument. This argument is not supported with array inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b5325521dae896ba091f0c622bb685243a752c" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default &lt;code&gt;None&lt;/code&gt; is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the &lt;code&gt;steps_per_epoch&lt;/code&gt; argument. This argument is not supported with array inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9bfe8f19e849a992284a80f1a5980131517eec2" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring the evaluation round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, 'evaluate' will run until the dataset is exhausted. This argument is not supported with array inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebe399fc79d830decb4088d9908b0a0d7cf8e87" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring the evaluation round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, 'evaluate' will run until the dataset is exhausted. This argument is not supported with array inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f9a2d337158bb6ad4889e0b1e861a66788f5ae" translate="yes" xml:space="preserve">
          <source>Integer or List/Tuple. The axis or axes to normalize across. Typically this is the features axis/axes. The left-out axes are typically the batch axis/axes. This argument defaults to &lt;code&gt;-1&lt;/code&gt;, the last dimension in the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eccdff7a407865cbfbdc69eea10f4bd5a37039a" translate="yes" xml:space="preserve">
          <source>Integer or Long, dimensionality of the output space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b058f1f30deac1321d12aaea555f116fa6dcac5" translate="yes" xml:space="preserve">
          <source>Integer or TensorShape: size of outputs produced by this cell.</source>
          <target state="translated">Integer или TensorShape:размер выходов,производимых этой ячейкой.</target>
        </trans-unit>
        <trans-unit id="c85d071ff67fea5317214e2c8376aa4e5f8888ac" translate="yes" xml:space="preserve">
          <source>Integer or iterable of integers. Axes to reverse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee228302b0384ee03ffd17e6827b3463a0b3348" translate="yes" xml:space="preserve">
          <source>Integer or tuple of integers, axis or axes along which to take the dot product. If a tuple, should be two integers corresponding to the desired axis from the first input and the desired axis from the second input, respectively. Note that the size of the two selected axes must match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5999e6dc053e2977702144f72bbcd35aee55179e" translate="yes" xml:space="preserve">
          <source>Integer or tuple of integers, the axis or axes that should be &quot;kept&quot;. These axes are not be summed over when calculating the normalization statistics. By default the last axis, the &lt;code&gt;features&lt;/code&gt; axis is kept and any &lt;code&gt;space&lt;/code&gt; or &lt;code&gt;time&lt;/code&gt; axes are summed. Each element in the the axes that are kept is normalized independently. If &lt;code&gt;axis&lt;/code&gt; is set to 'None', the layer will perform scalar normalization (diving the input by a single scalar value). The &lt;code&gt;batch&lt;/code&gt; axis, 0, is always summed over (&lt;code&gt;axis=0&lt;/code&gt; is not allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f12259e9abc566ecc3b05524f7d03fd2cfe6bc" translate="yes" xml:space="preserve">
          <source>Integer specifying the dimension index at which to expand the shape of &lt;code&gt;input&lt;/code&gt;. Given an input of D dimensions, &lt;code&gt;axis&lt;/code&gt; must be in range &lt;code&gt;[-(D+1), D]&lt;/code&gt; (inclusive).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c8cacca8698bf82625320d9b131a8bbb189fa16" translate="yes" xml:space="preserve">
          <source>Integer specifying the number of times to read through the dataset. If None, cycles through the dataset forever. Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ed15721d2c6d90008e99eaa483ba3f10bfd42a" translate="yes" xml:space="preserve">
          <source>Integer specifying the ragged rank for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. Must be greater than zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6519af9839eeba13e1e3740388939a4fa489a7c0" translate="yes" xml:space="preserve">
          <source>Integer, axis along which the softmax normalization is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d462894a57295d00bad79d961363f1631df9a74" translate="yes" xml:space="preserve">
          <source>Integer, expected rank of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62aa1ce6b98f050a623a72f064615f7ebaa28d3" translate="yes" xml:space="preserve">
          <source>Integer, how many top-guesses to return. Defaults to 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3611bec378f4b1d08160ba75818e35ce0f93549b" translate="yes" xml:space="preserve">
          <source>Integer, index of batch within the current epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d62c86ad8d866ffc788d8720b66c0f5e1be2cd" translate="yes" xml:space="preserve">
          <source>Integer, index of epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d657f1197d0e928e79d10b7b8d03e4e1ddc001" translate="yes" xml:space="preserve">
          <source>Integer, index of layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b561718573e7177a1eac4fbcbc3cc498d676fdb" translate="yes" xml:space="preserve">
          <source>Integer, k for @k metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1b6cc9500ca213cd3d0d99297a95ed6f3fd50e" translate="yes" xml:space="preserve">
          <source>Integer, k for @k metric. Only used for the default op name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52761a9a4283c1bc429a5480ab3ec7776b2ca8db" translate="yes" xml:space="preserve">
          <source>Integer, k for @k metric. This will calculate an average precision for range &lt;code&gt;[1,k]&lt;/code&gt;, as documented above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd36e6413d49b9537f7506be11f776c7d3c71a0" translate="yes" xml:space="preserve">
          <source>Integer, maximum rank of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08ffbff16740d8bc9516f3946ce07004cac1737" translate="yes" xml:space="preserve">
          <source>Integer, minimum rank of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9adb0e2ec41b5e471885175b1bf95f7edf8655" translate="yes" xml:space="preserve">
          <source>Integer, number of classes to consider.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27732837f81f5463d8f22501064a789937c5355" translate="yes" xml:space="preserve">
          <source>Integer, number of epochs to iterate over data. If &lt;code&gt;None&lt;/code&gt; will run forever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756d2f5bfa1491c14c543cdef058099c4a02c7b9" translate="yes" xml:space="preserve">
          <source>Integer, number of rows/columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1f994bd3e44dc5bab28185ee0d3ebc20ffca14" translate="yes" xml:space="preserve">
          <source>Integer, number of threads used for reading and enqueueing. In order to have predicted and repeatable order of reading and enqueueing, such as in prediction and evaluation mode, &lt;code&gt;num_threads&lt;/code&gt; should be 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18288dd031d517cfdcd834085b33c2abfce77bab" translate="yes" xml:space="preserve">
          <source>Integer, optional number of classes to classify images into, only to be specified if &lt;code&gt;include_top&lt;/code&gt; is True, and if no &lt;code&gt;weights&lt;/code&gt; argument is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1871917c279bfb78ebdc3c2e0743674ed63b10" translate="yes" xml:space="preserve">
          <source>Integer, or None. Factor by which to downscale. E.g. 2 will halve the input. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed9c65455c7ec7abdfccef38a621dc178eac27f2" translate="yes" xml:space="preserve">
          <source>Integer, or None. Specifies how much the pooling window moves for each pooling step. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b1cb642daf858515eca24974112fed3f4eda5c" translate="yes" xml:space="preserve">
          <source>Integer, random seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5520bbbf4a96e6a5c4b5b06bd200711c43958c41" translate="yes" xml:space="preserve">
          <source>Integer, random seed. Will use a random numpy integer when not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968237390c8614c7a696335a1225258fb805d241" translate="yes" xml:space="preserve">
          <source>Integer, repetition factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264e939c19b3f58405d2a50cba3a1680fb5e9096" translate="yes" xml:space="preserve">
          <source>Integer, size of a batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1a622ea56d7a867dad89ba08cf28b246d08f31" translate="yes" xml:space="preserve">
          <source>Integer, size of batches to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7832b33757b55335554c75f07149fc0123c05315" translate="yes" xml:space="preserve">
          <source>Integer, size of queue to accumulate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73acbfd02c64cde7c7d343aff1fa25e08d1cb5ef" translate="yes" xml:space="preserve">
          <source>Integer, size of the average pooling windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfa7ccddd5c7b3f54d3e32cc02d165c9b48661f" translate="yes" xml:space="preserve">
          <source>Integer, size of the max pooling window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed72656810565497136a688b72e432ebfed4fb3" translate="yes" xml:space="preserve">
          <source>Integer, the axis that should be normalized (typically the features axis). For instance, after a &lt;code&gt;Conv2D&lt;/code&gt; layer with &lt;code&gt;data_format=&quot;channels_first&quot;&lt;/code&gt;, set &lt;code&gt;axis=1&lt;/code&gt; in &lt;code&gt;BatchNormalization&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020ea74d267152d1abff3869457ed35e7f440945" translate="yes" xml:space="preserve">
          <source>Integer, the axis that should be normalized. (typically the features axis).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a43ff40e1f9e474e4c712af800f92e564d4913" translate="yes" xml:space="preserve">
          <source>Integer, the dimensionality of the output space (i.e. the number of filters in the convolution).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b610dfd9ecc1049624b3de2024a90db568d1cf07" translate="yes" xml:space="preserve">
          <source>Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8819f86173a8bca874d8aee9f0470a39d17dbfe" translate="yes" xml:space="preserve">
          <source>Integer, the height of the output shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e17f88143adecb575931142178922e1f292bca6" translate="yes" xml:space="preserve">
          <source>Integer, the number of scalars in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Целое число, количество скаляров в &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26487eb49125ef03870c0b659a881b807b193aa6" translate="yes" xml:space="preserve">
          <source>Integer, the width of the output shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd273ac6a47ca8cb36aefa50612c554a6d42ca7" translate="yes" xml:space="preserve">
          <source>Integer, tuple of 2 integers, or None. Strides values. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05e7e32a0a856148bde05e620e4a31af13622d8" translate="yes" xml:space="preserve">
          <source>Integer, tuple of 2 integers, or None. Strides values. Specifies how far the pooling window moves for each pooling step. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fbd2feec40ae60d2527e32c4735ba4f6949693" translate="yes" xml:space="preserve">
          <source>Integer. Dimension of the dense embedding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af39051e9e4b562c28e9a14aea3e781886cc1d8d" translate="yes" xml:space="preserve">
          <source>Integer. Epoch at which to start training (useful for resuming a previous training run).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2829e20dc8a95a905ae11cb111c6f5ce9e14cab2" translate="yes" xml:space="preserve">
          <source>Integer. If specified, refers to a dimension of the input tensor, such that quantization will be per slice along that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155a6c0384cc7d6005f32e2cdc3809924edbbb8b" translate="yes" xml:space="preserve">
          <source>Integer. Number of epochs to train the model. An epoch is an iteration over the entire &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; data provided. Note that in conjunction with &lt;code&gt;initial_epoch&lt;/code&gt;, &lt;code&gt;epochs&lt;/code&gt; is to be understood as &quot;final epoch&quot;. The model is not trained for a number of iterations given by &lt;code&gt;epochs&lt;/code&gt;, but merely until the epoch of index &lt;code&gt;epochs&lt;/code&gt; is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65631ff0724feabaccec4abc08da39ab086c3adc" translate="yes" xml:space="preserve">
          <source>Integer. Size of the queue for pending events and summaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ed747fc26142e27c2c7f14fa48a57b250a55b1" translate="yes" xml:space="preserve">
          <source>Integer. Size of the vocabulary, i.e. maximum integer index + 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68da2a75ba273567e4ed4a88dd4f1b24839014f8" translate="yes" xml:space="preserve">
          <source>Integer. Upsampling factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b26edd58891203d3630f5778a3b8ce101f4387" translate="yes" xml:space="preserve">
          <source>Integer. Used for generator or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum number of processes to spin up when using process-based threading. If unspecified, &lt;code&gt;workers&lt;/code&gt; will default to 1. If 0, will execute the generator on the main thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1dd01fbd0a0e315fb17382ec430a1e09ccd62f" translate="yes" xml:space="preserve">
          <source>Integer. Used for generator or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum size for the generator queue. If unspecified, &lt;code&gt;max_queue_size&lt;/code&gt; will default to 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a95c0266c9ac916ee83cc2715cb7f4a9453c87" translate="yes" xml:space="preserve">
          <source>Integer. Used for generator or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum number of processes to spin up when using process-based threading. If unspecified, &lt;code&gt;workers&lt;/code&gt; will default to 1. If 0, will execute the generator on the main thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026625dde93ca9f9da22c49466b3704e8d8d9ede" translate="yes" xml:space="preserve">
          <source>Integer. Used for generator or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum size for the generator queue. If unspecified, &lt;code&gt;max_queue_size&lt;/code&gt; will default to 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ef96833f4704c59b53b19fc9aaaf4497588d54" translate="yes" xml:space="preserve">
          <source>Integer. Used to create a random seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fe9ca590793172ed8cbbdd39a8aa90fd85af4d" translate="yes" xml:space="preserve">
          <source>Intended for &quot;grouping&quot; multiple checkpoints in a sharded checkpoint setup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c415d05fde4b20fb3d078c3ec3eea128c860727" translate="yes" xml:space="preserve">
          <source>Intended for use in gradient code which might deal with &lt;code&gt;IndexedSlices&lt;/code&gt; objects, which are easy to multiply by a scalar but more expensive to multiply with arbitrary tensors.</source>
          <target state="translated">Предназначен для использования в коде градиента, который может иметь дело с объектами &lt;code&gt;IndexedSlices&lt;/code&gt; , которые легко умножить на скаляр, но дороже умножить на произвольные тензоры.</target>
        </trans-unit>
        <trans-unit id="09de4915cfc5e9dec66a0e4b3cf98d49d13a1bf5" translate="yes" xml:space="preserve">
          <source>Interface for listeners that take action before or after checkpoint save.</source>
          <target state="translated">Интерфейс для слушателей,которые предпринимают действия до или после сохранения контрольно-пропускного пункта.</target>
        </trans-unit>
        <trans-unit id="7966d1ee34aecdadb5e17da45b8dc52964483fe6" translate="yes" xml:space="preserve">
          <source>Interface for the head/top of a model.</source>
          <target state="translated">Интерфейс для головы/верху модели.</target>
        </trans-unit>
        <trans-unit id="970dc6a3a66245c62ed217c2880dacf860847f5f" translate="yes" xml:space="preserve">
          <source>Interface representing a stateful summary writer object.</source>
          <target state="translated">Интерфейс,представляющий собой объект краткого описания состояния.</target>
        </trans-unit>
        <trans-unit id="267b20fba551cfdfeaade8ce47b964dcb7474511" translate="yes" xml:space="preserve">
          <source>Interleave the values from the &lt;code&gt;data&lt;/code&gt; tensors into a single tensor.</source>
          <target state="translated">Перемежайте значения из тензоров &lt;code&gt;data&lt;/code&gt; в один тензор.</target>
        </trans-unit>
        <trans-unit id="9d395369c8c508d85c7ffcfcd89cd26ab4bce1e5" translate="yes" xml:space="preserve">
          <source>InterleaveDataset</source>
          <target state="translated">InterleaveDataset</target>
        </trans-unit>
        <trans-unit id="dfeb3be591d4b480789b9b8465a40c757f82e1e8" translate="yes" xml:space="preserve">
          <source>Internal helper function for 'sp_t / dense_t'.</source>
          <target state="translated">Внутренняя вспомогательная функция для 'sp_t/dense_t'.</target>
        </trans-unit>
        <trans-unit id="e702c08b377f90299d4d1edf33ea46f8d70ab908" translate="yes" xml:space="preserve">
          <source>Internal scopes and variable names should not depend on any arguments that are not supplied to &lt;code&gt;make_template&lt;/code&gt;. In general you will get a ValueError telling you that you are trying to reuse a variable that doesn't exist if you make a mistake.</source>
          <target state="translated">Внутренние области видимости и имена переменных не должны зависеть от каких-либо аргументов, не предоставленных &lt;code&gt;make_template&lt;/code&gt; . Как правило, вы получите ValueError, сообщающее, что вы пытаетесь повторно использовать переменную, которой не существует, если вы допустили ошибку.</target>
        </trans-unit>
        <trans-unit id="a8a9d8482fb70d4cb98a40c92c111baaae956ec4" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; can build more than one graph, to support arguments with different data types or shapes, since TensorFlow can build more efficient graphs that are specialized on shapes and dtypes. &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; also treats any pure Python value as opaque objects, and builds a separate graph for each set of Python arguments that it encounters.</source>
          <target state="translated">Внутри &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; может строить более одного графа для поддержки аргументов с разными типами данных или формами, поскольку TensorFlow может строить более эффективные графы, которые специализируются на формах и типах данных. &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; также обрабатывает любое чистое значение Python как непрозрачные объекты и строит отдельный график для каждого набора аргументов Python, с которыми он сталкивается.</target>
        </trans-unit>
        <trans-unit id="3754c7a802c267bca9422c11ea6f0ba375d68725" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; adds outside compilation attributes to all ops in &lt;code&gt;computation&lt;/code&gt;. During later graph pass, these ops with outside compilation attribute is extracted out and replicated into a host-side graph. Inputs to this extract host-side graph is sent from TPU computation graph to host graph via a pair of XlaSendToHost and XlaRecvFromHost ops. Note that using &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; may result in tensor transfer between TPU and CPU, leading to non-trivial performance impact.</source>
          <target state="translated">Внутри &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; добавляет внешние атрибуты компиляции ко всем операциям в &lt;code&gt;computation&lt;/code&gt; . Во время более позднего прохода графа эти операции с внешним атрибутом компиляции извлекаются и реплицируются в граф на стороне хоста. Входные данные для этого извлечения графа на стороне хоста отправляются из графа вычислений TPU в граф хоста через пару операций XlaSendToHost и XlaRecvFromHost. Обратите внимание, что использование &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; может привести к тензорной передаче между TPU и CPU, что приведет к нетривиальному снижению производительности.</target>
        </trans-unit>
        <trans-unit id="c3b11c4a32c583b06a946fb7dece277cfaecec4c" translate="yes" xml:space="preserve">
          <source>Internally, a &lt;code&gt;RaggedTensor&lt;/code&gt; consists of a concatenated list of values that are partitioned into variable-length rows. In particular, each &lt;code&gt;RaggedTensor&lt;/code&gt; consists of:</source>
          <target state="translated">Внутри &lt;code&gt;RaggedTensor&lt;/code&gt; состоит из конкатенированного списка значений, которые разбиты на строки переменной длины. В частности, каждый &lt;code&gt;RaggedTensor&lt;/code&gt; состоит из:</target>
        </trans-unit>
        <trans-unit id="255d2ec4d3c0d9058219b6e2356af764fe41dab1" translate="yes" xml:space="preserve">
          <source>Internally, images are either stored in as one &lt;code&gt;float32&lt;/code&gt; per channel per pixel (implicitly, values are assumed to lie in &lt;code&gt;[0,1)&lt;/code&gt;) or one &lt;code&gt;uint8&lt;/code&gt; per channel per pixel (values are assumed to lie in &lt;code&gt;[0,255]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d19ba05c07ee939684f9bc5632fa152a3e99c6" translate="yes" xml:space="preserve">
          <source>Internally, this op reshapes the input tensors and invokes &lt;a href=&quot;../../../nn/conv2d&quot;&gt;&lt;code&gt;tf.nn.conv2d&lt;/code&gt;&lt;/a&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot;, a tensor of shape &lt;code&gt;batch_shape + [in_width, in_channels]&lt;/code&gt; is reshaped to &lt;code&gt;batch_shape + [1, in_width, in_channels]&lt;/code&gt;, and the filter is reshaped to &lt;code&gt;[1, filter_width, in_channels, out_channels]&lt;/code&gt;. The result is then reshaped back to &lt;code&gt;batch_shape + [out_width, out_channels]&lt;/code&gt; (where out_width is a function of the stride and padding as in conv2d) and returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc43cd3b01644683dd7e060724d61cbe55125e2" translate="yes" xml:space="preserve">
          <source>Internally, this op reshapes the input tensors and invokes &lt;a href=&quot;../../../nn/conv2d&quot;&gt;&lt;code&gt;tf.nn.conv2d&lt;/code&gt;&lt;/a&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot;, a tensor of shape [batch, in_width, in_channels] is reshaped to [batch, 1, in_width, in_channels], and the filter is reshaped to [1, filter_width, in_channels, out_channels]. The result is then reshaped back to [batch, out_width, out_channels] (where out_width is a function of the stride and padding as in conv2d) and returned to the caller.</source>
          <target state="translated">Внутренне эта операция изменяет входные тензоры и вызывает &lt;a href=&quot;../../../nn/conv2d&quot;&gt; &lt;code&gt;tf.nn.conv2d&lt;/code&gt; &lt;/a&gt; . Например, если &lt;code&gt;data_format&lt;/code&gt; не начинается с &amp;laquo;NC&amp;raquo;, тензор формы [batch, in_width, in_channels] изменяется на [batch, 1, in_width, in_channels], а фильтр изменяется на [1, filter_width, in_channels, out_channels]. Затем результат преобразуется обратно в [batch, out_width, out_channels] (где out_width является функцией шага и заполнения, как в conv2d) и возвращается вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="7c69ad0876e39d22ce51635e4a30f9a378a7dbe4" translate="yes" xml:space="preserve">
          <source>Internally, this op reshapes the input tensors and invokes &lt;a href=&quot;conv2d&quot;&gt;&lt;code&gt;tf.nn.conv2d&lt;/code&gt;&lt;/a&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot;, a tensor of shape [batch, in_width, in_channels] is reshaped to [batch, 1, in_width, in_channels], and the filter is reshaped to [1, filter_width, in_channels, out_channels]. The result is then reshaped back to [batch, out_width, out_channels] (where out_width is a function of the stride and padding as in conv2d) and returned to the caller.</source>
          <target state="translated">Внутренне эта операция изменяет входные тензоры и вызывает &lt;a href=&quot;conv2d&quot;&gt; &lt;code&gt;tf.nn.conv2d&lt;/code&gt; &lt;/a&gt; . Например, если &lt;code&gt;data_format&lt;/code&gt; не начинается с &amp;laquo;NC&amp;raquo;, тензор формы [batch, in_width, in_channels] изменяется на [batch, 1, in_width, in_channels], а фильтр изменяется на [1, filter_width, in_channels, out_channels]. Затем результат преобразуется обратно в [batch, out_width, out_channels] (где out_width является функцией шага и заполнения, как в conv2d) и возвращается вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="77366db31216abb65fcc3e1ddedf30536706afa8" translate="yes" xml:space="preserve">
          <source>Internally, this op reshapes the input tensors and invokes &lt;a href=&quot;conv2d&quot;&gt;&lt;code&gt;tf.nn.conv2d&lt;/code&gt;&lt;/a&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; does not start with &lt;code&gt;&quot;NC&quot;&lt;/code&gt;, a tensor of shape &lt;code&gt;batch_shape + [in_width, in_channels]&lt;/code&gt; is reshaped to &lt;code&gt;batch_shape + [1, in_width, in_channels]&lt;/code&gt;, and the filter is reshaped to &lt;code&gt;[1, filter_width, in_channels, out_channels]&lt;/code&gt;. The result is then reshaped back to &lt;code&gt;batch_shape + [out_width, out_channels]&lt;/code&gt; (where out_width is a function of the stride and padding as in conv2d) and returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917c90b98804c8a00e2f1f77d52497e6cc4c5478" translate="yes" xml:space="preserve">
          <source>Interpolation formula inspired by section 4 of Davis &amp;amp; Goadrich 2006.</source>
          <target state="translated">Формула интерполяции вдохновлена ​​разделом 4 Davis &amp;amp; Goadrich 2006.</target>
        </trans-unit>
        <trans-unit id="eff3de259388706cb8f11066e0a617e4e6f361f0" translate="yes" xml:space="preserve">
          <source>Interpolation method used to resample the image if the target size is different from that of the loaded image. Supported methods are &quot;nearest&quot;, &quot;bilinear&quot;, and &quot;bicubic&quot;. If PIL version 1.1.3 or newer is installed, &quot;lanczos&quot; is also supported. If PIL version 3.4.0 or newer is installed, &quot;box&quot; and &quot;hamming&quot; are also supported. By default, &quot;nearest&quot; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a83be95e3b71f9242daf3a730745b97d6a8590" translate="yes" xml:space="preserve">
          <source>Interpolation method used to resample the image if the target size is different from that of the loaded image. Supported methods are &lt;code&gt;&quot;nearest&quot;&lt;/code&gt;, &lt;code&gt;&quot;bilinear&quot;&lt;/code&gt;, and &lt;code&gt;&quot;bicubic&quot;&lt;/code&gt;. If PIL version 1.1.3 or newer is installed, &lt;code&gt;&quot;lanczos&quot;&lt;/code&gt; is also supported. If PIL version 3.4.0 or newer is installed, &lt;code&gt;&quot;box&quot;&lt;/code&gt; and &lt;code&gt;&quot;hamming&quot;&lt;/code&gt; are also supported. By default, &lt;code&gt;&quot;nearest&quot;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d41d1157db67f4ae8d3353790336143377bd1fb" translate="yes" xml:space="preserve">
          <source>Interpolation mode. Supported values: &quot;nearest&quot;, &quot;bilinear&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1b48a15bee98562ab2271bf7c674c69c76f9d7" translate="yes" xml:space="preserve">
          <source>Interpreter interface for TensorFlow Lite Models.</source>
          <target state="translated">Интерфейс интерпретатора для моделей TensorFlow Lite.</target>
        </trans-unit>
        <trans-unit id="cd0dc8bec74842908edb1323c813960ee0d10418" translate="yes" xml:space="preserve">
          <source>Intuitively, separable convolutions can be understood as a way to factorize a convolution kernel into two smaller kernels, or as an extreme version of an Inception block.</source>
          <target state="translated">Интуитивно разделяемые конвекции можно понимать как способ факторизации конверсионного ядра в два меньших ядра,или как экстремальный вариант Блока Зачатия.</target>
        </trans-unit>
        <trans-unit id="e82e41a0aefa660a1c7caa85a3e51aff86500f3e" translate="yes" xml:space="preserve">
          <source>Inv</source>
          <target state="translated">Inv</target>
        </trans-unit>
        <trans-unit id="4f28f8a2e4fbc807a9598103ca92496ec62e9283" translate="yes" xml:space="preserve">
          <source>InvGrad</source>
          <target state="translated">InvGrad</target>
        </trans-unit>
        <trans-unit id="58add683489305dc7550dd9711b45a710de33407" translate="yes" xml:space="preserve">
          <source>Invalid &lt;code&gt;PhysicalDevice&lt;/code&gt; specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765dc4833ea51f9712325654e6149e4320ae0357" translate="yes" xml:space="preserve">
          <source>Invalid IDs (&amp;lt; 0) are pruned from input IDs and weights, as well as any IDs with non-positive weight. For an entry with no features, the embedding vector for &lt;code&gt;default_id&lt;/code&gt; is returned, or the 0-vector if &lt;code&gt;default_id&lt;/code&gt; is not supplied.</source>
          <target state="translated">Недействительные идентификаторы (&amp;lt;0) удаляются из входных идентификаторов и весов, а также любых идентификаторов с неположительным весом. Для записи без функций возвращается вектор внедрения для &lt;code&gt;default_id&lt;/code&gt; или вектор 0, если &lt;code&gt;default_id&lt;/code&gt; не указан.</target>
        </trans-unit>
        <trans-unit id="c83be98b0df67b85dda471c4f0e08d9948550727" translate="yes" xml:space="preserve">
          <source>Invalid arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7227e77ba4898ce78f530c7179daf1d58aee3eba" translate="yes" xml:space="preserve">
          <source>Invalid input type.</source>
          <target state="translated">Неверный тип ввода.</target>
        </trans-unit>
        <trans-unit id="5ad0fc9e3c1773fd6f82ccad6e0477a808a3ba38" translate="yes" xml:space="preserve">
          <source>Invalid signature keys.</source>
          <target state="translated">Недействительные ключи подписи.</target>
        </trans-unit>
        <trans-unit id="0bc32d3cdc428cf1f9b21217961b07a8ba0776de" translate="yes" xml:space="preserve">
          <source>InvalidArgumentError: When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have incomptatible shapes or types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0224cb82fac3bd64320723e2cfea88c4cb1de8e" translate="yes" xml:space="preserve">
          <source>Inverse 2D fast Fourier transform.</source>
          <target state="translated">Обратное 2D быстрое преобразование Фурье.</target>
        </trans-unit>
        <trans-unit id="f86113a2dbd7ed935c16e9099b42fb7e6dba6038" translate="yes" xml:space="preserve">
          <source>Inverse 2D real-valued fast Fourier transform.</source>
          <target state="translated">Обратное 2D быстрое преобразование Фурье в реальную величину.</target>
        </trans-unit>
        <trans-unit id="bf6cbaad72f3eb6b8fa736b0c48f1b4b54ba4d45" translate="yes" xml:space="preserve">
          <source>Inverse 3D fast Fourier transform.</source>
          <target state="translated">Обратное 3D быстрое преобразование Фурье.</target>
        </trans-unit>
        <trans-unit id="729fe142f2358fcfd2d893f486c7ef7071098901" translate="yes" xml:space="preserve">
          <source>Inverse 3D real-valued fast Fourier transform.</source>
          <target state="translated">Обратное трехмерное быстрое преобразование Фурье в реальную величину.</target>
        </trans-unit>
        <trans-unit id="2b74c26781dc19d8cf865c887430b83b4bb874bf" translate="yes" xml:space="preserve">
          <source>Inverse error function of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Функция обратной ошибки &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2769447bdda650e2de43a09ec7f4f9b88e781719" translate="yes" xml:space="preserve">
          <source>Inverse fast Fourier transform.</source>
          <target state="translated">Обратное быстрое преобразование Фурье.</target>
        </trans-unit>
        <trans-unit id="59aef4232893465c6aaa96756ca11d4d57c9f509" translate="yes" xml:space="preserve">
          <source>Inverse lookup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca1ad1de11fec11fe41231e47070833956358bf" translate="yes" xml:space="preserve">
          <source>Inverse of the &lt;code&gt;serialize&lt;/code&gt; function.</source>
          <target state="translated">Инверсия функции &lt;code&gt;serialize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21739830573f1c06f7716e20676dc8044ac7dbe1" translate="yes" xml:space="preserve">
          <source>Inverse real-valued fast Fourier transform.</source>
          <target state="translated">Обратное быстрое преобразование Фурье.</target>
        </trans-unit>
        <trans-unit id="e844690a2086d9678b13582fd4701152c826641f" translate="yes" xml:space="preserve">
          <source>Invert</source>
          <target state="translated">Invert</target>
        </trans-unit>
        <trans-unit id="454fcced1bbd08f2febd8b9e63fda971abd10063" translate="yes" xml:space="preserve">
          <source>Invert (flip) each bit of supported types; for example, type &lt;code&gt;uint8&lt;/code&gt; value 01010101 becomes 10101010.</source>
          <target state="translated">Инвертировать (перевернуть) каждый бит поддерживаемых типов; например, введите &lt;code&gt;uint8&lt;/code&gt; , значение 01010101 станет 10101010.</target>
        </trans-unit>
        <trans-unit id="bed096656d7fe5e741cc84abd73ada3bd6383ffb" translate="yes" xml:space="preserve">
          <source>InvertPermutation</source>
          <target state="translated">InvertPermutation</target>
        </trans-unit>
        <trans-unit id="91d644123d1e143b7bcae5cd3ca4411f53cc0582" translate="yes" xml:space="preserve">
          <source>Invoke the interpreter.</source>
          <target state="translated">Спросите переводчика.</target>
        </trans-unit>
        <trans-unit id="a3b88b5d9fb1f01311b785a98dab39ae651b2e05" translate="yes" xml:space="preserve">
          <source>Invokes a python function to compute func(input)-&amp;gt;output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07bd56502c92792eb48f74185c5de124c19b5f15" translate="yes" xml:space="preserve">
          <source>Invokes the &lt;code&gt;Loss&lt;/code&gt; instance.</source>
          <target state="translated">Вызывает экземпляр &lt;code&gt;Loss&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b13fc57aaccb54faea2366b6fa9ef75d7f668372" translate="yes" xml:space="preserve">
          <source>Is the column count of the product large (&amp;gt;&amp;gt; 1)?</source>
          <target state="translated">Количество столбцов продукта велико (&amp;gt;&amp;gt; 1)?</target>
        </trans-unit>
        <trans-unit id="b8d5c82b816bc835c62912b744400ff40c02617e" translate="yes" xml:space="preserve">
          <source>Is the density of &lt;code&gt;A&lt;/code&gt; larger than approximately 15%?</source>
          <target state="translated">Плотность &lt;code&gt;A&lt;/code&gt; больше примерно 15%?</target>
        </trans-unit>
        <trans-unit id="c601bf8fc05bd7645229907978ac2511d637fa1a" translate="yes" xml:space="preserve">
          <source>Is the value of the flag allowed to be None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643c612596426f0fec64f232c9d5aef6f88c639b" translate="yes" xml:space="preserve">
          <source>IsBoostedTreesEnsembleInitialized</source>
          <target state="translated">IsBoostedTreesEnsembleInitialized</target>
        </trans-unit>
        <trans-unit id="77075fc1d53795c8c08144c8db26e03533240f78" translate="yes" xml:space="preserve">
          <source>IsBoostedTreesQuantileStreamResourceInitialized</source>
          <target state="translated">IsBoostedTreesQuantileStreamResourceInitialized</target>
        </trans-unit>
        <trans-unit id="12c95b5f06bb33c3c5be9c54bc9046e6da772489" translate="yes" xml:space="preserve">
          <source>IsFinite</source>
          <target state="translated">IsFinite</target>
        </trans-unit>
        <trans-unit id="b3060aaecf7335f09adf39163594f94ba1f28def" translate="yes" xml:space="preserve">
          <source>IsInf</source>
          <target state="translated">IsInf</target>
        </trans-unit>
        <trans-unit id="d0fa60fb2ee6d1b84448737ee8599591dd40c001" translate="yes" xml:space="preserve">
          <source>IsNan</source>
          <target state="translated">IsNan</target>
        </trans-unit>
        <trans-unit id="46d7b64826025485ac80b869ef64ad6ef233f634" translate="yes" xml:space="preserve">
          <source>IsVariableInitialized</source>
          <target state="translated">IsVariableInitialized</target>
        </trans-unit>
        <trans-unit id="e9232fd5729c418e2cf69329c493d9342acec23c" translate="yes" xml:space="preserve">
          <source>Issue tracker</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
