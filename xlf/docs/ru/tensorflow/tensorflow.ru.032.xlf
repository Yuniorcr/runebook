<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="0888914c679befa9b2cb2fda6a224ddf95b82d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, depth, first_cropped_axis, second_cropped_axis, third_cropped_axis)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c350e594e6b51e761934912455eb294521cb46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, depth, first_padded_axis, second_padded_axis, third_axis_to_pad)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ec0b7162cfee960e285831df5e57e17a03a60e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, cropped_rows, cropped_cols, channels)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; - &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; каналы_последний &quot; : &lt;code&gt;(batch, cropped_rows, cropped_cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3080e83cbbe1150d4ffe3e63f9f6d620396eedd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, dim1, dim2, dim3, channels)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; - &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; каналы_последний &quot; : &lt;code&gt;(batch, dim1, dim2, dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="003ead137d3f3851640c5a5a4a06d578ee1562e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop, depth)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; равен &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d5b3587001e70040c247fd7de822807f24ae9ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad, depth)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; - &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; каналы_последний &quot; : &lt;code&gt;(batch, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="483c2efe5b6618e7f64dde6715f4895ce351e56e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, first_cropped_axis, second_cropped_axis, third_cropped_axis, depth)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; равен &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch, first_cropped_axis, second_cropped_axis, third_cropped_axis, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df33090fd8aa7bd86d0ae1a9759ce56513b08b8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, first_padded_axis, second_padded_axis, third_axis_to_pad, depth)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; равен &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch, first_padded_axis, second_padded_axis, third_axis_to_pad, depth)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eed95b4a9ed8b9aeb9fdbd8e1b9803e00bf2766e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, padded_rows, padded_cols, channels)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; - &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; каналы_последний &quot; : &lt;code&gt;(batch, padded_rows, padded_cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f64e4bcccce433c9566b78b8afa1f94c8c04fcef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, rows, cols, channels)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; - &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; каналы_последний &quot; : &lt;code&gt;(batch, rows, cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44f47dd0c8b0b06a1527506e0b470b0131115a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, upsampled_dim1, upsampled_dim2, upsampled_dim3, channels)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; равен &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; : &lt;code&gt;(batch, upsampled_dim1, upsampled_dim2, upsampled_dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830a8a4e419a5e596ab42fcfe1067a6cadcf5b6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch, upsampled_rows, upsampled_cols, channels)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format&lt;/code&gt; - &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; каналы_последний &quot; : &lt;code&gt;(batch, upsampled_rows, upsampled_cols, channels)&lt;/code&gt; строки с повышением частоты дискретизации, столбцы с повышением частоты , каналы)</target>
        </trans-unit>
        <trans-unit id="9c980e0bd3d4179a05d59b1cf890443d4ce25e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, cropped_rows, cropped_cols, channels)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e566b24c18ce9f031e746f46f8905e4b74631307" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, dim1, dim2, dim3, channels)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22610788dff2c48e984360f638bc6947aba295ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop, depth)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d6a71d79669cd17f507222aaf3cb490b770b36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad, depth)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e782b5886d40393da5db097215c23e91186e00a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, first_cropped_axis, second_cropped_axis, third_cropped_axis, depth)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c839aceb75dea0ea713f5bef648104cce09784" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, first_padded_axis, second_padded_axis, third_axis_to_pad, depth)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab9148a972ebadf0dd3075746714500bc8921a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, padded_rows, padded_cols, channels)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c562a565912652dff405b1a14798558f017dfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, rows, cols, channels)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3142a421b73450500d561ccc2d06f8b08d04e6ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, upsampled_dim1, upsampled_dim2, upsampled_dim3, channels)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2ec1d843f4f81a6b756eeb5380e9936c6e1e45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, upsampled_rows, upsampled_cols, channels)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3403ab76bb64e92cbc1ce947dc55b8c2f4c83858" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 3D tensor with shape &lt;code&gt;(batch_size, features, downsampled_steps)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_first'&lt;/code&gt; : 3D тензор с формой &lt;code&gt;(batch_size, features, downsampled_steps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76789aedd1e1b30e65c811b2313b49f5abac81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 3D tensor with shape &lt;code&gt;(batch_size, features, steps)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_first'&lt;/code&gt; : 3D тензор с формой &lt;code&gt;(batch_size, features, steps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2c87816275e01f135bb9300e7a0edc16061dbaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 3D tensor with shape: &lt;code&gt;(batch_size, features, steps)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_first'&lt;/code&gt; : 3D тензор с формой: &lt;code&gt;(batch_size, features, steps)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d125d22c952d5e837dfbc3985718e658b08de7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 4D tensor with shape &lt;code&gt;(batch_size, channels, pooled_rows, pooled_cols)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_first'&lt;/code&gt; : 4D тензор с формой &lt;code&gt;(batch_size, channels, pooled_rows, pooled_cols)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efeffd222f25920652324c590da7090efc77a88f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 4D tensor with shape &lt;code&gt;(batch_size, channels, rows, cols)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_first'&lt;/code&gt; : 4D тензор с формой &lt;code&gt;(batch_size, channels, rows, cols)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="769dedd8ac289e52c4aa08f01592146935aca265" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_first'&lt;/code&gt; : 5D тензор с формой: &lt;code&gt;(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64af7dda1bd74417607c23dcca4549eb64eaf842" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_first'&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_first'&lt;/code&gt; : 5D тензор с формой: &lt;code&gt;(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f181cb0cca921d90a9528a5b16866d3bc2e4a31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 3D tensor with shape &lt;code&gt;(batch_size, downsampled_steps, features)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_last'&lt;/code&gt; : 3D тензор с формой &lt;code&gt;(batch_size, downsampled_steps, features)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e79cfe731a2022565e9ce98c413ff3d4fea639e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 3D tensor with shape &lt;code&gt;(batch_size, steps, features)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_last'&lt;/code&gt; : 3D тензор с формой &lt;code&gt;(batch_size, steps, features)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c23ac2b777982bd7858d1585dca6d0af455ce47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 3D tensor with shape: &lt;code&gt;(batch_size, steps, features)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_last'&lt;/code&gt; : 3D тензор с формой: &lt;code&gt;(batch_size, steps, features)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b5eae7be09c8d4e03880f99d1ad2a8a783e7aad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 4D tensor with shape &lt;code&gt;(batch_size, pooled_rows, pooled_cols, channels)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_last'&lt;/code&gt; : 4D тензор с формой &lt;code&gt;(batch_size, pooled_rows, pooled_cols, channels)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddca25a45ba996ea23fba4bf6ca17bee3cfae493" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 4D tensor with shape &lt;code&gt;(batch_size, rows, cols, channels)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_last'&lt;/code&gt; : 4D тензор с формой &lt;code&gt;(batch_size, rows, cols, channels)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8233b6c3273cec342b518aa2c3dfc2e35e020b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_last'&lt;/code&gt; : 5D тензор с формой: &lt;code&gt;(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ec7e00c511e46673a4884a5b2f092291c4ad275" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format='channels_last'&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;data_format='channels_last'&lt;/code&gt; : 5D тензор с формой: &lt;code&gt;(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="101fdcb700763ac96747e4c473dfe1a8f6429022" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dataset&lt;/code&gt; and this iterator do not have a compatible element structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d4d79f82a80c0c717b01758950d031ed5cbffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diag.dtype&lt;/code&gt; is not an allowed type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7fe4529e029d06f999f9bc38cc0d6023bbb309" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diag.dtype&lt;/code&gt; is real, and &lt;code&gt;is_self_adjoint&lt;/code&gt; is not &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bee3f10643b4f478b79d3f193343de525becd64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diagonals_format=compact&lt;/code&gt; this is a &lt;code&gt;[B1, ... Bb, 3, N]&lt;/code&gt; shaped &lt;code&gt;Tensor&lt;/code&gt; with the second to last dimension indexing the superdiagonal, diagonal and subdiagonal in that order. Note the superdiagonal is padded with an element in the last position, and the subdiagonal is padded with an element in the front.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc29f8a23b899bdf0c1cb2f7f06e1af47287a14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diagonals_format=matrix&lt;/code&gt; this is a &lt;code&gt;[B1, ... Bb, N, N]&lt;/code&gt; shaped &lt;code&gt;Tensor&lt;/code&gt; representing the full tridiagonal matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57a70a4b86996a9a5cf18c0625615bd122c34f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;diagonals_format=sequence&lt;/code&gt;, this is a list of three &lt;code&gt;Tensor&lt;/code&gt;'s each with shape &lt;code&gt;[B1, ..., Bb, N]&lt;/code&gt;, &lt;code&gt;b &amp;gt;= 0, N &amp;gt;= 0&lt;/code&gt;, representing the superdiagonal, diagonal and subdiagonal in that order. Note the superdiagonal is padded with an element in the last position, and the subdiagonal is padded with an element in the front.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed36e5e93ecd4beb399f887553834287fd94ebb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; does not match the element type of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0815ded52c109dcfe592d606c078182d529cbf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is integral and &lt;code&gt;maxval&lt;/code&gt; is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d91f8393ce0797c49bb3ce9117ea4ab3700a304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is integral and only one of &lt;code&gt;minval&lt;/code&gt; or &lt;code&gt;maxval&lt;/code&gt; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715d150b5f97b6abec4188a71fc697199a108a0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is not a floating point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1d1c40df2fea11227db382ded54071f270ecec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is not provided, it will attempt to assume the data type of &lt;code&gt;on_value&lt;/code&gt; or &lt;code&gt;off_value&lt;/code&gt;, if one or both are passed in. If none of &lt;code&gt;on_value&lt;/code&gt;, &lt;code&gt;off_value&lt;/code&gt;, or &lt;code&gt;dtype&lt;/code&gt; are provided, &lt;code&gt;dtype&lt;/code&gt; will default to the value &lt;a href=&quot;../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;dtype&lt;/code&gt; не указан , он попытается принять тип данных &lt;code&gt;on_value&lt;/code&gt; или &lt;code&gt;off_value&lt;/code&gt; , если один или оба переданы. Если ни один из &lt;code&gt;on_value&lt;/code&gt; , &lt;code&gt;off_value&lt;/code&gt; или &lt;code&gt;dtype&lt;/code&gt; не предоставлен, &lt;code&gt;dtype&lt;/code&gt; по умолчанию будет иметь значение &lt;a href=&quot;../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25b80e47772b0bfc696fbf3b5bb5ff69641199ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is real, and &lt;code&gt;is_self_adjoint&lt;/code&gt; and &lt;code&gt;is_positive_definite&lt;/code&gt;, a Cholesky factorization is used for the determinant and solve.</source>
          <target state="translated">Если &lt;code&gt;dtype&lt;/code&gt; является вещественным, а также &lt;code&gt;is_self_adjoint&lt;/code&gt; и &lt;code&gt;is_positive_definite&lt;/code&gt; , факторизация Холецкого используется для определителя и решения.</target>
        </trans-unit>
        <trans-unit id="87728c1899322de33a9ed090ef422757a31d60b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is specified the resulting tensor values are cast to the requested &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;dtype&lt;/code&gt; , результирующие значения тензора приводятся к запрошенному &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6bf0dabc06d37338f301de3b7a000a236395058" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dynamic_pad&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, it is sufficient that the &lt;em&gt;rank&lt;/em&gt; of the tensors is known, but individual dimensions may have shape &lt;code&gt;None&lt;/code&gt;. In this case, for each enqueue the dimensions with value &lt;code&gt;None&lt;/code&gt; may have a variable length; upon dequeue, the output tensors will be padded on the right to the maximum shape of the tensors in the current minibatch. For numbers, this padding takes value 0. For strings, this padding is the empty string. See &lt;code&gt;PaddingFIFOQueue&lt;/code&gt; for more info.</source>
          <target state="translated">Если &lt;code&gt;dynamic_pad&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , достаточно того, что известен &lt;em&gt;ранг&lt;/em&gt; тензоров, но отдельные измерения могут иметь форму &lt;code&gt;None&lt;/code&gt; . В этом случае для каждой постановки в очередь размеры со значением &lt;code&gt;None&lt;/code&gt; могут иметь переменную длину; после удаления из очереди выходные тензоры будут дополнены справа до максимальной формы тензоров в текущем мини-пакете. Для чисел это заполнение принимает значение 0. Для строк это заполнение представляет собой пустую строку. См. &lt;code&gt;PaddingFIFOQueue&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c7154051f64e09243a5e2742d4bb8fb6d037dddc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dynamic_pad&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, it is sufficient that the &lt;em&gt;rank&lt;/em&gt; of the tensors is known, but individual dimensions may have value &lt;code&gt;None&lt;/code&gt;. In this case, for each enqueue the dimensions with value &lt;code&gt;None&lt;/code&gt; may have a variable length; upon dequeue, the output tensors will be padded on the right to the maximum shape of the tensors in the current minibatch. For numbers, this padding takes value 0. For strings, this padding is the empty string. See &lt;code&gt;PaddingFIFOQueue&lt;/code&gt; for more info.</source>
          <target state="translated">Если &lt;code&gt;dynamic_pad&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , достаточно, чтобы известен &lt;em&gt;ранг&lt;/em&gt; тензоров, но отдельные измерения могут иметь значение &lt;code&gt;None&lt;/code&gt; . В этом случае для каждой постановки в очередь размеры со значением &lt;code&gt;None&lt;/code&gt; могут иметь переменную длину; после удаления из очереди выходные тензоры будут дополнены справа до максимальной формы тензоров в текущем мини-пакете. Для чисел это заполнение принимает значение 0. Для строк это заполнение представляет собой пустую строку. См. &lt;code&gt;PaddingFIFOQueue&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d5c4eeb6f8493afa30012ab8c1fe8880c30e46d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; has multiple ragged dimensions, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s with one fewer ragged dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890f3a4151caeb03adb2ed5bca108c0ccc050d09" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; has multiple ragged dimensions, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s with one fewer ragged dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ff4987e87872a49d04921c77285bda0adf062e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; has only one ragged dimension, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73b5f746aec87b8f4c8e0427c04e89620bf4afc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; has only one ragged dimension, then the values passed to &lt;code&gt;fn&lt;/code&gt; will be &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d267c0ab9c489452139a661e9ce438bd73ea6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a &lt;code&gt;RaggedTensor&lt;/code&gt;, then &lt;code&gt;fn&lt;/code&gt; will be called with each row of that ragged tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594a6d229c5aac392ec75df05f295fde289f7215" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, then &lt;code&gt;fn&lt;/code&gt; will be called with each row of that sparse tensor. In particular, the value passed to &lt;code&gt;fn&lt;/code&gt; will be a &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; with one fewer dimension than &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996bb4b616839cd6682611215f67fa1c27e26efa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, then &lt;code&gt;fn&lt;/code&gt; will be called with each row of that sparse tensor. In particular, the value passed to &lt;code&gt;fn&lt;/code&gt; will be a &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; with one fewer dimension than &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0d11ec70ebe7a5d7ac929ed8701c9ed4c87af9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a single tensor and &lt;code&gt;fn&lt;/code&gt;'s signature is &lt;code&gt;tf.Tensor-&amp;gt;tf.Tensor&lt;/code&gt;, then &lt;code&gt;map_fn(fn, elems)&lt;/code&gt; is equivalent to &lt;code&gt;tf.stack([fn(elem) for elem in tf.unstack(elems)])&lt;/code&gt;. E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c84dfd4aca9809b33d0c963419094e255ce668" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elems&lt;/code&gt; is a tuple (or nested structure) of tensors, then those tensors must all have the same outer-dimension size (&lt;code&gt;num_elems&lt;/code&gt;); and &lt;code&gt;fn&lt;/code&gt; is used to transform each tuple (or structure) of corresponding slices from &lt;code&gt;elems&lt;/code&gt;. E.g., if &lt;code&gt;elems&lt;/code&gt; is a tuple &lt;code&gt;(t1, t2, t3)&lt;/code&gt;, then &lt;code&gt;fn&lt;/code&gt; is used to transform each tuple of slices &lt;code&gt;(t1[i], t2[i], t3[i])&lt;/code&gt; (where &lt;code&gt;0 &amp;lt;= i &amp;lt; num_elems&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4b65a0810a67f6df4062a29da66142c0346f29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;tensors&lt;/code&gt; is assumed to represent a single example. An input tensor with shape &lt;code&gt;[x, y, z]&lt;/code&gt; will be output as a tensor with shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;enqueue_many&lt;/code&gt; имеет значение &lt;code&gt;False&lt;/code&gt; , предполагается , что &lt;code&gt;tensors&lt;/code&gt; представляют единственный пример. Входной тензор с shape &lt;code&gt;[x, y, z]&lt;/code&gt; будет выводиться как тензор с shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f53d0408f26222dd6e2cb6b512d5cf383ecb0db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, each &lt;code&gt;tensors_list[i]&lt;/code&gt; is assumed to represent a single example. An input tensor &lt;code&gt;x&lt;/code&gt; will be output as a tensor with shape &lt;code&gt;[batch_size] + x.shape&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;enqueue_many&lt;/code&gt; имеет значение &lt;code&gt;False&lt;/code&gt; , &lt;code&gt;tensors_list[i]&lt;/code&gt; , что каждый tensors_list [i] представляет единственный пример. Входной тензор &lt;code&gt;x&lt;/code&gt; будет выводиться как тензор с shape &lt;code&gt;[batch_size] + x.shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c84e3f51d2a96b8ae5c34258f3f8f20e2f9061c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, each &lt;code&gt;tensors_list[i]&lt;/code&gt; is assumed to represent a single example. An input tensor with shape &lt;code&gt;[x, y, z]&lt;/code&gt; will be output as a tensor with shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;enqueue_many&lt;/code&gt; имеет значение &lt;code&gt;False&lt;/code&gt; , &lt;code&gt;tensors_list[i]&lt;/code&gt; , что каждый tensors_list [i] представляет единственный пример. Входной тензор с shape &lt;code&gt;[x, y, z]&lt;/code&gt; будет выводиться как тензор с shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341111f29e74aa8ef96f30f69cc9494a535fcfdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;tensors&lt;/code&gt; is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of &lt;code&gt;tensors&lt;/code&gt; should have the same size in the first dimension. If an input tensor has shape &lt;code&gt;[*, x, y, z]&lt;/code&gt;, the output will have shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;enqueue_many&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , предполагается , что &lt;code&gt;tensors&lt;/code&gt; представляют пакет примеров, где первое измерение проиндексировано примером, а все члены &lt;code&gt;tensors&lt;/code&gt; должны иметь одинаковый размер в первом измерении. Если входной тензор имеет форму &lt;code&gt;[*, x, y, z]&lt;/code&gt; , на выходе будет форма &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdc2ab5b45f000da1295bb1b0a336e2b463d4530" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;tensors&lt;/code&gt; is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of &lt;code&gt;tensors&lt;/code&gt; should have the same size in the first dimension. If an input tensor has shape &lt;code&gt;[*, x, y, z]&lt;/code&gt;, the output will have shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;. The &lt;code&gt;capacity&lt;/code&gt; argument controls the how long the prefetching is allowed to grow the queues.</source>
          <target state="translated">Если &lt;code&gt;enqueue_many&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , предполагается , что &lt;code&gt;tensors&lt;/code&gt; представляют пакет примеров, где первое измерение проиндексировано примером, а все члены &lt;code&gt;tensors&lt;/code&gt; должны иметь одинаковый размер в первом измерении. Если входной тензор имеет форму &lt;code&gt;[*, x, y, z]&lt;/code&gt; , на выходе будет форма &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; . &lt;code&gt;capacity&lt;/code&gt; аргумент контролирует , как долго упреждающая выборка позволено расти очереди.</target>
        </trans-unit>
        <trans-unit id="26d498f25d2a64c1fed1145d08fdecc587420e5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;tensors_list[i]&lt;/code&gt; is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of &lt;code&gt;tensors_list[i]&lt;/code&gt; should have the same size in the first dimension. If an input tensor has shape &lt;code&gt;[*, x, y, z]&lt;/code&gt;, the output will have shape &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;enqueue_many&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;tensors_list[i]&lt;/code&gt; , что tensors_list [i] представляет пакет примеров, где первое измерение проиндексировано примером, а все элементы &lt;code&gt;tensors_list[i]&lt;/code&gt; должны иметь одинаковый размер в первом измерении. Если входной тензор имеет форму &lt;code&gt;[*, x, y, z]&lt;/code&gt; , на выходе будет форма &lt;code&gt;[batch_size, x, y, z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b55a60b064830f9883032828fbe6f4b068812e2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;tensors_list[i]&lt;/code&gt; is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of &lt;code&gt;tensors_list[i]&lt;/code&gt; should have the same size in the first dimension. The slices of any input tensor &lt;code&gt;x&lt;/code&gt; are treated as examples, and the output tensors will have shape &lt;code&gt;[batch_size] + x.shape[1:]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;enqueue_many&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;tensors_list[i]&lt;/code&gt; , что tensors_list [i] представляет пакет примеров, где первое измерение проиндексировано примером, а все элементы &lt;code&gt;tensors_list[i]&lt;/code&gt; должны иметь одинаковый размер в первом измерении. Срезы любого входного тензора &lt;code&gt;x&lt;/code&gt; рассматриваются как примеры, а выходные тензоры будут иметь shape &lt;code&gt;[batch_size] + x.shape[1:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="836e7db05d88c2184b063f2c9c00ed1ec43300d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;estimator&lt;/code&gt; is not of type &lt;a href=&quot;../estimator&quot;&gt;&lt;code&gt;tf.estimator.Estimator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6738e0e3984368cde96a4a476d2cdaa918be36c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exclusive==True&lt;/code&gt;, all predicates are evaluated, and an exception is thrown if more than one of the predicates evaluates to &lt;code&gt;True&lt;/code&gt;. If &lt;code&gt;exclusive==False&lt;/code&gt;, execution stops at the first predicate which evaluates to True, and the tensors generated by the corresponding function are returned immediately. If none of the predicates evaluate to True, this operation returns the tensors generated by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;exclusive==True&lt;/code&gt; , все предикаты оцениваются, и возникает исключение, если более чем один из предикатов оценивается как &lt;code&gt;True&lt;/code&gt; . Если &lt;code&gt;exclusive==False&lt;/code&gt; , выполнение останавливается на первом предикате, который оценивается как True, и тензоры, сгенерированные соответствующей функцией, возвращаются немедленно. Если ни один из предикатов не оценивается как True, эта операция возвращает тензоры, созданные по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1db350e8759c17cd115f23013c64e6af556ea62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exclusive_resource_access == True&lt;/code&gt; and another &lt;code&gt;CriticalSection&lt;/code&gt; has an execution requesting the same resources as &lt;code&gt;fn&lt;/code&gt;&lt;code&gt;. Note, even if&lt;/code&gt;exclusive_resource_access&lt;code&gt;is&lt;/code&gt;True&lt;code&gt;, if another execution in another&lt;/code&gt;CriticalSection&lt;code&gt;was created without&lt;/code&gt;exclusive_resource_access=True&lt;code&gt;, a&lt;/code&gt;ValueError` will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260e3949ec868b21a057005c57e5ab81d4a234b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;external_state_policy&lt;/code&gt; is not one of 'warn', 'ignore' or 'fail'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03bdec9947eaedf4bdce7a6822bddea8728620a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; uses &lt;code&gt;Variable&lt;/code&gt;s (that are not part of the inputs), i.e. through &lt;code&gt;get_variable&lt;/code&gt;, then &lt;code&gt;grad_fn&lt;/code&gt; should have signature &lt;code&gt;g(*grad_ys, variables=None)&lt;/code&gt;, where &lt;code&gt;variables&lt;/code&gt; is a list of the &lt;code&gt;Variable&lt;/code&gt;s, and return a 2-tuple &lt;code&gt;(grad_xs, grad_vars)&lt;/code&gt;, where &lt;code&gt;grad_xs&lt;/code&gt; is the same as above, and &lt;code&gt;grad_vars&lt;/code&gt; is a &lt;code&gt;list&amp;lt;Tensor&amp;gt;&lt;/code&gt; with the derivatives of &lt;code&gt;Tensor&lt;/code&gt;s in &lt;code&gt;y&lt;/code&gt; with respect to the variables (that is, grad_vars has one Tensor per variable in variables).</source>
          <target state="translated">Если &lt;code&gt;f&lt;/code&gt; использует &lt;code&gt;Variable&lt;/code&gt; s (которая не является частью входных данных), то есть через &lt;code&gt;get_variable&lt;/code&gt; , тогда &lt;code&gt;grad_fn&lt;/code&gt; должен иметь сигнатуру &lt;code&gt;g(*grad_ys, variables=None)&lt;/code&gt; , где &lt;code&gt;variables&lt;/code&gt; - это список &lt;code&gt;Variable&lt;/code&gt; s, и возвращать кортеж из 2 &lt;code&gt;(grad_xs, grad_vars)&lt;/code&gt; , где &lt;code&gt;grad_xs&lt;/code&gt; то же, что и выше, а &lt;code&gt;grad_vars&lt;/code&gt; - это &lt;code&gt;list&amp;lt;Tensor&amp;gt;&lt;/code&gt; с производными &lt;code&gt;Tensor&lt;/code&gt; s по &lt;code&gt;y&lt;/code&gt; по переменным (то есть grad_vars имеет один тензор для каждой переменной в переменных).</target>
        </trans-unit>
        <trans-unit id="372309d6842fa4a199f338a43c95a0cfee85deea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; an algorithm based on the numerically robust complete orthogonal decomposition is used. This computes the minimum-norm least-squares solution, even when \(A\) is rank deficient. This path is typically 6-7 times slower than the fast path. If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then &lt;code&gt;l2_regularizer&lt;/code&gt; is ignored.</source>
          <target state="translated">Если &lt;code&gt;fast&lt;/code&gt; имеет значение &lt;code&gt;False&lt;/code&gt; , используется алгоритм, основанный на численно устойчивом полном ортогональном разложении. Это вычисляет решение наименьших квадратов с минимальной нормой, даже если ранг \ (A \) недостаточен. Этот путь обычно в 6-7 раз медленнее, чем быстрый путь. Если &lt;code&gt;fast&lt;/code&gt; это значение &lt;code&gt;False&lt;/code&gt; , то &lt;code&gt;l2_regularizer&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="99ca2eb7416e2e7ca018fd9bd0de4034a8a44c56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal equations using Cholesky decomposition. Specifically, if \(m \ge n\) then \(X = (A^H A + \lambda I)^{-1} A^H B\), which solves the least-squares problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 + \lambda ||Z||_F^2\). If \(m \lt n\) then &lt;code&gt;output&lt;/code&gt; is computed as \(X = A^H (A A^H + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the minimum-norm solution to the under-determined linear system, i.e. \(X = \mathrm{argmin}_{Z \in \mathbb{C}^{n \times k} } ||Z||_F^2 \), subject to \(A Z = B\). Notice that the fast path is only numerically stable when \(A\) is numerically full rank and has a condition number \(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\) or \(\lambda\) is sufficiently large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2174f4ab172cb4e074462ef83b691a3c79ee539" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal equations using Cholesky decomposition. Specifically, if \(m \ge n\) then \(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 + \lambda ||Z||_F^2\). If \(m \lt n\) then &lt;code&gt;output&lt;/code&gt; is computed as \(X = A^T (A A^T + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the minimum-norm solution to the under-determined linear system, i.e. \(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||Z||_F^2 \), subject to \(A Z = B\). Notice that the fast path is only numerically stable when \(A\) is numerically full rank and has a condition number \(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\) or\(\lambda\) is sufficiently large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27049f19ad9a7d096760e3d9b009bb4362edc6f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal equations using Cholesky decomposition. Specifically, if \(m \ge n\) then \(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||A Z - B||_F^2 + \lambda ||Z||_F^2\). If \(m \lt n\) then &lt;code&gt;output&lt;/code&gt; is computed as \(X = A^T (A A^T + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the minimum-norm solution to the under-determined linear system, i.e. \(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||Z||_F^2 \), subject to \(A Z = B\). Notice that the fast path is only numerically stable when \(A\) is numerically full rank and has a condition number \(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach}}}\) or\(\lambda\) is sufficiently large.</source>
          <target state="translated">Если &lt;code&gt;fast&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , то решение вычисляется путем решения нормальных уравнений с использованием разложения Холецкого. В частности, если \ (m \ ge n \), то \ (X = (A ^ TA + \ lambda I) ^ {- 1} A ^ TB \), что решает задачу наименьших квадратов \ (X = \ mathrm { argmin} _ {Z \ in \ Re ^ {n \ times k}} || AZ - B || _F ^ 2 + \ lambda || Z || _F ^ 2 \). Если \ (m \ lt n \), то &lt;code&gt;output&lt;/code&gt; вычисляется как \ (X = A ^ T (AA ^ T + \ lambda I) ^ {- 1} B \), что (для \ (\ lambda = 0 \)) является решением минимальной нормы нижнего определенная линейная система, т.е. \ (X = \ mathrm {argmin} _ {Z \ in \ Re ^ {n \ times k}} || Z || _F ^ 2 \), при условии \ (AZ = B \). Обратите внимание, что быстрый путь является численно стабильным только тогда, когда \ (A \) имеет числовой полный ранг и имеет номер условия \ (\ mathrm {cond} (A) \ lt \ frac {1} {\ sqrt {\ epsilon_ {mach} }} \) или \ (\ lambda \) достаточно велико.</target>
        </trans-unit>
        <trans-unit id="10418c72e5c6dd6e80851e9e8fb65566fa234438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fetches&lt;/code&gt; or &lt;code&gt;feed_dict&lt;/code&gt; keys are invalid or refer to a &lt;code&gt;Tensor&lt;/code&gt; that doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bb23faf339d41deeb0901d589753c2877206d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fetches&lt;/code&gt; or &lt;code&gt;feed_dict&lt;/code&gt; keys are of an inappropriate type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171762a498ab89f9d232219b63ff0405f3d5e480" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fetches&lt;/code&gt; or &lt;code&gt;feed_list&lt;/code&gt; cannot be interpreted as arguments to &lt;code&gt;tf.Session.run&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b0573faec6681d2a2b616ba938701aadfaca62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flat_sequence&lt;/code&gt; and &lt;code&gt;structure&lt;/code&gt; have different element counts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb91a9d86d6c9aaea4ef3aa45e8bf4a6c340bf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; attempts to lock this &lt;code&gt;CriticalSection&lt;/code&gt; in any nested or lazy way that may cause a deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1551e8f73c2d83fbf8fd44dd46181ffa8358ded1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s, then use a &lt;a href=&quot;../../raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with the same &lt;code&gt;ragged_rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e23aa87bbeb1e4675017eca04866dd1e388f7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s with varying sizes, then use a &lt;a href=&quot;../../raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ragged_rank=0&lt;/code&gt; to combine them into a single ragged tensor (which will have ragged_rank=1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eeacd3486db351366bde57a63394d991f15f982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s, then use a &lt;a href=&quot;raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with the same &lt;code&gt;ragged_rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8d08d8e9b16ba0b500650cfa5d8f331678f73b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s with varying sizes, then use a &lt;a href=&quot;raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ragged_rank=0&lt;/code&gt; to combine them into a single ragged tensor (which will have ragged_rank=1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10e6e3b3df2442237b2da671f13b9920466825a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns a tuple (or nested structure) of tensors, then the result is formed by stacking corresponding elements from those structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1e8c321f941bc85990b6de55c2da7f3b805f5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt;'s input and output signatures are different, then the output signature must be specified using &lt;code&gt;fn_output_signature&lt;/code&gt;. (The input and output signatures are differ if their structures, dtypes, or tensor types do not match). E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931822ee2a64108c4c50b471e87b1dbdbef3f83b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fns[i]&lt;/code&gt; is not callable for any i, or &lt;code&gt;default&lt;/code&gt; is not callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac46406112566e4c8d7fd9007e8f023b0bb2d1e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is not specified or is the empty string, a default format is picked in function of the number of channels in &lt;code&gt;image&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;format&lt;/code&gt; не указан или является пустой строкой, выбирается формат по умолчанию в зависимости от количества каналов в &lt;code&gt;image&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c2863837c3f4cf6e88645c28db902644e8cef28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame_length&lt;/code&gt;, &lt;code&gt;frame_step&lt;/code&gt;, &lt;code&gt;pad_value&lt;/code&gt;, or &lt;code&gt;axis&lt;/code&gt; are not scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b26f5a78e8c279b178b9ade3dd5bc6d06da127" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not None, returns a &lt;code&gt;Callable&lt;/code&gt; which is equivalent to &lt;code&gt;func&lt;/code&gt;, but is not converted by AutoGraph. If &lt;code&gt;func&lt;/code&gt; is None, returns a decorator that, when invoked with a single &lt;code&gt;func&lt;/code&gt; argument, returns a &lt;code&gt;Callable&lt;/code&gt; equivalent to the above case.</source>
          <target state="translated">Если &lt;code&gt;func&lt;/code&gt; не равно None, возвращает &lt;code&gt;Callable&lt;/code&gt; , который эквивалентен &lt;code&gt;func&lt;/code&gt; , но не преобразуется AutoGraph. Если &lt;code&gt;func&lt;/code&gt; равно None, возвращает декоратор, который при вызове с одним аргументом &lt;code&gt;func&lt;/code&gt; возвращает &lt;code&gt;Callable&lt;/code&gt; , эквивалентный приведенному выше случаю.</target>
        </trans-unit>
        <trans-unit id="adab4fd150cb2345d1e66d4e52b3914d1ce9e9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not None, returns a callable that will execute the compiled function (and return zero or more &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects). If &lt;code&gt;func&lt;/code&gt; is None, returns a decorator that, when invoked with a single &lt;code&gt;func&lt;/code&gt; argument, returns a callable equivalent to the case above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f898cef9866995880d01892817ec2175fe439d2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not None, returns a callable that will execute the compiled function (and return zero or more &lt;code&gt;tf.Tensor&lt;/code&gt; objects). If &lt;code&gt;func&lt;/code&gt; is None, returns a decorator that, when invoked with a single &lt;code&gt;func&lt;/code&gt; argument, returns a callable equivalent to the case above.</source>
          <target state="translated">Если &lt;code&gt;func&lt;/code&gt; не None, возвращает вызываемый объект, который выполнит скомпилированную функцию (и вернет ноль или более объектов &lt;code&gt;tf.Tensor&lt;/code&gt; ). Если &lt;code&gt;func&lt;/code&gt; равно None, возвращает декоратор, который при вызове с одним аргументом &lt;code&gt;func&lt;/code&gt; возвращает вызываемый эквивалент случая выше.</target>
        </trans-unit>
        <trans-unit id="e85ff520cc5fc0cf0177cb0ed9640cb244dce5fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not callable or if the structures do not match each other by depth tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62acbfcfb14ee0a398f34c8b9aa49c710246709d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;global_norm == infinity&lt;/code&gt; then the entries in &lt;code&gt;t_list&lt;/code&gt; are all set to &lt;code&gt;NaN&lt;/code&gt; to signal that an error occurred.</source>
          <target state="translated">Если &lt;code&gt;global_norm == infinity&lt;/code&gt; тогда все записи в &lt;code&gt;t_list&lt;/code&gt; устанавливаются на &lt;code&gt;NaN&lt;/code&gt; , чтобы сигнализировать об ошибке.</target>
        </trans-unit>
        <trans-unit id="2956cad21f5b56edbff8960414c25d760e131d03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;grads_and_vars&lt;/code&gt; is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06180e8a961bb714a028db31c783968b59694720" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;graph_def&lt;/code&gt; is not a &lt;code&gt;GraphDef&lt;/code&gt; proto, &lt;code&gt;input_map&lt;/code&gt; is not a dictionary mapping strings to &lt;code&gt;Tensor&lt;/code&gt; objects, or &lt;code&gt;return_elements&lt;/code&gt; is not a list of strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461aea0814d7e39649d6d120c06dd3be55715069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hash_bucket_size &amp;lt; 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6361bf1f4ec971c2401c5cbb45657531e4fd66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;identifier&lt;/code&gt; cannot be interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85643c6bb3df08bc9a3e4fee59e6d92e89835fa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; is not a 4D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8202744147fe643212bcfe0c85cc04cbaa3a7c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was 4-D, a 4-D float Tensor of shape &lt;code&gt;[batch, target_height, target_width, channels]&lt;/code&gt; If &lt;code&gt;image&lt;/code&gt; was 3-D, a 3-D float Tensor of shape &lt;code&gt;[target_height, target_width, channels]&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;image&lt;/code&gt; было 4-D, 4-D тензор с плавающей запятой формы &lt;code&gt;[batch, target_height, target_width, channels]&lt;/code&gt; Если &lt;code&gt;image&lt;/code&gt; было 3-D, 3-D тензор с плавающей запятой формы &lt;code&gt;[target_height, target_width, channels]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e92f8fb84781c3e7b4d7c52dbb4a1a2a181a567" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was 4-D, a 4-D float Tensor of shape &lt;code&gt;[batch, width, height, channels]&lt;/code&gt; If &lt;code&gt;image&lt;/code&gt; was 3-D, a 3-D float Tensor of shape &lt;code&gt;[width, height, channels]&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;image&lt;/code&gt; было 4-D, 4-D тензор с плавающей запятой формы &lt;code&gt;[batch, width, height, channels]&lt;/code&gt; Если &lt;code&gt;image&lt;/code&gt; было 3-D, 3-D тензор с плавающей запятой формы &lt;code&gt;[width, height, channels]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b22ec650a9bcf3dbd00caf73b8addae20e1363f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;images&lt;/code&gt; was 4-D, a 4-D float Tensor of shape &lt;code&gt;[batch, new_height, new_width, channels]&lt;/code&gt;. If &lt;code&gt;images&lt;/code&gt; was 3-D, a 3-D float Tensor of shape &lt;code&gt;[new_height, new_width, channels]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;images&lt;/code&gt; были &lt;code&gt;[batch, new_height, new_width, channels]&lt;/code&gt; тензор с плавающей запятой формы [пакет, новая_высота, новая_ ширина, каналы] . Если &lt;code&gt;images&lt;/code&gt; были трехмерными, то трехмерный тензор с плавающей запятой формы &lt;code&gt;[new_height, new_width, channels]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2952b0ed613f675460838f4f741f5f9164c5ef5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;images&lt;/code&gt; was 4-D, return a 1-D float Tensor of shape &lt;code&gt;[batch]&lt;/code&gt; with the total variation for each image in the batch. If &lt;code&gt;images&lt;/code&gt; was 3-D, return a scalar float with the total variation for that image.</source>
          <target state="translated">Если &lt;code&gt;images&lt;/code&gt; были четырехмерными, вернуть 1-мерный тензор с плавающей запятой формы &lt;code&gt;[batch]&lt;/code&gt; с общим изменением для каждого изображения в пакете. Если &lt;code&gt;images&lt;/code&gt; были трехмерными, вернуть скалярное число с плавающей запятой с полным изменением для этого изображения.</target>
        </trans-unit>
        <trans-unit id="eda69d01cfcf1f44ffd4da2f558f423b426b0614" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; contains duplicates, then their updates are accumulated (summed).</source>
          <target state="translated">Если &lt;code&gt;indices&lt;/code&gt; содержат дубликаты, то их обновления накапливаются (суммируются).</target>
        </trans-unit>
        <trans-unit id="a94358a58fd92ac955695f20a84f5c03cc0dc2c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a RaggedTensor, the 'axis' argument must be positive and refer to a non-ragged axis. The output will be equivalent to applying 'one_hot' on the values of the RaggedTensor, and creating a new RaggedTensor from the result.</source>
          <target state="translated">Если &lt;code&gt;indices&lt;/code&gt; является RaggedTensor, &amp;laquo;оси&amp;raquo; аргумент должен быть положительным и относится к не рваной оси. Результат будет эквивалентен применению one_hot к значениям RaggedTensor и созданию нового RaggedTensor из результата.</target>
        </trans-unit>
        <trans-unit id="3b6eba702090dea64afc7969a9f079a18321fa1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a matrix (batch) with shape &lt;code&gt;[batch, features]&lt;/code&gt;, the output shape will be:</source>
          <target state="translated">Если &lt;code&gt;indices&lt;/code&gt; представляют собой матрицу (пакет) с формой &lt;code&gt;[batch, features]&lt;/code&gt; , выходной формой будет:</target>
        </trans-unit>
        <trans-unit id="2c8651ec95be2ea9a0cc30128faa66b9c2d43d29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a permutation and &lt;code&gt;len(indices) == params.shape[0]&lt;/code&gt; then this operation will permute &lt;code&gt;params&lt;/code&gt; accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7efb1cc16c63ea7b0aac3e018a11b41a9ddc9ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a scalar the output shape will be a vector of length &lt;code&gt;depth&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;indices&lt;/code&gt; являются скаляром, выходной формой будет вектор длины &lt;code&gt;depth&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cb59a7c31ae2fe8c97ecae2fc219f2e5547664d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a scalar the output shape will be a vector of length &lt;code&gt;depth&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a13c16c0eff3a5bb88de38a8d8307ec6511d293" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a vector of length &lt;code&gt;features&lt;/code&gt;, the output shape will be:</source>
          <target state="translated">Если &lt;code&gt;indices&lt;/code&gt; является вектором длиной &lt;code&gt;features&lt;/code&gt; , форма вывода будет:</target>
        </trans-unit>
        <trans-unit id="6c438e9ba6fd98b2384d247334493173a26303ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initializer&lt;/code&gt; is None, only out-of-vocabulary buckets are used.</source>
          <target state="translated">Если &lt;code&gt;initializer&lt;/code&gt; равен None, используются только сегменты вне словарного запаса.</target>
        </trans-unit>
        <trans-unit id="d93109613b12250a30b715aa9a4045da0bba426f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is already real, it is returned unchanged.</source>
          <target state="translated">Если &lt;code&gt;input&lt;/code&gt; уже реальный, он возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="2d73039dfcb009dbb9d3ba38b336fb7dee149a81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input_map&lt;/code&gt;, or &lt;code&gt;return_elements&lt;/code&gt; contains names that do not appear in &lt;code&gt;graph_def&lt;/code&gt;, or &lt;code&gt;graph_def&lt;/code&gt; is not well-formed (e.g. it refers to an unknown tensor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c620f70974120bd9cb3db4d33f50222f323be76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input_output_dtype = DTYPE&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;input_output_dtype = DTYPE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3def506820299b2293f03f5c9b04dcb9fe22d72c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputs&lt;/code&gt; don't all have same shape and dtype or the shape cannot be inferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e1e38e57c32a085e042e248a4488df18c84ff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputs&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; or an empty list, or if the arity and type of &lt;code&gt;state_name&lt;/code&gt; does not match that of &lt;code&gt;cell.state_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bec6ea37f82cfa7f2a1d5f2d2008b4707ac6ca5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputs&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; or an empty list, or if the input depth (column size) cannot be inferred from inputs via shape inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce85c6dd49fe3b8c73feae72b7f6738cadc8bb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X == False&lt;/code&gt;, callers should expect the operator to not have &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;is_X == False&lt;/code&gt; , абоненты должны ожидать , что оператор не имеет &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0afbb1278c738c0d57964d82ebe25d5d9dff4ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X == None&lt;/code&gt; (the default), callers should have no expectation either way.</source>
          <target state="translated">Если &lt;code&gt;is_X == None&lt;/code&gt; (по умолчанию), у вызывающих не должно быть никаких ожиданий.</target>
        </trans-unit>
        <trans-unit id="cd1b93088ca4115b8f08bd9ab8fb507c261ccce5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X == True&lt;/code&gt;, callers should expect the operator to have the property &lt;code&gt;X&lt;/code&gt;. This is a promise that should be fulfilled, but is &lt;em&gt;not&lt;/em&gt; a runtime assert. For example, finite floating point precision may result in these promises being violated.</source>
          <target state="translated">Если &lt;code&gt;is_X == True&lt;/code&gt; , абоненты должны ожидать , что оператор имеет свойство &lt;code&gt;X&lt;/code&gt; . Это обещание, которое должно быть выполнено, но &lt;em&gt;не&lt;/em&gt; утверждение во время выполнения. Например, конечная точность с плавающей запятой может привести к нарушению этих обещаний.</target>
        </trans-unit>
        <trans-unit id="c22402e2171c4c1f4ba6b2ff7b70ec7ea74f958a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X&lt;/code&gt; flags are set in an inconsistent way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a0cb7162dd9573a93c2d5e4c0945712cc80b22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_square&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96697908c1dc3e043634cbbd44dc5cfb701b564b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_tensor(x)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;, it is safe to assume that &lt;code&gt;x&lt;/code&gt; is a tensor or can be converted to a tensor using &lt;code&gt;ops.convert_to_tensor(x)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;is_tensor(x)&lt;/code&gt; возвращает &lt;code&gt;True&lt;/code&gt; , можно с уверенностью предположить, что &lt;code&gt;x&lt;/code&gt; является тензором или может быть преобразован в тензор с помощью &lt;code&gt;ops.convert_to_tensor(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a212a196f90ac2693f3cbfad3f8cd8e36d111b25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;iterator&lt;/code&gt; has reached the end of the sequence, the returned &lt;code&gt;Optional&lt;/code&gt; will have no value.</source>
          <target state="translated">Если &lt;code&gt;iterator&lt;/code&gt; достиг конца последовательности, возвращаемый &lt;code&gt;Optional&lt;/code&gt; не будет иметь значения.</target>
        </trans-unit>
        <trans-unit id="ecaa2a4898946decfeefef48b42990281e4ae0fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;job_name&lt;/code&gt; does not name a job in this cluster, or no task with index &lt;code&gt;task_index&lt;/code&gt; is defined in that job.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d396b2b2293caff3f0f5c227bcb99f143d81fabe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;job_name&lt;/code&gt; does not name a job in this cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8999131f1f1d024304557a7b65fc9bac0014050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; varies dynamically, use &lt;code&gt;TopKV2&lt;/code&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfaf8985bf78fa71a42c9e60b969cc11b499ddc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is a slice and &lt;code&gt;self&lt;/code&gt; is completely unknown and the step is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a027ba8554cd07c7f749c881765338f4424e936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is an integer, returns the dimension at that index; otherwise if &lt;code&gt;key&lt;/code&gt; is a slice, returns a TensorShape whose dimensions are those selected by the slice from &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd7fb4c21c7339eff15c78196173b6566f9d7fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f0ea9ed966ce6ace9ccb5bbc1f609e2328ffa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is out of bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8f886f9d669bed2a03baa8589f72cb8d4d6ce7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_key&lt;/code&gt; is not one of the &lt;code&gt;features&lt;/code&gt; keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442f4dde96ff9cbee6d4ed0116902353d0432184" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_mode&lt;/code&gt; is None, it yields &lt;code&gt;float32&lt;/code&gt; tensors of shape &lt;code&gt;(batch_size, image_size[0], image_size[1], num_channels)&lt;/code&gt;, encoding images (see below for rules regarding &lt;code&gt;num_channels&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ec12a31086fac5b8d9ae1402e7448374b19b18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_mode&lt;/code&gt; is None, it yields &lt;code&gt;string&lt;/code&gt; tensors of shape &lt;code&gt;(batch_size,)&lt;/code&gt;, containing the contents of a batch of text files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d5159794e9527572e582d5291c29b2551e8bac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_smoothing&lt;/code&gt; is nonzero, smooth the labels towards 1/2:</source>
          <target state="translated">Если &lt;code&gt;label_smoothing&lt;/code&gt; не равно нулю, сгладьте метки до 1/2:</target>
        </trans-unit>
        <trans-unit id="8bfcf6c3ee662c4541e7fcc138561099e2c68bfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_smoothing&lt;/code&gt; is nonzero, smooth the labels towards 1/num_classes: new_onehot_labels = onehot_labels * (1 - label_smoothing)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fc91aecf4a1093b877f40965090f1148dd8d17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_smoothing&lt;/code&gt; is nonzero, smooth the labels towards 1/num_classes: new_onehot_labels = onehot_labels * (1 - label_smoothing) + label_smoothing / num_classes</source>
          <target state="translated">Если &lt;code&gt;label_smoothing&lt;/code&gt; не равно нулю, сгладьте метки до 1 / num_classes: new_onehot_labels = onehot_labels * (1 - label_smoothing) + label_smoothing / num_classes</target>
        </trans-unit>
        <trans-unit id="9535e210890193a55032b616d005eda7ed94d172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_vocabulary&lt;/code&gt; is given, a string &lt;code&gt;SparseTensor&lt;/code&gt;. The &lt;code&gt;dense_shape&lt;/code&gt; must be &lt;code&gt;[D0, D1, ... DN, ?]&lt;/code&gt; and the values within &lt;code&gt;label_vocabulary&lt;/code&gt; or a multi-hot tensor of shape &lt;code&gt;[D0, D1, ... DN, n_classes]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;label_vocabulary&lt;/code&gt; , строка &lt;code&gt;SparseTensor&lt;/code&gt; . &lt;code&gt;dense_shape&lt;/code&gt; должен быть &lt;code&gt;[D0, D1, ... DN, ?]&lt;/code&gt; , А значения в пределах &lt;code&gt;label_vocabulary&lt;/code&gt; или мульти-горячий тензор формы &lt;code&gt;[D0, D1, ... DN, n_classes]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9d181f00ed5063e3bb83d7190390a7aaf79b6d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;latest_filename&lt;/code&gt; contains path components, or if it collides with &lt;code&gt;save_path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45779bfea581324e20f83680029d5b035eaab380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;layer&lt;/code&gt; is not a layer instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57faa88fcd4abc6c75a30eb2b606c25bc0cb752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;layer&lt;/code&gt; or &lt;code&gt;backward_layer&lt;/code&gt; is not a &lt;code&gt;Layer&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967c37ef4813eebb4b3f478746ba7d5ff73bdc1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(embedding_weights) &amp;gt; 1&lt;/code&gt;, each element &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;embedding_weights&lt;/code&gt; according to the &quot;div&quot; partition strategy, which means we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8126c22e40c006b2f71cc6c83da730cd7198f562" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(keys) &amp;lt; 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f7fb451ff0e7c028617b0faa305894fcff0b32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(nested_values_rowids) != len(nested_nrows)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e212b49e9635f45f33c86b9912893cbd223a5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt;, each element &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;params&lt;/code&gt; according to the &quot;div&quot; partition strategy, which means we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e776cdbcc3444233893bed8e8a175d8a296b35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt;, each element &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;params&lt;/code&gt; according to the &lt;code&gt;partition_strategy&lt;/code&gt;. In all strategies, if the id space does not evenly divide the number of partitions, each of the first &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; partitions will be assigned one more id.</source>
          <target state="translated">Если &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt; , каждый элемент &lt;code&gt;id&lt;/code&gt; из &lt;code&gt;ids&lt;/code&gt; распределяли между элементами &lt;code&gt;params&lt;/code&gt; в соответствии с &lt;code&gt;partition_strategy&lt;/code&gt; . Во всех стратегиях, если пространство идентификаторов не делит равномерно количество разделов, каждому из первых &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; разделов будет назначен еще один идентификатор.</target>
        </trans-unit>
        <trans-unit id="7c76724b7d1351d823fe9209abfbdddf28992103" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt;, each element of &lt;code&gt;sp_ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;params&lt;/code&gt; according to the &quot;div&quot; partition strategy, which means we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d08097191b4f17f118cbfefba6aecf799282429" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(partitions) &amp;gt; 1&lt;/code&gt;, then:</source>
          <target state="translated">Если &lt;code&gt;len(partitions) &amp;gt; 1&lt;/code&gt; , то:</target>
        </trans-unit>
        <trans-unit id="5f370b423121a48298eb43a3a0c878f9941513c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(partitions) == 0&lt;/code&gt; (the default), then:</source>
          <target state="translated">Если &lt;code&gt;len(partitions) == 0&lt;/code&gt; (по умолчанию), то:</target>
        </trans-unit>
        <trans-unit id="6cf134dcb33104f575f6a123d3a075fe42f5e61f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(partitions) == 1&lt;/code&gt;, then:</source>
          <target state="translated">Если &lt;code&gt;len(partitions) == 1&lt;/code&gt; , то:</target>
        </trans-unit>
        <trans-unit id="c7d16e6c5a371d846babf4540ef4a499f5ff7e85" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; defines a substring that would extend beyond the length of the input string, or if &lt;code&gt;len&lt;/code&gt; is negative, then as many characters as possible are used.</source>
          <target state="translated">Если &lt;code&gt;len&lt;/code&gt; определяет подстроку, которая будет выходить за пределы длины входной строки, или если &lt;code&gt;len&lt;/code&gt; отрицательное, то используется как можно больше символов.</target>
        </trans-unit>
        <trans-unit id="58c0544760219e22513b48eb9e261f94e98a41ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lengths&lt;/code&gt; has shape &lt;code&gt;[d_1, d_2, ..., d_n]&lt;/code&gt; the resulting tensor &lt;code&gt;mask&lt;/code&gt; has dtype &lt;code&gt;dtype&lt;/code&gt; and shape &lt;code&gt;[d_1, d_2, ..., d_n, maxlen]&lt;/code&gt;, with</source>
          <target state="translated">Если &lt;code&gt;lengths&lt;/code&gt; имеет форму &lt;code&gt;[d_1, d_2, ..., d_n]&lt;/code&gt; результирующая тензорная &lt;code&gt;mask&lt;/code&gt; имеет dtype &lt;code&gt;dtype&lt;/code&gt; и shape &lt;code&gt;[d_1, d_2, ..., d_n, maxlen]&lt;/code&gt; с</target>
        </trans-unit>
        <trans-unit id="3c5b2be06fb7017b079751ddda7b22925baf4691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;log_input&lt;/code&gt; and &lt;code&gt;targets&lt;/code&gt; do not have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8564534874792c985f423f360729ff591b2b7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;logits&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; do not have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495c5ec6c6d28f35484c4fc66c26cf6d9595cae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mark_as_used&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;, which is the default, a new unique name is created and marked as in use. If it's set to &lt;code&gt;False&lt;/code&gt;, the unique name is returned without actually being marked as used. This is useful when the caller simply wants to know what the name to be created will be.</source>
          <target state="translated">Если для &lt;code&gt;mark_as_used&lt;/code&gt; установлено значение &lt;code&gt;True&lt;/code&gt; , которое является значением по умолчанию, создается новое уникальное имя, которое помечается как используемое. Если установлено значение &lt;code&gt;False&lt;/code&gt; , возвращается уникальное имя, фактически не отмеченное как используемое. Это полезно, когда вызывающий просто хочет знать, каким будет создаваемое имя.</target>
        </trans-unit>
        <trans-unit id="cd1e44d4c7d6ed45c9cd26023b5058f4d025374d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_images&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;tag&lt;/em&gt;/image'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e4a9009970f0585fad5a33338c65900faf027d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_images&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;tag&lt;/em&gt;/image/0', '&lt;em&gt;tag&lt;/em&gt;/image/1', etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61766419fa18559947b6a6ba67bb03f1eea12328" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;name&lt;/em&gt;/audio'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93a8d469ca0a24100be9b2896764722aaf3a271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;name&lt;/em&gt;/image'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258df073bb92dd67ccc339545de0afc021f5a3dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;tag&lt;/em&gt;/audio'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb078f131932fa68d289f9e59ad97e8c707aaf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;name&lt;/em&gt;/audio/0', '&lt;em&gt;name&lt;/em&gt;/audio/1', etc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79a7ab3177da8b28168b7f679889bedd40abf53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;name&lt;/em&gt;/image/0', '&lt;em&gt;name&lt;/em&gt;/image/1', etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb63258c4a86e0f68d75252c89470c99c03722a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;tag&lt;/em&gt;/audio/0', '&lt;em&gt;tag&lt;/em&gt;/audio/1', etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619dc874e12b9ab9cd2cb9215273176742fd29ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_to_keep&lt;/code&gt; is not a positive integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d66f411337b07f0dab269875b71de9a6838978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mdcts&lt;/code&gt; is not at least rank 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e15c8d0da73bb687041dfc28fe499db780dc07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge_repeated&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, merge repeated classes in output. This means that if consecutive logits' maximum indices are the same, only the first of these is emitted. The sequence &lt;code&gt;A B B * B * B&lt;/code&gt; (where '*' is the blank label) becomes</source>
          <target state="translated">Если &lt;code&gt;merge_repeated&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , объединить повторяющиеся классы в выводе. Это означает, что если максимальные индексы последовательных логитов одинаковы, то выдается только первый из них. Последовательность &lt;code&gt;A B B * B * B&lt;/code&gt; (где '*' - пустая этикетка) становится</target>
        </trans-unit>
        <trans-unit id="7bac502b4b4499617b3003913f73281a64e6d6e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge_repeated&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, merge repeated classes in the output beams. This means that if consecutive entries in a beam are the same, only the first of these is emitted. That is, when the sequence is &lt;code&gt;A B B * B * B&lt;/code&gt; (where '*' is the blank label), the return value is:</source>
          <target state="translated">Если &lt;code&gt;merge_repeated&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , объединить повторяющиеся классы в выходных лучах. Это означает, что если последовательные входы в луч одинаковы, излучается только первый из них. То есть, когда последовательность &lt;code&gt;A B B * B * B&lt;/code&gt; (где '*' - пустая метка), возвращаемое значение:</target>
        </trans-unit>
        <trans-unit id="2f5f8af2740a968e311c9b89d559f686de2b0a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;min &amp;lt; max &amp;lt; 0&lt;/code&gt;: &lt;code&gt;min_adj = min - max&lt;/code&gt; and &lt;code&gt;max_adj = 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1304f8f39dbe5a8f6d6eeae3733c3fcf4be17ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;min &amp;lt;= 0 &amp;lt;= max&lt;/code&gt;: &lt;code&gt;scale = (max - min) / (2^num_bits - 1)&lt;/code&gt;, &lt;code&gt;min_adj = scale * round(min / scale)&lt;/code&gt; and &lt;code&gt;max_adj = max + min_adj - min&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0984202fa4f5e645b2c5a40e37b9b5a9dd3c9893" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;minlength&lt;/code&gt; and &lt;code&gt;maxlength&lt;/code&gt; are not given, returns a vector with length &lt;code&gt;tf.reduce_max(arr) + 1&lt;/code&gt; if &lt;code&gt;arr&lt;/code&gt; is non-empty, and length 0 otherwise. If &lt;code&gt;weights&lt;/code&gt; are non-None, then index &lt;code&gt;i&lt;/code&gt; of the output stores the sum of the value in &lt;code&gt;weights&lt;/code&gt; at each index where the corresponding value in &lt;code&gt;arr&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;minlength&lt;/code&gt; и &lt;code&gt;maxlength&lt;/code&gt; не указаны, возвращает вектор с длиной &lt;code&gt;tf.reduce_max(arr) + 1&lt;/code&gt; если &lt;code&gt;arr&lt;/code&gt; не пуст, и длиной 0 в противном случае. Если &lt;code&gt;weights&lt;/code&gt; равны None, то в индексе &lt;code&gt;i&lt;/code&gt; выходных данных сохраняется сумма значений &lt;code&gt;weights&lt;/code&gt; в каждом индексе, где соответствующее значение в &lt;code&gt;arr&lt;/code&gt; равно &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc775b5309c51edeb837cf49c77d15d49ce193f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.evaluate&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c70c96ae2eb1390ba94985d15df3380acf18bf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.evaluate&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1ffe619d3d50b4c85a21621ff8dceb52857ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.fit&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17b3f8cacf3362c475a9bbfd7a287c45fefb5e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.fit&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0faade3b34e959ce96253cdd4a1d86434d240213" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a072772fc22e466963013635b8c683c63ebd28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1686ca69810a585f4306a0c7eb54ba0fea271e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed39d59f9e1dad8c20bb30e50c137ed4963428b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127df10a5d3eac7073f1f68ddbc93e21b0620769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.test_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376bca6d71b04ff763045a323c905bd6843fc382" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.test_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a36ed8e1819cbdc2c4ff0e176448e312ac1adb1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.train_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00b583578569b2cefa9231d3ff9433b12727048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.train_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d5dd3eab0c124af031b708e6db7bb2cc0d63fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n_classes&lt;/code&gt; &amp;lt; 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6d4550e5a6bf869f60e3fa1a350b466e933f5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are both provided, &lt;code&gt;index&lt;/code&gt; will take precedence. Indices are based on order of horizontal graph traversal (bottom-up).</source>
          <target state="translated">Если указаны &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;index&lt;/code&gt; , приоритет будет иметь &lt;code&gt;index&lt;/code&gt; . Индексы основаны на порядке обхода горизонтального графика (снизу вверх).</target>
        </trans-unit>
        <trans-unit id="1c0d8013d0f068829822dba8e7f64091561f2075" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; does not correspond to a tensor in this graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8bc95945a72ec4e28c81731e09e5a537858c4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; does not correspond to an operation in this graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dac99a82a4855fd92c0429d41a455207d7330df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9372fbbb9f4a9e0103eaf09446f99e6060f9ec7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is not a valid scope name, according to the rules above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ec307ac7cb35e0dc1e4fe050cb0aec22f90730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name_or_scope&lt;/code&gt; is not None, it is used as is. If &lt;code&gt;name_or_scope&lt;/code&gt; is None, then &lt;code&gt;default_name&lt;/code&gt; is used. In that case, if the same name has been previously used in the same scope, it will be made unique by appending &lt;code&gt;_N&lt;/code&gt; to it.</source>
          <target state="translated">Если &lt;code&gt;name_or_scope&lt;/code&gt; не равно None, оно используется как есть. Если &lt;code&gt;name_or_scope&lt;/code&gt; равно None, то используется &lt;code&gt;default_name&lt;/code&gt; . В этом случае, если то же имя ранее использовалось в той же области, оно будет сделано уникальным, добавив к нему &lt;code&gt;_N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c871ac5f537b233d37ba8ba81c7ba4171a5f3e99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; has dimension sizes that are too small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1c2af83bbee922d1c0918f60ae2fcb275044f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is None, returns a copy of &lt;code&gt;sp_input&lt;/code&gt; with its shape reset to the tight bounding box of &lt;code&gt;sp_input&lt;/code&gt;. This will be a shape consisting of all zeros if sp_input has no values.</source>
          <target state="translated">Если &lt;code&gt;new_shape&lt;/code&gt; имеет значение None, возвращает копию &lt;code&gt;sp_input&lt;/code&gt; с ее формой, сброшенной в жесткую ограничивающую рамку &lt;code&gt;sp_input&lt;/code&gt; . Это будет фигура, состоящая из всех нулей, если sp_input не имеет значений.</target>
        </trans-unit>
        <trans-unit id="8ca15a59d7a7782d5db584a1d747b2599f5ff187" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is None, the returned SparseTensor will have a shape [2, 3, 4], which is the tight bounding box of &lt;code&gt;sp_input&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;new_shape&lt;/code&gt; равно None, возвращаемый SparseTensor будет иметь форму [2, 3, 4], которая является жесткой ограничивающей рамкой &lt;code&gt;sp_input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b570d610cf7a295b2ffb10a0e162c56ba33211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is determined during graph build to have dimension sizes that are too small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be9809aee367331cf17f4bd9c80ab0565a944bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is provided, then it must be larger or equal in all dimensions compared to the shape of &lt;code&gt;sp_input&lt;/code&gt;. When this condition is met, the returned SparseTensor will have its shape reset to &lt;code&gt;new_shape&lt;/code&gt; and its indices and values unchanged from that of &lt;code&gt;sp_input.&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;new_shape&lt;/code&gt; , то оно должно быть больше или равно во всех измерениях по сравнению с формой &lt;code&gt;sp_input&lt;/code&gt; . Когда это условие выполняется, возвращаемый SparseTensor будет иметь форму, сброшенную на &lt;code&gt;new_shape&lt;/code&gt; , а его индексы и значения не &lt;code&gt;sp_input.&lt;/code&gt; сравнению с sp_input.</target>
        </trans-unit>
        <trans-unit id="64e5cd1143e41daf1ced06d3243bd74d575211e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; represents a tensor with a different rank from that of &lt;code&gt;sp_input&lt;/code&gt; (if shapes are known when graph is constructed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d289ff2fb51015d3982713a0b861287cc457fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nrows&lt;/code&gt; is incompatible with &lt;code&gt;value_rowids&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d86dd9f224593f5a9a65b67de61c8f3febf1ab7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; is unspecified and cannot be inferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3e0c6e2098ecdeded1338dea9690c0f2076053" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_classes&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then &lt;code&gt;num_classes&lt;/code&gt; will be set to one plus the maximum value in either predictions or labels. Class labels are expected to start at 0. For example, if &lt;code&gt;num_classes&lt;/code&gt; is 3, then the possible labels would be &lt;code&gt;[0, 1, 2]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;num_classes&lt;/code&gt; равно &lt;code&gt;None&lt;/code&gt; , тогда &lt;code&gt;num_classes&lt;/code&gt; будет установлен на единицу плюс максимальное значение в прогнозах или метках. Ожидается, что метки классов будут начинаться с 0. Например, если &lt;code&gt;num_classes&lt;/code&gt; равно 3, тогда возможные метки будут &lt;code&gt;[0, 1, 2]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b01b0239cb5897c1f2262ed4d7ba81bcf45a0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_columns&lt;/code&gt; is determined statically to be non-scalar, or negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b02682a5d13fd2735399ea0a59eeecd0b50698a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_cores_per_replica&lt;/code&gt; is not 1, 2, 4, 8, ..., 128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd499df460f2dd2f7fc2c6f79c89aefd06f4920" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_diags == 1&lt;/code&gt;, the output tensor is of rank &lt;code&gt;r - 1&lt;/code&gt; with shape &lt;code&gt;[I, J, ..., L, max_diag_len]&lt;/code&gt; and values:</source>
          <target state="translated">Если &lt;code&gt;num_diags == 1&lt;/code&gt; , выходной тензор имеет ранг &lt;code&gt;r - 1&lt;/code&gt; с формой &lt;code&gt;[I, J, ..., L, max_diag_len]&lt;/code&gt; и значениями:</target>
        </trans-unit>
        <trans-unit id="e8ca4ee1f13309dc6f6b05d5f1ba5df5368509b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_mel_bins&lt;/code&gt; is not positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df0e8535951dd9f3d98a16079db075547e06704" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_mel_bins&lt;/code&gt;/&lt;code&gt;num_spectrogram_bins&lt;/code&gt;/&lt;code&gt;sample_rate&lt;/code&gt; are not positive, &lt;code&gt;lower_edge_hertz&lt;/code&gt; is negative, frequency edges are incorrectly ordered, &lt;code&gt;upper_edge_hertz&lt;/code&gt; is larger than the Nyquist frequency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71702fb3b8232853d975af1bf3071cd46c3b1ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is a 1-D Tensor (or list), then &lt;code&gt;value&lt;/code&gt; is split into &lt;code&gt;len(num_or_size_splits)&lt;/code&gt; elements. The shape of the &lt;code&gt;i&lt;/code&gt;-th element has the same size as the &lt;code&gt;value&lt;/code&gt; except along dimension &lt;code&gt;axis&lt;/code&gt; where the size is &lt;code&gt;num_or_size_splits[i]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c715ccae994cba7abe259313788d2138f8a5aa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is a 1-D Tensor (or list), we call it &lt;code&gt;size_splits&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; is split into &lt;code&gt;len(size_splits)&lt;/code&gt; elements. The shape of the &lt;code&gt;i&lt;/code&gt;-th element has the same size as the &lt;code&gt;value&lt;/code&gt; except along dimension &lt;code&gt;axis&lt;/code&gt; where the size is &lt;code&gt;size_splits[i]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;num_or_size_splits&lt;/code&gt; является одномерным тензором (или списком), мы называем его &lt;code&gt;size_splits&lt;/code&gt; , а &lt;code&gt;value&lt;/code&gt; разделяется на элементы &lt;code&gt;len(size_splits)&lt;/code&gt; . Форма &lt;code&gt;i&lt;/code&gt; -го элемента имеет тот же размер, что и &lt;code&gt;value&lt;/code&gt; за исключением &lt;code&gt;axis&lt;/code&gt; измерения, где размер равен &lt;code&gt;size_splits[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e425839a9eabf146225bfd1f11c4b5874f2adbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is an integer, then &lt;code&gt;value&lt;/code&gt; is split along dimension &lt;code&gt;axis&lt;/code&gt; into &lt;code&gt;num_split&lt;/code&gt; smaller tensors. This requires that &lt;code&gt;num_split&lt;/code&gt; evenly divides &lt;code&gt;value.shape[axis]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;num_or_size_splits&lt;/code&gt; является целым числом, то &lt;code&gt;value&lt;/code&gt; разбивается по &lt;code&gt;axis&lt;/code&gt; измерения на меньшие тензоры &lt;code&gt;num_split&lt;/code&gt; . Для этого требуется, чтобы &lt;code&gt;num_split&lt;/code&gt; равномерно &lt;code&gt;value.shape[axis]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86da9a142cb59be1ce483a5fcfad2cac22a8d043" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is an integer, then &lt;code&gt;value&lt;/code&gt; is split along the dimension &lt;code&gt;axis&lt;/code&gt; into &lt;code&gt;num_or_size_splits&lt;/code&gt; smaller tensors. This requires that &lt;code&gt;value.shape[axis]&lt;/code&gt; is divisible by &lt;code&gt;num_or_size_splits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450b92a44da53848f27208da6d233973284dc0ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_partitions&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; (not a &lt;code&gt;Tensor&lt;/code&gt;), then this is equivalent to &lt;code&gt;tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;num_partitions&lt;/code&gt; - это &lt;code&gt;int&lt;/code&gt; (не &lt;code&gt;Tensor&lt;/code&gt; ), то это эквивалентно &lt;code&gt;tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f769bea836beac98909e735795b268401e27cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_required&lt;/code&gt; &amp;lt; 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c4741e676875df5f8a0b09ab68db16b833e851" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_rows&lt;/code&gt; is determined statically to be non-scalar, or negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d2e4a3dd2b3d6799b99f0fed96f253cc3a96f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_rows&lt;/code&gt; or &lt;code&gt;batch_shape&lt;/code&gt; is ref-type (e.g. Variable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579c0d608dfebee22c27bc3846a042bea0ea2e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_shards &amp;lt;= 0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5d7600c41cb44c71f5d9a769d0cc3ba62e628f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not a type we support attempting to convert to types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2f62aecc189f0d6978a16f51136df1dfdafa83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not an object in the graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54195d19d2e45a3ab90b981e987d80bc875dcff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not trackable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d091a8b497d7d4382ab7948a754eedb14901ffe3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is of an appropriate type but invalid. For example, an invalid string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4931305edfb2d837c5c9e074234ca80b1ec8bcc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;off_value&lt;/code&gt; is not provided, it will default to the value &lt;code&gt;0&lt;/code&gt; with type &lt;code&gt;dtype&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;off_value&lt;/code&gt; не указан , по умолчанию будет установлено значение &lt;code&gt;0&lt;/code&gt; с типом &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f5adee6d1a5e5c25242f126e70ed57f928baf19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;on_value&lt;/code&gt; is not provided, it will default to the value &lt;code&gt;1&lt;/code&gt; with type &lt;code&gt;dtype&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;on_value&lt;/code&gt; не указан , по умолчанию будет установлено значение &lt;code&gt;1&lt;/code&gt; с типом &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be75a55bcf9630188e5d84c928dfdd3d3057e4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; then &lt;code&gt;ignore_existing&lt;/code&gt; must be &lt;code&gt;True&lt;/code&gt; and the new scope resets all colocation and device constraints.</source>
          <target state="translated">Если &lt;code&gt;op&lt;/code&gt; равно &lt;code&gt;None&lt;/code&gt; , тогда &lt;code&gt;ignore_existing&lt;/code&gt; должен иметь значение &lt;code&gt;True&lt;/code&gt; , и новая область сбрасывает все ограничения размещения и устройства.</target>
        </trans-unit>
        <trans-unit id="6d6efe500a1e419471950274e32a27e9f28c978e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_type&lt;/code&gt; is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420392368983977b5577e7d27b9eef71c57ac5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_type&lt;/code&gt; is not string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f506668c89a50f1d244e06bffb9e5da4a3f93cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_type_map&lt;/code&gt; is not a dictionary mapping strings to strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70782498d2a8b5e1fb1b956108ea7f9d6947614f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operator.is_non_singular&lt;/code&gt; is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ce4b8c411300123f420f7b7764c943a472c9df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operators&lt;/code&gt; is empty or are non-square.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb14b3c75832ddae6eceb4089bb41e04164cec51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operators&lt;/code&gt; is empty, contains an erroneous number of elements, or contains operators with incompatible shapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0178108ccd428b63c875a900e226b0c7611cbd90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operators&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfd171ea5e20a03c796a10ad68feaaf52cc516f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; acts like [batch] matrix &lt;code&gt;Aj&lt;/code&gt;, then &lt;code&gt;op_composed&lt;/code&gt; acts like the [batch] matrix formed with the multiplication &lt;code&gt;A1 A2...AJ&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;opj&lt;/code&gt; действует как [пакетная] матрица &lt;code&gt;Aj&lt;/code&gt; , то &lt;code&gt;op_composed&lt;/code&gt; действует как [пакетная] матрица, сформированная умножением &lt;code&gt;A1 A2...AJ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56c5724412cb951216de778a1bb8c5e384913867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; acts like a [batch] square matrix &lt;code&gt;Aj&lt;/code&gt;, then &lt;code&gt;op_combined&lt;/code&gt; acts like the [batch] square matrix formed by having each matrix &lt;code&gt;Aj&lt;/code&gt; on the main diagonal.</source>
          <target state="translated">Если &lt;code&gt;opj&lt;/code&gt; действует как [пакетная] квадратная матрица &lt;code&gt;Aj&lt;/code&gt; , то &lt;code&gt;op_combined&lt;/code&gt; действует как квадратная матрица [пакетного], образованная размещением каждой матрицы &lt;code&gt;Aj&lt;/code&gt; на главной диагонали.</target>
        </trans-unit>
        <trans-unit id="70c95e66ca24f2c6cab4d98e44a70b5b962a0ab7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; has shape &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt;, then the combined operator has shape &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt;, where &lt;code&gt;broadcast_batch_shape&lt;/code&gt; is the mutual broadcast of &lt;code&gt;batch_shape_j&lt;/code&gt;, &lt;code&gt;j = 1,...,J&lt;/code&gt;, assuming the intermediate batch shapes broadcast. Even if the combined shape is well defined, the combined operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</source>
          <target state="translated">Если &lt;code&gt;opj&lt;/code&gt; имеет форму &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt; , то комбинированный оператор имеет форму &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt; , где &lt;code&gt;broadcast_batch_shape&lt;/code&gt; является взаимная трансляция &lt;code&gt;batch_shape_j&lt;/code&gt; , &lt;code&gt;j = 1,...,J&lt;/code&gt; , предполагая промежуточное пакетные формы вещания. Даже если комбинированная форма хорошо определена, методы комбинированного оператора могут выйти из строя из-за отсутствия возможности широковещания в методах определяющих операторов.</target>
        </trans-unit>
        <trans-unit id="6d412d219703e29a2801725218983e3abe4d8a5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; has shape &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt;, then the composed operator will have shape equal to &lt;code&gt;broadcast_batch_shape + [prod M_j, prod N_j]&lt;/code&gt;, where the product is over all operators.</source>
          <target state="translated">Если &lt;code&gt;opj&lt;/code&gt; имеет форму &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt; , то составной оператор будет иметь форму, равную &lt;code&gt;broadcast_batch_shape + [prod M_j, prod N_j]&lt;/code&gt; , где продукт находится над всеми операторами.</target>
        </trans-unit>
        <trans-unit id="3035e177d8f7c6c99dae97a0ceb7953b26b8092b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; has shape &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt;, then we must have &lt;code&gt;N_j = M_{j+1}&lt;/code&gt;, in which case the composed operator has shape equal to &lt;code&gt;broadcast_batch_shape + [M_1, N_J]&lt;/code&gt;, where &lt;code&gt;broadcast_batch_shape&lt;/code&gt; is the mutual broadcast of &lt;code&gt;batch_shape_j&lt;/code&gt;, &lt;code&gt;j = 1,...,J&lt;/code&gt;, assuming the intermediate batch shapes broadcast. Even if the composed shape is well defined, the composed operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</source>
          <target state="translated">Если &lt;code&gt;opj&lt;/code&gt; имеет форму &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt; , тогда мы должны иметь &lt;code&gt;N_j = M_{j+1}&lt;/code&gt; , и в этом случае &lt;code&gt;broadcast_batch_shape + [M_1, N_J]&lt;/code&gt; оператор имеет форму, равную broadcast_batch_shape + [M_1, N_J] , где &lt;code&gt;broadcast_batch_shape&lt;/code&gt; является взаимная трансляция &lt;code&gt;batch_shape_j&lt;/code&gt; , &lt;code&gt;j = 1,...,J&lt;/code&gt; , предполагая, что промежуточные формы пакета транслируются. Даже если составная форма хорошо определена, методы составленного оператора могут не работать из-за отсутствия возможности широковещания в методах определяющих операторов.</target>
        </trans-unit>
        <trans-unit id="6ee93e7db0e30b7b5ccbb4d4fe3fae08772f421e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ord&lt;/code&gt; or &lt;code&gt;axis&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c905352aaa38aa4276b9e3ddc88efb6fafdbe603" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;outputs_from_all_shards&lt;/code&gt; is true, the outputs from all shards of &lt;code&gt;computation&lt;/code&gt; are concatenated back together along their &lt;code&gt;output_shard_axes&lt;/code&gt;. Otherwise, each output is taken from an arbitrary shard.</source>
          <target state="translated">Если &lt;code&gt;outputs_from_all_shards&lt;/code&gt; истинно, выходные данные от всех сегментов &lt;code&gt;computation&lt;/code&gt; объединяются вместе по их &lt;code&gt;output_shard_axes&lt;/code&gt; . В противном случае каждый вывод берется из произвольного шарда.</target>
        </trans-unit>
        <trans-unit id="9c1db6d79ffe07ebfaf8de704e064c8ef0b35ebe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pad_end&lt;/code&gt; is True, window positions that are past the end of the &lt;code&gt;axis&lt;/code&gt; dimension are padded with &lt;code&gt;pad_value&lt;/code&gt; until the window moves fully past the end of the dimension. Otherwise, only window positions that fully overlap the &lt;code&gt;axis&lt;/code&gt; dimension are produced.</source>
          <target state="translated">Если &lt;code&gt;pad_end&lt;/code&gt; имеет значение True, позиции окна, которые находятся за концом измерения &lt;code&gt;axis&lt;/code&gt; , дополняются &lt;code&gt;pad_value&lt;/code&gt; до тех пор, пока окно полностью не переместится за конец измерения. В противном случае создаются только положения окна, которые полностью перекрывают размер &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25d3dd5a787fb24d03624723b6ac3cb1fb7aafbe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;padding = &quot;SAME&quot;&lt;/code&gt;, then:</source>
          <target state="translated">Если &lt;code&gt;padding = &quot;SAME&quot;&lt;/code&gt; , то:</target>
        </trans-unit>
        <trans-unit id="0d24b307563d3f47caf57f6854d09c49e17b493e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;padding = &quot;VALID&quot;&lt;/code&gt;, then:</source>
          <target state="translated">Если &lt;code&gt;padding = &quot;VALID&quot;&lt;/code&gt; , то:</target>
        </trans-unit>
        <trans-unit id="11ca6ba85b93d818d20fc26499223569c33f6979" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf5b935b68f7f3addfed5f414c654714bb029cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;partition_strategy&lt;/code&gt; is &lt;code&gt;&quot;div&quot;&lt;/code&gt;, we assign ids to partitions in a contiguous manner. In this case, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;partition_strategy&lt;/code&gt; - &lt;code&gt;&quot;div&quot;&lt;/code&gt; , мы назначаем идентификаторы разделам непрерывно. В этом случае 13 идентификаторов разделены на 5 разделов следующим образом: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8acefec1523d308517a865bae60c7cc0aa4b6057" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;partition_strategy&lt;/code&gt; is &lt;code&gt;&quot;mod&quot;&lt;/code&gt;, we assign each id to partition &lt;code&gt;p = id % len(params)&lt;/code&gt;. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;partition_strategy&lt;/code&gt; - &lt;code&gt;&quot;mod&quot;&lt;/code&gt; , мы назначаем каждый идентификатор разделу &lt;code&gt;p = id % len(params)&lt;/code&gt; . Например, 13 идентификаторов разделены на 5 разделов следующим образом: &lt;code&gt;[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9c4832f7e4328cf39f111c97dc0ee8e31c623cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; cannot be opened for reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74a52c15c25f1deff61b03412dd4b9ef7402c3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; cannot be opened for writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dcb7eb9b33345678e978099f889acba18b6559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; specifies an index which is out of range for any of the input strings, then an &lt;code&gt;InvalidArgumentError&lt;/code&gt; is thrown.</source>
          <target state="translated">Если &lt;code&gt;pos&lt;/code&gt; указывает индекс, который выходит за пределы допустимого диапазона для любой из входных строк, возникает &lt;code&gt;InvalidArgumentError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03ca2ac0f5daf2ce02e137acee45f05e52ca4ccb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred&lt;/code&gt; is true, the &lt;code&gt;data&lt;/code&gt; input is forwarded to &lt;code&gt;output_true&lt;/code&gt;. Otherwise, the data goes to &lt;code&gt;output_false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6e53d36d6444935a96915d1d79cd000b99cfed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred_fn_pairs&lt;/code&gt; is a list but does not contain 2-tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02938a2c875b72d48bca1955864a514d0d9f55e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred_fn_pairs&lt;/code&gt; is not a list/dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0803575352c843b52cd64dde7a3cf2cb1dfc4156" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred_fn_pairs&lt;/code&gt; is not a list/tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfbd5fb700df00f8f689300a675fa3f95d1aad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; have mismatched shapes, if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if &lt;code&gt;sensitivity&lt;/code&gt; is not between 0 and 1, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf2fb54afc0a18a4d2f2c8afb5a2f3962603b49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; have mismatched shapes, if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if &lt;code&gt;specificity&lt;/code&gt; is not between 0 and 1, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6566667c2b1365a10aad1c89c55d266db371015d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; have mismatched shapes, or if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952ccf888d95d822b40e43d22e37817a337a6956" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; shape doesn't match &lt;code&gt;labels&lt;/code&gt; shape, or &lt;code&gt;axis&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;, &lt;code&gt;predictions&lt;/code&gt; or &lt;code&gt;weights&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7deb2d39051bc835be02d8f59da912bfcce83c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preprocess_collapse_repeated&lt;/code&gt; is True, then a preprocessing step runs before loss calculation, wherein repeated labels passed to the loss are merged into single labels. This is useful if the training labels come from, e.g., forced alignments and therefore have unnecessary repetitions.</source>
          <target state="translated">Если &lt;code&gt;preprocess_collapse_repeated&lt;/code&gt; имеет значение True, то перед вычислением потерь выполняется шаг предварительной обработки, в котором повторяющиеся метки, переданные в потерю, объединяются в отдельные метки. Это полезно, если обучающие метки получены, например, из принудительного выравнивания и, следовательно, имеют ненужные повторения.</target>
        </trans-unit>
        <trans-unit id="021bcc8eda694846961d1929e447de455777799b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;enqueue_ops&lt;/code&gt; are not provided when not restoring from &lt;code&gt;queue_runner_def&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164ac4e2b4a18286f06657a73f0ee558a2997841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rate&lt;/code&gt; is not in &lt;code&gt;[0, 1)&lt;/code&gt; or if &lt;code&gt;x&lt;/code&gt; is not a floating point tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55af12f0841b7b616eb136847a3820481361af7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rate&lt;/code&gt; is not in &lt;code&gt;[0, 1)&lt;/code&gt; or if &lt;code&gt;x&lt;/code&gt; is not a floating point tensor. &lt;code&gt;rate=1&lt;/code&gt; is disallowed, because the output would be all zeros, which is likely not what was intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e7bb60ddbe91fd7e6b982336b25fa2822fa9ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reader&lt;/code&gt; is of the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d718c63c1f1f0484423b570fc9531a8eff9cfe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ready_op&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the model is not checked for readiness.</source>
          <target state="translated">Если &lt;code&gt;ready_op&lt;/code&gt; равно &lt;code&gt;None&lt;/code&gt; , модель не проверяется на готовность.</target>
        </trans-unit>
        <trans-unit id="7957aaf8b9510d63a4030b611485abaa1905453d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;MEAN&lt;/code&gt;: Result (on all replicas): {'a': 2, 'b': [21, 49.5]}</source>
          <target state="translated">Если &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;MEAN&lt;/code&gt; : Результат (на всех репликах): {'a': 2, 'b': [21, 49.5]}</target>
        </trans-unit>
        <trans-unit id="e4c642304f745aaea2e1c1147192fb97d8fc30e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;SUM&lt;/code&gt;: Result (on all replicas): {'a': 4, 'b': [42, 99]}</source>
          <target state="translated">Если &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;SUM&lt;/code&gt; : Результат (на всех репликах): {'a': 4, 'b': [42, 99]}</target>
        </trans-unit>
        <trans-unit id="e0e30804ebbc33a2fc0166b120175f12f1b8b76b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned. Additionally, the axes can be negative, similar to the indexing rules in Python.</source>
          <target state="translated">Если &lt;code&gt;reduction_axes&lt;/code&gt; не имеет записей, все измерения уменьшаются, и возвращается тензор с одним элементом. Кроме того, оси могут быть отрицательными, как и в правилах индексации в Python.</target>
        </trans-unit>
        <trans-unit id="482cc696ec3bec581c709c5132a29fbf3c487797" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned. Additionally, the axes can be negative, which are interpreted according to the indexing rules in Python.</source>
          <target state="translated">Если &lt;code&gt;reduction_axes&lt;/code&gt; не имеет записей, все измерения уменьшаются, и возвращается тензор с одним элементом. Кроме того, оси могут быть отрицательными, что интерпретируется в соответствии с правилами индексации в Python.</target>
        </trans-unit>
        <trans-unit id="7f48379c242cda6f408083ddc4d5f3cb83c5bd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_sequences&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;return_sequences&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d35fbb8939197c7ac96515a84b436c62c4114b16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_sequences&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(samples, timesteps, filters, new_rows, new_cols)&lt;/code&gt; if data_format='channels_first' or 5D tensor with shape: &lt;code&gt;(samples, timesteps, new_rows, new_cols, filters)&lt;/code&gt; if data_format='channels_last'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e96de43a368a04807126c38f92e9d01f46e8303" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_sequences&lt;/code&gt;: N-D tensor with shape &lt;code&gt;[batch_size, timesteps, output_size]&lt;/code&gt;, where &lt;code&gt;output_size&lt;/code&gt; could be a high dimension tensor shape, or &lt;code&gt;[timesteps, batch_size, output_size]&lt;/code&gt; when &lt;code&gt;time_major&lt;/code&gt; is True.</source>
          <target state="translated">Если &lt;code&gt;return_sequences&lt;/code&gt; : тензор ND с формой &lt;code&gt;[batch_size, timesteps, output_size]&lt;/code&gt; , где &lt;code&gt;output_size&lt;/code&gt; может быть формой тензора высокой размерности, или &lt;code&gt;[timesteps, batch_size, output_size]&lt;/code&gt; когда &lt;code&gt;time_major&lt;/code&gt; имеет значение True.</target>
        </trans-unit>
        <trans-unit id="cf834b2e8c72ada021e5e5fa26d98ff38d8ebe5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_state&lt;/code&gt;: a list of tensors. The first tensor is the output. The remaining tensors are the last states, each 4D tensor with shape: &lt;code&gt;(samples, filters, new_rows, new_cols)&lt;/code&gt; if data_format='channels_first' or 4D tensor with shape: &lt;code&gt;(samples, new_rows, new_cols, filters)&lt;/code&gt; if data_format='channels_last'. &lt;code&gt;rows&lt;/code&gt; and &lt;code&gt;cols&lt;/code&gt; values might have changed due to padding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de50555e0eeebb193b44d9f99c305b469369c4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_state&lt;/code&gt;: a list of tensors. The first tensor is the output. The remaining tensors are the last states, each with shape &lt;code&gt;[batch_size, state_size]&lt;/code&gt;, where &lt;code&gt;state_size&lt;/code&gt; could be a high dimension tensor shape.</source>
          <target state="translated">Если &lt;code&gt;return_state&lt;/code&gt; : список тензоров. Первый тензор - это выход. Остальные тензоры - это последние состояния, каждое с формой &lt;code&gt;[batch_size, state_size]&lt;/code&gt; , где &lt;code&gt;state_size&lt;/code&gt; может быть формой тензора большой размерности.</target>
        </trans-unit>
        <trans-unit id="c98b068e115a7b1a126126186d96ebd64c8bfe6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;row_splits&lt;/code&gt; is an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb605686f7d9f5fc6c475658638babbcf6232d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, weights default to 1. Use &lt;code&gt;sample_weight&lt;/code&gt; of 0 to mask values.</source>
          <target state="translated">Если &lt;code&gt;sample_weight&lt;/code&gt; имеет значение &lt;code&gt;None&lt;/code&gt; , веса по умолчанию &lt;code&gt;sample_weight&lt;/code&gt; 1. Используйте sample_weight равным 0, чтобы замаскировать значения.</target>
        </trans-unit>
        <trans-unit id="8e28d91535a97ad650cc949f37258bb71da692f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of false negatives. This metric creates one local variable, &lt;code&gt;accumulator&lt;/code&gt; that is used to keep track of the number of false negatives.</source>
          <target state="translated">Если &lt;code&gt;sample_weight&lt;/code&gt; , вычисляет сумму весов ложноотрицательных результатов. Эта метрика создает одну локальную переменную, &lt;code&gt;accumulator&lt;/code&gt; который используется для отслеживания количества ложноотрицательных результатов.</target>
        </trans-unit>
        <trans-unit id="255358980ac8b58546dfe37fcb80b61a3fab0190" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of false positives. This metric creates one local variable, &lt;code&gt;accumulator&lt;/code&gt; that is used to keep track of the number of false positives.</source>
          <target state="translated">Если &lt;code&gt;sample_weight&lt;/code&gt; , вычисляет сумму весов ложных срабатываний. Эта метрика создает одну локальную переменную, &lt;code&gt;accumulator&lt;/code&gt; который используется для отслеживания количества ложных срабатываний.</target>
        </trans-unit>
        <trans-unit id="0a327cf38b6bc10153f472fc600865ad7c34dc87" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of true negatives. This metric creates one local variable, &lt;code&gt;accumulator&lt;/code&gt; that is used to keep track of the number of true negatives.</source>
          <target state="translated">Если &lt;code&gt;sample_weight&lt;/code&gt; , вычисляет сумму весов истинных отрицаний. Эта метрика создает одну локальную переменную, &lt;code&gt;accumulator&lt;/code&gt; который используется для отслеживания количества истинных отрицаний.</target>
        </trans-unit>
        <trans-unit id="157668b96cb6839360efaa68f2be010a0995a4ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of true positives. This metric creates one local variable, &lt;code&gt;true_positives&lt;/code&gt; that is used to keep track of the number of true positives.</source>
          <target state="translated">Если &lt;code&gt;sample_weight&lt;/code&gt; , вычисляет сумму весов истинно положительных результатов. Эта метрика создает одну локальную переменную &lt;code&gt;true_positives&lt;/code&gt; , которая используется для отслеживания количества истинных положительных результатов.</target>
        </trans-unit>
        <trans-unit id="1e99ed35485fa039a5ec399ab8ebf0bb9e48f66d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;scale&lt;/code&gt; or &lt;code&gt;center&lt;/code&gt; are enabled, the layer will scale the normalized outputs by broadcasting them with a trainable variable &lt;code&gt;gamma&lt;/code&gt;, and center the outputs by broadcasting with a trainable variable &lt;code&gt;beta&lt;/code&gt;. &lt;code&gt;gamma&lt;/code&gt; will default to a ones tensor and &lt;code&gt;beta&lt;/code&gt; will default to a zeros tensor, so that centering and scaling are no-ops before training has begun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2da19779e187c2e650651bd30fa0693bb089d6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.is_non_singular&lt;/code&gt; or &lt;code&gt;is_square&lt;/code&gt; is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48227b911119a516c4d8c5a10f56b38e2c7b085a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.is_square&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7a2e7a633e9dd2077225b20b7446adffe78f77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are not compatible (see is_compatible_with).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76678c2c433bcbde5907f519d3fe1c0a7ff4a4ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are not compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ed2a5d39e1cb42af886c61df533070e9fe88a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not represent shapes with the same rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45c24232f29a913f2a86b78d61193ec7a0ecbe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not represent the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e0efa59d0ad24d8ba4a6fa76b6d4d0ad5e1aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not have a known value for every dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451641d83eca8517ac4bb5051d5fc61e52bf5cea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not represent a shape with at least the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595c977a574f63ee86be4dd6f2c6b66f30a423e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not represent a shape with at most the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3f402cb6f12b2b990c1d375019237fc953c651" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not represent a shape with the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0283c3881ae85d735ecc7e5f6bee51fe71c8d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is an unknown shape with an unknown rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bffe63db0549b3cd56cefe8885a84cdb4b1bd6c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is an empty string, each element of the &lt;code&gt;source&lt;/code&gt; is split into individual strings, each containing one byte. (This includes splitting multibyte sequences of UTF-8.) If delimiter contains multiple bytes, it is treated as a set of delimiters with each considered a potential split point.</source>
          <target state="translated">Если &lt;code&gt;sep&lt;/code&gt; является пустой строкой, каждый элемент &lt;code&gt;source&lt;/code&gt; разбивается на отдельные строки, каждая из которых содержит один байт. (Это включает разбиение многобайтовых последовательностей UTF-8.) Если разделитель содержит несколько байтов, он рассматривается как набор разделителей, каждый из которых считается потенциальной точкой разделения.</target>
        </trans-unit>
        <trans-unit id="9fdfb5a1f94fc643caca96a1c21220a86e536291" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings. For example, &lt;code&gt;input&lt;/code&gt; of &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; and &lt;code&gt;sep&lt;/code&gt; of &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt;. If &lt;code&gt;sep&lt;/code&gt; is None or an empty string, consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace.</source>
          <target state="translated">Если задано &lt;code&gt;sep&lt;/code&gt; , последовательные разделители не группируются вместе и считаются ограничивающими пустые строки. Например, &lt;code&gt;input&lt;/code&gt; в &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; и &lt;code&gt;sep&lt;/code&gt; из &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; возвращается &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt; . Если &lt;code&gt;sep&lt;/code&gt; равен None или является пустой строкой, последовательные пробелы рассматриваются как один разделитель, и результат не будет содержать пустых строк в начале или конце, если строка имеет начальные или конечные пробелы.</target>
        </trans-unit>
        <trans-unit id="92dd030f8c8e48b20c9e8313f19f4213c360c52a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings. For example, source of &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; and sep of &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt;. If &lt;code&gt;sep&lt;/code&gt; is None or an empty string, consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the startor end if the string has leading or trailing whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410d562c0da8a3bf9960cfbc34a9467e74826468" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sequence&lt;/code&gt; format, &lt;code&gt;diagonals&lt;/code&gt; is list or tuple of three tensors: &lt;code&gt;[superdiag, maindiag, subdiag]&lt;/code&gt;, each having shape [..., M]. Last element of &lt;code&gt;superdiag&lt;/code&gt; first element of &lt;code&gt;subdiag&lt;/code&gt; are ignored.</source>
          <target state="translated">Если формат &lt;code&gt;sequence&lt;/code&gt; , &lt;code&gt;diagonals&lt;/code&gt; представляют собой список или кортеж из трех тензоров: &lt;code&gt;[superdiag, maindiag, subdiag]&lt;/code&gt; , каждый из которых имеет форму [..., M]. Последний элемент &lt;code&gt;superdiag&lt;/code&gt; первый элемент &lt;code&gt;subdiag&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="d4e69b0caa45c8dda4e5a80e1ddb9661eb89a96d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;serialized&lt;/code&gt; does not describe a well-formed topology.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9275c1cc2beb3aadef035909c57a8214c7cb4e18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;serialized&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;device_coordinates&lt;/code&gt; is not a rank 4 numpy int32 array that describes a valid coordinate mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebed2d9ba6ebe4d7486ba61e6980ca257015166" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;serialized&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;mesh_shape&lt;/code&gt; is not a sequence of 4 positive integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cd1c4325dfb3d13a2d209689253e4d7ddd0b5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sess&lt;/code&gt; is not a &lt;code&gt;Session&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7934bc8a2624320349f9c139def414a89ff0e04b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;session.run()&lt;/code&gt; raises any exceptions then &lt;code&gt;after_run()&lt;/code&gt; is not called.</source>
          <target state="translated">Если &lt;code&gt;session.run()&lt;/code&gt; вызывает какие-либо исключения, &lt;code&gt;after_run()&lt;/code&gt; не вызывается.</target>
        </trans-unit>
        <trans-unit id="09784c2129ebb38568a3c1d9df7ccc60926fc6ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;session.run()&lt;/code&gt; raises exception other than OutOfRangeError or StopIteration then &lt;code&gt;end()&lt;/code&gt; is not called. Note the difference between &lt;code&gt;end()&lt;/code&gt; and &lt;code&gt;after_run()&lt;/code&gt; behavior when &lt;code&gt;session.run()&lt;/code&gt; raises OutOfRangeError or StopIteration. In that case &lt;code&gt;end()&lt;/code&gt; is called but &lt;code&gt;after_run()&lt;/code&gt; is not called.</source>
          <target state="translated">Если &lt;code&gt;session.run()&lt;/code&gt; вызывает исключение, отличное от OutOfRangeError или StopIteration, &lt;code&gt;end()&lt;/code&gt; не вызывается. Обратите внимание на разницу между поведением &lt;code&gt;end()&lt;/code&gt; и &lt;code&gt;after_run()&lt;/code&gt; когда &lt;code&gt;session.run()&lt;/code&gt; вызывает OutOfRangeError или StopIteration. В этом случае &lt;code&gt;end()&lt;/code&gt; вызывается, но &lt;code&gt;after_run()&lt;/code&gt; не вызывается.</target>
        </trans-unit>
        <trans-unit id="57fd1127c11716bc2d9489a6deb8f1692eefbda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has more than one inferred (== -1) dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdb39fad8818509a7732132e218e156173f9c64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; is not compatible with the current shape of this tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26186007203a58d8911a11ba346690902e600819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; is set, the &lt;code&gt;value&lt;/code&gt; is reshaped to match. Scalars are expanded to fill the &lt;code&gt;shape&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;shape&lt;/code&gt; установлена, &lt;code&gt;value&lt;/code&gt; изменяется, чтобы соответствовать. Скаляры растягиваются, чтобы заполнить &lt;code&gt;shape&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="69ba8d826fa53cdf396fee409e1ec4f0ecdb1a26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; is specified, then the result is padded and/or truncated to the specified shape.</source>
          <target state="translated">Если &lt;code&gt;shape&lt;/code&gt; указана, результат дополняется и / или усекается до указанной формы.</target>
        </trans-unit>
        <trans-unit id="89232de163bc637ce58f4516f0bdef60a5ef7e2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signal&lt;/code&gt;'s rank is less than 2, or &lt;code&gt;frame_step&lt;/code&gt; is not a scalar integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7166a5ed0f15f536c01b378a69cfaac5e2d9fa6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signals&lt;/code&gt; is not at least rank 1, &lt;code&gt;frame_length&lt;/code&gt; is not scalar, or &lt;code&gt;frame_length&lt;/code&gt; is not a multiple of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613ee7740260ce62973f1ab1c65d17f5e2743235" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signals&lt;/code&gt; is not at least rank 1, &lt;code&gt;frame_length&lt;/code&gt; is not scalar, or &lt;code&gt;frame_step&lt;/code&gt; is not scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4fbedf928e2361e80160d5a67f755abc60ef5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skip_mismatch&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt; when &lt;code&gt;by_name&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a1b0007ac4afd8d13976ea5e308a532f9b01d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source_column&lt;/code&gt; is not a numeric column, or if it is not one-dimensional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3306aee7110cf653f0faca81ca3e2580c65d51bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt;, then &lt;code&gt;output.shape = [D0, D1, ..., Dn, vocab_size]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt; , то &lt;code&gt;output.shape = [D0, D1, ..., Dn, vocab_size]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb1cc9cf91251c8b6f3f93a0a55857068bb3f279" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt;, then &lt;code&gt;output.shape = [D0, D1, ..., Dn] + vocab_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4411ef14581c867217d2df04414ed49d9c28a03e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids&lt;/code&gt; and &lt;code&gt;vocab_size&lt;/code&gt; are lists of different lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6813a559b2946e19be42f85a8a034ff7dcf1bfbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids&lt;/code&gt; is not a &lt;code&gt;SparseTensor&lt;/code&gt;, or if &lt;code&gt;sp_weights&lt;/code&gt; is neither &lt;code&gt;None&lt;/code&gt; nor &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b895834e50bd2bdfc0f0a3b5d865361c9f8f5a82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_input&lt;/code&gt; is not a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be8e1370082dd375f634c0413b359c49efd2d0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_inputs&lt;/code&gt; is not a list of &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e04f80ce0bfacac0faf532947db58f9eff4ce40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_values&lt;/code&gt; is not a &lt;code&gt;SparseTensor&lt;/code&gt;. Or if &lt;code&gt;sp_ids&lt;/code&gt; is neither a &lt;code&gt;SparseTensor&lt;/code&gt; nor a list thereof. Or if &lt;code&gt;vocab_size&lt;/code&gt; is not a &lt;code&gt;Tensor&lt;/code&gt; or a Python int and &lt;code&gt;sp_ids&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;. Or if &lt;code&gt;vocab_size&lt;/code&gt; is not a or list thereof and &lt;code&gt;sp_ids&lt;/code&gt; is a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4962e7412ce58eae8b3acf5a207ac8244f0115d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;splits&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8902e3e27b9aa6fb1875d3d80d84c7f114fa6048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start[i] &amp;lt; limits[i] and deltas[i] &amp;gt; 0&lt;/code&gt;, then &lt;code&gt;output[i]&lt;/code&gt; will be an empty list. Similarly, if &lt;code&gt;start[i] &amp;gt; limits[i] and deltas[i] &amp;lt; 0&lt;/code&gt;, then &lt;code&gt;output[i]&lt;/code&gt; will be an empty list. This behavior is consistent with the Python &lt;code&gt;range&lt;/code&gt; function, but differs from the &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;tf.range&lt;/code&gt;&lt;/a&gt; op, which returns an error for these cases.</source>
          <target state="translated">Если &lt;code&gt;start[i] &amp;lt; limits[i] and deltas[i] &amp;gt; 0&lt;/code&gt; , то &lt;code&gt;output[i]&lt;/code&gt; будет пустым списком. Аналогично, если &lt;code&gt;start[i] &amp;gt; limits[i] and deltas[i] &amp;lt; 0&lt;/code&gt; , то &lt;code&gt;output[i]&lt;/code&gt; будет пустым списком. Это поведение согласуется с функцией &lt;code&gt;range&lt;/code&gt; Python , но отличается от &lt;a href=&quot;../range&quot;&gt; &lt;code&gt;tf.range&lt;/code&gt; &lt;/a&gt; , которая возвращает ошибку для этих случаев.</target>
        </trans-unit>
        <trans-unit id="5badd1435f6f82ed12933a662ffbe1ffaf9781d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;state_size&lt;/code&gt; is a nested list or tuple, then the return value is a nested list or tuple (of the same structure) of &lt;code&gt;2-D&lt;/code&gt; tensors with the shapes &lt;code&gt;[batch_size, s]&lt;/code&gt; for each s in &lt;code&gt;state_size&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;state_size&lt;/code&gt; является вложенным списком или кортежем, то возвращаемое значение представляет собой вложенный список или кортеж (той же структуры) &lt;code&gt;2-D&lt;/code&gt; тензоров с формами &lt;code&gt;[batch_size, s]&lt;/code&gt; для каждого s в &lt;code&gt;state_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07e559f7a73c999870c14a2000e0cc3df988ce1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;state_size&lt;/code&gt; is an int or TensorShape, then the return value is a &lt;code&gt;N-D&lt;/code&gt; tensor of shape &lt;code&gt;[batch_size, state_size]&lt;/code&gt; filled with zeros.</source>
          <target state="translated">Если &lt;code&gt;state_size&lt;/code&gt; имеет тип int или TensorShape, то возвращаемое значение представляет собой тензор &lt;code&gt;N-D&lt;/code&gt; формы &lt;code&gt;[batch_size, state_size]&lt;/code&gt; заполненный нулями.</target>
        </trans-unit>
        <trans-unit id="14e4d62f9d346901366838d3fd80a552973404e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;steps &amp;lt;= 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae2daed203e1d66c3418d4aa986f8e07fde11a25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stfts&lt;/code&gt; is not at least rank 2, &lt;code&gt;frame_length&lt;/code&gt; is not scalar, &lt;code&gt;frame_step&lt;/code&gt; is not scalar, or &lt;code&gt;fft_length&lt;/code&gt; is not scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4532e386d825d27cc0d8910075cfb30bf2a4f779" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;structure&lt;/code&gt; is a scalar, &lt;code&gt;flat_sequence&lt;/code&gt; must be a single-element list; in this case the return value is &lt;code&gt;flat_sequence[0]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;structure&lt;/code&gt; является скаляром, &lt;code&gt;flat_sequence&lt;/code&gt; должен быть одноэлементным списком; в этом случае возвращаемое значение - &lt;code&gt;flat_sequence[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b494d6e33a53c7ae07fa0e82931781adc7922732" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;structure&lt;/code&gt; is or contains a dict instance, the keys will be sorted to pack the flat sequence in deterministic order. This is true also for &lt;code&gt;OrderedDict&lt;/code&gt; instances: their sequence order is ignored, the sorting order of keys is used instead. The same convention is followed in &lt;code&gt;flatten&lt;/code&gt;. This correctly repacks dicts and &lt;code&gt;OrderedDict&lt;/code&gt;s after they have been flattened, and also allows flattening an &lt;code&gt;OrderedDict&lt;/code&gt; and then repacking it back using a corresponding plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be flattened.</source>
          <target state="translated">Если &lt;code&gt;structure&lt;/code&gt; является экземпляром dict или содержит его, ключи будут отсортированы для упаковки плоской последовательности в детерминированном порядке. Это верно также для экземпляров &lt;code&gt;OrderedDict&lt;/code&gt; : порядок их последовательности игнорируется, вместо этого используется порядок сортировки ключей. То же соглашение соблюдается и в &lt;code&gt;flatten&lt;/code&gt; . Это правильно переупаковывает dicts и &lt;code&gt;OrderedDict&lt;/code&gt; после того, как они были сглажены, а также позволяет сглаживать &lt;code&gt;OrderedDict&lt;/code&gt; , а затем переупаковывать его обратно с помощью соответствующего простого dict или наоборот. Словари с несортированными ключами не могут быть сглажены.</target>
        </trans-unit>
        <trans-unit id="2ff0d1fded6b11da7576139681c5785b18ee22e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t_list&lt;/code&gt; is not a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcaf1babb5a597a989c73bcfde0a0be8176fa94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tags&lt;/code&gt; don't match a MetaGraph in the SavedModel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54db97109d39c461225af09edb4e2c6bad57c86a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tensor_info&lt;/code&gt; does not correspond to a tensor in &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b5d1cfd94a3b115343c2aead810deecbcee0e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tensor_info&lt;/code&gt; is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787d21eabc723ffca9e50ef1a89051d32bffd148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tensors&lt;/code&gt; does not contain any &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e0188994bf5b19fa20e0c1686170da44726237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timer_interval_secs&lt;/code&gt; is None the thread calls &lt;code&gt;target(*args, **kwargs)&lt;/code&gt; repeatedly. Otherwise it calls it every &lt;code&gt;timer_interval_secs&lt;/code&gt; seconds. The thread terminates when a stop is requested.</source>
          <target state="translated">Если &lt;code&gt;timer_interval_secs&lt;/code&gt; равен None, поток повторно вызывает &lt;code&gt;target(*args, **kwargs)&lt;/code&gt; . В противном случае он вызывает его каждые &lt;code&gt;timer_interval_secs&lt;/code&gt; секунд. Поток завершается, когда запрашивается остановка.</target>
        </trans-unit>
        <trans-unit id="76359a8d4d73a2a3ba1c31d55e4ea69973764917" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timer_interval_secs&lt;/code&gt; is None the thread calls &lt;code&gt;target(args)&lt;/code&gt; repeatedly. Otherwise &lt;code&gt;target(args)&lt;/code&gt; is called every &lt;code&gt;timer_interval_secs&lt;/code&gt; seconds. The thread terminates when a stop of the coordinator is requested.</source>
          <target state="translated">Если &lt;code&gt;timer_interval_secs&lt;/code&gt; равен None, поток повторно вызывает &lt;code&gt;target(args)&lt;/code&gt; . В противном случае &lt;code&gt;target(args)&lt;/code&gt; вызывается каждые &lt;code&gt;timer_interval_secs&lt;/code&gt; секунд. Поток завершается, когда запрашивается остановка координатора.</target>
        </trans-unit>
        <trans-unit id="39df2528537689a6ff6d7670c2bc27741338adc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;top_k&lt;/code&gt; is set, recall will be computed as how often on average a class among the labels of a batch entry is in the top-k predictions.</source>
          <target state="translated">Если &lt;code&gt;top_k&lt;/code&gt; , напоминание будет вычисляться как то, как часто в среднем класс среди меток записи пакета встречается в предсказаниях top-k.</target>
        </trans-unit>
        <trans-unit id="22ad2e08fc56749566578c3ac9018bef993d749c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;top_k&lt;/code&gt; is set, we'll calculate precision as how often on average a class among the top-k classes with the highest predicted values of a batch entry is correct and can be found in the label for that entry.</source>
          <target state="translated">Если &lt;code&gt;top_k&lt;/code&gt; , мы будем вычислять точность как то, как часто в среднем класс из k классов с наивысшими прогнозируемыми значениями пакетной записи является правильным и может быть найден в метке для этой записи.</target>
        </trans-unit>
        <trans-unit id="58bafb59f0fd772a45f6640d18cc022786a6b29d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;topology&lt;/code&gt; is not &lt;code&gt;Topology&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4920d5aadd2fd1903db2747b34401a1a55495e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trainable&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; the variable is also added to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;trainable&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , переменная также добавляется в коллекцию графов &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e31d01c2f769b22b55d39dc7167bfe34f407bcd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;transpose_a&lt;/code&gt; and &lt;code&gt;adjoint_a&lt;/code&gt;, or &lt;code&gt;transpose_b&lt;/code&gt; and &lt;code&gt;adjoint_b&lt;/code&gt; are both set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e4b2e1a7e2f83da1dc94074e53cc0a41fefd20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;norm&lt;/code&gt; is &lt;code&gt;ortho&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a14472bd70b91d2d821d4767673189e3c32c45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;None,&lt;/code&gt;axis&lt;code&gt;is not&lt;/code&gt;-1&lt;code&gt;, or&lt;/code&gt;norm&lt;code&gt;is not&lt;/code&gt;None&lt;code&gt;or&lt;/code&gt;'ortho'`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8a412620e4f0db59b941b58e4ea5b61c2aadb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; or greater than 0, or &lt;code&gt;norm&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;'ortho'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfe5af8b4eee174a0116628b333e223b110eaba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type_value&lt;/code&gt; cannot be converted to a &lt;code&gt;DType&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f5898ab52e0b7a1f47284ea2d111ba5b883073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;units&lt;/code&gt;, &lt;code&gt;cell_type&lt;/code&gt;, and &lt;code&gt;rnn_cell_fn&lt;/code&gt; are not compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d94e19ec763d0a214f62d7c38f7e3bd893e8f1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mini_batch&lt;/code&gt; is False, it runs standard full batch K-means. Each training step runs a single iteration of K-Means and must process the full input at once. To run in this mode, the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt; must return the entire input dataset.</source>
          <target state="translated">Если &lt;code&gt;use_mini_batch&lt;/code&gt; имеет значение False, выполняется стандартное полное пакетное K-средство. Каждый шаг обучения запускает одну итерацию K-средних и должен обрабатывать все входные данные сразу. Чтобы работать в этом режиме, &lt;code&gt;input_fn&lt;/code&gt; , переданный в &lt;code&gt;train&lt;/code&gt; , должен возвращать весь входной набор данных.</target>
        </trans-unit>
        <trans-unit id="fbda24875bef97bbb29fa5aa5d61e455a7519b95" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mini_batch&lt;/code&gt; is True, it runs a generalization of the mini-batch K-means algorithm. It runs multiple iterations, where each iteration is composed of &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; steps. Each training step accumulates the contribution from one mini-batch into temporary storage. Every &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; steps, the cluster centers are updated and the temporary storage cleared for the next iteration. For example: the entire dataset contains 64k examples, where the batch size is 64. User can choose mini_batch_steps_per_iteration = 100 to run 10% of the entire data every iteration in order to update the cluster centers. Note that: * If &lt;code&gt;mini_batch_steps_per_iteration=1&lt;/code&gt;, the algorithm reduces to the standard K-means mini-batch algorithm. * If &lt;code&gt;mini_batch_steps_per_iteration = num_inputs / batch_size&lt;/code&gt;, the algorithm becomes an asynchronous version of the full-batch algorithm. However, there is no guarantee by this implementation that each input is seen exactly once per iteration. Also, different updates are applied asynchronously without locking. So this asynchronous version may not behave exactly like a full-batch version.</source>
          <target state="translated">Если &lt;code&gt;use_mini_batch&lt;/code&gt; имеет значение True, он запускает обобщение алгоритма мини-пакетных K-средних. Он выполняет несколько итераций, каждая из которых состоит из шагов &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; . Каждый шаг обучения накапливает вклад от одной мини-партии во временное хранилище. Каждые шаги &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; центры кластеров обновляются, а временное хранилище очищается для следующей итерации. Например: весь набор данных содержит 64k ​​примеров, из которых размер пакета равен 64. Пользователь может выбрать mini_batch_steps_per_iteration = 100 для запуска 10% всех данных на каждой итерации для обновления центров кластеров. Обратите внимание: * Если &lt;code&gt;mini_batch_steps_per_iteration=1&lt;/code&gt; , алгоритм сводится к стандартному алгоритму мини-пакетной обработки K-средних. * Если &lt;code&gt;mini_batch_steps_per_iteration = num_inputs / batch_size&lt;/code&gt; , алгоритм становится асинхронной версией алгоритма полного пакета. Однако эта реализация не гарантирует, что каждый ввод будет виден ровно один раз за итерацию. Кроме того, разные обновления применяются асинхронно без блокировки. Таким образом, эта асинхронная версия может не вести себя точно так же, как полноразмерная версия.</target>
        </trans-unit>
        <trans-unit id="0de9b1589edff3edb12b3507ec1953380c622e7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;SparseToSparseSetOperation&lt;/code&gt; validates the order and range of &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260ea41f74c472364a81400bd73602e6cf8bf5c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa3579a7c6b92c6e873864921b371fc1cfef25a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set2&lt;/code&gt; indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3305a90fa51b42ef64ce98951aa13c81a456e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set&lt;/code&gt; indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1abfdc44d511adbb90473745fa524076478dca31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is a list, then the length of the list must be equal to the number of elements implied by the desired shape of the tensor. If the total number of elements in &lt;code&gt;value&lt;/code&gt; is not equal to the number of elements required by the tensor shape, the initializer will raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f123d9bcbe68894415e895e218694c01aa94734" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is an &lt;code&gt;IndexedSlices&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; it is returned unmodified. Otherwise, it is converted to a &lt;code&gt;Tensor&lt;/code&gt; using &lt;code&gt;convert_to_tensor()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;IndexedSlices&lt;/code&gt; или &lt;code&gt;SparseTensor&lt;/code&gt; , оно возвращается без изменений. В противном случае он преобразуется в &lt;code&gt;Tensor&lt;/code&gt; с помощью &lt;code&gt;convert_to_tensor()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f99b9bc1783a763e0074d7f02eada525fcb32905" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is empty, the result is &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;value&lt;/code&gt; пусто, результатом будет &lt;code&gt;nan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc11671e327afed930dbaa313b8e03a128124801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is a &lt;code&gt;TensorProto&lt;/code&gt;, it is immediately returned; &lt;code&gt;dtype&lt;/code&gt; and &lt;code&gt;shape&lt;/code&gt; are ignored.</source>
          <target state="translated">Если &lt;code&gt;values&lt;/code&gt; - это &lt;code&gt;TensorProto&lt;/code&gt; , он немедленно возвращается; &lt;code&gt;dtype&lt;/code&gt; и &lt;code&gt;shape&lt;/code&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="4b3985f33eae49407759fdafe7e97f1ceb123a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is empty, if &lt;code&gt;axis&lt;/code&gt; is out of bounds or if the input tensors have different ranks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4991d0b9279a9695b7dc9ffd7b6d11392cfa51c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not iterable or is one of &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;SparseTensor&lt;/code&gt;, &lt;code&gt;np.array&lt;/code&gt;, &lt;a href=&quot;../compat#bytes_or_text_types&quot;&gt;&lt;code&gt;tf.compat.bytes_or_text_types&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adcccd399060c3499bb9a842249a7c23159bb96d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var&lt;/code&gt; is mirrored across multiple devices, then this implements logic like:</source>
          <target state="translated">Если &lt;code&gt;var&lt;/code&gt; зеркалируется на нескольких устройствах, то это реализует такую ​​логику:</target>
        </trans-unit>
        <trans-unit id="e259007ec837353b25e8dee0a7ca91b5e9dd17dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var&lt;/code&gt; is mirrored across multiple devices, then this method implements logic as following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11eede5a4c994c0e0896bbe89af7ae79fa5c41fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var_list&lt;/code&gt; contains anything else than &lt;code&gt;Variable&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f399b1c4fa48e152a02dd3bfffed24395c183ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var_list&lt;/code&gt; is empty, however, the function still returns an Op that can be run. That Op just has no effect.</source>
          <target state="translated">Однако, если &lt;code&gt;var_list&lt;/code&gt; пуст, функция все равно возвращает операцию , которую можно запустить. Эта операция просто не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="8be83695571e67c755a97c6fc16febe7943e3a10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var_list&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42bb3b276bc1fc0235ac461a83cafa45706822f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;variational_recurrent&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt; (&lt;strong&gt;NOT&lt;/strong&gt; the default behavior), then the same dropout mask is applied at every step, as described in: &lt;a href=&quot;https://arxiv.org/abs/1512.05287&quot;&gt;A Theoretically Grounded Application of Dropout in Recurrent Neural Networks. Y. Gal, Z. Ghahramani&lt;/a&gt;.</source>
          <target state="translated">Если для параметра &lt;code&gt;variational_recurrent&lt;/code&gt; установлено значение &lt;code&gt;True&lt;/code&gt; ( &lt;strong&gt;НЕ&lt;/strong&gt; поведение по умолчанию), то на каждом шаге применяется одна и та же маска исключения, как описано в: &lt;a href=&quot;https://arxiv.org/abs/1512.05287&quot;&gt;Теоретически обоснованное применение исключения в рекуррентных нейронных сетях. Й. Гал, З. Гахрамани&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="215c7e26218a7cf0186a8ee346eb2c5afd2709e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is not a &lt;code&gt;NumericColumn&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237eb51162671a05da58da5d5961835a0202c7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is specified, weights must be of shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; or &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;weight_column&lt;/code&gt; веса, веса должны иметь форму &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; или &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f989491367f7caf9a09da24af74f0b79ec083b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is specified, weights must be of shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt;, &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; or &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;weight_column&lt;/code&gt; , веса должны иметь форму &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; , &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; или &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84597725a0c8b36564c590276f692f8221e6d0bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is specified, weights must be of shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt;, or &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;weight_column&lt;/code&gt; , веса должны иметь форму &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; или &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47c0cda9fe6b3ac05940dedc576a336a807a2582" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; or the shape is not compatible with &lt;code&gt;losses&lt;/code&gt;, or if the number of dimensions (rank) of either &lt;code&gt;losses&lt;/code&gt; or &lt;code&gt;weights&lt;/code&gt; is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b457250beb9be8c779a4f43124b54d808dbb483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, weights default to 1. Use weights of 0 to mask values.</source>
          <target state="translated">Если &lt;code&gt;weights&lt;/code&gt; равен &lt;code&gt;None&lt;/code&gt; , вес по умолчанию равен 1. Используйте вес 0 для маскировки значений.</target>
        </trans-unit>
        <trans-unit id="3b2a2aef63c2b4c5eddf622788b9b18a8c0afbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is None, determines the type of the output bins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c3bdec09ee152e2fea08d1e1e856d94bfdf3de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1cbd19298e182234a3c7035094b3c9f4488462" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;values&lt;/code&gt;, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada8b39f6dc45d6686ae7823833c9a7be0ec5faf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, then each prediction contributes its corresponding weight to the total value of the confusion matrix cell.</source>
          <target state="translated">Если &lt;code&gt;weights&lt;/code&gt; не &lt;code&gt;None&lt;/code&gt; , то каждое предсказание вносит свой соответствующий вес в общее значение ячейки матрицы неточностей.</target>
        </trans-unit>
        <trans-unit id="34ed67f8fd358a60d4e9d51cdfe3288db982de76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is greater than the specified &lt;code&gt;target_width&lt;/code&gt; or &lt;code&gt;target_height&lt;/code&gt; respectively, this op centrally crops along that dimension. If &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is smaller than the specified &lt;code&gt;target_width&lt;/code&gt; or &lt;code&gt;target_height&lt;/code&gt; respectively, this op centrally pads with 0 along that dimension.</source>
          <target state="translated">Если &lt;code&gt;width&lt;/code&gt; или &lt;code&gt;height&lt;/code&gt; больше указанного значения &lt;code&gt;target_width&lt;/code&gt; или &lt;code&gt;target_height&lt;/code&gt; соответственно, эта операция выполняется централизованно по этому измерению. Если &lt;code&gt;width&lt;/code&gt; или &lt;code&gt;height&lt;/code&gt; меньше, чем указанная &lt;code&gt;target_width&lt;/code&gt; или &lt;code&gt;target_height&lt;/code&gt; соответственно, эта операция централизованно дополняется 0 вдоль этого измерения.</target>
        </trans-unit>
        <trans-unit id="92ed9d6131464277d99f7646cff60c8796c93393" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x &amp;lt; y&lt;/code&gt;, the &lt;code&gt;tf.add&lt;/code&gt; operation will be executed and &lt;code&gt;tf.square&lt;/code&gt; operation will not be executed. Since &lt;code&gt;z&lt;/code&gt; is needed for at least one branch of the &lt;code&gt;cond&lt;/code&gt;, the &lt;a href=&quot;../../math/multiply&quot;&gt;&lt;code&gt;tf.multiply&lt;/code&gt;&lt;/a&gt; operation is always executed, unconditionally.</source>
          <target state="translated">Если &lt;code&gt;x &amp;lt; y&lt;/code&gt; , операция &lt;code&gt;tf.add&lt;/code&gt; будет выполнена, а операция &lt;code&gt;tf.square&lt;/code&gt; не будет выполнена. Поскольку &lt;code&gt;z&lt;/code&gt; требуется хотя бы для одной ветви &lt;code&gt;cond&lt;/code&gt; , операция &lt;a href=&quot;../../math/multiply&quot;&gt; &lt;code&gt;tf.multiply&lt;/code&gt; &lt;/a&gt; всегда выполняется безоговорочно.</target>
        </trans-unit>
        <trans-unit id="f425000aaa59c101d7ba3f9fb85256ac75c9e8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x &amp;lt; y&lt;/code&gt;, the &lt;code&gt;tf.add&lt;/code&gt; operation will be executed and &lt;code&gt;tf.square&lt;/code&gt; operation will not be executed. Since &lt;code&gt;z&lt;/code&gt; is needed for at least one branch of the &lt;code&gt;cond&lt;/code&gt;, the &lt;a href=&quot;math/multiply&quot;&gt;&lt;code&gt;tf.multiply&lt;/code&gt;&lt;/a&gt; operation is always executed, unconditionally.</source>
          <target state="translated">Если &lt;code&gt;x &amp;lt; y&lt;/code&gt; , операция &lt;code&gt;tf.add&lt;/code&gt; будет выполнена, а операция &lt;code&gt;tf.square&lt;/code&gt; не будет выполнена. Поскольку &lt;code&gt;z&lt;/code&gt; требуется хотя бы для одной ветви &lt;code&gt;cond&lt;/code&gt; , операция &lt;a href=&quot;math/multiply&quot;&gt; &lt;code&gt;tf.multiply&lt;/code&gt; &lt;/a&gt; всегда выполняется безоговорочно.</target>
        </trans-unit>
        <trans-unit id="832ed76572de81853b5503e616fb7ad5eedb4aed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x.dtype&lt;/code&gt; is anything other than non-quantized integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3892e6d88b8a24b1edde46aeb1e02d77563762" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x.dtype&lt;/code&gt; is not a non-quantized integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce40d9c537cb43d8e1af25ac354efd39d19fafdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x.shape&lt;/code&gt; is not thes same as &lt;code&gt;y.shape&lt;/code&gt;, they will be broadcast to a compatible shape. (More about broadcasting &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e96c4fa15a730ffac011c15425ea745071f028e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not equal, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; не равны, &lt;code&gt;InvalidArgumentError&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , и возникает ошибка InvalidArgumentError .</target>
        </trans-unit>
        <trans-unit id="297d1fb5c3c14a94d30b09dddf10abc41cfa8dee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not provided (both are None):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803864858079bcf1272480039ae2206a7be4c3bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are provided (both have non-None values):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4cc2647cbcb811bf2321aed25eaa8d1038324d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are provided: A &lt;code&gt;Tensor&lt;/code&gt; with the same type as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and shape that is broadcast from &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt;. Otherwise, a &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;(num_true, dim_size(condition))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1bd6d19f89942e84389e6c169c715ab56481a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are reals, this will return the floating-point division.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются действительными, это вернет деление с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="893814a956c9c9c06f80ca1e2c4bbfa03a3a2f47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have different dtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f69de924efbdf9b3c63012131b1b697392bf070" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;bfloat16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc734366be07fc2f625cfb460bf82e6c13b36b24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a817fbc98a27accbded2d643fd8d39a33d9ce6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;complex64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fcc9cc94e7ac80655cda5ee52d4f9df30053c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7911ea01a9bc4c0cafc5a4bdae2a3e4331c165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931fbc164fb944daabf612ed523b88a84ada8883" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa4ab5f92b95479e59a006482757e4c9953c52a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95975368b7f95512f0de618f68dbee3011dd9b31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91834a574113cb46f5aae57836f11c53a2984dba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has a different rank, &lt;code&gt;message&lt;/code&gt;, as well as the shape of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; имеет другой ранг, печатается &lt;code&gt;message&lt;/code&gt; , а также форма &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;InvalidArgumentError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee4c81ef26436a2682343a27498b170ef1bb7eff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has a non-integer type, &lt;code&gt;message&lt;/code&gt;, as well as the dtype of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; имеет нецелочисленный тип, печатаются &lt;code&gt;message&lt;/code&gt; , а также dtype &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;InvalidArgumentError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91d266cfb0782577238e40aae35cafb92819efcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has a rank lower than &lt;code&gt;rank&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;, as well as the shape of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; имеет ранг ниже &lt;code&gt;rank&lt;/code&gt; , печатается &lt;code&gt;message&lt;/code&gt; , а также форма &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;InvalidArgumentError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d7c16b1c964db596a362f7e65c837d16f72864" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has shape &lt;code&gt;(s1, s2, s3)&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, the output will have shape &lt;code&gt;(s1, s2 * rep, s3)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; имеет форму &lt;code&gt;(s1, s2, s3)&lt;/code&gt; а &lt;code&gt;axis&lt;/code&gt; равна &lt;code&gt;1&lt;/code&gt; , результат будет иметь форму &lt;code&gt;(s1, s2 * rep, s3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="462b9044715afd0ebdf56bf7fbea531186505184" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.abs(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;SparseTensor&lt;/code&gt; , возвращает &lt;code&gt;SparseTensor(x.indices, tf.math.abs(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c4aba8143c54e7a6d9e46a577473bf33d777660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i0e(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;SparseTensor&lt;/code&gt; , возвращает &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i0e(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c627df3998e3060d22ab74298fa9d1cd985e9495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i1e(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;SparseTensor&lt;/code&gt; , возвращает &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i1e(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44f9cddabc7760ae0a95bb7dd6468e150137da94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.erf(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;SparseTensor&lt;/code&gt; , возвращает &lt;code&gt;SparseTensor(x.indices, tf.math.erf(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c5e7efe72880d19e7af394d00d8433be450c92d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.negative(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;SparseTensor&lt;/code&gt; , возвращает &lt;code&gt;SparseTensor(x.indices, tf.math.negative(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e07936dab82ee4885e6d659527e4c5ac457c891" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.sign(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;SparseTensor&lt;/code&gt; , возвращает &lt;code&gt;SparseTensor(x.indices, tf.math.sign(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42088fc82e406aa5224d738cba01bdcc601c6795" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.sqrt(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;SparseTensor&lt;/code&gt; , возвращает &lt;code&gt;SparseTensor(x.indices, tf.math.sqrt(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0e3946f9af72ad0a07071e4e7717e70504b6aaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.square(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;SparseTensor&lt;/code&gt; , возвращает &lt;code&gt;SparseTensor(x.indices, tf.math.square(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40ba052d0ea61514a5070671f03e1e45a14734d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.tanh(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;SparseTensor&lt;/code&gt; , возвращает &lt;code&gt;SparseTensor(x.indices, tf.math.tanh(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37f745c2ffe497f380fc665cd9e1671ab1f2a720" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a tensor and &lt;code&gt;coeffs&lt;/code&gt; is a list n + 1 tensors, this function returns the value of the n-th order polynomial</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - тензор, а &lt;code&gt;coeffs&lt;/code&gt; - список тензоров n + 1, эта функция возвращает значение полинома n-го порядка.</target>
        </trans-unit>
        <trans-unit id="e00f3ba3841dfdaf669fce32a84357b364f2fa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is complex, setting conjugate=True gives the conjugate transpose:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e057f1302f585f5922f3c3a18b760dc9042871" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not &amp;gt;= 0 everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не везде&amp;gt; = 0, печатаются &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;InvalidArgumentError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9d353171456976e630d0a86d03f725176648c08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not &amp;lt;= 0 everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не везде &amp;lt;= 0, печатаются &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;InvalidArgumentError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01d56b08bff3bee26005503ba42cfa3d1076bb9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not a numeric tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80fa1fece372f13db8582203c7da75b28f136c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not greater or equal to &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не больше или не равно &lt;code&gt;y&lt;/code&gt; по элементам , &lt;code&gt;InvalidArgumentError&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , и возникает ошибка InvalidArgumentError .</target>
        </trans-unit>
        <trans-unit id="8945369b8f94d01838a340d55daf17a3d1d0af50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not greater than &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не больше &lt;code&gt;y&lt;/code&gt; поэлементно , &lt;code&gt;InvalidArgumentError&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , и возникает ошибка InvalidArgumentError .</target>
        </trans-unit>
        <trans-unit id="73a28e0a51a5a1358482bd1d2c5d701b270800d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not less or equal than &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не меньше или равно &lt;code&gt;y&lt;/code&gt; поэлементно , &lt;code&gt;InvalidArgumentError&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , и возникает ошибка InvalidArgumentError .</target>
        </trans-unit>
        <trans-unit id="50217a1adc5af624b2db0c79520eab9a84830ef9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not less than &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не меньше &lt;code&gt;y&lt;/code&gt; поэлементно , &lt;code&gt;InvalidArgumentError&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , и возникает ошибка InvalidArgumentError .</target>
        </trans-unit>
        <trans-unit id="d6794554e1188cfc1e4c17fab928f93b523433cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not negative everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не везде отрицательный , &lt;code&gt;InvalidArgumentError&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; , и возникает InvalidArgumentError .</target>
        </trans-unit>
        <trans-unit id="68a88deab70057f102ed7d4f57ffb05621b00f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not positive everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не везде положителен , &lt;code&gt;InvalidArgumentError&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; , и возникает ошибка InvalidArgumentError .</target>
        </trans-unit>
        <trans-unit id="05ca699d60153153cfb210e0569b848d0973f500" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is real, it is returned unchanged.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; реально, он возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="a945f29840dadf91f914c8be913e68d58d4600b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is complex, the Jacobian will still be real but the corresponding Jacobian dimension(s) will be twice as large. This is required even if both input and output is complex since TensorFlow graphs are not necessarily holomorphic, and may have gradients not expressible as complex numbers. For example, if &lt;code&gt;x&lt;/code&gt; is complex with shape &lt;code&gt;[m]&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is complex with shape &lt;code&gt;[n]&lt;/code&gt;, each Jacobian &lt;code&gt;J&lt;/code&gt; will have shape &lt;code&gt;[m * 2, n * 2]&lt;/code&gt; with</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; комплексные, якобиан по-прежнему будет действительным, но соответствующая размерность (я) якобиана будет вдвое больше. Это требуется, даже если и ввод, и вывод являются сложными, поскольку графы TensorFlow не обязательно голоморфны и могут иметь градиенты, которые нельзя выразить как комплексные числа. Например, если &lt;code&gt;x&lt;/code&gt; сложен с формой &lt;code&gt;[m]&lt;/code&gt; , а &lt;code&gt;y&lt;/code&gt; сложен с формой &lt;code&gt;[n]&lt;/code&gt; , каждый якобиан &lt;code&gt;J&lt;/code&gt; будет иметь форму &lt;code&gt;[m * 2, n * 2]&lt;/code&gt; с</target>
        </trans-unit>
        <trans-unit id="b72659759aef98d470e47569f98300becf74fe6a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;param&lt;/code&gt; or &lt;code&gt;scalar&lt;/code&gt; does not have a shape that satisfies all specified constraints, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of the first encountered violating tensor are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;param&lt;/code&gt; или &lt;code&gt;scalar&lt;/code&gt; не имеют формы, которая удовлетворяет всем указанным ограничениям, печатаются &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи первого обнаруженного нарушающего тензора, и &lt;code&gt;InvalidArgumentError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb4201e11c9c9b78cc34cdf99933fa6d07a53697" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is negative, or greater than or equal to than the width of &lt;code&gt;x&lt;/code&gt; in bits the result is implementation defined.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; отрицательно или больше или равно ширине &lt;code&gt;x&lt;/code&gt; в битах, результат определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="01d4e2631b92dda8971f5f7cd4af31e88891e1af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is negative, or greater than or equal to the width of &lt;code&gt;x&lt;/code&gt; in bits the result is implementation defined.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; отрицательно или больше или равно ширине &lt;code&gt;x&lt;/code&gt; в битах, результат определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="30b7dec1cb97dae047ef8c7594503313f7bd0667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y_true&lt;/code&gt; cannot be cast to the &lt;code&gt;y_pred.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630404ed0aa98c724f5f45b2443214bdd9885f07" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;all&lt;/em&gt; underlying ClusterSpecs expose the set of workers as lists, we will concatenate the lists of workers, starting with the list of workers from the first ClusterResolver passed into the constructor.</source>
          <target state="translated">Если &lt;em&gt;все&lt;/em&gt; базовые спецификации ClusterSpec предоставляют набор рабочих процессов в виде списков, мы объединим списки рабочих процессов, начиная со списка рабочих процессов из первого ClusterResolver, переданного в конструктор.</target>
        </trans-unit>
        <trans-unit id="271b382563c95b776c249c61da000dbb2aa88697" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any&lt;/em&gt; of the ClusterSpecs expose the set of workers as a dict, we will treat all the sets of workers as dicts (even if they are returned as lists) and will only merge them into a dict if there is no conflicting keys. If there is a conflicting key, we will raise a &lt;code&gt;KeyError&lt;/code&gt;.</source>
          <target state="translated">Если &lt;em&gt;какой-либо&lt;/em&gt; из ClusterSpecs раскрывает набор рабочих процессов как dict, мы будем рассматривать все наборы рабочих процессов как dicts (даже если они возвращаются в виде списков) и объединим их в dict, только если нет конфликтующих ключей. Если есть конфликтующий ключ, мы &lt;code&gt;KeyError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbce25fbc64a35da3d529cbda0471472ace6aaab" translate="yes" xml:space="preserve">
          <source>If False, all variables will be regular Variables. If True, experimental ResourceVariables with well-defined semantics will be used instead. Defaults to False (will later change to True). When eager execution is enabled this argument is always forced to be True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e276bd2d482be3a780920df708c8f5a926a98964" translate="yes" xml:space="preserve">
          <source>If False, allows the variable to be initialized with a value of unknown shape. If True, the default, the shape of initial_value must be known. For this to be used the initializer must be a Tensor and not an initializer object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e22caea5a7edd671d9649e9073545eec0be196" translate="yes" xml:space="preserve">
          <source>If False, creates a regular Variable. If true, creates an experimental ResourceVariable instead with well-defined semantics. Defaults to False (will later change to True). When eager execution is enabled this argument is always forced to be True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04652b076209c80110035f6f97fb9f7b67a0e75d" translate="yes" xml:space="preserve">
          <source>If False, evaluation runs on CPU or GPU. In this case, the model_fn must return &lt;code&gt;EstimatorSpec&lt;/code&gt; when called with &lt;code&gt;mode&lt;/code&gt; as &lt;code&gt;EVAL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e086138a94bde8908ba51196ac86730005707798" translate="yes" xml:space="preserve">
          <source>If False, will not initialize the TPU embedding engine. If this is set to False and another instance of this class has not initialized the tpu embedding engine, the creation of this object will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9477cf4113441b48552d8e491777b39b333163eb" translate="yes" xml:space="preserve">
          <source>If JIT compilation is enabled.</source>
          <target state="translated">Если включена компиляция JIT.</target>
        </trans-unit>
        <trans-unit id="e0e5b865ff2f6414405c0b49034de9bd0d05490c" translate="yes" xml:space="preserve">
          <source>If TensorFlow 2 behavior has been disabled with &lt;a href=&quot;../../../compat/v1/disable_v2_behavior&quot;&gt;&lt;code&gt;tf.compat.v1.disable_v2_behavior()&lt;/code&gt;&lt;/a&gt;, this will instead return a special &quot;_infer&quot; policy which infers the dtype from the dtype of the first input the first time the layer is called. This behavior matches the behavior that existed in TensorFlow 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f404c4959ef2567bb4bc7e15658d38db76c0a4b" translate="yes" xml:space="preserve">
          <source>If True also add all the variables to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbb03e95c787ba1c8f64df66541fd60be1bfc22" translate="yes" xml:space="preserve">
          <source>If True and a cluster resolver is passed, will automatically enter the master task device scope, which indicates the master becomes the default device to run ops. It won't do anything if a cluster spec is passed. Will throw an error if the caller is currently already in some device scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da81f3101e16617f966c55c3724a76a3db849aad" translate="yes" xml:space="preserve">
          <source>If True use locks for update operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50606798e5dc09832e581473d48fd9163dfd0de2" translate="yes" xml:space="preserve">
          <source>If True use locks for update operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f18d1c4bb0479df3bb2fd4bef403529bc00af30" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;export_saved_model()&lt;/code&gt; exports a metagraph for serving on CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e46cba6288401db88fe775842baf3f9c1c8ca9" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;export_saved_model()&lt;/code&gt; exports a metagraph for serving on TPU. Note that unsupported export modes such as EVAL will be ignored. For those modes, only a CPU model will be exported. Currently, export_to_tpu only supports PREDICT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4f98c4d9f76c842e647c36ac96ebc2b65b042e" translate="yes" xml:space="preserve">
          <source>If True, BINARY, COUNT, and TFIDF modes will have their outputs padded to max_tokens, even if the number of unique tokens in the vocabulary is less than max_tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391332487ec275420b33d243c1ac17e1902deb89" translate="yes" xml:space="preserve">
          <source>If True, accepted and returned states are 2-tuples of the &lt;code&gt;c_state&lt;/code&gt; and &lt;code&gt;m_state&lt;/code&gt;. If False, they are concatenated along the column axis. The latter behavior will soon be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113a224ce2e757deca52721b8506e41e1dc90aaa" translate="yes" xml:space="preserve">
          <source>If True, accepted and returned states are 2-tuples of the &lt;code&gt;c_state&lt;/code&gt; and &lt;code&gt;m_state&lt;/code&gt;. If False, they are concatenated along the column axis. This latter behavior will soon be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a273cd953f2e6f16efd2683deb6890fa9d7c47" translate="yes" xml:space="preserve">
          <source>If True, accepted and returned states are n-tuples, where &lt;code&gt;n = len(cells)&lt;/code&gt;. If False, the states are all concatenated along the column axis. This latter behavior will soon be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0a94f25d503070a259cd5b2ceafd4021f39e98" translate="yes" xml:space="preserve">
          <source>If True, add a tuple around the gradients returned for an operations. This avoids some race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d74b57e3173462240140a06214d8da8416d87029" translate="yes" xml:space="preserve">
          <source>If True, add offset of &lt;code&gt;beta&lt;/code&gt; to normalized tensor. If False, &lt;code&gt;beta&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17ce9d21dc91dfe50d81f38bea0d0d40f40033c" translate="yes" xml:space="preserve">
          <source>If True, add offset of &lt;code&gt;beta&lt;/code&gt; to normalized tensor. If False, &lt;code&gt;beta&lt;/code&gt; is ignored. Defaults to True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0777a1250cd96104d9d7801c2393119800216b9" translate="yes" xml:space="preserve">
          <source>If True, attempt to run as many ops as possible on GPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bf5662552a40062f21a263f219715b015ae1e0" translate="yes" xml:space="preserve">
          <source>If True, create a chief supervisor in charge of initializing and restoring the model. If False, create a supervisor that relies on a chief supervisor for inits and restore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3778eb93235434d49db78d5f20f8989c18b3ad" translate="yes" xml:space="preserve">
          <source>If True, enables collection of executed graphs. It includes ones from tf.function invocation and ones from the legacy graph mode. The default is True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cf29bff8b8f38721019968f2ae60f5a20e2f70" translate="yes" xml:space="preserve">
          <source>If True, enables the advanced profiler. Enabling profiler implicitly enables the graph collection. The profiler may incur a high memory overhead. The default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5011109864df2f142f96a528ddcbf806ba9347ba" translate="yes" xml:space="preserve">
          <source>If True, equal elements in the original tensor will not be re-ordered in the returned order. Unstable sort is not yet implemented, but will eventually be the default for performance reasons. If you require a stable order, pass &lt;code&gt;stable=True&lt;/code&gt; for forwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750ecb9c072b7cf4ffc15ea96ce3af855fbca2b7" translate="yes" xml:space="preserve">
          <source>If True, gradients are normalized by the estimated variance of the gradient; if False, by the uncentered second moment. Setting this to True may help with training, but is slightly more expensive in terms of computation and memory. Defaults to False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1e2a28dcb00e4c427b5e6f9a7e2d06a8784cd1" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. Defaults to True. When the next layer is linear (also e.g. &lt;a href=&quot;../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9c004ec547a81c042012784ef627e9dddd1b00" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;../../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a76a1bcdfeeb85e09efa687176e35259e81cc6" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e283886c9fed9473765fda234d0e06956531313" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling can be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578ce0342e27bfeebf914f2f2252b95c5ffdce19" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1db80fd9a3060fcc2a7c235a1f90b8709a624c" translate="yes" xml:space="preserve">
          <source>If True, normalize the feature importances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2572de1e262e97ff64e6ca8e29487895501fe54b" translate="yes" xml:space="preserve">
          <source>If True, output has same structure as &lt;code&gt;loop_vars&lt;/code&gt;. If eager execution is enabled, this is ignored (and always treated as True).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1287bfecf53fede4f7f673c3e991544f7e20e027" translate="yes" xml:space="preserve">
          <source>If True, pin all ops to &lt;code&gt;/device:GPU:0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e192ab1f5235c570eacfb2b1b53f1c396eaad43" translate="yes" xml:space="preserve">
          <source>If True, save optimizer's state together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef179526c8ef1ce4119a23e41f41dc6bbf275cc0" translate="yes" xml:space="preserve">
          <source>If True, the TPU embedding computations will overlap with the TensorCore computations (and hence will be one step old). Set to True for improved performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12eba52a55d85913f21962c92ad731adf7bfc10e" translate="yes" xml:space="preserve">
          <source>If True, the axis indicated in &lt;code&gt;axis&lt;/code&gt; are kept with size 1. Otherwise, the dimensions in &lt;code&gt;axis&lt;/code&gt; are removed from the output shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3328c5b57ecb2ae47c200ab88a84221b9f503cf1" translate="yes" xml:space="preserve">
          <source>If True, the function is always compiled by &lt;a href=&quot;https://www.tensorflow.org/xla&quot;&gt;XLA&lt;/a&gt;. XLA may be more efficient in some cases (e.g. TPU, XLA_GPU, dense tensor computations).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311c0ba812861cff25aa3a9a763749c510b7f41b" translate="yes" xml:space="preserve">
          <source>If True, the returned numpy array is allowed to have partially evaluated values. Values that can't be evaluated will be None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7548f67ca3f064fd3f0736913e9f476ffa808ee" translate="yes" xml:space="preserve">
          <source>If True, this function will return False if node_def represents a variable-related op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84fe947ee0716714799cf00df4c8c6faaa998a2" translate="yes" xml:space="preserve">
          <source>If True, this op will output 1 instead of the number of times a token appears (equivalent to one_hot + reduce_any instead of one_hot + reduce_add). Defaults to False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30683a16709876cdbcd01a89ffad431f68ee9878" translate="yes" xml:space="preserve">
          <source>If True, try colocating gradients with the corresponding op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e39587c26c87189210d23066cfee0e73fa2a42e" translate="yes" xml:space="preserve">
          <source>If _ensure_non_none_value is True, then return value is not None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e656fc2aac4582c753c4ae45093be443f6a61f" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; is used to compute gradients instead of &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt;&lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt;&lt;/a&gt;, the loss and gradients must be scaled manually. This can be done by calling &lt;a href=&quot;lossscaleoptimizer#get_scaled_loss&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_scaled_loss&lt;/code&gt;&lt;/a&gt; before passing the loss to &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;lossscaleoptimizer#get_unscaled_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_unscaled_gradients&lt;/code&gt;&lt;/a&gt; after computing the gradients with &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">Если &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; используется для вычисления градиентов вместо &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt; &lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt; &lt;/a&gt; , потери и градиенты необходимо масштабировать вручную. Это можно сделать, вызвав &lt;a href=&quot;lossscaleoptimizer#get_scaled_loss&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_scaled_loss&lt;/code&gt; &lt;/a&gt; перед передачей потерь в &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;lossscaleoptimizer#get_unscaled_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_unscaled_gradients&lt;/code&gt; &lt;/a&gt; после вычисления градиентов с помощью &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="c62a01cf3e585d852286d2db8a969d75001530e3" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;compat/v1/session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; is used, an &lt;code&gt;Operation&lt;/code&gt; of a &lt;a href=&quot;graph&quot;&gt;&lt;code&gt;tf.Graph&lt;/code&gt;&lt;/a&gt; can be executed by passing it to &lt;code&gt;tf.Session.run&lt;/code&gt;. &lt;code&gt;op.run()&lt;/code&gt; is a shortcut for calling &lt;code&gt;tf.compat.v1.get_default_session().run(op)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;a href=&quot;compat/v1/session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; будет использован, то &lt;code&gt;Operation&lt;/code&gt; из &lt;a href=&quot;graph&quot;&gt; &lt;code&gt;tf.Graph&lt;/code&gt; &lt;/a&gt; может быть выполнена путем передачи его к &lt;code&gt;tf.Session.run&lt;/code&gt; . &lt;code&gt;op.run()&lt;/code&gt; - это ярлык для вызова &lt;code&gt;tf.compat.v1.get_default_session().run(op)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="865785682fb36eb7c051375ddba9ba312f45e409" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CheckpointManager&lt;/code&gt; was previously used in &lt;code&gt;directory&lt;/code&gt;, its state will be restored. This includes the list of managed checkpoints and the timestamp bookkeeping necessary to support &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;. The behavior of the new &lt;code&gt;CheckpointManager&lt;/code&gt; will be the same as the previous &lt;code&gt;CheckpointManager&lt;/code&gt;, including cleaning up existing checkpoints if appropriate.</source>
          <target state="translated">Если &lt;code&gt;CheckpointManager&lt;/code&gt; ранее использовался в &lt;code&gt;directory&lt;/code&gt; , его состояние будет восстановлено. Это включает список управляемых контрольных точек и учет временных меток, необходимых для поддержки &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; . Поведение нового &lt;code&gt;CheckpointManager&lt;/code&gt; будет таким же, как и у предыдущего &lt;code&gt;CheckpointManager&lt;/code&gt; , включая очистку существующих контрольных точек, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="5e64e8f1b8de75ff0a5ee5be594f66e107865c9e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DeviceSpec&lt;/code&gt; is partially specified, it will be merged with other &lt;code&gt;DeviceSpec&lt;/code&gt;s according to the scope in which it is defined. &lt;code&gt;DeviceSpec&lt;/code&gt; components defined in inner scopes take precedence over those defined in outer scopes.</source>
          <target state="translated">Если &lt;code&gt;DeviceSpec&lt;/code&gt; задан частично, он будет объединен с другими &lt;code&gt;DeviceSpec&lt;/code&gt; в соответствии с областью, в которой он определен. Компоненты &lt;code&gt;DeviceSpec&lt;/code&gt; , определенные во внутренних областях, имеют приоритет над компонентами, определенными во внешних областях.</target>
        </trans-unit>
        <trans-unit id="d433cac1256b5f0c29a6caba9953c430b9d228df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;file_pattern&lt;/code&gt; matches several files, &lt;code&gt;preferred_shard&lt;/code&gt; can be used to hint in which file the requested tensor is likely to be found. This op will first open the file at index &lt;code&gt;preferred_shard&lt;/code&gt; in the list of matching files and try to restore tensors from that file. Only if some tensors or tensor slices are not found in that first file, then the Op opens all the files. Setting &lt;code&gt;preferred_shard&lt;/code&gt; to match the value passed as the &lt;code&gt;shard&lt;/code&gt; input of a matching &lt;code&gt;Save&lt;/code&gt; Op may speed up Restore. This attribute only affects performance, not correctness. The default value -1 means files are processed in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14ed379de0c6fb8eb346774c644654872622bf9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;timeout_fn&lt;/code&gt; was specified, that function is called and if it returns a true boolean value the iterator stops yielding.</source>
          <target state="translated">Если был указан &lt;code&gt;timeout_fn&lt;/code&gt; , эта функция вызывается, и если она возвращает истинное логическое значение, итератор перестает давать результаты.</target>
        </trans-unit>
        <trans-unit id="0d849b7664051e2a1b340cdeff76439f664435a0" translate="yes" xml:space="preserve">
          <source>If a TypeSpec cannot be built for &lt;code&gt;value&lt;/code&gt;, because its type is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8164a55457820e6cea959683381dc10013ab7da4" translate="yes" xml:space="preserve">
          <source>If a component has an unknown rank, and the &lt;code&gt;padded_shapes&lt;/code&gt; argument is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec58a27134b5cd408fe0ba957abfdf776222edc" translate="yes" xml:space="preserve">
          <source>If a custom &lt;code&gt;window_fn&lt;/code&gt; is used with &lt;a href=&quot;stft&quot;&gt;&lt;code&gt;tf.signal.stft&lt;/code&gt;&lt;/a&gt;, it must be passed to &lt;a href=&quot;inverse_stft_window_fn&quot;&gt;&lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Если пользовательский &lt;code&gt;window_fn&lt;/code&gt; используется с &lt;a href=&quot;stft&quot;&gt; &lt;code&gt;tf.signal.stft&lt;/code&gt; &lt;/a&gt; , он должен быть передан &lt;a href=&quot;inverse_stft_window_fn&quot;&gt; &lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="04707a712ceddb742b3bc71b93c045408830d3e4" translate="yes" xml:space="preserve">
          <source>If a default TensorFlow session is available, we will return it.</source>
          <target state="translated">Если доступна сессия TensorFlow по умолчанию,мы вернем ее.</target>
        </trans-unit>
        <trans-unit id="213ed962ed066bee6b7b5cbd37c8e4427241d34e" translate="yes" xml:space="preserve">
          <source>If a dimension should not be cropped, pass the full size of that dimension. For example, RGB images can be cropped with &lt;code&gt;size = [crop_height, crop_width, 3]&lt;/code&gt;.</source>
          <target state="translated">Если размер не нужно обрезать, передайте полный размер этого размера. Например, изображения RGB могут быть обрезаны с &lt;code&gt;size = [crop_height, crop_width, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc9ba83547b410d42bf62831041b3d3149565986" translate="yes" xml:space="preserve">
          <source>If a function is passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ff9a74ff30c04f2722c0fc8f7a3a5f1b3d917a" translate="yes" xml:space="preserve">
          <source>If a gradient of &lt;code&gt;None&lt;/code&gt; is passed in any position of the nested structure, then an gradient update with a zero gradient is applied for that feature. For optimizers like SGD or Adagrad, this is the same as applying no update at all. For lazy Adam and other sparsely applied optimizers with decay, ensure you understand the effect of applying a zero gradient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35ca212a0c42d1f0472871e7f4f8866f1ab08bf" translate="yes" xml:space="preserve">
          <source>If a key is not found in the barrier, this operation will create a new incomplete element. If a key is found in the barrier, and the element already has a value at component_index, this operation will fail with INVALID_ARGUMENT, and leave the barrier in an undefined state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505d4a9c3cd6d1154b285ae8ef2d9c20d907de11" translate="yes" xml:space="preserve">
          <source>If a key is not present in the table, it is silently ignored.</source>
          <target state="translated">Если клавиша отсутствует в таблице,она беззвучно игнорируется.</target>
        </trans-unit>
        <trans-unit id="21703450259fbf9667e7b00b4bfd861d99657501" translate="yes" xml:space="preserve">
          <source>If a layer's compute and variable dtypes differ, &lt;code&gt;add_weight&lt;/code&gt; will wrap floating-point variables with a special wrapper called an &lt;code&gt;AutoCastVariable&lt;/code&gt;. This wrapper is identical to the original variable except it casts itself to the layer's compute dtype when used within &lt;a href=&quot;../../layers/layer#call&quot;&gt;&lt;code&gt;Layer.call&lt;/code&gt;&lt;/a&gt;. Outside &lt;a href=&quot;../../layers/layer#call&quot;&gt;&lt;code&gt;Layer.call&lt;/code&gt;&lt;/a&gt;, the variable is not casted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8f77e769af992f7a98efcdf6867f7871af8dee" translate="yes" xml:space="preserve">
          <source>If a matrix is not invertible there is no guarantee what the op does. It may detect the condition and raise an exception or it may simply return a garbage result.</source>
          <target state="translated">Если матрица не является инвертируемой,то нет никакой гарантии,что операция сделает.Она может обнаружить состояние и поднять исключение или просто вернуть мусорный результат.</target>
        </trans-unit>
        <trans-unit id="90d360255fc2e1f2162c5178513396009fd20bac" translate="yes" xml:space="preserve">
          <source>If a negative number is large, its sigmoid will approach to 0 since the formula will be &lt;code&gt;y = 1 / (1 + &amp;lt;large_num&amp;gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c949e4db2e61ac473a1157a4b3514a3881108e88" translate="yes" xml:space="preserve">
          <source>If a non-&lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; non-&lt;code&gt;None&lt;/code&gt; gradient is passed in, or a &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; of the incorrect shape is passed in. Also if the size of any sequence in &lt;code&gt;gradients&lt;/code&gt; does not match corresponding sequence in &lt;code&gt;feature_config&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9178c569fd77ec0b3d985f9eb129b9d6a07af9f" translate="yes" xml:space="preserve">
          <source>If a non-TPU name is used when constructing a TPUClusterResolver, that will be returned instead (e.g. If the tpus argument's value when constructing this TPUClusterResolver was 'grpc://10.240.1.2:8470', 'grpc://10.240.1.2:8470' will be returned).</source>
          <target state="translated">Если при построении TPUClusterResolver используется имя,отличное от TPU,то оно будет возвращено (например,если значение аргумента tpus при построении этого TPUClusterResolver было 'grpc://10.240.1.2:8470',то будет возвращено 'grpc://10.240.1.2:8470').</target>
        </trans-unit>
        <trans-unit id="d8aa2a02a92b82ba7a81289463203b5673fab674" translate="yes" xml:space="preserve">
          <source>If a particular element is zero, the reciprocal for that element is also set to zero.</source>
          <target state="translated">Если определенный элемент равен нулю,то обратная величина для этого элемента также устанавливается равной нулю.</target>
        </trans-unit>
        <trans-unit id="d73c24b67d544bb4ac9de98fe14e9ccd643c7a4d" translate="yes" xml:space="preserve">
          <source>If a partitioner is provided, a &lt;code&gt;PartitionedVariable&lt;/code&gt; is returned. Accessing this object as a &lt;code&gt;Tensor&lt;/code&gt; returns the shards concatenated along the partition axis.</source>
          <target state="translated">Если предоставляется &lt;code&gt;PartitionedVariable&lt;/code&gt; , возвращается PartitionedVariable . Доступ к этому объекту как к &lt;code&gt;Tensor&lt;/code&gt; возвращает сегменты, сцепленные вдоль оси раздела.</target>
        </trans-unit>
        <trans-unit id="893ecf49aee9a3ba330d87aa2fef55d4be74ece6" translate="yes" xml:space="preserve">
          <source>If a positive number is large, then its sigmoid will approach to 1 since the formula will be &lt;code&gt;y = &amp;lt;large_num&amp;gt; / (1 + &amp;lt;large_num&amp;gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347be984824f2221b441d6cd30c6293ef1ba4e6f" translate="yes" xml:space="preserve">
          <source>If a registered conversion function returns an invalid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead5b4e0e57f258ec5dc0e4180801aec2a6848cc" translate="yes" xml:space="preserve">
          <source>If a slice range is negative size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2123a41f061b2e74cae724869e7d376295c37aa5" translate="yes" xml:space="preserve">
          <source>If a task_type and task_id is given, this will override the &lt;code&gt;master&lt;/code&gt; string passed into the initialization function.</source>
          <target state="translated">Если заданы task_type и task_id, это переопределит &lt;code&gt;master&lt;/code&gt; строку, переданную в функцию инициализации.</target>
        </trans-unit>
        <trans-unit id="523e96cfbd593dd2c3baf3ac9053a63ba05d9124" translate="yes" xml:space="preserve">
          <source>If a tensor is produced by an operation of type &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;, its shape may be inferred if there is a registered shape function for &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;. See &lt;a href=&quot;https://tensorflow.org/extend/adding_an_op#shape_functions_in_c&quot;&gt;Shape functions&lt;/a&gt; for details of shape functions and how to register them. Alternatively, the shape may be set explicitly using &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если тензор создается операцией типа &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , его форма может быть выведена, если существует зарегистрированная функция формы для &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; . Подробную информацию о функциях фигур и их регистрации см. В разделе &lt;a href=&quot;https://tensorflow.org/extend/adding_an_op#shape_functions_in_c&quot;&gt;Функции фигур&lt;/a&gt; . В качестве альтернативы форма может быть задана явно с помощью &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="243834e6c2d91813583c07dbf83d5550f40b05d8" translate="yes" xml:space="preserve">
          <source>If a variable has a moving average, use the moving average variable name as the restore name; otherwise, use the variable name.</source>
          <target state="translated">Если переменная имеет скользящее среднее,используйте имя переменной скользящего среднего в качестве имени для восстановления;в противном случае используйте имя переменной.</target>
        </trans-unit>
        <trans-unit id="f642e4be5d733e10310c09fcad00792974d1e540" translate="yes" xml:space="preserve">
          <source>If all of these are true, then 2 properties are enforced by the template:</source>
          <target state="translated">Если все это правда,то шаблон настраивает 2 свойства:</target>
        </trans-unit>
        <trans-unit id="b47c01f63765154c2063ab037b98cdf2e6643b0d" translate="yes" xml:space="preserve">
          <source>If all operators do not have the same &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2a2942673f420e3b9df9018ebc3c57937a2a61" translate="yes" xml:space="preserve">
          <source>If all replicas do not have equal numbers of input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c6117c645e2d99da3c1e80d1e84fe0fe64cc20" translate="yes" xml:space="preserve">
          <source>If amsgrad = False: Initialization:</source>
          <target state="translated">Если амсград=Ложь:Инициализация:</target>
        </trans-unit>
        <trans-unit id="9b404c2a8925caf71a7bb356a68b571d47740e1b" translate="yes" xml:space="preserve">
          <source>If amsgrad = True: Initialization:</source>
          <target state="translated">Если амсград=Верно:Инициализация:</target>
        </trans-unit>
        <trans-unit id="5cf3f3e1c44e12d92c5b7fbf8235942d050af3de" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; object is created and the &lt;code&gt;apply()&lt;/code&gt; method is called on a list of variables, these variables will be added to the &lt;code&gt;GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/code&gt; collection. This convenience function returns the contents of that collection.</source>
          <target state="translated">Если создается объект &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; и вызывается метод &lt;code&gt;apply()&lt;/code&gt; для списка переменных, эти переменные будут добавлены в коллекцию &lt;code&gt;GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/code&gt; . Эта вспомогательная функция возвращает содержимое этой коллекции.</target>
        </trans-unit>
        <trans-unit id="0573b0aef7d01f68ba24860a81d945b1c44866a3" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;initializer&lt;/code&gt; is provided, then the output of &lt;code&gt;fn&lt;/code&gt; must have the same structure as &lt;code&gt;initializer&lt;/code&gt;; and the first argument of &lt;code&gt;fn&lt;/code&gt; must match this structure.</source>
          <target state="translated">Если &lt;code&gt;initializer&lt;/code&gt; предоставляется, то вывод &lt;code&gt;fn&lt;/code&gt; должен иметь ту же структуру, что и &lt;code&gt;initializer&lt;/code&gt; ; и первый аргумент &lt;code&gt;fn&lt;/code&gt; должен соответствовать этой структуре.</target>
        </trans-unit>
        <trans-unit id="7fdb898be79288ab3685a0b600db22aa721876bf" translate="yes" xml:space="preserve">
          <source>If an empty TPU name is specified and this is running in a Google Cloud environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f4864ad2daae673720e2d27a04ea8d707ae17bf" translate="yes" xml:space="preserve">
          <source>If an exception has been passed to &lt;code&gt;request_stop&lt;/code&gt;, this raises it.</source>
          <target state="translated">Если в &lt;code&gt;request_stop&lt;/code&gt; было передано исключение , это вызывает его.</target>
        </trans-unit>
        <trans-unit id="dee0a66565fe36d81b4afeadf3a4154301be5114" translate="yes" xml:space="preserve">
          <source>If an input element is a &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; or any other type, then it is batched as normal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5361ff44853948b5da97bedf499f8fcd750746" translate="yes" xml:space="preserve">
          <source>If an input element is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; whose static &lt;a href=&quot;../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; contains one or more axes with unknown size (i.e., &lt;code&gt;shape[i]=None&lt;/code&gt;), then the output will contain a &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; that is ragged up to any of such dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ecf5202d359cddeca2f06d60fe52705eafbb971" translate="yes" xml:space="preserve">
          <source>If an input element is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; whose static &lt;a href=&quot;../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; is fully defined, then it is batched as normal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f250f8ea55b97372b4bf0fcda3313dba275f0b" translate="yes" xml:space="preserve">
          <source>If an input feature is of numeric type, you can use &lt;code&gt;categorical_column_with_identity&lt;/code&gt;, or &lt;code&gt;bucketized_column&lt;/code&gt;, as in the example:</source>
          <target state="translated">Если функция ввода имеет числовой тип, вы можете использовать &lt;code&gt;categorical_column_with_identity&lt;/code&gt; или &lt;code&gt;bucketized_column&lt;/code&gt; , как в примере:</target>
        </trans-unit>
        <trans-unit id="5b4df35e958a9276d82646b052362b7eee1aacc9" translate="yes" xml:space="preserve">
          <source>If an invalid &lt;code&gt;device_policy&lt;/code&gt; is passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4624eedb4b71470bfe8956d0d864fba18f93e56" translate="yes" xml:space="preserve">
          <source>If an invalid checkpoint_format was given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da437886a8c1d8088049789df846da293dab7ad9" translate="yes" xml:space="preserve">
          <source>If an unknown keyword argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d660c47dfcbd8f8bb7bbe04503dea8a280958f" translate="yes" xml:space="preserve">
          <source>If an unordered dictionary is used for &lt;code&gt;pred_fn_pairs&lt;/code&gt;, the order of the conditional tests is not guaranteed. However, the order is guaranteed to be deterministic, so that variables created in conditional branches are created in fixed order across runs.</source>
          <target state="translated">Если для &lt;code&gt;pred_fn_pairs&lt;/code&gt; используется неупорядоченный словарь , порядок условных тестов не гарантируется. Однако порядок гарантированно будет детерминированным, поэтому переменные, созданные в условных ветвях, создаются в фиксированном порядке при выполнении.</target>
        </trans-unit>
        <trans-unit id="61aa7f26dc9bfe59ac61dcb0d725f8942ad22bbc" translate="yes" xml:space="preserve">
          <source>If an unsupported output stream is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34e1255c75e9685892d9a437bf03466f99ad3c0" translate="yes" xml:space="preserve">
          <source>If another profiling session is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb5ae0b72f49cc4b3190b35c502746c1bde1aa5" translate="yes" xml:space="preserve">
          <source>If any argument does not have the expected shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a04c132d63131668f4d5fc00adc259012cb811" translate="yes" xml:space="preserve">
          <source>If any argument does not have the expected type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104cc4757aab1efc5d6e568cd9b973a80e1046b2" translate="yes" xml:space="preserve">
          <source>If any argument is not a subclass of &lt;code&gt;ClusterResolvers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7bb5e26ed6f3d67fb39638574da3ab5aaddabc" translate="yes" xml:space="preserve">
          <source>If any downstream layer does not support masking yet receives such an input mask, an exception will be raised.</source>
          <target state="translated">Если какой-нибудь последующий слой не поддерживает маскировку,но получает такую маску ввода,то будет поднято исключение.</target>
        </trans-unit>
        <trans-unit id="634aed1eed17dfb056b4ad2197a898ad89414116" translate="yes" xml:space="preserve">
          <source>If any elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are equal, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если какие-либо элементы &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; равны, &lt;code&gt;InvalidArgumentError&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , и возникает ошибка InvalidArgumentError .</target>
        </trans-unit>
        <trans-unit id="e7d1ad99b5dd0129899030412bf73fb9c778531c" translate="yes" xml:space="preserve">
          <source>If any elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not close, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">Если какие-либо элементы &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; не являются близкими, &lt;code&gt;InvalidArgumentError&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; , а также первые &lt;code&gt;summarize&lt;/code&gt; записи &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , и возникает ошибка InvalidArgumentError .</target>
        </trans-unit>
        <trans-unit id="b2f25882615aa702375e83fa7b9e7593fb4f3fdf" translate="yes" xml:space="preserve">
          <source>If any input is &lt;code&gt;RaggedTensor&lt;/code&gt;, the output is &lt;code&gt;RaggedTensor&lt;/code&gt;. Else, if any input is &lt;code&gt;SparseTensor&lt;/code&gt;, the output is &lt;code&gt;SparseTensor&lt;/code&gt;. Otherwise, the output is &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201389c22590633c83c5b057c8d7d1a9efd7136f" translate="yes" xml:space="preserve">
          <source>If any input value is negative, the values are shifted so input value 0.0 is at 127. They are then rescaled so that either the smallest value is 0, or the largest one is 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b041f5bb8cb3bba32b9d99d9f1fdb9761357eb" translate="yes" xml:space="preserve">
          <source>If any member of graph_parents is &lt;code&gt;None&lt;/code&gt; or not a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd7e9a74a89a38f74d24f08a15f6aa84c314887" translate="yes" xml:space="preserve">
          <source>If any of flag name has not already been defined as a flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153ed179add7feb8b47efeb5504c4b40f4f6d107" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;SequenceDenseColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d115bf20c796ffd7a6d941e51d60620411f1bb26" translate="yes" xml:space="preserve">
          <source>If any of the arguments is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb5d0547ad1a9683e114915c25a63c2d054f87a" translate="yes" xml:space="preserve">
          <source>If any of the arguments is not of the expected type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b59ddf1a6f470800772a366cfe28702ffe98aef" translate="yes" xml:space="preserve">
          <source>If any of the arguments is not the expected type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1365eb07064dc9e5659eda64b059892f78c64922" translate="yes" xml:space="preserve">
          <source>If any of the byte counts are non-positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954800413b711cf77096d24081094c2560662f68" translate="yes" xml:space="preserve">
          <source>If any of the following is not &lt;code&gt;True&lt;/code&gt;: &lt;code&gt;{is_self_adjoint, is_non_singular, is_positive_definite}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da67b8db41666513a4a8f6b2c5ae9ca64b54a414" translate="yes" xml:space="preserve">
          <source>If any of the given &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;FeatureColumn&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246f099f519bd12e56fd8882d96401944e27101b" translate="yes" xml:space="preserve">
          <source>If any of the given &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;_FeatureColumn&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d6ef4de5d42bc2c9ae983cfc7b923fa4135bcc" translate="yes" xml:space="preserve">
          <source>If any of the input arguments is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164009727aa4b17dc13b64037a5217df8ac2bf3c" translate="yes" xml:space="preserve">
          <source>If any of the keys is &lt;code&gt;HashedCategoricalColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba75ce60ce4642b689e137daa52fd305c211ad0e" translate="yes" xml:space="preserve">
          <source>If any of the keys is neither a string nor &lt;code&gt;CategoricalColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0212db7cd6e76755e5faced8786020695bc785" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in &lt;code&gt;var_list&lt;/code&gt; are not unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae347247aa1f1565248180b4e03047133773f20" translate="yes" xml:space="preserve">
          <source>If any of the model checkpoint paths conflict with the file containing CheckpointSate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c849b28a0dd88d012bdea7f8413112695383378" translate="yes" xml:space="preserve">
          <source>If any of the pods returned by the master is not in the &lt;code&gt;Running&lt;/code&gt; phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a55c237aa2b737807fdc64d01d2bf3e0fcbec6" translate="yes" xml:space="preserve">
          <source>If any property name in &lt;code&gt;kwargs&lt;/code&gt; does not exist or is not allowed to be replaced, or both &lt;code&gt;save_checkpoints_steps&lt;/code&gt; and &lt;code&gt;save_checkpoints_secs&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306dd5fe96f1dd91f7030ff1c2b06063fea92e01" translate="yes" xml:space="preserve">
          <source>If any thread is still alive after &lt;code&gt;request_stop()&lt;/code&gt; is called and the grace period expires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95fe57fa1855b6ddf46278b8183ad2b9df4c0217" translate="yes" xml:space="preserve">
          <source>If any unsupported dtype is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18da86b931d75b280e98e54522ffc353ef05d29a" translate="yes" xml:space="preserve">
          <source>If args contains no &lt;code&gt;RaggedTensors&lt;/code&gt;, or if the &lt;code&gt;nested_splits&lt;/code&gt; of the input &lt;code&gt;RaggedTensor&lt;/code&gt;s are not identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c271fb50f50246bb17c3667097bcb19f1551e4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;shape&lt;/code&gt; requests a &lt;code&gt;SparseTensor&lt;/code&gt; with a different number of elements than &lt;code&gt;sp_input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d100e9a09233d86bf60e11ff4ca5463af5b29d" translate="yes" xml:space="preserve">
          <source>If argument validation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd4e1e21beb2600328c24eca5c8e19102684d0c" translate="yes" xml:space="preserve">
          <source>If attempting to run this model with a backend that does not support separable convolutions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10228106a0685e5f9e6380b371aad2f9a86e3ea7" translate="yes" xml:space="preserve">
          <source>If autoresolve_task is not a boolean or a callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f88c47fc9b05b10f2fcb778ad61c4f172bb0d49" translate="yes" xml:space="preserve">
          <source>If axis is not a constant scalar, or the direction is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ac540ff691a4908db4956927f427a38b150efe" translate="yes" xml:space="preserve">
          <source>If axis is specified, min_range and max_range</source>
          <target state="translated">Если указана ось,то мин_диапазон и макс_диапазон</target>
        </trans-unit>
        <trans-unit id="8b680e1777690485d0fdfbf495668b50dad1ab84" translate="yes" xml:space="preserve">
          <source>If batch length of predictions is not the same and &lt;code&gt;yield_single_examples&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d8d77b2a9b5e983e90c9ba56dc5a68dc113814" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;Tensor&lt;/code&gt;s. Use &lt;a href=&quot;../../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775f28b59c8769a12239d3417a4f08d984979d9e" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;Tensor&lt;/code&gt;s. Use &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8debb3f5cf7c56d30004043d17c49987b6983b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;lengths&lt;/code&gt; and &lt;code&gt;padding&lt;/code&gt; are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48546b5e8ae477de70d764bfd8c77f00989a5ce4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;meta_graph_def&lt;/code&gt; is not an instance of &lt;code&gt;MetaGraphDef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f91f4a4adbe074ac1d6bf586eeffdce44715c8f" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;num_parallel_batches&lt;/code&gt; and &lt;code&gt;num_parallel_calls&lt;/code&gt; are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a7c1288e03a43af5c0b5b4959caddd04931614" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;queue_runner_def&lt;/code&gt; and &lt;code&gt;queue&lt;/code&gt; are both specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c07e75ecd5ecce1ea77bb485d5ad418536da4f0" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;run_every_secs&lt;/code&gt; and &lt;code&gt;run_every_steps&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b90a4d783183b4de07e57fdd2cda84e4f3d07f0" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;save_checkpoints_steps&lt;/code&gt; and &lt;code&gt;save_checkpoints_secs&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1845445c62ee220acb45756953aeaef35c9fdb" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;shape&lt;/code&gt; and (&lt;code&gt;batch_input_shape&lt;/code&gt; or &lt;code&gt;batch_shape&lt;/code&gt;) are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e738c4c4deeba9768a8d9501a25e362ab98273" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;tensor&lt;/code&gt; are None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91cac691d81a79e3b90cd7a4ecc5bd41bc69a32" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;sparse&lt;/code&gt; and &lt;code&gt;ragged&lt;/code&gt; are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffff115e30b8d1d1e68c2e6877b5bdce943abab" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;steps&lt;/code&gt; and &lt;code&gt;max_steps&lt;/code&gt; are not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dca817d8bae391a4a501847a98642b28665de5b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;train_op_fn&lt;/code&gt; and &lt;code&gt;optimizer&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt; in TRAIN mode, or if both are set. If &lt;code&gt;mode&lt;/code&gt; is not in Estimator's &lt;code&gt;ModeKeys&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64d8facbe458ef00eeabe91ddcd150a12b58055" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;variable_def&lt;/code&gt; and initial_value are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa72f53d68fdd3e50b946d2a8a64e217e60056c2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are None, then this operation returns the coordinates of true elements of &lt;code&gt;condition&lt;/code&gt;. The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the number of true elements, and the second dimension (columns) represents the coordinates of the true elements. Keep in mind, the shape of the output tensor can vary depending on how many true values there are in input. Indices are output in row-major order.</source>
          <target state="translated">Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; равны None, то эта операция возвращает координаты истинных элементов &lt;code&gt;condition&lt;/code&gt; . Координаты возвращаются в виде двумерного тензора, где первое измерение (строки) представляет количество истинных элементов, а второе измерение (столбцы) представляет координаты истинных элементов. Имейте в виду, что форма выходного тензора может варьироваться в зависимости от того, сколько истинных значений присутствует на входе. Индексы выводятся в строчном порядке.</target>
        </trans-unit>
        <trans-unit id="4cc42a8c9ad46f8f728657a164104073727b3972" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; пусты, это тривиально выполняется.</target>
        </trans-unit>
        <trans-unit id="7eb29e91b27b7529865331e0ce47bff962ea89f5" translate="yes" xml:space="preserve">
          <source>If both arguments are sparse, we perform &quot;clipping&quot; as follows. By default, if two values sum to zero at some index, the output &lt;code&gt;SparseTensor&lt;/code&gt; would still include that particular location in its index, storing a zero in the corresponding value slot. To override this, callers can specify &lt;code&gt;thresh&lt;/code&gt;, indicating that if the sum has a magnitude strictly smaller than &lt;code&gt;thresh&lt;/code&gt;, its corresponding value and index would then not be included. In particular, &lt;code&gt;thresh == 0.0&lt;/code&gt; (default) means everything is kept and actual thresholding happens only for a positive value.</source>
          <target state="translated">Если оба аргумента являются разреженными, мы выполняем &amp;laquo;отсечение&amp;raquo; следующим образом. По умолчанию, если два значения суммируются до нуля в некотором индексе, выходной &lt;code&gt;SparseTensor&lt;/code&gt; все равно будет включать это конкретное местоположение в свой индекс, сохраняя ноль в соответствующем слоте значения. Чтобы переопределить это, вызывающие абоненты могут указать &lt;code&gt;thresh&lt;/code&gt; , указывая, что, если сумма имеет величину, строго меньшую, чем &lt;code&gt;thresh&lt;/code&gt; , ее соответствующее значение и индекс не будут включены. В частности, &lt;code&gt;thresh == 0.0&lt;/code&gt; (по умолчанию) означает, что все сохраняется, а фактическое определение порога происходит только для положительного значения.</target>
        </trans-unit>
        <trans-unit id="487e5ccf75b74d8c7372b9cbc5feed31632e6692" translate="yes" xml:space="preserve">
          <source>If both arguments are sparse, we perform &quot;clipping&quot; as follows. By default, if two values sum to zero at some index, the output &lt;code&gt;SparseTensor&lt;/code&gt; would still include that particular location in its index, storing a zero in the corresponding value slot. To override this, callers can specify &lt;code&gt;threshold&lt;/code&gt;, indicating that if the sum has a magnitude strictly smaller than &lt;code&gt;threshold&lt;/code&gt;, its corresponding value and index would then not be included. In particular, &lt;code&gt;threshold == 0.0&lt;/code&gt; (default) means everything is kept and actual thresholding happens only for a positive value.</source>
          <target state="translated">Если оба аргумента являются разреженными, мы выполняем &amp;laquo;отсечение&amp;raquo; следующим образом. По умолчанию, если два значения суммируются до нуля в некотором индексе, выходной &lt;code&gt;SparseTensor&lt;/code&gt; все равно будет включать это конкретное местоположение в свой индекс, сохраняя ноль в соответствующем слоте значения. Чтобы переопределить это, вызывающие абоненты могут указать &lt;code&gt;threshold&lt;/code&gt; , указывая, что, если сумма имеет величину, строго меньшую, чем &lt;code&gt;threshold&lt;/code&gt; , соответствующие ей значение и индекс не будут включены. В частности, &lt;code&gt;threshold == 0.0&lt;/code&gt; (по умолчанию) означает, что все сохраняется, а фактическое определение порога происходит только для положительного значения.</target>
        </trans-unit>
        <trans-unit id="2faa6168ffe9b5fd63bbf70e84a310f2b55cd9a8" translate="yes" xml:space="preserve">
          <source>If both checkpoint_dir and checkpoint_filename_with_path are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7781516620b3f8fffd28bff7dc8bb9d94e125f" translate="yes" xml:space="preserve">
          <source>If both classes and scores are set, they are interpreted as zipped, so each score corresponds to the class at the same index. Clients should not depend on the order of the entries.</source>
          <target state="translated">Если установлены оба класса и оценки,они интерпретируются как молнии,так что каждая оценка соответствует классу в том же самом индексе.Клиенты не должны зависеть от порядка следования записей.</target>
        </trans-unit>
        <trans-unit id="0d803087c359d71d2ff29aa729231f7ed5aaf6ec" translate="yes" xml:space="preserve">
          <source>If both conjugate_output and transpose_output are &lt;code&gt;true&lt;/code&gt;, returns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8cfec215c2c5f209ae8f622e020ddb585417b2" translate="yes" xml:space="preserve">
          <source>If both graph and graph_def are passed to the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f976dcd1cff06450253bab18a12e98d1d32310" translate="yes" xml:space="preserve">
          <source>If both keras_model and keras_model_path was given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88070f92b57f1d5fc2c333131e1e62338c2c40cc" translate="yes" xml:space="preserve">
          <source>If both linear_feature_columns and dnn_features_columns are empty at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8fd75dd7d2ee81283a96566ccce43e17dd69df" translate="yes" xml:space="preserve">
          <source>If both non-None, &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be broadcastable to the same shape.</source>
          <target state="translated">Если оба не-None, &lt;code&gt;condition&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; должны транслироваться в одну и ту же форму.</target>
        </trans-unit>
        <trans-unit id="97e1ce433328491ec96b5d0ae14362cbabdcecfd" translate="yes" xml:space="preserve">
          <source>If both non-None, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. The &lt;code&gt;condition&lt;/code&gt; tensor must be a scalar if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are scalar. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are tensors of higher rank, then &lt;code&gt;condition&lt;/code&gt; must be either a vector with size matching the first dimension of &lt;code&gt;x&lt;/code&gt;, or must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Если оба отличны от None, &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; должны иметь одинаковую форму. &lt;code&gt;condition&lt;/code&gt; тензор должен быть скаляром , если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются скалярными. Если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются тензорами более высокого ранга, тогда &lt;code&gt;condition&lt;/code&gt; должно быть либо вектором с размером, соответствующим первому измерению &lt;code&gt;x&lt;/code&gt; , либо должно иметь ту же форму, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88898c92dbb5ee5caa8215c3b9cf8b45aa7b86e0" translate="yes" xml:space="preserve">
          <source>If both predictions and labels are not 1-D vectors and have mismatched shapes, or if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79506ecb295374cd6b889ab3864fa6e7c7d48486" translate="yes" xml:space="preserve">
          <source>If both session and graph_def are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbf49639653cdfa17021b7bac7ebfe7fd55ca8b" translate="yes" xml:space="preserve">
          <source>If both the global and the operation seed are set: Both seeds are used in conjunction to determine the random sequence.</source>
          <target state="translated">Если установлен как общий,так и рабочий посевной материал:Оба семени используются вместе для определения случайной последовательности.</target>
        </trans-unit>
        <trans-unit id="56d176cd1c614313ea4d92304b5919bf83d47ec0" translate="yes" xml:space="preserve">
          <source>If both the graph-level and the operation seed are set: Both seeds are used in conjunction to determine the random sequence.</source>
          <target state="translated">Если настроены как графический уровень,так и рабочий посевной материал:Оба семени используются вместе для определения случайной последовательности.</target>
        </trans-unit>
        <trans-unit id="83ab65bb9cb8ad8b0b3f23c16f12a6dd295a6353" translate="yes" xml:space="preserve">
          <source>If called inside a &lt;code&gt;with strategy.scope():&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8c5f745f58975c02acd22d252d5ec6f5107427" translate="yes" xml:space="preserve">
          <source>If called on a non-persistent tape with eager execution enabled and without enabling experimental_use_pfor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd9e24f01558b732ceb8dcd58453b4958bdd228" translate="yes" xml:space="preserve">
          <source>If called when object wasn't created under a &lt;code&gt;TPUStrategy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2542f71c3cc80904a8ebcec3d207ae388a4fa9d7" translate="yes" xml:space="preserve">
          <source>If called with a non-chief Supervisor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574c82e941303e797d51c4233086b82a03679cdf" translate="yes" xml:space="preserve">
          <source>If called with eager execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f2eb2150a17d9cd67925c75d8e7cc6f7f0cadd" translate="yes" xml:space="preserve">
          <source>If called with eager execution enabled and &lt;code&gt;loss&lt;/code&gt; is not callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28345bb392e0302d6098655db8680a1e02e1c3df" translate="yes" xml:space="preserve">
          <source>If called with eager execution enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6498421806c61d63dafdda8fc836f385f363c358" translate="yes" xml:space="preserve">
          <source>If called with eager mode enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2644de4a188b77bdf5d0da83c2c6d802937ca848" translate="yes" xml:space="preserve">
          <source>If called with partitioned variable regularization and eager execution is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981bade383730db3cda301a6fb4a9c301167251d" translate="yes" xml:space="preserve">
          <source>If called with sparse = True and ragged = True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f9f6999464c58974327ddd22b42ad2da9c296b" translate="yes" xml:space="preserve">
          <source>If called with the callable and arguments omitted, will return a context object used like this::</source>
          <target state="translated">Если вызываемый объект вызывается с опущенными аргументами,то возвращается контекстный объект,используемый следующим образом::</target>
        </trans-unit>
        <trans-unit id="0093e9bdc160ff2fd3f4220aa3b82009d3743553" translate="yes" xml:space="preserve">
          <source>If called without a default &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09679b75631570067dfc643dc0450d3185c06a15" translate="yes" xml:space="preserve">
          <source>If checkpoint is True and no name was specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4f6a9857dccfef8e796c3e4e86b7476649d934" translate="yes" xml:space="preserve">
          <source>If cmd is 'scope' or 'graph', returns GraphNodeProto proto. If cmd is 'op' or 'code', returns MultiGraphNodeProto proto. Side effect: stdout/file/timeline.json depending on options['output']</source>
          <target state="translated">Если команда имеет значение 'scope' или 'graph',возвращает GraphNodeProto proto.Если команда 'op' или 'code',возвращает MultiGraphNodeProto proto.Побочный эффект:stdout/file/timeline.json в зависимости от опций['output'].</target>
        </trans-unit>
        <trans-unit id="780a855c8f95a645f3f19d73eeb415bbf7a48612" translate="yes" xml:space="preserve">
          <source>If compression_type is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172afde33c387d0bea150ccbe8dc6cc41072ff66" translate="yes" xml:space="preserve">
          <source>If conjugate is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a.dtype&lt;/code&gt; is either &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt; then the values of &lt;code&gt;a&lt;/code&gt; are conjugated and transposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee45e4b7147e79f84915e1d51de6d4a4803e7d8" translate="yes" xml:space="preserve">
          <source>If conjugate_output is &lt;code&gt;true&lt;/code&gt;, returns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fba8fa85c76e287a1fe2de2a680888f41efe3fe" translate="yes" xml:space="preserve">
          <source>If data_format ='channels_first' 4D tensor with shape: &lt;code&gt;(samples, filters, output_row, output_col)&lt;/code&gt;</source>
          <target state="translated">Если data_format = 'channels_first' 4D тензор с формой: &lt;code&gt;(samples, filters, output_row, output_col)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54b8064bacba3ba82e646ea2151170bb26cf1df6" translate="yes" xml:space="preserve">
          <source>If data_format='channels_first' 5D tensor with shape: &lt;code&gt;(samples, time, channels, rows, cols)&lt;/code&gt;</source>
          <target state="translated">Если data_format = 'channels_first' 5D тензор с формой: &lt;code&gt;(samples, time, channels, rows, cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6846cfb3158e1bd91d37169c22b71a8ea3739620" translate="yes" xml:space="preserve">
          <source>If data_format='channels_first' 5D tensor with shape: &lt;code&gt;(samples, time, filters, output_row, output_col)&lt;/code&gt;</source>
          <target state="translated">Если data_format = 'channels_first' 5D тензор с формой: &lt;code&gt;(samples, time, filters, output_row, output_col)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ac99ea61f4e7b17282390b961f6eda2ff80a416" translate="yes" xml:space="preserve">
          <source>If data_format='channels_last' 4D tensor with shape: &lt;code&gt;(samples, output_row, output_col, filters)&lt;/code&gt; where &lt;code&gt;o_row&lt;/code&gt; and &lt;code&gt;o_col&lt;/code&gt; depend on the shape of the filter and the padding</source>
          <target state="translated">Если data_format = 'channels_last' 4D тензор с формой: &lt;code&gt;(samples, output_row, output_col, filters)&lt;/code&gt; где &lt;code&gt;o_row&lt;/code&gt; и &lt;code&gt;o_col&lt;/code&gt; зависят от формы фильтра и заполнения</target>
        </trans-unit>
        <trans-unit id="75fa04bbee972fde32d36caa3e44ea33b4fe50fc" translate="yes" xml:space="preserve">
          <source>If data_format='channels_last' 5D tensor with shape: &lt;code&gt;(samples, time, output_row, output_col, filters)&lt;/code&gt;</source>
          <target state="translated">Если data_format = 'channels_last' 5D тензор с формой: &lt;code&gt;(samples, time, output_row, output_col, filters)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00479e6d45ac4e2661436ea4b5a406c2b0a2af7a" translate="yes" xml:space="preserve">
          <source>If data_format='channels_last' 5D tensor with shape: &lt;code&gt;(samples, time, rows, cols, channels)&lt;/code&gt;</source>
          <target state="translated">Если data_format = 'channels_last' 5D тензор с формой: &lt;code&gt;(samples, time, rows, cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6cc722ef0e9570f15a63451bd645878be8a8452" translate="yes" xml:space="preserve">
          <source>If delegate loading is used on unsupported platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63165fe5adeb1fdb48dac5762016f67811f8889" translate="yes" xml:space="preserve">
          <source>If delete_old_dirs is true, attempts to delete recursively the dirname of each path in the input checkpoint_prefixes. This is useful when those paths are non user-facing temporary locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160c1f322fbaf6f7ee50e6f699b208383b0194b4" translate="yes" xml:space="preserve">
          <source>If delimiter is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d715a83b67f7e7c89236f98ea91f6e13726547ae" translate="yes" xml:space="preserve">
          <source>If desired, the user can call this layer's &lt;code&gt;adapt()&lt;/code&gt; method on a data set, which will analyze the data set, determine the frequency of individual string values, and create a vocabulary from them. This vocabulary can have unlimited size or be capped, depending on the configuration options for this layer; if there are more unique values in the input than the maximum vocabulary size, the most frequent terms will be used to create the vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248964e67e0d3fce70856809b6338807ca585aa9" translate="yes" xml:space="preserve">
          <source>If desired, the user can call this layer's adapt() method on a dataset. When this layer is adapted, it will analyze the dataset, determine the frequency of individual integer or string values, and create a 'vocabulary' from them. This vocabulary can have unlimited size or be capped, depending on the configuration options for this layer; if there are more unique values in the input than the maximum vocabulary size, the most frequent terms will be used to create the vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21162df807938f113483d7bdf2b2cb1dc591185" translate="yes" xml:space="preserve">
          <source>If desired, the user can call this layer's adapt() method on a dataset. When this layer is adapted, it will analyze the dataset, determine the frequency of individual string values, and create a 'vocabulary' from them. This vocabulary can have unlimited size or be capped, depending on the configuration options for this layer; if there are more unique values in the input than the maximum vocabulary size, the most frequent terms will be used to create the vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff536a283d0c5634c5bc5433d6ad8c509ee37ad0" translate="yes" xml:space="preserve">
          <source>If desired_samples is set, then the audio will be cropped or padded with zeroes to the requested length.</source>
          <target state="translated">Если установлено значение параметра_samples,то звук будет обрезан или дополнен нулями до требуемой длины.</target>
        </trans-unit>
        <trans-unit id="64e144d6092560a27e1887bcdaf10a00b30d267c" translate="yes" xml:space="preserve">
          <source>If device placements are logged.</source>
          <target state="translated">Если размещение устройства зарегистрировано.</target>
        </trans-unit>
        <trans-unit id="697f21a90462730341e2696aa513a52a271ce192" translate="yes" xml:space="preserve">
          <source>If device scopes are not properly nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9291d64f354b112d4b4f3e8e525fef7cb19907b" translate="yes" xml:space="preserve">
          <source>If device_fn is not &lt;code&gt;None&lt;/code&gt;, it overrides the default device function used in &lt;code&gt;Estimator&lt;/code&gt;. Otherwise the default one is used.</source>
          <target state="translated">Если device_fn не равно &lt;code&gt;None&lt;/code&gt; , он отменяет функцию устройства по умолчанию, используемую в &lt;code&gt;Estimator&lt;/code&gt; . В противном случае используется значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0b94e1ea2398bda06ea8694498f1fb19cf4f6efb" translate="yes" xml:space="preserve">
          <source>If dims cannot be converted to a list of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b5d926c5ac01aa937713a473626aab510091b2" translate="yes" xml:space="preserve">
          <source>If dtype of &lt;code&gt;on_value&lt;/code&gt; and &lt;code&gt;off_value&lt;/code&gt; don't match one another</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37752ac4840b02cfca9a8f3dd25a0b640ddd01e2" translate="yes" xml:space="preserve">
          <source>If dtype of either &lt;code&gt;on_value&lt;/code&gt; or &lt;code&gt;off_value&lt;/code&gt; don't match &lt;code&gt;dtype&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80dde0979dfeaa6bd587ee11a441e44988883279" translate="yes" xml:space="preserve">
          <source>If dtype of the input is &lt;code&gt;int32&lt;/code&gt; and dtype of the &lt;code&gt;clip_value_min&lt;/code&gt; or &lt;code&gt;clip_value_max&lt;/code&gt; is &lt;code&gt;float32&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08188b171505f22eaa07320217d7cb0b3f94833f" translate="yes" xml:space="preserve">
          <source>If dtype of the input is not a floating point or complex type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9657f3ec9bff2adddd273db7e164c0f58e7fc0f8" translate="yes" xml:space="preserve">
          <source>If each &lt;code&gt;op_jj&lt;/code&gt; on the diagonal has shape &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt;, then the combined operator has shape &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt;, where &lt;code&gt;broadcast_batch_shape&lt;/code&gt; is the mutual broadcast of &lt;code&gt;batch_shape_j&lt;/code&gt;, &lt;code&gt;j = 0, 1, ..., J&lt;/code&gt;, assuming the intermediate batch shapes broadcast. Even if the combined shape is well defined, the combined operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f773f4a0b6ef385d8cc73446bd42bb5c0d9a3771" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled after creating/executing a TensorFlow graph, or if options provided conflict with a previous call to this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c1f0445f129f396fc0b13399b1bb388306a7c1" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled and a function is passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2f83ce7126d01f3c06de26aa60b7f6ac61c0aa" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled and&lt;code&gt;var_list&lt;/code&gt; does not specify a list of variables to save.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bfffa7113c3bf007ae681c0fa31393f368fdc2" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled ops created under this context manager will be added to the graph instead of executed eagerly.</source>
          <target state="translated">Если включено жадное исполнение,то вместо жадного исполнения на график будут добавляться операторы,созданные в рамках этого контекстного менеджера.</target>
        </trans-unit>
        <trans-unit id="25e2032ce88f649e7ec61962dfe0f982a0afa762" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ee55d70583c3e11eb60bef5ef2ced62457c4e9" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;hypothesis&lt;/code&gt; or &lt;code&gt;truth&lt;/code&gt; are not a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824be958493bfb410b4a85bc242595893b6d4fb4" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;steps&lt;/code&gt; or &lt;code&gt;max_steps &amp;lt;= 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47b36b34d98e0679cc6c53cff08c20a7dcfe2cb" translate="yes" xml:space="preserve">
          <source>If either argument is not a &lt;code&gt;GraphDef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b6ebdcf4ccf71906f53c9d13666a5c374b90ce" translate="yes" xml:space="preserve">
          <source>If enabled, an op will be placed on CPU if any of the following are true</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e670cc4a3f83ee25d0b6a6e5c98cd6a71ebb20d0" translate="yes" xml:space="preserve">
          <source>If enabled, an op will be placed on CPU if any of the following are true 1. there's no GPU implementation for the OP 2. no GPU devices are known or registered 3. need to co-locate with reftype input(s) which are from CPU</source>
          <target state="translated">Если опция включена,то она будет размещена на CPU,если одно из следующих значений верно 1.нет реализации GPU для OP 2.нет известных или зарегистрированных GPU-устройств 3.необходимо скомпоновать с входом(-ами)типа reftype,которые находятся на CPU</target>
        </trans-unit>
        <trans-unit id="63b0a6125d1477cb280541ff0da2e678b55452fd" translate="yes" xml:space="preserve">
          <source>If examples is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784a250668a12b694a60559c3d84175bc70e490e" translate="yes" xml:space="preserve">
          <source>If exit_without_error is true, the process will exit normally, otherwise it will exit with a SIGABORT signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb053d1301598dac02cff078c183716e72ed8191" translate="yes" xml:space="preserve">
          <source>If expand_nonconcat_dim is False, all inputs' shapes must match, except for the concat dimension. If expand_nonconcat_dim is True, then inputs' shapes are allowed to vary among all inputs.</source>
          <target state="translated">Если переменная expansion_nonconcat_dim равна False,все формы входов должны совпадать,за исключением размерности concat.Если переменная expansion_nonconcat_dim равна True,то фигуры всех входов должны совпадать.</target>
        </trans-unit>
        <trans-unit id="cae461a693ecc478ea610fcc38768106721e2c8f" translate="yes" xml:space="preserve">
          <source>If expand_nonconcat_dim is False, then the output shape is identical to the inputs', except along the concat dimension, where it is the sum of the inputs' sizes along that dimension.</source>
          <target state="translated">Если переменная expansion_nonconcat_dim-False,то выходная форма идентична входам',за исключением размерности конката,где она представляет собой сумму размеров входов по этой размерности.</target>
        </trans-unit>
        <trans-unit id="b6cd7aa57520c6214227753ed1c290366a7b241e" translate="yes" xml:space="preserve">
          <source>If expand_nonconcat_dim is True, then the output shape along the non-concat dimensions will be expand to be the largest among all inputs, and it is the sum of the inputs sizes along the concat dimension.</source>
          <target state="translated">Если переменная expansion_nonconcat_dim равна True,то выходная форма по неконкатным размерам будет расширена до наибольшей из всех входных величин и будет представлять собой сумму входных размеров по конкат размеру.</target>
        </trans-unit>
        <trans-unit id="12864773eaab4c0d7f585b96ba78a0e95386a506" translate="yes" xml:space="preserve">
          <source>If false, the output nmsed boxes, scores and classes are padded/clipped to &lt;code&gt;max_total_size&lt;/code&gt;. If true, the output nmsed boxes, scores and classes are padded to be of length &lt;code&gt;max_size_per_class&lt;/code&gt;*&lt;code&gt;num_classes&lt;/code&gt;, unless it exceeds &lt;code&gt;max_total_size&lt;/code&gt; in which case it is clipped to &lt;code&gt;max_total_size&lt;/code&gt;. Defaults to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29536533b7425b7b6f6f46b7c0caaaf741547425" translate="yes" xml:space="preserve">
          <source>If gamma is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48bc65a965bdec97a72d64adbdbd2e91ae8af762" translate="yes" xml:space="preserve">
          <source>If given, ensures the output has length at least &lt;code&gt;minlength&lt;/code&gt;, padding with zeros at the end if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850346f60197b83bee288e72b70f6de3db5f0a8d" translate="yes" xml:space="preserve">
          <source>If given, skips values in &lt;code&gt;arr&lt;/code&gt; that are equal or greater than &lt;code&gt;maxlength&lt;/code&gt;, ensuring that the output has length at most &lt;code&gt;maxlength&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1bedce8da3ba8708a050eca4c25f36172efb8c8" translate="yes" xml:space="preserve">
          <source>If given, skips values in &lt;code&gt;values&lt;/code&gt; that are equal or greater than &lt;code&gt;maxlength&lt;/code&gt;, ensuring that the output has length at most &lt;code&gt;maxlength&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904f78c9c6ff546dab3b5725280de3f83affea10" translate="yes" xml:space="preserve">
          <source>If global step is not provided, the staleness cannot be checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684b25bfd8962e05d99fb3f7f04a26800350f93f" translate="yes" xml:space="preserve">
          <source>If grad is of the wrong shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b342725a93b6c1c8e4b3915db7e2e97ff7ab962" translate="yes" xml:space="preserve">
          <source>If greater than 0 then smooth the labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f5a4e3f1411b344474e9d7a8bc5d911b5175d8" translate="yes" xml:space="preserve">
          <source>If greater than &lt;code&gt;0&lt;/code&gt; then smooth the labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ad5583d7bf74d16da967efa8cbb84ea5b0c957" translate="yes" xml:space="preserve">
          <source>If h5py is not available and the weight file is in HDF5 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ea4430736129715f7271fcff39b30fa4c0d755" translate="yes" xml:space="preserve">
          <source>If h5py is not available when attempting to save in HDF5 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f095b725e0a83d6762ff132445f344e05020f422" translate="yes" xml:space="preserve">
          <source>If hints are set incorrectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5fdf8a3fd0e485a281ac125b001fbd1f55d1ac7" translate="yes" xml:space="preserve">
          <source>If histogram_freq is set and no validation data is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6cab13cfa666ca9015cb19f120bb30a762f9b4" translate="yes" xml:space="preserve">
          <source>If initializer is &lt;code&gt;None&lt;/code&gt; (the default), the default initializer passed in the variable scope will be used. If that one is &lt;code&gt;None&lt;/code&gt; too, a &lt;code&gt;glorot_uniform_initializer&lt;/code&gt; will be used. The initializer can also be a Tensor, in which case the variable is initialized to this value and shape.</source>
          <target state="translated">Если инициализатор &lt;code&gt;None&lt;/code&gt; (по умолчанию), будет использоваться инициализатор по умолчанию, переданный в области переменной. Если это тоже &lt;code&gt;None&lt;/code&gt; , будет использоваться &lt;code&gt;glorot_uniform_initializer&lt;/code&gt; . Инициализатором также может быть тензор, и в этом случае переменная инициализируется этим значением и формой.</target>
        </trans-unit>
        <trans-unit id="10990b204b37f5fa91dbe2ef30fcaf924248b00a" translate="yes" xml:space="preserve">
          <source>If input is not a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9612495d1ea687b814d88c5bccfce311dbb1b1" translate="yes" xml:space="preserve">
          <source>If input value shapes have rank-&lt;code&gt;R&lt;/code&gt;, then the output TensorArray will contain elements whose shapes are rank-&lt;code&gt;(R-1)&lt;/code&gt;.</source>
          <target state="translated">Если формы входных значений имеют ранг- &lt;code&gt;R&lt;/code&gt; , то выходной TensorArray будет содержать элементы, формы которых имеют ранг- &lt;code&gt;(R-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45c77beb165c1701c210a5bf5acb9740e347fcd8" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filter&lt;/code&gt; shape, if padding is other than &lt;code&gt;&quot;VALID&quot;&lt;/code&gt; or &lt;code&gt;&quot;SAME&quot;&lt;/code&gt;, or if data_format is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b752dfc0612478ea8d685cf1e617bd3c1d83ebd2" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filter&lt;/code&gt;'s shape, if &lt;code&gt;output_shape&lt;/code&gt; is not at 3-element vector, if &lt;code&gt;padding&lt;/code&gt; is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;, or if &lt;code&gt;data_format&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d7f5300b03eeb800fd6998605d11f0f2eae57d" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filter&lt;/code&gt;'s shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6cae4ac7f38121f981199147df481f96e3c52a" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filters&lt;/code&gt; shape, if padding is other than &lt;code&gt;&quot;VALID&quot;&lt;/code&gt; or &lt;code&gt;&quot;SAME&quot;&lt;/code&gt;, or if data_format is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7238a8127bc3b5b9a1ee3eb0627ccf770c4ae056" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filters&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;, or if the &lt;code&gt;rate&lt;/code&gt; is less than one, or if the output_shape is not a tensor with 4 elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd231bf9fdacb69a5963dd5fc07c998be7bf172c" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filters&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bab3017e220504110ded7561dc6180055162263" translate="yes" xml:space="preserve">
          <source>If input_signature contains a non-TensorSpec object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c386ea372433836d4288cf5ce90403d9aebc9525" translate="yes" xml:space="preserve">
          <source>If input_tensor is &lt;code&gt;[&quot;emerson&quot;, &quot;lake&quot;, &quot;palmer&quot;, &quot;king&quot;, &quot;crimson&quot;]&lt;/code&gt;, the lookup result is &lt;code&gt;[0, 1, 2, 4, 7]&lt;/code&gt;.</source>
          <target state="translated">Если input_tensor - &lt;code&gt;[&quot;emerson&quot;, &quot;lake&quot;, &quot;palmer&quot;, &quot;king&quot;, &quot;crimson&quot;]&lt;/code&gt; , результат поиска будет &lt;code&gt;[0, 1, 2, 4, 7]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2ce072ba553bd0ced40a36046cee33cd2be18df" translate="yes" xml:space="preserve">
          <source>If inputs are invalid types, or if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have different types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="937342562c6c12fe45a02ebc5e107d2f78b33211" translate="yes" xml:space="preserve">
          <source>If inputs are not tensors, they will be converted to tensors. See &lt;a href=&quot;../convert_to_tensor&quot;&gt;&lt;code&gt;tf.convert_to_tensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3cb57fcb38985bdb74f964ec67623f1bd14e689" translate="yes" xml:space="preserve">
          <source>If inputs are shaped &lt;code&gt;(batch,)&lt;/code&gt; without a channel dimension, then flattening adds an extra channel dimension and output shapes are &lt;code&gt;(batch, 1)&lt;/code&gt;.</source>
          <target state="translated">Если входные данные имеют форму &lt;code&gt;(batch,)&lt;/code&gt; без размера канала, то при сведении добавляется дополнительный размер канала, а формы вывода - &lt;code&gt;(batch, 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf2f55ccc279229fe129dedb78a6ad7fa6f4a7cc" translate="yes" xml:space="preserve">
          <source>If inputs is None or an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14a37bc1250ce29bfed6cf06b06706687540d99" translate="yes" xml:space="preserve">
          <source>If inputs or outputs is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738230ba7fe766eb31fbdde5eb405514647a0533" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;operator&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; have shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; and &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt;, every operation increases in complexity by &lt;code&gt;B1*...*Bb&lt;/code&gt;.</source>
          <target state="translated">Если вместо этого &lt;code&gt;operator&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; имеют форму &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; и &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt; , сложность каждой операции увеличивается на &lt;code&gt;B1*...*Bb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f96eb77ff2ebfe9cc28cc3c35cc4a7ac58b190bc" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;operator&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; and &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt;, every operation increases in complexity by &lt;code&gt;B1*...*Bb&lt;/code&gt;.</source>
          <target state="translated">Если вместо этого &lt;code&gt;operator&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; имеют форму &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; и &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt; , сложность каждой операции увеличивается на &lt;code&gt;B1*...*Bb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c63a6d67533a63bed1e0240ed43f76ae36414b8" translate="yes" xml:space="preserve">
          <source>If instead a &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; with &lt;code&gt;default_value = -1.0&lt;/code&gt; and &lt;code&gt;shape=[]&lt;/code&gt; is used then the output will look like:</source>
          <target state="translated">Если вместо этого используется &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; с &lt;code&gt;default_value = -1.0&lt;/code&gt; и &lt;code&gt;shape=[]&lt;/code&gt; , то результат будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="40adf7e5387b8489f0ffa9f4f324e8e0ce220b98" translate="yes" xml:space="preserve">
          <source>If int: How many zeros to add at the beginning and end of the padding dimension (axis 1).</source>
          <target state="translated">Если int:Сколько нулей нужно добавить в начале и в конце размера набивки (ось 1).</target>
        </trans-unit>
        <trans-unit id="c440d21ae6487ba9289b79947d47d6f17645dab0" translate="yes" xml:space="preserve">
          <source>If int: the same symmetric cropping is applied to depth, height, and width.</source>
          <target state="translated">Если int:одинаковая симметричная обрезка применяется к глубине,высоте и ширине.</target>
        </trans-unit>
        <trans-unit id="0ad0224bfc863947c553eb515cd3685802c8418c" translate="yes" xml:space="preserve">
          <source>If int: the same symmetric cropping is applied to height and width.</source>
          <target state="translated">Если int:одинаковая симметричная обрезка применяется к высоте и ширине.</target>
        </trans-unit>
        <trans-unit id="4438a656974fdeb329935741ed684baf3991a64c" translate="yes" xml:space="preserve">
          <source>If int: the same symmetric padding is applied to height and width.</source>
          <target state="translated">Если int:одинаковая симметричная набивка применяется к высоте и ширине.</target>
        </trans-unit>
        <trans-unit id="35116c98450f720c42b3658d1258e91546d16954" translate="yes" xml:space="preserve">
          <source>If internal = False. Note that this method is intended only for internal use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15715c466e373aacdb51a0877bb847b6ca4afb0b" translate="yes" xml:space="preserve">
          <source>If it encounters an error (e.g. session is in an invalid state, or network errors occur).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e13d5017f46659d268ce30f514bf0071b12303" translate="yes" xml:space="preserve">
          <source>If it is None, all &lt;code&gt;device()&lt;/code&gt; invocations from the enclosing context will be ignored.</source>
          <target state="translated">Если это None, все вызовы &lt;code&gt;device()&lt;/code&gt; из включающего контекста будут игнорироваться.</target>
        </trans-unit>
        <trans-unit id="ef96e811e54b2027efeda53b92e404a485dc4193" translate="yes" xml:space="preserve">
          <source>If it is None, unnormalized dct4 is used, if it is &quot;ortho&quot; orthonormal dct4 is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc30b45f6aa3b5c14c0ae463c80d1818d9e01fe" translate="yes" xml:space="preserve">
          <source>If it is a device name string, all operations constructed in this context will be assigned to the device with that name, unless overridden by a nested &lt;code&gt;device()&lt;/code&gt; context.</source>
          <target state="translated">Если это строка имени устройства, все операции, созданные в этом контексте, будут назначены устройству с этим именем, если только они не будут переопределены вложенным контекстом &lt;code&gt;device()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5baf9468ce1d581b9eebf008c02586f0513f4b8" translate="yes" xml:space="preserve">
          <source>If it is a function, it will be treated as a function from Operation objects to device name strings, and invoked each time a new Operation is created. The Operation will be assigned to the device with the returned name.</source>
          <target state="translated">Если это функция,то она будет рассматриваться как функция от объектов Операции к строкам имени устройства и вызываться каждый раз при создании новой Операции.Операция будет присвоена устройству с возвращенным именем.</target>
        </trans-unit>
        <trans-unit id="029d0ac515384df1e368e1e371b6232459f15b2e" translate="yes" xml:space="preserve">
          <source>If iterator does not support checkpointing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e9423338b763ecced828cd53d616bb10a88e52" translate="yes" xml:space="preserve">
          <source>If keras_model has not been compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db73d9b90027e216149b4b949806b1ee26b98dcf" translate="yes" xml:space="preserve">
          <source>If known at graph construction time, filename used for variable loading/saving.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6771f2297bd8cb07650783afbbc78e61937b9a06" translate="yes" xml:space="preserve">
          <source>If label is used in &lt;code&gt;feature_columns&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7710d3f3b7456252ed02c1f1e66d4f4bf4c6ac" translate="yes" xml:space="preserve">
          <source>If label_key argument is provided, returns a &lt;code&gt;Dataset&lt;/code&gt; of tuple comprising of feature dictionaries and label.</source>
          <target state="translated">Если указан аргумент label_key, возвращает &lt;code&gt;Dataset&lt;/code&gt; кортежа, состоящий из словарей функций и метки.</target>
        </trans-unit>
        <trans-unit id="7de987675ff17795ab301bc41d5b2434a203cd40" translate="yes" xml:space="preserve">
          <source>If last_checkpoints is not a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13779508c02ec978c697bbe57313fdf67fe0477e" translate="yes" xml:space="preserve">
          <source>If last_checkpoints_with_time is not a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcc6e856bdd1179e8069f1fe13fd542e0500b2a" translate="yes" xml:space="preserve">
          <source>If len(input_shard_axes) != len(inputs)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb334df24c9579c81c1988b3200bbe9b7befd52" translate="yes" xml:space="preserve">
          <source>If len(output_shard_axes) != len(outputs from &lt;code&gt;computation&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc09e06652849b4243e73d3cebb00ac8c8528b69" translate="yes" xml:space="preserve">
          <source>If logits are scalars (need to have rank &amp;gt;= 1) or if the rank of the labels is not equal to the rank of the logits minus one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a9c00e10f0a30b035b3972813d0c5d1001a05f" translate="yes" xml:space="preserve">
          <source>If loss_scale_value is less than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c424513363e598474e7006a1b25045c0bfee1b11" translate="yes" xml:space="preserve">
          <source>If lower_bound or upper_bound are set, then this flag must be within the given range.</source>
          <target state="translated">Если установлен флаг lower_bound или upper_bound,то этот флаг должен находиться в заданном диапазоне.</target>
        </trans-unit>
        <trans-unit id="5c86764cba8090e4b738e2dccdd96c8da3f0010d" translate="yes" xml:space="preserve">
          <source>If lower_bound, or upper_bound are set, then this flag must be within the given range.</source>
          <target state="translated">Если установлен флаг lower_bound или upper_bound,то этот флаг должен находиться в заданном диапазоне.</target>
        </trans-unit>
        <trans-unit id="b744a1d7c3b92dd76e179f6bd1b1ff66d763286f" translate="yes" xml:space="preserve">
          <source>If memory growth is enabled for a &lt;code&gt;PhysicalDevice&lt;/code&gt;, the runtime initialization will not allocate all memory on the device.</source>
          <target state="translated">Если для &lt;code&gt;PhysicalDevice&lt;/code&gt; включен рост памяти , инициализация среды выполнения не будет выделять всю память на устройстве.</target>
        </trans-unit>
        <trans-unit id="bd3fe4729c6c6665ba5d979840f51083f4d41d85" translate="yes" xml:space="preserve">
          <source>If memory growth is enabled for a &lt;code&gt;PhysicalDevice&lt;/code&gt;, the runtime initialization will not allocate all memory on the device. Memory growth cannot be configured on a &lt;code&gt;PhysicalDevice&lt;/code&gt; with virtual devices configured.</source>
          <target state="translated">Если для &lt;code&gt;PhysicalDevice&lt;/code&gt; включен рост памяти , инициализация среды выполнения не будет выделять всю память на устройстве. Увеличение объема памяти невозможно настроить на &lt;code&gt;PhysicalDevice&lt;/code&gt; с настроенными виртуальными устройствами.</target>
        </trans-unit>
        <trans-unit id="a6d0cbfe8725ceb18dabe8bbc056a3473d718190" translate="yes" xml:space="preserve">
          <source>If missing variables in current graph, or if missing checkpoints or tensors in checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefb38872b3b0a9ef3e5c04bb1786c3ce57d227f" translate="yes" xml:space="preserve">
          <source>If more than one such registered method exists, the method whose registered classes have the shortest sum MRO paths to the input types is used.</source>
          <target state="translated">Если существует более одного такого зарегистрированного метода,то используется метод,у которого зарегистрированные классы имеют наименьшее количество MRO-путей к входным типам.</target>
        </trans-unit>
        <trans-unit id="3ae06d56729266c936751b0d6b4a49cea1d77595" translate="yes" xml:space="preserve">
          <source>If more than one such shortest path exists, the first method identified in the search is used (favoring a shorter MRO distance to &lt;code&gt;type(distribution_a)&lt;/code&gt;).</source>
          <target state="translated">Если существует более одного такого кратчайшего пути, используется первый метод, указанный в поиске (предпочтение отдается более короткому расстоянию MRO до &lt;code&gt;type(distribution_a)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="722f663586a3c2fd0a85e136dad3e99bf4d7d908" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;feature_columns&lt;/code&gt; are given with &lt;code&gt;Di&lt;/code&gt;&lt;code&gt;num_elements&lt;/code&gt; each, their outputs are concatenated. So, the final &lt;code&gt;Tensor&lt;/code&gt; has shape &lt;code&gt;[batch_size, T, D0 + D1 + ... + Dn]&lt;/code&gt;.</source>
          <target state="translated">Если несколько &lt;code&gt;feature_columns&lt;/code&gt; заданы с &lt;code&gt;Di&lt;/code&gt; &lt;code&gt;num_elements&lt;/code&gt; каждый, их выходные данные объединяются. Итак, окончательный &lt;code&gt;Tensor&lt;/code&gt; имеет форму &lt;code&gt;[batch_size, T, D0 + D1 + ... + Dn]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03c107a7651f56240affd9bf4b6bd3d81744ad9c" translate="yes" xml:space="preserve">
          <source>If multiple workers or threads all execute &lt;code&gt;count&lt;/code&gt; in parallel, there is no guarantee that access to the variable &lt;code&gt;v&lt;/code&gt; is atomic at any point within any thread's calculation of &lt;code&gt;count&lt;/code&gt;. In fact, even implementing an atomic counter that guarantees that the user will see each value &lt;code&gt;0, 1, ...,&lt;/code&gt; is currently impossible.</source>
          <target state="translated">Если несколько рабочих процессов или потоков выполняют &lt;code&gt;count&lt;/code&gt; параллельно, нет гарантии, что доступ к переменной &lt;code&gt;v&lt;/code&gt; является атомарным в любой точке в рамках любого потока вычисления &lt;code&gt;count&lt;/code&gt; . Фактически, даже реализация атомарного счетчика, который гарантирует, что пользователь увидит каждое значение &lt;code&gt;0, 1, ...,&lt;/code&gt; в настоящее время невозможно.</target>
        </trans-unit>
        <trans-unit id="9739a5fb4739612d4146a5dc1689746a7ba63d4e" translate="yes" xml:space="preserve">
          <source>If name is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef6af9a98489f657ca168be41baf35e4d8bb8b1" translate="yes" xml:space="preserve">
          <source>If name is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67481c8ed92bcb02951bb04ea04056c1ee8ecbc1" translate="yes" xml:space="preserve">
          <source>If needed, the JPEG-encoded image is transformed to match the requested number of color channels.</source>
          <target state="translated">При необходимости изображение с JPEG-кодировкой трансформируется в соответствии с запрошенным количеством цветовых каналов.</target>
        </trans-unit>
        <trans-unit id="675d725df0fc2c1253c204b76da4504e0b572994" translate="yes" xml:space="preserve">
          <source>If needed, the PNG-encoded image is transformed to match the requested number of color channels.</source>
          <target state="translated">При необходимости изображение в PNG-кодировке трансформируется в соответствии с требуемым количеством цветовых каналов.</target>
        </trans-unit>
        <trans-unit id="024d81b6c90a954567799332b341be59c768b8e4" translate="yes" xml:space="preserve">
          <source>If neither keras_model nor keras_model_path was given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4a46df302381b3a15b3175bfe7b5ee7e4f7f3c" translate="yes" xml:space="preserve">
          <source>If neither the global seed nor the operation seed is set, we get different results for every call to the random op and every re-run of the program:</source>
          <target state="translated">Если ни глобальный посевной материал,ни операционный посевной материал не заданы,мы получаем разные результаты при каждом вызове случайной операции и при каждом повторном запуске программы:</target>
        </trans-unit>
        <trans-unit id="a80f90092a9cdc14926ec279ccf684a91409808f" translate="yes" xml:space="preserve">
          <source>If neither the global seed nor the operation seed is set: A randomly picked seed is used for this op.</source>
          <target state="translated">Если ни общий посевной материал,ни рабочий посевной материал не установлены:Для этой операции используется случайно подобранный посевной материал.</target>
        </trans-unit>
        <trans-unit id="eb376915a9049b9705726662829e324ea799d8d9" translate="yes" xml:space="preserve">
          <source>If neither the graph-level nor the operation seed is set: A random seed is used for this op.</source>
          <target state="translated">Если ни уровень графика,ни рабочий посевной материал не установлены:Для этой операции используется случайное семя.</target>
        </trans-unit>
        <trans-unit id="53a2b49f6fe46128f61f59f18f91203c8cae5da5" translate="yes" xml:space="preserve">
          <source>If nest is not a sequence, tuple (or a namedtuple), dict, or an attrs class, then returns a single-element list: [nest].</source>
          <target state="translated">Если гнездо не является последовательностью,кортежом (или именем),диктом или классом attrs,то возвращается одноэлементный список:[гнездо].</target>
        </trans-unit>
        <trans-unit id="6e5c490bd2e442ff07025163116fecd6250620d3" translate="yes" xml:space="preserve">
          <source>If nest is not a structure , tuple (or a namedtuple), dict, or an attrs class, then returns a single-element list: [nest].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8fa99a78720209af5fdde779900c0982d9d43c7" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;graph&lt;/code&gt; argument is specified when constructing the session, the default graph will be launched in the session. If you are using more than one graph (created with &lt;a href=&quot;../../graph&quot;&gt;&lt;code&gt;tf.Graph()&lt;/code&gt;&lt;/a&gt;) in the same process, you will have to use different sessions for each graph, but each graph can be used in multiple sessions. In this case, it is often clearer to pass the graph to be launched explicitly to the session constructor.</source>
          <target state="translated">Если при построении сеанса не указан аргумент &lt;code&gt;graph&lt;/code&gt; в сеансе будет запущен график по умолчанию. Если вы используете более одного графика (созданного с помощью &lt;a href=&quot;../../graph&quot;&gt; &lt;code&gt;tf.Graph()&lt;/code&gt; &lt;/a&gt; ) в одном процессе, вам придется использовать разные сеансы для каждого графика, но каждый график можно использовать в нескольких сеансах. В этом случае часто бывает проще передать график для явного запуска конструктору сеанса.</target>
        </trans-unit>
        <trans-unit id="e03528b8eed8bab907807380295710ea8ffbc199" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;initializer&lt;/code&gt; is provided, the output structure and dtypes of &lt;code&gt;fn&lt;/code&gt; are assumed to be the same as its input; and in this case, the first argument of &lt;code&gt;fn&lt;/code&gt; must match the structure of &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;initializer&lt;/code&gt; не указан , предполагается , что структура вывода и dtypes &lt;code&gt;fn&lt;/code&gt; такие же, как и вход; и в этом случае первый аргумент &lt;code&gt;fn&lt;/code&gt; должен соответствовать структуре &lt;code&gt;elems&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ddf22c89a9b612e91a4b8184e53a33000a173de" translate="yes" xml:space="preserve">
          <source>If no KL method is defined for distribution types of &lt;code&gt;distribution_a&lt;/code&gt; and &lt;code&gt;distribution_b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035ae05d5610deba6220ec987dcb29d297b9b3f8" translate="yes" xml:space="preserve">
          <source>If no TPU devices found for eager execution or if run in a tf.function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e28ee02c99929146a3bc75c017bc3b5e90a8d33" translate="yes" xml:space="preserve">
          <source>If no TPU devices found in eager mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b01a5baff506f77205b70c8cfa23729c5d8d96" translate="yes" xml:space="preserve">
          <source>If no TPUs are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c93d808857c17377358a34f196f771ace213e9" translate="yes" xml:space="preserve">
          <source>If no conversion function is registered for &lt;code&gt;logits&lt;/code&gt; to Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89aa17961e0651e59900316456981d934e3912a8" translate="yes" xml:space="preserve">
          <source>If no conversion function is registered for &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db2dd7673a719bd18a4a69659d6bb176d96588c" translate="yes" xml:space="preserve">
          <source>If no docstring is given, only returns the method name.</source>
          <target state="translated">Если стыковочная строка не указана,возвращается только имя метода.</target>
        </trans-unit>
        <trans-unit id="4a269e9e969aae169d3e3205ccb3dae3b6b4e358" translate="yes" xml:space="preserve">
          <source>If no error is raised, the Op outputs the value of the variable before the increment.</source>
          <target state="translated">Если ошибка не поднимается,Op выводит значение переменной перед инкрементом.</target>
        </trans-unit>
        <trans-unit id="216c8a5f35ff33f04b721aaf62c762669c33d560" translate="yes" xml:space="preserve">
          <source>If no global Keras session exists at this point: we will create a new global session.</source>
          <target state="translated">Если на данный момент не существует глобальной сессии Keras:мы создадим новую глобальную сессию.</target>
        </trans-unit>
        <trans-unit id="c28b8b28787cacd056df528e92f88cbe1e1036f8" translate="yes" xml:space="preserve">
          <source>If no replica exists in the task which contains the logical core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9d82b8205b36e56cf0f7278c52946e01c5133b" translate="yes" xml:space="preserve">
          <source>If no resource containers are provided, all containers are reset.</source>
          <target state="translated">Если резервуары для ресурсов не предусмотрены,все резервуары сбрасываются.</target>
        </trans-unit>
        <trans-unit id="9cfd8b71191efc1c0a6b8d84ed8d6d888915fc70" translate="yes" xml:space="preserve">
          <source>If no structure is provided or if the structures do not match each other by type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c82db29e90e42775efa5d5de870d187dc07ca3" translate="yes" xml:space="preserve">
          <source>If no summaries were collected, returns None. Otherwise returns a scalar &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; containing the serialized &lt;code&gt;Summary&lt;/code&gt; protocol buffer resulting from the merging.</source>
          <target state="translated">Если сводки не были собраны, возвращает None. В противном случае возвращает скалярный &lt;code&gt;Tensor&lt;/code&gt; типа &lt;code&gt;string&lt;/code&gt; , содержащий сериализованный буфер протокола &lt;code&gt;Summary&lt;/code&gt; , полученный в результате слияния.</target>
        </trans-unit>
        <trans-unit id="07aeae9b6a2b7fb92c4e8a6abe9157cd51416be3" translate="yes" xml:space="preserve">
          <source>If no trace event is collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4677f5431e44aba52c3e416d441c3560e1d07b3e" translate="yes" xml:space="preserve">
          <source>If non-None, must be the same shape as arr. For each value in &lt;code&gt;arr&lt;/code&gt;, the bin will be incremented by the corresponding weight instead of 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9edd2e4ca6ef4287be04923df066082872634f" translate="yes" xml:space="preserve">
          <source>If non-None, must be the same shape as arr. For each value in &lt;code&gt;value&lt;/code&gt;, the bin will be incremented by the corresponding weight instead of 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9de9fbe1c63a1ea93130c03e9fe3eb64adbc926" translate="yes" xml:space="preserve">
          <source>If none of a node's properties match the specified regexes, the node is not displayed nor accounted.</source>
          <target state="translated">Если ни одно из свойств узла не соответствует указанным регексам,узел не отображается и не учитывается.</target>
        </trans-unit>
        <trans-unit id="d16008e222530e277dd5205338188d4326227051" translate="yes" xml:space="preserve">
          <source>If none of the TPUs specified exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ced5d0a9dde1412d62e35e74cea6874de5d3669" translate="yes" xml:space="preserve">
          <source>If none of the variables have gradients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5673c073f97a964e32cf1b429bfe01540d5a66bb" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a &lt;code&gt;DeviceAssignment&lt;/code&gt; describing the mapping between logical cores in the computation with physical cores in the TPU topology. Uses a default device assignment if &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;DeviceAssignment&lt;/code&gt; may be omitted if each replica of the computation uses only one core, and there is either only one replica, or the number of replicas is equal to the number of cores in the TPU system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c3c2c305c31754539127b6a5866a20f758c70f" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a &lt;code&gt;DeviceAssignment&lt;/code&gt; describing the mapping between logical cores in the computation with physical cores in the TPU topology. Uses a default device assignment if &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;DeviceAssignment&lt;/code&gt; may be omitted if each shard of the computation uses only one core, and there is either only one shard, or the number of shards is equal to the number of cores in the TPU system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509f2c9c1b984e6b680ad3a5e1fe26de648c4e5c" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a function that can be used to normalize the value of the tensor after &lt;code&gt;default_value&lt;/code&gt; is applied for parsing. Normalizer function takes the input &lt;code&gt;Tensor&lt;/code&gt; as its argument, and returns the output &lt;code&gt;Tensor&lt;/code&gt;. (e.g. lambda x: (x - 3.0) / 4.2). Please note that even though the most common use case of this function is normalization, it can be used for any kind of Tensorflow transformations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d465b2cf7ea11a58a6ed9a1556935218d29d6da5" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a nested structure of &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;s or &lt;a href=&quot;../../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s, matching the above, except that the tensors should be of float type (and they will be downcast to &lt;a href=&quot;../../../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;). For &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;s we assume the &lt;code&gt;indices&lt;/code&gt; are the same for the parallel entries from &lt;code&gt;features&lt;/code&gt; and similarly for &lt;a href=&quot;../../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s we assume the row_splits are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296b8e3c4315ff90baa92063d3b0326d08c56ad9" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, all embeddings are l2-normalized to max_norm before combining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a1ff929b229da4f9b213bdd01bc92916d8726d" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, each embedding is clipped if its l2-norm is larger than this value, before combining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8b1dcbe91b12c711cbead26da96a3057eeec76" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, each embedding is clipped if its l2-norm is larger than this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4186fef74e41eb06f918c4810fccf1e45e8a26" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, embedding values are l2-normalized to this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978a020b0f46543fd45be34416a7ef4179cb602b" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, must be a dictionary that will be filled with a mapping from '_FeatureColumn' to the associated output &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0bb7cd728839a79f7e1f1bd44743d45c0411f7" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, must be a dictionary that will be filled with a mapping from &lt;code&gt;_FeatureColumn&lt;/code&gt; to associated list of &lt;code&gt;Variable&lt;/code&gt;s. For example, after the call, we might have cols_to_vars = { _NumericColumn( key='numeric_feature1', shape=(1,): [</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c7e1c63640853eaa42afa057c2f45c362c9288" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, must be a dictionary that will be filled with a mapping from &lt;code&gt;_FeatureColumn&lt;/code&gt; to list of &lt;code&gt;Variable&lt;/code&gt;s. For example, after the call, we might have cols_to_vars = {_EmbeddingColumn( categorical_column=_HashedCategoricalColumn( key='sparse_feature', hash_bucket_size=5, dtype=tf.string), dimension=10): [</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ea74e730c8fdc7dced991be0cb79988348a460" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; from which to append a tuple of arguments as inputs to &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fa459e00f71f8fbe5145fbae6b30aae29c969f" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; from which to append a tuple of arguments as inputs to computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8b0ec37f8675dfef5175140fbc30d7548facce" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; to use to augment the inputs of &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adb13355e2e9171a471537a4efe3cc9a47e4197" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;logdir&lt;/code&gt; was passed to the constructor as the services need a log directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1544fb6f5eb544c03d6decbe78bbddfc4cc1a8" translate="yes" xml:space="preserve">
          <source>If not None, a &lt;code&gt;TPUEmbeddingConfiguration&lt;/code&gt; proto describing the desired configuration of the hardware embedding lookup tables. If embedding_config is None, no hardware embeddings can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f42570ffb6aa4e9f054aeab69979c5e90ad1417" translate="yes" xml:space="preserve">
          <source>If not None, names in &lt;code&gt;tensor_info&lt;/code&gt; are prefixed with this string before lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fdaefdedc8dd17a71aedc92fd4aa257320fff9" translate="yes" xml:space="preserve">
          <source>If not initialized with a &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;tf.keras.layers.Layer&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd2102800b8c57e0c21e6fddab9285a922daf0b" translate="yes" xml:space="preserve">
          <source>If not inside a distributed scope, this is equivalent to:</source>
          <target state="translated">Если это не относится к распределенному объему,то это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="ad750d422dbc04ae2bf1f5c8900ca8fc0b781343" translate="yes" xml:space="preserve">
          <source>If not inside of tf.function and not executing eagerly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80902a1672b889ee91d8c5e7f1e1ffb78350bede" translate="yes" xml:space="preserve">
          <source>If not using control flow v2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551cd382db7d04818e99686d5a2ef23e2c65b884" translate="yes" xml:space="preserve">
          <source>If not within a tpu_shard_context or group_assignment is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1152353c368563e8f451606390529f3dcdfc2374" translate="yes" xml:space="preserve">
          <source>If num_required &amp;lt; 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2d5188835a8dc9b2fc6daea0dbacadcb317cb6" translate="yes" xml:space="preserve">
          <source>If num_shards &amp;lt;= 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc823222acd9e434530a8993ce4e2336f5e34158" translate="yes" xml:space="preserve">
          <source>If num_tokens are smaller than replicas_to_aggregate - total_num_replicas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaea2a087144406be71543156cf54bff456a8e9" translate="yes" xml:space="preserve">
          <source>If obj is an instance, then it is its class that will actually be stubbed. Note that the method Set() does not do that: if obj is an instance, it (and not its class) will be stubbed.</source>
          <target state="translated">Если объект является экземпляром,то на самом деле именно его класс будет заглушен.Обратите внимание,что метод Set()этого не делает:если объект является экземпляром,то он (а не его класс)будет обрезан.</target>
        </trans-unit>
        <trans-unit id="12e486f660da647d480cd7f2ffdcdd861bede3fe" translate="yes" xml:space="preserve">
          <source>If objects in &lt;code&gt;kwargs&lt;/code&gt; are not trackable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae90fa036abf3772d3d0631e8f4275b836203c5" translate="yes" xml:space="preserve">
          <source>If on the other hand the spectrum is Hermitian, then this operator corresponds to a real-valued matrix, and setting &lt;code&gt;input_output_dtype&lt;/code&gt; to a real type is fine.</source>
          <target state="translated">Если, с другой стороны, спектр эрмитовский, то этот оператор соответствует матрице с действительными значениями, и установка &lt;code&gt;input_output_dtype&lt;/code&gt; в действительный тип - это нормально.</target>
        </trans-unit>
        <trans-unit id="3497dacd218f5e562f9d613938110d69a5766635" translate="yes" xml:space="preserve">
          <source>If one &lt;code&gt;SparseTensor&lt;/code&gt; and one &lt;code&gt;Tensor&lt;/code&gt; are passed in, returns a &lt;code&gt;Tensor&lt;/code&gt;. If both arguments are &lt;code&gt;SparseTensor&lt;/code&gt;s, this returns a &lt;code&gt;SparseTensor&lt;/code&gt;. The order of arguments does not matter. Use vanilla &lt;a href=&quot;../../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; for adding two dense &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="translated">Если &lt;code&gt;SparseTensor&lt;/code&gt; один SparseTensor и один &lt;code&gt;Tensor&lt;/code&gt; , возвращается &lt;code&gt;Tensor&lt;/code&gt; . Если оба аргумента являются &lt;code&gt;SparseTensor&lt;/code&gt; s, это возвращает &lt;code&gt;SparseTensor&lt;/code&gt; . Порядок аргументов не имеет значения. Используйте vanilla &lt;a href=&quot;../../math/add&quot;&gt; &lt;code&gt;tf.add()&lt;/code&gt; &lt;/a&gt; для добавления двух плотных &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18fe14991d61b8d26bb58197035c8d2daabc8b92" translate="yes" xml:space="preserve">
          <source>If one &lt;code&gt;SparseTensor&lt;/code&gt; and one &lt;code&gt;Tensor&lt;/code&gt; are passed in, returns a &lt;code&gt;Tensor&lt;/code&gt;. If both arguments are &lt;code&gt;SparseTensor&lt;/code&gt;s, this returns a &lt;code&gt;SparseTensor&lt;/code&gt;. The order of arguments does not matter. Use vanilla &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; for adding two dense &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="translated">Если &lt;code&gt;SparseTensor&lt;/code&gt; один SparseTensor и один &lt;code&gt;Tensor&lt;/code&gt; , возвращается &lt;code&gt;Tensor&lt;/code&gt; . Если оба аргумента являются &lt;code&gt;SparseTensor&lt;/code&gt; s, это возвращает &lt;code&gt;SparseTensor&lt;/code&gt; . Порядок аргументов не имеет значения. Используйте vanilla &lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add()&lt;/code&gt; &lt;/a&gt; для добавления двух плотных &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f0585e78e733116b83480d150410db915cb539" translate="yes" xml:space="preserve">
          <source>If one KL method is registered between any pairs of classes in these two parent hierarchies, it is used.</source>
          <target state="translated">Если один KL-метод зарегистрирован между любыми парами классов в этих двух родительских иерархиях,то он используется.</target>
        </trans-unit>
        <trans-unit id="1936b0b1103e6183e81d24cc6b618d20c1ed3535" translate="yes" xml:space="preserve">
          <source>If one component of 1-D tensor &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total size remains constant. In particular, a &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[-1]&lt;/code&gt; flattens into 1-D. At most one component of &lt;code&gt;shape&lt;/code&gt; may be unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221196929093898b7fbc8387574ba6a574c7e5f8" translate="yes" xml:space="preserve">
          <source>If one component of &lt;code&gt;new_shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total dense size remains constant. At most one component of &lt;code&gt;new_shape&lt;/code&gt; can be -1. The number of dense elements implied by &lt;code&gt;new_shape&lt;/code&gt; must be the same as the number of dense elements originally implied by &lt;code&gt;input_shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea084c2ad5e28df87d0ca52cc75d071fe917e285" translate="yes" xml:space="preserve">
          <source>If one component of &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total dense size remains constant. At most one component of &lt;code&gt;shape&lt;/code&gt; can be -1. The number of dense elements implied by &lt;code&gt;shape&lt;/code&gt; must be the same as the number of dense elements originally represented by &lt;code&gt;sp_input&lt;/code&gt;.</source>
          <target state="translated">Если один компонент &lt;code&gt;shape&lt;/code&gt; имеет специальное значение -1, размер этого измерения вычисляется так, чтобы общий плотный размер оставался постоянным. Максимум один компонент &lt;code&gt;shape&lt;/code&gt; может быть -1. Количество плотных элементов , вытекающих из &lt;code&gt;shape&lt;/code&gt; должно быть таким же , как количество плотных элементов , первоначально представленных &lt;code&gt;sp_input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bafb2065764a06f54947439b6949d0053558bc8a" translate="yes" xml:space="preserve">
          <source>If one component of &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total size remains constant. In particular, a &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[-1]&lt;/code&gt; flattens into 1-D. At most one component of &lt;code&gt;shape&lt;/code&gt; can be -1.</source>
          <target state="translated">Если один из компонентов &lt;code&gt;shape&lt;/code&gt; имеет специальное значение -1, размер этого измерения вычисляется так, чтобы общий размер оставался постоянным. В частности, &lt;code&gt;shape&lt;/code&gt; из &lt;code&gt;[-1]&lt;/code&gt; сглаживается в 1-D. Максимум один компонент &lt;code&gt;shape&lt;/code&gt; может быть -1.</target>
        </trans-unit>
        <trans-unit id="ce3fdef10714c187a3c205cc8298fa8e63609f57" translate="yes" xml:space="preserve">
          <source>If one of the arguments is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b262dc519863d0a0c455b46653404b98d409a27" translate="yes" xml:space="preserve">
          <source>If one of the tasks crashes and restarts, &lt;code&gt;managed_session()&lt;/code&gt; checks if the Model is initialized. If yes, it just creates a session and returns it to the training code that proceeds normally. If the model needs to be initialized, the chief task takes care of reinitializing it; the other tasks just wait for the model to have been initialized.</source>
          <target state="translated">Если одна из задач вылетает и перезапускается, &lt;code&gt;managed_session()&lt;/code&gt; проверяет, инициализирована ли Модель. Если да, он просто создает сеанс и возвращает его в обучающий код, который выполняется нормально. Если модель нуждается в инициализации, главная задача заключается в ее повторной инициализации; другие задачи просто ждут, пока модель будет инициализирована.</target>
        </trans-unit>
        <trans-unit id="bbb12d851ea0d6c46ec595443cab53217c732f23" translate="yes" xml:space="preserve">
          <source>If one or both of the inputs contain a lot of zeros, a more efficient multiplication algorithm can be used by setting the corresponding &lt;code&gt;a_is_sparse&lt;/code&gt; or &lt;code&gt;b_is_sparse&lt;/code&gt; flag to &lt;code&gt;True&lt;/code&gt;. These are &lt;code&gt;False&lt;/code&gt; by default. This optimization is only available for plain matrices/vectors (rank-2/1 tensors) with datatypes &lt;code&gt;bfloat16&lt;/code&gt; or &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">Если один или оба входа содержат много нулей, можно использовать более эффективный алгоритм умножения, установив для соответствующего &lt;code&gt;a_is_sparse&lt;/code&gt; или &lt;code&gt;b_is_sparse&lt;/code&gt; значение &lt;code&gt;True&lt;/code&gt; . По умолчанию это &lt;code&gt;False&lt;/code&gt; . Эта оптимизация доступна только для простых матриц / векторов (тензоры ранга-2/1) с типами данных &lt;code&gt;bfloat16&lt;/code&gt; или &lt;code&gt;float32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17b326f6ea020b628ceba1332baab40e28fbf23a" translate="yes" xml:space="preserve">
          <source>If one or both of the matrices contain a lot of zeros, a more efficient multiplication algorithm can be used by setting the corresponding &lt;code&gt;a_is_sparse&lt;/code&gt; or &lt;code&gt;b_is_sparse&lt;/code&gt; flag to &lt;code&gt;True&lt;/code&gt;. These are &lt;code&gt;False&lt;/code&gt; by default. This optimization is only available for plain matrices (rank-2 tensors) with datatypes &lt;code&gt;bfloat16&lt;/code&gt; or &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">Если одна или обе матрицы содержат много нулей, можно использовать более эффективный алгоритм умножения, установив соответствующий &lt;code&gt;a_is_sparse&lt;/code&gt; или &lt;code&gt;b_is_sparse&lt;/code&gt; в значение &lt;code&gt;True&lt;/code&gt; . По умолчанию это &lt;code&gt;False&lt;/code&gt; . Эта оптимизация доступна только для простых матриц (тензоры ранга 2) с типами данных &lt;code&gt;bfloat16&lt;/code&gt; или &lt;code&gt;float32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f4daf089aff0f2fa2e66596a4c62c77c048c8b" translate="yes" xml:space="preserve">
          <source>If one row of &lt;code&gt;transforms&lt;/code&gt; is &lt;code&gt;[a0, a1, a2, b0, b1, b2, c0, c1]&lt;/code&gt;, then it maps the &lt;em&gt;output&lt;/em&gt; point &lt;code&gt;(x, y)&lt;/code&gt; to a transformed &lt;em&gt;input&lt;/em&gt; point &lt;code&gt;(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)&lt;/code&gt;, where &lt;code&gt;k = c0 x + c1 y + 1&lt;/code&gt;. If the transformed point lays outside of the input image, the output pixel is set to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cec49ea279d810bcec33c21637d3e3e971bbbb" translate="yes" xml:space="preserve">
          <source>If only classes is set, it is interpreted as providing top-k results in descending order.</source>
          <target state="translated">Если заданы только классы,то это интерпретируется как предоставление результатов top-k в порядке убывания.</target>
        </trans-unit>
        <trans-unit id="75620cc03e8dc3221a8a09a86626829819275026" translate="yes" xml:space="preserve">
          <source>If only scores is set, it is interpreted as providing a score for every class in order of class ID.</source>
          <target state="translated">Если установлены только баллы,то это интерпретируется как предоставление баллов для каждого класса в порядке идентификатора класса.</target>
        </trans-unit>
        <trans-unit id="667b41a8af9aff900724c27ad2e8c154d2639d32" translate="yes" xml:space="preserve">
          <source>If optimizer is not one of tf.tpu.experimental.embedding.(SGD, Adam or Adagrad).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c9d9f46c8a297896e15240808cdbc2b353bfe6" translate="yes" xml:space="preserve">
          <source>If p and logits are passed, or if neither are passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5e99215ee01b17ad5ac6edb796d60bac8b52d6" translate="yes" xml:space="preserve">
          <source>If padding = &quot;SAME&quot;, specifies the shape of the convolution kernel/pooling window as an integer Tensor of shape [&amp;gt;=num_spatial_dims]. If padding = &quot;VALID&quot;, filter_shape is ignored and need not be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e0db46aec01ec30dc1082790031dd6d15b166e" translate="yes" xml:space="preserve">
          <source>If padding = &quot;SAME&quot;: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</source>
          <target state="translated">Если padding=&quot;SAME&quot;:output_spatial_shape[i]=ceil(input_spatial_shape[i]/strides[i])</target>
        </trans-unit>
        <trans-unit id="fcdcd97fe86754396f4eb68d73df8c9d73f8dba1" translate="yes" xml:space="preserve">
          <source>If padding = &quot;VALID&quot;: output_spatial_shape[i] = ceil((input_spatial_shape[i] - (window_shape[i] - 1) * dilation_rate[i]) / strides[i]).</source>
          <target state="translated">Если padding=&quot;VALID&quot;:output_spatial_shape[i]=ceil((input_spatial_shape[i]-(window_shape[i]-1)*dilation_rate[i]))/...</target>
        </trans-unit>
        <trans-unit id="05f33b626808fecfebc52bc856e9c14717da266f" translate="yes" xml:space="preserve">
          <source>If padding == &quot;SAME&quot;: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</source>
          <target state="translated">Если padding ==&quot;SAME&quot;:output_spatial_shape[i]=ceil(input_spatial_shape[i]/strides[i])</target>
        </trans-unit>
        <trans-unit id="136aa13ad4e629923ef043b74c86f4e39f2b8ae0" translate="yes" xml:space="preserve">
          <source>If padding == &quot;VALID&quot;: output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).</source>
          <target state="translated">Если padding ==&quot;VALID&quot;:output_spatial_shape[i]=ceil((input_spatial_shape[i]-(spatial_filter_shape[i]-1)*dilation_rate[i])/...</target>
        </trans-unit>
        <trans-unit id="f7b6860ab2b51cdf0388bf04a8450a071066af7a" translate="yes" xml:space="preserve">
          <source>If positive, the feature is a sequence feature with the corresponding maximum sequence length. If the sequence is longer than this, it will be truncated. If 0, the feature is not a sequence feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4fb2200f1abc514276162cb92eabdf216c950b" translate="yes" xml:space="preserve">
          <source>If possible you should use &lt;code&gt;assertRegex&lt;/code&gt;, which is a simpler version of this method. &lt;code&gt;assertRegex&lt;/code&gt; takes a single regular expression (a string or re compiled object) instead of a list.</source>
          <target state="translated">Если возможно, вам следует использовать &lt;code&gt;assertRegex&lt;/code&gt; , который является более простой версией этого метода. &lt;code&gt;assertRegex&lt;/code&gt; принимает одно регулярное выражение (строку или повторно скомпилированный объект) вместо списка.</target>
        </trans-unit>
        <trans-unit id="06742f16b6eea52463f3c33907285332cf099a29" translate="yes" xml:space="preserve">
          <source>If possible, you should use assertCountEqual instead of assertSameElements.</source>
          <target state="translated">Если возможно,вам следует использовать assertCountEqual вместо assertSameElements.</target>
        </trans-unit>
        <trans-unit id="614678e645a7e3d66b077654721dda0404775036" translate="yes" xml:space="preserve">
          <source>If prefix is an empty sequence, it will raise an error unless whole is also an empty sequence.</source>
          <target state="translated">Если префикс является пустой последовательностью,то это вызовет ошибку,если только вся последовательность не будет также пустой.</target>
        </trans-unit>
        <trans-unit id="47be90f234e2dd2a2a123f6a39d9360729095139" translate="yes" xml:space="preserve">
          <source>If prefix is not a sequence, it will raise an error if the first element of whole does not match.</source>
          <target state="translated">Если префикс не является последовательностью,то это приведет к ошибке,если первый элемент целого не совпадает.</target>
        </trans-unit>
        <trans-unit id="4456cc620a8e8e1b60e289bbd83d6240b8855aef" translate="yes" xml:space="preserve">
          <source>If previously created threads for the given session are still running, no new threads will be created.</source>
          <target state="translated">Если ранее созданные для данной сессии потоки все еще выполняются,новые потоки создаваться не будут.</target>
        </trans-unit>
        <trans-unit id="935d994a9d9f9a8a4651374980a9727dd4176a43" translate="yes" xml:space="preserve">
          <source>If provided the global step number is appended to &lt;code&gt;save_path&lt;/code&gt; to create the checkpoint filenames. The optional argument can be a &lt;code&gt;Tensor&lt;/code&gt;, a &lt;code&gt;Tensor&lt;/code&gt; name or an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6505b900cbe26dd0628fad67c8abdd95daefb1a9" translate="yes" xml:space="preserve">
          <source>If provided, a Tensor which is of the same type as &lt;code&gt;y&lt;/code&gt;, and has a shape broadcastable with &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ebfa3cb3d2b0a0319a06e522f9afca9b3a453d" translate="yes" xml:space="preserve">
          <source>If provided, a Tensor which is of the same type as &lt;code&gt;y&lt;/code&gt;, and has a shape broadcastable with &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e190b7a73646673bf3b834de40d541abeb2140" translate="yes" xml:space="preserve">
          <source>If provided, contains a name of a &quot;known&quot; function this implements. For example &quot;mycompany.my_recurrent_cell&quot;. This is stored as an attribute in inference function, which can then be detected when processing serialized function. See &lt;a href=&quot;https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md&quot;&gt;standardizing composite ops&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd1c318ea1071c0386e26e997ff535d9d7da5b2" translate="yes" xml:space="preserve">
          <source>If provided, parameters will be passed to each &lt;code&gt;Callback&lt;/code&gt; via &lt;a href=&quot;callback#set_params&quot;&gt;&lt;code&gt;Callback.set_params&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e75e5a1f64ca198b5be947e9d08bf1483b9ae0e" translate="yes" xml:space="preserve">
          <source>If range_given == False, the initial input_min, input_max will be determined automatically as the minimum and maximum values in the input tensor, otherwise the specified values of input_min, input_max are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a0d6e60eb82597465ad27ec661d2094826eef2" translate="yes" xml:space="preserve">
          <source>If range_given=True, the maximum input value that needs to be represented in the quantized representation. If axis is specified, this should be a vector of maximum values for each slice along axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29e16a712314dbeb26dae11afbe28b3144fe882" translate="yes" xml:space="preserve">
          <source>If range_given=True, the minimum input value, that needs to be represented in the quantized representation. If axis is specified, this should be a vector of minimum values for each slice along axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341f17f161cd76784a4d0ca890a541c032caae40" translate="yes" xml:space="preserve">
          <source>If rank of &lt;code&gt;condition&lt;/code&gt; is greater than rank of expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b41a1af83d2a93715620f2355e250fc52515b3" translate="yes" xml:space="preserve">
          <source>If rate is set to &lt;code&gt;0&lt;/code&gt; the input is returned, unchanged:</source>
          <target state="translated">Если скорость установлена ​​на &lt;code&gt;0&lt;/code&gt; , ввод возвращается без изменений:</target>
        </trans-unit>
        <trans-unit id="a4673a94db4f6c34f4aee3756479ca96ccf05ec9" translate="yes" xml:space="preserve">
          <source>If ready_for_local_init_op is not None but local_init_op is None</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13d81516362b4032d992ee7026437f786c08d61" translate="yes" xml:space="preserve">
          <source>If reduction is not a valid cross-shard reduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a119b1872be8a1e53e996eedc55e37414996ed" translate="yes" xml:space="preserve">
          <source>If regexes is the empty list, the matching will always fail.</source>
          <target state="translated">Если регексы-это пустой список,то совпадение всегда будет неудачным.</target>
        </trans-unit>
        <trans-unit id="80440764c99d48a4d795f521af9a42a08a91983b" translate="yes" xml:space="preserve">
          <source>If requested more GPUs per node then available or requested more tasks then assigned tasks or resolving missing values from the environment failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fe2d8006b52d6565c302d5fd04437409f9fb2a" translate="yes" xml:space="preserve">
          <source>If result is empty but the gradient is nonzero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987747562432e3f06305cc2152c8a49d1c73905b" translate="yes" xml:space="preserve">
          <source>If result type is incompatible with &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2d3ef0e0ba16ab30b7cbfeba73a83b309a4c52" translate="yes" xml:space="preserve">
          <source>If running inside a tf.function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903b4a597f4844b0d172060958b46a04076c6f57" translate="yes" xml:space="preserve">
          <source>If save and restore ops weren't built.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbaa0275dbd84220e47ad7f03f7672526f446b5" translate="yes" xml:space="preserve">
          <source>If save format is hdf5, and h5py is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aaf33d3510248f2ccf226e35da12a582cc0f4ec" translate="yes" xml:space="preserve">
          <source>If save_path is None or not a valid checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8b71f4c8233230d90cf75030653b89e7ac8f3b" translate="yes" xml:space="preserve">
          <source>If sep is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a0eb571e3f74bb0679d5102f7da6c4488fd506" translate="yes" xml:space="preserve">
          <source>If session wasn't passed and no default session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1052e1262f17b2ce83bec58b3858ca5adcbd4113" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;padding_width&lt;/code&gt; pad values will be added to both sides of each sequence. Defaults to &lt;code&gt;ngram_width&lt;/code&gt;-1. Must be greater than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42713d8f147f419359cb2f9d97685f1b466cd841" translate="yes" xml:space="preserve">
          <source>If set, directory containing summary files with eval metrics. By default, &lt;code&gt;estimator.eval_dir()&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b85a897129ee78e5ab69037f1060f3b5a56aa8c" translate="yes" xml:space="preserve">
          <source>If set, initial_value will be converted to the given type. If &lt;code&gt;None&lt;/code&gt;, either the datatype will be kept (if &lt;code&gt;initial_value&lt;/code&gt; is a Tensor), or &lt;code&gt;convert_to_tensor&lt;/code&gt; will decide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f050a1aecaf98e6e971ad7ddbad7946578f6991" translate="yes" xml:space="preserve">
          <source>If set, it overrides the maximum degree of intra-op parallelism.</source>
          <target state="translated">Если он установлен,то отменяет максимальную степень внутриоперационного параллелизма.</target>
        </trans-unit>
        <trans-unit id="406b1726c99d9d0143b0b00beee8d5df87d7ea20" translate="yes" xml:space="preserve">
          <source>If set, the dataset will use a private threadpool of the given size.</source>
          <target state="translated">Если установлено,то в наборе данных будет использоваться приватный потоковой пул заданного размера.</target>
        </trans-unit>
        <trans-unit id="ffc52c5a8474455aaec22a4147fbe64f35824f18" translate="yes" xml:space="preserve">
          <source>If set, the first &lt;code&gt;fixed_length&lt;/code&gt; bytes of each element will be converted. Data will be zero-padded or truncated to the specified length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3647e794d90ebd60c57ea22288d32190cb697002" translate="yes" xml:space="preserve">
          <source>If set, values outside of range &lt;code&gt;[0, num_buckets)&lt;/code&gt; will be replaced with this value. If not set, values &amp;gt;= num_buckets will cause a failure while values &amp;lt; 0 will be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce3f4499675c06927ac9cd4d0513f29af599d8a" translate="yes" xml:space="preserve">
          <source>If several adjustments are chained it is advisable to minimize the number of redundant conversions by first converting the images to the most natural data type and representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e247aff5f095d2ffb3872d7179387704922d50" translate="yes" xml:space="preserve">
          <source>If shape is not convertible to a &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt;, or dtype is not convertible to a &lt;a href=&quot;dtypes/dtype&quot;&gt;&lt;code&gt;tf.DType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c0f7d09583d4af41119ac2d7c50e6404fd2384" translate="yes" xml:space="preserve">
          <source>If shapes are not known during graph construction time, and during run time it is found out that the ranks do not match.</source>
          <target state="translated">Если формы не известны во время построения графа,а также во время прогона выясняется,что ранги не совпадают.</target>
        </trans-unit>
        <trans-unit id="aa925c0adaddfe1830079b9cbafb10c52df9958b" translate="yes" xml:space="preserve">
          <source>If shapes do not conform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba5d55fa813047e7fe0ec9851608cd7190123e3" translate="yes" xml:space="preserve">
          <source>If shapes is not a list of shapes, or the lengths of dtypes and shapes do not match, or if names is specified and the lengths of dtypes and names do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1814dc3de1048c3554d33e04a6570bd1af7a3688" translate="yes" xml:space="preserve">
          <source>If soft placement is enabled.</source>
          <target state="translated">Если включено мягкое размещение.</target>
        </trans-unit>
        <trans-unit id="e7fbbf1e215e574da65fd180d3efd4ed7169ba5a" translate="yes" xml:space="preserve">
          <source>If some arguments are invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74009976d1af3f8ace2767a5d190d7dc5534103a" translate="yes" xml:space="preserve">
          <source>If some of the variables are not &lt;code&gt;Variable&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188670dc4033de3caf330c736da12315f5461a5c" translate="yes" xml:space="preserve">
          <source>If specified, calls &lt;code&gt;should_stop_fn&lt;/code&gt; at an interval of &lt;code&gt;run_every_secs&lt;/code&gt; seconds. Defaults to 60 seconds. Either this or &lt;code&gt;run_every_steps&lt;/code&gt; must be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa858aa25d35679553ae73d53e82c00273b66b4f" translate="yes" xml:space="preserve">
          <source>If specified, calls &lt;code&gt;should_stop_fn&lt;/code&gt; every &lt;code&gt;run_every_steps&lt;/code&gt; steps. Either this or &lt;code&gt;run_every_secs&lt;/code&gt; must be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21bd4dafdeb31f10310614cb3babca1c0cb7f9de" translate="yes" xml:space="preserve">
          <source>If static checks determine &lt;code&gt;x&lt;/code&gt; has mismatched rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bfd962b0c1330f3e7f6c21b07640c3d065f10e" translate="yes" xml:space="preserve">
          <source>If static checks determine &lt;code&gt;x&lt;/code&gt; has wrong rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7c4513de4ff5d6eb54788b5e3829e4f82d9ad05" translate="yes" xml:space="preserve">
          <source>If static checks determine any shape constraint is violated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de409eb237796976a466cb4b77c35e672e5c4b3d" translate="yes" xml:space="preserve">
          <source>If supplied, a list of integers which specifies the intended dense shape to run embedding lookup for this feature on TensorCore. The batch dimension can be left None or -1 to indicate a dynamic shape. Only rank 2 shapes currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4311c10b99cf9dea10540595aa38757622923396" translate="yes" xml:space="preserve">
          <source>If tensor has the wrong shape or type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dc9cf7a428ffb3a2a2d1adf68ef64f616003b5" translate="yes" xml:space="preserve">
          <source>If tensor has the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba33c2663325e71d7455b176c4a928e4d72364" translate="yes" xml:space="preserve">
          <source>If that attempt is unsuccessful (e.g. the dataset is created from a Dataset.range), we will shard the dataset evenly at the end by appending a &lt;code&gt;.shard&lt;/code&gt; operation to the end of the processing pipeline. This will cause the entire preprocessing pipeline for all the data to be run on every worker, and each worker will do redundant work. We will print a warning if this method of sharding is selected. In this case, consider using &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; instead.</source>
          <target state="translated">Если эта попытка не удалась (например, набор данных создается из Dataset.range), мы равномерно &lt;code&gt;.shard&lt;/code&gt; набор данных в конце, добавив операцию .shard в конец конвейера обработки. Это приведет к тому, что весь конвейер предварительной обработки всех данных будет запущен на каждом воркере, и каждый воркер будет выполнять избыточную работу. Если выбран этот метод шардинга, мы напечатаем предупреждение. В этом случае рассмотрите возможность использования вместо этого &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3358bfa17db34ad277d96d5332d507879fea9dd9" translate="yes" xml:space="preserve">
          <source>If the &quot;checkpoint&quot; file contains a valid CheckpointState proto, returns it.</source>
          <target state="translated">Если файл &quot;контрольно-пропускной пункт&quot; содержит действующий прото-контроль,возвращает его.</target>
        </trans-unit>
        <trans-unit id="7258ed382efb992fab747cb709315af27fa6a0ea" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;distributediterator&quot;&gt;&lt;code&gt;tf.distribute.DistributedIterator&lt;/code&gt;&lt;/a&gt; has reached the end of the sequence, the returned &lt;a href=&quot;../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; will have no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c134a85184e534f88d7fb96668ca546c1278640d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Estimator&lt;/code&gt; has not produced a checkpoint yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40288d720b884ba08bda933b7028c5bbc2ac3f76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GraphDef&lt;/code&gt;s do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d23a673705ea572eb958c26ad999633860bb8c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Variable&lt;/code&gt; is of type string, this provides an estimate of how large each scalar in the &lt;code&gt;Variable&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3317e8f03ad0ddae193d8c356cad6a0931714dea" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;datasets&lt;/code&gt; or &lt;code&gt;choice_dataset&lt;/code&gt; arguments have the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f07f80fdcf6b0d82e35cb67ed69ccf18348c88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;datasets&lt;/code&gt; or &lt;code&gt;weights&lt;/code&gt; arguments have the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85f20c0c380f317916cf91653305134b56d70aa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; method under the same Python namespace has been invoked before, calling this method disables it. If no call to &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; has been made, calling this method is a no-op. Calling this method more than once is idempotent.</source>
          <target state="translated">Если метод &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; в том же пространстве имен Python был вызван ранее, вызов этого метода отключает его. Если не было выполнено ни одного вызова &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; , вызов этого метода не выполняется. Вызов этого метода более одного раза идемпотентен.</target>
        </trans-unit>
        <trans-unit id="850f4f3695a83977b57e13df3d06b8e2f6c6277a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;graph_def&lt;/code&gt; would be too large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c57e73738d6d60cc61fb52afa5770fd921df6c3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;initial_accumulator_value&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8e3475ccb7eea2e81161fcedd13db73d199519" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;initial_gradient_squared_accumulator_value&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77a52bdc6af3b48e4538f386e66464280d5e564" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inputs&lt;/code&gt; has dynamic shapes and you would like to automatically bucketize the inputs to avoid XLA recompilation. See the advanced example below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec1331f66efc3c89fcaeb5f189cdbc3f3c7a5f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shape[split_dim]&lt;/code&gt; is not an integer multiple of &lt;code&gt;num_split&lt;/code&gt;. Slices &lt;code&gt;[0 : shape[split_dim] % num_split]&lt;/code&gt; gets one extra dimension. For example, if &lt;code&gt;split_dim = 1&lt;/code&gt; and &lt;code&gt;num_split = 2&lt;/code&gt; and the input is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ba5c8db0186a187e8ec3f75cb6e513ca601471" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; are not specified, and cannot be inferred from the elements of &lt;code&gt;tensor_list_list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aa66c5edeb6fff7370d5b6a8be818bade3ce0b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; are not specified, and cannot be inferred from the elements of &lt;code&gt;tensors&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5484cde99e3216708fd00c33daac67c9c0ad62" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; are not specified, and cannot be inferred from the elements of &lt;code&gt;tensors_list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32d73aea60310abf91b1e01ff102173ff94bf4c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; argument is specified, each component of a queue element must have the respective fixed shape. If it is unspecified, different queue elements may have different shapes, but the use of &lt;code&gt;dequeue_many&lt;/code&gt; is disallowed.</source>
          <target state="translated">Если &lt;code&gt;shapes&lt;/code&gt; указан аргумент, каждый компонент элемента очереди должен иметь соответствующую фиксированную форму. Если он не указан, разные элементы очереди могут иметь разные формы, но использование &lt;code&gt;dequeue_many&lt;/code&gt; запрещено.</target>
        </trans-unit>
        <trans-unit id="7226982fe5b09f7a9182c06848094e1377702d50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;signatures&lt;/code&gt; argument is omitted, &lt;code&gt;obj&lt;/code&gt; will be searched for &lt;code&gt;@tf.function&lt;/code&gt;-decorated methods. If exactly one &lt;code&gt;@tf.function&lt;/code&gt; is found, that method will be used as the default signature for the SavedModel. This behavior is expected to change in the future, when a corresponding &lt;a href=&quot;load&quot;&gt;&lt;code&gt;tf.saved_model.load&lt;/code&gt;&lt;/a&gt; symbol is added. At that point signatures will be completely optional, and any &lt;code&gt;@tf.function&lt;/code&gt; attached to &lt;code&gt;obj&lt;/code&gt; or its dependencies will be exported for use with &lt;code&gt;load&lt;/code&gt;.</source>
          <target state="translated">Если аргумент &lt;code&gt;signatures&lt;/code&gt; опущен, &lt;code&gt;obj&lt;/code&gt; будет искать методы, &lt;code&gt;@tf.function&lt;/code&gt; . Если будет найдена ровно одна &lt;code&gt;@tf.function&lt;/code&gt; , этот метод будет использоваться как подпись по умолчанию для SavedModel. Ожидается, что это поведение изменится в будущем, когда будет добавлен соответствующий символ &lt;a href=&quot;load&quot;&gt; &lt;code&gt;tf.saved_model.load&lt;/code&gt; &lt;/a&gt; . С этого момента подписи будут полностью необязательными, и любая &lt;code&gt;@tf.function&lt;/code&gt; прикрепленная к &lt;code&gt;obj&lt;/code&gt; или его зависимостям, будет экспортирована для использования с &lt;code&gt;load&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fd7e686a1dc65c75a2588abd9db94c81edb3064" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sp_input.dense_shape[axis]&lt;/code&gt; is not an integer multiple of &lt;code&gt;num_split&lt;/code&gt; each slice starting from 0:&lt;code&gt;shape[axis] % num_split&lt;/code&gt; gets extra one dimension. For example, if &lt;code&gt;axis = 1&lt;/code&gt; and &lt;code&gt;num_split = 2&lt;/code&gt; and the input is:</source>
          <target state="translated">Если &lt;code&gt;sp_input.dense_shape[axis]&lt;/code&gt; не является целым числом, кратным &lt;code&gt;num_split&lt;/code&gt; , каждый срез, начиная с 0: &lt;code&gt;shape[axis] % num_split&lt;/code&gt; получает дополнительное измерение. Например, если &lt;code&gt;axis = 1&lt;/code&gt; и &lt;code&gt;num_split = 2&lt;/code&gt; и ввод:</target>
        </trans-unit>
        <trans-unit id="57e7719d24c0316d5621496138e5a812699ce17f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stride&lt;/code&gt; parameter is greater than 1, then each window will skip &lt;code&gt;(stride - 1)&lt;/code&gt; input elements between each element that appears in the window. Output windows will still contain &lt;code&gt;size&lt;/code&gt; elements regardless of the value of &lt;code&gt;stride&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3eb54590375091b7c8a0790f145904bd9715ba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; depth does not match &lt;code&gt;filters&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2801a9f9503028fe01b709b764a0b08f0e710d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; depth does not match &lt;code&gt;kernel&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4350b881d5074f040b3c42be06cd154a0ce36814" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; is a tensor not of given &lt;code&gt;dtype&lt;/code&gt; in graph mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130adade1f1a1eb5f1353a2cb7fb49bd034b04c8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;weights&lt;/code&gt; argument is specified and does not match the length of the &lt;code&gt;datasets&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06af6343f99ab2414ab6f7df25e2f6714e027807" translate="yes" xml:space="preserve">
          <source>If the Kubernetes Python client is not installed and no &lt;code&gt;override_client&lt;/code&gt; is passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5d5a953bc259f0271e19fc5d6c07aed62f3c39" translate="yes" xml:space="preserve">
          <source>If the SavedModel directory already exists and isn't empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb08920384c4a4c56e663c608090b5d9d7a8070" translate="yes" xml:space="preserve">
          <source>If the WarmStartSettings contains prev_var_name or VocabInfo configuration for variable names that are not used. This is to ensure a stronger check for variable configuration than relying on users to examine the logs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeef1d7dca0a515d92122f1e23dc5bfa84989757" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;../../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12dc57ccab95dcb91583b36ab94e270b350ccee7" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57079beaf471dbb9d3f9aeebd7728587fba24ba" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;../strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406a399aec9f3ac354fde4744023824e2671b245" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112da864d4b1f24e488ea72104bf36a2900d9125" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="translated">Если описанная выше логика пакетного разделения и сегментирования набора данных нежелательна, используйте вместо этого &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; , которая не выполняет никакого автоматического разделения или сегментирования.</target>
        </trans-unit>
        <trans-unit id="c05cf6d5da583a19c043c4546b8addef87e9dda3" translate="yes" xml:space="preserve">
          <source>If the answer to several of these questions is yes, consider converting the &lt;code&gt;SparseTensor&lt;/code&gt; to a dense one and using &lt;a href=&quot;../linalg/matmul&quot;&gt;&lt;code&gt;tf.matmul&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;a_is_sparse=True&lt;/code&gt;.</source>
          <target state="translated">Если ответ на несколько из этих вопросов &lt;code&gt;SparseTensor&lt;/code&gt; , подумайте о преобразовании SparseTensor в плотный и использовании &lt;a href=&quot;../linalg/matmul&quot;&gt; &lt;code&gt;tf.matmul&lt;/code&gt; &lt;/a&gt; с &lt;code&gt;a_is_sparse=True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03d4d4ad09e2435c621916ddd6a1d50f3469707d" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;dtype&lt;/code&gt; is not specified, then the type is inferred from the type of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Если аргумент &lt;code&gt;dtype&lt;/code&gt; не указан, то тип выводится из типа &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7a755586c48ee50759898fa7c989f8e67d40736" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;staircase&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;global_step / decay_steps&lt;/code&gt; is an integer division and the decayed learning rate follows a staircase function.</source>
          <target state="translated">Если аргумент &lt;code&gt;staircase&lt;/code&gt; равен &lt;code&gt;True&lt;/code&gt; , то &lt;code&gt;global_step / decay_steps&lt;/code&gt; представляет собой целочисленное деление, а уменьшенная скорость обучения следует за функцией лестничной клетки.</target>
        </trans-unit>
        <trans-unit id="d1f01cc54fa41c0d32fd1e24bafe662f494d520d" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;staircase&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;step / decay_steps&lt;/code&gt; is an integer division and the decayed learning rate follows a staircase function.</source>
          <target state="translated">Если аргумент &lt;code&gt;staircase&lt;/code&gt; равен &lt;code&gt;True&lt;/code&gt; , тогда &lt;code&gt;step / decay_steps&lt;/code&gt; является целочисленным делением, и уменьшенная скорость обучения следует за функцией лестницы.</target>
        </trans-unit>
        <trans-unit id="e346c3059dbd94f214dc5577c884d86380f954b5" translate="yes" xml:space="preserve">
          <source>If the arguments are not an allowed type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8963d4f9837f2142579419ad4b548a6f26586097" translate="yes" xml:space="preserve">
          <source>If the arguments do not have the appropriate type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8ebe15b04c5c4a7996a68d6b6095e7fba23d0d" translate="yes" xml:space="preserve">
          <source>If the arguments have the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5461a118a1f9cee1e8fdbbebb257329c594b169" translate="yes" xml:space="preserve">
          <source>If the attempt to shard by file is unsuccessful (i.e. the dataset is not read from files), we will shard the dataset evenly at the end by appending a &lt;code&gt;.shard&lt;/code&gt; operation to the end of the processing pipeline. This will cause the entire preprocessing pipeline for all the data to be run on every worker, and each worker will do redundant work. We will print a warning if this route is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55881dcd47167c577d9f3a17b426b645d5d9a3a1" translate="yes" xml:space="preserve">
          <source>If the attribute cannot be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38c88d9d6337fe7cece5f81a29f0e638b688c37" translate="yes" xml:space="preserve">
          <source>If the checkpoint has not been consumed completely, then the list of restore ops will grow as more objects are added to the dependency graph.</source>
          <target state="translated">Если контрольная точка не была использована полностью,то список восстановительных опций будет увеличиваться по мере добавления новых объектов на граф зависимости.</target>
        </trans-unit>
        <trans-unit id="a6f46ebca037e3275747c4060df65546e7f35655" translate="yes" xml:space="preserve">
          <source>If the clip_norm tensor is not a 0-D scalar tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322354248713025e3d6689fb7a7b7d477c48e541" translate="yes" xml:space="preserve">
          <source>If the code being run raises an exception, that exception is reported to the coordinator and the thread terminates. The coordinator will then request all the other threads it coordinates to stop.</source>
          <target state="translated">Если запускаемый код вызывает исключение,то об этом исключении сообщается координатору,и поток завершается.Координатор запросит,чтобы все остальные потоки,которые он координирует,остановились.</target>
        </trans-unit>
        <trans-unit id="d7979f58f3ff709afb03169a221ab568ed8d0b58" translate="yes" xml:space="preserve">
          <source>If the collection exists, this returns the list itself, which can be modified in place to change the collection. If the collection does not exist, it is created as an empty list and the list is returned.</source>
          <target state="translated">Если коллекция существует,возвращается сам список,который можно изменить,чтобы изменить коллекцию.Если коллекция не существует,она создается как пустой список,и список возвращается.</target>
        </trans-unit>
        <trans-unit id="16e2e93d9e738ccca07e48ed484e074d5b9423d1" translate="yes" xml:space="preserve">
          <source>If the coordinates are both normalized and centered, they range from -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper left corner, the lower right corner is located at (1.0, 1.0) and the center is at (0, 0).</source>
          <target state="translated">Если координаты нормализованы и центрированы,то они находятся в диапазоне от -1.0 до 1.0.Координаты (-1.0,-1.0)соответствуют левому верхнему углу,правый нижний угол расположен в (1.0,1.0),а центр-в (0,0).</target>
        </trans-unit>
        <trans-unit id="1ff57f39749c34bbe8fe0401b61997435557e382" translate="yes" xml:space="preserve">
          <source>If the coordinates are normalized but not centered, 0.0 and 1.0 correspond to the minimum and maximum of each height and width dimension.</source>
          <target state="translated">Если координаты нормализованы,но не отцентрированы,то 0,0 и 1,0 соответствуют минимальному и максимальному значениям каждого размера высоты и ширины.</target>
        </trans-unit>
        <trans-unit id="ccc9ff36ea56cfa9e765b3c8d0c91355e08ae564" translate="yes" xml:space="preserve">
          <source>If the coordinates are not normalized they are interpreted as numbers of pixels.</source>
          <target state="translated">Если координаты не нормализованы,они интерпретируются как количество пикселей.</target>
        </trans-unit>
        <trans-unit id="0a9b966bb81ad2605ac867ad5ef2ce7ea8c2375c" translate="yes" xml:space="preserve">
          <source>If the current thread has no default &lt;code&gt;tf.contrib.summary.SummaryWriter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9db9b059080921cd6c062dbce6bf5607f4a3a62" translate="yes" xml:space="preserve">
          <source>If the dataset length is unknown or infinite, or if eager execution is not enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea3d6caf73fa0c188e4b9504d662b3328e66ed1" translate="yes" xml:space="preserve">
          <source>If the default option of sharding the saved dataset was used, the element order of the saved dataset will be preserved when loading it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9562bf6c9ebf00a96c5a59cf2cf0460fffaaaae" translate="yes" xml:space="preserve">
          <source>If the deprecated &lt;code&gt;split_dim&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt; are both non None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f2c255dc162a384dc28be1433b4029caea49f5" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">Если размер является постоянным (например, &lt;a href=&quot;../../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt; ), компонент будет увеличен до этой длины в этом измерении.</target>
        </trans-unit>
        <trans-unit id="791f44cfdf8ef290ec842dbce59a72390416ce7a" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">Если размер является постоянным (например, &lt;a href=&quot;../../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt; ), компонент будет увеличен до этой длины в этом измерении.</target>
        </trans-unit>
        <trans-unit id="e002c71d640bbe2622e030008cf7b64978256ffa" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">Если размер является постоянным (например, &lt;a href=&quot;../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt; ), компонент будет увеличен до этой длины в этом измерении.</target>
        </trans-unit>
        <trans-unit id="191bc9524d6bf196a57d9a494c82f21595b508cf" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">Если размер является постоянным (например, &lt;a href=&quot;../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt; ), компонент будет увеличен до этой длины в этом измерении.</target>
        </trans-unit>
        <trans-unit id="8ee6305f8f5ea21e225c1270e43da8cf1fa7c5eb" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant, the component will be padded out to that length in that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340852a05739f6c28dacec87f71405e50e7f1da1" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">Если размер неизвестен (например, &lt;a href=&quot;../../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt; ), компонент будет дополнен до максимальной длины всех элементов в этом измерении.</target>
        </trans-unit>
        <trans-unit id="552f501db3f78e9dbef2993feeab6983fea583c8" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">Если размер неизвестен (например, &lt;a href=&quot;../../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt; ), компонент будет дополнен до максимальной длины всех элементов в этом измерении.</target>
        </trans-unit>
        <trans-unit id="5bdf9b1d41ce2f6dc0c751ffe579fd03e7de2703" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">Если размер неизвестен (например, &lt;a href=&quot;../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt; ), компонент будет дополнен до максимальной длины всех элементов в этом измерении.</target>
        </trans-unit>
        <trans-unit id="eb0dd7527d5cb7b1a0e894b67170a54d79baca84" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">Если размер неизвестен (например, &lt;a href=&quot;../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt; ), компонент будет дополнен до максимальной длины всех элементов в этом измерении.</target>
        </trans-unit>
        <trans-unit id="a8bfe46894536a1da19abd0f232f48aef12d3373" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown, the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd57dc9acb453b70e46365a7208d407f12c6c9d" translate="yes" xml:space="preserve">
          <source>If the dtype is not floating point</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fbb6086ed5b3f6f6f1921ca38eed44d66ed5c39" translate="yes" xml:space="preserve">
          <source>If the dtype is not numeric or boolean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fab38327b7bc8adbedea6107ee772a4670d5cf" translate="yes" xml:space="preserve">
          <source>If the dtype is not numeric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad56bd7d35410bb8c499cb702a271e4c16b2c44e" translate="yes" xml:space="preserve">
          <source>If the entity could not be converted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac307030ed380432cc7d8c7f0c1aee738c5a7f19" translate="yes" xml:space="preserve">
          <source>If the exception is an OpError, the op stack is also included in the message predicate search.</source>
          <target state="translated">Если исключение является OpError,стек опций также включается в поиск предикатов сообщений.</target>
        </trans-unit>
        <trans-unit id="3d22d4ab8d6d8dcc370d2b9e225550b1aaf6aab5" translate="yes" xml:space="preserve">
          <source>If the existing scope already has the given variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcaf8005ea2c08911435025591bcbbf4aad115b1" translate="yes" xml:space="preserve">
          <source>If the file exists, it will be overwritten.</source>
          <target state="translated">Если файл существует,он будет перезаписан.</target>
        </trans-unit>
        <trans-unit id="7dfe25f9b58e72feb123504aceee09af71a08930" translate="yes" xml:space="preserve">
          <source>If the first entry of a shape is &lt;code&gt;...&lt;/code&gt; (type &lt;code&gt;Ellipsis&lt;/code&gt;) or '*' that indicates a variable number of outer dimensions of unspecified size, i.e. the constraint applies to the inner-most dimensions only.</source>
          <target state="translated">Если первая запись фигуры - это &lt;code&gt;...&lt;/code&gt; (тип &lt;code&gt;Ellipsis&lt;/code&gt; ) или '*', что указывает переменное количество внешних размеров неопределенного размера, то есть ограничение применяется только к самым внутренним измерениям.</target>
        </trans-unit>
        <trans-unit id="3897e75c09282eed9bd085faaf64f74b8d961c5c" translate="yes" xml:space="preserve">
          <source>If the function is expressible as TensorFlow ops, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d42c11a5bae209f5c9a583478a2ea75e6c109c" translate="yes" xml:space="preserve">
          <source>If the function returns a false boolean value then the iterator resumes the wait for new checkpoints. At this point the timeout logic applies again.</source>
          <target state="translated">Если функция возвращает ложное логическое значение,то итератор возобновляет ожидание новых контрольно-пропускных пунктов.В этот момент снова применяется логика таймаута.</target>
        </trans-unit>
        <trans-unit id="92539ae5f5eea4cb1a88d428f58d55fcd395ace7" translate="yes" xml:space="preserve">
          <source>If the given TensorArray gradient already exists, returns a reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36167bdd84c2e1b5bd383edebcbb2793bbc3bfe8" translate="yes" xml:space="preserve">
          <source>If the given local job name is not present in the cluster specification, it will be automatically added, using an unused port on the localhost.</source>
          <target state="translated">Если заданное локальное имя задания отсутствует в спецификации кластера,оно будет автоматически добавлено,используя неиспользуемый порт на локальном хосте.</target>
        </trans-unit>
        <trans-unit id="ebfcc47390b8469a3d9d1e9bff51d80dfd3f6b82" translate="yes" xml:space="preserve">
          <source>If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, the value is dropped and will not be added to the sum of the segment.</source>
          <target state="translated">Если данный идентификатор сегмента &lt;code&gt;i&lt;/code&gt; отрицательный, значение отбрасывается и не будет добавлено к сумме сегмента.</target>
        </trans-unit>
        <trans-unit id="51397e8be959c9339c89ea29fb852fcfaf3a6efa" translate="yes" xml:space="preserve">
          <source>If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, then the corresponding value is dropped, and will not be included in the result.</source>
          <target state="translated">Если заданный идентификатор сегмента &lt;code&gt;i&lt;/code&gt; отрицательный, соответствующее значение отбрасывается и не включается в результат.</target>
        </trans-unit>
        <trans-unit id="05fe8b0760cfbd76be7917dd8b4c1ecc11a9be28" translate="yes" xml:space="preserve">
          <source>If the global seed is set but the operation seed is not set, we get different results for every call to the random op, but the same sequence for every re-run of the program:</source>
          <target state="translated">Если задано глобальное семя,но операция не задана,то мы получаем разные результаты для каждого вызова случайной операции,но одну и ту же последовательность для каждого повторного запуска программы:</target>
        </trans-unit>
        <trans-unit id="1cb1ccdb9d0fb5cdc68def8fd22357b5d55b9a41" translate="yes" xml:space="preserve">
          <source>If the global step tensor has a non-integer type, or if it is not a &lt;code&gt;Variable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37adaeda8b3d990b4e6abd16ea3a36a4fae5fd30" translate="yes" xml:space="preserve">
          <source>If the googleapiclient is not installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c722d6a3fdb4516b25d1b44abbde8c28b71d62" translate="yes" xml:space="preserve">
          <source>If the grads_and_vars is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044a241e356a4ce21f0db32daa27e993efe355cd" translate="yes" xml:space="preserve">
          <source>If the grads_and_vars is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975a2d5b2c4bf3df8f3609b1a1d61c4de3349336" translate="yes" xml:space="preserve">
          <source>If the graph contains any numeric operations in a control flow structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba86599b1172a9ff9081ad6d128cd8a8ab922af" translate="yes" xml:space="preserve">
          <source>If the graph-level seed is not set, but the operation seed is set: A default graph-level seed and the specified operation seed are used to determine the random sequence.</source>
          <target state="translated">Если посевной материал на графике не установлен,но установлен рабочий посевной материал:Для определения случайной последовательности по умолчанию используется посевной материал графа и заданный посевной материал операции.</target>
        </trans-unit>
        <trans-unit id="2b1abeab43afe5e63d9f398a048dcc795e5cb2b2" translate="yes" xml:space="preserve">
          <source>If the graph-level seed is set, but the operation seed is not: The system deterministically (determined by the current graph size) picks an operation seed in conjunction with the graph-level seed so that it gets a unique random sequence.</source>
          <target state="translated">Если установлен посевной материал на графике,но не установлен рабочий посевной материал:Система детерминированно (определяется текущим размером графика)выбирает посевной материал операции вместе с посевным материалом графа так,чтобы он получил уникальную случайную последовательность.</target>
        </trans-unit>
        <trans-unit id="2074e1b9dbac3bfaead9cf32a369b30715a5e3a0" translate="yes" xml:space="preserve">
          <source>If the graph-level seed is set, but the operation seed is not: The system deterministically picks an operation seed in conjunction with the graph-level seed so that it gets a unique random sequence. Within the same version of tensorflow and user code, this sequence is deterministic. However across different versions, this sequence might change. If the code depends on particular seeds to work, specify both graph-level and operation-level seeds explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273dd82b098bc3f4a8d0ecbea77a28fe92b0cc88" translate="yes" xml:space="preserve">
          <source>If the id space does not evenly divide the number of partitions, each of the first &lt;code&gt;(max_id + 1) % len(embedding_weights)&lt;/code&gt; partitions will be assigned one more id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d56891a8942eff2e058fb60914ffc8f8e21bff9" translate="yes" xml:space="preserve">
          <source>If the id space does not evenly divide the number of partitions, each of the first &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; partitions will be assigned one more id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b8c3b3a987d5c982d1d7b66e503b4bb62627ad" translate="yes" xml:space="preserve">
          <source>If the indices in &lt;code&gt;key&lt;/code&gt; have an unsupported type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f945cc45b60ebd8654614b2026ef5c9e8db51451" translate="yes" xml:space="preserve">
          <source>If the initial &lt;code&gt;ndims&lt;/code&gt; of &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;indices&lt;/code&gt;, and &lt;code&gt;updates&lt;/code&gt; are not the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9da5b2044d1a6c27127643a17ee6306fc4af59c" translate="yes" xml:space="preserve">
          <source>If the initial value is not specified, or does not have a shape and &lt;code&gt;validate_shape&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2419d82193089ac5125bbee3f22c17cb283853" translate="yes" xml:space="preserve">
          <source>If the initializer cannot create a tensor of the requested dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d4dc856ab835ed492ac9cb4bd626e0cdeb79ec" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;indices&lt;/code&gt; is rank &lt;code&gt;N&lt;/code&gt;, the output will have rank &lt;code&gt;N+1&lt;/code&gt;, The new axis is created at dimension &lt;code&gt;axis&lt;/code&gt; (default: the new axis is appended at the end).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b0de00712b693414eb54609b6c524990f67c51" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;indices&lt;/code&gt; is rank &lt;code&gt;N&lt;/code&gt;, the output will have rank &lt;code&gt;N+1&lt;/code&gt;. The new axis is created at dimension &lt;code&gt;axis&lt;/code&gt; (default: the new axis is appended at the end).</source>
          <target state="translated">Если входные &lt;code&gt;indices&lt;/code&gt; имеют ранг &lt;code&gt;N&lt;/code&gt; , выходные данные будут иметь ранг &lt;code&gt;N+1&lt;/code&gt; . Новая ось создается на &lt;code&gt;axis&lt;/code&gt; размеров (по умолчанию: новая ось добавляется в конце).</target>
        </trans-unit>
        <trans-unit id="17fd4b6f3df9f76ded25e1a15c4bac4ee5a468ba" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;value&lt;/code&gt; is not one of the expected types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc46517b63dc57aa5b1ac644c2f1d4dc634d82fc" translate="yes" xml:space="preserve">
          <source>If the input arguments contain multiple &lt;code&gt;RaggedTensor&lt;/code&gt;s, then they must have identical &lt;code&gt;nested_row_splits&lt;/code&gt;.</source>
          <target state="translated">Если входные аргументы содержат несколько &lt;code&gt;RaggedTensor&lt;/code&gt; , они должны иметь одинаковые &lt;code&gt;nested_row_splits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2a67481586f4794a55075ae0b8d77938a8ca45c" translate="yes" xml:space="preserve">
          <source>If the input comes from a QuantizedRelu6, the output type is quint8 (range of 0-255) but the possible range of QuantizedRelu6 is 0-6. The min_range and max_range values are therefore 0.0 and 6.0. Dequantize on quint8 will take each value, cast to float, and multiply by 6 / 255. Note that if quantizedtype is qint8, the operation will additionally add each value by 128 prior to casting.</source>
          <target state="translated">Если вход поступает от QuantizedRelu6,то тип выхода-quint8 (диапазон 0-255),но возможный диапазон QuantizedRelu6-0-6.Таким образом,значения min_range и max_range равны 0.0 и 6.0.Квантование на quint8 будет принимать каждое значение,отбрасываться в плавающий режим и умножаться на 6/255.Обратите внимание,что если квантифицированный тип равен qint8,то операция дополнительно прибавит каждое значение на 128 до литья.</target>
        </trans-unit>
        <trans-unit id="6426b4bfc81de4b1c9b426a44f2ae50a814240f6" translate="yes" xml:space="preserve">
          <source>If the input datatype &lt;code&gt;T&lt;/code&gt; is larger than the output datatype &lt;code&gt;type&lt;/code&gt; then the shape changes from [...] to [..., sizeof(&lt;code&gt;T&lt;/code&gt;)/sizeof(&lt;code&gt;type&lt;/code&gt;)].</source>
          <target state="translated">Если входной тип данных &lt;code&gt;T&lt;/code&gt; больше , чем выходной тип данных &lt;code&gt;type&lt;/code&gt; , то форма изменяется от [...] до [..., SizeOf ( &lt;code&gt;T&lt;/code&gt; ) / SizeOf ( &lt;code&gt;type&lt;/code&gt; )].</target>
        </trans-unit>
        <trans-unit id="ad23e3edc7d3493eaa2fe45269414dec76430c00" translate="yes" xml:space="preserve">
          <source>If the input height/width is even and the target height/width is odd (or inversely), the input image is left-padded by 1 pixel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4571fc930ec815d2a6c8980432dbfead6d756c" translate="yes" xml:space="preserve">
          <source>If the input ids are ragged tensors, partition variables are not supported and the partition strategy and the max_norm are ignored. The results of the lookup are concatenated into a dense tensor. The returned tensor has shape &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt;.</source>
          <target state="translated">Если входные идентификаторы представляют собой рваные тензоры, переменные разделения не поддерживаются, а стратегия разделения и max_norm игнорируются. Результаты поиска объединяются в плотный тензор. Возвращенный тензор имеет форму &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35273ad2487bd080e83fb5c9ed1a4b3f1830c00d" translate="yes" xml:space="preserve">
          <source>If the input is a vector (rank-1), finds the &lt;code&gt;k&lt;/code&gt; largest entries in the vector and outputs their values and indices as vectors. Thus &lt;code&gt;values[j]&lt;/code&gt; is the &lt;code&gt;j&lt;/code&gt;-th largest entry in &lt;code&gt;input&lt;/code&gt;, and its index is &lt;code&gt;indices[j]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd823ef3819942e402b7fb91e3ba05b9a1b32f9" translate="yes" xml:space="preserve">
          <source>If the input is a vector (rank-1), finds the entries which is the nth-smallest value in the vector and outputs their values as scalar tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2000d65cb54af404f075a90dd29fef64452cdfe9" translate="yes" xml:space="preserve">
          <source>If the input is a vector (rank=1), finds the &lt;code&gt;k&lt;/code&gt; largest entries in the vector and outputs their values and indices as vectors. Thus &lt;code&gt;values[j]&lt;/code&gt; is the &lt;code&gt;j&lt;/code&gt;-th largest entry in &lt;code&gt;input&lt;/code&gt;, and its index is &lt;code&gt;indices[j]&lt;/code&gt;.</source>
          <target state="translated">Если вход является вектором (ранг = 1), находит &lt;code&gt;k&lt;/code&gt; самых больших элементов вектора и выводит их значения и индексы в виде векторов. Таким образом, &lt;code&gt;values[j]&lt;/code&gt; - это &lt;code&gt;j&lt;/code&gt; -я по величине запись во &lt;code&gt;input&lt;/code&gt; , а ее индекс - index &lt;code&gt;indices[j]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25639d61413f3474f585047a2bb63baa71a0472f" translate="yes" xml:space="preserve">
          <source>If the input is prefixed by a Byte Order Mark needed to determine encoding (e.g. if the encoding is UTF-16 and the BOM indicates big-endian), then that BOM will be consumed and not emitted into the output. If the input encoding is marked with an explicit endianness (e.g. UTF-16-BE), then the BOM is interpreted as a non-breaking-space and is preserved in the output (including always for UTF-8).</source>
          <target state="translated">Если вход префиксом является знак байтового порядка,необходимый для определения кодировки (например,если кодировка UTF-16 и BOM обозначает big-endian),то эта спецификация будет потребляться,а не излучаться в выходной сигнал.Если входная кодировка помечена с явной эндианностью (например,UTF-16-BE),то BOM интерпретируется как неразрывное пространство и сохраняется в выводе (в том числе всегда для UTF-8).</target>
        </trans-unit>
        <trans-unit id="1c4e8d7712b75c855eb7c3cf4d70a0943cb24389" translate="yes" xml:space="preserve">
          <source>If the input pipeline is shared between training and validation, restoring the checkpoint during validation may override the validation input pipeline.</source>
          <target state="translated">Если входной трубопровод разделяется между обучением и проверкой,то восстановление контрольно-пропускного пункта во время проверки может перекрыть проверку входного трубопровода.</target>
        </trans-unit>
        <trans-unit id="72b72274c82e5eac3f5bdc28763a89bcac429b41" translate="yes" xml:space="preserve">
          <source>If the input signature cannot be inferred from the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1251694f974cc1b4075b791d370851197bfaaf" translate="yes" xml:space="preserve">
          <source>If the input tensor has rank &lt;code&gt;R_in&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; non-empty values, and &lt;code&gt;new_shape&lt;/code&gt; has length &lt;code&gt;R_out&lt;/code&gt;, then &lt;code&gt;input_indices&lt;/code&gt; has shape &lt;code&gt;[N, R_in]&lt;/code&gt;, &lt;code&gt;input_shape&lt;/code&gt; has length &lt;code&gt;R_in&lt;/code&gt;, &lt;code&gt;output_indices&lt;/code&gt; has shape &lt;code&gt;[N, R_out]&lt;/code&gt;, and &lt;code&gt;output_shape&lt;/code&gt; has length &lt;code&gt;R_out&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de105d3b1e2a42d85103cbee9a5ac005bccac197" translate="yes" xml:space="preserve">
          <source>If the input values are all positive, they are rescaled so the largest one is 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ad8b47d990bec6ccbeeba5c4178e748476355f" translate="yes" xml:space="preserve">
          <source>If the inputs are complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f925aa60776a7244d7085eecc014f09b4f812e92" translate="yes" xml:space="preserve">
          <source>If the interpreter could not resize the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad9551aaf11bca3406af0087bc0fe5a5694ca06" translate="yes" xml:space="preserve">
          <source>If the interpreter could not set the tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4087490d7b8bf7d3b2fedba5ad1da327138905e" translate="yes" xml:space="preserve">
          <source>If the interpreter was unable to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20c962df688017d296d76cbc25fc4a6e797657b" translate="yes" xml:space="preserve">
          <source>If the iterator has reached the end of the sequence, the returned &lt;a href=&quot;../../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; will have no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d05f1367e6298a309c7cc96ff6c0839630b43b4" translate="yes" xml:space="preserve">
          <source>If the iterator has reached the end of the sequence, the returned &lt;a href=&quot;../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; will have no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ca643cb2629c831ff2614bca40312edb51c292" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;begin_mask&lt;/code&gt; is set, &lt;code&gt;begin[i]&lt;/code&gt; is ignored and the fullest possible range in that dimension is used instead. &lt;code&gt;end_mask&lt;/code&gt; works analogously, except with the end range.</source>
          <target state="translated">Если установлен i-й бит &lt;code&gt;begin_mask&lt;/code&gt; , &lt;code&gt;begin[i]&lt;/code&gt; игнорируется и вместо этого используется максимально полный возможный диапазон в этом измерении. &lt;code&gt;end_mask&lt;/code&gt; работает аналогично, за исключением конечного диапазона.</target>
        </trans-unit>
        <trans-unit id="53b6f32d8b994e08e60c897ec2633fae0ba3393e" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;ellipsis_mask&lt;/code&gt; is set, as many unspecified dimensions as needed will be inserted between other dimensions. Only one non-zero bit is allowed in &lt;code&gt;ellipsis_mask&lt;/code&gt;.</source>
          <target state="translated">Если установлен i-й бит &lt;code&gt;ellipsis_mask&lt;/code&gt; , столько неопределенных измерений, сколько необходимо, будет вставлено между другими измерениями. Только один ненулевой бит допускается в &lt;code&gt;ellipsis_mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14e0da661bbe2e071831b21ea708a674b65e3553" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;new_axis_mask&lt;/code&gt; is set, then &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;stride&lt;/code&gt; are ignored and a new length 1 dimension is added at this point in the output tensor.</source>
          <target state="translated">Если установлен i-й бит &lt;code&gt;new_axis_mask&lt;/code&gt; , то &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; и &lt;code&gt;stride&lt;/code&gt; игнорируются, и в этой точке выходного тензора добавляется новое измерение длины 1.</target>
        </trans-unit>
        <trans-unit id="ea9295a32ee3d172d0de2b9a21ab6620d9c7aaa3" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;shrink_axis_mask&lt;/code&gt; is set, it implies that the ith specification shrinks the dimensionality by 1, taking on the value at index &lt;code&gt;begin[i]&lt;/code&gt;. &lt;code&gt;end[i]&lt;/code&gt; and &lt;code&gt;strides[i]&lt;/code&gt; are ignored in this case. For example in Python one might do &lt;code&gt;foo[:, 3, :]&lt;/code&gt; which would result in &lt;code&gt;shrink_axis_mask&lt;/code&gt; equal to 2.</source>
          <target state="translated">Если установлен i-й бит &lt;code&gt;shrink_axis_mask&lt;/code&gt; , это означает, что i-я спецификация уменьшает размерность на 1, принимая значение в индексе &lt;code&gt;begin[i]&lt;/code&gt; . &lt;code&gt;end[i]&lt;/code&gt; и &lt;code&gt;strides[i]&lt;/code&gt; в этом случае игнорируются. Например, в Python можно сделать &lt;code&gt;foo[:, 3, :]&lt;/code&gt; &lt;code&gt;shrink_axis_mask&lt;/code&gt; ], что приведет к shrink_axis_mask, равному 2.</target>
        </trans-unit>
        <trans-unit id="ec51310fe28dab35d237c5de7a060e05f980a65d" translate="yes" xml:space="preserve">
          <source>If the keras_model_path is a GCS URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acffbcc3c0cad783d61073d1795d38ade292db7" translate="yes" xml:space="preserve">
          <source>If the key is a &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;, the value should be a &lt;a href=&quot;sparsetensorvalue&quot;&gt;&lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если ключом является &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt; , значение должно быть &lt;a href=&quot;sparsetensorvalue&quot;&gt; &lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="069b207c0f431f445482fbf976b09b4c58fbe160" translate="yes" xml:space="preserve">
          <source>If the key is a &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;, the value should be a &lt;a href=&quot;sparsetensorvalue&quot;&gt;&lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adb28fdab6cc893d9c3156f443e8c35c99d1ae8" translate="yes" xml:space="preserve">
          <source>If the key is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, the value may be a Python scalar, string, list, or numpy ndarray that can be converted to the same &lt;code&gt;dtype&lt;/code&gt; as that tensor. Additionally, if the key is a &lt;a href=&quot;placeholder&quot;&gt;&lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt;&lt;/a&gt;, the shape of the value will be checked for compatibility with the placeholder.</source>
          <target state="translated">Если ключом является &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; , значение может быть скаляром Python, строкой, списком или numpy ndarray, которые могут быть преобразованы в тот же &lt;code&gt;dtype&lt;/code&gt; , что и этот тензор. Кроме того, если ключ является &lt;a href=&quot;placeholder&quot;&gt; &lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt; &lt;/a&gt; , форма значения будет проверена на совместимость с заполнителем.</target>
        </trans-unit>
        <trans-unit id="1d4c6296ff5f1ed16700becf51c667373e1f81ef" translate="yes" xml:space="preserve">
          <source>If the key is a nested tuple of &lt;code&gt;Tensor&lt;/code&gt;s or &lt;code&gt;SparseTensor&lt;/code&gt;s, the value should be a nested tuple with the same structure that maps to their corresponding values as above.</source>
          <target state="translated">Если ключ является вложенным кортежем &lt;code&gt;Tensor&lt;/code&gt; s или &lt;code&gt;SparseTensor&lt;/code&gt; s, значение должно быть вложенным кортежем с той же структурой, которая сопоставляется с их соответствующими значениями, как указано выше.</target>
        </trans-unit>
        <trans-unit id="c0ed05e65efc99254033bbf6b2b8901e04b16293" translate="yes" xml:space="preserve">
          <source>If the last dimension is empty, we follow the convention that the sum over the empty set is zero, and the product is one.</source>
          <target state="translated">Если последнее измерение пустое,то мы следуем условию,что сумма над пустым множеством равна нулю,а товар-единице.</target>
        </trans-unit>
        <trans-unit id="63f876d8411766c17a710087a716357c2f545e8f" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;sorted_sequence &amp;gt;= 2^31-1&lt;/code&gt; elements. If the total size of values exceeds &lt;code&gt;2^31 - 1&lt;/code&gt; elements. If the first &lt;code&gt;N-1&lt;/code&gt; dimensions of the two tensors don't match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99de0b684ff53cc972b2e916eef8dd972d4a9ba5" translate="yes" xml:space="preserve">
          <source>If the layer has not been built, this method will call &lt;code&gt;build&lt;/code&gt; on the layer. This assumes that the layer will later be used with inputs that match the input shape provided here.</source>
          <target state="translated">Если слой не был построен, этот метод вызовет &lt;code&gt;build&lt;/code&gt; на уровне. Это предполагает, что слой позже будет использоваться с входными данными, соответствующими указанной здесь форме ввода.</target>
        </trans-unit>
        <trans-unit id="0c93baadf61368eb61a32573a61ace4b23530d53" translate="yes" xml:space="preserve">
          <source>If the layer's &lt;code&gt;call&lt;/code&gt; method takes a &lt;code&gt;mask&lt;/code&gt; argument (as some Keras layers do), its default value will be set to the mask generated for &lt;code&gt;inputs&lt;/code&gt; by the previous layer (if &lt;code&gt;input&lt;/code&gt; did come from a layer that generated a corresponding mask, i.e. if it came from a Keras layer with masking support.</source>
          <target state="translated">Если метод &lt;code&gt;call&lt;/code&gt; слоя принимает аргумент &lt;code&gt;mask&lt;/code&gt; (как это делают некоторые слои Keras), его значение по умолчанию будет установлено на маску, сгенерированную для &lt;code&gt;inputs&lt;/code&gt; предыдущим слоем (если &lt;code&gt;input&lt;/code&gt; действительно поступил из слоя, который сгенерировал соответствующую маску, т. Е. Если он происходит из слоя Keras с поддержкой маскировки.</target>
        </trans-unit>
        <trans-unit id="9914ccb05442f0fd9eeac8901bc8d04826b15b98" translate="yes" xml:space="preserve">
          <source>If the max is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">Если максимальное значение пусто для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96d2c8a21f840629380501d04af2dc4fe3e1ab06" translate="yes" xml:space="preserve">
          <source>If the maximum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs the smallest possible value for the specific numeric type, &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::lowest()&lt;/code&gt;.</source>
          <target state="translated">Если максимум пуст для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; , он выводит наименьшее возможное значение для определенного числового типа, &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::lowest()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b06b3bf831b0d35a3637fb432a42854a21f98016" translate="yes" xml:space="preserve">
          <source>If the mean is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">Если среднее значение пусто для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1140e9402fba81b2c59500e980fdae7cc9b73760" translate="yes" xml:space="preserve">
          <source>If the min is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">Если min пусто для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00f33d9bbb883644d8d348d1d1e555c9c61673c2" translate="yes" xml:space="preserve">
          <source>If the minimum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs the largest possible value for the specific numeric type, &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">Если минимум пуст для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; , он выводит максимально возможное значение для определенного числового типа, &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::max()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb66ec88de963b30ef4f8246ae8014a7fd55e5c4" translate="yes" xml:space="preserve">
          <source>If the mode is 'MIN_FIRST', then this approach is used:</source>
          <target state="translated">Если режим 'MIN_FIRST',то используется этот подход:</target>
        </trans-unit>
        <trans-unit id="7ef024d8d4793bf018279248fd541d506ae2395b" translate="yes" xml:space="preserve">
          <source>If the mode is &lt;code&gt;SCALED&lt;/code&gt;, dequantization is performed by multiplying each input value by a scaling_factor. (Thus an input of 0 always maps to 0.0).</source>
          <target state="translated">Если режим &lt;code&gt;SCALED&lt;/code&gt; , деквантование выполняется путем умножения каждого входного значения на scaling_factor. (Таким образом, вход 0 всегда соответствует 0,0).</target>
        </trans-unit>
        <trans-unit id="db1124a69fc0391f15200d7a79013fb471df1704" translate="yes" xml:space="preserve">
          <source>If the mode is &lt;code&gt;SCALED&lt;/code&gt;, the quantization is performed by multiplying each input value by a scaling_factor. The scaling_factor is determined from &lt;code&gt;min_range&lt;/code&gt; and &lt;code&gt;max_range&lt;/code&gt; to be as large as possible such that the range from &lt;code&gt;min_range&lt;/code&gt; to &lt;code&gt;max_range&lt;/code&gt; is representable within values of type T.</source>
          <target state="translated">Если режим &lt;code&gt;SCALED&lt;/code&gt; , квантование выполняется путем умножения каждого входного значения на scaling_factor. &lt;code&gt;min_range&lt;/code&gt; определяется из min_range и &lt;code&gt;max_range&lt;/code&gt; как можно больше, чтобы диапазон от &lt;code&gt;min_range&lt;/code&gt; до &lt;code&gt;max_range&lt;/code&gt; представлялся в пределах значений типа T.</target>
        </trans-unit>
        <trans-unit id="6383b459b0c33d463602987492ae422c09b13402" translate="yes" xml:space="preserve">
          <source>If the model cannot be initialized or recovered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c659fe038e40df626c10048932fee8c629877e2" translate="yes" xml:space="preserve">
          <source>If the model cannot be recovered successfully then it is initialized by running the &lt;code&gt;init_op&lt;/code&gt; and calling &lt;code&gt;init_fn&lt;/code&gt; if they are provided. The &lt;code&gt;local_init_op&lt;/code&gt; is also run after init_op and init_fn, regardless of whether the model was recovered successfully, but only if &lt;code&gt;ready_for_local_init_op&lt;/code&gt; passes.</source>
          <target state="translated">Если модель не может быть успешно восстановлена, она инициализируется путем запуска &lt;code&gt;init_op&lt;/code&gt; и вызова &lt;code&gt;init_fn&lt;/code&gt; , если они предоставлены. &lt;code&gt;local_init_op&lt;/code&gt; также запускается после init_op и init_fn, независимо от того, был ли выздоровел модель успешно, но только если &lt;code&gt;ready_for_local_init_op&lt;/code&gt; проходит.</target>
        </trans-unit>
        <trans-unit id="42710bc33bad38e07caf615faa21fedd716ffc30" translate="yes" xml:space="preserve">
          <source>If the model is a subclassed model, and serving_only is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e493d4d88dd6364973cb16adddea7f1d7c9e11b9" translate="yes" xml:space="preserve">
          <source>If the model is recovered from a checkpoint it is assumed that all global variables have been initialized, in particular neither &lt;code&gt;init_op&lt;/code&gt; nor &lt;code&gt;init_fn&lt;/code&gt; will be executed.</source>
          <target state="translated">Если модель восстанавливается из контрольной точки, предполагается, что все глобальные переменные были инициализированы, в частности, ни &lt;code&gt;init_op&lt;/code&gt; , ни &lt;code&gt;init_fn&lt;/code&gt; не будут выполнены.</target>
        </trans-unit>
        <trans-unit id="4d6f1b8c16d5b51d1c9ded9f1446f976cc11e129" translate="yes" xml:space="preserve">
          <source>If the model was never compiled or,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f9d9bb5e085ae4acbe52e70dd3531828c8a5fc" translate="yes" xml:space="preserve">
          <source>If the number of dimensions in &lt;code&gt;st_input&lt;/code&gt; is not known statically, or is not two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3c99a79852c902d9b814a851d58f44663386e0" translate="yes" xml:space="preserve">
          <source>If the number of inputs per replica does not match the number of formal parameters to &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa742d76ae217bc9948872afe6ac45118d433ee3" translate="yes" xml:space="preserve">
          <source>If the op is not an &lt;code&gt;Operation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012fe8f2af0ac138febd5985745621393340a0d8" translate="yes" xml:space="preserve">
          <source>If the operation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6ec351ebdb083f3d17d8e986dd67bae3d01101" translate="yes" xml:space="preserve">
          <source>If the operation seed is not set but the global seed is set: The system picks an operation seed from a stream of seeds determined by the global seed.</source>
          <target state="translated">Если рабочий посевной материал не настраивается,но настраивается общий посевной материал:Система выбирает рабочий посевной материал из потока семян,определенного глобальным посевным материалом.</target>
        </trans-unit>
        <trans-unit id="150c78cb9921ff6cbc2920415e1cb51a5f161b3f" translate="yes" xml:space="preserve">
          <source>If the operation seed is set, but the global seed is not set: A default global seed and the specified operation seed are used to determine the random sequence.</source>
          <target state="translated">Если рабочий посевной материал установлен,но общий посевной материал не установлен:Глобальный посевной материал по умолчанию и указанный посевной материал операции используются для определения случайной последовательности.</target>
        </trans-unit>
        <trans-unit id="61786c3241da39066c5d1cad1bbd7d232ac2fec8" translate="yes" xml:space="preserve">
          <source>If the operation seed is set, we get different results for every call to the random op, but the same sequence for every re-run of the program:</source>
          <target state="translated">Если задана посевная операция,то мы получаем разные результаты для каждого вызова случайной операции,но одну и ту же последовательность для каждого повторного запуска программы:</target>
        </trans-unit>
        <trans-unit id="c7c4d1aa2a7f3d9f64a5d7440278a03c364673f0" translate="yes" xml:space="preserve">
          <source>If the operator is marked as self-adjoint (via &lt;code&gt;is_self_adjoint&lt;/code&gt;) this computation can be more efficient.</source>
          <target state="translated">Если оператор помечен как самосопряженный (через &lt;code&gt;is_self_adjoint&lt;/code&gt; ), это вычисление может быть более эффективным.</target>
        </trans-unit>
        <trans-unit id="62e7cf664c32974cdff913c7188633271cc1c617" translate="yes" xml:space="preserve">
          <source>If the operator is square, this is also the sum of the eigenvalues.</source>
          <target state="translated">Если оператор является квадратным,то это также сумма собственных значений.</target>
        </trans-unit>
        <trans-unit id="7cfb48973a04dbb9b6d9a3a87eb33a91ec4619ce" translate="yes" xml:space="preserve">
          <source>If the output type was qint8 ([-128, 127]), the operation will additionally subtract each value by 128 prior to casting, so that the range of values aligns with the range of qint8.</source>
          <target state="translated">Если тип вывода был qint8 ([-128,127]),то операция до литья дополнительно вычитает каждое значение на 128,так что диапазон значений выравнивается с диапазоном qint8.</target>
        </trans-unit>
        <trans-unit id="4dff92bc587fce4bff2b2db8dd6919485f299911" translate="yes" xml:space="preserve">
          <source>If the partitioner hits the &lt;code&gt;max_shards&lt;/code&gt; limit, then each shard may end up larger than &lt;code&gt;max_shard_bytes&lt;/code&gt;. By default &lt;code&gt;max_shards&lt;/code&gt; equals &lt;code&gt;None&lt;/code&gt; and no limit on the number of shards is enforced.</source>
          <target state="translated">Если разделитель &lt;code&gt;max_shards&lt;/code&gt; предела max_shards , то каждый сегмент может оказаться больше &lt;code&gt;max_shard_bytes&lt;/code&gt; . По умолчанию &lt;code&gt;max_shards&lt;/code&gt; равно &lt;code&gt;None&lt;/code&gt; , и ограничение на количество шардов не применяется.</target>
        </trans-unit>
        <trans-unit id="a942f30d3b77fdc54336a28fc3dfef09ecbb6824" translate="yes" xml:space="preserve">
          <source>If the path is not found, or the resource can't be opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a2a3fd0faa56bc31e1b5e49c1d047a10c2ec07" translate="yes" xml:space="preserve">
          <source>If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [20, 16] for fractional max pooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38bf0235baac14c6561ea9c91b1aa0b7e9bc6ea" translate="yes" xml:space="preserve">
          <source>If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [41/3, 26/3] for fractional avg pooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1885aec51a609f73968bad4dfc16b73c835fa1e" translate="yes" xml:space="preserve">
          <source>If the product is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 1&lt;/code&gt;.</source>
          <target state="translated">Если продукт для данного идентификатора сегмента &lt;code&gt;i&lt;/code&gt; пуст , &lt;code&gt;output[i] = 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14b06ad55e535b3bc2a49abca7c87697d17d429c" translate="yes" xml:space="preserve">
          <source>If the program crashes and is restarted, the managed session automatically reinitialize variables from the most recent checkpoint.</source>
          <target state="translated">В случае сбоя и перезапуска программы управляемая сессия автоматически переинициализирует переменные с последней контрольной точки.</target>
        </trans-unit>
        <trans-unit id="d33c70c7d1ae55398bb222a1899dc0ece170d6c0" translate="yes" xml:space="preserve">
          <source>If the provided TPU is not healthy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0821c52d17cc27d0dcda253ed0746d3cde7110" translate="yes" xml:space="preserve">
          <source>If the provided tag was already used for this type of event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3975f76c6a1a580f5974df80a91da72b3d715f48" translate="yes" xml:space="preserve">
          <source>If the provided weights list does not match the layer's specifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a357164b0c5580a5330506915d75a024dc5cd8a" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are fewer than &lt;code&gt;n&lt;/code&gt; elements, then an OutOfRange error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec15897d06f9071c5e97fa6f104995494c3c020" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are less than &lt;code&gt;n&lt;/code&gt; elements left, then an &lt;code&gt;OutOfRange&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если очередь закрыта и осталось меньше &lt;code&gt;n&lt;/code&gt; элементов, &lt;code&gt;OutOfRange&lt;/code&gt; исключение OutOfRange .</target>
        </trans-unit>
        <trans-unit id="e6d8db12ae869e217b426b4397efdcf921300b07" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are more than 0 but less than &lt;code&gt;n&lt;/code&gt; elements remaining, then instead of returning an OutOfRange error like QueueDequeueMany, less than &lt;code&gt;n&lt;/code&gt; elements are returned immediately. If the queue is closed and there are 0 elements left in the queue, then an OutOfRange error is returned just like in QueueDequeueMany. Otherwise the behavior is identical to QueueDequeueMany:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2909c49e7094efd16c1e6b533233682195cdca40" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are more than &lt;code&gt;0&lt;/code&gt; but fewer than &lt;code&gt;n&lt;/code&gt; elements remaining, then instead of raising a &lt;a href=&quot;../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; like &lt;code&gt;tf.QueueBase.dequeue_many&lt;/code&gt;, less than &lt;code&gt;n&lt;/code&gt; elements are returned immediately. If the queue is closed and there are &lt;code&gt;0&lt;/code&gt; elements left in the queue, then a &lt;a href=&quot;../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; is raised just like in &lt;code&gt;dequeue_many&lt;/code&gt;. Otherwise the behavior is identical to &lt;code&gt;dequeue_many&lt;/code&gt;.</source>
          <target state="translated">Если очередь закрыта и осталось больше &lt;code&gt;0&lt;/code&gt; , но меньше &lt;code&gt;n&lt;/code&gt; элементов, то вместо того, чтобы &lt;a href=&quot;../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt; &lt;code&gt;tf.QueueBase.dequeue_many&lt;/code&gt; , как tf.QueueBase.dequeue_many , немедленно возвращается меньше &lt;code&gt;n&lt;/code&gt; элементов. Если очередь закрыта и в ней осталось &lt;code&gt;0&lt;/code&gt; элементов, возникает &lt;a href=&quot;../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt; как и в &lt;code&gt;dequeue_many&lt;/code&gt; . В остальном поведение идентично &lt;code&gt;dequeue_many&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbed72aba5ba28d95f2d72fff5e20ff3a4222092" translate="yes" xml:space="preserve">
          <source>If the queue is empty when this operation executes, it will block until there is an element to dequeue.</source>
          <target state="translated">Если при выполнении этой операции очередь пуста,то она будет блокироваться до тех пор,пока не появится элемент,который нужно будет удалить.</target>
        </trans-unit>
        <trans-unit id="90be429384e7a1cfa4ccd2802a141dfd6052e934" translate="yes" xml:space="preserve">
          <source>If the queue is full when this operation executes, it will block until all of the elements have been enqueued.</source>
          <target state="translated">Если при выполнении этой операции очередь будет заполнена,то она будет блокироваться до тех пор,пока не будут выбраны все элементы.</target>
        </trans-unit>
        <trans-unit id="eabf4447a0d7c1faf56f579f18de2be7b3ff884c" translate="yes" xml:space="preserve">
          <source>If the queue is full when this operation executes, it will block until the element has been enqueued.</source>
          <target state="translated">Если при выполнении этой операции очередь заполнена,то она будет блокироваться до тех пор,пока элемент не будет выбран.</target>
        </trans-unit>
        <trans-unit id="55a8dc3be231a05be089bfed8d162468d9d0ecca" translate="yes" xml:space="preserve">
          <source>If the result is midway between two representable values, the even representable is chosen. For example:</source>
          <target state="translated">Если результат находится посередине между двумя представляемыми значениями,выбирается четное представление.Например:</target>
        </trans-unit>
        <trans-unit id="40ce55e23a050e14a92b2bf375cac16edef873d6" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;RaggedTensor&lt;/code&gt;, then use a &lt;a href=&quot;../../raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b62832016e2c0ed4032fbaf21eee5f5a78f0a04" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;RaggedTensor&lt;/code&gt;, then use a &lt;a href=&quot;raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59689227b3cca92043b54ed174b643ad8bc510ae" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;SparseTensor&lt;/code&gt;, then use a &lt;a href=&quot;../../sparsetensorspec&quot;&gt;&lt;code&gt;tf.SparseTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;. The individual &lt;code&gt;SparseTensor&lt;/code&gt;s returned by &lt;code&gt;fn&lt;/code&gt; will be stacked into a single &lt;code&gt;SparseTensor&lt;/code&gt; with one more dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8cf573a4e8bfa0d4b2566b9b0bc2c82137a852" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;SparseTensor&lt;/code&gt;, then use a &lt;a href=&quot;sparsetensorspec&quot;&gt;&lt;code&gt;tf.SparseTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;. The individual &lt;code&gt;SparseTensor&lt;/code&gt;s returned by &lt;code&gt;fn&lt;/code&gt; will be stacked into a single &lt;code&gt;SparseTensor&lt;/code&gt; with one more dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7235f6b7d8d91626523bb002062bf9af9f3e79" translate="yes" xml:space="preserve">
          <source>If the same tensor or variable is specified multiple times in &lt;code&gt;primals&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300ebf80fc956f29ae859b8d3c6560c81957725b" translate="yes" xml:space="preserve">
          <source>If the saved model file does not exist, or cannot be successfully parsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344be155e24f53b90446aa0dd405ae181b247cdf" translate="yes" xml:space="preserve">
          <source>If the scalar values in &lt;code&gt;pylist&lt;/code&gt; have inconsistent nesting depth; or if ragged_rank or inner_shape are incompatible with &lt;code&gt;pylist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fe61fb730912ad313c279c46346170b788594e" translate="yes" xml:space="preserve">
          <source>If the scope name already exists, the name will be made unique by appending &lt;code&gt;_n&lt;/code&gt;. For example, calling &lt;code&gt;my_op&lt;/code&gt; the second time will generate &lt;code&gt;MyOp_1/a&lt;/code&gt;, etc.</source>
          <target state="translated">Если имя области уже существует, имя будет уникальным путем добавления &lt;code&gt;_n&lt;/code&gt; . Например, второй вызов &lt;code&gt;my_op&lt;/code&gt; сгенерирует &lt;code&gt;MyOp_1/a&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="108c455c6020e7fdfe033c5720678463a8369595" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;image&lt;/code&gt; is incompatible with the &lt;code&gt;offset_*&lt;/code&gt; or &lt;code&gt;target_*&lt;/code&gt; arguments, or either &lt;code&gt;offset_height&lt;/code&gt; or &lt;code&gt;offset_width&lt;/code&gt; is negative, or either &lt;code&gt;target_height&lt;/code&gt; or &lt;code&gt;target_width&lt;/code&gt; is not positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2204e01ba6ff9a32e0d7fcf9a1b417b5a5274710" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;image&lt;/code&gt; is incompatible with the &lt;code&gt;offset_*&lt;/code&gt; or &lt;code&gt;target_*&lt;/code&gt; arguments, or either &lt;code&gt;offset_height&lt;/code&gt; or &lt;code&gt;offset_width&lt;/code&gt; is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37af20a631a4a1fcb4791bfe44a71bac00f8303e" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;logits&lt;/code&gt; doesn't match that of &lt;code&gt;multi_class_labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid, or if &lt;code&gt;weights&lt;/code&gt; is None. Also if &lt;code&gt;multi_class_labels&lt;/code&gt; or &lt;code&gt;logits&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88047769983b00d370c7aa8a73273e36c97d3bd7" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;logits&lt;/code&gt; doesn't match that of &lt;code&gt;onehot_labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid or if &lt;code&gt;weights&lt;/code&gt; is None. Also if &lt;code&gt;onehot_labels&lt;/code&gt; or &lt;code&gt;logits&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b08ab83a17beb9a37d9f3f65ec8143060cd7263" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;predictions&lt;/code&gt; doesn't match that of &lt;code&gt;labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid or if &lt;code&gt;labels&lt;/code&gt; or &lt;code&gt;predictions&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7553b5398dd554109ba0a10bde0fcd1930ed049" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;predictions&lt;/code&gt; doesn't match that of &lt;code&gt;labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid. Also if &lt;code&gt;labels&lt;/code&gt; or &lt;code&gt;predictions&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe4384c06dff4646d7a21614fb5b0db31008230" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;sample_weight&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd25b920cd34ef33927a979c45194f34614408b" translate="yes" xml:space="preserve">
          <source>If the shape of the input cannot be inferred from the arguments.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
